See
discussions
stats
and
author
profiles
for
this
publication
at
https://www.researchgate.net/publication/349928725
ARQUITECTURA
COMPUTADORAS
9Âº
EdiciÃ³n
2021
Book
March
2021
CITATIONS
READS
111
authors
Some
of
the
authors
of
this
publication
are
also
working
on
these
related
projects
PROSEMEV
Proyecto
Seguimiento
Mejora
EducaciÃ³n
Virtualidad
View
project
ANÃLISIS
COMPARATIVO
PRESTACIONES
TRÃFICO
VIDEO
MULTICAST
REDES
HETEROGÃ‰NEAS
View
project
Santiago
Cristobal
PÃ©rez
National
University
of
Technology
Mendoza
Argentina
109
PUBLICATIONS
96
CITATIONS
SEE
PROFILE
Higinio
Alberto
Facchini
National
University
of
Technology
72
PUBLICATIONS
70
CITATIONS
SEE
PROFILE
Daniel
ArgÃ¼ello
National
University
of
Technology
MENDOZA
ARGENTINA
11
PUBLICATIONS
CITATION
SEE
PROFILE
All
content
following
this
page
was
uploaded
by
Santiago
Cristobal
PÃ©rez
on
09
March
2021
The
user
has
requested
enhancement
of
the
downloaded
file
ARQUITECTURA
COMPUTADORAS
Universidad
TecnolÃ³gica
Nacional
Facultad
Regional
Mendoza
CÃ¡tedra
Arquitectura
Computadoras
Carrera
IngenierÃ­a
Sistemas
InformaciÃ³n
ARQUITECTURA
COMPUTADORAS
Daniel
M.
ArgÃ¼ello
Santiago
C.
PÃ©rez
Higinio
A.
Facchini
Mendoza
Argentina
2021
Arquitectura
Computadoras
Daniel
M.
ArgÃ¼ello
Santiago
C.
PÃ©rez
Higinio
A.
Facchini
DiseÃ±o
Tapa
Renzo
Guido
Facchini
DiseÃ±o
Interior
Renzo
Guido
Facchini
CorrecciÃ³n
Estilo
Renzo
Guido
Facchini
E-book
EdiciÃ³n
ISBN
978-950-42-0158-8
Rodriguez
273
5500
Mendoza
RepÃºblica
Argentina
viento
favorable
barco
adÃ³nde
Lucio
Anneo
SÃ©neca
a.
C.
65
d.
C.
imaginaciÃ³n
importante
conocimiento
conocimiento
limitado
imaginaciÃ³n
Albert
Einstein
1879
1955
CapÃ­tulo
RepresentaciÃ³n
NumÃ©rica
CapÃ­tulo
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
CapÃ­tulo
Algebra
Boole
CapÃ­tulo
Sistemas
Combinacionales
CapÃ­tulo
Sistemas
Secuenciales
CapÃ­tulo
Memorias
ElectrÃ³nicas
CapÃ­tulo
Arquitectura
BÃ¡sica
Computadora
CapÃ­tulo
Arquitectura
Convencional
CapÃ­tulo
Arquitectura
Avanzada
CapÃ­tulo
10
Entradas
Salidas
PRÃ“LOGO
libro
objetivo
reunir
obra
experiencia
docente
profesional
autores
temÃ¡ticas
TÃ©cnicas
Digitales
Arquitecturas
Computadoras
generar
material
integra
adecua
tÃ³picos
dispersos
diversa
profundidad
perspectiva
bibliografÃ­as
grado
universitarios
libro
presenta
CapÃ­tulos
contenidos
Sistemas
NumeraciÃ³n
CÃ³digos
Ãlgebra
Boole
tÃ­picos
base
conocimiento
discuten
temas
especÃ­ficos
referidos
Sistemas
ElectrÃ³nicos
Digitales
tipo
Combinacional
Secuencial
espe
cÃ­ficamente
Memorias
ElectrÃ³nicas
continuaciÃ³n
plantea
Arquitectura
BÃ¡sica
Computadora
usando
mÃ¡quina
elemental
didÃ¡ctica
facilitar
apropiaciÃ³n
conceptos
Finalmente
tratan
tÃ³picos
avanzados
Arquitecturas
Convencionales
Avanzadas
Entradas
Salidas
Computadora
libro
pensando
especialmente
alumnos
aÃ±os
grado
carreras
IngenierÃ­a
Sistemas
IngenierÃ­a
ElectrÃ³nica
Tecnicaturas
TICs
UTN
carreras
grado
tÃ©cnicas
TICs
general
instituciÃ³n
universitaria
objeto
otorgar
visiÃ³n
integrada
perfil
orientaciÃ³n
Planes
Estudio
nacionales
latinoamericanos
Agradecemos
colaboraciÃ³n
generosamente
aportado
tiempo
conocimientos
revisiÃ³n
elaboraciÃ³n
tablas
grÃ¡ficas
figuras
apoyo
autoridades
presididas
Ing.
JosÃ©
Balacco
Decano
Facultad
Regional
Mendoza
Daniel
ArgÃ¼ello
Santiago
PÃ©rez
Higinio
Facchini
Mendoza
Argentina
diciembre
2020
pÃ¡
g.
11
CAPÃTULO
RepresentaciÃ³n
NumÃ©rica
Sistemas
NumeraciÃ³n
1.1
IntroducciÃ³n
1.2
Confiabilidad
1.3
Costo
Sistema
NumeraciÃ³n
Binario
2.1
IntroducciÃ³n
2.2
ConversiÃ³n
nÃºmeros
distintas
bases
2.3
Complementos
binarios
2.4
RepresentaciÃ³n
nÃºmeros
negativos
binario
Punto
Fijo
Punto
Flotante
3.1
IntroducciÃ³n
3.2
Operaciones
aritmÃ©ticas
3.3
Norma
IEEE
754
EjercitaciÃ³n
12
CapÃ­tulo
RepresentaciÃ³n
NumÃ©rica
Sistemas
NumeraciÃ³n
1.1
IntroducciÃ³n
nÃºmeros
naturales
aparecen
contar
objetos
conjunto
infancia
empieza
aprender
contar
coordinan
conjuntos
prescindiendo
orden
mencionado
justificar
introducciÃ³n
nÃºmero
natura
formulaciÃ³n
axiomÃ¡tica
revele
consiste
operaciÃ³n
contar
posterioridad
invenciÃ³n
nÃºmero
natural
surge
necesidad
ampliar
concepto
nÃºmero
Aparece
nÃºmero
entero
racional
irracional
nÃºmero
real
PodrÃ­amos
avanzar
rÃ¡pidamente
introducir
concepto
Sistema
NumeraciÃ³n
conjunto
reglas
convenios
permiten
representaciÃ³n
nÃºmeros
signos
palabras
Sistemas
NumeraciÃ³n
conocidos
Romano
descompone
nÃºmero
suma
diferencia
representado
sÃ­mbolo
especial
sistema
Decimal
introducir
sÃ­mbolos
diversos
sumandos
utiliza
principio
valor
relativo
posicional
cifra
representa
valores
distintos
lugar
ocupa
sistemas
representan
interÃ©s
matemÃ¡tico
Sistema
Decimal
ue
inventado
India
siglo
IV
Cristo
llevado
Europa
Ã¡rabes
Edad
Media
fundado
nÃºmero
fijo
llamamos
habiendo
elegido
dedos
manos
combinaciÃ³n
operaciones
fundamentales
efectuadas
nÃºmeros
cualesquiera
origen
nÃºmero
llama
13
algoritmo
numeraciÃ³n
sistemas
numeraciÃ³n
basados
valor
relativo
posicionales
algoritmo
numeraciÃ³n
consiste
polinomio
anbn
an-1bn-1
an-2bn-2
a1b1
a0b0
a-1b-1
a-2b-2
a-kb-k
NÃºmero
ai
nÃºmero
natural
menor
sÃ­mbolo
base
sistema
cantidad
sÃ­mbolos
sistema
nÃºmero
natural
cantidad
cifras
enteras
cantidad
cifras
fraccionarias
ObsÃ©rvese
entera
nÃºmero
corresponde
tÃ©rminos
polinomio
base
elevada
exponentes
cero
positivos
fraccionaria
corresponde
exponentes
negativos
apreciarse
principio
valor
relativo
ejemplo
nÃºmero
24,2
conocido
sistema
numeraciÃ³n
decimal
polinomio
24,2
101
100
10-
ObsÃ©rvese
valor
depende
posiciÃ³n
ocupa
nÃºmero
propiedades
nÃºmeros
estudian
MatemÃ¡ticas
vÃ¡lidas
cualquiera
base
utilizada
utilice
algoritmo
numeraciÃ³n
elegimos
base
podrÃ­amos
operaciones
algebraicas
suma
resta
multiplicaciÃ³n
divisiÃ³n
etc.
problema
axiomÃ¡tica
teoremas
parten
algoritmo
numeraciÃ³n
anteriormente
eligiÃ³
10
base
hacernos
pregunta
Sistema
NumeraciÃ³n
Decimal
adecuado
usado
sistemas
fÃ­sicos
representaciÃ³n
tratamiento
informaciÃ³n
respuesta
resulta
evaluar
aspectos
costo
confiabilidad
Sistema
FÃ­sico
construir
14
1.2
Confiabilidad
sistema
fÃ­sico
confiable
correcto
funcionamiento
independiente
temperatura
trabaja
envejecimiento
dispersiÃ³n
tolerancia
componentes
forman
componentes
utilizan
construcciÃ³n
sistemas
fÃ­sicos
procesamiento
informaciÃ³n
elÃ©ctricos
electrÃ³nicos
transistores
diodos
resistores
capacitores
inductores
etc.
cambian
parÃ¡metros
envejecimiento
temperatura
imposible
construir
componentes
idÃ©nticos
llama
dispersiÃ³n
fabricantes
especifican
porcentaje
dispersiÃ³n
mÃ¡ximo
componentes
comercializan
aclarar
mencionado
comparemo
sistemas
fÃ­sicos
Figura
1.1
representan
nÃºmeros
distintas
bases
base
10
base
Fig
1.1a
indica
circuito
elÃ©ctrico
capaz
representar
nÃºmero
decimal
base
10
Fig
1.1b
indica
circuito
elÃ©ctrico
capaz
representar
nÃºmero
binario
base
consisten
foco
enciende
distintas
intensidades
luminosas
mover
llave
cantidad
posiciones
caso
caso
suponen
observador
capaz
determin
ar
nÃºmero
cuestiÃ³n
apreciando
intensidad
luminosa
Fig
1.1
Sistemas
fÃ­sicos
representan
nÃºmeros
conclusiÃ³n
resulta
evidente
fÃ¡cil
determinar
foco
caso
prendido
apagado
caso
intensidades
posibles
15
apreciaciÃ³n
Supongamos
aumenta
temperatura
ambiente
circuito
envejecido
modifica
valor
resistencias
intensidad
emitida
foco
temperatura
envejecimiento
afectan
caso
b.
Finalmente
supongamos
reponer
foco
quemÃ³
foco
dispersiÃ³n
seguramente
parÃ¡metros
consideraciones
debiÃ©semos
remplazar
resistencia
dispersiÃ³n
afecta
caso
b.
conclusiÃ³n
decirse
circuito
trabaja
binario
confiable
decimal
confiable
circuito
trabaje
base
sistemas
digitales
construyen
focos
llaves
considerado
aplicable
componentes
utilizan
realidad
1.3
Costo
Nuevamente
observando
Figura
1.1
punto
vista
costo
afirmar
costoso
construir
circuito
decimal
binario
Costo
proporcional
base
sistema
numeraciÃ³n
utilizado
necesitamos
circuitos
binarios
representar
cantidad
ejemplo
representar
nÃºmero
25
necesitarÃ­amos
circuitos
decimales
Fig.1.1a
circuitos
binarios
Fig.1.1b
Costo
proporcional
cantidad
cifras
escribir
Costo
n+1
relaciÃ³n
b(n+1
MÃ³dulo
Sistema
mÃ¡ximo
nÃºmero
representable
n+1
cifras
n+1).Ln
Ln
Ln
Ln
Reemplazando
16
Costo
Ln
Ln
derivada
base
dCosto
db=
igualando
cero
obtenemos
bÃ³ptima
Concluimos
base
Ã³ptima
punto
vista
costo
realidad
expresiÃ³n
costo
planteada
aproximada
Teniendo
confiabilidad
Sistema
Binario
utiliza
construcciÃ³n
Sistemas
Digitales
Sistema
NumeraciÃ³n
Binario
2.1
IntroducciÃ³n
Sistema
Binario
sÃ­mbolos
utilizados
llamados
dÃ­gitos
binarios
bits
bitios
aplicando
algoritmo
numeraciÃ³n
obtener
nÃºmeros
binarios
correspondientes
primeras
16
10
subÃ­ndice
10
indica
nÃºmero
Sistema
Decimal
cantidades
Igualmente
podrÃ­amos
obtener
nÃºmeros
Sistema
Octal
Sistema
Hexadecimal
Tabla
1.1
indica
correspondencias
ObsÃ©rvese
Sistema
Hexadecimal
agregado
letras
obtener
16
sÃ­mbolos
distintos
necesarios
razÃ³n
Sistema
16
cifras
binarias
corresponderÃ¡
cifra
hexadecimal
Sistema
Octal
parecido
23
cifras
binarias
corresponde
Octal
permite
encontrar
rÃ¡pidamente
equivalencias
binario
octal
hexadecimal
ejemplo
0010
1001
1110
01012
29E516
110
111
111
001
000
1108
6771068
grupo
bits
recibe
nombre
nib
ble
grupo
bits
recibe
nombre
octeto
byte
17
Tabla
1.1
Correspondencia
sistemas
numeraciÃ³n
usual
temas
utilizar
prefijos
kilo
mega
giga
tera
etc.
similar
Sistema
MÃ©trico
Decimal
diferencias
Kilo
1024
210
Mega
1024
220
Giga
1024
230
Tera
1024
240
decimos
ejemplo
1Mbit
indicando
1.048.576
bits
220
decimos
1Kbyte
indicando
1024
bytes
210
operaciones
aritmÃ©ticas
estudiadas
Ã¡lgebra
aplicadas
nÃºmeros
Sistema
Decimal
aplicables
nÃºmeros
binarios
Sistemas
responden
algoritmo
numeraciÃ³n
18
2.2
ConversiÃ³n
nÃºmeros
distintas
bases
convertir
expresiones
nÃºmeros
distintas
bases
usarse
procedimiento
general
entera
nÃºmero
tÃ©rminos
polinomio
base
elevada
exponentes
cero
positivos
Supongamos
miembro
igualdad
expresado
stema
NumeraciÃ³n
base
miembro
base
b2
Nb1
an
b2n
an-1
b2n-1
a1
b21
a0
b20
dividimos
miembro
miembro
b2
vemos
tÃ©rmino
miembro
a0
resto
divisiÃ³n
cifra
significativa
nÃºmero
base
b2
Repitiendo
divisiÃ³n
cociente
obtendremos
resto
sucesivamente
lle
gar
n.
ejemplo
presentado
Tabla
1.2
aclararÃ¡
expuesto
Ejemplo
b1
1010
Nb1
2510
b2
210
Tabla
1.2
Secuencia
conversiÃ³n
decimal
binario
mencionado
2510
110012
19
fraccionaria
nÃºmero
tÃ©rminos
polinomio
base
elevada
exponentes
negativos
Supongamos
miembro
igualdad
expresado
Sistema
NumeraciÃ³n
base
miembro
base
b2
Nb1
a-1
b2-1
a-2
b2-2
ak+1
b2k+1
a-k
b2-k
multiplicamos
miembro
miembro
observamos
tÃ©rmino
miembro
a-1
cifra
significativa
fraccionaria
Reiterando
multiplicaciÃ³n
fraccionaria
resultado
obteniendo
sucesivas
cifras
significativas
ejemplo
aclararÃ¡
expuesto
Ejemplo
b1
1010
Nb1
0,2110
b2
210
0,21
0,42
0,42
0,84
0,84
1,68
0,68
1,36
0,36
0,72
0,72
1,44
0,44
0,88
mencionado
0,2110
0,0011010
nÃºmeros
entera
fraccionaria
aplicamos
2.3
Complementos
binarios
Complemento
base
complemento
base
nÃºmero
posee
cifras
enteras
define
Cb(N
bm
20
Complemento
base
disminuida
complemento
base
disminuida
nÃºmero
posee
cifras
enteras
define
Cb-1(N
bm
2-k
cantidad
cifras
fraccionarias
complementos
aplican
Sistemas
NumeraciÃ³n
base
utilizaremos
especialmente
Sistema
NumeraciÃ³n
Binario
caso
llamaremos
Complemento
Complemento
respectivamente
Veamos
ejemplos
Ejemplo
Complemento
C2(100112
1021012-
100112
1000002
100112
011012
Ejemplo
Complemento
C1(100112
1021012
100112
12
1000002
100112
-12
011002
omitirÃ¡n
subÃ­ndices
indicar
nÃºmeros
binarios
interpretar
correctamente
Observando
ejemplos
vemos
Complemento
obtenerse
cambiando
ceros
viceversa
consecuencia
restar
1s
nÃºmero
bits
consecuencia
Complemento
nÃºmero
binario
obtenerse
cambiando
ceros
viceversa
sumando
definiciÃ³n
Complemento
caso
nÃºmeros
binarios
fraccionaria
ejemplo
1100011,110
definiciÃ³n
reglas
mencionadas
siguen
vÃ¡lidas
21
2.4
RepresentaciÃ³n
nÃºmeros
negativos
binario
nÃºmeros
negativos
representa
distintas
formas
Valor
Absoluto
Signo
Supongamos
nÃºmero
binario
bits
bit
significativo
reserva
signo
bit
signo
Bs
restantes
valor
absoluto
Mantisa
forma
representamos
nÃºmeros
negativos
decimal
Bit
Signo
cero
positivo
negativo
Convenio
Complemento
bit
significativo
bit
signo
restantes
Mantisa
nÃºmero
negativo
complemento
Bit
Signo
positivo
negativo
Convenio
Complemento
bit
significativo
bit
signo
restantes
Mantisa
nÃºmero
negativo
complemento
Bit
Signo
positivo
negativo
Convenio
Exceso
2n-1
bit
significativo
bit
signo
restantes
Mantisa
nÃºmero
negativo
complemento
Bit
Signo
negativo
positivo
Veamos
ejemplo
distintos
Convenios
nÃºmero
bits
ObsÃ©rvese
Tabla
1.3
Usando
Complemento
cero
resultar
ventaja
verÃ¡
Usando
Exceso
menores
combinaciones
binarias
absolutas
corresponden
menores
equivalentes
decimales
Ãºtil
representaciÃ³n
exponentes
Punto
Flotante
veremos
Unidades
posteriores
verÃ¡
conveniencia
Convenios
Complementos
22
forma
operaciÃ³n
resta
suma
simplifica
circuitos
lÃ³gicos
excepciÃ³n
representaciÃ³n
Valor
Absoluto
Signo
utilizaciÃ³n
representaciones
operaciones
aritmÃ©ticas
requiere
definir
regl
as
apropiadas
expondrÃ¡n
posteriormente
obstante
adelantaremos
conceptos
Tabla
1.3
RepresentaciÃ³n
nÃºmeros
enteros
usando
bits
tabla
observarse
caso
Convenios
Complemento
Complemento
incluir
bit
signo
bit
nÃºmero
ejemplo
encontrar
combinaciÃ³n
binaria
correspondiente
-3
Convenio
Complemento
basta
combinaciÃ³n
correspondiente
+3
011
encontrar
Complemento
incluyendo
Bit
Signo
C2(011
1000
011
101
forma
Bit
Signo
utiliza
bit
Veamos
ejemplo
+3
-3
usando
Convenio
Complemento
izquierda
rechaza
tratarse
nÃºmeros
bits
Convenio
Complemento
+1
-2
23
observa
usado
bit
signo
tratara
bit
Punto
Fijo
Punto
Flotante
3.1
IntroducciÃ³n
Lamentablemente
nÃºmeros
enteros
surgen
representaciones
binarias
dÃ­gitos
bits
fraccionarios
necesidad
llamada
NotaciÃ³n
Punto
Fijo
resuelve
problema
ejemplo
formato
1101001,101
caso
disponemos
10
bits
representar
nÃºmero
enteros
fraccionarios
problema
construir
Sistema
Digital
debemos
fijar
formato
nÃºmeros
Adem
Ã¡s
ciencias
usual
necesidad
representar
nÃºmeros
pequeÃ±os
nÃºmeros
cantidad
limitada
dÃ­gitos
resulta
imposible
abarcar
amplio
rango
cantidades
llamada
NotaciÃ³n
Punto
Flotante
NotaciÃ³n
similar
NotaciÃ³n
CientÃ­fica
divide
nÃºmero
campos
muestra
Figura
1.2
Signo
Mantisa
Exponente
Signo
Exponente
Mantisa
Exponente
Mantisa
Fig
1.2
RepresentaciÃ³n
nÃºmeros
reales
punto
flotante
Signo
Mantisa
campo
bit
positivo
negativo
24
Exponente
campo
bits
ConvenciÃ³n
Exceso
2n
-1
ejemplo
Exceso
64
bits
Exceso
128
requiere
bits
Mantisa(M
campo
bits
fraccionarios
nÃºmero
estÃ©
normalizado
bit
significativo
mantisa
1/2
menor
3.2
Operaciones
aritmÃ©ticas
operaciones
aritmÃ©ticas
nÃºmeros
punto
flotante
particularidades
1E1M1
2E2M2
nÃºmeros
punto
flotante
normalizados
Exceso
64
MultiplicaciÃ³n
producto
nÃºmeros
SpEpMp
Signo
mantisa
Sp
S1
S2
Sp
S1
S2
Exponente
Ep
E1
E2
64
valor
satisface
1/2
M1
M2
Mantisa
Mp
M1
M2
DivisiÃ³n
divisiÃ³n
nÃºmeros
SdEdMd
Signo
mantisa
Sd
S1
S2
Sd
S1
S2
Exponente
Ed
E1
E2
64
valor
satisface
1/2
M1
M2
25
Mantisa
Md
M1
M2
Suma
resta
sumar
restar
nÃºmeros
debemos
igualar
exponentes
exponentes
Exceso
convenciÃ³n
menores
nÃºmeros
corresponden
menores
combinaciones
binarias
absolutas
comparaciÃ³n
sencilla
Supongamos
E1
E2
encontramos
E1
E2
Modificamos
S2E2M2
igualar
exponentes
S2(E2
j)M2/2j
procedemos
sumar
restar
mantisas
caso
resultado
normalizado
expuso
divisiÃ³n
producto
Base
ExponenciaciÃ³n
objeto
aumentar
rango
representaciÃ³n
base
exponenciaciÃ³n
16
ejemplo
representaciÃ³n
punto
flotante
base
exponenciaciÃ³n
mantisa
interpretarse
Octal
grupos
bits
partiendo
coma
derecha
normalizaciÃ³n
casos
obtiene
dÃ­gito
significativo
grupo
bits
mantisa
cero
3.3
Norma
IEEE
754
estandarizar
representaciÃ³n
punto
flotante
IEEE
dictÃ³
Norma
754
1985
respetada
actualmente
mayorÃ­a
fabricantes
procesadores
norma
establece
tipos
representaciones
observa
Figura
1.3
26
Fig
1.3
Representaciones
punto
flotante
Norma
exponentes
mÃ­nimo
mÃ¡ximo
utilizan
casos
especiales
mantisas
normalizadas
empiezan
necesario
almacenarlo
coma
implÃ­cita
coloca
derecha
mantisa
llamada
significando
menor
consideran
clases
nÃºmeros
indica
Figura
1.4
Fig
1.4
Casos
especiales
nÃºmeros
punto
flotante
27
EjercitaciÃ³n
Ejercicio
Convertir
decimal
siguientes
nÃºmeros
11010100112
1BF16
111101,101012
2328
575,548
2CD,516
ResoluciÃ³n
punto
quiera
convertir
sistema
numeraciÃ³n
decimal
mÃ©todo
apropiado
polinomio
numeraciÃ³n
representa
nÃºmero
convertir
polinomio
opera
decimal
obteniendo
resultado
decimal
11010100112=1x29
1x28
0x27
1x26
0x25
1x24
0x23
0x22
1x21
1x20
11010100112=512
256
64
16
1=85110
Ejercicio
Convertir
octal
siguientes
nÃºmeros
l38210
7523,23610
111010012
1011011,10112
45BA16
DCBA,2F16
Ejercicio
Convertir
base
nÃºmero
78,3
base
volverlo
base
apreciando
bits
fraccionarios
conclusiones
resultan
Ejercicio
nÃºmero
decimal
representado
dÃ­gitos
hexadecimales
Ejercicio
Ordenar
siguientes
nÃºmeros
menor
BA316
110010112
834210
E4A16
689510
111011011112
Ejercicio
sÃ­mbolos
sistema
numeraciÃ³n
base
14
Indicar
posibles
individuos
Ejercicio
EfectÃºe
siguientes
operaciones
utilizando
palabras
bits
Representando
nÃºmeros
negativos
convenio
complemento
28
Representando
nÃºmeros
negativos
convenio
complemento
35
21
-48
21
-25
-39
-63
18
Ejercicio
Indique
mÃ¡ximo
nÃºmero
decimal
positivo
negativo
representado
convenio
complemento
utilizan
palabras
16
bits
32
bits
Ejercicio
Disponiendo
palabra
36
bits
destinado
bit
signo
nÃºmero
exponente
27
mantisa
represente
punto
flotante
base
16
siguientes
nÃºmeros
decimales
29
52,73
0,125
0,011
Ejercicio
10
EfectÃºe
siguientes
operaciones
representaciÃ³n
punto
flotante
indicada
ejercicio
base
110011
11100,110110
101,11
1110100,0111
10110,0011
1010010,00101
0,000010011001
Ejercicio
11
Obtenga
nÃºmeros
decimales
rep
resentaciÃ³n
punto
flotante
base
10001101
1110010010100001
01010001
1111010001100001
Ejercicio
12
Indique
mÃ¡ximos
mÃ­nimos
nÃºmeros
positivos
decimales
representarse
formato
punto
flotante
indicado
simple
doble
precisiÃ³n
base
Ejercicio
13
EfectÃºe
siguientes
operaciones
representaciÃ³n
punto
flotante
indicada
ejercicio
base
0,00000010111101
10011110,001
0,11111010
0,000000110
1101001010,0001
0,000001100001011
29
CAPÃTULO
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
CÃ³digos
1.1
IntroducciÃ³n
1.2
CÃ³digos
binarios
1.3
CÃ³digos
BCD
1.4
CÃ³digos
alfanumÃ©ricos
CÃ³digos
Detectores
Correctores
Error
2.1
IntroducciÃ³n
2.2
Distancia
mÃ­nima
2.3
CÃ³digos
detectores
error
2.4
CÃ³digos
correctores
error
EncriptaciÃ³n
Cifrado
CÃ³digos
4.1
CÃ³digos
barras
4.2
CÃ³digos
QR
EjercitaciÃ³n
30
CapÃ­tulo
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
CÃ³digos
1.1
IntroducciÃ³n
DefiniciÃ³n
cÃ³digo
ley
correspondencia
biunÃ­voca
elementos
conjuntos
cÃ³digo
representaciÃ³n
biunÃ­voca
conjunto
elementos
forma
asigna
combinaciÃ³n
sÃ­mbolos
determinados
viceversa
observa
Figura
2.1
comunicarse
cÃ³digo
utilizado
Fig
2.1
RelaciÃ³n
biunÃ­voca
cÃ³digo
CÃ³digos
numÃ©ricos
elementos
conjuntos
nÃºmeros
1.2
CÃ³digos
binarios
sistemas
numeraciÃ³n
binario
octal
hexadecimal
etc.
estudiados
constituyen
cÃ³digos
representaciÃ³n
cantidades
31
CÃ“DIGOS
BINARIOS
base
cÃ³digo
cÃ³digos
utilizados
sistemas
digitales
sistema
numeraciÃ³n
binario
presentado
Tabla
2.1
recibe
nombre
cÃ³digo
binario
natural
Tabla
2.1
CÃ³digo
binario
natural
cifras
binarias
bits
obtener
combinaciones
combinaciÃ³n
asignar
elemento
cantidad
distinto
grupo
bits
binarios
cÃ³digo
bits
asumir
combinaciones
distintas
1Â´s
0Â´s
cÃ³digo
Ãºtil
asignar
combinaciÃ³n
elemento
varÃ­an
2n
mÃ­nimo
nÃºmero
bits
requeridos
escribir
cÃ³digo
2n
elementos
distintos
mÃ¡ximo
nÃºmero
bits
especificado
combinaciones
podrÃ­amos
2n
permutaciones
2n
combinaciones
cÃ³digos
distintos
verÃ¡n
caracterÃ­sticas
particulares
Efectivamente
estudio
cÃ³digos
binarios
conocidos
aplicaciÃ³n
computacional
32
CÃ³digos
binarios
continuos
progresivos
combinaciones
correspondientes
nÃºmeros
decimales
consecutivos
adyacentes
llaman
combinaciones
binarias
adyacentes
difieren
bit
CÃ³digos
binarios
cÃ­clicos
cÃ³digos
continuos
combinaciÃ³n
adyacente
Cuadro
2.1
muestra
casos
Cuadro
2.1
CÃ³digos
continuos
cÃ­clicos
ejemplo
tÃ­pico
cÃ³digo
continuo
cÃ­clico
llamado
GRAY
bits
necesidad
llamado
reflejado
construir
cÃ³digo
bits
reflejan
combinaciones
cÃ³digo
Gray
n-1
utiliza
principalmente
convertidores
rÃ¡pidos
codificadores
combinaciÃ³n
binaria
contigua
cambia
bit
aumenta
velocidad
elimina
riesgo
transiciones
intermedias
ampliar
palabras
codificadas
cÃ³digo
bit
basta
repetir
simÃ©tricamente
com
binaciones
espejo
agregar
bit
izquierda
cero
mitad
mitad
combinaciones
posibles
Tabla
2.2
representa
cÃ³digo
Gray
bits
33
Tabla
2.2
RepresentaciÃ³n
cÃ³digo
Gray
bits
ejemplo
cÃ³digo
binario
continuo
cÃ­clico
Johnson
observa
Tabla
2.3
bits
Tabla
2.3
RepresentaciÃ³n
cÃ³digo
Johnson
bits
1.3
CÃ³digos
BCD
nÃºmeros
puros
representan
notaciÃ³n
octal
hexadecimal
facilidad
conversiÃ³n
conversiÃ³n
34
binaria
decimal
difÃ­cil
calculadoras
juegos
electrÃ³nicos
instrumentos
digitales
generalment
comÃºn
entrada
salida
nÃºmeros
notaciÃ³n
decimal
emplea
cÃ³digo
especial
representar
notaciÃ³n
cÃ³digo
llama
CODIGO
BCD
decimal
codificado
binario
binary
coded
decimal
tÃ©cnica
convert
nÃºmero
decimal
equivalente
binario
lugar
convertir
valor
decimal
entero
forma
binaria
pura
representar
dÃ­gitos
decimales
necesarios
bits
16
combinaciones
posibles
obtienen
bits
utilizan
cÃ³digos
BCD
clasificar
Ponderados
poseen
regla
formaciÃ³n
adjudica
peso
binarios
posiciÃ³n
ocupan
conjunto
bits
debiÃ©ndose
verificar
suma
algebraica
pesos
combinaciÃ³n
nÃºmero
decimal
representado
ejemplos
tÃ­picos
BCD
natural
pesos
BCD
AIKEN
pesos
Libres
ponderados
correspondencia
decimal
binaria
arbitraria
pesos
sumas
algebraicas
general
combinaciones
forman
reglas
especÃ­ficas
cÃ³digo
ejemplo
tÃ­pico
BCD
Exceso
forma
partiendo
BCD
natural
sumÃ¡ndole
combinaciÃ³n
Tabla
2.4
presenta
tipos
cÃ³digos
BCD
Tabla
2.4
Tipos
cÃ³digos
BCD
35
conversiÃ³n
nÃºmero
decimal
cÃ³digo
BCD
realiza
simplemente
expresando
dÃ­gito
combinaciÃ³n
binaria
corresponde
cÃ³digo
especificado
ejemplo
Tabla
2.5
observa
nÃºmero
decimal
926
representado
distintos
cÃ³digos
Tabla
2.5
RepresentaciÃ³n
nÃºmero
926
distintos
cÃ³digos
BCD
1.4
CÃ³digos
alfanumÃ©ricos
aplicaciones
computadoras
digitales
requieren
manejar
datos
consisten
nÃºmeros
letras
ejemplo
compaÃ±Ã­a
seguros
millones
clientes
computador
digital
procesar
historias
representar
nombre
dueÃ±o
pÃ³liza
forma
binaria
necesario
cÃ³digo
binario
alfabeto
cÃ³digo
binario
representar
nÃºmeros
decimales
caracteres
especiales
cÃ³digo
alfanumÃ©rico
cÃ³digo
binario
grupo
elementos
consistente
nÃºmeros
decimales
26
caracteres
alfabeto
nÃºmero
sÃ­mbolos
especiales
tales
cÃ³digos
conocido
ASCII
American
Standard
Code
for
Information
Interchange
CÃ³digo
normalizado
americano
intercambio
informaciÃ³n
continuaciÃ³n
Tabla
2.6
muestra
lista
cÃ³digo
ASCII
bÃ¡sico
estÃ¡ndar
bits
nÃºmeros
letras
mayÃºsculas
minÃºsculas
signos
puntuaciÃ³n
ASCII
incluye
256
cÃ³digos
divididos
conjuntos
estÃ¡ndar
extendido
128
conjuntos
representan
combinaciones
posibles
bits
conjunto
ASCII
bÃ¡sico
estÃ¡ndar
utiliza
bits
cÃ³digo
resultado
128
cÃ³digos
caracteres
127
00
7FH
hexadecimal
conjunto
ASCII
extendido
utiliza
bits
cÃ³digo
dando
resultado
128
cÃ³digos
adicionales
numerados
128
255
80
FFH
extendido
36
Tabla
2.6
CÃ³digo
ASCII
estÃ¡ndar
bits
conjunto
caracteres
ASCII
bÃ¡sico
32
valores
asignados
cÃ³digos
control
comunicaciones
perifÃ©ricos
caracteres
imprimibles
retroceso
retorno
carro
tabulaciÃ³n
empleados
controlar
forma
informaciÃ³n
transferida
computadora
computadora
impresora
96
cÃ³digos
restantes
asignan
signos
puntuaciÃ³n
corrientes
dÃ­gitos
letras
mayÃºsculas
minÃºsculas
alfabeto
latino
cÃ³digos
ASCII
extendido
128
255
asignan
conjuntos
caracteres
varÃ­an
fabricantes
computadoras
programadores
software
cÃ³digos
intercambiables
programas
computadoras
caracteres
ASCII
estÃ¡ndar
ejemplo
IBM
utiliza
grupo
caracteres
ASCII
extendido
suele
denominarse
conjunto
caracteres
IBM
extendido
computadoras
personales
Apple
Computer
utiliza
grupo
similar
caracteres
ASCII
extendido
lÃ­nea
computadoras
Macintosh
conjunto
caracteres
ASCII
estÃ¡ndar
universal
hardware
software
microordenadores
caracteres
ASCII
extendido
interpretarse
37
correctamente
programa
computadora
impresora
diseÃ±ados
CÃ³digos
Detectores
Correctores
Error
2.1
IntroducciÃ³n
definida
conexiÃ³n
fÃ­sica
transferir
informaciÃ³n
dispositivos
sistemas
existir
formato
datos
estrategia
sincronizaciÃ³n
envÃ­an
reciben
mensajes
incluyendo
detecciÃ³n
correcciÃ³n
errores
Figura
2.2
esquematiza
enlace
comunicaciones
datos
bloques
cumplen
funciones
Fig
2.2
Esquema
enlace
datos
DTE
Equipo
Terminal
Datos
DCE
Equipo
ComunicaciÃ³n
Datos
trasferencia
ordenada
informaciÃ³n
enlace
comunicaciÃ³n
logra
estableciendo
conexiÃ³n
DTE
identificando
emisor
receptor
asegurando
mensajes
transfieran
correctamente
errores
controlando
transferencia
informaciÃ³n
equipos
telÃ©fono
transmisor
modem
etc.
conexiones
cables
repetidoras
etc.
constituyen
soporte
fÃ­sico
permiten
enlace
datos
elemento
bÃ¡sico
considerar
estructura
mensaje
constituyendo
unidad
informaciÃ³n
llamarse
Trama
Segmento
Datagrama
protocolo
comunicaciones
asociado
general
mensaje
estructura
Figura
2.3
38
Fig
2.3
Estructura
general
mensaje
protocolo
Teniendo
equipos
canal
expuestos
ruidos
internos
externos
alterar
informaciÃ³n
transmite
resulta
fundamental
importancia
detectar
corregir
errores
formas
verificar
errores
qu
producen
mensaje
transmisiÃ³n
Especialmente
informaciÃ³n
numÃ©rica
aceptan
errores
necesario
detectar
presencia
producido
detecta
presencia
error
necesario
retransmitir
informaciÃ³n
detectar
corregir
error
producido
produce
retransmisiÃ³n
cÃ³digo
binario
utilizan
combinaciones
posibles
detectar
errores
cambia
bits
error
combinaciÃ³n
vÃ¡lida
darÃ­a
resultado
combinaciÃ³n
bits
vÃ¡lida
detectar
errores
necesario
utilizar
combinaciones
posibles
condiciÃ³n
necesaria
suficiente
efectivamente
detectar
corregir
errores
concepto
distancia
combinaciones
cÃ³digo
distancia
cÃ³digo
combinaciones
binarias
cualesquiera
nÃºmero
bits
eben
cambiarse
pasar
combinaciÃ³n
2.2
Distancia
mÃ­nima
Distancia
MÃ­nima
Dm
cÃ³digo
menor
distancias
combinaciones
cualesquiera
pertenecientes
cÃ³digo
distancia
mÃ­nima
cÃ³digos
vistos
unidad
detectar
errores
an
terior
deduce
detectar
corregir
errores
imprescindible
39
razonamiento
esquematizado
Figura
2.4
idea
capacidad
detecciÃ³n
correcciÃ³n
errores
cÃ³digo
Fig
2.4
Esquema
capacidad
detecciÃ³n
correcciÃ³n
error
cÃ³digo
Ci
Cj
combinaciones
vÃ¡lidas
cÃ³digo
considerado
resto
combinaciones
difieren
bits
vÃ¡lidas
combinaciones
vÃ¡lidas
caso
Dm
concluye
detectar
error
bit
combinaciÃ³n
vÃ¡lida
diferirÃ¡
bit
combinaciones
vÃ¡lidas
imposibilitarÃ­a
determinar
combinaciÃ³n
vÃ¡lida
proviene
corregir
caso
Dm
detectar
error
bits
corregir
bit
combinaciÃ³n
vÃ¡lida
diferirÃ¡
bit
combinaciÃ³n
vÃ¡lida
bits
permitirÃ­a
determinar
combinaciÃ³n
vÃ¡lida
proviene
probable
produzca
error
bit
corregir
bit
caso
Dm
concluye
detectar
error
bits
corregir
bits
mencionado
permite
deducir
CANTIDAD
ERRORES
DETECTABLES
Dm
CANTIDAD
ERRORES
CORREGIBLES
Dm
Distancia
mÃ­nima
Dm
40
Comentario
aproximaciÃ³n
vÃ¡lida
Sistema
Comunicaciones
probabilidad
error
bit
probabilidad
error
bits
12
ejemplo
10
-6
P2
10-12
probabilidades
errores
bits
disminuyen
abruptamente
2.3
CÃ³digos
detectores
error
detectar
errores
debemos
lograr
Dm
simple
lograrlo
contar
nÃºmero
1Â´s
binarios
contenidos
mensaje
agregarle
dÃ­gito
binario
bit
forma
mensaje
nÃºmero
par
1Â´s
nÃºmero
impar
1Â´s
llama
cÃ³digo
paridad
adiciona
bit
paridad
nÃºmero
1Â´s
par
trabaja
paridad
par
impar
procedimiento
logramos
cÃ³digo
resultante
Dm
obviamente
costa
agregar
bit
enviar
informaciÃ³n
necesario
ponerse
convenciones
trabaja
Cuadro
2.2
presenta
ejemplo
usando
cÃ³digo
BCD
natural
caracterÃ­stica
cÃ³digo
trabaje
detecciÃ³n
errores
cÃ³digos
consiste
comprobar
nÃºmero
combinaciÃ³n
cumple
convenciÃ³n
adaptada
trabaja
paridad
par
chequear
dato
recibido
cumpla
condiciÃ³n
error
solicitar
transmisiÃ³n
dato
Cuadro
2.2
Ejemplo
cÃ³digos
bit
paridad
usando
BCD
natural
41
cÃ³digos
detectores
error
cantidad
constante
1Â´s
peso
constante
encontramos
cÃ³digo
cÃ³digo
biquinario
observan
Tabla
2.6
Tabla
2.7
Ejemplos
cÃ³digos
peso
constante
cÃ³digos
combinaciÃ³n
paridad
par
forman
pesos
asignados
2.4
CÃ³digos
correctores
error
cÃ³digo
corrector
detecta
informaciÃ³n
codificada
presenta
errores
caso
afirmativo
determina
posiciÃ³n
bit
bits
errÃ³neos
corregirlos
inversiÃ³n
recordar
usando
sistema
binario
bit
error
cambia
complemento
vimos
cÃ³digos
distancia
mÃ­nima
Dm=2
permiten
correcciÃ³n
errores
producirse
error
combinaciÃ³n
obtenida
poseer
adyacentes
pertenecientes
cÃ³digo
correcta
ejemplo
cÃ³digo
detecta
combinaciÃ³n
errÃ³nea
01000
vÃ¡lida
error
produjo
bit
0100
bit
01010
ambas
combinaciones
vÃ¡lidas
deduce
corregir
bit
error
necesario
distancia
mÃ­nima
cÃ³digos
Dm
llaman
cÃ³digos
correctores
error
destacan
CÃ³digo
Hamming
cÃ³digos
Bidimensionales
CÃ³digos
Redundancia
CÃ­clica
CRC
42
2.4.1
CÃ³digo
Hamming
formaciÃ³n
cÃ³digo
cualquiera
bits
adicionan
bits
formando
cÃ³digo
bits
cÃ³digo
realizan
detecciones
paridad
obteniÃ©ndose
bit
paridad
cero
dependiendo
nÃºmero
bits
par
impar
conjunto
bits
paridad
forma
nÃºmero
sistema
binario
natural
cuyo
equivalente
decimal
indica
posiciÃ³n
bit
errÃ³neo
error
nÃºmero
obtenido
cero
bits
obtienen
2p
combinaciones
cumplir
relaciÃ³n
ejemplo
tomaremos
cÃ³digo
base
cÃ³digo
AIKEN
detectar
corregir
errores
bit
agregarle
bits
cumplir
condiciÃ³n
cÃ³digo
resultante
bits
detectar
posibles
errores
producir
combinaciÃ³n
errores
considerando
posiciones
combinaciÃ³n
ausencia
error
necesarias
combinaciones
binarias
correctoras
error
Dichas
combinaciones
correctora
error
obtienen
bits
c1
c2
c3
nÃºmero
decimal
formado
indica
posiciÃ³n
bit
errÃ³neo
combinaciones
correctoras
bits
observan
Tabla
2.8
Tabla
2.8
Tabla
correctora
cÃ³digo
Hamming
2p
43
bit
c1
toma
valor
produce
error
bits
b1
b3
b5
b7
combinaciÃ³n
cÃ³digo
formado
nÃºmero
existentes
posiciones
par
error
cualquiera
bits
convierte
impa
r.
c1
vale
nÃºmero
posiciones
dadas
impar
cero
caso
contrario
representar
conclusiÃ³n
funciÃ³n
lÃ³gica
sÃ­mbolo
funciÃ³n
OR-Exclusiva
estudiarÃ¡
posteriormente
resultado
nÃºmero
par
nÃºmero
impar
obtenemos
c2
c3
generar
bits
bits
agregarle
cÃ³digo
general
consideremos
bits
b1
b2
b4
aparecen
fÃ³rmulas
anteriores
generamos
ejemplo
b1
valer
nÃºme
ro
b3
b5
b7
impar
b1
b3
b5
b7
b2
b3
b6
b7
b4
b5
b6
b7
Cuadro
2.3
presenta
CÃ³digo
Hamming
deducido
CÃ³digo
AIKEN
Tabla
correcciÃ³n
C1
b1
b3
b5
b7
C2
b2
b3
b6
b7
C3
b4
b5
b6
b7
44
Cuadro
2.3
Ejemplo
cÃ³digo
Hamming
2.4.2
VerificaciÃ³n
redundancia
LRC
CRC
Resulta
interÃ©s
utilizaciÃ³n
cÃ³digos
cÃ­clicos
rotaciÃ³n
cÃ­clica
palabra
produce
palabra
pertenece
cÃ³digo
ventaja
emplear
cÃ³digos
cÃ­clicos
generaciÃ³n
implementar
fÃ¡cilmente
empleo
registros
desplazamientos
realimentaciÃ³n
VerificaciÃ³n
Redundancia
Longitudinal
LRC
cÃ³digo
detector
error
bit
Utilizado
adquisiciÃ³n
datos
control
industria
comunicaciÃ³n
dispositivos
PC
Figura
2.5
observa
ejemplo
trama
informaciÃ³n
ASCII
Fig
2.5
Ejemplo
trama
informaciÃ³n
ASCII
3A
identifica
comienzo
trama
0D
CR
0A
LF
identifican
trama
resto
trama
binario
equivalente
45
cÃ¡lculo
LRC
consiste
suma
hexadecimal
datos
calcular
complemento
01
08
00
00
61
62
CC
0011
0011
0011
0100
hexadecimal
33
34
LRC
33
34
VerificaciÃ³n
Redundancia
CÃ­clica
CRC
cÃ³digos
consisten
agregar
bits
mensaje
transmitir
bits
condiciÃ³n
cumple
k.
forma
obtiene
transmisiÃ³n
eficiente
can
tidad
bits
agregados
relativamente
pequeÃ±a
utilizaciÃ³n
cÃ³digos
permite
detecciÃ³n
correcciÃ³n
errores
forma
obtener
bits
agregar
procedimiento
redundancia
cÃ­clica
implementado
Registros
Desplazamiento
compuertas
XOR
CapÃ­tulos
fundamentado
aritmÃ©tica
binaria
acarreos
AritmÃ©tica
Binaria
acarreos
llamada
aritmÃ©tica
MÃ³dulo
realizan
operaciones
algebraicas
suma
resta
multiplicaciÃ³n
etc.
considerar
acarreos
ejemplo
1011
1011
1001
1001
0010
0010
observa
suma
resta
MÃ³dulo
resultado
obtenerse
realizando
funciÃ³n
XOR
bit
bit
simplificando
implementaciÃ³n
sumadores
restadores
suman
restan
nÃºmeros
iguales
resultado
cero
particularidad
cÃ¡lculo
bits
agregar
bits
llama
FCS
Frame
Check
Secuency
calculan
mensaje
transmitir
bits
cantidad
bits
agregar
FCS
46
transmisor
transmitir
procesa
usando
MÃ³du
mensaje
transmitir
ğ‘€2ğ‘˜
ğº(ğ‘¥
ğ¹ğ¶ğ‘†
ğº(ğ‘¥
Observe
FCS
resto
divisiÃ³n
bits
G(x
k+1
bits
G(x
patrÃ³n
bits
obtenido
polinomio
numeraciÃ³n
k+1
tÃ©rminos
enter
cumple
bit
significativo
significativo
MSB
LSB
G(x
normalizados
dependiendo
resultan
CRC
permiten
corregir
bits
transmisor
envÃ­a
ğ‘€2ğ‘˜
ğ¹ğ¶ğ‘†
Recepto
recibe
ğ‘€2ğ‘˜
ğ¹ğ¶ğ‘†
procesa
usando
MÃ³dulo
recibido
ğ‘€2ğ‘˜
ğ¹ğ¶ğ‘†
ğº(ğ‘¥
ğ‘€2ğ‘˜
ğº/ğ‘¥
ğ¹ğ¶ğ‘†
ğº/ğ‘¥
ğ¹ğ¶ğ‘†
ğº/ğ‘¥
ğ¹ğ¶ğ‘†
ğº/ğ‘¥
ğ¹ğ¶ğ‘†
ğ¹ğ¶ğ‘†
ğº(ğ‘¥
Observe
error
FCS
FCS
deberÃ­a
cero
resto
divisiÃ³n
receptor
cero
habido
error
transmisiÃ³n
corregir
error
receptor
procesamiento
recibido
software
hardware
rÃ¡pido
polinomios
generadores
G(X
rmalizados
internacionalmente
ejemplo
CRC-8
X8
X5
X4
100110001
Redundancia
bits
CRC-12
X12
X11
X3
X2
X1
11
Redundancia
16
bits
47
CRC-16
X16
X15
X2
Redundancia
16
bits
2.4.3
CÃ³digos
bidimensionales
utilizaciÃ³n
cÃ³digos
implica
transferencia
bloque
informaciÃ³n
organizada
dimensiones
transmisor
organiza
estructura
bidimensional
agrega
bits
adicionales
receptor
recibe
informaciÃ³n
bits
adicionales
procesa
detecta
corrige
errores
organizaciÃ³n
bidimensional
observa
Figura
2.6
Fig
2.6
OrganizaciÃ³n
cÃ³digos
bidimensionales
filas
matriz
interpretan
cÃ³digo
binario
cuya
Dm
Asimismo
columnas
matriz
interpretan
cÃ³digo
binario
Dm
transmisor
agrega
bits
filas
bits
columnas
bits
forma
distancias
mÃ­nimas
mayores
ejemplo
Figura
2.7
presenta
CÃ³digo
Bidimensional
cÃ³digo
correspondiente
filas
agregan
bits
Hamming
cÃ³digo
columnas
agrega
bit
paridad
48
Fig
2.7
OrganizaciÃ³n
cÃ³digos
bidimensionales
usando
Hamming
bits
paridad
cÃ³digo
filas
Dm
Hamming
cÃ³digo
columnas
Dm
cÃ³digo
paridad
determinar
Dm
cÃ³digo
Bidimensional
podrÃ­amos
encontrar
patrÃ³n
bits
error
detecta
do
receptor
basa
interpretar
concepto
Dm
cantidad
bits
cambiar
combinaciÃ³n
vÃ¡lida
cÃ³digo
encontrar
combinaciÃ³n
vÃ¡lida
ejemplo
Dm
cÃ³digo
partiendo
combinaciÃ³n
cÃ³digo
deberÃ­amos
cambiar
bits
encontrar
combinaciÃ³n
vÃ¡lida
caso
ejemplo
figura
patrÃ³n
bits
error
detectado
receptor
dibujado
caso
cÃ³digo
horizontal
cambiar
bits
caso
vertical
bits
Dm
generalizar
concluir
Dmbidimensional
Dmfilas
Dmcolumnas
cÃ¡lculo
bits
rectÃ¡ngulo
inferior
derecho
aparecen
bits
Hamming
paridad
simu
ltÃ¡neamente
afirmar
determinismo
cÃ¡lculos
parten
juego
bits
matriz
paridades
coincidir
extender
conceptos
cÃ³digos
tridimensionales
cÃ³digos
multid
imensionales
consistirÃ¡n
ordenamiento
bits
transmitir
tantas
direcciones
quiera
procedimiento
utilizado
aumentar
distancia
mÃ­nima
inconveniente
bajar
eficiencia
representativa
49
procesamiento
receptor
aumenta
crÃ­ticamente
ejemplo
caso
figura
Dm
corregir
bits
15%
transmitido
consiste
bits
agregados
EncriptaciÃ³n
Cifrado
introducciÃ³n
computadoras
especialmente
empresas
evidente
necesidad
herramientas
automÃ¡ticas
proteger
archivos
informaciones
almacenadas
memoria
nombre
genÃ©rico
tema
herramientas
diseÃ±a
das
proteger
datos
frustrar
usuarios
autorizados
informÃ¡ticos
Seguridad
Computadoras
unidad
temÃ¡tica
necesitado
desarrollarse
introducciÃ³n
redes
facilidades
comunicaciÃ³n
transportar
datos
ecnologÃ­a
esencial
redes
automÃ¡ticas
aplicaciones
seguridad
computadoras
EncriptaciÃ³n
Cifrado
medida
efectiva
amenaza
usuarios
autorizados
encriptado
cifrado
datos
inte
rpretarse
almacenamiento
transmisiÃ³n
datos
sensibles
forma
cifrada
terminologÃ­a
utilizada
campo
destaca
nombre
texto
plano
asignado
datos
originales
texto
plano
cifrado
sometiÃ©ndolo
algoritmo
cifrado
cuyas
entradas
texto
plano
clave
cifrado
salida
algoritmo
forma
cifrada
texto
plano
llama
texto
cifrado
detalles
algoritmo
normalmente
dominio
pÃºblico
clave
cifrado
mantiene
secreto
texto
cifrado
ininteligible
cualquiera
posea
clave
cifrado
guarda
computadoras
principales
organizaciÃ³n
transmite
lÃ­neas
comunicaciones
redes
esq
uema
empleado
deberÃ­a
trabajo
involucrado
romperlo
sobrepase
ventaja
potencial
pudiera
obtenerse
tÃ©cnicas
diferenciadas
utilizar
algoritmos
sustituciÃ³n
permutaciÃ³n
sustituciÃ³n
enfoques
bÃ¡sicos
cifrado
practica
tradicionalmente
clave
cifrado
determinar
caracter
texto
plano
caracter
texto
cifrado
sustituir
carÃ¡cter
tÃ©cnica
permutaciÃ³n
caracteres
texto
plano
simplemente
reorganizados
secuencia
influencia
clave
cifrado
ejemplo
podrÃ­amos
tÃ©cnica
sustituciÃ³n
algoritmo
elemental
cifrar
texto
plano
clave
cifrado
50
Texto
plano
TEXTO
DEMO
Clave
PRUEBA
Suponemos
simplicidad
Ãºnicos
caracteres
datos
manejar
letras
mayÃºsculas
espacios
blanco
algoritmo
cifrado
sustituciÃ³n
Dividimos
texto
plano
bloques
longitud
clave
cifrado
espacios
blanco
mostrados
explÃ­citamente
Remplazamos
caracter
texto
plano
entero
estÃ©
rango
00
26
usando
espacio
blanco
00
01
26
05192005
00
0519
00
2114
00
2005242115
00
04051315
Repetimos
paso
clave
cifrado
16
18
21
05
02
01
bloque
texto
plano
remplazamos
caracter
suma
mÃ³dulo
27
codificaciÃ³n
enteros
codificaciÃ³n
enteros
carÃ¡cter
correspondiente
clave
cifrado
05192005
00
0519
00
2114
00
2005242115
00
04051315
16182105
02
0116
18
2105
02
0116182105
02
01161821
21001410
02
0608
18
1519
02
2121151520
02
05210409
Remplazamos
codificaciÃ³n
enteros
resultado
paso
equivalente
caracteres
procedimiento
descifrado
ejemplo
directo
clave
caso
pareciera
difÃ­cil
infiltrado
determinar
clave
conocimiento
previo
teniendo
texto
plano
texto
cifrado
Aunqu
obvio
esquemas
sofisticados
51
tÃ©cnicas
sustituciÃ³n
permutaciÃ³n
particularmente
segura
algoritmos
combinan
proporcionar
alto
grado
seguridad
algoritmos
DES
EstÃ¡ndar
cifrado
datos
clave
64
bits
aÃ±os
personas
sugerido
probablemente
DES
seguro
aplicaciones
Alternativamente
aparecido
algoritmos
amp
liado
tamaÃ±o
clave
claves
encriptar
desencriptar
RSA
cÃ³digos
4.1
CÃ³digos
Barras
CÃ³digo
Barras
arreglo
paralelo
barras
espacios
contiene
informaciÃ³n
codificada
barras
espacios
sÃ­mbolo
informaciÃ³n
leÃ­da
dispositivos
Ã³pticos
lectores
cÃ³digo
barras
envÃ­an
informaciÃ³n
leÃ­da
computadora
informaciÃ³n
entrada
teclado
cÃ³digo
barras
definirse
conjunto
sÃ­mbolos
hechos
patrones
barras
espacios
blancos
negros
cÃ³digos
barras
codifican
bits
informaciÃ³n
datos
leÃ­dos
scanners
especiales
cÃ³digos
barras
conjunto
bases
datos
cÃ³digos
barras
requieren
ingreso
manual
humano
leÃ­dos
automÃ¡ticamente
scanners
virtualmente
libres
error
Scanners
cÃ³digos
barras
leen
patrÃ³n
barras
blancas
negras
claras
oscuras
decodifican
cÃ³digo
convirtiÃ©ndolo
string
caracteres
generalmente
guarda
base
datos
Ventajas
ventajas
procedimientos
colecciÃ³n
datos
imprime
bajos
costos
Permite
porcentajes
bajos
error
equipos
lectura
impresiÃ³n
cÃ³digo
barras
flexibles
fÃ¡ciles
conectar
instalar
52
Beneficios
cÃ³digo
barras
tÃ©cnica
entrada
datos
captura
manual
reconocimiento
Ã³ptico
cinta
magnÃ©tica
tecnologÃ­a
cÃ³digo
barras
tecnologÃ­a
implementar
sistema
co
lecciÃ³n
datos
identificaciÃ³n
automÃ¡tica
presenta
beneficios
Virtualmente
retrasos
lee
informaciÃ³n
usada
mejora
exactitud
datos
costos
fijos
labor
bajos
control
calidad
servicio
cliente
contar
categorÃ­as
informaciÃ³n
mejora
competitividad
Aplicaciones
aplicaciones
cÃ³digo
barras
cubren
prÃ¡cticamente
tipo
actividad
humana
industria
comercio
instituciones
educativas
instituciones
mÃ©dicas
gobierno
etc.
Control
material
proceso
Control
inventario
Control
tiempo
asistencia
Punto
venta
Control
calidad
Control
inventario
Embarques
recibos
Control
documentos
FacturaciÃ³n
Bibliotecas
Bancos
sangre
Hospitales
Control
acceso
Control
tiempo
asistencia
CaracterÃ­sticas
cÃ³digo
barras
sÃ­mbolo
cÃ³digo
barras
caracterÃ­sticas
nombrar
Densidad
anchura
elemento
barra
espacio
angosto
sÃ­mbolo
cÃ³digo
barras
mils
milÃ©simas
pulgada
cÃ³digo
barras
mide
longitud
fÃ­sica
densidad
WNR
Wide
to
Narrow
Ratio
razÃ³n
grosor
elemento
angosto
ancho
Usualmente
1:3
1:2
Quiet
Zone
53
Ã¡rea
blanca
principio
sÃ­mbolo
cÃ³digo
barras
Ã¡rea
necesaria
lectura
conveniente
sÃ­mbolo
SimbologÃ­as
sÃ­mbolo
cÃ³digo
barras
impresiÃ³n
fÃ­sica
cÃ³digo
barras
SimbologÃ­a
forma
codifica
informaciÃ³n
barras
espacios
sÃ­mbolo
cÃ³digo
barras
simbologÃ­as
aplicaciones
caracterÃ­sticas
principales
caracterÃ­sticas
definen
simbologÃ­a
cÃ³digo
barras
siguientes
NumÃ©ricas
alfanumÃ©ricas
longitud
fija
longitud
variable
Discretas
continuas
NÃºmero
anchos
elementos
AutoverificaciÃ³n
Figuras
2.8
2.13
presentan
ejemplos
simbologÃ­as
cÃ³digos
barras
EAN
UPC
Comercio
detallista
autoverificable
numÃ©rico
longitud
fija
Fig
2.8
SimbologÃ­a
EAN
UPC
54
CÃ³digo
39
Industrial
alfanumÃ©rico
44
caracteres
Fig
2.9
SimbologÃ­a
CÃ³digo
39
Codabar
Bancos
sangre
bibliotecas
Fig
2.10
SimbologÃ­a
Codabar
2/5
Aplicaciones
numÃ©ricas
aerolÃ­neas
numÃ©rico
Fig
2.11
SimbologÃ­a
2/5
55
CÃ³digo
93
Complementa
cÃ³digo
39
alfanumÃ©rico
Fig
2.12
SimbologÃ­a
CÃ³digo
93
CÃ³digo
128
Industrial
alfanumÃ©rico
128
caracteres
ASCII
Fig
2.13
SimbologÃ­a
CÃ³digo
128
4.2
CÃ³digos
QR
cÃ³digo
QR
cÃ³digo
barras
bidimensional
cuadrado
almacenar
datos
codificados
cÃ³digos
QR
folletos
carteles
revistas
etc.
cÃ³digos
QR
permiten
interactuar
mundo
smartphones
EspecÃ­ficamente
cÃ³digo
QR
extiende
datos
disposiciÃ³n
objeto
fÃ­sico
crean
medida
digital
operaciones
marketing
tecnologÃ­a
permite
acelera
servicios
web
mÃ³viles
herramienta
digital
creativa
56
Fig
2.14
Ejemplo
CÃ³digo
QR
escanear
cÃ³digo
QR
utilizando
telÃ©fono
inteligente
obtiene
acceso
inmediato
contenido
lector
cÃ³digo
QR
continuaciÃ³n
acciÃ³n
abrir
navegador
web
URL
especÃ­fica
provocarse
acciones
almacenamiento
tarjeta
visita
lista
contactos
telÃ©fono
inteligente
conectarse
red
inalÃ¡mbrica
cÃ³digos
QR
crearon
1994
Denso
Wave
subsidiaria
japonesa
Grupo
Toyota
tecnologÃ­a
libre
famoso
cÃ³digos
barras
2D
mundo
ganado
Ã©xito
JapÃ³n
dÃ©cada
2000
estÃ¡ndar
2011
japonese
escanearon
diariamente
cÃ³digos
QR
nÃºmero
SMS
enviados
2010
cÃ³digos
QR
comenzaron
expandirse
EE.UU
Europa
cÃ³digos
QR
personalizar
marcas
incorporen
identi
dad
visual
cÃ³digos
QR
personalizar
seguir
reglas
estructura
cÃ³digos
QR
sigan
legibles
Figuras
15
20
presentan
ejemplos
simbologÃ­as
cÃ³digos
barras
57
Fig
2.15
Ejemplo
CÃ³digo
QR
usado
ticket
acceso
evento
Fig
2.16
CÃ³digo
QR
usado
Wikipedia
58
Fig
2.17
Ejemplo
CÃ³digo
QR
usado
cartel
comercial
59
Fig
2.18
Ejemplo
CÃ³digo
QR
Fig
2.19
Ejemplo
CÃ³digo
QR
60
Fig
2.20
Ejemplo
CÃ³digo
QR
EjercitaciÃ³n
Ejercicio
tabla
cÃ³digo
Gray
bits
Ejercicio
cantidad
bits
necesitarÃ­a
cÃ³digo
Gray
codificar
Ã¡ngulos
grados
360
grados
Ejercicio
tabla
cÃ³digo
Jhonson
bits
Indique
caracterÃ­sticas
presenta
cÃ³digo
Ejercicio
Completar
cuadro
cÃ³digos
indicados
codificaciÃ³n
nÃºmeros
decimales
enunciados
cÃ³digos
auto
complementarios
Decimal
BCD
2421
BCD
EXC3
BCD
3421
BCD
5421
7,25
23,1
67,5
81
95,8
104,3
237
982,99
61
Ejercicio
Representar
nÃºmero
927
binario
natural
BCD
EXS
Comentar
resultado
efectuar
anÃ¡lisis
comparativo
facilidad
obtener
representaciones
longitud
bits
necesarios
caso
Ejercicio
Indicar
distancia
mÃ­nima
cÃ³digo
BCD
Aiken
Obtener
cÃ³digo
paridad
impar
incorporaciÃ³n
bit
paridad
distancia
mÃ­nima
cÃ³digo
resultante
Ejercicio
Realice
tabla
cÃ³digo
Hamming
detecciÃ³n
correcciÃ³n
bit
tomando
cÃ³digo
base
informaciÃ³n
BCD
3421
Ejercicio
bits
cÃ³digo
Hamming
detectar
corregir
error
datos
originalmente
codifican
combinaciones
bits
bits
12
bits
Ejercicio
Indicar
distintas
combinaciones
binarias
asignadas
siguientes
nÃº-meros
caracteres
sÃ­mbolos
especiales
cÃ³digo
ASCII
bits
Ejercicio
10
Indicar
nÃºmeros
caracteres
sÃ­mbolos
especiales
pertenecen
combinaciones
cÃ³digo
ASCII
bits
representan
siguientes
nÃºmeros
octal
75
12
105
62
52
13
74
132
55
27
62
Ejercicio
11
texto
somÃ©talo
algoritmo
cifrado
UNIVERSIDAD
TECNOLOGICA
NACIONAL
Suponemos
simplicidad
Ãºnicos
caracteres
datos
manejar
letras
mayÃºsculas
espacios
blanco
clave
cifrado
cadena
caracteres
ESTUDIAR
Ejercicio
12
texto
codificado
palabra
clave
AVANTI
descÃ­frelo
utilizando
esquema
Ã‘LTNÃ‘NSANCNIFJAZUIDQNOMN
63
CAPÃTULO
CAPÃTULO
Ãlgebra
Boole
VisiÃ³n
General
Ãlgebra
Boole
1.1
IntroducciÃ³n
1.2
Postulados
1.3
Teoremas
Funciones
LÃ³gicas
2.1
IntroducciÃ³n
2.2
Teoremas
funciones
lÃ³gicas
MinimizaciÃ³n
Funciones
LÃ³gicas
3.1
IntroducciÃ³n
3.2
MÃ©todo
simplificaciÃ³n
Karnaugh
Compuertas
LÃ³gicas
EjercitaciÃ³n
64
CapÃ­tulo
Ãlgebra
Boole
VisiÃ³n
General
Ãlgebra
Boole
1.1
IntroducciÃ³n
Sistema
aspecto
amplio
definirse
conjunto
elementos
guardan
relaciÃ³n
elemento
sistema
sistema
subsistema
Sistemas
clasifican
SISTEMAS
NATURALES
ARTIFICIALES
ELÃ‰CTRICOS
ELECTRÃ“NICOS
ANALÃ“GICOS
DIGITALES
COMBINACIONALES
SECUENCIALES
Sistema
digital
cuyos
elementos
digitales
adoptar
valores
discretos
Unidad
conclusiÃ³n
base
elecciÃ³n
sistema
numeraciÃ³n
adecuada
punto
vista
confiabilidad
costo
razÃ³n
Sistemas
Digitales
trabajan
elementos
fÃ­sicos
binarios
adoptar
valores
estudio
Sistemas
Digitales
necesita
estudiar
Ã¡lgebra
binaria
Ãlgebra
George
Boole
data
1854
dudas
apropiada
Claude
Shannon
1938
adaptÃ³
Ã¡lgebra
aplicaciÃ³n
sistemas
digitales
65
Seguidamente
estudia
brevemente
Ãlgebra
Boole
funciones
booleanas
minimizaciÃ³n
finalmente
compuertas
lÃ³gicas
1.2
Postulados
Ã¡lgebras
Boole
utilidad
definir
propiedad
bivalente
Ã¡lgebras
compuestas
elementos
Ã¡lgebra
conjunto
elementos
binarios
relacionados
operaciones
lÃ³gicas
producto
suma
cumplen
siguientes
postulados
letras
etc.
indican
variables
binarias
elemento
identidad
ğ‘.
operaciones
cumplen
propiedad
conmutativa
ğ‘.
ğ‘.
Propiedad
distributiva
ğ‘.
ğ‘.
ğ‘.
ğ‘.
ComplementaciÃ³n
inversiÃ³n
lÃ³gica
ğ‘Ì…
ğ‘.
ğ‘Ì…
1.3
Teoremas
teoremas
importantes
Dualidad
igualdad
lÃ³gica
vÃ¡lida
intercambian
operadores
elementos
identidad
simetrÃ­a
postulados
demuestra
teorema
Ã¡lgebra
conjunto
cerrado
resultados
aplicar
operaciones
lÃ³gicas
variables
pertenecen
Ã¡lgebra
66
Ã¡lgebra
cumple
ğ‘.
Ley
Idempotencia
ğ‘.
Ley
involuciÃ³n
ğ‘Ì¿
operaciones
lÃ³gicas
asociativas
ğ‘.
ğ‘.
ğ‘.
AbsorciÃ³n
ğ‘.
ğ‘.
8)
Leyes
Morgan
ğ‘›Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…
ğ‘Ì….
ğ‘Ì….
ğ‘Ì…
ğ‘›Ì…
ğ‘.
ğ‘.
ğ‘›Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…Ì…
ğ‘Ì…
ğ‘Ì…
ğ‘Ì…
ğ‘›Ì…
excepciÃ³n
teorema
aparecen
expresiones
obsÃ©rvese
dual
recomienda
alumno
demostrar
teoremas
forma
algebraica
basÃ¡ndose
postulados
operaciones
distributivas
prescindiremos
parÃ©ntesis
encierran
productos
lÃ³gicos
sÃ­mbolo
producto
indicarÃ¡
sucesivo
forma
ejemplo
expresiÃ³n
ğ‘.
escribirÃ¡
ğ‘ğ‘(ğ‘
67
Funciones
LÃ³gicas
2.1
IntroducciÃ³n
funciÃ³n
lÃ³gica
variable
binaria
depende
variables
binarias
relacionadas
operaciones
lÃ³gicas
funciÃ³n
lÃ³gica
nota
f(a
expresiÃ³n
lÃ³gica
involucra
variables
funciÃ³n
adoptarÃ¡
valor
expresiÃ³n
valor
determinado
variables
ejemplo
ğ‘“(ğ‘
ğ‘ğ‘Ì…
ğ‘ğ‘
f(a
funciÃ³n
variables
corresponde
Tabla
Tabla
3.1
decirse
tabla
forma
expresar
funciÃ³n
lÃ³gica
Tabla
3.1
Tabla
funciÃ³n
f(a
2.2
Teoremas
funciones
lÃ³gicas
Teorema
Ãlgebra
Boole
cumple
ğ‘“(ğ‘
ğ‘ğ‘“(1
ğ‘Ì…ğ‘“(0
68
demostrar
igualdad
basta
reemplazar
expresiÃ³n
verificar
cumple
casos
considerando
funciÃ³n
cuestiÃ³n
restricciones
vÃ¡lida
dual
ğ‘“(ğ‘
ğ‘“(0
ğ‘›)][ğ‘Ì…
ğ‘“(1
funciÃ³n
general
teorema
posee
corolarios
Ãºtiles
hora
simplificar
obtener
expresiÃ³n
simple
funciÃ³n
funciones
expresiones
general
lÃ³gicas
obtienen
efectuando
producto
miembro
miembro
expresiÃ³n
ğ‘Ì…
indica
continuaciÃ³n
ğ‘ğ‘“(ğ‘
ğ‘[ğ‘ğ‘“(1
ğ‘Ì…ğ‘“(0
Aplicando
propiedad
distributiva
miembro
obtiene
ğ‘ğ‘“(ğ‘
ğ‘ğ‘“(1
Corolario
multiplicamos
miembro
miembro
ğ‘Ì…
ğ‘Ì…ğ‘“(ğ‘
ğ‘Ì…[ğ‘ğ‘“(1
ğ‘Ì…ğ‘“0
Aplicando
propiedad
distributiva
miembro
obtiene
ğ‘Ì…ğ‘“(ğ‘
ğ‘Ì…ğ‘“(0
Corolario
Aplicando
dualidad
corolarios
anteriores
obtienen
ğ‘“(ğ‘
ğ‘“(0
Tercer
Corolario
ğ‘Ì…
ğ‘“(ğ‘
ğ‘Ì…
ğ‘“(1
Cuarto
Corolario
Teorema
II
funciÃ³n
lÃ³gica
expresarse
forma
canÃ³nica
sumatoria
tÃ©rminos
aparecen
variables
forma
producto
lÃ³gico
tÃ©rminos
llaman
MINTERMS
productoria
tÃ©rminos
aparecen
variables
forma
suma
lÃ³gica
tÃ©rminos
llaman
MAXTERMS
69
casos
funciÃ³n
xpresada
forma
canÃ³nica
tÃ©rminos
minterms
maxterms
llaman
tÃ©rminos
canÃ³nicos
demostrarÃ¡
teorema
funciÃ³n
variables
f(a
harÃ¡
extensivo
variables
Aplicando
Teorema
f(a
ğ‘“(ğ‘
ğ‘ğ‘“(1
ğ‘Ì…ğ‘“(0
Aplicando
nuevamente
Teorema
f(1
f(0
ğ‘“(1
ğ‘ğ‘“(1
ğ‘Ì…ğ‘“(1
ğ‘“(0
ğ‘ğ‘“(0
ğ‘Ì…ğ‘“(0
Remplazando
expresiÃ³n
inicial
obtiene
ğ‘“ğ‘
ğ‘ğ‘ğ‘“(1,1
ğ‘ğ‘Ì…ğ‘“(1,0
ğ‘Ì…ğ‘ğ‘“(0,1
ğ‘Ì…ğ‘Ì…ğ‘“(0,0
observa
funciÃ³n
expresarse
sumatoria
minterms
afectados
coeficiente
consiste
valor
funciÃ³n
calcula
remplazando
variables
minterm
acompaÃ±a
variable
correspondiente
directa
negada
respectivamente
Teniendo
f(a
funciÃ³n
cualquiera
Ã¡lgebra
Boole
dual
ğ‘“ğ‘
ğ‘“(0,0)][ğ‘
ğ‘Ì…
ğ‘“(0,1)][ğ‘
ğ‘Ì…
ğ‘“(0,1)][ğ‘Ì…
ğ‘Ì…
ğ‘“(1,1
AnÃ¡logamente
funciÃ³n
expresarse
productoria
maxterms
afectados
coeficiente
consiste
valor
funciÃ³n
calcula
remplazando
variables
maxterm
acompaÃ±a
variable
correspondiente
directa
negada
respectivamente
generalizaciÃ³n
resultados
obtenidos
funciones
variables
resulta
evidente
obtener
notaciÃ³n
sencilla
funciones
lÃ³gicas
suele
asignar
tÃ©rmino
canÃ³nico
nÃºmero
decimal
obtiene
dando
pesos
variables
70
encuentran
expresadas
forma
directa
negada
convenio
observa
Tabla
3.2
Tabla
3.2
Pesos
variables
booleanas
variable
aparece
forma
negada
peso
asignado
cero
ejemplo
usando
convenio
tÃ©rmino
canÃ³nico
cualquiera
ğ‘Ì…ğ‘ğ‘Ì…ğ‘‘
correspondiente
minterm
funciÃ³n
variables
nÃºmero
decimal
10
convenio
mencionado
permite
forma
llamada
compacta
notar
funciÃ³n
ğ‘“(ğ‘
ğ‘“(ğ‘–
2nâˆ’1
i=0
2ğ‘›
ğ‘“(ğ‘–
2nâˆ’1
ğ‘–=0
expresiÃ³n
deduce
regla
pasar
funciÃ³n
canÃ³nica
minterms
maxterms
viceversa
buscan
tÃ©rminos
canÃ³nicos
expresiÃ³n
funciÃ³n
complementa
2n
tÃ©rminos
funciÃ³n
buscada
ejemplo
funciÃ³n
variables
minterms
ğ‘“(ğ‘
âˆ‘(0
10
13
14
15
abajo
sÃ­mbolo
sumatoria
indica
cantidad
variables
tÃ©rminos
canÃ³nicos
11
12
complementos
15
13
11
expr
esiÃ³n
canÃ³nica
maxterms
funciÃ³n
ğ‘“(ğ‘
âˆ(3
11
13
71
NÃ³tese
verificaciÃ³n
suma
nÃºmero
minterms
maxterms
funciÃ³n
2n
MinimizaciÃ³n
Funciones
LÃ³gicas
3.1
IntroducciÃ³n
importante
obtener
mÃ­nima
expresiÃ³n
funciÃ³n
menor
cantidad
variables
operaciones
involucradas
mÃ©todos
minimizaciÃ³n
basan
postulados
Ã¡lgebra
conveniencia
agregar
oportunamente
tÃ©rminos
expresiÃ³n
funciÃ³n
aplicar
mÃ©todos
necesario
funciÃ³n
estÃ©
expresada
forma
canÃ³nica
vio
punto
funciÃ³n
lÃ³gica
expresable
forma
canÃ³nica
minterms
maxterms
SupÃ³ngase
funciÃ³n
canÃ³nica
variables
posee
expresiÃ³n
siguientes
tÃ©rminos
canÃ³nicos
ğ‘Ì…ğ‘ğ‘ğ‘‘Ì…
ğ‘ğ‘ğ‘ğ‘‘Ì…
observa
sacarse
factor
comÃºn
forma
ğ‘ğ‘ğ‘‘Ì…(ğ‘Ì…
postulado
ğ‘Ì…
ğ‘ğ‘ğ‘‘Ì…1
ğ‘ğ‘ğ‘‘Ì…
perdido
variable
a.
procedimiento
sistematiza
detectando
tÃ©rminos
canÃ³nicos
funciÃ³n
difieran
directo
negado
variable
saca
factor
comÃºn
eliminando
variables
ejemplo
ğ‘“(ğ‘
âˆ‘(0
4,8,12
72
expresiÃ³n
algebraica
ğ‘“(ğ‘
ğ‘Ì…ğ‘Ì…ğ‘Ì…ğ‘‘Ì…
ğ‘Ì…ğ‘Ì…ğ‘ğ‘‘Ì…
ğ‘Ì…ğ‘Ì…ğ‘Ì…ğ‘‘
ğ‘Ì…ğ‘Ì…ğ‘ğ‘‘
ve
adyacentes
sacarse
factor
comÃºn
ğ‘“(ğ‘
ğ‘Ì…ğ‘Ì…ğ‘‘Ì…(ğ‘
ğ‘Ì…
ğ‘Ì…ğ‘Ì…ğ‘‘(ğ‘
ğ‘Ì…
ğ‘Ì…ğ‘Ì…ğ‘‘Ì…
ğ‘Ì…ğ‘Ì…ğ‘‘
tÃ©rminos
quedan
canÃ³nicos
adyacentes
quedando
finalmente
ğ‘“(ğ‘
ğ‘Ì…ğ‘Ì…ğ‘‘Ì…
ğ‘Ì…ğ‘Ì…ğ‘‘
ğ‘Ì…ğ‘Ì…(ğ‘‘Ì…
ğ‘Ì…ğ‘Ì…
3.2
MÃ©todo
SimplificaciÃ³n
Karnaugh
E.
W.
Veitch
1952
propuso
mÃ©todo
grÃ¡fico
identificaciÃ³n
tÃ©rminos
adyacentes
funciÃ³n
Posteriormente
Maurice
Karnaugh
modificÃ³
conoce
actualmente
Consiste
mapas
aplicables
funciones
variables
mÃ©todo
resulta
prÃ¡ctico
funciones
variables
casos
mÃ©todo
numÃ©rico
estudia
libro
ejemplo
mapa
Karnaugh
muestra
Figura
.1
mapa
funciones
variables
nÃºmeros
binarios
columnas
filas
siguen
cÃ³digo
Gray
variables
corresponden
variables
directas
negadas
cuadro
nÃºmeros
decimales
signados
tÃ©rmino
canÃ³nico
convenciÃ³n
indicada
anterioridad
tabla
genÃ©rica
particularizarse
funciÃ³n
determinada
marcando
tÃ©rminos
canÃ³nicos
forman
funciÃ³n
forma
ncillo
identificar
tÃ©rminos
canÃ³nicos
adyacentes
limitan
lados
ejemplo
tÃ©rmino
canÃ³nico
14
posee
cuatros
tÃ©rminos
adyacentes
10
12
15
73
Fig
3.1
Mapa
Karnaugh
funciones
variables
Formar
grupo
colindantes
mapa
corresponde
sacar
factor
comÃºn
perder
variable
cambia
suponer
conveniencia
grupos
contengan
cantidad
interior
seguir
reglas
funciÃ³n
variables
minterms
ğ‘“(ğ‘
âˆ‘(0
1,2,3,6,7,8,9,10,11,14,15
mapa
corresponde
indicado
Figura
3.2
grupo
-2
corresponde
sacar
factor
comÃºn
pÃ©rdida
variable
b.
grupo
3-1
pierde
variable
b.
observa
grupos
adyacentes
juntar
grupo
-1-2-3
pierden
variables
b.
razonamiento
vÃ¡lido
grupo
-9-10-11
pierde
variables
b.
grupos
adyacentes
formarse
grupo
-1-2-
3-8-9-10-11
queda
variable
grupo
vertical
seguido
procedimiento
Cabe
aclarar
tÃ©rminos
canÃ³nicos
10
11
usado
realizarse
teorema
tÃ©rmino
canÃ³nico
repetirse
quiera
alterar
valor
funciÃ³n
74
Fig
3.2
Mapa
Karnaugh
funciÃ³n
ejemplo
funciÃ³n
minimizada
queda
ğ‘“(ğ‘
ğ‘Ì…
Cabe
aclarar
expresiÃ³n
suma
funciÃ³n
inicial
minterms
sumatoria
visto
enunciarse
regla
formaciÃ³n
grupos
agrupan
cantidad
potencia
grupo
resultante
subdividirse
grupos
menores
agrupan
restantes
siguiendo
regla
pudiendo
conveniente
agrupado
anteriormente
repite
caso
funciones
variables
tablas
pequeÃ±as
regla
formaciÃ³n
grupos
invita
alumno
sugerir
serÃ­as
tablas
visitar
Pr
Ã¡ctico
correspondiente
resolviendo
ejercicios
propuestos
75
Compuertas
LÃ³gicas
realizaciÃ³n
prÃ¡ctica
implementaciÃ³n
funciones
lÃ³gicas
compuertas
lÃ³gicas
base
constructiva
electrÃ³nica
digital
funciones
lÃ³gicas
presentan
interÃ©s
prÃ¡ctico
Figura
3.3
muestran
compuertas
lÃ³gicas
comunes
Fig
3.3
Listado
compuertas
lÃ³gicas
comunes
figura
aparecen
compuertas
entradas
compuertas
entradas
disponibles
comercialmente
circuitos
integrados
chips
SSI
Escala
IntegraciÃ³n
PequeÃ±a
funciÃ³n
76
cantidad
compuertas
chip
suele
clasificar
CI
escalas
integraciÃ³n
SSI
escala
integraciÃ³n
pequeÃ±a
10
compuertas
CI
MSI
escala
integraciÃ³n
media
10
100
compuertas
CI
LSI
escala
integraciÃ³n
100
1000
compuertas
CI
VLSI
escala
integraciÃ³n
1000
compuertas
CI
hora
implementar
funciÃ³n
lÃ³gica
torna
importante
minimizaciÃ³n
ejemplo
funciÃ³n
ğ‘“(ğ‘¥
âˆ‘(2,4,5,6
implementamos
funciÃ³n
minimizar
btenemos
circuito
Figura
3.4
Fig
3.4
ImplementaciÃ³n
compuertas
lÃ³gicas
funciÃ³n
minimizar
invita
lector
minimizar
funciÃ³n
comparar
resultados
obtenidos
77
EjercitaciÃ³n
Ejercicio
Hallar
expresiones
canÃ³nicas
siguientes
funciones
Representar
tabla
correspondiente
ccbadcbaf
deacebaedcbaf
cbabccacbaf
Ejercicio
Simplificar
siguientes
expresiones
aplicando
teoremas
Ã¡lgebra
Boole
rpqpqrrqpqppqrrqpf
cbddbadcbcbabdacabcbdcbaf
Ejercicio
Dadas
siguientes
funciones
representadas
expresiÃ³n
canÃ³nica
comprensiÃ³n
suma
productos
producto
sumas
obtener
representaciones
forma
producto
sumas
suma
productos
respectivamente
7,5,2
ïƒ¥=cbaf
ïƒ•=
14,12,8,4,3,1
dcbaf
Ejercicio
Obtener
tabla
funciÃ³n
canÃ³nica
comprensiÃ³n
forma
producto
sumas
funciÃ³n
variables
toma
valor
variables
toman
valor
Ejercicio
Obtener
tabla
funciÃ³n
canÃ³nica
comprensiÃ³n
extensiÃ³n
forma
suma
productos
producto
sumas
funciÃ³n
variables
toma
valor
variable
menor
peso
vale
peso
vale
78
Ejercicio
Demostrar
siguientes
igualdades
cedapcedap
baba
ïƒ…=ïƒ…
acabcaa
ïƒ…=ïƒ…
Ejercicio
leyes
Morgan
indicar
siguientes
igualdades
correcta
bccababccaab
baabccbaabcbacba
Ejercicio
Dadas
siguientes
funciones
representadas
expresiÃ³n
canÃ³nica
comprensiÃ³n
suma
productos
producto
sumas
obtener
representaciones
forma
producto
sumas
suma
productos
respectivamente
ïƒ¥=
15,14,9,8,6,4
dcbaf
6,5,2,1
ïƒ•=cbaf
Ejercicio
Minimizar
mÃ©todo
karnaugh
funciones
expresadas
forma
canÃ³nica
extensiÃ³n
Ejercicio
Ejercicio
10
siguientes
expresiones
corresponden
funciones
minimizadas
expresadas
forma
suma
productos
Obtener
funciones
minimizadas
expresadas
form
producto
sumas
correspondientes
bdacadcbbcddcbaf
79
acdbdcbadcbaf
cbbdbadcbaf
Ejercicio
11
sistema
digital
opera
cÃ³digo
BCD
EXC
desea
implementar
generador
paridad
impar
Indicar
funciÃ³n
simple
forma
producto
sumas
suma
productos
satisface
requisito
Ejercicio
12
registro
bits
cuyas
salidas
disponibles
exterior
almacena
informaciÃ³n
numÃ©rica
decimal
cÃ³digo
BCD
Natural
desea
implementar
sistema
digital
detecte
nÃºmero
contenido
registro
superior
inferior
Indicar
funciÃ³n
simple
forma
producto
sumas
suma
productos
satisface
requisito
80
81
CAPÃTULO
Sistemas
Combinacionales
Sistemas
Digitales
Sistemas
Combinacionales
2.1
IntroducciÃ³n
2.2
Sistemas
combinacionales
MSI
Casos
Comunes
Sistemas
Combinacionales
MSI
3.1
Codificadores
3.2
Decodificadores
3.3
Multiplexores
3.4
Demultiplexores
3.5
Comparadores
3.6
Detectores
Generadores
paridad
3.7
Sumadores
3.8
Unidades
aritmÃ©ticas
lÃ³gicas
EjercitaciÃ³n
82
CapÃ­tulo
Sistemas
Combinacionales
Sistemas
Digitales
sistema
digital
conjunto
elementos
binarios
relacionados
distinguen
tipos
variables
sistema
digital
variables
entrada
variables
salida
dependen
entrada
Funcionalmente
variables
entrada
dividen
grupos
variables
proceso
variables
control
Figura
4.1
Fig
4.1
Diagrama
sistema
digital
combinaciÃ³n
variables
entrada
Vector
entrada
corresponde
combinaciÃ³n
variables
salida
Vector
salida
sistema
combinacional
repita
conjunto
valores
variables
entrada
repetirÃ¡
salida
Figura
4.2
muestran
corres
pondencias
entradas
salidas
sistema
combinacional
vector
entrada
corresponder
salida
sistema
llama
secuencial
repite
conjunto
valores
variables
entrada
necesariamente
repetirÃ¡
salida
sistemas
secuenciales
poseer
memoria
interna
salidas
consecuencia
evoluciÃ³n
entradas
Figura
4.3
muestran
correspondencias
sistema
secuencial
83
Fig
4.2
Correspondencias
Sistema
Combinacional
Fig
4.3
Correspondencias
Sistema
Secuencial
Sistemas
Combinacionales
2.1
IntroducciÃ³n
definido
punto
concluye
Sistema
combinacional
salidas
cosa
funciones
lÃ³gicas
entradas
Figura
4.4
ve
diagrama
bloque
combinacional
entradas
salidas
escribir
ğ‘§ğ‘–
ğ‘“ğ‘–(ğ‘¥1
ğ‘¥2
ğ‘¥ğ‘›
84
Fig
4.4
Diagrama
bloque
sistema
circuito
combinacional
deduce
diseÃ±ar
circuito
combinacional
bastarÃ¡
minimizar
funciones
requeridas
finalmente
implementar
compuertas
lÃ³gicas
2.2
Circuitos
combinacionales
MSI
funciones
lÃ³gicas
complejas
diseÃ±o
basado
minimizaciÃ³n
posterior
implementaciÃ³n
compuertas
lÃ³gicas
adecuado
tÃ©cnicas
integraciÃ³n
permitido
CI
complejos
ejemplo
MSI
dispone
CI
100
puertas
bloques
funcionales
MSI
fines
especÃ­ficos
aplicarse
implementaciÃ³n
funciones
lÃ³gicas
variables
ventajas
principales
disminuciÃ³n
CI
necesarios
tiempo
diseÃ±o
nÃºmero
conexiones
externas
facilidad
mantenimiento
continuaciÃ³n
describen
brevemente
Combinacionales
MSI
comunes
Casos
Comunes
Sistemas
Combinacionales
MSI
3.1
Codificadores
Permiten
codificar
lÃ­neas
entrada
Generalmente
codifican
binario
BCD
Figura
4.5
muestra
codificador
binario
entradas
salidas
circuito
interno
tabla
codificador
supone
activa
entrada
caso
salida
calcularse
funciÃ³n
OR
bit
85
bit
salidas
correspondientes
entradas
activadas
independientemente
decodificadores
llaman
prioridad
Fig
4.5
Codificador
binario
entradas
salidas
tabla
Figura
4.5
remplazan
ceros
izquierda
entradas
obtiene
codificador
prioridad
entrada
prioridad
define
salida
entrada
activa
salidas
cero
estuviera
activada
entrada
D0
evitar
problema
codificadores
cuentan
salida
adicional
indica
ausencia
activaciÃ³n
entradas
codificadores
suelen
contar
entrada
habilitaciÃ³n
chip
activado
vÃ¡lida
tabla
chip
funciona
3.2
Decodificadores
combinacionales
poseen
entradas
salidas
orden
adecuado
salida
activa
codi
ficaciÃ³n
correspondiente
inyecta
entrada
Generalmente
binarios
BCD
caso
decodificador
binario
entradas
poseerÃ¡
salidas
decodificador
realiza
opuesto
codificador
Figura
4.6
muestra
decodificador
tabla
86
decodificadores
usarse
decodificar
Ãºtiles
implementar
funciones
lÃ³gicas
salidas
minterm
funciÃ³n
variables
Aprovechando
entrada
habilitaciÃ³n
suelen
aumentar
nÃºmero
variables
Figura
4.7
decodificador
implementar
funciÃ³n
F(z
1,3,6,7
Fig
4.6
Decodificador
entradas
salidas
Fig
4.7
Decodificador
3x8
implementar
funciÃ³n
F.
Figura
4.7
observa
entrada
habilitaciÃ³n
decodificador
habilitado
cualesquiera
valores
salida
activarÃ¡
Figura
4.8
mues
tra
obtener
decodificador
16
partiendo
decodificadores
87
Fig
4.8
Decodificador
4x16
decodificadores
3x8
3.3
Multiplexores
Disponen
2n
lÃ­neas
entrada
canales
lÃ­nea
salida
lÃ­neas
selecciÃ³n
funciÃ³n
lÃ­neas
selecciÃ³n
determina
entrada
aparece
salida
Figura
4.9
indica
funciÃ³n
multiplexor
Figura
4.10
circuito
multiplexor
canales
Fig
4.9
Funcionamiento
multiplexor
multiplexores
multiplexar
usarse
eficazmente
implementar
funciones
lÃ³gicas
Supongamos
funciÃ³n
implementar
F(a
0,1,5,6,7
88
Fig
4.10
Multiplexor
canales
implementar
funciÃ³n
variables
necesita
multiplexor
entradas
selecciÃ³n
variables
ejemplo
conectan
lÃ­neas
selecciÃ³n
tercer
variable
conecta
canales
altura
conveniente
contar
tabla
funciÃ³n
ejemplo
presentada
Tabla
4.1
tabla
funciÃ³n
construye
tabla
auxiliar
presentada
Tabla
4.2
tabla
auxiliar
obtiene
verificando
vale
funciÃ³n
combinaciones
permite
determinar
valores
conectar
canales
multiplexor
Figura
4.11
Tabla
4.1
Tabla
funciÃ³n
F.
89
Tabla
4.2
Tabla
auxiliar
procedimiento
generalizarse
variables
conectan
lÃ­neas
selecciÃ³n
multiplexor
restante
canales
tabla
auxiliar
multiplexores
canales
combinarse
multiplexores
ejemplo
Figura
4.12
muestra
multiplexor
32
canales
16
canales
canales
entrada
habilitaciÃ³n
activa
salida
multiplexor
independientemente
valor
entradas
Fig
4.11
ImplementaciÃ³n
funciÃ³n
usando
multiplexor
3.4
Demultiplexores
Cumplen
funciÃ³n
opuesta
multiplexores
entrada
salidas
entradas
selecciÃ³n
salida
seleccionada
valor
entrada
Figura
4.13
muestra
demultiplexor
canales
salida
circuito
demultiplexor
coincidente
decodificador
posea
entrada
habilitaciÃ³n
razÃ³n
encuentran
90
demultiplexores
especÃ­ficos
Figura
4.14
indica
obtener
demultiplexor
canales
decodificador
entrada
habilitaciÃ³n
Fig
4.12
Multiplexor
32
canales
usando
multiplexores
16
canales
Fig
4.13
Demultiplexor
canales
salida
usual
encontrar
familias
lÃ³gicas
multiplexores
demultiplexores
circuitos
cumplir
ambas
funciones
91
Fig
4.14
Demultiplexor
canales
usando
decodificador
2x4
3.5
Comparadores
Realizan
comparaciÃ³n
nÃºmeros
binarios
bits
circuito
bÃ¡sico
realiza
comparaciÃ³n
bit
indica
Figura
4.15
Fig
4.15
Circuito
bÃ¡sico
comparaciÃ³n
bit
circuito
responde
tabla
Tabla
4.3
Comparadores
bits
diseÃ±an
Comparadores
poseen
entradas
permite
comparadores
elevado
nÃºmero
bits
partiendo
comparadores
menores
ejemplo
Figu
ra
4.16
muestra
comparador
bits
partiendo
comparadores
bits
92
Tabla
4.3
Tabla
comparador
Fig
4.16
Comparador
bits
usando
comparadores
bits
3.6
Detectores
Generadores
paridad
CI
capaces
generar
detectar
paridad
conjunto
bits
Figura
4.17
muestra
generador
detector
paridad
bits
circuito
Fig
4.17
Generador
Detector
paridad
bits
93
seÃ±ales
control
TO
paridad
impar
paridad
par
permiten
seleccionar
paridad
recomienda
alumno
obtener
tabla
circuito
verificar
funcionamiento
3.7
Sumadores
CI
realizan
suma
aritmÃ©tica
nÃºmer
bits
sumadores
disponibles
escala
integraciÃ³n
MSI
estudiaremos
suma
resta
binaria
Suma
binaria
indicar
suma
aritmÃ©tica
utilizaremos
sÃ­mbolo
diferenciarlo
usado
suma
lÃ³gica
sumar
bits
implementar
circuito
Figura
4.18
llamado
Semisumador
cuya
tabla
observa
Tabla
4.4
Fig
4.18
Semisumador
sumador
parcial
Tabla
4.4
Tabla
semisumador
SupÃ³ngase
desea
sumar
nÃºmeros
binarios
bits
94
c4
c3
c2
c1
c0
a3
a2
a1
a0
b3
b2
b1
b0
s3
s2
s1
s0
observa
necesarios
circuitos
columna
capaz
sumar
bits
ai
bi
ci
implementa
circuito
Figura
4.19
llamado
Sumador
cuya
tabla
presenta
Tabla
4.5
Fig
4.19
Sumador
interconexiÃ³n
Sumadores
Totales
permite
obtener
CuÃ¡druple
Sumador
capaz
suma
aritmÃ©tica
nÃºmeros
binarios
bits
Figura
4.20
Resta
binaria
recordarse
convenios
representaciÃ³n
nÃºmeros
negativos
binario
implementar
circuito
resta
operaciÃ³n
verÃ¡
restar
nÃºmeros
realizando
suma
complemento
95
Tabla
4.5
Tabla
sumador
Fig
4.20
CuÃ¡druple
sumador
caso
convenio
complemento
nÃºmeros
binarios
signados
convenio
complemento
VÃ©ase
desarrollo
C2(B
2n
2n
expresiÃ³n
observa
resultado
obtenido
difiere
buscado
valor
n.
resultado
interpretarse
acarreo
despreciar
parÃ©ntesis
resulta
positivo
caso
parÃ©nt
esis
resulte
negativo
resultado
expresado
complemento
96
caso
complemento
nÃºmeros
binarios
signados
convenio
complemento
desarrollo
caso
C1(B
2n
2n
expresiÃ³n
observa
resultado
obtenido
difiere
buscado
valor
error
defecto
valor
resultado
interpretarse
acarreo
sumarse
resultado
parÃ©nte
sis
resulta
positivo
caso
parÃ©ntesis
resulte
negativo
resultado
expresado
complemento
conveniente
alumno
verifique
pÃ¡rrafo
par
casos
Figura
4.21
muestra
Sumador
Restador
complemento
bits
CuÃ¡druple
sumador
Figura
4.22
muestra
Sumador
Restador
bits
complemento
CuÃ¡druple
sumador
figuras
aparece
circuito
detector
rebasamiento
salida
rebasado
sumador
cero
caso
contrario
NÃ³tese
entradas
circuito
bits
signo
nÃºmeros
entrada
resultado
Fig
4.21
Sumador
Restador
bits
complemento
97
Fig
4.22
Sumador
Restador
bits
complemento
3.8
Unidades
aritmÃ©ticas
lÃ³gicas
bloques
funcionales
escala
MSI
permiten
operaciones
lÃ³gicas
aritmÃ©ticas
nÃºmeros
binarios
generalmente
bits
operaciÃ³n
selecciona
colocando
valores
adecuados
lÃ­neas
selecciÃ³n
Figura
4.23
muestra
ALU
tÃ­pica
bits
bloques
funci
onales
conectarse
cascada
operaciones
nÃºmeros
nÃºmero
bits
Fig
4.23
ALU
bits
98
EjercitaciÃ³n
Ejercicio
DiseÃ±e
sistema
combinacional
accione
motor
limpiaparabrisas
sabiendo
funciona
llave
general
auto
contacto
activa
control
limpiaparabrisas
desactiva
motor
funcionando
escobillas
lleguen
costado
izquierdo
Obtener
soluciÃ³n
imple
implementarla
compuertas
correspondientes
Ejercicio
diseÃ±o
implementaciÃ³n
llaves
luz
colocadas
pie
cima
escalera
prender
luz
llave
abajo
apagarla
llave
viceversa
Ejercicio
Utilizar
decodificadores
implementar
siguientes
funciones
10,8,6,0
ïƒ¥=dcbaf
13,8,7,5,1
ïƒ¥=dcbaf
Ejercicio
diseÃ±o
comparador
nÃºmeros
bits
sistema
salidas
menor
diseÃ±o
compuertas
NAND
Ejercicio
DiseÃ±ar
sistema
combinacional
excitaciÃ³n
variables
entrada
genere
salidas
activen
display
BCD
segmentos
representaciÃ³n
dÃ­gitos
decimales
Considerar
combinaciones
entrada
corresponden
cÃ³digo
BCD
8421
restantes
16
posibles
letras
alfabeto
f.
Obtener
soluciÃ³n
simple
implementarla
compuertas
NOR
99
Ejercicio
registro
salidas
paralelo
A0
-A3
contiene
carÃ¡cter
codificado
BCD
5421
generador
paridad
agregar
correspondiente
bit
Ap
permita
elegir
paridad
par
impar
llave
selectora
Utilizar
decodificadores
multiplexores
Ejercicio
diagrama
figura
indica
sistema
arranque
motor
elÃ©ctrico
variables
binarias
control
permitirÃ¡n
arranque
motor
xiste
paridad
impar
casos
especiales
llamados
emergencia
permitirÃ¡n
arranque
ocurren
variables
cero
simultÃ¡neamente
compuertas
Ejercicio
Construir
multiplexor
can
ales
multiplexores
canales
Ejercicio
detector
desbordamiento
aritmÃ©tico
intervalo
valores
representar
nÃºmeros
bits
sistema
numÃ©rico
complemento
-2n-1
N<=
2n-1
100
101
CAPÃTULO
Sistemas
Secuenciales
VisiÃ³n
General
Sistemas
Secuenciales
1.1
IntroducciÃ³n
1.2
caso
estudio
Biestables
2.1
IntroducciÃ³n
2.2
Biestables
asÃ­ncronos
2.3
Biestables
sÃ­ncronos
Tipos
Biestables
3.1
IntroducciÃ³n
3.2
Biestables
JK
3.3
Biestables
3.4
Biestables
Aplicaciones
Biestables
4.1
Registros
desplazamiento
4.2
Transferencias
registros
4.3
Contadores
4.4
MultiplicaciÃ³n
divisiÃ³n
binaria
EjercitaciÃ³n
102
CapÃ­tulo
Sistemas
Secuenciales
VisiÃ³n
General
Sistemas
Secuenciales
1.1
IntroducciÃ³n
Sistemas
Digitales
cuyas
salidas
dependen
entradas
momento
evolucionado
anteriormente
Sistema
Secuencial
capaz
memorizar
mencionada
evoluciÃ³n
decirse
qu
salidas
Sistema
Secuencial
dependen
entradas
concepto
equivalente
permite
plantear
esquema
general
Sistema
Secuencial
partiendo
Sistema
Combinacional
realimentado
entradas
est
combinacional
formadas
variables
independientes
salidas
mencionado
observarse
Figura
5.1
observa
tipo
variables
llamadas
variables
internas
bloque
indica
circuito
capaz
mantener
entradas
valor
tiempo
lector
deducir
sistema
evolucionarÃ¡
distintos
internos
arribar
estable
Efectivamente
valor
variables
entrada
dete
rminado
salidas
combinacional
adoptarÃ¡n
realimentan
salidas
combinacional
cambiarÃ¡n
nuevamente
proceso
llamado
evoluciÃ³n
automÃ¡tica
sistema
repetirÃ¡
valor
variables
internas
coincida
estable
variables
internas
deja
pasar
izquierda
derecha
momentos
obtiene
Sistema
Secuencial
SÃ­ncrono
muestra
Figura
5.2
103
Fig
5.1
Sistema
Secuencial
AsÃ­ncrono
Fig
5.2
Sistema
Secuencial
SÃ­ncrono
104
diseÃ±o
bÃ¡sico
sistemas
consiste
plantear
tabla
concepto
tiempo
funciÃ³n
lÃ³gica
depende
variables
independientes
depende
ejemplo
ğ‘“(ğ‘
observa
funciÃ³n
indicada
aparece
miembros
expresiÃ³n
carezca
sentido
interpretarse
ğ‘ğ‘¡+1
ğ‘“(ğ‘
ğ‘ğ‘¡
subÃ­ndice
t+1
interpreta
valor
adoptarÃ¡
conjunto
valores
tenÃ­an
variables
depende
instante
t.
1.2
caso
estudio
aclarar
conceptos
anteriores
plantea
resoluciÃ³n
problema
Considere
construcciÃ³n
Sistema
Digital
alarma
domiciliaria
posea
variables
entrada
Variable
entrada
sensor
ejemplo
proviene
sensor
puerta
Variable
entrada
inicializaciÃ³n
variable
salida
Variable
salida
sirena
sistema
deberÃ¡
funcionar
variable
tome
valor
activarÃ¡
salida
activada
permanecerÃ¡
condiciÃ³n
salida
quedarÃ¡
activada
variable
pase
variable
toma
valor
desactivarÃ¡
salida
desactivada
permanecerÃ¡
condiciÃ³n
salida
quedarÃ¡
desactivada
variable
pase
valer
simultÃ¡neamente
propone
tabla
Tabla
5.1
concepto
tiempo
explicado
105
Tabla
5.1
Tabla
sistema
secuencial
ejemplo
entradas
combinacional
Ã¡n
variables
izquierda
indican
produce
combinaciÃ³n
variables
entrada
importa
valor
adopte
t+1
implementar
circuito
realiza
mapa
Karnaugh
funciÃ³n
Fi
gura
5.3
presenta
caso
funciÃ³n
forma
minterms
Figura
5.4
caso
maxterms
t+1
ï“3
t+1
ï3
corresponden
minterms
maxterms
decidido
incluirlos
expresiones
obtenerse
minimizaciÃ³n
Ã³ptima
Fig
5.3
FunciÃ³n
ïï€®
106
Fig
5.4
FunciÃ³n
ï“ï€®
Figura
5.3
ğ‘„ğ‘¡+1
ğ‘„ğ‘¡
ğ‘…Ì…
ğ‘„ğ‘¡ğ‘…Ì…Ì¿Ì¿Ì¿Ì¿Ì¿Ì¿Ì¿Ì¿Ì¿Ì¿
resulta
circuito
Figura
5.5
Fig
5.5
Circuito
Biestable
SR
NAND
Figura
5.4
deducirse
circuito
figura
5.6
formado
compuertas
NOR
realimentadas
107
Fig
5.6
Circuito
Biestable
SR
NOR
conceptos
Ãºtiles
compuertas
lÃ³gicas
reales
diferencian
ideales
Poseen
tiempo
retardo
seÃ±al
lÃ³gica
tarda
tiempo
nulo
atravesar
compuerta
Disipan
calor
caracterÃ­stica
especial
importancia
Sistemas
Secuenciales
Efectivamente
figura
5.1
aparecen
elementos
necesarios
secuencial
funcione
elementos
estuvieran
lÃ­nea
lÃ³gica
deberÃ­a
Biestables
Figuras
5.5
5.6
elementos
aparecen
razÃ³n
funcionan
construidos
compuertas
reales
retardo
cumple
funciÃ³n
elementos
M.
II
seÃ±al
lÃ³gica
indicar
siguientes
partes
Figura
5.7
108
Fig
5.7
Componentes
seÃ±al
lÃ³gica
Biestables
2.1
IntroducciÃ³n
vio
problema
Biestables
secuenciales
poseen
estables
variables
internas
adoptar
caso
permanecerÃ¡n
indefinidamente
cambien
variables
entrada
secuenciales
simples
poseen
variable
interna
Biestables
representan
circuitos
base
construcciÃ³n
secuenciales
complejos
clasificar
Biestables
BIESTABLE
ASÃNCRONOS
SÃNCRONOS
ACTIVADOS
NIVEL
MAESTRO
ESCLAVO
ACTIVADOS
FLANCOS
109
2.2
Biestables
asÃ­ncronos
entradas
actÃºan
directamente
biestable
ejemplos
biestables
vistos
problema
alarma
domiciliaria
Fig
5.5
Fig
5.6
decirse
tabla
Tabla
5.1
vÃ¡lida
momento
2.3
Biestables
sÃ­ncronos
Biestables
cuentan
entrada
adicional
entrada
sincronismo
reloj
actÃºa
seÃ±al
Biestables
sÃ­ncronos
dividen
activados
nivel
maestro
esclavo
activados
flancos
Biestables
SÃ­ncronos
activados
nivel
biestables
tabla
vÃ¡lida
presencia
nivel
activo
entrada
sincronismo
figura
5.8
muestra
biestable
SR
sÃ­ncrono
nivel
observa
RS
asÃ­ncrono
agrega
circuito
disparo
Figura
5.8
muestra
SR
activado
nivel
Figura
5.8
SR
activado
nivel
Fig
5.8
Biestable
SR
sÃ­ncrono
nivel
Biestables
sÃ­ncronos
maestro
esclavo
110
formados
biestables
activados
nivel
Figura
5.9
muestra
biestable
SR
maestro
esclavo
observa
Ck
funcionando
biestable
maestro
momento
Ck
informaciÃ³n
maestro
pasa
esclavo
biestable
actÃºa
estuviera
activado
flanco
bajada
seÃ±al
sincronismo
obstante
diferencia
activados
flancos
ntradas
actÃºan
maestro
tiempo
Ck
Fig
5.9
Biestable
SR
maestro
esclavo
Biestables
activados
flancos
Biestables
entradas
actÃºan
presencia
flanco
subida
bajada
entrada
sincron
ismo
tabla
vÃ¡lida
instantes
Figura
5.10
muestra
SR
activado
flanco
SR
sÃ­ncrono
nivel
agrega
circuito
detecto
flancos
Figura
5.11
muestra
sÃ­mbolo
utilizado
tipo
biestables
Figura
5.11
muestra
SR
sincronizado
flanco
subida
Figura
5.11
muestra
SR
sincronizado
flanco
bajada
111
Fig
5.10
Biestable
SR
activado
flanco
Fig
5.11
RepresentaciÃ³n
biestables
activados
flanco
Biestables
SR
tabla
Dependiendo
clase
SR
tabla
vÃ¡lida
nivel
activo
flanco
activo
corresponda
forma
reducida
indicar
tabla
SR
indica
Tabla
5.2
Tabla
5.2
Tabla
biestable
SR
112
Tipos
Biestables
3.1
IntroducciÃ³n
tipos
Biestables
SR
biestable
JK
biestable
biestable
D.
encuentran
disponibles
clases
asÃ­ncronos
sÃ­ncronos
nivel
etc.
tablas
indicadas
Tabla
5.3
respectivamente
Tabla
5.3
Biestables
JK
D.
3.2
Biestables
JK
Tabla
5.3
t+1
Qâ€™t
salida
adopta
valor
opuesto
razÃ³n
aplicaciÃ³n
prÃ¡ctica
biestables
JK
sÃ­ncronos
activados
flancos
Figuras
5.12
5.13
muestran
biestables
JK
Fig
5.12
Biestable
JK
Maestro
Esclavo
SR
nivel
113
Fig
5.13
Biestable
JK
flanco
ascendente
SR
flanco
3.3
Biestables
disponibles
comercialmente
obtienen
biestable
JK
T.
obtenerse
biestable
flancos
3.4
Biestables
Tabla
5.3
muestra
tabla
biestable
concluye
carece
aplicaciÃ³n
biestable
asÃ­ncrono
biestables
disponen
comercialmente
sÃ­ncronos
nivel
Latch
Maestro
Esclavo
flanco
obtenerse
SR
sÃ­ncrono
Figura
5.14
JK
Figura
5.14
sincronismo
Figura
5.14
usarse
SR
nivel
maestroâ€“esclavo
flanco
resultarÃ¡
biestable
nivel
maestroâ€“esclavo
flanco
respectivamente
Fig
5.14
supone
JK
maestro-esclavo
flanco
114
Fig
5.14
Biestable
implementado
biestables
SR
JK
Aplicaciones
Biestables
biestables
secuenciales
bÃ¡sicos
capaces
memorizar
bit
infinidad
aplicaciones
principales
encuentran
Memorias
electrÃ³nicas
desarrolladas
CapÃ­tulo
Registros
Contadores
4.1
Registros
desplazamiento
sistema
secuencial
sÃ­ncrono
almacena
bits
informaciÃ³n
formato
informaciÃ³n
tipos
serie
bits
transfieren
lÃ­nea
paralelo
transfieren
simultÃ¡neament
registros
clasificarse
Registros
Desplazamiento
Entrada
serie
salida
serie
Entrada
serie
salida
paralela
Entrada
paralela
salida
serie
II
Registros
propiamente
dichos
Registros
Entrada
paralela
salida
paralela
115
Registros
desplazamiento
serie
serie
considerarÃ¡
registros
cantidad
bits
almacenados
principalmente
caso
serie
serie
Figuras
5.15
5.16
observan
registros
bits
Fig
5.15
Registro
desplazamiento
bits
serie
serie
Fig
5.16
Registro
desplazamiento
paralelo
serie
bits
116
Registros
propiamente
dichos
Consisten
conjunto
biestables
sincronizados
nivel
flancos
cuyas
entradas
sincronismo
encuentran
unidas
extensivo
sistema
digital
Figura
5.17
muestra
registro
bits
cuyas
salidas
provistas
inversores
tri-estado
conectarse
bus
Fig
5.17
Registro
paralelo
paralelo
bits
4.2
Transferencias
registros
actividad
Sistema
Digital
transferencia
contenidos
distintos
registros
GuÃ­a
DidÃ¡ctica
presenta
computadora
elemental
funcionamiento
basa
transferencia
registros
Lenguajes
ProgramaciÃ³n
Hardware
permiten
diseÃ±ar
sistemas
digitales
basÃ¡ndose
transferencias
registros
comÃºn
estructuras
117
aparece
bus
conjunto
lÃ­neas
lÃ³gicas
transporta
informaciÃ³n
encuentran
colgados
registros
registros
actuar
elementos
interconexiÃ³n
bus
distintas
unidades
funcionales
registros
almacenamiento
tempo
rario
informaciÃ³n
exclusivamente
Figura
5.18
presenta
forma
interconexiÃ³n
registros
llamada
BUS
COMÃšN
registros
bits
entradas
registros
conectadas
Unidad
Funcional
ALU
ejemplo
funcionando
caso
registro
salida
salidas
registros
conectadas
Unidad
Funcional
Unidad
Memoria
ejemplo
funcionando
cas
registro
entrada
Figura
indica
deberÃ­an
seÃ±ales
control
cabo
transferencia
registros
seÃ±ales
control
generadas
general
Unidad
Control
Bus
eficie
ncia
depende
medida
prestaciones
velocidad
procesamiento
Sistema
Digital
forma
construir
sistema
interconexiÃ³n
registros
usando
registros
salida
tri
-estado
indicado
Figura
5.17
ejemplo
apreciarse
Figura
5.19
figura
aprecian
registros
salida
tri
-estado
registro
entradas
salidas
informaciÃ³n
poseen
entradas
control
Enable
Control
salida
manejadas
Unidad
Control
Bus
Unidades
Funcionales
SupÃ³ngase
ejemplo
Unidad
Funcional
procesado
informaciÃ³n
necesario
transferirla
Registro
finalmente
procesada
Unidad
Funcional
II
jemplo
Unidad
Control
Bus
deberÃ¡
118
Fig
5.18
InterconexiÃ³n
registros
bus
comÃºn
Fig
5.19
InterconexiÃ³n
registros
usando
registros
tri-estado
119
Recibir
Unidad
Funcional
seÃ±al
listo
Unidad
Funcional
dispone
informaciÃ³n
carga
Registro
Enable
envÃ­a
seÃ±al
listo
Unidad
Control
Bus
Activar
seÃ±al
Salida
Control
vuelca
bus
contenido
Registro
A.
Activar
seÃ±al
Enable
cargar
Registro
informaciÃ³n
presente
Bus
Desactivar
seÃ±ales
Salida
Control
Enable
C.
Indicar
Unidad
Funcional
II
Registro
informaciÃ³n
procesar
Unidad
Funcional
II
recibir
seÃ±al
Unidad
Control
Bus
lee
contenido
Registro
seÃ±al
Salida
Control
C.
visto
intuir
importancia
Bus
Sistemas
Digitales
CapÃ­tulo
desarrolla
Sistema
Dig
ital
basado
estructura
Von
Newman
Bus
unidad
4.3
Contadores
sistema
secuencial
formado
biestables
lÃ³gica
combinacional
capaz
almacenar
binario
cÃ³digo
cantidad
impu
lsos
recibidos
entrada
aplicarse
divisor
frecuencia
control
tiempos
generador
direcciones
sistemas
memoria
secuenciador
unidades
control
etc.
Contadores
AsÃ­ncronos
secuenciales
sÃ­ncronos
formados
conjunto
biestables
sÃ­ncronos
flancos
denominaciÃ³n
asÃ­ncrono
refiere
tipo
secuencial
entradas
sincronismo
biestables
unidas
general
salida
biestable
sirve
entrada
sincronismo
Figura
5.20
muestra
contador
binario
bits
asÃ­ncrono
obsÃ©rvese
salidas
biestables
conectan
entradas
sincronismo
verse
diagrama
tiempo
contador
120
Fig
5.20
Contador
asÃ­ncrono
bits
Diagrama
circuital
Diagrama
tiempo
Contadores
SÃ­ncronos
similares
anteriores
comparten
seÃ±al
reloj
rÃ¡pidos
complejos
asÃ­ncronos
Figura
5.21
muestra
contador
binario
natural
sÃ­ncrono
bits
NÃ³tese
diferencia
Figura
5.20
contador
entradas
sincronismo
biestables
unidas
complejo
puesto
compuertas
Fig
5.21
Contador
binario
natural
bits
sÃ­ncrono
diseÃ±o
contadores
realiza
planteando
tabla
temporal
obtener
funciones
correspondientes
minimizan
teniendo
biestable
elegido
biestables
utilizados
121
contadores
registros
desplazamiento
biestables
sÃ­ncrono
maestro
esclavo
activados
flancos
4.4
MultiplicaciÃ³n
divisiÃ³n
binaria
multiplicaciÃ³n
divisiÃ³n
binaria
implican
circuitos
naturaleza
combinacional
secuencial
momento
adecuado
mencionar
principales
caracterÃ­sticas
4.4.1
MultiplicaciÃ³n
binaria
multiplicaciÃ³n
sucesiÃ³n
sumas
multiplicar
nÃºmeros
MULTIPLICANDO
multiplicador
obtener
PRODUCTO
deberÃ­amos
sumar
MULTIPLICADOR
tantas
indique
multiplicando
Veremos
ALU
procesador
incluye
sumador
tonces
multiplicaciÃ³n
resolver
software
programa
procese
sumas
mencionadas
soluciÃ³n
requiere
tiempo
producto
variable
alto
resolver
problema
elevado
tiempo
producto
dependiente
valor
factores
implementar
multiplicador
hardware
caso
ALU
incluye
hardware
circuito
multiplica
alternativas
construir
multiplicador
hardware
Multiplicador
paralelo
concurrente
Multiplicador
serie
secuencial
Multiplicador
paralelo
Consiste
aplicar
algoritmo
multiplicaciÃ³n
conocemos
escuela
primaria
ejemplo
nÃºmeros
binarios
bits
1001
0110
0000
1001
1001
0000
0110110
122
hacerse
observaciones
resultado
bits
pretendemos
producto
bits
deberemos
chequear
rebasamiento
multiplicamos
nÃºmeros
bits
producto
superar
mÃ¡xima
cantidad
representable
bits
consideran
nÃºmeros
signo
datos
convertir
nÃºmeros
positivos
tratar
bit
signo
separadamente
multiplicar
valores
absolutos
Finalmente
deberÃ¡
expresar
resultado
convenio
representaciÃ³n
nÃºmeros
negativos
utilizado
circuito
Figura
5.22
ejemplifica
hardware
multiplicador
paralelo
bits
detector
rebasamiento
overflow
suma
comienza
inyectan
circuito
MULTIPLICANDO
M3M2M1M0
multiplicador
m3m2m1m0
conjunto
compuertas
AND
realizan
paralelo
productos
parciales
sumarÃ¡n
sumadores
bits
conectados
serie
compuerta
OR
genera
overflow
tiempo
producto
TPp
circuito
ğ‘‡ğ‘ƒğ‘
ğ‘‡ğ‘ğ‘›ğ‘‘
3ğ‘‡ğ‘ ğ‘¢ğ‘šğ‘ğ‘‘ğ‘œğ‘Ÿ
Tand
tiempo
retardo
compuerta
AND
Tsumador
tiempo
retardo
SUMADOR
BITS
123
Fig
5.22
Multiplicador
paralelo
bits
generaciÃ³n
overflow
tomamos
unidad
retardo
retardo
AND
llamamos
ğ‘‡ğ‘ƒğ‘
ğ‘‡ğ‘ğ‘›ğ‘‘
3.4ğ‘‡ğ‘ğ‘›ğ‘‘
Tsumador
4Tand
caso
general
multiplicador
bits
tiempo
producto
aum
enta
nÃºmero
bits
aumenta
significativamente
complejidad
hardware
ejemplo
consideremos
multiplicadores
32
bits
caso
necesitan
31
sumadores
32
bits
lograr
tiempos
suma
supuestos
ejempl
ğ‘‡ğ‘ƒğ‘
ğ‘‡ğ‘ğ‘›ğ‘‘
4(ğ‘›
1)ğ‘‡ğ‘ğ‘›ğ‘‘
4ğ‘›
3)ğ‘‡ğ‘ğ‘›ğ‘‘
124
bits
requieren
generadores
acarreo
anticipado
32
bits
complica
hardware
Multiplicador
serie
secuencial
aproximaciÃ³n
simplifica
hardware
mejora
promedio
TP
nÃºmero
bits
elevado
utiliza
Ãºnico
sumador
cambian
adecuadamente
entradas
desplazamiento
funcionamiento
implica
secuencia
seÃ±ales
control
motivo
llama
multiplicador
secuencial
multiplicador
ALU
procesador
secuencia
seÃ±ales
control
generarse
circuito
control
especial
Unidad
Control
Cableada
CapÃ­tulo
llama
multiplicaciÃ³n
serie
hardware
microprograma
Unidad
Control
Microprogramada
CapÃ­tulo
llama
multiplicaciÃ³n
firmware
Figura
5.23
observa
multiplicador
serie
bits
Fig
5.23
Multiplicador
serie
bits
generador
overflow
RD1
RD2
registros
desplazamiento
paralelo-serie
bits
cuyo
contenido
aparece
salidas
inferiores
diagrama
seÃ±ales
controlan
RD
125
borra
RD
CP1
carga
RD1
CP2
carga
RD2
Ck
desplaza
bit
derecha
contenidos
RD1
RD2
continuaciÃ³n
describe
funcionamiento
multiplicador
borrados
RD
suministra
MULTIPLICANDO
multiplicador
carga
RD2
seÃ±al
CP2
dispara
secuencia
BIT
espera
SUMADOR
BITS
resultado
carga
RD1
seÃ±al
CP1
BIT
pasamos
desplaza
derecha
contenidos
RD1
RD2
seÃ±al
Ck
Terminar
repetido
saltar
tiempo
multiplicaciÃ³n
TPs
circuito
ğ‘‡ğ‘ƒğ‘ 
ğ‘‡ğ‘ğ‘1
ğ‘‡ğ‘ ğ‘¢ğ‘šğ‘ğ‘‘ğ‘œğ‘Ÿ
ğ‘‡ğ‘‘
Tcp1
tiempo
carga
RD1
Tsumador
tiempo
suma
SUMADOR
BITS
Td
tiempo
necesario
desplazar
contenidos
RD1
RD2
aproximamos
ğ‘‡ğ‘ğ‘1
ğ‘‡ğ‘‘
ğ‘‡ğ‘ ğ‘¢ğ‘šğ‘ğ‘‘ğ‘œğ‘Ÿ
4ğ‘‡
ğ‘‡ğ‘ƒğ‘ 
2ğ‘‡
4ğ‘‡)4
caso
multiplicador
bits
tiempo
producto
multiplicador
1s
ğ‘‡ğ‘ƒğ‘ 
6ğ‘›ğ‘‡
multiplicador
0s
ğ‘‡ğ‘ƒğ‘ 
ğ‘›ğ‘‡
Finalmente
consideramos
promedio
nÃºmeros
cantidad
1s
0s
tiempo
multiplicaciÃ³n
media
126
aumenta
nÃºmero
bits
complejidad
hardware
aumenta
significativamente
caso
multiplicador
paralelo
ejemplo
construir
multiplicador
serie
32
bits
necesario
Ãºnico
sumador
32
bits
registros
desplazamiento
16
bits
Tabla
5.4
comparan
tiempos
producto
aproximados
alternativas
planteadas
Tabla
5.4
Comparativa
aproximada
tiempos
producto
ve
multiplicadores
serie
rÃ¡pidos
complejos
multiplicadores
paralelo
vÃ¡lido
comentar
multiplicador
paralelo
paralelizamos
acarreos
salida
sumadores
parciales
componen
lograrÃ­amos
tiempo
producto
independiente
nÃºmero
bits
factor
TPp
estarÃ­a
orden
ğ‘‡ğ‘ƒğ‘
5ğ‘‡
ğ‘‡ğ‘”ğ‘
Tga
tiempo
propagaciÃ³n
generador
acarreo
anticipado
bits
tiempo
menor
vistos
anteriormente
resulta
hardware
complejo
ğ‘‡ğ‘ƒğ‘ 
3,5ğ‘›ğ‘‡
127
4.4.2
DivisiÃ³n
binaria
DIVISIÃ“N
sucesiÃ³n
RESTAS
DIVIDIR
nÃºmeros
DIVIDENDO
divisor
obtener
COCIENTE
RESTO
deberÃ­amos
restar
DIVIDENDO
divisor
tantas
obtener
RESTO
menor
DIVISOR
dijimos
anteriormente
ALU
procesador
incluye
sumador
divisiÃ³n
resolver
software
programa
soluciÃ³n
consume
tiempo
divisiÃ³n
variable
alto
resolver
problema
ALUs
incluyen
hardware
circuito
implementa
divisiÃ³n
caso
aplica
algoritmo
divisiÃ³n
aprende
tempranamente
escuela
ejemplo
divisiÃ³n
entera
nÃºmeros
binarios
signo
bits
1101
0010
10
0110
10
10
01
algoritmo
describirse
Tomamos
MSB
DIVIDENDO
comparamos
divisor
menor
divisor
colocamos
COCIENTE
representarÃ¡
MSB
COCIENTE
tomamos
MSB
DIVIDENDO
comparamos
nuevamente
menor
divisor
colocamos
COCIENTE
Segui
mos
menor
caso
restamos
bits
considerados
DIVIDENDO
divisor
colocamos
COCIENTE
Seguimos
procedimiento
agotar
bits
DIVIDENDO
resultado
resta
divisiÃ³n
resolver
hardware
divisiÃ³n
construirse
divisores
paralelos
concurrentes
divisores
serie
secuenciales
resultan
circuitos
complejidad
cambio
divisores
serie
resultan
circuitos
relativamente
simples
128
Figura
5.24
observa
ejemplo
divisor
serie
bits
Fig
5.24
Circuito
divisor
serie
bits
RD1
RD2
registros
desplazamiento
paralelo
serie
disponibilidad
contenidos
comparador
compara
RESTO
contenido
RD1
divisor
salida
compuerta
OR
indica
RESTO
divisor
generar
cociente
biestable
S-R
determinar
realiza
resta
operan
resultado
identificados
forma
DIVIDENDO
D3D2D2D0
entrada
Divisor
d3d2d1d0
entrada
COCIENTE
C3C2C1C0
salida
129
RESTO
R3R2R1R0
salida
funcionamiento
circuito
describir
secuencia
repetirse
tantas
bits
tengan
nÃºmeros
inicializa
RD1
RD2
biestable
SR
desplaza
bit
izquierda
RD1
RD2
Ck1
Ck2=1
repeticiÃ³n
desplazar
RD1
Ck1
terminar
contenido
RD2
COCIENTE
contenido
RD1
RESTO
RD1
divisor
resta
carga
resultado
RD1
Ck1
RD1
menor
divisor
faltan
repeticiones
saltar
tabla
5.5
presenta
verificaciÃ³n
funcionamiento
1101
0010
tiempo
divisiÃ³n
circuito
similar
tiempo
producto
TPs
3,5nT
Comparando
Figuras
5.23
5.24
ve
circuitos
Multiplicador
Divisor
similares
disponemos
sumador
restador
registros
desplazam
iento
reversibles
desplacen
izquierda
derecha
seÃ±al
control
hardware
multiplicar
dividir
caso
multiplicador
serie
divisor
serie
ALU
controlarse
seÃ±ales
control
generadas
hardware
Unidad
Control
cableada
caso
ALU
divisiÃ³n
hardware
seÃ±ales
control
generadas
microprograma
Unidad
Control
microprogramada
ALU
divisiÃ³n
firmware
130
Tabla
5.5
Secuencia
control
circuito
divisor
Figura
5.24
EjercitaciÃ³n
Ejercicio
tabla
biestable
131
Ejercicio
Explicar
significado
cuadro
brevedad
sintetiza
utilizaciÃ³n
biestable
J-K
R-S
D.
Ejercicio
Deducir
flip
-flop
sÃ­ncrono
asÃ­ncrono
funcionamiento
Ejercicio
Determinar
cÃ³digo
usando
registro
desplazamiento
biestables
-K.
Suponer
inicialmente
QO
Ql
Q2
Q3=0
132
Ejercicio
diagramas
bloque
registros
desplazamiento
entrada
serie
salida
serie
entrada
serie
salida
paralelo
entrada
paralelo
salida
serie
entra-da
paralelo
salida
paralelo
Ejercicio
biestable
SR
obtener
JK
biestable
JK
obtener
biestable
T.
biestable
SR
obtener
biestable
D.
Ejercicio
Determinar
Sistema
combinacional
necesario
indicar
contadores
binarios
alcanzado
valor
equivalente
decimal
52
inicie
conteo
nuevamente
133
CAPÃTULO
Memorias
ElectrÃ³nicas
VisiÃ³n
General
1.1
IntroducciÃ³n
1.2
ClasificaciÃ³n
memorias
electrÃ³nicas
Memorias
Acceso
Aleatorio
RAM
2.1
DefiniciÃ³n
2.2
Memorias
RAM
lectura
escritura
2.3
Memorias
RAM
lectura
ROM
2.4
ExtensiÃ³n
longitud
palabra
capacidad
Memorias
Acceso
Serie
3.1
DefiniciÃ³n
3.2
Registros
desplazamiento
3.3
Memorias
FIFO
3.4
Memorias
LIFO
EjercitaciÃ³n
134
CapÃ­tulo
Memorias
ElectrÃ³nicas
VisiÃ³n
General
1.1
IntroducciÃ³n
memorias
dispositivos
almacenamiento
datos
instrucciones
computadora
Llamamos
sistema
memoria
conjunto
dispositivos
algoritmos
hardware
software
control
Diversos
dispositivos
capaces
almacenar
informaciÃ³n
deseable
procesador
tuviese
acceso
inmediato
ininterrumpido
memoria
lograr
velocidad
procesamiento
Desafortunadamente
memorias
velocidades
similares
procesador
caras
razÃ³n
informaciÃ³n
almacenada
distribuye
forma
compleja
variedad
memorias
caracterÃ­sticas
fÃ­sicas
distintas
clasificaciÃ³n
funcional
memorias
Memoria
interna
Constituida
registros
internos
CPU
Unidad
Central
Procesos
Procesador
tipo
memoria
estudia
CapÃ­tulo
caracteriza
alta
velocidad
Memoria
central
principal
Almacena
programas
datos
relativamente
rÃ¡pida
accedida
directamente
CPU
bus
tipo
memoria
GuÃ­a
DidÃ¡ctica
Memoria
secundaria
almacenamiento
programas
sistema
archivos
capacidad
anteriores
lenta
acceso
CPU
indirecto
principales
tecnologÃ­as
magnÃ©tica
Ã³ptica
definir
parÃ¡metros
generales
aplicables
memorias
Unidad
almacenamiento
Bit
135
Capacidad
almacenamiento
Cantidad
bits
almacenarse
unidad
almacenamiento
bit
byte
encontramos
capacidades
Kb
1Kb
1024
bytes
Mb
1Mb
1024
Kb
Gb
1Gb
1024
Mb
etc
memorias
consideran
organiz
adas
palabras
palabra
conjunto
bits
accede
simultÃ¡neamente
Tiempo
acceso
ta
tarda
leer
escribir
palabra
memoria
momento
direcciona
velocidad
acceso
ba=1
ta
mide
palabras
Figura
6.1
Tipo
acceso
Acceso
aleatorio
tiempo
acceso
similar
posiciÃ³n
Acceso
serie
tiempo
acceso
depende
posiciÃ³n
ocupa
palabra
memoria
Tiempo
ciclo
tc
Indica
mÃ­nimo
tiempo
accesos
sucesivos
memoria
tiempo
tc
tiempo
ta
ancho
banda
memoria
define
inversa
tc
indicativo
cantidad
palabras
procesables
unidad
tiempo
fÃ­sico
ElectrÃ³nicas
construidas
semiconductores
MagnÃ©ticas
basadas
fenÃ³meno
histÃ©resis
materiales
ferromagnÃ©ticos
Ã“pticas
utilizan
tecnologÃ­a
lÃ¡ser
Estabilidad
Volatilidad
contenido
memoria
pierde
suspende
alimentaciÃ³n
elÃ©ctrica
Almacenamiento
dinÃ¡mico
bit
almacena
carga
capacidad
parÃ¡sita
transistor
MOS
informaciÃ³n
pierde
capacitor
descarga
necesario
refresco
periÃ³dic
restaurar
contenido
deteriore
Lectura
destructiva
DRO
efectuar
lectura
pierde
informaciÃ³n
proceso
acompaÃ±arse
restauraciÃ³n
Tabla
6.1
136
Fig
6.1
Tiempo
acceso
palabras
seg
funciÃ³n
costo
/bit
Tabla
6.1
ClasificaciÃ³n
memorias
usando
principales
caracterÃ­sticas
137
1.2
ClasificaciÃ³n
memorias
electrÃ³nicas
memorias
electrÃ³nicas
considerarse
sistema
digital
mixto
combinacional
secuencial
capaz
almacenar
informaciÃ³n
binaria
acceder
introducir
extraer
informaciÃ³n
parcialmente
momento
funciÃ³n
tipo
acceso
memorias
clasifican
Memorias
acceso
aleatorio
RAM
ta
similar
posiciÃ³n
subdividen
Memorias
lectura
escritura
llamadas
activas
caracterizan
ta
lectura
escritura
similares
presentan
volatilidad
pierden
contenido
dejan
alimentadas
subdividen
Memorias
estÃ¡ticas
SRAM
Memoria
dinÃ¡micas
DRAM
Memorias
lectura
ROM
llamadas
pasivas
caracterizan
ta
escritura
lectura
presentan
volatilidad
pierden
contenido
alimentaciÃ³n
subdividen
ROM
graban
fabricante
PROM
graban
usuario
EPROM
graban
usuario
borrado
realiza
luz
ultravioleta
EEPROM
graban
usuario
borrado
realiza
elÃ©ctricamente
posiciÃ³n
posiciÃ³n
FLASH
graban
usuario
borrado
realiza
elÃ©ctricamente
Memorias
acceso
serie
tiempo
acceso
ta
depende
posiciÃ³n
palabra
memoria
memorias
lectura
escritura
subdividen
Registros
desplazamiento
Memorias
pila
LIFO
escritura
lectura
Memorias
cola
FIFO
escritura
lectura
138
Memorias
Acceso
Aleatorio
RAM
2.1
DefiniciÃ³n
60
aparecen
circuitos
integrados
permiten
construir
memorias
alta
capacidad
Actualmente
encuentran
memorias
semiconductoras
orden
Gb
considerar
memoria
conjunto
posiciones
formada
celdas
cÃ©lulas
elementales
esquema
general
memoria
acceso
aleatorio
verse
Figura
6.2
diagrama
bloque
Figura
6.3
Fig
6.2
Esquema
general
memoria
RAM
tipo
celda
depend
clase
memoria
trate
tecnologÃ­a
utilizada
RAM
lectura
escritura
celdas
consisten
biestables
asÃ­ncronos
estudiados
CapÃ­tulo
RAM
lectura
ROM
consisten
diodos
transistores
139
Fig
6.3
Diagrama
bloques
memoria
RAM
memorias
RAM
operan
direcciÃ³n
conjunto
bits
transfiere
registro
direcciones
decodificador
direcciones
procesa
direcciÃ³n
selecciona
posiciÃ³n
memoria
posiciÃ³n
seleccionada
lee
escribe
funciÃ³n
seÃ±ales
control
lectura
contenido
posiciÃ³n
seleccionada
transfiere
registro
datos
salida
bits
escritura
caso
RAM
lectura
escritura
transfiere
registro
datos
entrada
cargado
anteriormente
posiciÃ³n
seleccionada
organizaciÃ³n
interna
memorias
RAM
2D
3D
OrganizaciÃ³n
2D
Bidimensional
celdas
organizan
matriz
dimensiones
filas
vienen
dadas
nÃºmero
palabras
columnas
longitud
cantidad
bits
palabra
Figura
6.4
celda
binaria
accede
lÃ­nea
selecciÃ³n
organizaciÃ³n
memorias
pequeÃ±a
capacidad
140
Fig
6.4
Esquema
memoria
RAM
2D.
OrganizaciÃ³n
3D
Tridimensional
celda
binaria
accede
lÃ­neas
selecciÃ³n
activaciÃ³n
simultÃ¡nea
ambas
determina
selecciÃ³n
celda
logra
reducir
tamaÃ±o
decodificadores
Figura
6.5
Fig
6.5
Esquema
memoria
RAM
3D.
destaca
cantidad
lÃ­neas
salidas
decodificador
organizaciÃ³n
2D
LS2D
cantidad
lÃ­neas
direccionamiento
141
valor
cantidad
lÃ­neas
salidas
decodificador
reduce
organizaciÃ³n
3D
LS3D
m/2
considerando
decodificadores
iguales
reducciÃ³n
lÃ­neas
logra
costa
agregar
decodificador
compuerta
AND
palabra
2.2
Memorias
RAM
lectura
escritura
2.2.1
Memorias
RAM
lectura
escritura
estÃ¡ticas
elemento
bÃ¡sico
celda
elemental
memorias
consiste
biestable
asÃ­ncrono
estudiado
GuÃ­a
DidÃ¡ctica
compuertas
adicionales
manejar
selecciÃ³n
control
celda
Figura
6.6
muestra
celda
bÃ¡sica
caso
organizaciÃ³n
2D.
observa
lÃ­nea
selecciÃ³n
activa
lÃ³gico
habilita
celda
lectura
escritura
Ì…â„
operaciÃ³n
lectura
entradas
biestable
bloquean
habilita
compuerta
AND
salida
Ì…â„
bloquea
compuerta
AND
salida
habilita
entrada
biestable
Figura
6.7
muestra
celda
bÃ¡sica
caso
organizaciÃ³n
3D.
142
Fig
6.6
Celda
bÃ¡sica
organizaciÃ³n
2D.
Fig
6.7
Celda
bÃ¡sica
organizaciÃ³n
3D.
observa
compuerta
AND
entradas
completa
selecciÃ³n
143
Figura
6.8
muestra
RAM
lectura
escritura
organizaciÃ³n
interna
2D
celda
bÃ¡sica
Figura
16
palabras
bits
Fig
6.8
RAM
lectura
escritura
organizaciÃ³n
2D.
lÃ­neas
acceso
externas
memoria
LÃ­neas
direccionamiento
A0
A3
Bus
direcciones
lÃ­neas
unidireccionales
externas
selecciÃ³n
palabra
acceder
16
combinaciones
posibles
bits
asociados
lÃ­neas
LÃ­neas
datos
01
O3
Bus
datos
lÃ­neas
bidireccionales
externas
actuar
entradas
salidas
lograr
lÃ­neas
bidireccionales
buffer
triestado
forma
evita
lÃ­neas
entrada
salida
independientes
144
SeÃ±ales
control
lectura
escritura
Ì…â„
Ì…â„
lee
memoria
Ì…â„
escribe
memoria
SeÃ±ales
control
ğ¶ğ‘†Ì…Ì…Ì…Ì…
lÃ­neas
datos
colocan
alta
impedancia
ğ¶ğ‘†Ì…Ì…Ì…Ì…
Ì…â„
lÃ­neas
datos
externas
conectan
lÃ­neas
datos
entrada
interiores
memoria
lÃ­neas
datos
salida
interiores
memoria
colocan
alta
impedancia
ğ¶ğ‘†Ì…Ì…Ì…Ì…
Ì…â„
lÃ­neas
datos
externas
conectan
lÃ­neas
datos
salida
interiores
memoria
lÃ­neas
datos
entrada
interiores
memoria
colocan
alta
impedancia
ğ‘‚ğ¸Ì…Ì…Ì…Ì…
deshabilitan
circuitos
salida
memoria
seÃ±ales
ğ¶ğ‘†Ì…Ì…Ì…Ì…
Ì…â„
Ciclo
lectura
ciclo
escritura
correcta
operaciÃ³n
memoria
necesita
temporizaciÃ³n
adecuada
seÃ±ales
aplicadas
lÃ­neas
Tabla
6.2
presentan
combinaciones
posibles
lÃ­neas
control
escritura
lectura
habilitaciÃ³n
memoria
representada
esquemÃ¡ticamente
Figura
6.9
Tabla
6.2
Combinaciones
lÃ­neas
control
escritura
lectura
variedad
memorias
requiere
temporizaciÃ³n
fabricante
provee
diagramas
tiempo
involucran
seÃ±ales
memoria
Figuras
6.10
observa
diagrama
tiempo
operaciÃ³n
lectura
escritura
memoria
general
145
ciclo
lectura
escritura
comienza
aplicaciÃ³n
direcciÃ³n
lÃ­neas
direccionamiento
bus
direcciones
lÃ­nea
ğ¶ğ‘†Ì…Ì…Ì…Ì…
ğ¶ğ¸Ì…Ì…Ì…Ì…
ve
Tabla
6.2
cero
momento
Fig
6.9
Diagrama
bloques
memoria
RAM
estÃ¡tica
lectura
ğ‘ŠÌ…â„
ğ¸Ì…â„
colocarse
datos
leer
aparecerÃ¡n
lÃ­neas
salida
datos
Dout
cabo
tiempo
A.
tiempo
lectura
escritura
ğ‘ŠÌ…â„
colocarse
tiempo
mÃ­nimo
tAW
tiempo
fijaciÃ³n
direcciÃ³n
pasar
indicar
operaciÃ³n
escritura
valor
mantenerse
tiempo
tWP
ancho
pulso
escritura
garantizar
datos
hayan
almacenado
RAM
datos
escribir
lÃ­neas
entrada
datos
in
momento
aparece
direcciÃ³n
mantenerse
tiempo
tWP
tiempo
tiempo
ciclo
indicativo
cantidad
operaciones
sucesivas
unidad
tiempo
observa
tC
ta
146
Fig
6.10
Diagrama
tiempo
operaciÃ³n
lectura
escritura
2.2.2
Memorias
RAM
lectura
escritura
dinÃ¡micas
memorias
celda
bÃ¡sica
consiste
capacidad
parÃ¡sita
compuerta
transistor
MOS
circuitos
asociados
control
Puesto
pÃ©rdidas
inevitables
capacitor
descarga
necesario
restaurar
periÃ³dicamente
informaciÃ³n
proceso
llama
refresco
refresco
consiste
lectura
seguida
escritura
automÃ¡tica
ms
dependiendo
memoria
actuando
proceso
refresco
147
acceder
memoria
velocidad
memorias
menor
estÃ¡ticas
densidad
integraciÃ³n
apreciablemente
estructura
interna
memorias
generalmente
3D
nÃºmero
filas
ROW
columnas
COLUMN
bits
direcciÃ³n
divididos
m/2
filas
m/2
columnas
Figura
6.11
Generalmente
lÃ­neas
direcciÃ³n
multiplexadas
tiempo
exterior
suministran
m/2
bits
filas
cargan
registro
filas
seÃ±al
RAS
suministran
m/2
bits
columnas
cargan
registro
columnas
seÃ±al
CAS
reduce
bus
direcciones
mitad
Fig
6.11
Estructura
interna
memorias
RAM
escritura
lectura
dinÃ¡micas
DRAM
aplicaciÃ³n
direcciÃ³n
fila
provoca
celdas
fila
lean
restauren
lugar
operaciÃ³n
lectura
escritura
operaciÃ³n
refresco
realiza
Controlador
RAM
dinÃ¡mica
incluido
memoria
exterior
memorias
lentas
estÃ¡ticas
poseen
caracterÃ­stica
interesante
casos
necesario
leer
escribir
direcciones
consecutivas
memoria
caso
colocarse
datos
fila
necesario
cambiar
direcciÃ³n
columna
operaciÃ³n
traduce
148
velocidades
mayores
estÃ¡ticas
posibl
complejo
aprovecharlo
generalidad
casos
2.3
Memorias
RAM
lectura
ROM
memorias
programadas
realizan
operaciones
lectura
volÃ¡tiles
utilizarse
almacenar
cÃ³digos
generadores
caracteres
funciones
aritmÃ©ticas
complejas
unidades
control
microprogramadas
almacenamiento
partes
sistema
operativo
BIOS
organizaciÃ³n
interna
memorias
similar
RAM
lectura
escritura
arte
entrada
salida
sencilla
necesario
considerar
salidas
sucede
lÃ­neas
control
ROM
memorias
RAM
suele
utilizar
tÃ©rmino
referencia
memorias
lectura
escritura
2.3.1
Memorias
ROM
construcciÃ³n
utilizan
diodos
transistores
conexiones
indica
conexiones
indica
verse
Figura
6.12
presencia
elemento
acoplador
diodo
realiza
fabricante
suministrarle
informaciÃ³n
requerida
Fig
6.12
Esquema
conexiones
memoria
ROM
diodos
utilizan
elementos
acopladores
conexiÃ³n
diodos
lÃ­nea
implementa
funciÃ³n
OR
seÃ±ales
149
entrada
decirse
ROM
2n
bits
combinacional
variables
entrada
funciones
salidas
bus
datos
Figura
6.12
triestado
permitir
conexiÃ³n
memoria
bus
comÃºn
2.3.2
Memorias
PROM
elementos
conexiÃ³n
diodos
transistores
fusible
serie
Inic
ialmente
memoria
presenta
conexiones
establecidas
programaciÃ³n
consiste
destruir
fusible
lugares
almacenarse
direccionando
palabra
deseado
inyectando
corriente
adecuada
salidas
conexiÃ³n
queda
abierta
existiera
elemento
acoplador
deduce
programada
memoria
volver
Internamente
memorias
similares
ROM
verse
Figura
6.13
grabaciÃ³n
memorias
necesario
utilizar
equipos
grabaciÃ³n
especiales
disponibles
comercialmente
2.3.3
Memorias
RPROM
diferencia
anteriores
memorias
RPOM
reescritas
usuario
necesario
contar
eq
uipos
grabaciÃ³n
especÃ­ficos
tipo
memoria
grabaciÃ³n
realiza
memoria
circuito
conectada
distinguen
tipos
RPROM
EPROM
celdas
constituidas
puertas
flotantes
transistores
MOS
descarga
realiza
luz
ultravioleta
exponiendo
celda
minutos
reprogramaciÃ³n
elÃ©ctrica
aplicando
tensiones
superiores
funcionamiento
permanente
vuelva
grabarse
EEPROM
Similares
anteriores
diferencia
borrado
posiciÃ³n
posiciÃ³n
elÃ©ctricamente
casos
realizarse
memoria
inserta
circuito
FLASH
Similares
anteriores
borrado
realiza
simultÃ¡neamente
posiciones
150
Fig
6.13
Esquema
conexiones
memoria
ROM
2.4
ExtensiÃ³n
longitud
palabra
capacidad
aumentar
capacidad
memoria
partiendo
circuitos
integrados
menor
capacidad
lograrse
aumentando
longitud
palabra
cantidad
2.4.1
ExtensiÃ³n
longitud
palabra
Figura
6.14
observa
memoria
palabras
k.m
bits
partiendo
CI
palabras
bits
lÃ­neas
direcciÃ³n
control
compartidas
CI
lÃ­neas
datos
amplÃ­an
k.m
bits
151
Fig
6.14
Memoria
palabras
k.m
bits
2.4.2
ExtensiÃ³n
nÃºmero
palabras
Figura
6.15
observa
memoria
2kN
palabras
bits
partiendo
CI
palabras
bits
lÃ­neas
direcciÃ³n
necesarias
interconectan
CI
seleccionar
2p
palabras
CI
resto
lÃ­neas
direcciÃ³n
inyectan
decodificador
cuyas
salidas
conectan
lÃ­neas
selecciÃ³n
CS
CI
seÃ±al
ğ‘ŠÌ…â„
comÃºn
CI
bus
datos
comÃºn
CI
gracias
tecnologÃ­a
triestados
CI
ampliar
longitud
palabra
cantidad
suman
tÃ©cnicas
indicadas
ejemplo
interesante
observar
Figura
6.16
Finalmente
disponemos
memorias
RAM
palabras
bits
pretendemos
memoria
palabras
bits
procede
calcula
nÃºmero
Chips
NÃºmero
CIs
Entero
Nâ€™/N
calcula
decodificador
entradas
2k
NÃºmero
CIs
baja
direcciÃ³n
conecta
lÃ­neas
direcciÃ³n
CIs
lÃ­neas
2p
alta
direcciÃ³n
bits
conecta
entradas
decodificador
salidas
decodificador
conectan
entradas
selecciÃ³n
CS
CI
lÃ­neas
datos
conectan
bus
comÃºn
bits
152
Fig.6.15
Memoria
2kN
palabras
k.m
bits
153
Fig.6.16
Memoria
ejemplo
Memorias
Acceso
Serie
3.1
DefiniciÃ³n
tiempo
escritura
lectura
posiciÃ³n
depende
situaciÃ³n
fÃ­sica
interior
memoria
escribir
leer
memorias
preciso
pasar
posiciones
anteriores
Figura
6.17
154
Fig
6.17
Esquema
memoria
serie
memorias
serie
nformaciÃ³n
organizarse
formas
OrganizaciÃ³n
bit
bit
disponen
serie
palabras
bits
conforman
Figuras
6.18
6.19
memoria
posee
lÃ­nea
entrada
informaciÃ³n
salida
ispone
lÃ­neas
control
lectura
escritura
Fig
6.18
Esquema
memoria
serie
bit
bit
Fig
6.19
Detalles
memoria
serie
bit
bit
OrganizaciÃ³n
posiciÃ³n
posiciÃ³n
disponen
palabras
serie
bits
conforman
paralelo
Figuras
6.20
6.21
caso
entradas
informaciÃ³n
salidas
informaciÃ³n
lÃ­neas
control
presentes
memorias
clasificar
tipos
Registros
desplazamiento
memorias
FIFO
memorias
LIFO
155
Fig
6.20
Esquema
memoria
serie
posiciÃ³n
posiciÃ³n
Fig
6.21
Detalles
memoria
serie
posiciÃ³n
posiciÃ³n
3.2
Registros
desplazamiento
informaciÃ³n
desplaza
posiciÃ³n
sentido
orden
lectura
escritura
orden
externa
desplazamiento
constituida
impulsos
generador
reloj
clock
tipos
registros
desplazamiento
estÃ¡ticos
dinÃ¡micos
156
3.2.1
Registros
desplazamiento
estÃ¡ticos
impulsos
desplazamiento
anularse
tiempo
indefinido
informaciÃ³n
almacenada
pierda
constituidos
biestables
sÃ­ncronos
activados
flancos
Figura
6.22
Fig
6.22
Esquema
registro
desplazamiento
estÃ¡tico
3.2.2
Registros
desplazamiento
dinÃ¡micos
impulsos
desplazamiento
anularse
informaciÃ³n
perderÃ­a
celda
elemental
caso
capacidad
parÃ¡sita
puerta
transistor
MOS
similar
DRAM
sencillez
celdas
alta
densidad
integraciÃ³n
permitido
construir
CI
capacidad
costo
restaurar
informaciÃ³n
registros
salidas
conectan
entradas
forma
informaciÃ³n
circula
permanentemente
registro
sincrÃ³nicamente
impulsos
reloj
circuito
Figura
6.23
funciona
corre
ctamente
realice
operaciÃ³n
lectura
escritura
concluir
necesario
agregar
circuitos
permitan
operaciones
lectura
escritura
casos
deberÃ¡
adicionar
circuito
exterior
permitir
operaciones
mencionadas
157
Fig
6.23
Esquema
registro
desplazamiento
dinÃ¡mico
caso
lectura
propone
circuito
Figura
6.24
escritura
circuito
Figura
6.25
Fig
6.24
Circuito
operaciÃ³n
lectura
158
Fig
6.25
Circuito
operaciÃ³n
escritura
invita
alumno
interpretar
funcionamiento
circuitos
ciclos
lectura
escritura
3.3
Memorias
FIFO
memorias
serie
informaciÃ³n
entra
sale
First
Input
First
Output
Figura
6.26
indica
FIFO
bloque
funcionamiento
observa
Figura
6.27
memorias
FIFO
implementarse
registros
desplazamiento
estÃ¡ticos
unidad
control
siguientes
caracterÃ­sticas
tipo
memoria
lectura
destructiva
leer
dato
leÃ­do
memoria
operaciÃ³n
lectura
escritura
produci
desplazamiento
resto
memoria
memoria
llena
escribirse
Unidad
Control
deberÃ¡
capaz
generar
seÃ±al
Memoria
llena
159
Generar
seÃ±ales
control
necesarias
dato
escrito
estÃ©
disponible
lectura
DeberÃ¡
aceptar
entradas
exteriores
seÃ±al
lectura
escritura
seÃ±al
inicio
ciclo
seÃ±al
sincronismo
Fig
6.26
Esquema
memoria
FIFO
Fig
6.27
Funcionamiento
memoria
FIFO
Figura
6.28
muestra
diagrama
bloques
simplificado
memoria
FIFO
implementada
registro
desplazamiento
estÃ¡tico
FIFO
encuentran
CI
LSI
aplicaciones
acoplar
sis
temas
digitales
velocidades
procesamiento
Figura
6.29
sistema
rÃ¡pido
llenando
FIFO
lento
160
vaciando
capacidad
memoria
acorde
diferencia
velocidades
tamaÃ±o
bloque
transferir
Fig
6.28
Diagrama
bloques
memoria
FIFO
implementada
registro
desplazamiento
estÃ¡tico
Fig
6.29
Ejemplo
aplicaciÃ³n
memoria
FIFO
sistemas
digitales
3.4
Memorias
LIFO
memorias
informaciÃ³n
entra
sale
Last
Input
First
Output
Figura
6.30
indica
diagrama
bloque
Figura
6.31
funcionamiento
memoria
LIFO
LIFO
implementarse
registro
desplazamiento
reversible
verse
Figura
6.32
registro
desplazamiento
reversible
formado
biestables
sÃ­ncronos
multiplexores
salida
memoria
salida
biestable
entrada
canal
multiplexor
sugiere
alumno
interpretar
Figura
6.32
ciclos
lectura
escritura
161
diagrama
bloque
LIFO
indicado
Figura
6.33
Fig
6.30
Esquema
memoria
LIFO
Fig
6.31
Funcionamiento
memoria
LIFO
162
Fig
6.32
Diagrama
bloques
memoria
LIFO
implementada
registro
desplazamiento
reversible
Fig
6.33
Diagrama
bloque
LIFO
EjercitaciÃ³n
Ejercicio
Determinar
valor
n1
n2
memoria
Kbytes
64
Kbytes
1Mbytes
4096
palabras
32
bits
65536
palabras
16
bits
524288
palabras
64
bits
163
Ejercicio
bits
direccionamiento
necesarios
localizaciÃ³n
palabra
memoria
256
posiciones
1024
Ejercicio
bits
posee
memoria
32Kx8
32
cantidad
posiciones
direccionar
cantidad
bits
posiciÃ³n
palabra
bits
direccionamiento
necesarios
Ejercicio
memorias
RAM
256
posiciones
bits
necesitarÃ¡n
direcciona
ambas
obtener
memoria
512
posiciones
conexiÃ³n
Ejercicio
memoria
partiendo
pastillas
Ejercicio
Indique
cantidad
biestables
memoria
RAM
Gbytes
Ejercicio
Suponga
memoria
Mbytes
tamaÃ±o
decodificadores
tÃ©cnicas
2D
3D
respectivamente
Memoria
Acceso
Aleatorio
RAM
Bus
Direcciones
Bus
Datos
164
Ejercicio
Suponga
determinado
sistema
control
almacenar
temperatura
sensores
hora
24
hs
temperatura
viene
dada
dÃ­gitos
p.
ej.
100.6
028.7
grados
centÃ­grados
registro
temperaturas
meses
cuyos
valores
mÃ¡ximo
mÃ­nimo
esperables
150
10
Â°C
capacidad
memoria
necesitarÃ­a
registro
Considere
lectura
codificar
dÃ­gitos
BCD
forma
binaria
ASCII
seleccionar
forma
demande
capacidad
memoria
Ejercicio
Teniendo
tamaÃ±o
memoria
definida
ejercicio
tiempo
llenarÃ¡
dicha
memoria
sensores
registran
valores
minutos
Ejercicio
10
circuito
combinacional
acepta
nÃºmero
trada
bits
codificado
binario
natural
genera
cuadrado
salidas
correspondientes
Escribir
tabla
circuito
obtendrÃ­a
funcionamiento
remplazando
circuito
combinacional
memoria
ROM
tamaÃ±o
memoria
ROM
Mostrar
esquema
conexiones
pertinente
165
CAPÃTULO
Arquitectura
BÃ¡sica
Computadora
Arquitectura
Von
Neumann
MÃ¡quina
Elemental
2.1
IntroducciÃ³n
2.2
Arquitectura
computadora
elemental
2.3
conjunto
instrucciones
2.4
ciclo
mÃ¡quina
2.5
Flujo
informaciÃ³n
2.6
Unidad
control
2.7
Unidad
control
microprogramada
2.8
Bus
mÃ¡quina
elemental
2.9
Unidad
aritmÃ©tica
lÃ³gica
EjercitaciÃ³n
166
CapÃ­tulo
Arquitectura
BÃ¡sica
Computadora
Arquitectura
Von
Neumann
estructura
bÃ¡sica
computadora
compuesta
elementos
Figura
7.1
Unidad
Proceso
Central
CPU
Unidad
Memoria
UM
Unidad
Entrada
Salida
UE
Unidad
Buses
UB
Programa
Almacenado
UM
PA
Fig
7.1
Estructura
bÃ¡sica
computadora
elementos
funcionamiento
reciben
nombre
Arquitectura
Computadoras
John
von
Neumann
recuerdo
principales
propulsores
1903
-1957
utilizaremos
definiciÃ³n
COMPUTADORA
167
comÃºn
referenciar
elementos
HARDWARE
quinto
SOFTWARE
funcionamiento
Computadora
implica
fuerte
cooperaciÃ³n
unidades
componen
supone
memoria
reside
conjunto
ordenado
INSTRUCCIONES
llamado
PROGRAMA
Funcionamiento
INSTRUCCIONES
PROGRAMA
buscadas
ejecutadas
secuencialmente
CPU
programa
finaliza
ejecuciÃ³n
instrucciÃ³n
necesario
obtener
datos
guardar
resultados
UM
obtener
datos
enviarlos
UE
necesario
coordinar
movimiento
datos
UM
UE
S.
CPU
UNIDAD
PROCESAMIENTO
CENTRAL
Unidad
Central
Procesos
Procesador
REGISTROS
REGISTROS
usados
principalmente
almacenar
temporalmente
informaciÃ³n
datos
direcciones
instrucciones
Unidad
AritmÃ©tica
LÃ³gica
ALU
ALU
realiza
operaciones
lÃ³gico-aritmÃ©ticas
necesarias
eventualmente
ejecuciÃ³n
instrucciÃ³n
Unidad
Control
UC
UC
CPU
realiza
concretamente
control
sistema
genera
conjunto
seÃ±ales
control
Ã³rdenes
diseminan
Sistema
UM
UNIDAD
MEMOR
IA
almacena
programas
datos
principalmente
memoria
RAM
lectura
escritura
necesario
leer
escribir
obstante
porciÃ³n
UM
ROM
almacenar
programas
tipo
datos
cambien
deber
Ã­an
permanecer
quite
alimentaciÃ³n
UE
UNIDAD
ENTRADA
SALIDA
encarga
interconectar
computadora
dispositivos
externos
perifÃ©ricos
accesibles
usuario
teclado
monitor
impresora
etc.
uales
ingresar
extraer
informaciÃ³n
CPU
UE
cuentan
INTERFACES
generalmente
realizan
adaptaciÃ³n
niveles
elÃ©ctricos
seÃ±ales
CONTROLADORES
sistemas
digitales
controlar
perifÃ©ricos
especÃ­ficos
168
UB
UNIDAD
BUSES
cumple
funciÃ³n
transportar
informaciÃ³n
unidades
Sistema
tipo
informaciÃ³n
clasificarse
buses
BUS
DATOS
Transporta
Operandos
Instrucciones
BUS
DIRECCIONES
Transporta
Direcciones
BUS
CONTROL
Transporta
seÃ±ales
Control
PA
PROGRAMA
ALMACENADO
conjunto
INSTRUCCIONES
almacenadas
correlativamente
Unidad
Memoria
programas
comienzo
instrucciones
mÃ¡quina
conocen
Set
Instrucciones
MÃ¡quina
Elemental
2.1
IntroducciÃ³n
estudiar
arquitectura
computadora
definida
presentaremos
MÃ¡quina
Elemental
utilizando
planteo
Caxton
Foster
libro
Arquitectura
Computadoras
Previo
desarrollo
necesario
distinguir
mÃ¡quinas
asÃ­ncronas
sÃ­ncronas
primeras
Ã³rdenes
emitidas
UC
suceden
secuencialmente
cambio
sÃ­ncronas
Ã³rdenes
emitidas
UC
forma
sÃ­ncrona
seÃ±al
sincronismo
externa
llamada
reloj
mÃ¡quinas
asÃ­ncronas
rÃ¡pidas
sÃ­ncronas
acciones
ordenadas
UC
tardan
tarda
hardware
involucrado
sÃ­ncronas
acciones
tardan
periodo
reloj
ventaja
mencionada
mÃ¡quinas
construyen
sÃ­ncronas
simplicidad
hardware
inferir
UC
mÃ¡quina
asÃ­ncrona
deberÃ¡
contar
hardware
adicional
detecte
finalizaciÃ³n
acciones
ordenadas
implica
complicaciÃ³n
justifica
ganancia
tiempo
resultarÃ­a
caracterÃ­sticas
principales
computadora
Arquitectura
von
Neumman
sistema
binario
aritmÃ©tica
complemento
169
memoria
4096
16
4096
posiciones
memoria
16
bits
punto
fijo
datos
16
bits
15
bits
mantisa
bit
signo
observa
Figura
7.2
Fig
7.2
Formato
datos
numÃ©ricos
punto
fijo
instrucciones
formato
fijo
16
bits
bits
cÃ³digo
operaciÃ³n
12
bits
campo
direcciÃ³n
presentan
Figura
7.3
Fig
7.3
Formato
instrucciones
BUS
comÃºn
16
bits
multiplexado
datos
direcciones
ALU
realiza
operandos
siguientes
operaciones
ADD
OR
XOR
AND
RAL
NOT
Capacidad
manejar
128
perifÃ©ricos
170
Externamente
consola
llaves
pulsadores
luces
permite
operador
comunicarse
MÃ¡quina
aspecto
muestra
Figura
7.4
Fig
7.4
Consola
mÃ¡quina
elemental
Diagrama
Bloques
MÃ¡quina
Elemental
presenta
Figura
7.5
171
Fig
7.5
Diagrama
bloques
mÃ¡quina
elemental
2.2
Arquitectura
computadora
elemental
2.2.1
Unidad
procesamiento
central
CPU
REGISTROS
ACC
16
bits
registro
Acumulador
registro
propÃ³sitos
generales
utiliza
distintos
fines
172
16
bits
registro
Instrucciones
registro
propÃ³sito
especial
utiliza
guardar
instrucciÃ³n
buscado
memoria
PC
12
bits
registro
Contador
Programa
registro
propÃ³sitos
especiales
utiliza
guardar
direcciÃ³n
memoria
prÃ³xima
instrucciÃ³n
buscar
Registro
16
bits
Registro
16
bits
Registros
Operandos
entrada
ALU
registros
propÃ³sito
especial
accedidos
programador
bit
re
gistro
propÃ³sito
especial
Permite
generar
ALU
realiza
operaciones
lÃ³gico
-aritmÃ©ticas
mencionadas
operandos
ubicados
registros
Y.
Genera
seÃ±al
OV
overflow
resultado
suma
aritmÃ©tica
supera
capacidad
representaciÃ³n
UC
Unidad
Control
entrada
sincronismo
genera
Ã³rdenes
sincronismo
flancos
Reloj
tipos
Unidades
Control
UC
Cableada
UC
Microprogramada
2.2.2
Unidad
memoria
UM
memoria
RAM
lectura
escritura
vistas
anteriormente
Posee
registro
asociado
lÃ­neas
datos
llamado
MBR
16
bits
pasarÃ¡
informaciÃ³n
lea
escriba
memoria
posee
registro
asociado
lÃ­neas
direcciÃ³n
llamado
MAR
12
bits
cuyo
contenido
deberÃ¡
direcciÃ³n
memoria
pretende
acceder
RAM
Tiempo
Acceso
400
ns
2.2.3
Unidad
Entrada
Salida
dispositivos
entrada
salida
observan
casos
CONSOLA
conectada
directamente
BUS
interior
posee
hardware
posibilita
comunicaciÃ³n
CPU
pulsadores
16
llaves
16
luces
Registro
Llaves
16
bits
reflejan
16
llaves
binarias
16
luces
indican
contenido
pulsadores
definidos
Pulsador
ARRANQUE
Start
Pulsador
PARADA
Stop
173
Pulsador
CARGAR
PC
Load
PC
AcciÃ³n
Transfiere
contenido
SR
PC
Pulsador
DEPOSITAR
Deposite
AcciÃ³n
Transfiere
contenido
SR
posiciÃ³n
memoria
indicada
PC
incrementa
PC
Pulsador
EXAMINAR
Examine
AcciÃ³n
Transfiere
contenido
posiciÃ³n
memoria
indicada
PC
incrementa
PC
Pulsador
RESET
Reset
AcciÃ³n
Borra
RAM
Registros
DISPOSITIVOS
EXTERNOS
llamados
perifÃ©ricos
P0
P63
entrada
P0
P63
salida
destinado
BUS
bidireccional
dedicado
bits
Datos
BUS
bits
selecciÃ³n
perifÃ©rico
hardware
inferfa
muestra
Figura
7.5
transferencias
entrada
salida
Blue
realizadas
control
programa
veremos
instrucciones
acumulador
ejecuta
instrucciÃ³n
entrada
salida
Unidad
Control
genera
seÃ±al
Transferencia
TRA
dispositivos
externos
dispositivo
seleccionado
responderÃ¡
seÃ±al
Ready
completa
do
tarea
tipo
control
llama
HANDSHAKING
2.3
Conjunto
instrucciones
anticipamos
computadora
posee
tipo
instrucciÃ³n
longitud
fija
16
bits
formato
Figura
7.6
Fig
7.6
Formato
instrucciones
bits
cÃ³digo
operaciÃ³n
dispone
sumo
16
instrucciones
presentan
Tabla
7.1
174
Tabla
7.1
Conjunto
instrucciones
descripciÃ³n
instrucciones
HLT
XXXX
Detiene
funcionamiento
computadora
Presionando
pulsador
START
consola
principal
computadora
arranca
nuevamente
siguiendo
ejecuciÃ³n
instrucciÃ³n
HALT
campo
direcciones
XXXX
ignora
175
ADD
XXXX
Realiza
suma
aritmÃ©tica
complemento
operandos
ubicados
acumulador
direcciÃ³n
memoria
expresada
campo
XXXX
deja
resultado
acumulador
contenido
direcciÃ³n
memoria
XXXX
cambia
dato
encontraba
acumulador
resultado
suma
215-1
menor
215
computadora
detiene
XOR
XXXX
Realiza
OR
-Exclusiva
bit
bit
operandos
ubicados
acumulador
dire
cciÃ³n
memoria
expresada
campo
XXXX
deja
resultado
acumulador
contenido
direcciÃ³n
memoria
XXXX
cambia
dato
encontraba
acumulador
AND
XXXX
Realiza
AND
bit
bit
operan
ubicados
acumulador
direcciÃ³n
memoria
expresada
campo
XXXX
deja
resultado
acumulador
contenido
direcciÃ³n
memoria
XXXX
cambia
dato
encontraba
acumulador
IOR
XXXX
Realiza
OR
bit
bit
operandos
ubicados
acumulador
direcciÃ³n
memoria
expresada
campo
XXXX
deja
resultado
acumulador
contenido
direcciÃ³n
memoria
XXXX
cambia
dato
qu
encontraba
acumulador
NOT
XXXX
bit
dato
acumulador
remplazado
complemento
lÃ³gico
direcciÃ³n
memoria
XXXX
ignora
LDA
XXXX
contenido
ubicaciÃ³n
memoria
XXXX
copia
acumulador
contenido
direcciÃ³n
memoria
XXXX
cambia
dato
encontraba
acumulador
STA
XXXX
contenido
acumulador
copia
direcciÃ³n
memoria
XXXX
contenido
acumulador
cambia
dato
encontraba
direcciÃ³n
memoria
176
SRJ
XXXX
Sirve
salto
programa
subrutina
realiza
copia
contador
programa
12
bits
bajos
acumulador
bits
altos
acumulador
ponen
ceros
copia
nÃºmero
XXXX
contador
programa
prÃ³xima
instrucciÃ³n
tomada
dicha
direcciÃ³n
JMA
XXXX
Produce
salto
direcciÃ³n
programa
bit
signo
acumulador
deci
acumulador
contiene
nÃºmero
negativo
cumple
dicha
condiciÃ³n
copia
nÃºmero
XXXX
contador
programa
prÃ³xima
instrucciÃ³n
toma
direcciÃ³n
cumple
condiciÃ³n
bit
signo
acumulador
cero
dato
acumulador
positivo
cero
instrucciÃ³n
realiza
programa
normalmente
JMP
XXXX
Produce
salto
incondicional
programa
copia
nÃºmero
XXXX
contador
programa
prÃ³xima
instrucciÃ³n
ejecutar
toma
direcciÃ³n
XXXX
INP
XXYY
bits
peso
acumulador
colocan
cero
carÃ¡cter
bits
viene
dispositivo
externo
YY
coloca
baja
acumulador
XX
campo
direcciÃ³n
ignora
prÃ³xima
instrucciÃ³n
ejecuta
transferencia
dato
completado
OUT
XXYY
bits
significativos
acumulador
envÃ­an
dispositivo
externo
YY
XX
campo
direcciÃ³n
ig
nora
dispositivo
externo
aceptar
dato
momento
computadora
espera
podido
trasferencia
RAL
XXXX
bits
acumulador
rotan
lugar
izquierda
bit
AC15
coloca
ACo
desplazamiento
cÃ­clico
campo
direcciones
XXXX
ignora
CSA
XXXX
nÃºmero
registro
llaves
introducido
llaves
consola
copia
acumulador
campo
direcciones
XXXX
ignora
177
NOP
XXXX
instrucciÃ³n
campo
direcciones
XXXX
ignora
2.4
Ciclo
instrucciÃ³n
llama
ciclo
instrucciÃ³n
computadora
procedimiento
consta
tareas
necesarias
buscar
ejecutar
completamente
instrucciÃ³n
programa
almacenado
memoria
sintetizar
forma
BÃºsqueda
instrucciÃ³n
memoria
Lectura
interpretaciÃ³n
instrucciÃ³n
EjecuciÃ³n
Almacenamiento
resultados
PreparaciÃ³n
leer
prÃ³xima
instrucciÃ³n
computadora
elemental
BLUE
ciclo
instrucciÃ³n
bÃ¡sico
compuesto
partes
CICLO
BÃšSQUEDA
CICLO
EJECUCIÃ“N
Ciclo
BÃºsqueda
instrucciÃ³n
almace
memoria
apuntada
Contador
Programa
PC
localiza
memoria
copia
Registro
Instrucciones
RI
nÃºmero
almacenado
PC
incrementa
logrando
apunte
prÃ³xima
celda
memoria
instrucciÃ³n
completar
Ciclo
bÃºsqueda
instrucciÃ³n
analiza
decodifica
ejecuta
presente
instrucciÃ³n
necesita
bÃºsqueda
memoria
dato
operando
ciclo
mÃ¡quina
termina
momento
necesario
buscar
operando
memoria
comienza
Ciclo
EjecuciÃ³n
acceso
memoria
traer
operando
necesario
completar
instrucciÃ³n
2.5
Flujo
informaciÃ³n
analizar
instrucciones
detalle
mostraremos
movimientos
informaciÃ³n
registros
mÃ¡quina
Flujo
direcciones
addreses
MÃ¡quina
Elemental
movimientos
registros
12
bits
Figura
7.7
178
Load
PC
envÃ­a
12
bits
bajos
registro
llaves
SR
PC
Saltos
JMP
JMA
SRJ
envÃ­an
12
bits
bajos
PC
SRJ
salto
subrutina
envÃ­a
12
bits
PC
Acumulador
ACC
BÃºsqueda
instrucciÃ³n
envÃ­a
12
bits
PC
MAR
BÃºsqueda
Operando
envÃ­a
12
bits
bajos
RI
MAR
Flujo
instrucciones
operandos
MÃ¡quina
Elemental
movimientos
registros
16
bits
Figura
7.8
CSA
copia
16
bits
SR
ACC
Deposit
copia
16
bits
SR
MBR
Instrucciones
copian
MBR
RI
LDA
copia
16
bits
MBR
ACC
STA
copia
16
bits
ACC
MBR
Operaciones
ALU
ciclo
ejecuciÃ³n
Copia
16
bits
ACC
Registro
ALU
Copia
16
bits
MBR
Registro
ALU
Resultado
salida
ALU
copia
ACC
posibles
transferencias
vistas
necesario
implementar
esquema
relaciÃ³n
registros
memoria
unidades
ejemplo
BUS
COMUN
elegido
MÃ¡quina
Elemental
PUNTO
PUNTO
179
Fig
7.7
transmisiÃ³n
direcciones
Blue
Fig
7.8
transmisiÃ³n
instrucciones
operandos
Blue
180
2.6
Unidad
control
mÃ¡quinas
sÃ­ncronas
Unidades
Control
SÃ­ncronas
entrada
sincronismo
reloj
emite
pulsos
periodos
tiempos
fijos
frecuencia
reloj
pulso
realizan
tareas
ventaja
mantiene
distintas
tareas
dispositivo
orden
secuencia
hardware
sencillo
desventaja
tarea
tiempo
duraciÃ³n
ciclo
reloj
tarea
unidad
control
coordinar
acciones
mÃ¡quina
trabajo
neces
ita
secuencia
pulsos
seÃ±ales
generarse
sincrÃ³nicamente
reloj
maneras
diseÃ±ar
Unidad
Control
Unidad
Control
Cableada
Unidad
Control
Microprogramada
Ambas
verse
caja
negra
exactament
entradas
salidas
diferencia
implementaciÃ³n
interna
2.6.1
Unidad
Control
Cableada
Figura
7.9
presenta
Diagrama
Bloques
Unidad
Control
Cableada
integrada
siguientes
componentes
DECODIFICADOR
INSTRUCCIONES
Sistema
Combinacional
decodificador
binario
entradas
16
salidas
utiliza
determinar
instrucciÃ³n
contiene
entradas
IR12
IR15
181
Fig
7.9
Diagrama
bloques
Unidad
Control
Cableada
SECUENCIADOR
Sistema
Secuencial
MÃ¡quina
182
SECUENCIADOR
consta
Figura
7.10
biestables
definir
distintos
mencionados
RUN
arranque
biestable
Set
-Reset
arranca
pone
salida
botÃ³n
START
pone
salida
botÃ³n
STOP
instrucciÃ³n
HALT
detecciÃ³n
overflow
aritmÃ©tico
STATE
biestable
condiciones
salidas
determinar
ciclo
bÃºsqueda
Fetch
ciclo
ejecuciÃ³n
Execute
biestable
relacionado
TRA
transferencia
biestable
Set-Reset
pone
inicia
transferencia
pone
recibe
seÃ±a
Ready
perifÃ©rico
discute
biestable
tareas
relacionadas
Pulsadores
EXA
DEP
reloj
externo
Mhz
LÃ“GICA
CONTROL
Sistema
Combinacional
consiste
conjunto
compuertas
generan
seÃ±ales
control
2.6.2
Secuenciador
seÃ±al
sincronismo
oscilador
Mhz
llamado
RELOJ
divide
secuencia
pulsos
llamado
CICLO
MEMORIA
lÃ­neas
distintas
separadas
tiempo
125
ns
RUN
mÃ¡quina
funcionando
contador
pulsos
reloj
comenzando
inicialmente
cero
salidas
contador
conectadas
entradas
decodificador
binario
cuyas
salidas
pulsos
125
ns
BÃšSQUEDA
EJECUCION
FUNCIONANDO
RUN
DETENIDA
STOP
183
llega
1001
CP9
contador
borra
comienza
CICLO
MEMORIA
pulso
CP9
sincronizar
biestable
borrar
biestable
SR
nombre
instrucciÃ³n
proceso
ciclo
toma
valor
caso
instrucciones
ciclo
toma
valor
forma
mÃ¡quina
pasa
CICLO
BÃšSQUEDA
CICLO
EJECUCIÃ“N
automÃ¡ticamente
CP8
NÃ³tese
mÃ¡quina
arranca
RUN
presionar
pulsador
START
detiene
presionar
STOP
OV
instrucciÃ³n
HLT
BÃšSQUEDA
biestable
SR
genera
seÃ±al
TRA
perifÃ©ricos
condiciones
ven
Figura
7.10
recibe
seÃ±al
READY
perifÃ©ricos
pone
cero
pulsadores
EXA
DEP
funcionan
RUN
disparan
Ãºnico
CICLO
MEMORIA
Figura
7.11
muestra
diagrama
tiempo
secuenciador
aparecen
CP1
CP8
CP9
CICLO
MEMORIA
menor
duraciÃ³n
Ciclo
BÃºsqueda
biestable
RUN
arranca
reloj
biestable
STATE
BÃºsqueda
inicia
ciclo
bÃºsqueda
mÃ¡quina
mÃ¡quina
carga
instrucciÃ³n
cuya
direcciÃ³n
PC
registro
instrucciones
necesita
operador
cargado
PROGRAMA
Memoria
direcciÃ³n
instrucciÃ³n
PC
Consola
secuencia
ciclo
bÃºsqueda
presenta
Tabla
7.2
184
Fig
7.10
Diagrama
bloques
secuenciador
Fig
7.11
Diagrama
tiempos
secuenciador
185
pulso
reloj
copia
contenido
contador
programa
PC
registro
direcciones
memoria
MAR
registro
ALU
inicia
ciclo
lectura
memoria
pulso
reloj
coloca
nÃºmero
+1
registro
ALU
pulso
reloj
esperamos
realice
suma
PC
pulso
copia
resultado
suma
salida
ALU
contador
Programa
incrementa
PC
listo
indicar
prÃ³xima
instrucciÃ³n
pulso
copia
dato
memoria
registro
buffer
memoria
MBR
pulso
copia
contenido
MBR
registro
instrucciÃ³n
culmina
Ciclo
BÃºsqueda
instrucciÃ³n
cuestiÃ³n
req
uiere
ejecuciÃ³n
acceder
memoria
dato
utilizar
pulsos
reloj
ejecutar
instrucciones
BLUE
caso
instrucciones
HALT
NOP
JMP
JMA
SRJ
CSA
NOT
RAL
indica
Tabla
7.2
finalizan
ciclo
memoria
asignado
BÃºsqueda
necesitan
ciclo
memoria
llamamos
instrucciones
ciclo
bÃºsqueda
ejecuciÃ³n
instrucciones
realizan
ciclo
memoria
finalizar
ciclo
bÃºsqueda
empieza
ciclo
asignarse
nuevamente
BÃºsqueda
Tabla
7.2
Ciclo
bÃºsqueda
186
instrucciÃ³n
requiere
ejecuciÃ³n
acceder
memoria
instrucciones
INP
OUT
necesario
asignar
ciclo
EjecuciÃ³n
Ciclo
EjecuciÃ³n
instrucciones
requieren
dato
memoria
operaciÃ³n
lÃ³gica
matemÃ¡tica
transferencia
datos
memoria
requieren
segu
ndo
ciclo
memoria
LDA
STA
ADD
XOR
AND
IOR
acceder
memoria
necesario
ciclo
memoria
observa
Tabla
7.3a
7.3b
instrucciones
requieren
ciclo
acceden
memor
ia
ejecuciÃ³n
caso
particular
instrucciones
INP
OUT
Utilizan
ciclos
esperar
perifÃ©rico
involucrado
tantos
ciclos
tiempo
espera
Tabla
7.4
187
Tabla
7.3
EjecuciÃ³n
instrucciones
ciclos
188
Tabla
7.4
Ciclo
bÃºsqueda
instrucciones
INP
OUT
Figura
7.12
hardware
relacionado
Entrada
Salida
detalle
189
Fig
7.12
LÃ³gica
funcionamiento
S.
2.6.3
LÃ³gica
control
observa
Figura
7.13
entradas
bloque
combinacional
cÃ³digos
operaciÃ³n
decodificados
pulsos
reloj
BÃºsqueda
EjecuciÃ³n
salidas
Ã³rdenes
concretas
emite
unidad
control
aclarar
consiste
hardware
bloqu
LÃ“GICA
CONTROL
veamos
ejemplo
casos
UC
emitir
orden
CARGAR
MAR
mÃ¡quina
parada
presiona
pulsador
EXA
DEP
CP1
mÃ¡quina
funcionando
BÃºsqueda
CP1
mÃ¡quina
funcionando
EjecuciÃ³n
instrucciones
LDA
STA
ADD
IOR
AND
XOR
CP1
190
circuito
control
deberÃ¡
mÃ¡quina
parada
biestable
significa
producirÃ¡
Ãºnica
secuencia
pulsos
CP1
CP8
operador
presionÃ³
EXA
DEP
Fig
7.13
Vista
parcial
lÃ³gica
control
recuadro
indica
retardo
50
ns
permitir
establezca
BUS
verÃ¡
poste
riormente
Circuitos
similares
planteado
corresponderÃ¡n
seÃ±ales
emitidas
Unidad
Control
2.7
Unidad
control
microprogramada
esquema
general
mÃ¡quina
elemental
unidad
control
microprogramada
simplemente
microprogramada
observa
Figura
7.14
ObsÃ©rvese
Ãºnico
cambiado
mÃ¡quina
elemental
Unidad
Control
parecido
arquitectura
von
Neumman
llamado
MÃQUINA
INTERIOR
bÃºsqueda
ejecuciÃ³n
macroinstrucciÃ³n
realizadas
micro
programas
residentes
micro
-ROM
contenido
ROM
microprogramas
ROM
llama
FIRMWARE
direcciÃ³n
microinstrucciÃ³n
ejecutar
proporcionada
cÃ³digo
operaciÃ³n
macroinstrucciÃ³n
16
primeras
posiciones
microinstrucciÃ³n
compuesta
45
bits
divididos
campos
AcciÃ³n
Test
EnvÃ­e
Reciba
Falso
Ã‰xito
significado
verse
Tabla
campo
AcciÃ³n
relacionado
Ã³rdenes
Unidad
Control
191
leer
memoria
escribir
memoria
etc.
campo
Test
relaciona
necesidad
chequear
mÃ¡quina
momento
Bit
15
acumulador
seÃ±al
overflow
etc.
campos
EnvÃ­e
Reciba
enviar
contenidos
registros
bus
levantarlos
campos
falso
Ã©xito
relacionados
resultado
chequeo
indicado
campo
Test
definen
prÃ³xima
microinstrucciÃ³n
ejecutar
NÃ³tese
mÃ¡quina
interior
posee
contador
programa
Tabla
7.5
verse
contenido
ROM
microprogramas
correspondientes
instrucciÃ³n
Fig
7.14
MÃ¡quina
elemental
unidad
control
microprogramada
192
MicroinstrucciÃ³n
MÃ¡quina
Microprogramada
Tabla
7.5
Formato
microinstrucciÃ³n
mÃ¡quina
elemental
microprogramada
193
circuito
UNIDAD
CONTROL
MICROPROGRAMADA
observa
Figura
7.15
ObsÃ©rvese
contenido
micro-MAR
biestables
Figura
orÃ­genes
Contenido
campo
FALSO
caso
salida
multiplexor
cero
Contenido
campo
Ã‰XITO
caso
salida
multiplexor
cÃ³digo
operaciÃ³n
macrointrucciÃ³n
residente
registro
instrucciones
caso
bit
campo
acciÃ³n
Cero
caso
RESET
seÃ±al
proviene
botÃ³n
Master
Reset
consola
operador
casos
Unidad
Control
ejecutando
microprograma
correspondiente
macroinstrucciÃ³n
ciclo
bÃºsqueda
Tablas
6a
muestra
contenido
ROM
256
45
ejemplo
describirÃ¡
ciclo
bÃºsqueda
mÃ¡quina
microprograma
correspondiente
comienza
direcciÃ³n
rotulada
RNI
campo
AcciÃ³n
contenido
indicando
acciÃ³n
necesaria
campo
EnvÃ­e
envÃ­a
PC
bus
campo
Reciba
carga
MAR
bus
campo
test
verifica
alguien
apretado
botÃ³n
STOP
consola
apretado
prÃ³xima
microinstrucciÃ³n
direcciÃ³n
rotulada
HALT
apretado
prÃ³xima
microinstrucciÃ³n
RNI1
RNI1
RNI5
realiza
incremento
PC
carga
contenido
posiciÃ³n
memoria
direccionada
RNI6
orden
cargar
micro
-MAR
cÃ³digo
operaciÃ³n
macroinstrucciÃ³n
almacenada
bit
circuito
control
micro-MAR
194
Fig
7.15
Unidad
control
microprogramada
195
196
197
Tabla
7.6
Contenido
ROM
256
45
conveniente
anÃ¡lisis
microprogramas
comprender
funcionamiento
completo
GuÃ­a
DidÃ¡ctica
discuten
ventajas
desventajas
mÃ¡quinas
microprogramadas
facilidad
firmware
poseen
cantidad
instrucciones
contraposiciÃ³n
mÃ¡quinas
microprogramadas
poseen
caracterÃ­sticas
instrucciones
198
2.8
Bus
mÃ¡quina
elemental
analizamos
Ã³rdenes
emite
UC
Cableada
Microprogramada
concluir
mayorÃ­a
implica
transferencia
registros
exactitud
20
seÃ±ales
enviar
BUS
cargar
BUS
Ã³rdenes
implican
transferencias
LEER
ESCRIBIR
TRA
TRA
actividad
mÃ¡quina
resuelve
transfiriendo
registros
mencionado
registros
eficazme
nte
interconectados
lograrse
arquitectura
BUS
COMÃšN
tÃ©rmino
refiere
existirÃ¡
Ãºnico
BUS
interconecta
distintas
partes
MÃ¡quina
BUS
COMÃšN
transportar
dato
16
bits
instrucciÃ³n
16
its
direcciÃ³n
12
bits
distintos
momentos
razÃ³n
llama
bus
multiplexado
seÃ±ales
control
diseminadas
MÃ¡quina
BUS
especial
llamamos
BUS
CONTROL
Figura
7.16
observa
circuito
resuelve
requerimientos
seÃ±ales
control
Enviar
ACC
Cargar
MBR
seÃ±al
Cargar
MBR
retardada
tiempo
respuesta
biestable
compuertas
AND
OR
199
Fig
7.16
Circuito
resuelve
requerimientos
seÃ±ales
control
ObsÃ©rvese
enviar
registro
BUS
cargar
registro
BUS
simultÃ¡neamente
ejemplo
orden
ENVÃE
PC
CARGUE
MAR
conexiÃ³n
Registro
MBR
BUS
requiere
circuito
adicional
Registro
conectado
memoria
Figura
7.17
indica
conexiÃ³n
200
Fig
7.17
Circuito
asociado
Registro
MBR
2.9
Unidad
aritmÃ©tica
lÃ³gica
ALU
MÃ¡quina
Elemental
realiza
operaciones
AND
OR
IOR
XOR
ADD
operandos
contenidos
registros
Y.
operaciones
lÃ³gicas
realizan
bit
bit
suma
aritmÃ©tica
realiza
conveni
Complemento
acarreo
desprecia
Adicionalmente
ALU
realiza
operaciÃ³n
NOT
C1
RAL
rotaciÃ³n
bits
izquierda
contenido
Z.
operaciones
mencionadas
realiza
simultÃ¡nea
permanentemente
momento
calculando
resultados
contenido
registros
Y.
unidad
control
cargar
registros
operandos
seleccionar
salida
necesita
diagrama
bloques
ALU
observa
Figura
7.18
201
Fig
7.18
Diagrama
bloques
unidad
aritmÃ©tica
lÃ³gica
recomienda
lector
circuito
ALU
ejercitar
aprendido
ALU
16
Compuertas
AND
16
Compuertas
XOR
16
Compuertas
IOR
16
Compuertas
NOT
Sumador
16
bits
circuito
rebasamiento
OV
acarreo
C2
Compuertas
AND
OR
implementar
selecciÃ³n
salida
conveniente
mencionar
tiempo
tarda
ALU
suma
aritmÃ©tica
ADD
ayor
necesario
operaciones
lÃ³gicas
requieren
hardware
ciclos
mÃ¡quina
ALU
tarda
sumar
ADD
mÃ¡ximo
200
ns
resto
operaciones
80
ns
ALU
suma
UC
deberÃ­a
esperarla
pulso
reloj
caso
UC
Cableada
microinstrucciÃ³n
caso
UC
Microprogramada
Observe
Figuras
7.10
7.15
202
EjercitaciÃ³n
Ejercicio
efecto
siguientes
instrucciones
octal
Indique
mnemÃ³nico
correspondiente
177777
137701
140277
013150
042322
125000
075303
104210
063501
Ejercicio
Complete
cuadro
restantes
formas
representaciÃ³n
MnemÃ³nico
octal
binario
ADD
50
150510
1111000001001000
NOT
33
0011000001010110
110350
XOR
276
Ejercicio
Escriba
programa
comenzando
ubicaciÃ³n
400
intercambie
contenidos
ubicaciones
550
551
Expresarlo
representaciÃ³n
octal
mnemÃ³nica
Ejercicio
Escriba
representaciÃ³n
octal
programa
contenido
acumulador
ubicaciones
3007
3010
3011
3012
ejecuciÃ³n
programa
3001
LDA
3007
3002
IOR
3010
3003
AND
3011
3004
STA
3012
3005
OUT
01
3006
HLT
3007
110771
3010
145735
203
3011
074000
3012
77177
Ejercicio
Escriba
programa
comience
ubicaciÃ³n
550
efectÃºe
operaciÃ³n
lÃ³gica
AND
contenido
ubicaciÃ³n
560
563
Depositar
resultado
560
indicar
valor
resultante
octal
siguientes
datos
decimal
560
+1307
563
+2431
Ejercicio
Proyecte
secuencia
instrucciones
efectÃºe
salto
ubicaciÃ³n
255
contenido
direcciÃ³n
300
cero
ubicaciÃ³n
333
contenido
distinto
cero
Ejercicio
Suponga
mÃ¡quina
elemental
dotada
doble
instrucciones
modificarÃ­a
estructura
palabra
manteniendo
longitud
objeto
palabras
direccionarse
directamente
propuesta
Ejercicio
Escriba
programa
efectÃºe
multiplicaciÃ³n
nÃºmeros
usando
mÃ©todo
sumas
sucesivas
Ejercicio
Escriba
instrucciones
blue
cÃ³digo
programa
lenguaje
alto
nivel
tipo
C++
considerando
variables
enteras
proponiendo
posiciones
memoria
almacenamiento
datos
programa
for
10
a[i
b[i
204
Ejercicio
10
instrucciones
MÃ¡quina
Elemental
escriba
cÃ³digo
o10
while
i<0
do
a[i]=
b[i
i+1
break
a[i]=
17o
done
Ejercicio
11
Escriba
instrucciones
blue
expresiÃ³n
algebraica
programa
lenguaje
alto
nivel
tipo
C++
considerando
variables
enteras
proponiendo
posiciones
memoria
almacenamiento
datos
programa
Realizarlo
subrutina
indicar
expresamente
paso
retomo
subrutina
programa
principal
Ejercicio
12
Realice
circuito
Unidad
Control
Cableada
usando
contador
decodificador
generar
pulsos
CP1
CP8
Ciclo
MÃ¡quina
MÃ¡quina
Elemental
205
CAPÃTULO
Arquitectura
Convencional
VisiÃ³n
General
1.1
Formato
instrucciones
1.2
Modos
direccionamiento
Hardware
Software
2.1
Registros
2.2
MÃ¡quina
elemental
indexada
2.3
estructura
convencional
Microprocesador
8088
3.1
IntroducciÃ³n
3.2
Diagrama
bloques
EjercitaciÃ³n
206
CapÃ­tulo
Arquitectura
Convencional
VisiÃ³n
General
CapÃ­tulo
veremos
inicialmente
conceptos
formato
instrucciones
modos
direccionamiento
haremos
modificaciones
MÃ¡quina
Elemental
obtener
MÃ¡quina
Elemental
Indexada
MEI
arquit
ectura
actual
computadora
agregaremos
Interrupciones
MÃ¡quina
Elemental
Indexada
MEI
finalmente
estudiaremos
microprocesador
INTEL
8088
ejemplo
mÃ¡quina
CPU
convencional
1.1
Formato
instrucciones
sentido
ge
neral
instrucciÃ³n
involucre
operaciÃ³n
diÃ³dica
operandos
resultado
requiere
piezas
datos
cÃ³digo
operaciÃ³n
UbicaciÃ³n
operando
UbicaciÃ³n
operando
UbicaciÃ³n
resultado
UbicaciÃ³n
prÃ³xima
instrucciÃ³n
1.1.1
Formato
direcciones
primeras
mÃ¡quinas
solÃ­an
piezas
instrucciÃ³n
Figura
8.1
ejemplo
Fig
8.1
Formato
general
instrucciones
direcciones
207
instrucciÃ³n
ADD
implica
sumar
colocar
resultado
buscar
prÃ³xima
instrucciÃ³n
D.
1.1.2
Formato
direcciones
pieza
eliminar
direcciÃ³n
prÃ³xima
instrucciÃ³n
instrucciones
colocan
forma
sucesiva
memoria
prÃ³xima
instrucciÃ³n
obtiene
ayuda
registro
llamado
contador
programa
Fig
8.2
Fig
8.2
Formato
general
instrucciones
direcciones
instrucciÃ³n
ADD
implica
sumar
colocar
resultado
buscar
prÃ³xima
instrucciÃ³n
PC
1.1.3
Formato
direcciones
pieza
eliminar
ubicaciÃ³n
resultado
Fig
8.3
ejemplo
Fig
8.3
Formato
general
instrucciones
direcciones
instrucciÃ³n
ADD
implica
208
sumar
colocar
resultado
buscar
prÃ³xima
instrucciÃ³n
PC
direcciÃ³n
operando
utiliza
1.1.4
Formato
direcciÃ³n
pieza
eliminar
direcciÃ³n
operando
operando
registro
CPU
Figura
8.4
ejemplo
Fig
8.4
Formato
general
instrucciones
direcciÃ³n
instrucciÃ³n
ADD
implica
sumar
contenido
Acc
colocar
resultado
Acc
buscar
prÃ³xima
instrucciÃ³n
PC
caso
mÃ¡quina
elemental
vista
CapÃ­tulo
1.2
Modos
direccionamiento
medios
facilitan
tarea
programaciÃ³n
permitiendo
acceso
datos
Modos
Direccionamiento
indican
procesador
calcular
direcciÃ³n
absoluta
real
efectiva
determinar
encuentran
datos
espec
ifican
obtener
operando
operando
ubicado
Memoria
Registro
CPU
InstrucciÃ³n
dato
instrucciÃ³n
almacenada
CPU
importante
aclarar
ue
general
instrucciÃ³n
realiza
operaciÃ³n
lÃ³gico
-aritmÃ©tica
involucrados
209
operandos
realiza
operaciÃ³n
indicarse
OPER1
OPER2
MNEMÃ“NICO
OPER2
OPER1
caso
instrucciones
realizan
operaciones
Ãºnico
operando
OPER2
aparece
MNEMÃ“NICO
OPER1
caso
instrucciones
realizan
movimientos
datos
suele
indicar
operandos
OPERfuente
OPERdestino
indicando
ubicaciÃ³n
origen
destino
movimiento
MNEMÃ“NICO
OPERdestino
OPERfuente
mencionado
queda
instrucciÃ³n
operandos
coexistan
Modos
Direccionamiento
ubicado
operando
especifica
siguientes
modos
direccionamiento
MODOS
DIRECCIONAMIENTO
OPERANDO
CPU
OPERANDO
MEMORIA
DIRECCIONAMIENTO
INMEDIATO
DIRECCIONAMIENTO
REGISTRO
DIRECCIONAMIENTO
DIRECTO
DIRECCIONAMIENTO
INDIRECTO
MEMORIA
DIRECCIONAMIENTO
INDIRECTO
REGISTRO
INDEXADO
210
1.2.1
Operando
CPU
direccionamiento
inmediato
operando
instrucciÃ³n
MÃ¡quina
Elemental
vista
disponemos
direccionamiento
registro
operando
Registro
CPU
MÃ¡quina
Elemental
ejemplificado
instrucciones
NOT
Operando
ACC
operaciÃ³n
Ãºnico
operando
ACC
RAL
Operando
ACC
caso
similar
CSA
OPERfuente
SR
OPERdestino
ACC
operaciÃ³n
movimiento
datos
operando
1.2.2
Operando
memoria
direccionamiento
directo
direcciÃ³n
operando
instrucciÃ³n
Ejemplo
siguientes
instrucciones
MÃ¡quina
Elemental
LDA
XXXX
OPERfuente
direcciÃ³n
XXXX
Memoria
direccionamiento
directo
OPERdestino
ACC
direccionamiento
registro
STA
XXXX
OPERfuente
Acc
direccionamiento
registro
OP
ERdestino
direcciÃ³n
XXXX
Memoria
direccionamiento
directo
ejemplos
direccionamiento
directo
instrucciones
ADD
XXXX
IOR
XXXX
XOR
XXXX
casos
OPER2
Memoria
direcciÃ³n
XXXX
indica
instrucciÃ³n
direccionamiento
directo
OPER1
211
registro
CPU
ACC
direccionamiento
Registro
direccionamiento
indirecto
memoria
instrucciÃ³n
especifica
direcciÃ³n
direcciÃ³n
operando
direccionamiento
mÃ¡quina
elemental
soporte
implica
ampliar
hardware
software
MÃ¡quina
Elemental
veremos
posteriormente
direccionamiento
indirecto
registro
direcciÃ³n
operando
Registros
destinados
direccionamiento
MÃ¡quina
Elemental
caso
necesario
ampliar
componentes
MÃ¡quina
Elemental
Direccionami
ento
realidad
indirecto
direcciÃ³n
operando
instrucciÃ³n
Registro
razÃ³n
suele
llamar
Indirecto
Registro
modos
direccionamiento
indirecto
Ãºtiles
programador
relaciÃ³n
tareas
comunes
Ã¡mbito
programaciÃ³n
tareas
Modificar
direcciones
Generar
contadores
implementar
lazos
repetitivos
Reducir
espacio
ocupado
memoria
instrucciones
Permitir
reubicaciÃ³n
cÃ³digo
Facilitar
manejo
estructuras
datos
continuaciÃ³n
presentan
par
ejemplos
facilitados
direccionamiento
Supongamos
mÃ¡quina
elemental
deseamos
sumar
sucesivamente
conjunt
100
nÃºmeros
ubicados
correlativamente
memoria
DeberÃ­amos
tomar
nÃºmeros
sumarlos
colocar
suma
parcial
posiciÃ³n
memoria
llegar
nÃºmero
100
problema
comÃºn
mover
bloque
datos
sector
memoria
interesante
contar
hardware
software
faciliten
incremento
direcciÃ³n
memoria
conteo
operaciones
realizadas
Surge
idea
mejorar
hardware
facilitar
tareas
mencionadas
212
Hardware
Software
2.1
Registros
agregar
registros
mÃ¡quina
elemental
objeto
obtener
mejoras
operativas
2.1.1
Registros
Ã­ndices
agregar
Registros
Ãndice
mÃ¡quina
elemental
registros
16
bits
Registro
Ãndice
Fuente
RIF
Registro
Ãndice
Destino
RID
trabajar
Registros
Ãndice
modificaremos
formato
instrucciÃ³n
indicar
direccionamiento
Planteamos
formato
Figura
8.5
Fig
8.5
Formato
instrucciÃ³n
modificado
bits
CÃ³digo
OperaciÃ³n
podremos
32
instrucciones
usando
16
bits
Campo
DirecciÃ³n
podremos
direccionar
65536
posiciones
memoria
bits
Campo
Modificador
podremos
seleccionar
Modos
Direccionamiento
instrucciones
campos
requerirÃ¡n
posiciones
16
bits
asignando
posiciÃ³n
Campo
DirecciÃ³n
instrucciones
necesiten
Campo
Modificador
Campo
DirecciÃ³n
almacenarÃ¡n
posiciÃ³n
16
bits
instrucciones
MÃ¡quina
Elemental
Blue
ciclo
permanecen
MÃ¡quina
Elemental
Indexada
MEI
cuparÃ¡n
posiciÃ³n
memoria
213
Directo
contenido
Campo
Modificador
Campo
DirecciÃ³n
direcciÃ³n
operando
ejemplo
LDA
1000
Carga
Acc
contenido
posiciÃ³n
1000
Indirecto
memoria
contenido
Campo
Modificador
Campo
DirecciÃ³n
apunta
posiciÃ³n
memoria
cuyo
contenido
operando
direcciÃ³n
ejemplo
suponiendo
contenido
posiciÃ³n
1000
3400
LDA
1000
Carga
Acc
contenido
posiciÃ³n
3400
Indirecto
registro
Indexado
contenido
Campo
Modificador
contenido
RIF
suma
Campo
DirecciÃ³n
obteniendo
direcciÃ³n
operando
ejemplo
Suponiendo
contenido
RIF
5000
LDA
1000
Carga
Acc
contenido
posiciÃ³n
6000
1000
5000
contenido
Campo
Modificador
contenido
RID
suma
Campo
DirecciÃ³n
obteniendo
direcciÃ³n
operando
Sumador
Direcciones
suma
indicada
direccionamiento
indexado
agregamos
sumador
CPU
dedicado
tarea
forma
tiempo
ALU
Sumador
registros
entrada
Registro
Registro
16
bits
suma
resultado
contenido
tercer
registro
agregaremos
Registro
Base
16
bits
Decodificador
Campo
Modificador
decodificar
campo
Modificador
implementamos
Unidad
Control
decodificador
DECODIFICADOR
CAMPO
MODIFICADOR
Decodificador
Instrucciones
existente
permite
simultÃ¡neamente
decodificaciÃ³n
CÃ³digo
OperaciÃ³n
instrucciÃ³n
Campo
Modificador
214
2.1.2
Registros
base
programador
escribe
programa
definir
direcciÃ³n
comienzo
memoria
necesita
programa
datos
asociados
idea
arbitraria
comÃºnmente
usada
comience
direcciÃ³n
CE
RO
razones
programa
comenzar
direcciÃ³n
CERO
existir
programa
residente
memoria
momento
MultiprogramaciÃ³n
comenzar
direcciÃ³n
CERO
primeras
posiciones
memoria
reservan
tareas
manejo
entrada
salida
discutirÃ¡
posteriormente
imaginar
necesidad
programa
administrador
sistema
podrÃ­amos
llamar
Monitor
programa
deberÃ­a
tareas
encargarse
decidir
ejecuciÃ³n
programas
usuario
asignÃ¡ndole
direcciones
comienzo
Ã¡rea
memoria
utilizar
Proceso
llamado
ensamblado
programa
programador
forma
antemano
direcciÃ³n
comienzo
programa
disponible
momento
ejecuciÃ³n
programa
cargado
Monitor
necesitar
reubicarlo
consolidar
Ã¡reas
vacÃ­as
memoria
desfragmentaciÃ³n
Programa
Cargador
Reubicable
Relocating
Loader
soluciÃ³n
reubicar
programas
memoria
programa
Monitor
deberÃ­a
capaz
distinguir
constantes
programa
usuario
modificar
direcciones
reubicables
programa
modificar
ensamblarlo
alternativa
permite
reubicar
programas
utilizando
herramienta
hardware
agregar
registro
llamado
REGISTRO
BASE
16
bits
Registro
Base
Registro
Ãndice
sentido
contenido
suma
campo
direcciÃ³n
instrucciÃ³n
obtener
direcciÃ³n
efectiva
diferencia
consiste
usuario
comÃºn
control
contenido
Registro
Base
contenido
Registro
Base
suma
direcciÃ³n
efectiva
realiza
referencia
memoria
EjecuciÃ³n
instrucciÃ³n
Aclaremos
ejemplo
Supongamos
usuario
escribe
programa
comienza
direcciÃ³n
CERO
0000
ENI
1000
coloque
valor
1000
Registro
Ãndice
RID
0001
LDA
1234
cargue
Acc
contenido
posiciÃ³n
2234
1234
1000
215
Supongamos
Relocating
Loader
razones
mencionadas
carga
programa
direcciÃ³n
5000
resultado
ejecuciÃ³n
introduce
siguientes
modificaciones
5000
ENI
1000
coloque
valor
1000
Registro
Ãndice
RID
5001
LDA
6234
cargue
Acc
contenido
posiciÃ³n
7234
6234
1000
observa
modificada
instrucciÃ³n
direcciÃ³n
5000
constante
modifica
instrucciÃ³n
direcciÃ³n
5001
direcciÃ³n
mÃ¡quina
Registro
Base
tarea
Relocating
Loader
simplificarse
desplazamiento
direcciÃ³n
cargado
Registro
Base
instrucciÃ³n
privilegiada
suma
direcciÃ³n
efectiva
realiza
referencia
memoria
constantes
inmunes
influencia
referencia
memoria
modifica
automÃ¡ticamente
cantidad
direcciÃ³n
inicial
programa
2.2
MÃ¡quina
elemental
indexada
propone
MÃ¡quina
Elemental
Indexada
MEI
incluyendo
Registros
Ãndice
Registro
Base
Sumador
Direcciones
registros
entrada
RB
diagrama
bloques
mÃ¡quina
muestra
Figura
8.6
figura
indica
cursiva
hardware
ObsÃ©rvese
Sumador
Direcciones
realiza
suma
aritmÃ©tica
direcciones
operandos
Registro
16
bits
Registro
16
bits
Registro
base
16
bits
genera
direcciÃ³n
tiempo
jecuciÃ³n
realiza
suma
NÃ³tese
suma
influye
BÃºsqueda
direcciÃ³n
instrucciÃ³n
buscada
contenido
Registro
PC
acarreo
sumador
216
Fig
8.6
Diagrama
bloques
MÃ¡quina
Elemental
Indexada
2.2.1
Conjunto
instrucciones
mÃ¡quina
elemental
indexada
Tabla
8.1
presentan
detalles
conjunto
instrucciones
MÃ¡quina
Elemental
Indexada
columna
izquierda
parÃ©ntesis
indica
cantidad
posiciones
memoria
ocupa
instrucciÃ³n
presentan
instrucciones
MÃ¡quina
Elemental
permanecen
funciÃ³n
bÃ¡sica
MÃ¡quina
Elemental
Indexada
instrucciones
acceso
memoria
disponen
modos
direccionamiento
lÃ³gicamente
instrucciones
propuestas
MÃ¡quina
Elemental
Indexada
requerimientos
arquitectÃ³nicos
217
218
219
220
Tabla
8.1
Conjunto
instrucciones
MÃ¡quina
Elemental
Indexada
2.2.2
Ciclos
mÃ¡quina
cambios
MÃ¡quina
Elemental
reflejan
ciclo
bÃºsqueda
ejecuciÃ³n
continuaciÃ³n
presentan
Tabla
8.2
Tabla
8.6
casos
instrucciones
Blue
LDA
XXXXXX
Cargue
Acc
contenido
posiciÃ³n
memoria
XXXXXX
RID
aspecto
LDA
XXXXXX
Memoria
ciclos
bÃºsqueda
ejecuciÃ³n
observan
Tabla
8.2
221
Tabla
8.2
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
LDA
XXXXXX
222
ciclo
bÃºsqueda
MÃ¡quina
Elemental
ciclo
ejecuciÃ³n
consta
ciclos
memoria
CP1
ciclo
ejecuciÃ³n
direcciona
posiciÃ³n
obtener
campo
direcciÃ³n
instrucciÃ³n
instrucciÃ³n
ocupa
palabras
Memoria
CP2
CP4
incrementa
nuevamente
PC
forma
ciclo
bÃºsqueda
apunte
prÃ³xima
instrucciÃ³n
CP5
CP6
cargan
registros
entrada
sumador
direcciones
calcular
direcciÃ³n
efectiva
operando
CP1
ejecuciÃ³n
direcciona
operando
orden
lectura
CP2
CP5
espera
memoria
CP6
envÃ­a
dato
leÃ­do
Acumulador
Finalmente
CP8
coloca
mÃ¡quina
bÃºsqueda
instrucciÃ³n
observa
ins
trucciÃ³n
utilizan
ciclos
mÃ¡quina
LDA
XXXXXX
Carga
ACUMULADOR
contenido
direcciÃ³n
indicada
contenido
XXXXXX
aspecto
LDA
XXXXXX
Memoria
ciclos
bÃºsqueda
ejecuciÃ³n
observan
Tabla
8.3
223
224
Tabla
8.3
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
LDA
XXXXXX
observa
direccionamiento
indirecto
requiere
ciclos
mÃ¡quina
LDA
XXXXXX
Cargue
Acc
contenido
posiciÃ³n
XXXXXX
aspecto
LDA
XXXXXX
Memoria
ciclos
bÃºsqueda
ejecuciÃ³n
observan
Tabla
8.4
225
Tabla
8.4
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
LDA
XXXXXX
226
INC
XXX
Incrementar
Registro
Ãndice
RIF
valor
XXX
nÃºmero
signado
bits
aspecto
INC2
XXX
Memoria
ciclos
bÃºsqueda
ejecuciÃ³n
observan
Tabla
8.5
Tabla
8.5
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
INC2
valor
XXXXXX
227
ENI
XXXXXX
Cargar
RID
valor
XXXXXX
aspecto
ENI
RID
XXXXXX
Memoria
ciclos
bÃºsqueda
ejecuciÃ³n
observan
Tabla
8.6
Tabla
8.6
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
ENI3
XXXXXX
228
Comentarios
MÃ¡quina
Elemental
Indexada
formato
fijo
instrucciÃ³n
instrucciones
referencia
memoria
modos
direccionamiento
ejemplo
instrucciÃ³n
LIX
XXXXXX
posee
direccionamiento
indexado
estarÃ­a
autoindexando
instrucciones
ciclos
mÃ¡quina
ejecutarse
dependiendo
instrucciÃ³n
direccionamiento
sugiere
lector
deduzca
ciclos
mÃ¡quina
instrucciones
MÃ¡quina
Elemental
Indexada
MEI
indican
CapÃ­tulo
2.2.3
Interrupciones
entradas
-salidas
MÃ¡quina
Elemental
llevan
cabo
control
CPU
usando
instrucciones
INP
OUT
formas
manejar
operaciones
entrada
salida
inmovilizan
CPU
ocurre
transferencia
datos
velocidad
perifÃ©ricos
general
inferior
CPU
eventos
producen
frecuencia
importancia
conveniente
atenderlos
momento
ocurren
eventos
externos
generan
directamente
programa
perifÃ©rico
conveniente
manejar
problemas
arreglar
hardware
forma
ue
eventos
ocurren
produzca
suspensiÃ³n
interrupciÃ³n
automÃ¡tica
programa
corriente
transfiera
control
temporariamente
rutina
diseÃ±ada
especialmente
manejar
eventos
planteadas
cosas
podrÃ­amos
cla
sificar
transferencia
Entrada
Salida
forma
Control
CPU
Interrupciones
Manejo
229
Manejo
Entrada
Salida
Control
Procesador
general
operaciones
entrada
salida
iniciadas
procesador
iniciada
operaciÃ³n
Procesador
espera
complete
continÃºa
programa
principal
caso
mÃ¡quina
elemental
ObsÃ©rvese
velocidad
dispositivo
inferior
Procesador
caso
general
inmovilizado
tiempo
dispositivo
sufre
desperfecto
Procesador
esperar
eternamente
Manejo
Entrada
Salida
Interrupciones
opciÃ³n
principio
iniciar
operaciÃ³n
entrada
salida
continuar
programa
principal
dispositivo
cuestiÃ³n
termina
solicita
pedido
atenciÃ³n
solicitud
interrupciÃ³n
er
atendido
Procesador
finaliza
operaciÃ³n
esquema
eficaz
pÃ©rdida
tiempo
esperando
perifÃ©rico
requiere
hardware
instrucciones
especiales
soporten
dispositivo
solicite
atenciÃ³n
necesario
identificarlo
asignar
prioridades
esquema
interrupciones
Ãºtil
caso
dispositivos
requieren
operaciÃ³n
entrada
salida
necesariamente
iniciadas
Procesador
anteriormente
verÃ¡
identifica
dispositivo
solicita
InterrupciÃ³n
interrupciones
clasificar
Polling
Interrupciones
Vectorizadas
describir
Sistema
Elemental
Interrupciones
MÃ¡quina
Elemental
mencionar
concepto
interrupciÃ³n
extiende
eventos
necesariamente
externos
caso
llamadas
interrupciones
internas
cuy
230
origen
proviene
interior
Procesador
desborde
registros
divisiÃ³n
cero
cÃ³digo
operaciÃ³n
vÃ¡lido
etc.
llamadas
interrupciones
software
dispara
proceso
interrupciÃ³n
instrucciones
especiales
2.2.4
Sistema
elemental
interrupciones
define
Biestable
Unidad
Control
llama
Sistema
InterrupciÃ³n
valor
bit
controlarse
instrucciones
ION
IOF
UC
desactiva
procesando
interrupciÃ³n
activa
proceso
concluido
sistema
interrupciones
habilitado
sistema
interrupciones
deshabilitado
dispositivo
capac
idad
interrumpir
posee
lÃ­nea
solicitud
interrupciÃ³n
pone
necesita
atenciÃ³n
Banderas
Dispositivo
BD
compuerta
OR
cuya
salida
lÃ­nea
Ãºnica
pedido
IRQ
interrupciÃ³n
CPU
interrupcio
nes
habilitadas
SI=1
IRQ
pasa
produce
interrupciÃ³n
ejecuciÃ³n
programa
corriente
justo
comienzo
ciclo
bÃºsqueda
instrucciÃ³n
actual
termina
ejecutarse
eventos
ocurren
CPU
acepta
interrupciÃ³n
Biestable
coloca
inhabilitando
sistema
interrupciones
contenido
PC
guarda
posiciÃ³n
CERO
carga
PC
valor
dispara
ciclo
bÃºsqueda
eventos
cabo
Unidad
Control
esquema
Figura
8.7
biestable
PRO
indica
CPU
atendiendo
interrupciÃ³n
verÃ¡
condiciona
acciones
realiza
instrucciÃ³n
INP
YY
figura
obs
ervan
Biestable
biestable
PRO
Biestable
mencionado
tercer
Biestable
auxiliar
encargado
generar
seÃ±al
seÃ±al
dispara
ciclo
INTERRUPCIÃ“N
mÃ¡quina
BÃºsqueda
EjecuciÃ³n
InterrupciÃ³n
231
InterrupciÃ³n
ocurre
ve
Figura
lÃ­nea
IRQ
indicando
dispositivo
requiere
atenciÃ³n
sistema
interrupciones
habilitado
CP8
EjecuciÃ³n
ciclo
BÃºsqueda
instrucciÃ³n
corriente
ciclo
asegura
finalizaciÃ³n
ejecuciÃ³n
instrucciÃ³n
corriente
Fig
8.7
Unidad
Control
incluyendo
sistema
elemental
interrupciones
Ciclo
InterrupciÃ³n
Tabla
8.7
indica
ciclo
interrupciÃ³n
232
Tabla
8.7
Ciclo
interrupciÃ³n
Rutina
InterrupciÃ³n
posiciÃ³n
memoria
instrucciÃ³n
salto
rutina
interrupciÃ³n
cuya
tarea
consiste
secuencia
acciones
Figura
8.8
233
Fig
8.8
Secuencia
acciones
rutina
interrupciÃ³n
Salvar
guardar
memoria
contenidos
Registros
Contexto
PC
restituirlos
terminado
proceso
acciÃ³n
implementarse
automÃ¡ticamente
ciclo
interrupciÃ³n
caso
implicar
ciclo
mÃ¡quina
Determinar
qui
Ã©n
causÃ³
interrupciÃ³n
acciÃ³n
realizarse
POLLING
llamados
VEC
TORES
INTERRUPCIÃ“N
Saltar
Subrutina
AtenciÃ³n
perifÃ©rico
determinado
Subrutina
especÃ­fica
perifÃ©rico
realiza
transferencia
Entrada
Salida
finalizar
Subrutinas
AtenciÃ³n
PerifÃ©ricos
saltan
porciÃ³n
cÃ³digo
restaura
contexto
esencial
transparente
est
proceso
interrupciÃ³n
programa
principal
Programa
principal
continuarÃ¡
234
hubiera
Restaurar
contexto
implica
volver
cargar
registros
CPU
valores
tenÃ­an
acciÃ³n
habilitar
SISTEMA
INTERR
UPCIONES
retornar
Programa
Principal
realizarse
instrucciÃ³n
llamada
RTI
Retorno
InterrupciÃ³n
evitar
retornar
produzca
interrupciÃ³n
pendiente
ciclo
mÃ¡quina
RTI
muestra
Tabla
8.8
Tabla
8.8
Ciclo
mÃ¡quina
instrucciÃ³n
RTI
235
Polling
determinar
perifÃ©rico
solicitÃ³
interrupciÃ³n
aplicarse
tÃ©cnica
POLLING
recuerda
dispositivo
capacidad
interrumpir
posee
Bandera
Dispositivo
BD
BD
indica
solicita
interrupciÃ³n
caso
contrario
tÃ©cnica
polling
pregunta
secuencialmente
BD
orden
BD
resulta
salto
subrutina
atenciÃ³n
perifÃ©rico
corresponda
proponer
instrucciÃ³n
verifique
banderas
SKF
XX
Omitir
prÃ³xima
instrucciÃ³n
XX
CERO
XX
representa
bandera
corresponde
dispositivos
solicitan
interrupciÃ³n
rutina
interrupciÃ³n
llamada
POLLING
aspecto
SKF
bandera
omitir
prÃ³xima
instrucciÃ³n
JMP
Rutina1
Salte
Rutina
AtenciÃ³n
Dispositivo
SKF
bandera
omitir
prÃ³xima
instrucciÃ³n
JMP
Rutina2
Salte
Rutina
AtenciÃ³n
Dispositivo
SKF
bandera
omitir
prÃ³xima
instrucciÃ³n
JMP
Rutina3
Salte
Rutina
AtenciÃ³n
Dispositivo
SKF
bandera
omitir
prÃ³xima
instrucciÃ³n
JMP
Rutina4
Salte
Rutina
AtenciÃ³n
Dispositivo
orden
realiza
verificaciÃ³n
banderas
dispositivo
Rutina
InterrupciÃ³n
determina
prioridad
dispositivo
solicita
atenciÃ³n
caso
existir
solicitud
esquema
probable
perifÃ©rico
atendido
difÃ­cilmente
atendido
soluciÃ³n
aspecto
cambiar
prioridades
alterando
orden
instrucciones
prÃ¡ctico
236
alternativa
implementa
MÃ¡quina
Elemental
Indexada
agregar
registro
llamado
Registro
MÃ¡scara
RM
cuyo
contenido
modificarse
instrucciÃ³n
EMR
Valor
registro
permite
enmascarar
evitar
curso
solicitudes
interrupciÃ³n
Figura
8.9
presenta
sistema
interrupciones
descripto
Fig
8.9
Sistema
interrupciones
usando
Banderas
Dispositivos
Registro
MÃ¡scaras
prioridades
Banderas
Dispositivo
BD
bits
provienen
dispositivos
solicitan
atenciÃ³n
borran
instrucciÃ³n
SKF
XX
lee
bandera
237
Vector
Interrupciones
mÃ©todo
implementa
MÃ¡quina
Elemental
Indexada
determinar
interrumpe
llamado
VECTORIZADO
esquema
dispositivo
interrumpir
asigna
direcciÃ³n
llamada
vector
interrupciÃ³n
Trap
Vector
Address
direcciÃ³n
suplida
dispositivo
interrumpe
programador
almacenar
direcciÃ³n
comienzo
Rutina
AtenciÃ³n
corresponda
forma
toma
lugar
salto
indirecto
vector
Rutina
AtenciÃ³n
Figura
8.10
inferirse
mÃ©todo
rÃ¡pido
POLLING
necesario
preguntar
bandera
bandera
conveniente
considerar
seÃ±al
reconocimiento
interrupciÃ³n
ACK
generada
Unidad
Control
reconocido
solicitud
interrupciÃ³n
comienza
proceso
atenciÃ³n
Figura
8.11
indica
conexionado
externo
CPU
seÃ±al
reconocimiento
ACK
encadena
Dispositivo
siguientes
prioridad
Dispositivo
izquierda
seÃ±al
similar
seÃ±al
BD
bandera
solicitud
interrupciÃ³n
pone
dispositivo
correspondiente
necesita
atenciÃ³n
dispositivo
ecibe
seÃ±al
reconocimiento
ACK
vuelca
BUS
dibujado
direcciÃ³n
pone
bandera
I.
seÃ±al
bit
registro
mÃ¡scara
distribuido
perifÃ©ricos
pone
programa
hardware
software
necesario
implementaciÃ³n
verificaciÃ³n
vectorizada
desarrolla
invita
lector
planteo
2.2.5
Inicio
transferencia
comprender
realiza
transferencia
Entrada
Salida
necesario
consideraciones
PerifÃ©ricos
perifÃ©ricos
dispositivos
caracterÃ­sticas
externos
MEI
BÃ¡sicamente
debemos
considerar
perifÃ©ricos
poseer
238
Fig
8.10
Vector
Interrupciones
Elementos
micromecÃ¡n
ica
servomotores
relay
motores
paso
paso
sensores
Ã³pticos
sensores
magnÃ©ticos
indicadores
luminosos
componentes
electrÃ³nicos
media
potencia
etc.
Circuitos
electrÃ³nicos
permiten
controlar
elementos
constitutivos
perifÃ©rico
CONTROLADOR
Circuitos
electrÃ³nicos
permiten
adaptaciÃ³n
niveles
tensiÃ³n
corriente
INTERFASE
conectarlos
MEI
general
acciones
control
perifÃ©rico
realizan
Controladores
sistemas
electrÃ³nicos
dedicados
especÃ­ficamente
perifÃ©rico
cuestiÃ³n
forma
control
nivel
tarea
CPU
CPU
ve
PerifÃ©ricos
registros
comunica
mayorÃ­a
perifÃ©ricos
Controladores
dejan
CPU
siguientes
registros
239
REGISTRO
DATOS
fluyen
datos
transferencia
REGISTRO
CONTROL
CPU
envÃ­a
comandos
REGISTRO
refleja
perifÃ©rico
Fig
8.11
Sistema
interrupciones
usando
bit
Dispositivos
seÃ±al
ACK
CPU
prioridades
perifÃ©ricos
clasifican
funciÃ³n
direcciÃ³n
datos
fluyen
Bus
PerifÃ©ricos
Entrada
PerifÃ©ricos
salida
datos
dirigen
PerifÃ©rico
Salida
viceversa
simplificar
explicaciÃ³n
considerar
perifÃ©ricos
REGISTRO
DATOS
Ciclo
instrucciones
entrada
salida
interrupciones
transferencias
entrada
salida
general
iniciadas
programa
instrucciones
INP
YY
OUT
YY
240
instrucciones
ciclos
mÃ¡quina
vistos
mÃ¡quina
Elemental
diferencia
consiste
ue
realizan
verificaciÃ³n
seÃ±al
Ready
Simplemente
TRA
pulso
reloj
TRA
OUT
YY
espera
seÃ±al
PerifÃ©rico
genera
pulso
reloj
duraciÃ³n
indica
PerifÃ©ric
YY
comienzo
transferencia
salida
Tabla
8.9
perifÃ©rico
recibir
TRA
carga
Registro
Entrada
valor
bits
significativos
ACC
BUS
comienza
acciÃ³n
correspondiente
or
ejemplo
imprimir
programador
deberÃ¡
cargar
ACC
dato
desea
transferir
instrucciÃ³n
OUT
YY
Tabla
8.9
Ciclo
instrucciÃ³n
OUT
YY
INP
YY
genera
pulso
TRA
instrucciÃ³n
OUT
YY
PRO
CPU
involucrada
Proceso
InterrupciÃ³n
Tabla
8.10
caso
CPU
estÃ©
Proceso
InterrupciÃ³n
lugar
Rutina
InterrupciÃ³n
genera
TRA
CP8
cargan
bits
significativos
ACC
valor
Registro
Salida
perifÃ©rico
YY
PYY
Bus
S.
241
Tabla
8.10
Ciclo
instrucciÃ³n
INP
YY
sugiere
lector
ejercitaciÃ³n
escribir
Subrutina
manejar
impresora
PerifÃ©rico
salida
capaz
escribir
caracter
ASCII
desean
escribir
100
caracteres
ubicados
Memoria
posiciÃ³n
1000
Controladores
elementales
perifÃ©ricos
PERIFÃ‰RICO
SALIDA
PerifÃ©
rico
Salida
ejecutado
instrucciÃ³n
OUT
YY
Registro
Datos
cargarÃ¡
dato
estÃ©
BUS
perifÃ©rico
seleccionado
YY
reciba
seÃ±al
TRA
iniciarÃ¡
acciones
Ejemplo
PerifÃ©rico
Salida
P32
OUT
32
Figura
8.12
Fig
8.12
Transferencia
salida
perifÃ©rico
32
242
PERIFÃ‰RICO
ENTRADA
PerifÃ©rico
Entrada
ejecutado
instrucciÃ³n
INP
YY
opciones
PRO
MÃ¡quina
atendiendo
interrupciÃ³n
ejecuta
INP
YY
perifÃ©rico
YY
recibe
TRA
inicia
acciones
obtener
dato
solicitado
PRO
MÃ¡quina
atendiendo
interrupciÃ³n
Registro
Datos
dato
solicitado
disp
onible
Bus
perifÃ©rico
seleccionado
CP7
instrucciÃ³n
INP
YY
seÃ±al
TRA
genera
caso
instrucciÃ³n
INP
YY
Ejemplo
PerifÃ©rico
Entrada
P16
INP
16
Figura
8.13
Fig
8.13
Transferencia
entrada
perifÃ©rico
16
Registro
puntero
pila
Sistema
Interrupciones
descripto
permite
CPU
interrumpida
atendiendo
interrupciÃ³n
direcciÃ³n
retorno
guardada
posiciÃ³n
CERO
perderÃ­a
contexto
mÃ¡quina
incluido
PC
guardara
memoria
estructura
LIFO
pila
cuya
direcciÃ³n
inicial
indicara
Registro
atender
interrupciones
interrupciÃ³n
interrupciones
anidadas
registro
llama
REGISTRO
PUNTERO
PILA
SP
interrupciÃ³n
incrementarse
Registro
cantidad
adecuada
contenido
decrementarse
retorno
interrupciÃ³n
biestable
deberÃ­a
ponerse
justo
comienzo
Rutina
AtenciÃ³n
Dispositivo
243
programador
escribir
Rutina
InterrupciÃ³n
dispositivos
menor
prioridad
puedan
interrumpir
proceso
interrupciÃ³n
corriente
prioridad
habr
Ã­a
agregar
hardware
instrucciones
deja
lector
bosquejar
modelaciÃ³n
MÃ¡quina
Elemental
Indexada
Interrupciones
anidadas
2.3
estructura
convencional
mÃ¡quina
esencial
procesador
actual
generalizaciÃ³n
conceptos
introducidos
previamente
llevarÃ­a
organizaciÃ³n
memoria
mÃ¡quina
convencional
Imaginemos
programa
memoria
multiprogramaciÃ³n
contexto
necesario
programa
posiblemente
distintos
usuarios
deb
poseer
sector
memoria
cÃ³digo
datos
opera
datos
locales
Exista
ctor
destinado
datos
compartidos
programas
datos
globales
EstÃ©
previsto
sector
destinado
Sistema
Interrupciones
sector
destinado
PILA
Exista
sector
destinado
programa
Monitor
administre
Sistema
observa
memoria
organizada
sectores
Monitor
cumplir
bÃ¡sicamente
siguientes
tareas
Organizar
Memoria
Administrar
ejecuciÃ³n
Programas
Reubicar
Programas
Prioridades
Memoria
disponible
Datos
Globales
Administrar
Interrupciones
HabilitaciÃ³n
Prioridades
Definir
tamaÃ±o
PILA
funciÃ³n
actual
Sistema
resumen
Monitor
administrar
recursos
Siste
ma
adecuadamente
dependerÃ¡
desenvolvimiento
mÃ¡quina
distintos
requerimientos
usuario
apartado
verÃ¡
microprocesador
Intel
8088
sirviÃ³
CPU
primeras
PC
Computadora
Personal
arquitectura
244
fundamental
alcance
inicial
GuÃ­as
DidÃ¡cticas
conserva
procesadores
actuales
mÃ¡quina
convencional
Microprocesador
Intel
8088
3.1
IntroducciÃ³n
tÃ©rmino
microprocesador
refiere
CPU
contenida
circuito
integrado
mercado
microprocesadores
utilizados
CPU
mÃ¡quina
convencional
elegido
Intel
8088
Figura
8.14
in
iciador
PC
IBM
PC
XT
estructura
similar
procesadores
Intel
8086
80186
80286
80386
80486
Pentium
difundido
Fig
8.14
ConfiguraciÃ³n
pines
8088
Intel
8088
siguientes
caracterÃ­sticas
generales
Interfase
bus
datos
bits
Arquitectura
interna
16
bits
245
Capacidad
direccionamiento
Mbyte
Compatibilidad
Software
8086
CPU
Variedad
modos
direccionamiento
Operaciones
bloques
palabras
bytes
AritmÃ©tica
signada
-signada
16
bits
binario
decimal
incluyendo
multiplicaciÃ³n
divisiÃ³n
14
registros
16
bits
lÃ­neas
pines
8088
describen
Tabla
8.11
bus
datos
bit
8088
microprocesador
16
bits
multiplexado
tiempo
lÃ­neas
datos
momento
direcciones
memoria
Tabla
8.11
SÃ­mbolos
tipo
funciÃ³n
pines
8088
246
3.2
Diagrama
Bloques
Figura
8.15
Fig
8.15
Diagrama
bloques
microprocesador
8088
247
3.2.1
BIU
EU
funciones
internas
8088
divididas
lÃ³gicamente
unidades
procesamiento
BIU
EU
unidades
interactuar
directamente
realizando
operaciones
asincrÃ³nicamente
Unidad
Interfaz
bus
BIU
cumple
siguientes
funciones
Busca
instrucciones
memoria
Llena
cola
instrucciones
consta
bytes
FIFO
Proporciona
control
bus
Proporciona
EU
operandos
procesar
BIU
formada
sumador
conjunto
registros
16
bits
cola
instrucciones
bytes
circuitos
relacionados
control
bus
tareas
pre-bÃºsqueda
instrucciones
realiza
BIU
indicados
Figura
8.15
Unidad
ejecuciÃ³n
EU
recibe
instrucciÃ³n
buscada
previamente
BIU
encarga
ejecutarla
EU
consta
Unidad
Control
CU
Unidad
LÃ³gico
AritmÃ©tica
ALU
conjunto
registros
16
bits
Figura
8.15
observa
8088
posee
buses
internos
ALU
posee
registros
temporarios
entrada
estando
limitada
entrada
salida
ALU
registro
temporario
fluir
bus
registro
incluidos
entrada
operaciones
16
bits
condiciones
resultantes
almacenadas
registro
condiciones
BIU
detecta
bus
externo
ocioso
envÃ­a
solicitud
memoria
leer
byte
flujo
instrucciones
bytes
leÃ­dos
almacenados
temporariamente
cola
instrucciones
EU
requiere
byte
instrucciÃ³n
toma
cola
dimensiÃ³n
bytes
cola
responde
compromiso
EU
esperando
byte
colas
largas
ocuparÃ­an
bus
llenÃ¡ndose
bytes
utilizarse
ejemplo
ejecuta
instrucciÃ³n
salto
Unidad
Control
8088
micropr
ogramada
posee
ROM
504
palabras
21
bits
recomienda
leer
mÃ¡quina
elemental
microprogramada
almacena
90
248
microprocedimientos
instrucciÃ³n
ejecutarse
requerirÃ¡
microprocedimiento
instr
ucciÃ³n
almacenada
cola
instrucciones
transferida
registro
instrucciones
decodificador
extrae
disemina
Unidad
Control
informaciÃ³n
relacionada
fuente
destino
operando
transfiere
registros
N.
cÃ³digo
operaciÃ³n
transfiere
registro
indicar
ALU
operaciÃ³n
registro
indicar
ALU
operaciÃ³n
16
bits
cÃ³digo
operaciÃ³n
transfiere
combinacional
PLA
obtener
direcciÃ³n
comienzo
microprocedimiento
correspondiente
microprocedimiento
mÃ¡ximo
16
microinstrucciones
exclusivos
instrucciÃ³n
ejemplo
microprocedimientos
comunes
instrucciones
relacionados
cÃ¡lculo
direcciones
formato
microinstrucciÃ³n
8088
observa
Figura
8.16
incluye
siguientes
campos
Fig
8.16
Formato
microinstrucciÃ³n
8088
Campo
Fuente
Indica
registro
fuente
operaciÃ³n
Campo
Destino
Indica
registro
destino
operaciÃ³n
Campo
Tipo
Indica
tipo
microinstrucciÃ³n
OperaciÃ³n
ALU
OperaciÃ³n
memoria
Salto
corto
Salto
Llamada
microprocedimiento
Contabilidad
Campo
ALU
Indica
operaciÃ³n
ALU
Campo
Registro
Proporciona
operando
Campo
CondiciÃ³n
Indica
activaciÃ³n
registro
249
microinstrucciones
ejecutan
ciclo
rel
oj
direcciÃ³n
microinstrucciÃ³n
ejecutar
proporciona
cÃ³digo
operaciÃ³n
instrucciÃ³n
PLA
cargando
microMAR
observa
Figura
8.14
microMAR
cargado
ROM
traslaciÃ³n
mapea
direcciones
bits
registro
SR
ROM
traslaciÃ³n
microprograma
requiere
salto
registro
SR
utiliza
guardar
direcciÃ³n
retorno
micro-subrrutina
estudio
detalle
funcionam
iento
Unidad
Control
8088
escapa
alcance
GuÃ­a
DidÃ¡ctica
obstante
considerar
similar
mÃ¡quina
elemental
microprogramada
microprograma
8088
microprocesadores
accesible
usuario
estructura
particular
micro
consecuencia
consideraciones
tecnolÃ³gicas
mercado
posteriormente
harÃ¡n
consideraciones
generales
ventajas
desventajas
microprogramaciÃ³n
3.2.2
Registros
8088
8088
catorce
registros
agrupan
siguientes
categorÃ­as
Registros
generales
registros
generales
16
bits
dividen
grupos
registros
direccionables
16
bits
bits
AX
Acumulador
usado
almacenar
resultados
operaciones
lectura
escritura
memoria
puertos
AH
BX
Base
usado
direccionamiento
BH
BL
CX
Contador
usado
interacciones
contador
CH
CL
DX
Datos
usado
acceso
datos
DH
DL
registros
Ã­ndice
registros
base
BP
Puntero
base
usado
direccionamiento
Ãndice
usado
direccionamiento
DI
Ãndice
usado
direccionamiento
SP
Puntero
pila
apunta
irecciÃ³n
pila
utilizada
250
Registros
segmento
registros
16
bits
propÃ³sitos
especiales
relacionados
segmentaciÃ³n
memoria
CS
Selecciona
Ã¡rea
memoria
destinada
cÃ³digo
programa
DS
Selecciona
Ã¡rea
memoria
destinada
datos
SS
Selecciona
Ã¡rea
memoria
destinada
pila
STACK
Selecciona
Ã¡rea
memoria
destinada
Registros
control
registros
16
bits
propÃ³sitos
especiales
Registro
condiciones
Bit
Acarreo
C=1
acarreo
Bit
usado
Bit
Paridad
P=1
resultado
nÃºmero
par
Bit
usado
Bit
AC
Acarreo
auxiliar
AC
acarreo
bit
bit
resultado
Bit
usado
Bit
Cero
Z=1
resultado
cero
Bit
Signo
S=1
resultado
negativo
Bit
Trap
T=1
ocurre
interrupciÃ³n
Bit
InterrupciÃ³n
I=1
indica
interrupciones
habilitadas
Bit
10
DirecciÃ³n
D=1
indica
sentido
alto
procesamiento
cadenas
Bit
11
Overflow
O=1
overflow
Bit
12
usado
Bit
13
usado
Bit
14
usado
Bit
15
usado
IP
Puntero
instrucciones
indica
direcciÃ³n
prÃ³xima
instrucciÃ³n
ejecutar
3.2.3
OrganizaciÃ³n
memoria
memoria
organizada
conjunto
segmentos
secuencia
lineal
64
kbytes
memoria
direcciona
usando
componentes
direcciÃ³n
consistentes
selector
segmento
16
bits
offset
16
bits
Figura
8.17
indica
segmento
seleccionado
indica
byte
deseado
segmento
instrucciones
direccionan
251
operandos
memoria
deberÃ¡n
especificar
segmento
offset
mayorÃ­a
casos
necesario
indicar
forma
explÃ­cita
segmento
registro
segmento
correcto
elegido
automÃ¡ticamente
Tabla
8.12
Instrucciones
especiales
permiten
especificar
segmento
casos
determinados
Fig
8.17
Suma
segmento
offset
Cabe
mencionar
memoria
disponible
finalidad
primeras
03FFh
posiciones
verÃ¡
posteriormente
encuentran
destinadas
proceso
interrupciones
Fh
posiciones
FFF0h
FFFFh
reservadas
operaciones
carga
programa
inicial
8088
recibe
seÃ±al
pin
RESET
inicializa
IP
apunte
posiciÃ³n
FFF0h
deberÃ­a
instrucciÃ³n
salto
rutina
inicio
desprende
memoria
RAM
Necesariamente
sectores
memoria
ROM
252
Tabla
8.12
SelecciÃ³n
registro
segmento
3.2.4
Modos
direccionamiento
8088
posibles
modos
direccionamiento
especificar
operandos
provistos
instrucciones
operan
registros
operandos
inmediatos
operando
registro
operando
registros
generales
16
bits
ejemplo
MOV
AX
DX
DX
AX
operando
inmediato
operando
incluido
instrucciÃ³n
ejemplo
MOV
AH
14
14
AH
modos
direccionamiento
restantes
permiten
especificar
operandos
ubicados
segmento
memoria
observÃ³
direcciÃ³n
operando
memoria
posee
componentes
16
bits
selector
segmento
offset
selector
segmento
suple
registros
segmento
offset
calcula
suma
combinaciones
siguientes
elementos
direcciÃ³n
desplazamiento
valor
16
bits
incluido
instrucciÃ³n
base
contenido
registro
base
BP
BX
Ã­ndice
contenido
registro
Ã­ndice
DI
253
combinaciÃ³n
elementos
direcciÃ³n
define
siguientes
modos
directo
offset
contenido
instrucciÃ³n
desplazamiento
ejemplo
MOV
14
DS
10h
14h
indirecto
registro
offset
contenido
registros
BX
BP
DI
ejemplo
MOV
BX
CX
CX
DS
10h
BX
basado
offset
resulta
suma
desplazamiento
contenido
BP
BX
ejemplo
MOV
BP
2A
2A
DS
10h
BP
3h
indexado
offset
resulta
suma
desplazamiento
contenido
DI
ejemplo
MOV
2A
2A
DS
10h
3h
basado
indexado
offset
resulta
suma
contenido
registro
base
registro
Ã­ndice
ejemplo
MOV
BP
2A
2A
DS
10h
BP
basado
indexado
desplazamiento
offset
resulta
suma
contenido
registro
base
registro
Ã­ndice
desplazamiento
ejemplo
MOV
BP
I+
2A
2A
DS
10h
BP
3h
Cabe
aclarar
acarreo
sumas
ignora
desplazamiento
valor
signado
caso
valor
bits
extiende
16
bits
MSB
bit
signo
cabe
aclarar
offset
obtenerse
registro
IP
bÃºsqueda
instrucciÃ³n
instrucciones
salto
caso
contenido
IP
modificarse
formas
salto
relativo
contenido
IP
suma
desplazamiento
salto
directo
contenido
IP
cambia
desplazamiento
254
salto
indirecto
contenido
IP
cambiado
offset
obtenido
cualquiera
modos
indirectos
vistos
anteriormente
3.2.5
Conjunto
instrucciones
instrucciones
8088
dividen
categorÃ­as
Transferencia
datos
AritmÃ©ticas
LÃ³gicas
desplazamiento
rotaciÃ³n
manipulaciÃ³n
cadenas
control
programa
control
procesador
instrucciÃ³n
referirse
cero
operandos
operando
residir
registro
instrucciÃ³n
memoria
instrucciones
cero
operando
NOP
HLT
byte
longitud
operando
INC
DEC
usualmente
bytes
longitud
operandos
MOV
ADD
usualmente
longitud
bytes
referencia
reg
istro
locaciÃ³n
memoria
instrucciones
permiten
siguientes
tipos
operaciones
registro
registro
memoria
registro
inmediato
registro
registro
memoria
inmediato
memoria
tipos
datos
soporta
8088
Entero
Valor
numÃ©rico
signado
16
bits
operaciones
asumen
representaciÃ³n
complemento
Ordinal
Valor
numÃ©rico
signo
16
bits
Puntero
cantidad
32
bits
compuesto
selector
segmento
offset
16
bits
Cadena
Secuencia
continua
bytes
palabras
contener
64
Kbytes
BCD
byte
representa
dÃ­gito
BCD
BCD
empaquetado
byte
representa
dÃ­gitos
BCD
nibble
255
3.2.6
Direccionamiento
Entrada
Salida
operaciones
entrada
salida
direccionar
64
registros
S.
direcciÃ³n
aparece
bus
direcciones
forma
direcciÃ³n
memoria
instrucciones
entrada
salida
puerto
variable
registro
DX
contener
direcciÃ³n
registro
puerto
capacidad
direccionamiento
cambio
instrucciones
puerto
fijo
direccionar
256
locaciones
pÃ¡gina
cero
3.2.7
Interrupciones
8088
8088
provisto
sistema
interrupciones
vectorizado
clasificar
Interrupciones
iniciadas
hardware
Externas
enmascarables
pin
INTR
enmascarables
pin
NMI
Internas
Interrupciones
iniciadas
software
instrucciÃ³n
INT
XX
interrupciÃ³n
resulta
transferencia
control
programa
primeras
1024
03FF
posiciones
memoria
reside
tabla
256
elementos
contiene
punteros
programas
servicio
interrupciÃ³n
elemento
puntero
bytes
corresponde
llama
tipo
interrupciÃ³n
dispositivo
interrumpe
suministra
proceso
reconocimiento
interrupciÃ³n
valor
bits
vector
tipo
interrupciÃ³n
corresponda
interrupciÃ³n
inicia
pin
NMI
prioridad
pin
INTR
producirÃ¡
interrupciÃ³n
tipo
general
activar
rutinas
falla
alimentaciÃ³n
vector
suplido
internamente
ocurre
interrupciÃ³n
tipo
automÃ¡ticamente
borra
bit
registro
enmascarar
posibles
interrupciones
iniciadas
pin
INTR
interrupciÃ³n
requerida
pin
INTR
interrupciones
encuentran
habilitadas
bit
I=1
registro
256
inicia
proceso
atenciÃ³n
interrupciÃ³n
termina
ejecutar
instrucciÃ³n
corriente
bit
borra
salva
contexto
actual
contenido
conjunto
registros
stack
emite
seÃ±al
reconocimiento
interrupciÃ³n
INTA
recibirla
dispositivo
interrumpe
vuelca
bus
vector
vector
utiliza
terminar
puntero
rutina
atenciÃ³n
interrupciÃ³n
transfiere
control
dicha
rutina
terminada
rutina
restituye
contexto
continÃºa
ejecuciÃ³n
programa
interrumpido
caso
existir
dispositivo
externo
interrumpir
necesita
adicionar
hardware
controlador
interrupciones
ejemplo
controlador
8258
capaz
manejar
dispositivos
interrupciones
software
reciben
tratamiento
iniciadas
INTR
vector
caso
suministra
campo
XX
instrucciÃ³n
INT
XX
vectores
disponibles
utilizados
8088
reserva
usos
especÃ­ficos
Microprocesador
8088
may
orÃ­a
CPUs
PCs
Rutinas
Servicio
forman
programa
interrumpido
aportadas
sistema
operativo
cargan
disco
directamente
memoria
ROM
BIOS
Basic
Input
Output
System
ru
tina
servicio
interrupciÃ³n
porciÃ³n
cÃ³digo
ocupa
cabo
tarea
especÃ­fica
tipo
interrupciÃ³n
soporta
ejecuciÃ³n
programa
registros
internos
procesador
PC
AX
SP
etc.
contienen
informaciÃ³n
vinculada
rutina
servicio
utiliza
registros
ejecuciÃ³n
necesario
momento
interrupciÃ³n
informaciÃ³n
contenida
registros
resguarde
memoria
recupere
finaliza
ejecuciÃ³n
rutina
servicio
permite
programa
original
continuar
comprende
importancia
preservar
contenido
contador
programa
puntero
instrucciones
contiene
direcciÃ³n
prÃ³
xima
instrucciÃ³n
ejecutar
contenidos
registros
almacenan
zona
memoria
principal
denominada
Pila
Stack
trabaja
modalidad
LIFO
Last
In
First
Out
retorno
rutina
servicio
determinado
instrucciÃ³n
IRET
rescata
registros
Pila
257
salvaguardados
ciclo
reconocimiento
interrupciÃ³n
cargÃ¡ndolos
CPU
EjercitaciÃ³n
Ejercicio
Represente
estructura
CPU
8088
indicando
composiciÃ³n
interna
subunidades
BIU
EU
conexiÃ³n
memoria
principal
Mbytes
buses
correspondientes
Ejercicio
efecto
siguientes
instrucciones
octal
Indique
mnemÃ³nico
correspondiente
Acceda
set
instrucciones
simulador
8088
resoluciÃ³n
ejercicio
F4
BE503A
BF028B
B80100
01D8
F7D2
35AF00
F7D9
E900FF
E822FF
3400
A21300
Ejercicio
Complete
cuadro
restantes
formas
representaciÃ³n
MnemÃ³nico
hexadecimal
binario
MOV
CX
DX
09D8
0111010111111010
XOR
AX
BX
0111001111110110
F7D9
INC
Ejercicio
Indique
cantidad
bytes
almacenamiento
modos
direccionamiento
utilizados
instrucciones
cuadro
Ejercicio
258
Ejercicio
Indique
posiciÃ³n
memoria
accederÃ¡
leer
instrucciÃ³n
contenidos
registros
IP
CS
1F1A
F341
respectivamente
Ejercicio
Suponiendo
contenidos
registros
DS
Segmento
Datos
CS
Segmento
CÃ³digo
024B
B000
respectivamente
indicar
posiciÃ³n
fÃ­sica
inicio
segmentos
datos
cÃ³digo
Ejercicio
Suponiendo
contenidos
registros
DS
Segmento
Datos
CS
Segmento
CÃ³digo
000
B246
respectivamente
indicar
posiciÃ³n
fÃ­sica
inicio
segmentos
datos
cÃ³digo
Observa
problema
Ejercicio
Indicar
valor
queda
almacenado
operando
destino
ejecutar
siguientes
instrucciones
ADD
AX
BX
ADD
AX
BX
ADD
BX,0124
ADD
1A1B
ADD
BX
SI+1A
Datos
AX=1A1B
BX=147A
SI=2682
AL=1B
DS:147A
AB
DS:147B
DC
DS:1A1B=12
DS:269C=21
DS:269D
A2
Ejercicio
Escriba
instrucciones
8088
cÃ³digo
programa
lenguaje
alto
nivel
tipo
C++
considerando
variables
enteras
proponiendo
posiciones
memoria
almacenamiento
datos
programa
for
10
a[i
b[i
259
CAPÃTULO
Arquitectura
Avanzada
VisiÃ³n
General
Pipeline
2.1
IntroducciÃ³n
2.2
PredicciÃ³n
direcciÃ³n
salto
2.3
Pipeline
mÃ¡quina
elemental
Memoria
CachÃ©
3.1
Principio
localidad
3.2
Manejo
cachÃ©
DMA
4.1
Controlador
DMA
4.2
Scanner
EvoluciÃ³n
Arquitecturas
5.1
CISC
5.2
RISC
5.3
ComparaciÃ³n
RISC
CISC
EvoluciÃ³n
Procesador
8088
6.1
Funcionamiento
bÃ¡sico
procesador
Intel
80486
6.2
Funcionamiento
bÃ¡sico
procesador
Intel
Pentium
EjercitaciÃ³n
260
CapÃ­tulo
Arquitectura
Avanzada
VisiÃ³n
General
objetivo
diseÃ±o
computadora
rÃ¡pida
logra
veloz
hardware
limitaciones
velocidad
propagaciÃ³n
seÃ±ales
elÃ©ctricas
conductor
cobre
orden
20
cm
ns
ns
recorre
20
cm
pretende
construir
mÃ¡quina
ciclo
instrucciÃ³n
nanosegundos
bus
deberÃ­a
longitud
significativamente
menor
20
cm
presenta
brecha
tecnolÃ³gica
limitaciÃ³n
medida
aumentamos
velocidad
mÃ¡quina
aumenta
calor
generado
construirlas
reducido
espacio
dificulta
tarea
disiparlo
Construir
mÃ¡quinas
rÃ¡pidas
confiables
costoso
producciÃ³n
serie
implica
elevados
costos
impracticable
construir
mÃ¡quinas
rÃ¡pidas
basÃ¡ndose
tecnologÃ­as
rÃ¡pidas
aumentar
velocidad
argumento
gestores
trabajan
simultÃ¡neamente
realizan
gestiÃ³n
menor
tiempo
gestor
Obviamente
gestor
deberÃ¡
tarea
organizar
acciones
gestores
Ade
deberÃ­a
preverse
gestor
tareas
organizaciÃ³n
caso
gestor
encargado
falle
tipo
procesamiento
denomina
PROCESAMIENTO
PARALELO
implica
CPUs
trabajando
coordinada
simultÃ¡neamente
comando
forma
aumentar
velocidad
procesamiento
definimos
ğ‘‰ğ‘
ğ¼ğ‘›ğ‘ ğ‘¡ğ‘Ÿğ‘¢ğ‘ğ‘ğ‘–ğ‘œğ‘›ğ‘’ğ‘ 
ğ‘ˆğ‘›ğ‘–ğ‘‘ğ‘ğ‘‘
ğ‘‘ğ‘’
ğ‘¡ğ‘–ğ‘’ğ‘šğ‘ğ‘œ
ğ¼ğ‘›ğ‘ ğ‘¡ğ‘Ÿğ‘¢ğ‘ğ‘ğ‘–ğ‘œğ‘›ğ‘’ğ‘ 
ğ‘†ğ‘’ğ‘”ğ‘¢ğ‘›ğ‘‘ğ‘œ
adicionar
hardware
necesario
qu
CPU
busque
comience
ejecutar
instrucciÃ³n
terminado
ejecutar
instrucciÃ³n
corriente
mecanismo
llama
PROCESAMIENTO
PIPELINE
261
mencionado
aumentar
velocidad
procesamiento
podrÃ­amos
agreg
ar
memoria
rÃ¡pida
menor
capacidad
UM
cercana
CPU
bus
privado
almacenar
datos
frecuente
evitando
UM
memora
rÃ¡pida
conoce
MEMORIA
CACHÃ‰
Finalmente
agregar
hard
ware
permita
transferencias
datos
directamente
Unidad
Memoria
perifÃ©ricos
viceversa
intervenciÃ³n
mÃ­nima
CPU
forma
aumentarÃ­a
velocidad
procesamiento
dejarÃ­a
disponible
CPU
dure
transferencia
recurso
conocido
Acceso
Directo
Memoria
DMA
Pipeline
2.1
IntroducciÃ³n
Unidad
Control
tarea
analizÃ³
previamente
acciones
realiza
secuencialmente
BÃºsqueda
EjecuciÃ³n
subdividir
DecodificaciÃ³n
CÃ¡lculo
Direcciones
BÃºsqueda
Operandos
EjecuciÃ³n
propiamente
dicha
Guardar
resultado
notar
subdividir
EjecuciÃ³n
instrucciÃ³n
tareas
tarden
tiempos
similares
asignan
Unidades
Funcionales
tarea
mencionada
Unidades
Funcionales
operan
forma
simultÃ¡nea
coordinada
aumentar
velocidad
procesamiento
factor
importante
Unidad
Control
extrae
instrucciÃ³n
dirige
unidades
funcionales
ejecuciÃ³n
Unidad
Control
procede
extraer
prÃ³xima
instrucciÃ³n
envÃ­a
unidades
funcionales
sucesivamente
unidades
funcionales
estÃ©n
ocupadas
Supongamos
Unidad
Control
Unidades
Funcionales
indica
Tabla
9.1
Horizontalmente
262
considerado
tiempo
indicados
CICLOS
MEMORIA
nÃºmeros
13
Unidad
Control
coordina
acciones
suministrar
sucesivas
Unidades
Funcionales
Instrucciones
indicadas
I1
I2
IS
etc.
IS
indica
instrucciÃ³n
Salto
Tabla
9.1
Comportamiento
Unidades
Funcionales
13
ciclos
memoria
Figura
9.1
presenta
ejemplo
Pipeline
Consiste
Unidades
Funcionales
Unidad
Control
dedicadas
funciones
especÃ­ficas
Tabla
9.1
observa
proceso
ciclo
procede
buscar
instrucciÃ³n
ciclo
decodifica
instrucciÃ³n
busca
instrucciÃ³n
sucesivamente
Fig
9.1
Ejemplo
pipeline
2.2
PredicciÃ³n
direcciÃ³n
salto
instrucciÃ³n
representa
salto
observa
Tabla
9.1
ciclo
procede
buscar
prÃ³xima
instrucciÃ³n
ejecutar
Teniendo
estadÃ­sticamente
verifica
instrucci
ones
salto
representan
30
programa
incremento
velocidad
lograrse
pipeline
factor
caso
ve
263
reducido
porcentaje
indicado
Vale
pena
estudiar
tipos
saltos
posibles
disminuir
porcentaje
categorÃ­as
saltos
saltos
incondicionales
saltos
condicionales
saltos
iterativos
forma
disminuir
porcentaje
penalizaciÃ³n
salto
condicional
ejecutar
prÃ³xima
instrucciÃ³n
considerar
salto
caso
efectivamente
salto
concreta
perdido
continÃºa
proceso
normal
pipeline
salto
produce
eliminarse
instrucciones
actualmente
lÃ­nea
volver
comenzar
infiere
tÃ©cnica
dotar
procesador
registros
auxiliares
salven
contexto
sistema
momento
salto
forma
restituirlos
caso
salto
produzca
tÃ©cni
ca
eficaz
caso
saltos
incondicionales
producen
tÃ©cnica
utilizada
predicciÃ³n
direcciÃ³n
salto
programador
raramente
escribe
programa
fuente
lenguaje
ensamblador
nstrucciones
mÃ¡quina
Generalmente
escribe
lenguaje
nivel
superior
Pascal
Visual
HTML
etc
CPU
entiende
programa
escrito
lenguaje
mÃ¡quina
programa
lenguaje
ensamblador
traducido
1s
0s
necesario
traducir
programa
fuente
escrito
lenguaje
superior
lenguaje
mÃ¡quina
proceso
llama
COMPILACIÃ“N
programa
realiza
COMPILADOR
clases
predicciones
estÃ¡ticas
momento
compilaciÃ³n
dinÃ¡micas
momento
ejecuciÃ³n
caso
Compilador
estima
direcciÃ³n
instrucciones
salto
genera
ejemplo
saltos
iterativos
probable
salto
produzca
inicio
iteraciÃ³n
incondicionales
conoce
di
recciÃ³n
condicionales
suponer
probabilidad
ocurrencia
condiciÃ³n
funciÃ³n
estimar
direcciÃ³n
probable
caso
Unidad
Control
construye
tabla
saltos
guarda
comportamiento
decidir
direcciÃ³n
prÃ³xima
instrucciÃ³n
probable
requiere
agregar
hardware
264
utilizaciÃ³n
tÃ©cnicas
logrado
reducir
porcentaje
penalizaciÃ³n
10
PIPELINE
co
mo
ejemplo
cuente
tÃ©cnicas
predicciÃ³n
direcciÃ³n
salto
aumentar
Vp
expresiÃ³n
ğ‘‰ğ‘(ğ‘ğ‘–ğ‘ğ‘’ğ‘™ğ‘–ğ‘›ğ‘’
ğ‘‰ğ‘
0,9
cantidad
Unidades
Funcionales
UC
factor
dep
ende
tiempo
acceso
memoria
reloj
mÃ¡quina
2.3
Pipeline
mÃ¡quina
elemental
Ciclos
MÃ¡quina
MÃ¡quina
Elemental
observÃ³
BUS
UM
reparte
Pulsos
BUS
eventualmente
Ã³rdenes
OL
OE
Pulsos
esperan
UM
Pulsos
orden
puntual
ej.
TRA=1
idea
aprovechar
cantidad
pulsos
acciÃ³n
forma
BUS
estÃ©
ocupado
tiempo
lograrse
reestructurando
UC
Unidades
Funcionales
BÃºsqueda
EjecuciÃ³n
puedan
funcionar
forma
simultÃ¡nea
forma
esperando
UM
usarse
bus
alcanzar
permanente
UM
di
sparando
ciclos
memoria
permanentemente
2.3.1
Unidad
control
pipeline
Unidad
Control
Cableada
consta
Unidades
Funcionales
Unidad
Funcional
BÃºsqueda
UFB
Unidad
Funcional
EjecuciÃ³n
UFE
unidades
funcionar
simultÃ¡neamente
ciclo
contarÃ¡
pulsos
CP1
CP6
suponemos
UM
tiempo
acceso
pulsos
sexto
pulso
necesario
rescatar
dato
eventualmente
leÃ­do
UM
265
instrucciones
MÃ¡quina
Elemental
simples
formato
fijo
decodificaciÃ³n
cÃ³digo
operaciÃ³n
simple
decodificaciÃ³n
cuan
do
instrucciÃ³n
buscada
carga
Registro
Instrucciones
CP6
diagrama
bloque
UC
PIPELINE
ve
Figura
9.2
Ã³rdenes
bÃºsqueda
ejecuciÃ³n
emiten
sincrÃ³nicamente
pulsos
CP1
CP6
Secuenciador
abilita
UFB
UFE
seÃ±ales
HB
Unidad
Control
observarÃ¡
biestable
diferencia
vemos
biestable
UFB
cuya
salida
HB
habilitar
Unidad
Funcional
BÃºsqueda
biestable
UFE
cuya
salida
habilitar
Unidad
Funcional
EjecuciÃ³n
simplificar
mantiene
habilitada
Unidad
Funcional
EjecuciÃ³n
RUN
generar
CP1
CP6
contador
binario
natural
bits
decodificador
binar
io
UC
Cableada
GuÃ­a
DidÃ¡ctica
Ciclo
Memoria
pulsos
reloj
Tabla
9.2
PIPELINE
tiempo
transcurre
abajo
columna
izquierda
acumulado
pulsos
requeridos
ejecutar
distintas
instrucciones
columna
ACCIONES
indica
Unidad
Control
PREGUNTA
Agregar
incrementador
MÃ¡quina
Elemental
resultarÃ­a
aumento
velocidad
procesamiento
2.3.2
Secuenciador
UC
pipeline
Figura
9.3
presenta
secuenciador
Unidad
Control
Pipeline
arranca
MÃ¡quina
START
UC
pone
HB
seÃ±al
RUN
1er
ciclo
266
Fig
9.2
Diagrama
bloque
Unidad
Control
267
Fig
9.3
Secuenciador
Unidad
Control
finaliza
ciclo
Unidad
Funcional
BÃºsqueda
define
funciÃ³n
instrucciÃ³n
contenida
BUFB
instrucciÃ³n
siguientes
ADD
XOR
AND
IOR
LDA
STA
INP
OUT
UC
BUFB
instrucciÃ³n
cualquiera
restantes
HB
queda
finaliza
ciclo
Unidad
Funcional
EjecuciÃ³n
BUFB
pone
BUFB=
268
2.3.3
Ciclos
Pipeline
269
270
271
Tabla
9.2
Ciclos
pipeline
272
2.3.4
Incrementador
contador
programa
adicionado
UC
incrementador
PC
Figura
9.4
evitar
ALU
ahorran
pulsos
Fig
9.4
Incrementador
PC
2.3.5
PredicciÃ³n
direcciÃ³n
salto
predicciÃ³n
direcciÃ³n
salto
implementamos
hardware
circuito
Figura
9.5
Fig
9.5
Circuito
predicciÃ³n
salto
instrucciÃ³n
buscado
instrucciÃ³n
salto
prÃ³xima
instrucciÃ³n
buscarÃ¡
direcciÃ³n
contiene
registro
IR0-
12
direcciÃ³n
indica
PC
ejemplo
predicciÃ³n
dinÃ¡mica
estima
direcciÃ³n
salto
momento
ejecuciÃ³n
2.3.6
ComparaciÃ³n
mÃ¡quina
elemental
Tabla
9.2
observa
ejecutar
instrucciones
MÃ¡quina
Elemental
PIPELINE
necesitan
119
pulsos
reloj
Comparando
cantidad
necesaria
MÃ¡quina
Elemental
PIPELINE
lector
calcular
160
pulsos
vemos
mejora
velocidad
procesamiento
35
273
Memoria
CachÃ©
3.1
Principios
localidad
realiza
referencia
memoria
probable
prÃ³ximas
referencias
realicen
cercanÃ­as
tiempo
ejecuciÃ³n
programa
emplea
iteraciones
nÃºmero
limitado
instrucciones
principio
localidad
comportamiento
mÃ¡quina
verifica
lapso
arbitrario
90%
referencias
memoria
caen
Ã¡rea
relativamente
pequeÃ±a
principio
representa
base
sistemas
memoria
cachÃ©
velocidad
memoria
principal
sistema
menor
CPU
atendiendo
mencionado
conveniente
disponer
memoria
adicional
cachÃ©
estÃ©
cerca
CPU
controlada
pequeÃ±a
encarecer
sistema
bus
privado
definir
tÃ©cnica
apropiada
llenado
teniendo
principio
localidad
idea
general
llenado
cachÃ©
Unidad
Control
realiza
ciclo
lectura
memoria
dispare
simultÃ¡neamente
ciclo
lectura
CachÃ©
indica
Figura
9.6
Fig
9.6
Simultaneidad
ciclo
lectura
memoria
cachÃ©
culminar
Ciclo
lectura
CachÃ©
dato
continÃºa
ciclo
lectura
memoria
concluido
escribe
CachÃ©
obviamente
culminar
Ciclo
lectura
CachÃ©
dato
274
continÃºa
ciclo
lectura
memoria
dato
cachÃ©
mejora
velocidad
formalizarse
tcachÃ©
tiempo
acceso
memoria
cachÃ©
tmem
tiempo
acceso
memoria
principal
proporciÃ³n
aciertos
fracciÃ³n
lecturas
satisfechas
cachÃ©
ğ‘‡ğ‘–ğ‘’ğ‘šğ‘ğ‘œ
ğ‘šğ‘’ğ‘‘ğ‘–ğ‘œ
ğ‘‘ğ‘’
ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘œ
ğ‘¡ğ‘ğ‘ğ‘â„Ã©
ğ‘¡ğ‘šğ‘’ğ‘š(1
3.2
Manejo
cachÃ©
necesario
contenido
cachÃ©
memoria
consistentes
coincidan
importante
hora
mover
bloque
datos
memoria
programas
necesiten
datos
Ã¡rea
memoria
Â¨cacheadoÂ¨.
tÃ©cnicas
consistencia
Escritura
memoria
escribe
cachÃ©
escribe
memoria
tÃ©cnica
asegura
coincidan
momento
Retrocopiado
memoria
actualiza
cuand
necesario
ejemplo
falta
transferir
bloque
datos
memoria
perifÃ©rico
evitar
transferencia
completa
CachÃ©
adiciona
bit
palabra
memoria
cachÃ©
indica
modificada
cargÃ³
memoria
DMA
4.1
Controlador
DMA
ocurre
transferencia
Entrada
Salida
MÃ¡quina
Elemental
ejemplo
transferir
bloque
datos
memoria
perifÃ©rico
viceversa
realiza
ACC
salida
programador
deberÃ¡
cargar
ACC
instrucciÃ³n
OUT
YY
caso
entrada
instrucciÃ³n
INP
YY
cargarÃ¡
ACC
dato
perifÃ©rico
275
idea
aumentar
velocidad
transferencia
evitar
intervenga
CPU
proceso
contÃ¡ramos
procesador
auxiliar
controlar
bus
memoria
ceda
CPU
transferencia
devuelva
control
CPU
ez
finalizada
estarÃ­amos
evitando
intervenciÃ³n
CPU
podrÃ­amos
aumentar
velocidad
supone
procesador
auxiliar
hardware
software
especialmente
diseÃ±ados
funciÃ³n
UC
tareas
compartiendo
BUS
procesador
auxiliar
estÃ©
esperando
UM
PerifÃ©rico
procesador
auxiliar
llama
Controlador
DMA
Direct
Access
Memory
controlador
DMA
contar
Unidad
Control
capaz
comunicarse
CPU
controlar
UM
BUS
registros
almacenar
DirecciÃ³n
Inicial
Memoria
Bloque
transferir
registro
almacenar
Cantidad
Palabras
transferir
Registro
Datos
esquema
sop
orte
hardware
canal
datos
DMA
indica
Figura
9.7
Fig
9.7
Diagrama
bloque
canal
DMA
Observar
trayectoria
datos
transferencia
DMA
pasa
CPU
razÃ³n
transferencia
rÃ¡pida
276
Controlador
DMA
maneja
interrupciones
CPU
inicia
transferencia
DMA
enviÃ¡ndole
Controlador
DMA
direcciÃ³n
inicial
bloque
datos
enviar
perifÃ©rico
recibir
cantidad
palabras
transmitir
cediÃ©ndole
control
BUS
Controlador
DMA
culmina
transferencia
solicita
INTERRUPCIÃ“N
transfere
ncia
termina
recuperando
CPU
control
BUS
4.2
Scanner
explicado
controlador
DMA
computadora
independiente
programa
fijo
almacenado
memoria
ROM
capaz
generar
ciclos
memoria
proporcionando
direcciÃ³n
memoria
Ã³rdenes
lectura
escritura
caso
capaz
coordinar
acciones
CPU
peticionar
atenciÃ³n
UM
CPU
tareas
seguramente
UM
transferencia
DMA
BUS
ocioso
esperando
dato
escriba
lea
UM
lapsos
CPU
BUS
conflictos
CPU
necesita
acceder
UM
dure
transferencia
representa
problema
caso
transferencias
extensas
efectivamente
demorar
inaceptablemente
ejecuciÃ³n
programa
casos
conveniente
seguir
ejecutando
programa
lentamente
proceso
transferencia
DMA
implementaciÃ³n
sistema
permita
realizarlo
recibe
nombre
ROBO
CICLO
4.2.1
Robo
ciclo
UM
podÃ­a
requerida
CPU
MÃ¡quinas
DMA
UM
requerida
controlador
DMA
controladores
DMA
caso
tÃ©cnica
utilizada
lograr
aprovechamiento
UM
apuntando
aumentar
velocidad
procesamiento
agregar
hardware
administre
UM
hardware
administrador
llamado
scanner
funciona
llave
selectora
gira
constantemente
busca
procesador
necesite
UM
Supongamos
UM
compartida
CPU
DMA
Scanner
dispositivo
contarÃ­a
Puertos
Scanner
examinarÃ­a
puerto
277
requerimiento
servicio
Scanner
detiene
atiende
requerimiento
requerimiento
atendido
Scanner
avanza
puerto
sucesivamente
velocidad
avance
puerto
menor
tiempo
ciclo
memoria
variaciones
esquema
planteado
permiten
asignar
prioridades
procesadores
asegurar
recurso
perifÃ©ricos
rÃ¡pidos
EvoluciÃ³n
Arquitecturas
5.1
IntroducciÃ³n
invento
microprogramaciÃ³n
Wilkes
principio
cincuenta
idea
complejo
microcÃ³digo
irresistible
razones
validez
aÃ±os
memorias
significativamente
lentas
CPU
forma
posibilidad
bibliotecas
aplicaciones
frecuente
residentes
microcÃ³digo
ROM
rÃ¡pida
lugar
memoria
principal
representaba
soluciÃ³n
ideal
elevar
nivel
lenguaje
mÃ¡quina
incorporando
instrucciones
complejas
parecÃ­a
discusiÃ³n
microprogramaciÃ³n
permitÃ­a
modificar
agregar
instrucciones
camb
iando
microprograma
significa
simplemente
cambiar
memoria
ROM
microprogramaciÃ³n
discusiÃ³n
aÃ±os
arquitectura
siguiÃ³
proceso
perfeccionamiento
micromemoria
costosa
recordemos
rÃ¡pida
limita
dimensiÃ³n
micromemoria
ancha
45
bits
mÃ¡quina
elemental
microprogramada
llama
horizontal
implica
microinstrucciones
ejecutar
instrucciÃ³n
mÃ¡quina
rÃ¡pida
contrapartida
pensar
micromemoria
angosta
microprogramac
iÃ³n
vertical
microinstrucciones
instrucciÃ³n
menor
costo
micromemoria
verse
UC
microprogramada
secuencias
microinstrucciones
comunes
instrucciÃ³n
diÃ³
idea
escribir
microrutinas
usables
instrucciones
residir
microROM
angosta
combinarla
microprogramaciÃ³n
horizontal
alternativas
compromiso
costo
perfomance
arquitectura
mÃ¡quinas
llama
CISC
Complex
Instruction
Set
Computer
278
5.2
CISC
computadores
360
370
IBM
surgidos
dÃ©cada
70
mayorÃ­a
procesadores
CPU
computadoras
incluidos
minicomputadoras
PC
personales
Pentium
P6
Intel
68
0x0
Motorola
CISC
Complex
Instruction
Set
Computer
denominaciÃ³n
ejecutar
instrucciones
simples
ordenan
sumar
restar
nÃºmeros
registros
CPU
resultado
asignarlo
registros
instrucciones
complejas
usados
movimientos
cadenas
caracteres
longitud
variable
procesamiento
textos
instrucciones
simples
decodificaciÃ³n
ejecutarse
puls
reloj
complejas
requieren
nÃºmero
pulsos
depende
secuencia
pasos
necesarios
ejecuciÃ³n
describiÃ³
paso
cabo
combinaciones
binarias
microinstrucciones
aparecen
lÃ­neas
control
UC
pulso
reloj
activa
circuitos
intervienen
paso
sucesivas
microinstruc
iones
requiera
ejecuciÃ³n
instrucciÃ³n
compleja
provistas
ROM
firmware
Control
almacena
forma
UC
procesador
CISC
necesariamente
contener
ROM
microinstrucciones
ejecutar
instrucciones
complejas
caracterÃ­sticas
CISC
general
operaciÃ³n
ordena
instrucciÃ³n
procesador
CISC
presenta
variantes
aplicadas
diversas
estructuras
datos
simples
constantes
variables
matrices
instrucciÃ³n
ordena
sumar
variantes
cÃ³digos
funciÃ³n
estructura
datos
opera
existieran
tantas
instrucciones
ordenan
operaciÃ³n
estructuras
datos
tÃ­picas
definido
operar
concepto
279
planteado
previamente
nombre
modos
direccionamiento
instrucciÃ³n
existencia
modos
direccionamiento
operaciÃ³n
ordena
instrucciÃ³n
caracterÃ­sticas
complejidad
procesadores
CISC
manifiesta
repertorio
set
instrucciones
mÃ¡quina
CISC
presente
nÃºmero
elevado
cÃ³digos
operaciÃ³n
IBM
370
210
instrucciones
300
VAX
230
80486
Asimismo
exige
instrucciones
ocupan
distinta
cantidad
bytes
memoria
Resulta
instrucciones
ejecutables
cantidad
pulsos
rel
oj
procesador
CISC
aprovechar
eficazmente
pipeline
producciÃ³n
instrucciones
5.3
RISC
setenta
velocidad
memorias
acercÃ³
CPU
resultaba
difÃ­cil
escribir
depurar
mantener
microprogra
especialistas
comenzaron
analizar
tipo
instrucciones
usadas
programas
resultados
sorprendentes
85%
instrucciones
asignaciÃ³n
condicionales
llamadas
procedimientos
80%
instrucciones
asignaciÃ³n
tÃ©rmino
41%
procedimientos
argumentos
80%
procedimientos
variables
locales
conclusiÃ³n
teÃ³ricamente
escribir
programas
complicados
mayorÃ­a
programas
reales
consisten
simples
asignaciones
declaraciones
condicionales
llamadas
procedimientos
nÃºmero
reducido
parÃ¡metros
conclusiÃ³n
extrema
importancia
tendencia
agregar
funciones
microcÃ³digo
lenguaje
mÃ¡quina
complicado
microprograma
lento
nÃºmero
elevado
modos
direccionamiento
significa
decodificaciÃ³n
realizarse
lÃ­nea
implicarÃ­a
repetir
cientos
microcÃ³digo
sacrificado
velocidad
incorporar
instrucciones
prÃ¡ctica
rara
afirmar
idea
eliminar
microcÃ³digo
programas
corran
directamente
hardware
residiendo
rÃ¡pida
memoria
principal
Surgen
computadoras
nÃºmero
reducido
instrucciones
llamadas
mÃ¡quinas
RISC
Reduced
280
Instruction
set
Computer
Wilkes
maquinas
RISC
microprogramaciÃ³n
computadoras
complejas
eficientes
industria
volviendo
raÃ­ces
construyendo
mÃ¡quinas
sencillas
rÃ¡pidas
denominaciÃ³n
RISC
aplicada
instrucciones
caracterÃ­stica
importante
completan
ciclo
usando
pipeline
intensivamente
entendiendo
ciclo
extracciÃ³n
operandos
registro
colocarlos
bus
ejecutarlos
ALU
guardar
resultado
registro
operaciÃ³n
lleve
cabo
ciclo
formar
conjunto
instrucciones
5.3.1
Arquitectura
carga
almacenamiento
instrucciÃ³n
ejecutarse
ciclo
resulta
referencia
memoria
representan
problema
instrucciones
ordinarias
operandos
registros
permitido
direccionamiento
registros
Ãºnicas
instrucciones
referencia
memoria
LOAD
STORE
lograr
ejecuten
ciclo
recurre
exigir
instrucciÃ³n
inicie
ciclo
importar
cuan
do
termine
logra
comenzar
instrucciones
ciclos
alcanzado
promedio
instrucciÃ³n
ciclo
RISC
poseen
procesamiento
lÃ­nea
pipeline
ejemplo
RISC
unidades
funcionales
tendrÃ­a
aspecto
Tabla
9.5
ejemplo
apreciar
instrucciones
ordinarias
ejecutan
ciclos
instrucciÃ³n
LOAD
indicada
ejecuta
ciclos
observa
instrucciÃ³n
termina
ejecutarse
termine
ocurre
instrucciÃ³n
S.
casos
Compilador
verifica
instrucciÃ³n
afectada
instrucciÃ³n
L.
proceso
continÃºa
problemas
caso
contrario
lgo
hacerse
ejemplo
Compilador
reemplazar
instrucciÃ³n
NOP
implica
degradaciÃ³n
velocidad
caso
instrucciones
salto
JUMP
producirÃ¡
problema
similar
soluciÃ³n
ins
trucciÃ³n
salto
comienza
ejecutarse
independientemente
salto
cabo
casos
Compilador
responsable
colocar
instrucciÃ³n
281
Ãºtil
salto
caso
encontrar
adecuad
coloca
instrucciÃ³n
NOP
Tabla
9.3
Procesador
RISC
etapas
instrucciones
generadas
Compilador
ejecutadas
directamente
hardware
interpretadas
microcÃ³digo
razÃ³n
velocidad
RISC
complejidad
soporta
microcÃ³digo
CISC
traslada
cÃ³digo
usuario
RISC
instrucciÃ³n
compleja
implica
microinstrucciones
CISC
RISC
implicarÃ­a
nÃºmero
similar
instrucciones
ocuparÃ­a
memoria
tenerse
instrucciones
complejas
representan
porcentaje
menor
programa
real
recomienda
comparar
tiempos
ciclo
instrucciÃ³n
mÃ¡quina
elemental
mÃ¡quina
elemental
microprogramada
razÃ³n
reducido
nÃºmero
instrucciones
responde
idea
simplificar
decodificador
instrucciones
modos
direccionamiento
conviene
reducirlos
mÃ­nimo
formato
instrucciÃ³n
RISC
Figura
9.8
pu
ede
apreciarse
generar
distintos
modos
direccionamiento
Fig
9.8
Formato
tÃ­pico
instrucciÃ³n
282
operando
operaciÃ³n
toma
registro
origen
instrucciones
ordinarias
ADD
operandos
dependen
vale
I.
operando
especifican
bits
campo
desplazamiento
representa
direccionamiento
registro
operando
campo
desplazamiento
representa
direccionamiento
inmediato
instrucciones
LOAD
STORE
desplazamiento
sumado
registro
origen
obtener
direcciÃ³n
memoria
representa
direccionamiento
indexado
desplazamiento
cero
representa
direccionamiento
indirecto
registro
5.3.2
Registros
mÃºltiples
reducir
nÃºmero
cargas
almacenamientos
LOAD
STORE
chip
RISC
registros
raro
encontrar
RISC
500
registros
aprovechando
carece
firmware
organizaciÃ³n
registros
aspecto
importante
RISC
anteriormente
importante
trÃ¡fico
memoria
consecuencia
llamados
procedimientos
implica
transmitir
parÃ¡metros
salvar
registros
etc.
lugar
diseÃ±adores
RISC
plantear
organizaciÃ³n
registros
llamada
traslape
registros
traslape
registros
consiste
general
momento
CPU
accede
subgrupo
general
32
bits
divididos
grupos
Figura
9.9
registros
encuentran
momento
accesibles
CPU
representan
registros
globales
utilizables
procedimiento
cambio
grupo
24
registros
accesibles
CPU
dependiendo
valor
puntero
registros
puntero
ajusta
procedimiento
invo
cado
actual
organizaciÃ³n
permite
intercambiar
valores
procedimientos
necesidad
referir
memoria
283
Fig
9.9
OrganizaciÃ³n
registros
usados
traslape
5.4
ComparaciÃ³n
RISC
CISC
conceptos
introducidos
apartados
anteriores
establecer
comparaciÃ³n
arquitecturas
RISC
CISC
considerando
caracterÃ­sticas
particulares
5.4.1
semÃ¡ntica
programas
alto
nivel
Buscando
optimizar
performance
procesadores
realizaron
estadÃ­sticas
inst
rucciones
mÃ¡quina
usadas
ResultÃ³
instrucciones
simples
-que
20%
repertorio
instrucciones
procesador
CISC
constituÃ­an
80%
programas
tÃ­picos
ejecutados
91%
sentencias
usadas
lenguajes
lto
nivel
Fortran
Pascal
Basic
etc.
tipo
Asignar
valor
variable
IF
condicional
CaIl
llamar
procedimiento
Loop
repetir
secuencia
promedio
constituyen
47%
23%
15%
6%
respectivamente
concepciÃ³n
CISC
busca
menor
disparidad
lenguajes
alto
nivel
lenguaje
mÃ¡quina
llamar
salto
semÃ¡ntico
Recordar
sentencia
traducir
secuencia
instrucciones
mÃ¡quina
I1
I2
I3
I4
284
Suponiendo
lenguaje
alto
nivel
dicha
sentencia
comÃºn
usara
frecuentemente
CISC
hiciera
corresponder
sentencia
instrucciÃ³n
mÃ¡quina
reemplazara
instrucciones
citadas
conseguirÃ­a
escribiendo
ROM
Control
extensa
secuencia
microcÃ³digos
ejecutar
Ix
existir
equivalencias
sentencias
alto
nivel
instrucciones
mÃ¡quina
programa
traductor
niveles
compilador
sencillo
fabricar
tiempos
compilaciÃ³n
disminuirÃ­an
objetivos
arquitecturas
CISC
comprende
concepciÃ³n
llegar
extremo
fabricar
CISC
instrucciones
mÃ¡quina
equivalentes
sentencias
usadas
lenguaje
alto
nivel
usarÃ­an
programa
lenguaje
alto
nivel
utiliza
informaciÃ³n
sirviÃ³
planificar
proces
adores
repertorio
instrucciones
simples
operar
nÃºmeros
registros
CPU
resultado
asignarlo
registros
presentan
modos
direccionamiento
simples
instrucciones
ejecutan
pulso
reloj
decodificada
traducir
lenguaje
alto
nivel
tipo
instrucciones
empleando
mÃ­nimo
requiere
RISC
programa
compilador
inteligente
elaborado
necesario
compilador
software
complejo
contrapartida
hardware
simple
5.4.2
Considerando
transferencia
datos
CPU
memoria
mover
datos
memoria
registro
sentido
contrario
necesario
existencia
instrucciones
ordenen
movimientos
lenguaje
assembler
RISC
denominan
LOAD
STORE
respectivamente
instrucciones
usarlas
programas
compiladores
inteligentes
puesto
requier
pulsos
ejecutadas
decodificadas
diferencia
CISC
instrucciÃ³n
opciÃ³n
requerir
dato
memoria
285
nÃºmero
instrucciones
repertorio
procesador
RISC
reducido
70
150
instrucciones
modelo
Puesto
mayorÃ­a
instrucciones
RISC
ejecutan
pulso
reloj
resulta
pipeline
eficaz
terminÃ¡ndose
ejecutar
promedio
instrucciÃ³n
pulso
reloj
promedio
instrucciones
tipo
LOAD
STORE
requieren
pulsos
decodificadas
instrucciones
RISC
formato
fijo
ejemplo
bytes
CISC
ocupan
distinta
cantidad
bytes
redunda
sencillez
velocidad
procesamiento
constar
instrucciones
cuya
fase
ejecuciÃ³n
demanda
mayormente
pulso
sumo
requiere
ROM
Control
generar
microcÃ³digo
aparecer
salidas
UC
pulso
reloj
comandar
procesador
bits
cÃ³digo
operaciÃ³n
instrucciÃ³n
llega
registro
instrucciÃ³n
RI
ejecutado
procesador
RISC
sirven
base
circuito
UC
convierta
directamente
combinaciÃ³n
bits
aparecer
salidas
UC
microcÃ³digo
pulso
reloj
ejecute
instrucciÃ³n
cuestiÃ³n
UC
RISC
contiene
ROM
control
microcÃ³digos
permite
ganar
velocidad
evita
acceso
ROM
beneficia
diseÃ±o
chip
contiene
procesador
RISC
superficie
ocupa
ROM
Control
CISC
RISC
aprovechada
aumentar
-como
32-
nÃºmero
registros
general
CPU
nÃºmero
registros
permite
utilizar
instrucciones
LOAD
STORE
redunda
accesos
memoria
principal
mayorÃ­a
instrucciones
complejidad
trae
parejado
rendimiento
pipeline
mantenga
dependencia
resultado
instrucciÃ³n
ejecutar
recurso
ejemplo
registro
CPU
requerido
etapas
pipeli
ne
factor
influye
RISC
CISC
resultando
velocidad
procesamiento
ejemplo
resultado
instrucciÃ³n
dato
puesto
mayorÃ­a
requiere
pulsos
fases
ejecutarse
uando
instrucciÃ³n
pipeline
pasa
fase
ejecuciÃ³n
anteriores
entraron
pipeline
completaron
dicha
fase
espera
dato
opera
instrucciÃ³n
cargÃ³
registro
memoria
instrucciÃ³n
286
pipeline
llegan
instrucciones
mÃ¡quina
planificadas
compilador
inteligente
5.4.3
Comportamiento
salto
subrutinas
interrupciones
procesadores
CISC
pierden
tiempo
instrucciones
llamado
subrutina
interrupciones
consiguientes
accesos
pila
memoria
principal
requieren
estadÃ­sticas
indican
llamado
procedimientos
98%
utilizan
argumentos
92%
variables
locales
Asimismo
1%
casos
llega
llamadas
sucesivas
niveles
anidamiento
procedimiento
llame
cuarto
etc
RISC
pos
een
nÃºmero
elevado
registros
usarse
manejo
llamados
lugar
perder
tiempo
escribir
leer
pila
ubicada
memoria
5.4.4
Cuadro
comparativo
RISC
CISC
aspectos
discutidos
previamente
resumirse
tabla
comparativa
observa
Tabla
9.4
Tabla
9.4
ComparaciÃ³n
caracterÃ­sticas
RISC
CISC
287
comparaciÃ³n
RISC
CISC
determinar
entendiendo
rÃ¡pida
extremo
compleja
factores
tenerse
podrÃ­amos
orientarnos
preguntas
tipo
programas
corren
mÃ¡quina
Programas
llamadas
procedimientos
saltos
corren
CISC
programas
cortos
recursivos
corren
RISC
tipo
compilador
usÃ³
entendible
compilador
implica
programas
rÃ¡pidos
DeberÃ­an
usarse
programas
punto
flotante
visto
RISC
contar
hardware
adicional
tipo
cÃ¡lculo
tenerse
recursos
sistema
CPU
unidades
entrada
salida
sistema
operativo
etc.
tecnologÃ­a
construir
CPU
mÃ¡quinas
podrÃ­amos
comparar
distintas
tecnologÃ­as
distintos
tiempos
reloj
distintos
buses
etc
cosas
considerarse
cantidad
memor
ia
utilizada
sentido
RISC
memoria
CISC
teniendo
memorias
baratas
considerar
aspecto
medirse
trÃ¡fico
memoria
mÃ¡quina
realice
programa
referencias
memoria
tiempos
similares
general
cÃ¡lculos
desempeÃ±o
favorecen
mÃ¡quinas
RISC
conclusiÃ³n
tomarse
desestimar
arquitectura
CISC
Simplemente
significa
as
mÃ¡quinas
RISC
desempeÃ±an
CISC
construidas
diseÃ±o
tuvieron
respetar
compatibilidad
procesadores
anteriores
ejemplo
80486
hubiera
compatible
8088
seguramente
arquitectura
CISC
habrÃ­a
EvoluciÃ³n
Procesador
8088
evoluciÃ³n
tecnologÃ­a
permitido
construyan
procesadores
veloces
rendimiento
principales
Ã­tems
adicionado
mejorado
288
capacidad
memoria
aumento
tamaÃ±o
dato
32
bits
64
bits
actualmente
frecuencias
reloj
superan
3.000
Mhz
pipeline
obtenciÃ³n
anticipada
prÃ³ximas
instrucciones
ejecutar
memoria
cachÃ©
nÃºmero
registros
CPU
operaciÃ³n
multitarea
multitasking
tiempo
mejoras
permitido
procesadores
familia
puedan
ejecutar
instrucciones
modelos
anteriores
ca
mbiar
software
desarrollado
logrando
necesaria
compatibilidad
relaciÃ³n
mejoras
citadas
ejemplo
Intel
incorporado
procesadores
observa
Tabla
9.5
8086
utiliza
tipo
pipeline
realiza
obtenciÃ³n
anticipada
prÃ³ximas
instrucciones
ejecutar
procesador
80286
aumenta
frecuencia
reloj
25
MHz
presenta
opciÃ³n
coprocesador
matemÃ¡tico
externo
opcional
80287
multitasking
protegido
sistema
operativo
preparado
Opera
memoria
ALU
16
bits
24
lÃ­neas
direcciÃ³n
acceder
24
16
MB
memoria
principal
Opera
25
Mhz
80386
perfeccionar
innovaciones
80
286
corno
opcional
externo
memoria
cachÃ©
Maneja
32
bits
registros
internos
32
bits
lÃ­neas
direcciÃ³n
32
pudiendo
direccionar
32
GB
memoria
Opera
40
MHz
289
Tabla
9.5
Mejoras
procesadores
Intel
8086
80586
procesador
80486DX
opera
datos
32
bits
32
lÃ­neas
direcciÃ³n
80386
Presenta
pipeline
elaborado
interior
coprocesador
matemÃ¡tico
cachÃ©
KB
obtienen
forma
simultÃ¡nea
promedio
prÃ³ximas
instrucciones
ejecutar
procesadores
RISC
instrucciones
incluidas
usadas
resguardar
datos
pila
486
ejecutan
pulso
reloj
utilizan
microcÃ³digo
ROM
Control
Pentium
opera
internamente
32
bits
comunica
exterior
64
lÃ­neas
datos
32
direcciÃ³n
Contiene
pipeline
ALU
ejecutar
simultÃ¡neamente
instrucciones
pulso
reloj
ambas
simples
procesador
super
escalar
modelo
Von
Neumann
escalar
concepciones
RISC
predicciÃ³n
saltos
condicionales
punto
flotante
rÃ¡pido
486
P6
designado
Intel
opera
interna
externam
ente
nÃºmero
bits
Pentium
Presenta
pipeline
posibilidad
ejecutar
instrucciones
simples
pulsos
reloj
Permite
ejecutar
instrucciones
orden
establecido
programa
reordenadas
hardware
convierte
instrucciones
80x86
operaciones
simples
tipo
RISC
Incorpora
registros
32
bits
290
relaciÃ³n
registros
clÃ¡sicos
80x86
150
MHz
llegar
50%
rÃ¡pido
Pentium
computador
sistema
operativo
totalmente
32
bits
OS/2
Windows
NT
Windows
95
chip
P6
5.5
millones
transistores
viene
adosado
chip
contiene
cachÃ©
externo
nivel
level
-L2
256
51
KB
15.5
31
millones
transistores
respectivamente
Pentium
cachÃ©
interno
L1
separado
KB
instrucciones
KB
datos
caracterÃ­stica
P6
conectarse
directamente
procesadores
P6
multiprocesamiento
requerimientos
actuales
velocidad
procesamiento
necesario
desarrollo
mÃ¡quinas
designadas
Von
Neumann
sentido
procesadores
operando
juntos
paralelo
ejecutar
forma
independiente
instrucciones
programa
programas
independientes
operar
diversos
datos
tiempo
conoce
multiprocesamiento
contrapuesto
uniprocesamiento
Vo
Neumann
arquitecturas
Von
Neumann
CPU
terminar
ejecutar
juntas
instrucciones
pulso
reloj
confundirse
multiprocesamiento
multiprogramaciÃ³n
Multitasking
traducible
multitarea
consiste
ejecuciÃ³n
alternada
CPU
programas
memoria
principal
Dada
velocidad
procesamiento
parecerle
usuario
simultÃ¡nea
ejecuciÃ³n
programas
cuya
ejecuciÃ³n
realidad
alterna
rÃ¡pidamente
6.1
Funcionamiento
bÃ¡sico
procesador
Intel
80486
continuaciÃ³n
describiremos
principales
bloques
interior
procesador
486
funciones
cumplen
Figura
9.10
aparecen
siguientes
sub-bloques
bloques
registros
direcciones
RDl
datos
RDA
pertenecen
Unidad
InterconexiÃ³n
Bus
BIU
inglÃ©s
encargada
comunicaciÃ³n
exterior
32
lÃ­neas
datos
32
lÃ­neas
direcciones
bus
instrucciones
datos
leÃ­dos
memoria
pasan
cachÃ©
interno
KB
procesador
Unidad
cachÃ©
KB
guarda
instrucciones
datos
seguramente
requeridos
prÃ³ximamente
291
bus
128
lÃ­neas
leer
cachÃ©
16
bytes
pasan
buffer
Unidad
pre-carga
instrucciones
correspondientes
promedio
instrucciones
ejecutar
llegan
juntas
entrar
pipeline
cachÃ©
leÃ­do
envÃ­en
32
bits
datos
ALU
registro
CPU
64
bits
datos
Uni
dad
Punto
Flotante
FPU
inglÃ©s
escritura
cachÃ©
32
64
bits
respectivamente
Unidad
Pre
-carga
proporciona
direcc
iones
prÃ³ximas
instrucciones
ejecutar
guarda
orden
buffers
16
bytes
decodificada
Unidad
DecodificaciÃ³n
realiza
decodificaciones
instrucciÃ³n
Unidad
Control
UC
lÃ­neas
salen
activa
operaciones
pulso
reloj
distintos
bloques
CPU
conforme
establecen
microcÃ³digos
ROM
Control
Unidad
segmentaciÃ³n
paginaciÃ³n
protecciÃ³n
memoria
conocida
Unidad
manejo
memoria
MMU
inglÃ©s
encarga
proporcionar
direcciones
fÃ­sicas
memoria
utiliza
programa
unidad
convierte
referencia
direcciÃ³n
dato
viene
instrucciÃ³n
correspondiente
direcciÃ³n
fÃ­sica
Puesto
memoria
PC
divide
segmentos
necesario
subdividirse
pÃ¡ginas
unidad
encarga
protecciÃ³n
escrituras
permitidas
zonas
reservadas
memoria
292
Fig
9.10
Bloques
sub-bloques
Intel
80486
unidades
participan
pipeline
instrucciones
486
consta
etapas
progresan
pulso
reloj
compÃ¡s
millones
ciclos
Pre-carga
pre-fetch
consiste
llegada
cÃ³digos
prÃ³ximas
instrucciones
entrarÃ¡n
pipeline
buffers
16
bytes
Unidad
Pre-carga
formar
cola
DecodificaciÃ³n
Uni
dad
DecodificaciÃ³n
llegan
bytes
instrucciÃ³n
separar
bytes
forman
cÃ³digo
mÃ¡quina
cÃ³digo
operaciÃ³n
nÃºmero
referencia
direcciÃ³n
dato
cÃ³digos
operaciÃ³n
bytes
DecodificaciÃ³n
cÃ³digo
operaciÃ³n
identificado
paso
decodificado
permite
determinar
secuencia
microcÃ³digo
contenida
ROM
Control
merced
UC
generarÃ¡
seÃ±ales
control
enviarÃ¡
lÃ­neas
salen
unidad
controla
ejecute
instrucciÃ³n
pulso
reloj
instrucciÃ³n
simple
ejecuta
pulso
293
tiempo
pasa
etapa
pipeline
bytes
cÃ³digo
entran
etapa
codificaciÃ³n
EjecuciÃ³n
ejecuta
operaciÃ³n
ALU
ejemplo
leyendo
dato
operar
cachÃ©
Paralelamente
acciÃ³n
reciÃ©n
descripta
ejecutando
tareas
decodificaciÃ³n
Almacenamiento
resultados
etapa
de1
pipeline
completÃ¡ndose
ejecuciÃ³n
instrucciÃ³n
resultado
ALU
almacena
flags
genera
resultantes
operaciÃ³n
registro
6.2
Funcionamiento
bÃ¡sico
procesador
Intel
Pentium
Figura
9.11
esquema
bÃ¡sico
Pentium
basado
486
Fig
9.11
Bloques
Intel
Pentium
386
486
Pentium
instrucciones
enteros
siguen
pipeline
etapas
etapa
pre-carga
supone
cachÃ©
interno
KB
encuentran
prÃ³ximas
instrucciones
ejecutar
Pentium
pasan
promedio
juntas
bu
ffer
Unidad
294
pre-carga
almacenar
32
bytes
buffers
cachÃ©
leen
32
bytes
acceso
datos
cachÃ©
KB
memorias
cachÃ©
separadas
permite
accede
prÃ³ximas
instrucciones
ejecutar
cachÃ©
tiempo
accede
datos
esperar
Pentium
bus
datos
externo
interno
64
bits
llega
cachÃ©
posibilita
ac
ceso
cachÃ©
externo
leer
dato
instrucciÃ³n
contenido
accede
memoria
principal
cachÃ©
reciba
doble
datos
instrucciones
486
Pentium
contiene
pipeline
instrucciones
operan
nÃºmeros
enteros
procesar
instrucciones
forma
independiente
fÃ¡brica
autos
lÃ­neas
montaje
superescalar
capaz
terminar
ejecutar
instrucciones
pulso
procesadores
RISC
requiere
cachÃ©
datos
instrucciones
Asimismo
existir
duplicado
unidad
decodificadora
decodificar
instrucciones
unidad
segmen
taciÃ³n
generadora
direcciones
datos
ALU
Puesto
instrucciones
proceso
simultÃ¡neo
necesitar
acceder
juntas
cachÃ©
datos
leer
dato
operar
cachÃ©
duplicado
nÃºmero
lÃ­neas
datos
direcciones
decodificaciÃ³n
entran
instrucciones
tiempo
determina
ambas
procesarÃ¡n
juntas
pipeline
seguirÃ¡
pipeline
identifica
porciÃ³n
instrucci
Ã³n
permite
formar
direcciÃ³n
dato
pasa
unidad
segmentaciÃ³n
correspondiente
cÃ³digo
operaciÃ³n
pasarÃ¡
codificaciÃ³n
instrucciÃ³n
nÃºmeros
punto
flotante
opera
datos
64
bits
ocupan
pipelines
nÃºmeros
enteros
32
bits
procesarse
instrucciÃ³n
instrucciones
pasan
etapas
correspondientes
instrucciones
enteros
requiere
etapas
pipeline
exclusivo
punto
flotante
decirse
Pentium
presenta
pipeline
etapas
instrucciones
enteros
ejecutan
etapas
295
denominadas
instrucciones
simples
enteros
pre
-carga
decodificaciones
pasos
ejecutan
pulsos
reloj
complejidad
instrucciones
simples
ejemplo
datos
operar
registros
UCP
resultado
operaciÃ³n
asignado
registro
UCP
ejecutan
pulso
reloj
decodificaciÃ³n
decodificaciÃ³n
determina
par
instrucciones
identificadas
simples
orden
depende
resultado
ejecuciÃ³n
pipelines
procesan
paralelo
ambas
ejecutan
cantidad
pulsos
reloj
cabo
terminan
ejecutar
simultÃ¡neamente
forma
Pentium
ejecutar
instrucciones
pulso
reloj
significa
resultados
operaciones
ordenadas
obtienen
tiempo
EjercitaciÃ³n
Ejercicio
imposible
pipeline
instru
cciones
etapas
reduzca
tiempo
ciclo
instrucciones
mitad
comparaciÃ³n
diseÃ±o
pipeline
Justifique
Ejercicio
diferencia
localidad
espacial
localidad
temporal
Desarrolle
Ejercicio
Desarrolle
programas
pseudocÃ³digo
favorezca
localidad
espacial
temporal
contrario
Ejercicio
apareciÃ³
memoria
cachÃ©
sistema
disponÃ­a
Ãºnica
cachÃ©
procesadores
actuales
disponen
diversos
niveles
memoria
cachÃ©
nÃºmero
niveles
apropiados
Justifique
Ejercicio
relaciona
principio
localidad
mÃºltiples
niveles
jerarquÃ­a
memoria
computadora
Desarrolle
296
Ejercicio
diseÃ±os
sistemas
incluyeron
memoria
cachÃ©
disponÃ­an
Ãºnica
cachÃ©
almacenar
referencias
operandos
instrucciones
procesadores
actuales
tienden
cachÃ©s
separadas
divididas
dedica
instrucciones
datos
operandos
Considere
conceptos
pipeline
bÃºsqueda
datos
asociados
correspondan
Ejercicio
procesadores
RISC
unidades
control
microprogramadas
cableadas
Justifique
Ejercicio
resulta
importante
desarrollo
compiladores
mÃ¡quinas
RISC
Justifique
297
CAPÃTULO
10
Entradas
Salidas
MÃ³dulos
Canales
Procesadores
1.1
IntroducciÃ³n
1.2
MÃ³dulo
1.3
Diagrama
bloques
mÃ³dulo
1.4
TÃ©cnicas
operaciones
1.5
Ejemplo
mÃ³dulo
1.6
Canales
procesadores
Datos
SeÃ±ales
Interfaces
2.1
Datos
seÃ±ales
2.2
Ancho
banda
2.3
SeÃ±alizaciÃ³n
2.4
Interface
serie
paralela
2.5
Configuraciones
punto-a-punto
multipunto
2.6
Medios
enlace
Casos
Estudio
3.1
Puerto
USB
3.2
Puerto
Ethernet
3.3
Puerto
Bluetooth
3.4
Puerto
HDMI
3.5
Puerto
Wi-Fi
EjercitaciÃ³n
298
CapÃ­tulo
10
Entradas
Salidas
MÃ³dulos
Canales
Procesadores
1.1
IntroducciÃ³n
tercer
componente
fundamental
computadora
Unidad
Entradas
Salidas
UE
CPU
memoria
realidad
conjunto
mÃ³dulos
especializados
conectan
habitualmente
sistema
buses
bus
direcciones
bus
datos
bus
control
controla
comunicaciÃ³n
dispositivos
perifÃ©ricos
simplemente
perifÃ©
ricos
mÃ³dulo
capacidad
necesaria
permitir
comunicaciÃ³n
perifÃ©rico
sistema
buses
perifÃ©ricos
conectan
directamente
sistema
buses
alcanzar
CPU
memoria
caso
especial
diversos
motivos
perifÃ©ricos
deberÃ­a
disponerse
lÃ³gica
adicional
CPU
dispositivo
mayorÃ­a
perifÃ©ricos
lentos
CPU
memoria
desaprovecharÃ­a
tiempo
prestaciones
conectÃ¡ndolos
sistema
buses
alta
velocidad
inconveniente
CPU
memoria
gestionen
transferencias
perifÃ©ricos
altos
rendimientos
Finalmente
perifÃ©ricos
distintos
constructivamente
utilizan
datos
formatos
tamaÃ±os
distintos
computadora
comunican
mÃ³dulos
interface
nexo
procesador
memoria
conjunto
buses
di
spositivos
perifÃ©ricos
usando
enlaces
datos
especÃ­ficos
Figura
10.1
perifÃ©ricos
comunican
computadora
enlace
mÃ³dulo
especÃ­fico
enlace
permite
intercambio
seÃ±ales
control
datos
entr
mÃ³dulo
dispositivo
externo
seÃ±ales
control
determina
funciÃ³n
perifÃ©rico
seÃ±ales
indica
dispositivo
ejemplo
seÃ±alar
preparado
transferencia
Finalmente
datos
produce
efectivo
intercambio
informaciÃ³n
digital
envÃ­a
recibe
mÃ³dulo
S.
299
Fig
10.1
MÃ³dulo
S.
expuesto
perifÃ©rico
deberÃ¡
lÃ³gica
control
controla
operaciÃ³n
mÃ³dulo
S.
seÃ±ales
elÃ©ctricas
datos
requerir
transducciÃ³n
adecuaciÃ³n
caso
salida
entrada
dependiendo
caracterÃ­sticas
operativas
perifÃ©rico
Finalmente
di
spositivo
disponer
memoria
buffer
almacenar
temporalmente
datos
vienen
mÃ³dulo
perifÃ©rico
aspectos
muestran
Figura
10.2
perifÃ©ricos
clasifican
sentido
transferencia
datos
PerifÃ©ricos
entrada
PerifÃ©ricos
salida
PerifÃ©ricos
entrada-salida
interactÃºan
interacciÃ³n
humanos
interacciÃ³n
mÃ¡quinas
300
Fig
10.2
Diagrama
bloques
dispositivo
externo
perifÃ©rico
1.2
MÃ³dulos
CPU
requerir
comunicaciÃ³n
perifÃ©rico
necesidades
programa
CPU
memoria
principal
buses
compartirse
transferencias
datos
perifÃ©ricos
mÃ³dulos
deberÃ¡n
incluir
funciones
control
temporizaciÃ³n
coordinen
trÃ¡fico
recursos
internos
externos
computadora
mÃ³dulos
comunicarse
procesador
recibirÃ¡
Ã³rdenes
intercambiarÃ¡
datos
informaciÃ³n
bus
control
bus
datos
respectivamente
lÃ³gicamente
comunicaciÃ³n
perifÃ©rico
enlaces
externos
implica
Ã³rdenes
informaciÃ³n
datos
funciÃ³n
comÃºn
mÃ³dulo
almacenamiento
temporal
datos
capacidad
resuelve
diferencia
velocidades
dispositivos
internos
externos
ejemplo
rÃ¡faga
datos
proviene
CPU
memoria
principal
almacenarse
301
buffer
mÃ³dulo
enviarse
perifÃ©rico
velocidad
criterio
seguirse
transferencia
sentido
contrario
libera
memoria
principal
tiempo
ocupada
operaciÃ³n
transferencia
lenta
Finalmente
problemas
mecÃ¡nicos
elÃ©ctricos
perifÃ©ricos
informarse
funciÃ³n
detecciÃ³n
errores
comunicarse
CPU
1.3
Diagrama
bloques
mÃ³dulo
Figura
10.3
presenta
diagrama
bloques
mÃ³dulo
S.
previamente
mÃ³dulo
conecta
CPU
memoria
lÃ­neas
bus
sistema
indicadas
izquierda
figura
datos
almacenan
temporalme
nte
registros
datos
internos
mÃ³dulo
tantos
registros
lÃ³gica
control
mÃ³dulo
interactÃºa
CPU
lÃ­neas
control
mÃ³dulo
preparado
reconocer
direcciones
provienen
CPU
generar
direcciones
asociadas
perifÃ©ricos
controla
motivo
mÃ³dulo
direcciÃ³n
Ãºnica
conjunto
Ãºnico
direcciones
controla
dispositivo
externo
Finalmente
posee
lÃ³gica
dedicada
interfaz
dispositivos
controla
tÃ©rminos
mÃ³dulo
oculta
detalles
temporizaciÃ³n
formatos
datos
aspectos
constructivos
dispositivos
externos
procesador
observa
versiÃ³n
simplificada
perifÃ©rico
aplica
Ã³rdenes
lectura
escritura
mÃ³dulos
clasificarse
detalles
procesamiento
presentados
CPU
Canal
procesador
mÃ³dulo
encarga
mayorÃ­a
detalles
procesamiento
presentando
CPU
interface
alto
niv
esquema
computadoras
mainframes
Controlador
dispositivo
mÃ³dulo
sencillo
requiere
CPU
control
detallado
302
Fig
10.3
Diagrama
bloques
mÃ³dulo
S.
1.4
TÃ©cnicas
operaciones
operaciones
discutido
CapÃ­tulo
8)
utilizar
tÃ©cnicas
programada
datos
intercambian
procesador
mÃ³dulo
S.
programa
ejecuta
CPU
controla
directamente
operaciÃ³n
S.
procesador
envÃ­a
orden
mÃ³dulo
esperar
operaciÃ³n
concluya
gestiÃ³n
operaciÃ³n
programa
ejecutÃ¡ndose
CPU
rÃ¡pida
genera
desperdicio
tiempo
interrupciones
CPU
envÃ­a
orden
continÃºa
ejecutando
instrucciones
interrumpida
mÃ³dulo
terminado
operaciÃ³n
Acceso
directo
memoria
DMA
mÃ³dulo
memoria
principal
intercambian
datos
directamente
intervenciÃ³n
CPU
primeras
tÃ©cnicas
CPU
responsable
almacenar
datos
leÃ­dos
mÃ³dulo
memoria
operaciÃ³n
entrada
leerlos
memoria
operaciÃ³n
salida
303
1.5
Ejemplo
mÃ³dulo
ejemplo
mÃ³dulo
utilizado
programada
interrupciones
interface
programable
Intel
82C55A.
mÃ³dulo
propÃ³sito
general
integrado
chip
diseÃ±ado
usarse
conjunto
CPU
8088/8086
Figura
10.4
muestra
diagrama
bloques
general
derecha
observa
interface
externa
24
lÃ­neas
salidas
digitales
programables
8088/86
registro
control
registro
establecer
diversos
modos
operaciÃ³n
configuraciones
operativas
24
lÃ­neas
dividen
grupos
registros
bits
llamados
C.
registro
funcionar
puerto
bits
Alternativamente
registro
subdividirse
rse
grupos
bits
asociados
registros
B.
configuraciÃ³n
subgrupos
contienen
seÃ±ales
control
registros
B.
izquierda
interface
interna
conecta
bus
datos
8088/86
lÃ­neas
datos
bidireccional
D0-D7
transferir
datos
puertos
informaciÃ³n
registro
control
lÃ­neas
direcciones
A0-A1
seleccionan
puertos
registro
control
82C55
usarse
controlar
diversos
dispositivos
simples
Figura
10.5
muestra
diagrama
bloques
controlar
terminan
teclado
pantalla
teclado
roporciona
bits
entrada
datos
bits
SHIFT
CONTROL
lÃ­neas
adicionales
sincronizaciÃ³n
teclado
pantalla
conectada
puerto
datos
bits
bits
significado
especÃ­fico
pantalla
lÃ­neas
control
sincronizaciÃ³n
304
Fig
10.4
Diagrama
bloques
interface
programable
perifÃ©ricos
802C55A
Intel
305
Fig
10.5
Interface
teclado
pantalla
usando
802C55A.
1.6
Canales
procesadores
evoluciÃ³n
computadoras
creciente
complejidad
computadoras
manifestado
componentes
incluidos
mÃ³dulos
S.
evoluciÃ³n
describirse
secuencia
dispositivos
simples
CPU
controla
directamente
perifÃ©rico
CPU
programada
interrupciones
incorporaciÃ³n
controlador
mÃ³dulo
S.
CPU
independiza
aspectos
especÃ­ficos
interfaces
dispositivos
externos
CPU
necesita
esperar
termine
operaciÃ³n
comienzo
transferencia
mecanismo
interrupciones
306
CPU
permite
acceso
directo
mÃ³dulo
memoria
DMA
transfiere
bloque
datos
memoria
participaciÃ³n
CPU
comienzo
transferencia
funciones
realizan
participaciÃ³n
CPU
aspecto
releva
CPU
tarea
mejorando
prestaciones
generales
computadora
complejidad
mÃ³dulo
crecido
forma
incluye
mejoras
significativas
siguientes
mÃ³dulo
comportarse
procesador
reperto
rio
instrucciones
orientado
S.
CPU
procesador
ejecute
programa
memoria
interrumpida
completa
secuencia
entera
caso
mÃ³dulo
recibe
nombre
canal
S.
incluye
memoria
local
transformando
mÃ³dulo
computadora
arquitectura
mÃ³dulo
controlar
conjunto
dispositivos
mÃ­nima
intervenciÃ³n
CPU
caso
mÃ³dulo
llama
procesador
S.
habitualmente
nombres
canal
procesador
intercambiada
canal
extensiÃ³n
concepto
DMA
canal
ejecutar
instrucciones
relevando
CPU
dichas
operacio
nes
modos
operativos
Canal
selector
Figura
10.6
controla
dispositivos
velocidad
elevada
instante
dedica
transferir
datos
dispositivos
Canal
multiplexor
Figura
10.6
controlar
dispositivos
tiempo
307
Fig
10.6
Arquitectura
canal
308
Datos
SeÃ±ales
Interfaces
2.1
Datos
seÃ±ales
DATO
ente
abstracto
contiene
informaciÃ³n
lograr
representaciÃ³n
fÃ­sica
utilizamos
ondas
electromagnÃ©ticas
representaciÃ³n
llamamos
SEÃ‘AL
seÃ±ales
electromagnÃ©ticas
CONTÃNUAS
intensidad
varÃ­a
suavemente
tiempo
DISCRETAS
intensidad
cambia
bruscamente
tiempo
cas
cantidad
valores
adoptar
seÃ±al
tiempo
nivel
alto
nivel
seÃ±al
llama
seÃ±al
binaria
Figura
10.7a
indica
seÃ±al
continua
figura
10.7b
seÃ±al
discreta
Fig
10.7
SeÃ±ales
continuas
discretas
309
datos
seÃ±ales
continuos
discretos
datos
continuos
llama
ANALÃ“GICOS
discretos
llama
DIGITALES
datos
analÃ³gicos
digitales
transportarse
fuente
destino
transporte
propagaciÃ³n
procesamiento
seÃ±ales
recibe
nombre
TRANSMISIÃ“N
2.2
Ancho
banda
demostrar
serie
Fourier
seÃ±al
formada
componentes
sinusoidales
distintas
frecuencias
dominio
frecuencias
componentes
conforman
llamamos
ESPECTRO
seÃ±al
ancho
espectro
llama
ANCHO
BANDA
ABSOLUTO
seÃ±al
seÃ±al
discreta
espectro
infinitas
componentes
sinusoid
ales
ancho
banda
infinito
observando
detalle
espectro
seÃ±ales
discretas
ve
energÃ­a
concentra
sector
estrecho
banda
conoce
ANCHO
BANDA
EFECTIVO
simplemente
ANCHO
BANDA
AB
seÃ±al
unidad
Hz
ancho
banda
AB
concepto
esencial
transmisiÃ³n
datos
verifica
sistemas
transmisiÃ³n
transmisor
receptor
transferir
efi
cazmente
banda
limitada
frecuencias
banda
define
ancho
banda
sistema
transmisiÃ³n
ancho
banda
implica
costo
sistema
ancho
banda
AB
relacionado
velocidad
transmisiÃ³n
mide
cantidad
datos
transmitirse
unidad
tiempo
transmisiones
digitales
velocidad
transmisiÃ³n
VT
mide
bits
bps
indica
cantidad
bits
transmitir
AB
sistema
transmisiÃ³n
velocidad
transmitir
datos
general
comprobarse
AB
Hz
sistema
transmisiÃ³n
transmitir
velocidad
transmisiÃ³n
VT
bps
Hz
mÃ¡ximo
dependiendo
caracterÃ­sticas
canal
comunicaciones
atenuaciÃ³n
ruido
distorsiÃ³n
tasa
errores
310
2.3
SeÃ±alizaciÃ³n
transformaciÃ³n
dato
representaciÃ³n
electromagnÃ©tica
propagaciÃ³n
fÃ­sica
recibe
nombre
seÃ±alizaciÃ³n
dato
analÃ³gico
seÃ±alizar
obtener
seÃ±al
analÃ³gica
ejemplo
voz
telÃ©fono
obtener
seÃ±al
digital
ejemplo
voz
CODEC
dato
digital
seÃ±alizar
obtener
seÃ±al
analÃ³gica
ejemplo
usando
MODEM
obtener
seÃ±al
digital
ejemplo
transmisor
digital
seÃ±ales
analÃ³gicas
digitales
transmisiÃ³n
analÃ³gica
transmisiÃ³n
digital
transmisiÃ³n
digital
avanzado
desplazando
transmisiÃ³n
analÃ³gica
muchÃ­simas
aplicaciones
sucede
seÃ±alizaciÃ³n
digital
analÃ³gica
razones
EvoluciÃ³n
soporte
digital
hardware
CIs
mayores
prestaciones
Integridad
datos
Repetidoras
lugar
amplificadores
Multiplexado
eficacia
tÃ©cnicas
digitales
mx
tiempo
Seguridad
integraciÃ³n
EncriptaciÃ³n
SeÃ±alizaciÃ³n
digital
suele
mencionar
seÃ±alizaciÃ³n
digital
codificaciÃ³n
codificaciÃ³n
realiza
transformaciÃ³n
datos
digitales
seÃ±ales
digitales
seÃ±alizaciones
utilizadas
NRZ
NRZI
BIPOLAR
AMI
PSEUDOTERNARIO
MANCHESTER
MANCHESTER
DIFERENCIAL
Figura
10.8
muestra
codificaciones
311
Fig
10.8
SeÃ±alizaciÃ³n
Digital
transmisiones
realizan
CPU
UM
UE
presentan
seÃ±alizaciones
digitales
generalmente
NRZ
-L
BUS
representa
guiado
transmisiones
computado
ra
exterior
perifÃ©ricos
utilizan
tipo
seÃ±alizaciÃ³n
controladores
perifÃ©ricos
Unidad
conectados
BUS
COMÃšN
BUS
S.
arquitectura
MÃ¡quina
actual
incluye
controladores
estandarizados
facilitar
generalizar
transmisiÃ³n
datos
mÃ¡quina
controladores
reciben
nombre
Â¨puertosÂ¨
corresponden
estÃ¡ndares
incluyen
protocolos
transmisiÃ³n
2.4
Interface
serie
paralela
interface
perifÃ©rico
mÃ³dulo
caracterÃ­sticas
funcionamiento
perifÃ©rico
principales
caracterÃ­sticas
interface
serie
paralela
Figura
10.9
312
Fig
10.9
paralela
serie
interface
paralela
lÃ­neas
conectadas
mÃ³dulo
dispositivo
perifÃ©rico
transfieren
bits
simultÃ¡neamente
bus
datos
interface
serie
lÃ­nea
transmi
tir
datos
bits
transmitirse
interfaces
paralelas
utilizaron
usualmente
dispositivos
alta
velocidad
generaciÃ³n
interfaces
series
alta
velocidad
interfaces
par
alelas
comunes
Cualquiera
caso
mÃ³dulo
establecer
diÃ¡logo
perifÃ©rico
diÃ¡logo
operaciÃ³n
escritura
requiere
mÃ³dulo
envÃ­e
seÃ±al
control
solicitando
permiso
enviar
datos
perifÃ©rico
reconocer
solicitud
mÃ³dulo
inicie
transferencia
datos
finalmente
perifÃ©rico
reconocer
recepciÃ³n
datos
2.4.1
TransmisiÃ³n
paralela
caso
transmiten
bits
requerirÃ¡
tantas
lÃ­neas
bits
transmitan
lÃ­neas
adicionales
resolver
sincronismo
tipo
transmisiÃ³n
usual
unidades
internas
computadora
BUS
ejemplo
comunicaciÃ³n
CPU
UM
UE
S.
usÃ³
transmisiones
computadora
perifÃ©ricos
interface
BUS
dedicado
313
cooperaciÃ³n
Transmisor
Receptor
lugar
tÃ©cnicas
diferenciadas
TransmisiÃ³n
paralela
control
EstroboscÃ³pico
TransmisiÃ³n
paralela
Handshaking
TransmisiÃ³n
paralela
control
estroboscÃ³pico
lÃ­neas
datos
tipo
transmisiÃ³n
paralelo
lÃ­nea
sincronismo
figura
10.10
indica
caso
Fig
10.10
TransmisiÃ³n
Paralela
estroboscÃ³pica
Receptor
detecta
flanco
bajada
lÃ­nea
sincronismo
lee
guarda
lÃ­neas
datos
Figura
10.11
Fig
10.11
Diagrama
tiempo
transmisiÃ³n
paralela
estroboscÃ³pica
314
TransmisiÃ³n
paralela
handshaking
caso
lÃ­neas
datos
lÃ­neas
control
resuelven
sincronismo
lÃ­neas
SeÃ±al
EnvÃ­o
Transmisor
genera
seÃ±al
avisa
Receptor
lÃ­neas
datos
dato
enviado
SeÃ±al
AceptaciÃ³n
Receptor
genera
seÃ±al
avisa
Transmisor
recibido
guardado
dato
Transmisor
recibe
seÃ±al
aceptaciÃ³n
borra
SeÃ±al
envÃ­o
asimismo
receptor
ve
seÃ±al
envÃ­o
borrada
borra
seÃ±al
aceptaciÃ³n
forma
culmina
handshaking
apretÃ³n
manos
Figura
10.1
aprecia
lÃ³gica
Figura
10.1
diagrama
tiempo
handshaking
Fig
10.12
LÃ³gica
funcionamiento
transmisiÃ³n
paralela
handshaking
315
Fig
10.13
Diagrama
tiempo
ejemplifica
handshaking
transmisiÃ³n
paralela
sensible
perturbaciones
electromagnÃ©ticas
externas
internas
cable
seÃ±al
sincronismo
degrada
metros
distancias
mayores
utiliza
transmisiÃ³n
serie
2.4.2
TransmisiÃ³n
serie
tipo
transmisiÃ³n
bits
envÃ­an
utilizan
distintas
seÃ±alizaciones
tipos
transmisiÃ³n
serie
TransmisiÃ³n
AsÃ­ncrona
TransmisiÃ³n
SÃ­ncrona
TransmisiÃ³n
asÃ­ncrona
caso
datos
organizan
carÃ¡cter
carÃ¡cter
bits
carÃ¡cter
bits
carÃ¡cter
envÃ­an
serie
carÃ¡cter
sucesivamente
Ãºnica
lÃ­nea
Figura
10.14
Receptor
oportunidad
sincronizarse
ca
rÃ¡cter
carÃ¡cter
Fig
10.14
TransmisiÃ³n
serie
asÃ­ncrona
316
transmite
carÃ¡cter
lÃ­nea
comunicaciÃ³n
reposo
receptor
espera
recibir
bit
comienzo
receptor
detectÃ³
bit
comienzo
empieza
leer
carÃ¡cter
leÃ­do
carÃ¡cte
carÃ¡cter
bit
paridad
receptor
espera
leer
1.5
bits
parada
proceso
repite
carÃ¡cter
carÃ¡cter
logrando
forma
sincronizaciÃ³n
necesario
receptor
conozca
velocidad
transmisor
incluye
bit
paridad
Figura
10.15
muestra
caso
transmisiÃ³n
carÃ¡cter
bits
transmisiÃ³n
serie
asÃ­ncrona
Fig
10.15
Diagrama
tiempo
transmisiÃ³n
serie
asÃ­ncrona
Velocidad
ModulaciÃ³n
velocidad
modulaciÃ³n
define
VT
Velocidad
ModulaciÃ³n
BAUDIOS
VT
Velocidad
TransmisiÃ³n
bps
cantidad
bits
elemento
seÃ±al
Nota
lector
verificar
seÃ±alizaciÃ³n
Manchester
seÃ±alizaciÃ³n
NRZ-L
317
Ejemplo
transmisiÃ³n
serie
asÃ­ncrona
figura
10.16
indica
ejemplo
norma
RS232C
Fig
10.16
RS232
ejemplo
transmisiÃ³n
asÃ­ncrona
esquema
interfaces
incluidas
verse
Figura
10.17
Fig
10.17
Esquema
completo
comunicaciÃ³n
RS232
Supongamos
siguientes
valores
VT
110
bps
110
baudios
Tiempo
palabra
11
bits
1/
110
bits
0,1
VT
palabras
0,1
10
palabras
VT
carga
Ãºtil
10
palabras
bits
/palabra
70
bps
ejemplo
seÃ±alizaciÃ³n
utilizada
implica
elemento
seÃ±al
bits
baudios
bps
iguales
318
relaciÃ³n
eficiencia
enlace
Eficiencia
VT(carga
Ãºtil)/VT
100
Eficiencia
70/110
100
63
transmisiÃ³n
serie
asÃ­ncrona
acabamos
sincronizaciÃ³n
logra
receptor
VT
detecta
bit
comienzo
Seguramente
reloj
receptor
corrimiento
reloj
transmisor
desfasaje
inevitable
representa
problema
verse
Figura
10.18
Fig
10.18
Desfasaje
temporizaciÃ³n
transmisor
receptor
TransmisiÃ³n
sÃ­ncrona
caso
transmite
bloque
cantidad
importante
bits
utilizar
bits
comienzo
parada
caso
asÃ­ncrono
tipos
transmisiÃ³n
serie
sÃ­ncrona
TransmisiÃ³n
sÃ­ncrona
lÃ­nea
sincronizaciÃ³n
TransmisiÃ³n
sÃ­ncrona
autosincronizada
caso
lÃ­nea
adicional
reloj
sincronizaciÃ³n
Figura
10.19
utilizado
receptor
leer
bit
guardarlo
sincronizaciÃ³n
establecerse
flanco
descendente
reloj
tÃ©cnica
funciona
distancias
cortas
mayores
distancias
seÃ±al
sincronismo
sufre
degradaciÃ³n
importante
319
Fig
10.19
TransmisiÃ³n
serie
sÃ­ncrona
reloj
independiente
alternativa
transmite
sincronismo
seÃ±al
datos
Figura
7.20
tÃ©cnica
ahorra
lÃ­nea
sincronismo
especial
evita
degradaciÃ³n
contrapartida
requiere
ancho
banda
ejemplo
caso
seÃ±al
izaciÃ³n
Manchester
usada
Redes
LAN
Cableadas
Ethernet
seÃ±alizaciÃ³n
demanda
elementos
seÃ±al
bit
Fig
10.20
TransmisiÃ³n
serie
sÃ­ncrona
reloj
incorporado
datos
cualquiera
tÃ©cnicas
sincronizaciÃ³n
mencionadas
tipo
transmisiÃ³n
necesita
sincronizaciÃ³n
adicional
receptor
identificar
comienzo
bloque
bits
trama
Consiste
adicionar
patrÃ³n
bits
conocido
ejemplo
llamado
delimitador
trama
receptor
detecta
delimitador
comienza
termina
trama
trama
comienza
conjunto
bits
cabecera
control
incluye
metadatos
dependen
protocolo
comunicaciÃ³n
or
ejemplo
direcciones
origen
destino
tipo
prioridad
trÃ¡fico
tamaÃ±o
trama
bloque
datos
etc.
bloque
datos
termina
conjunto
bits
cola
control
bits
verificaciÃ³n
checksum
figura
10.21
representa
trama
320
Fig
10.21
Trama
transmisiÃ³n
serie
sÃ­ncrona
eficiencia
transmisiÃ³n
sÃ­ncrona
relaciÃ³n
bits
efectivos
datos
bits
significativamente
asÃ­ncrona
tenerse
bloque
datos
contiene
cantidad
bits
superior
campos
ejemplo
protocolos
reales
campos
control
delimitador
48
bits
bloque
datos
orden
8000
bits
eficiencia
caso
Eficiencia
8000/8048
100
99,4
resultado
superior
caso
asÃ­ncrono
2.5
Configuraciones
punto-a-punto
multipunto
conexiÃ³n
mÃ³dulo
computador
perifÃ©ricos
punto-a-punto
multipunto
interface
punto-a-punto
proporciona
lÃ­nea
especÃ­fica
mÃ³dulo
dispositivo
externo
Figura
10.22
computadoras
personales
comunicaciÃ³n
teclado
monitor
dispositivos
tipo
punto-a-punto
Fig
10.22
TopologÃ­a
punto
punto
321
interfaces
externas
multipunto
utilizadas
soportar
dispositivos
enlace
interfaces
multipunto
buses
externos
Figura
10.23
Fig
10.23
TopologÃ­a
Multipunto
2.6
Medios
transmisiÃ³n
medios
transmisiÃ³n
utilizados
comunicaciones
computadoras
perifÃ©ricos
computadoras
redes
datos
LAN
Cableadas
Ethernet
InalÃ¡mbricas
Wi-Fi
clasificarse
Medios
Guiados
Medios
Guiados
InalÃ¡mbricos
casos
comunicaciÃ³n
computadora
dispositivos
concreta
ondas
electromagnÃ©ticas
caracterÃ­sticas
calidad
transmisiÃ³n
determinadas
tipo
seÃ±al
caracterÃ­sticas
utilizado
2.6.1
Medios
guiados
medios
guiados
proporcionan
camino
fÃ­sico
seÃ±al
propaga
actualidad
computadora
comunicarse
bÃ¡sicamente
cualquiera
siguientes
medios
guiados
Par
Trenzado
Fibra
Ã“ptica
322
Par
trenzado
par
trenzado
consiste
cables
embutidos
aislante
entrecruzados
forma
espiral
par
cables
estable
enlace
comunicaciÃ³n
aplicaciones
agrupan
pares
envoltura
protectora
Figura
10.24
Fig
10.24
Cable
pares
trenzados
par
trenzado
datos
digitales
distancia
cortas
alcanzar
velocidades
transmisiÃ³n
orden
Gbps
largas
distancias
llegar
velocidades
transmisiÃ³n
orden
Mbps
barato
usarse
topologÃ­as
punto
punto
multipunto
usarse
pares
trenzados
apantallados
apantallar
apantallado
UTP
utiliza
habitualmente
ambientes
computacionales
Figura
10.25
telefonÃ­a
evitar
interferencias
electromagnÃ©ticas
externas
pares
trenzados
malla
metÃ¡lica
cubre
pares
STP
mejora
resultados
ambientes
crÃ­ticos
323
Fig
10.25
Cable
par
trenzado
apantallado
Fibra
Ã³ptica
fibra
Ã³ptica
flexible
capaz
transportar
informaciÃ³n
digital
haz
luz
utilizar
comunicaciones
computacionales
Figura
10.26
observa
patch
cord
fibra
transporta
luz
nÃº
cleo
fibra
cristal
plÃ¡stico
micras
diÃ¡metro
velocidad
transmisiÃ³n
llegar
cientos
Gbps
distancias
decenas
kilÃ³metros
cable
liviano
menor
atenuaciÃ³n
aislamiento
electromagnÃ©tico
pares
trenzados
324
Fig
10.26
Cable
fibra
Ã³ptica
2.6.2
Medios
guiados
inalÃ¡mbricos
medios
guiados
inalÃ¡mbricas
utilizan
antena
transmitir
recibir
aire
vacÃ­o
agua
transmisiÃ³n
antena
radia
energÃ­a
electromagnÃ©tica
circundante
recepciÃ³n
capta
ondas
electromagnÃ©ticas
rodea
comunicaciones
inalÃ¡mbricas
separan
clasifican
bandas
frecuencias
muestra
Tabla
10.1
325
Tabla
10.1
CaracterÃ­sticas
bandas
comunicaciones
comunicaciones
inalÃ¡mbricas
usadas
comunicaciones
computadora
notebook
netbook
dispositivos
mÃ³viles
transferencias
informaciÃ³n
acceder
red
datos
Figura
10.2
bandas
frecuencias
normalmente
ubicadas
banda
SHF
conocida
microondas
Fig
10.27
Comunicaciones
inalÃ¡mbricas
326
Casos
Estudio
3.1
Puerto
USB
VisiÃ³n
general
Universal
Serial
Bus
USB
estÃ¡ndar
industrial
desarrollado
mediados
aÃ±os
1990
define
cables
conectores
protocolos
usados
bus
conectar
comunicar
proveer
alimentaciÃ³n
elÃ©ctrica
ordenadores
perifÃ©ricos
dispositivos
electrÃ³
nicos
1996
lanzÃ³
especificaciÃ³n
USB
1.0
popular
1998
USB
1.1
USB
diseÃ±ado
estandarizar
conexiÃ³n
perifÃ©ricos
mouse
teclados
memorias
USB
Figura
10.2
8)
joysticks
escÃ¡neres
cÃ¡maras
digitales
telÃ©fonos
mÃ³viles
reproductores
multimedia
impresoras
dispositivos
multifuncionales
sistemas
adquisiciÃ³n
datos
mÃ³dems
tarjetas
red
tarjetas
sonido
tarjetas
sintonizadoras
televisiÃ³n
grabadora
DVD
externa
discos
duros
externos
disquetera
externas
desplazado
conectores
puerto
serie
puerto
paralelo
puerto
juegos
Apple
Desktop
Bus
PS/2
Fig
10.28
Memoria
USB
campo
aplicaciÃ³n
extiende
actualidad
dispositivo
electrÃ³nico
componentes
automÃ³viles
327
reproductores
modernos
juguetes
implementado
variaciones
industrial
militar
nota
influencia
telÃ©fonos
inteligentes
Europa
creado
norma
mÃ³viles
deberÃ¡n
veni
cargador
microUSB
tabletas
PDAs
videoconsolas
reemplazado
conectores
propietarios
completo
Aspectos
tÃ©cnicos
puerto
USB
permite
conectar
127
dispositivos
estÃ¡ndar
ordenadores
generaciÃ³n
incluyen
puertos
USB
3.0
modernos
USB
1.1
anticuados
puerto
totalmente
plug
and
play
conectar
dispositivo
reconocido
instalado
inmediata
cable
USB
transfieren
datos
alimentar
dispositivos
externos
limitaciones
tipo
conexiones
longitud
cable
superar
metros
cumplir
especificaciones
Standard
USB
iguales
1.1
2.0
Figura
10.29
Fig
10.29
Cables
USB
328
dispositivos
USB
clasifican
tipos
velocidad
transferencia
datos
Baja
velocidad
1.0
Tasa
transferencia
1,5
Mbit
188
kB
Utilizado
dispositivos
interfaz
humana
teclados
ratones
mouse
cÃ¡maras
web
etc.
Velocidad
completa
1.1
Tasa
transferencia
12
Mbit
1,5
MB
estÃ¡ndar
rÃ¡pida
especificaciÃ³n
USB
2.0
Alta
velocidad
2.0
Tasa
transferencia
480
Mbit
60
MB
tasa
real
prÃ¡ctica
mÃ¡xima
280
Mbit
35
MB
cable
USB
2.0
dispone
lÃ­neas
par
datos
par
alimentaciÃ³n
dispositivos
fabricados
actualidad
trabajan
velocidad
Superalta
velocidad
3.0
tasa
transferencia
4,8
Gbit
600
MB
velocidad
bus
rÃ¡pida
USB
2.0
incluido
contactos
adicionales
compatible
estÃ¡ndares
anteriores
especificaciones
USB
1.0
1.1
2.0
definen
tipos
conectores
conectar
dispositivos
servidor
B.
capa
mecÃ¡nica
cambiado
conectores
ejemplo
fabricantes
mantienen
seÃ±ales
protocolos
caracterÃ­sticos
USB
3.2
Puerto
Ethernet
VisiÃ³n
general
puerto
viene
integrado
tarjeta
principal
motherboard
computadora
tarjeta
placa
red
NIC
Network
Interface
Card
utiliza
interconectar
computadora
computadoras
dispositivos
red
red
LAN
Local
Area
Network
cableada
Figura
10
30
muestra
puerto
Ethernet
red
LAN
cableada
cable
UTP
329
Fig
10.30
Puerto
Ethernet
cable
UTP
placa
red
puerto
Ethernet
RJ
-45
Registered
Jack
45
interfaz
fÃ­sica
posee
pines
conexiones
elÃ©ctricas
extremos
cables
par
trenzado
UTP
STP
Figura
10.31
variante
puerto
Ethernet
interfaz
fÃ­sica
cables
fibra
Ã³ptica
Fig
10.31
Cable
par
trenzado
puerto
Ethernet
330
Aspectos
tÃ©cnicos
puerto
Ethernet
tarjeta
red
adaptador
red
Figura
10.27
muestra
puerto
Ethernet
cableado
par
trenzado
UTP
Permite
comunicaciÃ³n
aparatos
conectados
compartir
recursos
computadoras
discos
duros
CD-ROM
impresoras
etc
tarjetas
red
llama
NIC
Network
Interface
Card
diversos
tipos
adaptadores
funciÃ³n
tipo
cableado
arquitectura
utilice
red
ctualmente
comÃºn
tipo
Ethernet
utilizando
interface
conector
RJ-45
tÃ©rmino
tarjeta
red
suele
asociar
tarjeta
expansiÃ³n
insertada
ranura
interna
computador
observa
Figura
10.32
suele
utilizar
referirse
placa
integrada
placa
principal
madre
computadora
notebook
netbook
tablets
Fig
10.32
Placa
red
Ethernet
puerto
par
trenzado
UTP
tarjetas
red
Ethernet
cable
UTP
utilizan
conectores
RJ-
45
comunicaciones
10/100/1000
Mbps
actualmente
empezando
utilizar
10
Gigabit
Ethernet
331
Alternativamente
puertos
Ethernet
Fibra
Ã“ptica
1000
Mbps
superior
Figura
10
33
conectores
usuales
aplicaciones
fibra
Ã³ptica
MM
ST
Straight
Tip
fibra
MultiModo
na
soluciÃ³n
simple
conectar
computadora
directamente
red
fibra
Ã³ptica
alta
velocidad
ofrece
conexiÃ³n
fibra
directa
susceptible
interferencia
electromagnÃ©tica
Fig
10.33
Placa
red
puerto
Ethernet
fibra
Ã³ptica
3.3
Puerto
Bluetooth
VisiÃ³n
general
puerto
BlueTooth
puerto
inalÃ¡mbrico
viene
integrado
tarjeta
principal
otherboard
computadora
estandarizado
dispositivos
mÃ³viles
notebooks
netbooks
tablets
computadoras
tengan
recurso
conectividad
inalÃ¡mbrica
integrada
tarjeta
placa
red
NIC
Network
Interface
Card
utiliza
interconectar
computadora
computadoras
dispositivos
red
red
WPAN
Redes
InalÃ¡mbricas
Ãrea
Personal
Bluetooth
na
especificaciÃ³n
industrial
posibilita
transmisiÃ³n
voz
datos
dispositivos
enlace
332
radiofrecuencia
banda
ISM
2,4
GHz
principales
objetivos
pretenden
norma
Facilitar
comunicaciones
equipos
mÃ³viles
Eliminar
cables
conectores
Ofrecer
posibilidad
crear
pequeÃ±as
redes
inalÃ¡mbricas
facilitar
sincronizaciÃ³n
datos
equipos
personales
dispositivos
frecuencia
utilizan
tecnologÃ­a
siguientes
dispositivos
PDA
telÃ©fonos
mÃ³viles
computadoras
portÃ¡tiles
computadoras
impresoras
cÃ¡maras
digitales
Aspectos
tÃ©cnicos
Bluetooth
diseÃ±ado
especialmente
dispositivos
consumo
req
uieren
corto
alcance
emisiÃ³n
basados
transceptores
transmisores
receptores
costo
dispositivos
incorporan
protocolo
comunicarse
encuentran
alcance
comunicaciones
realizan
radiofrecuencia
forma
dispositivos
alineados
habitaciones
separadas
potencia
transmisiÃ³n
suficiente
dispositivos
clasifican
Clase
Clase
Clase
referencia
potencia
transmisiÃ³n
Tabla
10.2
Tabla
10.2
Clases
Bluetooth
mayorÃ­a
casos
cobertura
efectiva
dispositivo
clase
extiende
conecta
transceptor
clase
gracias
sensibilidad
potencia
transmisiÃ³n
dispositivo
clase
dispositivos
Bluetooth
clasificarse
capacidad
canal
observa
Tabla
10.3
333
Tabla
10.3
Versiones
velocidad
Bloototh
utilidad
Bluetooth
desarrollada
1994
Jaap
Haartsen
Mattisson
Sven
reemplazo
cable
trabajando
Ericsson
Lund
Suecia
prestaciones
publicadas
Bluetooth
Special
Interest
Group
SIG
SIG
anunciÃ³
formalmente
20
mayo
1998
membresÃ­a
20.000
empresas
mundo
creado
Ericsson
IBM
Intel
Toshiba
Nokia
posteriormente
sumaron
compaÃ±Ã­as
versiones
estÃ¡ndares
Bluetooth
diseÃ±adas
retro
compatibilidad
permite
estÃ¡ndar
cubra
versiones
anteriores
versiones
recientes
3.0
4.0
versiÃ³n
3.0
HS
especificaciÃ³n
Core
Bluetooth
aprobada
Bluetooth
SIG
2009
Soporta
velocidades
teÃ³ricas
transferencia
datos
24
Mbit
enlace
Bluetooth
propiamente
conexiÃ³n
Bluetooth
nativa
utiliza
negociaciÃ³n
establecimiento
trÃ¡fico
datos
alta
velocidad
realiza
enlace
Wi
-Fi
Justamente
principal
novedad
AMP
Alternate
MAC
PHY
adiciÃ³n
Wi
-Fi
transporte
alta
velocidad
especificaciÃ³n
incorporaciÃ³n
transmisiÃ³n
alta
velocidad
obligatoria
dispositivos
marcados
HS
incorporan
enlace
Wi-Fi
alta
velocidad
transferencia
datos
dispositivo
Bluetooth
3.0
sufijo
HS
soporta
alta
velocidad
334
SIG
Bluetooth
completÃ³
2010
especificaciÃ³n
nÃºcleo
Bluetooth
versiÃ³n
4.0
incluye
Bluetooth
clÃ¡sico
Bluetooth
alta
velocidad
protocolos
Bluetooth
consumo
bluetooth
alta
velocidad
basa
Wi
-Fi
Bluetooth
clÃ¡sico
consta
protocolos
Bluetooth
preexistentes
bluetooth
baja
energÃ­a
Bluetooth
Low
Energy
BLE
subconjunto
Bluetooth
v4.0
pila
protocolos
completamente
desarrollar
rÃ¡pidamente
enlaces
sencillos
alternativa
protocolos
estÃ¡ndar
Bluetooth
introdujeron
Bluetooth
v1.0
v4.0
dirigido
aplicaciones
baja
potencia
alimentados
pila
botÃ³n
3.4
Puerto
HDMI
VisiÃ³n
general
puerto
HDMI
High
-Definition
Multimedia
Interface
Interface
multimedia
alta
definiciÃ³n
norma
audio
vÃ­deo
digital
cifrado
compresiÃ³n
HDMI
provee
interface
Figura
10
34
fuente
audio
vÃ­deo
digital
computadora
sintonizador
TDT
reproductor
Blu-ray
Tablet
PC
monitor
audio
vÃ­deo
digital
compatible
televisor
digital
DTV
Fig
10.34
Conector
interface
HDMI
HDMI
permite
vÃ­deo
computarizado
mejorado
alta
definiciÃ³n
audio
digital
multicanal
Ãºnico
cable
335
Aspectos
tÃ©cnicos
conector
estÃ¡ndar
HDMI
tipo
19
pines
Tabla
10.4
definido
versiÃ³n
resoluciÃ³n
-tipo
B-
generalizado
tipo
29
pines
permitiendo
canal
vÃ­deo
expandido
pantallas
alta
resoluciÃ³n
diseÃ±ado
resoluciones
altas
tamaÃ±o
imagen
HDMI
tipo
compatible
atrÃ¡s
enlace
simple
DVI
usado
monitores
computadoras
tarjetas
grÃ¡ficas
modernas
fuente
DVI
conectarse
monitor
HDMI
viceversa
adaptador
cable
adecuado
audio
caracterÃ­sticas
control
remoto
HDMI
estarÃ¡n
disponibles
HDMI
tipo
forma
similar
compatible
atrÃ¡s
enlace
trial
DVI
Tabla
10.4
AsignaciÃ³n
pines
conector
HDMI
tipo
A.
336
conector
HDMI
diseÃ±ado
equipos
utilicen
impidan
usuario
copia
contenido
audio
-vÃ­deo
transmitido
cifrado
dichos
datos
apariciÃ³n
versiÃ³n
HDMI
2002
sucedido
sucesivas
revisiones
resumen
Tabla
10.5
especificaciÃ³n
HDMI
define
longitud
mÃ¡xima
cable
cables
atenuaciÃ³n
seÃ±al
alta
determinada
longitud
lugar
HDMI
especifica
mÃ­nimo
nivel
potencia
materiales
calidades
construcciÃ³n
permitirÃ¡n
cables
longitudes
jor
cumplimiento
requisitos
tÃ©cnicos
cables
permitirÃ¡
soportar
formatos
vÃ­deo
resoluciÃ³n
atenuaciÃ³n
seÃ±al
interferencia
causada
cables
compensadas
utilizaciÃ³n
ecualizadores
norma
HDMI
1.3
definidas
categorÃ­as
cables
llamados
CategorÃ­a
EstÃ¡ndar
HDTV
CategorÃ­a
alta
velocidad
superior
HDTV
reducir
confusiÃ³n
acerca
cables
soporte
distintos
formatos
vÃ­deo
Usando
conductores
calibre
28
AWG
cable
metros
fabricar
fÃ¡cil
econÃ³mica
especificaciones
categorÃ­a
cable
conductores
grosor
24
AWG
construcciÃ³n
estricta
tolerancias
factores
alcanzar
longitudes
12
15
metros
cables
fibra
Ã³ptica
doble
cable
Cat
-5
estÃ¡ndar
cobre
utilizar
ampliar
HDMI
100
metros
compaÃ±Ã­as
ofrecen
amplificadores
ecualizadores
repetidores
encadenar
cables
HDMI
337
Tabla
10.5
Resumen
sucesivas
revisiones
HDMI
3.5
Puerto
Wi-Fi
VisiÃ³n
general
puerto
Wi
-Fi
puerto
inalÃ¡mbrico
viene
integrado
tarjeta
principal
motherboard
computadora
estandarizado
dispositivos
mÃ³viles
notebooks
netbooks
tablets
smartphones
computadoras
recurso
conectividad
inalÃ¡mbrica
integrada
tarjeta
placa
red
NIC
Network
Interface
Card
placas
red
Wi-Fi
conexiÃ³n
USB
utiliza
interconectar
computadora
computadoras
dispositivos
red
red
WLAN
Wireless
LAN
NIC
Wi
-Fi
vienen
variedades
dependiendo
norma
ajustan
Usualmente
802.11a
802.11b
802.11
802.11n
tiempo
populares
802.11b
transmite
11
Mbit
1,375
MB
802.11
transmite
54
338
Mbit
6,75
MB
Actualmente
protocolo
viene
utilizando
802.11n
capaz
transmitir
600
Mbit
s.
Actualmente
capa
fÃ­sica
soporta
velocidad
teÃ³rica
300
Mbit
s.
Aspectos
tÃ©cnicos
tecnologÃ­a
surgiÃ³
necesidad
establecer
mecanismo
conexiÃ³n
inalÃ¡mbrica
fuese
compatible
distintos
dispositivos
Buscando
compatibilidad
1999
importantes
empresas
reunieron
crear
Wireless
Ethernet
Compatibility
Alliance
WECA
actualmente
llamada
Wi-Fi
Alliance
objetivo
designar
marca
permitiese
fomentar
fÃ¡cilmente
tecnologÃ­a
inalÃ¡mbrica
asegurar
compatibilidad
equipos
norma
inalÃ¡mbrica
IEEE
802.11
diseÃ±ada
sustituir
equivalente
cableado
IEEE
802.3
Ethernet
Ãºnico
diferencia
red
Wi
-Fi
red
Ethernet
transmiten
tramas
paquetes
datos
resto
idÃ©ntico
red
local
inalÃ¡mbrica
802.11
completamente
compatible
servicios
redes
locales
LAN
cable
802.3
Ethernet
diversos
tipos
Wi
-Fi
basado
estÃ¡ndar
original
IEEE
802.11
siguientes
estÃ¡ndares
IEEE
802.11b
IEEE
802.11
IEEE
802.11n
disfrutan
aceptaciÃ³n
internacional
banda
2.4
GHz
disponible
universalmente
velocidad
11
Mbit
54
Mbit
300
Mbit
respectivamente
estÃ¡ndar
IEEE
802.11a
conocido
WIFI
opera
banda
GHz
disfruta
operatividad
canales
relativamente
limpios
banda
GHz
recientemente
habilitada
tecnologÃ­as
Bluetooth
microondas
ZigBee
WUSB
estÃ©n
utilizando
interferencias
alcance
menor
estÃ¡ndares
trabajan
2.4
GHz
10%
frecuencia
frecuencia
menor
alcance
tecnologÃ­as
inalÃ¡mbricas
Bluetooth
funcionan
frecuencia
2.4
GHz
presentar
interferencias
tecnologÃ­a
Wi
-Fi
versiÃ³n
1.2
estÃ¡ndar
Bluetooth
ejemplo
actualizÃ³
especificaciÃ³n
existieran
interferencias
utilizaciÃ³n
simultÃ¡nea
ambas
tecnologÃ­as
339
problemas
enfrenta
actualmente
tecnologÃ­a
Wi
-Fi
progresiva
saturaciÃ³n
espectro
radioelÃ©ctrico
masificaciÃ³n
usuario
s.
afecta
especialmente
conexiones
larga
distancia
100
metros
tenerse
Wi
-Fi
diseÃ±ado
conectar
computadoras
dispositivos
mÃ³viles
red
distancias
reducidas
dispositivos
Wi-Fi
dividir
grupos
Dispositivos
DistribuciÃ³n
Red
destacan
routers
puntos
acceso
APs
Repetidores
Wi-Fi
Figura
10.35
servicio
Wi-Fi
dispositivos
terminales
Dispositivos
Terminales
equipos
NIC
Wi-Fi
placa
red
Wi-FI
internas
tarjetas
PCI
USB
caso
computadoras
personales
dispositivos
mÃ³viles
Fig
10.35
Router
Wi-Fi
Dispositivos
DistribuciÃ³n
Red
puntos
acceso
APs
dispositivos
generan
set
servicios
definirse
Red
Wi
-Fi
conectar
dispositivos
APs
permiten
conectar
dispositivos
forma
inalÃ¡mbrica
red
existente
340
agregarse
APs
red
generar
redes
cobertura
amplia
conectar
antenas
amplifiquen
seÃ±al
repetidores
inalÃ¡mbricos
equipos
utilizan
extender
cobertura
red
inalÃ¡mbrica
conectan
red
existente
seÃ±al
dÃ©bil
crean
seÃ±al
limpia
conectar
equipos
alcance
funcionan
punto
acceso
router
inalÃ¡mbricos
dispositivos
compuestos
especialmente
di
seÃ±ados
redes
pequeÃ±as
hogareÃ±as
pequeÃ±a
oficina
dispositivos
incluyen
Router
encargado
interconectar
redes
ejemplo
red
hogar
internet
punto
acceso
explicado
generalmente
switch
permite
conectar
equipos
vÃ­a
cable
Ethernet
USB
tarea
tomar
conexiÃ³n
internet
brindar
acceso
equipos
conectemos
cable
forma
inalÃ¡mbrica
dispositivos
terminales
clasifican
egÃºn
tipo
tarjeta
Wi-Fi
servicio
red
Wi-Fi
tipos
mayoritarios
tarjetas
PCI
tarjetas
PCMCIA
tarjetas
USB
tarjetas
PCI
Wi-Fi
agregan
vienen
fÃ¡brica
computadoras
personales
perdiendo
terreno
tarjetas
USB
grupo
agregarse
tarjetas
MiniPCI
vienen
integradas
computadora
portÃ¡til
disponible
mercado
tarjetas
PCMCIA
modelo
utilizÃ³
primeras
computadoras
personales
cayendo
desuso
integraciÃ³n
tarjeta
inalÃ¡mbricas
internas
computadoras
tarjetas
USB
Wi-Fi
tipo
tarjeta
comÃºn
conectar
PC
personal
portÃ¡til
ventajas
tecnologÃ­a
USB
encontrarse
tarjetas
USB
estÃ¡ndar
802.11n
estÃ¡ndar
liberado
redes
inalÃ¡mbricas
impresoras
cÃ¡maras
Web
perifÃ©ricos
funcionan
tecnologÃ­a
Wi
-Fi
permitiendo
ahorro
cableado
instalaciones
redes
especialmente
movilidad
341
EjercitaciÃ³n
Ejercicio
computadora
capaz
ejecutar
10
instrucciones
desea
conectar
computador
Ãºnicamente
perifÃ©rico
velocidad
transferencia
20.000
bytes
sg
realizan
operaciones
lectura
bloques
1.024
bytes
pretende
comportamiento
pareja
computador-perifÃ©rico
tÃ©cnicas
entrada-
salida
programada
interrupciones
DMA
rutina
transferencia
programada
consta
10
instrucciones
rutina
tratamiento
interrupciÃ³
interrupciones
consta
20
instruciones
rutina
inicializacÃ³n
DMA
consta
instrucciones
operaciÃ³n
escritura
dato
memoria
controlador
ocupa
buses
500
ns
pide
Indicar
nÃºmero
instrucciones
procesos
computador
tipos
previstos
Ejercicio
ejercicio
suponiendo
velocidad
transferencia
perifÃ©rico
100.000
bytes
bloques
512
bytes
Ejercicio
computadora
ejecutar
100.000
instrucciones
tiempo
tarda
leer
bloque
2048
bytes
indicar
instrucciones
quedarÃ­an
disponibles
procesos
conectamos
sistema
DMA
supone
rutina
inicializaciÃ³n
DMA
consta
instrucciones
operaciÃ³n
escritura
dato
memoria
controlador
ocupa
buses
750
nseg
Ejercicio
sistema
controlado
operador
serie
comandos
introducen
teclado
intervalo
horas
introducen
promedio
sesenta
comandos
Suponga
procesador
comprueba
teclado
100
ms
chequea
periodo
horas
po
rcentaje
reducirÃ­a
nÃºmero
comprobaciones
teclado
utilizase
interrupciones
342
Ejercicio
mÃ³dulo
DMA
transfiere
caracteres
memoria
robo
ciclo
dispositivo
transmite
9600
bps
procesador
ejecuta
instrucciones
ritmo
millÃ³n
disminuye
velocidad
procesador
DMA
Ejercicio
Considere
sistema
transferencia
bus
necesita
500
ns
transferencia
control
bus
sentido
procesador
dispositivo
necesita
250
ns
dispositivos
velocidad
transferencia
50
Kbytes
utiliza
DMA
datos
transfieren
byte
byte
Suponga
emplea
DMA
rÃ¡faga
interface
DMA
adquiere
control
bus
empezar
transferencia
bloque
mantiene
control
transferencia
completa
tiempo
dispositivo
bus
ocupado
transfieren
128
bytes
Repita
cÃ¡lculo
utiliza
robo
ciclo
Ejercicio
puertos
direccionar
8088
Desarrolle
Ejercicio
ventajas
8088
mapeadas
memoria
Desarrolle
analice
opciÃ³n
utiliza
8088
343
Ãndice
contenidos
CapÃ­tulo
RepresentaciÃ³n
NumÃ©rica
Sistemas
NumeraciÃ³n
12
1.1
IntroducciÃ³n
12
1.2
Confiabilidad
14
1.3
Costo
15
Sistema
NumeraciÃ³n
Binario
16
2.1
IntroducciÃ³n
16
2.2
ConversiÃ³n
nÃºmeros
distintas
bases
18
2.3
Complementos
binarios
19
2.4
RepresentaciÃ³n
nÃºmeros
negativos
binario
21
Punto
Fijo
Punto
Flotante
23
3.1
IntroducciÃ³n
23
3.2
Operaciones
aritmÃ©ticas
24
3.3
Norma
IEEE
754
25
EjercitaciÃ³n
27
CapÃ­tulo
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
CÃ³digos
30
1.1
IntroducciÃ³n
30
1.2
CÃ³digos
binarios
30
1.3
CÃ³digos
BCD
33
1.4
CÃ³digos
alfanumÃ©ricos
35
CÃ³digos
detectores
correctores
error
37
2.1
IntroducciÃ³n
37
2.2
Distancia
mÃ­nima
38
2.3
CÃ³digos
detectores
error
40
2.4
CÃ³digos
correctores
error
41
2.4.1
CÃ³digo
Hamming
42
2.4.2
VerificaciÃ³n
redundancia
LRC
CRC
44
2.4.3
CÃ³digos
bidimensionales
47
EncriptaciÃ³n
cifrado
49
cÃ³digos
51
4.1
CÃ³digos
barras
51
4.2
CÃ³digos
QR
55
EjercitaciÃ³n
60
CapÃ­tulo
Ãlgebra
Boole
VisiÃ³n
General
Ãlgebra
Boole
64
1.1
IntroducciÃ³n
64
1.2
Postulados
65
1.3
Teoremas
65
344
Funciones
lÃ³gicas
67
2.1
IntroducciÃ³n
67
2.2
Teoremas
Funciones
LÃ³gicas
67
MinimizaciÃ³n
Funciones
LÃ³gicas
71
3.1
IntroducciÃ³n
71
3.2
MÃ©todo
SimplificaciÃ³n
Karnaugh
72
Compuertas
LÃ³gicas
75
EjercitaciÃ³n
77
CapÃ­tulo
Sistemas
Combinacionales
Sistemas
Digitales
82
Sistemas
Combinacionales
83
2.1
IntroducciÃ³n
83
2.2
Circuitos
Combinacionales
MSI
84
Casos
Comunes
Sistemas
Combinacionales
MSI
84
3.1
Codificadores
84
3.2
Decodificadores
85
3.3
Multiplexores
87
3.4
Demultiplexores
89
3.5
Comparadores
91
3.6
Detectores
Generadores
Paridad
92
3.7
Sumadores
93
3.8
Unidades
AritmÃ©ticas
LÃ³gicas
97
EjercitaciÃ³n
98
CapÃ­tulo
Sistemas
Secuenciales
VisiÃ³n
general
sistemas
secuenciales
102
1.1
IntroducciÃ³n
102
1.2
Caso
Estudio
104
Biestables
108
2.1
IntroducciÃ³n
108
2.2
Biestables
AsÃ­ncronos
109
2.3
Biestables
AsÃ­ncronos
109
Tipos
Biestables
112
3.1
IntroducciÃ³n
112
3.2
Biestables
JK
112
3.3
Biestables
113
3.4
Biestables
113
Aplicaciones
Biestables
114
4.1
Registros
Desplazamiento
114
4.2
Transferencias
Registros
116
4.3
Contadores
119
4.4
MultiplicaciÃ³n
DivisiÃ³n
Binaria
121
4.4.1
MultiplicaciÃ³n
binaria
121
4.4.2
DivisiÃ³n
binaria
127
345
EjercitaciÃ³n
130
CapÃ­tulo
Memorias
ElectrÃ³nicas
VisiÃ³n
general
134
1.1
IntroducciÃ³n
134
1.2
ClasificaciÃ³n
memorias
electrÃ³nicas
137
Memorias
acceso
aleatorio
RAM
138
2.1
DefiniciÃ³n
138
2.2
Memorias
RAM
lectura
escritura
141
2.2.1
Memorias
RAM
lectura
escritura
estÃ¡ticas
141
2.2.2
Memorias
RAM
lectura
escritura
dinÃ¡micas
146
2.3
Memorias
RAM
lectura
ROM
148
2.3.1
Memorias
ROM
148
2.3.2
Memorias
PROM
149
2.3.3
Memorias
RPROM
149
2.4
ExtensiÃ³n
longitud
palabra
capacidad
150
2.4.1
ExtensiÃ³n
longitud
palabra
150
2.4.2
ExtensiÃ³n
nÃºmero
palabras
151
Memorias
acceso
serie
153
3.1
DefiniciÃ³n
153
3.2
Registros
desplazamiento
155
3.2.1
Registros
desplazamiento
estÃ¡ticos
156
3.2.2
Registros
desplazamiento
dinÃ¡micos
156
3.3
Memorias
FIFO
158
3.4
Memorias
LIFO
160
EjercitaciÃ³n
162
CapÃ­tulo
Arquitectura
BÃ¡sica
Computadora
Arquitectura
Von
Neumann
166
MÃ¡quina
elemental
168
2.1
IntroducciÃ³n
168
2.2
Arquitectura
Computadora
Elemental
171
2.2.1
Unidad
Procesamiento
Central
171
2.2.2
Memorias
RAM
lectura
escritura
dinÃ¡micas
172
2.2.3
Unidad
Entrada
Salida
172
2.3
Conjunto
Instrucciones
173
2.4
Ciclo
MÃ¡quina
177
2.5
Flujo
InformaciÃ³n
177
2.6
Unidad
Control
180
2.6.1
Unidad
Control
Cableada
180
2.6.2
Secuenciador
182
2.6.3
LÃ³gica
Control
189
2.7
Unidad
control
microprogramada
190
2.8
Bus
mÃ¡quina
elemental
198
2.9
Unidad
aritmÃ©tica
lÃ³gica
200
346
EjercitaciÃ³n
202
CapÃ­tulo
Arquitectura
Convencional
VisiÃ³n
General
206
1.1
Formato
Instrucciones
206
1.1.1
Formato
direcciones
206
1.1.2
Formato
direcciones
207
1.1.3
Formato
direcciones
207
1.1.4
Formato
direcciÃ³n
208
1.2
Modos
direccionamiento
208
1.2.1
Operando
CPU
210
1.2.2
Operando
memoria
210
Hardware
Software
212
2.1
Registros
212
2.1.1
Registros
Ã­ndices
212
2.1.2
Registros
base
213
2.2
MÃ¡quina
Elemental
Indexada
215
2.2.1
Conj
instrucciones
mÃ¡quina
elemental
indexada
216
2.2.2
Ciclos
mÃ¡quina
220
2.2.3
Interrupciones
228
2.2.4
Sistema
elemental
interrupciones
230
2.2.5
Inicio
transferencia
237
2.3
Estructura
Convencional
243
Microprocesador
Intel
8088
244
3.1
IntroducciÃ³n
244
3.2
Diagrama
Bloques
246
3.2.1
BIU
EU
247
3.2.2
Registros
8088
249
3.2.3
OrganizaciÃ³n
memoria
250
3.2.4
Modos
direccionamiento
252
3.2.5
Conjunto
instrucciones
254
3.2.6
Direccionamiento
Entrada
Salida
255
3.2.7
Interrupciones
8088
255
EjercitaciÃ³n
257
CapÃ­tulo
Arquitectura
Avanzada
VisiÃ³n
general
260
Pipeline
261
2.1
IntroducciÃ³n
261
2.2
PredicciÃ³n
DirecciÃ³n
Salto
262
2.2
Pipeline
MÃ¡quina
Elemental
264
2.3.1
Unidad
control
pipeline
264
2.3.2
Secuenciador
UC
pipeline
265
2.3.3
Ciclos
Pipeline
268
347
2.3.4
Incrementador
contador
programa
272
2.3.5
PredicciÃ³n
direcciÃ³n
salto
272
2.3.6
ComparaciÃ³n
mÃ¡quina
elemental
272
Memoria
CachÃ©
273
3.1
Principios
localidad
273
3.2
Manejo
cachÃ©
274
DMA
274
4.1
Controlador
DMA
274
4.2
Scanner
276
4.2.1
Robo
ciclo
276
EvoluciÃ³n
Arquitecturas
277
5.1
IntroducciÃ³n
277
5.2
CISC
278
5.3
RISC
279
5.3.1
Arquitectura
carga
almacenamiento
280
5.3.2
Registros
mÃºltiples
282
5.4
ComparaciÃ³n
RISC
CISC
283
5.4.1
semÃ¡ntica
programas
alto
nivel
283
5.4.2
Considerando
transferencia
datos
CPU
memoria
284
5.4.3
Comportamiento
salto
subrutinas
interrupciones
286
5.4.4
Cuadro
comparativo
RISC
CISC
286
EvoluciÃ³n
procesador
8088
287
6.1
Funcionamiento
bÃ¡sico
procesador
Intel
80486
290
6.2
Funcionamiento
bÃ¡sico
procesador
Intel
Pentium
293
EjercitaciÃ³n
295
CapÃ­tulo
10
Entradas
Salidas
MÃ³dulos
Canales
Procesadores
298
1.1
IntroducciÃ³n
298
1.2
MÃ³dulos
300
1.3
Diagrama
bloques
mÃ³dulo
301
1.4
TÃ©cnicas
operaciones
302
1.5
Ejemplo
mÃ³dulo
303
1.6
Canales
procesadores
305
Datos
SeÃ±ales
Interfaces
308
2.1
Datos
SeÃ±ales
308
2.2
Ancho
Banda
309
2.3
SeÃ±alizaciÃ³n
310
2.4
Interface
serie
paralela
311
2.4.1
TransmisiÃ³n
paralela
312
2.4.2
TransmisiÃ³n
serie
315
2.5
Configuraciones
punto-a-punto
multipunto
320
2.6
Medios
transmisiÃ³n
321
2.6.1
Medios
guiados
321
348
2.6.2
Medios
guiados
inalÃ¡mbricos
324
Casos
Estudio
326
3.1
Puerto
USB
326
3.2
Puerto
Ethernet
328
3.3
Puerto
Bluetooth
331
3.4
Puerto
HDMI
334
3.5
Puerto
Wi-Fi
337
EjercitaciÃ³n
341
Ãndice
contenidos
343
Ãndice
Figuras
349
Ãndice
Tablas
355
Ãndice
Cuadros
357
349
Ãndice
Figuras
CapÃ­tulo
RepresentaciÃ³n
NumÃ©rica
Figura
1.1
Sistemas
fÃ­sicos
representan
nÃºmeros
14
Figura
1.2
RepresentaciÃ³n
nÃºmeros
reales
punto
flotante
23
Figura
1.3
Representaciones
punto
flotante
Norma
754
26
Figura
1.4
Casos
especiales
nÃºmeros
punto
flotante
26
CapÃ­tulo
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
Figura
2.1
RelaciÃ³n
biunÃ­voca
cÃ³digo
30
Figura
2.2
Esquema
capacidad
detecciÃ³n
correcciÃ³n
error
cÃ³digo
37
Figura
2.3
Estructura
general
mensaje
protocolo
38
Figura
2.4
Esquema
capacidad
detecciÃ³n
correcciÃ³n
error
cÃ³digo
39
Figura
2.5
Figura
Esquema
enlace
datos
44
Figura
2.6
OrganizaciÃ³n
cÃ³digos
bidimensionales
47
Figura
2.7
OrganizaciÃ³n
cÃ³digos
bidimensionales
usando
Hamming
bit
paridad
48
Figura
2.8
SimbologÃ­a
EAN
UPC
53
Figura
2.9
SimbologÃ­a
CÃ³digo
39
54
Figura
2.10
SimbologÃ­a
Codabar
54
Figura
2.11
SimbologÃ­a
2/5
54
Figura
2.12
SimbologÃ­a
CÃ³digo
93
55
Figura
2.13
SimbologÃ­a
CÃ³digo
128
55
Figura
2.14
Ejemplo
CÃ³digo
QR
56
Figura
2.15
Ejemplo
CÃ³digo
QR
ticket
acceso
evento
57
Figura
2.16
CÃ³digo
QR
usado
Wikipedia
57
Figura
2.17
Ejemplo
CÃ³digo
QR
usado
cartel
comercial
58
Figura
2.18
Ejemplo
CÃ³digo
QR
59
Figura
2.19
Ejemplo
CÃ³digo
QR
59
Figura
2.20
Ejemplo
CÃ³digo
QR
60
CapÃ­tulo
Ãlgebra
Boole
Figura
3.1
Mapa
Karnaugh
funciones
variables
73
Figura
3.2
Mapa
Karnaugh
funciÃ³n
ejemplo
74
Figura
3.3
Listado
compuertas
lÃ³gicas
comunes
75
Figura
3.4
ImplementaciÃ³n
compuertas
lÃ³gicas
funciÃ³n
minimizar
76
350
CapÃ­tulo
Sistemas
Combinacionales
Figura
4.1
Diagrama
sistema
digital
82
Figura
4.2
Correspondencias
Sistema
Combinacional
83
Figura
4.3
Correspondencias
Sistema
Secuencial
83
Figura
4.4
Diagrama
bloque
sistema
circuito
Combinacional
84
Figura
4.5
Codificador
binario
entradas
salidas
85
Figura
4.6
Decodificador
entradas
salidas
86
Figura
4.7
Decodificador
3x8
implementar
funciÃ³n
86
Figura
4.8
Decodificador
4x16
decodificadores
3x8
87
Figura
4.9
Funcionamiento
multiplexor
87
Figura
4.10
Multiplexor
canales
88
Figura
4.11
ImplementaciÃ³n
funciÃ³n
usando
multiplexor
89
Figura
4.12
Multiplexor
32
canales
usando
multiplexores
16
canales
90
Figura
4.13
Demultiplexor
canales
salida
90
Figura
4.14
Demultiplexor
canales
usando
decodificador
2x4
91
Figura
4.15
Circuito
bÃ¡sico
comparaciÃ³n
bit
91
Figura
4.16
Comparador
bits
usando
comparadores
bits
92
Figura
4.17
Generador
Detector
paridad
bits
92
Figura
4.18
Semisumador
sumador
parcial
93
Figura
4.19
Sumador
94
Figura
4.20
CuÃ¡druple
sumador
95
Figura
4.21
Sumador
Restador
bits
complemento
96
Figura
4.22
Sumador
Restador
bits
complemento
97
Figura
4.23
ALU
bits
97
CapÃ­tulo
Sistemas
Secuenciales
Figura
5.1
Sistema
Secuencial
AsÃ­ncrono
103
Figura
5.2
Sistema
Secuencial
SÃ­ncrono
103
Figura
5.3
FunciÃ³n
105
Figura
5.4
FunciÃ³n
106
Figura
5.5
Circuito
Biestable
SR
NAND
106
Figura
5.6
Circuito
Biestable
SR
NOR
107
Figura
5.7
Componentes
seÃ±al
lÃ³gica
108
Figura
5.8
Biestable
SR
sÃ­ncrono
nivel
109
Figura
5.9
Biestable
SR
maestro
esclavo
110
Figura
5.10
Biestable
SR
activado
flanco
111
Figura
5.11
RepresentaciÃ³n
biestables
activados
flanco
111
Figura
5.12
Biestable
JK
Maestro
Esclavo
SR
nivel
112
Figura
5.13
Biestable
JK
flanco
ascendente
SR
flanco
113
351
Figura
5.14
Biestable
implementado
biestables
SR
JK
114
Figura
5.15
Registro
desplazamiento
bits
serie-serie
115
Figura
5.16
Registro
desplazamiento
paraleloâ€“serie
bits
115
Figura
5.17
Registro
paralelo
paralelo
bits
116
Figura
5.18
InterconexiÃ³n
registros
bus
comÃºn
118
Figura
5.19
InterconexiÃ³n
registros
usando
registros
tri-estado
118
Figura
5.20
Contador
asÃ­ncrono
bits
Diagrama
circuital
Diagrama
tiempo
120
Figura
5.21
Contador
binario
natural
bits
sÃ­ncrono
120
Figura
5.22
Multiplicador
paralelo
bits
generaciÃ³n
overflow
123
Figura
5.23
Multiplicador
serie
bits
generaciÃ³n
overflow
124
Figura
5.24
Circuito
divisor
serie
bits
128
CapÃ­tulo
Memorias
ElectrÃ³nicas
Figura
6.1
Tiempo
acceso
palabras
seg
funciÃ³n
costo
/bit
136
Figura
6.2
Esquema
general
memoria
RAM
138
Figura
6.3
Diagrama
bloques
memoria
RAM
139
Figura
6.4
Esquema
memoria
RAM
2D
140
Figura
6.5
Esquema
memoria
RAM
3D
140
Figura
6.6
Celda
bÃ¡sica
organizaciÃ³n
2D
142
Figura
6.7
Celda
bÃ¡sica
organizaciÃ³n
2D
142
Figura
6.8
RAM
lectura
escritura
organizaciÃ³n
2D
143
Figura
6.9
Diagrama
bloques
memoria
RAM
estÃ¡tica
145
Figura
6.10
Diagrama
tiempo
operaciÃ³n
lectura
escritura
146
Figura
6.11
Estructura
interna
memorias
RAM
escritura
lectura
dinÃ¡micas
DRAM
147
Figura
6.12
Esquema
conexiones
memoria
ROM
148
Figura
6.13
Esquema
conexiones
memoria
ROM
150
Figura
6.14
Memoria
palabras
k.m
bits
151
Figura
6.15
Memoria
2kN
palabras
k.m
bits
152
Figura
6.16
Memoria
ejemplo
153
Figura
6.17
Esquema
memoria
serie
154
Figura
6.18
Esquema
memoria
serie
bit
bit
154
Figura
6.19
Detalles
memoria
serie
bit
bit
154
Figura
6.20
Esquema
memoria
serie
posiciÃ³n
posiciÃ³n
155
Figura
6.21
Detalles
memoria
serie
posiciÃ³n
posiciÃ³n
155
Figura
6.22
Esquema
registro
desplazamiento
estÃ¡tico
156
Figura
6.23
Esquema
registro
desplazamiento
dinÃ¡mico
157
Figura
6.24
Circuito
operaciÃ³n
lectura
157
Figura
6.25
Circuito
operaciÃ³n
escritura
158
Figura
6.26
Esquema
memoria
FIFO
159
Figura
6.27
Funcionamiento
memoria
FIFO
159
352
Figura
6.28
Diagrama
bloques
memoria
FIFO
implementada
registro
desplazamiento
estÃ¡tico
160
Figura
6.29
Ejemplo
aplicaciÃ³n
memoria
FIFO
sistemas
digitales
160
Figura
6.30
Esquema
memoria
LIFO
161
Figura
6.31
Funcionamiento
memoria
LIFO
161
Figura
6.32
Diagrama
bloques
memoria
LIFO
implementada
registro
desplazamiento
reversible
162
Figura
6.33
Diagrama
bloque
LIFO
162
CapÃ­tulo
Arquitectura
BÃ¡sica
Computadora
Figura
7.1
Estructura
bÃ¡sica
computadora
166
Figura
7.2
Formato
datos
numÃ©ricos
punto
fijo
169
Figura
7.3
Formato
instrucciones
169
Figura
7.4
Consola
mÃ¡quina
elemental
170
Figura
7.5
Diagrama
bloques
mÃ¡quina
elemental
171
Figura
7.6
Formato
instrucciones
173
Figura
7.7
transmisiÃ³n
direcciones
Blue
179
Figura
7.8
transmisiÃ³n
instrucciones
operandos
Blue
179
Figura
7.9
Diagrama
bloques
Unidad
Control
Cableada
181
Figura
7.10
Diagrama
bloques
secuenciador
184
Figura
7.11
Diagrama
tiempos
secuenciador
184
Figura
7.12
LÃ³gica
funcionamiento
189
Figura
7.13
Vista
parcial
lÃ³gica
control
190
Figura
7.14
MÃ¡quina
elemental
unidad
control
Microprogramada
191
Figura
7.15
Unidad
control
microprogramada
194
Figura
7.16
Circuito
resuelve
requerimientos
seÃ±ales
control
199
Figura
7.17
Circuito
asociado
Registro
MBR
200
Figura
7.18
Diagrama
bloques
unidad
aritmÃ©tica
lÃ³gica
201
CapÃ­tulo
Arquitectura
Convencional
Figura
8.1
Formato
general
instrucciones
direcciones
206
Figura
8.2
Formato
general
instrucciones
direcciones
207
Figura
8.3
Formato
general
instrucciones
direcciones
207
Figura
8.4
Formato
general
instrucciones
direcciÃ³n
208
Figura
8.5
Formato
instrucciÃ³n
modificado
212
Figura
8.6
Diagrama
bloques
MÃ¡quina
Elemental
Indexada
216
353
Figura
8.7
Unidad
Control
incluyendo
sistema
elemental
Interrupciones
231
Figura
8.8
Secuencia
acciones
rutina
interrupciÃ³n
233
Figura
8.9
Sistema
interrupciones
usando
Banderas
Dispositivos
Registro
MÃ¡scaras
prioridades
236
Figura
8.10
Vector
Interrupciones
238
Figura
8.11
Sistema
interrupciones
usando
bit
Dispositivos
seÃ±al
ACK
CPU
prioridades
239
Figura
8.12
Transferencia
salida
perifÃ©rico
32
241
Figura
8.13
Transferencia
entrada
perifÃ©rico
16
242
Figura
8.14
ConfiguraciÃ³n
pines
8088
244
Figura
8.15
Diagrama
bloques
microprocesador
8088
246
Figura
8.16
Formato
microinstrucciÃ³n
8088
248
Figura
8.17
Suma
segmento
offset
251
CapÃ­tulo
Arquitectura
Avanzada
Figura
9.1
Ejemplo
pipeline
262
Figura
9.2
Diagrama
bloque
Unidad
Control
266
Figura
9.3
Secuenciador
Unidad
Control
267
Figura
9.4
Incrementador
PC
272
Figura
9.5
Circuito
predicciÃ³n
salto
272
Figura
9.6
Simultaneidad
ciclo
lectura
memoria
cachÃ©
273
Figura
9.7
Diagrama
bloque
canal
DMA
275
Figura
9.8
Formato
tÃ­pico
instrucciÃ³n
281
Figura
9.9
OrganizaciÃ³n
registros
usados
traslape
283
Figura
9.10
Bloques
sub-bloques
Intel
80486
292
Figura
9.11
Bloques
Intel
Pentium
293
CapÃ­tulo
10
Entradas
Salidas
Figura
10.1
MÃ³dulo
299
Figura
10.2
Diagrama
bloques
dispositivo
externo
PerifÃ©rico
300
Figura
10.3
Diagrama
bloques
mÃ³dulo
302
Figura
10.4
Diagrama
bloques
interface
programable
perifÃ©ricos
802C55A
Intel
304
Figura
10.5
Interface
teclado
pantalla
usando
802C55A
305
Figura
10.6
Arquitectura
canal
307
Figura
10.7
SeÃ±ales
continuas
discretas
308
Figura
10.8
SeÃ±alizaciÃ³n
Digital
311
Figura
10.9
paralela
serie
312
Figura
10.10
TransmisiÃ³n
Paralela
StroboscÃ³pica
313
354
Figura
10.11
Diagrama
tiempo
transmisiÃ³n
paralela
StroboscÃ³pica
313
Figura
10.12
LÃ³gica
funcionamiento
transmisiÃ³n
paralela
handshaking
314
Figura
10.13
Diagrama
tiempo
ejemplifica
handshaking
315
Figura
10.14
TransmisiÃ³n
serie
asÃ­ncrona
315
Figura
10.15
Diagrama
tiempo
transmisiÃ³n
serie
AsÃ­ncrona
316
Figura
10.16
RS323
ejemplo
transmisiÃ³n
asÃ­ncrona
317
Figura
10.17
Esquema
completo
comunicaciÃ³n
RS232
317
Figura
10.18
Desfasaje
temporizaciÃ³n
transmisor
receptor
318
Figura
10.19
TransmisiÃ³n
serie
sÃ­ncrona
reloj
independiente
319
Figura
10.20
TransmisiÃ³n
serie
sÃ­ncrona
reloj
incorporado
datos
319
Figura
10.21
Trama
transmisiÃ³n
serie
sÃ­ncrona
320
Figura
10.22
TopologÃ­a
punto
punto
320
Figura
10.23
TopologÃ­a
Multipunto
321
Figura
10.24
Cable
pares
trenzados
322
Figura
10.25
Patch
cord
cable
UTP
323
Figura
10.26
Patch
cord
fibra
324
Figura
10.27
Comunicaciones
inalÃ¡mbricas
325
Figura
10.28
Memoria
USB
326
Figura
10.29
Cables
USB
327
Figura
10.30
Puerto
Ethernet
cable
UTP
placa
red
329
Figura
10.31
Cable
par
trenzado
puerto
Ethernet
329
Figura
10.32
Placa
red
Ethernet
puerto
par
trenzado
UTP
330
Figura
10.33
Placa
red
puerto
Ethernet
fibra
Ã³ptica
331
Figura
10.34
Conector
interface
HDMI
334
Figura
10.35
Router
Wi-Fi
339
355
Ãndice
Tablas
CapÃ­tulo
RepresentaciÃ³n
NumÃ©rica
Tabla
1.1
Correspondencia
sistemas
numeraciÃ³n
17
Tabla
1.2
Secuencia
conversiÃ³n
decimal
binario
18
Tabla
1.3
RepresentaciÃ³n
nÃºmeros
enteros
usando
representaciÃ³n
bits
22
CapÃ­tulo
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
Tabla
2.1
CÃ³digo
binario
natural
31
Tabla
2.2
RepresentaciÃ³n
cÃ³digo
Gray
bits
33
Tabla
2.3
RepresentaciÃ³n
cÃ³digo
Johnson
bits
33
Tabla
2.4
Tipos
cÃ³digos
BCD
34
Tabla
2.5
RepresentaciÃ³n
nÃºmero
926
distintos
cÃ³digos
BCD
35
Tabla
2.6
CÃ³digo
ASCII
estÃ¡ndar
bits
36
Tabla
2.7
Ejemplos
cÃ³digos
peso
constante
.41
Tabla
2.8
Tabla
correctora
cÃ³digo
Hamming
42
CapÃ­tulo
Ãlgebra
Boole
Tabla
3.1
Tabla
funciÃ³n
f(a
67
Tabla
3.2
Pesos
variables
booleanas
70
CapÃ­tulo
Sistemas
Combinacionales
Tabla
4.1
Tabla
funciÃ³n
88
Tabla
4.2
Tabla
auxiliar
89
Tabla
4.3
Tabla
comparador
92
Tabla
4.4
Tabla
semisumador
93
Tabla
4.5
Tabla
sumador
95
CapÃ­tulo
Sistemas
Secuenciales
Tabla
5.1
Tabla
sistema
secuencial
ejemplo
105
Tabla
5.2
Tabla
biestable
SR
111
Tabla
5.3
Biestables
JK
112
Tabla
5.4
Comparativa
aproximada
tiempos
productos
126
Tabla
5.5
Secuencia
control
circuito
divisor
Figura
5.24
130
CapÃ­tulo
Memorias
ElectrÃ³nicas
Tabla
6.1
ClasificaciÃ³n
memorias
usando
principales
caracterÃ­sticas
136
Tabla
6.2
Combinaciones
lÃ­neas
control
escritura
lectura
144
356
CapÃ­tulo
Arquitectura
BÃ¡sica
Computadora
Tabla
7.1
Conjunto
Instrucciones
174
Tabla
7.2
Ciclo
bÃºsqueda
185
Tabla
7.3
EjecuciÃ³n
instrucciones
ciclos
187
Tabla
7.4
Ciclo
bÃºsqueda
instrucciones
INP
OUT
188
Tabla
7.5
Formato
microinstrucciÃ³n
mÃ¡quina
elemental
microprogramada
192
Tabla
7.5
Contenido
ROM
256
45
197
CapÃ­tulo
Arquitectura
Convencional
Tabla
8.1
Conjunto
instrucciones
MÃ¡quina
Elemental
Indexada
220
Tabla
8.2
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
LDA
3,XXXXXX
221
Tabla
8.3
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
LDA
1,XXXXXX
224
Tabla
8.4
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
LDA
0,XXXXXX
225
Tabla
8.5
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
INC2
valor
XXXXXX
226
Tabla
8.6
Formato
ciclos
bÃºsqueda
ejecuciÃ³n
instrucciÃ³n
ENI3
XXXXXX
227
Tabla
8.7
Ciclo
interrupciÃ³n
232
Tabla
8.8
Ciclo
mÃ¡quina
instrucciÃ³n
RTI
234
Tabla
8.9
Ciclo
instrucciÃ³n
OUT
YY
240
Tabla
8.10
Ciclo
instrucciÃ³n
INP
YY
241
Tabla
8.11
SÃ­mbolos
tipo
funciÃ³n
pines
8088
245
Tabla
8.12
SelecciÃ³n
registro
segmento
252
CapÃ­tulo
Arquitectura
Avanzada
Tabla
9.1Comportamiento
Unidades
Funcionales
13
ciclos
memoria
262
Tabla
9.2
Ciclos
pipeline
271
Tabla
9.3
Procesador
RISC
etapas
281
Tabla
9.4
ComparaciÃ³n
caracterÃ­sticas
RISC
CISC
286
Tabla
9.5
Mejoras
procesadores
Intel
8086
80586
289
CapÃ­tulo
10
Entradas
Salidas
Tabla
10.1
CaracterÃ­sticas
bandas
comunicaciones
325
Tabla
10.2
Clases
Bluetooth
332
Tabla
10.3
Versiones
velocidad
Bloototh
333
Tabla
10.4
AsignaciÃ³n
pines
conector
HDMI
tipo
335
Tabla
10.5
Resumen
sucesivas
revisiones
HDMI
337
357
Ãndice
Cuadros
CapÃ­tulo
CÃ³digos
NumÃ©ricos
AlfanumÃ©ricos
Cuadro
2.1
CÃ³digos
continuos
cÃ­clicos
32
Cuadro
2.2
Ejemplo
cÃ³digos
bit
paridad
usando
BCD
Nat
40
Cuadro
2.3
Ejemplo
cÃ³digo
Hamming
44
358
View
publication
statsView
publication
stats
