Principios
Ingeniería
Software
Introduccci
ón
Rigor
formalidad
Separaci
ón
intereses
Modularidad:
Abstracci
ón
Anticipaci
ón
cambio:
Generalidad
Incrementalidad
Introduccci
ón
documento
presentan
principios
enerales
importancia
centrales
desarrollar
software
forma
exitosa
tratan
proceso
ingenier
ía
software
producto
proceso
adecuado
ayudar
desarrollar
producto
deseado
tambi
én
producto
deseado
afectar
elecci
ón
proceso
utilizar
problema
tradicional
ingenier
ía
software
énfasis
proceso
producto
excluyendo
importantes
principios
suficientemente
generales
aplicados
proceso
construcci
ón
gesti
ón
software
suficientes
guiar
desarrollo
describen
propiedades
deseables
procesos
productos
software
aplicarlos
necesario
contar
étodos
apropiados
écnicas
espec
íficas
étodos
gu
ías
generales
gobiernan
ejecuci
ón
actividad
presentan
enfoques
rigurosos
sistem
áticos
disciplinados
écnicas
ás
mec
ánicas
refieren
aspectos
ás
técnicos
étodos
aplicaci
ón
restringida
metodolog
ía
conjunto
étodos
écnicas
cuyo
prop
ósito
promover
enfoque
resoluci
ón
problema
conjunto
seleccionado
herramientas
desarrolladas
apoyar
aplicaci
ón
écnicas
étodos
metodolog
ías
principios
base
étodos
técnicas
metodolog
ías
herramientas
Rigor
formalidad
proceso
creativo
tendencia
seguir
inspiraci
ón
momento
forma
estructurada
precisos
desarrollo
so
ftware
actividad
creativa
rigor
complemento
necesario
creatividad
actividades
ingenier
ía
únicamente
trav
és
enfoque
riguroso
podr
án
producirse
productos
ás
confiables
controlando
costos
incrementando
grado
confianza
rigor
qu
restringir
creatividad
contrario
potenciar
creatividad
aumentand
confianza
ingeniero
resultados
analizados
luz
evaluaciones
rigurosas
Parad
ójicamente
rigor
cualidad
intuitiva
definida
for
ma
rigurosa
alcanzarse
niveles
rigurosidad
ás
alto
formalidad
formalidad
requerimiento
ás
fuerte
rigor
requiere
proceso
oftware
guiado
evaluado
leyes
matem
áticas
Obviamente
formalidad
implica
rigor
inversa
riguroso
informalmente
campos
ingenier
ía
proceso
dise
ño
secuencia
pasos
definidos
establecidos
forma
precisa
posiblemente
probados
siguiendo
paso
alg
ún
étodo
aplicando
écnica
étodos
écnicas
án
basados
combinaci
ón
resultados
óricos
derivados
modelado
formal
realida
ajustes
emp
íricos
fen
ómenos
presentes
modelo
étodos
pr
ácticos
evaluaci
ón
dependen
experiencia
rules
of
thumb
ingeniero
ómo
cu
ándo
formal
requerido
entendiendo
nive
rigor
formalidad
alcanzado
dependiendo
dificultad
conceptual
tarea
criticidad
variar
partes
siste
ma
ejemplo
partes
cr
íticas
requerir
descripci
ón
formal
funciones
esperadas
enfoque
fo
rmal
evaluaci
ón
partes
est
ándares
entendidas
requerir
án
enfoques
ás
simples
aplica
tambi
én
caso
ingenier
ía
software
ejemplo
caso
especif
icaci
ón
software
establecerse
forma
rigurosa
utilizando
lenguaje
natural
tam
bi
én
darse
formalmente
descripci
ón
formal
lenguaje
sentencias
ógicas
ventaja
formalidad
rigor
base
mecanizaci
ón
proceso
ejemplo
utilizar
descripci
ón
formal
crear
programa
mostrar
programa
co
rresponde
especificaciones
establecidas
programa
especifi
caciones
Tradicionalmente
fase
codificaci
ón
utiliza
enfoque
formal
pro
gramas
objetos
formales
escritos
lenguaje
cuya
sintaxis
sem
ántica
est
án
completamente
definidas
programas
descripciones
formales
manipu
ladas
autom
áticamente
compiladores
chequean
correctitud
transforman
fo
rma
equivalente
lenguaje
assembler
lengu
aje
áquina
gracias
utilizaci
ón
formalidad
programaci
ón
aplicaci
ón
principio
rigor
formalidad
influen
cia
beneficiosa
obtenci
ón
cualidades
software
confiabilidad
verificabilidad
ma
ntenibilidad
reusabilidad
portabilidad
comprensi
bilidad
interoperabilidad
ejemplo
documentaci
ón
software
rigurosa
formal
mejo
rar
cualidades
documentaci
ón
informal
ambigua
inconsistente
incompleta
principio
rigor
formalidad
tambi
én
aplica
proceso
software
documentaci
ón
rigurosa
proceso
ayuda
reutilizado
proyectos
similares
tambi
én
ayuda
mantener
producto
existente
permitiendo
modificaciones
rea
licen
partiendo
nivel
intermedio
apropiado
lugar
ódigo
proceso
software
est
especificado
forma
rigurosa
gerentes
podr
án
controlar
adecuaci
ón
evaluar
oportunidad
mejorar
productividad
Separaci
ón
intereses
principio
permite
enfrentarse
distintos
aspectos
individuales
problema
forma
concentrarse
separado
desarr
ollo
producto
software
tomarse
decisiones
funciones
án
ofrecidas
confiabilidad
esperada
eficiencia
tiempo
espacio
relaciones
ambiente
recursos
softwar
hardware
especial
interfaces
usuario
decisiones
proce
so
desarrollo
ambiente
desarrollo
organizaci
ón
estructura
equipo
agenda
procedimi
entos
control
estrategias
dise
ño
mecanismos
recuperaci
ón
frente
errores
ás
temas
econ
ómicos
financieros
decisiones
pued
relacionadas
obviamente
podr
án
tratadas
forma
separada
án
fuertemente
relacionadas
pr
ácticamente
imposible
tema
tiempo
personas
única
forma
enfrentar
complejidad
proyecto
separar
distintos
intereses
forma
separar
dis
tintos
intereses
seg
ún
tiempo
permite
planificar
distintas
actividades
eliminar
trabajo
extra
implica
cambiar
forma
restringida
separaci
ón
seg
ún
tiempo
motivaci
ón
ciclo
vida
software
modelo
racional
secuencia
actividades
deber
ían
seguirse
producci
ón
software
forma
separaci
ón
intereses
érminos
cualidades
deber
ían
tratarse
separado
ejemplo
podr
ían
enfrentarse
separadamente
eficiencia
correc
titud
programa
dise
ñándolo
cuidadosa
estructuradamente
garantizar
correctitud
priori
reestructurarlo
mejorar
eficiencia
tipo
importante
separaci
ón
intereses
permite
distintas
visiones
oftware
analizadas
forma
separada
ejemplo
analizar
requ
erimientos
aplicaci
ón
podr
ía
ayuda
concentrarse
datos
fluyen
actividad
flujo
control
gobierna
sincronizaci
ón
dichas
actividades
Ambas
ayudan
entender
sistema
provee
visi
ón
completa
forma
ás
aplicaci
ón
principio
enfrentar
partes
istema
forma
separada
érminos
tama
ño
concepto
fundamental
dominars
enfrentar
complejidad
producci
ón
software
importante
com
punto
aparte
principio
modularidad
podr
ían
perderse
optimizaciones
potenciales
problema
conjunto
complejidad
global
resolverse
mu
cho
concentr
ándose
distintos
aspectos
separado
descomponer
problema
distintos
aspectos
forma
inmed
iata
tomar
inicialmente
decisiones
dise
ño
generales
aplicar
principio
separaci
ón
intereses
forma
efectiva
observaci
ón
separaci
ón
intereses
podr
ía
resultar
separaci
ón
responsabilidades
enfrentarse
distintos
aspectos
cue
nta
base
dividir
trabaj
problema
complejo
asignaciones
trabajo
espec
íficas
posiblemente
personas
distintas
distint
as
habilidades
Modularidad
sistema
complejo
dividirse
piezas
ás
simples
llamadas
ódulos
sistema
compuesto
módulos
llamado
modular
principal
beneficio
modularidad
permite
aplicaci
ón
principio
separaci
ón
intereses
fases
enfrentar
detal
ódulo
separado
ignorando
detalles
ódulos
enfrentar
caracter
ísticas
globales
ódulos
relaciones
integrarlos
único
sistema
coherente
fases
ejecutad
as
orden
sistema
dise
ñado
abajo
bottom
up
orden
inverso
sistema
dise
ñado
abajo
top
down
principio
modularidad
objetivo
principales
capacidad
descomponer
sistema
complejo
capacidad
componerlo
ódulos
existentes
comprensi
ón
sistema
piezas
pedazos
posibilidad
descomponer
sistema
basa
dividir
subproblemas
forma
top
down
problema
original
aplicar
principio
ca
subproblema
forma
recursiva
procedimien
to
refleja
conocido
principio
Divide
Vencer
ás
Divide
Conquer
posibilidad
componer
sistema
est
basada
obtener
sistema
forma
bottom
up
componentes
elementales
Idealmente
produc
ci
ón
software
quisiera
ensamblar
aplicaciones
tomando
ódulos
biblioteca
combin
ándolos
formar
producto
requerido
módulos
deber
ían
dise
ñados
objetivo
expreso
reusables
capacidad
comprender
sistema
forma
separada
ayuda
modificabilidad
sistema
naturaleza
evolutiva
softw
are
volver
atr
ás
trabajo
previo
modificarlo
sistema
comprendido
modificaciones
án
dif
íciles
aplicar
resultado
confiable
necesario
reparar
sistema
modularizaci
ón
apropiada
ayuda
restringir
úsqueda
fuente
error
componentes
separados
alcanzar
objetivos
ódulos
divida
sistema
lta
cohesi
ón
acoplamiento
ódulo
alta
cohesi
ón
elementos
est
án
fuertemente
relacionados
agrupados
raz
ón
ógica
cooperan
alcanzar
objet
ivo
com
ún
funci
ón
ódulo
cohesi
ón
propiedad
interna
ódulo
contrario
acoplamiento
caracteriza
relaciones
ódulo
acoplamiento
mide
interdepend
encia
módulos
ejemplo
ódulo
llamada
rutina
provista
ódulo
accede
variable
declarada
ódulo
B.
ódulos
dependen
fuertemente
lto
acoplamiento
vuelve
dif
íciles
analizar
comprender
modificar
testear
reusar
forma
separada
Idealmente
ódulos
sistema
tengan
acoplamiento
estructura
modular
alta
cohesi
ón
acoplamiento
permite
ódulos
cajas
negras
describe
estructura
global
sistema
encarar
ódulo
separado
analiza
describe
funcionalidad
ódulo
Abstracci
ón
abstracci
ón
proceso
identifican
aspectos
relevantes
problema
ignorando
detalles
caso
especial
pri
ncipio
separación
intereses
separan
aspectos
importantes
detalles
menor
impor
tancia
abstrae
depender
prop
ósito
abstracci
ón
podr
án
hacerse
distintas
abstracciones
realidad
proveer
visi
ón
realidad
sirve
prop
ósito
espec
ífico
ejemplo
requerimientos
aplicaci
ón
analizados
especificados
construye
modelo
aplicaci
ón
propuesta
podr
expresado
formas
dependiendo
gra
do
requerido
rigor
formalidad
importar
lenguaje
elegido
expresar
requerimi
entos
provee
modelo
abstrae
detal
decidi
pod
ían
ignorados
forma
segura
lenguajes
programaci
ón
tambi
én
abstracciones
construidas
hardware
ue
proveen
constructores
útiles
poderosos
escribir
programas
ignorando
detalles
úmero
bits
utilizan
representar
úmeros
mecanismos
direccionamiento
permite
concentrarse
problema
resolver
lugar
forma
instruir
áquina
principio
abstracci
ón
principio
importante
aplica
productos
software
procesos
caso
ejemplo
estimaci
ón
costos
aplicaci
ón
forma
identificar
factores
laves
sistema
extrapolar
valores
perfiles
costo
sistemas
previos
similares
factores
claves
utilizados
an
álisis
abstracciones
sistema
Anticipaci
ón
cambio
software
sufre
cambios
constantemente
io
tratar
mantenibilidad
software
cambios
surgir
necesidad
eliminar
errores
detectados
liberar
aplicaci
ón
necesidad
apoyar
evoluci
ón
aplicaci
ón
requerimientos
cambios
requerimientos
existentes
habilidad
software
evolucionar
viene
requiere
esfuerzo
especial
anti
cipar
cu
ándo
ocurrir
cambios
identif
ican
posibles
cambios
futuros
cuidado
proceder
forma
áciles
aplicar
importante
aislar
posibles
cambios
porciones
espec
íficas
software
forma
est
én
restringidos
partes
anticipaci
ón
cambio
posiblemente
principio
ás
distingue
software
tipos
producci
ón
industrial
aplicaci
ón
software
desarrollada
requerim
ientos
est
án
completamente
comprendidos
liberado
obt
ener
retroalimentaci
ón
usuario
evolucionar
requerimientos
cambios
requerimientos
existentes
ener
distintos
or
ígenes
ejemplo
cambios
ambiente
organizaci
ón
principio
utilizado
lograr
evoluc
ionabilidad
software
tambi
én
reusabilidad
componentes
viendo
reusabilidad
evoluciona
bilidad
granularidad
ás
fina
nivel
componentes
aplicaci
ón
principio
requiere
disponga
her
ramientas
apropiadas
gestionar
versiones
revisiones
software
forma
controlada
almacenar
recuperar
documentaci
ón
fuentes
ejecutables
etc.
base
datos
act
úe
repositorio
central
componentes
reusables
acceso
controlado
sistema
software
mantenerse
consistente
aplican
ambios
componentes
disciplina
estudia
clase
problemas
Gesti
ón
Configuraci
ón
posteriormente
anticipaci
ón
cambio
tambi
én
aplica
proceso
desarrollo
software
ejemplo
gesti
ón
proyecto
gerentes
deber
ían
anticipar
efectos
reducci
ón
personal
estimar
costos
dise
ñar
estructura
organizaci
ón
apoyar
evoluci
ón
software
decidir
vale
pena
invertir
tiempo
esfuerzo
producci
ón
componentes
reusables
royecto
desarrollo
software
esfuerzo
desarrollo
paralelo
Generalidad
principio
generalidad
establece
resolver
problema
buscar
problema
general
posiblemente
est
oculto
problema
original
puesto
suceder
problema
general
ás
complejo
ás
simple
original
posiblemente
soluci
ón
problema
general
potencial
reuso
xista
mercado
producto
off-the-shelf
dise
ñe
ódulo
invocado
ás
punto
aplicaci
ón
lugar
soluciones
especializadas
soluci
ón
general
posiblemente
ás
costosa
érminos
rapidez
ejecuci
ón
requerimientos
memoria
tiempo
desarrollo
ue
soluci
ón
especializada
problema
original
evaluarse
generalidad
co
sto
eficiencia
momento
decidir
qu
vale
ás
pena
soluci
ón
general
especializada
generalidad
principio
fundamental
ene
objetivo
desarrollo
herramientas
gen
erales
paquetes
mercado
exitosa
deber
án
cubrir
necesidades
distintas
personas
productos
prop
ósito
general
off-the-shelf
ejempo
pro
cesadores
texto
representan
tendencia
general
software
área
espec
ífica
aplicaci
ón
paquetes
generales
proveen
soluciones
est
ándares
problemas
comunes
tendencia
id
éntica
ocurri
áreas
industria
ejemplo
autom
óviles
inicios
tecnolog
ía
automotriz
autos
requerimie
ntos
espec
íficos
cliente
medida
área
industrializando
pod
ían
encargarse
cat
álogo
actualmente
pedir
dise
ño
auto
personal
est
dispuesto
pagar
enorme
cantidad
dinero
Incrementalidad
incrementalidad
caracteriza
proceso
sarrolla
forma
pasos
incrementos
alcanza
ndo
objetivo
deseado
aproximaciones
sucesiv
as
aproximaci
ón
alcanzada
trav
és
incremento
previa
forma
aplicar
principio
incrementalida
consiste
identificar
subconjuntos
tempranos
aplicaci
ón
útiles
forma
obtener
retroalimentaci
ón
feedback
temprana
cliente
permite
aplicaci
ón
evolucione
forma
controlada
casos
qu
requerimientos
iniciales
est
án
estables
completamente
entendidos
motivaci
ón
principio
obtener
requerimientos
omenzar
desarrollo
aplicaci
ón
emergiendo
experimentaci
ón
aplicaci
ón
partes
contar
feedback
usuario
tilidad
aplicaci
ón
ás
ácil
incorporar
cambios
requeridos
producto
principio
est
ligado
principio
anticipaci
ón
cambio
principios
basa
evolucionabilidad
incrementalidad
aplica
cualid
ades
software
vistas
previamente
ejemplo
comenzar
úcleo
aplicaci
ón
útil
agregando
funcionalidades
tambi
én
agregar
performance
forma
incremental
or
ejemplo
versi
ón
inicial
enfatizaba
interfaces
usuario
confiabilidad
sucesivas
liberaciones
án
mejorando
eficiencia
tiempo
espacio
construye
aplicaci
ón
forma
incremental
pasos
intermedios
prototipos
producto
aproximaci
ón
Obviamente
ciclo
vida
basado
prototipos
distinto
tradicional
mode
cascada
est
basado
modelo
desarrollo
flexible
iterativo
diferencias
tendr
án
efectos
aspectos
écnicos
tambi
én
organizativos
gesti
ón
mencionaba
principio
anticipaci
ón
cambio
desarrollo
software
forma
evo
lutiva
requiere
especial
cuidado
gesti
ón
documentaci
ón
programas
datos
testeo
etc.
desarrollados
versiones
softwar
e.
incremento
significativo
registrad
documentaci
ón
ácilmente
recuperada
cambios
aplicarse
forma
ordenada
etc.
realiza
cuidado
intent
desarrollo
evolutivo
podr
ía
ápidamente
transformarse
desarrollo
software
indisciplinado
perderse
ventajas
potenciales
evolucionabilidad
Fundamentals
of
Software
Engineering
Carlo
Ghezzi
Mehdi
Jazayeri
Dino
Mandrioli
Prenti
ce-
Hall
Inc
1991
edici
ón
ingl
és
ISBN-0-13-820432-2
Cap
ítulo
Software
Engineering
Principles
