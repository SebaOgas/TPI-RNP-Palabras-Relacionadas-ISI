Principios
patrones
desarrollo
software
SOFTWARE
DESIGN
GUIA
DIRECTIVOS
TÉCNICOS
Software
Design
Principios
patrones
desarrollo
software
documento
forma
guías
onboarding
Autentia
apasiona
desarrollo
software
calidad
ayúdanos
difundirlas
anímate
unirte
equipo
documento
vivo
puedes
encontrar
versión
resto
partes
completan
documento
web
https://www.autentia.com/libros/
obra
licenciada
licencia
Creative
Commons
Attribution
ShareAlike
4.0
International
CC
BY-SA
4.0
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
fases
iniciales
desarrollo
proyecto
software
primeras
versiones
funcionalidades
fluyen
graciosa
natural
parecen
construirse
vino
rosas
medida
proyectos
avanzando
creciendo
magia
desaparece
comienzan
surgir
serie
problemas
situaciones
muestran
síntomas
diseños
degradando
pudriendo
tiempo
demostrará
software
enfrentarse
fuertes
vientos
cambio
asentado
roca
firme
arena”PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
síntomas
evidentes
Rigidez
so
ftware
vuelve
difícil
cambiar
tareas
sencillas
estimaciones
abultadas
funcionalidad
cuesta
horrores
inmediata
Fragilida
relacionado
rigidez
fragilidad
tendencia
software
rompa
múltiples
sitios
cambio
partes
conceptualmente
relación
subimos
versión
costado
sudor
lágrimas
resulta
rompen
cosas
aparentemente
Inmovilidad
reutilización
resulta
imposible
reutilizar
software
proyectos
partes
proyecto
Suele
ocurrir
módulo
reutilizar
mochila
dependencias
asumir
esfuerzo
riesgo
desacoplarlo
piden
cosas
prácticamente
copia
funcionalidades
disponemos
ventaja
cuesta
sacar
común
reutilizarlo
tendiendose
copiar
duplicar
código
Viscosidad
viscosidad
ámbito
diseño
sencillo
cosas
ñapa
tratar
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
hacerlas
camino
trazado
viscosidad
entorno
ocurre
ecosistema
desarrollo
lento
ineficiente
amplio
sentido
palabra
ejemplo
funcionalidad
terminada
hacerla
llegar
producción
supone
auténtica
aventura
necesitan
semanas
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
principios
desarrollo
software
serie
reglas
recomendaciones
específicas
programadores
seguir
desarrollo
quieren
escribir
código
limpio
comprensible
fácil
mantener
varita
mágica
transformar
combinación
variables
clases
funciones
código
ideal
consejos
sugerencias
ayudar
programador
determinar
cosas
tratar
evitar
situaciones
ejemplo
narrado
apartado
seguro
llevamos
tiempo
suficiente
dedicados
maravillosa
profesión
desarrollo
software
habremos
vivido
similar
Software
Design
Índice
Principios
patrones
desarrollo
software
Principios
generales
Principios
S.O.L.I.D.
Single
responsibility
SRP
Open
closed
OCP
Liskov
substitution
LSP
Interface
segr
egation
ISP
Dependency
inver
sion
DIP
Don’t
Repeat
Yourself
DRY
Inversion
Control
IoC
You
Aren
Gonna
Need
It
YAGNI
Keep
It
Simple
Stupid
KISS
Law
of
Demeter
LoD
Strive
for
loosel
coupled
design
between
objects
that
interact
Composition
over
inheritance
Encapsulate
wha
varies
The
four
rules
of
simple
design
The
boy
scout
rule
Last
Responsible
Moment•
Design
Patterns
Patrones
creacionales
Builder
Singleton
Dependency
Injection
Service
Locator
Abstract
Factory
Factory
thod
Patrones
estructurales
Adapter
Data
ccess
Object
DAO
Query
Object
Decorator
Bridge
Patrones
comportamien
to
Command
Chain
of
Responsibility
Strategy
Template
thod
Interpre
ter
Observer
State
Visitor
Iterator
Bibliografía
Lecciones
aprendidas
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
Principios
generales
Principios
S.O.L.I.D.
S.O.L.I.D.
acrónimo
mnemónico
principios
diseño
destinados
diseños
software
comprensibles
flexibles
mantenibles
principios
subconjunto
principios
promovidos
ingeniero
instructor
software
estadounidense
Robert
C.
Martin
aplican
diseño
orientado
objetos
principios
SOLID
formar
filosofía
central
metodologías
desarrollo
ágil
desarrollo
software
adaptativo
principios
comprendidos
S.O.L.I.D.
S​
​Single
responsibility​.
O​
​Open
closed​.
L​
​Liskov
substitution​.
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
I​
​Interface
segregation​.
D​
​Dependency
inversion​.
Aplicar
principios
facilitará
trabajo
ajeno
probable
código
acaben
leyendo
desarrolladores
ciclo
vida
ventajas
aplicarlo
Facilitar
mantenimiento
código
Reducir
complejidad
añadir
funcionalidades
Aumentar
reusabilidad
piezas
componentes
Mejorar
calidad
código
comprensión
​Single
responsibility
SRP
principio
responsabilidad
única
single
responsibility
establece
módulo
software
razón
cambiar​.
razón
cambiar
entiende
responsabilidad
Reúna
cosas
cambian
razones
Separe
cosas
cambian
razones
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
principio
estrechamente
relacionado
conceptos
acoplamiento
cohesión
aumentar
cohesión
cosas
cambian
razones
disminuir
acoplamiento
cosas
cambian
razones
principio
limitar
impacto
cambio​.
razón
cambiar
clase
probablemente
responsabilidad
olor
comportamientos
dependiendo
responsabilidad
código
difícil
leer
testear
mantener
código
flexible
ventajas
aplicar
principio
encontramos
necesita
cambio
fácil
detectar
aislado
clase
claramente
definida
comprensible
Minimizando
efectos
colaterales
clases
ejemplos
encontramos
vida
real
cambia
forma
compra
artículo
tendremos
modificar
código
responsable
almacenarlo
cambia
base
datos
arreglar
pedazo
código
utiliza
detalle
artículo
​[S.O.L.I.D.
Single
responsibility
principle
Principio
Responsabilidad
Única​
Adictos
Trabajo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
10
​Open
closed
OCP
principio
​los
módulos
software
abiertos
extensión
cerrados
modificación​.
refiere
Abierto
extensión​
significa
comportamiento
módulo
extenderse
medida
cambian
requisitos
aplicación
ampliar
módulo
comportamientos
satisfagan
cambios
palabras
cambiar
módulo
Cerrado
modificación​
módulo
cerrado
dispone
descripción
interface
estable
definida
Extender
comportamiento
módulo
debería
afectar
código
existente
módulo
código
original
módulo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
11
debería
verse
afectado
modificarse
realmente
esencia
principio
Debería
fácil
cambiar
comportamiento
módulo
cambiar
código
fuente
módulo
significa
cambiará
código
fuente
significa
debemos
esforzarnos
lograr
código
esté
estructurado
forma
comportamiento
cambie
esperada
debamos
cambios
radicales
módulos
sistema
Idealmente
podremos
agregar
comportamiento
añadiendo
código
cambiando
código
antiguo
forma
implementar
principio
mundo
práctico
polimorfismo
interfaces
clases
abstractas
detalle
artículo
​[S.O.L.I.D.
Open-Closed
Principle
Principio
Abierto-Cerrado​
Adictos
Trabajo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
12
​Liskov
substitution
LSP
ve
pato
cuac
pato
necesita
baterías
probablemente
tengas
abstracción
incorrecta
sustitución
Liskov
​objetos
programa
deberían
reemplazables
instancias
subtipos
alterar
correcto
funcionamiento
programa
Básicamente
código
usando
clase
clase
extendida
utilizar
cualquiera
clases
hijas
programa
siga
válido
obliga
asegurarnos
extendemos
clase
alterando
comportamiento
clase
padre
principio
​ayuda
utilizar
herencia
forma
correcta
muestra
mapear
automáticamente
mundo
real
modelo
orientado
objetos
equivalencia
unívoca
modelos
detalle
artículo
​[S.O.L.I.D.
Liskov
substitution
Adictos
Trabajo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
13
​Interface
segregation
ISP
principio
segregación
interfaces
establece
​muchas
interfaces
cliente
específicas
mejores
interfaz
propósito
general​.
clientes
forzados
utilizar
interfaces
completo
sujetos
cambios
interfaz
resulta
acoplamiento
innecesario
clientes
cliente
depende
clase
implementa
interfaz
cuya
funcionalidad
cliente
clientes
cliente
afectado
cambios
fuercen
clientes
clase
cuestión
Debemos
intentar
evitar
tipo
acoplamiento
separando
interfaces
pequeñas
específicas
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
14
detalle
artículo
​[S.O.L.I.D.
Interface
Segregation
Principle
Principio
segregación
interfaz​
Adictos
Trabajo
​Dependency
inversion
DIP
principio
inversión
dependencia
​las
entidades
software
depender
abstracciones
implementaciones​.
módulos
alto
nivel
deberían
depender
nivel
deberían
depender
abstracciones
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
15
principio
ocultamos
detalles
implementación
ganando
flexibilidad
tests
reemplazar
dependencias
reales
objetos
mockeados
Gracias
flexibilidad
sustituir
componentes
clientes
consumen
vean
afectados
dependen
abstracción
implementación
concreta
pretende
existan
dependencias
directas
módulos
dependan
abstracciones
forma
módulos
fácilmente
reutilizables
fundamental
abstracción
defina
base
necesidades
módulo
cliente
capacidades
implementación
contrario
abstracción
estaría
acoplada
implementación
teniendo
flexibilidad
detalle
artículo
​[S.O.L.I.D.
Dependency
inversion
principle
Principio
inversión
dependencias​
Adictos
Trabajo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
16
​Don’t
Repeat
Yourself
DRY
objetivo
principal
​evitar
duplicación
lógica​.
pieza
funcionalidad
​identidad
única​
​no
ambigua
​representativa
sistema
principio
pieza
funcionalidad
debería
duplicada
duplicidad
incrementa
dificultad
cambios
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
17
evolución
posterior
perjudicar
claridad
crear
espacio
posibles
inconsistencias
pieza
funcionalidad
referimos
código
lógica
concretamente
función
lógica
saludable
métodos
abrir
conexión
base
datos
código
motivo
justifique
ve
caso
métodos
distinto
código
función
conectarse
base
datos
evolución
software
solicita
cambiar
forma
conectarnos
tipo
base
datos
enviar
datos
sistema
almacenamiento
deberemos
modificar
métodos
incrementa
cantidad
trabajo
debemos
escribir
código
consecuentemente
probarlo
introduce
posibilidades
cometer
errores
aumenta
complejidad
código
autores
originales
código
toca
mantenerlo
difícil
laborioso
principio
DRY
aplica
forma
eficiente
cambios
proceso
requieren
cambios
único
lugar
contrario
partes
proceso
repetidas
sitios
cambios
provocar
fallos
facilidad
sitios
aparece
encuentran
sincronizados
resumen
importante
código
mantenible​.
Evitar
repetición
lógica
permite
cambia
funcionalidad
cuestión
tengas
lugares
repetiste
Reduce
tamaño
código​.
legible
entendible
código
Ahorra
tiempo​.
pedazos
lógica
disponibles
reutilizarlos
futuro
preparados
lograr
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
18
tiempo
​Inversion
of
Control
IoC
nombre
indica
inversión
control
utiliza
diseño
orientado
objetos
delegar
tipos
flujos
control
​para
lograr
acoplamiento
incluye
control
flujo
aplicación
control
flujo
creación
objeto
creación
vinculación
objetos
dependientes
principio
IoC
ayuda
aumentar
modularidad
programa
diseño
clases
acoplamiento
testeables
mantenibles
extensibles
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
19
patrones
diseño
implementaciones
principio
Service
locator​.
Dependency
injection​.
Template
method​.
Strategy​.
Abstract
Factory​.
Observer​.
principio
conoce
​Don’t
call
us
we’ll
call
you​
llame
llamamos
​Hollywood
Principle​
Principio
Hollywood
​You
Aren’t
Gonna
Need
It
YAGNI
principio
traducir
vas
necesitar
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
20
principio
indica
​no
​se
​deben
​agregar
funcionalidades
extras
necesario​.
tentación
escribir
código
necesario
serlo
futuro
desventajas
desperdicio
tiempo
destinaría
funcionalidad
básica
características
depuradas
documentadas
soportadas
requieran
funcionalidades
funcionen
correctamente
definido
necesitar
imposible
artículo
​El
principio
YAGNI​
Adictos
Trabajo
detalle
​Keep
It
Simple
Stupid
KISS
principio
KISS
acrónimo
proviene
frase
inglesa
keep
it
simple
stupid
traducir
mantenlo
simple
estúpido
entiende
necesidad
minimizar
errores
tratando
tareas
forma
efectiva
eficiente
complicandose
mínimo
simplicidad
objetivo
clave
diseño
desarrollo
solución
evitar
​complejidad
innecesaria​.
​Law
of
Demeter
LoD
Ley
Demeter
conocida
​Principle
of
least
knowledge
principio
​Don’t
talk
to
strangers
método
objeto
debería
interactuar
Métodos
objeto
argumentos
recibe
objeto
creado
método
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
21
propiedad
campo
directo
objeto
idea
principal
objeto
​no
porqué
estructura
interna
objetos
colabora​.
palabras
evitar
código
estructura
similar
object.getX().getY().getZ().doSomething
problema
Básicamente
cadena
denota
fuerte
acoplamiento
estructura
clases
involucradas
afectándonos
cambio
modificación
ventajas
aplicar
principio
encontramos
software
resultante
tiende
fácil
mantener
adaptar
objetos
dependen
estructura
interna
objetos
reduce
acoplamiento
vuelve
sencillo
reutilizar
clases
código
fácil
probar
detalle
artículo
​Ley
Demeter​
Adictos
Trabajo
​Strive
for
loosely
coupled
design
between
objects
that
interact
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
22
español
diseño
débilmente
acoplado
objetos
interactúan
acoplamiento
refiere
grado
conocimiento
directo
elemento
objetivo
​reducir
riesgo
cambio
objetos
interaccionamos
provoque
cambios
objetos​.
Limitar
interconexiones
ayudar
aislar
problemas
cosas
salen
simplificar
procedimientos
prueba
mantenimiento
solución
problemas
permite
construir
sistemas
flexibles
manejar
cambios
reducen
dependencia
múltiples
objetos
arquitectura
acoplamiento
siguientes
características
Reduce
riesgo
cambio
elemento
provocar
cambios
elementos
Simplifica
pruebas​
mantenimiento
resolución
problemas
componentes
sistema
débilmente
acoplado
reemplazarse
implementaciones
alternativas
brinden
servicios
ejemplo
implementación
principio
patrón
Observer​
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
23
Composition
over
inheritance
principio
composición
herencia
conocido
composite
reuse
principle​
establece
clases
​lograr
comportamiento
polimórfico
reutilización
código
composición
contener
instancias
clases
implementan
funcionalidad
deseada
lugar
herencia
clase
base
primaria
herencia
estructuramos
clases
composición
estructuramos
clases
basándonos
favorecer
composición
herencia
​pensar
términos
cosas
lugar
liberamos
estructuras
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
24
herencia
frágiles
estrechamente
acopladas
problema
herencia
tendemos
predecir
futuro
construir
estructura
rígida
fuerte
acoplamiento
clases
padres
hijas
etapa
temprana
proyecto
probable
cometamos
errores
diseño
predecir
futuro
cambiar
salir
estructuras
taxonomías
herencia
difícil
favorecer
composición
herencia
dotamos
diseño
flexibilidad
natural
construir
clases
componentes
tratar
encontrar
puntos
común
crear
árbol
genealógico
ejemplo
pedal
acelerador
volante
comparten
rasgos
comunes
componentes
vitales
automóvil
utilizar
beneficiar
automóvil
define
fácilmente
composición
proporciona
dominio
estable
plazo
propenso
peculiaridades
miembros
palabras
componer
objeto
verificando
cumpla
relación
​HAS-A
​TIENE-UN​
extender
significa
utilice
herencia
implementar
simple
sentido
modelo
fundamentalmente
verificando
cumpla
relación
​IS-A
ES-UN​.
diseño
inicial
simplifica
identificando
comportamientos
objetos
sistema
interfaces
separadas
lugar
crear
relación
jerárquica
distribuir
comportamientos
clases
herencia
enfoque
flexible
cambios
futuros
requerirían
reestructuración
completa
clases
dominio
modelo
herencia
evita
problemas
asociados
cambios
relativamente
menores
modelo
basado
herencia
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
25
incluye
generaciones
clases
Evitando
posibles
diseños
requiera
herencia
múltiple
lenguajes
soportan
desventaja
diseños
basados
enfoque
composición
intuitivos
​Encapsulate
what
varies
principio
refiere
identifiquen
partes
aplicación
​pueden
cambiar​
​aislar
​encapsular
abstracciones
permitan
cambio
afectar
partes
aplicación
principio
apoya
vistos
apartados
anteriores
​Single
responsibility
SRP)​
​Open
closed
OCP)​.
correcta
aplicación
principio
obtener
beneficios
fundamentales
responsabilidad
correctamente
acotada
único
módulo
variaciones
requisitos
responsabilidad
influyen
únicamente
módulo
reduciendo
fragilidad
sistema
aumentando
reusabilidad
solicitud
requisitos
comportamientos
obtiene
incorporación
elementos
lugar
modificación
elementos
existentes
reduce
rigidez
sistema
vuelve
versátil
flexible
reduce
fragilidad
código
probado
modifica
mayoría
patrones
diseño
basan
principios
patrones
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
26
Abstract
Factory​.
Factory
Method​.
Adapter​.
Bridge​.
Decorator​.
Iterator​.
Observer​.
State​.
Strategy​.
Template
Method​.
Visitor​.
​The
four
rules
of
simple
design
reglas
Kent
Beck
introdujo
años
90
puntos
fundamentales
hora
diseñar
software
buscando
​manera
​objetiva
​medir
calidad
diseño
perspectiva
minimizar
costes
maximizar
beneficio
huyendo
valoraciones
subjetivas
reglas
sencillas
recordar
ordenadas
relevancia
tests
pasan​
testing
pieza
faltar
desarrollamos
software
objetivo
principal
tarea
funcione
esperada
tests
verifican
criterios
cumplen
Expresan
intención​
código
autoexplicativo
fácil
entender
facilita
comunicación
propósito
duplicidades
DRY
reducir
máximo
duplicidad
lógica
código
estaremos
construyendo
software
frágil
cambio
pequeño
romper
partes
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
27
Mínimo
número
elementos​
procurar
reducir
número
componentes
clases
métodos
etc.
imprescindible
eliminando
cosas
incrementen
complejidad
sistema
innecesaria
reglas
discutidas
variedad
libros
foros
diversos
dando
lugar
cantidad
ideas
interesantes
destacando
unanimidad
orden
puntos
originando
idea
generalizada
deberían
nivel
importancia
punto
considerado
siquiera
punto
diseño
simple
esencial
connatural
desarrollo
software
siquiera
debería
plantear
posibilidad
código
tests
punto
considerado
consecuencia
continua
aplicación
puntos
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
28
​The
boy
scout
rule
Boy
Scouts
regla
dejar
campamento
limpio
encontraron
caso
ensuciarlo
limpia
deja
persona
venga
aplica
desarrollo
software
vemos
código
mejorar
independientemente
debemos
objetivo
principal
mejorar
calidad
código
evitar
deterioro
ayudar
desarrollador
tiempo
cambiar
desarrollar
funcionalidad
forma
sencilla
promueve
trabajo
equipo
individualidad
importante
tarea
persona
proyecto
general
ve
mejorar
idea
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
29
mejorar
pequeñas
partes
código
acotada
segura
cuestión
cambiar
módulo
entero
mejorando
calidad
aplicar
regla
claros
principios
​SOLID​.
detalle
artículo
​La
regla
Boy
Scout
Oxidación
Software​
Adictos
Trabajo
​Last
Responsible
Moment
desarrollo
software
disciplina
realmente
curiosa
extraño
atrevería
habitual
encontrarse
trabajando
funcionalidades
proyecto
incipiente
añadiendo
avanzado
claramente
descritos
requisitos
​Este
principio
propone
estrategia
abordar
diseños
diferir
decisiones
especialmente
puedan
considerar
irreversibles
​último
momento
posible​.
momento
tomar
decisión
supone
coste
tomarla
tiempo
mantengamos
decisiones
abiertas
información
iremos
acumulando
optar
decisión
adecuada
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
30
Design
Patterns
patrones
diseño
descripciones
objetos
clases
conectadas
personalizan
resolver
problema
diseño
general
contexto
particular
Gang
of
Four
patrones
diseño
ofrecen
​soluciones
comunes
problemas
recurrentes
diseño
aplicaciones
programación
orientada
objetos
patrones
diseño
normalmente
dirigidos
resolver
problemas
asociados
creación
interacción
objetos
lugar
problemas
escala
afrontan
arquitecturas
generales
software
Proporcionan
soluciones
generalizadas
forma
repeticiones
aplicar
problemas
vida
real
patrones
diseño
soluciones
útiles
probadas
problemas
inevitablemente
aparecen
albergan
años
conocimiento
experiencia
colectiva
patrones
diseño
ofrecen
​vocabulario
común
desarrolladores
arrojan
luz
problemas
innecesario
excesivo
patrones
diseño
suponer
ingeniería
dando
resultado
sistema
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
31
excesivamente
complejo
lejos
resolver
problemas
aumenta
dando
lugar
diseño
ineficiente
rendimiento
problemas
mantenimiento
patrones
diseño
clasificaron
originalmente
grupos
Creacionales
Estructurales
comportamiento
tiempo
apareciendo
patrones
categorías
problemas
solucionan
ejemplo
patrones
concurrencia
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
32
Patrones
creacionales
Builder
patrón
pretende
separar
lógica
construcción
representación
define
clase
abstracta
Builder
encargada
crear
instancias
objetos
elementos
intervienen
siguientes
Builder
interfaz
abstracta
crea
productos
Builder
concreto
implementación
concreta
builder
crea
productos
tipo
Director
encargado
utilizar
clase
builder
crear
objetos
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
33
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
34
Singleton
patrón
consiste
utilizar
​una
instancia
clase
definiendo
único
punto
global
acceso
Dicha
instancia
encargada
inicialización
creación
acceso
propiedades
clase
patrón
utilizado
controlar
acceso
único
recurso
físico
fichero
lectura
exclusivo
datos
deban
disponibles
resto
objetos
aplicación
instancia
log
ejemplo
define
método
acceso
recuperar
instancia
clase
método
encargará
crear
instancia
caso
solicite
prestar
atención
problemas
pudiera
acceso
exclusivo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
35
Dependency
Injection
patrón
diseño
encarga
extraer
responsabilidad
​creación
instancias
componente
delegarla
Permite
objeto
reciba
objetos
depende
lugar
objeto
cree
objetos
llaman
dependencias
típica
relación
objeto
receptor
llama
cliente
objeto
inyectado
llama
servicio
código
pasa
servicio
cliente
tipos
llama
inyector
lugar
cliente
especifique
servicio
usará
inyector
cliente
servicio
inyección
refiere
paso
dependencia
servicio
objeto
cliente
usaría
inyección
dependencias
forma
lograr
​inversión
control​.
cliente
únicamente
necesita
interfaces
servicios
preocuparse
implementación
real
By
Vanderjoe
Own
work
CC
BY-SA
4.0
https://commons.wikimedia.org/wiki/File:W3sDesign_Dependency_Injection_Design_Pattern_UML.jpg
detalle
artículo
​Patrón
Inyección
dependencias
Adictos
Trabajo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
36
Service
Locator
patrón
localización
servicios
patrón
diseño
utilizado
encapsular
procesos
involucrados
obtención
servicio
capa
abstracción
fuerte
patrón
utiliza
registro
central
conocido
Service
Locator
demanda
devuelve
componente
necesario
determinada
tarea
basa
creación
clase
llamada
ServiceLocator
crear
dependencias
tipos
localizador
servicios
actúa
depósito
objetos
servicios
previamente
inicializados
requiere
servicios
solicita
llamando
método
determinado
ServiceLocator
casos
método
encargado
localización
servicios
crea
instancias
objetos
medida
necesitan
defensores
patrón
enfoque
simplifica
aplicaciones
basadas
componentes
dependencias
enumeran
limpiamente
comienzo
diseño
aplicación
inyección
dependencias
tradicional
forma
compleja
conectar
objetos
críticos
patrón
argumentan
software
difícil
probar
principal
diferencia
frente
inyección
dependencias
caso
solicitud
explícita
obtener
dependencia
inyección
dependencias
obtención
viene
dada
patrón
implementación
principio
​inversión
control
IoC)​.
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
37
Abstract
Factory
propósito
Abstract
Factory
proporcionar
interfaz
​crear
familias
​objetos
relacionados
especificar
clases
concretas
Normalmente
cliente
crea
implementación
concreta
fábrica
abstracta
utiliza
interfaz
genérica
crear
objetos
concretos
cliente
importa
objetos
concretos
obtiene
fábricas
internas
utiliza
interfaces
genéricas
productos
patrón
separa
detalles
implementación
conjunto
objetos
general
basa
composición
objeto
creación
objetos
implementa
métodos
expuestos
interfaz
fábrica
estructura
típica
patrón
Abstract
Factory
Cliente
clase
llamará
factoría
adecuada
necesita
crear
objetos
provee
factoría
Abstract
Factory
definición
interfaces
factorías
proveer
método
obtención
objeto
crear
Factorías
Concretas
familias
productos
Provee
instancia
concreta
tipo
objeto
encarga
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
38
crear
Producto
abstracto
definición
interfaces
familia
productos
genéricos
Producto
concreto
implementación
productos
patrón
implementación
principio
​inversión
control
IoC)​.
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
39
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
40
Factory
Method
Provee
interfaz
clase
abstracta
creator
permite
encapsular
lógica
creación
objetos
subclases
deciden
clase
instanciar
objetos
crean
método
factory
method
constructor
normalmente
ConcreteCreators
devuelven
interfaz
Product
permite
cliente
trate
productos
tengan
implementación
estructura
típica
patrón
Factory
method
Product
definición
interfaces
familia
productos
genéricos
ConcreteProduct
implementación
productos
Creator
declara
factory
method
encargará
instanciar
objetos
importante
método
devuelva
interfaz
Product
Normalmente
Creator
suele
clase
abstracta
lógica
negocio
relacionada
productos
crear
Dependiendo
instancia
producto
devuelva
seguir
flujo
ConcreteCreator
crea
instancia
producto
concreto
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
41
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
42
Patrones
estructurales
Adapter
libro
GoF
indica
patrón
proporciona
​interfaz
​unificada
conjunto
interfaces
subsistema
Head
First
Design
Patterns
explicación
señala
convierte
interfaz
clase
interfaz
clientes
esperan
adaptador
permite
clases
puedan
trabajar
juntas
interfaces
incompatibles
libro
GoF
describen
tipos
principales
adaptadores
Adaptadores
clase
generalmente
herencia
múltiple
interfaces
implementarlo
Adaptadores
objetos
realizan
composiciones
objetos
adaptarlos
adaptador
considerar
aplicación
principio
inversión
dependencias
DIP)​
clase
alto
nivel
define
interfaz
adaptador
módulo
nivel
implementado
clase
adaptada
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
43
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
44
Data
Access
Object
DAO
solución
original
propuso
patrón
DAO
definió
libro
Core
J2EE
Patterns
Best
Practices
and
Design
Strategies
Data
Access
Object
DAO
​abstraer
encapsular
acceso
fuente
datos​.
DAO
gestiona
conexión
fuente
datos
obtener
almacenar
datos
problema
resolvió
abstracción
encapsulación
fuente
datos
evitar
aplicación
dependiera
implementación
fuente
datos
desacopla
capa
negocio
fuente
datos
originariamente
permitía
protegerse
frente
cambios
motor
base
datos
patrón
DAO
patrón
valioso
solución
original
válida
lugar
protegerse
impacto
cambio
improbable
tipo
fuente
datos
valor
capacidad
prueba
estructurar
código
mantenerlo
limpio
código
acceso
datos
patrón
DAO
encapsula
operaciones
acceso
datos
interfaz
implementada
clase
concreto
mockea
clase
probar
clases
negocio
conexiones
base
datos
implementación
concreta
DAO
utiliza
API
nivel
operaciones
acceso
datos
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
45
Query
Object
patrón
consultar
libro
Patterns
of
Enterprise
Application
Architecture
Query
Object
​intérprete
GoF
estructura
objetos
​formar
consulta
​SQL​.
crear
consulta
referencia
clases
campos
lugar
tablas
columnas
forma
escriben
consultas
independientemente
esquema
base
datos
cambios
esquema
localizar
lugar
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
46
Decorator
propósito
patrón
asignar
​responsabilidades
​adicionales
objeto
​dinámicamente​
proporcionando
alternativa
flexible
herencia
extender
funcionalidad
estructura
compuesta
Component
deﬁne
interfaz
implementar
objetos
añadir
funcionalidades
ConcreteComponent
deﬁne
objeto
agregar
responsabilidades
adicionales
Implementa
interfaz
Component
Decorator
mantiene
referencia
Component
asociado
Implementa
interfaz
super
clase
Component
delegando
Component
asociado
Decorator
general
añade
comportamiento
método
Component
ConcreteDecorator
añade
responsabilidades
Component
ventajas
implementar
patrón
encontrar
flexible
herencia
Permite
añadir
eliminar
responsabilidades
tiempo
ejecución
Evita
herencia
clases
herencia
múltiple
Limita
responsabilidad
componentes
evitar
clases
excesivas
responsabilidades
niveles
superiores
jerarquía
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
47
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
48
Bridge
objetivo
​desacoplar
​abstracción
​implementación​.
Permite
abstracción
implementación
desarrollen
forma
independiente
puente
bridge
ambas
código
cliente
acceder
abstracción
preocuparse
implementación
Participantes
Abstraction
recibe
parámetro
interfaz
servirá
puente
implementaciones
comunicará
cliente
ConcreteAbstraction
trabajar
distintas
implementaciones
interfaz
Implementator
declara
interfaz
respectivos
métodos
actúen
enlace
abstracción
implementaciones
ConcreteImplementator
contiene
código
concreto
implementación
ventajas
implementar
patrón
encontrar
cliente
trabaja
abstracciones
implementaciones
Cumple
principio
Open
Closed
añadir
implementaciones
independientes
Permite
reducir
número
subclases
usaramos
herencia
pura
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
49
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
50
Patrones
comportamiento
Command
libro
The
Gang
of
Four
GoF
indica
patrón
Comando
​encapsular
​solicitud
objeto
permitiendo
definir
interfaz
común
invocar
acciones
diversas
Simplificando
objetivo
comando
ejecutar
serie
acciones
receptor
Receiver
cliente
crea
objeto
Command
generalmente
pasa
Receiver
acceder
Client
desea
ejecutar
Command
utiliza
Invoker
almacena
Command
encarga
iniciar
ejecución
momento
invocando
método
execute
Command
permite
añadir
funcionalidades
acciones
encolamiento
registro
acciones
deshacer
rehacer
operaciones
etc.
gracias
​desacoplar​
​solicitud​
acción
ejecución
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
51
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
52
Chain
of
Responsibility
libro
The
Gang
of
Four
GoF
indica
patrón
evitar
acoplar
remitente
solicitud
receptor
darle
​más
objeto
oportunidad
​manejar
​solicitud​.
encadenan
objetos
receptores
pasa
solicitud
cadena
receptor
maneja
procesan
serie
receptores
forma
secuencial
fuente
iniciará
procesamiento
patrón
constituimos
cadena
objetos
receptores
lógica
manejar
tipo
particular
objeto
realiza
procesamiento
pendiente
reenviar
receptor
cadena
Cabe
indicar
tipo
patrón
establece
jerarquía
receptores
cadena
prioridad
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
53
siguientes
agregar
receptores
momento
cadena
By
Vanderjoe
Own
work
CC
BY-SA
4.0
​https://commons.wikimedia.org
index.php?curid=62530468
patrón
representa
implementación
concepto
definido
principio
​responsabilidad
única
SRP)​.
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
54
Strategy
libro
The
Gang
of
Four
GoF
indica
patrón
definir
familia
​algoritmos
encapsulan
forma
intercambiables​.
patrón
estrategia
permite
algoritmo
varíe
independientemente
cliente
clave
aplicar
patrón
Strategy
diseñar
interfaces
estrategia
contexto
suficientemente
generales
admitir
variedad
algoritmos
debería
cambiar
estrategia
interfaz
contexto
admitir
algoritmo
patrón
estrategia
comportamientos
clase
heredarse
lugar
encapsularse
utilizando
interfaces
compatible
principio
​Open
Closed
OCP)​
propone
clases
abiertas
extensión
cerradas
modificación
detalle
artículo
​Utilizando
patrón
Estrategia
Adictos
Trabajo
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
55
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
56
Template
Method
libro
The
Gang
of
Four
GoF
indica
patrón
definir
esqueleto
​algoritmo
operación
​delegando
​pasos
subclases
método
plantilla
permite
subclases
redefinan
pasos
algoritmo
cambiar
estructura
algoritmo
template
method
definimos
estructura
mínima
esencial
algoritmo
diferimos
funcionalidades
responsabilidades
subclases
resultado
redefinir
pasos
algoritmo
manteniendo
estructura
clave
fija
algoritmo
tiempo
ejecución
algoritmo
representado
método
plantilla
ejecuta
enviando
mensaje
plantilla
instancia
subclases
concretas
herencia
método
plantilla
clase
base
comienza
ejecutarse
delegando
detalles
implementación
clases
hijas
mecanismo
garantiza
algoritmo
general
siga
pasos
tiempo
permite
detalles
pasos
dependan
instancia
recibió
solicitud
original
ejecutar
algoritmo
patrón
ejemplo
​inversión
control
código
alto
nivel
determina
algoritmos
ejecutar
lugar
selecciona
algoritmo
nivel
inferior
tiempo
ejecución
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
57
By
Vanderjoe
Own
work
CC
BY-SA
4.0
https://commons.wikimedia.org/w/index.php?curid=63155402
detalle
artículo
​El
patrón
diseño
Template
Method​
Adictos
Trabajo
Interpreter
libro
GoF
define
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
58
lenguaje
define
representación
​gramática
intérprete
dicha
representación
interpretar
sentencias
lenguaje
palabras
patrón
define
gramática
lenguaje
particular
orientada
objetos
evaluada
intérprete
Teniendo
técnicamente
podríamos
construir
expresión
regular
personalizada
intérprete
DSL
personalizado
podríamos
analizar
cualquiera
lenguajes
humanos
construir
árboles
sintaxis
abstracta
ejecutar
interpretación
patrón
intérprete
generalmente
usarse
gramática
relativamente
simple
contrario
difícil
mantener
By
Vanderjoe
Own
work
CC
BY-SA
4.0
https://upload.wikimedia.org/wikipedia/commons/3/33/W3sDesign_Interpreter_Design_Pattern_UML.jpg
Ventajas
inconvenientes
Facilidad
cambiar
ampliar
puesto
patrón
clases
representar
reglas
gramática
herencia
cambiar
extender
Fácil
implementación
clases
definen
nodos
árbol
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
59
sintáctico
abstracto
implementaciones
similares
gramáticas
complejas
difíciles
mantener
define
clase
regla
gramática
gramáticas
contienen
reglas
puedan
difíciles
controlar
mantener
detalle
artículo
​Patrón
Intérprete​
Adictos
Trabajo
Observer
patrón
define
​dependencia
objetos
forma
objeto
​cambia
​estado​
objetos
dependen
notificados​
reaccionar
desean
acción
objeto
datos
Subject
provee
métodos
objeto
Observer
suscribirse
cancelar
suscripción
pasando
referencia
Observable
Subject
Subject
mantiene
lista
referencias
Observers
notificarles
cambio
procede
Observers
obligados
implementar
métodos
utiliza
Subject
notificar
Observers
cambios
sufre
tengan
oportunidad
reaccionar
cambio
produzca
cambio
Subject
recorrer
lista
Observers
notificando
patrón
aplicable
abstracción
puntos
vista
dependientes
Encapsular
puntos
vista
objetos
separados
permite
cambiarlos
reutilizarlos
cambio
objeto
requiere
cambiar
objetos
cambiar
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
60
objeto
debería
notificar
ventajas
utilizar
patrón
encontramos
modificar
Subject
Observers
forma
independiente
desacoplados
permite
reutilizar
Observers
Subjects
Respeta
principio
Open
Closed
permitiendo
añadir
Observers
modificar
Subjects
Reduce
acoplamiento
Subject
Observer
Subject
conoce
lista
Observers
interfaz
clase
concreta
Subject
comunica
Observers
broadcast
difusión
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
61
State
libro
GoF
patrón
State
permite
objeto
​modifique
​comportamiento
​cambie
​estado
interno
Parecerá
cambia
clase
objeto
dibujar
comportamiento
objeto
tratase
máquina
finita
patrón
encapsular
comportamiento
variable
objeto
función
interno
limpia
construir
objeto
cambia
comportamiento
tiempo
ejecución
recurrir
declaraciones
condicionales
respetando
principio
Open
Closed
Single
Responsibility
Principle
representado
clase
implementa
interfaz
facilita
mantenibilidad
código
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
62
Participantes
Context
Define
interfaz
usada
clientes
Mantiene
instancia
representa
actual
objeto
State
Define
interfaz
encapsular
comportamiento
asociado
determinado
Context
Subclases
State
subclase
implementa
comportamiento
asociado
Context
Principales
ventajas
Separa
comportamiento
objeto
aislar
comportamiento
convertirlo
clases
separadas
permite
fácilmente
añadir
definir
transiciones
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
63
explícitas
transiciones
evitar
transiciones
internos
inconsistentes
transiciones
atómicas
Context
objetos
State
compartirse
contextos
tengan
interno
comportándose
objetos
patrón
Flyweight
intrínseco
comportamiento
Visitor
Permite
​añadir
​funcionalidad
​sin
necesidad
​cambiar
clases
elementos
ejecutarse
denominados
Visitors
patrón
sugiere
situemos
comportamiento
clase
llamada
Visitor
integrarlo
clase
base
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
64
necesite
añadir
comportamiento
hará
implementación
Visitor
clase
base
aceptar
delegar
comportamiento
Visitor
correspondiente
Participantes
Visitor
interfaz
declara
serie
métodos
normalmente
llamados
visit
reciben
parámetro
elementos
concretos
añadir
funcionalidad
crear
tantos
métodos
visit
clases
concretas
tengamos
llamarse
diferenciarán
firma
método
ConcreteVisitor
implementan
interfaz
Visitor
definen
funcionalidades
aplicarán
elementos
clase
base
definir
comportamiento
clase
base
caso
querer
modificación
hará
ConcreteVisitors
directamente
elemento
Recordemos
clase
base
únicamente
delega
Visitor
realice
modificaciones
Element
interfaz
declara
método
acepta
Visitors
ConcreteElement
clase
base
implementa
interfaz
Element
objetivo
redirigir
Visitor
concreto
encargará
añadir
comportamiento
específico
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
65
Iterator
Provee
forma
acceder
secuencialmente
elementos
colección
necesidad
exponer
representación
interna
objetivo
principal
extraer
comportamiento
colección
objeto
llamado
Iterator
encargará
información
necesaria
manipularla
cliente
trabajando
abstracciones
interfaces
permite
tipos
colecciones
iteradores
código
Participantes
Client
interactúa
Iterator
Iterable
interfaces
acoplarse
clases
concretas
Iterable
declara
método
responsable
instanciar
objeto
Iterator
Importante
método
devuelva
interfaz
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
66
acoplarnos
implementaciones
ConcreteIterable
implementa
interfaz
instancia
Iterator
concreto
iterará
colección
específica
Iterator
declara
métodos
necesarios
recorrer
colección
declarar
métodos
remove
getFirst
currentItem
size
next
etc.
ConcreteIterator
implementa
métodos
declarados
interfaz
responsable
gestionar
posición
iteración
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
67
PRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
68
Bibliografía
fuentes
consultado
basado
redacción
material
The
rules
of
simple
design
https://blog.jbrains.ca/permalink/the-four-elements-of-simple-desig
https://blog.thecodewhisperer.com/permalink/putting-an-age-old-ba
ttle-to-rest
​Understanding
the
Four
Rules
of
Simple
Design
Corey
Haines
The
Clean
Code
Blog
by
Robert
C.
Martin
Uncle
Bob
https://blog.cleancoder.com
Head
First
Design
Patterns
Eric
Freeman
Elisabeth
Freeman
Design
Patterns
Elements
of
Reusable
Object-Oriented
Software
Erich
Gamma
Richard
Helm
Ralph
Johnson
John
Vlissides
GoF
Core
J2EE
Patterns
Best
Practices
and
Design
Strategies
Deepak
Alur
John
Crupi
Malks
Patterns
of
Enterprise
Application
Architecture
Martin
Fowler
colaboración
David
Rice
Matthew
Foemmel
Edward
Hieatt
Robert
Mee
Randy
Stafford
Página
50
guía
visto
principales
principios
patrones
diseño
prácticas
experiencia
profesionales
sector
reunidas
serie
recetas
prácticas
software
crezca
evolucione
forma
sostenible
visto
malos
olores
desprender
código
profesionales
responsabilidad
irlos
solucionando
generando
deuda
técnica
bola
nieve
boy
scout
implícito
tareas
permitir
futuras
entregas
valor
rápidas
calidad
rompan
funcionalidad
existente
pide
permiso
managers
product
owners
gente
desarrollo
negocio
acometer
tareas
asumiendo
decisión
tareas
conllevan
inversión
tiempo
error
base
construcción
software
responsabilidad
desarrolladores
software
software
patrones
creacionales
estructurales
comportamiento
proporcionar
herramientas
válidas
entregar
valor
constante
calidad
prácticas
principios
diseño
proporcionar
herramientas
necesarias
afrontar
desarrollos
seguridad
sabiendo
decisiones
tomar
aplazar
construir
software
pilares
sólidos
cambio
cambio
mantengan
firmes
Lecciones
aprendidas
guíaPRINCIPIOS
PATRONES
DESARROLLO
SOFTWARE
Autentia
proporcionamos
soporte
desarrollo
software
ayudamos
transformación
digital
organizaciones
referentes
eficacia
prácticas
invito
informes
servicios
profesionales
Autentia
soporte
proporcionar
transformación
digital
empresa
Conoce
SOPORTE
DESARROLLO
Construimos
entornos
sólidos
proyectos
trabajando
diario
equipos
desarrollo
AUDITORÍA
DESARROLLO
Analizamos
calidad
técnica
producto
ayudamos
recuperar
productividad
perdida
ACOMPAÑAMIENTO
AGILE
Ayudamos
escalar
modelos
ágiles
organizaciones
FORMACIÓN
Formamos
empresas
clases
impartidas
desarrolladores
profesionales
activo
DISEÑO
PRODUCTO
UX
Convertimos
ideas
productos
digitales
valor
usuarios
ﬁnales
SOFTWARE
MEDIDA
Desarrollamos
aplicaciones
web
móviles
Fullstack
developers
expertos
backend
Expertos
creación
software
calidad
Diseñamos
productos
digitales
experiencias
medida
www.autentia.com
info@autentia.com
T.
91
675
33
06
Síguenos
canales
