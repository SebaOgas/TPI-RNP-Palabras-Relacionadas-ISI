ANDREW
S.
TANENBAUMANDREW
S.
TANENBAUM
TANENBAUMTANENBAUM
edición
best-seller
incorpora
recientes
desarrollos
tecnologías
sistemas
operativos
agregaron
cientos
páginas
material
eliminó
contenido
obsoleto
definiti-
cubre
principios
práctica
sistemas
operativos
modernos
concentrándose
Linux
Windows
Vista
sistemas
multimedia
embebidos
tiempo
real
Andrew
S.
Tanenbaum
plasma
estilo
entretenido
conceptos
importantes
diseñador
sistemas
operativos
dominar
base
extensa
trayectoria
diseñador
co-diseñador
sistemas
operativos
transmite
obra
profundos
conocimientos
experiencia
prácti-
ca
libros
igualar
diversos
temas
autor
detalle
procesos
hilos
administración
memoria
sistemas
archivos
interbloqueos
diseño
interfaces
multimedia
mejoras
rendimiento
tendencias
recientes
diseño
sistemas
operativos
EDICIÓN
reciente
cobertura
Windows
Vista
sistemas
operativos
Linux
Unix
caso
estudio
abarca
capítulo
sistema
operativo
Symbian
disposi-
tivos
móviles
análisis
actualizado
mejorado
seguridad
reorganización
completa
libro
temas
clave
presenten
oportu-
nidad
presentación
investigaciones
recientes
probablemente
devengan
sistemas
operativos
futuro
Ejercicios
programación
totalmente
actualizados
adicionales
capítulo
Experimentos
sistemas
operativos
línea
herramientas
populares
Windows
código
fuente
abierto
Ejercicios
simulación
sistemas
operativos
información
visite
página
Web
www.pearsoneducacion.net/tanenbaum
3ª
edición
SISTEMAS
OPERATIVOS
MODERNOS
3ª
edición
SISTEMAS
OPERATIVOS
MODERNOS
SISTEMAS
OPERATIVOS
MODERNOS
SISTEMAS
OPERATIVOS
MODERNOS
3ª
edición
ISBN
978-607-442-046-3
www.FreeLibros.me
www
FreeLibros.meSISTEMAS
OPERATIVOS
MODERNOS
EDICIÓN
Principios
Paradigmas
edición
www.FreeLibros.me
www
FreeLibros.meSISTEMAS
OPERATIVOS
MODERNOS
EDICIÓN
ANDREW
S.
TANENBAUM
Vrije
Universiteit
Amsterdam
Holanda
TRADUCCIÓN
Alfonso
Vidal
Romero
Elizondo
Ingeniero
Sistemas
Computacionales
Instituto
Tecnológico
Estudios
Superiores
Monterrey
Campus
Monterrey
REVISIÓN
TÉCNICA
José
Ramón
Ríos
Sánchez
Departamento
Académico
Computación
Instituto
Tecnológico
Autónomo
México
Aarón
Jiménez
Govea
Catedrático
Departamento
Ciencias
Computacionales
Universidad
Guadalajara
México
www
FreeLibros.meAuthorized
translation
from
the
English
language
edition
entitled
Modern
operating
systems
3rd
edition
by
Andrew
S.
Tanenbaum
published
by
Pearson
Education
Inc
publishing
as
PRENTICE
HALL
INC
Copyright
2008
All
rights
reserved
ISBN
9780136006633
Traducción
autorizada
edición
idioma
inglés
titulada
Modern
operating
systems
3ª.
edición
Andrew
S.
Tanenbaum
publicada
Pearson
Education
Inc
publicada
PRENTICE
HALL
INC
Copyright
2008
derechos
reservados
edición
español
única
autorizada
Edición
español
Editor
Luis
Miguel
Cruz
Castillo
e-mail:luis.cruz@pearsoned.com
Editor
desarrollo
Bernardino
Gutiérrez
Hernández
Supervisor
producción
José
D.
Hernández
Garduño
Edición
inglés
Editorial
Director
Computer
Science
Engineering
Cover
Illustrator
Steve
Lefkowitz
and
Advanced
Mathematics
Marcia
J.
Horton
Interior
design
Andrew
S.
Tanenbaum
Executive
Editor
Tracy
Dunkelberger
Typesetting
Andrew
S.
Tanenbaum
Editorial
Assistant
Melinda
Haggerty
Art
Director
Kenny
Beck
Associtate
Editor
ReeAnne
Davis
Art
Editor
Gregory
Dulles
Senior
Managing
Editor
Scott
Disanno
Media
Editor
David
Alick
Production
Editor
Irwin
Zucker
Manufacturing
Manager
Alan
Fischer
Cover
Concept
Andrews
S.
Tanenbaum
and
Tracy
Dunkelberger
Manufacturing
Buyer
Lisa
McDowell
Cover
Design
Tamara
Newman
Marketing
Manager
Mack
Patterson
EDICIÓN
2009
D.R.
2009
Pearson
Educación
México
S.A.
C.V
Atlacomulco
500-5o
piso
Col
Industrial
Atoto
53519
Naucalpan
Juárez
México
Cámara
Nacional
Industria
Editorial
Mexicana
Reg
Núm
1031
Prentice
Hall
marca
registrada
Pearson
Educación
México
S.A.
C.V
Reservados
derechos
totalidad
publicación
reproducirse
registrarse
transmitirse
sistema
recuperación
información
forma
electrónico
mecánico
foto-
químico
magnético
electroóptico
fotocopia
grabación
permiso
previo
escrito
editor
préstamo
alquiler
forma
cesión
ejemplar
requirirá
autorización
editor
representantes
ISBN
978-607-442-046-3
Impreso
México
Printed
in
Mexico
1234567890
Datos
catalogación
bibliográfica
TANENBAUM
ANDREW
S.
MAARTEN
AN
STEEN
Sistemas
operativos
modernos
edición
PEARSON
EDUCACIÓN
México
2009
ISBN
978-607-442-046-3
Área
Computación
Formato
18.5
23.5
cm
Páginas
1104
www
FreeLibros.mePara
Suzanne
Barbara
Marvin
memoria
Bram
Sweetie
/H9266
www.FreeLibros.me
www
FreeLibros.meCONTENIDO
PREFACIO
xxiv
INTRODUCCIÓN
1.1
SISTEMA
OPERATIVO
1.1.1
sistema
operativo
máquina
extendida
1.1.2
sistema
operativo
administrador
recursos
1.2
HISTORIA
SISTEMAS
OPERATIVOS
1.2.1
generación
1945
1955
tubos
vacío
1.2.2
generación
1955
1965
transistores
sistemas
procesamiento
lotes
1.2.3
generación
1965
1980
circuitos
integrados
multiprogramación
10
1.2.4
cuarta
generación
1980
fecha
computadoras
personales
15
1.3
REVISIÓN
HARDWARE
COMPUTADORA
19
1.3.1
Procesadores
19
1.3.2
Memoria
23
1.3.3
Discos
26
1.3.4
Cintas
27
1.3.5
Dispositivos
27
1.3.6
Buses
30
1.3.7
Arranque
computadora
33
vii
www
FreeLibros.me1.4
TIPOS
SISTEMAS
OPERATIVOS
33
1.4.1
Sistemas
operativos
mainframe
34
1.4.2
Sistemas
operativos
servidores
34
1.4.3
Sistemas
operativos
multiprocesadores
34
1.4.4
Sistemas
operativos
computadoras
personales
35
1.4.5
Sistemas
operativos
computadoras
bolsillo
35
1.4.6
Sistemas
operativos
integrados
35
1.4.7
Sistemas
operativos
nodos
sensores
36
1.4.8
Sistemas
operativos
tiempo
real
36
1.4.9
Sistemas
operativos
tarjetas
inteligentes
37
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
37
1.5.1
Procesos
38
1.5.2
Espacios
direcciones
40
1.5.3
Archivos
40
1.5.4
Entrada
salida
43
1.5.5
Protección
44
1.5.6
shell
44
1.5.7
ontogenia
recapitula
filogenia
46
1.6
LLAMADAS
SISTEMA
49
1.6.1
Llamadas
sistema
administración
procesos
52
1.6.2
Llamadas
sistema
administración
archivos
56
1.6.3
Llamadas
sistema
administración
directorios
57
1.6.4
Miscelánea
llamadas
sistema
58
1.6.5
API
Win32
Windows
59
1.7
ESTRUCTURA
SISTEMA
OPERATIVO
62
1.7.1
Sistemas
monolíticos
62
1.7.2
Sistemas
capas
63
1.7.3
Microkernels
64
1.7.4
Modelo
cliente-servidor
67
1.7.5
Máquinas
virtuales
67
1.7.6
Exokernels
71
1.8
MUNDO
72
1.8.1
lenguaje
72
1.8.2
Archivos
encabezado
73
1.8.3
Proyectos
programación
extensos
74
1.8.4
modelo
tiempo
ejecución
75
1.9
INVESTIGACIÓN
ACERCA
SISTEMAS
OPERATIVOS
76
1.10
DESCRIPCIÓN
GENERAL
RESTO
LIBRO
77
viii
CONTENIDO
www
FreeLibros.meCONTENIDO
ix
1.11
UNIDADES
MÉTRICAS
78
1.12
RESUMEN
79
PROCESOS
HILOS
83
2.1
PROCESOS
83
2.1.1
modelo
proceso
84
2.1.2
Creación
proceso
86
2.1.3
Terminación
procesos
88
2.1.4
Jerarquías
procesos
89
2.1.5
proceso
90
2.1.6
Implementación
procesos
91
2.1.7
Modelación
multiprogramación
93
2.2
HILOS
95
2.2.1
hilos
95
2.2.2
modelo
clásico
hilo
100
2.2.3
Hilos
POSIX
104
2.2.4
Implementación
hilos
espacio
usuario
106
2.2.5
Implementación
hilos
kernel
109
2.2.6
Implementaciones
híbridas
110
2.2.7
Activaciones
planificador
111
2.2.8
Hilos
emergentes
112
2.2.9
Conversión
código
hilado
simple
multihilado
114
2.3
COMUNICACIÓN
PROCESOS
117
2.3.1
Condiciones
carrera
117
2.3.2
Regiones
críticas
119
2.3.3
Exclusión
mutua
espera
ocupada
120
2.3.4
Dormir
despertar
125
2.3.5
Semáforos
128
2.3.6
Mutexes
130
2.3.7
Monitores
134
2.3.8
Pasaje
transmisión
mensajes
140
2.3.9
Barreras
144
2.4
PLANIFICACIÓN
145
2.4.1
Introducción
planificación
145
2.4.2
Planificación
sistemas
procesamiento
lotes
152
2.4.3
Planificación
sistemas
interactivos
154
2.4.4
Planificación
sistemas
tiempo
real
160
www
FreeLibros.me2.4.5
Política
mecanismo
161
2.4.6
Planificación
hilos
162
2.5
PROBLEMAS
CLÁSICOS
COMUNICACIÓN
PROCESOS
IPC
163
2.5.1
problema
filósofos
comelones
164
2.5.2
problema
lectores
escritores
167
2.6
INVESTIGACIÓN
ACERCA
PROCESOS
HILOS
168
2.7
RESUMEN
169
ADMINISTRACIÓN
MEMORIA
175
3.1
ABSTRACCIÓN
MEMORIA
176
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
179
3.2.1
noción
espacio
direcciones
180
3.2.2
Intercambio
181
3.2.3
Administración
memoria
libre
184
3.3
MEMORIA
VIRTUAL
188
3.3.1
Paginación
189
3.3.2
Tablas
páginas
193
3.3.3
Aceleración
paginación
194
3.3.4
Tablas
páginas
memorias
extensas
198
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
201
3.4.1
algoritmo
reemplazo
páginas
óptimo
202
3.4.2
algoritmo
reemplazo
páginas
usadas
recientemente
203
3.4.3
algoritmo
reemplazo
páginas
entrar
salir
FIFO
204
3.4.4
algoritmo
reemplazo
páginas
oportunidad
204
3.4.5
algoritmo
reemplazo
páginas
reloj
205
3.4.6
algoritmo
reemplazo
páginas
usadas
recientemente
LRU
206
3.4.7
Simulación
LRU
software
207
3.4.8
algoritmo
reemplazo
páginas
conjunto
trabajo
209
3.4.9
algoritmo
reemplazo
páginas
WSClock
213
3.4.10
Resumen
algoritmos
reemplazo
páginas
215
CONTENIDO
www
FreeLibros.meCONTENIDO
xi
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
216
3.5.1
Políticas
asignación
local
asignación
global
216
3.5.2
Control
carga
218
3.5.3
Tamaño
página
219
3.5.4
Espacios
separados
instrucciones
datos
221
3.5.5
Páginas
compartidas
221
3.5.6
Bibliotecas
compartidas
223
3.5.7
Archivos
asociados
225
3.5.8
Política
limpieza
226
3.5.9
Interfaz
memoria
virtual
226
3.6
CUESTIONES
IMPLEMENTACIÓN
227
3.6.1
Participación
sistema
operativo
paginación
227
3.6.2
Manejo
fallos
página
228
3.6.3
Respaldo
instrucción
229
3.6.4
Bloqueo
páginas
memoria
230
3.6.5
Almacén
respaldo
231
3.6.6
Separación
política
mecanismo
233
3.7
SEGMENTACIÓN
234
3.7.1
Implementación
segmentación
pura
237
3.7.2
Segmentación
paginación
MULTICS
238
3.7.3
Segmentación
paginación
Intel
Pentium
242
3.8
INVESTIGACIÓN
ACERCA
ADMINISTRACIÓN
MEMORIA
247
3.9
RESUMEN
248
SISTEMAS
ARCHIVOS
255
4.1
ARCHIVOS
257
4.1.1
Nomenclatura
archivos
257
4.1.2
Estructura
archivos
259
4.1.3
Tipos
archivos
260
4.1.4
Acceso
archivos
262
4.1.5
Atributos
archivos
263
4.1.6
Operaciones
archivos
264
4.1.7
programa
ejemplo
utiliza
llamadas
sistema
archivos
265
www
FreeLibros.me4.2
DIRECTORIOS
268
4.2.1
Sistemas
directorios
nivel
268
4.2.2
Sistemas
directorios
jerárquicos
268
4.2.3
Nombres
rutas
269
4.2.4
Operaciones
directorios
272
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
273
4.3.1
Distribución
sistema
archivos
273
4.3.2
Implementación
archivos
274
4.3.3
Implementación
directorios
280
4.3.4
Archivos
compartidos
283
4.3.5
Sistemas
archivos
estructurados
registro
285
4.3.6
Sistemas
archivos
bitácora
287
4.3.7
Sistemas
archivos
virtuales
288
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
292
4.4.1
Administración
espacio
disco
292
4.4.2
Respaldos
sistema
archivos
298
4.4.3
Consistencia
sistema
archivos
304
4.4.4
Rendimiento
sistema
archivos
307
4.4.5
Desfragmentación
discos
311
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
312
4.5.1
Sistemas
archivos
CD-ROM
312
4.5.2
sistema
archivos
MS-DOS
318
4.5.3
sistema
archivos
V7
UNIX
321
4.6
INVESTIGACIÓN
ACERCA
SISTEMAS
ARCHIVOS
324
4.7
RESUMEN
324
ENTRADA
SALIDA
329
5.1
PRINCIPIOS
HARDWARE
329
5.1.1
Dispositivos
330
5.1.2
Controladores
dispositivos
331
5.1.3
asignación
memoria
332
5.1.4
Acceso
directo
memoria
DMA
336
5.1.5
Repaso
interrupciones
339
xii
CONTENIDO
www
FreeLibros.meCONTENIDO
xiii
5.2
FUNDAMENTOS
SOFTWARE
343
5.2.1
Objetivos
software
343
5.2.2
programada
344
5.2.3
controlada
interrupciones
346
5.2.4
DMA
347
5.3
CAPAS
SOFTWARE
348
5.3.1
Manejadores
interrupciones
348
5.3.2
Drivers
dispositivos
349
5.3.3
Software
independiente
dispositivo
353
5.3.4
Software
espacio
usuario
359
5.4
DISCOS
360
5.4.1
Hardware
disco
361
5.4.2
Formato
disco
376
5.4.3
Algoritmos
programación
brazo
disco
379
5.4.4
Manejo
errores
382
5.4.5
Almacenamiento
estable
385
5.5
RELOJES
388
5.5.1
Hardware
reloj
388
5.5.2
Software
reloj
390
5.5.3
Temporizadores
software
393
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
394
5.6.1
Software
entrada
394
5.6.2
Software
salida
399
5.7
CLIENTES
DELGADOS
415
5.8
ADMINISTRACIÓN
ENERGÍA
417
5.8.1
Cuestiones
hardware
418
5.8.2
Cuestiones
sistema
operativo
419
5.8.3
Cuestiones
programas
aplicaciones
424
5.9
INVESTIGACIÓN
ACERCA
425
5.10
RESUMEN
426
INTERBLOQUEOS
433
6.1
RECURSOS
434
www
FreeLibros.me6.1.1
Recursos
apropiativos
apropiativos
434
6.1.2
Adquisición
recursos
435
6.2
INTRODUCCIÓN
INTERBLOQUEOS
437
6.2.1
Condiciones
interbloqueos
recursos
438
6.2.2
Modelado
interbloqueos
438
6.3
ALGORITMO
VESTRUZ
441
6.4
DETECCIÓN
RECUPERACIÓN
INTERBLOQUEO
442
6.4.1
Detección
interbloqueos
recurso
tipo
442
6.4.2
Detección
interbloqueo
recursos
tipo
444
6.4.3
Recuperación
interbloqueo
447
6.5
EVITAR
INTERBLOQUEOS
448
6.5.1
Trayectorias
recursos
449
6.5.2
seguros
inseguros
450
6.5.3
algoritmo
banquero
recurso
451
6.5.4
algoritmo
banquero
recursos
452
6.6
PREVENIR
INTERBLOQUEOS
454
6.6.1
atacar
condición
exclusión
mutua
454
6.6.2
atacar
condición
contención
espera
455
6.6.3
atacar
condición
apropiativa
455
6.6.4
atacar
condición
espera
circular
456
6.7
CUESTIONES
457
6.7.1
Bloqueo
fases
457
6.7.2
Interbloqueos
comunicaciones
458
6.7.3
Bloqueo
activo
459
6.7.4
Inanición
461
6.8
INVESTIGACIÓN
INTERBLOQUEOS
461
6.9
RESUMEN
462
SISTEMAS
OPERATIVOS
MULTIMEDIA
467
7.1
INTRODUCCIÓN
MULTIMEDIA
468
7.2
ARCHIVOS
MULTIMEDIA
472
7.2.1
Codificación
video
473
xiv
CONTENIDO
www
FreeLibros.meCONTENIDO
xv
7.2.2
Codificación
audio
476
7.3
COMPRESIÓN
VIDEO
478
7.3.1
estándar
JPEG
478
7.3.2
estándar
MPEG
481
7.4
COMPRESIÓN
AUDIO
484
7.5
PROGRAMACIÓN
PROCESOS
MULTIMEDIA
487
7.5.1
Procesos
programación
homogéneos
488
7.5.2
Programación
general
tiempo
real
488
7.5.3
Programación
monotónica
frecuencia
490
7.5.4
Programación
menor
tiempo
respuesta
491
7.6
PARADIGMAS
SISTEMAS
ARCHIVOS
MULTIMEDIA
493
7.6.1
Funciones
control
VCR
494
7.6.2
Video
demanda
496
7.6.3
Video
demanda
funciones
VCR
498
7.7
COLOCACIÓN
ARCHIVOS
499
7.7.1
Colocación
archivo
disco
500
7.7.2
estrategias
alternativas
organización
archivos
501
7.7.3
Colocación
archivos
video
demanda
504
7.7.4
Colocación
archivos
disco
506
7.7.5
Colocación
archivos
discos
508
7.8
CACHÉ
510
7.8.1
Caché
bloque
511
7.8.2
Caché
archivo
512
7.9
PROGRAMACIÓN
DISCOS
MULTIMEDIA
513
7.9.1
Programación
discos
estática
513
7.9.2
Programación
disco
dinámica
515
7.10
INVESTIGACIÓN
MULTIMEDIA
516
7.11
RESUMEN
517
SISTEMAS
MÚLTIPLES
PROCESADORES
523
8.1
MULTIPROCESADORES
526
8.1.1
Hardware
multiprocesador
526
www
FreeLibros.me8.1.2
Tipos
sistemas
operativos
multiprocesador
534
8.1.3
Sincronización
multiprocesadores
538
8.1.4
Planificación
multiprocesadores
542
8.2
MULTICOMPUTADORAS
548
8.2.1
Hardware
multicomputadora
549
8.2.2
Software
comunicación
nivel
553
8.2.3
Software
comunicación
nivel
usuario
555
8.2.4
Llamada
procedimiento
remoto
558
8.2.5
Memoria
compartida
distribuida
560
8.2.6
Planificación
multicomputadoras
565
8.2.7
Balanceo
carga
565
8.3
VIRTUALIZACIÓN
568
8.3.1
Requerimientos
virtualización
570
8.3.2
Hipervisores
tipo
571
8.3.3
Hipervisores
tipo
572
8.3.4
Paravirtualización
574
8.3.5
Virtualización
memoria
576
8.3.6
Virtualización
578
8.3.7
Dispositivos
virtuales
579
8.3.8
Máquinas
virtuales
CPUs
multinúcleo
579
8.3.9
Cuestiones
licencias
580
8.4
SISTEMAS
DISTRIBUIDOS
580
8.4.1
Hardware
red
583
8.4.2
Protocolos
servicios
red
586
8.4.3
Middleware
basado
documentos
590
8.4.4
Middleware
basado
sistemas
archivos
591
8.4.5
Middleware
basado
objetos
596
8.4.6
Middleware
basado
coordinación
598
8.4.7
Grids
Mallas
603
8.5
INVESTIGACIÓN
SISTEMAS
MÚLTIPLES
PROCESADORES
604
8.6
RESUMEN
605
SEGURIDAD
611
9.1
ENTORNO
SEGURIDAD
613
9.1.1
Amenazas
613
xvi
CONTENIDO
www
FreeLibros.meCONTENIDO
xvii
9.1.2
Intrusos
615
9.1.3
Pérdida
accidental
datos
616
9.2
FUNDAMENTOS
CRIPTOGRAFÍA
CIFRADO
616
9.2.1
Criptografía
clave
secreta
617
9.2.2
Criptografía
clave
pública
618
9.2.3
Funciones
vía
619
9.2.4
Firmas
digitales
619
9.2.5
Módulo
plataforma
confiable
621
9.3
MECANISMOS
PROTECCIÓN
622
9.3.1
Dominios
protección
622
9.3.2
Listas
control
acceso
624
9.3.3
Capacidades
627
9.3.4
Sistemas
confiables
630
9.3.5
Base
cómputo
confiable
631
9.3.6
Modelos
formales
sistemas
seguros
632
9.3.7
Seguridad
multinivel
634
9.3.8
Canales
encubiertos
637
9.4
AUTENTICACIÓN
641
9.4.1
Autenticación
contraseñas
642
9.4.2
Autenticación
objeto
físico
651
9.4.3
Autenticación
biométrica
653
9.5
ATAQUES
INTERIOR
656
9.5.1
Bombas
lógicas
656
9.5.2
Trampas
657
9.5.3
Suplantación
identidad
inicio
sesión
658
9.6
EXPLOTAR
ERRORES
BUGS
CÓDIGO
659
9.6.1
Ataques
desbordamiento
búfer
660
9.6.2
Ataques
cadenas
formato
662
9.6.3
Ataques
retorno
libc
664
9.6.4
Ataques
desbordamiento
enteros
665
9.6.5
Ataques
inyección
código
666
9.6.6
Ataques
escalada
privilegios
667
9.7
MALWARE
667
9.7.1
Caballos
Troya
troyanos
670
9.7.2
Virus
672
9.7.3
Gusanos
682
9.7.4
Spyware
684
9.7.5
Rootkits
688
www
FreeLibros.me9.8
DEFENSAS
692
9.8.1
Firewalls
693
9.8.2
antivirus
técnicas
anti-antivirus
695
9.8.3
Firma
código
701
9.8.4
Encarcelamiento
702
9.8.5
Detección
intrusos
basada
modelos
703
9.8.6
Encapsulamiento
código
móvil
705
9.8.7
Seguridad
Java
709
9.9
INVESTIGACIÓN
SEGURIDAD
711
9.10
RESUMEN
712
10
CASO
ESTUDIO
LINUX
719
10.1
HISTORIA
UNIX
LINUX
720
10.1.1
UNICS
720
10.1.2
UNIX
PDP-11
721
10.1.3
UNIX
portable
722
10.1.4
Berkeley
UNIX
723
10.1.5
UNIX
estándar
724
10.1.6
MINIX
725
10.1.7
Linux
726
10.2
GENERALIDADES
LINUX
728
10.2.1
Objetivos
Linux
729
10.2.2
Interfaces
Linux
730
10.2.3
shell
731
10.2.4
Programas
utilitarios
Linux
734
10.2.5
Estructura
kernel
736
10.3
PROCESOS
LINUX
739
10.3.1
Conceptos
fundamentales
739
10.3.2
Llamadas
sistema
administrar
procesos
Linux
741
10.3.3
Implementación
procesos
hilos
Linux
745
10.3.4
Planificación
Linux
752
10.3.5
Arranque
Linux
755
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
758
10.4.1
Conceptos
fundamentales
758
10.4.2
Llamadas
sistema
administración
memoria
Linux
761
xviii
CONTENIDO
www
FreeLibros.meCONTENIDO
xix
10.4.3
Implementación
administración
memoria
Linux
762
10.4.4
paginación
Linux
768
10.5
ENTRADA
SALIDA
LINUX
771
10.5.1
Conceptos
fundamentales
772
10.5.2
Redes
773
10.5.3
Llamadas
sistema
Entrada
Salida
Linux
775
10.5.4
Implementación
entrada
salida
Linux
775
10.5.5
módulos
Linux
779
10.6
SISTEMA
ARCHIVOS
LINUX
779
10.6.1
Conceptos
fundamentales
780
10.6.2
Llamadas
sistema
archivos
Linux
785
10.6.3
Implementación
sistema
archivos
Linux
788
10.6.4
NFS
sistema
archivos
red
796
10.7
SEGURIDAD
LINUX
803
10.7.1
Conceptos
fundamentales
803
10.7.2
Llamadas
sistema
seguridad
Linux
805
10.7.3
Implementación
seguridad
Linux
806
10.8
RESUMEN
806
11
CASO
ESTUDIO
WINDOWS
VISTA
813
11
HISTORIA
WINDOWS
VISTA
813
11.1.1
1980
MS-DOS
814
11.1.2
1990
Windows
basado
MS-DOS
815
11.1.3
2000
Windows
basado
NT
815
11.1.4
Windows
Vista
818
11.2
PROGRAMACIÓN
WINDOWS
VISTA
819
11.2.1
Interfaz
programación
aplicaciones
NT
nativa
822
11.2.2
interfaz
programación
aplicaciones
Win32
825
11.2.3
registro
Windows
829
11.3
ESTRUCTURA
SISTEMA
831
11.3.1
Estructura
sistema
operativo
832
11.3.2
Booteo
Windows
Vista
847
11.3.3
Implementación
administrador
objetos
848
11.3.4
Subsistemas
DLLs
servicios
usuario
858
www
FreeLibros.me11.4
PROCESOS
HILOS
WINDOWS
VISTA
861
11.4.1
Conceptos
fundamentales
861
11.4.2
Llamadas
API
administrar
trabajos
procesos
hilos
fibras
866
11.4.3
Implementación
procesos
hilos
871
11.5
ADMINISTRACIÓN
MEMORIA
879
11.5.1
Conceptos
fundamentales
879
11.5.2
Llamadas
sistema
administrar
memoria
884
11.5.3
Implementación
administración
memoria
885
11.6
CACHÉ
WINDOWS
VISTA
894
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
896
11.7.1
Conceptos
fundamentales
897
11.7.2
Llamadas
API
entrada
salida
898
11.7.3
Implementación
901
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
906
11.8.1
Conceptos
fundamentales
907
11.8.2
Implementación
sistema
archivos
NT
908
11.9
SEGURIDAD
WINDOWS
VISTA
918
11.9.1
Conceptos
fundamentales
919
11.9.2
Llamadas
API
seguridad
921
11.9.3
Implementación
seguridad
922
11.10
RESUMEN
924
12
CASO
ESTUDIO
SYMBIAN
929
12.1
HISTORIA
SYMBIAN
930
12.1.1
Raíces
Symbian
Psion
EPOC
930
12.1.2
Symbian
versión
931
12.1.3
Symbian
versión
932
12.1.4
Symbian
actualidad
932
12.2
GENERALIDADES
SYMBIAN
932
12.2.1
Orientación
objetos
933
12.2.2
Diseño
microkernel
934
12.2.3
nanokernel
Symbian
935
12.2.4
Acceso
recursos
cliente
servidor
935
xx
CONTENIDO
www
FreeLibros.meCONTENIDO
xxi
12.2.5
Características
sistema
operativo
936
12.2.6
Comunicaciones
multimedia
937
12.3
PROCESOS
HILOS
SYMBIAN
937
12.3.1
Hilos
nanohilos
938
12.3.2
Procesos
939
12.3.3
Objetos
activos
939
12.3.4
Comunicación
procesos
940
12.4
ADMINISTRACIÓN
MEMORIA
941
12.4.1
Sistemas
memoria
virtual
941
12.4.2
direcciona
Symbian
memoria
943
12.5
ENTRADA
SALIDA
945
12.5.1
Drivers
dispositivos
945
12.5.2
Extensiones
kernel
946
12.5.3
Acceso
directo
memoria
946
12.5.4
Caso
especial
medios
almacenamiento
947
12.5.5
Bloqueo
947
12.5.6
Medios
removibles
948
12.6
SISTEMAS
ALMACENAMIENTO
948
12.6.1
Sistemas
archivos
dispositivos
móviles
948
12.6.2
Sistemas
archivos
Symbian
949
12.6.3
Seguridad
protección
sistema
archivos
949
12.7
SEGURIDAD
SYMBIAN
950
12.8
COMUNICACIÓN
SYMBIAN
953
12.8.1
Infraestructura
básica
953
12.8.2
análisis
detallado
infraestructura
954
12.9
RESUMEN
957
13
DISEÑO
SISTEMAS
OPERATIVOS
959
13.1
NATURALEZA
PROBLEMA
DISEÑO
960
13.1.1
Objetivos
960
13.1.2
difícil
diseñar
sistema
operativo
961
13.2
DISEÑO
INTERFACES
963
13.2.1
Principios
guía
963
www
FreeLibros.me13.2.2
Paradigmas
965
13.2.3
interfaz
llamadas
sistema
968
13.3
IMPLEMENTACIÓN
971
13.3.1
Estructura
sistema
971
13.3.2
Comparación
mecanismo
directiva
975
13.3.3
Ortogonalidad
976
13.3.4
Nomenclatura
977
13.3.5
Tiempo
vinculación
978
13.3.6
Comparación
estructuras
estáticas
dinámicas
979
13.3.7
Comparación
implementación
arriba-abajo
implementación
abajo-arriba
980
13.3.8
Técnicas
útiles
981
13.4
RENDIMIENTO
987
13.4.1
lentos
sistemas
operativos
987
13.4.2
optimizar
988
13.4.3
Concesiones
espacio
tiempo
988
13.4.4
caché
991
13.4.5
Sugerencias
992
13.4.6
Explotar
localidad
993
13.4.7
Optimizar
caso
común
993
13.5
ADMINISTRACIÓN
PROYECTOS
994
13.5.1
mítico
hombre-mes
994
13.5.2
Estructura
equipos
995
13.5.3
función
experiencia
997
13.5.4
bala
plata
998
13.6
TENDENCIAS
DISEÑO
SISTEMAS
OPERATIVOS
998
13.6.1
Virtualización
999
13.6.2
Chips
multinúcleo
999
13.6.3
Sistemas
operativos
espacios
direcciones
extensos
1000
13.6.4
Redes
1000
13.6.5
Sistemas
paralelos
distribuidos
1001
13.6.6
Multimedia
1001
13.6.7
Computadoras
operadas
baterías
1002
13.6.8
Sistemas
embebidos
1002
13.6.9
Nodos
monitoreo
1003
13.7
RESUMEN
1003
xxii
CONTENIDO
www
FreeLibros.meCONTENIDO
xxiii
14
LISTA
LECTURAS
BIBLIOGRAFÍA
1007
14.1
SUGERENCIAS
CONTINUAR
LECTURA
1007
14.1.1
Introducción
obras
generales
1008
14.1.2
Procesos
hilos
1008
14.1.3
Administración
memoria
1009
14.1.4
Entrada
salida
1009
14.1.5
Sistemas
archivos
1010
14.1.6
Interbloqueos
1010
14.1.7
Sistemas
operativos
multimedia
1010
14.1.8
Sistemas
procesadores
1011
14.1.9
Seguridad
1012
14.1.10
Linux
1014
14.1.11
Windows
Vista
1014
14.1.12
sistema
operativo
Symbian
1015
14.1.13
Principios
diseño
1015
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1016
ÍNDICE
1049
www
FreeLibros.meLa
edición
libro
difiere
aspectos
empezar
reordena-
mos
capítulos
colocar
material
central
principio
pusimos
énfasis
sistema
operativo
creador
abstracciones
capítulo
actualizado
forma
considerable
ofrece
introducción
conceptos
capítulo
abstrac-
ción
CPU
procesos
aborda
abstracción
memoria
física
espacios
direcciones
memoria
virtual
versa
abstracción
disco
archivos
conjunto
procesos
espacios
direcciones
virtuales
archivos
conceptos
clave
proporcionan
sistemas
operativos
razón
hayamos
colocado
capítulos
correspondientes
establecido
edición
capítulo
modificó
actualizó
considerable
ejemplo
proporciona
introducción
lenguaje
programación
modelo
tiempo
ejecución
lectores
familiarizados
Java
capítulo
análisis
hilos
threads
modificó
expandió
reflejar
nue-
importancia
cosas
sección
acerca
hilos
Pthreads
estándar
IEEE
capítulo
administración
memoria
reorganizó
énfasis
idea
funciones
clave
sistema
operativo
proporcionar
abstracción
es-
pacio
direcciones
virtuales
proceso
eliminó
material
administra-
ción
memoria
sistemas
procesamiento
lotes
actualizó
referente
implementación
paginación
destacar
necesidad
administrar
espacios
di-
recciones
extensos
comunes
ofrecer
velocidad
PREFACIO
xxiv
www
FreeLibros.mePREFACIO
xxv
actualizaron
capítulos
eliminó
material
secciones
actividades
actuales
investigación
capítulos
reescribieron
cero
agregaron
problemas
ejercicios
programación
actualizó
capítulo
incluyendo
material
acerca
sistemas
multinúcleo
sección
tecnología
hipervirtualización
hipervisores
máqui-
nas
virtuales
utilizó
VMware
ejemplo
capítulo
modificó
reorganizó
considerable
material
actuali-
zado
referente
explotación
errores
bugs
código
malware
defensas
con-
tra
capítulo
10
acerca
Linux
readaptación
trataba
so-
bre
UNIX
Linux
duda
énfasis
Linux
cantidad
mate-
rial
capítulo
11
Windows
Vista
importante
revisión
capítulo
11
trataba
Windows
2000
capítulo
muestra
análisis
completamente
actualizado
Win-
dows
capítulo
12
parecer
sistemas
operativos
embebidos
incrustados
co-
mo
encuentran
teléfonos
celulares
asistentes
digitales
personales
PDAs
ignoran
mayoría
libros
texto
dispositivos
mercado
PCs
computadoras
portátiles
edición
remedia
problema
aná-
lisis
extendido
Symbian
utiliza
ampliamente
teléfonos
inteligentes
Smart
Phones
capítulo
13
diseño
sistemas
operativos
presenta
modificaciones
importantes
libro
pone
disposición
cantidad
material
didáctico
apoyo
suple-
mentos
instructor
encuentran
sitio
web
libro
www.pearsoneducacion.net/
tanembaum
incluyen
diapositivas
PowerPoint
herramientas
software
estudiar
sistemas
operativos
experimentos
laboratorio
estudiantes
simuladores
material
adicional
utilizar
cursos
instructores
utilicen
libro
texto
definitivamente
dar-
vistazo
personas
ayudaron
revisión
lugar
deseo
agradecer
editora
Tracy
Dunkelberger
libro
número
18
desgastado
editores
proceso
Tracy
allá
cumplimiento
deber
libro
cosas
tales
buscar
colabo-
radores
organizar
reseñas
ayudar
suplementos
lidiar
contratos
actuar
intermediario
PH
coordinar
cantidad
procesamiento
paralelo
general
asegurarse
saliera
tiempo
cosas
ayudó
mantener
es-
tricto
itinerario
trabajo
lograr
libro
imprimiera
tiempo
man-
teniéndose
animosa
alegre
actividades
exigían
atención
Gracias
Tracy
agradezco
Ada
Gavrilovska
Georgia
Tech
experta
aspectos
internos
Linux
actualizó
capítulo
10
basado
UNIX
énfasis
FreeBSD
convertirlo
en-
focado
Linux
capítulo
genérico
sistemas
UNIX
Linux
popular
estudiantes
FreeBSD
cambio
im-
portante
Dave
Probert
Microsoft
actualizó
capítulo
11
basado
Windows
2000
concentrarlo
Windows
Vista
similitudes
diferencias
con-
siderables
Dave
conoce
Windows
suficiente
visión
indicar
diferencia
puntos
Microsoft
correcto
equivocó
resultado
trabajo
libro
www
FreeLibros.meMike
Jipping
Hope
College
escribió
capítulo
acerca
Symbian
abordar
sis-
temas
embebidos
tiempo
real
grave
omisión
libro
gracias
Mike
resolvió
problema
sistemas
embebidos
tiempo
real
volviendo
importantes
mundo
capítulo
ofrece
excelente
introducción
tema
diferencia
Ada
Dave
Mike
enfocó
capítulo
Shivakant
Mishra
University
of
Colorado
Boulder
fungió
sistema
distribuido
leyendo
comentarios
capítulos
proporcionar
cantidad
ejer-
cicios
problemas
programación
libro
Hugh
Lauer
merece
mención
especial
pedimos
ideas
re-
visar
edición
esperábamos
informe
23
páginas
interlineado
sencillo
obtuvimos
cambios
énfasis
abstracciones
procesos
espacios
direcciones
archivos
participa-
ción
quiero
agradecer
personas
ayudaron
formas
incluyendo
sugerir
temas
cubrir
leer
manuscrito
cuidado
suplementos
contribuir
ejercicios
Steve
Armstrong
Jeffrey
Chastine
John
Connelly
Mischa
Gelder-
mans
Paul
Gray
James
Griffioen
Jorrit
Herder
Michael
Howard
Suraj
Kothari
Roger
Kraft
Trudy
Levine
John
Masiyowski
Shivakant
Mishra
Rudy
Pait
Xiao
Qin
Mark
Russinovich
Krishna
Sivalingam
Leendert
Doorn
Ken
Wong
personal
Prentice
Hall
amistoso
cooperativo
especial
Irwin
Zuc-
ker
Scott
Disanno
producción
David
Alick
ReeAnne
Davies
Melinda
Haggerty
edito-
rial
importante
Barbara
Marvin
siguen
maravillosos
forma
especial
única
quiero
agradecer
Suzan-
ne
amor
paciencia
recientes
Andrew
S.
Tanenbaum
xxvi
PREFACIO
www
FreeLibros.meACERCA
AUTOR
Andrew
S.
Tanenbaum
licenciatura
ciencias
M.I.T.
doctorado
University
of
California
Berkeley
actualidad
profesor
Ciencias
computacionales
Vrije
Universiteit
Amsterdam
Holanda
encabeza
Grupo
sistemas
computacionales
Decano
Advanced
School
for
Computing
and
Imaging
escuela
graduados
interuniver-
sidades
realiza
investigaciones
acerca
sistemas
paralelos
avanzados
distribuidos
creación
imágenes
Profesor
académico
Royal
Netherlands
Academy
of
Arts
and
Sciencies
salvado
convertirse
burócrata
Tanenbaum
investigaciones
compiladores
sistemas
operativos
redes
siste-
distribuidos
área
local
sistemas
distribuidos
área
amplia
escalan
mil
mi-
llones
usuarios
proyectos
investigación
producido
140
artículos
evaluados
expertos
publicaciones
especializadas
conferencias
participado
autor
coautor
libros
fecha
aparecido
18
ediciones
libros
traduci-
do
21
idiomas
vasco
tailandés
utilizan
universidades
mundo
combinación
idioma+edición
130
versiones
profesor
Tanenbaum
producido
cantidad
considerable
software
ar-
quitecto
principal
Amsterdam
Compiler
Kit
kit
herramientas
utilizado
ampliamente
escribir
compiladores
portables
diseñadores
principales
Amoeba
sistemas
distribuidos
utilizado
colección
estaciones
trabajo
conecta-
das
LAN
Globe
sistema
distribuido
área
amplia
autor
MINIX
pequeño
clon
UNIX
cuyo
propósito
principal
utilizar-
laboratorios
programación
estudiantes
inspiración
directa
Linux
plataforma
desarrolló
inicialmente
versión
actual
MINIX
conocida
MI-
NIX
concentra
sistema
operativo
extremadamente
confiable
seguro
profesor
Ta-
nenbaum
labor
terminado
innecesario
equipar
computadora
botón
reinicio
MIINIX
proyecto
continuo
código
fuente
abier-
to
invitados
participar
lector
visitar
www
.minix3.org
descargar
copia
gratuita
averiguar
ocurriendo
actualidad
estudiantes
doctorado
profesor
Tanenbaum
obtenido
gloria
graduarse
orgulloso
Tanenbaum
miembro
ACM
IEEE
Royal
Netherlands
Academy
of
Arts
and
Sciences
recibido
premios
labor
científica
incluyen
2007
IEEE
James
H.
Mulligan
Jr
Education
Medal
2003
TAA
McGuffey
Award
for
Computer
Science
and
Engineering
2002
TAA
Texty
Award
for
Computer
Science
and
Engineering
1997
ACM
SIGCSE
Award
for
Outstanding
Contributions
to
Computer
1994
ACM
Karl
Karlstrom
Outstanding
Educator
Award
pertenece
lista
mundo
Who
Who
in
the
World
página
Web
URL
http://www.cs.vu.nl/~ast
www.FreeLibros.me
www
FreeLibros.me1
INTRODUCCIÓN
computadora
moderna
consta
procesadores
memoria
principal
discos
im-
presoras
teclado
ratón
pantalla
monitor
interfaces
red
dispositivos
en-
trada
salida
general
sistema
complejo
programadores
aplicaciones
tuvieran
comprender
funcionamiento
partes
escribirían
código
trabajo
administrar
componentes
utilizarlos
óptima
tarea
desafiante
razón
computadoras
equipadas
capa
software
llama-
sistema
operativo
cuyo
trabajo
proporcionar
programas
usuario
modelo
compu-
tadora
simple
pulcro
encargarse
administración
recursos
mencionados
sistemas
operativos
tema
libro
mayoría
lectores
habrán
experiencia
sistema
operativo
Windows
Linux
FreeBSD
Mac
apariencias
engañosas
progra-
ma
usuarios
generalmente
interactúan
denomina
shell
basado
texto
GUI
Graphical
User
Interface
Interfaz
gráfica
usuario
utiliza
elementos
gráficos
iconos
realidad
forma
sistema
operativo
utiliza
cabo
trabajo
figura
1-1
presenta
esquema
general
componentes
principales
anali-
zan
inferior
muestra
hardware
consiste
circuitos
integrados
chips
tarje-
tas
discos
teclado
monitor
objetos
físicos
similares
hardware
software
mayoría
computadoras
modos
operación
kernel
usuario
sistema
operativo
pieza
fundamental
software
ejecuta
kernel
conocido
supervisor
sistema
operativo
acceso
www.FreeLibros.mecompleto
hardware
ejecutar
instrucción
máquina
capaz
ejecutar
resto
software
ejecuta
usuario
subconjunto
instrucciones
máquina
permitido
particular
instrucciones
afectan
control
má-
quina
encargan
entrada
salida
prohibidas
programas
usuario
olveremos
tratar
diferencias
kernel
usuario
repetidamente
libro
INTRODUCCIÓN
CAPÍTULO
Hardware
Software
usuario
kernel
Sistema
operativo
Navegador
Web
Lector
correo
electrónico
Reproductor
músicaPrograma
interfaz
usuario
Figura
1-1
Ubicación
sistema
operativo
programa
interfaz
usuario
shell
GUI
nivel
software
usuario
permite
ejecución
programas
navegador
Web
lector
correo
elec-
trónico
reproductor
música
programas
utilizan
forma
intensiva
sistema
operativo
ubicación
sistema
operativo
muestra
figura
1-1
ejecuta
directamente
hardware
proporciona
base
aplicaciones
software
distinción
importante
sistema
operativo
software
ejecuta
usua-
rio
usuario
gusta
ejemplo
lector
correo
electrónico
libre
con-
seguir
escribir
desea
libre
escribir
manejador
interrupciones
reloj
forma
sistema
operativo
protegido
hardware
intento
modificación
usuarios
distinción
clara
sistemas
integrados
co-
noce
integrados
incrustados
kernel
sistemas
inter-
pretados
sistemas
operativos
basados
Java
separar
componentes
utilizan
interpretación
hardware
sistemas
programas
ejecutan
usuario
ayudan
sistema
operativo
realizan
funciones
privilegiadas
ejemplo
programa
permite
usuarios
cambiar
contraseña
programa
forma
sistema
operativo
ejecuta
kernel
duda
cabo
función
delicada
proteger-
www
FreeLibros.meSECCIÓN
1.1
SISTEMA
OPERATIVO
especial
sistemas
idea
extremo
partes
tradicionalmente
sistema
operativo
ejemplo
sistema
archivos
ejecutan
espacio
usuario
dichos
sistemas
difícil
trazar
límite
ejecuta
kernel
forma
duda
sistema
operativo
decirse
progra-
ejecutan
forman
sistema
es-
tán
estrechamente
asociados
sistemas
operativos
difieren
programas
usuario
aplicación
cuestiones
lugar
residen
particular
enormes
complejos
larga
du-
ración
código
fuente
sistema
operativo
Linux
Windows
contiene
cerca
millones
líneas
código
idea
significa
considere
trabajo
imprimir
millones
líneas
formato
libro
50
líneas
página
1000
páginas
volumen
requerirían
100
volúmenes
listar
sistema
operativo
tamaño
de-
cir
librero
Imagine
lector
trabajo
encargado
mantenimiento
sistema
operativo
jefe
presenta
librero
código
Apréndase
ejecuta
kernel
programas
usua-
rio
interfaz
gráfica
bibliotecas
software
aplicación
básico
Explorador
Windows
abarcar
fácilmente
10
20
cantidad
punto
lector
idea
clara
sistemas
operativos
larga
vida
difícil
escribir
propietario
resiste
tirarlo
empezar
evolucionan
periodos
extensos
Windows
95/98
esencialmen-
sistema
operativo
distinto
Windows
NT/2000
XP
Vista
sucesor
apariencia
similar
usuarios
Microsoft
razones
deshacerse
Windows
98
describiremos
estudiemos
Windows
detalle
capítulo
11
ejemplo
principal
utilizaremos
libro
Windows
UNIX
variantes
clones
evolucionado
años
versiones
ta-
System
Solaris
FreeBSD
derivan
sistema
original
Linux
tie-
ne
base
código
modelada
estrechamente
UNIX
altamente
compatible
Utilizaremos
ejemplos
UNIX
libro
analizaremos
Linux
detalle
capítulo
10
capítulo
hablaremos
brevemente
aspectos
clave
sistemas
operativos
incluyendo
síntesis
historia
tipos
conceptos
básicos
estructura
capítulos
posteriores
volveremos
hablar
tópicos
importantes
detalle
1.1
SISTEMA
OPERATIVO
difícil
definir
sistema
operativo
aparte
software
ejecuta
kernel
problema
sistemas
ope-
rativos
realizan
funciones
básicas
relacionadas
proporcionar
programadores
aplicaciones
programas
aplicaciones
naturalmente
conjunto
abstracto
recur-
sos
simples
complejos
conjuntos
hardware
administrar
recursos
hard-
www.FreeLibros.meware
Dependiendo
esté
hablando
lector
escuchar
acerca
función
analizaremos
ambas
1.1.1
sistema
operativo
máquina
extendida
arquitectura
conjunto
instrucciones
organización
memoria
estructura
bus
mayoría
computadoras
nivel
lenguaje
máquina
primitiva
compleja
programar
especial
entrada
salida
punto
concreto
considere
forma
cabo
disco
flexible
dispositivos
controladores
device
controllers
compatibles
NEC
PD765
utilizan
mayoría
computadoras
personales
basadas
Intel
libro
utilizaremos
términos
disco
flexible
diskette
indistintamen-
Utilizamos
disco
flexible
ejemplo
obsoleto
simple
disco
duro
moderno
PD765
16
comandos
espe-
cifica
carga
bytes
registro
dispositivo
comandos
leer
escribir
datos
desplazar
brazo
disco
formato
pistas
inicializar
de-
tectar
restablecer
recalibrar
dispositivo
controlador
unidades
comandos
básicos
ready
write(lectura
escritura
re-
13
parámetros
empaquetados
bytes
parámetros
especifican
elementos
tales
co-
mo
dirección
bloque
disco
leer
número
sectores
pista
grabación
utilizado
físico
espacio
separación
sectores
marca
dirección
datos
eliminados
lector
comprende
tecnicismos
preocu-
pe
precisamente
punto
oscuro
operación
com-
pleta
chip
dispositivo
controlador
devuelve
23
campos
error
empaquetados
bytes
suficiente
programador
disco
flexible
cons-
tantemente
motor
encendido
apagado
motor
apagado
encen-
derse
retraso
arranque
datos
puedan
leídos
escritos
motor
dejar
tiempo
encendido
desgastará
programador
ve
obligado
lidiar
problema
elegir
retrasos
largos
arranque
desgastar
discos
flexibles
llegar
perder
datos
entrar
detalles
reales
quedar
programador
promedio
de-
see
involucrarse
programación
discos
flexibles
discos
duros
complejos
desea
abstracción
simple
alto
nivel
encargue
lidiar
disco
caso
discos
abstracción
común
disco
contiene
colección
archivos
nombre
archivo
abierto
lectura
escri-
tura
leído
escrito
cerrado
detalles
tales
grabación
utilizar
modulación
frecuencia
motor
momento
aparecer
abstracción
presenta
programador
aplicaciones
abstracción
clave
lidiar
complejidad
abstracciones
convierten
tarea
imposible
tareas
manejables
definir
implementar
abstracciones
utilizarlas
resolver
problema
cuestión
abstracción
ca-
usuario
computadora
comprende
archivo
pieza
útil
información
co-
mo
fotografía
digital
mensaje
correo
electrónico
almacenado
página
Web
fácil
lidiar
fotografías
correos
electrónicos
páginas
Web
detalles
discos
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.1
SISTEMA
OPERATIVO
caso
disco
flexible
descrito
trabajo
sistema
operativo
crear
abstrac-
ciones
implementar
administrar
objetos
abstractos
creados
li-
bro
hablaremos
acerca
abstracciones
claves
comprender
sistemas
operativos
punto
importante
vale
pena
repetirlo
distintas
palabras
respeto
ingenieros
industriales
diseñaron
Macintosh
hardware
feo
procesa-
dores
memorias
discos
dispositivos
reales
complicados
presentan
interfaces
di-
fíciles
enredadas
peculiares
inconsistentes
personas
escribir
software
utilizarlos
necesidad
compatibilidad
hardware
deseo
ahorrar
dinero
diseñadores
hard-
ware
idea
importa
grave
problema
ocasionando
software
principales
tareas
sistema
operativo
ocultar
hardware
presentar
programas
programadores
abstracciones
agradables
elegantes
simples
consisten-
tes
puedan
trabajar
sistemas
operativos
ocultan
fea
hermosa
muestra
figura
1-2
Sistema
operativo
Hardware
Interfaz
fea
Interfaz
hermosa
Programas
aplicación
Figura
1-2
sistemas
operativos
ocultan
hardware
feo
abstracciones
hermosas
recalcar
verdaderos
clientes
sistema
operativo
programas
apli-
cación
programadores
aplicaciones
tratan
directamen-
sistema
operativo
abstracciones
contraste
usuarios
finales
lidiar
abstracciones
proporciona
interfaz
usuario
shell
línea
comandos
interfaz
gráfica
abstracciones
interfaz
usuario
similares
proporciona
sistema
operativo
caso
aclarar
punto
considere
escritorio
normal
Windows
indicador
comandos
orientado
texto
pro-
gramas
ejecutan
sistema
operativo
Windows
utilizan
abstracciones
siste-
ma
proporciona
ofrecen
interfaces
usuario
distintas
similar
usuario
Linux
ejecuta
Gnome
KDE
ve
interfaz
distinta
ve
usuario
Linux
trabaja
directamente
Sistema
Window
subyacente
orientado
texto
abs-
tracciones
sistema
operativo
subyacente
casos
www
FreeLibros.meEn
libro
estudiaremos
detalladamente
abstracciones
proporcionan
progra-
aplicación
trataremos
acerca
interfaces
usuario
tema
extenso
importante
relacionado
periferia
sistemas
ope-
rativos
1.1.2
sistema
operativo
administrador
recursos
concepto
sistema
operativo
cuya
función
principal
proporcionar
abstracciones
pro-
gramas
aplicación
responde
perspectiva
abajo
perspectiva
alterna
abajo
sostiene
sistema
operativo
presente
administrar
piezas
sistema
complejo
computadoras
modernas
constan
procesadores
memorias
tempo-
rizadores
discos
ratones
interfaces
red
impresoras
amplia
variedad
dispositivos
perspectiva
alterna
trabajo
sistema
operativo
proporcionar
asignación
ordenada
controlada
procesadores
memorias
dispositivos
diversos
programas
compiten
recursos
sistemas
operativos
modernos
permiten
ejecución
simultánea
programas
Ima-
gine
ocurriría
programas
ejecutan
computadora
trataran
imprimir
resultados
forma
simultánea
impresora
primeras
líneas
impresión
po-
drían
provenir
programa
siguientes
programa
programa
sucesivo
resultado
caos
sistema
operativo
imponer
orden
caos
poten-
cial
guardando
búferes
disco
salida
destinada
impresora
termina
programa
sistema
operativo
copiar
salida
previamente
almacenada
archi-
vo
disco
impresora
tiempo
programa
continuar
gene-
rando
salida
ajeno
salida
realidad
enviando
impresora
computadora
red
usuarios
necesidad
administrar
proteger
memoria
dispositivos
recursos
contrario
usua-
rios
interferir
usuarios
necesitan
frecuencia
compartir
hardware
información
archivos
bases
datos
ejemplo
resu-
men
visión
sistema
operativo
sostiene
tarea
principal
registro
programa
utilizando
recursos
otorgar
peticiones
recursos
contabilizar
mediar
peticiones
conflicto
provenientes
distintos
programas
usuarios
administración
recursos
incluye
multiplexaje
compartir
recursos
formas
distintas
tiempo
espacio
recurso
multiplexa
tiempo
distintos
programas
usuarios
toman
turnos
utilizarlo
obtiene
acceso
recurso
sucesivo
ejemplo
CPU
programas
desean
ejecutar-
sistema
operativo
asigna
CPU
programa
ejecutado
tiempo
suficiente
programa
obtiene
acceso
CPU
momento
programa
vuelve
obtener
acceso
recurso
tarea
determinar
có-
mo
multiplexa
recurso
tiempo
tiempo
responsabilidad
sistema
operativo
ejemplo
multiplexaje
tiempo
compartición
impreso-
ra
trabajos
cola
impresión
imprimirlos
impresora
tomar
decisión
trabajo
imprimirse
continuación
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.2
HISTORIA
SISTEMAS
OPERATIVOS
tipo
multiplexaje
espacio
clientes
tomen
turnos
obtiene
recurso
ejemplo
normalmente
memoria
principal
divide
va-
rios
programas
ejecución
residente
tiempo
ejem-
plo
tomar
turnos
utilizar
CPU
Suponiendo
suficiente
memoria
contener
programas
eficiente
contener
programas
memoria
proporcionar
programa
memoria
especial
necesita
pequeña
frac-
ción
genera
problemas
equidad
protección
ejemplo
corresponde
sistema
operativo
resolverlos
recurso
multiplexa
espacio
disco
duro
mu-
chos
sistemas
disco
contener
archivos
usuarios
tiempo
Asig-
nar
espacio
disco
registro
utilizando
bloques
disco
tarea
típica
administración
recursos
común
sistema
operativo
1.2
HISTORIA
SISTEMAS
OPERATIVOS
sistemas
operativos
ido
evolucionando
años
siguientes
secciones
analizaremos
brevemente
hitos
importantes
sistemas
operativos
estrechamente
relacionados
historia
arquitectura
computadoras
ejecutan
analizaremos
generaciones
sucesivas
computadoras
sistemas
operativos
vinculación
generaciones
sistemas
operativos
generaciones
computadoras
burda
proporciona
estructura
forma
habría
progresión
muestra
continuación
cronológica
desarro-
llo
accidentado
fase
surgió
esperar
terminara
completa-
mente
traslapes
mencionar
falsos
inicios
callejones
salida
lector
tomar
guía
palabra
computadora
digital
diseñada
matemático
inglés
Charles
Bab-
bage
1792
1871
Babbage
gastó
vida
fortuna
tratando
cons-
truir
máquina
analítica
logró
funcionara
apropiada
puramente
mecánica
tecnología
podía
producir
ruedas
engranes
dientes
alta
precisión
requería
máquina
analítica
sistema
operativo
nota
histórica
interesante
Babbage
necesitaba
software
má-
quina
analítica
contrató
joven
llamada
Ada
Lovelace
hija
afamado
poeta
bri-
tánico
Lord
Byron
programadora
mundo
lenguaje
programación
Ada
nombre
1.2.1
generación
1945
1955
tubos
vacío
esfuerzos
infructuosos
Babbage
progresos
construcción
computadoras
digitales
Guerra
Mundial
estimuló
explosión
actividad
profesor
John
Atanasoff
estudiante
graduado
Clifford
Berry
construyeron
conoce
computadora
digital
funcional
Iowa
State
University
Uti-
lizaba
300
tubos
vacío
bulbos
tiempo
Konrad
Zuse
Berlín
www.FreeLibros.meconstruyó
computadora
Z3
relevadores
1944
máquina
Colossus
construida
equipo
trabajo
Bletchley
Park
Inglaterra
Mark
Howard
Aiken
Harvard
ENIAC
William
Mauchley
estudiante
graduado
J.
Presper
Eckert
Universidad
Pennsylvania
binarias
utilizaron
bulbos
programables
to-
das
primitivas
tardaban
segundos
cálculo
simple
grupo
personas
generalmente
ingenieros
diseñaban
cons-
truían
programaban
operaban
daban
mantenimiento
máquina
programación
realizaba
exclusivamente
lenguaje
máquina
creando
circuitos
eléctricos
conexión
miles
cables
tableros
conexiones
plugboards
controlar
funciones
básicas
máquina
lenguajes
programación
desconocidos
desconocía
lenguaje
ensamblador
sistemas
operativos
desconocían
usual
ope-
ración
consistía
programador
trabajaba
periodo
registrándose
hoja
firmas
entraba
cuarto
máquinas
insertaba
tablero
conexiones
compu-
tadora
invertía
horas
esperando
cerca
20,000
bulbos
quemara
du-
rante
ejecución
Prácticamente
problemas
cálculos
numéricos
simples
obtener
tablas
senos
cosenos
logaritmos
principios
década
1950
rutina
mejorado
introducción
tarjetas
perforadas
escribir
programas
tarjetas
leerlas
ta-
bleros
conexiones
aparte
procedimiento
1.2.2
generación
1955
1965
transistores
sistemas
procesamiento
lotes
introducción
transistor
mediados
década
1950
cambió
radicalmente
panora-
ma
computadoras
volvieron
confiables
fabricarlas
vender-
clientes
dispuestos
pagar
expectativa
seguirían
funcionando
tiempo
suficiente
cabo
cantidad
útil
trabajo
ha-
bía
clara
separación
diseñadores
constructores
operadores
programadores
per-
sonal
mantenimiento
máquinas
conocidas
mainframes
encerradas
cuartos
especiales
aire
acondicionado
grupos
operadores
profesionales
manejarlas
empresas
universidades
agencias
gubernamentales
importantes
podían
financiar
costo
multimi-
llonario
operar
máquinas
ejecutar
trabajo
programa
conjunto
programas
programador
escribía
programa
papel
FORTRAN
ensambla-
dor
pasaba
tarjetas
perforadas
llevaba
conjunto
tarjetas
cuarto
en-
trada
datos
entregaba
operadores
iba
tomar
café
esperar
resultados
estuvieran
listos
computadora
terminaba
trabajo
ejecutando
momento
operador
iba
impresora
arrancaba
hojas
resultados
llevarlas
cuarto
salida
datos
programador
pudiera
recogerlas
posteriormente
operador
tomaba
conjuntos
tarjetas
traído
cuarto
entrada
introducía
má-
quina
necesitaba
compilador
FORTRAN
operador
obtenerlo
gabinete
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.2
HISTORIA
SISTEMAS
OPERATIVOS
archivos
introducirlo
máquina
desperdiciaba
tiempo
computadora
mien-
operadores
caminaban
cuarto
máquina
alto
costo
equipo
sorprendente
personas
buscaran
rápidamente
formas
reducir
tiempo
desperdiciado
solución
adoptó
forma
general
sistema
pro-
cesamiento
lotes
idea
concepto
recolectar
bandeja
llena
trabajos
cuarto
entrada
datos
pasarlos
cinta
magnética
pequeña
computadora
relativamente
económica
IBM
1401
adecuada
leer
tar-
jetas
copiar
cintas
imprimir
resultados
cálculos
numéricos
lle-
var
cabo
cálculos
numéricos
utilizaron
máquinas
costosas
IBM
7094
procedimiento
ilustra
figura
1-3
1401
7094
1401
Lector
tarjetas
Unidad
cinta
Cinta
entrada
Salida
cinta
Cinta
sistema
Impresora
Figura
1-3
sistemas
procesamiento
lotes
programa-
dores
llevan
tarjetas
1401
1401
lee
lotes
trabajos
coloca
cin-
ta
operador
cinta
entrada
7094
7094
realiza
cálculos
operador
cinta
salida
1401
1401
imprime
resultados
hora
recolectar
lote
trabajos
tarjetas
leían
colocaban
cinta
magnética
llevaba
cuarto
máquinas
monta-
ba
unidad
cinta
operador
cargaba
programa
especial
ancestro
sis-
tema
operativo
leía
trabajo
cinta
ejecutaba
resultados
escribían
cinta
imprimirlos
terminaba
trabajo
sistema
operativo
leía
automática
trabajo
cinta
empezaba
ejecu-
tarlo
terminaba
ejecutar
lote
operador
quitaba
cintas
entrada
salida
reemplazaba
cinta
entrada
lote
llevaba
cinta
salida
1401
imprimir
línea
conexión
computadora
principal
figura
1-4
muestra
estructura
típica
trabajo
entrada
ordinario
Empieza
tarjeta
JOB
especificando
tiempo
máximo
ejecución
minutos
número
cargar
nombre
programador
utiliza
tarjeta
FORTRAN
indi-
cando
sistema
operativo
cargar
compilador
FORTRAN
cinta
sistema
Des-
pués
inmediatamente
programa
compilar
tarjeta
LOAD
indica
sistema
operativo
cargar
programa
objeto
acaba
compilar
programas
compilados
escribían
cintas
reutilizables
tenían
cargarse
forma
explí-
cita
utiliza
tarjeta
RUN
indica
sistema
operativo
ejecutar
www.FreeLibros.meprograma
datos
suceden
tarjeta
END
marca
trabajo
Es-
tas
tarjetas
control
primitivas
precursoras
shells
intérpretes
línea
coman-
modernos
10
INTRODUCCIÓN
CAPÍTULO
JOB
10,6610802
MARVIN
TANENBAUM
FORTRAN
LOAD
RUN
END
Programa
Fortran
Datos
programa
Figura
1-4
Estructura
trabajo
típico
FMS
computadoras
generación
utilizaron
principalmente
cálculos
científicos
ingeniería
tales
resolver
ecuaciones
diferenciales
parciales
surgen
me-
nudo
física
ingeniería
programaron
FORTRAN
lenguaje
ensamblador
sistemas
operativos
típicos
FMS
Fo
rtran
Monitor
System
IBSYS
sistema
operativo
IBM
7094
1.2.3
generación
1965
1980
circuitos
integrados
multiprogramación
principio
década
1960
mayoría
fabricantes
computadoras
tenían
líneas
productos
distintas
incompatibles
computadoras
científicas
escala
orientadas
palabras
7094
utilizaban
cálculos
numéricos
ciencia
ingeniería
computadoras
comerciales
orientadas
caracteres
1401
utilizaban
ampliamente
ordenar
cintas
imprimir
datos
bancos
com-
pañías
seguros
Desarrollar
mantenimiento
líneas
productos
completamente
distintos
propuesta
costosa
fabricantes
clientes
computadoras
necesita-
ban
principio
equipo
pequeño
suficiente
deseaban
máqui-
na
pudiera
ejecutar
programas
anteriores
rapidez
www
FreeLibros.meSECCIÓN
1.2
HISTORIA
SISTEMAS
OPERATIVOS
11
IBM
intentó
resolver
problemas
golpe
introducción
línea
compu-
tadoras
System/360
360
serie
máquinas
compatibles
software
variaban
tamaño
similar
1401
potentes
7094
máquinas
diferían
precio
rendimiento
máxima
memoria
velocidad
procesador
número
dispositivos
permitidos
etcétera
máquinas
tenían
arquitectura
conjunto
instrucciones
programas
escritos
máquina
podían
ejecutarse
teoría
360
diseñó
manejar
compu-
tación
científica
numérica
comercial
ende
familia
máquinas
po-
satisfacer
necesidades
clientes
años
siguientes
tecnología
moderna
IBM
desarrollado
sucesores
compatibles
línea
360
conoce
modelos
370
4300
3080
3090
serie
zSeries
descendiente
re-
ciente
línea
diverge
considerablemente
original
IBM
360
línea
importante
computadoras
utilizar
circuitos
integrados
ICs
pequeña
escala
ofrecer
ventaja
precio
rendimiento
comparación
máquinas
generación
construidas
tran-
sistores
individuales
éxito
inmediato
idea
familia
computadoras
compatibles
adoptada
fabricantes
importantes
descendientes
máqui-
nas
siguen
utilizando
centros
cómputo
actualidad
utilizan
frecuencia
manejar
bases
datos
enormes
ejemplo
sistemas
reservaciones
aerolíneas
servidores
sitios
World
Wide
Web
procesar
miles
solicitudes
se-
gundo
fortaleza
idea
familia
tiempo
debilidad
intención
software
incluyendo
sistema
operativo
OS/360
funcionara
to-
modelos
Debía
ejecutarse
sistemas
pequeños
general
reemplazaban
1401s
copiaba
tarjetas
cinta
sistemas
reemplazaban
7094s
realizaba
predicciones
clima
cálculos
pesados
sis-
temas
dispositivos
periféricos
sistemas
funcionar
entornos
comerciales
científicos
eficiente
usos
distintos
forma
IBM
pudiera
escribir
pieza
software
cum-
pliera
requerimientos
conflicto
resultado
enorme
extraordinariamen-
complejo
sistema
operativo
órdenes
magnitud
FMS
Consistía
millones
líneas
lenguaje
ensamblador
escrito
miles
programadores
miles
errores
requerían
flujo
continuo
versiones
intento
co-
rregirlos
versión
corregía
errores
introducía
probablemen-
número
errores
permanecía
constante
tiempo
Fred
Brooks
diseñadores
OS/360
escribió
posteriormente
libro
ingenioso
incisivo
Brooks
1996
describía
experiencias
OS/360
imposible
re-
sumir
libro
basta
portada
muestra
manada
bestias
prehistóricas
atrapadas
pozo
brea
portada
Silberschatz
coautores
2005
muestra
punto
vista
similar
acerca
sistemas
operativos
dinosaurios
enorme
tamaño
problemas
OS/360
sistemas
operativos
similares
generación
producidos
fabricantes
computadoras
realidad
dejaban
razo-
www.FreeLibros.menablemente
satisfechos
mayoría
clientes
popularizaron
técnicas
clave
ausentes
sistemas
operativos
generación
importante
multiprogramación
7094
trabajo
actual
detenía
esperar
comple-
tara
operación
cinta
dispositivo
CPU
simplemente
permanecía
inactiva
terminar
operación
S.
cálculos
científicos
requieren
intensivo
CPU
frecuente
tiempo
desperdiciado
considerable
pro-
cesamiento
datos
comerciales
tiempo
espera
operaciones
menu-
do
80
90
ciento
tiempo
debía
hacerse
evitar
costosa
CPU
esté
inactiva
tiempo
solución
surgió
particionar
memoria
piezas
trabajo
distinto
partición
muestra
figura
1-5
trabajo
esperaba
com-
pletara
operación
podía
usando
CPU
pudieran
contenerse
suficientes
trabajos
memoria
principal
tiempo
CPU
podía
ocupada
100
ciento
tiempo
trabajos
forma
segura
memoria
requiere
hardware
espe-
cial
proteger
trabajo
evitar
entrometan
malogren
360
de-
sistemas
generación
equipados
hardware
12
INTRODUCCIÓN
CAPÍTULO
Trabajo
Trabajo
Trabajo
Sistema
operativo
Particiones
memoria
Figura
1-5
sistema
multiprogramación
trabajos
memoria
característica
importante
sistemas
operativos
generación
capacidad
leer
trabajos
tarjetas
colocarlos
disco
llevaban
cuarto
compu-
tadoras
terminaba
trabajo
ejecución
sistema
operativo
podía
cargar
nue-
vo
trabajo
disco
partición
vacía
ejecutaba
técnica
conoce
spooling
Simultaneous
Peripheral
Operation
On
Line
operación
periférica
simultánea
línea
utilizó
operaciones
salida
spooling
máquinas
1401
necesarias
desapareció
trabajo
transportar
cintas
sistemas
operativos
generación
apropiados
cálculos
cientí-
ficos
extensos
ejecuciones
procesamiento
datos
comerciales
masivos
seguían
esencia
sistemas
procesamiento
lotes
programadores
añoraban
prime-
ra
generación
tenían
máquina
horas
po-
dían
depurar
programas
rapidez
sistemas
generación
tiempo
transcurría
enviar
trabajo
recibir
vuelta
salida
comúnmente
horas
coma
colocada
podía
ocasionar
fallara
compilación
programador
des-
perdiciara
mitad
deseo
obtener
tiempo
rápido
respuesta
allanó
camino
tiempo
compar-
tido
timesharing
variante
multiprogramación
usuario
terminal
www
FreeLibros.meSECCIÓN
1.2
HISTORIA
SISTEMAS
OPERATIVOS
13
línea
sistema
tiempo
compartido
20
usuarios
conectados
17
pen-
sando
paseo
tomar
café
CPU
asignar
turno
trabajos
de-
atendidos
personas
depuran
programas
generalmente
envían
comandos
cortos
ejemplo
compilar
procedimiento
hojas
largos
ejemplo
or-
denar
archivo
millón
registros
computadora
proporcionar
servicio
rápi-
do
interactivo
usuarios
ocuparse
trabajos
lotes
plano
CPU
estaría
inactiva
sistema
tiempo
com-
partido
propósito
general
conocido
CTSS
Compatible
Time
Sharing
System
Sistema
compatible
tiempo
compartido
desarrolló
M.I.T.
7094
modificada
forma
especial
Corbató
colaboradores
1962
realidad
tiempo
compartido
po-
pularizó
hardware
protección
necesario
empezó
utilizar
ampliamente
du-
rante
generación
éxito
sistema
CTSS
M.I.T.
Bell
Labs
General
Electric
enton-
ces
importante
fabricante
computadoras
decidieron
emprender
desarrollo
uti-
lería
computadora
máquina
capaz
servir
cientos
usuarios
simultáneos
tiempo
compartido
modelo
sistema
electricidad
necesita
energía
conectar
contacto
pared
razonable
energía
requiera
esta-
rá
diseñadores
sistema
conocido
MULTICS
MULTiplexed
Information
and
Computing
Service
Servicio
Información
Cómputo
MULTiplexado
imaginaron
enor-
máquina
proporcionaba
cómputo
usuarios
área
Boston
idea
40
años
vendieran
millones
máquinas
10,000
rápidas
mainframe
GE-645
precio
1000
dólares
pura
ciencia
ficción
Al-
go
idea
existiera
transatlántico
supersónico
agua
MULTICS
éxito
parcial
diseñó
soporte
cientos
usuarios
máqui-
na
potente
PC
basada
Intel
386
capacidad
S.
disparatado
personas
sabían
escri-
bir
programas
pequeños
eficientes
habilidad
perdido
tiempo
razones
MULTICS
acaparó
atención
mundial
escrito
PL
compilador
PL
demoró
años
fun-
cionaba
Aparte
MULTICS
sistema
ambicioso
época
parecido
máquina
analítica
Charles
Babbage
siglo
diecinueve
resumir
larga
historia
MULTICS
introdujo
ideas
seminales
literatura
computadoras
convertirlas
producto
serio
éxito
comercial
importante
difícil
cualquiera
hubiera
esperado
Bell
Labs
retiró
proyecto
Gene-
ral
Electric
negocio
computadoras
completo
M.I.T.
persistió
logró
momento
MULTICS
funcionara
compañía
compró
negocio
computadoras
GE
Honeywell
vendió
producto
comercial
instala-
do
cerca
80
compañías
universidades
importantes
nivel
mundial
número
pe-
queño
usuarios
MULTICS
leales
ejemplo
General
Motors
Ford
Agencia
Seguridad
Nacional
Unidos
desconectaron
sistemas
MULTICS
libro
utilizaremos
términos
procedimiento
subrutina
función
indistinta
www.FreeLibros.mefinales
década
1990
30
años
presentación
mercado
tratar
años
Honeywell
actualizara
hardware
concepto
utilería
computadora
disipado
regrese
forma
servidores
masivos
Internet
centralizados
conecten
máquinas
usua-
rio
relativamente
tontas
mayoría
trabajo
realice
servidores
pro-
bable
motivación
caso
mayoría
personas
desean
administrar
sistema
cómputo
complejo
melindroso
prefieren
delegar
tarea
equi-
po
profesionales
trabajen
compañía
opera
servidor
comercio
electrónico
evolucionando
dirección
compañías
operan
centros
comerciales
elec-
trónicos
servidores
multiprocesador
conectan
máquinas
cliente
simples
parecido
diseño
MULTICS
carencia
éxito
comercial
MULTICS
enorme
influencia
siste-
operativos
subsecuentes
describe
artículos
libro
Corbató
colaboradores
1972
Corbató
Vyssotsky
1965
Daley
Dennis
1968
Organick
1972
Staltzer
1974
sitio
Web
activo
ubicado
www.multicians.org
información
acer-
ca
sistema
diseñadores
usuarios
desarrollo
importante
generación
increíble
crecimiento
mi-
nicomputadoras
empezando
DEC
PDP-1
1961
PDP-1
palabras
18
bits
120,000
máquina
ciento
precio
7094
vendió
co-
mo
pan
caliente
clase
trabajo
numérico
rápida
7094
origen
industria
minicomputadora
siguió
rápidamente
serie
PDP
diferencia
familia
IBM
incompatibles
culminando
PDP-11
Posteriormente
Ken
Thompson
científicos
cómputo
Bell
Labs
trabajó
proyecto
MULTICS
encontró
pequeña
minicomputadora
PDP-7
usando
dispuso
escribir
versión
simple
MULTICS
usuario
tra-
convirtió
sistema
operativo
UNIX
popular
mundo
académico
agencias
gubernamentales
compañías
historia
UNIX
contada
libros
ejemplo
Salus
1994
capítulo
10
hablaremos
historia
baste
código
fuente
disponible
ampliamente
organizaciones
desarrollaron
versiones
incompatibles
produjo
caos
desarrollaron
versiones
princi-
pales
System
AT&T
BSD
Berkeley
Software
Distribution
Distribución
Software
Berkeley
Universidad
California
Berkeley
versiones
tenían
variantes
menores
escribir
programas
pudieran
ejecutarse
sistema
UNIX
IEEE
desarrolló
estándar
UNIX
conocido
POSIX
mayoría
versiones
UNIX
actuales
cumplen
POSIX
define
interfaz
mínima
llamadas
sis-
tema
sistemas
UNIX
conformarse
sistemas
ope-
rativos
admiten
interfaz
POSIX
agregado
vale
pena
mencionar
1987
autor
liberó
pequeño
clon
UNIX
conocido
MINIX
fines
educativos
funcionalidad
MINIX
simi-
lar
UNIX
incluyendo
soporte
POSIX
época
versión
original
evolucio-
nado
MINIX
altamente
modular
enfocada
presentar
alta
confiabilidad
habilidad
detectar
reemplazar
módulos
fallas
inutilizables
dis-
14
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.2
HISTORIA
SISTEMAS
OPERATIVOS
15
positivos
controladores
dispositivos
instante
necesidad
reiniciar
pertur-
bar
programas
ejecución
disponible
libro
describe
operación
inter-
na
contiene
listado
código
fuente
apéndice
Tanenbaum
Woodhull
2006
sistema
MINIX
disponible
forma
gratuita
incluyendo
código
fuente
Internet
www.minix3.org
deseo
versión
producción
educativa
gratuita
MINIX
llevó
es-
tudiante
finlandés
llamado
Linus
Torvalds
escribir
Linux
sistema
inspirado
MI-
NIX
desarrollado
sistema
originalmente
ofrecía
soporte
características
MINIX
ejemplo
sistema
archivos
MINIX
extendido
formas
retiene
estructura
subyacente
común
MINIX
UNIX
lectores
interesados
historia
detallada
Linux
movimien-
to
código
fuente
abierto
deseen
leer
libro
Glyn
Moody
2001
acerca
UNIX
libro
aplica
System
MINIX
Linux
versiones
clones
UNIX
1.2.4
cuarta
generación
1980
fecha
computadoras
personales
desarrollo
circuitos
LSI
Large
Scale
Integration
Integración
escala
contienen
miles
transistores
centímetro
cuadrado
silicio
chip
nació
computadora
personal
términos
arquitectura
computadoras
personales
princi-
pio
conocidas
microcomputadoras
distintas
minicomputado-
ras
clase
PDP-11
términos
precio
duda
distintas
minicomputadora
departamento
compañía
universidad
tuviera
computadora
chip
microprocesador
logró
individuo
tuviera
compu-
tadora
personal
Intel
presentó
microprocesador
8080
1974
CPU
bits
propó-
sito
general
deseaba
sistema
operativo
probarlo
Intel
pidió
consultores
Gary
Kildall
escribiera
Kildall
amigo
construyeron
dispo-
sitivo
controlador
disco
flexible
pulgadas
Shugart
Associates
recién
si-
do
sacado
mercado
conectaron
disco
flexible
8080
produjeron
microcomputadora
disco
Kildall
escribió
sistema
operativo
basado
disco
conocido
CP
Control
Program
for
Microcomputers
Programa
Control
Microcomputadoras
CPU
Intel
pensó
microcomputadoras
basadas
disco
tuvieran
futuro
Kildall
pidió
derechos
CP
Intel
concedió
petición
Kildall
formó
compañía
llamada
Digital
Research
desarrollar
vender
CP
M.
1977
Digital
Research
rediseñó
CP
adaptarlo
pudiera
ejecutar
microcomputadoras
utilizaban
chips
8080
Zilog
Z80
escribieron
programas
aplicación
ejecutarse
CP
permitió
dominar
comple-
to
mundo
microcomputación
tiempo
aproximado
años
www
FreeLibros.meA
principios
década
1980
IBM
diseñó
IBM
PC
buscó
software
ejecutarlo
gente
IBM
puso
contacto
Bill
Gates
obtener
licencia
in-
térprete
BASIC
preguntaron
sabía
sistema
operativo
ejecutara
PC
Gates
sugirió
IBM
pusiera
contacto
Digital
Research
compañía
dominio
mundial
área
sistemas
operativos
Kildall
rehusó
reunirse
IBM
envió
subordinados
duda
decisión
ne-
gocios
historia
empeorar
cosas
abogado
rehusó
firmar
contrato
divulgación
IBM
PC
anunciado
IBM
regresó
Gates
podía
proveerles
sistema
operativo
IBM
regresó
Gates
enterado
fabricante
local
computadoras
Seattle
Computer
Products
sistema
operativo
adecuado
conocido
Disk
Ope-
rating
System
Sistema
Operativo
Disco
acercó
ofreció
comprarlo
supues-
tamente
75,000
dólares
accedieron
Gates
ofreció
IBM
paquete
BASIC
aceptó
IBM
quería
modificaciones
Gates
contrató
persona
escribió
Tim
Paterson
empleado
recién
creada
empresa
nombre
Microsoft
llevara
cabo
sistema
rediseñado
cambió
nombre
MS-DOS
Microsoft
Disk
Operating
System
Sistema
Operativo
Disco
Micro-
Soft
rápidamente
dominar
mercado
IBM
PC
factor
clave
deci-
sión
Gates
retrospectiva
extremo
inteligente
vender
MS-DOS
empresas
computadoras
incluyeran
hardware
comparación
inten-
to
Kildall
vender
CP
usuarios
finales
principio
supo
Kildall
murió
forma
repentina
inesperada
cau-
sas
reveladas
completo
salió
mercado
1983
IBM
PC
AT
sucesora
IBM
PC
CPU
Intel
80286
MS-DOS
afianzado
CP
daba
suspiros
MS-DOS
utilizó
ampliamente
80386
80486
versión
inicial
MS-DOS
primitiva
versiones
siguientes
tenían
características
avanzadas
incluyendo
tomaron
UNIX
Microsoft
UNIX
inclusive
vendía
versión
sistema
microcomputadora
conocida
XENIX
años
com-
pañía
CP
MS-DOS
sistemas
operativos
primeras
microcomputadoras
basaban
usuarios
escribieran
comandos
teclado
tiempo
cambió
debi-
do
investigación
realizada
Doug
Engelbart
Stanford
Research
Institute
década
1960
Engelbart
inventó
Interfaz
Gráfica
Usuario
GUI
completa
ventanas
iconos
menús
ratón
investigadores
Xerox
PARC
adoptaron
ideas
incorporaron
máquinas
construyeron
Steve
Jobs
co-inventor
computadora
Apple
cochera
visitó
PARC
vio
GUI
inmediato
valor
potencial
administración
Xe-
rox
equivocación
estratégica
gigantescas
proporciones
condujo
libro
titulado
Fumbling
the
Future
Smith
Alexander
1988
Posteriormente
Jobs
emprendió
proyecto
construir
Apple
GUI
proyecto
culminó
Lisa
costosa
fra-
casó
comercialmente
intento
Jobs
Apple
Macintosh
enorme
éxito
só-
económica
Lisa
amigable
16
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.2
HISTORIA
SISTEMAS
OPERATIVOS
17
usuario
user
friendly
significaba
diseñada
usuarios
sa-
bían
acerca
computadoras
tenían
intención
aprender
mundo
creativo
diseño
gráfico
fotografía
digital
profesional
producción
video
digital
profesional
Macintosh
ampliamente
utilizadas
usuarios
entusiastas
Microsoft
decidió
crear
sucesor
MS-DOS
fuertemente
influenciado
éxito
Macintosh
Produjo
sistema
basado
GUI
llamado
Windows
principio
ejecutaba
MS-DOS
shell
sis-
tema
operativo
cerca
10
años
1985
1995
Windows
entorno
gráfico
MS-DOS
1995
liberó
versión
independiente
Win-
dows
conocida
Windows
95
incorporaba
características
sistemas
opera-
tivos
utilizaba
sistema
MS-DOS
subyacente
iniciar
ejecutar
programas
MS-DOS
antiguos
1998
liberó
versión
ligeramente
modificada
sistema
conocida
Windows
98
Windows
95
Windows
98
contenían
cantidad
lenguaje
ensamblador
procesadores
Intel
16
bits
sistemas
operativos
Microsoft
Windows
NT
NT
significa
Tecnolo-
gía
compatible
Windows
95
nivel
completamente
rediseñado
interior
sistema
completo
32
bits
diseñador
jefe
Windows
NT
David
Cutler
diseñadores
sistema
operativo
VMS
AX
al-
gunas
ideas
VMS
presentes
NT
tantas
ideas
VMS
presentes
pro-
pietario
VMS
DEC
demandó
Microsoft
caso
resolvió
corte
cantidad
dígitos
Microsoft
esperaba
versión
NT
acabara
MS-DOS
versiones
Windows
sistema
superior
fracasó
Windows
NT
4.0
finalmente
empezó
éxito
especial
redes
corporativas
ver-
sión
Windows
NT
cambió
nombre
Windows
2000
principios
1999
destinada
sucesor
Windows
98
Windows
NT
4.0
funcionó
esperaba
Microsoft
preparó
versión
Win-
dows
98
conocida
Windows
Millennium
edition
2001
liberó
versión
lige-
ramente
actualizada
Windows
2000
conocida
Windows
XP
versión
duró
mercado
años
reemplazando
versiones
anteriores
Windows
enero
2007
Microsoft
liberó
sucesor
Windows
XP
conocido
Windows
Vista
interfaz
gráfica
Aero
programas
usuario
actualizados
Mi-
crosoft
espera
sustituya
Windows
XP
completo
proceso
durar
década
competidor
importante
mundo
computadoras
personales
UNIX
to-
das
variantes
UNIX
fuerte
servidores
redes
empresariales
pe-
ro
presente
computadoras
escritorio
especial
países
desarrollan
rapidez
India
China
computadoras
basadas
Pentium
Linux
convirtiendo
alternativa
popular
Windows
estudiantes
usuarios
corporativos
agregado
libro
utilizaremos
término
Pentium
denotar
Pentium
II
III
sucesores
tales
Core
Duo
término
x86
utiliza
indicar
rango
completo
CPU
Intel
par-
tiendo
8086
utilizaremos
Pentium
indicar
CPU
www
FreeLibros.mePentium
I.
Admitimos
término
perfecto
disponible
pregunta
genio
mercadotecnia
Intel
desperdició
marca
comercial
Pentium
mitad
mundo
conocía
respetaba
sustituyéndola
términos
Core
duo
personas
comprenden
significan
duo
Pentium
Pen-
tium
dual
core
etc.
difíciles
recordar
FreeBSD
derivado
popular
UNIX
originó
proyecto
BSD
Berkeley
computadoras
modernas
Macintosh
utilizan
versión
modificada
FreeBSD
UNIX
estándar
estacio-
nes
trabajo
operadas
chips
RISC
alto
rendimiento
venden
Hewlett-Packard
Sun
Microsystems
usuarios
UNIX
especial
programadores
experimentados
prefieren
in-
terfaz
línea
comandos
GUI
sistemas
UNIX
presentan
sis-
tema
ventanas
llamado
Window
System
conocido
X11
producido
M.I.T.
sistema
encarga
administración
básica
ventanas
permite
usuarios
crear
eliminar
desplazar
cambiar
tamaño
ventanas
ratón
fre-
cuencia
disponible
GUI
completa
Gnome
KDE
ejecutarse
X11
proporciona
UNIX
apariencia
parecida
Macintosh
Microsoft
Windows
usuarios
UNIX
desean
interesante
desarrollo
empezó
surgir
mediados
década
1980
crecimien-
to
redes
computadoras
personales
ejecutan
sistemas
operativos
red
sistemas
operativos
distribuidos
Tanenbaum
Steen
2007
sistema
operativo
red
usua-
rios
conscientes
existencia
computadoras
iniciar
sesión
equipos
remotos
copiar
archivos
equipo
equipo
ejecuta
sistema
operativo
lo-
cal
usuario
usuarios
local
sistemas
operativos
red
fundamentalmente
distintos
sistemas
operativos
procesador
obvio
necesitan
dispositivo
controlador
interfaz
red
cier-
to
software
nivel
controlarlo
programas
lograr
inicio
sesión
remota
acceso
remoto
archivos
adiciones
cambian
estructura
esencial
sistema
operativo
contraste
sistema
operativo
distribuido
presenta
usuarios
forma
sis-
tema
tradicional
procesador
realidad
compuesto
procesado-
res
usuarios
ejecutando
programas
encuentran
archivos
sistema
operativo
encarga
automática
efi-
ciente
verdaderos
sistemas
operativos
distribuidos
requieren
agregar
código
sistema
operativo
procesador
sistemas
distribuidos
cen-
tralizados
difieren
puntos
críticos
ejemplo
sistemas
distribuidos
permiten
fre-
cuencia
aplicaciones
ejecuten
procesadores
tiempo
requiere
algoritmos
planificación
procesador
complejos
optimizar
cantidad
pa-
ralelismo
retrasos
comunicación
red
implican
algorit-
mos
deban
ejecutarse
información
incompleta
obsoleta
incorrecta
situación
distinta
sistema
procesador
sistema
operativo
informa-
ción
completa
acerca
sistema
18
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
19
1.3
REVISIÓN
HARDW
ARE
COMPUTADORA
sistema
operativo
íntimamente
relacionado
hardware
computadora
ejecuta
Extiende
conjunto
instrucciones
computadora
administra
recursos
trabajar
hardware
respecta
aparece
programador
razón
revisaremos
brevemente
hardware
computadora
encuen-
tra
computadoras
personales
modernas
empezar
entrar
de-
talles
acerca
sistemas
operativos
funcionan
Conceptualmente
computadora
personal
simple
abstraer
modelo
co-
mo
figura
1-6
CPU
memoria
dispositivos
conectados
bus
sistema
comunican
bus
computadoras
personales
moder-
nas
estructura
complicada
intervienen
buses
analizare-
mos
basta
modelo
siguientes
secciones
analizaremos
brevemente
componentes
examinaremos
cuestiones
hardware
relevancia
diseñadores
sistemas
operativos
sobra
resumen
com-
pacto
escrito
libros
acerca
tema
hardware
computadora
organiza-
ción
libros
conocidos
acerca
tema
Tanenbaum
2006
Patterson
Hennessy
2004
Monitor
Teclado
Impresora
USB
Unidad
disco
duro
Dispositivo
controlador
disco
duro
Dispositivo
controlador
USB
Dispositivo
controlador
teclado
Dispositivo
controlador
video
MemoriaCPU
Bus
MMU
Figura
1-6
componentes
computadora
personal
simple
1.3.1
Procesadores
cerebro
computadora
CPU
obtiene
instrucciones
memoria
eje-
cuta
ciclo
básico
CPU
obtener
instrucción
memoria
decodificarla
determinar
tipo
operandos
ejecutarla
obtener
decodificar
ejecutar
instruccio-
nes
subsiguientes
ciclo
repite
programa
termina
forma
ejecutan
programas
www
FreeLibros.meCada
CPU
conjunto
específico
instrucciones
ejecutar
Pentium
ejecutar
programas
SPARC
SPARC
ejecutar
programas
Pentium
Co-
mo
acceso
memoria
obtener
instrucción
palabra
datos
requiere
tiempo
ejecutar
instrucción
CPU
contienen
registros
interior
contener
variables
clave
resultados
temporales
conjunto
instruccio-
nes
generalmente
contiene
instrucciones
cargar
palabra
memoria
registro
alma-
cenar
palabra
registro
memoria
instrucciones
combinan
operandos
registros
memoria
resultado
operación
sumar
palabras
al-
macenar
resultado
registro
memoria
registros
generales
utilizados
contener
variables
resultados
temporales
mayoría
computadoras
registros
especiales
visibles
progra-
mador
contador
programa
program
counter
contiene
dirección
memoria
instrucción
obtener
obtiene
instrucción
conta-
dor
programa
actualiza
apuntar
registro
apuntador
pila
stack
pointer
apunta
superior
pila
stack
actual
memoria
pila
contiene
conjunto
valores
procedimiento
entrado
salido
conjunto
valores
pila
pro-
cedimiento
contiene
parámetros
entrada
variables
locales
variables
temporales
mantienen
registros
registros
PSW
Program
Status
Word
Palabra
programa
registro
contiene
bits
código
condición
asignan
ejecutan
ins-
trucciones
comparación
prioridad
CPU
usuario
kernel
bits
control
programas
usuario
leer
normalmente
PSW
general
só-
escribir
campos
PSW
juega
papel
importante
llamadas
sistema
operaciones
S.
sistema
operativo
registros
CPU
multiplexa
tiempo
sistema
operativo
detiene
frecuencia
programa
ejecución
re)iniciar
detiene
programa
ejecución
sistema
operativo
guardar
regis-
tros
restaurarlos
programa
continúe
ejecución
mejorar
rendimiento
diseñadores
CPUs
abandonaron
tiempo
modelo
obtener
decodificar
ejecutar
instrucción
CPUs
modernas
cuen-
medios
ejecutar
instrucción
tiempo
ejemplo
CPU
po-
dría
unidades
separadas
obtención
decodificación
ejecución
ejecutando
instrucción
decodificando
instrucción
/H110011
ob-
teniendo
instrucción
/H110012
dicha
organización
conoce
canalización
pipeline
figura
1-7(a
ilustra
canalización
etapas
canalizaciones
co-
mún
mayoría
diseños
canalizaciones
obtenido
instrucción
coloca
canalización
ejecutar
instrucción
bifurcación
con-
dicional
tomó
canalizaciones
producen
dolores
cabeza
programadores
compiladores
sistemas
operativos
quedan
descubierto
complejidades
má-
quina
subyacente
avanzada
diseño
canalización
CPU
superescalar
muestra
figura
1-7(b
diseño
unidades
ejecución
ejemplo
arit-
20
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
21
mética
enteros
aritmética
punto
flotante
operaciones
Booleanas
instrucciones
obtienen
decodifican
vacían
búfer
contención
puedan
ejecutarse
unidad
ejecución
encuentre
libre
busca
búfer
contención
instrucción
manejar
saca
instruc-
ción
búfer
ejecuta
consecuencia
diseño
frecuencia
instrucciones
programa
ejecutan
forma
desordenada
responsabilidad
hardware
ase-
gurarse
resultado
producido
hubiera
producido
implementación
se-
cuencial
cantidad
molesta
complejidad
impuesta
sistema
operativo
veremos
mayoría
CPU
excepción
extremadamente
simples
utilizan
sistemas
integrados
modos
kernel
usuario
dijimos
ge-
neral
bit
PSW
controla
operar
kernel
CPU
ejecutar
cual-
quier
instrucción
conjunto
instrucciones
utilizar
características
hardware
sistema
operativo
opera
kernel
acceso
hardware
completo
contraste
programas
usuario
operan
usuario
permite
ejecutar
subconjunto
instrucciones
acceso
subconjunto
característi-
cas
general
permiten
instrucciones
implican
operaciones
protección
memoria
usuario
prohibido
asignar
bit
PSW
entrar
kernel
obtener
servicios
sistema
operativo
programa
usuario
lanzar
llamada
sistema
system
call
atrapa
kernel
invoca
sistema
operativo
instrucción
TRAPcambia
usuario
kernel
inicia
sistema
operativo
comple-
tado
trabajo
control
devuelve
programa
usuario
instrucción
llamada
sistema
capítulo
explicaremos
detalles
acerca
mecanis-
mo
llamadas
sistema
piense
tipo
especial
instrucción
lla-
mada
procedimiento
propiedad
adicional
cambiar
usuario
kernel
indicación
tipografía
utilizaremos
tipo
letra
Helvetica
minúsculas
indicar
llamadas
sistema
texto
libro
muestra
continuación
read
Vale
pena
indicar
computadoras
traps
aparte
instrucción
eje-
cutar
llamada
sistema
mayoría
traps
producidos
hardware
advertir
acerca
situación
excepcional
intento
dividir
subdesbor-
Unidad
obtención
Unidad
obtención
Unidad
obtención
Unidad
deco-
dificación
Unidad
deco-
dificación
Unidad
ejecución
Unidad
deco-
dificación
Búfer
contención
Unidad
ejecución
Unidad
ejecución
Unidad
ejecución
Figura
1-7
Canalización
etapas
CPU
superescalar
www.FreeLibros.medamiento
punto
flotante
caso
sistema
operativo
obtiene
control
deci-
dir
programa
terminarse
error
error
pue-
ignorar
número
provoque
subdesbordamiento
establecerse
programa
anuncia
adelantado
desea
manejar
tipos
condiciones
devolvérsele
control
dejarlo
resolver
problema
Chips
multihilamiento
multinúcleo
ley
Moore
establece
número
transistores
chip
duplica
18
meses
Es-
ta
ley
tipo
ley
física
conservación
momento
ob-
servación
hecha
Gordon
Moore
cofundador
Intel
acerca
velocidad
ingenieros
procesos
compañías
semiconductores
reducir
transistores
ley
Moore
vigente
décadas
espera
siga
me-
década
abundancia
transistores
ocasionando
problema
párrafos
anteriores
vimos
solución
arquitecturas
superescalares
múltiples
unidades
funcionales
medida
incrementa
número
transistores
obvio
colocar
cachés
chip
CPU
ocurriendo
momento
llega
punto
rendimiento
decreciente
paso
obvio
multiplicar
unidades
funcionales
lógica
control
Pentium
chips
CPU
propiedad
conocida
co-
mo
multihilamiento
multithreading)ohiperhilamiento
hyperthreading
nombre
puso
In-
tel
multihilamiento
aproximación
permitir
CPU
contenga
hilos
ejecución
threads
distintos
alterne
escala
tiempo
nanosegundos
hilo
ejecución
proceso
ligero
programa
ejecución
veremos
detalles
capítulo
ejemplo
procesos
necesita
leer
palabra
memoria
requiere
ciclos
reloj
CPU
multihilamiento
cambiar
hilo
multihilamiento
ofrece
paralelismo
proceso
ejecución
tiempo
cambio
hilo
reduce
orden
nanosegundo
multihilamiento
consecuencias
sistema
operativo
hilo
apa-
rece
sistema
operativo
CPU
separada
Considere
sistema
CPU
reales
hilos
sistema
operativo
verá
hubiera
CPU
suficien-
trabajo
mantener
ocupadas
CPU
punto
tiempo
planificar
inadvertida
hilos
CPU
CPU
estaría
completamente
inactiva
elección
eficiente
utilizar
hilo
CPU
sucesor
Pentium
conocido
arquitectura
Core
Core
hiperhilamiento
In-
tel
anunciado
sucesor
Core
nuevamente
allá
multihilamiento
chips
CPU
procesadores
com-
pletos
núcleos
cores
interior
chips
multinúcleo
multicore
figura
1-8
con-
efectivamente
minichips
interior
CPU
independiente
hablaremos
cachés
chip
multinúcleo
requiere
definitiva
sistema
operativo
multiprocesador
22
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
23
1.3.2
Memoria
componente
importante
computadora
memoria
teoría
memo-
ria
extremo
rápida
rápida
velocidad
ejecución
instrucción
ma-
nera
memoria
detenga
CPU
tamaño
económica
tecnología
actualidad
cumple
objetivos
adopta
solución
distinta
sis-
tema
memoria
construido
jerarquía
capas
muestra
figura
1-9
capas
superiores
velocidad
menor
capacidad
costo
bit
capas
inferiores
factores
mil
millones
L2
L2
L2
L2
Caché
L2
Caché
L1
Núcleo
Núcleo
Núcleo
Núcleo
Núcleo
3Núcleo
Núcleo
Núcleo
Figura
1-8
chip
núcleos
quad-core
caché
L2
compartida
chip
núcleos
cachés
L2
separadas
Registros
Caché
Memoria
principal
Cinta
magnética
Disco
magnético
nseg
nseg
10
nseg
10
mseg
100
seg
KB
MB
512-2048
MB
200-1000
GB
400-800
GB
Capacidad
típicaTiempo
acceso
típico
Figura
1-9
común
jerarquía
memoria
números
aproximaciones
capa
superior
consiste
registros
internos
CPU
compuestos
ma-
terial
CPU
ende
rapidez
consecuencia
retraso
hora
utilizarlos
capacidad
almacenamiento
disponible
registros
generalmente
32
/H1100332
bits
CPU
32
bits
64
/H1100364
bits
CPU
64
bits
KB
casos
programas
administrar
registros
decidir
guardar
software
www
FreeLibros.meEl
nivel
memoria
caché
hardware
controla
parcial
memoria
principal
divide
líneas
caché
general
64
bytes
direcciones
63
línea
caché
direcciones
64
127
línea
caché
sucesivamente
líneas
caché
utilizan
frecuencia
mantienen
caché
alta
velocidad
ubicada
den-
tro
cerca
CPU
programa
necesita
leer
palabra
memoria
hardware
caché
comprueba
línea
requiere
caché
cono-
ce
acierto
caché
petición
caché
cumple
envía
petición
memoria
bus
memoria
principal
aciertos
caché
general
requieren
tiempo
aproximado
ciclos
reloj
fallos
caché
memoria
castigo
consi-
derable
tiempo
memoria
caché
limitada
tamaño
alto
costo
máqui-
nas
niveles
caché
lenta
cachés
juega
papel
importante
áreas
ciencias
computacionales
caché
líneas
RAM
recurso
extenso
divi-
dir
piezas
utilizan
frecuencia
invoca
caché
mejorar
rendimiento
sistemas
operativos
utilizan
tiempo
ejemplo
mayoría
sistemas
operativos
mantienen
piezas
archivos
utili-
zan
frecuencia
memoria
principal
evitar
obtenerlos
disco
forma
repetida
similar
resultados
convertir
nombres
rutas
extensas
tales
/home
ast
proyectos
minix3
src
kernel
reloj.c
dirección
disco
archivo
colocar
caché
evitar
bús-
quedas
repetidas
dirección
página
Web
URL
convierte
dirección
red
dirección
IP
resultado
caché
usarlo
futuro
exis-
ten
usos
sistema
caché
surgen
rapidez
preguntas
incluyendo
elemento
caché
línea
caché
elemento
elemento
eliminar
caché
necesita
posición
elemento
recién
desalojado
memoria
tamaño
preguntas
relevantes
situación
caché
líneas
memoria
principal
caché
CPU
general
introduce
elemento
ca-
fallo
caché
línea
caché
utilizar
calcula
generalmente
bits
orden
dirección
memoria
referencia
ejemplo
4096
líneas
caché
64
bytes
direcciones
32
bits
bits
17
utilizarse
pa-
ra
especificar
línea
caché
bits
byte
línea
caché
caso
elemento
quitar
colocan
datos
sis-
temas
vuelve
escribir
línea
caché
memoria
prin-
cipal
modificado
puso
caché
posición
memoria
volver
escribir
determina
únicamente
dirección
cuestión
cachés
idea
útil
CPUs
modernas
caché
L1
nivel
CPU
general
alimenta
instrucciones
decodifica-
das
motor
ejecución
CPU
mayoría
chips
caché
L1
24
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
25
palabras
datos
utilizan
frecuencia
general
cachés
L1
16
KB
caché
conocida
caché
L2
contiene
me-
gabytes
palabras
memoria
utilizadas
recientemente
diferencia
cachés
L1
L2
es-
tá
velocidad
acceso
caché
L1
realiza
retraso
acceso
caché
L2
requiere
retraso
ciclos
reloj
chips
multinúcleo
diseñadores
decidir
colocar
cachés
fi-
gura
1-8(a
caché
L2
compartida
núcleos
metodología
utiliza
chips
multinúcleo
Intel
contraste
figura
1-8(b
núcleo
caché
L2
AMD
utiliza
metodología
estrategia
pros
contras
ejemplo
caché
L2
compar-
tida
Intel
requiere
dispositivo
controlador
caché
complicado
AMD
utiliza
caché
difícil
labor
mantener
cachés
L2
consistentes
memoria
principal
viene
continuación
jerarquía
figura
1-9
caballo
batalla
sistema
memoria
general
memoria
principal
conoce
RAM
Random
Access
Memory
Memoria
Acceso
Aleatorio
usuarios
computadora
antiguos
llaman
memoria
núcleo
computadoras
décadas
1950
1960
utilizaban
pequeños
núcleos
ferrita
magnetizables
memoria
principal
ac-
tualidad
memorias
contienen
cientos
megabytes
gigabytes
tamaño
aumenta
rapidez
peticiones
CPU
puedan
satisfacer
caché
pa-
san
memoria
principal
memoria
principal
computadoras
pequeña
cantidad
memo-
ria
acceso
aleatorio
volátil
diferencia
RAM
memoria
volátil
pierde
conte-
nido
desconecta
energía
ROM
Read
Only
Memory
Memoria
lectura
programa
fábrica
modificarse
rápida
económica
compu-
tadoras
cargador
arranque
bootstrap
loader
utiliza
iniciar
computadora
contenido
ROM
tarjetas
vienen
ROM
manejar
control
dispositivos
nivel
EEPROM
Electrically
Erasable
PROM
PROM
eléctricamente
borrable
memoria
flash
volátiles
contraste
ROM
borrar
volver
escribir
datos
escribir
tipo
memorias
requiere
tiempo
escribir
RAM
utilizan
forma
ROM
ca-
racterística
adicional
corregir
errores
programas
contienen
acción
volver
escribir
datos
campo
trabajo
memoria
flash
utiliza
comúnmente
almacenamiento
dis-
positivos
electrónicos
portátiles
Sirve
película
cámaras
digitales
disco
reproductores
música
portátiles
nombrar
usos
memoria
flash
RAM
disco
velocidad
diferencia
memoria
disco
borra
demasiadas
desgasta
tipo
memoria
CMOS
volátil
computadoras
utilizan
memo-
ria
CMOS
guardar
fecha
hora
actuales
memoria
CMOS
circuito
reloj
in-
crementa
hora
memoria
energizados
pequeña
batería
hora
actualiza
forma
correcta
computadora
encuentre
desconectada
memoria
CMOS
contener
parámetros
configuración
disco
ini-
ciar
sistema
utiliza
CMOS
consume
energía
batería
instalada
www.FreeLibros.mela
fábrica
dura
años
empieza
fallar
parecer
compu-
tadora
tuviera
enfermedad
Alzheimer
olvidando
cosas
sabido
años
des-
disco
duro
iniciar
sistema
1.3.3
Discos
lugar
jerarquía
corresponde
disco
magnético
disco
duro
almacenamiento
disco
órdenes
magnitud
económico
RAM
bit
órde-
nes
magnitud
tamaño
único
problema
tiempo
acceder
forma
aleatoria
datos
cerca
órdenes
magnitud
lento
baja
veloci-
dad
disco
dispositivo
mecánico
muestra
figura
1-10
26
INTRODUCCIÓN
CAPÍTULO
Superficie
Superficie
Superficie
Cabeza
lectura
escritura
superficie
Dirección
movimiento
brazo
Superficie
Superficie
Superficie
Superficie
Superficie
Figura
1-10
Estructura
unidad
disco
disco
consiste
platos
giran
5400
7200
10,800
rpm
brazo
mecáni-
co
punto
giro
colocado
esquina
mueve
platos
similar
brazo
aguja
viejo
tocadiscos
información
escribe
disco
serie
círcu-
concéntricos
posición
dada
brazo
cabezas
leer
re-
gión
anular
conocida
pista
track
conjunto
pistas
posición
dada
brazo
forman
cilindro
cylinder
pista
divide
número
sectores
general
512
bytes
sector
discos
modernos
cilindros
exteriores
contienen
sectores
interiores
desplazar
brazo
cilindro
requiere
milisegundo
desplazar
brazo
cilindro
aleatoriamente
requieren
general
10
milisegundos
dependiendo
uni-
dad
brazo
pista
correcta
unidad
esperar
sector
ne-
cesario
gire
abajo
cabeza
retraso
adicional
10
milisegundos
dependiendo
rpm
unidad
sector
cabeza
lectura
escritura
ocurre
velo-
cidad
50
MB
seg
discos
rendimiento
160
MB
seg
discos
rápidos
computadoras
presentan
esquema
conocido
memoria
virtual
virtual
me-
mory
describiremos
punto
capítulo
esquema
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
27
ejecución
programas
memoria
física
colocarlos
disco
utilizar
me-
moria
principal
tipo
caché
partes
ejecutan
frecuencia
esquema
requiere
reasignación
direcciones
memoria
instante
convertir
dirección
programa
generó
dirección
física
RAM
palabra
asignación
realiza
CPU
conocida
MMU
Memory
Management
Unit
Unidad
Administración
Memoria
muestra
figura
1-6
presencia
caché
MMU
impacto
rendimiento
sis-
tema
multiprogramación
cambiar
programa
conoce
comúnmente
co-
mo
cambio
contexto
context
switch
necesario
vaciar
bloques
modificados
caché
modificar
registros
asignación
MMU
Ambas
operaciones
costosas
programadores
esfuerzan
evitarlas
veremos
conse-
cuencias
tácticas
1.3.4
Cintas
capa
jerarquía
memoria
cinta
magnética
utiliza
fre-
cuencia
respaldo
almacenamiento
disco
contener
conjuntos
datos
extensos
acceder
cinta
colocarse
lector
cinta
ha-
ga
persona
robot
manejo
automatizado
cintas
común
instalaciones
bases
datos
enormes
cinta
embobinarse
llegar
bloque
solicitado
general
proceso
tardar
minutos
ventaja
cinta
extremo
económica
bit
removible
importante
cintas
respaldo
almacenar
sitio
trabajo
puedan
sobrevivir
incen-
dios
inundaciones
terremotos
desastres
jerarquía
memoria
descrito
común
instalaciones
capas
capas
distintas
disco
óptico
medida
desciende
capas
jerarquía
tiempo
acceso
aleatorio
incrementa
for-
ma
dramática
capacidad
aumenta
forma
costo
bit
baja
considerablemente
consecuencia
probable
jerarquías
memoria
utilicen
años
1.3.5
Dispositivos
CPU
memoria
únicos
recursos
sistema
operativo
administrar
dispositivos
interactúan
sistema
operativo
vimos
figu-
ra
1-6
dispositivos
generalmente
constan
partes
dispositivo
controlador
dispositivo
dispositivo
controlador
chip
conjunto
chips
controla
físicamen-
dispositivo
ejemplo
acepta
comandos
sistema
operativo
leer
datos
dis-
positivo
cabo
casos
control
dispositivo
complicado
detallado
trabajo
chip
chips
dispositivo
controlador
presentar
interfaz
simple
sistema
operati-
vo
formas
complejo
ejemplo
controlador
disco
aceptar
comando
leer
sector
11,206
disco
convertir
número
www.FreeLibros.mesector
lineal
cilindro
sector
cabeza
conversión
complicar
cilindros
exteriores
sectores
interiores
sectores
defectuosos
reasignado
Posteriormente
dispositivo
controlador
determinar
cilindro
brazo
darle
secuencia
pulsos
desplazarse
núme-
ro
requerido
cilindros
esperar
sector
apropiado
girado
cabeza
empieza
leer
almacenar
bits
medida
saliendo
unidad
eliminando
preámbulo
calculando
suma
verificación
ensamblar
bits
entrantes
palabras
almacenarlos
memoria
trabajo
dispositivos
contro-
ladores
consisten
pequeñas
computadoras
incrustadas
programan
trabajo
pieza
dispositivo
dispositivos
interfaces
simples
debi-
do
estandarizarlas
necesario
ma-
nera
dispositivo
controlador
disco
IDE
manejar
disco
IDE
ejemplo
IDE
Integrated
Drive
Electronics
significa
Electrónica
unidades
integradas
tipo
estándar
disco
computadoras
interfaz
real
dispositivo
oculta
dispositivo
controlador
sistema
operativo
ve
interfaz
disposi-
tivo
controlador
distinta
interfaz
dispositivo
tipo
dispositivo
controlador
distinto
requiere
software
con-
trolar
software
comunica
dispositivo
controlador
propor-
ciona
comandos
acepta
respuestas
conoce
driver
controlador
fabricante
dispositivos
controladores
suministrar
driver
específico
sistema
operativo
funcionar
escáner
venir
ejemplo
drivers
Windows
2000
Windows
XP
Vista
Linux
utilizar
driver
colocar
sistema
operativo
ejecu-
tarse
kernel
realidad
drivers
ejecutar
kernel
sistemas
actuales
admiten
posibilidad
requiere
capacidad
per-
mitir
driver
espacio
usuario
acceder
dispositivo
controlada
característica
raras
admite
formas
driver
colocar
kernel
volver
enlazar
kernel
driver
reiniciar
sistema
sistemas
UNIX
antiguos
trabajan
crear
entrada
archivo
sistema
operativo
indique
necesita
driver
reinicie
sistema
pa-
ra
momento
arranque
sistema
operativo
busque
drivers
necesarios
cargue
Windows
funciona
forma
sistema
operativo
acepte
dri-
vers
ejecuta
instala
instante
necesidad
reiniciar
forma
solía
rara
volviendo
común
dispositivos
conectables
caliente
hot-
pluggable
dispositivos
USB
IEEE
1394
describen
continuación
ne-
cesitan
drivers
cargan
forma
dinámica
dispositivo
controlador
número
pequeño
registros
sirven
comunicar-
ejemplo
dispositivo
controlador
disco
mínimas
características
registros
especificar
dirección
disco
dirección
memoria
número
sectores
instrucción
lectura
escritura
activar
dispositivo
controlador
driver
recibe
coman-
do
sistema
operativo
traduce
valores
apropiados
escribirlos
re-
gistros
dispositivo
colección
registros
dispositivo
forma
espacio
puertos
tema
regresaremos
capítulo
28
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
29
computadoras
registros
dispositivo
correspondencia
espacio
direcciones
sistema
operativo
direcciones
utilizar
puedan
leer
escribir
palabras
memoria
ordinarias
dichas
computadoras
re-
quieren
instrucciones
especiales
programas
usuario
aislarse
hardware
colocar
direcciones
memoria
alcance
ejemplo
registros
base
límite
computadoras
registros
dispositivo
colocan
espacio
puer-
tos
especial
registro
dirección
puerto
máquinas
instruc-
ciones
INy
OUTespeciales
disponibles
kernel
permiten
drivers
leer
escribir
registros
esquema
elimina
necesidad
instrucciones
especiales
utiliza
par-
espacio
direcciones
esquema
utiliza
espacio
direcciones
requiere
ins-
trucciones
especiales
sistemas
utilizan
ampliamente
operaciones
entrada
salida
maneras
distintas
método
simple
programa
usuario
emite
llamada
sistema
kernel
posteriormente
tra-
duce
llamada
procedimiento
driver
apropiado
driver
inicia
per-
manece
ciclo
estrecho
sondeando
forma
continua
dispositivo
terminado
general
bit
indica
dispositivo
ocupado
terminada
driver
coloca
datos
necesitan
regresa
sistema
operativo
de-
vuelve
control
llamador
método
conoce
espera
ocupada
desven-
taja
mantiene
ocupada
CPU
sondeando
dispositivo
termina
método
consiste
driver
inicie
dispositivo
pida
generar
interrup-
ción
termine
punto
driver
regresa
sistema
operativo
bloquea
progra-
ma
llamador
necesario
busca
trabajo
dispositivo
controlador
detecta
transferencia
genera
interrupción
indicar
operación
completado
interrupciones
importantes
sistemas
operativos
exami-
nar
idea
detalle
figura
1-11(a
proceso
pasos
S.
paso
driver
indica
dispositivo
controlador
disco
escribir
datos
registros
dispositivo
dispositivo
controlador
inicia
dispositivo
terminado
leer
escribir
número
bytes
transferir
alerta
chip
controlador
interrupciones
líneas
bus
paso
controlador
interrupciones
prepara-
do
aceptar
interrupción
ocupado
priori-
dad
utiliza
pin
chip
CPU
informarlo
paso
paso
controlador
interrupciones
coloca
número
dispositivo
bus
CPU
leerlo
sepa
dispositivo
acaba
terminar
dispositivos
funcionando
tiempo
CPU
decidido
tomar
interrupción
contador
programa
PSW
típicamente
agregados
pushed
pila
actual
CPU
cambia
kernel
número
dispositivo
utilizar
índice
memoria
encontrar
dirección
manejador
handler
interrupciones
dispositivo
memoria
conoce
co-
mo
vector
interrupción
manejador
interrupciones
driver
dispositivo
realizando
interrupción
iniciado
quita
contador
programa
PSW
pila
guarda
consultar
dispositivo
mane-
jador
interrupciones
termina
regresa
programa
usuario
ejecutando
previa-
mente
instrucción
ejecutado
pasos
muestran
figura
1-11(b
www
FreeLibros.meEl
tercer
método
operaciones
chip
especial
llamado
DMA
Direct
Memory
Access;Acceso
directo
memoria
controlar
flujo
bits
me-
moria
dispositivo
controlador
intervención
constante
CPU
CPU
configura
chip
DMA
indica
bytes
transferir
direcciones
dispositivo
memoria
involucra-
das
instrucción
deja
haga
trabajo
chip
DMA
termina
genera
interrupción
maneja
descrita
capítulo
discutiremos
detalle
hardware
DMA
general
interrupciones
ocurrir
momentos
inconvenientes
ejemplo
manejador
interrupciones
ejecutando
razón
CPU
for-
ma
deshabilitar
interrupciones
rehabilitarlas
interrupciones
deshabilitadas
dispositivo
termine
continúa
utilizando
señales
interrupción
pe-
ro
CPU
interrumpe
vuelven
habilitar
interrupciones
dispo-
sitivos
terminan
interrupciones
habilitadas
controlador
interrupciones
decide
dejar
pasar
basa
generalmente
prioridades
estáticas
asignadas
ca-
dispositivo
dispositivo
prioridad
gana
1.3.6
Buses
organización
figura
1-6
utilizó
minicomputadoras
años
IBM
PC
original
medida
procesadores
memorias
veloces
habilidad
bus
duda
bus
IBM
PC
manejar
tráfico
forzaba
has-
ta
punto
quiebre
ceder
resultado
agregaron
buses
dis-
positivos
rápidos
tráfico
CPU
memoria
consecuencia
evolución
sistema
Pentium
extenso
actualmente
apariencia
similar
figura
1-12
sistema
buses
caché
local
memoria
PCI
SCSI
USB
IDE
ISA
velocidad
transferencia
función
distintas
sistema
operativo
30
INTRODUCCIÓN
CAPÍTULO
CPU
Controlador
interrup-
ciones
Dispositivo
controlador
disco
Unidad
disco
Instrucción
actual
instrucción
Interrupción
Regreso
Envía
manejador
Manejador
interrupciones
b)(a
42
Figura
1-11
pasos
iniciar
dispositivo
obtener
interrup-
ción
procesamiento
interrupciones
involucra
tomar
interrupción
ejecutar
manejador
interrupciones
regresar
programa
usuario
www
FreeLibros.meSECCIÓN
1.3
REVISIÓN
HARDWARE
COMPUTADORA
31
buses
configuración
administración
buses
principales
bus
ISA
In-
dustry
Standard
Architecture
Arquitectura
estándar
industria
IBM
PC
original
sucesor
bus
PCI
Peripheral
Component
Interconnect
Interconexión
componentes
periféri-
cos
bus
ISA
bus
original
IBM
PC
AT
opera
8.33
MHz
transferir
bytes
velocidad
máxima
16.67
MB
seg
incluye
mantener
compatibilidad
atrás
tarjetas
antiguas
lentas
sistemas
modernos
omiten
frecuen-
cia
obsoleto
bus
PCI
inventado
Intel
sucesor
bus
ISA
operar
66
MHz
transferir
bytes
lograr
velocidad
transferencia
datos
528
MB
seg
mayoría
dispositivos
alta
velocidad
utilizan
bus
PCI
actualidad
computadoras
emplean
procesadores
Intel
bus
PCI
de-
bido
extenso
número
tarjetas
disponibles
bus
computadoras
es-
tán
saliendo
mercado
versión
actualizad
bus
PCI
conocida
PCI
Express
configuración
CPU
comunica
chip
puente
PCI
bus
local
chip
puente
PCI
comunica
memoria
bus
memoria
dedicado
normal-
mente
opera
100
MHz
sistemas
Pentium
caché
nivel
chip
caché
nivel
chip
conectada
CPU
bus
caché
sistema
contiene
buses
especializados
IDE
USB
SCSI
bus
IDE
sirve
conectar
dispositivos
periféricos
tales
discos
CD-ROM
sistema
bus
IDE
Puente
ISA
Módem
Ratón
Puente
PCICPU
Memoria
principal
SCSI
USB
Bus
local
Tarjeta
sonido
Impre-
sora
Ranura
ISA
disponible
Bus
ISA
Disco
IDE
Ranura
PCI
disponible
Tecla-
do
Moni-
tor
Adaptador
gráficos
Caché
nivel
Bus
caché
Bus
memoria
Bus
PCI
Bus
IDE
Bus
SCSI
Bus
USB
Figura
1-12
estructura
sistema
Pentium
extenso
www.FreeLibros.mefruto
interfaz
controladora
disco
PC
AT
estándar
sistemas
basados
Pentium
disco
duro
CD-ROM
USB
Universal
Serial
Bus
Bus
serial
universal
inventó
conectar
computadora
dispositivos
lentos
teclado
ratón
Utiliza
pequeño
conector
cua-
tro
cables
suministran
energía
eléctrica
dispositivos
USB
USB
bus
centralizado
dispositivo
raíz
sondea
dispositivos
milisegundo
tráfico
USB
1.0
podía
manejar
carga
agregada
1.5
MB
seg
reciente
USB
2.0
manejar
60
MB
seg
dispositivos
USB
comparten
dispositivo
controlador
USB
innecesario
instalar
controlador
dispositivo
USB
con-
secuencia
agregarse
dispositivos
USB
computadora
necesidad
reiniciar
bus
SCSI
Small
Computer
System
Interface
Interfaz
sistemas
cómputo
pequeños
bus
alto
rendimiento
diseñado
discos
escáneres
dispositivos
veloces
ne-
cesitan
ancho
banda
considerable
operar
velocidad
transferencia
160
MB
seg
presente
sistemas
Macintosh
inventaron
popular
UNIX
sistemas
basados
Intel
bus
muestra
figura
1-12
conocido
IEEE
1394
conoce
FireWire
hablando
sentido
estricto
FireWire
nombre
utili-
za
Apple
implementación
1394
USB
IEEE
1394
bus
bits
serie
diseñado
transferencias
empaquetadas
100
MB
seg
conveniente
conectar
computadora
cámaras
video
digitales
dispositivos
multimedia
similares
diferencia
USB
IEE
1394
dispositivo
controlador
central
trabajar
entorno
figura
1-12
sistema
operativo
dispositivos
periféricos
conectados
computadora
configurarlos
requeri-
miento
condujo
Intel
Microsoft
diseñar
sistema
PC
conocido
plug
and
play
ba-
sado
concepto
similar
implementó
Apple
Macintosh
plug
and
play
tarjeta
nivel
petición
interrupción
fijo
direcciones
fijas
registros
S.
ejemplo
teclado
interrupción
utilizaba
direcciones
0x60
0x64
dispositivo
controlador
disco
flexible
interrupción
utilizaba
direcciones
0x3F0
0x3F7
impresora
interrupción
utilizaba
direccio-
nes
0x378
0x37A
sucesivamente
problema
usuario
compraba
tarjeta
sonido
tarjeta
módem
utilizaban
interrupción
ejemplo
Instaladas
juntas
serían
incapaces
funcionar
solución
incluir
interruptores
DIP
puentes
jumpers
ca-
tarjeta
indicar
usuario
favor
configurara
seleccionar
nivel
in-
terrupción
direcciones
dispositivos
estuvieran
conflicto
tarjetas
sistema
usuario
adolescentes
dedicaron
vidas
complejidades
hard-
ware
PC
podían
cometer
errores
desgracia
podía
provocó
caos
función
plug
and
play
permitir
sistema
recolecte
automáticamente
informa-
ción
acerca
dispositivos
asigne
niveles
interrupción
direcciones
central
indique
tarjeta
números
trabajo
es-
tá
íntimamente
relacionado
proceso
arranque
computadora
continua-
ción
analizaremos
proceso
trivial
32
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.4
TIPOS
SISTEMAS
OPERATIVOS
33
1.3.7
Arranque
computadora
forma
proceso
arranque
Pentium
Pentium
contiene
tarjeta
madre
motherboard
tarjeta
madre
padre
programa
conocido
BIOS
Basic
Input
Output
System
Sistema
básico
entrada
salida
sistema
BIOS
con-
software
nivel
incluyendo
procedimientos
leer
teclado
escribir
pantalla
operaciones
disco
cosas
contenido
RAM
tipo
flash
volátil
sistema
operativo
actualizarla
encuentran
errores
BIOS
arranca
computadora
BIOS
inicia
ejecución
pruebas
RAM
instalada
teclado
dispositivos
básicos
instalados
respon-
den
forma
correcta
Empieza
explorando
buses
ISA
PCI
detectar
dispositivos
co-
nectados
Comúnmente
dispositivos
heredados
diseñaron
inventar
tecnología
plug
and
play
valores
fijos
niveles
inte-
rrupciones
direcciones
posiblemente
establecen
interruptores
puentes
tarjeta
sistema
operativo
modificar
dispositivos
registran
dispositivos
plug
and
play
dispositivos
presentes
distintos
sistema
inició
configuran
dispositivos
BIOS
determina
dispositivo
arranque
prueba
lista
dispo-
sitivos
almacenada
memoria
CMOS
usuario
cambiar
lista
entra
progra-
ma
configuración
BIOS
justo
iniciar
sistema
general
intento
arrancar
disco
flexible
presente
falla
consulta
unidad
CD-ROM
contiene
CD-ROM
arrancar
disco
flexible
CD-ROM
puedan
iniciarse
sistema
arranca
disco
duro
sector
dis-
positivo
arranque
lee
coloca
memoria
ejecutarse
sector
contiene
programa
general
examina
tabla
particiones
sector
arranque
pa-
ra
determinar
partición
activa
lee
cargador
arranque
secundario
partición
cargador
lee
sistema
operativo
partición
activa
inicia
sistema
operativo
consulta
BIOS
obtener
información
configuración
Pa-
ra
dispositivo
comprueba
driver
correspondiente
pide
usuario
inserte
CD-ROM
contenga
driver
suministrado
fabricante
dispositivo
drivers
dispositivos
sistema
operativo
carga
kernel
inicializa
tablas
crea
procesos
plano
requieran
arranca
programa
inicio
sesión
GUI
1.4
TIPOS
SISTEMAS
OPERATIVOS
sistemas
operativos
funcionamiento
siglo
tiempo
desarrollado
variedad
extensa
conocen
ampliamente
sección
describiremos
libro
regresaremos
distintos
tipos
sistemas
www
FreeLibros.me1.4.1
Sistemas
operativos
mainframe
extremo
superior
sistemas
operativos
mainframes
computadoras
tama-
ño
cuarto
completo
encuentran
principales
centros
datos
corporativos
diferencia
computadoras
personales
capacidad
S.
mainframe
1000
discos
millones
gigabytes
datos
común
computadora
personal
especificaciones
envidia
amigos
propietario
mainframes
volvien-
do
figurar
ámbito
computacional
servidores
Web
alto
rendimiento
servidores
si-
tios
comercio
electrónico
escala
servidores
transacciones
negocio
negocio
sistemas
operativos
mainframes
profundamente
orientados
procesa-
miento
trabajos
requiere
operaciones
S.
general
ofrecen
tipos
servicios
procesamiento
lotes
procesamiento
tran-
sacciones
tiempo
compartido
sistema
procesamiento
lotes
procesa
trabajos
ru-
tina
usuario
interactivo
presente
procesamiento
reclamaciones
compañía
seguros
reporte
ventas
cadena
tiendas
actividades
rea-
lizan
comúnmente
procesamiento
lotes
sistemas
procesamiento
transac-
ciones
manejan
cantidades
pequeñas
peticiones
ejemplo
procesamiento
cheques
banco
reservaciones
aerolínea
unidad
trabajo
pequeña
pe-
ro
sistema
manejar
cientos
miles
sistemas
tiempo
compartido
permi-
ten
usuarios
remotos
ejecuten
trabajos
computadora
tiempo
consultar
base
datos
funciones
íntimamente
relacionadas
sis-
temas
operativos
mainframes
realizan
ejemplo
sistema
operativo
main-
frame
OS/390
descendiente
OS/360
sistemas
operativos
mainframes
reemplazados
gradualmente
variantes
UNIX
Linux
1.4.2
Sistemas
operativos
servidores
nivel
abajo
encuentran
sistemas
operativos
servidores
ejecutan
servidores
computadoras
personales
estaciones
trabajo
main-
frames
servicio
usuarios
red
permiten
compartir
re-
cursos
hardware
software
servidores
proporcionar
servicio
impresión
archivos
Web
proveedores
Internet
operan
equipos
servidores
soporte
clientes
sitios
Web
utilizan
servidores
almacenar
páginas
Web
hacerse
cargo
peticiones
entrantes
sistemas
operativos
servidores
comunes
Solaris
FreeBSD
Linux
Windows
Server
200x
1.4.3
Sistemas
operativos
multiprocesadores
común
obtener
cómputo
ligas
conectar
CPU
sistema
Dependiendo
exactitud
conecten
comparta
sistemas
conocen
computadoras
paralelo
multicomputadoras
multiprocesadores
Necesitan
sistemas
operativos
especiales
variaciones
sistemas
operativos
servidores
características
especiales
comunicación
conectividad
consistencia
34
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.4
TIPOS
SISTEMAS
OPERATIVOS
35
reciente
llegada
chips
multinúcleo
computadoras
personales
sistemas
operativos
equipos
escritorio
portátiles
convencionales
empezando
lidiar
multiprocesadores
pequeña
escala
probable
número
núcleos
aumen-
tiempo
fortuna
conoce
acerca
sistemas
operativos
multiprocesa-
dores
gracias
años
investigación
previa
conocimiento
sistemas
multinúcleo
presentar
dificultades
difícil
aplicaciones
hagan
cómputo
sistemas
operativos
populares
incluyendo
Win-
dows
Linux
ejecutan
multiprocesadores
1.4.4
Sistemas
operativos
computadoras
personales
categoría
sistema
operativo
computadora
personal
sistemas
opera-
tivos
modernos
soportan
multiprogramación
frecuencia
inician
docenas
programas
momento
arrancar
sistema
trabajo
proporcionar
soporte
usuario
utilizan
ampliamente
procesamiento
texto
hojas
cálculo
acceso
Internet
Al-
gunos
ejemplos
comunes
Linux
FreeBSD
Windows
Vista
sistema
operativo
Macintosh
sistemas
operativos
computadora
personal
conocidos
necesario
presentarlos
detalle
personas
siquiera
conscientes
tipos
sistemas
operativos
1.4.5
Sistemas
operativos
computadoras
bolsillo
Continuando
sistemas
pequeños
llegamos
computadoras
bolsillo
handheld
computadora
bolsillo
PDA
Personal
Digital
Assitant
Asistente
personal
di-
gital
computadora
cabe
bolsillos
realiza
pequeña
variedad
funciones
libreta
direcciones
electrónica
bloc
notas
teléfonos
celulares
similares
PDAs
excepción
teclado
pantalla
efecto
PDAs
te-
léfonos
celulares
fusionado
esencia
principales
diferencias
observan
tama-
ño
peso
interfaz
usuario
basan
CPUs
32
bits
protegido
ejecutan
sofisticado
sistema
operativo
sistemas
operativos
operan
dispositivos
bolsillo
sofisti-
cados
habilidad
proporcionar
telefonía
fotografía
digital
funciones
ejecutan
aplicaciones
desarrolladas
terceros
comenzan-
do
asemejarse
sistemas
operativos
computadoras
personales
década
principales
diferencias
dispositivos
bolsillo
PCs
discos
duros
cientos
gigabytes
cambia
rápidamente
sistemas
ope-
rativos
populares
dispositivos
bolsillo
Symbian
Palm
1.4.6
Sistemas
operativos
integrados
sistemas
integrados
embedded
conocen
incrustados
embebidos
operan
computadoras
controlan
dispositivos
consideran
generalmente
computado-
ras
aceptan
software
instalado
usuario
ejemplos
comunes
hornos
www.FreeLibros.mede
microondas
televisiones
autos
grabadores
DVDs
teléfonos
celulares
re-
productores
MP3
propiedad
principal
diferencia
sistemas
integrados
dispositi-
vos
bolsillo
certeza
ejecutar
software
confiable
descargar
aplicaciones
horno
microondas
software
ROM
significa
necesidad
protección
aplicaciones
conlleva
cier-
ta
simplificación
sistemas
QNX
VxWorks
populares
dominio
1.4.7
Sistemas
operativos
nodos
sensores
redes
pequeños
nodos
sensores
implementando
fines
nodos
pequeñas
computadoras
comunican
estación
base
comu-
nicación
inalámbrica
redes
sensores
utilizan
proteger
perímetros
edifi-
cios
resguardar
fronteras
nacionales
detectar
incendios
bosques
medir
temperatura
precipitación
pronóstico
tiempo
deducir
información
acerca
movimiento
ene-
migos
campos
batalla
sensores
pequeñas
computadoras
radios
integrados
alimentadas
baterías
energía
limitada
trabajar
largos
periodos
exterior
desatendidas
fre-
cuencia
condiciones
ambientales
rudas
red
robusta
tolerar
fa-
llas
nodos
individuales
ocurren
frecuencia
medida
baterías
empiezan
agotarse
nodo
sensor
computadora
CPU
RAM
ROM
sen-
sores
ambientales
Ejecuta
sistema
operativo
pequeño
real
general
manejador
eventos
responde
eventos
externos
realiza
mediciones
forma
periódica
base
reloj
interno
sistema
operativo
pequeño
simple
nodos
po-
ca
RAM
tiempo
vida
baterías
cuestión
importante
sistemas
integrados
programas
cargan
adelantado
usuarios
inician
repenti-
namente
programas
descargaron
Internet
simplifica
diseño
forma
considerable
TinyOS
sistema
operativo
conocido
nodo
sensor
1.4.8
Sistemas
operativos
tiempo
real
tipo
sistema
operativo
sistema
tiempo
real
sistemas
caracterizan
tiempo
parámetro
clave
ejemplo
sistemas
control
procesos
industria-
computadoras
tiempo
real
recolectar
datos
acerca
proceso
producción
utilizarlos
controlar
máquinas
fábrica
tiempos
entrega
estrictos
cumplir
ejemplo
auto
desplaza
línea
ensamblaje
lle-
varse
cabo
acciones
determinados
instantes
robot
soldador
realiza
trabajo
soldadura
tiempo
auto
arruinará
acción
ocurrir
excepción
momento
rango
sistema
tiempo
real
duro
sistemas
encuentran
control
procesos
industriales
aeronáutica
milicia
áreas
aplicación
similares
sistemas
proveer
garantías
absolutas
acción
ocurrirá
instante
determinado
36
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
37
tipo
sistema
tiempo
real
sistema
tiempo
real
suave
acepta-
ble
ocasionalmente
fallar
tiempo
predeterminado
sistemas
audio
di-
gital
multimedia
categoría
teléfonos
digitales
ejemplos
sistema
tiempo
real
suave
sistemas
tiempo
real
crucial
cumplir
tiempos
predeterminados
rea-
lizar
acción
sistema
operativo
simplemente
biblioteca
enlazada
programas
aplicación
acoplado
forma
estrecha
protección
partes
sistema
ejemplo
tipo
sistema
tiempo
real
e-Cos
categorías
sistemas
computadoras
bolsillo
sistemas
integrados
sistemas
tiempo
real
traslapan
forma
considerable
aspec-
tos
tiempo
real
suave
sistemas
integrados
tiempo
real
ejecutan
software
colo-
can
diseñadores
sistema
usuarios
agregar
software
facilita
protección
sistemas
computadoras
bolsillo
sistemas
integrados
diseñados
consumidores
sistemas
tiempo
real
adecuados
in-
dustrial
características
común
1.4.9
Sistemas
operativos
tarjetas
inteligentes
sistemas
operativos
pequeños
operan
tarjetas
inteligentes
dispositivos
tamaño
tarjeta
crédito
contienen
chip
CPU
severas
restricciones
procesamiento
memoria
energizan
contactos
lector
insertan
tarjetas
inteligentes
contactos
energizan
inducción
limita
forma
considerable
cosas
sistemas
tipo
rea-
lizar
función
pagos
electrónicos
cabo
funciones
tarjeta
inteligente
sistemas
propietarios
tarjetas
inteligentes
funcionan
Java
significa
ROM
tar-
jeta
inteligente
contiene
intérprete
Máquina
virtual
Java
JVM
applets
Java
pequeños
programas
descargan
tarjeta
interpretados
intérprete
JVM
Al-
gunas
tarjetas
manejar
applets
Java
tiempo
conlleva
multiprogramación
necesidad
planificarlos
administración
recursos
pro-
tección
convierten
problema
applets
presentes
tiempo
sistema
operativo
general
extremo
primitivo
presente
tarjeta
encargado
manejar
cuestiones
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
mayoría
sistemas
operativos
proporcionan
conceptos
básicos
abstracciones
tales
procesos
espacios
direcciones
archivos
base
comprender
funciona-
miento
siguientes
secciones
analizaremos
conceptos
básicos
forma
bre-
ve
introducción
libro
volveremos
analizar
detalle
ilustrar
conceptos
utilizaremos
ejemplos
ge-
neral
basan
UNIX
obstante
general
ejemplos
similares
sistemas
capítulo
11
estudiaremos
Windows
Vista
detalle
www
FreeLibros.me1.5.1
Procesos
concepto
clave
sistemas
operativos
proceso
proceso
esencia
pro-
grama
ejecución
proceso
asociado
espacio
direcciones
lista
ubicacio-
nes
memoria
mínimo
generalmente
valor
máximo
proceso
leer
escribir
información
espacio
direcciones
contiene
programa
ejecuta-
ble
datos
programa
pila
asociado
proceso
conjunto
recur-
sos
comúnmente
incluye
registros
contador
programa
apuntador
pila
lista
archivos
abiertos
alarmas
pendientes
listas
procesos
relacionados
información
necesaria
ejecutar
programa
esencia
proceso
recipiente
guar-
información
necesaria
ejecutar
programa
capítulo
volveremos
analizar
concepto
proceso
detalle
fácil
lector
dé
idea
proceso
pensar
sistema
multiprogramación
usuario
iniciado
programa
edición
video
convertir
video
hora
formato
específico
tardar
horas
des-
pués
irse
navegar
Web
proceso
plano
despierta
forma
periódica
comprobar
mensajes
entrantes
empezado
ejecutarse
procesos
activos
editor
video
navegador
Web
lector
correo
electrónico
tiempo
sistema
operativo
decide
detener
ejecución
proceso
empezar
ejecutar
ejemplo
utilizado
tiempo
correspondía
CPU
proceso
suspende
forma
temporal
ejemplo
reiniciar-
exactamente
detuvo
significa
información
acerca
proceso
guardarse
forma
explícita
sus-
pensión
ejemplo
proceso
archivos
abiertos
leerlos
tiem-
po
archivos
apuntador
asociado
proporciona
posición
actual
número
byte
registro
leer
continuación
proceso
sus-
pende
forma
temporal
apuntadores
guardarse
llamada
readque
ejecute
reiniciar
proceso
lea
datos
apropiados
sistemas
operativos
información
acerca
proceso
contenido
espacio
direcciones
almacena
tabla
sistema
operativo
conocida
tabla
proce-
sos
arreglo
lista
enlazada
estructuras
proceso
encuentre
actualmente
existencia
proceso
suspendido
consiste
espacio
direcciones
conoce
comúnmen-
imagen
núcleo
honor
memorias
núcleo
magnético
utilizadas
antaño
entrada
tabla
procesos
guarda
contenido
registros
elementos
necesarios
reiniciar
proceso
llamadas
sistema
administración
procesos
clave
encargan
crea-
ción
terminación
procesos
Considere
ejemplo
común
proceso
llamado
intérpre-
comandos
shell
lee
comandos
terminal
usuario
acaba
escribir
comando
solicitando
compilación
programa
shell
crear
proceso
ejecutar
compilador
proceso
terminado
compilación
ejecuta
llamada
sistema
terminarse
38
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
39
proceso
crear
procesos
aparte
conocidos
procesos
hijos
procesos
crear
procesos
hijos
llegamos
rápidamente
estructura
árbol
pro-
cesos
figura
1-13
procesos
relacionados
cooperan
trabajo
necesitan
comunicarse
sincronizar
actividades
comunicación
co-
noce
comunicación
procesos
veremos
detalle
capítulo
Figura
1-13
árbol
proceso
proceso
creó
proceso
hijos
C.
pro-
ceso
creó
procesos
hijos
F.
llamadas
sistema
procesos
disponibles
solicitar
memoria
liberar
memoria
utilizar
esperar
termine
proceso
hijo
superponer
programa
distinto
ocasiones
necesidad
transmitir
información
proceso
ejecución
esperando
información
ejemplo
proceso
comunica
computadora
distinta
envía
mensajes
proceso
remoto
red
computadoras
protegerse
posibilidad
pierda
mensaje
contestación
emisor
pue-
solicitar
sistema
operativo
notifique
número
segundos
pa-
ra
retransmitir
mensaje
recibido
señal
aceptación
asignar
temporizador
programa
continuar
realizando
trabajo
transcurrido
número
especificado
segundos
sistema
operativo
envía
se-
ñal
alarma
proceso
señal
provoca
proceso
suspenda
forma
temporal
esté
almacene
registros
pila
empiece
ejecutar
procedimiento
manejador
se-
ñales
especial
ejemplo
retransmitir
mensaje
perdido
termina
manejador
señales
proceso
ejecución
reinicia
encontraba
jus-
to
señal
señales
analogía
software
interrupciones
hardware
generar
variedad
causas
expiración
temporizadores
Mu-
chas
traps
detectadas
hardware
ejecución
instrucción
ilegal
di-
rección
inválida
convierten
señales
envían
proceso
culpable
persona
autorizada
utilizar
sistema
recibe
UID(User
Identification
Identifica-
ción
usuario
administrador
sistema
asigna
proceso
iniciado
UID
persona
inició
proceso
hijo
UID
padre
usuarios
miem-
bros
grupos
GID
Group
Identification
Identificación
grupo
UID
conocida
superusuario
superuser
UNIX
especial
vio-
lar
reglas
protección
instalaciones
extensas
administrador
sistema
conoce
contraseña
requerida
convertirse
superusuario
usuarios
ordi-
www.FreeLibros.menarios
especial
estudiantes
dedican
esfuerzo
considerable
tratar
encontrar
fallas
sistema
permitan
convertirse
superusuario
contraseña
capítulo
estudiaremos
procesos
comunicación
procesos
cuestiones
re-
lacionadas
1.5.2
Espacios
direcciones
computadora
memoria
principal
utiliza
mantener
programas
ejecución
sistema
operativo
simple
programa
memoria
ejecutar
se-
gundo
programa
quitar
colocar
memoria
sistemas
operativos
sofisticados
permiten
colocar
programas
memoria
tiempo
evitar
interfieran
sistema
operativo
necesita
mecanismo
protección
mecanismo
hardware
contro-
sistema
operativo
punto
vista
relaciona
administración
protección
memoria
prin-
cipal
computadora
administración
espacio
direcciones
procesos
relacionada
memoria
actividad
importancia
ge-
neral
proceso
conjunto
direcciones
utilizar
generalmente
valor
máximo
caso
simple
máxima
cantidad
espacio
direc-
ciones
proceso
menor
memoria
principal
forma
proceso
llenar
espacio
direcciones
suficiente
espacio
memoria
principal
con-
necesario
computadoras
direcciones
32
64
bits
ob-
espacio
direcciones
32
264
bytes
respectivamente
ocurre
proceso
tie-
ne
espacio
direcciones
memoria
principal
computadora
desea
usarlo
primeras
computadoras
proceso
simplemente
podía
técnica
llamada
memoria
virtual
sistema
operativo
man-
espacio
direcciones
memoria
principal
disco
moviendo
pedazos
lugar
necesario
esencia
sistema
operativo
crea
abstracción
espacio
direcciones
conjunto
direcciones
referencia
pro-
ceso
espacio
direcciones
desacopla
memoria
física
máquina
pudiendo
ma-
yor
menor
memoria
física
administración
espacios
direcciones
memoria
física
forman
importante
sistema
operativo
capítulo
dedica
tema
1.5.3
Archivos
concepto
clave
sistemas
operativos
sistema
archivos
funciones
principales
sistema
operativo
ocultar
peculiaridades
dis-
cos
dispositivos
presentando
programador
modelo
abstracto
limpio
agrada-
ble
archivos
independientes
dispositivo
duda
requieren
llamadas
sistema
crear
archivos
eliminarlos
leer
escribir
leer
archivo
locali-
40
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
41
zarse
disco
abrirse
leído
información
archivo
cerrarse
proporcionan
llamadas
cosas
proveer
lugar
puedan
mantener
archivos
mayoría
sistemas
operativos
concepto
directorio
agrupar
archivos
ejem-
plo
estudiante
directorio
curso
esté
tomando
progra-
necesarios
curso
directorio
correo
electrónico
página
inicio
World
Wide
Web
necesitan
llamadas
sistema
crear
eliminar
directo-
rios
proporcionan
llamadas
archivo
existente
directorio
eliminar
archivo
directorio
entradas
directorio
archivos
direc-
torios
modelo
surgimiento
jerarquía
sistema
archivos
mues-
tra
figura
1-14
Directorio
raíz
Estudiantes
Docentes
Leo
Prof.
Brown
Archivos
Cursos
CS101
CS105
Artículos
Conce-
siones
SOSP
COST-11
Comités
Prof.
Green
Prof.
WhiteMattyRobbert
Figura
1-14
sistema
archivos
departamento
universitario
jerarquías
procesos
archivos
organizadas
forma
árboles
simili-
tud
detiene
general
jerarquías
procesos
profundas
ni-
veles
inusual
jerarquías
archivos
comúnmente
niveles
profundidad
común
jerarquías
procesos
tengan
tiempo
vida
corto
general
minutos
jerarquía
directorios
exis-
tir
años
propiedad
protección
difieren
procesos
archivos
común
proceso
padre
controlar
acceder
proceso
hijo
siem-
www.FreeLibros.mepre
mecanismos
permitir
archivos
directorios
leídos
grupo
apar-
propietario
especificar
archivo
jerarquía
directorio
proporciona
nombre
ruta
superior
jerarquía
directorios
directorio
raíz
Dichos
nombres
ru-
ta
absolutos
consisten
lista
directorios
recorrerse
directorio
raíz
lle-
gar
archivo
utilizan
barras
diagonales
separar
componentes
figura
1-14
ruta
archivo
CS101
/Docentes
Prof.
Brown
Cursos
CS101
barra
diagonal
in-
dica
ruta
absoluta
empieza
directorio
raíz
observación
adi-
cional
MS-DOS
Windows
utiliza
carácter
barra
diagonal
inversa
separador
carácter
barra
diagonal
ruta
archivo
mostrado
escri-
birse
\Docentes\Prof
Brown\Cursos\CS101
libro
utilizaremos
generalmen-
convención
UNIX
rutas
instante
proceso
directorio
trabajo
actual
buscan
nombres
ruta
empiecen
barra
diagonal
ejemplo
figura
1-14
/Do-
centes
Prof.
Brown
directorio
trabajo
nombre
ruta
Cursos
CS101
produciría
archivo
nombre
ruta
absoluto
proporcionado
procesos
pue-
den
modificar
directorio
trabajo
llamada
sistema
especifique
di-
rectorio
trabajo
leer
escribir
archivo
abrir
momento
comprueban
permisos
permitido
acceso
sistema
devuelve
pequeño
entero
conocido
des-
criptor
archivo
usarlo
siguientes
operaciones
acceso
prohibido
devuel-
ve
código
error
concepto
importante
UNIX
sistema
archivos
montado
compu-
tadoras
personales
unidades
ópticas
insertar
CD-ROMs
DVDs
puertos
USB
conectar
memorias
USB
rea-
lidad
unidades
sólido
computadoras
discos
flexibles
discos
du-
ros
externos
ofrecer
elegante
lidiar
medios
removibles
UNIX
permite
adjuntar
sistema
archivos
CD-ROM
DVD
árbol
principal
Considere
si-
tuación
figura
1-15(a
llamada
mount(montar
sistema
archivos
raíz
disco
duro
sistema
archivos
CD-ROM
separados
relación
sistema
archivo
CD-ROM
utilizar
forma
especificar
nombres
rutas
UNIX
permite
colocar
prefijos
nom-
bres
rutas
basados
nombre
unidad
número
precisamente
tipo
de-
pendencia
dispositivos
sistemas
operativos
eliminar
llamada
sistema
mountpermite
adjuntar
sistema
archivos
CD-ROM
sistema
archivos
raíz
programa
desea
esté
figura
1-15(b
sistema
archivos
CD-ROM
montado
directorio
permite
acceso
archivos
/b
/b
y.
directo-
rio
tuviera
archivos
estarían
accesibles
CD-ROM
estuviera
montado
debi-
do
/b
haría
referencia
directorio
raíz
CD-ROM
acceder
archivos
grave
sistemas
archivos
montan
directo-
rios
vacíos
sistema
contiene
discos
duros
montar
árbol
42
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
43
concepto
importante
UNIX
archivo
especial
archivos
especiales
propor-
cionan
dispositivos
vean
archivos
forma
pue-
leer
escribir
utilizando
llamadas
sistema
utilizan
leer
escribir
archivos
tipos
archivos
especiales
archivos
especiales
bloque
ar-
chivos
especiales
carácter
archivos
especiales
bloque
utilizan
modelar
disposi-
tivos
consisten
colección
bloques
direccionables
azar
tales
discos
abrir
archivo
especial
bloque
leer
bloque
programa
acceder
ma-
nera
directa
cuarto
bloque
dispositivo
importar
estructura
sistema
archivos
contenga
similar
archivos
especiales
carácter
utilizan
modelar
impreso-
ras
módems
dispositivos
aceptan
producen
salida
flujo
caracteres
convención
archivos
especiales
mantienen
directorio
/dev
ejemplo
/dev
lp
impresora
llamó
impresora
línea
característica
veremos
descripción
general
relacionada
pro-
cesos
archivos
canales
canal
pipe
tipo
pseudoarchivo
utilizar-
conectar
procesos
muestra
figura
1-16
procesos
desean
comunicarse
canal
establecerlo
adelantado
proceso
desea
enviar
datos
proceso
escribe
canal
archivo
salida
implementación
canal
parecida
archivo
proceso
leer
da-
tos
canal
archivo
entrada
ende
comunicación
proce-
sos
UNIX
apariencia
similar
operaciones
comunes
lectura
escritura
archivos
única
proceso
descubrir
archi-
vo
salida
escribiendo
realidad
archivo
canal
llamada
sistema
especial
sistemas
archivos
importantes
capítulos
10
11
hablaremos
1.5.4
Entrada
salida
computadoras
dispositivos
físicos
adquirir
entrada
producir
salida
tendría
computadora
usuarios
pudieran
indicarle
ha-
cer
pudieran
obtener
resultados
realizara
trabajo
solicitado
Raíz
CD-ROM
ab
cd
abxy
Figura
1.15
montarse
archivos
CD-ROM
accesibles
montarse
forman
jerarquía
archivos
www.FreeLibros.metipos
dispositivos
entrada
salida
incluyendo
teclados
monitores
impresoras
etcétera
responsabilidad
sistema
operativo
administrar
dispositivos
consecuencia
sistema
operativo
subsistema
administrar
dis-
positivos
S.
software
independiente
dispositivos
aplica
dispositivos
partes
software
drivers
dispositivos
específicas
dispositivos
S.
capítulo
analizaremos
soft-
ware
S.
1.5.5
Protección
computadoras
contienen
cantidades
información
usuarios
comúnmente
de-
proteger
mantener
confidencial
información
incluir
mensajes
co-
rreo
electrónico
planes
negocios
declaraciones
fiscales
responsabilidad
sistema
operativo
administrar
seguridad
sistema
archivos
ejemplo
só-
accesibles
usuarios
autorizados
ejemplo
simple
idea
funcionar
seguridad
con-
sidere
sistema
operativo
UNIX
archivos
UNIX
protegidos
recibe
código
protección
binario
bits
código
protección
consiste
campos
bits
propietario
miembros
grupo
propietario
admi-
nistrador
sistema
divide
usuarios
grupos
campo
tie-
ne
bit
acceso
lectura
bit
acceso
escritura
bit
acceso
ejecución
bits
conocen
bits
rwx
ejemplo
código
protección
rwxr-
x--x
indica
propietario
leer
escribir
ejecutar
archivo
miembros
grupo
leer
ejecutar
escribir
archivo
ejecutarlo
leer
escribir
directorio
indica
permiso
búsqueda
guión
corto
indi-
ca
permiso
correspondiente
protección
archivos
cuestiones
seguridad
proteger
sistema
intrusos
deseados
humanos
humanos
ejemplo
virus
capítulo
analizaremos
cuestiones
seguridad
1.5.6
shell
sistema
operativo
código
cabo
llamadas
sistema
editores
compila-
dores
ensambladores
enlazadores
intérpretes
comandos
definitiva
forman
sis-
tema
operativo
importantes
útiles
riesgo
confundir
cosas
sección
describiremos
brevemente
intérprete
comandos
UNIX
conocido
44
INTRODUCCIÓN
CAPÍTULO
Proceso
Canal
Proceso
AB
Figura
1-16
procesos
conectados
canal
www
FreeLibros.meSECCIÓN
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
45
shell
forma
sistema
operativo
utiliza
frecuencia
características
ende
sirve
ejemplo
forma
utilizar
lla-
madas
sistema
interfaz
principal
usuario
sentado
terminal
sis-
tema
operativo
usuario
esté
usando
interfaz
gráfica
usuario
shells
incluyendo
sh
csh
ksh
bash
soportan
funcionalidad
descrita
deriva
shell
original
sh
usuario
inicia
sesión
inicia
shell
shell
terminal
en-
trada
estándar
salida
estándar
Empieza
escribir
indicador
comandos
prompt
ca-
rácter
signo
dólar
indica
usuario
shell
esperando
aceptar
comando
ejemplo
usuario
escribe
date
shell
crea
proceso
hijo
ejecuta
programa
date
hijo
ejecuta
proce-
so
hijo
shell
espera
termine
hijo
termina
shell
escribe
indicador
leer
línea
entrada
usuario
especificar
salida
estándar
redirigida
archivo
ejemplo
date
archivo
similar
entrada
estándar
redirigir
sort
archivo1
archivo2
invoca
programa
sort
entrada
recibe
archivo1
salida
envía
archivo2
salida
programa
utilizar
entrada
conectan
canal
cat
archivo1
archivo2
archivo3
sort
/dev
lp
invoca
programa
cat
concatenar
archivos
enviar
salida
sort
ordenar
líneas
orden
alfabético
salida
sort
redirige
archivo
/dev
lp
general
impresora
usuario
coloca
signo
comando
shell
espera
complete
proporciona
indicador
comandos
inmediato
consecuencia
cat
archivo1
archivo2
archivo3
sort
/dev
lp
inicia
comando
sort
trabajo
plano
permite
usuario
continuar
trabajo
normal
ordenamiento
cabo
shell
características
interesantes
describiremos
falta
espacio
mayoría
libros
UNIX
des-
criben
shell
grado
ejemplo
Kernighan
Pike
1984
Kochan
Wood
1990
Me-
dinets
1999
Newham
Rosenblatt
1998
Robbins
1999
Actualmente
computadoras
personales
utilizan
GUI
GUI
programa
ejecuta
sistema
operativo
shell
sistemas
Linux
obvio
usuario
selección
GUIs
Gno-
KDE
utiliza
ventana
terminal
X11
Windows
www.FreeLibros.mereemplazar
escritorio
estándar
GUI
indows
Explorer
programa
distinto
modifican
valores
registro
personas
1.5.7
ontogenia
recapitula
filogenia
publicó
libro
Charles
Darwin
titulado
origen
especies
zoó-
logo
alemán
Ernst
Haeckel
declaró
ontogenia
recapitula
filogenia
quiso
desarrollo
embrión
ontogenia
repite
recapitula
evolución
es-
pecies
filogenia
palabras
fertilización
óvulo
humano
pasa
etapas
pez
cerdo
sucesivo
convertirse
bebé
humano
biólogos
modernos
consideran
simplificación
burda
grado
análogo
ocurrido
industria
computadoras
especie
mainfra-
minicomputadora
computadora
personal
computadora
bolsillo
computadora
sistema
integrado
tarjeta
inteligente
etc.
pasar
desarrollo
ancestros
hardware
software
olvidamos
ocurre
negocio
computadoras
campos
controlado
tecnología
razón
antiguos
romanos
tenían
autos
gustara
caminar
de-
bió
sabían
construirlos
computadoras
personales
millones
personas
deseo
reprimido
siglos
poseer
computadora
fabricarlas
costo
económico
olvidamos
afecta
tecnología
visión
sistemas
vale
pena
reflexionar
punto
especial
frecuencia
ocurre
cambio
tecnología
idea
vuel-
obsoleta
desaparece
rapidez
cambio
tecnología
revivirla
especial
cambio
rendimiento
relativo
distintas
partes
sistema
ejemplo
CPUs
volvieron
rápidas
memorias
cachés
tomaron
importancia
agilizar
memoria
lenta
nue-
tecnología
memoria
memorias
rápidas
CPUs
cachés
desaparecerán
tecnología
CPUs
rápidas
memorias
nue-
vo
cachés
volverán
aparecer
biología
extinción
ciencia
computacional
años
consecuencia
transitoriedad
libro
analizaremos
con-
ceptos
obsoletos
ideas
óptimas
tecnología
actual
cambios
tecnología
traer
denominados
conceptos
obsoletos
razón
importante
comprender
concepto
obsoleto
cambios
en-
torno
vuelva
aclarar
punto
consideremos
ejemplo
simple
primeras
computadoras
tenían
conjuntos
instrucciones
cableados
forma
fija
instrucciones
ejecutaban
directa-
mente
hardware
podían
modificar
microprogramación
introdujo
escala
IBM
360
intérprete
subyacente
ejecutaba
instruc-
ciones
hardware
software
ejecución
instrucciones
fijas
volvió
obsoleta
es-
to
flexible
inventaron
computadoras
RISC
microprogramación
46
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.5
CONCEPTOS
SISTEMAS
OPERATIVOS
47
ejecución
interpretada
volvió
obsoleta
ejecución
directa
ve-
loz
viendo
resurgimiento
interpretación
forma
applets
Java
envían
Internet
interpretan
momento
llegada
velocidad
ejecución
crucial
retrasos
red
tienden
dominar
en-
péndulo
oscilado
ejecución
directa
interpretación
volver
oscilar
futuro
Memorias
extensas
examinar
desarrollos
históricos
hardware
forma
afec-
tado
software
repetidas
primeras
mainframes
tenían
memoria
limitada
IBM
7090
7094
completamente
equipada
fungió
rey
montaña
finales
1959
1964
cerca
128
KB
memoria
programaba
lenguaje
en-
samblador
sistema
operativo
escrito
lenguaje
ensamblador
ahorrar
valiosa
memoria
medida
pasaba
tiempo
compiladores
lenguajes
FORTRAN
CO-
BOL
lenguaje
ensamblador
hiciera
obsoleto
liberó
mercado
minicomputadora
comercial
PDP-1
4096
palabras
18
bits
memoria
lenguaje
ensamblador
regreso
sorpresivo
tiempo
microcomputadoras
adquirieron
memoria
lenguajes
alto
nivel
preva-
lecieron
microcomputadoras
llegaron
principios
1980
primeras
tenían
memorias
KB
programación
lenguaje
ensamblador
surgió
muertos
computadoras
embebidas
utilizaban
chips
CPU
microcomputadoras
8080
Z80
posteriormente
8086
programaban
ensamblador
principio
des-
cendientes
computadoras
personales
memoria
programan
/H11001
H11001y
Ja-
lenguajes
alto
nivel
tarjetas
inteligentes
pasando
desarrollo
similar
allá
tamaño
intérprete
Java
ejecutan
programas
Java
forma
interpretativa
compile
Java
lenguaje
máquina
tarjeta
inteligente
Hardware
protección
primeras
mainframes
IBM
7090/7094
tenían
hardware
protección
ejecutaban
programa
programa
errores
podía
acabar
siste-
ma
operativo
máquina
fallara
facilidad
introducción
IBM
360
disponible
forma
primitiva
protección
hardware
máquinas
podían
for-
ma
contener
programas
memoria
tiempo
dejarlos
tomaran
turnos
ejecutarse
multiprogramación
monoprogramación
declaró
obsoleta
apareció
minicomputadora
hardware
protección
multiprogramación
PDP-1
PDP-8
tenían
hardware
protección
momento
PDP-11
dando
entrada
multiprogramación
tiempo
UNIX
www
FreeLibros.meCuando
construyeron
primeras
microcomputadoras
utilizaban
chip
CPU
8080
Intel
protección
hardware
regresamos
vuelta
monoprograma-
ción
Intel
80286
hardware
protección
multiprogramación
fecha
sistemas
integrados
hardware
protección
ejecutan
programa
veamos
sistemas
operativos
principio
primeras
mainframes
tenían
hard-
ware
protección
soporte
multiprogramación
ejecutaban
sistemas
operativos
simples
encargaban
programa
cargado
forma
manual
adqui-
rieron
soporte
hardware
sistema
operativo
manejar
programas
des-
pués
capacidades
completas
tiempo
compartido
aparecieron
minicomputadoras
tenían
hardware
pro-
tección
ejecutaban
programa
cargado
forma
manual
multiprograma-
ción
establecida
mundo
mainframes
Gradualmente
adquirieron
hardware
protección
habilidad
ejecutar
programas
primeras
microcomputadoras
capaces
ejecutar
programa
adquirieron
habilidad
multiprogramación
computadoras
bolsillo
tarjetas
inteligentes
ruta
casos
desarrollo
software
rigió
base
tecnología
ejemplo
primeras
microcomputadoras
tenían
cerca
KB
memoria
tenían
hardware
protección
lenguajes
alto
nivel
multiprogramación
sistema
peque-
ño
pudiera
hacerse
cargo
medida
microcomputadoras
evolucionaron
computado-
ras
personales
modernas
adquirieron
hardware
necesario
software
necesario
manejar
características
avanzadas
probable
desarrollo
continúe
años
campos
rueda
reencarnaciones
industria
computadoras
girar
velocidad
Discos
primeras
mainframes
basadas
cinta
magnética
Leían
progra-
ma
cinta
compilaban
ejecutaban
escribían
resultados
vuelta
cinta
discos
concepto
sistema
archivos
empezó
cambiar
IBM
intro-
dujo
disco
duro
RAMAC
RAndoM
Access
Acceso
aleatorio
1956
Ocupaba
cer-
ca
metros
cuadrados
espacio
piso
podía
almacenar
millones
caracteres
bits
suficiente
fotografía
digital
mediana
resolución
renta
anual
35,000
dólares
ensamblar
suficientes
discos
almacenar
equivalente
rollo
película
extremo
costoso
tiempo
precios
disminuyeron
desarrollaron
sistemas
archivos
primitivos
desarrollos
típicos
época
CDC
6600
introducida
1964
considerada
años
computadora
rápida
mundo
usuarios
podían
crear
archivos
permanentes
darles
nombre
esperar
usuario
hubiera
decidido
datos
nombre
adecuado
archivo
directorio
nivel
tiempo
mainframes
desarrollaron
sistemas
archivos
jerárquicos
com-
plejos
probablemente
culminó
sistema
archivos
MULTICS
48
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
49
minicomputadoras
empezaron
usarse
tiempo
tuvieron
discos
du-
ros
disco
estándar
PDP-11
introdujo
1970
disco
RK05
capaci-
dad
2.5
MB
mitad
RAMAC
IBM
cerca
40
cm
diámetro
cm
altura
principio
directorio
nivel
lle-
garon
microcomputadoras
CP
principio
sistema
operativo
dominante
so-
portaba
directorio
disco
flexible
Memoria
virtual
memoria
virtual
describe
capítulo
proporciona
habilidad
ejecutar
progra-
extensos
memoria
física
computadora
llevando
trayendo
pedazos
RAM
disco
Pasó
desarrollo
similar
apareció
mainframes
des-
pués
avanzó
minis
micros
memoria
virtual
permitió
capacidad
ligar
dinámicamente
programa
biblioteca
tiempo
ejecución
compilarlo
MUL-
TICS
sistema
operativo
capacidad
tiempo
idea
propagó
des-
cendiendo
línea
utiliza
ampliamente
mayoría
sistemas
UNIX
Windows
desarrollos
vemos
ideas
inventaron
contexto
des-
cartaron
cambió
contexto
programación
lenguaje
ensamblador
monoprograma-
ción
directorios
nivel
etc.
reaparecer
contexto
distinto
década
razón
libro
vemos
ideas
algoritmos
pue-
den
parecer
atrasados
comparación
PC
capacidades
gigabytes
pe-
ro
volver
computadoras
incrustadas
tarjetas
inteligentes
1.6
LLAMADAS
SISTEMA
visto
sistemas
operativos
funciones
principales
proveer
abstracciones
programas
usuario
administrar
recursos
computadora
inte-
racción
programas
usuario
sistema
operativo
relaciona
función
ejemplo
crear
escribir
leer
eliminar
archivos
administración
recursos
transparente
usuarios
realiza
automática
ende
in-
terfaz
programas
usuario
sistema
operativo
principalmente
acerca
li-
diar
abstracciones
comprender
realmente
sistemas
operativos
debemos
examinar
interfaz
detalle
llamadas
sistema
disponibles
interfaz
varían
sistema
operativo
conceptos
subyacentes
tienden
similares
vemos
obligados
elegir
opción
generalidades
imprecisas
sistemas
operativos
llamadas
sistema
leer
archivos
sistema
específico
UNIX
llamada
sistema
conocida
readcon
parámetros
especifi-
car
archivo
colocar
datos
indicar
bytes
leer
optado
opción
implica
trabajo
proporciona
visión
de-
tallada
realmente
sistemas
operativos
análisis
refiere
www.FreeLibros.meen
forma
específica
POSIX
Estándar
internacional
9945-1
ende
UNIX
System
BSD
Linux
MINIX
etc.
mayoría
sistemas
operativos
modernos
llama-
das
sistema
realizan
funciones
difieren
detalles
mecánica
relacionada
acción
emitir
llamada
sistema
altamente
dependiente
máquina
expresarse
código
ensamblador
proporciona
biblioteca
procedimientos
llamadas
sistema
programas
general
lenguajes
conveniente
computadora
CPU
ejecutar
instrucción
proceso
ejecutando
programa
usuario
mo-
do
usuario
necesita
servicio
sistema
leer
datos
archivo
ejecutar
instrucción
trap
transferir
control
sistema
operativo
sistema
operativo
ave-
rigua
proceso
llamador
inspecciona
parámetros
lle-
cabo
llamada
sistema
devuelve
control
instrucción
llamada
sistema
sentido
llamada
sistema
tipo
especial
llamada
procedimiento
llamadas
sistema
entran
kernel
llamadas
pro-
cedimientos
entendible
mecanismo
llamadas
sistema
vistazo
rápi-
do
llamada
sistema
read
dijimos
parámetros
especifica
archivo
apunta
búfer
proporciona
número
bytes
leer
llamadas
sistema
invoca
programas
llamada
pro-
cedimiento
biblioteca
nombre
llamada
sistema
read
llamada
des-
programa
apariencia
read(fd
bufer
nbytes
llamada
sistema
procedimiento
biblioteca
devuelve
número
bytes
leen
general
valor
nbytes
pequeño
ejemplo
archivo
leyendo
llamada
sistema
cabo
parámetro
inválido
error
disco
establece
/H110021
número
error
coloca
variable
global
llamada
errno
programas
comprobar
resultados
llamada
sistema
ocurrió
error
llamadas
sistema
llevan
cabo
serie
pasos
concepto
quede
examinar
llamada
readantes
descrita
preparación
llamar
proce-
dimiento
biblioteca
read
realmente
llamada
sistema
read
programa
lla-
mador
mete
parámetros
pila
muestra
pasos
figura
1-17
compiladores
/H11001
H11001meten
parámetros
pila
orden
inverso
razones
históricas
parámetro
printf
cadena
formato
aparezca
superior
pila
parámetros
pasan
valor
parámetro
pasa
referencia
significa
pasa
dirección
búfer
indica
contenido
viene
llamada
procedimien-
to
biblioteca
paso
instrucción
instrucción
llamada
procedimiento
normal
uti-
lizada
llamar
procedimientos
50
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
51
procedimiento
biblioteca
probablemente
escrito
lenguaje
ensamblador
coloca
general
número
llamada
sistema
lugar
sistema
operativo
espera
registro
paso
ejecuta
instrucción
TRAP
cambiar
usuario
kernel
empezar
ejecución
dirección
fija
núcleo
paso
instrucción
TRAPen
realidad
similar
instrucción
llamada
procedimiento
sentido
instrucción
toma
ubicación
distante
dirección
retorno
guarda
pila
posterior
instrucción
TRAP
difiere
instrucción
llamada
procedi-
miento
formas
básicas
lugar
efecto
secundario
cambia
kernel
instrucción
llamada
procedimiento
cambia
lugar
dirección
relativa
absoluta
procedimiento
instrucción
TRAPno
saltar
dirección
arbitraria
Dependiendo
arquitectura
salta
ubicación
fija
campo
bits
instrucción
proporciona
índice
tabla
memoria
contiene
di-
recciones
salto
equivalente
código
kernel
empieza
instrucción
TRAPexamina
número
llama-
sistema
pasa
manejador
correspondiente
llamadas
sistema
gene-
ral
tabla
apuntadores
manejadores
llamadas
sistema
indexados
base
Regresa
procedimiento
llamador
10
78
11
Despa-
chador
Manejador
llamadas
sistema
Dirección
0xFFFFFFFF
Espacio
usuario
Espacio
kernel
sistema
operativo
Procedimiento
biblioteca
read
Programa
usuario
llamando
read
Trap
kernel
Coloca
código
lectura
registro
Incrementa
SP
Llama
read
Mete
fd
pila
Mete
bufer
pila
Mete
nbytes
i\pila
Figura
1-17
11
pasos
llamada
sistema
read(fd
bufer
nbytes
www.FreeLibros.menúmero
llamada
sistema
paso
momento
ejecuta
manejador
llamadas
sistema
paso
8)
manejador
terminado
trabajo
control
regresar
procedimiento
biblioteca
espacio
usuario
instrucción
instrucción
TRAP(paso
procedimiento
regresa
programa
usuario
forma
usual
regresan
llamadas
procedimientos
paso
10
terminar
trabajo
programa
usuario
limpiar
pila
llamada
procedimiento
paso
11
Suponiendo
pila
crece
abajo
co-
mo
comúnmente
caso
código
compilado
incrementa
apuntador
pila
suficiente
eliminar
parámetros
metieron
llamada
ead
programa
libre
quiera
continuación
paso
dijimos
regresar
procedimiento
biblioteca
espacio
usuario
razón
llamada
sistema
bloquear
procedi-
miento
llamador
evitando
continúe
ejemplo
leer
teclado
escrito
procedimiento
llamador
bloqueado
caso
sistema
operativo
buscará
ejecutar
proceso
continuación
adelan-
esté
disponible
entrada
deseada
proceso
recibirá
atención
sistema
lle-
varán
cabo
pasos
11
siguientes
secciones
examinaremos
llamadas
sistema
POSIX
frecuente
forma
específica
procedimientos
biblioteca
realizan
llamadas
sistema
POSIX
100
llamadas
procedimientos
importantes
listan
figura
1-18
agrupadas
conveniencia
categorías
texto
examinaremos
brevemente
llamada
función
grado
servicios
ofrecidos
llamadas
determinan
la-
bor
sistema
operativo
administración
recursos
computadoras
personales
actividad
mínima
compara
equipos
usuarios
servicios
incluyen
acciones
tales
crear
terminar
procesos
crear
eliminar
leer
escribir
archivos
administrar
directorios
operaciones
entrada
salida
margen
vale
pena
mencionar
asignación
llamadas
procedimientos
POSIX
llamadas
sistema
estándar
POSIX
especifica
procedimientos
suministrar
sistema
conforme
estándar
especifica
llama-
das
sistema
llamadas
biblioteca
procedimiento
llevarse
cabo
necesidad
invocar
llamada
sistema
atrapar
kernel
general
realizará
espacio
usuario
cuestión
rendimiento
mayoría
proce-
dimientos
POSIX
invocan
llamadas
sistema
general
procedimiento
asig-
na
directamente
llamada
sistema
casos
especial
procedimientos
requeridos
pequeñas
variaciones
procedimiento
llama-
sistema
maneja
llamada
biblioteca
1.6.1
Llamadas
sistema
administración
procesos
grupo
llamadas
figura
1-18
encarga
administración
procesos
fork
lugar
empezar
análisis
forkes
única
crear
proceso
POSIX
Crea
duplicado
exacto
proceso
original
incluyendo
descriptoresde
archivos
52
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
53
Administración
procesos
DescripciónLlamada
Crea
proceso
hijo
idéntico
padre
Abre
archivo
lectura
escritura
ambas
Crea
directorio
Elimina
directorio
vacío
Crea
entrada
llamada
nombre2
apunta
nombre1
Elimina
entrada
directorio
Monta
sistema
archivos
Desmonta
sistema
archivos
Cambia
directorio
trabajo
Cambia
bits
protección
archivo
Envía
señal
proceso
Obtiene
tiempo
transcurrido
Ene
1970
Cierra
archivo
abierto
Lee
datos
archivo
coloca
búfer
Escribe
datos
búfer
archivo
Desplaza
apuntador
archivo
Obtiene
información
archivo
Espera
hijo
termine
Termina
ejecución
proceso
devuelve
Reemplaza
imagen
núcleo
proceso
pid
fork
pid
waitpid(pid
statloc
opciones
execve(nombre
argv
entornp
exit(estado
Administración
archivos
DescripciónLlamada
fd
open(archivo
close(fd
read(fd
bufer
nbytes
write(fd
bufer
nbytes
posicion
lseek(fd
desplazamiento
dedonde
stat(nombre
buf
Administración
sistema
directorios
archivos
DescripciónLlamada
mkdir(nombre
rmdir(nombre
link(nombre1
nombre2
unlink(nombre
mount(especial
nombre
bandera
umount(especial
Llamadas
DescripciónLlamada
chdir(nombredir
chmod(nombre
kill(pid
senial
segundos
tiempo(&segundos
Figura
1-18
principales
llamadas
sistema
POSIX
código
re-
torno
/H110021
ocurrió
error
códigos
retorno
pid
id
proceso
fd
descriptor
archivo
bytes
posicion
desplazamien-
to
archivo
segundos
tiempo
transcurrido
parámetros
explican
texto
www.FreeLibros.meregistros
fork
proceso
original
copia
padre
hijo
caminos
separados
variables
valores
idénticos
momento
llamada
fork
datos
padre
copian
crear
hijo
posteriores
cambios
afectarán
texto
programa
modificar
compar-
padre
hijo
llamada
forkdevuelve
valor
cero
hijo
identificador
proceso
PID
hijo
padre
PID
devuelto
procesos
proceso
padre
proceso
hijo
mayoría
casos
llamada
forkel
hijo
ejecutar
código
distinto
padre
Considere
caso
shell
lee
comando
terminal
llama
fork
crear
proceso
hijo
espera
hijo
ejecute
comando
lee
comando
hijo
termina
esperar
hijo
termine
padre
ejecuta
llamada
sistema
waitpid
espera
hijo
termine
hijo
Wait-
pidpuede
esperar
hijo
específico
hijo
establece
parámetro
/H110021
waitpidse
completa
dirección
apunta
parámetro
statloc
es-
tablece
salida
hijo
terminación
normal
anormal
valor
exit
proporcionan
opciones
especificadas
tercer
parámetro
considere
forma
shell
utiliza
fork
escribe
comando
shell
crea
proceso
usando
fork
proceso
hijo
ejecutar
comando
usuario
utiliza
llamada
sistema
execve
imagen
núcleo
completa
sus-
tituya
archivo
nombrado
parámetro
realidad
llamada
sistema
exec
procedimientos
biblioteca
llaman
distintos
parámetros
nombres
lige-
ramente
trataremos
llamadas
fueran
llamadas
sistema
fi-
gura
1-19
muestra
shell
simplificado
ilustra
fork
waitpidy
execve
define
TRUE
while
TRUE
repite
forma
indefinida
type_prompt
muestra
indicador
comando
pantalla
read_command(command
parameters
lee
entrada
terminal
if
fork
fork
proceso
hijo
Codigo
padre
waitpid(-1
status
espera
hijo
termine
else
Codigo
hijo
execve(command
parameters
ejecuta
comando
Figura
1-19
versión
simplificada
shell
libro
supondremos
TRUE
define
caso
general
execvetiene
parámetros
nombre
archivo
ejecu-
tar
apuntador
arreglo
argumentos
apuntador
arreglo
entorno
descri-
biremos
parámetros
proporcionan
rutinas
biblioteca
incluyendo
execl
execv
54
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
55
execle
execve
permitir
omisión
parámetros
especificarlos
formas
libro
utilizaremos
nombre
execpara
representar
llamada
sistema
invoca
me-
diante
rutinas
Consideremos
caso
comando
cp
archivo1
archivo2
utiliza
copiar
archivo1
archivo2
shell
bifurcado
fork
proceso
hijo
localiza
ejecuta
archivo
cp
pasa
nombres
archivos
origen
destino
programa
principal
cp
programa
principal
mayoría
programas
contienen
declaración
main(argc
argv
envp
argc
número
elementos
línea
comandos
incluyendo
nom-
bre
programa
ejemplo
argc
parámetro
argv
apuntador
arreglo
elemento
arreglo
apuntador
i-ésima
cadena
línea
comandos
ejemplo
argv[0
apuntaría
cadena
cp
argv[1
apuntaría
cadena
archivo1
argv[2
apuntaría
cadena
archivo2
tercer
parámetro
main
envp
apuntador
entorno
arreglo
cadenas
con-
asignaciones
forma
nombre
valor
utilizan
pasar
información
tipo
terminal
nombre
directorio
inicio
programas
procedimientos
bi-
blioteca
programas
llamar
obtener
variables
entorno
utilizan
personalizar
forma
usuario
desea
tareas
ejemplo
impresora
predeterminada
desea
utilizar
figura
1-19
pasa
entorno
hijo
tercer
parámetro
ex
ecve
cero
execparece
complicado
desanime
sentido
semántico
compleja
to-
das
llamadas
sistema
POSIX
simples
ejemplo
llamada
simple
considere
exit
procesos
utilizar
terminan
ejecución
Tie-
ne
parámetro
exit(0
255
devuelve
padre
statloc
lla-
mada
sistema
waitpid
UNIX
procesos
memoria
dividida
segmentos
segmento
texto
código
programa
segmento
datos(es
variables
segmento
pila
segmento
datos
crece
pila
crece
abajo
muestra
figura
1-20
espacio
libre
direcciones
utilizar
pila
crece
espacio
automática
necesario
expansión
segmento
datos
realiza
ma-
nera
explícita
llamada
sistema
brk
especifica
dirección
terminar
segmento
datos
llamada
definida
estándar
PO-
SIX
recomienda
programadores
utilizar
procedimiento
biblioteca
malloc
asignar
espacio
almacenamiento
forma
dinámica
implementación
subyacente
mallocno
tema
adecuado
estandarización
programadores
utili-
zan
directamente
improbable
alguien
dé
siquiera
brk
POSIX
www
FreeLibros.me1.6.2
Llamadas
sistema
administración
archivos
llamadas
sistema
relacionan
sistema
archivos
sección
analizaremos
llamadas
operan
archivos
individuales
sección
examinaremos
llama-
das
implican
directorios
sistema
archivos
leer
escribir
archivo
abrirse
open
llamada
es-
pecifica
nombre
archivo
abrir
nombre
ruta
absoluto
relati-
vo
directorio
trabajo
código
O_RDONLY
O_WRONLY
O_RDWR
significa
abrir
lectura
escritura
crear
archivo
utiliza
parámetro
O_CREAT
utilizar
descriptor
archivo
devuelto
leer
escribir
terminar
ar-
chivo
cerrar
close
descriptor
archivo
esté
disponible
reutilizarlo
llamada
openposterior
llamadas
frecuente
duda
read
write
Anteriormente
vimos
read
Writetiene
parámetros
mayoría
programas
leen
escriben
archivos
forma
secuencial
cier-
tas
aplicaciones
programas
necesitan
capacidad
acceder
archivo
forma
aleatoria
archivo
apuntador
asociado
indica
posición
actual
archivo
leer
escribir
forma
secuencial
general
apunta
byte
leer
escribir
llamada
lseekcambia
valor
apuntador
posición
siguientes
llamadas
reado
writepuedan
empezar
archivo
Lseektiene
parámetros
descriptor
archivo
posición
archivo
indica
posición
archivo
relativa
inicio
po-
sición
actual
archivo
valor
devuelto
lseekes
posición
absoluta
archi-
vo
bytes
modificar
apuntador
archivo
UNIX
registro
archivo
archivo
regular
especial
direc-
torio
etcétera
tamaño
hora
modificación
información
in-
formación
programas
utilizar
llamada
sistema
stat
parámetro
especifica
archivo
inspeccionar
apuntador
estructura
co-
locar
información
llamadas
sistema
fstat
archivo
abierto
56
INTRODUCCIÓN
CAPÍTULO
Dirección
hex
FFFF
0000
Pila
Datos
Texto
Espacio
libre
Figura
1-20
procesos
segmentos
texto
datos
pila
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
57
1.6.3
Llamadas
sistema
administración
directorios
sección
analizaremos
llamadas
sistema
relacionan
directorios
sistema
archivos
relacionarse
archivo
específico
co-
mo
sección
primeras
llamadas
mkdiry
rmdir
crean
eliminan
directorios
va-
cíos
respectivamente
llamada
link
propósito
permitir
aparezca
archivo
nombres
distintos
directorios
común
permitir
miembros
equipo
programación
compartan
archivo
común
ca-
archivo
directorio
posiblemente
distintos
nombres
compartir
archivo
proporcionar
miembro
equipo
copia
privada
te-
ner
archivo
compartido
significa
cambios
realice
miembro
equipo
visibles
instantánea
miembros
archivo
realizan
co-
pias
archivo
cambios
subsiguientes
realizan
copia
afectan
funciona
link
considere
situación
figura
1-21(a
usua-
rios
ast
jim
directorio
archivos
ast
ejecuta
programa
contenga
llamada
sistema
link(“/usr
jim
memo
/usr
ast
nota
archivo
memo
directorio
jim
introduce
directorio
ast
nombre
nota
/usr
jim
memo
/usr
ast
nota
harán
referencia
archivo
comple-
mentar
lugar
mantengan
directorios
usuarios
/usr
/user
/home
simplemente
decisión
realiza
admi-
nistrador
sistema
local
/usr
ast
/usr
jim
16
81
40
correo
juegos
prueba
31
70
59
38
bin
memo
f.c
prog1
/usr
ast
/usr
jim
16
81
40
70
correo
juegos
prueba
nota
31
70
59
38
bin
memo
f.c
prog1
Figura
1-21
directorios
enlazar
/usr
jim
memo
directorio
ast
directorios
enlace
Entendiendo
funciona
linkprobablemente
aclare
archivo
UNIX
número
único
número-i
identifica
número-i
índice
tabla
no-
dos-i
archivo
indican
propietario
archivo
bloques
disco
etcétera
directorio
simplemente
archivo
contiene
conjunto
pares
núme-
ro-i
nombre
ASCII
primeras
versiones
UNIX
entrada
directorio
16
bytes
bytes
número-i
14
bytes
nombre
necesita
estructura
complica-
soportar
nombres
archivo
extensos
concepto
directorio
conjunto
pares
número-i
nombre
ASCII
figura
1-21
correo
número-i
16
sucesivamente
linkhace
crear
entrada
directorio
nombre
www
FreeLibros.me(posiblemente
usando
número-i
archivo
existente
figura
1-21(b
entra-
das
número-i
70
ende
refieren
archivo
eli-
mina
llamada
sistema
unlink
vigente
eliminan
ambas
UNIX
ve
entradas
archivo
campo
nodo-i
número
entradas
directorio
apuntan
archivo
archivo
elimina
disco
dijimos
llamada
sistema
mountpermite
combinar
sistemas
archivos
situación
común
sistema
archivos
raíz
contenga
versiones
binarias
eje-
cutables
comandos
comunes
archivos
frecuente
disco
duro
usua-
rio
insertar
disco
CD-ROM
archivos
leer
unidad
CD-ROM
ejecutar
llamada
sistema
mount
sistema
archivos
CD-ROM
adjuntar
sistema
archivos
raíz
muestra
figura
1-22
instrucción
común
montaje
mount(“/dev
fd0
/mnt
parámetro
nombre
archivo
especial
bloque
unidad
se-
gundo
parámetro
posición
árbol
montar
tercer
parámetro
indica
sistema
archivo
montar
lectura-escritura
escritura
58
INTRODUCCIÓN
CAPÍTULO
bin
dev
lib
mnt
usr
bin
dev
usrlib
Figura
1-22
Sistema
archivos
montaje
Sistema
archivos
des-
pués
montaje
llamada
mount
acceso
archivo
unidad
uti-
lizar
ruta
directorio
raíz
directorio
trabajo
importar
unidad
encuentre
unidades
cuarta
montar
árbol
llamada
mounthace
integrar
medios
removibles
jerarquía
ar-
chivos
integrada
importar
dispositivo
archivo
ejemplo
in-
volucra
CD-ROMs
montar
porciones
discos
duros
conoce
particiones
dispositivos
menores
forma
dis-
cos
duros
memorias
USB
externos
necesita
sistema
archivos
desmontar
llamada
sistema
umount
1.6.4
Miscelánea
llamadas
sistema
variedad
llamadas
sistema
analizaremos
llamada
chdircambia
directorio
trabajo
actual
llamada
chdir(“/usr
ast
prueba
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
59
instrucción
abrir
archivo
xyz
abrirá
/usr
ast
prueba
xyz
concepto
directorio
trabajo
elimina
necesidad
escribir
nombres
ruta
absolutos
extensos
tiempo
UNIX
archivo
utiliza
protección
incluye
bits
leer-escribir-ejecutar
propietario
grupo
llamada
sistema
chmod
po-
sible
modificar
archivo
ejemplo
archivo
lectura
propietario
podríamos
ejecutar
chmod(“archivo
0644
llamada
sistema
killes
forma
usuarios
procesos
usuario
envían
seña-
proceso
preparado
atrapar
señal
específica
llega
ejecuta
manejador
señales
proceso
preparado
manejar
señal
llegada
ma-
ta
proceso
utilice
nombre
llamada
POSIX
define
procedimientos
tratar
tiempo
ejemplo
time
devuel-
ve
hora
actual
segundos
corresponde
Enero
1970
medianoche
justo
cuan-
do
empezaba
terminaba
computadoras
utilizan
palabras
32
bits
valor
máximo
devolver
time
32
segundos
suponiendo
utiliza
entero
signo
valor
corresponde
136
años
año
2106
sistemas
UNIX
32
bits
volverán
locos
parecido
famoso
problema
año
2000
Y2
hubiera
causado
estragos
computadoras
mundo
2000
masivo
esfuerzo
puso
industria
IT
corregir
problema
actualmente
sistema
UNIX
32
bits
recomienda
intercambie
64
bits
año
2106
1.6.5
API
Win32
Windows
enfocado
principalmente
UNIX
tiempo
vistazo
Windows
Windows
UNIX
difieren
fundamental
respectivos
modelos
programación
programa
UNIX
consiste
código
realiza
cosa
lla-
madas
sistema
servicios
contraste
programa
Windows
general
manejado
eventos
programa
principal
espera
ocurra
evento
llama
procedimiento
manejarlo
eventos
comunes
teclas
oprimen
ratón
desplaza
botón
ratón
oprime
CD-ROM
inserta
manejadores
llaman
procesar
evento
actualizar
pantalla
actualizar
interno
programa
produce
estilo
distinto
programación
UNIX
enfoque
libro
acerca
función
estructura
sistema
operativo
distintos
modelos
programación
preocuparán
Windows
llamadas
sistema
UNIX
rela-
ción
llamadas
sistema
ejemplo
read
procedimientos
biblio-
teca
ejemplo
read
utilizan
invocar
llamadas
sistema
palabras
llamada
sistema
raro
procedimiento
biblioteca
llamado
in-
vocarlo
indica
figura
1-17
POSIX
100
lla-
madas
procedimientos
www
FreeLibros.meCon
Windows
situación
distinta
empezar
llamadas
biblioteca
llamadas
sistema
desacopladas
Microsoft
definido
conjunto
procedi-
mientos
conocidos
API
Win32
Application
Program
Interface
Interfaz
programación
aplicaciones
programadores
utilizar
obtener
servicios
sistema
ope-
rativo
interfaz
proporciona
parcialmente
versiones
Windows
Win-
dows
95
desacoplar
interfaz
llamadas
actuales
sistema
Microsoft
retiene
habilidad
modificar
llamadas
sistema
tiempo
versión
versión
invalidar
programas
existentes
constituye
realmente
Win32
ligeramente
ambiguo
Windows
2000
Windows
XP
Windows
Vista
lla-
madas
disponibles
sección
Win32
significa
interfaz
soportan
versiones
Windows
número
llamadas
API
Win32
miles
invocan
llamadas
sistema
número
considerable
lle-
cabo
completamente
espacio
usuario
consecuencia
Windows
imposible
llamada
sistema
kernel
encarga
simplemente
llama-
biblioteca
espacio
usuario
llamada
sistema
versión
Windows
espacio
usuario
versión
viceversa
hablemos
llamadas
sistema
Windows
libro
utilizaremos
procedimientos
Win32
apropiado
Microsoft
garantiza
estables
tiempo
vale
pena
recordar
verdaderas
llamadas
sistema
traps
kernel
API
Win32
número
llamadas
administrar
ventanas
figuras
geométri-
cas
texto
tipos
letras
barras
desplazamiento
cuadros
diálogo
menús
caracterís-
ticas
GUI
grado
subsistema
gráficos
ejecute
kernel
versiones
Windows
llamadas
sistema
caso
contrario
llamadas
biblioteca
Debemos
hablar
llamadas
li-
bro
realidad
relacionan
función
sistema
operativo
deci-
dido
kernel
llevarlas
cabo
lectores
interesados
API
Win32
consultar
libros
acerca
tema
ejemplo
Hart
1997
Rector
Newcomer
1997
Simon
1997
cuestión
introducir
llamadas
API
Win32
restringiremos
llamadas
corresponden
funcionalidad
llamadas
Unix
listan
figura
1-18
listan
figura
1-23
daremos
repaso
lista
figura
1-23
CreateProcesscrea
proceso
Realiza
trabajo
combinado
forky
execveen
UNIX
parámetros
especifi-
can
propiedades
proceso
recién
creado
Windows
jerarquía
procesos
UNIX
concepto
proceso
padre
proceso
hijo
crea
proceso
creador
creado
iguales
WaitForSingleObjectse
utiliza
esperar
even-
to
esperar
eventos
posibles
parámetro
especifica
proceso
proceso
llamador
espera
proceso
especificado
termine
Exit-
Process
siguientes
llamadas
operan
archivo
funcionalidad
similar
con-
trapartes
UNIX
difieren
parámetros
detalles
archivos
60
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.6
LLAMADAS
SISTEMA
61
abrir
cerrar
leer
escribir
forma
parecida
UNIX
llamadas
Set-
FilePointery
GetFileAttributesExestablecen
posición
archivo
obtienen
atributos
Windows
directorios
crean
eliminan
llamadas
API
CreateDirectory
RemoveDirectory
respectivamente
noción
directorio
actual
es-
tablece
SetCurrentDirectory
hora
actual
adquiere
Ge-
tLocalTime
interfaz
Win32
enlaces
archivos
sistemas
archivos
montados
seguridad
señales
llamadas
correspondientes
UNIX
Win32
número
llamadas
UNIX
especial
administrar
GUI
Windows
Vista
elaborado
sistema
seguridad
soporta
enla-
ces
archivos
vale
pena
observación
acerca
Win32
interfaz
uni-
forme
consistente
principal
culpabilidad
necesidad
compatibilidad
ha-
cia
atrás
interfaz
16
bits
utilizada
Windows
3.x
UNIX
Win32
Descripción
fork
CreateProcess
Crea
proceso
waitpid
WaitForSingleObject
esperar
proceso
termine
execve
CreateProces
fork
execve
exit
ExitProcess
Termina
ejecución
open
CreateFile
Crea
archivo
abre
existente
close
CloseHandle
Cierra
archivo
read
ReadFile
Lee
datos
archivo
write
WriteFile
Escribe
datos
archivo
lseek
SetFilePointer
Desplaza
apuntador
archivo
stat
GetFileAttributesEx
Obtiene
atributos
archivo
mkdir
CreateDirectory
Crea
directorio
rmdir
RemoveDirectory
Elimina
directorio
vacío
link
Win32
soporta
enlaces
unlink
DeleteFile
Destruye
archivo
existente
mount
Win32
soporta
montaje
umount
Win32
soporta
montaje
chdir
SetCurrentDirectory
Cambia
directorio
trabajo
actual
chmod
Win32
soporta
seguridad
NT
kill
Win32
soporta
señales
time
GetLocalTime
Obtiene
hora
actual
Figura
1-23
llamadas
API
Win32
corresponden
llamadas
UNIX
figura
1-18
www
FreeLibros.me1.7
ESTRUCTURA
SISTEMA
OPERATIVO
visto
apariencia
exterior
sistemas
operativos
interfaz
pro-
gramador
tiempo
vistazo
interior
siguientes
secciones
analizaremos
estructuras
distintas
probado
darnos
idea
espectro
posibilidades
exhaustivas
idea
dise-
ños
probado
práctica
diseños
sistemas
monolíticos
sistemas
ca-
pas
microkernels
sistemas
cliente-servidor
máquinas
virtuales
exokernels
1.7.1
Sistemas
monolíticos
diseño
organización
común
sistema
ope-
rativo
ejecuta
programa
kernel
sistema
operativo
escribe
colección
procedimientos
enlazados
programa
binario
ejecutable
extenso
utiliza
técnica
procedimiento
sistema
libertad
llamar
cual-
quier
proporciona
cómputo
útil
necesita
miles
proce-
dimientos
llamar
restricción
frecuencia
produce
sistema
manejable
difícil
comprender
construir
programa
objeto
actual
sistema
operativo
utiliza
diseño
pri-
mero
compilan
procedimientos
individuales
archivos
contienen
procedi-
mientos
vinculan
conjunto
formar
archivo
ejecutable
usando
enlazador
sistema
términos
ocultamiento
información
esencia
procedimientos
visibles
procedimiento
contraste
estructura
contenga
módulos
paquetes
información
oculta
mó-
dulos
puntos
entrada
designados
oficial
llamar
exterior
módulo
sistemas
monolíticos
estructura
solicitar
servicios
llamadas
sistema
proporciona
sistema
operativo
parámetros
colocan
lugar
definido
ejemplo
pila
ejecuta
instrucción
trap
instrucción
cambia
máquina
usuario
kernel
transfiere
control
sistema
operativo
muestra
paso
figura
1-17
sistema
operativo
obtie-
ne
parámetros
determina
llamada
sistema
cabo
indiza
tabla
contiene
ranura
apuntador
procedimiento
cabo
llamada
sistema
paso
figura
1-17
organización
sugiere
estructura
básica
sistema
operativo
programa
principal
invoca
procedimiento
servicio
solicitado
conjunto
procedimientos
servicio
llevan
cabo
llamadas
sistema
conjunto
procedimientos
utilitarios
ayudan
procedimientos
servicio
modelo
llamada
sistema
procedimiento
servicio
encarga
llamada
ejecuta
procedimientos
utilitarios
cosas
necesitan
procedi-
62
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.7
ESTRUCTURA
SISTEMA
OPERATIVO
63
mientos
servicio
obtener
datos
programas
usuario
división
proce-
dimientos
niveles
muestra
figura
1-24
Procedimiento
principal
Procedimientos
servicio
Procedimientos
utilitarios
Figura
1-24
modelo
estructuración
simple
sistema
monolítico
núcleo
sistema
operativo
carga
arrancar
computadora
sis-
temas
operativos
soportan
extensiones
cargar
drivers
dispositivos
sistemas
archivos
componentes
cargan
demanda
1.7.2
Sistemas
capas
generalización
diseño
figura
1-24
organizar
sistema
operativo
jerar-
quía
capas
construida
abajo
sistema
construido
forma
sistema
THE
construido
Technische
Hogeschool
Eindhoven
Holanda
E.
W.
Dijkstra
1968
estudiantes
sistema
THE
sistema
simple
procesamiento
lotes
computadora
holandesa
Electrologica
X8
32
palabras
27
bits
bits
costosos
sistema
capas
muestra
figura
1-25
nivel
encargaba
asignación
procesador
cambiar
proceso
ocurrían
interrupciones
ex-
piraban
temporizadores
nivel
sistema
consistía
procesos
secuenciales
podía
programar
necesidad
preocuparse
procesos
ejecución
procesador
palabras
nivel
proporcionaba
multiprogramación
básica
CPU
capa
encargaba
administración
memoria
Asignaba
espacio
proce-
sos
memoria
principal
tambor
palabras
512
utilizaba
contener
par-
tes
procesos
páginas
espacio
memoria
principal
capa
procesos
tenían
preocuparse
acerca
memoria
tambor
software
capa
encargaba
asegurar
páginas
llevaran
memoria
re-
querían
www
FreeLibros.meLa
capa
encargaba
comunicación
proceso
consola
operador
de-
cir
usuario
capa
proceso
efecto
consola
operador
capa
encargaba
administrar
dispositivos
guardar
búferes
flujos
información
dirigidos
capa
proceso
podía
trabajar
dispositivos
abstractos
excelentes
propiedades
dispositivos
reales
mu-
chas
peculiaridades
capa
encontraban
programas
usuario
tenían
preocuparse
administración
procesos
memoria
consola
S.
proceso
operador
sistema
encontraba
nivel
generalización
concepto
capas
presente
sistema
MULTICS
capa
MULTICS
describió
serie
anillos
concéntricos
interio-
res
tenían
privilegios
exteriores
efecto
viene
pro-
cedimiento
anillo
exterior
quería
llamar
procedimiento
anillo
interior
equivalente
llamada
sistema
instrucción
TRAP
cuyos
parámetros
comprobara
cuidadosamente
fueran
válidos
permitir
continuara
llamada
sistema
operativo
espacio
direcciones
proceso
usuario
MULTICS
hardware
designaran
procedimientos
individuales
realidad
segmentos
memoria
protegidos
lectura
escritura
ejecución
realidad
esquema
capas
THE
ayuda
diseño
partes
sistema
enlazadas
programa
ejecutable
MUL-
TICS
mecanismo
anillos
presente
tiempo
ejecución
hardware
en-
cargaba
implementarlo
ventaja
mecanismo
anillos
extender
fácilmente
estructurar
subsistemas
usuario
ejemplo
profesor
escribir
programa
evaluar
calificar
programas
estudiantes
ejecutando
programa
anillo
programas
estudiantes
ejecutaban
anillo
/H110011
ende
podían
cambiar
calificaciones
1.7.3
Microkernels
diseño
capas
diseñadores
podían
elegir
dibujar
límite
kernel
usua-
rio
Tradicionalmente
capas
iban
kernel
necesario
te-
ner
sentido
kernel
errores
64
INTRODUCCIÓN
CAPÍTULO
Capa
Función
operador
Programas
usuario
Administración
entrada
salida
Comunicación
operador-proceso
Administración
memoria
tambor
Asignación
procesador
multiprogramación
Figura
1-25
Estructura
sistema
operativo
THE
www
FreeLibros.meSECCIÓN
1.7
ESTRUCTURA
SISTEMA
OPERATIVO
65
kernel
paralizar
sistema
inmediato
contraste
procesos
usuario
configurar
tengan
error
fatal
investigadores
estudiado
número
errores
1000
líneas
código
ejemplo
Basilli
Perricone
1984
Ostrand
Weyuker
2002
densidad
errores
depen-
tamaño
módulo
tiempo
vida
cifra
aproximada
sistemas
industriales
formales
errores
mil
líneas
código
significa
proba-
ble
sistema
operativo
monolítico
millones
líneas
código
contenga
cerca
50,000
errores
kernel
fatales
errores
cosas
tales
emitir
mensaje
error
incorrecto
situación
ocurre
ra-
ras
sistemas
operativos
tantos
errores
fabricantes
compu-
tadoras
colocan
botones
reinicio
panel
frontal
fabricantes
televisiones
estéreos
autos
cantidad
software
dispo-
sitivos
idea
básica
diseño
microkernel
lograr
alta
confiabilidad
dividir
sis-
tema
operativo
módulos
pequeños
definidos
microkernel
ejecuta
kernel
resto
ejecuta
procesos
usuario
ordinarios
relati-
vamente
especial
ejecutar
driver
dispositivo
sistema
archivos
proce-
so
usuario
separado
error
procesos
falle
componente
falle
sistema
error
driver
dispositivo
audio
ha-
rá
sonido
confuso
detenga
computadora
fallará
contraste
sistema
monolítico
drivers
kernel
driver
audio
errores
fácilmente
referencia
dirección
memoria
inválida
sistema
alto
ro-
tundo
instante
implementado
desplegado
microkernels
Accetta
colaboradores
1986
Haer-
tig
colaboradores
1997
Heiser
colaboradores
2006
Herder
colaboradores
2006
Hildebrand
1992
Kirsch
colaboradores
2005
Liedtke
1993
1995
1996
Pike
colaboradores
1992
Zuberi
colaboradores
1999
especial
comunes
aplicaciones
tiempo
real
indus-
triales
aeronáuticas
militares
misión
crítica
requerimientos
confiabilidad
altos
microkernels
conocidos
Integrity
K42
L4
PikeOS
QNX
Symbian
MINIX
veremos
forma
generalidades
acerca
MINIX
llevado
idea
modularidad
límite
dividiendo
sistema
operativo
procesos
independientes
usuario
MINIX
sistema
código
fuente
abierto
conformidad
POSIX
disponible
costo
www.minix3.org
Herder
colaboradores
2006a
Herder
colaboradores
2006b
microkernel
MINIX
cerca
3200
líneas
800
líneas
ensamblador
pa-
ra
funciones
nivel
atrapar
interrupciones
conmutar
proceso
código
administra
planifica
procesos
encarga
comunicación
en-
tre
procesos
pasar
mensajes
procesos
ofrece
conjunto
35
lla-
madas
kernel
permitir
resto
sistema
operativo
realice
trabajo
llamadas
realizan
funciones
tales
asociar
drivers
interrupciones
desplazar
datos
espa-
cios
direcciones
instalar
mapas
memoria
procesos
recién
creados
es-
tructura
procesos
MINIX
muestra
figura
1-26
manejadores
llamadas
kernel
etiquetan
Sys
manejador
dispositivo
reloj
www.FreeLibros.meen
kernel
planificador
interactúa
cerca
dispositivos
controladores
ejecutan
procesos
usuario
separados
66
INTRODUCCIÓN
CAPÍTULO
usuario
microkernel
maneja
interrupciones
procesos
planificación
IPC
SysClock
FS
Proc
Reinc
Servidores
Disk
TTY
Netw
Print
Drivers
Shell
Make
Proceso
Programas
usuario
Figura
1-26
Estructura
sistema
MINIX
kernel
sistema
estructura
capas
procesos
ejecutan
mo-
do
usuario
capa
inferior
contiene
drivers
dispositivos
ejecutan
usuario
acceso
físico
espacio
puertos
emitir
comandos
directamente
programar
dispositivo
driver
crea
estructu-
ra
indicarle
valores
escribir
puertos
realiza
llamada
kernel
indicarle
realice
escritura
metodología
permite
kernel
compruebe
dri-
esté
escribiendo
leyendo
autorizado
utilizar
consecuencia
dife-
rencia
diseño
monolítico
driver
audio
defectuoso
escribir
accidentalmente
disco
drivers
capa
usuario
contiene
servidores
realizan
trabajo
sistema
operativo
servidores
archivos
administran
sistema(s
archivos
administrador
procesos
crea
destruye
administra
procesos
sucesivamente
programas
usuario
obtienen
servicios
sistema
operativo
envío
mensajes
cortos
servidores
pidiéndoles
llamadas
sistema
POSIX
ejem-
plo
proceso
necesite
llamada
readenvía
mensaje
servidores
archivos
indicarle
leer
servidor
interesante
servidor
reencarnación
cuyo
trabajo
comprobar
servidores
drivers
funcionando
forma
correcta
caso
detecte
defectuo-
so
reemplaza
automáticamente
intervención
usuario
forma
sistema
auto-
corregible
lograr
alta
confiabilidad
sistema
restricciones
limitan
proceso
dijimos
an-
tes
drivers
utilizar
puertos
autorizados
acceso
llamadas
kernel
controlado
dependiendo
proceso
habilidad
enviar
mensa-
jes
procesos
procesos
otorgar
permiso
limitado
procesos
pa-
ra
kernel
acceda
espacios
direcciones
ejemplo
sistema
archivos
www
FreeLibros.meSECCIÓN
1.7
ESTRUCTURA
SISTEMA
OPERATIVO
67
otorgar
permiso
dispositivo
controlador
disco
dejar
kernel
coloque
blo-
disco
recién
leído
dirección
específica
espacio
direcciones
sistema
archivos
resultado
restricciones
driver
servidor
exacto
trabajo
limita
forma
considerable
daño
ocasionar
componente
defectuoso
idea
relacionada
kernel
mínimo
colocar
mecanismo
pa-
ra
kernel
directiva
aclarar
punto
considere
planifica-
ción
proceso
algoritmo
planificación
relativamente
simple
asignar
prioridad
proceso
kernel
ejecute
proceso
prioridad
ejecuta-
ble
mecanismo
kernel
buscar
proceso
prioridad
ejecutarlo
directiva
asignar
prioridades
procesos
realizarse
procesos
usuario
forma
directiva
mecanismo
desacoplar
kernel
reducir
tamaño
1.7.4
Modelo
cliente-servidor
ligera
variación
idea
microkernel
diferenciar
clases
procesos
servido-
res
proporciona
servicio
clientes
utilizan
servicios
modelo
conoce
cliente-servidor
capa
inferior
microkernel
requerido
esencia
presencia
procesos
cliente
procesos
servidor
comunicación
clientes
servidores
cabo
comúnmente
paso
mensajes
obtener
servicio
proceso
cliente
construye
mensaje
indicando
desea
envía
servicio
apropiado
servicio
trabajo
envía
vuelta
res-
puesta
cliente
servidor
ejecutan
equipo
optimiza-
ciones
concepto
hablando
paso
mensajes
generalización
obvia
idea
clientes
servidores
ejecuten
distintas
computadoras
conectadas
red
área
local
amplia
describe
figura
1-27
clientes
comunican
servidores
envío
mensa-
jes
necesitan
mensajes
manejan
forma
local
equipos
en-
vían
red
servidores
equipo
remoto
cliente
concierne
ocurre
casos
envían
peticiones
regresan
respuestas
ende
modelo
cliente-servidor
abstracción
utilizar
equipo
red
equipos
sistemas
involucran
usuarios
PCs
domésticas
clientes
equipos
operan
servidores
Web
opera
forma
PC
envía
petición
página
Web
servidor
pá-
gina
Web
envía
vuelta
común
modelo
cliente-servidor
red
1.7.5
Máquinas
virtuales
versiones
iniciales
OS/360
sentido
estricto
sistemas
procesamiento
lotes
usuarios
360
querían
capacidad
trabajar
interactiva
terminal
grupos
IBM
decidieron
escribir
siste-
www.FreeLibros.memas
tiempo
compartido
sistema
sistema
tiempo
compartido
oficial
IBM
co-
nocido
TSS/360
liberó
tiempo
lento
sitios
cambiaron
sistema
momento
abandonado
de-
sarrollo
consumido
cerca
50
millones
dólares
Graham
1970
grupo
Scientific
Center
IBM
Cambridge
Massachusetts
produjo
sistema
radicalmente
distinto
IBM
aceptó
eventualmente
producto
descendiente
lineal
sistema
conocido
VM
utiliza
ampliamente
actualidad
mainframes
IBM
zSeries
utilizan
centros
datos
corporativos
extensos
ejemplo
servidores
comer-
cio
electrónico
manejan
cientos
miles
transacciones
utilizan
bases
datos
cuyos
tamaños
llegan
millones
gigabytes
VM/370
sistema
principio
llamó
CP
CMS
posteriormente
cambió
nombre
VM/370
Seawright
MacKinnon
1979
basado
astuta
observación
sistema
tiempo
com-
partido
proporciona
multiprogramación
máquina
extendida
interfaz
conve-
niente
hardware
esencia
VM/370
separar
completo
funciones
corazón
sistema
conoce
monitor
máquina
virtual
ejecuta
hardware
realiza
multiprogramación
proporcionando
máqui-
nas
virtuales
capa
muestra
figura
1-28
diferencia
sistemas
operativos
máquinas
virtuales
máquinas
extendidas
archivos
características
adecuadas
copias
xactas
hardware
incluyendo
kernel/
usuario
interrupciones
má-
quina
real
máquina
virtual
idéntica
hardware
ejecutar
cual-
quier
sistema
operativo
ejecute
directamente
hardware
Distintas
máquinas
virtua-
frecuencia
ejecutar
distintos
sistemas
operativos
sistema
VM/370
original
ejecutaban
OS/360
sistemas
operativos
extensos
procesa-
miento
lotes
procesamiento
transacciones
ejecutaban
sistema
in-
teractivo
usuario
llamado
CMS
Conversational
Monitor
System
Sistema
monitor
conversacional
usuarios
interactivos
tiempo
compartido
popular
programadores
68
INTRODUCCIÓN
CAPÍTULO
Máquina
Máquina
Máquina
Máquina
Cliente
Kernel
Servidor
archivos
Kernel
Servidor
procesos
Kernel
Servidor
terminales
Kernel
Mensaje
cliente
servidor
Red
Figura
1-27
modelo
cliente-servidor
red
www
FreeLibros.meSECCIÓN
1.7
ESTRUCTURA
SISTEMA
OPERATIVO
69
programa
CMS
ejecutaba
llamada
sistema
quedaba
atrapada
sistema
operativo
máquina
virtual
VM/370
forma
ejecuta-
ra
máquina
real
virtual
CMS
emitía
instrucciones
normales
hardware
leer
disco
virtual
necesario
cabo
llamada
instrucciones
atrapadas
VM/370
ejecutaba
simulación
hardware
real
separar
completo
funciones
multiprogramación
pro-
porcionar
máquina
extendida
piezas
podían
simples
flexibles
fáciles
mantener
encarnación
moderna
VM
utiliza
general
ejecutar
sistemas
ope-
rativos
completos
sistemas
simplificados
usuario
CMS
ejemplo
serie
zSeries
capaz
ejecutar
máquinas
virtuales
Linux
sistemas
ope-
rativos
tradicionales
IBM
Redescubrimiento
máquinas
virtuales
IBM
producto
máquina
virtual
disponible
décadas
compañías
Sun
Microsystems
Hewlett-Packard
agregado
reciente-
mente
soporte
máquinas
virtuales
servidores
empresariales
alto
rendimiento
idea
virtualización
ignorado
tiempo
mundo
PC
años
combinado
necesidades
software
tecnolo-
gías
convertirla
tema
moda
hablaremos
necesidades
compañías
ejecutado
tradicionalmen-
servidores
correo
servidores
Web
servidores
FTP
servidores
computadoras
se-
paradas
distintos
sistemas
operativos
Consideran
virtualización
forma
ejecutarlos
máquina
falla
servidor
haga
falle
resto
virtualización
popular
mundo
hospedaje
Web
clientes
hospedaje
Web
ven
obligados
elegir
hospedaje
compartido
ofrece
inicio
sesión
servidor
Web
control
software
servidor
hospedaje
dedicado
ofrece
máquina
flexible
costeable
sitios
Web
pequeños
medianos
compañía
hospedaje
Web
ofrece
renta
máquinas
virtuales
máquina
física
ejecutar
máquinas
virtuales
Instrucciones
Traps
Traps
Llamadas
sistema
370s
virtuales
CMS
CMS
CMS
VM/370
Hardware
370
Figura
1-28
estructura
VM/370
CMS
www.FreeLibros.mecada
máquina
completa
clientes
rentan
máquina
vir-
tual
ejecutar
cualesquier
sistema
operativo
software
deseen
fracción
costo
servidor
dedicado
máquina
física
soporta
máquinas
vir-
tuales
tiempo
virtualización
usuarios
finales
desean
ejecutar
sistemas
operativos
tiempo
Windows
Linux
pa-
quetes
aplicaciones
favoritos
ejecutan
situa-
ción
ilustra
figura
1-29(a
término
monitor
máquinas
virtuales
cambiado
nombre
hipervisor
tipo
años
recientes
70
INTRODUCCIÓN
CAPÍTULO
Hipervisor
tipo
Sistema
operativo
anfitrión
LinuxWindows
Excel
Word
Mplayer
Apollon
Hipervisor
tipo
SO
huésped
Proceso
huésped
SO
Proceso
anfitrión
SO
Figura
1-29
hipervisor
tipo
hipervisor
tipo
pasemos
software
disputa
atractivo
máquinas
virtuales
pro-
blema
implementación
ejecutar
software
máquina
virtual
compu-
tadora
CPU
virtualizable
Popek
Goldberg
1974
síntesis
proble-
ma
sistema
operativo
opera
máquina
virtual
usuario
ejecuta
instrucción
privilegiada
modificar
PSW
operación
esen-
cial
hardware
atrape
monitor
máquina
virtual
instrucción
emular
software
CPUs
Pentium
predecesores
clo-
nes
intentos
ejecutar
instrucciones
privilegiadas
usuario
simplemente
igno-
ran
propiedad
hacía
imposible
máquinas
virtuales
hardware
explica
falta
interés
mundo
PC
intérpretes
Pentium
ejecutaban
Pentium
pérdida
rendimiento
general
5x
10x
útiles
trabajo
serio
situación
cambió
resultado
proyectos
investigación
académicos
década
1990
Disco
Stanford
Bugnion
colaboradores
1997
ocasionaron
sur-
gimiento
productos
comerciales
ejemplo
VMware
Workstation
reviviera
interés
máquinas
virtuales
VMware
Workstation
hipervisor
tipo
muestra
figura
1-29(b
contraste
hipervisores
tipo
ejecutaban
hardware
direc-
to
hipervisores
tipo
ejecutan
programas
aplicación
Windows
Linux
sistema
operativo
conocido
sistema
operativo
anfitrión
inicia
hipervisor
tipo
lee
CD-ROM
instalación
sistema
operativo
huésped
elegido
www
FreeLibros.meSECCIÓN
1.7
ESTRUCTURA
SISTEMA
OPERATIVO
71
instala
disco
virtual
archivo
sistema
archivos
siste-
ma
operativo
anfitrión
arrancar
sistema
operativo
huésped
realiza
hardware
real
general
inicia
procesos
plano
GUI
hipervisores
tra-
ducen
programas
binarios
sistema
operativo
huésped
bloque
bloque
reemplazando
cier-
tas
instrucciones
control
llamadas
hipervisor
bloques
traducidos
ejecutan
colocan
caché
posterior
enfoque
distinto
manejo
instrucciones
control
modificar
sistema
operativo
eliminarlas
enfoque
virtualización
paravir-
tualización
capítulo
hablaremos
virtualización
detalle
máquina
virtual
Java
área
utilizan
máquinas
virtuales
distinta
ejecu-
tar
programas
Java
Sun
Microsystems
inventó
lenguaje
programación
Java
tam-
bién
inventó
máquina
virtual
arquitectura
computadora
llamada
JVM
Java
Virtual
Machine
Máquina
virtual
Java
compilador
Java
produce
código
JVM
típicamente
ejecuta
software
intérprete
JVM
ventaja
mé-
código
JVM
enviar
Internet
computadora
intérprete
JVM
ejecuta
ejemplo
compilador
hubiera
producido
pro-
gramas
binarios
SPARC
Pentium
enviado
ejecutado
par-
facilidad
Sun
producido
compilador
produjera
binarios
SPARC
distribuir
intérprete
SPARC
JVM
arqui-
tectura
simple
interpretar
ventaja
JVM
intérprete
implementa
apropiada
completamente
trivial
comprobar
programas
JVM
entrantes
seguros
ejecutarlos
entorno
protegido
puedan
robar
datos
daño
1.7.6
Exokernels
clonar
máquina
actual
máquinas
virtuales
estrategia
par-
ticionarla
palabras
usuario
proporciona
subconjunto
recursos
máquina
virtual
obtener
bloques
disco
1023
obtener
bloques
disco
1024
2047
sucesivamente
capa
inferior
ejecuta
kernel
programa
llamado
exokernel
En-
gler
colaboradores
1995
trabajo
asignar
recursos
máquinas
virtuales
com-
probar
intentos
utilizarlos
asegurar
máquina
trate
recursos
máquina
virtual
nivel
usuario
ejecutar
sistema
operativo
VM/370
Pentium
8086
virtuales
excepción
restringida
utilizar
recursos
pedido
asignados
ventaja
esquema
exokernel
ahorra
capa
asignación
dise-
ños
máquina
virtual
piensa
disco
bloques
cier-
www.FreeLibros.meto
valor
máximo
monitor
máquina
virtual
mantener
tablas
reasignar
direcciones
disco
recursos
exokernel
reasignación
ne-
cesaria
exokernel
necesita
registro
máquina
virtual
asig-
nado
recurso
método
teniendo
ventaja
separar
multiprogramación
exokernel
código
sistema
operativo
usuario
espacio
usuario
so-
brecarga
exokernel
mantener
máquinas
virtuales
sepa-
radas
1.8
MUNDO
general
sistemas
operativos
extensos
programas
/H11001
H11001
consisten
piezas
escritas
programadores
entorno
utiliza
de-
sarrollar
sistemas
operativos
distinto
acostumbrados
individuos
estudiantes
escribir
pequeños
programas
Java
sección
intento
proporcionar
introducción
mundo
escritura
sistemas
operativos
programadores
inexpertos
Java
1.8.1
lenguaje
guía
resumen
diferencias
clave
en-
tre
Java
Java
basado
similitudes
lenguajes
imperativos
tipos
datos
variables
instrucciones
control
ejemplo
ti-
pos
datos
primitivos
enteros
incluyendo
cortos
largos
caracteres
números
pun-
to
flotante
tipos
datos
compuestos
construir
arreglos
estructuras
uniones
instrucciones
control
similares
Java
incluyendo
instrucciones
if
switch
for
while
funciones
parámetros
iguales
lenguajes
característica
Java
apuntadores
explícitos
apuntador
variable
apunta
contiene
dirección
variable
estructura
datos
Consi-
dere
siguientes
instrucciones
char
c1
c2
c1
c1
c2
declaran
c1
c2
variables
tipo
carácter
variable
apunta
de-
cir
contiene
dirección
carácter
asignación
almacena
código
ASCII
carácter
variable
c1
asigna
dirección
c1
variable
apuntador
p.
asigna
contenido
variable
apunta
variable
c2
ejecutar
instrucciones
c2
contiene
código
ASCII
teoría
apuntado-
res
tipificados
asignar
dirección
número
punto
flotante
72
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.8
MUNDO
73
apuntador
tipo
carácter
práctica
compiladores
aceptan
dichas
asignaciones
advertencia
apuntadores
construcción
potente
tam-
bién
fuente
errores
utilizan
precaución
cosas
cadenas
integradas
hilos
paquetes
clases
objetos
seguri-
dad
tipos
recolección
basura
obstáculo
sistemas
operativos
almacenamiento
estático
programador
asigna
libera
explícita
general
funciones
biblioteca
malloc
free
propiedad
control
programador
memoria
apuntadores
explícitos
lenguaje
atractivo
escribir
sistemas
operativos
esencia
sistemas
operativos
sistemas
tiem-
po
real
punto
propósito
general
ocurre
interrupción
sis-
tema
operativo
microsegundos
acción
contrario
perder
información
crítica
intolerable
recolector
basura
ac-
ción
momento
arbitrario
1.8.2
Archivos
encabezado
general
proyecto
sistema
operativo
consiste
número
directorios
contiene
archivos
.c
contienen
código
sistema
jun-
to
archivos
encabezado
.h
contienen
declaraciones
definiciones
utilizadas
archivos
código
archivos
encabezado
incluir
macros
simples
tales
define
TAM_BUFER
4096
permiten
programador
nombre
constantes
TAM_BUFER
utilice
código
reemplace
compilación
número
4096
práctica
programación
nombrar
constante
/H110021
nombran
macros
parámetros
tales
define
max(a
programador
escribir
max(j
k+1
obtener
k+1
almacenar
/H110011
i.
encabezados
contener
compilación
condicional
ejemplo
ifdef
PENTIUM
intel_int_ack
endif
compila
llamada
función
intel_int_ack
macro
PENTIUM
definida
caso
contrario
compilación
condicional
utiliza
frecuencia
www.FreeLibros.meaislar
código
dependiente
arquitectura
código
inserte
compile
sistema
Pentium
inserte
código
sistema
compile
SPARC
sucesivamente
archivo
.c
incluir
físicamente
cero
archivos
encabezado
directiva
include
archivos
encabezado
comunes
archivo
.c
almacenan
directorio
central
1.8.3
Proyectos
programación
extensos
generar
sistema
operativo
compilador
compila
archivo
.c
archivo
có-
digo
objeto
archivos
sufijo
.o
contienen
instrucciones
binarias
equipo
destino
Posteriormente
CPU
ejecutará
directamente
código
byte
Java
mundo
C.
compilador
conoce
preprocesador
C.
medida
lee
archivo
.c
llega
directiva
include
obtiene
archivo
encabe-
zado
cuyo
nombre
contiene
procesa
expandiendo
macros
manejando
compilación
con-
dicional
cosas
pasando
resultados
compilador
incluyeran
físicamente
sistemas
operativos
extensos
común
tengan
cerca
millo-
nes
líneas
código
imposible
recompilar
modifica
archivo
cambiar
archivo
encabezado
clave
incluye
miles
archivos
volver
compilar
archivos
archivos
código
objeto
depende
archivos
encabezado
manejar
ayuda
fortuna
computadoras
precisamente
tipo
cosas
sis-
temas
UNIX
programa
llamado
make
numerosas
variantes
tales
gmake
pmake
etcétera
lee
Makefile
archivo
indica
archivos
dependientes
archivos
make
archivos
código
objeto
necesitan
generar
archi-
vo
binario
sistema
operativo
necesita
momento
comprueba
archivos
depende
código
encabezados
modificado
des-
pués
creó
archivo
código
objeto
archivo
código
ob-
jeto
volver
compilar
make
determinado
archivos
.c
volver
compilar
invoca
compilador
recompile
reduce
nú-
mero
compilaciones
mínimo
proyectos
extensos
creación
Makefile
propen-
sa
errores
herramientas
automática
listos
archivos
.o
pasan
programa
conocido
enlaza-
dor
combinarlos
archivo
binario
ejecutable
función
biblioteca
llamada
incluye
punto
resuelven
referencias
funciones
reasignan
direcciones
máquina
necesario
enlazador
termina
resul-
tado
programa
ejecutable
tradición
llama
a.out
sistemas
UNIX
diver-
sos
componentes
proceso
ilustran
figura
1-30
programa
archivos
archivos
encabezado
hablado
desarrollo
sistemas
operativos
aplica
desarrollo
programa
extenso
74
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.8
MUNDO
75
1.8.4
modelo
tiempo
ejecución
enlazado
archivo
binario
sistema
operativo
computadora
reini-
ciarse
sistema
operativo
ejecución
cargar
piezas
forma
dinámi-
ca
hayan
incluido
estática
binario
drivers
dispositivos
sistemas
archivos
tiempo
ejecución
sistema
operativo
consistir
seg-
mentos
texto
código
programa
datos
pila
general
segmento
texto
inmutable
cambia
ejecución
segmento
datos
empieza
ta-
maño
inicializa
valores
cambiar
crecer
necesite
princi-
pio
pila
vacía
crece
reduce
medida
llamadas
funciones
regresa
segmento
texto
coloca
cerca
memoria
segmento
datos
justo
habilidad
crecer
segmento
pi-
dirección
virtual
superior
habilidad
crecer
abajo
distintos
siste-
trabajan
casos
código
sistema
operativo
ejecutado
directamente
hardware
intérprete
compilación
justo-a-tiempo
caso
Java
defs.h
mac.h
main.c
ayuda.c
otro.c
Preprocesador
Compilador
main.o
ayuda.o
otro.o
enlazadorlibc.a
a.out
Programa
binario
ejecutable
Figura
1-30
proceso
compilar
archivos
encabezado
crear
ar-
chivo
ejecutable
www
FreeLibros.me1.9
INVESTIGACIÓN
ACERCA
SISTEMAS
OPERATIVOS
ciencia
computacional
campo
avanza
rapidez
difícil
predecir
investigadores
universidades
laboratorios
investigación
industrial
desarrollan-
do
constantemente
ideas
convier-
ten
piedra
angular
futuros
productos
impacto
masivo
industria
usuarios
ideas
éxito
fácil
retrospección
tiempo
real
Separar
trigo
paja
especial
difícil
requieren
20
30
años
idea
haga
impacto
ejemplo
presidente
Eisenhower
estableció
Agencia
Proyectos
Avanzados
Investigación
ARPA
Departamento
Defensa
1958
trataba
evitar
Ejército
predominara
Marina
Fuerza
Aérea
relación
presupuesto
investigación
tratando
inventar
Internet
cosas
ARPA
patrocinar
in-
vestigación
universitaria
oscuro
tema
conmutación
paquetes
con-
dujo
red
experimental
conmutación
paquetes
ARPANET
Entró
funcionamiento
1969
tiempo
redes
investigación
patrocinadas
ARPAestaban
conecta-
das
ARPANET
nació
Internet
utilizada
felizmente
investigado-
res
académicos
enviarse
correo
electrónico
20
años
principios
década
1990
Tim
Berners-Lee
inventó
World
Wide
Web
laboratorio
investigación
CERN
Ginebra
Marc
Andreesen
escribió
código
navegador
gráfico
red
Universidad
Illinois
Internet
llena
adolescentes
conversando
Pro-
bablemente
presidente
Eisenhower
esté
revolcándose
tumba
investigación
sistemas
operativos
producido
cambios
dramáticos
sistemas
prácticos
vimos
sistemas
computacionales
comerciales
to-
sistemas
procesamiento
lotes
M.I.T.
inventó
tiempo
compartido
interac-
tivo
principios
década
1960
computadoras
basadas
texto
Doug
Engelbart
inventó
ratón
interfaz
gráfica
usuario
Stanford
Research
Institute
finales
década
1960
vendrá
continuación
sección
secciones
equivalentes
resto
libro
daremos
vistazo
investigación
sistemas
operativos
llevado
cabo
du-
rante
10
años
idea
horizonte
definitiva
introducción
exhaustiva
basa
artículos
pu-
blicado
principales
diarios
investigación
conferencias
ideas
so-
brevivido
proceso
revisión
personal
riguroso
publicarse
mayoría
artículos
citados
secciones
investigación
publicados
ACM
IEEE
Computer
Society
USENIX
disponibles
Internet
miembros
estu-
diantes
organizaciones
obtener
información
acerca
organizaciones
bibliotecas
digitales
consulte
siguientes
sitios
Web
ACM
http://www.acm.org
IEEE
Computer
Society
http://www.computer.org
USENIX
http://www.usenix.org
76
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meSECCIÓN
1.10
DESCRIPCIÓN
GENERAL
RESTO
LIBRO
77
investigadores
sistemas
operativos
consideran
sistemas
operativos
ac-
tuales
masivos
inflexibles
confiables
inseguros
cargados
errores
eviden-
temente
divulgamos
nombres
dañar
aludidos
consecuencia
investigación
acerca
construir
mejores
sistemas
operativos
fechas
recientes
publicado
trabajo
acerca
sistemas
operativos
Krieger
co-
laboradores
2006
estructura
sistema
operativo
Fassino
colaboradores
2002
rectitud
sistema
operativo
Elphinstone
colaboradores
2007
Kumar
Li
2002
Yang
colaborado-
res
2006
confiabilidad
sistema
operativo
Swift
colaboradores
2006
LeVasseur
co-
laboradores
2004
máquinas
virtuales
Barham
colaboradores
2003
Garfinkel
colaborado-
res
2003
King
colaboradores
2003
Whitaker
colaboradores
2002
virus
gusanos
Costa
colaboradores
2005
Portokalidis
colaboradores
2006
Tucek
colaboradores
2007
Vrable
colaboradores
2005
errores
depuración
Chou
colaboradores
2001
King
colaboradores
2005
hiperhilamiento
multihilamiento
Fedorova
2005
Bulpin
Pratt
2005
comportamiento
usuarios
Yu
colaboradores
2006
temas
1.10
DESCRIPCIÓN
GENERAL
RESTO
LIBRO
completado
introducción
visión
sistema
operativo
tiempo
entrar
detalles
dijimos
punto
vista
programador
propósito
principal
sistema
operativo
proveer
abstracciones
clave
importan-
tes
procesos
hilos
espacios
direcciones
archivos
acorde
siguien-
tes
capítulos
dedicados
temas
cruciales
capítulo
acerca
procesos
hilos
Describe
propiedades
comunican
proporciona
ejemplos
detallados
acerca
forma
fun-
ciona
comunicación
procesos
evitar
obstáculos
capítulo
estudiaremos
espacios
direcciones
administración
adjunta
me-
moria
detalle
Examinaremos
importante
tema
memoria
virtual
concep-
tos
estrechamente
relacionados
paginación
segmentación
capítulo
llegaremos
importantísimo
tema
sistemas
archivos
Has-
ta
punto
usuario
ve
sistema
archivos
Analizaremos
inter-
faz
sistema
archivos
implementación
capítulo
cubre
tema
operaciones
entrada
salida
Hablaremos
conceptos
independencia
dispositivos
dependencia
dispositivos
Utilizaremos
ejemplos
dispositivos
importantes
discos
teclados
pantallas
capítulo
acerca
interbloqueos
Anteriormente
capítulo
mostramos
forma
interbloqueos
Hablaremos
formas
prevenirlos
evitarlos
punto
habremos
completado
estudio
acerca
principios
básicos
sis-
temas
operativos
CPU
especial
acerca
te-
avanzados
capítulo
examinaremos
sistemas
multimedia
www.FreeLibros.mepropiedades
requerimientos
distintos
sistemas
operativos
convencionales
ele-
mentos
planificación
tareas
sistema
archivos
ven
afectados
naturaleza
multimedia
tema
avanzado
sistemas
múltiples
procesadores
incluyendo
multiprocesadores
computadoras
paralelo
sistemas
distribuidos
Cubriremos
te-
capítulo
tema
enorme
importancia
seguridad
sistemas
operativos
cubre
capítulo
temas
descritos
capítulo
amenazas
virus
gusa-
mecanismos
protección
modelos
seguridad
continuación
veremos
ejemplos
prácticos
sistemas
operativos
reales
Linux
capítulo
10
Windows
Vista
capítulo
11
Symbian
capítulo
12
libro
concluye
consejos
pensamientos
acerca
diseño
sistemas
operativos
capítulo
13
1.11
UNIDADES
MÉTRICAS
evitar
confusión
vale
pena
declarar
forma
explícita
libro
ciencia
computacional
general
utilizan
unidades
métricas
tradicionales
uni-
dades
sistema
inglés
principales
prefijos
métricos
listan
figura
1-31
gene-
ral
prefijos
abrevian
primeras
letras
unidades
mayores
mayúsculas
base
datos
TB
ocupa
10
12
bytes
almacenamiento
reloj
100
pseg
100
ps
emite
pulso
10-10
segundos
mili
micro
empiezan
letra
elección
general
mili
letra
griega
mu
micro
78
INTRODUCCIÓN
CAPÍTULO
Exp
Explícito
Prefijo
Exp
Explícito
Prefijo
10−3
m1
1,000
Kilo
10−6
m1
1,000,000
Mega
10−9
n1
1,000,000,000
Giga
10−12
0.000000000001
pico
10
12
1,000,000,000,000
Tera
10−15
0.000000000000001
femto
10
15
1,000,000,000,000,000
Peta
10−18
0.0000000000000000001
atto
10
18
1,000,000,000,000,000,000
Exa
10−21
0.0000000000000000000001
zepto
10
21
1,000,000,000,000,000,000,000
Zetta
10−24
0.0000000000000000000000001
yocto
10
24
1,000,000,000,000,000,000,000,000
Yotta
Figura
1-31
principales
prefijos
métricos
vale
pena
recalcar
medir
tamaños
memorias
práctica
co-
mún
industria
unidades
significados
ligeramente
Kilo
significa
10
1024
103
1000
memorias
utilizan
potencia
ende
memoria
KB
contiene
1024
bytes
1000
bytes
similar
memoria
MB
contiene
20
1,048,576
bytes
memoria
GB
contiene
30
1,073,741,824
by-
tes
línea
comunicación
Kbps
transmite
1000
bits
LAN
10
Mbps
opera
10,000,000
bits
seg
velocidades
potencias
desgracia
personas
tienden
mezclar
sistemas
especial
tamaños
www
FreeLibros.meSECCIÓN
1.12
RESUMEN
79
discos
evitar
ambigüedades
libro
utilizaremos
símbolos
KB
MB
GB
pa-
ra
210
220
230
bytes
respectivamente
símbolos
Kbps
Mbps
Gbps
10
106
109
bits-
/seg
respectivamente
1.12
RESUMEN
sistemas
operativos
puntos
vista
administradores
recursos
máquinas
extendidas
punto
vista
correspondiente
administrador
recursos
función
sistema
operativo
administrar
distintas
partes
sistema
forma
eficiente
punto
vista
correspondiente
máquina
extendida
función
sistema
operativo
proveer
usuarios
abstracciones
convenientes
máquina
actual
abstrac-
ciones
incluyen
procesos
espacios
direcciones
archivos
sistemas
operativos
larga
historia
empezando
reemplaza-
ron
operador
sistemas
modernos
multiprogramación
puntos
importantes
sistemas
procesamiento
lotes
sistemas
multiprogramación
sistemas
computadora
personal
sistemas
operativos
interactúan
cerca
hardware
útil
conoci-
miento
hardware
computadora
parea
comprenderlos
computadoras
compuestas
procesadores
memorias
dispositivos
S.
partes
conectan
buses
conceptos
básicos
basan
sistemas
operativos
procesos
administración
memoria
administración
sistema
archivos
seguridad
conceptos
tratará
detalle
capítulo
posterior
corazón
sistema
operativo
conjunto
llamadas
sistema
ma-
nejar
llamadas
indican
realmente
sistema
operativo
UNIX
visto
grupos
llamadas
sistema
grupo
llamadas
relaciona
creación
terminación
procesos
grupo
leer
escribir
archivos
tercer
grupo
pa-
ra
administrar
directorios
cuarto
grupo
contiene
miscelánea
llamadas
sistemas
operativos
estructurar
formas
comunes
sistema
monolítico
jerarquía
capas
microkernel
cliente-servidor
máquina
virtual
exokernel
PROBLEMAS
multiprogramación
spooling
Cree
computadoras
personales
avanzadas
spooling
característica
estándar
futuro
primeras
computadoras
byte
datos
leídos
escritos
manejaba
CPU
DMA
implicaciones
multiprogramación
www
FreeLibros.me4
idea
familia
computadoras
introducida
década
1960
mainframes
IBM
System/360
muerta
idea
pie
razón
GUI
adoptaron
rapidez
principio
costo
hardwa-
re
necesario
darles
soporte
RAM
video
necesita
soporte
pantalla
texto
monocromático
25
líneas
80
caracteres
necesita
mapa
bits
1024
/H11003768
píxeles
colores
24
bits
costo
RAM
precios
1980
dólares
KB
vale
metas
diseño
hora
crear
sistema
operativo
ejemplo
utilización
recursos
puntualidad
robusto
etcétera
ejemplo
metas
diseño
puedan
contradecirse
siguientes
instrucciones
permitirse
kernel
Deshabilitar
interrupciones
Leer
reloj
hora
Establecer
reloj
hora
Cambiar
mapa
memoria
Considere
sistema
CPUs
CPU
hilos
hiperhilamiento
Suponga
inician
programas
P0
P1
P2
tiempos
ejecución
10
20
mseg
respectivamen-
tardará
completar
ejecución
programas
Suponga
progra-
100%
ligados
CPU
bloquean
ejecución
cambian
CPU
asigna
computadora
canalización
etapas
etapa
requiere
tiempo
pa-
ra
trabajo
nseg
instrucciones
ejecutar
máquina
10
Considere
sistema
cómputo
memoria
caché
memoria
principal
RAM
disco
sistema
operativo
utiliza
memoria
virtual
requieren
nseg
acceder
palabra
caché
10
nseg
acceder
palabra
RAM
10
ms
acceder
palabra
disco
proporción
aciertos
caché
95%
proporción
aciertos
memoria
fallo
caché
99%
tiempo
promedio
acceder
palabra
11
revisor
alerta
observa
error
ortografía
consistente
manuscrito
libro
texto
sistemas
operativos
punto
impreso
libro
cerca
700
páginas
50
líneas
80
caracteres
tiempo
requerirá
digitalizar
forma
electrónica
texto
caso
copia
maestra
encuentre
niveles
memoria
figura
1-9
métodos
almacenamiento
interno
considere
tiempo
acceso
da-
do
carácter
discos
suponga
tiempo
bloque
1024
caracteres
cinta
suponga
tiempo
inicio
datos
acceso
posterior
velocidad
acceso
disco
12
programa
usuario
realiza
llamada
sistema
leer
escribir
archivo
disco
proporciona
indicación
archivo
desea
apuntador
búfer
datos
control
transfiere
sistema
operativo
llama
driver
apropiado
Suponga
driver
inicia
disco
termina
ocurre
interrupción
caso
leer
disco
obvio
procedimiento
llamada
bloqueado
datos
leer
caso
escribir
disco
Necesita
bloqueado
procedimien-
to
llamador
esperar
complete
transferencia
disco
80
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
81
13
instrucción
trap
Explique
sistemas
operativos
14
diferencia
clave
trap
interrupción
15
necesita
tabla
procesos
sistema
tiempo
compartido
necesita
sistemas
computadora
personal
proceso
proceso
ocupa
to-
máquina
termina
16
razón
conveniente
montar
sistema
archivos
directorio
vacío
17
propósito
llamada
sistema
sistema
operativo
18
siguientes
llamadas
sistema
proporcione
condición
haga
falle
fork
execy
unlink
19
llamada
write(fd
bufer
nbytes
devolver
valor
distinto
nbytes
20
archivo
cuyo
descriptor
fd
contiene
secuencia
bytes
realizan
siguientes
llamadas
sistema
lseek(fd
SEEK_SET
read(fd
bufer
llamada
lseekrealiza
búsqueda
byte
archivo
contiene
bufer
des-
pués
completar
operación
lectura
21
Suponga
archivo
10
MB
almacena
disco
pista
pista
50
sec-
tores
consecutivos
brazo
disco
actualmente
situado
pista
número
100
tardará
recuperar
archivo
disco
Suponga
desplazar
brazo
ci-
lindro
requiere
ms
requieren
ms
sector
almacenado
inicio
archivo
gire
cabeza
Suponga
lectura
ocurre
velocidad
100
MB
s.
22
diferencia
esencial
archivo
especial
bloque
archivo
especial
carácter
23
ejemplo
figura
1-17
procedimiento
biblioteca
llama
read
llamada
sistema
llama
read
esencial
tengan
nombre
importante
24
modelo
cliente-servidor
popular
sistemas
distribuidos
utilizarse
sistema
computadora
25
programador
llamada
sistema
ve
llamada
procedi-
miento
biblioteca
importante
programador
sepa
procedimientos
biblioteca
resultan
llamadas
sistema
circunstancias
26
figura
1-23
muestra
llamadas
sistema
UNIX
equivalentes
API
Win32
llamadas
listan
equivalente
Win32
consecuencias
programador
convierta
programa
UNIX
ejecute
Windows
www
FreeLibros.me27
sistema
operativo
portátil
portar
arquitectura
sistema
modificación
Explique
factible
construir
sistema
operativo
completamen-
portátil
Describa
capas
alto
nivel
diseñar
sistema
operativo
alta-
mente
portátil
28
Explique
separación
directiva
mecanismo
ayuda
construir
sistemas
operativos
basados
microkernel
29
preguntas
practicar
conversiones
unidades
segundos
equivale
microaño
micrómetros
conoce
comúnmente
micrones
gigamicron
bytes
memoria
TB
masa
Tierra
6000
yottagramos
kilogramos
30
Escriba
shell
similar
figura
1-19
contenga
suficiente
código
funcionar
probar
agregar
características
redirec-
ción
entrada
salida
canales
trabajos
plano
31
sistema
personal
parecido
UNIX
Linux
MINIX
FreeBSD
etcétera
disponible
fallar
seguridad
reiniciar
escriba
secuencia
comandos
shell
inten-
crear
número
ilimitado
procesos
hijos
observe
ocurre
ejecutar
experi-
mento
escriba
sync
shell
vaciar
búferes
sistema
archivos
disco
evitar
arruinar
sistema
archivos
Nota
intente
sistema
compartido
obtener
prime-
ro
permiso
administrador
sistema
consecuencias
obvias
inmediato
probable
atrapen
sancionen
32
Examine
trate
interpretar
contenido
directorio
tipo
UNIX
Windows
herra-
mienta
programa
od
UNIX
programa
DEBUG
MS-DOS
Sugerencia
forma
haga
dependerá
permita
SO
truco
funcionar
crear
di-
rectorio
disco
flexible
sistema
operativo
leer
datos
puros
disco
usan-
do
sistema
operativo
distinto
permita
acceso
82
INTRODUCCIÓN
CAPÍTULO
www
FreeLibros.me2
PROCESOS
HILOS
83
punto
emprender
estudio
detallado
sistemas
operativos
diseñados
construidos
concepto
importante
sistema
operativo
proceso
abs-
tracción
programa
ejecución
depende
concepto
im-
portante
diseñador
sistema
operativo
estudiante
comprensión
profunda
acerca
proceso
procesos
abstracciones
antiguas
importantes
proporcionan
sis-
temas
operativos
proporcionan
capacidad
operar
pseudo
concurrentemente
CPU
disponible
Convierten
CPU
CPU
virtuales
abstracción
procesos
computación
moderna
existir
capítulo
examinaremos
detalle
procesos
primos
hilos
threads
2.1
PROCESOS
computadoras
modernas
ofrecen
cosas
tiempo
acostum-
brados
trabajar
estén
completamente
conscientes
uti-
lizaremos
ejemplos
aclarar
punto
Consideremos
servidor
Web
convergen
peticiones
páginas
Web
provenientes
lados
llega
pe-
tición
servidor
verifica
página
necesita
caché
devuelve
pá-
gina
caso
contrario
inicia
petición
disco
obtenerla
perspectiva
CPU
peticiones
tardan
eternidades
espera
cumplimiento
petición
www.FreeLibros.memás
llegar
discos
presentes
peticiones
di-
rigirse
discos
cumpla
petición
evidente
necesita
forma
modelar
controlar
concurrencia
procesos
especial
hilos
ayudar
caso
consideremos
PC
usuario
arranca
sistema
inician
proce-
sos
forma
secreta
usuario
desconoce
ejemplo
iniciar
pro-
ceso
esperar
correo
electrónico
entrante
permite
antivirus
comprobar
perió-
dicamente
disponibilidad
definiciones
virus
procesos
usuario
explícitos
ejemplo
imprimir
archivos
quemar
CD-ROM
usuario
nave-
ga
Web
actividad
administrar
caso
sistema
multipro-
gramación
soporte
múltiples
procesos
útil
sistema
multiprogramación
CPU
conmuta
proceso
rapidez
ejecutando
décimas
centésimas
milisegundos
hablando
sentido
estricto
instante
CPU
ejecutando
proceso
transcurso
po-
dría
trabajar
dando
apariencia
paralelismo
pseudoparalelismo
distinguirlo
paralelismo
hardware
sistemas
multiprocesadores
CPUs
comparten
memoria
física
difícil
personas
actividades
paralelo
diseñadores
sistemas
operativos
evoluciona-
do
paso
años
modelo
conceptual
procesos
secuenciales
facilita
trabajo
paralelismo
modelo
usos
consecuencias
conforman
tema
es-
capítulo
2.1.1
modelo
proceso
modelo
software
ejecutable
computadora
incluye
sis-
tema
operativo
organiza
procesos
secuenciales
procesos
abreviar
proce-
so
instancia
programa
ejecución
incluyendo
valores
actuales
contador
programa
registros
variables
concepto
proceso
CPU
virtual
realidad
CPU
real
conmuta
proceso
entender
sis-
tema
fácil
pensar
colección
procesos
ejecutan
pseudo
para-
lelo
tratar
CPU
conmuta
programa
programa
conmutación
rápida
proceso
conoce
multiprogramación
vimos
capítulo
figura
2-1(a
muestra
computadora
multiprogramando
programas
memoria
figura
2-1(b
lista
procesos
flujo
control
contador
programa
lógico
ejecutándose
forma
independiente
contador
programa
físico
ejecuta
proceso
carga
contador
programa
lógico
contador
programa
real
termina
tiempo
asignado
contador
programa
físico
guarda
contador
programa
lógico
alma-
cenado
proceso
memoria
figura
2-1(c
intervalo
suficien-
temente
procesos
progresado
momento
proceso
ejecución
84
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.1
PROCESOS
85
capítulo
suponer
CPU
condición
suce-
realidad
chips
multinúcleo
CPUs
capítulo
analizaremos
chips
multinúcleo
multiprocesadores
general
simple
considerar
CPU
decimos
CPU
ejecutar
proceso
núcleos
CPUs
eje-
cutar
proceso
CPU
conmuta
rápidamente
proceso
velocidad
pro-
ceso
ejecuta
cálculos
uniforme
siquiera
reproducible
ejecutan
mis-
mos
procesos
ende
programar
procesos
asumirse
variación
velocidad
ejemplo
considere
proceso
inicia
unidad
cinta
magnética
pa-
ra
restaurar
archivos
respaldados
ejecuta
ciclo
inactividad
10,000
permitir
obtenga
velocidad
adecuada
emite
comando
leer
registro
CPU
decide
conmutar
proceso
ciclo
inactividad
proceso
cinta
ejecute
registro
encuentre
allá
cabeza
lectura
proceso
requerimientos
críticos
tiempo
real
ocurrir
eventos
específicos
número
especificado
milisegundos
necesario
tomar
medidas
especiales
asegurar
ocurran
general
mayoría
pro-
cesos
ven
afectados
multiprogramación
subyacente
CPU
velocidades
relati-
vas
distintos
procesos
diferencia
proceso
programa
sutil
crucial
ayudarnos
analogía
científico
computacional
mente
culinaria
hornea
pastel
cumpleaños
hija
receta
pastel
cumpleaños
cocina
equipada
ingre-
dientes
harina
huevos
azúcar
extracto
vainilla
etcétera
analogía
receta
pro-
grama
algoritmo
expresado
notación
adecuada
científico
computacional
procesador
CPU
ingredientes
pastel
datos
entrada
proceso
acti-
vidad
consiste
cocinero
leyendo
receta
obteniendo
ingredientes
horneando
pastel
Conmutación
proceso
contador
programa
contadores
programa
Proceso
Tiempo
BC
Figura
2-1
Multiprogramación
programas
Modelo
conceptual
procesos
secuenciales
independientes
programa
activo
www
FreeLibros.meAhora
imagine
hijo
científico
entra
corriendo
gritando
abeja
acaba
pi-
carlo
científico
computacional
registra
punto
receta
proce-
so
curso
guarda
saca
libro
auxilios
empieza
seguir
instrucciones
contiene
procesador
conmuta
proceso
hornear
pastel
prioridad
ad-
ministrar
cuidados
médicos
programa
distinto
receta
libro
auxilios
ocupado
picadura
abeja
científico
computacional
regresa
pastel
continúa
punto
quedado
idea
clave
proceso
actividad
tipo
programa
entra-
salida
procesos
compartir
procesador
algoritmo
planificación
determinar
detener
trabajo
proceso
pa-
ra
servicio
Vale
pena
recalcar
programa
ejecutando
duplicado
pro-
cesos
ejemplo
iniciar
procesador
palabras
imprimir
archivos
tiempo
impresoras
disponibles
procesos
eje-
cución
tengan
programa
importa
procesos
distintos
sistema
operativo
compartir
código
copia
memoria
detalle
técnico
cambia
situación
conceptual
procesos
ejecución
2.1.2
Creación
proceso
sistemas
operativos
necesitan
crear
procesos
sistemas
simples
sis-
temas
diseñados
ejecutar
aplicación
ejemplo
controlador
horno
mi-
croondas
presentes
procesos
vayan
requerir
sistema
inicie
obstante
sistemas
propósito
general
necesita
forma
crear
termi-
nar
procesos
necesario
operación
analizaremos
cues-
tiones
eventos
principales
provocan
creación
procesos
arranque
sistema
ejecución
proceso
llamada
sistema
creación
procesos
petición
usuario
crear
proceso
inicio
trabajo
lotes
Generalmente
arranca
sistema
operativo
crean
procesos
procesos
plano
procesos
interactúan
usuarios
humanos
rea-
lizan
trabajo
procesos
plano
asociados
usuarios
específicos
función
específica
ejemplo
diseñar
proceso
plano
aceptar
correo
electrónico
entrante
permanece
inactivo
pe-
ro
activa
llega
mensaje
diseñar
proceso
plano
86
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.1
PROCESOS
87
aceptar
peticiones
entrantes
páginas
Web
hospedadas
equipo
despierte
llegue
petición
darle
servicio
procesos
permanecen
plano
mane-
jar
actividades
correo
electrónico
páginas
Web
noticias
impresiones
etcétera
co-
nocen
demonios
daemons
sistemas
comúnmente
docenas
UNIX
utilizar
programa
ps
listar
procesos
ejecución
Windows
administrador
tareas
procesos
crean
arranque
posteriormente
crear
me-
nudo
proceso
ejecución
emitirá
llamadas
sistema
crear
procesos
pa-
ra
ayuden
trabajo
especial
útil
crear
procesos
trabajo
formular
fácilmente
términos
procesos
interactivos
relacionados
independientes
aspectos
ejemplo
obtener
cantidad
datos
red
posterior
procesamiento
conveniente
crear
proceso
ob-
datos
colocarlos
búfer
compartido
proceso
remueve
ele-
mentos
datos
procesa
multiprocesador
permitir
proceso
ejecute
CPU
distinta
trabajo
realice
rapidez
sistemas
interactivos
usuarios
iniciar
programa
escribiendo
comando
doble
clic
icono
Cualquiera
acciones
inicia
proceso
ejecuta
programa
seleccionado
sistemas
UNIX
basados
comandos
ejecutan
pro-
ceso
cargo
ventana
inició
Microsoft
Windows
inicia
proceso
ventana
crear
mayoría
siste-
usuarios
ventanas
abiertas
ejecutando
proce-
so
ratón
usuario
seleccionar
ventana
interactuar
proceso
ejemplo
proveer
datos
necesario
situación
crean
procesos
aplica
sistemas
procesa-
miento
lotes
encuentran
mainframes
usuarios
enviar
tra-
bajos
procesamiento
lotes
sistema
posiblemente
forma
remota
sistema
operativo
decide
recursos
ejecutar
trabajo
crea
proceso
ejecuta
si-
guiente
trabajo
cola
entrada
Técnicamente
casos
crear
proceso
proceso
exis-
tente
ejecute
llamada
sistema
creación
proceso
proceso
proceso
usuario
ejecución
proceso
sistema
invocado
teclado
ratón
proceso
administrador
procesamiento
lotes
caso
ejecutar
llamada
sis-
tema
crear
proceso
llamada
sistema
indica
sistema
operativo
cree
proceso
indica
directa
indirectamente
programa
ejecutarlo
UNIX
llamada
sistema
crear
proceso
fork
llamada
crea
clon
exacto
proceso
llamada
fork
procesos
padre
hijo
tie-
nen
imagen
memoria
cadenas
entorno
archivos
abiertos
general
proceso
hijo
ejecuta
execveo
llamada
sistema
simi-
lar
cambiar
imagen
memoria
ejecutar
programa
ejemplo
usuario
escribe
comando
sort
shell
crea
proceso
hijo
ejecu-
ta
sort
razón
proceso
pasos
permitir
hijo
manipular
descriptores
archivo
fork
execve
lograr
redirección
entrada
es-
tándar
salida
estándar
error
estándar
www
FreeLibros.mePor
contrario
Windows
llamada
función
Win32
CreateProcess
maneja
creación
procesos
carga
programa
correcto
proceso
llamada
10
parámetros
incluyen
programa
ejecutar
parámetros
línea
coman-
introducir
datos
programa
atributos
seguridad
bits
controlan
archivos
abiertos
heredan
información
prioridad
especificación
ventana
crear
proceso
crear
apuntador
estructura
de-
vuelve
proceso
llamada
información
acerca
proceso
recién
creado
CreateProcess
Win32
cerca
100
funciones
administrar
sincronizar
proce-
sos
temas
relacionados
UNIX
Windows
crea
proceso
padre
hijo
espacios
direcciones
distintos
cualquiera
procesos
modifica
palabra
espacio
direcciones
modificación
visible
proceso
UNIX
espa-
cio
direcciones
inicial
hijo
copia
padre
definitiva
espacios
di-
recciones
distintos
involucrados
comparte
memoria
escribir
implementaciones
UNIX
comparten
texto
programa
pue-
modificar
proceso
recién
creado
compartir
recursos
creador
archivos
abiertos
Windows
espacios
direcciones
hi-
jo
padre
distintos
principio
2.1.3
Terminación
procesos
crea
proceso
empieza
ejecutarse
realiza
trabajo
destinado
dura
siquiera
procesos
proceso
ter-
minará
general
siguientes
condiciones
Salida
normal
voluntaria
Salida
error
voluntaria
Error
fatal
involuntaria
Eliminado
proceso
involuntaria
mayoría
procesos
terminan
concluido
trabajo
com-
pilador
compilado
programa
recibe
ejecuta
llamada
sistema
indicar
siste-
ma
operativo
terminado
llamada
exiten
UNIX
ExitProcessen
Windows
programas
orientados
pantalla
admiten
terminación
voluntaria
procesadores
palabras
navegadores
Internet
programas
similares
icono
elemento
me-
nú
usuario
clic
indicar
proceso
elimine
archivos
tem-
porales
abiertos
termine
razón
terminación
proceso
descubra
error
ejemplo
usua-
rio
escribe
comando
cc
foo.c
88
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.1
PROCESOS
89
compilar
programa
foo.c
archivo
compilador
simplemente
termina
procesos
interactivos
orientados
pantalla
general
terminan
reciben
paráme-
tros
incorrectos
aparece
cuadro
diálogo
pide
usuario
intente
razón
terminación
error
fatal
producido
proceso
error
programa
ejemplos
incluyen
ejecutar
instrucción
ilegal
refe-
rencia
memoria
existente
división
cero
sistemas
UNIX
proceso
indicar
sistema
operativo
desea
manejar
errores
mis-
mo
cuyo
caso
proceso
recibe
señal
interrumpe
terminar
cuarta
razón
proceso
terminar
ejecute
llamada
sistema
indique
sistema
operativo
elimine
procesos
UNIX
llamada
kill
fun-
ción
correspondiente
Win32
TerminateProcess
casos
proceso
eliminador
autorización
necesaria
eliminación
sistemas
proce-
so
termina
forma
voluntaria
forzosa
procesos
creó
eliminan
inme-
diato
Windows
UNIX
trabajan
forma
2.1.4
Jerarquías
procesos
sistemas
proceso
crea
proceso
padre
proceso
hijo
continúan
aso-
ciados
formas
proceso
hijo
crear
procesos
formando
je-
rarquía
procesos
Observe
diferencia
plantas
animales
utilizan
reproducción
sexual
proceso
padre
cero
hijos
UNIX
proceso
hijos
posteriores
descendientes
forman
gru-
po
procesos
usuario
envía
señal
teclado
envía
miembros
grupo
procesos
actualmente
asociado
teclado
general
procesos
acti-
vos
crearon
ventana
actual
individual
proceso
atrapar
se-
ñal
ignorarla
tomar
acción
predeterminada
eliminado
señal
ejemplo
jerarquía
procesos
juega
papel
veamos
forma
UNIX
inicializa
enciende
computadora
proceso
especial
lla-
mado
init
imagen
inicio
empieza
ejecutarse
lee
archivo
indica
cuán-
tas
terminales
utiliza
fork
crear
proceso
terminal
procesos
esperan
alguien
inicie
sesión
inicio
sesión
éxito
proceso
inicio
se-
sión
ejecuta
shell
aceptar
comandos
iniciar
procesos
sucesivamen-
ende
procesos
sistema
completo
pertenecen
árbol
init
raíz
contraste
Windows
concepto
jerarquía
procesos
procesos
iguales
única
sugerencia
jerarquía
procesos
crea
proceso
padre
recibe
indicador
especial
token
llamado
manejador
utilizar
controlar
hijo
libertad
pasar
indicador
procesos
invalida
jerarquía
procesos
UNIX
desheredar
hijos
www
FreeLibros.me2.1.5
proceso
proceso
entidad
independiente
contador
programa
interno
procesos
necesitan
interactuar
proceso
generar
sa-
lida
proceso
utiliza
entrada
comando
shell
cat
capitulo1
capitulo2
capitulo3
grep
arbol
proceso
ejecuta
cat
concatena
archivos
envía
salida
pro-
ceso
ejecuta
grep
selecciona
líneas
contengan
palabra
arbol
Dependiendo
velocidad
relativa
procesos
dependen
complejidad
relativa
programas
tiempo
CPU
ocurrir
grep
esté
listo
ejecutarse
entrada
esperándolo
bloquear
entrada
disponible
proceso
bloquea
lógica
continuar
común-
mente
esperando
entrada
disponible
proceso
esté
listo
concepto
ejecutarse
detenga
sistema
ope-
rativo
decidido
asignar
CPU
proceso
tiempo
condiciones
com-
pletamente
distintas
caso
suspensión
inherente
problema
procesar
línea
comandos
usuario
escrito
teclado
caso
tecnicismo
sistema
suficientes
CPUs
otorgar
ca-
proceso
procesador
privado
figura
2-2
diagrama
muestra
encontrar
proceso
ejecución
realidad
usando
CPU
instante
Listo
ejecutable
detuvo
temporalmente
dejar
ejecute
proceso
Bloqueado
ejecutarse
ocurra
evento
externo
sentido
lógico
similares
casos
proceso
deseoso
ejecutarse
temporalmente
CPU
tercer
dis-
tinto
proceso
ejecutar
CPU
90
PROCESOS
HILOS
CAPÍTULO
12
4Bloqueado
ejecución
Listo
proceso
bloquea
recibir
entrada
planificador
selecciona
proceso
planificador
selecciona
proceso
entrada
disponible
Figura
2-2
proceso
encontrarse
ejecución
bloqueado
listo
transiciones
muestran
transiciones
posibles
indica
transición
ocurre
sistema
operativo
descubre
proceso
continuar
justo
momento
www
FreeLibros.meSECCIÓN
2.1
PROCESOS
91
sistemas
proceso
ejecutar
llamada
sistema
pause
entrar
es-
tado
bloqueado
sistemas
incluyendo
UNIX
proceso
lee
datos
cana-
lización
archivo
especial
terminal
entrada
disponible
proceso
bloquea
forma
automática
transiciones
producidas
planificador
procesos
sistema
operativo
proceso
sepa
siquiera
acerca
transición
ocurre
plani-
ficador
decide
proceso
ejecución
ejecutado
tiempo
suficiente
momento
dejar
proceso
tiempo
CPU
transición
ocurre
procesos
tiempo
CPU
momento
pro-
ceso
obtenga
CPU
ejecutarse
tema
planificación
procesos
decidir
proceso
ejecutarse
momento
tiempo
importante
capítulo
analizaremos
ideado
algoritmos
tratar
balancear
contrastan-
tes
demandas
eficiencia
sistema
equidad
procesos
individua-
capítulo
estudiaremos
transición
ocurre
produce
evento
externo
proceso
espe-
rando
llegada
datos
entrada
proceso
ejecución
ins-
tante
activa
transición
proceso
empieza
ejecutarse
caso
contrario
esperar
listo
instantes
CPU
esté
disponible
turno
utilizarla
utilizamos
modelo
procesos
fácil
pensar
ocurriendo
sistema
procesos
ejecutan
programas
llevan
cabo
comandos
escribe
usuario
sistema
encargan
tareas
cumplir
pe-
ticiones
servicios
archivos
administrar
detalles
ejecutar
unidad
disco
cinta
magnética
ocurre
interrupción
disco
sistema
toma
decisión
dejar
ejecutar
proceso
actual
ejecutar
proceso
disco
bloqueado
esperando
inte-
rrupción
pensar
interrupciones
pensar
procesos
usuario
procesos
disco
procesos
terminal
etc.
bloquean
esperando
ocurra
leído
disco
escrito
carácter
proceso
espera
desbloquea
elegible
continuar
ejecutándose
punto
vista
pie
modelo
muestra
figura
2-3
nivel
sistema
operativo
planificador
variedad
procesos
manejo
interrupciones
detalles
relacionados
iniciar
detener
procesos
ocultan
denomina
planificador
realidad
código
resto
sistema
operativo
estructurado
forma
procesos
sistemas
reales
estructurados
2.1.6
Implementación
procesos
implementar
modelo
procesos
sistema
operativo
mantiene
tabla
arreglo
es-
tructuras
llamada
tabla
procesos
entrada
proceso
autores
llaman
entradas
bloques
control
procesos
entrada
contiene
información
importante
acerca
proceso
incluyendo
contador
programa
apuntador
pila
asignación
memoria
archivos
abiertos
información
contabilidad
planificación
de-
www.FreeLibros.memás
guardarse
acerca
proceso
cambia
ejecución
listo
blo-
queado
reiniciar
posteriormente
hubiera
detenido
figura
2-4
muestra
campos
clave
sistema
típico
campos
pri-
mera
columna
relacionan
administración
procesos
relacionan
administración
memoria
archivos
respectivamente
recalcar
campos
conteni-
tabla
procesos
varían
sistema
figura
idea
general
tipos
información
necesaria
Figura
2-4
campos
entrada
típica
tabla
procesos
analizado
tabla
procesos
explicar
acerca
có-
mo
ilusión
procesos
secuenciales
mantiene
CPU
cla-
ubicación
asociada
general
ubicación
cerca
memoria
llama
ector
interrupción
ubicación
contiene
di-
rección
procedimiento
servicio
interrupciones
Suponga
proceso
usuario
ejecución
ocurre
interrupción
disco
contador
programa
palabra
92
PROCESOS
HILOS
CAPÍTULO
01
Planificador
Procesos
Figura
2-3
capa
baja
sistema
operativo
estructurado
procesos
en-
carga
interrupciones
planificación
capa
procesos
se-
cuenciales
Administración
procesos
Administración
memoria
Administración
archivos
Registros
Apuntador
información
Directorio
raíz
Contador
programa
segmento
texto
Directorio
trabajo
Palabra
programa
Apuntador
información
Descripciones
archivos
Apuntador
pila
segmento
datos
ID
usuario
proceso
Apuntador
información
ID
grupo
Prioridad
segmento
pila
Parámetros
planificación
ID
proceso
Proceso
padre
Grupo
procesos
Señales
Tiempo
inicio
proceso
Tiempo
utilizado
CPU
Tiempo
CPU
utilizado
hijo
Hora
alarma
www
FreeLibros.meSECCIÓN
2.1
PROCESOS
93
programa
registros
proceso
usuario
meten
pila
ac-
tual
hardware
interrupción
computadora
salta
dirección
especifi-
vector
interrupción
hardware
depende
software
especial
procedimiento
servicio
interrupciones
interrupciones
empiezan
guardar
registros
entrada
tabla
procesos
proceso
actual
quita
información
interrupción
metió
pila
apuntador
pila
establece
apunte
pila
temporal
utilizada
manejador
procesos
acciones
guardar
registros
establecer
apuntador
pila
expresar
siquiera
lenguajes
alto
nivel
tales
realizan
pe-
queña
rutina
lenguaje
ensamblador
general
interrupciones
trabajo
guardar
registros
idéntico
importar
causa
interrupción
termina
rutina
llama
procedimiento
resto
trabajo
tipo
interrupción
específico
suponemos
sistema
operativo
escrito
elección
usual
sistemas
operativos
reales
terminado
trabajo
ocasionando
proceso
esté
listo
planificador
llamado
pro-
ceso
ejecutar
continuación
control
pasa
vuelta
código
len-
guaje
ensamblador
cargar
registros
mapa
memoria
proceso
actual
empieza
ejecutar
figura
2-5
sintetizan
manejo
interrupciones
pla-
nificación
proceso
Vale
pena
recalcar
detalles
varían
dependiendo
sistema
hardware
mete
contador
programa
pila
etc.
hardware
carga
contador
programa
vector
interrupciones
Procedimiento
lenguaje
ensamblador
guarda
registros
Procedimiento
lenguaje
ensamblador
establece
pila
servicio
interrupciones
ejecuta
general
lee
guarda
entrada
búfer
planificador
decide
proceso
ejecutar
continuación
Procedimiento
regresa
código
ensamblador
Procedimiento
lenguaje
ensamblador
inicia
proceso
actual
Figura
2-5
Esqueleto
nivel
sistema
operativo
ocurre
interrupción
proceso
termina
sistema
operativo
muestra
carácter
indicador
espera
nue-
vo
comando
recibe
comando
carga
programa
memoria
sobrescribiendo
2.1.7
Modelación
multiprogramación
utiliza
multiprogramación
CPU
mejorar
forma
cruda
proceso
promedio
realiza
cálculos
20
ciento
tiempo
memoria
procesos
memoria
CPU
deberá
ocupada
tiempo
es-
modelo
optimista
supone
procesos
estarán
esperando
tiempo
www
FreeLibros.meUn
modelo
analizar
CPU
punto
vista
probabilístico
Supon-
ga
proceso
gasta
fracción
tiempo
esperando
complete
operación
S.
procesos
memoria
probabilidad
procesos
estén
espe-
rando
cuyo
caso
CPU
inactiva
pn
CPU
obtiene
fórmula
CPU
/H110051
/H11002pn
figura
2-6
muestra
CPU
función
conoce
gra-
do
multiprogramación
94
PROCESOS
HILOS
CAPÍTULO
50%
espera
80%
espera
20%
espera
100
80
60
40
20
123456
789
00
Grado
multiprogramación
CPU
porcentaje
Figura
2-6
CPU
función
número
procesos
memoria
figura
deja
procesos
gastan
80
ciento
tiempo
esperando
ope-
raciones
10
procesos
memoria
desperdicio
CPU
esté
10%
damos
proceso
interactivo
espera
usuario
escriba
terminal
espera
es-
tar
tiempos
espera
80
ciento
comunes
in-
cluso
servidores
procesos
realizan
operaciones
disco
porcentaje
obtener
precisión
completa
debemos
recalcar
modelo
probabilístico
aca-
bamos
describir
aproximación
Supone
forma
implícita
procesos
in-
dependientes
significa
aceptable
sistema
procesos
memoria
ejecución
espera
CPU
pro-
cesos
ejecución
proceso
cambie
listo
CPU
esté
ocupada
esperar
ende
procesos
independientes
construir
modelo
preciso
teoría
colas
punto
establecer
multi-
programación
permite
procesos
utilicen
CPU
contrario
estaría
inactiva
válido
curvas
verdaderas
figura
2-6
ligeramente
distintas
muestran
figura
www
FreeLibros.meSECCIÓN
2.2
HILOS
95
modelo
figura
2-6
simple
formas
utilizar
reali-
zar
predicciones
específicas
aproximadas
acerca
rendimiento
CPU
ejemplo
suponga
computadora
512
MB
memoria
sistema
operativo
ocupa
128
MB
programa
usuario
ocupa
128
MB
tamaños
permiten
pro-
gramas
usuario
memoria
promedio
80
ciento
tiempo
espera
utilización
CPU
ignorando
sobrecarga
sistema
operativo
0.8
49
ciento
agregamos
512
MB
memoria
sistema
pa-
sar
multiprogramación
vías
multiprogramación
vías
CPU
eleva
79
ciento
palabras
512
MB
adicionales
elevarán
ren-
dimiento
30
ciento
agregamos
512
MB
CPU
incrementaría
79
91
ciento
elevaría
rendimiento
12%
adicional
Utilizando
modelo
propieta-
rio
computadora
decidir
adición
inversión
segun-
2.2
HILOS
sistemas
operativos
tradicionales
proceso
espacio
direcciones
hi-
control
definición
proceso
frecuencia
situaciones
conveniente
hilos
control
espacio
direccio-
nes
ejecuta
cuasi-paralelo
fueran
procesos
separados
espa-
cio
direcciones
compartido
siguientes
secciones
hablaremos
situaciones
implicaciones
2.2.1
hilos
alguien
querría
tipo
proceso
proceso
Resulta
va-
rias
razones
miniprocesos
conocidos
hilos
analizaremos
principal
razón
hilos
aplicaciones
desarrollan
activi-
dades
bloquear
descomponer
aplica-
ción
hilos
secuenciales
ejecutan
cuasi-paralelo
modelo
programación
simplifica
visto
argumento
precisamente
justificación
procesos
pensar
interrupciones
temporizadores
conmutaciones
contexto
pensar
pro-
cesos
paralelos
hilos
agregamos
elemento
habilidad
en-
tidades
paralelo
compartir
espacio
direcciones
datos
habilidad
esencial
aplicaciones
razón
funcionará
pro-
cesos
espacios
direcciones
separados
argumento
hilos
ligeros
procesos
fáciles
crear
rápidos
destruir
sistemas
creación
hilo
10
100
rápida
proceso
número
hilos
necesarios
cambia
ma-
nera
dinámica
rápida
útil
propiedad
www
FreeLibros.meUna
razón
hilos
argumento
relacionado
rendimiento
hilos
producen
aumento
rendimiento
ligados
CPU
cantidad
considerable
cálculos
operaciones
hilos
activi-
dades
traslapar
agiliza
velocidad
aplicación
hilos
útiles
sistemas
CPUs
verda-
dero
paralelismo
capítulo
volveremos
cuestión
fácil
hilos
útiles
utilizamos
ejemplos
concretos
ejemplo
considere
procesador
palabras
general
procesadores
palabras
muestran
documento
crear
pantalla
exactamente
aparecerá
página
impresa
especial
saltos
línea
página
posiciones
correctas
finales
mane-
ra
usuario
inspeccionarlas
cambiar
documento
necesario
ejemplo
eliminar
viudas
huérfanas
líneas
superiores
inferiores
incompletas
consideran
estética-
mente
desagradables
Suponga
usuario
escribiendo
libro
punto
vista
autor
fá-
cil
mantener
libro
archivo
facilitar
búsqueda
temas
sustitucio-
nes
globales
etc.
capítulo
archivo
separado
sección
subsección
archivo
separado
molestia
cambios
globales
libro
tendrían
editarse
cientos
archi-
vos
forma
individual
ejemplo
aprueba
estándar
xxxx
propuesto
justo
libro
imprenta
ocurrencias
Estándar
xxxx
borrador
tendrían
cam-
biarse
Estándar
xxxx
hora
libro
archivo
general
so-
comando
sustituciones
contrario
libro
esparcido
300
archivos
editar
separado
considere
ocurre
usuario
repentinamente
elimina
enunciado
página
documento
800
páginas
revisar
página
modificada
esté
co-
rrecta
usuario
desea
cambio
página
600
escribe
comando
indica
procesador
palabras
página
posiblemente
búsqueda
frase
esté
página
procesador
palabras
volver
formato
libro
página
600
momento
línea
página
600
procesado
páginas
retraso
considerable
mostrar
página
600
usuario
estaría
descontento
ayudar
hilos
Suponga
procesador
palabras
escribe
pro-
grama
hilos
hilo
interactúa
usuario
encarga
volver
formato
plano
elimina
enunciado
página
hilo
interactivo
indi-
ca
hilo
encargado
volver
formato
aplique
formato
libro
hilo
interactivo
esperando
acciones
teclado
ratón
responde
coman-
simples
desplazarse
página
hilo
realizando
cálculos
inten-
sivos
plano
suerte
proceso
volver
formato
completará
usuario
pida
página
600
mostrarse
instante
agregar
tercer
hilo
procesadores
pala-
bras
característica
guardar
automática
archivo
disco
número
minutos
proteger
usuario
pérdida
trabajo
caso
fallo
programa
sistema
energía
tercer
hilo
encargar
96
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
97
respaldos
disco
interferir
figura
2-7
muestra
situación
hilos
Kernel
Teclado
Disco
Four
score
and
seven
years
ago
our
fathers
brought
forth
upon
this
continent
new
nation
conceived
in
liberty
and
dedicated
to
the
proposition
that
all
men
are
created
equal
Now
we
are
engaged
in
great
civil
war
testing
whether
that
nation
or
any
nation
so
conceived
and
so
dedicated
can
long
endure
We
are
met
on
great
battlefield
of
that
war
We
have
come
to
dedicate
portion
of
that
field
as
resting
place
for
those
who
here
gave
their
lives
that
this
nation
might
live
It
is
altogether
fitting
and
proper
that
we
should
do
this
But
in
larger
sense
we
cannot
dedicate
we
cannot
consecrate
we
cannot
hallow
this
ground
The
brave
men
living
and
dead
who
struggled
here
have
consecrated
it
far
above
our
poor
power
to
add
or
detract
The
world
will
little
note
nor
long
remember
what
we
say
here
but
it
can
never
forget
what
they
did
here
It
is
for
us
the
living
rather
to
be
dedicated
here
to
the
unfinished
work
which
they
who
fought
here
have
thus
far
so
nobly
advanced
It
is
rather
for
us
to
be
here
dedicated
to
the
great
task
remaining
before
us
that
from
these
honored
dead
we
take
increased
devotion
to
that
cause
for
which
they
gave
the
last
full
measure
of
devotion
that
we
here
highly
resolve
that
these
dead
shall
not
have
died
in
vain
that
this
nation
under
God
shall
have
new
birth
of
freedom
and
that
government
of
the
people
by
the
people
Figura
2-7
procesador
palabras
hilos
programa
tuviera
hilo
iniciara
respaldo
disco
ignorarían
comandos
teclado
ratón
terminara
respaldo
usuario
du-
consideraría
rendimiento
pobre
alternativa
eventos
teclado
ratón
interrumpir
respaldo
disco
permitiendo
rendimiento
produciendo
modelo
programación
complejo
controlado
interrupciones
hilos
modelo
programación
simple
hilo
interactúa
usuario
pro-
ceso
vuelve
formato
documento
indica
escribe
contenido
RAM
disco
forma
periódica
Debemos
aclarar
funcionaría
procesos
separados
hilos
necesitan
operar
documento
hilos
procesos
comparten
me-
moria
común
ende
acceso
documento
editando
situación
parecida
programas
interactivos
ejemplo
hoja
cálculo
electrónica
programa
permite
usuario
mantener
matriz
algu-
elementos
datos
proporcionados
usuario
elementos
calculan
base
datos
entrada
usando
fórmulas
potencialmente
complejas
usuario
modifica
ele-
mento
recalcular
elementos
hilo
plano
realice
cálculos
hilo
interactivo
permitir
usuario
modificaciones
adiciona-
cálculo
llevando
cabo
similar
tercer
hilo
encargar
respaldos
periódicos
disco
considere
ejemplo
utilidad
hilos
servidor
sitio
World
Wide
Web
solicitudes
páginas
llegan
página
solicitada
envía
vuelta
cliente
mayoría
sitios
Web
páginas
visitan
frecuencia
ejemplo
www.FreeLibros.mela
página
inicio
Sony
recibe
visitas
página
niveles
profundi-
dad
árbol
contenga
especificaciones
técnicas
cámara
video
servi-
dores
Web
utilizan
mejorar
rendimiento
mantener
colección
páginas
frecuente
memoria
principal
eliminar
necesidad
disco
obtenerlas
dicha
colección
conoce
caché
utiliza
contextos
ejemplo
capítulo
vimos
cachés
CPU
figura
2-8(a
muestra
forma
organizar
servidor
Web
hilo
despa-
chador
lee
peticiones
entrantes
trabajo
red
examinar
solicitud
seleccio-
na
hilo
trabajador
inactivo
bloqueado
envía
solicitud
escribiendo
apuntador
mensaje
palabra
especial
asociada
hilo
despachador
des-
pierta
trabajador
inactivo
pasa
bloqueado
listo
98
PROCESOS
HILOS
CAPÍTULO
Hilo
despachador
Hilo
trabajador
Caché
páginas
Web
Kernel
Conexión
red
Proceso
servidor
Web
Espacio
usuario
Espacio
kernel
Figura
2-8
servidor
Web
múltiples
hilos
trabajador
despierta
comprueba
petición
satisfacer
ca-
ché
páginas
Web
hilos
acceso
inicia
operación
readpara
obtener
página
disco
bloquea
complete
operación
disco
hilo
bloquea
operación
disco
selecciona
hilo
ejecutarlo
posi-
blemente
despachador
adquirir
trabajo
trabajador
queda
listo
ejecutarse
modelo
permite
escribir
servidor
forma
colección
hilos
secuenciales
programa
despachador
consiste
ciclo
infinito
obtener
petición
trabajo
enviarla
trabajador
código
trabajador
consiste
ciclo
infinito
encarga
aceptar
petición
despachador
comprobar
caché
páginas
Web
pági-
na
presente
devuelve
cliente
trabajador
bloquea
esperar
nue-
petición
www
FreeLibros.meSECCIÓN
2.2
HILOS
99
figura
2-9
muestra
bosquejo
código
resto
libro
su-
pone
TRUE
constante
buf
pagina
estructuras
apropiadas
contener
petición
trabajo
página
Web
respectivamente
while
TRUE
while
TRUE
obtener_siguiente_peticion(&buf
esperar_trabajo(&buf
pasar_trabajo(&buf
buscar_pagina_en_cache(&buf,&pagina
if
pagina_no_esta_en_cache(&pagina
leer_pagina_de_disco(&buf
pagina
devolver_pagina(&pagina
Figura
2-9
bosquejo
código
figura
2-8
Hilo
despachador
Hilo
trabajador
Considere
forma
escribirse
servidor
Web
hilos
posibilidad
ha-
cer
opere
hilo
ciclo
principal
servidor
Web
recibe
petición
exa-
mina
cabo
completarla
obtener
espera
disco
servidor
inactivo
procesa
peticiones
entrantes
servidor
Web
ejecutan-
do
máquina
dedicada
común
caso
CPU
simplemente
inactiva
servidor
Web
espera
disco
resultado
neto
procesar
peticiones
se-
gundo
ende
hilos
obtienen
aumento
considerable
rendimiento
hilo
programa
secuencial
forma
usual
visto
posibles
diseños
servidor
Web
multihilado
servidor
Web
hilo
Suponga
hilos
disponibles
diseñadores
sistema
consideran
pérdida
rendimiento
hilo
inaceptable
versión
bloqueo
llamada
sistema
readdisponible
tercer
diseño
entra
petición
único
hilo
existente
examina
satisfacer
caché
inicia
operación
disco
bloqueo
servidor
registra
petición
actual
tabla
pasa
obtener
si-
guiente
evento
petición
trabajo
respuesta
disco
acerca
operación
trabajo
inicia
respuesta
disco
infor-
mación
relevante
obtiene
tabla
procesa
respuesta
disco
bloqueo
respuesta
probablemente
tomar
forma
señal
interrupción
diseño
modelo
proceso
secuencial
tuvimos
casos
pierde
cálculo
guardarse
restaurarse
explícita
tabla
servidor
cambia
trabajar
petición
efecto
simulando
hilos
pilas
difícil
diseño
cálculo
guar-
conjunto
eventos
ocurrir
cambiar
conoce
máquina
finitos
concepto
utiliza
ampliamente
ciencias
computacionales
www
FreeLibros.meAhora
lector
ofrecen
hilos
posibilitan
concepto
procesos
se-
cuenciales
realizan
llamadas
sistema
bloqueo
ejemplo
disco
to-
das
formas
logran
paralelismo
llamadas
sistema
bloqueo
facilitan
proceso
programación
paralelismo
mejora
rendimiento
servidor
hilo
retiene
simple-
za
llamadas
sistema
bloqueo
pierde
rendimiento
tercer
método
logra
alto
rendimiento
paralelismo
utiliza
llamadas
interrupciones
bloqueo
ende
difícil
programar
figura
2-10
sintetizan
modelos
Modelo
Características
Hilos
Paralelismo
llamadas
sistema
bloqueo
Proceso
hilo
paralelismo
llamadas
sistema
bloqueo
Máquina
finitos
Paralelismo
llamadas
sistema
bloqueo
interrupciones
Figura
2-10
formas
construir
servidor
tercer
ejemplo
hilos
utilidad
aplicaciones
procesar
cantidades
datos
método
normal
leer
bloque
datos
procesarlo
des-
pués
escribirlo
nuevamente
salida
problema
disponibles
llamadas
sistema
bloqueo
proceso
bloquea
mientas
datos
entrando
saliendo
CPU
quede
inactiva
cálculos
duda
ineficiente
debemos
evitarlo
hilos
ofrecen
solución
proceso
estructurarse
hilo
entrada
hilo
procesamiento
hilo
salida
hilo
entrada
lee
datos
coloca
búfer
entra-
hilo
procesamiento
toma
datos
búfer
entrada
procesa
coloca
resultados
búfer
salida
búfer
salida
escribe
resultados
vuelta
disco
forma
operaciones
entrada
salida
procesamiento
ocurriendo
tiempo
modelo
funciona
llamada
sistema
bloquea
hilo
llamada
proceso
2.2.2
modelo
clásico
hilo
visto
útiles
hilos
utilizar
in-
vestigar
idea
cerca
modelo
procesos
basa
conceptos
indepen-
dientes
agrupamiento
recursos
ejecución
útil
separarlos
entran
hilos
analizaremos
modelo
clásico
hilos
modelo
hilos
Li-
nux
desaparece
línea
procesos
hilos
proceso
forma
agrupar
recursos
relacionados
proceso
espacio
direcciones
contiene
texto
datos
programa
recursos
incluir
archivos
abiertos
procesos
hijos
alarmas
pendientes
manejadores
señales
información
contable
reunirlos
forma
proceso
admi-
nistrarse
facilidad
100
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
101
concepto
proceso
hilo
ejecución
general
llama
hilo
hilo
contador
programa
registro
instrucción
ejecutar
continuación
registros
contienen
variables
trabajo
actuales
pila
contiene
historial
ejecución
conjunto
valores
procedimiento
llamado
devuelto
hilo
ejecutar
proceso
hilo
proceso
conceptos
distintos
tratarse
separado
pro-
cesos
utilizan
agrupar
recursos
entidades
planificadas
ejecución
CPU
agregan
hilos
modelo
procesos
permitir
lleven
cabo
ejecu-
ciones
entorno
proceso
independientes
Te-
ner
procesos
ejecutándose
paralelo
proceso
similar
procesos
ejecutándose
paralelo
computadora
caso
hilos
comparten
espacio
direcciones
recursos
procesos
comparten
memoria
física
discos
impresoras
recursos
hilos
propiedades
procesos
algu-
nas
llama
procesos
ligeros
término
multihilamiento
utiliza
descri-
bir
situación
permitir
hilos
proceso
vimos
capítulo
CPUs
soporte
directo
hardware
multihilamiento
permiten
conmuta-
ciones
hilos
ocurran
escala
tiempo
nanosegundos
figura
2-11(a
procesos
tradicionales
proceso
es-
pacio
direcciones
hilo
control
contrario
figura
2-11(b
vemos
proceso
hilos
control
casos
hilos
figura
2-11(a
opera
espacio
direcciones
distinto
figura
2-11(b
comparten
espacio
direcciones
Hilo
Hilo
Kernel
Kernel
Proceso
Proceso
Proceso
Proceso
Espacio
usuario
Espacio
kernel
Figura
2-11
procesos
hilo
proceso
hilos
ejecuta
proceso
multihilamiento
sistema
CPU
hilos
to-
man
turnos
ejecutarse
figura
2-1
vimos
funciona
multiprogramación
proce-
sos
conmutar
proceso
procesos
sistema
apariencia
www.FreeLibros.meprocesos
secuenciales
separados
ejecutándose
paralelo
multihilamientofunciona
CPU
conmuta
rápidamente
hilo
dando
ilusión
hilos
eje-
cutan
paralelo
CPU
lenta
hilos
limitados
cálculos
proceso
hilos
parecerían
ejecutarse
paralelo
CPU
tercio
velocidad
CPU
distintos
hilos
proceso
independientes
procesos
hi-
espacio
direcciones
significa
comparten
va-
riables
globales
hilo
acceder
dirección
memoria
espacio
direcciones
proceso
hilo
leer
escribir
borrar
pila
hilo
pro-
tección
hilos
imposible
necesario
diferencia
te-
ner
procesos
distintos
usuarios
hostiles
proceso
propiedad
usuario
supone
creado
hilos
puedan
coo-
perar
pelear
compartir
espacio
direcciones
hilos
compartir
conjunto
archivos
abiertos
procesos
hijos
alarmas
señales
etc.
muestra
figura
2-12
ende
organización
figura
2-11(a
utilizaría
procesos
estén
esencialmente
relacionados
figura
2-11(b
apropiada
hilos
realidad
formen
trabajo
estén
cooperando
forma
activa
estrecha
en-
tre
102
PROCESOS
HILOS
CAPÍTULO
Elementos
proceso
Elementos
hilo
Espacio
direcciones
Contador
programa
Variables
globales
Registros
Archivos
abiertos
Pila
Procesos
hijos
Alarmas
pendientes
Señales
manejadores
señales
Información
contable
Figura
2-12
columna
lista
elementos
compartidos
hilos
proceso
elementos
privados
hilo
elementos
columna
propiedades
proceso
hilo
ejem-
plo
hilo
abre
archivo
archivo
visible
hilos
proceso
leer
escribir
datos
lógico
proceso
unidad
administración
re-
cursos
hilo
hilo
tuviera
espacio
direcciones
archivos
abiertos
alarmas
pendientes
etcétera
proceso
separado
tratando
lograr
concepto
hilos
habilidad
hilos
ejecución
compartan
conjunto
recursos
puedan
trabajar
conjunto
tarea
proceso
tradicional
proceso
hilo
hilo
ejecución
bloqueado
listo
terminado
hilo
ejecución
CPU
momento
activo
hilo
bloqueado
esperando
evento
www
FreeLibros.meSECCIÓN
2.2
HILOS
103
desbloquee
ejemplo
hilo
realiza
llamada
sistema
leer
datos
teclado
bloquea
escribe
entrada
hilo
bloquearse
espera
ocurra
evento
externo
hilo
desbloquee
hilo
listo
programa
ejecutarse
hará
turno
transiciones
hilos
transiciones
procesos
ilustran
figura
2-2
importante
hilo
pila
figura
2-13
ilustra
pila
hilo
contiene
conjunto
valores
procedimiento
llamado
regresado
conjunto
valores
contiene
variables
locales
procedimiento
dirección
retorno
utilizar
terminado
llamada
procedimien-
to
ejemplo
procedimiento
llama
procedimiento
llama
procedimiento
ejecuta
conjuntos
valores
estarán
pila
general
hilo
llama
distintos
procedimientos
ende
historial
ejecución
di-
ferente
razón
hilo
necesita
pila
Kernel
Pila
hilo
Proceso
Hilo
3Hilo
Hilo
Pila
hilo
Figura
2-13
hilo
pila
multihilamiento
general
procesos
empiezan
hilo
presente
hilo
habilidad
crear
hilos
llamada
procedimiento
biblioteca
co-
mo
thread_create
Comúnmente
parámetro
thread_create
especifica
nombre
pro-
cedimiento
ejecute
hilo
necesario
especificar
acerca
espacio
direcciones
hilo
ejecuta
automática
espacio
direcciones
hilo
creador
hilos
jerárquicos
relación
padre-hijo
dicha
relación
hilos
iguales
relación
jerár-
quica
hilo
creador
generalmente
recibe
identificador
hilo
nombre
hilo
hilo
termina
trabajo
salir
llamada
procedimiento
bi-
blioteca
thread_exit
desaparece
planificarse
volver
ejecutar-
sistemas
hilos
hilo
esperar
hilo
específico
termine
www.FreeLibros.mela
llamada
procedimiento
ejemplo
thread_join
procedimiento
bloquea
hilo
llama-
dor
hilo
específico
terminado
aspecto
creación
terminación
hi-
parecido
creación
terminación
procesos
conteniendo
opciones
llamada
hilos
común
thread_yield
permite
hilo
entregar
voluntariamente
CPU
dejar
hilo
ejecute
Dicha
llamada
importante
inte-
rrupción
reloj
implementar
realidad
multiprogramación
procesos
ende
importante
hilos
amables
entreguen
voluntaria
CPU
hilos
oportunidad
ejecutarse
llamadas
permiten
hilo
espe-
rar
termine
trabajo
anuncie
terminó
trabajo
sucesi-
vamente
hilos
útiles
introducen
número
complicaciones
modelo
programación
empezar
considere
efectos
llamada
sistema
forkde
UNIX
proceso
padre
hilos
deberá
hijo
tenerlos
pro-
ceso
funcionar
forma
apropiada
esenciales
obstante
proceso
hijo
obtiene
tantos
hilos
padre
ocurre
hilo
padre
bloqueó
llamada
read
ejemplo
teclado
hilos
bloqueados
teclado
padre
hijo
escriba
línea
obtendrán
hi-
copia
padre
hijo
problema
conexiones
abiertas
red
clase
problemas
relaciona
hilos
comparten
estruc-
turas
datos
ocurre
hilo
cierra
archivo
leyendo
datos
Suponga
hilo
detecta
memoria
empieza
asignar
mitad
pro-
ceso
ocurre
conmutación
hilos
hilo
detecta
memoria
empieza
asignar
memoria
probable
asigne
memoria
Es-
tos
problemas
resolver
esfuerzo
necesario
pensar
diseñar
cuida-
do
programas
multihilamiento
funcionen
correcta
2.2.3
Hilos
POSIX
escribir
programas
hilos
portátiles
IEEE
definido
estándar
hilos
conocido
1003.1c
paquete
hilos
define
conoce
Pthreads
ma-
yoría
sistemas
UNIX
aceptan
paquete
estándar
define
60
llamadas
funcio-
nes
demasiadas
verlas
libro
describiremos
importantes
lector
idea
funcionan
llamadas
des-
cribiremos
listan
figura
2-14
hilos
Pthreads
propiedades
identificador
con-
registros
incluyendo
contador
programa
conjunto
atributos
almace-
nan
estructura
atributos
incluyen
tamaño
pila
parámetros
planificación
elementos
necesarios
utilizar
hilo
104
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
105
crear
hilo
utiliza
llamada
pthread_create
identificador
hilo
hilo
re-
cién
creado
devuelven
valor
función
llamada
intencionalmente
pareci-
llamada
sistema
fork
identificador
hilo
juega
papel
PID
medida
identificar
hilos
referenciados
llamadas
hilo
terminado
trabajo
asignó
terminar
llamando
pthread_e-
xit
llamada
detiene
hilo
libera
pila
hilo
necesita
esperar
termine
trabajo
salga
continuar
hilo
esperando
llama
pthread_join
esperar
hilo
específico
termine
identificador
hilo
hilo
esperar
proporciona
parámetro
sucede
hilo
lógicamente
bloqueado
siente
ejecu-
tado
tiempo
suficiente
desea
hilo
oportunidad
ejecutarse
lograr
obje-
tivo
llamada
pthread_yield
llamada
procesos
supone
procesos
extremo
competitivos
desea
CPU
tiem-
po
hilos
proceso
trabajando
conjunto
códi-
go
escrito
indudablemente
programador
desea
darles
hilos
oportunidad
siguientes
llamadas
hilos
tratan
atributos
Pthread_attr_init
crea
estructu-
ra
atributos
asociada
hilo
inicializa
valores
predeterminados
valores
prioridad
modificar
manipulación
campos
estructura
atributos
pthread_attr_destroy
elimina
estructura
atributos
hilo
liberando
me-
moria
afecta
hilos
utilizan
siguen
existiendo
idea
forma
funciona
Pthreads
considere
ejemplo
simple
figura
2-15
programa
principal
itera
NUMERO_DE_HILOS
creando
nue-
vo
hilo
iteración
anunciar
intención
falla
creación
hilo
imprime
mensaje
error
termina
crear
hilos
programa
principal
ter-
mina
crea
hilo
imprime
mensaje
línea
anunciándose
des-
pués
termina
orden
intercalan
diversos
mensajes
determinado
va-
riar
ejecución
programa
Llamada
hilo
Descripción
Pthread_create
Crea
hilo
Pthread_exit
Termina
hilo
llamador
Pthread_join
Espera
hilo
específico
termine
Pthread_yield
Libera
CPU
dejar
hilo
ejecute
Pthread_attr_init
Crea
inicializa
estructura
atributos
hilo
Pthread_attr_destroy
Elimina
estructura
atributos
hilo
Figura
2-14
llamadas
funciones
Pthreads
www.FreeLibros.me#include
pthread.h
include
stdio.h
include
stdlib.h
define
NUMERO_DE_HILOS
10
void
imprimir_hola_mundo(void
tid
funcion
imprime
identificador
hilo
termina
printf(“Hola
mundo
Saludos
hilo
d0
tid
pthread_exit(NULL
int
main(int
argc
char
argv
programa
principal
crea
10
hilos
termina
pthread_t
hilos[NUMERO_DE_HILOS
int
for(i=0
NUMERO_DE_HILOS
i++
printf(“Aqui
main
Creando
hilo
d0
pthread_create(%hilos[i
NULL
imprimir_hola_mundo
void
if
printf(“Ups
pthread_create
devolvió
codigo
error
d0
exit(-1
exit(NULL
Figura
2-15
programa
ejemplo
utiliza
hilos
llamadas
Pthreads
descritas
definitiva
únicas
analizaremos
hablar
procesos
sincronización
hilos
2.2.4
Implementación
hilos
espacio
usuario
formas
principales
implementar
paquete
hilos
espacio
usuario
ker-
nel
elección
controversial
implementación
híbrida
describiremos
métodos
ventajas
desventajas
método
colocar
paquete
hilos
completamente
espacio
usuario
ker-
nel
acerca
kernel
concierne
administrando
procesos
ordina-
rios
hilo
ventaja
obvia
paquete
hilos
nivel
usuario
implementarse
sistema
operativo
acepte
hilos
sistemas
operativos
106
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
107
solían
entrar
categoría
método
hi-
implementan
biblioteca
implementaciones
estructura
general
ilustra
figu-
ra
2-16(a
hilos
ejecutan
sistema
tiempo
ejecución
co-
lección
procedimientos
administran
hilos
visto
pthread_create
pthread_exit
pthread_join
pthread_yield
general
Proceso
ProcesoHilo
Hilo
Tabla
procesos
Tabla
procesos
Tabla
hilos
Tabla
hilos
Sistema
tiempo
ejecución
Espacio
kernel
Espacio
usuario
KernelKernel
Figura
2-16
paquete
hilos
nivel
usuario
paquete
hilos
admi-
nistrado
kernel
hilos
administran
espacio
usuario
proceso
necesita
tabla
hilos
privada
hilos
proceso
tabla
similar
tabla
procesos
kernel
propiedades
hilo
contador
programa
apuntador
pila
registros
etc.
tabla
hilos
administrada
sistema
tiempo
ejecución
hilo
pasa
listo
bloqueado
información
necesaria
reiniciarlo
almacena
tabla
hilos
forma
exacta
kernel
almacena
información
acerca
procesos
tabla
procesos
hilo
ponerlo
bloqueado
forma
local
ejem-
plo
esperar
hilo
proceso
complete
trabajo
llama
procedimien-
to
sistema
tiempo
ejecución
procedimiento
comprueba
hilo
ponerse
bloqueado
almacena
registros
hilo
registros
tabla
hilos
busca
tabla
hilo
listo
ejecutarse
vuelve
cargar
registros
máquina
valores
guardados
hilo
conmutan
apuntador
pila
contador
programa
hilo
vuelve
vida
automática
máquina
instrucción
guardar
registros
cargarlos
conmutación
hilos
instrucciones
conmutación
hilos
orden
magnitud
www.FreeLibros.meveloz
trap
kernel
sólido
argumento
favor
paquetes
hilos
nivel
usuario
diferencia
clave
procesos
hilo
termina
ejecutarse
momento
ejemplo
llama
thread_yield
código
thread_yield
guar-
información
hilo
tabla
hilos
llamar
plani-
ficador
hilos
elegir
hilo
ejecutarlo
procedimiento
guarda
hilo
planificador
procedimientos
locales
eficiente
invocarlos
llamada
kernel
cuestiones
necesita
trap
conmutación
contexto
memoria
caché
necesita
vaciarse
etc.
planificación
hilos
rápida
hilos
nivel
usuario
ventajas
Permiten
proceso
algoritmo
planificación
personalizado
ejemplo
aplicaciones
hilo
recolector
basura
ventaja
preocuparse
hilo
de-
momento
inconveniente
escalan
hilos
kernel
requie-
ren
duda
espacio
tabla
pila
kernel
problema
cantidad
hilos
rendimiento
paquetes
hilos
nivel
usuario
pro-
blemas
importantes
implementan
llamadas
sis-
tema
bloqueo
Suponga
hilo
lee
teclado
oprimido
tecla
inaceptable
permitir
hilo
realice
llamada
sistema
detendrá
to-
hilos
principales
objetivos
hilos
lugar
permitir
utilizara
llamadas
bloqueo
evitar
hilo
bloqueado
afectara
de-
llamadas
sistema
bloqueo
difícil
lograr
objetivo
problemas
llamadas
sistema
cambiar
quedaran
bloqueo
ejem-
plo
readen
teclado
devolvería
bytes
hubiera
caracteres
búfer
in-
conveniente
requerir
cambios
sistema
operativo
argumentos
hilos
nivel
usuario
precisamente
podían
ejecutar
sistemas
operativos
existen-
tes
cambia
semántica
read
requerirán
cambios
programas
usuario
alternativa
antemano
llamada
bloquear
al-
gunas
versiones
UNIX
llamada
sistema
select
permite
procedimiento
llamada
llamada
readrealizará
bloqueo
llama-
presente
procedimiento
biblioteca
read
reemplazar
pri-
mero
realice
llamada
selecty
realice
llamada
readsi
seguro
bloqueo
llamada
readva
bloquear
eje-
cuta
hilo
próxima
sistema
tiempo
ejecución
obtenga
control
com-
probar
llamada
reades
segura
método
requiere
vuelvan
escribir
partes
biblioteca
llamadas
sistema
ineficiente
elegante
opción
código
colocado
llamada
sistema
encarga
compro-
bación
conoce
envoltura
similar
problema
llamadas
sistema
bloqueo
problema
fallos
página
capítulo
estudiaremos
tema
basta
computadoras
108
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
109
configurar
forma
programa
encuentre
memoria
pro-
grama
llama
salta
instrucción
esté
memoria
ocurre
fallo
página
siste-
ma
operativo
obtiene
instrucción
faltante
instrucciones
aledañas
disco
conoce
fallo
página
proceso
bloquea
instrucción
necesaria
localiza
lee
hilo
produce
fallo
página
kernel
siquiera
existencia
hilos
bloquea
naturalmente
proceso
complete
operación
hilos
pudieran
ejecutados
problema
paquetes
hilos
nivel
usuario
hilo
empieza
ejecutar-
hilo
proceso
ejecutará
renuncie
volun-
taria
CPU
proceso
interrupciones
reloj
imposible
planificar
procesos
formato
round
robin
tomando
turnos
hilo
en-
tre
sistema
tiempo
ejecución
voluntad
planificador
opor-
tunidad
solución
problema
hilos
ejecutan
forma
indefinida
sistema
tiempo
ejecución
solicite
señal
reloj
interrupción
pa-
ra
control
crudo
complicado
programa
po-
sibles
interrupciones
periódicas
reloj
frecuencia
alta
sobrecarga
considerable
hilo
requerir
inte-
rrupción
reloj
interfiriendo
sistema
tiempo
ejecución
reloj
argumento
realidad
devastador
hilos
nivel
usuario
general
programadores
desean
hilos
precisamente
aplicaciones
blo-
quean
frecuencia
ejemplo
servidor
Web
multihilado
hilos
rea-
lizando
llamadas
sistema
forma
constante
ocurre
trap
kernel
lleve
cabo
llamada
sistema
cuesta
kernel
conmutar
hilos
es-
tá
bloqueado
kernel
elimina
necesidad
llamadas
sistema
selecten
forma
constante
comprueben
llamadas
sistema
read
seguras
aplicaciones
esencia
completamente
limitadas
CPU
raras
bloquean
objetivo
hilos
propondría
seriedad
calcular
números
primos
jugar
ajedrez
utilizando
hilos
obtiene
ventaja
es-
ta
forma
2.2.5
Implementación
hilos
kernel
considerar
caso
kernel
acerca
hilos
administra
necesita
sistema
tiempo
ejecución
acciones
muestra
figura
2-16(b
tabla
hilos
proceso
kernel
tabla
hilos
hilos
sistema
hilo
desea
crear
hilo
destruir
existente
realiza
llamada
kernel
encarga
creación
destrucción
actualización
tabla
hilos
kernel
tabla
hilos
kernel
contiene
registros
información
hilo
información
hilos
nivel
usuario
mantiene
ker-
nel
espacio
usuario
sistema
tiempo
ejecución
infor-
mación
subconjunto
información
mantienen
tradicionalmente
kernels
acerca
www.FreeLibros.mesus
procesos
hilo
proceso
kernel
mantiene
tabla
procesos
tradicional
procesos
llamadas
bloquear
hilo
implementan
llamadas
sistema
costo
considerablemente
llamada
procedimiento
sistema
tiempo
eje-
cución
hilo
bloquea
kernel
decida
ejecutar
hilo
mis-
mo
proceso
listo
hilo
proceso
distinto
hilos
nivel
usuario
sistema
tiempo
ejecución
ejecuta
hilos
proceso
kernel
quita
CPU
hilos
ejecutar
costo
considerablemente
crear
destruir
hilos
kernel
siste-
optan
método
ambientalmente
correcto
reciclando
hilos
destruye
hi-
marca
ejecutable
estructuras
datos
kernel
ven
afectadas
forma
crearse
hilo
reactiva
aho-
rra
sobrecarga
reciclaje
hilos
hilos
nivel
usuario
sobrecarga
administración
hilos
menor
incentivos
hilos
kernel
requieren
llamadas
sistema
bloqueo
hi-
proceso
produce
fallo
página
kernel
comprobar
facilidad
proceso
hilos
puedan
ejecutarse
ejecuta
espera
traiga
página
requerida
disco
principal
desventaja
costo
llamada
sistema
considerable
operaciones
hilos
creación
terminación
ejem-
plo
comunes
incurrirá
sobrecarga
hilos
kernel
resuelven
problemas
ejemplo
ocurre
proceso
multihilamiento
utiliza
llamada
forkpara
crear
proceso
nue-
vo
proceso
hilos
casos
elec-
ción
depende
proceso
planee
continuación
llamar
execpara
iniciar
programa
probablemente
elección
correcta
hilo
continúa
ejecución
reproducir
cuestión
relacionada
señales
Recuerde
señales
envían
proce-
sos
hilos
modelo
clásico
entra
señal
hilo
ha-
cerse
cargo
hilos
puedan
registrar
interés
señales
llegue
señal
envíe
hilo
esperando
ocurre
hilos
registran
señal
problemas
introducen
hi-
2.2.6
Implementaciones
híbridas
investigado
formas
tratar
combinar
ventajas
hilos
nivel
usuario
hilos
nivel
kernel
formas
utilizar
hilos
nivel
kernel
multiplexar
hilos
nivel
usuario
hilos
nivel
kernel
muestra
figu-
ra
2-17
utiliza
método
programador
determinar
hilos
kernel
utilizar
hilos
nivel
usuario
multiplexar
modelo
proporciona
úl-
timo
flexibilidad
110
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
111
método
kernel
consciente
hilos
nivel
kernel
planifica
Al-
gunos
hilos
hilos
nivel
usuario
multiplexados
hilos
nivel
usuario
crean
destruyen
planifican
forma
hilos
nivel
usua-
rio
proceso
ejecuta
sistema
operativo
capacidad
multihilamiento
modelo
hilo
nivel
kernel
conjunto
hilos
nivel
usuario
toman
turnos
utilizarlo
2.2.7
Activaciones
planificador
hilos
kernel
mejores
hilos
nivel
usuario
formas
clave
tam-
bién
duda
lentos
consecuencia
investigadores
buscado
formas
me-
jorar
situación
renunciar
propiedades
positivas
continuación
describimos
métodos
ideado
Anderson
colaboradores
1992
conocido
activaciones
planifica-
dor
trabajo
relacionado
describe
obras
Edler
colaboradores
1988
Scott
colaboradores
1990
objetivos
trabajo
activación
planificador
imitar
funcionalidad
hilos
kernel
rendimiento
flexibilidad
general
asocian
paquetes
hilos
implementados
espacio
usuario
especial
hilos
usuario
llamadas
especiales
sistema
bloqueo
comprobar
antemano
seguro
llamadas
sistema
hilo
bloquea
lla-
mada
sistema
fallo
página
ejecutar
hilos
proce-
so
listo
eficiencia
obtiene
evitando
transiciones
innecesarias
espacios
usuario
kernel
ejemplo
hilo
bloquea
espera
hilo
realice
acción
razón
involucrar
kernel
ahorra
sobrecarga
transición
kernel
usua-
rio
sistema
tiempo
ejecución
espacio
usuario
bloquear
hilo
sincronizador
programar
hilos
usuario
hilo
kernel
Espacio
usuario
Espacio
kernelHilo
kernelKernel
Figura
2-17
Multiplexaje
hilos
nivel
usuario
hilos
nivel
kernel
www
FreeLibros.meCuando
utilizan
activaciones
planificador
kernel
asigna
número
procesa-
dores
virtuales
proceso
deja
sistema
tiempo
ejecución
espacio
usuario
asigne
hilos
procesadores
mecanismo
utilizar
multiprocesador
procesadores
virtuales
CPUs
reales
principio
número
procesadores
virtuales
asigna
proceso
proceso
pedir
devolver
pro-
cesadores
necesita
kernel
obtener
vuelta
procesadores
virtuales
estén
asignados
asignarlos
procesos
tengan
necesidad
idea
básica
esquema
funcione
kernel
hilo
bloqueado
ejemplo
ejecutar
llamada
sistema
bloqueo
ocasionar
fa-
llo
página
notifica
sistema
tiempo
ejecución
proceso
pasándole
pará-
metros
pila
número
hilo
cuestión
descripción
evento
ocurrió
notificación
kernel
activa
sistema
tiempo
ejecución
dirección
inicial
conocida
similar
señal
UNIX
mecanismo
conoce
llamada
as-
cendente
upcall
activa
forma
sistema
tiempo
ejecución
replanificar
hilos
comúnmente
marca
hilo
actual
bloqueado
tomando
hilo
lista
hilos
listos
establece
registros
reinicia
kernel
detecta
hilo
original
ejecutar
ejemplo
canal
trataba
leer
contiene
datos
página
falló
trajo
disco
realiza
llamada
ascendente
sistema
tiem-
po
ejecución
informarle
evento
sistema
tiempo
ejecución
discreción
reiniciar
hilo
bloqueado
inmediato
colocarlo
lista
hilos
listos
pa-
ra
ejecutarlo
ocurre
interrupción
hardware
hilo
usuario
ejecuta
CPU
interrumpió
conmuta
kernel
manejador
interrupciones
termina
in-
terrupción
producida
evento
interés
proceso
interrumpido
terminación
operación
proceso
coloca
hilo
interrumpido
vuelta
interrupción
obstante
proceso
interesado
in-
terrupción
llegada
página
requiere
hilos
procesador
hilo
interrumpido
reinicia
hilo
interrumpido
suspende
sistema
tiem-
po
ejecución
inicia
CPU
virtual
hilo
interrumpido
pila
Des-
pués
responsabilidad
sistema
tiempo
ejecución
decidir
hilo
planificar
CPU
interrumpió
acaba
pasar
listo
opción
objeción
activaciones
planificador
dependencia
fundamental
llama-
das
ascendentes
concepto
viola
estructura
inherente
sistema
capas
general
capa
ofrece
servicios
capa
llamar
capa
pue-
llamar
procedimientos
capa
llamadas
ascendentes
siguen
principio
fundamental
2.2.8
Hilos
emergentes
hilos
utilizan
frecuencia
sistemas
distribuidos
importante
ejemplo
for-
ma
manejan
mensajes
entrantes
ejemplo
peticiones
servicio
método
tradicional
proceso
hilo
bloqueado
llamada
sistema
receive
112
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.2
HILOS
113
espere
mensaje
entrante
llega
mensaje
acepta
desempaqueta
examina
con-
procesa
utilizar
método
completamente
distinto
lle-
gada
mensaje
sistema
cree
hilo
manejar
mensaje
hilo
conoce
hilo
emergente
pop-up
thread)y
ilustra
figura
2-18
ventaja
cla-
ve
hilos
emergentes
historial
registros
pila
etcétera
necesario
restaurar
empieza
cero
idéntico
crear
hilo
rapidez
hilo
recibe
mensaje
entrante
proce-
sar
resultado
utilizar
hilos
emergentes
latencia
llegada
mensaje
ini-
cio
procesamiento
baja
Red
Mensaje
entrante
Hilo
emergente
creado
manejar
mensaje
entrante
Hilo
existente
Proceso
Figura
2.18
Creación
hilo
llega
mensaje
lle-
gue
mensaje
llega
mensaje
necesaria
planeación
anticipada
utilizan
hilos
emergentes
ejemplo
proceso
ejecuta
hilo
sistema
acepta
hilos
ejecutan
contexto
kernel
hilo
ejecutar
explica
mostrado
kernel
figura
2-18
hilo
emergente
ejecute
espacio
kernel
general
rápido
sencillo
colocarlo
espacio
usuario
hilo
emergente
espacio
kernel
acce-
der
facilidad
tablas
kernel
dispositivos
necesarios
procesamiento
interrupciones
hilo
kernel
errores
daño
hilo
usuario
errores
ejemplo
ejecuta
tiempo
quitarlo
datos
entrantes
perder
www
FreeLibros.me2.2.9
Conversión
código
hilado
simple
multihilado
programas
existentes
escribieron
procesos
hilo
difícil
convertir
programas
utilicen
multihilamiento
parecer
princi-
pio
continuación
analizaremos
obstáculos
empezar
código
hilo
normalmente
consiste
procedimientos
proceso
variables
locales
variables
globales
parámetros
variables
parámetros
locales
ocasionan
problemas
variables
globales
hilo
globales
programa
problema
variables
globales
sentido
procedimientos
hilo
utilizan
utilizar
variable
global
hilos
deberían
lógica
dejarlas
paz
ejemplo
considere
variable
errno
mantiene
UNIX
proceso
hilo
realiza
llamada
sistema
falla
código
error
coloca
errno
figura
2-19
hilo
ejecuta
llamada
sistema
access
averiguar
permiso
acceder
ar-
chivo
sistema
operativo
devuelve
respuesta
variable
global
errno
con-
trol
regresa
hilo
oportunidad
leer
errno
planificador
decide
hilo
suficiente
tiempo
CPU
momento
decide
conmutar
hilo
hilo
ejecuta
llamada
open
falla
sobrescriba
valor
errno
código
acceso
hilo
pierde
hilo
continúe
lee-
rá
valor
incorrecto
comportará
incorrecta
114
PROCESOS
HILOS
CAPÍTULO
Hilo
Hilo
Access
asigna
errno
inspecciona
errno
Open
sobrescribe
errno
Tiempo
Figura
2-19
Conflictos
hilos
variable
global
soluciones
posibles
problema
prohibir
variables
globales
completo
ideal
parezca
conveniente
entra
conflicto
softwa-
re
existente
solución
asignar
hilo
variables
globales
privadas
muestra
figura
2-20
forma
hilo
copia
privada
errno
variables
globales
evitan
conflictos
efecto
decisión
crea
nivel
al-
cance
variables
visibles
procedimientos
hilo
www
FreeLibros.meSECCIÓN
2.2
HILOS
115
niveles
alcance
existentes
variables
visibles
procedimiento
variables
visibles
partes
programa
Código
hilo
Código
hilo
Pila
hilo
Pila
hilo
Variables
globales
hilo
Variables
globales
hilo
Figura
2-20
hilos
variables
globales
privadas
acceder
variables
globales
privadas
problemático
mayo-
ría
lenguajes
programación
expresar
variables
locales
va-
riables
globales
formas
intermedias
asignar
trozo
memoria
variables
globales
pasarlo
procedimiento
hilo
parámetro
adicional
solución
elegante
funciona
alternativa
introducirse
procedimientos
biblioteca
crear
es-
tablecer
leer
variables
globales
nivel
hilo
llamada
mues-
tra
continuación
create_global(“bufptr
llamada
asigna
espacio
almacenamiento
apuntador
llamado
bufptr
heap
pila
memoria
dinámica
área
especial
almacenamiento
reservada
hilo
invocador
importar
asigne
espacio
almacenamiento
hilo
invocador
acceso
variable
global
hilo
crea
variable
global
nombre
obtiene
ubicación
distinta
almacenamiento
conflicto
existente
necesitan
llamadas
acceder
variables
globales
escribirlas
leerlas
escribir
set_global(“bufptr
buf
suficiente
llamada
almacena
valor
apuntador
ubicación
almacenamiento
creó
previamente
llamada
create_global
leer
variable
global
lla-
mada
bufptr
read_global(“bufptr
llamada
devuelve
dirección
almacenada
variable
global
acce-
der
datos
www
FreeLibros.meEl
problema
convertir
programa
hilo
programa
múltiples
hilos
procedimientos
biblioteca
re-entrantes
diseñaron
pa-
ra
llamada
procedimiento
llamada
terminado
ejemplo
programar
envío
mensaje
red
ensam-
blando
mensaje
búfer
fijo
biblioteca
trap
kernel
pa-
ra
enviarlo
ocurre
hilo
ensamblado
mensaje
búfer
interrupción
reloj
obliga
haga
conmutación
hilo
inmediato
sobrescribe
bú-
fer
mensaje
similar
procedimientos
asignación
memoria
malloc
UNIX
mantienen
tablas
cruciales
acerca
memoria
ejemplo
lista
ligada
trozos
dis-
ponibles
memoria
procedimiento
mallocestá
ocupado
actualizando
listas
pue-
den
temporalmente
inconsistente
apuntadores
apuntan
ocurre
conmutación
hilos
tablas
inconsistentes
llega
llamada
hilo
distinto
utilice
apuntador
inválido
produzca
fallo
programa
corregir
problemas
efectiva
necesario
reescribir
biblioteca
com-
pleta
insignificante
solución
distinta
proporcionar
procedimiento
envoltura
fije
bit
pa-
ra
marcar
librería
estuviera
hilo
intenta
procedimiento
biblio-
teca
completado
llamada
bloquea
método
funcione
elimina
paralelismo
potencial
considere
señales
señales
lógicamente
específicas
hilo
ejemplo
hilo
llama
alarm
sentido
señal
resultante
hilo
llamada
hilos
implementan
totalmente
es-
pacio
usuario
kernel
siquiera
acerca
hilos
dirigir
señal
hilo
correcto
complicación
adicional
proceso
alarma
pendiente
hilos
llamar
alarm
independiente
señales
interrupción
teclado
específicas
hilo
de-
be
atraparlas
hilo
designado
hilos
hilo
emergente
recién
creado
ocurre
hilo
cambia
manejadores
señales
indicar
hilos
ocurre
hilo
desea
atrapar
señal
específica
ejemplo
usuario
opri-
CTRL-C
hilo
desea
señal
terminar
proceso
situación
surgir
hilos
ejecutan
procedimientos
biblioteca
estándar
escritos
usua-
rio
evidente
deseos
incompatibles
general
señales
difíci-
manejar
entorno
hilo
Cambiar
entorno
multihilamiento
facilita
manejo
problema
introducen
hilos
administración
pila
siste-
pila
proceso
desborda
kernel
proporciona
pila
proceso
automática
proceso
múltiples
hilos
pilas
kernel
tamaño
aumente
automá-
tica
ocurra
fallo
pila
siquiera
detectar
fallo
memo-
ria
relacionado
aumento
tamaño
pila
hilo
duda
problemas
imposibles
resolver
muestran
resolverán
introducir
hilos
sistema
existente
rediseño
considerable
sistema
116
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
117
redefinir
semántica
llamadas
sistema
reescribir
bibliotecas
cuan-
do
forma
mantenga
compatibilidad
atrás
programas
existentes
caso
limitante
proceso
hilo
obtener
in-
formación
adicional
acerca
hilos
consulte
Hauser
colaboradores
1993
Marsh
colabo-
radores
1991
2.3
COMUNICACIÓN
PROCESOS
frecuencia
procesos
necesitan
comunicarse
procesos
ejemplo
cana-
lización
shell
salida
proceso
pasar
proceso
sucesivamen-
ende
necesidad
comunicación
procesos
preferencia
forma
estructurada
utilizar
interrupciones
siguientes
secciones
analizaremos
cuestiones
relacionadas
comunicación
procesos
IPC
resumen
cuestiones
alude
proceso
pue-
pasar
información
relacionada
procesos
interpongan
ejemplo
procesos
sistema
reservaciones
aerolínea
obtener
asiento
avión
cliente
distinto
acerca
obtener
secuencia
apropiada
dependencias
presentes
proceso
produce
datos
proceso
imprime
esperar
produ-
cido
datos
empezar
imprimir
sección
analizaremos
cues-
tiones
importante
mencionar
cuestiones
aplican
forma
hilos
paso
información
fácil
hilos
comparten
espacio
direcciones
común
hilos
distintos
espacios
direcciones
necesitan
comunicarse
entran
categoría
procesos
comunicación
evitar
hilo
en-
tre
conflicto
obtener
secuencia
apropiada
aplican
forma
hi-
problemas
aplican
soluciones
continuación
veremos
problema
contexto
procesos
aplican
problemas
soluciones
hilos
2.3.1
Condiciones
carrera
sistemas
operativos
procesos
trabajan
conjunto
compartir
es-
pacio
almacenamiento
leer
escribir
datos
almacenamiento
compartido
memoria
principal
posiblemente
estructura
datos
kernel
archivo
compartido
ubicación
memoria
compartida
cambia
naturaleza
co-
municación
problemas
surgen
funciona
comunicación
procesos
práctica
consideremos
ejemplo
simple
común
spooler
impresión
pro-
ceso
desea
imprimir
archivo
introduce
nombre
archivo
directorio
spooler
espe-
cial
proceso
demonio
impresión
comprueba
forma
periódica
archivos
deban
imprimirse
imprime
elimina
nombres
directorio
www
FreeLibros.meImagine
directorio
spooler
cantidad
ranuras
numera-
das
capaz
contener
nombre
archivo
Imagine
tam-
bién
variables
compartidas
sal
apunta
archivo
imprimir
ent
apunta
ranura
libre
directorio
variables
mantenerse
archivo
palabras
disponible
procesos
momento
ranuras
vacías
impreso
archivos
ranuras
llenas
nombres
archivos
cola
impresión
simultánea
procesos
deciden
desean
cola
archivo
imprimirlo
situación
muestra
figura
2-21
118
PROCESOS
HILOS
CAPÍTULO
abc
prog.c
prog.n
Proceso
sal
ent
Proceso
Directorio
spooler
Figura
2-21
procesos
desean
acceder
memoria
compartida
tiempo
jurisdicciones
aplica
ley
Murphy†
ocurrir
pro-
ceso
lee
ent
guarda
valor
variable
local
llamada
siguiente_ranura_libre
Justo
en-
tonces
ocurre
interrupción
reloj
CPU
decide
proceso
ejecutado
tiempo
suficiente
conmuta
proceso
B.
proceso
lee
ent
ob-
forma
almacena
variable
local
siguiente_ranura_libre
instan-
procesos
piensan
ranura
libre
proceso
continúa
ejecución
Almacena
nombre
archivo
ranura
actualiza
ent
realiza
tareas
momento
proceso
ejecuta
partiendo
lugar
Busca
siguiente_ranura_libre
escribe
nombre
archivo
ranura
borrando
nombre
proceso
acaba
calcula
siguiente_ranura_libre
fija
ent
directorio
spooler
internamente
consistente
salir
hará
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
119
demonio
impresión
detectará
incorrecto
proceso
recibirá
nin-
guna
salida
usuario
esperará
cuarto
impresora
años
deseando
vehemencia
obtener
salida
llegará
Situaciones
procesos
leyendo
es-
cribiendo
datos
compartidos
resultado
depende
ejecuta
exactamen-
conocen
condiciones
carrera
Depurar
programas
contienen
condiciones
carrera
divertido
resultados
mayoría
ejecuciones
prueba
momento
frecuente
ocurrirá
extraño
inexplicable
2.3.2
Regiones
críticas
evitamos
condiciones
carrera
clave
evitar
problemas
situaciones
involucran
memoria
compartida
archivos
compartidos
de-
compartido
buscar
prohibir
proceso
lea
escriba
datos
compartidos
tiempo
palabras
necesitamos
exclusión
mutua
forma
asegurar
proceso
utilizando
variable
archivo
compartido
procesos
excluirán
dificultad
mencionada
ocurrió
proceso
empezó
utilizar
variables
compartidas
proceso
ter-
minara
elección
operaciones
primitivas
apropiadas
lograr
exclusión
mutua
cuestión
diseño
importante
sistema
operativo
tema
analizaremos
detalle
siguientes
secciones
problema
evitar
condiciones
carrera
formular
abs-
tracta
tiempo
proceso
ocupado
realizando
cálculos
internos
cosas
producen
condiciones
carrera
proceso
acceder
me-
moria
compartida
archivos
compartidos
cosas
críticas
producir
carre-
ras
programa
accede
memoria
compartida
conoce
reg
ión
crítica
sección
crítica
pudiéramos
ordenar
cosas
procesos
estu-
vieran
regiones
críticas
tiempo
podríamos
evitar
carreras
requerimiento
evita
condiciones
carrera
suficiente
pro-
cesos
paralelo
cooperen
correcta
eficiente
utilizar
datos
compartidos
Necesi-
tamos
cumplir
condiciones
solución
procesos
simultánea
regiones
críticas
hacerse
suposiciones
acerca
velocidades
número
CPUs
proceso
ejecute
región
crítica
bloquear
procesos
proceso
esperar
entrar
región
crítica
sentido
abstracto
comportamiento
deseamos
muestra
figura
2-22
proceso
entra
región
crítica
tiempo
tiempo
T2
proceso
intenta
entrar
región
crítica
falla
proceso
www.FreeLibros.meregión
crítica
permite
consecuencia
suspende
temporalmente
has-
ta
tiempo
sale
región
crítica
permite
entrar
inmediato
momento
sale
regresamos
situación
original
procesos
regiones
críticas
120
PROCESOS
HILOS
CAPÍTULO
entra
región
crítica
sale
región
crítica
intenta
entrar
región
crítica
entra
región
crítica
T1
T2
T3
T4
Proceso
Proceso
bloquea
sale
región
crítica
Tiempo
Figura
2-22
Exclusión
mutua
regiones
críticas
2.3.3
Exclusión
mutua
espera
ocupada
sección
examinaremos
proposiciones
lograr
exclusión
mutua
proceso
esté
ocupado
actualizando
memoria
compartida
región
crítica
proceso
entrar
región
crítica
ocasionar
problemas
Deshabilitando
interrupciones
sistema
procesador
solución
simple
proceso
deshabilite
interrupciones
justo
entrar
región
crítica
rehabilite
justo
salir
interrupciones
deshabilitadas
ocurrir
interrupciones
reloj
to-
do
CPU
conmuta
proceso
resultado
interrupción
reloj
tipo
interrupciones
desactivadas
CPU
conmutará
proceso
ende
proceso
deshabilitado
interrupciones
examinar
actualizar
memoria
compartida
temor
proceso
intervenga
general
método
atractivo
conveniente
procesos
usuario
desactivar
interrupciones
Suponga
hiciera
volviera
activar
sistema
sistema
multiprocesador
posiblemente
CPUs
deshabilitar
interrupciones
ve
afectada
CPU
ejecutó
instrucción
disable
continuarán
ejecutándose
acceder
me-
moria
compartida
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
121
frecuencia
conveniente
kernel
deshabilitar
interrupcio-
nes
instrucciones
actualiza
variables
listas
ejemplo
ocurriera
interrupción
lista
procesos
inconsistente
pro-
ducirse
condiciones
carrera
conclusión
deshabilitar
interrupciones
técnica
útil
sistema
operativo
apropiada
mecanismo
exclu-
sión
mutua
general
procesos
usuario
posibilidad
lograr
exclusión
mutua
deshabilitar
interrupciones
kernel
disminuyendo
creciente
número
chips
multinúcleo
encuentran
PCs
rendimiento
común
núcleos
máquinas
actuales
alto
rendimiento
16
multinúcleo
sistema
multiprocesadores
deshabilitar
interrupciones
CPU
evita
CPUs
interfieran
operaciones
CPU
realizando
consecuen-
cia
requieren
esquemas
sofisticados
Variables
candado
intento
busquemos
solución
software
Considere
variable
compartida
candado
principio
proceso
desea
entrar
región
crí-
tica
evalúa
candado
candado
proceso
fija
entra
región
crítica
candado
espera
candado
haga
ende
signifi-
ca
proceso
región
crítica
significa
proceso
re-
gión
crítica
desgracia
idea
contiene
exactamente
error
fatal
vimos
directorio
spooler
Suponga
proceso
lee
candado
ve
fijar
can-
proceso
planifica
ejecutarse
fija
candado
proceso
ejecuta
fija
candado
procesos
encontrarán
regiones
críticas
tiempo
lector
pensar
resolver
problema
leemos
valor
candado
verificamos
justo
almacenar
valor
realidad
ayuda
condición
carrera
produce
proceso
modifica
candado
justo
proceso
terminado
verificación
Alternancia
estricta
figura
2-23
muestra
solución
problema
exclusión
mutua
frag-
mento
programa
libro
escrito
C.
elegi-
mos
lenguaje
sistemas
operativos
reales
escriben
ocasiones
C++
lenguajes
Java
Modula
Pascal
po-
tente
eficiente
predecible
características
cruciales
escribir
sistemas
operativos
ejem-
plo
Java
predecible
agotar
espacio
almacenamiento
momento
crítico
tendría
invocar
recolector
basura
reclamar
memoria
mo-
mento
verdaderamente
inoportuno
ocurrir
recolección
www.FreeLibros.mede
basura
comparación
cuantitativa
C++
Java
lenguajes
proporciona
Prechelt
2000
while
TRUE
while
TRUE
while
turno
ciclo
while
turno
ciclo
region_critica
region_critica
turno
turno
region_nocritica
region_nocritica
Figura
2-23
solución
propuesta
problema
región
crítica
Proce-
so
Proceso
casos
asegúrese
signos
punto
coma
terminan
instrucciones
while
figura
2-23
variable
entera
turno
principio
acerca
proceso
toca
entrar
región
crítica
examinar
actualizar
memoria
compartida
principio
proceso
inspecciona
turno
descubre
entra
región
crítica
proceso
des-
cubre
queda
ciclo
estrecho
evaluando
turno
forma
continua
convierte
acción
evaluar
forma
continua
variable
aparez-
ca
valor
conoce
espera
ocupada
general
evitar
desperdicia
tiempo
CPU
espera
ocupada
utiliza
expectativa
razonable
espera
corta
candado
utiliza
espera
ocupada
conoce
candado
giro
proceso
sale
región
crítica
establece
turno
permitir
proceso
región
crítica
Suponga
proceso
sale
rápidamente
región
crítica
ma-
nera
procesos
encuentran
regiones
críticas
turno
establecido
Aho-
ra
proceso
ejecuta
ciclo
rápidamente
saliendo
región
crítica
estableciendo
turno
punto
turno
procesos
ejecutando
regiones
críticas
proceso
termina
región
crítica
regresa
superior
ci-
clo
desgracia
entrar
región
crítica
turno
proce-
so
ocupado
región
crítica
proceso
espera
ciclo
whilehasta
pro-
ceso
establezca
turno
forma
distinta
tomar
turnos
idea
procesos
lento
situación
viola
condición
establecida
proceso
bloqueado
proceso
región
crítica
olviendo
directorio
spooler
mencionado
asociamos
región
crítica
lectura
escritura
directorio
spooler
proceso
imprimir
archivo
proceso
cosa
solución
requiere
procesos
alternen
estricta
entrar
regiones
críticas
ejemplo
archivos
cola
impresión
archivos
cola
tiempo
algoritmo
evita
condiciones
carrera
realidad
candidato
serio
solución
viola
condición
122
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
123
Solución
Peterson
combinar
idea
tomar
turnos
idea
variables
candado
variables
ad-
vertencia
matemático
holandés
llamado
T.
Dekker
idear
solución
soft-
ware
problema
exclusión
mutua
requiere
alternancia
estricta
análisis
algoritmo
Dekker
consulte
Dijkstra
1965
1981
G.L.
Peterson
descubrió
simple
lograr
exclusión
mu-
tua
solución
Dekker
obsoleta
algoritmo
Peterson
muestra
figura
2-24
algoritmo
consiste
procedimientos
escritos
ANSI
significa
suministrar
prototipos
funciones
definidas
utilizadas
ahorrar
espacio
mostraremos
prototipos
ejemplo
siguientes
define
FALSE
define
TRUE
define
número
procesos
int
turno
turno
int
interesado[N
principio
valores
FALSE
void
entrar_region(int
proceso
proceso
int
número
proceso
proceso
opuesto
proceso
interesado[proceso
TRUE
muestra
interesado
turno
proceso
establece
bandera
while
turno
proceso
interesado[otro
TRUE
instrucción
nula
void
salir_region(int
proceso
proceso
saliendo
interesado[proceso
FALSE
indica
salió
región
crítica
Figura
2-24
Solución
Peterson
lograr
exclusión
mutua
utilizar
variables
compartidas
entrar
región
crítica
proceso
llama
entrar_region
número
proceso
parámetro
lla-
mada
hará
espere
necesario
seguro
entrar
terminado
variables
compartidas
proceso
llama
salir_region
indicar
terminado
permitir
procesos
entren
desea
Veamos
funciona
solución
principio
proceso
región
crítica
proceso
llama
entrar_region
Indica
interés
estableciendo
elemento
arreglo
fija
turno
proceso
interesado
entrar_region
regresa
inmediato
proceso
llamada
entrar_region
quedará
interesado[0
www
FreeLibros.meFALSE
evento
ocurre
proceso
llama
salir_region
salir
región
crítica
considere
caso
procesos
llaman
entrar_region
forma
simul-
tánea
almacenarán
número
proceso
turno
almacenamiento
sobrescribe
pierde
Suponga
proceso
almacena
turno
procesos
llegan
instrucción
while
proceso
ejecuta
entra
región
crítica
proceso
itera
entra
región
crítica
proceso
sale
región
crítica
instrucción
TSL
veamos
proposición
requiere
ayuda
hardware
computado-
ras
especial
diseñadas
procesadores
mente
instrucción
TSL
REGISTRO
CANDADO
Evaluar
fijar
candado
funciona
Lee
contenido
palabra
memoria
candado
guarda
registro
RX
almacena
valor
distinto
cero
dirección
memoria
candado
garantiza
operaciones
leer
palabra
almacenar
valor
indivisibles
procesador
acceder
palabra
memoria
si-
termine
instrucción
CPU
ejecuta
instrucción
TSLbloquea
bus
me-
moria
impedir
CPUs
accedan
memoria
termine
importante
observar
bloquear
bus
memoria
acción
distinta
des-
habilitar
interrupciones
deshabilitar
interrupciones
operación
lec-
tura
palabra
memoria
seguida
operación
escritura
evita
procesador
bus
acceda
palabra
lectura
escritura
deshabilitan
interrupciones
procesador
produce
efecto
procesador
única
for-
ma
mantener
procesador
memoria
procesador
termine
bloquear
bus
requiere
herramienta
hardware
especial
básicamente
línea
bus
afirme
bus
bloqueado
disponible
procesadores
aparte
bloqueó
instrucción
TSLnecesitamos
variable
compartida
candado
coordine
ac-
ceso
memoria
compartida
candado
proceso
fijar
median-
instrucción
TSLy
lectura
escritura
memoria
compartida
termina
proceso
establece
candado
vuelta
instrucción
move
ordinaria
utilizar
instrucción
evitar
procesos
entren
tiempo
regiones
críticas
solución
proporciona
figura
2-25
muestra
subru-
tina
instrucciones
lenguaje
ensamblador
ficticio
común
instruc-
ción
copia
antiguo
valor
candadoen
registro
fija
candado
valor
compara
distinto
cero
candado
cerrado
progra-
ma
regresa
principio
vuelve
evaluar
volverá
proce-
so
esté
actualmente
región
crítica
salga
subrutina
regresará
bloqueo
establecido
simple
quitar
bloqueo
programa
almacena
candado
necesitan
instrucciones
especiales
sincronización
124
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
125
entrar_region
TSL
REGISTRO
CANDADO
|copia
candado
registro
fija
candado
CMP
REGISTRO,#0
|¿era
candado
cero
JNE
entrar_region
|si
distinto
cero
candado
cerrado
repite
RET
|regresa
llamador
entra
región
crítica
salir_region
MOVE
CANDADO,#0
|almacena
candado
RET
|regresa
llamador
Figura
2-25
entrar
salir
región
crítica
instrucción
TSL
solución
simple
directa
problema
regiones
críticas
entrar
región
crítica
proceso
llama
entrar_region
cabo
espera
ocupada
candado
abierto
adquiere
candado
regresa
región
crí-
tica
proceso
llama
salir_region
almacena
candado
so-
luciones
basadas
regiones
críticas
procesos
llamar
entrar_region
salir_region
momentos
correctos
método
funcione
proceso
trampa
exclusión
mu-
tua
fallará
instrucción
alternativa
TSLes
XCHG
intercambia
contenido
ubicaciones
forma
atómica
ejemplo
registro
palabra
memoria
código
muestra
figura
2-26
esencia
solución
TSL
CPUs
Intel
x86
utilizan
instrucción
XCHGpara
sincronización
nivel
entrar_region
MOVE
REGISTRO,#1
|coloca
registro
XCHG
REGISTRO
CANDADO
|intercambia
contenido
registro
variable
candado
CMP
REGISTRO,#0
|¿era
candado
cero
JNE
entrar_region
|si
distinto
cero
candado
cerrado
repite
RET
|regresa
llamada
entra
región
crítica
salir_region
MOVE
CANDADO,#0
|almacena
candado
RET
|regresa
llamada
Figura
2-26
entrar
salir
región
crítica
instrucción
XCHG
2.3.4
Dormir
despertar
solución
Peterson
soluciones
TSL
XCHG
correctas
to-
das
defecto
requerir
espera
ocupada
esencia
soluciones
comprueban
www.FreeLibros.mepermite
entrada
proceso
desea
entrar
región
crítica
permite
proceso
espera
ciclo
estrecho
permita
entrada
método
desperdicia
tiempo
CPU
efectos
ines-
perados
Considere
computadora
procesos
prioridad
alta
prioridad
ba-
ja
reglas
planificación
tales
ejecuta
listo
momento
región
crítica
cambia
listo
ejecutarse
ejemplo
completa
operación
empieza
espera
ocupada
planifica
ejecución
oportunidad
salir
región
crítica
itera
forma
indefinida
situación
conoce
problema
inversión
prioridades
Veamos
primitivas
comunicación
procesos
bloquean
des-
perdiciar
tiempo
CPU
entrar
regiones
críticas
sim-
ples
par
sleep(dormir
wakeup(despertar
Sleepes
llamada
sistema
proceso
llama
bloquee
desactive
suspenda
proceso
des-
pierte
llamada
wakeuptiene
parámetro
proceso
despertar
activar
mane-
ra
alternativa
sleep
wakeup
parámetro
dirección
memoria
utiliza
asociar
llamadas
sleepcon
llamadas
wakeup
problema
productor-consumidor
ejemplo
forma
utilizar
primitivas
consideremos
problema
productor-consumidor
conocido
problema
búfer
limitado
procesos
comparten
búfer
común
tamaño
fijo
productor
coloca
información
búfer
consumidor
saca
generalizar
problema
productores
consumidores
consideraremos
caso
produc-
tor
consumidor
suposición
simplifica
soluciones
problema
surge
productor
desea
colocar
elemento
búfer
lleno
solución
productor
dormir
desactiva
des-
pierte
active
consumidor
quitado
elementos
similar
consumidor
desea
quitar
elemento
búfer
ve
vacío
duerme
has-
ta
productor
coloca
búfer
despierta
método
suena
simple
produce
tipos
condiciones
carre-
ra
vimos
directorio
spooler
número
elementos
búfer
necesitamos
variable
número
máximo
elementos
contener
búfer
código
productor
comprueba
N.
productor
duerme
productor
agrega
elemento
incrementará
código
consumidor
similar
evalúa
duer-
distinta
cero
quita
elemento
disminuye
contador
pro-
cesos
comprueba
despertar
despierta
código
productor
consumidor
muestra
figura
2-27
expresar
llamadas
sistema
sleepy
wakeupen
mostraremos
llamadas
rutinas
biblioteca
forman
biblioteca
estándar
suponer
estarán
disponibles
sistema
realmente
llamadas
sistema
126
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
127
define
100
número
ranuras
búfer
int
número
elementos
búfer
void
productor(void
int
elemento
while
TRUE
repite
forma
indefinida
elemento
producir_elemento
genera
elemento
if
sleep
búfer
lleno
pasa
inactivo
insertar_elemento(elemento
coloca
elemento
búfer
incrementa
elementos
búfer
if
wakeup(consumidor
vacío
búfer
void
consumidor(void
int
elemento
while
TRUE
repite
forma
indefinida
if
sleep
búfer
vacío
pasa
inactivo
elemento
quitar_elemento
saca
elemento
búfer
disminuye
elementos
búfer
if
cuenta==N–1
wakeup(productor
lleno
búfer
consumir_elemento(elemento
imprime
elemento
Figura
2-27
problema
productor-consumidor
condición
carrera
fatal
procedimientos
insertar_elemento
quitar_elemento
muestran
encar-
gan
colocar
elementos
búfer
sacarlos
regresemos
condición
carrera
ocurrir
acceso
restringido
ocurra
situación
búfer
vacío
consumidor
aca-
ba
leer
instante
planificador
decide
detener
consumidor
forma
temporal
empieza
ejecutar
productor
productor
inserta
elemento
búfer
in-
crementa
observa
Razonando
ende
con-
sumidor
dormido
productor
llama
wakeup
despertar
consumidor
desgracia
consumidor
lógicamente
dormido
señal
des-
pertarlo
pierde
turno
ejecute
consumidor
evalúa
valor
leyó
pasa
dormirse
productor
llenará
búfer
pasará
dormirse
quedarán
dormidos
www
FreeLibros.meLa
esencia
problema
señal
envía
despertar
proceso
dormido
pierde
perdiera
funcionaría
solución
rápida
modificar
reglas
agregar
panorama
bit
espera
despertar
envía
señal
despertar
proceso
despierto
fija
bit
proceso
intenta
pasar
dormir
bit
espera
despertar
encendido
apa-
gará
proceso
permanecerá
despierto
bit
alcancía
almacenar
señales
despertar
bit
espera
despertar
logra
cometido
ejemplo
simple
fácil
cons-
truir
ejemplos
procesos
bit
espera
despertar
insuficiente
Po-
dríamos
modificación
agregar
bit
espera
despertar
32
principio
problema
2.3.5
Semáforos
situación
1965
E.
W.
Dijkstra
1965
sugirió
variable
entera
pa-
ra
contar
número
señales
despertar
guardadas
futuro
propuesta
introdu-
jo
tipo
variable
llamó
semáforo
semáforo
valor
indicando
guardaron
señales
despertar
valor
positivo
estuvieran
pendientes
señales
despertar
Dijkstra
propuso
tuvieran
operaciones
down
up
generalizaciones
sleep
wakeup
respectivamente
operación
downen
semáforo
comprueba
valor
disminuye
valor
utiliza
señal
despertar
almacenada
continúa
valor
proceso
pone
dormir
completar
operación
downpor
momento
acciones
comprobar
valor
modificarlo
posiblemente
pasar
dormir
realizan
conjun-
to
acción
atómica
indivisible
garantiza
empieza
operación
semáforo
proceso
acceder
semáforo
operación
completado
bloqueado
atomicidad
absolutamente
esencial
resolver
problemas
sincronización
evitar
condiciones
carrera
acciones
atómicas
grupo
ope-
raciones
relacionadas
realizan
interrupción
definitiva
realizan
extremo
im-
portantes
áreas
ciencias
computacionales
operación
up
incrementa
valor
semáforo
direccionado
procesos
esta-
ban
inactivos
semáforo
completar
operación
downanterior
sistema
selec-
ciona
azar
permite
complete
operación
down
operación
up
semáforo
contenga
procesos
dormidos
semáforo
seguirá
ha-
brá
proceso
dormido
operación
incrementar
semáforo
despertar
pro-
ceso
indivisible
proceso
bloquea
operación
up
forma
proceso
bloquea
realizando
operación
wakeupen
modelo
punto
adicional
artículo
original
Dijsktra
utilizó
nombres
Py
Ven
down
up
respectivamente
significado
nemónico
personas
ha-
blan
holandés
significado
marginal
Proberen
inten-
tar
Verhogen
elevar
elevar
utilizaremos
términos
downy
up
defecto
introdujeron
lenguaje
programación
Algol
68
128
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
129
resolver
problema
productor-consumidor
semáforos
semáforos
resuelven
problema
pérdida
señales
despertar
muestra
fi-
gura
2-28
funcionen
correcta
esencial
implementen
forma
in-
divisible
normal
implementar
up
down
llamadas
sistema
sistema
operativo
deshabilita
brevemente
interrupciones
evalúa
semáforo
actuali-
za
pone
proceso
dormir
necesario
acciones
requieren
cuan-
tas
instrucciones
peligro
deshabilitar
interrupciones
utilizan
CPUs
semáforo
protegido
variable
candado
utilicen
instrucciones
TSLo
XCHGpara
asegurar
CPU
examinar
semáforo
Asegúrese
comprender
TSLo
XCHG
evitar
CPUs
tengan
acce-
so
semáforo
tiempo
distinto
caso
productor
consumi-
dor
espera
ocupada
esperando
vacíe
llene
búfer
operación
semáforo
tarda
microsegundos
productor
consumidor
po-
drían
tardarse
cantidad
tiempo
arbitraria
extensa
solución
utiliza
semáforos
llamado
llenas
contabilizar
número
ranuras
llenas
llamado
vacíaspara
contabilizar
número
ranuras
vacías
llamado
mu-
tex
asegurar
productor
consumidor
tengan
acceso
búfer
tiempo
principio
llenas
vacíases
número
ranuras
búfer
mutex
semáforos
inicializan
utilizados
procesos
asegurar
entrar
región
crítica
momento
llaman
semáforos
binarios
proce-
so
realiza
operación
downjusto
entrar
región
crítica
operación
upjusto
des-
pués
salir
garantiza
exclusión
mutua
primitiva
comunicación
procesos
disposición
volvamos
analizar
secuencia
interrupción
figura
2-5
sistema
utiliza
semáfo-
ros
forma
natural
ocultar
interrupciones
asociar
semáforo
principio
dispositivo
S.
Justo
iniciar
dispositivo
proceso
administrati-
vo
realiza
operación
downen
semáforo
asociado
bloquea
inmediato
Cuan-
do
entra
interrupción
manejador
interrupciones
realiza
operación
up
semáforo
asociado
proceso
relevante
esté
listo
ejecutarse
modelo
paso
figura
2-5
consiste
operación
up
semáforo
dispositivo
paso
planificador
ejecutar
administrador
dispositivos
lue-
go
procesos
listos
momento
planificador
optar
ejecutar
proceso
importante
continuación
capítulo
analizaremos
algoritmos
utilizan
planificación
ejemplo
figura
2-28
realidad
utilizado
semáforos
maneras
distin-
tas
diferencia
importante
recalcarla
explícitamente
semáforo
mu-
tex
utiliza
exclusión
mutua
diseñado
garantizar
proceso
leer
escribir
búfer
variables
asociadas
momento
exclusión
mutua
re-
querida
evitar
caos
sección
estudiaremos
exclusión
mutua
pode-
mos
lograrla
www.FreeLibros.me#define
100
número
ranuras
búfer
typedef
int
semaforo
semáforos
tipo
especial
int
semaforo
mutex
controla
acceso
región
crítica
semaforo
vacias
ranuras
vacías
búfer
semaforo
llenas
ranuras
llenas
búfer
void
productor(void
int
elemento
while(TRUE
TRUE
constante
elemento
producir_elemento
genera
colocar
búfer
down(&vacias
disminuye
ranuras
vacías
down(&mutex
entra
región
crítica
insertar_elemento(elemento
coloca
elemento
búfer
up(&mutex
sale
región
crítica
up(&llenas
incrementa
ranuras
llenas
void
consumidor(void
int
elemento
while(TRUE
ciclo
infinito
down(&llenas
disminuye
ranuras
llenas
down(&mutex
entra
región
crítica
elemento
quitar_elemento
saca
elemento
búfer
up(&mutex
sale
región
crítica
up(&vacias
incrementa
ranuras
vacías
consumir_elemento(elemento
elemento
Figura
2-28
problema
productor-consumidor
semáforos
semáforos
sincronización
semáforos
vacías
llenas
nece-
sitan
garantizar
secuencias
eventos
ocurran
caso
aseguran
productor
deje
ejecutarse
búfer
esté
lleno
consumidor
deje
ejecutarse
cuan-
do
búfer
esté
vacío
distinto
exclusión
mutua
2.3.6
Mutexes
necesita
habilidad
semáforo
contar
utiliza
versión
sim-
plificada
llamada
mutex
mutexes
administrar
exclusión
mutua
recurso
compartido
pieza
código
implementan
facilidad
eficiencia
130
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
131
especialmente
útiles
paquetes
hilos
implementan
totalidad
es-
pacio
usuario
mutex
variable
abierto
desbloqueado
ce-
rrado
bloqueado
consecuencia
requiere
bit
representarla
práctica
utiliza
frecuencia
entero
indica
abierto
valores
indi-
can
cerrado
utilizan
procedimientos
mutexes
hilo
proceso
necesita
acceso
región
crítica
llama
mutex_lock
mutex
actualmente
abierto
significa
región
crítica
disponible
llamada
éxito
hilo
llama-
dor
entrar
región
crítica
mutex
cerrado
hilo
llamada
bloquea
has-
ta
hilo
región
crítica
termine
llame
mutex_unlock
bloquean
hi-
mutex
selecciona
azar
permite
adquiera
mutex
mutexes
simples
implementar
facilidad
espacio
usua-
rio
instrucción
TSLo
XCHGdisponible
código
mutex_lock
mu-
tex_unlock
utilizar
procedimientos
paquete
hilos
nivel
usuario
muestra
figura
2-29
solución
XCHGes
esencia
similar
mutex_lock
TSL
REGISTRO
MUTEX
|copia
mutex
registro
establece
mutex
CMP
REGISTRO,#0
|¿el
mutex
JZE
ok
|si
cero
mutex
abierto
regresa
CALL
thread_yield
|el
mutex
ocupado
planifica
hilo
JMP
mutex_lock
|intenta
ok
RET
|regresa
procedimiento
llamador
entra
región
crítica
mutex_unlock
MOVE
MUTEX,#0
|almacena
mutex
RET
|regresa
procedimiento
llamador
Figura
2-29
Implementaciones
mutex_lock
mutex_unlock
código
mutex_lock
similar
código
entrar_region
figura
2-25
diferencia
crucial
entrar_region
entrar
región
crítica
continúa
evaluando
mutex
forma
repetida
espera
ocupada
momento
reloj
agotará
proceso
programará
ejecutarlo
proceso
mantiene
mutex
pasa
ejecutarse
libera
hilos
usuario
situación
distinta
reloj
detenga
hilos
ejecutado
tiempo
consecuencia
hilo
intente
adquirir
mutex
espera
ocupada
iterará
forma
indefinida
adquirirá
mutex
permitirá
hilo
ejecute
libere
mutex
entra
diferencia
entrar_regiony
mutex_lock
procedi-
miento
adquirir
mutex
llama
thread_yieldpara
entregar
CPU
hilo
conse-
cuencia
espera
ocupada
hilo
ejecuta
evalúa
mutex
www
FreeLibros.meComo
thread_yield
llamada
planificador
hilos
espacio
usuario
rápido
consecuencia
mutex_lock
mutex_unlock
requieren
llamadas
kernel
utili-
zarlas
hilos
nivel
usuario
sincronizarse
completamente
espacio
usuario
uti-
lizando
procedimientos
requieren
instrucciones
sistema
mutex
descrito
conjunto
mínimo
llamadas
software
demanda
características
primitivas
sincronización
excepción
ejemplo
paquete
hilos
ofrece
llamada
mutex_trylock
adquiere
mutex
devuelve
código
falla
bloquea
llamada
otorga
hilo
fle-
xibilidad
decidir
continuación
alternativas
esperar
sutil
cuestión
visto
forma
superficial
con-
veniente
explícita
paquete
hilos
espacio
usuario
pro-
blema
hilos
tengan
acceso
mutex
hilos
operan
espacio
direcciones
común
mayoría
soluciones
anteriores
algoritmo
Peterson
semáforos
suposición
mencionado
acerca
procesos
acceso
memoria
compartida
palabra
procesos
espacios
direcciones
juntos
consistente
compartir
variable
turno
algoritmo
Peterson
semáforos
búfer
común
respuestas
lugar
estructuras
datos
compartidas
semáforos
almacenar
kernel
accede
llamadas
siste-
ma
enfoque
elimina
problema
lugar
mayoría
sistemas
operativos
mo-
dernos
incluyendo
UNIX
Windows
ofrecen
procesos
compartan
porción
espacio
direcciones
procesos
forma
compartir
bú-
feres
estructuras
datos
casos
utilizar
archivo
compartido
procesos
comparten
mayoría
espacios
direcciones
distin-
ción
procesos
hilos
elimina
completo
duda
presente
procesos
comparten
espacio
direcciones
común
siguen
teniendo
distintos
archivos
abiertos
tem-
porizadores
alarma
propiedades
correspondientes
proceso
hilos
proceso
comparten
procesos
comparten
espacio
direcciones
común
eficiencia
hilos
nivel
usuario
kernel
involucrado
administración
Mutexes
Pthreads
Pthreads
proporciona
funciones
utilizar
sincronizar
hilos
mecanis-
mo
básico
utiliza
variable
mutex
cerrada
abierta
resguardar
región
crítica
hi-
desea
entrar
región
crítica
cerrar
mutex
asociado
mutex
abierto
hilo
entrar
inmediato
bloqueo
establece
forma
automática
evitando
hilos
entren
mutex
cerrado
hilo
llamada
bloquea
mutex
esté
abierto
hilos
esperando
mutex
abierto
continuar
volver
cerrarlo
bloqueos
obligatorios
res-
ponsabilidad
programador
asegurar
hilos
utilicen
correcta
132
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
133
principales
llamadas
relacionadas
mutexes
muestran
figura
2-30
esperarse
crear
destruir
llamadas
operaciones
pthread-
mutex_init
pthread_mutex_destroy
respectivamente
cerrar
pth-
read_mutex_lock
adquirir
mutex
bloquea
cerrado
opción
tratar
cerrar
mutex
falla
código
error
bloquearlo
bloqueado
llamada
pthread_mutex_trylock
permite
hilo
realice
efec-
to
espera
ocupada
requiere
Pthread_mutex_unlock
abre
mutex
libera
exactamente
hilo
espera
mutexes
atribu-
tos
utilizan
propósitos
especializados
Figura
2-30
llamadas
Pthreads
relacionadas
mutexes
mutexes
pthreads
ofrece
mecanismo
sincronización
varia-
bles
condición
mutexes
permitir
bloquear
acceso
región
crítica
variables
condición
permiten
hilos
bloqueen
condición
cumpliendo
utilizan
métodos
juntos
Veamos
interacción
hilos
mutexes
variables
condición
detalle
ejemplo
simple
considere
nuevamente
escenario
productor-consumidor
hi-
coloca
cosas
búfer
saca
productor
descubre
ranuras
libres
disponibles
búfer
bloquear
disponible
mutexes
comprobación
forma
atómica
interferencia
hilos
descubrir
búfer
lleno
productor
necesita
forma
bloquearse
despertado
posteriormente
permiten
variables
condición
llamadas
relacionadas
variables
condición
muestran
figura
2-31
podríamos
esperar
llamadas
crear
destruir
variables
condición
atributos
llamadas
administrarlas
muestran
operaciones
primarias
variables
condición
pthread_cond_wait
pthread_cond_signal
bloquea
hilo
llamada
hilo
señala
utilizando
lla-
mada
razones
bloquear
esperar
forman
pro-
tocolo
espera
señalización
hilo
bloquea
esperando
hilo
señalización
realice
trabajo
libere
recurso
realice
actividad
en-
tonces
continuar
hilo
bloqueado
variables
condición
permiten
espera
Llamada
hilo
Descripción
Pthread_mutex_init
Crea
mutex
Pthread_mutex_destroy
Destruye
mutex
existente
Pthread_mutex_lock
Adquiere
mutex
bloquea
Pthread_mutex_trylock
Adquiere
mutex
falla
Pthread_mutex_unlock
Libera
mutex
www.FreeLibros.mebloqueo
realicen
forma
atómica
llamada
pthread_cond_broadcast
utiliza
hilos
potencialmente
bloqueados
esperan
señal
134
PROCESOS
HILOS
CAPÍTULO
Figura
2-31
llamadas
Pthreads
relacionan
variables
condición
Llamada
hilo
Descripción
Pthread_cond_init
Crea
variable
condición
Pthread_cond_destroy
Destruye
variable
condición
Pthread_cond_wait
Bloquea
espera
señal
Pthread_cond_signal
Envia
señal
hilo
despierta
Pthread_cond_broadcast
Envia
señal
hilos
despierta
variables
condición
mutexes
utilizan
conjunto
patrón
hilo
cierre
mutex
espere
variable
condicional
obtener
desea
momento
hilo
señalará
continuar
llamada
pthread_cond-
wait
cierra
abre
forma
atómica
mutex
contiene
razón
mutex
parámetros
vale
pena
observar
variables
condición
diferencia
semáforos
memoria
envía
señal
variable
condición
hilo
espera
pierde
señal
programadores
cuidado
perder
señales
ejemplo
forma
utilizan
mutexes
variables
condición
figu-
ra
2-32
muestra
problema
productor-consumidor
simple
búfer
pro-
ductor
llenado
búfer
esperar
consumidor
vacíe
producir
elemento
similar
consumidor
quitado
elemento
espe-
rar
productor
producido
simple
ejemplo
ilustra
me-
canismos
básicos
instrucción
pone
hilo
inactivo
verificar
condición
asegurarse
cumpla
continuar
hilo
desper-
tado
señal
UNIX
razón
2.3.7
Monitores
semáforos
mutexes
comunicación
procesos
ve
sencilla
Olvíde-
Analice
cerca
orden
operaciones
downantes
insertar
quitar
elementos
búfer
figura
2-28
Suponga
invirtió
orden
operaciones
downen
código
pro-
ductor
mutex
disminuyó
vacías
búfer
estuviera
completamente
lleno
productor
bloquearía
mutex
establecida
conse-
cuencia
próxima
consumidor
tratara
acceder
búfer
realizaría
operación
down
mutex
bloquearía
procesos
permanecerían
bloqueados
indefinida
realizaría
trabajo
desafortunada
situación
conoce
in-
terbloqueo
deadlock
capítulo
estudiaremos
interbloqueos
detalle
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
135
include
stdio.h
include
pthread.h
define
MAX
1000000000
números
producir
pthread_mutex_t
el_mutex
pthread_cond_t
condc
condp
int
bufer
búfer
utilizado
productor
consumidor
void
productor(void
ptr
produce
datos
int
for
i=1
i<=MAX
i++
pthread_mutex_lock(&el_mutex
obtiene
acceso
exclusivo
búfer
while
bufer!=0
pthread_cond_wait(&condp
el_mutex
bufer
coloca
elemento
búfer
pthread_cond_signal(&condc
despierta
consumidor
pthread_mutex_unlock(&el_mutex
libera
acceso
búfer
pthread_exit(0
void
consumidor(void
ptr
consume
datos
int
for
i=1
i<=MAX
i++
pthread_mutex_lock(&el_mutex
obtiene
acceso
exclusivo
búfer
while
bufer==0
pthread_cond_wait(&condc
el_mutex
bufer
saca
elemento
búfer
pthread_cond_signal(&condp
despierta
productor
pthread_mutex_unlock(&el_mutex
libera
acceso
búfer
pthread_exit(0
int
main(int
argc
char
argv
pthread_t
pro
pthread_mutex_init(&el_mutex
pthread_cond_init(&condc
pthread_cond_init(&condp
pthread_create(&con
consumidor
pthread_create(&pro
productor
pthread_join(pro
pthread_join(con
pthread_cond_destroy(&condc
pthread_cond_destroy(&condp
pthread_mutex_destroy(&el_mutex
Figura
2-32
hilos
resolver
problema
productor-consumidor
www
FreeLibros.meResaltamos
problema
mostrar
cuidadoso
programador
utilizar
semáforos
ligero
error
detiene
forma
abrupta
programación
lengua-
je
ensamblador
errores
condiciones
carrera
interbloqueos
formas
comportamiento
impredecible
irreproducible
facilitar
escritura
programas
correctos
Brinch
Hansen
1973
Hoare
1974
pro-
pusieron
primitiva
sincronización
nivel
conocida
monitor
proposicio-
nes
tenían
ligeras
variaciones
describe
continuación
monitor
colección
procedimientos
variables
estructuras
datos
agrupan
tipo
especial
módulo
pa-
quete
procesos
llamar
procedimientos
monitor
desean
pe-
ro
acceder
directa
estructuras
datos
internas
monitor
procedimientos
declarados
figura
2-33
ilustra
monitor
escrito
lenguaje
imaginario
Pidgin
Pascal
utilizar
monitores
concep-
to
lenguaje
monitor
ejemplo
integer
condition
procedure
productor
end
procedure
consumidor
end
end
monitor
Figura
2-33
monitor
monitores
importante
propiedad
útiles
lograr
exclusión
mu-
tua
proceso
activo
monitor
instante
monitores
construcción
lenguaje
programación
compilador
especiales
pue-
manejar
llamadas
procedimientos
monitor
forma
distinta
llamadas
pro-
cedimientos
general
proceso
llama
procedimiento
monitor
primeras
instrucciones
procedimiento
comprobarán
proceso
activo
momento
monitor
proceso
invocador
suspenderá
proceso
de-
jado
monitor
proceso
utilizando
monitor
proceso
invocador
entrar
responsabilidad
compilador
implementar
exclusión
mutua
entradas
moni-
tor
forma
común
utilizar
mutex
semáforo
binario
compilador
programador
arreglos
exclusión
mutua
probable
al-
136
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
137
go
salga
caso
persona
escribe
monitor
acerca
có-
mo
compilador
arreglos
exclusión
mutua
Basta
convertir
regiones
críticas
procedimientos
monitor
procesos
ejecuten
re-
giones
críticas
tiempo
monitores
proporcionan
fácil
lograr
exclusión
mutua
he-
mos
visto
basta
necesitamos
forma
procesos
bloqueen
puedan
continuar
problema
productor-consumidor
sencillo
colo-
car
pruebas
búfer-lleno
búfer-vacío
procedimientos
monitor
debe-
ría
bloquearse
productor
búfer
lleno
solución
introducción
variables
condición
operaciones
waity
signal
procedimiento
monitor
descubre
continuar
ejemplo
productor
búfer
lleno
realiza
operación
waiten
variable
condición
llenas
acción
proceso
llamada
bloquee
Tam-
bién
permite
proceso
podido
entrar
monitor
contexto
Pthreads
descrito
vimos
variables
condición
operaciones
ejemplo
proceso
consumidor
despertar
socio
dormido
median-
realización
operación
signalen
variable
condición
socio
esté
esperan-
do
evitar
procesos
activos
monitor
tiempo
necesitamos
regla
indique
ocurre
operación
signal
Hoare
propuso
dejar
proceso
recién
despertado
ejecutara
suspendiendo
Brinch
Hansen
propuso
requerir
pro-
ceso
realice
operación
signaldeba
salir
monitor
inmediato
palabras
instrucción
signalpodría
aparecer
instrucción
procedimiento
moni-
tor
Utilizaremos
proposición
Brinch
Hansen
concepto
simple
fácil
implementar
realiza
operación
signal
variable
condi-
ción
procesos
estén
esperando
determine
planificador
sis-
tema
revivirá
Adicionalmente
solución
propusieron
Hoare
Brinch
Hansen
so-
lución
expone
dejar
señalizador
continúe
ejecución
permita
proceso
espera
empezar
ejecutarse
señalizador
salido
monitor
variables
condición
contadores
acumulan
señales
posterior
co-
mo
semáforos
ende
variable
condición
señaliza
proce-
so
esperándola
señal
pierde
palabras
operación
waitdebe
operación
signal
regla
facilita
implementación
forma
considerable
práctica
problema
fácil
registro
proceso
variables
necesario
proceso
contrario
realizaría
operación
signal
es-
ta
operación
necesaria
analizar
variables
figura
2-34
muestra
esqueleto
problema
productor-consumidor
monitores
lenguaje
imaginario
Pidgin
Pascal
ventaja
utilizar
Pidgin
Pascal
len-
guaje
puro
simple
modelo
Hoare
Brinch
Hansen
exactitud
lector
esté
pensando
operaciones
waity
signalse
parecen
sleepy
wakeup
operaciones
vimos
tenían
condiciones
carrera
fatales
realidad
simila-
res
diferencia
crucial
sleepy
wakeupfallaban
proceso
tratando
dormir
tratando
despertarlo
monitores
www.FreeLibros.meocurrir
exclusión
mutua
automática
procedimientos
monitor
garantiza
ejem-
plo
productor
procedimiento
monitor
descubre
búfer
lleno
completar
operación
wait
preocuparse
posibilidad
planificador
pue-
conmutar
consumidor
justo
complete
operación
wait
consumidor
si-
138
PROCESOS
HILOS
CAPÍTULO
monitor
ProductorConsumidor
condition
llenas
vacias
integer
procedure
insertar(elemento
integer
begin
if
then
wait(llenas
insertar_elemento(elemento
if
then
signal(vacias
end
function
eliminar
integer
begin
if
then
wait(vacias
eliminar
eliminar_elemento
if
then
signal(llenas
end
end
monitor
procedure
productor
begin
while
true
do
begin
elemento
producir_elemento
ProductorConsumidor.insertar(elemento
End
end
procedure
consumidor
begin
while
true
do
begin
elemento
ProductorConsumidor.eliminar
consumir_elemento(elemento
end
end
Figura
2-34
esquema
problema
productor-consumidor
monitores
procedimiento
monitor
activo
búfer
ranuras
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
139
quiera
permitir
entrar
monitor
waitsea
terminado
productor
mar-
cado
ejecutable
Pidgin
Pascal
lenguaje
imaginario
lenguajes
programación
reales
permiten
implementar
monitores
forma
diseñada
Hoare
Brinch
Hansen
Java
lenguajes
Java
lenguaje
orientado
objetos
soporta
hilos
nivel
usuario
permite
agrupar
métodos
procedimientos
clases
agregar
palabra
clave
synchronizeda
declaración
método
Java
garantiza
hilo
empezado
ejecutar
método
permitirá
hilo
empiece
ejecutar
método
synchronizedde
objeto
figura
2-35
muestra
solución
Java
problema
productor-consumidor
utiliza
monitores
solución
consiste
clases
clase
exterior
ProductorConsumidor
crea
inicia
hilos
clases
productor
consumidor
respectivamen-
contienen
código
productor
consumidor
clase
nuestro_monitor
monitor
Contiene
hilos
sincronizados
utilizan
insertar
elementos
búfer
com-
partido
sacarlos
diferencia
ejemplos
anteriores
caso
mostramos
código
completo
insertar
eliminar
hilos
productor
consumidor
idénticos
funcionalidad
contrapartes
ejemplos
anteriores
productor
ciclo
infinito
genera
datos
coloca
búfer
común
consumidor
ciclo
infinito
equivalente
sacar
datos
búfer
común
divertido
interesante
programa
clase
nuestro_monitor
contiene
búfer
va-
riables
administración
métodos
sincronizados
productor
activo
insertar
antemano
consumidor
activo
eliminar
seguro
actualizar
variables
búfer
temor
produzcan
condiciones
carrera
variable
registro
elementos
búfer
tomar
va-
lor
incluyendo
variable
inf
índice
ranura
búfer
obtener
elemento
similar
sup
índice
ranura
búfer
colocar
elemento
permite
inf
/H11005sup
significa
elementos
búfer
valor
indica
caso
aplica
métodos
sincronizados
Java
difieren
monitores
clásicos
punto
esencial
Ja-
variables
condición
integradas
ofrece
procedimientos
wait
no-
tify
equivalentes
sleep
wakeup
excepción
utilizarlos
métodos
sincronizados
sujetos
condiciones
carrera
teoría
método
wait
inte-
rrumpir
código
circundante
Java
requiere
manejo
excepcio-
nes
explícito
fines
imagine
ir_al_estado_inactivo
dormir
automatizar
exclusión
mutua
regiones
críticas
monitores
progra-
mación
paralelo
propensa
errores
semáforos
formas
desventajas
ejemplos
monitores
escribieron
Pidgin
Pascal
ejemplos
libro
dijimos
monitores
concepto
lenguaje
programación
compilador
reconocerlos
arreglos
exclusión
mutua
Pascal
mayoría
lenguajes
monitores
irrazonable
esperar
compiladores
implemen-
www.FreeLibros.meten
reglas
exclusión
mutua
compilador
siquiera
proce-
dimientos
monitores
lenguajes
semáforos
fácil
agregarlos
nece-
sitamos
agregar
rutinas
cortas
lenguaje
ensamblador
biblioteca
emitir
llamadas
sistema
upy
down
compiladores
siquiera
lue-
go
sistemas
operativos
acerca
semáforos
sistema
operativo
basado
semáforos
escribir
programas
usuario
sis-
tema
C++
lenguaje
ensamblador
masoquistas
monitores
requiere
lenguaje
integrados
problema
monitores
semáforos
diseñados
resolver
problema
exclusión
mutua
CPUs
tengan
acceso
memoria
común
colocar
semáforos
memoria
compartida
protegerlos
instrucciones
TSLo
XCHG
evitar
condiciones
carrera
utilizamos
sistema
distribuido
consista
CPUs
memoria
privada
conectadas
red
área
local
primitivas
aplicar
conclusión
semáforos
nivel
dema-
siado
monitores
usarse
lenguajes
programación
Ade-
primitivas
permite
intercambio
información
máquinas
necesita
2.3.8
Pasaje
transmisión
mensajes
pasaje
mensajes
message
passing
método
comunicación
procesos
utiliza
primitivas
sendy
receive
semáforos
diferencia
monitores
llamadas
sistema
construcciones
lenguaje
tales
pue-
den
colocar
facilidad
procedimientos
biblioteca
send(destino
mensaje
receive(origen
mensaje
llamada
envía
mensaje
destino
especificado
recibe
mensaje
origen
especificado
CUALQUIERA
receptor
importa
mensaje
dis-
ponible
receptor
bloquear
llegue
alternativa
regresar
inmediato
código
error
Aspectos
diseño
sistemas
pasaje
mensajes
sistemas
paso
mensajes
problemas
cuestiones
diseño
presentan
reto
surgen
semáforos
monitores
especial
procesos
comu-
nicando
encuentran
distintas
máquinas
conectadas
red
ejemplo
140
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
141
public
class
ProductorConsumidor
static
int
100
constante
proporciona
tamaño
búfer
static
productor
new
productor
crea
instancia
hilo
productor
static
consumidor
new
consumidor
crea
instancia
hilo
consumidor
static
nuestro_monitor
mon
new
nuestro_monitor
crea
instancia
monitor
public
static
void
main(String
args
p.start
inicia
hilo
productor
c.start
inicia
hilo
consumidor
static
class
productor
extends
Thread
public
void
run
método
run
contiene
código
hilo
int
elemento
while(true
ciclo
productor
elemento
producir_elemento
mon.insertar(elemento
private
int
producir_elemento
realmente
produce
static
class
consumidor
extends
Thread
public
void
run
método
run
contiene
código
hilo
int
elemento
while(true
ciclo
consumidor
elemento
mon.eliminar
consumir_elemento(elemento
private
void
consumir_elemento(int
elemento
realmente
consume
static
class
nuestro_monitor
monitor
private
int
bufer[]=new
int[N
private
int
cuenta=0
inf=0
sup=0
contadores
índices
public
synchronized
void
insertar(int
val
if
cuenta==N
ir_a_estado_inactivo
búfer
lleno
pasa
inactivo
bufer[sup]=val
inserta
elemento
búfer
sup=(sup+1)%N
ranura
colocar
elemento
cuenta+1
elemento
búfer
if
cuenta==1
notify
consumidor
inactivo
despierta
public
synchronized
int
eliminar
int
val
if
cuenta==0
ir_a_estado_inactivo
búfer
vacío
pasa
inactivo
val
bufer[inf
obtiene
elemento
búfer
ranura
colocar
elemento
cuenta-1
elemento
búfer
if
cuenta==N
H110021
notify
productor
inactivo
despierta
return
val
private
void
ir_a_estado_inactivo
try{wait();}catch(InterruptedException
exc
Figura
2-35
solución
problema
productor-consumidor
Java
www.FreeLibros.meperder
mensajes
red
protegerse
mensajes
perdidos
emisor
receptor
pue-
den
acordar
recibido
mensaje
receptor
enviará
vuelta
men-
saje
especial
acuse
recibo
acknowledgement
emisor
recibido
acuse
intervalo
tiempo
vuelve
transmitir
mensaje
considere
ocurre
mensaje
recibió
forma
correcta
pierde
men-
saje
acuse
envía
vuelta
emisor
volverá
transmitir
mensaje
receptor
recibirá
esencial
receptor
diferenciar
mensaje
retransmisión
general
problema
resuelve
colocando
números
se-
cuencia
consecutivos
mensaje
original
receptor
recibe
mensaje
contenga
número
secuencia
mensaje
mensaje
duplicado
ignorar
comunicación
exitosa
cara
pasaje
mensajes
confiabilidad
constitu-
ye
estudio
redes
computadoras
obtener
información
consul-
Tanenbaum
1996
sistemas
mensajes
lidiar
forma
denominan
pro-
cesos
proceso
especificado
llamada
sendo
receiveesté
libre
ambi-
güedad
autenticación
cuestión
sistemas
mensajes
cliente
comunicando
servidor
archivos
impostor
extremo
espectro
cuestiones
diseño
importantes
emisor
receptor
máquina
rendimiento
acción
copiar
mensa-
jes
proceso
lenta
operación
semáforo
entrar
monitor
esfuerzo
lograr
pasaje
mensajes
eficiente
ejemplo
Cheriton
1984
sugirió
limitar
tamaño
mensajes
tamaño
registros
máquina
pasaje
mensajes
registros
problema
productor-consumidor
pasaje
mensajes
veamos
resolver
problema
productor-consumidor
pasaje
men-
sajes
memoria
compartida
figura
2-36
muestra
solución
Suponemos
mensajes
tamaño
sistema
operativo
coloca
mensajes
enviados
recibidos
automática
búfer
solución
utiliza
mensajes
similar
ranuras
búfer
memoria
compartida
consumidor
empieza
en-
viar
mensajes
vacíos
productor
productor
elemento
con-
sumidor
recibe
mensaje
vacío
envía
regreso
lleno
número
mensajes
sistema
permanece
constante
tiempo
puedan
almacenar
can-
tidad
memoria
específica
conoce
antemano
productor
trabaja
rapidez
consumidor
mensajes
terminarán
lle-
esperando
consumidor
productor
bloqueará
esperando
regrese
mensaje
va-
cío
consumidor
trabaja
rapidez
ocurrirá
inverso
mensajes
estarán
vacíos
esperando
productor
llene
consumidor
bloqueará
espera
mensaje
lleno
variantes
posibles
paso
mensajes
empezar
veamos
forma
direccionan
mensajes
asignar
proceso
dirección
única
direccio-
nar
mensajes
procesos
distinta
inventar
estructura
datos
conocida
142
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.3
COMUNICACIÓN
PROCESOS
143
buzón
buzón
lugar
colocar
búfer
número
mensajes
general
especifica
hora
crear
buzón
utilizan
buzones
parámetros
di-
rección
llamadas
sendy
receiveson
buzones
procesos
proceso
en-
viar
buzón
lleno
suspende
remueva
mensaje
buzón
espacio
mensaje
problema
productor-consumidor
productor
consumidor
crearían
buzones
tamaño
suficiente
contener
mensajes
productor
enviaría
mensajes
contuvieran
datos
actuales
buzón
consumidor
consumidor
enviaría
mensajes
va-
cíos
buzón
productor
utilizan
buzones
mecanismo
búfer
bu-
zón
destino
contiene
mensajes
enviado
proceso
destino
aceptado
extremo
buzones
eliminar
búfer
mé-
operación
sendtermina
operación
receive
proceso
emisor
bloquea
has-
ta
ocurre
operación
receive
momento
mensaje
copiar
direc-
ta
emisor
receptor
búfer
similar
realiza
opera-
define
100
número
ranuras
búfer
void
productor(void
int
elemento
mensaje
búfer
mensajes
while
TRUE
elemento
producir_elemento
genera
colocar
búfer
receive(consumidor,&m
espera
llegue
mensaje
vacío
crear_mensaje(&m
elemento
construye
mensaje
enviarlo
send(consumidor,&m
envía
elemento
consumidor
void
consumidor(void
int
elemento
mensaje
for
i=0
i++
send(productor,&m
envía
mensajes
vacíos
while
TRUE
receive(productor,&m
obtiene
mensaje
contiene
elemento
elemento
extraer_elemento(&m
extrae
elemento
mensaje
send(productor,&m
envía
vuelta
respuesta
mensaje
vacío
consumir_elemento(elemento
elemento
Figura
2-36
problema
productor-consumidor
mensajes
www.FreeLibros.meción
receive
receptor
bloquea
ocurre
operación
send
estrategia
conoce
encuentro
fácil
implementar
esquema
mensajes
búfer
flexible
emisor
receptor
ven
obligados
ejecutarse
paso
bloqueo
pasaje
mensajes
utiliza
frecuencia
sistemas
programación
paralelo
ejemplo
sistema
paso
mensajes
reconocido
MPI
Message-Passing
Interface
In-
terfaz
pasaje
mensajes
utiliza
computación
científica
obtener
información
sistema
consulte
Gropp
colaboradores
1994
Snir
colaboradores
1996
2.3.9
Barreras
mecanismo
sincronización
destinado
grupos
procesos
situaciones
tipo
productor-consumidor
procesos
aplicaciones
dividen
fa-
ses
regla
proceso
continuar
fase
procesos
estén
listos
lograr
comportamiento
coloca
barrera
fi-
nal
fase
proceso
llega
barrera
bloquea
procesos
llegado
operación
barrera
ilustra
figura
2-37
144
PROCESOS
HILOS
CAPÍTULO
Barrera
Barrera
Barrera
Tiempo
Tiempo
Tiempo
Proceso
Figura
2-37
barrera
Procesos
acercándose
barrera
procesos
bloqueados
barrera
proceso
llega
barrera
dejan
pasar
figura
2-37(a
procesos
acercan
barrera
sig-
nifica
calculando
llegado
fase
actual
tiempo
proceso
termina
cálculos
requeridos
fase
Des-
pués
ejecuta
primitiva
barrier
general
llamando
procedimiento
biblioteca
proceso
suspende
tercer
proceso
terminan
fase
ejecutando
primitiva
barrier
situación
ilustra
figura
2-37(b
últi-
mo
proceso
llega
barrera
liberan
procesos
muestra
figura
2-37(c
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
145
ejemplo
problema
requiere
barreras
considere
problema
común
relaja-
ción
física
ingeniería
general
matriz
contiene
valores
iniciales
valores
representar
temperaturas
diversos
puntos
hoja
metal
idea
calcular
tarda
propagarse
efecto
flama
colocada
esquina
hoja
Empezando
valores
actuales
aplica
transformación
matriz
obtener
versión
ejemplo
aplicación
leyes
termodinámica
valor
temperaturas
tiempo
posterior
representado
∆T.
proceso
repite
proporcionando
temperaturas
puntos
muestreo
co-
mo
función
tiempo
medida
calienta
hoja
algoritmo
produce
serie
ma-
trices
tiempo
imagine
matriz
ejemplo
millón
millón
requieren
procesos
paralelo
posiblemente
multiprocesador
agilizar
cálculos
Distintos
procesos
trabajarán
distintas
partes
matriz
calculando
elementos
anteriores
leyes
física
proceso
empezar
iteración
complete
iteración
to-
proceso
hayan
terminado
trabajo
actual
forma
lograr
objetivo
programar
proceso
ejecute
operación
barrierdespués
terminado
iteración
actual
hayan
terminado
matriz
entrada
siguien-
iteración
completa
procesos
liberarán
forma
simultánea
empezar
iteración
2.4
PLANIFICACIÓN
computadora
multiprograma
frecuencia
procesos
hilos
com-
piten
CPU
tiempo
situación
ocurre
procesos
encuentran
tiempo
listo
CPU
disponible
decidir
proceso
ejecutar
continuación
sistema
operativo
realiza
decisión
conoce
planificador
procesos
algoritmo
utiliza
conoce
algoritmo
planificación
terminos
conforman
tema
tratar
siguientes
secciones
cuestiones
aplican
planificación
procesos
apli-
can
planificación
hilos
distintas
kernel
administra
hilos
general
planificación
cabo
hilo
importa
proceso
per-
tenece
hilo
principio
enfocaremos
cuestiones
planificación
aplican
procesos
hilos
analizaremos
explícita
planificación
hilos
cuestiones
únicas
surgen
capítulo
trabajaremos
chips
multinúcleo
2.4.1
Introducción
planificación
sistemas
procesamiento
lotes
entrada
forma
imágenes
tarje-
tas
cinta
magnética
algoritmo
planificación
simple
bastaba
ejecutar
siguien-
trabajo
cinta
sistemas
multiprogramación
algoritmo
planificación
www.FreeLibros.mevolvió
complejo
comúnmente
usuarios
esperando
atendidos
Al-
gunas
mainframe
combinan
servicios
procesamiento
lotes
tiempo
compar-
tido
requiriendo
planificador
decida
toca
turno
trabajo
procesamiento
lotes
usuario
interactivo
terminal
punto
aparte
trabajo
procesamien-
to
lotes
petición
ejecutar
programas
sucesión
sec-
ción
supondremos
petición
ejecutar
programa
tiempo
CPU
recurso
escaso
máquinas
planificador
di-
ferencia
rendimiento
percibido
satisfacción
usuario
consecuencia
puesto
esfuerzo
idear
algoritmos
planificación
astutos
eficientes
llegada
computadoras
personales
situación
cambió
maneras
lugar
tiempo
proceso
activo
probable
usuario
entra
documento
procesador
palabras
compile
tiempo
programa
plano
usuario
escribe
comando
procesador
palabras
planifica-
dor
esforzarse
averiguar
proceso
ejecutar
procesador
palabras
único
candidato
lugar
computadoras
vuelto
veloces
paso
años
CPU
raras
recurso
escaso
mayoría
programas
computadoras
personales
limitados
velocidad
usuario
presentar
datos
entrada
es-
cribir
clic
velocidad
CPU
procesarlos
compilacio-
nes
consumían
ciclos
CPU
requieren
segundos
mayoría
casos
estén
ejecutando
programas
tiem-
po
procesador
palabras
hoja
cálculo
raras
importante
ejecuta
usuario
probablemente
esperando
terminen
con-
secuencia
planificación
importancia
PCs
simples
aplicaciones
prácticamente
comen
viva
CPU
ejemplo
visualizar
hora
video
alta
resolución
ajustan
colores
108,000
cuadros
NTSC
90,000
cuadros
PAL
requiere
cómputo
nivel
industrial
em-
bargo
aplicaciones
similares
excepción
regla
tratarse
servidores
red
situación
cambia
forma
considerable
proce-
sos
compiten
CPU
planificación
retoma
importancia
ejemplo
CPU
elegir
ejecutar
proceso
recopila
estadísticas
diarias
atiende
peticiones
usuarios
usuarios
contentos
tipo
pro-
cesos
prioridad
CPU
elegir
proceso
correcto
ejecutar
continuación
planificador
tam-
bién
preocuparse
eficiente
CPU
conmutación
procesos
cara
empezar
cambio
usuario
kernel
guardar
proceso
actual
incluyendo
almacenamiento
registros
ta-
bla
procesos
puedan
volver
cargarse
sistemas
mapa
memoria
ejemplo
bits
referencia
memoria
tabla
páginas
guardar
tam-
bién
seleccionar
proceso
ejecución
algoritmo
planifica-
ción
volver
cargar
MMU
mapa
memoria
proceso
iniciar
proceso
generalmente
conmutación
procesos
inválida
memoria
caché
volver
cargarse
forma
diná-
146
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
147
mica
memoria
principal
momento
entrar
kernel
salir
realizan
conmutaciones
procesos
llegar
consumir
cantidad
considerable
tiempo
CPU
aconseja
precaución
Comportamiento
proceso
procesos
alternan
ráfagas
cálculos
peticiones
disco
mues-
tra
figura
2.38
general
CPU
opera
tiempo
detenerse
rea-
liza
llamada
sistema
leer
datos
archivo
escribirlos
completa
llamada
sistema
CPU
realiza
cálculos
necesita
datos
tie-
ne
escribir
datos
sucesivamente
actividades
cuentan
cálculos
ejemplo
CPU
copia
bits
RAM
video
ac-
tualizar
pantalla
calculando
realizando
operaciones
CPU
sentido
proceso
entra
bloqueado
espera
dispo-
sitivo
externo
complete
trabajo
Ráfaga
CPU
larga
Ráfaga
CPU
corta
Esperando
Tiempo
Figura
2-38
ráfagas
CPU
alternan
periodos
espera
S.
proceso
ligado
CPU
proceso
ligado
S.
importante
observar
acerca
figura
2-38
procesos
muestra
figura
2-38(a
invierten
tiempo
realizando
cálculos
muestra
figura
2-38(b
invierten
tiempo
espe-
rando
S.
conoce
limitados
cálculos
segundos
limi-
tados
O-bound
general
procesos
limitados
cálculos
ráfagas
CPU
largas
consecuencia
esperas
infrecuentes
procesos
limitados
ráfagas
CPU
cortas
ende
esperas
frecuentes
S.
Observe
factor
cla-
ve
longitud
ráfaga
CPU
ráfaga
S.
procesos
limitados
limitados
realizan
cálculos
petición
de-
bido
tengan
peticiones
especial
largas
requiere
tiempo
emitir
petición
hardware
leer
bloque
disco
importar
tiempo
requiera
procesar
datos
lleguen
www
FreeLibros.me148
PROCESOS
HILOS
CAPÍTULO
Vale
pena
observar
medida
CPUs
vuelven
rápidas
procesos
tienden
limitados
S.
efecto
ocurre
CPUs
mejorando
ma-
yor
rapidez
discos
consecuencia
probable
planificación
procesos
limita-
convierta
tema
importante
futuro
idea
básica
proceso
limitado
desea
ejecutarse
obtener
rápidamente
oportunidad
emitir
petición
disco
mantener
disco
ocupado
vimos
figura
2-6
procesos
limitados
requieren
CPU
es-
tar
completamente
ocupada
planificar
procesos
cuestión
clave
relacionada
planificación
tomar
decisiones
planifica-
ción
Resulta
variedad
situaciones
necesita
planificación
pri-
mer
lugar
crea
proceso
tomar
decisión
ejecutar
proceso
padre
proceso
hijo
procesos
encuentran
listo
decisión
normal
programación
ejecutar
cualquiera
programador
procesos
elegir
ejecutar
legítima
padre
hijo
lugar
tomar
decisión
planificación
proceso
termina
proceso
ejecutar
elegir
pro-
ceso
conjunto
procesos
listos
proceso
listo
general
ejecuta
proce-
so
inactivo
suministrado
sistema
tercer
lugar
proceso
bloquea
esperar
operación
semáforo
razón
elegir
proceso
ejecutarlo
razón
blo-
queo
jugar
papel
elección
ejemplo
proceso
importante
espe-
rando
salga
región
crítica
dejamos
ejecute
continuación
salir
región
crítica
ende
dejar
continúe
problema
planificador
comúnmente
información
necesaria
tomar
dependencia
cuarto
lugar
ocurre
interrupción
tomar
decisión
planificación
interrupción
proviene
dispositivo
terminado
trabajo
proceso
bloqueado
espera
operación
esté
listo
ejecutarse
responsabilidad
planificador
decidir
ejecutar
proceso
acaba
en-
trar
listo
proceso
ejecutando
momento
interrupción
reloj
hardware
proporciona
interrupciones
periódicas
50
60
Hz
fre-
cuencia
tomar
decisión
planificación
interrupción
reloj
k-ési-
ma
interrupción
reloj
algoritmos
planificación
dividir
categorías
forma
manejan
interrupciones
reloj
algoritmo
programación
apropiativo
nonpreemptive
selecciona
proceso
ejecutarlo
deja
eje-
cute
bloquea
espera
operación
pro-
ceso
libera
CPU
forma
voluntaria
ejecute
horas
suspenderá
forzosa
efecto
toman
decisiones
planificación
inte-
rrupciones
reloj
completado
procesamiento
interrupción
reloj
reanuda
ejecución
proceso
interrupción
proceso
prioridad
esté
esperando
tiempo
libre
acabe
cumplir
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
149
contrario
algoritmo
planificación
apropiativa
selecciona
proceso
deja
ejecute
máximo
tiempo
fijo
ejecución
intervalo
tiempo
suspende
planificador
selecciona
proceso
ejecutarlo
disponible
lle-
var
cabo
planificación
apropiativa
necesario
ocurra
interrupción
reloj
intervalo
tiempo
CPU
regrese
control
planificador
reloj
disponi-
ble
planificación
apropiativa
única
opción
Categorías
algoritmos
planificación
sorprendente
distintos
entornos
requieran
algoritmos
planificación
si-
tuación
presenta
áreas
aplicación
distintos
tipos
sistemas
operativos
objetivos
palabras
planificador
optimizar
sistemas
entornos
vale
pena
mencionar
Procesamiento
lotes
Interactivo
tiempo
real
sistemas
procesamiento
lotes
siguen
utilizándose
ampliamente
mundo
ne-
gocios
nóminas
inventarios
cuentas
cobrar
cuentas
pagar
cálculos
interés
bancos
procesamiento
reclamaciones
compañías
seguros
tareas
pe-
riódicas
sistemas
procesamiento
lotes
usuarios
esperen
impacientemente
terminales
obtener
respuesta
rápida
petición
corta
consecuencia
acep-
tables
algoritmos
apropiativos
apropiativos
largos
periodos
proceso
método
reduce
conmutación
procesos
ende
mejora
rendimiento
realidad
al-
goritmos
procesamiento
lotes
generales
aplicar
situaciones
valga
pena
estudiarlos
personas
es-
tán
involucradas
computación
mainframes
corporativas
entorno
usuarios
interactivos
apropiación
esencial
evitar
proceso
acapare
CPU
niegue
servicio
hubiera
proceso
ejecutara
in-
definidamente
intencional
proceso
deshabilitara
ma-
nera
indefinida
error
programa
apropiación
necesaria
evitar
comportamiento
servidores
entran
categoría
general
servi-
cio
usuarios
remotos
prisa
sistemas
restricciones
tiempo
real
parezca
extraño
apropiación
ve-
ces
necesaria
procesos
ejecutar
periodos
ex-
tensos
general
realizan
trabajo
bloquean
rapidez
diferencia
sistemas
interactivos
sistemas
tiempo
real
ejecutan
programas
destinados
ampliar
aplicación
cuestión
sistemas
interactivos
propósito
general
eje-
cutar
programas
arbitrarios
cooperativos
malintencionados
www
FreeLibros.meMetas
algoritmos
planificación
diseñar
algoritmo
programación
necesario
idea
ha-
cer
algoritmo
objetivos
dependen
entorno
procesamiento
lotes
interac-
tivo
tiempo
real
deseables
casos
figura
2-39
listan
metas
continuación
analizaremos
sistemas
Equidad
Otorgar
proceso
justa
CPU
Aplicación
políticas
Verificar
lleven
cabo
políticas
establecidas
Balance
Mantener
ocupadas
partes
sistema
Sistemas
procesamiento
lotes
Rendimiento
Maximizar
número
trabajos
hora
Tiempo
retorno
Minimizar
tiempo
entrega
terminación
Utilización
CPU
Mantener
ocupada
CPU
tiempo
Sistemas
interactivos
Tiempo
respuesta
Responder
peticiones
rapidez
Proporcionalidad
Cumplir
expectativas
usuarios
Sistemas
tiempo
real
Cumplir
plazos
Evitar
perder
datos
Predictibilidad
Evitar
degradación
calidad
sistemas
multimedia
Figura
2-39
metas
algoritmo
planificación
distintas
circunstancias
circunstancias
equidad
importante
procesos
comparables
obte-
ner
servicio
comparable
justo
otorgar
proceso
tiempo
CPU
equivalente
distintas
categorías
procesos
tratar
Considere
control
seguridad
administración
nómina
centro
compu-
tacional
reactor
nuclear
ejecución
políticas
sistema
relacionada
equidad
política
local
procesos
control
seguridad
ejecuten
deseen
significa
nómina
tardará
30
segundos
planificador
asegurar
ejecute
política
meta
general
mantener
ocupadas
partes
sistema
CPU
dispositivos
mantener
ejecución
tiempo
rea-
lizará
cantidad
trabajo
componentes
inactivos
ejemplo
sistema
procesamiento
lotes
planificador
controla
tra-
bajos
llevan
memoria
ejecutarlos
procesos
limitados
CPU
al-
gunos
procesos
limitados
juntos
memoria
cargar
ejecutar
trabajos
limitados
CPU
terminen
cargar
ejecutar
trabajos
limitados
S.
utiliza
estrategia
procesos
ligados
CPU
ejecuten
lucharán
CPU
disco
inactivo
entren
trabajos
ligados
lu-
150
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
151
charán
disco
CPU
inactiva
mantener
sistema
ejecución
mis-
mo
tiempo
cuidadosa
mezcla
procesos
administradores
centros
cómputo
ejecutan
trabajos
proce-
samiento
lotes
comúnmente
basan
métricas
verificar
desempeño
siste-
rendimiento
tiempo
retorno
utilización
CPU
endimiento
número
trabajos
hora
completa
sistema
Considerando
detalles
terminar
50
tra-
bajos
hora
terminar
40
tiempo
retorno
tiempo
estadísticamente
promedio
des-
momento
envía
trabajo
lotes
momento
completa
parámetro
mide
tiempo
esperar
usuario
promedio
salida
regla
pequeño
bello
algoritmo
planificación
maximiza
rendimiento
necesariamente
minimiza
tiempo
retorno
ejemplo
dada
mezcla
trabajos
cortos
largos
planificador
ejecutado
trabajos
cortos
ejecutó
trabajos
largos
lograr
rendimiento
excelente
trabajos
cortos
hora
expensas
terrible
tiempo
retorno
trabajos
largos
trabajos
cortos
llegaran
tiempo
estable
trabajos
largos
ejecutarían
tiempo
respuesta
promedio
volvería
infinito
lograría
rendimiento
alto
utilización
CPU
emplea
métrica
sistemas
procesamien-
to
lotes
realidad
métrica
importa
trabajos
hora
salen
sistema
rendimiento
tiempo
requiere
obtener
trabajo
vuel-
ta
tiempo
retorno
utilización
CPU
métrica
clasificar
autos
base
hora
gira
motor
útil
detectar
CPU
llegando
100%
momento
obtener
cómputo
sistemas
interactivos
aplican
distintas
metas
importante
minimizar
tiempo
respuesta
tiempo
transcurre
emitir
comando
obtener
resul-
tado
computadora
personal
ejecuta
proceso
plano
ejemplo
leer
almacenar
correo
electrónico
red
petición
usuario
iniciar
programa
abrir
archivo
precedencia
trabajo
plano
pe-
ticiones
interactivas
atiendan
percibirá
servicio
cuestión
relacionada
denominarse
proporcionalidad
usuarios
idea
inherente
incorrecta
acerca
tardar
cosas
Cuan-
do
petición
percibe
compleja
tarda
tiempo
usuarios
aceptan
petición
percibe
simple
tarda
tiempo
usuarios
irritan
ejemplo
clic
icono
empieza
enviar
fax
sistema
tarda
60
segundos
completar
oración
usuario
probablemente
aceptará
gaje
oficio
espera
fax
envíe
segundos
usuario
clic
icono
interrumpe
conexión
telefónica
enviado
fax
expectativas
completado
30
segundos
probable
usuario
esté
sumamente
enojado
60
segundos
echando
espuma
boca
comportamiento
percepción
común
usuarios
supone
llamada
telefónica
enviar
fax
requiere
tiempo
colgar
teléfono
casos
planificador
acerca
www.FreeLibros.metiempo
respuesta
casos
especial
retraso
ma-
elección
orden
procesos
sistemas
tiempo
real
propiedades
distintas
sistemas
interactivos
en-
metas
planificación
caracterizan
tiempos
límite
debe-
rían
cumplirse
ejemplo
computadora
controlando
dispositivo
produce
datos
paso
regular
ejecutar
proceso
recolección
datos
tiempo
perder
infor-
mación
ende
principal
necesidad
sistema
tiempo
real
cumplir
tiempos
límite
mayoría
sistemas
tiempo
real
especial
involucran
multimedia
pre-
dictibilidad
importante
fatal
fallar
tiempo
límite
procesador
audio
ejecuta
errores
calidad
sonido
deteriorará
rapidez
video
cuen-
ta
oído
sensible
perturbación
ojo
evitar
problema
planificación
procesos
altamente
predecible
regular
capítulo
estudiaremos
algoritmos
planificación
procesamiento
lotes
interactivos
aplazaremos
estudio
planificación
tiempo
real
analicemos
sistemas
ope-
rativos
multimedia
capítulo
2.4.2
Planificación
sistemas
procesamiento
lotes
tiempo
pasar
cuestiones
planificación
general
algoritmos
planifi-
cación
específicos
sección
analizaremos
algoritmos
utilizan
sistemas
pro-
cesamiento
lotes
siguientes
secciones
examinaremos
sistemas
interactivos
tiempo
real
Vale
pena
aclarar
algoritmos
utilizan
sistemas
proce-
samiento
lotes
interactivos
estudiaremos
algoritmos
entrar
atendido
Probablemente
simple
algoritmos
planificación
tipo
entrar
atendido
FCFS
First-Come
First-Served
apropiativo
algo-
ritmo
CPU
asigna
procesos
orden
solicitan
esencia
cola
procesos
listos
trabajo
entra
sistema
exterior
mañana
inicia
inmediato
permite
ejecutarse
tiempo
desee
interrumpe
ejecutado
tiempo
medida
entrando
trabajos
colocan
fi-
nal
cola
proceso
ejecución
bloquea
proceso
cola
ejecuta
con-
tinuación
proceso
bloqueado
pasa
listo
trabajo
recién
llegado
coloca
cola
fuerza
algoritmo
fácil
comprender
igualmente
sencillo
pro-
gramar
equitativo
sentido
equitativo
asignar
escasos
bole-
tos
eventos
deportivos
conciertos
personas
dispuestas
permanecer
línea
A.M.
algoritmo
lista
ligada
procesos
lis-
tos
elegir
proceso
ejecutar
requiere
eliminar
frontal
cola
Pa-
ra
agregar
trabajo
desbloquear
proceso
adjuntarlo
cola
simple
comprender
implementar
152
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
153
desgracia
algoritmo
tipo
entrar
atendido
importante
desventaja
Suponga
proceso
ligado
cálculos
ejecuta
momento
procesos
limitados
utilizan
tiempo
CPU
1000
lecturas
disco
completarse
proceso
limitado
cálculos
ejecuta
lee
bloque
disco
Aho-
ra
ejecutan
procesos
inician
lecturas
disco
proceso
limitado
cálculos
obtiene
bloque
disco
ejecuta
seguido
procesos
limitados
rápida
sucesión
resultado
neto
proceso
limitado
llega
leer
bloque
reque-
rirá
1000
segundos
completarse
algoritmo
planificación
apropió
proce-
so
limitado
cálculos
10
mseg
procesos
limitados
terminarían
10
segundos
1000
segundos
quitar
velocidad
proceso
limitado
cálculos
trabajo
corto
analicemos
algoritmo
procesamiento
lotes
apropiativo
supone
tiempos
ejecución
conocen
antemano
ejemplo
compañía
seguros
perso-
nas
predecir
precisión
tiempo
requerirá
ejecutar
lote
1000
reclamaciones
realiza
trabajo
similar
trabajos
importancia
esperando
iniciados
cola
entrada
planificador
selecciona
trabajo
corto
SJF
Shortest
Job
First
Analice
figura
2-40
encontramos
tra-
bajos
tiempos
ejecución
minutos
respectivamente
ejecutar-
orden
tiempo
respuesta
minutos
12
minutos
16
minutos
20
minutos
promedio
14
minutos
Figura
2-40
ejemplo
planificación
tipo
trabajo
corto
Eje-
cución
trabajos
orden
original
Ejecución
trabajos
orden
tipo
trabajo
corto
consideremos
ejecutar
trabajos
usando
trabajo
corto
muestra
figura
2-40(b
tiempos
respuesta
12
20
minutos
promedio
11
minutos
Probablemente
óptimo
algoritmo
tipo
trabajo
corto
pri-
mero
Considere
caso
trabajos
tiempos
ejecución
respectivamen-
trabajo
termina
tiempo
termina
tiempo
/H11001b
sucesivo
tiempo
promedio
respuesta
4a
/H110013b
/H110012c
/H11001d)/4
contribuye
promedio
tiempos
trabajo
corto
continua-
ción
afecta
tiempo
retorno
mis-
mo
argumento
aplica
facilidad
número
trabajos
www
FreeLibros.meVale
pena
observar
trabajo
corto
óptimo
traba-
jos
disponibles
tiempo
ejemplo
contrario
considere
trabajos
tiempos
ejecución
respectivamente
tiempos
llegada
principio
elegir
trabajos
llegado
toda-
vía
Utilizando
trabajo
corto
ejecutaremos
trabajos
orden
pa-
ra
tiempo
espera
promedio
4.6
ejecutarlos
orden
espera
promedio
4.4
menor
tiempo
restante
continuación
versión
apropiativa
algoritmo
tipo
trabajo
corto
menor
tiempo
res-
tante
continuación
SRTN
Shortest
Remaining
Time
Next
algoritmo
planificador
selecciona
proceso
cuyo
tiempo
restante
ejecución
corto
de-
be
tiempo
ejecución
antemano
llega
trabajo
tiempo
compara
tiempo
restante
proceso
actual
trabajo
necesita
tiempo
terminar
proceso
actual
suspende
trabajo
inicia
esquema
permite
trabajos
cortos
obtengan
servicio
2.4.3
Planificación
sistemas
interactivos
analizaremos
algoritmos
utilizar
sistemas
interactivos
algo-
ritmos
comunes
computadoras
personales
servidores
tipos
sistemas
Planificación
turno
circular
algoritmos
antiguos
simples
equitativos
turno
circular
round-robin
proceso
asigna
intervalo
tiempo
conocido
quántum
du-
rante
permite
ejecutarse
proceso
ejecutando
CPU
apropiada
dársela
proceso
proceso
bloquea
termina
trans-
currido
quántum
conmutación
CPU
realiza
proceso
bloquea
lue-
go
fácil
implementar
algoritmo
turno
circular
realizador
necesita
mantener
lista
procesos
ejecutables
muestra
figura
2-41(a
proce-
so
utiliza
quántum
coloca
lista
muestra
figura
2-41(b
única
cuestión
interesante
algoritmo
turno
circular
longitud
quántum
conmutar
proceso
requiere
cantidad
tiempo
adminis-
tración
guardar
cargar
registros
mapas
memoria
actualizar
tablas
listas
vaciar
recargar
memoria
caché
sucesivamente
Suponga
conmutación
pro-
ceso
conmutación
contexto
llama
requiere
mseg
incluyendo
cambio
mapas
memoria
vaciado
recarga
caché
etc.
Suponga
quántum
establece
mseg
pa
rámetros
mseg
trabajo
útil
CPU
gastar
desperdiciar
mseg
conmutación
procesos
ende
154
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
155
20
ciento
CPU
desperdiciará
sobrecarga
administrativa
duda
dema-
siado
mejorar
eficiencia
CPU
podríamos
establecer
quántum
100
mseg
tiempo
desperdiciado
ciento
considere
ocurre
sistema
servidor
llegan
50
peticiones
intervalo
tiempo
corto
requerimientos
variables
CPU
colocarán
cincuenta
procesos
lista
procesos
ejecutables
CPU
inactiva
empezará
inmediato
inicie
100
mseg
sucesivo
desafortunado
esperar
segundos
oportunidad
suponiendo
utilizan
quántums
completos
mayoría
usuarios
percibirán
lenta
respuesta
segundos
comando
corto
Es-
ta
situación
mala
peticiones
cerca
cola
requirieron
milisegundos
tiempo
CPU
quántum
corto
hubieran
obtenido
ser-
vicio
factor
quántum
asigna
tiempo
ráfaga
promedio
CPU
apropiación
ocurrirá
frecuencia
mayoría
procesos
realizarán
operación
bloqueo
quántum
agote
ocasionando
conmuta-
ción
proceso
eliminar
apropiación
mejora
rendimiento
conmutaciones
procesos
ocurrirán
lógicamente
necesario
proceso
blo-
quee
continuar
conclusión
formular
establece
quántum
corto
producen
demasiadas
conmutaciones
procesos
reduce
eficiencia
CPU
pe-
ro
establece
producir
mala
respuesta
peticiones
interacti-
vas
cortas
quántum
valor
20
50
mseg
constituye
solución
razonable
Planificación
prioridad
planificación
turno
circular
suposición
implícita
procesos
importancia
frecuencia
personas
poseen
operan
computadoras
multiusuario
ideas
aspecto
ejemplo
universidad
orden
jerárqui-
co
decanos
profesores
secretarias
conserjes
estudiantes
necesidad
tomar
factores
externos
planificación
prioridad
idea
básica
simple
proceso
asigna
prioridad
proceso
ejecu-
table
prioridad
alta
ejecutar
Proceso
actual
proceso
BFDGA
Proceso
actual
FDGAB
Figura
2-41
Planificación
turno
circular
lista
procesos
ejecutables
lista
procesos
ejecutables
utiliza
quántum
www
FreeLibros.meIncluso
PC
propietario
procesos
importantes
ejemplo
proceso
demonio
envía
correo
electrónico
plano
debería
recibir
menor
prioridad
proceso
muestra
película
vi-
deo
pantalla
tiempo
real
evitar
procesos
alta
prioridad
ejecuten
indefinida
planifica-
dor
reducir
prioridad
proceso
actual
ejecución
pulso
reloj
interrupción
reloj
acción
prioridad
reduzca
valor
menor
proceso
prioridad
alta
ocurre
conmutación
procesos
mane-
ra
alternativa
proceso
asignar
quántum
tiempo
máximo
permi-
tido
ejecutarse
quántum
utiliza
proceso
prioridad
alta
recibe
oportunidad
ejecutarse
prioridades
asignar
procesos
forma
estática
dinámica
compu-
tadora
militar
procesos
iniciados
generales
empezar
prioridad
100
iniciados
coroneles
90
mayores
80
capitanes
70
tenien-
tes
60
sucesivamente
alternativa
centro
computacional
comercial
trabajos
prioridad
alta
costar
100
hora
prioridad
media
75
prio-
ridad
baja
50
hora
sistema
UNIX
comando
llamado
nice
permite
usuario
reducir
voluntaria
prioridad
proceso
agradable
usuarios
utiliza
sistema
asignar
prioridades
forma
dinámica
lograr
objeti-
vos
ejemplo
procesos
limitados
gastan
tiem-
po
esperando
complete
proceso
desea
CPU
recibirla
inmediato
dejar
inicie
petición
proceder
pa-
ralelo
proceso
encuentre
realizando
cálculos
proceso
limitado
espere
tiempo
CPU
significa
ocupando
memoria
tiempo
inne-
cesariamente
algoritmo
simple
servicio
procesos
limitados
establecer
prioridad
fracción
quántum
utilizó
proceso
proceso
utilizó
mseg
quántum
50
mseg
obtendría
prioridad
50
mien-
proceso
ejecutara
25
mseg
bloquearse
recibiría
prioridad
proceso
utilizara
quántum
completo
recibiría
prioridad
conveniente
agrupar
procesos
clases
prioridad
utilizar
planificación
prioridad
clases
planificación
turno
circular
clase
figura
2-42
muestra
sistema
clases
prioridad
algoritmo
programación
mien-
procesos
ejecutables
clase
prioridad
ejecutar
turno
circular
preocuparse
clases
menor
prioridad
clase
prioridad
vacía
ejecutar
procesos
clase
turno
circular
clases
vacías
en-
tonces
ejecutar
clase
turno
circular
sucesivamente
prioridades
ajustan
ma-
nera
ocasional
clases
menor
prioridad
morir
hambre(sin
tiempo
CPU
Múltiples
colas
planificadores
prioridad
CTSS
Sistema
tiempo
comparti-
do
compatible
M.I.T.
ejecutaba
IBM
7094
Corbató
colaboradores
1962
CTSS
156
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
157
problema
conmutación
procesos
lenta
7094
po-
contener
proceso
memoria
conmutación
procesos
ocasionaba
intercambiar
swapping
proceso
actual
disco
leer
disco
diseñadores
CTSS
die-
ron
rápidamente
eficiente
procesos
limitados
CPU
quántum
darles
quántums
pequeños
frecuencia
reducir
inter-
cambio
proporcionar
procesos
quántum
obtendría
tiem-
po
respuesta
pobre
visto
solución
establecer
clases
prioridades
procesos
clase
alta
ejecutaban
quántum
procesos
clase
alta
ejecutaban
quántums
procesos
clase
ejecutaban
quántums
sucesivamente
proceso
utilizaba
quántums
asignados
movía
clase
abajo
jerarquía
ejemplo
considere
proceso
necesita
cálculos
forma
continua
100
quántums
inicio
recibe
quántum
intercambia
proceso
disco
recibirá
quántums
vuelva
intercambiar
siguientes
ejecu-
ciones
obtendrá
12
16
32
64
quántums
utilizado
37
64
quántums
finales
completar
trabajo
intercambios
incluyendo
carga
inicial
requerirán
100
utiliza
algoritmo
turno
circular
medida
pro-
ceso
hunde
colas
prioridad
ejecutará
frecuencia
guardando
CPU
procesos
cortos
interactivos
política
adoptó
evitar
proceso
requería
ejecutarse
tiempo
empezó
volvió
interactivo
casti-
gado
escribía
retorno
carro
tecla
Intro
Enter
termi-
nal
proceso
pertenecía
terminal
movía
clase
prioridad
base
suposición
punto
volverse
interactivo
usuario
proce-
so
limitado
CPU
descubrió
sentarse
terminal
teclear
retornos
ca-
rro
azar
segundos
tiempo
respuesta
mejoraba
forma
considerable
contó
amigos
Moraleja
historia
llegar
correcto
práctica
di-
fícil
teoría
utilizado
algoritmos
asignar
procesos
clases
prioridades
ejemplo
influyente
sistema
XDS
940
Lampson
1968
construido
Berkeley
cla-
ses
prioridad
terminal
quántum
corto
quántum
proceso
es-
tado
esperando
entrada
terminal
despertaba
pasaba
clase
prioridad
Prioridad
Prioridad
Prioridad
Prioridad
Encabezados
colas
Procesos
ejecutables
Prioridad
alta
Prioridad
baja
Figura
2-42
algoritmo
planificación
clases
prioridad
www
FreeLibros.me(terminal
proceso
espera
bloque
disco
pasaba
listo
enviaba
clase
proceso
ejecución
agotaba
quántum
principio
colocaba
clase
obstante
proceso
utilizaba
quántum
dema-
siadas
seguidas
bloquearse
espera
terminal
tipo
movía
abajo
cola
sistemas
utilizan
similar
favorecer
usuarios
procesos
interactivos
ejecutan
plano
proceso
corto
continuación
algoritmo
tipo
trabajo
corto
produce
tiempo
respuesta
promedio
mínimo
sistemas
procesamiento
lotes
pudiera
utilizar
procesos
interactivos
grado
general
pro-
cesos
interactivos
siguen
patrón
esperar
comando
ejecutarlo
esperar
comando
eje-
cutarlo
etcétera
consideramos
ejecución
comando
trabajo
separado
podríamos
minimizar
tiempo
respuesta
ejecución
corto
único
problema
averiguar
procesos
actuales
ejecutables
corto
método
estimaciones
base
comportamiento
ejecutar
pro-
ceso
tiempo
ejecución
estimado
corto
Suponga
tiempo
estimado
co-
mando
terminal
suponga
ejecución
mide
T1
Podríamos
actualizar
estimación
suma
ponderada
números
aT
/H11001(1
/H11002a)T1
elección
decidir
proceso
estimación
olvide
ejecuciones
anteriores
rápidamente
recuerde
tiempo
/H110051/2
obtenemos
estimaciones
sucesivas
T0
/2
/H11001T1
/2
T0
/4
/H11001T1
/4
/H11001T2
/2
T0
/8
/H11001T1
/8
/H11001T2
/4
/H11001T3
/2
ejecuciones
peso
T0
estimación
reducido
1/8
técnica
estimar
valor
serie
obtención
promedio
pon-
derado
valor
actual
medido
estimación
conoce
envejeci-
miento
aplica
situaciones
predicción
base
valores
anteriores
especial
envejecimiento
fácil
implementar
/H110051/2
necesita
sumar
valor
estimación
actual
dividir
suma
desplazamiento
bit
derecha
Planificación
garantizada
método
completamente
distinto
planificación
promesas
reales
usuarios
acerca
rendimiento
cumplirlas
realista
fácil
cumplir
usuarios
conectados
trabajando
recibirá
1/
CPU
similar
sistema
usuario
procesos
ejecución
mien-
diferencias
usuario
obtener
ciclos
CPU
bastan-
justo
158
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
159
cumplir
promesa
sistema
potencia
CPU
te-
nido
proceso
creación
calcula
CPU
asignarse
ca-
proceso
tiempo
creó
dividido
n.
cantidad
tiempo
CPU
proceso
conoce
simple
calcular
proporción
tiempo
CPU
consumió
tiempo
CPU
proceso
derecho
proporción
0.5
indica
proceso
mitad
tiempo
debería
proporción
2.0
indica
proceso
doble
tiempo
debería
algo-
ritmo
ejecutar
proceso
menor
proporción
desplazado
deba-
jo
competidor
cercano
Planificación
sorteo
promesas
usuarios
cumplirlas
idea
difícil
implementar
utilizar
algoritmo
producir
resultados
similares
implementa-
ción
sencilla
algoritmo
conoce
planificación
sorteo
Waldspurger
Weihl
1994
idea
básica
procesos
boletos
lotería
diversos
recursos
sistema
tiempo
CPU
tomar
decisión
planificación
selecciona
boleto
lotería
azar
proceso
boleto
obtiene
recurso
aplica
planificación
CPU
sistema
sorteo
50
ganador
obtendría
20
mseg
tiempo
CPU
premio
Parafraseando
George
Orwell
procesos
iguales
igua-
procesos
importantes
recibir
boletos
adicionales
incrementar
probabilidad
ganar
100
boletos
repartidos
proceso
20
probabilidad
20
ciento
ganar
sorteo
larga
recibirá
20
ciento
tiempo
CPU
contraste
planificador
prioridad
difícil
establecer
significa
prioridad
40
regla
clara
proceso
contenga
fracción
boletos
recibirá
fracción
recurso
cuestión
planificación
lotería
propiedades
interesantes
ejemplo
aparece
proceso
recibe
boletos
sorteo
oportunidad
ganar
pro-
porción
número
boletos
palabras
planificación
lotería
alto
grado
respuesta
procesos
cooperativos
intercambiar
boletos
desean
ejemplo
proceso
cliente
envía
mensaje
proceso
servidor
bloquea
boletos
servidor
incrementar
probabilidad
ejecute
continuación
servidor
termina
devuelve
boletos
cliente
ejecutar
ausencia
clientes
servidores
necesitan
boletos
planificación
sorteo
utilizar
resolver
problemas
difíciles
mane-
jar
métodos
ejemplo
servidor
video
procesos
enviando
flujos
continuos
video
clientes
enviando
cuadros
distintas
velocidades
Suponga
proceso
necesita
cuadros
10
20
25
cuadros
asignar
procesos
10
20
25
boletos
respectivamente
dividirán
automática
tiempo
CPU
propor-
ción
correcta
aproximada
10
20
25
www
FreeLibros.mePlanificación
partes
equitativas
asumido
proceso
planifica
importar
propietario
resultado
usuario
inicia
procesos
usuario
inicia
proceso
planificación
turno
circular
prioridades
iguales
usuario
obtendrá
90
ciento
tiempo
CPU
usuario
recibirá
10
ciento
evitar
situación
sistemas
toman
consideración
propietario
proceso
planificarlo
modelo
usuario
asigna
fracción
CPU
planificador
selecciona
procesos
forma
cumpla
modelo
ende
usuarios
prometió
50
ciento
tiempo
CPU
obtendrán
importar
procesos
tengan
existencia
ejemplo
considere
sistema
usuarios
pro-
metió
50
ciento
CPU
usuario
procesos
usuario
proceso
utiliza
planificación
turno
circular
secuencia
plani-
ficación
cumple
restricciones
AE
usuario
derecho
doble
tiempo
CPU
usuario
podría-
mos
obtener
secuencia
AB
posibilidades
explotar
dependiendo
noción
equidad
2.4.4
Planificación
sistemas
tiempo
real
sistema
tiempo
real
tiempo
desempeña
papel
esencial
general
dispositivos
físicos
externos
computadora
generan
estímulo
computadora
reaccionar
apropiada
cantidad
fija
tiempo
ejemplo
computadora
reproductor
disco
compacto
recibe
bits
medida
provienen
unidad
convertirlos
música
intervalo
tiempo
estrecho
cálculo
tarda
música
sonido
peculiar
sistemas
tiempo
real
monitoreo
pacientes
unidad
cuidados
intensivos
hospital
autopiloto
aeronave
control
ro-
bots
fábrica
automatizada
casos
respuesta
correcta
malo
tenerla
general
sistemas
tiempo
real
categorizan
tiempo
real
duro
sig-
nifica
tiempos
límite
absolutos
cumplir
tiempo
real
suave
significa
conveniente
fallar
tiempo
límite
ocasiones
tole-
rable
casos
comportamiento
tiempo
real
logra
dividiendo
programa
procesos
comportamiento
predecible
conoce
antemano
general
procesos
tiempos
vida
cortos
ejecutarse
completarse
detecta
evento
externo
responsabilidad
plani-
ficador
planificar
procesos
forma
cumpla
tiempos
límite
160
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.4
PLANIFICACIÓN
161
eventos
llegar
responder
sistema
tiempo
real
categorizar
periódicos
ocurren
intervalos
regulares
aperiódicos
ocurren
impre-
decible
sistema
responder
flujos
eventos
periódicos
Dependien-
do
tiempo
requiera
evento
procesamiento
siquiera
manejarlos
ejemplo
eventos
periódicos
evento
ocurre
periodo
requiere
Ci
segundos
tiempo
CPU
manejar
evento
carga
po-
drá
manejar
sistema
tiempo
real
cumple
criterio
planificable
ejemplo
considere
sistema
tiempo
real
eventos
periódicos
periodos
100
200
500
mseg
respectivamente
eventos
requieren
50
30
100
mseg
tiempo
CPU
evento
respectivamente
sistema
planificable
0.5
/H110010.15
/H110010.2
agrega
cuarto
evento
periodo
sistema
seguirá
planificable
evento
requiera
150
mseg
tiempo
CPU
evento
es-
cálculo
implícita
suposición
sobrecarga
conmutación
contexto
pequeña
ignorar
algoritmos
planificación
tiempo
real
estáticos
dinámicos
toman
decisiones
planificación
sistema
empiece
ejecutarse
segundos
tiempo
ejecución
planificación
estática
funciona
infor-
mación
perfecta
disponible
antemano
acerca
trabajo
tiempos
límite
cumplir
algoritmos
planificación
dinámicos
restricciones
Aplazaremos
estudio
algoritmos
específicos
capítulo
trataremos
sis-
temas
multimedia
tiempo
real
2.4.5
Política
mecanismo
tácitamente
procesos
sistema
pertenecen
distin-
tos
usuarios
compiten
CPU
su-
cede
proceso
hijos
ejecutándose
control
ejemplo
proceso
sistema
administración
bases
datos
hijos
hijo
trabajando
petición
distinta
función
específica
análisis
consultas
acceso
disco
ejemplo
completo
proceso
prin-
cipal
idea
excelente
acerca
hijos
importante
requiere
tiem-
po
urgencia
importante
desgracia
planificadores
descritos
acepta
entrada
procesos
usuario
acerca
decisiones
planificación
resultado
raras
planificador
toma
decisión
solución
problema
separar
mecanismo
planificación
política
pla-
nificación
principio
establecido
tiempo
Levin
colaboradores
1975
signi-
fica
algoritmo
planificación
parametrizado
forma
procesos
usuario
llenar
parámetros
Consideremos
ejemplo
base
datos
Pi
Ci
www
FreeLibros.meSuponga
kernel
utiliza
algoritmo
planficación
prioridad
proporciona
lla-
mada
sistema
proceso
establecer
modificar
prioridades
hijos
forma
padre
controlar
detalle
forma
planifican
hijos
encarga
planificación
mecanismo
kernel
política
establece
proceso
usuario
2.4.6
Planificación
hilos
procesos
múltiples
hilos
niveles
paralelismo
pre-
sentes
procesos
hilos
planificación
tales
sistemas
difiere
forma
considerable
depen-
diendo
soporte
hilos
nivel
usuario
hilos
nivel
kernel
Consideremos
hilos
nivel
usuario
kernel
consciente
exis-
tencia
hilos
opera
forma
selecciona
proceso
otor-
ga
proceso
control
quántum
planificador
hilos
decide
hilo
ejecutar
A1
interrupciones
reloj
multiprogramar
hilos
hilo
pue-
continuar
ejecutándose
tiempo
quiera
utiliza
quántum
proceso
ker-
nel
seleccionará
proceso
ejecutarlo
proceso
ejecute
hilo
A1
continuará
ejecución
Seguirá
consumiendo
tiempo
termine
comportamiento
antisocial
afectará
procesos
recibirán
planificador
procesos
considere
apropiada
importar
esté
ocurriendo
proceso
A.
considere
caso
hilos
relativamente
trabajo
ráfaga
CPU
ejemplo
mseg
trabajo
quántum
50
mseg
consecuencia
ejecuta
instantes
entrega
CPU
planificador
hilos
producir
secuencia
A1
A2
A3
A1
A2
A3
A1
A2
A3
A1
ker-
nel
conmute
proceso
B.
situación
ilustra
figura
2-43(a
algoritmo
planificación
utilizado
sistema
tiempo
ejecución
cual-
quiera
descritos
práctica
algoritmos
planificación
turno
circular
planificación
prioridad
comunes
única
restricción
ausencia
reloj
pa-
ra
interrumpir
proceso
ejecutado
tiempo
considere
situación
hilos
nivel
kernel
kernel
selecciona
hilo
especí-
fico
ejecutarlo
tomar
proceso
pertenece
hilo
ha-
cerlo
desea
hilo
recibe
quántum
suspende
obligatoriamente
excede
quántum
quántum
50
mseg
hilos
bloquean
mseg
orden
hilos
periodo
30
mseg
A1
B1
A2
B2
A3
B3
posi-
ble
parámetros
hilos
nivel
usuario
situación
ilustra
forma
parcial
fi-
gura
2-43(b
diferencia
importante
hilos
nivel
usuario
hilos
nivel
kernel
rendimien-
to
conmutación
hilos
hilos
nivel
usuario
requiere
instruccio-
nes
máquina
hilos
nivel
kernel
requiere
conmutación
contexto
cambiar
mapa
memoria
invalidar
caché
órdenes
magnitud
lento
la-
do
hilos
nivel
kernel
hilo
bloquea
espera
suspende
proceso
hilos
nivel
usuario
162
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.5
PROBLEMAS
CLÁSICOS
COMUNICACIÓN
PROCESOS
163
kernel
costoso
conmutar
hilo
proceso
hilo
proceso
ejecutar
hilo
proceso
cambiar
mapa
memoria
arruina
memoria
caché
considerar
información
tomar
deci-
sión
ejemplo
dados
hilos
importancia
pertenece
proceso
hilo
acaba
bloquear
pertenece
proceso
distinto
preferencia
factor
importante
hilos
nivel
usuario
emplear
planificador
hilos
específico
aplicación
ejemplo
considere
servidor
Web
figura
2-8
Suponga
hilo
trabajador
acaba
bloquearse
hilo
despachador
hilos
trabajadores
listos
ejecutarse
continuación
sistema
tiempo
ejecución
hilos
seleccionar
fácilmente
despachador
ejecute
conti-
nuación
iniciar
ejecución
hilo
trabajador
estrategia
maximi-
za
cantidad
paralelismo
entorno
trabajadores
bloquean
frecuencia
disco
hilos
nivel
kernel
kernel
sabría
hilo
aun-
asignar
distintas
prioridades
general
planificadores
hilos
específicos
aplicación
optimizar
aplicación
kernel
2.5
PROBLEMAS
CLÁSICOS
COMUNICACIÓN
PROCESOS
IPC
literatura
sistemas
operativos
repleta
interesantes
problemas
descrito
ana-
lizado
ampliamente
variedad
métodos
sincronización
siguien-
tes
secciones
examinaremos
problemas
conocidos
Proceso
Proceso
Proceso
BProceso
kernel
selecciona
proceso
kernel
selecciona
hilo
A1
A2
A3
A1
A2
A3
A1
B1
A2
B2
A3
B3
A1
A2
A3
A1
A2
A3
Imposible
A1
B1
A2
B2
A3
B3
Orden
ejecutan
hilos
sistema
tiempo
ejecución
selecciona
hilo
123
13
Figura
2-43
planificación
hilos
nivel
usuario
quántum
50
mseg
proceso
hilos
ejecutan
mseg
ráfaga
CPU
planificación
hilos
nivel
kernel
característi-
cas
www
FreeLibros.me2.5.1
problema
filósofos
comelones
1965
Dijkstra
propuso
resolvió
problema
sincronización
llamó
problema
filósofos
comelones
momento
inventaban
primitiva
sincroni-
zación
sentían
obligados
demostrar
maravillosa
primitiva
mostrar
elegancia
resolvía
problema
filósofos
comelones
problema
enunciar
simplemente
filósofos
sentados
mesa
circular
filósofo
plato
espagueti
espagueti
resbaloso
filósofo
necesita
tenedores
comerlo
par
platos
tenedor
distribución
mesa
ilus-
tra
figura
2-44
164
PROCESOS
HILOS
CAPÍTULO
Figura
2-44
Hora
comer
Departamento
Filosofía
vida
filósofo
consiste
periodos
alternos
comer
pensar
abstracción
filósofos
actividades
irrelevantes
Cuan-
do
filósofo
hambre
adquirir
tenedores
izquierdo
derecho
orden
éxito
adquirir
tenedores
come
momento
deja
tenedores
continúa
pensando
pregunta
clave
escribir
programa
filósofo
haga
supone
trabe
recalcado
requeri-
miento
tenedores
artificial
deberíamos
cambiar
comida
italiana
co-
mida
china
sustituir
espagueti
arroz
tenedores
palillos
chinos
figura
2-45
muestra
solución
obvia
procedimiento
tomar_tenedor
espera
tenedor
específico
esté
disponible
toma
desgracia
solución
obvia
Su-
ponga
filósofos
toman
tenedores
izquierdos
tiempo
to-
mar
tenedores
derechos
interbloqueo
www
FreeLibros.meSECCIÓN
2.5
PROBLEMAS
CLÁSICOS
COMUNICACIÓN
PROCESOS
165
define
número
filósofos
void
filosofo(int
número
filósofo
while(TRUE
pensar
filósofo
pensando
tomar_tenedor(i
toma
tenedor
izquierdo
tomar_tenedor((i+1
toma
tenedor
derecho
operador
módulo
comer
come
espagueti
poner_tenedor(i
pone
tenedor
izquierdo
vuelta
mesa
poner_tenedor((i+1
pone
tenedor
derecho
vuelta
mesa
Figura
2-45
solución
incorrecta
problema
filósofos
comelones
Podríamos
modificar
programa
tomar
tenedor
izquierdo
pro-
grama
compruebe
tenedor
derecho
disponible
filósofo
regresa
tenedor
izquierdo
espera
tiempo
repite
proceso
proposición
falla
tam-
bién
razón
distinta
mala
suerte
filósofos
iniciar
algoritmo
forma
simultánea
tomarían
tenedores
izquierdos
verían
tenedores
de-
rechos
disponibles
regresarían
tenedores
izquierdos
esperarían
volverían
tomar
tenedores
izquierdos
tiempo
sucesivo
eternamente
situación
programas
continúan
ejecutándose
forma
indefinida
progresan
co-
noce
inanición
starvation
llama
inanición
problema
ocurre
res-
taurante
italiano
chino
podríamos
pensar
filósofos
esperan
tiempo
aleatorio
es-
perar
tiempo
adquirir
tenedor
derecho
probabilidad
continúe
bloqueado
hora
pequeña
observación
ca-
aplicaciones
intentar
tiempo
posterior
representa
problema
ejemplo
popular
red
área
local
Ethernet
computadoras
envían
paquete
tiempo
espera
tiempo
aleatorio
intenta
práctica
solución
funciona
aplicaciones
preferible
solución
fun-
cione
fallar
serie
improbable
números
aleatorios
Piense
acerca
control
seguridad
planta
energía
nuclear
mejora
figura
2-45
interbloqueo
inanición
proteger
ins-
trucciones
siguen
llamada
pensarmediante
semáforo
binario
empezar
ad-
quirir
tenedores
filósofo
realizaría
operación
down
mutex
regresar
tenedores
realizaría
operación
up
mutex
punto
vista
teórico
solución
adecuada
punto
vista
práctico
error
rendimiento
fi-
lósofo
comiendo
instante
tenedores
disponibles
deberíamos
permi-
tir
filósofos
coman
tiempo
solución
presenta
figura
2-46
libre
interbloqueos
permite
máximo
paralelismo
número
arbitrario
filósofos
Utiliza
arreglo
llamado
www
FreeLibros.me166
PROCESOS
HILOS
CAPÍTULO
define
número
filósofos
define
IZQUIERDO
i+N-1)%N
número
vecino
izquierdo
define
DERECHO
i+1)%N
número
vecino
derecho
define
PENSANDO
filósofo
pensando
define
HAMBRIENTO
filósofo
obtener
tenedores
define
COMIENDO
filósofo
comiendo
typedef
int
semaforo
semáforos
tipo
especial
int
int
estado[N
arreglo
registro
todos*/
semaforo
mutex
exclusión
mutua
regiones
críticas
semaforo
s[N
semáforo
filósofo
void
filosofo(int
número
filósofo
H110021
while(TRUE
repite
forma
indefinida
pensar
filósofo
pensando
tomar_tenedores(i
adquiere
tenedores
bloquea
comer
come
espagueti
poner_tenedores(i
pone
vuelta
tenedores
mesa
void
tomar_tenedores(int
número
filósofo
H110021
down(&mutex
entra
región
crítica
estado[i
HAMBRIENTO
registra
filósofo
hambriento
probar(i
adquirir
tenedores
up(&mutex
sale
región
crítica
down(&s[i
bloquea
adquirieron
tenedores
void
poner_tenedores(i
número
filósofo
N–1
down(&mutex
entra
región
crítica
estado[i
PENSANDO
filósofo
terminó
comer
probar(IZQUIERDO
verifica
vecino
izquierdo
comer
probar(DERECHO
verifica
vecino
derecho
comer
up(&mutex
sale
región
crítica
void
probar(i
número
filósofo
H110021
if
estado[i
HAMBRIENTO
estado[IZQUIERDO
COMIENDO
estado[DERECHO
COMIENDO
estado[i
COMIENDO
up(&s[i
Figura
2-46
solución
problema
filósofos
comelones
www
FreeLibros.meSECCIÓN
2.5
PROBLEMAS
CLÁSICOS
COMUNICACIÓN
PROCESOS
167
registro
filósofo
comiendo
pensando
hambriento
tratando
adquirir
tenedores
filósofo
mover
comer
vecino
comiendo
vecinos
filósofo
definen
macros
IZQUIERDO
DERECHO
palabras
IZQUIERDO
DERECHO
programa
utiliza
arreglo
semáforos
filósofo
filó-
sofos
hambrientos
puedan
bloquearse
tenedores
necesitan
ocupados
Observe
proceso
ejecuta
procedimiento
ilosofo
código
principal
proce-
dimientos
tomar_tenedores
poner_tenedores
probar
ordinarios
procesos
separados
2.5.2
problema
lectores
escritores
problema
filósofos
comelones
útil
modelar
procesos
compiten
acceso
ex-
clusivo
número
limitado
recursos
dispositivos
S.
problema
famoso
lectores
escritores
Courtois
colaboradores
1971
modela
acceso
base
da-
tos
ejemplo
imagine
sistema
reservación
aerolíneas
procesos
compe-
tencia
desean
leer
escribir
aceptable
procesos
lean
base
datos
tiempo
proceso
actualizando
escribiendo
base
datos
proceso
acceso
base
datos
siquiera
lectores
pregunta
pro-
graman
lectores
escritores
solución
muestra
figura
2-47
solución
lector
obtener
acceso
base
datos
realiza
operación
downen
semáforo
bd
siguientes
lectores
simplemente
incrementan
contador
llamado
cl
medida
lectores
saliendo
decrementan
contador
realiza
operación
upen
semáforo
permitir
escritor
bloqueado
solución
presenta
contiene
forma
implícita
decisión
sutil
vale
pe-
na
observar
Suponga
lector
utiliza
base
datos
llega
lector
problema
lectores
tiempo
lector
admitido
admitir
lectores
llegan
suponga
aparece
escritor
admitido
base
datos
escritores
acceso
exclusivo
ende
escritor
suspende
apare-
cen
lectores
adicionales
lector
activo
admitirán
siguientes
lectores
consecuencia
estrategia
suministro
continuo
lectores
entrarán
lleguen
escritor
suspendido
lector
presente
llega
lector
segundos
lector
requiere
segundos
tra-
escritor
entrará
evitar
situación
programa
escribir
ligeramente
distinta
llega
lector
escritor
espera
lector
suspende
escritor
admitido
inmediato
forma
escritor
esperar
terminen
lec-
tores
activos
esperar
lectores
llegaron
des-
pués
desventaja
solución
logra
menor
concurrencia
ende
menor
rendimiento
Courtois
colaboradores
presentan
solución
prioridad
es-
critores
obtener
detalles
consulte
bibliografía
www.FreeLibros.metypedef
int
semaforo
use
imaginación
semaforo
mutex=1
controla
acceso
cl
semaforo
bd=1
controla
acceso
base
datos
int
cl=0
procesos
leen
desean
void
lector(void
while(TRUE
repite
indefinida
down(&mutex
obtiene
acceso
exclusivo
cl
cl
cl
lector
if
cl
down(&bd
lector
up(&mutex
libera
acceso
exclusivo
cl
leer_base_de_datos
accede
datos
down(&mutex
obtiene
acceso
exclusivo
cl
cl
cl
lector
if
cl
up(&bd
lector
up(&mutex
libera
acceso
exclusivo
cl
usar_lectura_datos
región
crítica
void
escritor(void
while(TRUE
repite
indefinida
pensar_datos
región
crítica
down(&bd
obtiene
acceso
exclusivo
escribir_base_de_datos
actualiza
datos
up(&bd
libera
acceso
exclusivo
Figura
2-47
solución
problema
lectores
escritores
2.6
INVESTIGACIÓN
ACERCA
PROCESOS
HILOS
capítulo
analizamos
investigación
actual
acerca
estructura
sistemas
operativos
capítulo
veremos
investigación
enfoque
específico
empe-
zando
procesos
aclarará
tiempo
temas
asentados
investigación
tiende
temas
presentes
décadas
concepto
proceso
ejemplo
asentado
sis-
tema
noción
proceso
contenedor
agrupar
recursos
relacionados
espacio
direcciones
hilos
archivos
abiertos
permisos
protección
etcétera
distintos
sistemas
realizan
agrupamientos
formas
ligeramente
dife-
rencias
ingeniería
idea
básica
controversial
investigación
cuan-
to
tema
procesos
168
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
2.7
RESUMEN
169
hilos
idea
reciente
procesos
presentes
tiempo
aparece
artículo
ocasional
acerca
hilos
ejem-
plo
acerca
agrupamientos
hilos
multiprocesadores
Tam
colaboradores
2007
esca-
lando
número
hilos
proceso
100,000
on
Behren
colaboradores
2003
sincronización
procesos
tema
establecido
presenta
artículo
acerca
procesamiento
concurrente
candados
Fraser
Harris
2007
sincronización
bloqueo
sistemas
tiempo
real
Hohmuth
Haertig
2001
planificación
procesos
uniprocesadores
multiprocesadores
tema
cercano
querido
investigadores
temas
inves-
tigando
incluyen
planificación
eficiencia
energía
dispositivos
móviles
Yuan
Nahrs-
tedt
2006
planificación
capacidad
hiperhilamiento
Bulpin
Pratt
2005
CPU
estaría
inactiva
caso
Eggert
Touch
2005
planificación
tiempo
virtual
Nieh
colaboradores
2001
diseñadores
sistemas
actualidad
busca
algoritmo
decente
planificación
hilos
tipo
investigación
interés
investigador
demanda
procesos
hilos
planificación
temas
interés
an-
tes
investigación
avanzado
áreas
2.7
RESUMEN
ocultar
efectos
interrupciones
sistemas
operativos
proporcionan
modelo
con-
ceptual
consiste
procesos
secuenciales
ejecutándose
paralelo
procesos
crear
terminar
forma
dinámica
proceso
espacio
direcciones
aplicaciones
conveniente
hilos
control
proce-
so
hilos
planifican
independiente
pila
hilos
proceso
comparten
espacio
direcciones
común
hilos
implementar
espacio
usuario
kernel
procesos
comunicar
primitivas
comunicación
procesos
semáforos
monitores
mensajes
primitivas
utilizan
asegurar
procesos
regiones
críticas
tiempo
situación
produce
caos
proceso
ejecución
listo
ejecutarse
bloqueado
pudiendo
cambiar
proceso
ejecute
primitivas
comunicación
procesos
comunicación
hilos
similar
primitivas
comunicación
procesos
utilizar
resolver
problemas
ta-
productor-consumidor
filósofos
comelones
lectores
escritores
primitivas
cuidado
evitar
errores
interbloqueos
estudiado
algoritmos
planificación
utilizan
principal-
mente
sistemas
procesamiento
lotes
planificación
trabajo
corto
prime-
ro
comunes
sistemas
procesamiento
lotes
sistemas
interactivos
algoritmos
incluyen
planificación
turno
circular
prioridad
colas
www.FreeLibros.memultiniveles
planificación
garantizada
planificación
lotería
planificación
partes
equitati-
vas
sistemas
clara
separación
mecanismo
planificación
política
planificación
permite
usuarios
control
algoritmo
planificación
PROBLEMAS
figura
2-2
muestran
procesos
teoría
transiciones
muestran
transiciones
Exis-
circunstancia
ambas
transiciones
faltantes
pudiera
ocurrir
Suponga
diseñar
arquitectura
computadora
avanzada
hiciera
conmutación
procesos
hardware
interrupciones
información
necesitaría
CPU
Des-
criba
trabajar
conmutación
procesos
hardware
computadoras
actuales
manejadores
interrupciones
es-
criben
lenguaje
ensamblador
interrupción
llamada
sistema
transfiere
control
sistema
operativo
general
utiliza
área
pila
kernel
separada
pila
proceso
interrumpido
trabajos
ejecutar
paralelo
terminar
rapidez
hubieran
ejecu-
tado
secuencia
Suponga
trabajos
necesita
10
minutos
tiempo
CPU
inician
tiempo
tiempo
tardará
completarse
ejecu-
forma
secuencial
tiempo
ejecutan
paralelo
Suponga
50%
es-
pera
S.
texto
estableció
modelo
figura
2-11(a
adecuado
servidor
ar-
chivos
utiliza
memoria
caché
proceso
caché
proceso
multihilamiento
utiliza
operación
fork
ocurre
problema
hijo
obtiene
co-
pias
hilos
padre
Suponga
hilos
originales
esperando
entra-
teclado
hilos
esperando
entrada
teclado
proceso
Acaso
ocurre
problema
procesos
hilo
figura
2-8
muestra
servidor
Web
multihilamiento
única
forma
leer
archi-
vo
llamada
sistema
read
normal
bloqueo
cree
usando
hilos
nivel
usuario
hilos
nivel
kernel
servidor
Web
texto
describimos
servidor
Web
multihilamiento
mostrando
servidor
hilo
servidor
máquina
finitos
circunstan-
cia
servidor
hilo
Dé
ejemplo
10
figura
2-12
conjunto
registros
lista
hilos
procesos
Des-
pués
máquina
conjunto
registros
11
hilo
otorgaría
voluntaria
CPU
llamar
thread_yield
interrupción
periódica
reloj
obtenga
CPU
vuelta
12
darse
apropiamiento
hilo
interrupción
reloj
circunstancias
170
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
171
13
problema
comparar
lectura
archivo
utilizando
servidor
archivos
hilo
servidor
multihilado
requieren
15
mseg
obtener
petición
despacharla
resto
procesamiento
necesario
suponiendo
datos
necesarios
caché
bloque
necesita
operación
disco
caso
tiempo
requieren
75
mseg
adicionales
hilo
duerme
peticiones
manejar
servidor
hilo
multihilado
14
ventaja
implementar
hilos
espacio
usuario
desven-
taja
15
figura
2-15
creaciones
hilos
mensajes
impresos
intercalan
azar
forma
forzar
orden
estrictamente
hilo
creado
hilo
impri-
mensaje
hilo
termina
hilo
creado
hilo
imprime
mensaje
hilo
termina
suce-
sivo
16
análisis
variables
globales
hilos
utilizamos
procedimiento
llamado
crear_global
asignar
espacio
apuntador
variable
variable
esencial
trabajar
procedimientos
valores
forma
17
Considere
sistema
hilos
implementan
completo
espacio
usuario
sistema
tiempo
ejecución
obtiene
interrupción
reloj
Su-
ponga
ocurre
interrupción
reloj
hilo
ejecuta
sistema
tiempo
ejecución
problema
ocurrir
sugerir
forma
resolverlo
18
Suponga
sistema
operativo
parecido
llamada
sistema
select
adelantado
seguro
leer
archivo
canal
dispositivo
permite
establecer
relo-
jes
alarma
interrumpen
llamadas
bloqueadas
sistema
implementar
pa-
quete
hilos
espacio
usuario
condiciones
Explique
19
problema
inversión
prioridades
vimos
sección
2.3.4
ocurrir
hilos
ni-
vel
usuario
20
sección
2.3.4
describió
situación
proceso
alta
prioridad
proceso
ba-
ja
prioridad
ocasionaba
iterara
forma
indefinida
Ocurre
problema
utiliza
planificación
turno
circular
planificación
prioridad
Explique
21
sistema
hilos
pila
hilo
pila
proceso
utilizan
hilos
nivel
usuario
utilizan
hilos
nivel
kernel
Explique
22
desarrollando
computadora
general
simula
pro-
grama
ejecuta
instrucción
multiprocesadores
simulan
estricta-
mente
forma
secuencial
ocurra
condición
carrera
eventos
simultáneos
23
Funciona
solución
espera
ocupada
utiliza
variable
turno
figura
2-23
procesos
ejecutan
multiprocesador
memoria
compartida
CPU
comparten
memoria
común
24
solución
Peterson
problema
exclusión
mutua
muestra
figura
2-24
funcio-
na
planificación
apropiativa
pasa
apropiativa
25
Dé
bosquejo
acerca
sistema
operativo
deshabilitar
interrupciones
implementar
semáforos
www
FreeLibros.me26
Muestre
implementarse
semáforos
contadores
semáforos
contener
valor
arbitrario
utilizando
semáforos
binarios
instrucciones
máquina
ordina-
rias
27
sistema
procesos
sentido
utilizar
barrera
sincronizarlos
28
hilos
proceso
sincronizarse
semáforo
kernel
hilos
implementados
kernel
pasa
implementan
espacio
usuario
Suponga
hilo
proceso
acceso
semáforo
Analice
respuestas
29
sincronización
monitores
utiliza
variables
condición
operaciones
especiales
wait
signal
forma
general
sincronización
tendría
primitiva
waituntil
tuviera
predicado
booleano
arbitrario
parámetro
podríamos
ejemplo
waituntil
/H11001z
primitiva
signal
necesaria
evidente
esquema
general
Hoare
Brinch
Hansen
utiliza
Sugerencia
Considere
implementación
30
restaurante
comida
rápida
tipos
empleados
toman
pedidos
clientes
cocineros
preparan
comida
especialistas
empaquetado
meten
comida
bolsas
cajeros
entregan
bolsas
clientes
reciben
dinero
Ca-
empleado
considerarse
proceso
secuencial
comunicativo
forma
comu-
nicación
procesos
utilizan
Relacione
modelo
procesos
UNIX
31
Suponga
sistema
paso
mensajes
utiliza
buzones
enviar
buzón
lle-
tratar
recibir
vacío
proceso
bloquea
recibe
vuelta
código
error
responder
código
error
proceso
vuelve
intentar
éxito
Produce
esquema
condiciones
carrera
32
computadoras
CDC
6000
podían
manejar
10
procesos
forma
simultánea
utili-
zando
forma
interesante
planificación
turno
circular
conocida
compartición
procesador
llevaba
cabo
conmutación
procesos
instrucción
instrucción
provenía
proceso
instrucción
proceso
etcétera
conmutación
procesos
realizaba
hardware
especial
sobrecarga
cero
proceso
necesi-
taba
segundos
completarse
ausencia
competencia
tiempo
necesitaría
uti-
lizara
compartición
procesador
procesos
33
medida
determinar
analizando
código
fuente
proceso
probable
es-
té
limitado
CPU
limitado
determinarse
tiempo
ejecución
34
sección
planificar
planificación
po-
dría
mejorar
proceso
importante
pudiera
desempeñar
papel
seleccionar
pro-
ceso
ejecutar
bloquearse
Mencione
situación
utilizar
explique
35
mediciones
sistema
demostrado
proceso
promedio
ejecuta
tiempo
bloquearse
operación
S.
conmutación
procesos
requie-
re
tiempo
efectivamente
desperdiciado
sobrecarga
planificación
turno
cir-
cular
quántum
proporcione
fórmula
eficiencia
CPU
siguientes
casos
172
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
173
/H11005∞
/H11005S
cercano
36
trabajos
espera
ejecutados
tiempos
ejecución
esperados
X.
orden
ejecutar
minimizar
tiempo
respuesta
promedio
respues-
ta
dependerá
37
trabajos
procesamiento
lotes
llegan
centro
cómputo
tiem-
po
tiempos
ejecución
estimados
10
minutos
prioridades
determina-
das
forma
externa
respectivamente
prioridad
alta
siguientes
algoritmos
planificación
determine
tiempo
respuesta
proce-
so
promedio
Ignore
sobrecarga
conmutación
procesos
turno
circular
prioridad
entrar
atendido
ejecutados
orden
10
8)
trabajo
corto
suponga
sistema
multiprogramado
trabajo
recibe
equitativa
CPU
incisos
suponga
ejecuta
trabajo
termina
trabajos
completamente
ligados
CPU
38
proceso
ejecuta
CTSS
necesita
30
quántums
completarse
intercambiar
incluyendo
ejecutado
siquiera
39
idear
forma
evitar
sistema
prioridades
CTSS
engañado
retornos
carro
40
algoritmo
envejecimiento
/H110051/2
utiliza
predecir
tiempos
ejecución
ejecuciones
anteriores
antigua
reciente
40
20
40
15
mseg
predicción
tiempo
41
sistema
tiempo
real
suave
eventos
periódicos
periodos
50
100
200
250
mseg
Suponga
eventos
requieren
35
20
10
mseg
tiempo
CPU
respectivamente
valor
sistema
planificable
42
Explique
utiliza
comúnmente
planificación
niveles
43
sistema
tiempo
real
necesita
manejar
llamadas
voz
eje-
cuta
mseg
consume
mseg
tiempo
CPU
ráfaga
video
25
cuadros-
/segundo
cuadro
requiere
20
mseg
tiempo
CPU
planificable
sistema
44
Considere
sistema
desean
separar
política
mecanismo
planificación
hilos
kernel
Proponga
lograr
objetivo
45
solución
problema
filósofos
comelones
figura
2-46
variable
establece
HAMBRIENTO
procedimiento
tomar_tenedores
www
FreeLibros.me46
Considere
procedimiento
poner_tenedores
figura
2-46
Suponga
variable
estado[i
estableció
PENSANDO
llamadas
probar
afectaría
solución
47
problema
lectores
escritores
formular
maneras
catego-
ría
procesos
iniciar
Describa
cuidado
variaciones
distintas
pro-
blema
favoreciendo
favoreciendo
categoría
procesos
variación
especifique
ocurre
lector
escritor
listo
acceder
base
datos
ocurre
proceso
termina
base
datos
48
Escriba
secuencia
comandos
shell
produzca
archivo
números
secuenciales
leer
número
archivo
sumarle
adjuntar
resultado
archi-
vo
Ejecute
instancia
secuencia
comandos
plano
plano
ca-
acceder
archivo
tiempo
pasa
manifieste
condición
carrera
región
crítica
Modifique
secuencia
comandos
evitar
condición
carrera
Sugerencia
utilice
ln
archivo
archivo.lock
bloquear
archivo
datos
49
Suponga
sistema
operativo
proporciona
semáforos
Implemente
sistema
men-
sajes
Escriba
procedimientos
enviar
recibir
mensajes
50
Resuelva
problema
filósofos
comelones
utilizando
monitores
semáforos
51
Suponga
universidad
desea
mostrar
rectitud
política
aplicar
doctrina
Separado
inherentemente
desigual
Suprema
Corte
Unidos
género
raza
finalizando
vieja
práctica
baños
segregados
género
campus
concesión
tradición
decreta
mujer
baño
entrar
mujeres
hombres
viceversa
signo
marca
deslizable
puerta
baño
indica
momento
•V
acío
Mujer
presente
Hombre
presente
lenguaje
programación
preferencia
escriba
siguientes
procedimientos
mujer-
desea_entrar
hombre_desea_entrar
mujer_sale
hombre_sale
contadores
técni-
cas
sincronización
desee
52
Vuelva
escribir
programa
figura
2-23
manejar
procesos
53
Escriba
problema
productor-consumidor
utilice
hilos
comparta
búfer
común
em-
bargo
utilice
semáforos
primitiva
sincronización
proteger
estructu-
ras
datos
compartidas
deje
hilo
utilice
quiera
Use
sleepy
wakeuppara
manejar
condiciones
lleno
vacío
Vea
tiempo
requiere
ocurra
condi-
ción
carrera
fatal
ejemplo
productor
imprima
número
imprima
número
minuto
afectar
con-
diciones
carrera
174
PROCESOS
HILOS
CAPÍTULO
www
FreeLibros.me3
ADMINISTRACIÓN
MEMORIA
175
memoria
principal
RAM
importante
recurso
administrarse
cuidado
Aun-
actualmente
computadora
doméstica
promedio
10,000
memoria
IBM
7094
computadora
mundo
principios
década
1960
progra-
creciendo
rapidez
memorias
Parafraseando
ley
Parkinson
diría
programas
expanden
llenar
memoria
disponible
contenerlos
capítulo
estudiaremos
forma
sistemas
operativos
crean
abstracciones
memoria
administran
programador
quisiera
memoria
privada
tamaño
rapidez
infinitas
volátil
pierda
contenido
desconecta
potencia
eléctrica
hacerla
barata
desgracia
tecnolo-
gía
proporciona
tales
memorias
momentos
descubra
opción
años
elaborado
concepto
jerarquía
memoria
computadoras
megabytes
memoria
ca-
ché
rápida
costosa
volátil
gigabytes
memoria
principal
mediana
velo-
cidad
precio
mediano
volátil
terabytes
almacenamiento
disco
lento
económico
volátil
almacenamiento
removible
DVDs
memorias
USB
trabajo
sistema
operativo
abstraer
jerarquía
modelo
útil
administrarla
sistema
operativo
administra
jerarquía
memoria
conoce
co-
mo
administrador
memoria
trabajo
administrar
memoria
eficiencia
re-
gistro
partes
memoria
asignar
memoria
procesos
necesiten
desasignarla
terminen
www
FreeLibros.meEn
capítulo
investigaremos
esquemas
distintos
administración
memoria
varían
simples
sofisticados
generalmente
hardware
en-
carga
administrar
nivel
memoria
caché
capítulo
concentraremos
modelo
programador
memoria
principal
administrar
abs-
tracciones
administración
almacenamiento
permanente
disco
tema
capítulo
Analizaremos
esquemas
simples
posibles
progresaremos
gradual
esquemas
elaborados
3.1
ABSTRACCIÓN
MEMORIA
abstracción
simple
memoria
abstracción
primeras
computadoras
main-
frame
1960
primeras
minicomputadoras
1970
primeras
computado-
ras
personales
1980
tenían
abstracción
memoria
programa
veía
simplemente
memoria
física
programa
ejecutaba
instrucción
MOV
REGISTRO1
1000
computadora
movía
contenido
ubicación
memoria
física
1000
REGISTRO1
modelo
programación
presentaba
programador
simplemente
memoria
física
conjunto
direcciones
valor
máximo
dirección
correspon-
celda
contenía
número
bits
comúnmente
condiciones
programas
ejecutándose
memoria
tiempo
programa
escribía
valor
ejemplo
ubicación
2000
bo-
rraría
valor
programa
estuviera
almacenando
programas
falla-
rían
inmediato
modelo
memoria
consiste
memoria
física
opciones
posibles
figura
3-1
muestran
variaciones
sistema
operativo
inferior
memoria
RAM
Random
Access
Memory
Memoria
acceso
aleatorio
muestra
figura
3-1(a
ROM
Read
Only
Memory
Memoria
lec-
tura
superior
memoria
muestra
figura
3-1(b
controladores
dispositivos
superior
memoria
ROM
resto
sistema
RAM
abajo
muestra
figura
3-1(c
modelo
utilizó
mainframes
minicomputadoras
actualmente
emplea
modelo
utili-
za
computadoras
bolsillo
sistemas
integrados
tercer
modelo
utilizado
primeras
computadoras
personales
ejemplo
ejecutaban
MS-DOS
porción
sistema
ROM
conoce
BIOS
Basic
Input
Output
System
Sistema
básico
en-
trada
salida
modelos
desventaja
error
programa
usua-
rio
borrar
sistema
operativo
posiblemente
resultados
desastrosos
información
disco
quedar
ininteligible
sistema
organiza
forma
general
ejecutar
proceso
usuario
teclea
comando
sistema
operativo
copia
programa
so-
licitado
disco
memoria
ejecuta
termina
proceso
sistema
operativo
mues-
176
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.1
ABSTRACCIÓN
MEMORIA
177
tra
carácter
indicador
comando
espera
comando
recibe
comando
car-
ga
programa
memoria
sobrescribiendo
forma
obtener
grado
paralelismo
sistema
abstracción
memoria
programar
múltiples
hilos
supone
hilos
proceso
ven
imagen
memoria
vean
obligados
problema
idea
funciona
limitado
personas
desean
programas
relacionados
ejecuten
tiempo
abstracción
hilos
provee
Ade-
probable
sistema
primitivo
proporcionar
abstrac-
ción
memoria
proporcione
abstracción
hilos
Ejecución
múltiple
programas
abstracción
memoria
obstante
abstracción
memoria
ejecutar
programas
tiem-
po
sistema
operativo
guardar
contenido
memoria
archi-
vo
disco
traer
ejecutar
programa
programa
memoria
conflictos
concepto
intercambio
analiza
continuación
adición
hardware
especial
ejecutar
múltiples
programas
concurren-
temente
intercambio
modelos
IBM
360
resolvieron
problema
memoria
dividida
bloques
KB
asignaba
llave
protección
bits
guardada
registros
especiales
CPU
equipo
memoria
MB
necesitaba
512
registros
bits
totalizar
256
bytes
almacenamiento
llave
registro
PSW
Program
Status
Word
Palabra
progra-
ma
contenía
llave
bits
hardware
360
controlaba
trap
cual-
quier
intento
proceso
ejecución
acceder
memoria
código
protección
distinto
llave
PSW
sistema
operativo
podía
modificar
lla-
ves
protección
procesos
usuario
controlados
interfirieran
sistema
operativo
0xFFF
00
Programa
usuario
Programa
usuario
Programa
usuario
Sistema
operativo
RAM
Sistema
operativo
RAM
Sistema
operativo
ROM
Drivers
dispositivos
ROM
Figura
3-1
formas
simples
organizar
memoria
sistema
operativo
proceso
usuario
posibilidades
www
FreeLibros.meSin
solución
desventaja
ilustra
figura
3-2
muestran
figuras
3-2(a
programas
tamaño
16
KB
sombreado
indicar
llave
memoria
empieza
saltando
dirección
24
contiene
instrucción
MOV
saltando
dirección
28
contiene
instrucción
CMP
instrucciones
relevantes
análisis
muestran
programas
cargan
consecutivamente
memoria
em-
pezando
dirección
situación
figura
3-2(c
ejemplo
suponemos
sistema
operativo
alta
memoria
muestra
178
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
12
16
20
24
28
12
16
20
24
28
12
16
20
24
28ADD
JMP
24
MOV
16384
16388
16392
16396
16400
16404
16408
16412
ADD
JMP
24
MOV
16380
JMP
28
CMP
16380
16380
JMP
28
CMP
32764
Figura
3-2
Ilustración
problema
reubicación
programa
16
KB
programa
16
KB
programas
cargados
consecutivamente
me-
moria
programas
cargan
ejecutar
distintas
llaves
me-
moria
dañar
problema
naturaleza
distinta
Cuan-
do
inicia
programa
ejecuta
instrucción
JMP
24
salta
instrucción
espera
programa
funciona
normal
programa
ejecutado
tiempo
suficiente
siste-
ma
operativo
decida
ejecutar
programa
carga
dirección
16,384
instrucción
ejecutada
JMP28
salta
instrucción
ADDen
pri-
mer
programa
instrucción
CMP
supone
saltar
probable
programa
falle
www
FreeLibros.meSECCIÓN
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
179
problema
central
programas
referencia
memoria
física
absolu-
ta
definitivamente
deseamos
programa
haga
referencia
conjunto
privado
direcciones
locales
mostraremos
logra
IBM
360
hacía
solución
salir
paso
modificar
programa
instante
medida
cargaba
memoria
usando
técnica
conocida
reubicación
estática
técnica
funcionaba
cargaba
programa
dirección
16,384
sumaba
va-
lor
constante
16,384
direcciones
programa
proceso
carga
mecanismo
funciona
cabo
forma
correcta
solución
general
redu-
ce
velocidad
carga
requiere
información
adicional
programas
ejecutables
indicar
palabras
contienen
direcciones
reubicables
28
figura
3-2(b
reubicarse
instrucción
MOV
REGISTRO1
28
mueve
número
28
REGISTRO1
reubicar
cargador
necesita
forma
dirección
constante
recalcamos
capítulo
historia
tiende
repetirse
mundo
computadoras
direccionamiento
directo
memoria
física
lejos
po-
der
aplicarse
mainframes
minicomputadoras
computadoras
escritorio
notebooks
fal-
ta
abstracción
memoria
común
sistemas
integrados
tarjeta
inteligente
actualidad
dispositivos
radios
lavadoras
hornos
mi-
croondas
llenos
software
ROM
mayoría
casos
software
direcciona
memoria
absoluta
funciona
programas
conocen
antemano
usuarios
libertad
ejecutar
software
tostador
sistemas
integrados
alta
tecnología
teléfonos
celulares
sistemas
operativos
elaborados
simples
casos
sistema
operativo
pe-
ro
biblioteca
ligada
programa
aplicación
proporciona
llamadas
sistema
operaciones
tareas
comunes
popular
sistema
operativo
e-cos
ejemplo
común
sistema
operativo
biblioteca
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
exponer
memoria
física
procesos
desventajas
lugar
programas
usuario
direccionar
byte
memoria
estropear
sistema
operati-
vo
facilidad
intencional
accidentalmente
sistema
detendría
forma
súbita
hardware
especial
esquema
bloqueo
llaves
IBM
360
Es-
problema
programa
usuario
aplicación
ejecución
segun-
do
lugar
modelo
difícil
programas
ejecución
tomando
turnos
CPU
computadoras
personales
común
programas
abiertos
procesador
palabras
programa
correo
electrónico
navegador
Web
enfoque
actual
reactivan
clic
ratón
situa-
ción
difícil
lograr
abstracción
memoria
física
www
FreeLibros.me3.2.1
noción
espacio
direcciones
resolver
problemas
permitir
aplicaciones
memoria
tiempo
interfieran
protección
reubicación
analizamos
solución
primiti-
problema
IBM
360
etiquetar
trozos
memoria
llave
protección
comparar
llave
proceso
ejecución
palabra
memoria
obtenida
CPU
método
resuelve
problema
resolver
reubicación
programas
momento
cargarlos
solución
lenta
complicada
solución
inventar
abstracción
memoria
espacio
direccio-
nes
concepto
proceso
crea
tipo
CPU
abstracta
ejecutar
programas
espacio
direcciones
crea
tipo
memoria
abstracta
programas
vivan
es-
pacio
direcciones
address
space
conjunto
direcciones
utilizar
proceso
direccionar
memoria
proceso
espacio
direcciones
independiente
pertenecen
procesos
circunstancias
especiales
pro-
cesos
desean
compartir
espacios
direcciones
concepto
espacio
direcciones
general
ocurre
contextos
Con-
sidere
números
telefónicos
Unidos
países
número
te-
léfono
local
comúnmente
número
dígitos
consecuencia
espacio
direcciones
números
telefónicos
varía
0,000,000
9,999,999
números
co-
mo
empiezan
000
utilizan
crecimiento
teléfonos
celulares
módems
máquinas
fax
espacio
volviendo
pequeño
cuyo
caso
uti-
lizar
dígitos
espacio
direcciones
puertos
Pentium
varía
has-
ta
16383
direcciones
IPv4
números
32
bits
espacio
direcciones
varía
32
números
reservados
espacios
direcciones
numéricos
conjunto
dominios
.com
In-
ternet
espacio
direcciones
espacio
direcciones
consiste
cade-
nas
longitud
63
caracteres
puedan
formar
utilizando
letras
números
guiones
cortos
seguidas
.com
momentos
hacerse
idea
simple
difícil
proporcionar
programa
espacio
direcciones
dirección
28
programa
indique
ubicación
física
distinta
dirección
28
programa
continuación
analizaremos
forma
simple
solía
común
caí-
do
desuso
habilidad
esquemas
complicados
mejores
chips
CPU
modernos
Registros
base
límite
solución
sencilla
utiliza
versión
simple
reubicación
dinámica
asociar
espacio
direcciones
proceso
distinta
memoria
física
simple
solución
clásica
utilizaba
máquinas
CDC
6600
pri-
mera
supercomputadora
mundo
Intel
8088
corazón
IBM
PC
original
equi-
par
CPU
registros
hardware
especiales
conocidos
comúnmente
registros
180
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
181
base
límite
utilizan
registros
programas
cargan
ubicaciones
consecuti-
vas
memoria
espacio
reubicación
carga
muestra
fi-
gura
3-2(c
ejecuta
proceso
registro
base
carga
dirección
física
empieza
programa
memoria
registro
límite
carga
longitud
programa
fi-
gura
3-2(c
valores
base
límite
cargarían
registros
hardware
ejecutar
pri-
mer
programa
16,384
respectivamente
valores
utilizados
ejecuta
programa
16,384
16,384
respectivamente
cargara
tercer
programa
16
KB
directa-
mente
ejecutara
registros
base
límite
serían
32,768
16,384
proceso
referencia
memoria
obtener
instrucción
memoria
leer
escribir
palabra
datos
hardware
CPU
suma
automá-
tica
valor
base
dirección
generada
proceso
enviar
dirección
bus
me-
moria
tiempo
comprueba
dirección
ofrecida
valor
resultante
sumar
valores
registros
límite
base
cuyo
caso
genera
fallo
aborta
ac-
ceso
ende
caso
instrucción
programa
figura
3-2(c
proceso
ejecuta
instrucción
JMP
28
hardware
JMP
16412
llega
instrucción
CMP
esperaba
valores
registros
base
límite
ejecución
programa
figura
3-2(c
muestran
figura
3-3
registros
base
límite
fácil
proporcionar
proceso
espacio
direcciones
privado
dirección
memoria
genera
forma
auto-
mática
suma
contenido
registro
base
enviarla
memoria
implemen-
taciones
registros
base
límite
protegidos
forma
sistema
operativo
modificarlos
caso
CDC
6600
Intel
8088
siquiera
te-
nía
registro
límite
registros
base
permitía
reubicaran
texto
datos
independiente
ofrecía
protección
referencias
me-
moria
rango
desventaja
reubicación
usando
registros
base
límite
necesidad
suma
comparación
referencia
memoria
comparaciones
rapidez
sumas
lentas
tiempo
propagación
acarreo
utilicen
circuitos
especiales
suma
3.2.2
Intercambio
memoria
física
computadora
contener
proce-
sos
esquemas
descritos
funcionarán
forma
correcta
práctica
cantidad
RAM
requieren
procesos
acomodarse
memoria
sistema
Windows
Linux
común
iniciar
www.FreeLibros.meentre
40
60
procesos
inicia
computadora
ejemplo
insta-
aplicación
Windows
emite
comandos
inicios
subsiguientes
sistema
inicie
proceso
haga
buscar
actualizaciones
aplica-
ción
proceso
ocupar
fácilmente
10
MB
memoria
procesos
segun-
do
plano
comprueban
correo
entrante
conexiones
red
entrantes
cosas
inicie
programa
usuario
programas
aplicaciones
usuario
serios
ejecutarse
ocupando
fácilmente
50
200
MB
consecuencia
mantener
procesos
memoria
tiempo
requiere
cantidad
memoria
hacerse
memoria
suficiente
años
desarrollado
esquemas
generales
lidiar
sobrecar-
ga
memoria
estrategia
simple
conocida
intercambio
consiste
ca-
proceso
completo
memoria
ejecutarlo
tiempo
regresarlo
disco
procesos
inactivos
mayormente
almacenados
disco
ocupan
memoria
ejecutando
despiertan
periódicamente
pa-
ra
trabajo
vuelven
quedar
inactivos
estrategia
conocida
me-
moria
virtual
permite
programas
ejecuten
encuentran
forma
parcial
memoria
continuación
estudiaremos
intercambio
sección
3.3
examinare-
mos
memoria
virtual
182
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
12
16
20
24
28
ADD
JMP
24
MOV
JMP
28
CMP
16384
16388
16392
16396
16400
16404
16408
16412
16380
32764
16384
16384
Registro
base
Registro
límite
Figura
3-3
utilizar
registros
base
límite
proceso
espa-
cio
direcciones
separado
www
FreeLibros.meSECCIÓN
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
183
operación
sistema
intercambio
ilustra
figura
3-4
principio
pro-
ceso
memoria
procesos
crean
intercambian
disco
figura
3-4(d
intercambia
disco
llega
sale
B.
entra
ubicación
distinta
direcciones
contiene
reubicar
software
intercambia
probablemente
hardware
eje-
cución
programa
ejemplo
registros
base
límite
funcionarían
caso
Sistema
operativo
Sistema
operativo
Sistema
operativo
Tiempo
Sistema
operativo
Sistema
operativo
Sistema
operativo
Sistema
operativo
Figura
3-4
asignación
memoria
cambia
medida
llegan
procesos
memoria
salen
regiones
sombreadas
memoria
intercambio
crea
huecos
memoria
combinarlos
desplazando
procesos
abajo
técnica
conoce
compactación
memoria
general
realiza
requiere
tiempo
CPU
ejemplo
máquina
GB
copiar
bytes
20
nseg
requerirían
segundos
compactar
memoria
aspecto
vale
pena
mencionar
cantidad
memoria
asignarse
pro-
ceso
crea
intercambia
procesos
crean
tamaño
fijo
cambia
asignación
sencilla
sistema
operativo
asigna
exactamente
necesario
obstante
segmentos
datos
procesos
crecer
ejemplo
asignación
dinámica
memoria
proveniente
heap
lenguajes
programa-
ción
ocurre
problema
proceso
crecer
hueco
adyacente
proceso
asignarse
permite
proceso
crecer
hueco
proceso
adyacente
pro-
ceso
proceso
crecimiento
moverse
hueco
memoria
alojarlo
intercambiar
procesos
crear
hueco
tamaño
suficiente
proceso
crecer
memoria
área
intercambio
dis-
co
llena
proceso
suspenderse
libere
espacio
eli-
minar
www
FreeLibros.meSi
espera
mayoría
procesos
crezcan
medida
ejecuten
probablemente
conveniente
asignar
memoria
adicional
intercambia
mueve
proceso
reducir
sobrecarga
asociada
acción
mover
intercambiar
procesos
caben
memoria
asignada
obstante
intercambiar
procesos
disco
intercam-
biar
memoria
encuentre
desperdicio
intercambiar
memoria
adicional
figura
3-5(a
configuración
memoria
asigna-
do
espacio
crezcan
procesos
184
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Sistema
operativo
Espacio
crecer
Espacio
crecer
Pila
Pila
Datos
Datos
Programa
Programa
Sistema
operativo
Espacio
crecer
Realmente
Espacio
crecer
Realmente
Figura
3-5
Asignación
espacio
segmento
datos
crecimiento
Asignación
espacio
pila
crecimiento
segmento
datos
cre-
cimiento
procesos
segmentos
crecimiento
ejemplo
segmento
datos
utiliza
heap
variables
asignan
liberan
forma
dinámica
segmento
pila
variables
locales
normales
direcciones
retorno
arreglo
alter-
nativo
sugiere
figura
3-5(b
figura
proceso
ilustrado
pila
superior
memoria
asignada
creciendo
abajo
segmento
datos
justo
texto
programa
creciendo
memoria
segmentos
utilizar
cualquiera
agota
proceso
moverse
hueco
suficiente
espacio
intercambiarse
memo-
ria
crear
hueco
suficientemente
eliminarse
3.2.3
Administración
memoria
libre
memoria
asigna
forma
dinámica
sistema
operativo
administrarla
tér-
minos
generales
formas
registro
memoria
mapas
bits
listas
libres
sección
analizaremos
métodos
www
FreeLibros.meSECCIÓN
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
185
Administración
memoria
mapas
bits
mapa
bits
memoria
divide
unidades
asignación
pequeñas
cuan-
tas
palabras
kilobytes
unidad
asignación
bit
corres-
pondiente
mapa
bits
unidad
libre
ocupada
viceversa
figura
3-6
muestra
memoria
mapa
bits
correspondiente
AB
81
Hueco
Empieza
18
Longitud
Proceso
P05
H53
P86
P1
44
H1
82
P2
06
P2
63
H2
93
Figura
3-6
memoria
procesos
huecos
mar-
cas
graduación
muestran
unidades
asignación
memoria
regiones
som-
breadas
mapa
bits
libres
mapa
bits
correspondiente
información
forma
lista
tamaño
unidad
asignación
importante
cuestión
diseño
peque-
ña
unidad
asignación
mapa
bits
unidad
asignación
pequeña
bytes
32
bits
memoria
requerirán
bit
mapa
me-
moria
32n
bits
utilizará
bits
mapa
mapa
bits
ocupará
1/33
memo-
ria
unidad
asignación
elige
mapa
bits
pequeño
desperdiciar
cantidad
considerable
memoria
unidad
proceso
tamaño
múltiplo
exacto
unidad
asignación
mapa
bits
proporciona
simple
registro
palabras
memoria
cantidad
fija
memoria
tamaño
mapa
bits
depende
tamaño
memoria
tamaño
unidad
asignación
problema
principal
de-
cidido
proceso
unidades
memoria
administrador
memoria
buscar
mapa
encontrar
serie
kbits
consecutivos
valor
mapa
bits
proceso
buscar
mapa
bits
serie
longitud
operación
lenta
serie
cruzar
límites
palabras
mapa
argumento
mapas
bits
Administración
memoria
listas
ligadas
registro
memoria
mantener
lista
ligada
segmentos
me-
moria
asignados
libres
segmento
contiene
proceso
hueco
vacío
www
FreeLibros.me186
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
procesos
memoria
figura
3-6(a
representa
figura
3-6(c
lista
ligada
segmentos
entrada
lista
especifica
hueco
proceso
dirección
inicia
longitud
apuntador
entrada
ejemplo
lista
segmentos
mantiene
ordenada
dirección
ordenarla
es-
ta
ventaja
termina
proceso
intercambia
proceso
ac-
tualizar
lista
simple
proceso
terminación
general
vecinos
superior
inferior
memoria
procesos
hue-
cos
conduce
combinaciones
figura
3-7
figura
3-7(a
actuali-
zar
lista
requiere
reemplazar
H.
figuras
3-7(b
3-7(c
entradas
fusionan
lista
reduce
entrada
figura
3-7(d
fusionan
en-
tradas
elementos
eliminados
lista
ranura
tabla
procesos
proceso
terminación
general
apuntará
entrada
lista
proceso
conveniente
lista
lista
doblemente
ligada
lista
simplemente
ligada
figura
3-6(c
estructura
facili-
ta
encontrar
entrada
combinación
convierte
convierte
convierte
convierte
termine
AB
termina
Figura
3-7
combinaciones
vecinos
proceso
terminación
X.
procesos
huecos
mantienen
lista
ordenada
dirección
utili-
zar
algoritmos
asignar
memoria
proceso
creado
proceso
existente
in-
tercambie
disco
Suponemos
administrador
memoria
asignar
algoritmo
simple
ajuste
administrador
memoria
explora
lista
segmen-
tos
encontrar
hueco
hueco
divide
partes
proceso
memoria
utilizar
estadísticamente
improbable
caso
ajuste
exacto
algoritmo
ajuste
rápido
busca
pequeña
variación
algoritmo
ajuste
algoritmo
ajuste
Funciona
ajuste
registro
descubre
hueco
adecuado
llamado
buscar
hueco
empieza
buscar
lista
lugar
empezar
principio
algoritmo
ajuste
simulaciones
realiza-
das
Bays
1977
muestran
algoritmo
ajuste
rendimiento
ligeramen-
ajuste
algoritmo
conocido
ampliamente
utilizado
ajuste
algoritmo
busca
lista
principio
toma
hueco
pequeño
adecuado
dividir
hueco
necesitarse
algoritmo
ajuste
buscar
www
FreeLibros.meSECCIÓN
3.2
ABSTRACCIÓN
MEMORIA
ESPACIOS
DIRECCIONES
187
hueco
esté
cerca
tamaño
actual
necesario
coincida
solicitud
hue-
cos
disponibles
ejemplo
algoritmos
ajuste
ajuste
considere
fi-
gura
3-6
necesita
bloque
tamaño
algoritmo
ajuste
asignará
hueco
ajuste
asignará
hueco
18
algoritmo
ajuste
lento
ajuste
buscar
to-
lista
llama
sorprendente
provoca
desperdicio
memoria
algoritmos
ajuste
ajuste
tiende
llenar
memoria
huecos
pequeños
inutilizables
algoritmo
ajuste
genera
huecos
promedio
resolver
problema
dividir
coincidencias
exactas
proceso
pe-
queño
hueco
podríamos
considerar
algoritmo
ajuste
tomar
hueco
disponible
hueco
útil
simulación
demostrado
algoritmo
ajuste
idea
algoritmos
acelerados
manteniendo
listas
separadas
procesos
huecos
forma
dedican
energía
inspeccionar
huecos
pro-
cesos
precio
inevitable
paga
aceleración
asignación
complejidad
adi-
cional
lentitud
desasignar
memoria
segmento
liberado
eliminarse
lista
procesos
insertarse
lista
huecos
mantienen
distintas
listas
procesos
huecos
lista
huecos
man-
ordenada
tamaño
algoritmo
ajuste
rápido
al-
goritmo
ajuste
busca
lista
huecos
pequeño
encuentre
hueco
ajuste
sabrá
hueco
pequeño
utilizar
denomine
ajuste
necesario
buscar
esquema
lista
lista
huecos
ordenada
tamaño
algoritmos
ajuste
ajuste
rápidos
innecesario
ajuste
huecos
mantienen
listas
separadas
procesos
pequeña
optimización
conjunto
separado
estructuras
datos
mantener
lista
huecos
figura
3-6(c
información
almacenar
huecos
pri-
mera
palabra
hueco
tamaño
palabra
apuntador
entrada
nodos
lista
figura
3-6(c
requieren
palabras
bit
necesarios
algoritmo
asignación
denominado
ajuste
rápido
mantiene
listas
se-
paradas
tamaños
comunes
solicitados
ejemplo
tabla
entradas
entrada
apuntador
cabeza
lista
huecos
KB
entrada
apuntador
lista
huecos
KB
entrada
apun-
tador
huecos
12
KB
sucesivamente
ejemplo
huecos
21
KB
colocar-
lista
20
KB
lista
especial
huecos
tamaño
inusual
algoritmo
ajuste
rápido
buscar
hueco
tamaño
requerido
extremadamente
rápido
desventaja
esquemas
ordenan
tamaño
hueco
proceso
termina
intercambiado
buscar
vecinos
fusión
proceso
costoso
realiza
fusión
memoria
fragmentará
rápidamen-
número
pequeños
huecos
cabrá
proceso
www
FreeLibros.me3.3
MEMORIA
VIRTUAL
registros
base
límite
utilizar
crear
abstracción
espacios
direcciones
problema
resolver
administración
agrandamiento
soft-
ware
bloatware
tamaño
memorias
incrementa
rapidez
softwa-
re
aumenta
década
1980
universidades
operaban
sistema
tiempo
compartido
docenas
usuarios
satisfechos
trabajando
simultáneamen-
AX
MB
Microsoft
recomienda
512
MB
siste-
ma
Vista
usuario
ejecute
aplicaciones
simples
GB
usuario
trabajo
serio
tendencia
multimedia
impone
mayores
exigencias
memoria
consecuencia
desarrollos
necesidad
ejecutar
programas
de-
masiado
caber
memoria
duda
necesidad
sistemas
puedan
soportar
programas
ejecutándose
tiempo
cua-
cabe
memoria
forma
colectiva
exceden
tamaño
intercambio
opción
atractiva
disco
SATA
ordinario
velocidad
transferencia
pi-
co
100
MB
significa
requiere
10
segundos
in-
tercambiar
programa
GB
memoria
disco
10
segundos
intercambiar
programa
GB
disco
memoria
problema
programas
memoria
presente
inicios
computación
áreas
limitadas
ciencia
ingeniería
simular
creación
universo
simular
aeronave
requiere
memoria
solución
adoptó
década
1960
dividir
programas
pequeñas
partes
co-
nocidas
sobrepuestos
overlays
empezaba
programa
cargaba
memoria
administrador
sobrepuestos
inmediato
cargaba
ejecutaba
sobrepues-
to
terminaba
indicaba
administrador
sobrepuestos
cargara
sobrepuesto
memoria
espacio
espacio
sistemas
sobrepuestos
complejos
permitían
sobrepuestos
memoria
sobrepuestos
mantenían
disco
intercambiándolos
adentro
memoria
afuera
memoria
administrador
sobrepuestos
trabajo
real
intercambiar
sobrepuestos
adentro
afuera
memo-
ria
realizaba
sistema
operativo
dividir
programa
partes
realizarlo
pro-
gramador
forma
manual
proceso
dividir
programas
partes
modulares
pequeñas
consumía
tiempo
aburrido
propenso
errores
programadores
pasó
tiempo
alguien
ideara
forma
pasar
trabajo
computadora
método
ideado
Fotheringham
1961
conoce
actualmente
memoria
virtual
idea
básica
memoria
virtual
programa
espacio
direcciones
divide
trozos
llamados
páginas
página
rango
contiguo
direcciones
páginas
asocian
memoria
física
memoria
física
ejecutar
programa
programa
referencia
espacio
direcciones
memoria
física
hardware
realiza
asociación
necesaria
instante
programa
refe-
rencia
espacio
direcciones
memoria
física
sistema
operativo
recibe
alerta
buscar
faltante
volver
ejecutar
instrucción
falló
188
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.3
MEMORIA
VIRTUAL
189
sentido
memoria
virtual
generalización
idea
registros
base
lí-
mite
procesador
8088
registros
base
separados
registros
límite
texto
datos
memoria
virtual
reubicación
separado
segmentos
texto
datos
espacio
direcciones
asociar
memoria
física
unidades
pequeñas
equitativas
continuación
mostraremos
implementa
memoria
virtual
memoria
virtual
funciona
sistema
multiprogramación
bits
partes
programas
memoria
programa
espera
mis-
mo
lea
coloque
memoria
CPU
otorgarse
proceso
3.3.1
Paginación
sistemas
memoria
virtual
utilizan
técnica
llamada
paginación
describiremos
continuación
computadora
programas
referencia
con-
direcciones
memoria
programa
ejecuta
instrucción
MOV
REG
1000
copiar
contenido
dirección
memoria
1000
REG(o
viceversa
dependiendo
computadora
direcciones
generar
usando
indexado
registros
base
registros
segmentos
formas
Paquete
CPU
CPU
CPU
envía
direcciones
virtuales
MMU
MMU
envía
direcciones
físicas
memoria
Unidad
administración
memoria
Memoria
Controlador
disco
Bus
Figura
3-8
posición
función
MMU
MMU
muestra
chip
CPU
común
configuración
actualidad
em-
bargo
lógicamente
chip
separado
años
direcciones
generadas
programa
conocen
direcciones
virtuales
forman
espacio
direcciones
virtuales
computadoras
memoria
virtual
dirección
física
coloca
directamente
bus
memoria
lea
escriba
palabra
memoria
fí-
sica
dirección
utiliza
memoria
virtual
direcciones
virtuales
di-
rectamente
bus
memoria
MMU
Memory
Managemente
Unit
www
FreeLibros.me190
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Unidad
administración
memoria
asocia
direcciones
virtuales
direcciones
memoria
físicas
ilustra
figura
3-8
figura
3-9
muestra
ejemplo
simple
funciona
asociación
ejemplo
computadora
genera
direcciones
16
bits
64
K.
direcciones
virtuales
computadora
32
KB
memoria
física
escribir
programas
64
KB
cargar
completos
memoria
ejecu-
tarse
obstante
copia
completa
imagen
básica
programa
64
KB
presente
disco
partes
puedan
traer
memoria
necesario
espacio
direcciones
virtuales
divide
unidades
tamaño
fijo
llamadas
páginas
unidades
correspondientes
memoria
física
llaman
marcos
página
páginas
mar-
cos
página
general
tamaño
ejemplo
KB
sistemas
reales
utilizado
tamaños
página
512
bytes
64
KB
64
KB
espacio
direcciones
virtuales
32
KB
memoria
física
obtenemos
16
páginas
virtuales
marcos
pá-
gina
transferencias
RAM
disco
páginas
completas
Espacio
direcciones
virtuales
Dirección
memoria
física
60Kñ64
56Kñ60
52Kñ56
48Kñ52
44Kñ48
40Kñ44
36Kñ40
32Kñ36
28Kñ32
24Kñ28
20Kñ24
16Kñ20
12Kñ16
8Kñ12
4Kñ8
0Kñ4
28Kñ32
24Kñ28
20Kñ24
16Kñ20
12Kñ16
8Kñ12
4Kñ8
0Kñ4
Página
virtual
Marco
págin
Figura
3-9
relación
direcciones
virtuales
direcciones
memoria
fí-
sica
dada
tabla
páginas
página
empieza
múltiplo
4096
termina
4095
direcciones
realidad
significa
4096
8191
12
significa
8192
12287
notación
figura
3-9
rango
marcado
significa
di-
recciones
virtuales
físicas
página
4095
rango
refiere
www
FreeLibros.meSECCIÓN
3.3
MEMORIA
VIRTUAL
191
direcciones
4096
8191
sucesivo
página
contiene
exactamente
4096
direccio-
nes
empiezan
múltiplo
4096
terminan
múltiplo
4096
ejemplo
programa
acceder
dirección
usando
instrucción
MOV
REG,0
dirección
virtual
envía
MMU
MMU
ve
dirección
virtual
página
4095
asociación
marco
página
8192
12287
trans-
forma
dirección
8192
envía
dirección
8192
bus
memoria
acerca
MMU
ve
petición
leer
escribir
dirección
8192
cumple
ma-
nera
MMU
asociado
efectivamente
direcciones
virtuales
4095
di-
recciones
físicas
8192
12287
similar
instrucción
MOV
REG,8192
transforma
efectivamente
MOV
REG,24576
dirección
virtual
8192
página
virtual
asocia
dirección
24576
marco
página
físico
tercer
ejemplo
dirección
virtual
20500
20
bytes
inicio
página
virtual
direcciones
virtuales
20480
24575
asocia
dirección
físi-
ca
12288
/H1100120
/H1100512308
habilidad
asociar
16
páginas
virtuales
cualquiera
marcos
pá-
gina
configuración
apropiada
asociación
MMU
resuelve
problema
espacio
direcciones
virtuales
memoria
física
marcos
página
físicos
páginas
virtuales
figura
3-9
asocian
memoria
física
muestran
cruz
figura
asociadas
hardware
real
bit
presente
ausente
registro
páginas
físicamente
pre-
sentes
memoria
ocurre
programa
referencia
direcciones
asociadas
ejemplo
instrucción
MOV
REG,32780
byte
12
página
virtual
empezando
32768
MMU
detecta
pá-
gina
asociada
indica
cruz
figura
CPU
haga
trap
sistema
operativo
trap
llama
fallo
página
sistema
operativo
selecciona
marco
página
utilice
escribe
contenido
vuelta
disco
es-
tá
obtiene
página
acaba
referenciar
marco
página
acaba
liberar
cambia
asociación
reinicia
instrucción
originó
trap
ejemplo
sistema
operativo
decidiera
desalojar
marco
página
cargaría
pági-
na
virtual
dirección
física
8192
realizaría
cambios
asociación
MMU
Pri-
mero
marcaría
entrada
página
virtual
asociada
trap
acceso
direcciones
virtuales
4096
8191
reemplazaría
cruz
entrada
www.FreeLibros.mela
página
virtual
ejecutar
instrucción
originó
trap
asocie
dirección
virtual
32780
dirección
física
4108
4096
/H1100112
veamos
MMU
analizar
funcionamiento
optado
utilizar
tamaño
página
potencia
figura
3-10
vemos
ejemplo
dirección
virtual
8196
0010000000000100
binario
asociar
usando
asociación
MMU
figura
3-9
dirección
virtual
entrante
16
bits
divide
número
pá-
gina
bits
desplazamiento
12
bits
bits
número
página
te-
ner
16
páginas
12
bits
desplazamiento
direccionar
4096
bytes
página
192
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
15
14
13
12
11
10
000
000
000
000
111
000
101
000
000
000
011
100
000
110
001
010
Bit
presente/
ausente
Tabla
páginas
desplazamiento
12
bits
copiado
directamente
entrada
salida
página
virtual
utiliza
índice
tabla
páginas
Dirección
virtual
entrante
8196
Dirección
física
saliente
24580
110
00
Figura
3-10
operación
interna
MMU
16
páginas
KB
número
página
utiliza
índice
tabla
páginas
conduciendo
número
marco
página
corresponde
página
virtual
bit
presente
ausente
provo-
ca
trap
sistema
operativo
bit
número
marco
página
encontrado
tabla
páginas
copia
bits
orden
registro
salida
desplazamien-
to
12
bits
copia
modificación
dirección
virtual
entrante
conjunto
forman
dirección
física
15
bits
registro
salida
coloca
bus
memoria
dirección
memoria
física
www
FreeLibros.meSECCIÓN
3.3
MEMORIA
VIRTUAL
193
3.3.2
Tablas
páginas
implementación
simple
asociación
direcciones
virtuales
direcciones
físicas
pue-
resumir
dirección
virtual
divide
número
página
virtual
bits
orden
desplazamiento
bits
menor
orden
ejemplo
direc-
ción
16
bits
tamaño
página
KB
bits
superiores
especificar
16
páginas
virtuales
12
bits
inferiores
especificar
desplazamiento
by-
tes
4095
página
seleccionada
división
número
bits
página
distintas
divisiones
implican
tamaños
página
número
página
virtual
utiliza
índice
tabla
páginas
buscar
entra-
página
virtual
entrada
tabla
páginas
número
marco
página
número
marco
página
adjunta
extremo
orden
des-
plazamiento
reemplazando
número
página
virtual
formar
dirección
física
enviar
memoria
ende
propósito
tabla
páginas
asociar
páginas
virtuales
marcos
pági-
na
Hablando
sentido
matemático
tabla
páginas
función
número
página
virtual
argumento
número
marco
físico
resultado
Utilizando
resultado
función
campo
página
virtual
dirección
virtual
reemplazar
campo
marco
página
formando
dirección
memoria
física
Estructura
entrada
tabla
páginas
pasar
estructura
tablas
páginas
general
detalles
entrada
tabla
páginas
distribución
exacta
entrada
depende
máquina
tipo
información
presente
máquina
figura
3-11
proporcionamos
ejemplo
entrada
tabla
páginas
tamaño
va-
ría
computadora
32
bits
tamaño
común
campo
importante
número
marco
página
objetivo
asociación
páginas
mostrar
valor
campo
bit
presente
ausente
bit
entrada
válida
utilizar
página
virtual
pertenece
entrada
actualmente
memoria
acceder
entrada
tabla
página
bit
puesto
produce
fallo
página
caché
deshabilitado
Modificada
Presente
ausente
Número
marco
página
Referenciada
Protección
Figura
3-11
típica
entrada
tabla
páginas
www
FreeLibros.meLos
bits
protección
indican
tipo
acceso
permitido
forma
simple
es-
campo
contiene
bit
lectura
escritura
lectura
arreglo
sofistica-
do
bits
habilitar
lectura
escritura
ejecutar
página
bits
modificada
referenciada
llevan
registro
páginas
escri-
be
página
hardware
establece
automática
bit
modificada
bit
valioso
sistema
operativo
decide
reclamar
marco
página
página
modificada
sucia
escribirse
vuelta
disco
mo-
dificado
limpia
abandonar
copia
disco
válida
bit
conoce
bit
sucio
refleja
página
bit
referenciada
establece
página
referenciada
leer
escribir
función
ayudar
sistema
operativo
elegir
página
desalojarla
ocu-
rre
fallo
página
páginas
estén
utilizando
mejores
candidatos
pági-
nas
utilizando
bit
desempeña
importante
papel
algoritmos
reemplazo
páginas
estudiaremos
capítulo
Finalmente
bit
permite
deshabilitar
caché
página
característi-
ca
importante
páginas
asocian
registros
dispositivos
me-
moria
sistema
operativo
esperando
ciclo
espera
hermético
dispositivo
responda
comando
acaba
recibir
esencial
hardware
siga
obteniendo
palabra
dispositivo
utilice
copia
antigua
caché
bit
caché
desactivar
máquinas
espacio
separado
utilizan
asociada
memoria
necesitan
bit
Observe
dirección
disco
utilizado
guardar
página
memo-
ria
forma
tabla
páginas
razón
simple
tabla
páginas
guarda
in-
formación
hardware
necesita
traducir
dirección
virtual
dirección
física
información
necesita
sistema
operativo
manejar
fallos
página
mantiene
ta-
blas
software
sistema
operativo
hardware
necesita
analizar
aspectos
implementación
vale
pena
recalcar
memoria
virtual
crear
abstracción
espacio
direcciones
abstrac-
ción
memoria
física
proceso
abstracción
procesador
físico
CPU
implementar
memoria
virtual
descomponer
espacio
direcciones
virtuales
páginas
asociar
marco
página
memoria
física
dejarla
temporalmente
asociar
ende
capítulo
fundamentalmente
abstracción
creada
siste-
ma
operativo
forma
administra
abstracción
3.3.3
Aceleración
paginación
Acabamos
fundamentos
memoria
virtual
paginación
tiempo
en-
trar
detalle
acerca
posibles
implementaciones
sistema
paginación
abordar
cuestiones
principales
194
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.3
MEMORIA
VIRTUAL
195
asociación
dirección
virtual
dirección
física
rápida
espacio
direcciones
virtuales
tabla
páginas
punto
consecuencia
asociación
virtual-a-física
reali-
zarse
referencia
memoria
instrucciones
provenir
finalmente
me-
moria
referencias
operandos
memoria
consecuencia
necesario
referencias
tabla
páginas
instrucción
ejecución
instrucción
tarda
ejemplo
nseg
búsqueda
tabla
páginas
realizarse
0.2
nseg
evitar
asociación
convierta
cuello
botella
importante
punto
deriva
computadoras
modernas
utilizan
direc-
ciones
virtuales
32
bits
64
bits
vuelven
comunes
de-
cir
tamaño
página
KB
espacio
direcciones
32
bits
millón
páginas
espacio
direcciones
64
bits
desearíamos
contemplar
millón
páginas
espacio
direcciones
virtual
tabla
páginas
millón
entradas
recuerde
proceso
necesita
tabla
páginas
es-
pacio
direcciones
virtuales
necesidad
asociación
páginas
extensa
rápida
restricción
considerable
construyen
computadoras
diseño
simple
concepto
tabla
páginas
consista
arreglo
registros
hardwa-
re
veloces
entrada
página
virtual
indexada
número
página
virtual
muestra
figura
3-10
inicia
proceso
sistema
operativo
carga
registros
tabla
páginas
proceso
tomada
copia
mantiene
memoria
principal
ejecución
proceso
necesitan
referencias
memoria
tabla
pági-
nas
ventajas
método
simple
requiere
referencias
memoria
asociación
desventaja
extremadamente
costoso
tabla
páginas
extensa
cargar
tabla
páginas
completa
conmutación
contexto
ve
afec-
tado
rendimiento
extremo
tabla
páginas
memoria
principal
hardware
necesita
registro
apunte
inicio
tabla
páginas
diseño
permite
cambiar
asociación
direcciones
virtuales
direcciones
físicas
momento
con-
mutación
contexto
recargar
registro
desventaja
requerir
referencias
memoria
leer
entradas
tabla
páginas
ejecución
instrucción
lenta
Búferes
traducción
adelantada
veamos
esquemas
implementados
ampliamente
acelerar
paginación
manejar
espa-
cios
direcciones
virtuales
extensos
empezando
aceleración
paginación
punto
ini-
cial
técnicas
optimización
tabla
páginas
memoria
Potencialmente
diseño
enorme
impacto
rendimiento
ejemplo
considere
instrucción
byte
copia
registro
falta
paginación
instrucción
www.FreeLibros.mesólo
referencia
memoria
obtener
instrucción
paginación
requiere
referencia
adicional
memoria
acceder
tabla
páginas
velocidad
ejecu-
ción
comúnmente
limitada
proporción
CPU
obtener
instrucciones
da-
tos
memoria
referencias
memoria
reduce
rendimiento
mitad
condiciones
utilizaría
paginación
diseñadores
computadoras
sabido
acerca
problema
años
idea-
do
solución
basada
observación
programas
tienden
número
referencias
pequeño
número
páginas
viceversa
ende
lee
frecuencia
pequeña
fracción
entradas
tabla
páginas
res-
to
utiliza
solución
ideado
equipar
computadoras
pequeño
dispositivo
hard-
ware
asociar
direcciones
virtuales
direcciones
físicas
pasar
tabla
páginas
dis-
positivo
llamado
TLB
Translation
Lookaside
Buffer
Búfer
traducción
adelantada
memoria
asociativa
ilustra
figura
3-12
general
MMU
consiste
pequeño
número
entradas
ejemplo
raras
64
Ca-
entrada
contiene
información
acerca
página
incluyendo
número
página
virtual
bit
establece
modifica
página
código
protección
permisos
lectura
es-
critura
ejecución
marco
página
físico
página
campos
correspondencia
campos
tabla
páginas
número
página
virtual
necesita
tabla
páginas
bit
indica
entrada
válida
196
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Página
virtualVálida
Modificada
Protección
Marco
página
Figura
3-12
TLB
acelerar
paginación
ejemplo
generar
TLB
figura
3-12
proceso
ciclo
abarque
páginas
virtuales
19
20
21
entradas
TLB
tengan
códigos
pro-
tección
lectura
ejecución
datos
principales
utilizando
arreglo
esté
procesando
encuentran
páginas
129
130
página
140
contiene
índices
utilizados
cálculos
arreglo
pila
páginas
860
861
veamos
funciona
TLB
presenta
dirección
virtual
MMU
pa-
ra
traduzca
hardware
comprueba
número
página
virtual
presente
www
FreeLibros.meSECCIÓN
3.3
MEMORIA
VIRTUAL
197
TLB
compararla
entradas
forma
simultánea
paralelo
en-
cuentra
coincidencia
válida
acceso
viola
bits
protección
marco
página
toma
directamente
TLB
pasar
tabla
páginas
número
página
virtual
presente
TLB
instrucción
tratando
escribir
página
lectura
genera
fallo
protección
caso
interesante
ocurre
número
página
virtual
TLB
MMU
detecta
realiza
búsqueda
ordinaria
tabla
páginas
desalo-
ja
entradas
TLB
reemplaza
entrada
tabla
páginas
acaba
buscar
forma
página
utiliza
producirá
acier-
to
TLB
fracaso
purga
entrada
TLB
bit
modificado
co-
pia
vuelta
entrada
tabla
páginas
memoria
valores
bit
referencia
TLB
carga
tabla
páginas
campos
toman
memoria
Administración
TLB
software
máquina
memoria
virtual
paginada
tablas
pági-
nas
reconocidas
hardware
TLB
diseño
administración
manejo
fa-
llas
TLB
realiza
completo
hardware
MMU
traps
trampas
sistema
operativo
ocurren
página
memoria
suposición
correcta
máquinas
RISC
modernas
in-
cluyendo
SPARC
MIPS
HP
PA
administración
páginas
softwa-
re
máquinas
entradas
TLB
cargan
explícita
sistema
operativo
coincidencia
TLB
MMU
tablas
páginas
buscar
obtener
referencia
página
necesita
genera
fa-
llo
TLB
pasa
problema
sistema
operativo
sistema
buscar
página
eliminar
entrada
TLB
introducir
página
reiniciar
instrucción
originó
fallo
instrucciones
fallos
TLB
ocurren
frecuencia
fallos
página
sorprendente
TLB
razonablemente
ejemplo
64
entradas
reducir
proporción
fallos
administración
TLB
software
resulta
eficien-
cia
aceptable
beneficio
principal
MMU
simple
libera
cantidad
considerable
área
chip
CPU
cachés
características
mejorar
ren-
dimiento
Uhlig
colaboradores
1994
describen
administración
TLB
software
desarrollado
estrategias
mejorar
rendimiento
equipos
realizan
ad-
ministración
TLB
software
método
enfoca
reducir
fallos
TLB
cos-
to
fallo
TLB
llega
ocurrir
Bala
colaboradores
1994
reducir
fallos
TLB
sistema
operativo
averigua
intuitivo
páginas
pro-
babilidad
utilizadas
continuación
precarga
entradas
TLB
ejemplo
cuan-
do
proceso
cliente
envía
mensaje
proceso
servidor
equipo
probable
servidor
ejecutarse
Sabiendo
tiempo
procesa
trap
ope-
ración
send
sistema
comprobar
páginas
código
datos
pila
servidor
asociándolas
tengan
oportunidad
producir
fallos
TLB
www
FreeLibros.meLa
forma
normal
procesar
fallo
TLB
hardware
software
ta-
bla
páginas
operaciones
indexado
localizar
página
referenciada
pro-
blema
búsqueda
software
páginas
contienen
tabla
páginas
estén
TLB
producirá
fallos
adicionales
TLB
procesamiento
fallos
reducir
mantener
caché
software
ejemplo
KB
entradas
TLB
ubicación
fija
cuya
página
mantenga
TLB
compro-
bar
caché
software
sistema
operativo
reducir
substancial
fa-
llos
TLB
utiliza
administración
TLB
software
esencial
comprender
di-
ferencia
tipos
fallos
fallo
suave
ocurre
página
referenciada
TLB
memoria
necesita
TLB
actualice
nece-
sita
disco
general
fallo
suave
requiere
10
20
instrucciones
máquina
completar
nanosegundos
contrario
fallo
duro
ocurre
página
memoria
TLB
requiere
acceso
disco
traer
página
tarda
milisegundos
fallo
duro
definitiva
mi-
llón
lento
fallo
suave
3.3.4
Tablas
páginas
memorias
extensas
TLBs
utilizar
acelerar
traducciones
direcciones
virtuales
direcciones
fí-
sicas
esquema
original
tabla
páginas
memoria
único
proble-
ma
debemos
combatir
problema
lidiar
espacios
direcciones
virtuales
extensos
continuación
veremos
maneras
Tablas
páginas
multinivel
método
considere
tabla
páginas
multinivel
figura
3-13
muestra
ejemplo
simple
figura
3-13(a
dirección
virtual
32
bits
par-
ticiona
campo
TP1
10
bits
campo
TP2
10
bits
campo
Desplazamiento
12
bits
desplazamientos
12
bits
páginas
KB
20
secreto
método
tabla
páginas
multinivel
evitar
mantenerlas
memoria
tiempo
especial
necesitan
ejemplo
suponga
proceso
nece-
sita
12
megabytes
megabytes
inferiores
memoria
texto
programa
siguientes
megabytes
datos
megabytes
superiores
pila
superior
da-
tos
inferior
pila
hueco
gigantesco
utiliza
figura
3-13(b
funciona
tabla
página
niveles
ejem-
plo
izquierda
tabla
páginas
nivel
superior
1024
entradas
correspon-
den
campo
TP1
10
bits
presenta
dirección
virtual
MMU
extrae
campo
TP1
utiliza
valor
índice
tabla
páginas
nivel
superior
1024
entradas
representa
espacio
direcciones
virtuales
gi-
gabytes
32
bits
dividido
trozos
4096
bytes
198
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.3
MEMORIA
VIRTUAL
199
entrada
localiza
indexar
tabla
páginas
nivel
superior
produce
dirección
número
marco
página
tabla
páginas
nivel
entrada
tabla
páginas
nivel
superior
apunta
tabla
páginas
texto
programa
entrada
apunta
tabla
páginas
datos
entrada
1023
apunta
tabla
páginas
pila
entradas
sombreadas
utilizan
campo
TP2se
utiliza
índice
tabla
pági-
nas
nivel
seleccionada
buscar
número
marco
página
página
ejemplo
considere
dirección
virtual
32
bits
0x00403004
4,206,596
decimal
12,292
bytes
datos
dirección
virtual
corresponde
TP1
/H110051
Tabla
páginas
nivel
superior
Tablas
páginas
nivel
páginas
Tabla
páginas
superiores
memoria
1023
1023
Bits
10
10
12
TP1
TP2
Desplaza-
miento
Figura
3-13
dirección
32
bits
campos
tablas
páginas
Tablas
páginas
niveles
www
FreeLibros.meTP2
/H110052
Desplazamiento
/H110054
MMU
utiliza
TP1
indexar
tabla
pági-
nas
nivel
superior
obtener
entrada
corresponde
direcciones
8M.
Des-
pués
utiliza
PT2
indexar
tabla
páginas
nivel
acaba
encontrar
extrae
entrada
corresponde
direcciones
12288
16383
trozo
direcciones
absolutas
4,206,592
4,210,687
entrada
contiene
número
marco
página
contiene
dirección
virtual
0x00403004
página
me-
moria
bit
presente
ausente
entrada
tabla
páginas
cero
pro-
ducirá
fallo
página
página
memoria
número
marco
página
obtiene
tabla
páginas
nivel
combina
desplazamiento
construir
dirección
física
dirección
coloca
bus
envía
memoria
interesante
acerca
figura
3-13
espacio
direcciones
contiene
millón
páginas
realidad
tablas
páginas
requeridas
tabla
nivel
superior
tablas
nivel
texto
programa
datos
superiores
pila
bits
presente
ausenteen
1021
entradas
tabla
páginas
nivel
superior
obligan
produzca
fallo
página
tratan
utilizar
caso
ocurra
sistema
operativo
observará
proceso
es-
tá
tratando
referenciar
memoria
tomará
acción
apropiada
enviar
se-
ñal
eliminarlo
ejemplo
elegido
números
redondos
diversos
tamaños
TP1
TP2
práctica
elegir
valores
sistema
tablas
páginas
niveles
figura
3-13
expandir
cua-
tro
niveles
niveles
obtiene
flexibilidad
improbable
complejidad
adicional
utilidad
niveles
Tablas
páginas
invertidas
espacios
direcciones
virtuales
32
bits
tabla
páginas
multinivel
funciona
bastan-
medida
computadoras
64
bits
comunes
situación
cambia
drástica
espacio
direcciones
64
bytes
páginas
KB
nece-
sitamos
tabla
páginas
52
entradas
entrada
bytes
tabla
30
millones
gigabyes
30
PB
Ocupar
30
millones
gigabytes
tabla
páginas
idea
probablemente
año
consecuencia
necesita
solución
espacios
direcciones
virtuales
paginados
64
bits
soluciones
tabla
páginas
invertida
diseño
entrada
marco
página
memoria
real
entrada
página
espacio
di-
recciones
virtuales
ejemplo
direcciones
virtuales
64
bits
página
KB
GB
RAM
tabla
páginas
invertida
requiere
262,144
entradas
entrada
regis-
tro
proceso
página
virtual
marco
página
tablas
página
invertidas
ahorran
cantidades
espacio
cuan-
do
espacio
direcciones
virtuales
memoria
física
seria
des-
ventaja
traducción
dirección
virtual
dirección
física
difícil
proceso
referencia
página
virtual
hardware
buscar
página
física
usan-
do
índice
tabla
páginas
buscar
entrada
200
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
201
tabla
páginas
invertida
búsqueda
referencia
me-
moria
fallos
página
Buscar
tabla
256
referencia
memoria
máquina
deslumbrantemente
rápida
forma
salir
dilema
utilizar
TLB
TLB
contener
páginas
frecuente
traducción
ocurrir
rapidez
tablas
páginas
regu-
lares
fallo
TLB
tabla
páginas
invertida
buscarse
software
factible
búsqueda
tabla
hash
arreglada
hash
dirección
virtual
páginas
virtuales
encuentren
memoria
tengan
valor
hash
encadenan
conjunto
muestra
figura
3-14
tabla
hash
tantas
ranuras
páginas
físicas
máquina
cadena
promedio
entrada
acelera
considerable
asociación
encon-
trado
número
marco
página
introduce
par
virtual
física
TLB
Tabla
páginas
tradicional
entrada
52
páginas
memoria
física
GB
18
marcos
página
KB
Tabla
hash
218
-1
252
-1
218
-1
00
Indexada
página
virtual
Indexada
hash
página
virtual
Página
virtual
Marco
página
Figura
3-14
Comparación
tabla
páginas
tradicional
tabla
pági-
nas
invertida
tablas
páginas
invertidas
comunes
máquinas
64
bits
tamaño
página
número
entradas
tabla
páginas
enorme
ejem-
plo
páginas
MB
direcciones
virtuales
64
bits
necesitan
42
entradas
tabla
páginas
métodos
manejar
memorias
virtuales
extensas
encontrar
Talluri
colaboradores
1995
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
ocurre
fallo
página
sistema
operativo
elegir
página
desalojarla
eliminarla
memoria
espacio
página
entrante
página
eliminar
modificó
www.FreeLibros.memientras
memoria
volver
escribirse
disco
actualizar
copia
obstante
página
modificado
ejemplo
contiene
texto
programa
copia
actualizada
necesita
rescribir
página
leer
sobrescribe
página
desalojar
elegir
página
azar
desalojarla
fallo
página
ren-
dimiento
sistema
selecciona
página
frecuente
elimina
página
frecuente
traerse
vuelta
rápidamente
pro-
duce
sobrecarga
adicional
trabajo
teórico
experimental
tema
algoritmos
reemplazo
páginas
continuación
describiremos
al-
goritmos
importantes
Vale
pena
observar
problema
reemplazo
páginas
ocurre
áreas
diseño
computacional
ejemplo
mayoría
computadoras
me-
morias
cachés
consisten
bloques
memoria
32
bytes
64
bytes
reciente
Cuan-
do
caché
llena
elegir
bloque
eliminarlo
problema
precisamente
reemplazo
páginas
escala
tiempo
menor
realizar-
nanosegundos
milisegundos
reemplazo
páginas
razón
menor
escala
tiempo
fallos
bloques
caché
satisfacen
me-
moria
principal
tiempo
búsqueda
latencia
rotacional
ejemplo
servidor
Web
servidor
mantener
número
páginas
Web
frecuente
memoria
caché
memoria
caché
llena
referencia
página
decidir
página
Web
desalojar
consi-
deraciones
similares
páginas
memoria
virtual
pági-
nas
Web
modifican
caché
copia
fresca
disco
sistema
memoria
virtual
páginas
memoria
principal
sucias
limpias
algoritmos
reemplazo
páginas
analizaremos
continuación
surge
cier-
ta
cuestión
desalojar
página
memoria
páginas
pro-
ceso
fallido
página
pertenezca
proceso
caso
limitando
efecto
proceso
número
fijo
páginas
caso
Ambas
posibilidades
sección
3-5.1
volveremos
punto
3.4.1
algoritmo
reemplazo
páginas
óptimo
algoritmo
reemplazo
páginas
fácil
describir
imposible
imple-
mentar
momento
ocurre
fallo
página
conjunto
páginas
memoria
referenciará
instrucción
página
contiene
instrucción
páginas
referencien
10
100
1000
instrucciones
Ca-
página
etiquetar
número
instrucciones
ejecutarán
ha-
ga
referencia
página
algoritmo
óptimo
reemplazo
páginas
establece
página
etiqueta
alta
eliminarse
página
utilizar
millones
instrucciones
utilizar
millones
instrucciones
eliminar
enviará
fallo
pági-
na
obtendrá
vuelta
lejos
futuro
personas
com-
putadoras
tratan
posponer
eventos
indeseables
tiempo
202
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
203
único
problema
algoritmo
momento
fallo
pá-
gina
sistema
operativo
forma
próxima
referencia
páginas
vimos
situación
similar
algoritmo
planificación
trabajo
corto
sistema
trabajo
corto
ejecutar
pro-
grama
simulador
referencias
páginas
implemen-
tar
algoritmo
óptimo
reemplazo
página
corrida
utilizar
información
referencia
páginas
recolectada
corrida
comparar
rendimiento
algoritmos
realizables
sistema
operativo
logra
rendimiento
ejemplo
ciento
algoritmo
óptimo
esfuerzo
invertido
buscar
algoritmo
producirá
mejora
ciento
evitar
confusión
aclarar
registro
referencias
pá-
ginas
refiere
programa
acaba
medir
entrada
específica
algoritmo
reemplazo
páginas
derive
específico
programa
datos
entrada
método
útil
evaluar
algoritmos
reemplazo
pá-
ginas
útil
sistemas
prácticos
continuación
estudiaremos
algoritmos
útiles
sistemas
reales
3.4.2
algoritmo
reemplazo
páginas
usadas
recientemente
permitir
sistema
operativo
recolecte
estadísticas
útiles
páginas
ma-
yor
computadoras
memoria
virtual
bits
asociados
pági-
na
establece
referencia
página
lectura
escritura
establece
escribe
página
modifica
bits
contenidos
entrada
tabla
páginas
muestra
figura
3-11
importante
bits
actualizar
referencia
memoria
imprescindible
establez-
can
hardware
establece
bit
permanece
siste-
ma
operativo
restablece
hardware
bits
simularse
forma
inicia
proceso
entradas
tabla
páginas
marcan
memoria
haga
referencia
página
ocurrirá
fallo
página
sistema
ope-
rativo
establece
bit
tablas
internas
cambia
entrada
tabla
páginas
apunte
página
correcta
LECTURA
reinicia
instrucción
página
modifica
ocurrirá
fallo
página
permite
sistema
operativo
establecer
bit
cambiar
página
LECTURA
ESCRITURA
bits
utilizar
construir
algoritmo
simple
paginación
si-
guiente
inicia
proceso
bits
página
páginas
esta-
blecen
sistema
operativo
bit
borra
forma
periódica
interrupción
reloj
diferenciar
páginas
referencia
recientemente
referenciado
ocurre
fallo
página
sistema
operativo
inspecciona
páginas
di-
vide
categorías
base
valores
actuales
bits
www
FreeLibros.meClase
referenciada
modificada
Clase
referenciada
modificada
Clase
referenciada
modificada
Clase
referenciada
modificada
páginas
clase
parecen
instancia
imposibles
ocurren
interrup-
ción
reloj
borra
bit
página
clase
interrupciones
reloj
borran
bit
información
necesita
página
vuelto
escribir
disco
borrar
obtiene
página
clase
algoritmo
NRU
Not
Recently
Used
usada
recientemente
elimina
página
azar
clase
menor
numeración
esté
vacía
algoritmo
implícita
idea
eliminar
página
modificada
referencia
pul-
so
reloj
general
20
mseg
página
limpia
frecuente
principal
atracción
NRU
fácil
comprender
moderadamente
eficiente
implementar
pro-
porciona
rendimiento
óptimo
adecuado
3.4.3
algoritmo
reemplazo
páginas
entrar
salir
FIFO
algoritmo
paginación
baja
sobrecarga
entrar
salir
First-In
First-Out
FIFO
ilustrar
funciona
considere
supermercado
suficien-
tes
repisas
mostrar
exactamente
productos
distintos
empresa
introduce
alimento
conveniencia
yogurt
orgánico
instantáneo
liofilizado
reconsti-
tuir
horno
microondas
éxito
inmediato
supermercado
finito
deshacer
producto
antiguo
tenerlo
existencia
posibilidad
buscar
producto
supermercado
existencia
tiempo
ejemplo
empezó
vender
120
años
deshacerse
razón
interesado
efecto
supermercado
mantiene
lista
ligada
productos
vende
actualmente
orden
introdujeron
pasa
fi-
nal
lista
frente
lista
elimina
algoritmo
reemplazo
páginas
aplica
idea
sistema
operativo
mantiene
lista
páginas
actualmente
memoria
llegada
reciente
reciente
frontal
fallo
página
elimina
pá-
gina
frontal
página
agrega
lista
aplica
tiendas
FIFO
eliminar
gomina
bigote
eliminar
harina
sal
mantequilla
aplica
computadoras
surge
problema
razón
raro
utilice
FIFO
forma
pura
3.4.4
algoritmo
reemplazo
páginas
oportunidad
modificación
simple
algoritmo
FIFO
evita
problema
descartar
página
frecuente
inspeccionar
bit
página
antigua
página
antigua
204
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
205
utilizado
sustituye
inmediato
bit
bit
borra
página
pone
lista
páginas
tiempo
carga
actualiza
acabara
llegar
memo-
ria
búsqueda
continúa
operación
algoritmo
conocido
oportunidad
muestra
figu-
ra
3-15
figura
3-15(a
vemos
páginas
mantienen
lista
ligada
ordenan
base
tiempo
llegaron
memoria
Página
cargó
Página
cargada
recientemente0
12
14
15
18
página
cargada
nuevamente
12
14
15
18
20
Figura
3-15
Operación
algoritmo
oportunidad
Páginas
ordena-
das
base
FIFO
Lista
páginas
ocurre
fallo
página
tiem-
po
20
bit
activado
números
páginas
tiempos
carga
Suponga
ocurre
fallo
página
tiempo
20
página
antigua
tiempo
inició
proceso
bit
Rde
desactivado
desaloja
memoria
escribiéndola
disco
sucia
abandona
limpia
bit
activado
coloca
lista
tiempo
carga
restablece
tiempo
ac-
tual
20
bit
desactivado
búsqueda
página
adecuada
continúa
B.
algoritmo
oportunidad
buscando
página
antigua
referencia
intervalo
reloj
reciente
referencia
páginas
algoritmo
oportunidad
degenera
convierte
FIFO
puro
es-
pecífica
imagine
páginas
figura
3-15(a
bits
activados
sistema
operativo
mueve
páginas
lista
desactivando
bit
adjun-
ta
página
lista
momento
regresará
página
bit
desactivado
punto
desaloja
ende
algoritmo
termina
3.4.5
algoritmo
reemplazo
páginas
reloj
algoritmo
oportunidad
razonable
innecesariamente
ineficiente
de-
bido
moviendo
constantemente
páginas
lista
método
mantener
marcos
página
lista
circular
forma
reloj
muestra
figura
3-16
manecilla
apunta
página
antigua
ocurre
fallo
página
página
apunta
manecilla
inspecciona
bit
página
desaloja
inserta
página
reloj
lugar
manecilla
avanza
www.FreeLibros.meuna
posición
borra
manecilla
avanza
página
proceso
repite
encontrar
página
/H110050
sorprender
algoritmo
llame
reloj
3.4.6
algoritmo
reemplazo
páginas
usadas
recientemente
LRU
aproximación
algoritmo
óptimo
basa
observación
páginas
hayan
utilizado
frecuencia
instrucciones
volverán
frecuen-
cia
siguientes
contrario
páginas
hayan
utilizado
tiempo
pro-
bablemente
seguirán
utilizarse
tiempo
idea
sugiere
algoritmo
factible
ocurra
fallo
página
descartar
página
utilizado
longitud
tiempo
estrategia
conoce
paginación
LRU
Least
Recently
Used
usadas
recientemente
teoría
algoritmo
LRU
realizable
barato
implementar
LRU
completo
necesario
mantener
lista
enlazada
páginas
memoria
página
reciente
frontal
reciente
dificultad
lista
actualizarse
referencia
memoria
Buscar
página
lista
eliminar-
pasarla
frente
operación
consume
tiempo
hard-
ware
suponiendo
pudiera
construirse
hardware
formas
implementar
algoritmo
LRU
hardware
especial
Con-
sideremos
forma
simple
método
requiere
equipar
hardware
contador
64
bits
llamado
incrementa
automática
instrucción
entrada
tabla
páginas
campo
guardar
contador
referencia
memoria
valor
actual
al-
macena
entrada
tabla
páginas
página
acaba
referenciar
ocu-
rre
fallo
página
sistema
operativo
examina
contadores
tabla
páginas
encontrar
menor
página
reciente
206
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
ocurre
fallo
página
página
apunta
manecilla
inspecciona
acción
depende
bit
Desaloja
página
Desactiva
avanza
manecilla
Figura
3-16
algoritmo
reemplazo
páginas
reloj
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
207
veamos
algoritmo
LRU
hardware
máquina
marcos
página
hardware
LRU
mantener
matriz
bits
inicialmente
referencia
página
hardware
establece
bits
fila
bits
columna
instante
fila
cuyo
valor
binario
menor
reciente
fila
cuyo
valor
reciente
sucesivo
funcionamiento
algoritmo
muestra
figura
3-17
marcos
página
referencias
páginas
orden
referencia
página
situación
figura
3-17(a
ha-
cer
referencia
página
situación
figura
3-17(b
sucesivo
Página
Página
Página
Página
Página
Figura
3-17
LRU
usando
matriz
referencia
páginas
or-
den
3.4.7
Simulación
LRU
software
algoritmos
LRU
anteriores
principio
realizables
máquinas
acaso
hardware
requerido
necesita
solución
implemen-
tarse
software
posibilidad
algoritmo
NFU
Not
Frequently
Used
utilizadas
fre-
cuentemente
algoritmo
requiere
contador
software
asociado
página
principio
cero
interrupción
reloj
sistema
operativo
explora
páginas
memoria
página
agrega
bit
contador
contadores
llevan
aproximada
frecuencia
referencia
página
ocurre
fa-
llo
página
selecciona
página
contador
menor
sustituirla
principal
problema
algoritmo
NFU
olvida
ejemplo
com-
pilador
pasadas
páginas
utilizaron
frecuencia
www.FreeLibros.metener
alta
siguientes
pasadas
tiempo
ejecución
pasadas
páginas
contienen
código
pasadas
sub-
siguientes
cuentas
menores
páginas
consecuencia
sistema
operativo
eliminará
páginas
útiles
páginas
hayan
utilizado
fortuna
pequeña
modificación
algoritmo
NFU
permite
simular
algoritmo
LRU
modificación
consta
partes
contadores
desplaza
derecha
bit
agregar
bit
R.
bit
agrega
bit
izquierda
lugar
sumarse
bit
derecha
figura
3-18
ilustra
funciona
algoritmo
modificado
conocido
envejecimien-
to
aging
Suponga
pulso
reloj
bits
páginas
valores
respectivamente
página
página
página
etc.
palabras
pulsos
referencia
páginas
es-
tableciendo
bits
páginas
quedaron
desplazado
contadores
correspondientes
bit
insertado
izquierda
tie-
nen
valores
muestran
figura
3-18(a
columnas
restantes
muestran
contadores
siguientes
pulsos
reloj
208
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Página
Bits
páginas
pulso
reloj
10000000
00000000
10000000
00000000
10000000
10000000
Bits
páginas
pulso
reloj
11000000
10000000
01000000
00000000
11000000
01000000
Bits
páginas
pulso
reloj
11100000
11000000
00100000
10000000
01100000
10100000
Bits
páginas
pulso
reloj
11110000
01100000
00100000
01000000
10110000
01010000
Bits
páginas
pulso
reloj
01111000
10110000
10010000
00100000
01011000
00101000
Figura
3-18
algoritmo
envejecimiento
simula
LRU
software
muestran
páginas
pulsos
reloj
pulsos
reloj
represen-
incisos
ocurre
fallo
página
elimina
página
cuyo
contador
menor
página
referencia
ejemplo
pulsos
reloj
ceros
izquierda
contador
ende
valor
menor
conta-
dor
referencia
pulsos
reloj
algoritmo
difiere
LRU
formas
Considere
páginas
figu-
ra
3-18(e
referenciado
pulsos
reloj
ambas
referenciaron
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
209
pulso
algoritmo
LRU
sustituir
página
de-
bemos
elegir
problema
referencia
intervalo
pulso
registrar
bit
intervalo
tiempo
perdido
capacidad
diferenciar
referencias
anteriores
intervalo
re-
loj
ocurrieron
eliminar
página
referencia
página
pulsos
reloj
página
diferencia
algoritmos
LRU
envejecimiento
contadores
número
finito
bits
ejemplo
limita
horizonte
Suponga
páginas
valor
contador
elegir
azar
realidad
páginas
referencia
pulsos
atrás
1000
pulsos
atrás
forma
determinarlo
práctica
bastan
bits
pulso
reloj
20
milisegundos
referencia
página
160
milisegundos
importante
3.4.8
algoritmo
reemplazo
páginas
conjunto
trabajo
forma
pura
paginación
procesos
inician
páginas
memo-
ria
CPU
obtener
instrucción
recibe
fallo
página
cau-
sando
sistema
operativo
traer
página
contiene
instrucción
general
fallo
siguen
fallos
página
variables
globales
pila
tiempo
proceso
mayoría
páginas
necesita
establece
ejecutar-
relativamente
fallos
página
estrategia
conoce
paginación
demanda
páginas
cargan
demanda
adelantado
fácil
escribir
programa
prueba
lea
sistemática
páginas
espacio
direcciones
extenso
produciendo
tantos
fallos
página
suficiente
memoria
contenerlos
fortuna
mayoría
procesos
traba-
jan
Exhiben
localidad
referencia
significa
fase
ejecución
proceso
referencia
fracción
relativamente
pequeña
pá-
ginas
ejemplo
compilador
pasadas
referencia
fracción
páginas
fracción
distinta
conjunto
páginas
utiliza
proceso
momento
conoce
conjun-
to
trabajo
Denning
1968a
Denning
1980
conjunto
trabajo
memoria
proceso
ejecutará
producir
fallos
avance
fase
ejecución
ejem-
plo
compilador
memoria
disponible
pequeña
pa-
ra
contener
conjunto
trabajo
completo
proceso
producirá
fallos
página
ejecutará
lentamente
ejecutar
instrucción
requieren
nanosegun-
leer
página
disco
requieren
general
10
milisegundos
proporción
instrucciones
10
milisegundos
requeriría
eternidad
terminar
programa
produce
fallos
página
instrucciones
sobrepaginando
thras-
hing
Denning
1968b
sistema
multiprogramación
procesos
mueven
frecuencia
disco
páginas
eliminan
memoria
dejar
procesos
tengan
oportunidad
www.FreeLibros.meusar
CPU
surge
pregunta
proceso
regresa
Téc-
nicamente
proceso
producirá
fallos
página
car-
gado
conjunto
trabajo
problema
20
100
1000
fallos
página
carga
proceso
lento
desperdicia
tiempo
considerable
CPU
sistema
operativo
tarda
milisegundos
tiempo
CPU
pro-
cesar
fallo
página
sistemas
paginación
tratan
conjunto
trabajo
proceso
aseguran
esté
memoria
permitir
proceso
ejecute
Es-
método
conoce
modelo
conjunto
trabajo
Denning
1970
diseñado
reducir
proporción
fallos
página
proceso
cargar
páginas
permitir
ejecuten
procesos
conoce
prepaginación
conjunto
trabajo
cambia
tiempo
programas
referencia
espa-
cio
direcciones
uniforme
referencias
tienden
agruparse
pequeño
número
páginas
referencia
memoria
obtener
instrucción
obtener
datos
almacenar
datos
instante
tiempo
conjunto
consistente
páginas
utilizadas
referencias
memoria
recientes
conjunto
w(k
trabajo
/H110051
referencias
recientes
utilizado
páginas
utilizadas
referencias
recientes
w(k
función
mono-
tónicamente
decreciente
límite
w(k
medida
crece
finito
pro-
grama
referencia
páginas
contiene
espacio
direcciones
programas
utilizarán
páginas
figura
3-19
muestra
tamaño
conjun-
to
trabajo
función
k.
210
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
w(k
Figura
3-19
conjunto
trabajo
conjunto
páginas
utilizadas
re-
ferencias
memoria
recientes
función
w(k
tamaño
conjunto
tra-
tiempo
t.
mayoría
programas
acceden
aleatoria
pequeño
núme-
ro
páginas
conjunto
cambia
lentamente
tiempo
explica
rápida
elevación
inicial
curva
lenta
elevación
ejemplo
programa
ejecuta
ciclo
ocupa
páginas
utilizando
datos
páginas
referencia
páginas
1000
instrucciones
referencia
reciente
página
po-
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
211
dría
millón
instrucciones
fase
inicialización
comporta-
miento
asintótico
contenido
conjunto
trabajo
sensible
valor
elegido
k.
forma
distinta
amplio
rango
valores
conjunto
trabajo
cam-
bia
conjunto
trabajo
varía
lentamente
tiempo
pre-
dicción
razonable
páginas
necesitarán
programa
reinicie
base
conjunto
trabajo
detuvo
prepaginación
consiste
cargar
pá-
ginas
reanudar
proceso
implementar
modelo
conjunto
trabajo
necesario
sistema
operativo
lle-
ve
páginas
conjunto
trabajo
información
conduce
inmediato
algoritmo
reemplazo
páginas
ocurra
fallo
página
buscar
página
encuentre
conjunto
trabajo
desalojarla
Pa-
ra
implementar
algoritmo
requiere
precisa
determinar
páginas
conjunto
trabajo
definición
conjunto
trabajo
conjunto
páginas
utilizadas
referencias
memoria
recientes
autores
utilizan
referencias
páginas
recientes
elección
arbitraria
implementar
algoritmo
conjunto
tra-
elegir
adelantado
valor
k.
seleccionado
valor
referencia
memoria
conjunto
páginas
utilizadas
referencias
me-
moria
recientes
determina
forma
única
definición
operacional
conjunto
trabajo
significa
ha-
forma
eficiente
calcularlo
ejecución
programa
imaginar
registro
desplazamiento
longitud
referencia
memoria
desplazará
registro
posición
izquierda
insertará
número
página
referencia
reciente
derecha
conjunto
números
página
registro
desplazamiento
conjunto
trabajo
teoría
fallo
página
contenido
registro
desplazamiento
ex-
traer
ordenar
páginas
duplicadas
eliminadas
resultado
con-
trabajo
proceso
mantener
registro
desplazamiento
procesarlo
fallo
página
extremo
costoso
técnica
utiliza
utilizan
aproximaciones
común
desechar
idea
con-
tar
atrás
referencias
memoria
defecto
tiempo
ejecución
ejemplo
definir
conjunto
trabajo
páginas
utilizadas
10
millones
re-
ferencias
memoria
anteriores
definirlo
conjunto
páginas
utilizadas
100
milisegundos
tiempo
ejecución
práctica
dicha
definición
conveniente
fácil
trabajar
Observe
proceso
tiempo
ejecución
proceso
empieza
ejecución
tiempo
40
milisegundos
tiempo
CPU
tiempo
real
/H11001100
milisegundos
fines
conjunto
trabajo
tiempo
40
mseg
cantidad
tiempo
CPU
utilizado
realidad
proceso
empezó
conoce
comúnmente
tiempo
virtual
actual
aproximación
conjunto
trabajo
proceso
conjunto
páginas
referencia
segundos
tiempo
virtual
veamos
algoritmo
reemplazo
páginas
basado
conjunto
trabajo
idea
básica
buscar
página
esté
conjunto
trabajo
desalojarla
figura
3-20
vemos
porción
tabla
páginas
máquina
páginas
memoria
consideran
candidatos
desalojo
algoritmo
ignora
páginas
www.FreeLibros.meno
memoria
entrada
contiene
elementos
clave
información
tiempo
aproximado
utilizó
página
bit
referenciada
rectángu-
vacío
color
blanco
simboliza
campos
necesita
algoritmo
nú-
mero
marco
página
bits
protección
bit
modificado
212
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Información
acerca
página
2084
2204
Tiempo
virtual
actual
2003
1980
1213
2014
2020
2032
1620
Tabla
páginas
Tiempo
Página
referenciada
pulso
Página
referenciada
pulso
Bit
referenciada
Explora
páginas
examinando
bit
establece
tiempo
tiempo
virtual
actual
edad
elimina
página
edad
recuerda
menor
tiempo
Figura
3-20
algoritmo
conjunto
trabajo
algoritmo
funciona
supone
hardware
establecer
bits
vimos
similar
supone
interrupción
periódica
re-
loj
ejecute
software
borrar
bit
Referenciada
pulso
reloj
fa-
llo
página
explora
tabla
páginas
busca
página
adecuada
desalojarla
medida
procesa
entrada
examina
bit
R.
tiempo
virtual
actual
escribe
campo
Tiempo
tabla
páginas
indicando
página
momento
ocurrió
fallo
página
referencia
página
pulso
reloj
actual
evidente
conjunto
trabajo
candidata
elimi-
nación
supone
abarca
pulsos
reloj
referencia
página
pulso
reloj
actual
can-
didata
eliminación
eliminarse
calcula
edad
tiempo
virtual
actual
Tiempo
compara
edad
página
conjunto
trabajo
página
sustituye
exploración
continúa
actualizando
entradas
restantes
obstante
edad
menor
página
conjunto
trabajo
página
reserva
temporalmente
apunta
página
edad
me-
nor
valor
Tiempo
tabla
completa
explora
encontrar
candidato
desalojar
significa
páginas
conjunto
trabajo
caso
encontraron
páginas
/H110050
desaloja
antigua
caso
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
213
referencia
páginas
pulso
reloj
actual
ende
/H110051
selecciona
azar
eliminarla
preferencia
página
limpia
3.4.9
algoritmo
reemplazo
páginas
WSClock
algoritmo
básico
conjunto
trabajo
incómodo
exige
explorar
tabla
pá-
ginas
fallo
página
localizar
candidato
adecuado
algoritmo
mejorado
basa-
do
algoritmo
reloj
utiliza
información
conjunto
trabajo
conoce
WSClock
Carr
Hennessey
1981
simplicidad
implementación
rendimiento
utilizado
práctica
estructura
datos
necesaria
lista
circular
marcos
página
algorit-
mo
reloj
mostrada
figura
3-21(a
principio
lista
vacía
carga
pri-
mera
página
agrega
lista
medida
agregan
páginas
pasan
lista
formar
anillo
entrada
contiene
campo
Tiempo
algoritmo
básico
conjunto
trabajo
bit
mostrado
bit
mostrado
algoritmo
reloj
fallo
página
examina
página
apunta
manecilla
bit
página
utilizado
pulso
actual
candidata
ideal
eliminación
bit
establece
manecilla
avanza
página
repite
algoritmo
página
secuencia
eventos
muestra
figura
3-21(b
considere
ocurre
página
apunta
manecilla
/H110050
muestra
figura
3-21(c
edad
página
limpia
significa
conjunto
trabajo
copia
válida
disco
marco
página
sim-
plemente
reclama
página
coloca
muestra
figura
3-21(d
página
sucia
reclamar
inmediato
copia
válida
pre-
sente
disco
evitar
conmutación
procesos
escritura
disco
planifica
manecilla
avanza
algoritmo
continúa
página
página
antigua
limpia
allá
línea
utilizar
inmediato
principio
páginas
planificar
disco
ciclo
reloj
reducir
tráfico
disco
establecer
límite
permitir
escri-
ban
vuelta
máximo
páginas
llega
límite
planifican
escrituras
ocurre
manecilla
llega
punto
inicial
casos
considerar
planificado
escritura
planificado
escrituras
caso
manecilla
moviéndose
buscando
página
limpia
planificado
escrituras
momento
completará
escritura
página
marcará
limpia
página
limpia
encuentre
desaloja
página
ne-
cesariamente
escritura
planificada
controlador
disco
reordenar
escri-
turas
optimizar
rendimiento
disco
www
FreeLibros.meEn
caso
páginas
conjunto
trabajo
hubie-
ra
planificado
escritura
información
adicional
simple
re-
clamar
página
limpia
usarla
ubicación
página
limpia
rastrearse
barrido
páginas
limpias
selecciona
página
actual
víctima
escribe
vuelta
disco
214
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
2204
Tiempo
virtual
actual
1213
2084
2032
1620
2020
12003
1980
2014
Tiempo
Bit
página
1213
2084
2032
1620
2020
12003
1980
2014
1213
2084
2032
1620
2020
12003
1980
2014
2204
2084
2032
1620
2020
12003
1980
2014
Figura
3-21
Operación
algoritmo
WSClock
ejemplo
ocurre
/H110051
ejemplo
/H110050
www
FreeLibros.meSECCIÓN
3.4
ALGORITMOS
REEMPLAZO
PÁGINAS
215
3.4.10
Resumen
algoritmos
reemplazo
páginas
visto
variedad
algoritmos
reemplazo
páginas
sección
mostrare-
mos
resumen
lista
algoritmos
descritos
proporciona
figura
3-22
Algoritmo
Comentario
Óptimo
implementar
útil
punto
comparación
NRU
usadas
recientemente
aproximación
burda
LRU
FIFO
entrar
salir
descartar
páginas
importantes
oportunidad
mejora
FIFO
Reloj
Realista
LRU
usadas
recientemente
Excelente
difícil
implementar
exactitud
NFU
utilizadas
frecuentemente
Aproximación
LRU
burda
Envejecimiento
Algoritmo
eficiente
aproxima
LRU
Conjunto
trabajo
costoso
implementar
WSClock
Algoritmo
eficientemente
algoritmo
óptimo
desaloja
página
hará
referencia
futuro
lejano
desgracia
forma
determinar
página
práctica
utilizar
algoritmo
útil
punto
comparación
algorit-
mos
algoritmo
NRU
divide
páginas
clases
dependiendo
bits
M.
selecciona
página
aleatoria
clase
menor
numeración
algoritmo
fácil
implementar
burdo
mejores
FIFO
orden
cargaron
páginas
memoria
mantenerlas
lista
enlazada
Eliminar
página
antigua
vuelve
proceso
trivial
co-
mo
página
FIFO
mala
opción
algoritmo
oportunidad
modificación
FIFO
comprueba
página
eliminarla
página
reserva
modificación
mejora
ma-
nera
considerable
rendimiento
algoritmo
reloj
simplemente
implementación
distin-
ta
algoritmo
oportunidad
propiedades
rendimiento
toma
tiempo
ejecutar
algoritmo
LRU
algoritmo
excelente
implementar
hardware
especial
NFU
burdo
intento
aproximarse
LRU
algoritmo
envejecimiento
aproximación
LRU
implementar
eficiencia
opción
algoritmos
utilizan
conjunto
trabajo
algoritmo
conjunto
traba-
jo
ofrece
rendimiento
razonable
costoso
implementar
WSClock
va-
riante
rendimiento
eficiente
implementar
Figura
3-22
Algoritmos
reemplazo
páginas
descritos
texto
www
FreeLibros.meCon
mejores
algoritmos
envejecimiento
WSClock
basan
LRU
conjunto
trabajo
respectivamente
rendimiento
paginación
pue-
den
implementarse
eficiencia
algoritmos
importantes
práctica
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
secciones
anteriores
explicado
funciona
paginación
analizado
algoritmos
básicos
reemplazo
páginas
mostrar
modelarlos
basta
mecánica
básica
diseñar
sistema
funcione
diferencia
mover
piezas
aje-
drez
jugador
siguientes
secciones
analizaremos
cuestiones
con-
siderar
diseñadores
sistemas
operativos
obtener
rendimiento
sistema
paginación
3.5.1
Políticas
asignación
local
asignación
global
secciones
anteriores
analizado
algoritmos
seleccionar
página
susti-
tuirla
ocurrir
fallo
cuestión
importante
asociada
elección
dejado
cuidadosamente
asignar
memoria
procesos
ejecuta-
bles
competencia
Dé
vistazo
figura
3-23(a
figura
procesos
componen
conjun-
to
procesos
ejecutables
Suponga
obtiene
fallo
página
algoritmo
reem-
plazo
páginas
tratar
encontrar
página
reciente
considerando
páginas
actualmente
asignadas
considerar
páginas
memoria
examina
páginas
asignadas
página
menor
valor
edad
A5
ob-
situación
figura
3-23(b
eliminar
página
menor
valor
edad
importar
elegirá
página
B3
obtendremos
situación
figura
3-23(c
algoritmo
fi-
gura
3-23(b
reemplazo
páginas
local
figura
3-23(c
algoritmo
global
algoritmos
locales
corresponden
efectiva
asignar
proce-
so
fracción
fija
memoria
algoritmos
globales
asignan
marcos
página
dinámica
procesos
ejecutables
número
marcos
página
asignados
pro-
ceso
varía
tiempo
general
algoritmos
globales
funcionan
especial
tamaño
conjun-
to
trabajo
variar
tiempo
vida
proceso
utiliza
algoritmo
local
conjunto
trabajo
crece
producirá
sobrepaginación
marcos
página
libres
conjunto
trabajo
reduce
algoritmos
locales
desperdician
memoria
utiliza
algoritmo
global
sistema
decidir
forma
continua
marcos
pá-
gina
asignar
proceso
supervisar
tamaño
conjunto
trabajo
216
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
217
indicado
bits
envejecimiento
método
necesariamente
evita
sobrepagina-
ción
conjunto
trabajo
cambiar
tamaño
microsegundos
bits
envejecimiento
medida
burda
esparcida
pulsos
reloj
método
algoritmo
asignar
marcos
página
procesos
determinar
periódicamente
número
procesos
ejecución
asignar
proceso
par-
12,416
marcos
página
disponibles
sistema
operativo
10
procesos
proceso
obtiene
1241
marcos
restantes
pasan
reserva
uti-
lizarlos
ocurran
fallos
página
método
equitativo
sentido
otorgar
partes
iguales
memo-
ria
proceso
10
KB
proceso
300
KB
asignar
páginas
proporción
tamaño
proceso
proceso
300
KB
obtiene
30
asig-
nación
proceso
10
KB
Probablemente
prudente
proceso
número
mí-
nimo
ejecutar
importar
pequeño
ejemplo
máquinas
instrucción
operandos
necesitar
páginas
instrucción
operando
origen
operando
destino
extenderse
límites
páginas
asignación
páginas
programas
contengan
tales
instrucciones
ejecutar
utiliza
algoritmo
global
empezar
proceso
número
pági-
nas
proporcional
tamaño
proceso
asignación
actualizar
dinámicamente
medida
ejecuten
procesos
administrar
asignación
utilizando
al-
goritmo
PFF
Page
Fault
Frequency
Frecuencia
fallo
páginas
algoritmo
indica
cuán-
do
incrementar
decrementar
asignación
páginas
proceso
acerca
página
sustituir
fallo
controla
tamaño
conjunto
asigna-
ción
A0
A1
A2
A3
A4
A5
B0
B1
B2
B3
B4
B5
B6
C1
C2
C3
A0
A1
A2
A3
A4
A6
B0
B1
B2
B3
B4
B5
B6
C1
C2
C3
A0
A1
A2
A3
A4
A5
B0
B1
B2
A6
B4
B5
B6
C1
C2
C3
Edad
10
12
Figura
3-23
Comparación
reemplazo
páginas
local
global
Confi-
guración
original
Reemplazo
páginas
local
Reemplazo
páginas
global
www
FreeLibros.mePara
clase
extensa
algoritmos
reemplazo
páginas
incluyendo
LRU
proporción
fallos
disminuye
medida
asignan
páginas
describimos
anterior-
mente
suposición
algoritmo
PFF
propiedad
ilustra
figura
3-24
218
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Fallos
página
seg
Número
marcos
página
asignados
Figura
3-24
Proporción
fallos
página
función
número
marcos
página
asignados
Medir
proporción
fallos
página
proceso
simple
número
fallos
posiblemente
tomando
media
móvil
segundos
transcurridos
sencilla
sumar
número
fallos
página
inmediata-
mente
media
móvil
actual
dividir
línea
punteada
marcada
corres-
ponde
proporción
fallos
página
alta
proceso
emitió
fallo
recibe
marcos
página
reducir
proporción
fallos
línea
punteada
marcada
co-
mo
corresponde
proporción
fallos
página
baja
suponer
proce-
so
demasiada
memoria
caso
quitar
marcos
página
algoritmo
PFF
mantener
proporción
paginación
proceso
límites
aceptables
importante
recalcar
algoritmos
reemplazo
páginas
funcionar
política
sustitución
local
global
ejemplo
FIFO
sustituir
página
antigua
memoria
algoritmo
global
antigua
posea
proceso
actual
algo-
ritmo
local
similar
algoritmo
LRU
aproximación
reemplazar
página
usada
recientemente
memoria
algoritmo
global
página
usa-
recientemente
poseída
proceso
actual
algoritmo
local
elección
local
global
independiente
algoritmo
casos
algoritmos
sustitución
página
sentido
estra-
tegia
local
especial
algoritmos
conjunto
trabajo
WSClock
refieren
proceso
específico
aplicarse
contexto
realidad
conjunto
trabajo
má-
quina
tratar
unión
conjuntos
trabajo
perdería
pro-
piedad
localidad
funcionaría
3.5.2
Control
carga
algoritmo
reemplazo
páginas
asignación
global
óptima
marcos
página
procesos
ocurrir
sistema
sobrepagine
con-
www
FreeLibros.meSECCIÓN
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
219
juntos
trabajo
combinados
procesos
exceden
capacidad
memoria
pue-
esperar
sobrepaginación
síntoma
situación
algoritmo
PFF
indica
al-
gunos
procesos
necesitan
memoria
proceso
necesita
memoria
caso
forma
proporcionar
memoria
procesos
necesitan
lastimar
proceso
única
solución
real
deshacerse
temporalmente
procesos
forma
reducir
número
procesos
compiten
memoria
intercam-
biar
enviándolos
disco
liberar
páginas
mantienen
ejem-
plo
proceso
intercambiarse
disco
marcos
página
dividirse
procesos
sobrepaginando
sobrepaginado
detiene
sistema
operar
forma
tiempo
detiene
intercambiar
proceso
sucesivo
de-
sobrepaginado
ende
paginación
necesitando
intercam-
bio
utiliza
reducir
demanda
potencial
memoria
reclamar
páginas
proceso
intercambiar
procesos
liberar
carga
memoria
semejante
pla-
nificación
niveles
procesos
colocan
disco
utiliza
planificador
corto
plazo
planificar
procesos
restantes
duda
combinar
ideas
don-
intercambien
memoria
procesos
suficientes
proporción
fallo
páginas
aceptable
Periódicamente
procesos
traen
disco
inter-
cambian
factor
considerar
grado
multiprogramación
número
procesos
memoria
principal
CPU
inactiva
largos
pe-
riodos
consideración
sostiene
tomar
tamaño
proceso
proporción
paginación
decidir
proceso
intercambiar
caracterís-
ticas
ligado
CPU
características
proce-
sos
restantes
3.5.3
Tamaño
página
tamaño
página
parámetro
sistema
operativo
elegir
hardware
diseñado
ejemplo
páginas
512
bytes
sistema
operativo
consi-
derar
fácilmente
pares
páginas
sucesivo
páginas
KB
asignar
marcos
página
512
bytes
consecutivos
determinar
tamaño
página
requiere
balancear
factores
competiti-
vos
resultado
tamaño
óptimo
general
empezar
factores
favor
tamaño
página
pequeño
segmento
texto
datos
pila
elegido
azar
llenará
número
integral
páginas
promedio
mitad
página
vacía
espacio
adicional
página
desperdicia
desperdicio
conoce
fragmen-
tación
interna
segmentos
memoria
tamaño
página
bytes
desperdicia-
rán
np/2
bytes
fragmentación
interna
razonamiento
favor
tamaño
página
pequeño
argumento
tamaño
página
pequeño
aparente
consideramos
programa
consiste
fases
secuenciales
KB
tamaño
página
32
KB
asignar
32
KB
programa
tiempo
tamaño
página
16
KB
www.FreeLibros.mesólo
necesita
16
KB
tamaño
página
KB
menor
requiere
KB
instante
general
tamaño
página
hará
utilizada
programa
tamaño
página
pequeño
páginas
pequeñas
implica
programas
necesitarán
páginas
sugiere
necesidad
tabla
páginas
programa
32
KB
necesita
páginas
KB
64
páginas
512
bytes
transferencias
disco
general
página
tiempo
retraso
búsqueda
retraso
rotacional
transferir
página
pequeña
requiere
tiem-
po
transferir
página
podran
requerir
64
10
mseg
cargar
64
páginas
512
bytes
12
mseg
cargar
páginas
KB
máquinas
tabla
páginas
cargar
registros
hardware
CPU
cambia
proceso
máquinas
tamaño
pequeño
página
signi-
fica
tiempo
requerido
cargar
registros
aumenta
medida
pequeña
espacio
ocupado
tabla
páginas
aumenta
medida
reduce
tamaño
páginas
punto
analizar
matemáticamente
Digamos
tamaño
promedio
proceso
bytes
tamaño
página
bytes
supone
entrada
página
requiere
bytes
número
aproximado
páginas
necesarias
proceso
ocupando
bytes
espacio
tabla
páginas
memoria
desperdiciada
pá-
gina
proceso
fragmentación
interna
p/2
sobrecarga
tabla
páginas
pérdida
fragmentación
interna
obtiene
suma
tér-
minos
sobrecarga
/H11005se
/H11001p/2
término
tamaño
tabla
páginas
tamaño
página
peque-
ño
término
fragmentación
interna
tamaño
página
valor
óptimo
sacar
derivada
igualarla
cero
obtenemos
ecuación
/H11002se
/H110011/2
ecuación
derivar
fórmula
proporcione
tamaño
página
óptimo
conside-
rando
memoria
gastada
fragmentación
tamaño
tabla
páginas
resultado
/H11005√
2se
/H110051
MB
/H110058
bytes
entrada
tabla
páginas
tamaño
página
óptimo
KB
computadoras
disponibles
forma
comercial
utilizado
tamaños
página
varían
512
bytes
64
KB
valor
común
solía
KB
co-
mún
KB
KB
medida
memorias
aumentan
tamaño
tamaño
página
tien-
crecer
forma
lineal
Cuadruplicar
tamaño
RAM
rara
duplica
siquiera
tamaño
página
220
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
221
3.5.4
Espacios
separados
instrucciones
datos
computadoras
espacio
direcciones
contiene
pro-
gramas
datos
muestra
figura
3-25(a
espacio
direcciones
bas-
tante
funciona
obstante
pequeño
obliga
programadores
pararse
cabeza
tratando
ajustar
espacio
direcciones
espacio
direcciones
232
Datos
Programa
Espacio
Espacio
232
Programa
Página
usada
Datos
Figura
3-25
espacio
direcciones
Espacios
separados
solución
utilizada
PDP-11
16
bits
espacios
direccio-
nes
separados
instrucciones
texto
programa
datos
llamados
espacio
espacio
respectivamente
muestra
figura
3-25(b
espacio
direcciones
empieza
valor
máximo
general
16
/H110021
232
/H110021
enlazador
utilizan
espacios
separados
ocurre
datos
reubican
di-
rección
virtual
empezar
programa
computadora
diseño
espacios
direcciones
paginar
ma-
nera
independiente
tabla
páginas
asignación
páginas
virtuales
marcos
páginas
físicas
hardware
desea
obtener
instrucción
utilizar
espacio
tabla
páginas
espacio
similar
referencias
datos
pasar
tabla
páginas
espacio
D.
Aparte
distinción
espacios
separados
introduce
complicación
especial
duplica
espacio
di-
recciones
disponible
3.5.5
Páginas
compartidas
cuestión
diseño
compartición
sistema
multiprogramación
común
usuarios
ejecuten
programa
Evidentemente
eficiente
compar-
tir
páginas
evitar
copias
página
memoria
tiempo
problema
páginas
compartir
especial
compartirse
páginas
lectura
texto
programa
páginas
datos
admiten
espacios
separados
relativamente
simple
compartir
programas
ha-
cer
procesos
utilicen
tabla
páginas
espacio
distintas
www.FreeLibros.metablas
páginas
espacios
D.
general
implementación
soporta
com-
partición
forma
tablas
páginas
estructuras
datos
independientes
tabla
procesos
proceso
apuntadores
tabla
procesos
tabla
páginas
espacio
tabla
páginas
espacio
muestra
figu-
ra
3-26
planificador
selecciona
proceso
ejecutarlo
utiliza
apuntadores
pa-
ra
localizar
tablas
páginas
apropiadas
establece
MMU
utilice
espacios
separados
procesos
compartir
programas
bibliotecas
mecanismo
complicado
222
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Programa
Tabla
procesos
Datos
Datos
Tablas
páginas
Figura
3-26
procesos
comparten
programa
compartiendo
tabla
páginas
procesos
comparten
código
ocurre
problema
páginas
com-
partidas
Suponga
procesos
ejecutando
editor
comparten
páginas
planificador
decide
eliminar
memoria
desalojando
páginas
llenando
marcos
página
vacíos
programa
causará
genere
número
fallos
página
pa-
ra
traerlas
vuelta
similar
termina
esencial
descubrir
páginas
espacio
disco
libere
accidente
Buscar
tablas
páginas
página
compartida
frecuentemente
caro
necesitan
estructuras
datos
especiales
páginas
compartidas
especial
uni-
dad
compartición
página
individual
serie
páginas
tabla
pági-
nas
completa
Compartir
datos
complicado
compartir
código
imposible
especial
UNIX
llamada
sistema
fork
padre
hijo
compartir
tex-
www
FreeLibros.meSECCIÓN
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
223
to
programa
texto
datos
sistema
paginado
procesos
tabla
páginas
apunten
conjunto
páginas
realiza
copia
páginas
momento
operación
fork
páginas
datos
asociadas
procesos
LECTURA
READ
ONLY
procesos
lean
datos
modificarlos
situación
conti-
nuar
cualquiera
procesos
actualiza
palabra
memoria
violación
protección
lectura
produce
trap
sistema
operativo
copia
página
ofensora
proceso
copia
privada
Ambas
copias
esta-
blecen
LECTURA-ESCRITURA
READ-WRITE
siguientes
operacio-
nes
escritura
cualquiera
copias
continúen
lanzar
trap
estrategia
significa
páginas
modifican
incluyendo
programa
necesitan
copiar
método
conocido
copiar
escritura
mejora
rendimiento
reducir
co-
piado
3.5.6
Bibliotecas
compartidas
compartición
elementos
páginas
individuales
pro-
grama
inicia
sistemas
operativos
compartirán
auto-
mática
páginas
texto
quedando
copia
memoria
páginas
texto
lectura
problema
Dependiendo
sistema
operativo
proceso
obtener
copia
privada
páginas
datos
compartir
marcar
lectura
proceso
modifica
página
datos
realizará
copia
privada
aplicará
copia
escritura
sistemas
modernos
bibliotecas
extensas
utilizadas
procesos
ejemplo
biblioteca
maneja
diálogo
explorar
archivos
desean
abrir
bibliotecas
gráficos
enlazaran
forma
estática
bibliotecas
programa
eje-
cutable
disco
agrandarían
técnica
común
utilizar
bibliotecas
compartidas
conocen
DLLs
Bibliotecas
enlaces
dinámicos
Windows
aclarar
idea
biblioteca
compartida
considere
enlazamiento
tradicional
programa
enlaza
nom-
bra
archivos
código
objeto
posiblemente
bibliotecas
comando
enlazador
comando
UNIX
ld
.o
lc
lm
enlaza
.o
objeto
directorio
actual
explora
bibliotecas
/usr/
lib
libc.a
/usr
lib
libm.a
funciones
llame
archivos
objeto
es-
tén
ejemplo
printf
conocen
externas
indefinidas
buscan
bibliotecas
encuentran
incluyen
binario
ejecutable
función
llamen
esté
presente
convierte
externa
indefinida
ejemplo
printf
necesita
wri-
write
incluida
enlazador
buscará
incluirá
encuentre
www
FreeLibros.meCuando
enlazador
termina
escribe
archivo
binario
ejecutable
disco
contiene
to-
das
funciones
necesarias
funciones
presentes
biblioteca
llamaron
incluyen
programa
carga
memoria
ejecuta
funciones
necesi-
ta
suponga
programas
comunes
20
50
MB
funciones
gráficos
interfaz
usuario
enlazaran
estática
cientos
programas
biblio-
tecas
desperdiciaría
tremenda
cantidad
espacio
disco
desperdiciar
espa-
cio
RAM
hora
cargarlas
sistema
tendría
forma
compartirlas
entran
bibliotecas
compartidas
programa
vincula
bibliotecas
compartidas
ligeramente
estáticas
incluir
función
llamó
vinculador
incluye
pequeña
rutina
auxiliar
enlaza
función
lla-
mada
tiempo
ejecución
Dependiendo
sistema
detalles
configuración
biblio-
tecas
compartidas
cargan
carga
programa
funciones
llaman
programa
cargado
biblioteca
compartida
necesidad
volver
cargarla
objetivo
Observe
carga
utiliza
bi-
blioteca
compartida
lee
biblioteca
memoria
golpe
pagina
pági-
na
necesario
funciones
llamadas
carguen
RAM
reducir
tamaño
archivos
ejecutables
ahorrar
espacio
memoria
bi-
bliotecas
compartidas
ventaja
función
biblioteca
compartida
actualiza
eliminar
error
necesario
recompilar
programas
llaman
antiguos
binarios
siguen
funcionando
característica
especial
importante
software
comer-
cial
código
fuente
distribuye
cliente
ejemplo
Microsoft
descubre
corri-
ge
error
seguridad
DLL
estándar
Windows
Update
descargará
DLL
sustituirá
programas
utilicen
DLL
automática
versión
próxima
inicien
bibliotecas
compartidas
pequeño
problema
resolver
problema
ilustra
figura
3-27
vemos
procesos
compartiendo
biblioteca
20
KB
tamaño
suponiendo
cuadro
KB
obstante
biblioteca
ubicada
dirección
distinta
proceso
programas
mis-
mo
tamaño
proceso
biblioteca
empieza
dirección
36
proceso
empieza
12K.
Suponga
función
biblioteca
saltar
dirección
16
biblioteca
biblioteca
compartida
reubicarse
instante
momento
cargarla
salto
proceso
pudiera
dirección
virtual
36
/H1100116
Observe
dirección
física
RAM
biblioteca
importa
páginas
asociadas
direcciones
virtuales
direcciones
físicas
hardware
MMU
biblioteca
compartida
reubicación
instantánea
funcionará
proceso
llama
función
dirección
12
instrucción
salto
12
/H1100116
36
/H1100116
pequeño
problema
resolverlo
utilizar
copia
escritura
crear
páginas
proceso
comparta
biblioteca
reubi-
cándolas
instantánemente
medida
crean
evidente
esquema
pro-
pósito
compartir
biblioteca
224
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.5
CUESTIONES
DISEÑO
SISTEMAS
PAGINACIÓN
225
solución
compilar
bibliotecas
compartidas
bandera
compilador
es-
pecial
indicar
compilador
producir
instrucciones
utilicen
direcciones
ab-
solutas
utilizan
instrucciones
direcciones
relativas
ejemplo
instrucción
saltar
atrás
bytes
contraste
instrucción
proporciona
dirección
específica
saltar
instrucción
fun-
ciona
correctamente
importar
coloque
biblioteca
compartida
espacio
di-
recciones
virtuales
evitar
direcciones
absolutas
problema
resolver
código
utiliza
desplazamientos
relativos
conoce
código
independiente
posición
3.5.7
Archivos
asociados
bibliotecas
compartidas
realmente
caso
herramienta
general
conocida
co-
mo
archivos
asociados
memoria
idea
proceso
emitir
llamada
sis-
tema
asociar
archivo
porción
espacio
direcciones
virtuales
implementaciones
traen
páginas
momento
asociación
medida
páginas
paginan
demanda
usando
archivo
disco
al-
macén
respaldo
proceso
termina
desasocia
forma
explícita
archivo
páginas
modificadas
escriben
vuelta
archivo
archivos
asociados
proporcionan
modelo
alternativo
S.
lec-
turas
escrituras
archivo
accesar
arreglo
caracteres
memoria
situaciones
programadores
encuentran
modelo
conveniente
procesos
asocian
archivo
tiempo
comunicar
memoria
compartida
escrituras
realizadas
proceso
memoria
compar-
tida
inmediatamente
visibles
lee
espacio
direcciones
virtua-
asociado
archivo
mecanismo
proporciona
canal
ancho
banda
procesos
utiliza
grado
asociar
archivo
temporal
disponibles
archivos
asociados
memoria
biblio-
tecas
compartidas
mecanismo
Proceso
Proceso
2RAM
36
12
Figura
3-27
biblioteca
compartida
utilizada
procesos
www
FreeLibros.me3.5.8
Política
limpieza
paginación
funciona
marcos
página
libres
reclamar
momento
ocurran
fallos
página
marco
página
lleno
modifi-
cado
traer
página
escribir
página
disco
asegurar
provisión
abundante
marcos
página
libres
sistemas
paginación
proceso
plano
conocido
demonio
paginación
inactivo
tiempo
despierta
forma
periódica
inspeccionar
me-
moria
marcos
página
libres
demonio
paginación
empieza
seleccionar
páginas
desalojarlas
algoritmo
reemplazo
páginas
páginas
modificadas
haberse
cargado
escriben
disco
caso
recuerda
contenido
página
caso
pá-
ginas
desalojadas
necesite
sobrescriba
marco
reclamarse
elimina
reserva
marcos
página
libres
mantener
provisión
marcos
página
mano
obtiene
rendimiento
utilizar
memoria
tratar
encon-
trar
marco
momento
necesitarlo
demonio
paginación
asegura
to-
marcos
libres
estén
limpios
necesitan
escribir
disco
apuro
hora
requeridos
implementar
política
limpieza
reloj
manecillas
manecilla
principal
controlada
demonio
paginación
apunta
página
su-
cia
página
escribe
vuelta
disco
manecilla
principal
avanza
apunta
página
limpia
avanza
manecilla
secundaria
utiliza
reemplazar
páginas
algoritmo
reloj
estándar
probabilidad
manecilla
secundaria
lle-
gue
página
limpia
incrementa
trabajo
demonio
paginación
3.5.9
Interfaz
memoria
virtual
análisis
memoria
virtual
transparente
procesos
programadores
ven
espacio
direcciones
vir-
tuales
computadora
memoria
física
pequeña
sistemas
sistemas
avanzados
programadores
control
mapa
memoria
utilizarlo
maneras
tradicionales
mejorar
comportamiento
programa
sección
analizaremos
formas
razón
otorga
programadores
control
mapa
memoria
permitir
procesos
compartan
memoria
programadores
nombrar
regiones
memoria
proceso
proceso
nombre
región
memoria
proceso
asociarla
pro-
cesos
compartiendo
páginas
compartición
ancho
banda
posi-
ble
proceso
escribe
memoria
compartida
proceso
lee
compartición
páginas
utilizar
implementar
sistema
transmi-
sión
mensajes
alto
rendimiento
general
pasan
mensajes
datos
copian
espacio
direcciones
costo
considerable
procesos
controlar
mapa
páginas
pasar
mensaje
proceso
emisor
desasocie
la(s
pági-
226
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.6
CUESTIONES
IMPLEMENTACIÓN
227
na(s
contiene(n
mensaje
proceso
receptor
la(s
asocia
copiar
nombres
páginas
datos
técnica
administración
avanzada
memoria
memoria
compartida
distribui-
Feeley
colaboradores
1995
Li
1986
Li
Hudak
1989
Zekauskas
colaboradores
1994
idea
permitir
procesos
compartan
red
conjunto
páginas
po-
siblemente
necesario
espacio
direcciones
lineal
compartido
proceso
referencia
página
asociada
obtiene
fallo
página
manejador
fallos
página
espacio
kernel
usuario
localiza
máquina
contiene
página
envía
mensaje
pidiéndole
desasocie
envíe
red
llega
página
asocia
instrucción
falló
reinicia
capítulo
examinare-
mos
memoria
compartida
distribuida
detalle
3.6
CUESTIONES
IMPLEMENTACIÓN
implementadores
sistemas
memoria
virtual
elegir
principales
al-
goritmos
teóricos
algoritmo
oportunidad
envejecimiento
asig-
nación
páginas
local
global
paginación
demanda
prepaginación
cuestiones
prácticas
implementación
sección
daremos
vistazo
problemas
comunes
soluciones
3.6.1
Participación
sistema
operativo
paginación
ocasiones
sistema
operativo
trabajo
relacionado
paginación
crear
proceso
ejecutar
proceso
ocurrir
fallo
página
terminar
proceso
examinaremos
brevemente
ocasiones
crea
proceso
sistema
paginación
sistema
operativo
deter-
minar
programa
datos
principio
crear
tabla
páginas
pa-
ra
asignar
espacio
memoria
tabla
páginas
inicializar
tabla
páginas
necesita
residente
proceso
intercambia
tie-
ne
memoria
proceso
ejecutando
asignar
espacio
área
intercambio
disco
intercambie
página
lugar
don-
área
intercambio
inicializar
texto
programa
datos
proceso
empiece
recibir
fallos
página
páginas
puedan
traer
sistemas
paginan
texto
programa
directamente
archivo
ejecutable
ahorra
espacio
disco
tiempo
inicialización
información
acerca
tabla
páginas
área
intercambio
disco
registrar
tabla
procesos
proceso
planifica
ejecución
MMU
restablecer
proceso
TLB
vacía
deshacerse
restos
proceso
ejecutando
tabla
páginas
proceso
actualizar
general
copiándola
me-
diante
apuntador
cierto(s
registro(s
hardware
opcional
www.FreeLibros.metodas
páginas
proceso
traer
memoria
reducir
número
fallos
página
principio
ejemplo
evidente
necesaria
página
apunta
PC
ocurre
fallo
página
sistema
operativo
leer
registros
hardwa-
re
determinar
dirección
virtual
produjo
fallo
base
información
calcu-
lar
página
necesita
localizarla
disco
buscar
marco
página
disponible
colocar
página
desalojando
página
necesario
leer
página
necesaria
colocarla
marco
páginas
respaldar
con-
tador
programa
apunte
instrucción
falló
dejar
instrucción
eje-
cute
proceso
termina
sistema
operativo
liberar
tabla
páginas
páginas
espacio
disco
ocupan
páginas
disco
páginas
compartidas
procesos
páginas
memoria
disco
liberarse
proceso
utilice
terminado
3.6.2
Manejo
fallos
página
Finalmente
posición
describir
detalle
ocurre
fallo
página
secuencia
eventos
hardware
trap
kernel
guardando
contador
programa
pila
máquinas
guarda
información
acerca
instruc-
ción
actual
registros
especiales
CPU
inicia
rutina
código
ensamblador
guardar
registros
generales
información
volátil
evitar
sistema
operativo
destruya
rutina
llama
sistema
operativo
procedimiento
sistema
operativo
descubre
ocurrido
fallo
página
descubrir
página
virtual
necesita
registros
hardware
contiene
infor-
mación
sistema
operativo
obtener
contador
programa
obtener
instrucción
analizarla
software
averiguar
ocu-
rrió
fallo
conoce
dirección
virtual
produjo
fallo
sistema
comprueba
dirección
válida
protección
consistente
acceso
pro-
ceso
recibe
señal
eliminado
dirección
válida
ocurrido
fallo
página
sistema
comprueba
marco
página
disponible
marcos
dis-
ponibles
ejecuta
algoritmo
reemplazo
páginas
seleccionar
víctima
marco
página
seleccionado
sucio
página
planifica
transferirla
dis-
co
realiza
conmutación
contexto
suspendiendo
proceso
fallido
dejando
ejecute
completado
transferencia
disco
ca-
so
marco
marca
ocupado
evitar
utilice
propósito
228
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.6
CUESTIONES
IMPLEMENTACIÓN
229
marco
página
esté
limpio
inmediato
escri-
birlo
disco
sistema
operativo
busca
dirección
disco
página
necesaria
planifica
operación
disco
llevarla
memoria
cargando
página
proceso
fallido
suspendido
ejecuta
proceso
usuario
disponible
interrupción
disco
indica
página
llegado
tablas
páginas
actualizan
reflejar
posición
marco
marca
normal
instrucción
fallida
respalda
empezó
contador
programa
restablece
apuntar
instrucción
proceso
fallido
planifica
sistema
operativo
regresa
rutina
lenguaje
en-
samblador
llamó
10
rutina
recarga
registros
información
regresando
espacio
usuario
continuar
ejecución
hubiera
ocurrido
fallo
3.6.3
Respaldo
instrucción
programa
referencia
página
memoria
instrucción
pro-
dujo
fallo
detiene
parcialmente
ocurre
trap
sistema
operativo
sistema
operativo
obtiene
página
necesaria
reiniciar
instrucción
produjo
trap
fá-
cil
naturaleza
problema
casos
considere
CPU
ins-
trucciones
direcciones
procesador
Motorola
680x0
utilizado
ampliamente
sis-
temas
integrados
ejemplo
instrucción
MOV.L
6(A1),2(A0
bytes
vea
figura
3-28
reiniciar
instrucción
sistema
operativo
de-
terminar
byte
instrucción
valor
contador
programa
momento
ocurre
trap
depende
operando
falló
imple-
mentado
microcódigo
CPU
MOVE
1000
1002
1004
Código
operación
operando
operando
16
Bits
MOVE.L
6(A1
2(A0
Figura
3-28
instrucción
produce
fallo
página
figura
3-28
instrucción
empieza
dirección
1000
referencias
memoria
palabra
instrucción
desplazamientos
operandos
www
FreeLibros.me230
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Dependiendo
referencias
memoria
ocasionado
fallo
página
con-
tador
programa
1000
1002
1004
momento
fallo
frecuencia
imposi-
ble
sistema
operativo
determine
ambigüedad
empezó
instrucción
contador
programa
1002
momento
fallo
sistema
operativo
palabra
1002
dirección
memoria
asociada
instrucción
1000
ejem-
plo
ubicación
operando
código
operación
instrucción
problema
modos
direcciona-
miento
680x0
utilizan
autoincremento
significa
efecto
secundario
ejecutar
instrucción
incrementar
registros
instrucciones
utilizan
autoin-
cremento
fallar
Dependiendo
detalles
microcódigo
incremento
referencia
memoria
cuyo
caso
sistema
operativo
decremen-
tar
registro
software
reiniciar
instrucción
autoincremento
referencia
memoria
cuyo
caso
momento
trap
sistema
operativo
deberá
deshacerlo
autodecremento
produce
problema
similar
detalles
precisos
autoincrementos
autodecre-
mentos
correspondientes
referencias
memoria
diferir
instrucción
modelo
CPU
fortuna
máquinas
diseñadores
CPU
proporcionan
solución
general
forma
registro
interno
oculto
copia
contador
programa
justo
ejecutar
instrucción
máquinas
registro
indique
registros
autoincrementado
autodecrementado
Dada
información
sistema
operativo
deshacer
ambigüedad
efectos
instruc-
ción
fallida
reiniciar
información
disponible
sistema
operativo
peripecias
averiguar
ocurrió
repararlo
diseñadores
hardware
pudieran
resolver
problema
pasaran
responsabilidad
escritores
sistema
operativo
3.6.4
Bloqueo
páginas
memoria
hablado
capítulo
computadora
memoria
virtual
significa
estén
ausentes
operaciones
S.
memoria
virtual
interactúan
formas
sutiles
Considere
proceso
acaba
emitir
llamada
sis-
tema
leer
archivo
dispositivo
colocarlo
búfer
espacio
direccio-
nes
espera
complete
proceso
suspende
permite
proceso
ejecutarse
proceso
recibe
fallo
página
algoritmo
paginación
global
pequeña
probabilidad
distinta
cero
página
contiene
búfer
seleccionada
eliminarla
memoria
dispo-
sitivo
proceso
transferencia
DMA
página
eli-
minarla
datos
escribirán
búfer
pertenecen
página
acaba
cargar
solución
problema
bloquear
páginas
involucradas
operaciones
memoria
eliminen
Bloquear
página
conoce
www
FreeLibros.meSECCIÓN
3.6
CUESTIONES
IMPLEMENTACIÓN
231
fijada
pinning
memoria
solución
enviar
operaciones
búfe-
res
kernel
copiar
datos
páginas
usuario
3.6.5
Almacén
respaldo
análisis
algoritmos
reemplazo
páginas
vimos
selecciona
pá-
gina
eliminarla
coloca
disco
pagina
memoria
describir
cuestiones
relacionadas
administración
disco
algoritmo
simple
asignar
espacio
página
disco
partición
intercambio
especial
disco
tenerla
disco
separado
sistema
operativo
balancear
carga
sistemas
UNIX
funcionan
parti-
ción
sistema
archivos
normal
elimina
sobrecarga
convertir
desplaza-
mientos
archivos
direcciones
bloque
utilizan
números
bloque
relativos
inicio
partición
inicia
sistema
partición
intercambio
vacía
representa
memo-
ria
entrada
proporciona
origen
tamaño
esquema
simple
inicia
proceso
reserva
trozo
área
partición
tamaño
pro-
ceso
reduce
área
restante
cantidad
medida
inician
procesos
asigna
trozos
partición
intercambio
tamaño
equivalente
imágenes
nú-
cleo
terminar
libera
espacio
disco
partición
intercambio
administra
lista
trozos
libres
capítulo
10
analizaremos
mejores
algoritmos
proceso
asociada
dirección
disco
área
intercambio
partición
intercambio
mantiene
imagen
información
mantiene
ta-
bla
procesos
cálculo
dirección
escribir
página
simple
su-
ma
desplazamiento
página
espacio
direcciones
virtual
inicio
área
intercambio
proceso
empezar
inicializar
área
in-
tercambio
forma
copiar
imagen
proceso
área
intercambio
traer
colocar
memoria
necesario
cargar
proceso
memoria
dejar
pagine
necesario
simple
modelo
problema
procesos
incrementar
tamaño
empezar
texto
programa
general
fijo
área
datos
cre-
cer
pila
crecer
consecuencia
reservar
áreas
intercambio
separadas
texto
datos
pila
permitiendo
áreas
con-
sista
trozo
disco
extremo
asignar
adelantado
asignar
espacio
disco
pá-
gina
intercambie
memoria
desasignarlo
vuelva
in-
tercambiar
memoria
forma
procesos
memoria
acaparan
espacio
intercambio
desventaja
necesita
dirección
disco
memoria
página
disco
palabras
tabla
proceso
indique
página
disco
alternativas
muestran
fi-
gura
3-29
www
FreeLibros.meEn
figura
3-29(a
ilustra
tabla
páginas
páginas
páginas
es-
tán
memoria
páginas
disco
área
intercambio
disco
gran-
espacio
direcciones
virtuales
proceso
páginas
página
ubicación
fija
escribe
desaloja
memoria
principal
calcular
di-
rección
requiere
empieza
área
paginación
proceso
páginas
almacenan
contigua
ordenadas
número
página
virtual
página
memoria
copia
sombra
disco
copia
obsoleta
página
modificó
haberla
cargado
páginas
sombreadas
memoria
indican
pá-
ginas
presentes
memoria
páginas
sombreadas
disco
principio
su-
plantadas
copias
memoria
página
memoria
intercambiar
vuelta
disco
modificado
cargó
utilizará
copia
disco
sombreada
figura
3-29(b
páginas
direcciones
fijas
disco
intercambia
página
memoria
selecciona
página
vacía
disco
momento
mapa
disco
espacio
dirección
disco
página
virtual
actualiza
ma-
nera
acorde
página
memoria
copia
disco
entradas
mapa
disco
contienen
dirección
disco
inválida
bit
marca
partición
intercambio
fija
ejemplo
par-
ticiones
disco
disponibles
caso
utilizar
archivos
previamente
asig-
nados
sistema
archivos
normal
Windows
utiliza
método
utilizar
optimización
reducir
cantidad
espacio
disco
necesaria
tex-
to
programa
proceso
proviene
archivo
ejecutable
sistema
archivos
archivo
ejecutable
utilizar
área
intercambio
texto
programa
generalmente
lectura
memoria
escasa
desalojar
páginas
programa
memoria
descartan
vuelven
leer
archivo
ejecutable
necesiten
bibliotecas
compartidas
trabajar
forma
232
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Páginas
Tabla
páginas
Memoria
principal
Disco
Área
intercambio
Pages
Tabla
páginas
Memoria
principal
Disco
Área
intercambio
Mapa
disco
Figura
3-29
Paginación
área
intercambio
estática
Respaldo
pági-
nas
forma
dinámica
www
FreeLibros.meSECCIÓN
3.6
CUESTIONES
IMPLEMENTACIÓN
233
3.6.6
Separación
política
mecanismo
importante
herramienta
administrar
complejidad
sistema
separar
po-
lítica
mecanismo
principio
aplicar
administración
memoria
administrador
memoria
ejecute
proceso
nivel
usuario
Di-
cha
separación
Mach
Young
colaboradores
1987
aná-
lisis
basa
general
Mach
figura
3-30
muestra
ejemplo
simple
separar
política
me-
canismo
sistema
administración
memoria
divide
partes
manejador
MMU
nivel
manejador
fallos
página
forma
kernel
paginador
externo
ejecuta
espacio
usuario
detalles
acerca
funcionamiento
MMU
encapsulados
manejador
MMU
código
dependiente
máquina
volver
escribirse
pla-
taforma
porte
sistema
operativo
manejador
fallos
página
código
indepen-
diente
máquina
contiene
mecanismo
paginación
política
determina
paginador
externo
ejecuta
proceso
usuario
DiscoMemoria
principal
Paginador
externo
Manejador
fallos
Proceso
usuario
Manejador
MMU
Fallo
página
Asocia
página
página
Espacio
usuario
Espacio
kernel
Página
necesaria
Llega
página
Página
requiere
Figura
3-30
Manejo
fallos
página
paginador
externo
inicia
proceso
notifica
paginador
externo
establecer
mapa
páginas
proceso
asignar
almacenamiento
respaldo
disco
necesario
medida
proceso
ejecuta
asignar
objetos
espacio
direcciones
notifica
paginador
externo
proceso
empieza
ejecutarse
obtener
fallo
página
manejador
fallos
averigua
página
virtual
necesita
envía
mensaje
paginador
externo
indicán-
www.FreeLibros.medole
problema
paginador
externo
lee
página
necesaria
disco
copia
porción
espacio
direcciones
indica
manejador
fallos
es-
tá
página
manejador
fallos
desasigna
página
espacio
direcciones
pagi-
nador
externo
pide
manejador
MMU
coloque
espacio
direcciones
usuario
lugar
correcto
reiniciar
proceso
usuario
implementación
deja
establecido
colocar
algoritmo
reemplazo
páginas
limpio
tenerlo
paginador
externo
problemas
mé-
problema
principal
paginador
externo
acceso
bits
páginas
bits
desempeñan
papel
algoritmos
paginación
ende
necesita
mecanismo
pasar
información
paginador
externo
algoritmo
reemplazo
páginas
kernel
caso
manejador
fallos
indica
pagi-
nador
externo
página
seleccionado
desalojarla
proporciona
datos
asignán-
dola
espacio
direcciones
eterno
paginador
incluyéndola
mensaje
forma
paginador
externo
escribe
datos
disco
principal
ventaja
implementación
obtiene
código
modular
flexibilidad
principal
desventaja
sobrecarga
adicional
cruzar
límite
usua-
rio
kernel
sobrecarga
diversos
mensajes
envían
partes
sistema
momentos
tema
controversial
medida
computadoras
rápidas
software
complejo
larga
sacrificar
cier-
to
rendimiento
software
confiable
probablemente
aceptable
mayoría
implementadores
3.7
SEGMENTACIÓN
memoria
virtual
analizado
unidimensional
direccio-
nes
virtuales
dirección
máxima
dirección
mu-
chos
problemas
espacios
direcciones
virtuales
separados
ejemplo
compilador
tablas
generan
medida
procede
compilación
posiblemente
incluyen
texto
código
fuente
guarda
listado
impreso
sistemas
procesa-
miento
lotes
tabla
símbolos
contiene
nombres
atributos
variables
tabla
contiene
constantes
enteras
punto
flotante
utilizadas
árbol
análisis
sintáctico
contiene
análisis
sintáctico
programa
pila
utilizada
llamadas
procedimientos
compilador
primeras
tablas
crece
forma
continua
medida
procede
compila-
ción
crece
reduce
maneras
impredecibles
compilación
memo-
ria
unidimensional
tablas
tendría
asignar
trozos
contiguos
espacio
direcciones
virtuales
figura
3-31
234
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.7
SEGMENTACIÓN
235
Considere
ocurre
programa
número
variables
usual
cantidad
normal
trozo
espacio
direcciones
asignado
ta-
bla
símbolos
llenar
espacio
tablas
compilador
simplemente
emitir
mensaje
indicando
compilación
continuar
demasiadas
variables
deportivo
de-
ja
espacio
tablas
posibilidad
jugar
Robin
Hood
tomando
espacio
tablas
exceso
dándolo
tablas
espacio
revoltura
hacerse
similar
administra
sobrepuestos
molestia
mínimo
casos
trabajo
te-
dioso
recompensas
necesita
realmente
forma
liberar
programador
administrar
tablas
expansión
contracción
forma
memoria
virtual
elimina
preocu-
pación
organizar
programa
sobrepuestos
solución
simple
extremado
general
proporcionar
máquina
espacios
direcciones
completo
independientes
llamados
segmentos
segmento
consiste
secuencia
lineal
direcciones
valor
máximo
longitud
segmento
valor
máximo
permitido
distintos
segmentos
te-
ner
distintas
longitudes
general
longitudes
segmentos
cambiar
ejecución
longitud
segmento
pila
incrementarse
meta
pila
decrementarse
saque
segmento
constituye
espacio
direcciones
separado
distintos
seg-
mentos
crecer
reducirse
independiente
afectar
pila
Espacio
utiliza
actualmente
árbol
análisis
sintáctico
Libre
Espacio
direcciones
virtuales
Tabla
símbolos
tabla
símbolos
topado
tabla
texto
código
fuente
Espacio
direcciones
asignado
árbol
análisis
sintáctico
Árbol
análisis
sintáctico
Texto
código
fuente
Tabla
constantes
Pila
llamadas
Figura
3-31
espacio
direcciones
unidimensional
tablas
aumentan
tamaño
tabla
toparse
www.FreeLibros.mecierto
segmento
necesita
espacio
direcciones
crecer
tenerlo
na-
espacio
direcciones
topar
segmento
llenar
general
segmentos
ocurrencia
ra-
ra
especificar
dirección
memoria
segmentada
bidimensional
programa
suministrar
dirección
partes
número
segmento
dirección
segmen-
to
figura
3-32
ilustra
memoria
segmentada
tablas
compilador
vi-
mos
muestran
segmentos
independientes
236
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Tabla
símbolos
Texto
fuente
Constantes
Árbol
análisis
sintáctico
Pila
llamadas
Segmento
Segmento
Segmento
Segmento
Segmento
20
16
12
12
16
12
12
Figura
3-32
memoria
segmentada
permite
tabla
crezca
reduzca
independiente
tablas
Enfatizamos
segmento
entidad
lógica
programador
consciente
utiliza
entidad
lógica
segmento
contener
procedimiento
arreglo
pila
colección
variables
escalares
general
contiene
mezcla
dis-
tintos
tipos
memoria
segmentada
ventajas
simplificar
manejo
estructuras
datos
aumentan
reducen
tamaño
procedimiento
ocupa
segmento
separado
dirección
dirección
inicial
vinculación
procedimientos
compilan
separado
simplifica
considerable
compilado
vinculado
to-
procedimientos
constituyen
programa
llamada
procedimiento
segmen-
to
utilizará
dirección
partes
direccionar
palabra
punto
entrada
procedimiento
segmento
modifica
recompila
posteriormente
necesi-
dad
cambiar
procedimientos
modificado
direcciones
iniciales
versión
memoria
unidimensional
procedi-
mientos
empaquetan
estrechamente
espacio
direcciones
consecuencia
cambiar
tamaño
procedimiento
afectar
dirección
inicial
procedimientos
relacionados
requiere
modificación
proce-
www
FreeLibros.meSECCIÓN
3.7
SEGMENTACIÓN
237
dimientos
llamen
cualquiera
procedimientos
movieron
incorporar
direcciones
iniciales
programa
contiene
cientos
procedimientos
proceso
costoso
segmentación
facilita
compartición
procedimientos
datos
pro-
cesos
ejemplo
común
biblioteca
compartida
estaciones
trabajo
modernas
ope-
ran
sistemas
ventanas
avanzados
bibliotecas
gráficas
extremo
extensas
compilan
programas
sistema
segmentado
biblioteca
gráfica
colocar
segmento
procesos
compartirla
eliminando
necesidad
tenerla
espacio
direcciones
proceso
bibliotecas
compar-
tidas
sistemas
paginación
puros
complicado
efecto
sistemas
me-
diante
simulación
segmentación
segmento
forma
entidad
lógica
programador
consciente
co-
mo
procedimiento
arreglo
pila
distintos
segmentos
tipos
protección
segmento
procedimiento
especificar
ejecución
prohibir
intentos
leer
almacenar
arreglo
punto
flotante
especi-
ficar
lectura
escritura
ejecución
intentos
saltar
atraparán
Dicha
protección
útil
atrapar
errores
programación
lector
tratar
comprender
protección
sensible
memoria
segmen-
tada
memoria
paginada
unidimensionalmente
memoria
segmentada
usuario
consciente
segmento
general
segmento
contendría
procedimiento
pila
ejemplo
segmento
con-
tipo
objeto
protección
apropiada
tipo
específico
pagi-
nación
segmentación
comparan
figura
3-33
contenido
página
sentido
accidental
programador
siquiera
consciente
ocurriendo
paginación
cuan-
tos
bits
entrada
tabla
páginas
especificar
acceso
permitido
utilizar
es-
ta
característica
programador
tendría
registro
lugar
encontraran
límites
página
espacio
direcciones
paginación
inventó
eliminar
precisamen-
tipo
administración
usuario
memoria
segmentada
ilusión
segmentos
encuentran
memoria
principal
tiempo
direc-
cionarlos
estuvieran
proteger
segmento
separado
preocupar-
administración
superponerlos
3.7.1
Implementación
segmentación
pura
implementación
segmentación
difiere
paginación
esencial
páginas
tamaño
fijo
segmentos
figura
3-34(a
muestra
ejemplo
memoria
fí-
sica
principio
contiene
segmentos
considere
ocurre
segmento
desaloja
segmento
pequeño
coloca
lugar
Obtendremos
configuración
memoria
figura
3-34(b
segmento
área
hue-
co
segmento
reemplaza
segmento
figura
3-34(c
segmen-
to
reemplaza
segmento
figura
3-34(d
www
FreeLibros.meUna
sistema
ejecución
tiempo
memoria
dividirá
número
trozos
contendrán
segmentos
huecos
fenómeno
lla-
mado
efecto
tablero
ajedrez
fragmentación
externa
desperdicia
memoria
huecos
manejar
compactación
veremos
figura
3-34(c
3.7.2
Segmentación
paginación
MULTICS
segmentos
extensos
inconveniente
imposible
mantenerlos
comple-
tos
memoria
principal
idea
paginarlos
páginas
realmente
necesiten
tengan
presentes
sistemas
importantes
soportado
seg-
mentos
páginas
sección
describiremos
MULTICS
analiza-
remos
reciente
Intel
Pentium
MULTICS
operaba
máquinas
Honeywell
6000
descendientes
proveía
pro-
grama
memoria
virtual
18
segmentos
250,000
65,536
palabras
36
bits
longitud
implementar
diseñadores
MULTICS
optaron
considerar
segmento
memoria
virtual
paginaron
com-
238
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Consideración
Paginación
Segmentación
Necesita
programador
consciente
utilizando
técnica
espacios
direcciones
lineales
espacio
direcciones
exceder
tamaño
memoria
física
procedimientos
datos
diferenciarse
protegerse
separado
tablas
cuyo
tamaño
fluctúa
acomodarse
facilidad
facilita
compartición
procedimientos
usuarios
inventó
técnica
obtener
permitir
espacio
direcciones
programas
datos
lineal
comprar
dividirse
espacios
memoria
física
direcciones
lógicamente
inde-
pendientes
ayudando
compartición
protección
Figura
3-33
Comparación
paginación
segmentación
www
FreeLibros.meSECCIÓN
3.7
SEGMENTACIÓN
239
binando
ventajas
paginación
tamaño
página
uniforme
mantener
segmento
memoria
utilizando
ventajas
segmentación
facilidad
programación
modularidad
protección
compartición
programa
MULTICS
tabla
segmentos
descriptor
segmento
potencia
cuarto
millón
entradas
tabla
tabla
segmentos
segmento
pagina
descriptor
segmentos
contiene
indicación
acerca
segmento
memoria
principal
segmento
memoria
con-
sidera
segmento
memoria
tabla
páginas
memoria
segmento
es-
tá
memoria
descriptor
contiene
apuntador
18
bits
tabla
páginas
figura
3-35(a
direcciones
físicas
24
bits
páginas
alinean
límites
64
bytes
implicando
bits
menor
orden
direcciones
página
000000
necesitan
18
bits
descriptor
almacenar
dirección
tabla
páginas
descriptor
contiene
tamaño
segmento
bits
protección
elementos
figura
3-35(b
ilustra
descriptor
segmento
MULTICS
dirección
segmento
me-
moria
secundaria
descriptor
segmentos
tabla
utilizada
maneja-
dor
fallos
segmento
segmento
espacio
direcciones
virtual
ordinario
pagina
forma
memoria
paginada
segmentada
descrita
anteriormente
capítulo
tamaño
normal
página
1024
palabras
segmentos
utilizados
MULTICS
paginados
paginados
unidades
64
palabras
ahorrar
memoria
física
dirección
MULTICS
consiste
partes
segmento
dirección
seg-
mento
dirección
segmento
divide
número
página
pa-
labra
página
muestra
figura
3-36
ocurre
referencia
memoria
cabo
algoritmo
c)(b)(a
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
Segmento
10
Figura
3-34
a)-(d
Desarrollo
efecto
tablero
ajedrez
Eliminación
efecto
tablero
ajedrez
compactación
www
FreeLibros.me240
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
número
segmento
utiliza
encontrar
descriptor
segmentos
realiza
comprobación
tabla
páginas
segmento
memo-
ria
tabla
páginas
memoria
localiza
ocurre
fallo
segmento
violación
protección
ocurre
fallo
trap
entrada
tabla
páginas
página
virtual
solicitada
examina
pági-
na
memoria
dispara
fallo
página
memoria
direc-
Dirección
memoria
principal
tabla
páginas
Longitud
seg-
mento
páginas
18
Tamaño
página
1024
palabras
64
palabras
segmento
paginado
segmento
paginado
Bits
Bits
protección
Descriptor
segmento
Descriptor
segmento
Descriptor
segmento
Descriptor
segmento
Descriptor
segmento
Descriptor
segmento
Descriptor
segmento
Segmento
descriptor
36
bits
Entrada
página
Entrada
página
Entrada
página
Tabla
páginas
segmento
Entrada
página
Entrada
página
Entrada
página
Tabla
páginas
segmento
Figura
3-35
memoria
virtual
MULTICS
segmento
descriptor
apun-
ta
tablas
páginas
descriptor
segmento
números
longi-
tudes
campos
www
FreeLibros.meSECCIÓN
3.7
SEGMENTACIÓN
241
ción
memoria
principal
inicio
página
extrae
entrada
tabla
páginas
desplazamiento
agrega
origen
página
obtener
dirección
memoria
principal
palabra
Finalmente
cabo
operación
lectura
almacenamiento
Número
segmento
Número
página
Desplazamiento
página
18
10
Dirección
segmento
Figura
3-36
dirección
virtual
MULTICS
34
bits
proceso
ilustra
figura
3-37
simpleza
omitimos
seg-
mento
descriptor
paginado
ocurre
realidad
utiliza
registro
regis-
tro
base
descriptor
localizar
tabla
páginas
segmento
descriptor
apunta
páginas
segmento
descriptor
encontrado
descriptor
segmento
necesario
direccionamiento
procede
muestra
figura
3-37
Número
segmento
Número
página
Desplazamiento
Segmento
descriptor
Número
segmento
Número
página
Dirección
virtual
MULTICS
Tabla
páginas
Página
Palabra
Desplazamiento
Descriptor
Marco
página
Figura
3-37
Conversión
dirección
MULTICS
partes
dirección
memoria
principal
duda
adivinado
momentos
sistema
operativo
llevara
cabo
algoritmo
instrucción
programas
ejecutarían
rapidez
rea-
lidad
hardware
MULTICS
contiene
TLB
16
palabras
alta
velocidad
bus-
car
llave
dada
entradas
paralelo
ilustra
figura
3-38
www.FreeLibros.mepresenta
dirección
computadora
hardware
direccionamiento
comprueba
dirección
virtual
esté
TLB
obtiene
número
marco
página
directamen-
TLB
forma
dirección
actual
palabra
referenciada
buscar
segmen-
to
descriptor
tabla
páginas
242
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Número
segmento
Página
virtual
Marco
página
Campo
comparación
Protección
Edad
entrada
12
12
Lectura
escritura
lectura
Lectura
escritura
ejecución
ejecución
13
10
Figura
3-38
versión
simplificada
TLB
MULTICS
existencia
ta-
maños
página
TLB
real
complicado
direcciones
16
páginas
referencia
reciente
mantienen
TLB
programas
cuyo
conjunto
trabajo
menor
tamaño
TLB
equilibrarán
di-
recciones
conjunto
trabajo
TLB
ejecutarán
eficiencia
página
TLB
referencia
descriptor
tablas
páginas
encontrar
dirección
marco
TLB
actualiza
incluir
página
página
recien-
descarta
campo
edad
registro
entrada
reciente
ra-
zón
TLB
comparar
números
segmento
página
entradas
paralelo
3.7.3
Segmentación
paginación
Intel
Pentium
memoria
virtual
Pentium
asemeja
formas
MULTICS
incluyendo
presen-
cia
segmentación
paginación
MULTICS
256
segmentos
independientes
64
palabras
36
bits
Pentium
16
segmentos
independientes
contiene
mil
millones
palabras
32
bits
segmen-
tos
tamaño
segmento
importante
programas
necesi-
1000
segmentos
programas
necesitan
segmentos
extensos
corazón
memoria
virtual
Pentium
consiste
tablas
llamadas
LDT
Local
Descriptor
Table
Tabla
descriptores
locales
GDT
Global
Descriptor
Table
Tabla
descrip-
www
FreeLibros.meSECCIÓN
3.7
SEGMENTACIÓN
243
tores
globales
programa
LDT
GDT
compartida
programas
computadora
LDT
describe
segmentos
locales
programa
in-
cluyendo
código
datos
pila
etcétera
GDT
describe
segmentos
sistema
incluyendo
sistema
operativo
acceder
segmento
programa
Pentium
carga
selector
seg-
mento
registros
segmento
máquina
ejecución
registro
CS
contiene
selector
segmento
código
registro
DS
contiene
selector
segmen-
to
datos
registros
segmento
importantes
selector
número
16
bits
muestra
figura
3-39
Índice
GDT/1
LDT
Nivel
privilegio
Bits
13
Figura
3-39
selector
Pentium
bits
selector
indica
segmento
local
global
LDT
GDT
trece
bits
especifican
número
entrada
LDT
GDT
tablas
restringidas
contener
descriptores
segmento
bits
relacionan
protección
describen
descriptor
prohibido
car-
garse
segura
registro
segmento
indicar
registro
segmento
es-
tá
disponible
momento
Produce
trap
utiliza
momento
carga
selector
registro
segmento
descriptor
correspon-
diente
obtiene
LDT
GDT
almacena
registros
microprograma
pue-
acceder
rapidez
ilustra
figura
3-40
descriptor
consiste
bytes
incluyendo
dirección
base
segmento
tamaño
información
formato
selector
elegido
inteligencia
facilitar
localización
des-
criptor
selecciona
LDT
GDT
base
bit
selector
selec-
tor
copia
registro
temporal
interno
bits
menor
orden
establecen
suma
dirección
tabla
LDT
GDT
proporcionar
apuntador
des-
criptor
ejemplo
selector
72
refiere
entrada
GDT
di-
rección
GDT
/H1100172
rastrear
pasos
par
selector
desplazamiento
convierte
dirección
física
microprograma
registro
segmento
utilizando
encontrar
descriptor
completo
corresponde
selector
registros
internos
segmento
selector
momento
paginó
sacarlo
memo-
ria
produce
trap
hardware
utiliza
campo
Límite
comprobar
desplazamiento
allá
segmento
cuyo
caso
produce
trap
Lógicamente
debería
campo
32
bits
descriptor
proporcionar
tamaño
segmento
20
bits
www.FreeLibros.medisponibles
utiliza
esquema
distinto
campo
Gbit
granularidad
cam-
po
Límitees
tamaño
segmento
exacto
MB
campo
Límite
proporciona
ta-
maño
segmento
páginas
bytes
tamaño
página
Pentium
fijo
KB
20
bits
suficientes
segmentos
32
bytes
Suponiendo
segmento
memoria
desplazamiento
rango
Pen-
tium
suma
campo
Base
32
bits
descriptor
desplazamiento
formar
cono-
ce
dirección
lineal
muestra
figura
3-41
campo
Base
divide
partes
esparce
descriptor
compatibilidad
286
campo
Base
24
bits
efecto
campo
Base
permite
segmento
empiece
lugar
arbitrario
espacio
direcciones
lineal
32
bits
244
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
Nivel
privilegio
Dirección
relativa
Base
15
Límite
15
Base
24
31
Base
16
23Límite
16
19GD0
DPL
Tipo
Li
bytes
Li
páginas
Segmento
16
bits
Segmento
32
bits
segmento
memoria
segmento
memoria
Tipo
protección
segmento
Sistema
Aplicación
32
Bits
Figura
3-40
Descriptor
segmento
código
Pentium
segmentos
datos
difieren
Descriptor
Dirección
base
Límite
campos
Dirección
lineal
32
bits
Selector
Desplazamiento
Figura
3-41
Conversión
par
selector
desplazamiento
dirección
lineal
deshabilita
paginación
bit
registro
control
global
dirección
lineal
interpreta
dirección
física
envía
memoria
lectura
escritura
ende
paginación
deshabilitada
esquema
segmentación
pura
di-
rección
base
segmento
proporciona
descriptor
evita
segmentos
www
FreeLibros.meSECCIÓN
3.7
SEGMENTACIÓN
245
traslapen
probablemente
problema
requeriría
tiempo
pa-
ra
verificar
estuvieran
disjuntos
paginación
habilitada
dirección
lineal
interpreta
direc-
ción
virtual
asigna
dirección
física
usando
tablas
páginas
forma
parecida
ejemplos
anteriores
única
complicación
dirección
virtual
32
bits
página
KB
segmento
contener
millón
páginas
utiliza
asignación
niveles
reducir
tamaño
tabla
páginas
segmentos
pequeños
programa
ejecución
directorio
páginas
consiste
1024
entradas
32
bits
dirección
apunta
registro
global
entrada
di-
rectorio
apunta
tabla
páginas
contiene
1024
entradas
32
bits
entradas
tabla
páginas
apuntan
marcos
página
esquema
muestra
figura
3-42
Bits
Dirección
lineal
10
10
12
Dir
Página
Desplazamiento
Directorio
páginas
entrada
directorio
apunta
tabla
páginas
entrada
tabla
páginas
apunta
palabra
Marco
página
Palabra
seleccionada
Dir
Tabla
páginas
Página
1024
entradas
Offset
Figura
3-42
Asociación
dirección
lineal
dirección
física
figura
3-42(a
dirección
lineal
dividida
campos
Dir
Página
Desplazamiento
campo
Dir
utiliza
indexar
directorio
páginas
localizar
apuntador
tabla
páginas
apropiada
utiliza
campo
Página
índice
tabla
páginas
buscar
dirección
física
marco
página
Desplazamien-
to
suma
dirección
marco
página
obtener
dirección
física
byte
palabra
re-
querida
entradas
tabla
páginas
32
bits
20
contienen
nú-
mero
marco
página
bits
restantes
contienen
bits
acceso
bits
sucios
establecidos
hardware
beneficio
sistema
operativo
bits
protección
bits
utilitarios
tabla
páginas
entradas
1024
marcos
página
KB
so-
tabla
páginas
maneja
megabytes
memoria
segmento
menor
directo-
www.FreeLibros.merio
páginas
entrada
apuntador
única
tabla
páginas
sobrecarga
segmentos
cortos
páginas
millón
páginas
ne-
cesitarían
tabla
páginas
nivel
evitar
referencias
repetidas
memoria
Pentium
MULTICS
pequeño
TLB
asigna
directamente
combinaciones
Dir-Página
reciente
dirección
física
marco
página
combinación
actual
presente
TLB
cabo
mecanismo
figura
3-42
actualiza
TLB
fraca-
sos
TLB
raros
rendimiento
vale
pena
observar
aplicación
necesita
segmentación
contenta
espacio
direcciones
paginado
32
bits
modelo
registros
segmento
establecer
selector
cuyo
descriptor
Base
/H110050
Límiteestablecido
máximo
desplazamiento
instrucción
dirección
li-
neal
espacio
direcciones
único
utilizado
efecto
paginación
normal
he-
cho
sistemas
operativos
actuales
Pentium
funcionan
OS/2
único
utilizó
arquitectura
Intel
MMU
crédito
diseñadores
Pentium
Dadas
metas
conflictivas
implementar
paginación
pura
segmentación
pura
segmentos
paginados
tiempo
debía
compatible
286
eficiencia
diseño
resultante
sorprendentemente
simple
limpio
cubierto
forma
arquitectura
completa
memoria
virtual
Pen-
tium
vale
pena
palabras
acerca
protección
tema
estre-
chamente
relacionado
memoria
virtual
esquema
memoria
virtual
modelado
forma
parecida
MULTICS
sistema
protección
Pen-
tium
admite
niveles
protección
nivel
privilegiado
privilegiado
muestran
figura
3-43
instante
programa
ejecución
en-
cuentra
nivel
indicado
campo
bits
PSW
segmento
sistema
nivel
programa
restrinja
utilizar
segmentos
nivel
funcionará
permiten
intentos
acceder
datos
nivel
alto
acceder
datos
nivel
inferior
ilegales
producen
traps
intentos
llamar
proce-
dimientos
nivel
distinto
menor
permiten
controlada
cuida-
dosamente
llamada
niveles
instrucción
CALL
contener
selector
dirección
selector
designa
descriptor
llamado
compuerta
llamada
proporciona
dirección
procedimiento
llamar
ende
sal-
tar
segmento
código
arbitrario
nivel
distinto
utilizar
pun-
tos
entrada
oficiales
conceptos
niveles
protección
compuertas
llamada
utilizaron
MULTICS
denominaron
anillos
protección
común
mecanismo
sugiere
figura
3-43
nivel
encontramos
kernel
sistema
operativo
encarga
administración
memoria
cues-
tiones
críticas
nivel
presente
manejador
llamadas
sistema
programas
usuario
llamar
procedimientos
cabo
llamadas
sistema
llamar
lista
procedimientos
específicos
protegidos
nivel
contiene
procedi-
mientos
biblioteca
posiblemente
compartida
programas
ejecución
progra-
246
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
3.8
INVESTIGACIÓN
ACERCA
ADMINISTRACIÓN
MEMORIA
247
usuario
llamar
procedimientos
leer
datos
modificar-
programas
usuario
ejecutan
nivel
menor
protección
traps
interrupciones
utilizan
mecanismo
similar
compuertas
llamadas
referencia
descriptores
direcciones
absolutas
descriptores
apuntan
procedimientos
específicos
ejecutar
campo
Tipo
figura
3-40
in-
dica
diferencias
segmentos
código
segmentos
datos
diversos
tipos
compuertas
3.8
INVESTIGACIÓN
ACERCA
ADMINISTRACIÓN
MEMORIA
administración
memoria
especial
algoritmos
paginación
área
fructífera
investigación
desaparecido
tiempo
sistemas
propósito
general
mayoría
sistemas
rea-
tienden
utilizar
variación
reloj
fácil
implementar
relativa-
mente
efectivo
excepción
reciente
rediseño
sistema
memoria
virtual
BSD
4.4
Cranor
Prulkar
1999
realizando
investigaciones
paginación
tipos
re-
cientes
sistemas
ejemplo
teléfonos
celulares
PDAs
convertido
pequeñas
PCs
muchps
paginan
RAM
disco
disco
teléfono
celular
memoria
flash
propiedades
distintas
disco
magnético
giratorio
traba-
jo
reciente
reporta
In
colaboradores
2007
Joo
colaboradores
2006
Park
colaborado-
res
2004a
Park
colaboradores
2004b
analizado
paginación
demanda
consciente
energía
dispositivos
móviles
Kernel
Nivel
Usos
comunes
niveles
Llamadas
sistemaBibliotecas
compartidas
Programas
usuario
Figura
3-43
protección
Pentium
www
FreeLibros.meTambién
realizando
investigaciones
acerca
modelado
rendimiento
pagi-
nación
Albers
colaboradores
2002
Burton
Kelly
2003
Cascaval
colaboradores
2005
Pa-
nagiotou
Souza
2006
Peserico
2003
interés
administración
memoria
sistemas
multimedia
Dasigenis
colaboradores
2001
Hand
1999
sistemas
tiem-
po
real
Pizlo
Vitek
2006
3.9
RESUMEN
capítulo
examinamos
administración
memoria
Vimos
sistemas
simples
realizan
intercambios
paginaciones
carga
programa
memoria
per-
manece
termina
sistemas
operativos
permiten
proceso
memoria
soportan
multiprogramación
paso
intercambio
utiliza
técnica
sistema
manejar
procesos
alojar
memoria
procesos
espacio
intercambian
disco
registro
espacio
libre
memoria
disco
mapa
bits
lista
huecos
computadoras
modernas
forma
memoria
virtual
forma
simple
espacio
direcciones
proceso
divide
bloques
tamaño
uniforme
lla-
mados
páginas
colocarse
marco
página
disponible
memoria
algoritmos
reemplazo
páginas
mejores
algoritmos
envejecimien-
to
WSClock
modelar
sistemas
paginación
abstraer
cadena
referencia
página
programa
utilizar
cadena
referencia
distintos
algoritmos
modelos
pue-
den
utilizar
predicciones
acerca
comportamiento
paginación
sistemas
paginación
funcionen
basta
elegir
algoritmo
atención
cuestiones
tales
determinar
conjunto
trabajo
política
asignación
memoria
tamaño
página
segmentación
ayuda
manejar
estructuras
datos
cambiar
tamaño
du-
rante
ejecución
simplifica
vinculación
compartición
facilita
provisión
distintos
tipos
protección
distintos
segmentos
segmentación
pagina-
ción
combinan
proporcionar
memoria
virtual
bidimensional
sistema
MULTICS
Intel
Pentium
soportan
segmentación
paginación
PROBLEMAS
figura
3-3
registros
base
límite
contienen
valor
16,384
accidente
iguales
accidente
iguales
ejemplo
sistema
intercambio
elimina
huecos
compactación
Suponiendo
distribución
aleatoria
huecos
segmentos
datos
tiempo
lectura
escritura
palabra
memoria
32
bits
10
nseg
tiempo
requiere
com-
pactar
128
MB
simplificar
suponga
palabra
hueco
palabra
alta
memoria
contiene
datos
válidos
248
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
249
problema
comparar
almacenamiento
necesario
memo-
ria
libre
utilizando
mapa
bits
lista
ligada
memoria
128
MB
asig-
na
unidades
bytes
lista
enlazada
suponga
memoria
consiste
secuencia
alternante
segmentos
huecos
64
KB
Suponga
nodo
lista
enlazada
necesita
dirección
memoria
32
bits
longitud
16
bits
campo
nodo
16
bits
bytes
almacenamiento
requieren
método
Considere
sistema
intercambio
memoria
consiste
siguientes
tamaños
hue-
co
orden
memoria
10
KB
KB
20
KB
18
KB
KB
KB
12
KB
15
KB
hue-
co
toma
siguientes
solicitudes
segmento
sucesivas
12
KB
10
KB
KB
algoritmo
ajuste
repita
pregunta
ajuste
ajuste
si-
guiente
ajuste
siguientes
direcciones
virtuales
decimales
calcule
número
página
virtual
desplazamiento
página
KB
página
KB
20000
32768
60000
procesador
Intel
8086
admite
memoria
virtual
compañías
vendían
an-
teriormente
sistemas
contenían
CPU
8086
modificaciones
realizaba
paginación
Trate
llegar
conclusión
lógica
acerca
Sugerencia
piense
acerca
ubicación
lógica
MMU
Considere
programa
int
X[N
int
paso
constante
predefinida
for
int
paso
X[i
X[i
programa
ejecuta
máquina
tamaño
página
KB
TLB
64
entradas
valores
harán
TLB
falle
ejecución
ciclo
interno
distinta
respuesta
inciso
ciclo
repitiera
Explique
cantidad
espacio
disco
disponible
almacenamiento
páginas
relacionada
número
máximo
procesos
número
bytes
espacio
direcciones
virtual
número
bytes
RAM
r.
Proporcione
expresión
requeri-
mientos
espacio
disco
casos
realista
cantidad
máquina
espacio
direcciones
32
bits
página
KB
tabla
páginas
completamente
hardware
palabra
32
bits
entrada
inicia
proceso
tabla
páginas
copia
hardware
memoria
palabra
100
nseg
proceso
ejecuta
100
mseg
incluyendo
tiempo
cargar
tabla
pá-
ginas
fracción
tiempo
CPU
dedica
cargar
tablas
páginas
10
Suponga
máquina
direcciones
virtuales
48
bits
direcciones
físicas
32
bits
páginas
KB
entradas
tabla
páginas
nivel
Explique
www.FreeLibros.meb
Suponga
sistema
TLB
Búfer
traducción
adelantada
32
entradas
suponga
programa
contiene
instrucciones
caben
página
lee
secuen-
cialmente
elementos
enteros
largos
arreglo
abarca
miles
páginas
efecti-
vo
TLB
caso
11
Suponga
máquina
direcciones
virtuales
38
bits
direcciones
físicas
32
bits
principal
ventaja
tabla
páginas
multinivel
tabla
páginas
nivel
tabla
páginas
niveles
páginas
16
KB
entradas
bytes
bits
asignar
campo
tabla
páginas
nivel
superior
campo
tabla
páginas
nivel
Explique
12
computadora
dirección
32
bits
utiliza
tabla
páginas
niveles
di-
recciones
virtuales
dividen
campo
tabla
páginas
nivel
superior
bits
cam-
po
tabla
páginas
nivel
11
bits
desplazamiento
páginas
espacio
direcciones
13
Suponga
dirección
virtual
32
bits
divide
campos
d.
utilizan
sistema
tablas
páginas
niveles
cuarto
campo
des-
plazamiento
Depende
número
páginas
tamaños
campos
importan
14
computadora
direcciones
virtuales
32
bits
páginas
KB
programa
datos
caben
juntos
página
baja
4095
pila
cabe
página
alta
entra-
das
necesitan
tabla
páginas
utiliza
paginación
tradicional
nivel
en-
tradas
tabla
páginas
necesitan
paginación
niveles
10
bits
15
computadora
cuyos
procesos
1024
páginas
espacios
direcciones
mantiene
tablas
páginas
memoria
sobrecarga
requerida
leer
palabra
tabla
páginas
nseg
reducir
sobrecarga
computadora
TLB
contiene
32
pares
pági-
na
virtual
marco
página
física
búsqueda
nseg
proporción
aciertos
necesita
reducir
sobrecarga
promedio
nseg
16
TLB
AX
contiene
bit
R.
17
implementarse
hardware
dispositivo
memoria
asociativa
necesario
im-
plementar
TLB
implicaciones
diseño
expandible
18
máquina
direcciones
virtuales
48
bits
direcciones
físicas
32
bits
páginas
KB
entradas
necesitan
tabla
páginas
19
computadora
página
KB
memoria
principal
256
KB
espacio
di-
recciones
virtuales
64
GB
utiliza
tabla
páginas
invertida
implementar
memoria
virtual
tabla
hash
asegurar
cadena
hash
longitud
promedio
menor
Suponga
tamaño
tabla
hash
potencia
20
estudiante
curso
diseño
compiladores
propone
profesor
proyecto
escribir
compilador
produzca
lista
referencias
páginas
puedan
utilizar
implemen-
tar
algoritmo
reemplazo
páginas
óptimo
pudiera
hacerse
mejorar
eficiencia
paginación
tiempo
ejecución
250
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
251
21
Suponga
flujo
referencia
páginas
virtuales
contiene
repeticiones
largas
secuencias
referencias
páginas
seguidas
ocasionalmente
referencia
página
aleatoria
ejem-
plo
secuencia
511
431
511
332
consiste
repeticiones
secuen-
cia
511
seguida
referencia
aleatoria
páginas
431
332
serían
efectivos
algoritmos
sustitución
estándar
LRU
FIFO
Reloj
manejar
carga
trabajo
asignación
página
menor
longitud
secuencia
programa
asignaran
500
marcos
página
describa
método
sustitución
página
rendimiento
algoritmos
LRU
FIFO
Reloj
22
utiliza
algoritmo
FIFO
reemplazo
páginas
marcos
página
pági-
nas
fallos
página
ocurrirán
cadena
referencia
0172327103
mar-
cos
vacíos
principio
repita
problema
algoritmo
LRU
23
Considere
secuencia
páginas
figura
3-15(b
Suponga
bits
páginas
11011011
respectivamente
página
eliminará
algoritmo
oportu-
nidad
24
pequeña
computadora
marcos
página
pulso
reloj
bits
0111
página
resto
siguientes
pulsos
reloj
valores
1011
1010
1101
0010
1010
1100
0001
utiliza
algoritmo
envejecimiento
contador
bits
proporcione
valores
contadores
pulso
25
Dé
ejemplo
simple
secuencia
referencias
páginas
página
selec-
cionada
sustitución
algoritmos
reemplazo
páginas
reloj
LRU
Suponga
proceso
asignan
marcos
cadena
referencia
contiene
nú-
meros
página
conjunto
26
algoritmo
WSClock
figura
3-21(c
manecilla
apunta
página
/H110050
/H11005400
eliminará
página
pasa
/H110051000
27
tiempo
requiere
cargar
programa
64
KB
disco
cuyo
tiempo
búsque-
promedio
10
mseg
cuyo
tiempo
rotación
10
mseg
cuyas
pistas
contienen
32
KB
tamaño
página
KB
tamaño
página
KB
páginas
esparcidas
aleatoria
disco
número
cilindros
probabilidad
páginas
encuentren
cilindro
insignificante
28
computadora
marcos
página
tiempo
carga
tiempo
acceso
bits
página
muestran
continuación
tiempos
pulsos
reloj
Pá
gina
Cargada
referencia
126
280
230
265
140
270
110
285
www.FreeLibros.mea
página
reemplazará
algoritmo
NRU
página
reemplazará
algoritmo
FIFO
página
reemplazará
algoritmo
LRU
página
reemplazará
algoritmo
oportunidad
29
Considere
arreglo
bidimensional
int
X[64][64
Suponga
sistema
marcos
página
marco
128
palabras
en-
tero
ocupa
palabra
programas
manipulan
arreglo
caben
exactamente
pá-
gina
ocupan
página
datos
intercambian
marcos
arreglo
almacena
orden
importancia
filas
X[0][1
des-
pués
X[0][0
memoria
fragmentos
código
muestran
continua-
ción
generarán
menor
número
fallos
página
Explique
calcule
número
fallos
página
Fragmento
for
int
/H110050
64
H11001
H11001
for
int
/H110050
64
H11001
H11001
X[i][j
/H110050
Fragmento
for
int
/H110050
64
H11001
H11001
for
int
/H110050
64
H11001
H11001
X[i][j
/H110050
30
primeras
máquinas
tiempo
compartido
PDP-1
memoria
palabras
18
bits
Contenía
proceso
memoria
planificador
proceso
decidía
ejecutar
proceso
proceso
memoria
escribía
tambor
paginación
pala-
bras
18
bits
circunferencia
tambor
podía
empezar
escribir
leer
palabra
palabra
Supone
tambor
se-
leccionado
31
computadora
proporciona
proceso
65,536
bytes
espacio
direcciones
dividido
páginas
4096
bytes
programa
específico
tamaño
texto
32,768
bytes
tama-
ño
datos
16,386
bytes
tamaño
pila
15,870
bytes
Cabrá
programa
espa-
cio
direcciones
tamaño
página
512
bytes
cabría
Recuerde
página
contener
partes
segmentos
distintos
32
página
conjuntos
trabajo
tiempo
Explique
33
observado
número
instrucciones
ejecutadas
fallos
página
directamente
proporcional
número
marcos
página
asignados
programa
memoria
disponible
duplica
intervalo
promedio
fallos
página
duplica
Suponga
ins-
trucción
normal
requiere
microsegundo
ocurre
fallo
página
requiere
2001
µseg
mseg
hacerse
cargo
fallo
programa
requiere
60
segundos
ejecutarse
tiempo
obtiene
15,000
fallos
página
tiempo
requeriría
ejecutarse
hubiera
disponible
doble
memoria
34
grupo
diseñadores
sistemas
operativos
Compañía
Computadoras
Frugal
ideando
maneras
reducir
cantidad
almacenamiento
respaldo
necesario
sis-
tema
operativo
jefe
sugerido
preocupar
guardar
texto
pro-
grama
área
intercambio
paginarla
directamente
archivo
binario
252
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
253
necesite
condiciones
funciona
idea
texto
programa
condiciones
funciona
datos
35
instrucción
lenguaje
máquina
cargar
palabra
32
bits
registro
contiene
dirección
32
bits
palabra
cargar
número
máximo
fallos
pági-
na
provocar
instrucción
36
utilizan
segmentación
paginación
MULTICS
buscar
descriptor
segmento
descriptor
página
Funciona
TLB
ma-
nera
niveles
búsqueda
37
Consideremos
programa
segmentos
muestran
continuación
consisten
instrucciones
segmento
datos
lectura
escritura
segmento
seg-
mento
protección
lectura
ejecución
segmento
protección
lectura
escritura
sistema
memoria
sistema
memoria
virtual
paginación
demanda
direc-
ciones
virtuales
número
página
bits
desplazamiento
10
bits
ta-
blas
páginas
protección
siguientes
números
tabla
decimal
siguientes
casos
proporcione
dirección
memoria
real
actual
resul-
ta
traducción
direcciones
dinámicas
identifique
tipo
fallo
ocurre
fallo
página
protección
Obtener
segmento
página
desplazamiento
Almacenar
segmento
página
desplazamiento
16
Obtener
segmento
página
desplazamiento
28
Saltar
ubicación
segmento
página
desplazamiento
32
38
pensar
situación
soporte
memoria
virtual
mala
idea
ganaría
soportar
memoria
virtual
Explique
39
Trace
histograma
calcule
media
mediana
tamaños
archivos
binarios
ejecu-
tables
computadora
acceso
sistema
Windows
analice
archi-
vos
.exe
.dll
sistema
UNIX
analice
archivos
ejecutables
/bin
/usr
bin
Segmento
1Segmento
Lectura
ejecución
Lectura
escritura
página
virtual
marco
página
marco
página
página
virtuall
02
disco
disco
14
21
29
353
disco
disco
disco
13
646
73
www.FreeLibros.me/local/bin
secuencias
comandos
utilice
herramienta
ile
buscar
ejecutables
Determine
tamaño
página
óptimo
computadora
considerando
código
datos
Considere
fragmentación
interna
tamaño
tabla
páginas
hacien-
do
suposición
razonable
acerca
tamaño
entrada
tabla
páginas
Suponga
programas
probabilidad
ejecutarse
ende
considerarse
peso
40
pequeños
programas
MS-DOS
compilar
archivos
.COM
archivos
cargan
dirección
0x100
segmento
memoria
utilice
códi-
go
datos
pila
instrucciones
transfieren
control
ejecución
JMP
CALL
acceden
datos
estáticos
direcciones
fijas
instrucciones
compilen
código
objeto
Escriba
programa
reubicar
archivo
programa
ejecutar-
empezando
dirección
arbitraria
programa
explorar
código
busca
códigos
objeto
instrucciones
hagan
referencia
direcciones
memoria
fijas
modi-
ficar
direcciones
apunten
ubicaciones
memoria
rango
reubicar
Encontra-
rá
códigos
objeto
libro
programación
lenguaje
ensamblador
perfectamente
información
adicional
general
tarea
imposible
palabras
datos
valores
similares
códigos
objeto
instrucciones
41
Escriba
programa
simule
sistema
paginación
utilizando
algoritmo
envejecimien-
to
número
marcos
página
parámetro
secuencia
referencias
páginas
leer-
archivo
archivo
entrada
dibuje
número
fallos
página
1000
referencias
memoria
función
número
marcos
página
disponibles
42
Escriba
programa
demostrar
efecto
fallos
TLB
tiempo
acceso
efectivo
memoria
midiendo
tiempo
acceso
requiere
recorrer
arreglo
extenso
Explique
conceptos
principales
programa
describa
espera
muestre
salida
arquitectura
memoria
virtual
práctica
Ejecute
programa
computadora
explique
ajustan
datos
ex-
pectativas
Repita
computadora
antigua
arquitectura
distinta
expli-
diferencia
importante
salida
43
Escriba
programa
demuestre
diferencia
política
reemplazo
páginas
local
global
caso
simple
procesos
Necesitará
rutina
ge-
nerar
cadena
referencias
páginas
basado
modelo
estadístico
modelo
es-
tados
enumerados
N-1
representan
posibles
referencias
páginas
probabilidad
asociada
represente
probabilidad
referencia
página
caso
contrario
referencia
página
páginas
probabilidad
Demuestre
rutina
generación
cadena
referencias
páginas
comporta
for-
ma
apropiada
pequeña
Calcule
proporción
fallos
página
pequeño
ejemplo
proceso
número
fijo
marcos
página
Explique
correcto
comportamiento
Repita
procesos
secuencias
referencias
páginas
independientes
doble
marcos
página
Repita
utilizando
política
global
local
compare
propor-
ción
fallos
página
proceso
método
política
local
254
ADMINISTRACIÓN
MEMORIA
CAPÍTULO
www
FreeLibros.me4
SISTEMAS
ARCHIVOS
255
aplicaciones
computadora
requieren
almacenar
recuperar
información
proceso
ejecución
almacenar
cantidad
limitada
información
pro-
pio
espacio
direcciones
capacidad
almacenamiento
restringida
ta-
maño
espacio
direcciones
virtuales
aplicaciones
tamaño
adecuado
tales
reservaciones
aerolíneas
bancarias
contabilidad
corporativa
pequeño
problema
relacionado
mantenimiento
información
espacio
direcciones
proceso
proceso
termina
información
pierde
aplicaciones
ejemplo
base
datos
información
retener
semanas
meses
indefinidamente
inaceptable
información
desvanezca
proceso
utiliza
termine
desaparecer
falla
computadora
acaba
proceso
tercer
problema
frecuentemente
necesario
procesos
accedan
partes
información
tiempo
directorio
telefónico
línea
almacenado
es-
pacio
direcciones
proceso
proceso
acceso
directorio
resolver
problema
información
independiente
proceso
consecuencia
requerimientos
esenciales
almacenamiento
informa-
ción
plazo
almacenar
cantidad
información
información
sobrevivir
terminación
proceso
utilice
Múltiples
procesos
capaces
acceder
información
concurrentemente
www
FreeLibros.meDurante
años
utilizado
discos
magnéticos
almacenamiento
plazo
cintas
discos
ópticos
rendimiento
menor
capítulo
estu-
diaremos
discos
momento
basta
pensar
disco
secuen-
cia
lineal
bloques
tamaño
fijo
admite
operaciones
Leer
bloque
k.
Escribir
bloque
k.
realidad
operaciones
podríamos
principio
resolver
problema
almacenamiento
plazo
operaciones
inconvenientes
especial
sistemas
extensos
uti-
lizados
aplicaciones
usuarios
ejemplo
servidor
cuan-
tas
preguntas
surgen
rápidamente
encontramos
información
evitamos
usuario
lea
datos
usuario
bloques
libres
vimos
sistema
operativo
abstrajo
concepto
procesador
pa-
ra
crear
abstracción
proceso
concepto
memoria
física
ofrecer
procesos
espacios
direcciones
virtuales
resolver
problema
abstracción
archivo
conjunto
abstracciones
procesos
hilos
espacios
direcciones
archivos
conceptos
importantes
relación
sistemas
operativos
realmente
compren-
conceptos
principio
preparado
convertirse
experto
siste-
operativos
archivos
unidades
lógicas
información
creada
procesos
general
dis-
co
contiene
miles
millones
archivos
independientes
concibe
archi-
vo
tipo
espacio
direcciones
alejado
utilizan
modelar
disco
modelar
RAM
procesos
leer
archivos
existentes
crear
necesario
información
almacena
archivos
persistente
afectada
creación
ter-
minación
procesos
archivo
desaparecer
propietario
remueve
ma-
nera
explícita
operaciones
leer
escribir
archivos
comunes
examinaremos
continuación
archivos
administrados
sistema
operativo
estructuran
de-
nominan
abren
utilizan
protegen
implementan
administran
tópicos
fundamentales
di-
seño
sistemas
operativos
sistema
operativo
archivos
conoce
sistema
archivos
tema
capítulo
punto
vista
usuario
aspecto
importante
sistema
archivos
apariencia
constituye
archivo
denominan
protegen
archivos
operaciones
permiten
etcétera
detalles
acerca
utilizan
listas
enlazadas
li-
gadas
mapas
bits
almacenamiento
libre
sectores
bloque
disco
lógico
interés
importancia
diseñadores
sis-
256
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.1
ARCHIVOS
257
tema
archivos
razón
estructurado
capítulo
secciones
primeras
relacionadas
interfaz
usuario
archivos
directorios
respectivamente
incluimos
análisis
detallado
acerca
implementa
administra
sistema
archivos
daremos
ejemplos
sistemas
archivos
reales
4.1
ARCHIVOS
siguientes
páginas
analizaremos
archivos
punto
vista
usuario
có-
mo
utilizan
propiedades
4.1.1
Nomenclatura
archivos
archivos
mecanismo
abstracción
Proporcionan
almacenar
informa-
ción
disco
leerla
forma
proteja
usuario
detalles
acerca
almacena
información
funcionan
discos
rea-
lidad
Probablemente
característica
importante
mecanismo
abstracción
objetos
administrados
denominados
empezaremos
exa-
men
sistemas
archivos
tema
nomenclatura
archivos
proce-
so
crea
archivo
proporciona
nombre
proceso
termina
archivo
continúa
existiendo
utilizado
procesos
nombre
reglas
exactas
denominar
archivos
varían
sistema
sistemas
operativos
actuales
permiten
cadenas
letras
nombres
archivos
le-
gales
ende
andrea
bruce
cathy
posibles
nombres
archivos
frecuencia
permiten
dígitos
caracteres
especiales
nombres
urgente
Fig.2-14
válidos
sistemas
archivos
admiten
nombres
255
caracteres
sistemas
archivos
diferencian
letras
mayúsculas
minúsculas
UNIX
cae
categoría
MS-DOS
sistema
UNIX
siguientes
nombres
archivos
distintos
maria
Maria
MARIA
MS-DOS
to-
nombres
refieren
archivo
adecuado
momento
paréntesis
sistemas
archivos
Win-
dows
95
Windows
98
utilizan
sistema
archivos
MS-DOS
conocido
FAT-16y
ende
heredan
propiedades
forma
construyen
nombres
Win-
dows
98
introdujo
extensiones
FAT-16
condujo
FAT-32
sistemas
similares
Windows
NT
Windows
2000
Windows
XP
.WV
admiten
sistemas
archivos
FAT
realidad
obsoletos
sistemas
operativos
basa-
NT
sistema
archivos
nativo
NTFS
propiedades
nom-
bres
archivos
Unicode
capítulo
hagamos
referencia
sistemas
archivos
MS-DOS
FAT
estaremos
hablando
FAT-16
FAT-32
utilizan
Windows
especifique
contrario
capítulo
analizaremos
sistemas
archivos
FAT
capítulo
11
examinaremos
sistema
archivos
NTFS
analizaremos
Windows
Vista
detalle
www
FreeLibros.meMuchos
sistemas
operativos
aceptan
nombres
archivos
partes
separadas
pun-
to
prog.c
punto
conoce
extensión
archivo
general
indica
acerca
naturaleza
ejemplo
MS-DOS
nombres
archi-
vos
caracteres
extensión
opcional
caracteres
UNIX
tamaño
extensión
elección
usuario
archivo
exten-
siones
paginainicio.html.zip
.html
indica
página
Web
HTML
.zip
indica
archivo
comprimido
programa
zip
extensiones
archivos
comunes
significados
muestran
figura
4-1
258
SISTEMAS
ARCHIVOS
CAPÍTULO
Extensión
Significado
archivo.bak
Archivo
respaldo
archivo.c
Programa
fuente
archivo.gif
Imagen
Formato
Intercambio
Gráficos
CompuServe
archivo.hlp
Archivo
ayuda
archivo.html
Documento
Lenguaje
Marcación
Hipertexto
World
Wide
Web
archivo.jpg
Imagen
fija
codificada
estándar
JPEG
archivo.mp3
Música
codificada
formato
audio
MPEG
capa
archivo.mpg
Película
codificada
estándar
MPEG
archivo.o
Archivo
objeto
producido
compilador
enlazado
archivo.pdf
Archivo
Formato
Documento
Portable
archivo.ps
Archivo
PostScript
archivo.tex
Entrada
programa
formateador
TEX
archivo.txt
Archivo
texto
general
archivo.zip
Archivo
comprimido
Figura
4-1
extensiones
archivos
comunes
sistemas
UNIX
extensiones
archivo
convenciones
impuestas
sistemas
operativos
archivo
llamado
archivo.txt
tipo
ar-
chivo
texto
nombre
recordatorio
propietario
trans-
portar
información
computadora
compilador
insistir
archivos
compilar
terminen
.c
rehusarse
compilarlos
termi-
nación
convenciones
especialmente
útiles
programa
mane-
jar
tipos
archivos
ejemplo
compilador
recibir
lista
ar-
chivos
compilarlos
enlazarlos
archivos
archivos
lenguaje
ensamblador
extensión
vuelve
esencial
compilador
sepa
ar-
chivos
archivos
lenguaje
ensamblador
archivos
tipo
contrario
Windows
consciente
extensiones
asigna
significado
usua-
rios
procesos
registrar
extensiones
sistema
operativo
especificar
programa
posee
extensión
usuario
doble
clic
nombre
archi-
vo
programa
asignado
extensión
archivo
inicia
archivo
parámetro
www
FreeLibros.meSECCIÓN
4.1
ARCHIVOS
259
ejemplo
doble
clic
archivo.doc
inicia
Microsoft
Word
archivo.doc
ar-
chivo
inicial
editar
4.1.2
Estructura
archivos
archivos
estructurar
formas
posibilidades
comunes
descri-
ben
figura
4-2
archivo
figura
4-2(a
secuencia
bytes
estructura
sis-
tema
operativo
importa
archivo
ve
bytes
significado
impuesto
programas
nivel
usuario
UNIX
Windows
uti-
lizan
metodología
Registro
Hormiga
Zorro
Cerdo
Gato
Vaca
Perro
Cabra
León
Búho
Pony
Rata
Gusano
Gallina
Ibis
Cordero
Byte
Figura
4-2
tipos
archivos
Secuencia
bytes
Secuencia
registros
Árbol
sistema
operativo
considere
archivos
secuencias
bytes
provee
máxima
flexibilidad
programas
usuario
colocar
cosa
quieran
archivos
denominarlos
conveniente
sistema
operativo
ayuda
estorba
usuarios
desean
cosas
inusuales
importante
versiones
UNIX
MS-DOS
Windows
utilizan
modelo
archivos
configuración
estructura
muestra
figura
4-2(b
modelo
ar-
chivo
secuencia
registros
longitud
fija
estructura
interna
con-
cepto
central
idea
archivo
secuencia
registros
idea
operación
lectura
devuelva
registro
operación
escritura
sobrescriba
agregue
re-
gistro
nota
histórica
décadas
reinaba
tarjeta
perforada
80
colum-
nas
sistemas
operativos
mainframes
basaban
sistemas
archivos
archivos
consistentes
registros
80
caracteres
imágenes
tarjeta
sistemas
tam-
bién
admitían
archivos
registros
132
caracteres
destinados
impresora
www.FreeLibros.melínea
impresoras
cadena
132
columnas
programas
leían
entrada
unidades
80
caracteres
escribían
unidades
132
caracteres
úl-
timos
52
podían
espacios
sistema
propósito
general
actualidad
uti-
liza
modelo
sistema
archivos
primario
tarjetas
perforadas
80
columnas
papel
impresora
línea
132
caracteres
modelo
común
computadoras
mainframe
tercer
tipo
estructura
archivo
muestra
figura
4-2(c
organización
archivo
consiste
árbol
registros
necesariamente
longitud
contiene
campo
llave
posición
fija
registro
árbol
or-
dena
base
campo
llave
permitir
búsqueda
rápida
llave
específica
operación
básica
obtener
registro
obtener
registro
llave
específica
archivo
zoológico
figura
4-2(c
podríamos
pedir
sistema
ejemplo
obtenga
registro
cuya
llave
pony
preocu-
parnos
acerca
posición
exacta
archivo
agregar
registros
archivo
sistema
operativo
usuario
decidiendo
colocarlos
Evidentemente
es-
tipo
archivos
distinto
flujos
bytes
estructura
UNIX
Windows
utiliza
amplia
computadoras
mainframe
emplean
procesamiento
datos
comerciales
4.1.3
Tipos
archivos
sistemas
operativos
soportan
tipos
archivos
ejemplo
UNIX
Windows
tie-
nen
archivos
directorios
regulares
UNIX
archivos
especiales
caracteres
blo-
ques
archivos
regulares
contienen
información
usuario
archivos
figura
4-2
archivos
regulares
directorios
sistemas
archivos
mantener
estructura
sistema
archivos
Estudiaremos
directorios
archi-
vos
especiales
caracteres
relacionan
entrada
salida
utilizan
modelar
dispo-
sitivos
serie
tales
terminales
impresoras
redes
archivos
especiales
bloques
utilizan
modelar
discos
capítulo
estaremos
interesados
principalmente
archivos
regulares
general
archivos
regulares
archivos
ASCII
binarios
archivos
ASCII
con-
sisten
líneas
texto
sistemas
línea
termina
carácter
retorno
carro
utiliza
carácter
avance
línea
sistemas
ejemplo
MS-DOS
utilizan
líneas
necesitan
longitud
ventaja
archivos
ASCII
mostrar
imprimir
editar
editor
texto
programas
utilizan
archivos
ASCII
entrada
salida
fácil
conectar
salida
programa
entrada
canalizaciones
shell
plomería
procesos
fácil
interpretación
in-
formación
convención
estándar
ASCII
utiliza
expresarla
archivos
binarios
significa
archivos
ASCII
listarlos
impresora
aparece
listado
incomprensible
caracteres
general
estructura
interna
conocida
programas
utilizan
260
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.1
ARCHIVOS
261
ejemplo
figura
4-3(a
vemos
archivo
binario
ejecutable
simple
tomado
primeras
versiones
UNIX
técnicamente
archivo
secuencia
bytes
sistema
operativo
ejecutará
archivo
formato
apropiado
archivo
cin-
co
secciones
encabezado
texto
datos
bits
reubicación
tabla
símbolos
encabezado
em-
pieza
número
mágico
identifica
archivo
archivo
ejecutable
evitar
ejecución
accidental
archivo
formato
vienen
tama-
ños
diversas
partes
archivo
dirección
empieza
ejecución
bits
bandera
encabezado
texto
datos
programa
cargan
memoria
reubican
usando
bits
reubicación
tabla
símbolos
utiliza
depurar
Encabezado
Encabezado
Encabezado
Número
mágico
Tamaño
texto
Tamaño
datos
Tamaño
BSS
Tamaño
tabla
símbolos
Punto
entrada
Banderas
Texto
Datos
Bits
reubicación
Tabla
símbolos
Módulo
objeto
Módulo
objeto
Módulo
objeto
Nombre
módulo
Datos
Propietario
Protección
Tamaño
Encabezado
Figura
4-3
archivo
ejecutable
archivo
ejemplo
archivo
binario
archivo
UNIX
Consiste
colección
procedimientos
módulos
biblioteca
compilados
enlazados
antepone
encabezado
indica
nombre
fecha
creación
propietario
código
www.FreeLibros.meprotección
tamaño
caso
archivo
ejecutable
encabezados
módu-
llenos
números
binarios
copiarlos
impresora
produciría
basura
salida
sistema
operativo
reconocer
tipo
archivo
archivo
ejecutable
reconocen
antiguo
sistema
TOPS-20
DECsystem
20
hacía
examinaba
hora
creación
archivo
ejecutar
localiza-
ba
archivo
código
fuente
veía
modificado
creó
binario
recompilaba
automáticamente
código
fuente
términos
UNIX
pro-
grama
make
integrado
shell
extensiones
archivo
obligatorias
sistema
operativo
podía
programa
binario
derivaba
fuente
archivos
fuertemente
tipificados
ocasiona
problemas
usuario
diseñadores
sistema
esperaban
ejemplo
considere
sistema
archivos
salida
programa
extensión
.dat
archivos
datos
usuario
es-
cribe
programa
formateador
lea
archivo
.c
programa
transforma
ejemplo
convirtiéndolo
esquema
sangría
estándar
escribe
archivo
transformado
salida
archivo
salida
tipo
.dat
usuario
ofrecer
compilador
pa-
ra
compile
sistema
rehusará
extensión
incorrecta
intentos
copiar
archivo.data
archivo.c
rechazados
sistema
inválidos
proteger
usua-
rio
errores
tipo
amabilidad
usuario
ayudar
novatos
vuelve
lo-
cos
usuarios
experimentados
dedicar
esfuerzo
considerable
sortear
idea
sistema
operativo
razonable
4.1.4
Acceso
archivos
sistemas
operativos
proporcionaban
tipo
acceso
acceso
secuencial
es-
tos
sistemas
proceso
podía
leer
bytes
registros
archivo
orden
empezando
principio
podía
saltar
leerlos
orden
archivos
secuenciales
podían
rebobinarse
leerlos
necesario
archi-
vos
secuenciales
convenientes
almacenamiento
cinta
magnética
disco
empezó
discos
almacenar
archivos
leer
bytes
re-
gistros
archivo
orden
pudiendo
acceder
registros
llave
posición
archivos
cuyos
bytes
registros
leer
orden
llaman
archivos
ac-
ceso
aleatorio
requeridos
aplicaciones
archivos
acceso
aleatorio
esenciales
aplicaciones
sistemas
bases
datos
cliente
aerolínea
llama
desea
reservar
asiento
vuelo
es-
pecífico
programa
reservación
acceso
registro
vuelo
leer
miles
registros
vuelos
utilizar
métodos
especificar
empezar
leer
operación
readda
posición
archivo
empezar
leer
provee
operación
especial
seek
establecer
posición
actual
operación
seek
archivo
leer
secuencial
posición
actual
método
utiliza
UNIX
Windows
262
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.1
ARCHIVOS
263
4.1.5
Atributos
archivos
archivo
nombre
datos
sistemas
operativos
asocian
in-
formación
archivo
ejemplo
fecha
hora
modificación
archivo
tamaño
elementos
adicionales
llamaremos
atributos
archivo
personas
llaman
metadatos
lista
atributos
varía
considerablemente
sistema
tabla
figura
4-4
muestra
posibilidades
sistema
existente
presente
sistema
Atributo
Significado
Protección
acceso
archivo
forma
Contraseña
Contraseña
necesaria
acceder
archivo
Creador
ID
persona
creó
archivo
Propietario
propietario
actual
Bandera
lectura
lectura
escritura
lectura
Bandera
oculto
normal
aparezca
listados
Bandera
sistema
archivos
normales
archivo
sistema
Bandera
archivo
respaldado
necesita
respaldarse
Bandera
ASCII
binario
archivo
ASCII
archivo
binario
Bandera
acceso
aleatorio
acceso
secuencial
acceso
aleatorio
Bandera
temporal
normal
eliminar
archivo
salir
proceso
Banderas
bloqueo
desbloqueado
distinto
cero
bloqueado
Longitud
registro
Número
bytes
registro
Posición
llave
Desplazamiento
llave
registro
Longitud
llave
Número
bytes
campo
llave
Hora
creación
Fecha
hora
creó
archivo
Hora
acceso
Fecha
hora
accedió
archivo
Hora
modificación
Fecha
hora
modificó
archivo
Tamaño
actual
Número
bytes
archivo
Tamaño
máximo
Número
bytes
crecer
archivo
Figura
4-4
posibles
atributos
archivos
atributos
relacionan
protección
archivo
indican
pue-
acceder
tipos
esquemas
posibles
estudia-
remos
sistemas
usuario
presentar
contraseña
acceder
archivo
cuyo
caso
contraseña
atributos
banderas
bits
campos
cortos
controlan
habilitan
propiedad
específica
ejemplo
archivos
ocultos
aparecen
listados
archivos
bandera
archivo
bit
registro
archivo
respaldado
recientemente
programa
www.FreeLibros.mede
respaldo
desactiva
sistema
operativo
activa
modifica
archivo
forma
programa
respaldo
indicar
archivos
necesitan
respaldarse
bandera
temporal
permite
marcar
archivo
eliminación
automática
proceso
creó
termina
campos
longitud
registro
posición
llave
longitud
llave
presentes
archivos
cuyos
registros
búsquedas
llave
pro-
porcionan
información
requerida
buscar
llaves
diversos
tiempos
llevan
creó
archivo
acceso
modifica-
ción
recientes
útiles
variedad
propósitos
ejemplo
archivo
código
fuente
modificado
creación
archivo
código
objeto
corres-
pondiente
necesita
volver
compilarse
campos
proporcionan
información
necesaria
tamaño
actual
indica
archivo
presente
sistemas
operati-
vos
computadoras
mainframe
antiguas
requieren
especifique
tamaño
máximo
ho-
ra
crear
archivo
permitir
sistema
operativo
reserve
cantidad
máxima
almacenamiento
antemano
sistemas
operativos
estaciones
trabajo
computadoras
personales
inteligentes
arreglárselas
característica
4.1.6
Operaciones
archivos
archivos
almacenar
información
permitir
recupere
posteriormente
Dis-
tintos
sistemas
proveen
operaciones
permitir
almacenamiento
recuperación
continuación
muestra
análisis
llamadas
sistema
comunes
relacionadas
archivos
Create
archivo
crea
datos
propósito
llamada
anunciar
llegada
archivo
establecer
atributos
Delete
archivo
necesita
eliminar
liberar
espacio
disco
llamada
sistema
propósito
Open
archivo
proceso
abrirlo
propósito
llamada
open
permitir
sistema
lleve
atributos
lista
direcciones
disco
memoria
principal
acceso
rápido
datos
llamadas
posteriores
Close
terminan
accesos
atributos
direcciones
disco
necesarias
archivo
cerrar
liberar
espacio
tabla
interna
Mu-
chos
sistemas
fomentan
imponer
número
máximo
archivos
abiertos
pro-
ceso
disco
escribe
bloques
cerrar
archivo
obliga
escribir
bloque
archivo
bloque
esté
lleno
Read
datos
leen
archivo
general
bytes
provienen
posición
ac-
tual
llamador
especificar
datos
necesitan
proporcionar
búfer
colocarlos
264
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.1
ARCHIVOS
265
Write
datos
escriben
archivo
general
posición
actual
posición
actual
archivo
aumenta
tamaño
posición
actual
archivo
datos
existentes
sobrescriben
pierden
Append
llamada
forma
restringida
write
agregar
datos
archivo
sistemas
proveen
conjunto
mínimo
llamadas
sistema
general
append
sistemas
proveen
formas
mis-
ma
acción
append
Seek
archivos
acceso
aleatorio
necesita
método
especificar
dón-
tomar
datos
aproximación
común
llamada
sistema
nom-
bre
seek
reposiciona
apuntador
archivo
posición
específica
archivo
completa
llamada
leer
escribir
datos
po-
sición
Get
attributes
procesos
necesitan
leer
atributos
archivo
trabajo
ejemplo
programa
make
UNIX
utiliza
frecuencia
pa-
ra
administrar
proyectos
desarrollo
software
consisten
archivos
fuen-
llama
make
programa
examina
tiempos
modificación
archivos
fuente
objeto
calcula
mínimo
número
compilaciones
re-
queridas
actualizado
trabajo
analizar
atributos
tiempos
modificación
10
Set
attributes
atributos
establecerlos
usuario
mo-
dificar
creado
archivo
llamada
sistema
in-
formación
protección
ejemplo
obvio
mayoría
banderas
caen
categoría
11
Rename
frecuencia
ocurre
usuario
necesita
cambiar
nombre
archivo
existente
llamada
sistema
estrictamente
necesaria
archivo
general
copiar
archivo
nombre
eliminando
archivo
4.1.7
programa
ejemplo
utiliza
llamadas
sistema
archivos
sección
examinaremos
programa
simple
UNIX
copia
archivo
archivo
fuente
archivo
destino
listado
muestra
figura
4-5
programa
mínima
funcionalidad
reporte
errores
idea
razonable
acerca
fun-
cionan
llamadas
sistema
relacionadas
archivos
ejemplo
programa
copyfile
llamar
línea
comandos
copyfile
abc
xyz
copiar
archivo
abc
xyz
xyz
sobrescribirá
caso
contrario
creará
www
FreeLibros.me266
SISTEMAS
ARCHIVOS
CAPÍTULO
programa
llamarse
exactamente
argumentos
nombres
archivo
válidos
archivo
fuente
salida
instrucciones
include
iniciales
incluya
cantidad
defini-
ciones
prototipos
funciones
programa
necesario
programa
confor-
estándares
internacionales
relevantes
ocuparemos
Programa
copiar
archivos
verificación
reporte
errores
mínimos
include
sys
types.h
incluye
archivos
encabezado
necesarios
include
fcntl.h
include
stdlib.h
include
unistd.h
int
main(int
argc
char
argv
prototipo
ANSI
define
TAM_BUF
4096
tamaño
búfer
4096
bytes
define
MODO_SALIDA
0700
bits
protección
archivo
salida
int
main(int
argc
char
argv
int
ent_da
sal_da
leer_cuenta
escribir_cuenta
char
bufer[TAM_BUF
if
argc
exit(1
error
sintaxis
argc
Abre
archivo
entrada
crea
archivo
salida
ent_da
open(argv[1
O_RDONL
abre
archivo
fuente
if
ent_da
exit(2
abrir
termina
sal_da
creat(argv[2
MODO_SALIDA
crea
archivo
destino
if
sal_da
exit(3
crear
termina
Ciclo
copia
while
TRUE
leer_cuenta
read(ent_da
bufer
TAM_BUF
lee
bloque
datos
if
lee_cuenta
break
llega
archivo
error
sale
ciclo
escribe_cuenta
write(sal_da
bufer
lee_cuenta
escribe
datos
if
escribe_cuenta
exit(4
escribe_cuenta
error
Cierra
archivos
close(ent_da
close(sal_da
if
lee_cuenta==0
error
lectura
exit(0
else
exit(5
error
lectura
Figura
4-5
programa
simple
copiar
archivo
www
FreeLibros.meSECCIÓN
4.1
ARCHIVOS
267
línea
prototipo
función
main
requerido
ANSI
im-
portante
fines
instrucción
define
definición
macro
define
cadena
caracteres
TAM_BUF
macro
expande
número
4096
programa
leerá
escribirá
trozos
4096
bytes
práctica
programación
nombres
constan-
tes
utilizar
nombres
constantes
convención
facilita
programas
fáciles
leer
mantenimiento
instrucción
define
determina
acceder
archivo
salida
programa
principal
llama
main
argumentos
argc
argv
sistema
operati-
vo
suministra
argumentos
llamada
programa
indica
cuán-
tas
cadenas
presentes
línea
comandos
invocó
programa
incluyendo
nombre
arreglo
apuntadores
argumentos
llamada
ejemplo
elementos
arreglo
contienen
apuntadores
siguientes
valores
argv[0
copyfile
argv[1
abc
argv[2
xyz
arreglo
programa
acceso
argumentos
declaran
variables
primeras
ent_da
sal_da
contienen
descriptores
archivos
pequeños
enteros
devuelven
abre
archivo
siguientes
leer-
escribir_cuenta
cuentas
bytes
devuelven
llamadas
sistema
ready
write
respectivamente
variable
bufer
búfer
utiliza
guardar
datos
leídos
suministrar
datos
escribir
instrucción
verifica
argc
termina
código
código
distinto
indica
ocurrió
error
código
úni-
co
reportar
errores
programa
versión
producción
general
imprime
mensajes
error
tratamos
abrir
archivo
fuente
crear
archivo
destino
archivo
fuente
abre
éxito
sistema
asigna
pequeño
entero
ent_da
identificar
archivo
lla-
madas
siguientes
incluir
entero
sistema
sepa
archivo
desea
similar
archivo
destino
crea
satisfactoriamente
sal_da
recibe
valor
iden-
tificarlo
argumento
creat
establece
protección
falla
apertura
creación
archivos
descriptor
archivo
correspondiente
establece
/H110021
progra-
ma
termina
código
error
viene
ciclo
copia
Empieza
tratando
leer
KB
datos
bufer
llamada
procedimiento
biblioteca
read
realidad
invoca
llamada
sistema
read
parámetro
identifica
archivo
proporciona
búfer
indica
cuán-
tos
bytes
leer
valor
asignado
leer_cuenta
indica
número
bytes
leídos
ge-
neral
número
4096
archivo
quedan
bytes
alcanzado
archivo
leer_cuenta
cero
negativo
proceso
copia
pue-
continuar
ejecutándose
instrucción
break
terminar
ciclo
ten-
dría
www
FreeLibros.meLa
llamada
write
envía
búfer
archivo
destino
parámetro
identifica
archi-
vo
bufer
indica
bytes
escribir
forma
análoga
read
Observe
bytes
número
bytes
leídos
TAM_BUF
punto
im-
portante
lectura
devolverá
4096
archivo
múltiplo
KB
procesado
archivo
llamada
allá
archivo
re-
gresará
leer_cuenta
hará
salga
ciclo
punto
cierran
archivos
programa
termina
indica
terminación
normal
llamadas
sistema
Windows
UNIX
estructura
ge-
neral
programa
Windows
línea
comandos
copiar
archivo
moderadamen-
similar
figura
4-5
capítulo
11
examinaremos
llamadas
Windows
Vista
4.2
DIRECTORIOS
registro
archivos
sistemas
archivos
general
directorios
carpetas
sistemas
archivos
sección
hablaremos
di-
rectorios
organización
propiedades
operaciones
realizarse
4.2.1
Sistemas
directorios
nivel
forma
simple
sistema
directorios
directorio
contenga
archivos
llama
directorio
raíz
único
nombre
impor-
ta
primeras
computadoras
personales
sistema
común
usuario
dato
interesante
supercomputadora
mundo
CDC
6600
directorio
archivos
utilizada
usuarios
decisión
duda
mantener
simple
diseño
soft-
ware
figura
4-6
muestra
ejemplo
sistema
directorio
directorio
con-
archivos
ventajas
esquema
simpleza
habilidad
localizar
ar-
chivos
rapidez
lugar
buscar
utiliza
dispositivos
incrustados
simples
teléfonos
cámaras
digitales
reproductores
mú-
sica
portátiles
4.2.2
Sistemas
directorios
jerárquicos
nivel
adecuado
aplicaciones
dedicadas
simples
utilizaba
primeras
computadoras
personales
usuarios
modernos
miles
archivos
imposible
encontrar
archivos
estuvieran
directorio
268
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.2
DIRECTORIOS
269
consecuencia
necesita
forma
agrupar
archivos
relacionados
ejemplo
profesor
colección
archivos
conjunto
formen
libro
escribien-
do
curso
colección
archivos
contienen
programas
enviados
es-
tudiantes
curso
tercer
grupo
archivos
contenga
código
sistema
escritura
compiladores
avanzado
construyendo
cuarto
grupo
archivos
contie-
nen
proposiciones
becas
archivos
correo
electrónico
minutas
reuniones
artículos
escribiendo
juegos
etcétera
necesita
jerarquía
árbol
directorios
esquema
pue-
tantos
directorios
necesite
agrupar
archivos
formas
naturales
usuarios
comparten
servidor
archivos
común
caso
redes
empresas
usuario
directorio
raíz
privado
jerarquía
es-
quema
muestra
figura
4-7
directorios
contenidos
di-
rectorio
raíz
pertenecen
usuario
distinto
creado
subdirectorios
proyectos
trabajando
Directorio
raíz
Figura
4-6
sistema
directorio
nivel
contiene
archivos
Directorio
usuario
Subdirectorios
usuario
Directorio
raíz
Archivo
usuario
Figura
4-7
sistema
directorios
jerárquico
capacidad
usuarios
crear
número
arbitrario
subdirectorios
provee
po-
derosa
herramienta
estructuración
usuarios
organicen
trabajo
razón
ca-
sistemas
archivos
modernos
organizan
4.2.3
Nombres
rutas
sistema
archivos
organizado
árbol
directorios
necesita
for-
ma
especificar
nombres
archivos
general
utilizan
métodos
distintos
método
archivo
recibe
nombre
ruta
absoluto
consiste
ruta
www
FreeLibros.me270
SISTEMAS
ARCHIVOS
CAPÍTULO
directorio
raíz
archivo
ejemplo
ruta
/usr
ast
mailbox
significa
directorio
raíz
contiene
subdirectorio
llamado
usr
contiene
subdirectorio
ast
contiene
archivo
mailbox
nombres
ruta
absolutos
empiezan
directorio
raíz
únicos
UNIX
componentes
ruta
separados
Windows
separador
MUL-
TICS
nombre
ruta
escribiría
sistemas
Windows
\usr\ast\mailbox
UNIX
/usr
ast
mailbox
MULTICS
usr
ast
mailbox
importar
carácter
utilice
carácter
nombre
ruta
separador
en-
tonces
ruta
absoluta
tipo
nombre
nombre
ruta
relativa
utiliza
conjunto
con-
cepto
directorio
trabajo
llamado
directorio
actual
usuario
designar
directorio
directorio
trabajo
actual
cuyo
caso
nombres
rutas
empiecen
directorio
raíz
toman
forma
relativa
directorio
trabajo
ejemplo
directorio
trabajo
actual
/usr
ast
archivo
cuya
ruta
absoluta
/usr
ast
mail-
box
referenciar
simplemente
mailbox
palabras
comando
UNIX
cp
/usr
ast
mailbox
/usr
ast
mailbox.bak
comando
cp
mailbox
mailbox.bak
exactamente
directorio
trabajo
/usr
ast
conveniente
forma
relativa
forma
absoluta
programas
necesitan
acceder
archivo
específico
importar
directo-
rio
trabajo
caso
utilizar
nombres
rutas
absolutas
ejemplo
co-
rrector
ortográfico
necesitar
leer
/usr
lib
dictionary
trabajo
utilizar
nombre
ruta
absoluta
completo
caso
directorio
trabajo
llamado
nombre
ruta
absoluta
funcionará
importar
di-
rectorio
trabajo
corrector
ortográfico
necesita
número
archivos
/usr
lib
esquema
alternativo
emita
llamada
sistema
cambiar
directorio
trabajo
/usr
lib
utilice
dictionary
parámetro
open
cambiar
forma
explícita
directorio
trabajo
certeza
árbol
directorios
pa-
ra
rutas
relativas
proceso
directorio
trabajo
cambia
termina
proceso
ve
afectado
quedan
rastros
cambio
sistema
archi-
vos
forma
perfectamente
seguro
proceso
cambiar
directorio
tra-
conveniente
procedimiento
biblioteca
cambia
directorio
trabajo
devuelve
valor
original
termina
resto
programa
www
FreeLibros.meSECCIÓN
4.2
DIRECTORIOS
271
funcione
directorio
trabajo
debería
inváli-
do
razón
procedimientos
biblioteca
raras
cambian
directorio
trabajo
devuelven
posición
original
regresar
mayoría
sistemas
operativos
proporcionan
sistema
directorios
jerárquico
entradas
especiales
directorio
general
pronuncian
pun-
to
puntopunto
Punto
refiere
directorio
actual
puntopunto
refiere
padre
directorio
raíz
refiere
utilizan
entradas
especia-
considere
árbol
archivos
UNIX
figura
4-8
proceso
/usr
ast
directorio
trabajo
utilizar
subir
árbol
ejemplo
copiar
archi-
vo
/usr
lib
dictionary
directorio
comando
cp
/lib
dictionary
ruta
instruye
sistema
directorio
usr
baje
direc-
torio
lib
encontrar
archivo
dictionary
Directorio
raíz
bin
etc
lib
usr
ast
jim
tmp
jim
bin
etc
lib
usr
tmp
ast
/usr
jim
lib
lib
dict
Figura
4-8
árbol
directorios
UNIX
argumento
punto
nombra
directorio
actual
comando
cp
obtiene
nombre
directorio
incluyendo
punto
argumento
copia
archivos
www.FreeLibros.medirectorio
forma
normal
copia
utilizar
nombre
ruta
absoluta
completo
archivo
origen
cp
/usr
lib
dictionary
punto
ahorra
usuario
molestia
escribir
dictionary
em-
bargo
funciona
escribir
cp
/usr
lib
dictionary
dictionary
cp
/usr
lib
dictionary
/usr
ast
dictionary
comandos
realizan
exactamente
4.2.4
Operaciones
directorios
llamadas
sistema
permitidas
administrar
directorios
exhiben
variación
siste-
ma
llamadas
sistema
archivos
impresión
có-
mo
funcionan
daremos
ejemplo
tomado
UNIX
Create
crea
directorio
vacío
punto
puntopunto
sistema
coloca
automática
casos
programa
mkdir
Delete
elimina
directorio
eliminar
directorio
vacío
directorio
contiene
punto
puntopunto
vacío
general
eliminar
Opendir
directorios
leer
ejemplo
listar
archivos
directorio
programa
listado
abre
directorio
leer
nombres
ar-
chivos
contiene
leer
directorio
abrir
forma
análoga
proceso
abrir
leer
archivo
Closedir
leído
directorio
cerrar
liberar
espacio
tabla
interna
Readdir
llamada
devuelve
entrada
directorio
abierto
po-
sible
leer
directorios
utilizando
llamada
sistema
readcomún
método
desventaja
forzar
programador
tratar
estructura
interna
direc-
torios
contraste
readdirsiempre
devuelve
entrada
formato
estándar
impor-
tar
posibles
estructuras
directorio
utilice
Rename
aspectos
directorios
archivos
cam-
biar
nombre
forma
archivos
Link
vinculación
ligado
técnica
permite
archivo
aparecer
directorio
llamada
sistema
especifica
archivo
existente
nombre
ru-
ta
creando
vínculo
archivo
existente
nombre
especificado
ruta
272
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
273
forma
archivo
aparecer
directorios
vínculo
es-
tipo
incrementa
contador
nodo-i
archivo
núme-
ro
entradas
directorio
contienen
archivo
llama
vínculo
duro
liga
dura
Unlink
elimina
entrada
directorio
archivo
desvincular
es-
tá
presente
directorio
caso
normal
quita
sistema
archivos
pre-
sente
directorios
elimina
nombre
ruta
especificado
permanecen
UNIX
llamada
sistema
eliminar
archivos
vimos
unlink
lista
contiene
llamadas
importantes
ejemplo
administrar
información
protección
asociada
directorio
variante
idea
vincular
archivos
vínculo
simbólico
liga
simbólica
nombres
apunten
estructura
datos
interna
representa
ar-
chivo
crear
nombre
apunte
pequeño
archivo
nombre
utiliza
archivo
ejemplo
abierto
sistema
archivos
ruta
busca
nom-
bre
empieza
proceso
búsqueda
utilizando
nombre
víncu-
simbólicos
ventaja
traspasar
límites
discos
nombrar
archivos
computadoras
remotas
implementación
eficiente
vínculos
duros
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
momento
cambiar
punto
vista
usuario
acerca
sistema
ar-
chivos
punto
vista
implementa
usuarios
preocupan
acerca
nom-
brar
archivos
operaciones
permiten
apariencia
árbol
directorios
cuestiones
similares
interfaz
implementadores
interesados
forma
almacenan
archivos
directorios
administra
espacio
disco
funcione
eficiencia
confiabilidad
siguientes
secciones
examinaremos
áreas
problemas
concesiones
4.3.1
Distribución
sistema
archivos
sistemas
archivos
almacenan
discos
mayoría
discos
dividir
particiones
sistemas
archivos
independientes
partición
sector
disco
conoce
MBR
Master
Boot
Record
Registro
maestro
arranque
utiliza
arrancar
computadora
MBR
contiene
tabla
particiones
proporciona
direcciones
inicio
partición
particiones
tabla
marca
acti-
arranca
computadora
BIOS
lee
ejecuta
MBR
pro-
grama
MBR
localizar
partición
activa
leer
bloque
conocido
bloque
arranque
ejecutarlo
programa
bloque
arranque
carga
sistema
operativo
contenido
www.FreeLibros.meen
partición
cuestión
uniformidad
partición
inicia
bloque
arranque
contenga
sistema
operativo
arrancar
contener
futuro
empezar
bloque
arranque
distribución
partición
disco
varía
sistema
archivos
sistema
archivos
contendrá
elementos
muestran
figura
4-9
superbloque
Contiene
pa-
rámetros
clave
acerca
sistema
archivos
lee
memoria
arranca
compu-
tadora
entra
contacto
sistema
archivos
información
típica
superbloque
incluye
número
mágico
identificar
tipo
sistema
archivos
núme-
ro
bloques
contiene
sistema
archivos
información
administrativa
clave
274
SISTEMAS
ARCHIVOS
CAPÍTULO
Disco
completo
Partición
discoTabla
particiones
Archivos
directoriosDirectorio
raíz
Nodos-ISuper
bloque
Administración
espacio
libre
Bloque
arranque
MBR
Figura
4-9
distribución
sistema
archivos
continuación
venir
información
acerca
bloques
libres
sistema
archivos
ejemplo
forma
mapa
bits
lista
apuntadores
seguida
nodos-i
arreglo
estructuras
datos
archivo
indica
acerca
archivo
venir
directorio
raíz
contiene
superior
árbol
sistema
archivos
resto
disco
contiene
directorios
archivos
4.3.2
Implementación
archivos
Probablemente
cuestión
importante
implementar
almacenamiento
archivos
man-
registro
acerca
bloques
disco
archivo
utilizan
métodos
distintos
sistemas
operativos
sección
examinaremos
Asignación
contigua
esquema
asignación
simple
almacenar
archivo
serie
contigua
bloques
disco
disco
bloques
KB
archivo
50
KB
asignarían
50
bloques
consecutivos
bloques
KB
asignarían
25
bloques
consecutivos
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
275
figura
4-10(a
ejemplo
asignación
almacenamiento
contigua
muestran
40
bloques
disco
empezando
bloque
izquierda
prin-
cipio
disco
vacío
escribió
archivo
bloques
longitud
dis-
co
empezando
principio
bloque
Posteriormente
escribió
archivo
bloques
llamado
empezando
justo
archivo
A.
Observe
archivo
empieza
inicio
bloque
archivo
fue-
ra
realmente
1/2
bloques
desperdiciaría
espacio
bloque
fi-
gura
muestra
archivos
empezando
bloque
archivo
utiliza
sombreado
facilitar
distinción
archivo
significado
real
términos
almacenamiento
Archivo
bloques
Archivo
bloques
Archivo
bloques
Archivo
bloques
Archivo
bloques
Archivo
12
bloques
Archivo
bloques
Archivo
Archivo
Archivo
bloques
libres
bloques
libres
Archivo
Archivo
Figura
4-10
Asignación
contigua
espacio
disco
archivos
disco
removido
archivos
F.
asignación
espacio
disco
contiguo
ventajas
significativas
lugar
simple
implementar
registro
ubicación
bloques
archivo
reduce
recordar
números
dirección
disco
bloque
número
bloques
archivo
número
bloque
encontrar
número
blo-
simple
suma
lugar
rendimiento
lectura
excelente
archivo
completo
leer
disco
operación
necesita
búsqueda
bloque
necesarias
búsquedas
retrasos
rotación
datos
lle-
gan
ancho
banda
completa
disco
ende
asignación
contigua
simple
im-
plementar
alto
rendimiento
desgracia
asignación
contigua
desventaja
ligeramente
significante
transcurso
tiempo
discos
fragmentan
ocurre
examine
figura
4-10(b
www
FreeLibros.meAquí
eliminado
archivos
F.
quita
archivo
bloques
liberan
natural-
mente
dejando
serie
bloques
libres
disco
disco
compacta
momento
quitar
hueco
implicaría
copiar
bloques
hueco
po-
drían
millones
resultado
disco
consiste
archivos
huecos
ilustra
figura
principio
fragmentación
problema
archivo
escri-
bir
disco
momento
disco
llenará
necesario
compactarlo
extremo
costoso
reutilizar
espacio
libre
huecos
reutilizar
espacio
mantener
lista
huecos
cree
archivo
necesario
tamaño
elegir
hueco
tamaño
correcto
colocarlo
Imagine
consecuencias
diseño
usuario
empieza
editor
texto
procesador
palabras
escribir
documento
pide
programa
bytes
ten-
drá
documento
pregunta
responder
programa
continuará
núme-
ro
finalmente
pequeño
programa
terminar
prematuramente
hueco
disco
lleno
lugar
colocar
resto
archivo
usuario
tra-
ta
evitar
problema
proporcionar
número
tamaño
de-
cir
100
MB
editor
encontrar
hueco
anuncie
archivo
crear
usuario
libertad
iniciar
programa
dicien-
do
50
MB
sucesivo
encuentre
hueco
adecuado
probable
esquema
haga
usuarios
estén
felices
situación
factible
asignación
contigua
uti-
liza
ampliamente
CD-ROMs
tamaños
archivos
conocen
antema-
cambiarán
subsiguiente
sistema
archivos
CD-ROM
capítulo
estudiaremos
sistema
archivos
CD-ROM
común
situación
DVDs
complicada
principio
película
90
mi-
nutos
decodificar
archivo
longitud
aproximada
4.5
GB
sistema
archivos
utilizado
conocido
UDF
Universal
Disk
Format
Formato
disco
uni-
versal
utiliza
número
30
bits
representar
longitud
archivo
limitando
tama-
ño
archivos
GB
consecuencia
películas
DVD
almacenan
generalmente
archivos
GB
contiguo
partes
físicas
único
archivo
lógico
película
conocen
fragmentos
mencionamos
capítulo
historia
repite
ciencias
compu-
tacionales
medida
surgiendo
generaciones
tecnología
realidad
asig-
nación
contigua
utilizó
sistemas
archivos
discos
magnéticos
años
simpleza
alto
rendimiento
amabilidad
usuario
contaba
Des-
pués
descartó
idea
molestia
especificar
tamaño
archivo
momento
creación
llegada
CD-ROMs
DVDs
medios
óp-
ticos
escribir
archivos
contiguos
repentinamente
idea
importante
estudiar
antiguos
sistemas
ideas
conceptualmente
claras
simples
aplicarse
sistemas
futuros
formas
sorprendentes
276
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
277
Asignación
lista
enlazada
ligada
método
almacenar
archivos
mantener
lista
enlazada
blo-
ques
disco
muestra
figura
4-11
palabra
bloque
utiliza
co-
mo
apuntador
resto
bloque
datos
Archivo
Bloque
físico
Bloque
físico
72
12
Bloque
archivo
Bloque
archivo
Bloque
archivo
Bloque
archivo
Bloque
archivo
Archivo
63
Bloque
archivo
Bloque
archivo
Bloque
archivo
Bloque
archivo
Figura
4-11
Almacenamiento
archivo
lista
enlazada
bloques
disco
diferencia
asignación
contigua
método
utilizar
bloque
disco
pierde
espacio
fragmentación
disco
fragmentación
interna
bloque
entrada
directorio
basta
almacenar
dirección
disco
bloque
resto
encontrar
lectura
secuencial
archivo
directa
acceso
aleatorio
ex-
tremo
lento
llegar
bloque
sistema
operativo
empezar
principio
leer
bloques
anteriores
clarto
tantas
lecturas
lentas
cantidad
almacenamiento
datos
bloque
potencia
apuntador
ocupa
bytes
fatal
tamaño
peculiar
eficiente
programas
leen
escriben
bloques
cuyo
tamaño
potencia
bytes
bloque
ocupados
apuntador
blo-
leer
tamaño
bloque
completo
requiere
adquirir
concatenar
información
bloques
disco
genera
gasto
adicional
procesamiento
copia
Asignación
lista
enlazada
utilizando
tabla
memoria
Ambas
desventajas
asignación
lista
enlazada
eliminar
tomamos
palabra
apuntador
bloque
disco
colocamos
tabla
memoria
figura
4-12
mues-
www.FreeLibros.metra
apariencia
tabla
ejemplo
figura
4-11
ambas
figuras
archivos
archivo
utiliza
bloques
disco
10
12
orden
archivo
uti-
liza
bloques
disco
11
14
orden
Utilizando
tabla
figura
4-12
empezar
bloque
seguir
cadena
empezan-
do
bloque
Ambas
cadenas
terminan
marcador
especial
ejemplo
/H110021
número
bloque
válido
Dicha
tabla
memoria
principal
conoce
FAT(File
Allocation
Table
Tabla
asignación
archivos
278
SISTEMAS
ARCHIVOS
CAPÍTULO
Bloque
físico
archivo
empieza
archivo
empieza
Bloque
utilizar
10
11
12
13
14
15
10
11
12
14
Figura
4-12
Asignación
lista
enlazada
utiliza
tabla
asignación
archi-
vos
memoria
principal
Utilizando
organización
bloque
completo
disponible
datos
ac-
ceso
aleatorio
sencillo
seguir
cadena
encontrar
des-
plazamiento
archivo
cadena
completamente
memoria
seguir
necesidad
referencias
disco
método
entrada
directorio
necesita
mantener
entero
número
bloque
inicial
localizar
bloques
importar
archivo
principal
desventaja
método
tabla
memoria
tiem-
po
funcione
disco
200
GB
tamaño
bloque
KB
tabla
necesita
200
millones
entradas
200
millones
bloques
disco
entra-
mínimo
bytes
búsqueda
rápida
bytes
tabla
ocupará
600
MB
800
MB
memoria
principal
tiempo
dependiendo
siste-
ma
optimizado
espacio
tiempo
práctico
idea
FAT
escala
discos
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
279
Nodos-i
método
registro
bloques
pertenecen
archivo
asociar
archivo
estructura
datos
conocida
nodo-i
nodo-índice
lista
atri-
butos
direcciones
disco
bloques
archivo
figura
4-13
muestra
ejem-
plo
simple
nodo-i
encontrar
bloques
archivo
ventaja
esquema
comparación
archivos
vinculados
utilizan
tabla
me-
moria
nodo-i
necesita
memoria
abierto
archivo
correspon-
diente
nodo-i
ocupa
bytes
máximo
archivos
abiertos
memoria
ocupada
arreglo
contiene
nodos-i
archivos
abiertos
kn
bytes
reservar
espacio
adelantado
Atributos
archivo
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
disco
Dirección
bloque
apuntadores
Bloque
disco
contiene
direcciones
disco
adicionales
Figura
4-13
nodo-i
ejemplo
general
arreglo
pequeño
espacio
ocupado
tabla
ar-
chivos
descrita
sección
razón
simple
tabla
contener
lista
enlazada
bloques
disco
proporcional
tamaño
disco
disco
bloques
tabla
necesita
entradas
medida
aumenta
tamaño
discos
tabla
aumenta
li-
nealmente
contraste
esquema
nodo-i
requiere
arreglo
memoria
cuyo
ta-
maño
proporcional
número
máximo
archivos
abiertos
importa
disco
10
GB
100
GB
1000
GB
problema
nodos-i
espacio
número
fijo
direccio-
nes
disco
ocurre
archivo
crece
allá
límite
solución
reser-
www.FreeLibros.mevar
dirección
disco
bloque
datos
dirección
bloque
contenga
direcciones
bloques
disco
muestra
figura
4-13
avanzado
bloques
contuvieran
direcciones
disco
bloques
disco
apuntando
bloques
disco
llenos
direcciones
volveremos
nodos-i
estudiar
UNIX
4.3.3
Implementación
directorios
leer
archivo
abrirse
abre
archivo
sistema
operativo
utiliza
nombre
ruta
suministrado
usuario
localizar
entrada
directorio
entrada
provee
información
necesaria
encontrar
bloques
disco
Dependiendo
sis-
tema
información
dirección
disco
archivo
asignación
contigua
número
bloque
esquemas
lista
enlazada
número
nodo-i
casos
función
principal
sistema
directorios
asociar
nombre
ASCII
archivo
información
necesaria
localizar
datos
cuestión
relacionada
almacenarse
atributos
sistema
ar-
chivos
mantiene
atributos
archivo
propietario
hora
creación
archivo
de-
biendo
almacenarse
posibilidad
obvia
almacenarlos
directamente
entrada
directorio
sistemas
opción
muestra
figura
4-14(a
diseño
simple
directorio
consiste
lista
entradas
tamaño
fijo
archivo
contienen
nombre
archivo
longitud
fija
estructura
atributos
archivo
direcciones
disco
máximo
indique
encuentran
blo-
ques
disco
280
SISTEMAS
ARCHIVOS
CAPÍTULO
juegos
correo
noticias
trabajo
atributos
atributos
atributos
atributos
Estructura
datos
contiene
atributos
juegos
correo
noticias
trabajo
Figura
4-14
directorio
simple
contiene
entradas
tamaño
fijo
di-
recciones
disco
atributos
entrada
directorio
directorio
entrada
referencia
nodo-i
sistemas
utilizan
nodos-i
posibilidad
almacenar
atributos
nodos-i
entradas
directorio
caso
entrada
directorio
corta
nombre
archivo
número
nodo-i
método
ilustra
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
281
figura
4-14(b
veremos
método
ventajas
método
colocarlos
entrada
directorio
esquemas
muestran
figura
4-14
co-
rresponden
Windows
UNIX
respectivamente
veremos
suposición
archivos
nombres
cortos
longitud
fija
MS-DOS
archivos
nombre
base
caracteres
extensión
opcional
caracteres
UNIX
Version
nombres
archivos
14
caracteres
in-
cluyendo
extensión
sistemas
operativos
modernos
aceptan
nombres
archivos
largos
longitud
variable
implementar
esquema
simple
establecer
límite
longitud
nombre
archivo
general
255
caracteres
utilizar
diseños
figura
4-14
255
ca-
racteres
reservados
nombre
archivo
esquema
simple
desperdicia
espacio
directorio
archivos
nombres
largos
cuestiones
eficien-
cia
deseable
estructura
distinta
alternativa
renunciar
idea
entradas
directorio
tamaño
método
entrada
directorio
contiene
porción
fija
general
empieza
longitud
entrada
seguida
datos
formato
fijo
co-
múnmente
incluyen
propietario
hora
creación
información
protección
atribu-
tos
encabezado
longitud
fija
seguido
nombre
archivo
importar
longitud
muestra
figura
4-15(a
formato
big-endian
ejemplo
SPARC
ejemplo
archivos
sexto-proyecto
personaje
ave
nombre
archivo
ter-
mina
carácter
especial
general
representa
figura
cua-
dro
cruz
permitir
entrada
directorio
empiece
límite
palabra
nombre
archivo
rellena
número
entero
palabras
muestran
cuadros
som-
breados
figura
desventaja
método
elimina
archivo
lugar
queda
hue-
co
tamaño
variable
directorio
archivo
introducir
pue-
quepa
problema
vimos
archivos
disco
contiguos
factible
compactar
directorio
completo
memoria
problema
entrada
directorio
abarcar
páginas
ocurrir
fallo
páginas
leer
nombre
archivo
manejar
nombres
longitud
variable
entradas
directorio
longitud
fija
mantener
nombres
archivos
juntos
heap
directorio
muestra
figura
4-15(b
método
ventaja
remueva
entrada
archivo
introducir
cabrá
heap
administrar
ocurrir
fallos
página
procesar
nombres
archi-
vos
pequeña
ganancia
necesidad
nombres
archivos
empiecen
límites
palabras
necesitan
caracteres
relleno
nombres
archivos
figura
4-15(b
figura
4-15(a
diseños
mostrados
realizan
búsquedas
lineales
directorios
principio
buscar
nombre
archivo
directorios
extremo
largos
búsqueda
lineal
lenta
acelerar
búsqueda
utilizar
tabla
hash
directorio
Llamemos
tamaño
tabla
introducir
nombre
archivo
codifica
hash
valor
/H110021
ejemplo
dividiéndolo
tomando
www.FreeLibros.meresiduo
alternativa
palabras
componen
nombre
archivo
sumar
cantidad
divide
similar
forma
inspecciona
entrada
tabla
correspondiente
código
hash
apuntador
coloca
entrada
archivo
entradas
archivos
siguen
tabla
hash
ranura
construye
lista
enlazada
encabeza
en-
trada
tabla
encadena
entradas
valor
hash
buscar
archivo
procedimiento
nombre
archivo
codifica
hash
seleccionar
entrada
tabla
hash
entradas
cadena
encabeza
ranura
verifican
nombre
archivo
presente
nombre
cadena
archivo
presente
directorio
tabla
hash
ventaja
búsqueda
rápida
desventaja
administración
compleja
realidad
candidato
serio
siste-
espera
directorios
rutinariamente
contengan
cientos
miles
archivos
distinta
acelerar
búsqueda
directorios
extensos
colocar
caché
resultados
búsquedas
iniciar
búsqueda
realiza
verificación
nombre
archivo
caché
localizar
inmediato
lue-
go
caché
funciona
número
relativamente
pequeño
archivos
abarcan
ma-
yoría
búsquedas
282
SISTEMAS
ARCHIVOS
CAPÍTULO
Longitud
entrada
archivo
Atributos
archivo
Apuntador
nombre
archivo
Atributos
archivo
Apuntador
nombre
archivo
Atributos
archivo
Apuntador
nombre
archivo
3Longitud
entrada
archivo
Atributos
archivo
Longitud
entrada
archivo
Atributos
archivo
ave
Entrada
archivo
Heap
Entrada
archivo
Atributos
archivo
Figura
4-15
maneras
manejar
nombres
archivos
largos
directorio
línea
heap
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
283
4.3.4
Archivos
compartidos
usuarios
trabajando
conjunto
proyecto
necesitan
compartir
archivos
resultado
frecuencia
conveniente
aparezca
archivo
compartido
forma
simultánea
distintos
directorios
pertenezcan
distintos
usuarios
figura
4-16
mues-
tra
sistema
archivos
figura
4-7
archivos
presentes
directorios
conexión
directorio
archivo
compartido
conoce
vínculo
liga
sistema
archivos
Gráfico
ací-
clico
dirigido
Directed
Acyclic
Graph
DAG
árbol
Directorio
raíz
CA
Archivo
compartido
Figura
4-16
Sistema
archivos
contiene
archivo
compartido
Compartir
archivos
conveniente
introduce
problemas
empezar
directorios
realidad
contienen
direcciones
disco
copia
direcciones
disco
directorio
ligue
archivo
agregan
poste-
riormente
archivo
bloques
listarán
directorio
usuario
datos
cambios
estarán
visibles
usuario
fracasa
propósito
compartición
problema
resolver
formas
solución
bloques
disco
listan
directorios
pequeña
estructura
datos
asociada
archivo
directorios
apuntarían
pequeña
estructura
datos
esquema
utiliza
UNIX
pequeña
estructura
datos
nodo-i
solución
vincula
archivos
sistema
cree
archivo
tipo
LINK
introduciendo
archivo
directorio
B.
archivo
con-
nombre
ruta
archivo
vinculado
lee
archivo
vincu-
sistema
operativo
ve
archivo
leyendo
datos
tipo
LINK
busca
nombre
archivo
lee
archivo
esquema
conoce
vínculo
simbólico
liga
simbólica
contrastarlo
tradicional
vínculo
duro
www
FreeLibros.meCada
métodos
desventajas
método
momento
vincula
archivo
compartido
nodo-i
registra
propietario
archivo
C.
crear
vínculo
cambia
propiedad
vea
figura
4-17
incrementa
vínculos
nodo-i
sistema
entradas
directorio
actualmente
apuntan
archivo
284
SISTEMAS
ARCHIVOS
CAPÍTULO
Directorio
Directorio
Directorio
BDirectorio
Propietario
Propietario
Propietario
Figura
4-17
Situación
previa
vinculación
crear
vínculo
propietario
original
elimina
archivo
posteriormente
eliminar
archivo
sistema
enfrenta
problema
eli-
mina
archivo
limpia
nodo-i
entrada
directorio
apunte
nodo-i
invá-
lido
nodo-i
reasigna
archivo
vínculo
apuntará
archivo
incorrecto
sistema
nodo-i
archivo
sencilla
encuentre
entradas
directorio
archivo
borrarlas
apuntadores
directorios
almacenar
nodo-i
pue-
número
ilimitado
directorios
único
eliminar
entrada
directorio
dejar
nodo-i
intacto
establecida
muestra
figura
4-17(c
situación
único
usuario
entrada
directorio
archivo
pertenece
C.
sistema
realiza
contabilidad
cuotas
seguirá
cobrando
archivo
de-
cida
eliminarlo
acaso
momento
archivo
eliminará
vínculos
simbólicos
produce
problema
pro-
pietario
apuntador
nodo-i
usuarios
creado
vínculos
archivo
nombres
ruta
apuntadoras
nodos-i
propietario
elimina
archivo
des-
truye
intentos
posteriores
utilizar
archivo
vía
vínculo
simbólico
fallarán
sistema
localizar
archivo
eliminar
vínculo
simbólico
archivo
ve
afec-
tado
problema
vínculos
simbólicos
gasto
adicional
procesamiento
requerido
leer
archivo
contiene
ruta
analizar
sintácticamente
seguir
componente
componente
llegar
nodo-i
actividad
requerir
canti-
dad
considerable
accesos
adicionales
disco
necesita
nodo-i
adicional
ca-
vínculo
simbólico
bloque
disco
adicional
almacenar
ruta
nombre
ruta
corto
sistema
almacenarlo
nodo-i
tipo
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
285
optimización
vínculos
simbólicos
ventaja
utilizar
vincular
ar-
chivos
máquinas
dondequiera
mundo
proporcionar
dirección
red
máquina
reside
archivo
ruta
máquina
problema
introducen
vínculos
simbólicos
tipo
permiten
vínculos
archivos
rutas
programas
empiezan
directorio
encontrando
archivos
directorio
subdirecto-
rios
localizarán
archivo
vinculado
ejemplo
programa
vacía
ar-
chivos
directorio
subdirectorios
cinta
copias
archivo
vinculado
cinta
lee
máquina
programa
vaciado
inteligente
archivo
vinculado
copiará
disco
vinculado
4.3.5
Sistemas
archivos
estructurados
registro
cambios
tecnología
ejerciendo
presión
sistemas
archivos
actuales
especial
CPUs
veloces
discos
baratos
rápidos
memorias
aumentando
tamaño
forma
exponencial
úni-
co
parámetro
teniendo
avances
tiempo
búsqueda
disco
combi-
nación
factores
indica
cuello
botella
funcionamiento
creciendo
sistemas
archivos
investigaciones
realizadas
Berkeley
trataron
aliviar
problema
diseñar
tipo
sistema
archivos
completamente
llamado
LFS
Log-struc-
tured
File
System
Sistema
archivos
estructurado
registro
sección
describiremos
brevemente
funciona
LFS
Consulte
tratamiento
completo
Rosenblum
Ouster-
hout
1991
idea
impulsó
diseño
LFS
medida
CPUs
vuelven
rápidas
memorias
RAM
cachés
disco
incrementan
rapi-
dez
consecuencia
satisfacer
fracción
considerable
peti-
ciones
lectura
directamente
caché
sistema
archivos
necesitar
accesos
disco
observación
deducir
futuro
mayoría
accesos
disco
escri-
turas
mecanismo
lectura
adelantada
utilizado
sistemas
archivos
pa-
ra
obtener
bloques
necesitarlos
gana
rendimiento
empeorar
cosas
mayoría
sistemas
archivos
escrituras
realizan
trozos
pequeños
pequeñas
escrituras
altamente
ineficientes
escritura
dis-
co
50
µseg
precedida
búsqueda
10
mseg
retraso
rotacional
mseg
parámetros
eficiencia
disco
disminuye
fracción
1%
provienen
pequeñas
escrituras
considere
creación
archivo
sistema
UNIX
escribir
archivo
escribir
nodo-i
directo-
rio
bloque
directorio
nodo-i
archivo
archivo
escrituras
retrasar
expone
sistema
archivos
problemas
consistencia
graves
ocu-
rre
falla
escrituras
razón
escrituras
nodos-i
generalmente
realizan
inmediato
razonamiento
diseñadores
LFS
decidieron
reimplementar
sistema
archivos
UNIX
alcance
ancho
banda
completo
disco
carga
trabajo
consistiera
pequeñas
escrituras
azar
idea
básica
estruc
turar
www.FreeLibros.metodo
disco
registro
periódica
necesidad
especial
escrituras
pendientes
colocaron
búfer
memoria
recolectan
segmento
escriben
disco
segmento
continuo
registro
segmento
contener
nodos-i
bloques
directorio
bloques
datos
mezclados
inicio
segmento
resumen
segmento
indica
encontrar
segmento
segmento
promedio
tamaño
apro-
ximado
MB
utilizar
ancho
banda
disco
diseño
nodos-i
estructura
UNIX
esparcidos
registro
posición
fija
disco
localiza
nodo-i
localización
bloques
realiza
usual
difícil
buscar
nodo-i
dirección
simplemente
pue-
calcular
número-i
UNIX
encontrar
nodos-i
man-
mapa
nodos-i
indexados
número-i
entrada
mapa
apunta
nodo-i
disco
mapa
mantiene
disco
coloca
caché
partes
utilizadas
estén
memoria
tiempo
resumir
principio
escrituras
colocan
búfer
memoria
periódicamente
escrituras
búfer
escriben
disco
segmento
registro
abrir
archivo
utiliza
mapa
localizar
no-
do-i
archivo
localizado
nodo-i
encontrar
direcciones
blo-
ques
bloques
estarán
segmentos
registro
discos
fueran
infinitamente
extensos
descripción
discos
reales
finitos
momento
registro
ocupará
disco
momento
escribir
segmentos
registro
fortuna
segmentos
existentes
bloques
necesarios
ejemplo
sobrescribe
archi-
vo
nodo-i
apuntará
bloques
anteriores
seguirán
ocupando
espacio
segmentos
escritos
anteriormente
lidiar
problema
LFS
hilo
limpiador
pasa
tiempo
explorando
registro
circularmente
compactarlo
Empieza
leyendo
resumen
segmento
registro
nodos-i
archivos
verifica
mapa
nodos-i
actual
nodos-i
actualizados
bloques
archivos
descarta
información
nodos-i
bloques
memoria
pa-
ra
escribirse
segmento
segmento
original
marca
libre
ma-
nera
registro
utilizarlo
datos
limpiador
desplaza
registro
removiendo
segmentos
antiguos
colocando
información
viva
memoria
volver
escribirla
segmento
consecuencia
disco
búfer
circular
hilo
escritor
agrega
segmentos
frente
hilo
limpiador
remueve
segmentos
viejos
contabilidad
trivial
bloque
archivo
escribe
vuel-
ta
segmento
localizar
nodo-i
archivo
registro
ac-
tualizarlo
colocarlo
memoria
escribirse
segmento
mapa
nodos-i
actualizarse
apuntar
copia
administra-
ción
resultados
rendimiento
muestran
complejidad
vale
pena
medicio-
nes
proporcionadas
artículos
citados
muestran
LFS
supera
UNIX
rendimiento
286
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
287
orden
magnitud
escrituras
pequeñas
rendimiento
bue-
UNIX
lecturas
escrituras
extensas
4.3.6
Sistemas
archivos
bitácora
sistemas
archivos
estructurados
registro
idea
interesante
utilizan
ampliamente
alta
incompatibilidad
sistemas
archivos
existentes
ideas
inherentes
robustez
frente
fallas
aplicar
fa-
cilidad
sistemas
archivos
convencionales
idea
básica
mantener
registro
sistema
archivos
sistema
falla
trabajo
planeado
momento
re-arrancar
sistema
buscar
registro
ocurriendo
momento
falla
terminar
trabajo
Dichos
sistemas
archi-
vos
conocidos
sistemas
archivos
bitácora
Journaling
files
system
JFS
encuen-
tran
actualmente
sistema
archivos
NTFS
Microsoft
sistemas
ext3
ReiserFS
Linux
bitácora
continuación
daremos
introducción
tema
naturaleza
problema
considere
operación
simple
ocurre
tiem-
po
remover
archivo
operación
UNIX
requiere
pasos
Quitar
archivo
directorio
Liberar
nodo-i
pasarlo
reserva
nodos-i
libres
Devolver
bloques
disco
reserva
bloques
disco
libres
Windows
requieren
pasos
similares
ausencia
fallas
sistema
orden
realizan
pasos
importa
presencia
fallas
Suponga
completa
paso
sistema
falla
nodo-i
bloques
archivo
estarán
accesibles
nin-
gún
archivo
estarán
disponibles
reasignados
encuentran
limbo
disminuyendo
recursos
disponibles
falla
ocurre
pa-
so
pierden
bloques
orden
operaciones
cambia
nodo-i
libera
re-
arrancar
nodo-i
reasignar
entrada
directorio
seguirá
apuntando
ende
archivo
incorrecto
bloques
liberan
falla
lim-
piar
nodo-i
indicará
entrada
directorio
válida
apunta
nodo-i
lista
bloques
encuentran
reserva
almacenamiento
libre
probablemente
reutilicen
produciendo
archivos
compartan
azar
bloques
resultados
sistema
archivos
bitácora
escribir
entrada
registro
liste
acciones
completar
entrada
registro
escribe
disco
bue-
na
medida
posiblemente
lea
disco
verificar
integridad
escrito
entrada
registro
empiezan
diversas
operaciones
opera-
ciones
completan
éxito
borra
entrada
registro
sistema
falla
momen-
www.FreeLibros.meto
recuperarse
sistema
archivos
verificar
registro
operaciones
pendientes
volver
ejecutar
múltiples
caso
fallas
re-
petidas
archivo
elimine
forma
correcta
funcione
sistema
bitácora
operaciones
registradas
idempotentes
significa
repetirse
necesario
peligro
operacio-
nes
Actualizar
mapa
bits
marcar
nodo-i
bloque
libre
repetir
operaciones
completen
peligro
similar
opera-
ciones
buscar
directorio
eliminar
entrada
llamada
foobar
idempotentes
operación
agregar
bloques
recién
liberados
nodo-i
lista
libre
idempotente
encuentren
operación
costosa
Buscar
lista
bloques
libres
agregarle
bloque
presente
idem-
potente
sistemas
archivos
bitácora
organizar
estructuras
datos
opera-
ciones
registrarse
idempotentes
condiciones
recuperación
errores
rápida
segura
confiabilidad
sistema
archivos
introducir
concepto
bases
datos
conocido
transacción
atómica
utiliza
concepto
acciones
agrupar
operaciones
begin
transactiony
end
transaction
sistema
archivos
completar
operaciones
agrupadas
combinación
NTFS
sistema
bitácora
extenso
estructura
rara
corrompe
fallas
sistema
desarrollo
liberó
Windows
NT
1993
sistema
archivos
bitácora
Linux
ReiserFS
popularidad
vio
impedida
incompatible
sistema
archivos
ext2
estándar
contraste
ext3
proyecto
ambicioso
ReiserFS
bitácora
tiempo
mantiene
compatibilidad
sistema
ext2
4.3.7
Sistemas
archivos
virtuales
sistemas
archivos
distintos
computadora
pa-
ra
sistema
operativo
sistema
Windows
sistema
archivos
NTFS
prin-
cipal
unidad
partición
FAT-32
FAT-16
heredada
contenga
datos
antiguos
necesarios
requerir
CD-ROM
DVD
sistema
archivos
manejar
sistemas
archivos
dispares
Windows
identifica
letra
unidad
distinta
etcétera
proceso
abre
archivo
letra
unidad
presente
forma
explícita
implícita
ma-
nera
Windows
sepa
sistema
archivos
pasar
solicitud
intento
integrar
sistemas
archivos
heterogéneos
unificado
contraste
sistemas
UNIX
modernos
tratan
seriedad
integrar
sistemas
archivos
estructura
sistema
Linux
ext2
sistema
archivos
raíz
partición
ext3
montada
/usr
disco
duro
sistema
archivos
ReiserFS
montado
/home
CD-ROM
ISO
9660
montado
temporalmente
288
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
289
/mnt
punto
vista
usuario
jerarquía
sistemas
archivos
sucede
abarcar
múltiples
sistemas
archivos
incompatibles
visible
usuarios
procesos
presencia
múltiples
sistemas
archivos
visible
definitivamente
implementación
trabajo
encabezado
Sun
Microsystems
Kleiman
1986
mayoría
sistemas
UNIX
utilizado
concepto
VFS
virtual
file
system
Sistema
ar-
chivos
virtual
tratar
integrar
múltiples
sistemas
archivos
estructura
ordenada
idea
clave
abstraer
sistema
archivos
común
sistemas
ar-
chivos
código
capa
separada
llame
sistemas
archivos
concretos
sub-
yacentes
administrar
datos
estructura
general
ilustra
figura
4-18
análisis
específico
Linux
FreeBSD
versión
UNIX
pro-
porciona
panorama
general
acerca
funcionan
sistemas
archivos
virtuales
sistemas
UNIX
Proceso
usuario
SA
SA
SA
Caché
búfer
Sistema
archivos
virtual
Sistema
archivos
Interfaz
VFS
POSIX
Figura
4-18
Posición
sistema
archivos
virtual
llamadas
sistema
relacionadas
archivos
dirigen
sistema
archivos
vir-
tual
procesamiento
inicial
llamadas
provienen
procesos
usuario
llamadas
POSIX
estándar
tales
open
read
write
lseek
etcétera
ende
VFS
interfaz
superior
procesos
usuario
conocida
interfaz
POSIX
VFS
interfaz
inferior
sistemas
archivos
concretos
etiqueta-
Interfaz
VFS
figura
4-18
interfaz
consiste
docenas
llamadas
funciones
VFS
sistema
archivos
trabajo
crear
sistema
archivos
trabaje
VFS
diseñadores
sistema
archi-
vos
asegurar
suministre
llamadas
funciones
requiere
VFS
ejemplo
ob-
vio
dicha
función
lee
bloque
específico
disco
coloca
caché
búfer
sistema
archivos
devuelve
apuntador
bloque
consecuencia
VFS
interfaces
distintas
superior
procesos
usuario
inferior
sistemas
archi-
vos
concretos
mayoría
sistemas
VFS
representan
particiones
disco
local
caso
motivación
original
Sun
construir
VFS
soporte
www.FreeLibros.melos
sistemas
archivos
remotos
protocolo
NFS
Network
File
System
Sistema
archivos
red
diseño
VFS
sistema
archivos
concreto
suministre
funciones
requiere
VFS
preocupa
almacenan
datos
sistema
archivos
subyacente
interior
mayoría
implementaciones
VFS
esencia
orientadas
objetos
escritas
/H11001
H11001
tipos
clave
objetos
soportan
nor-
malmente
incluyen
superbloque
describe
sistema
archivos
nodo-v
describe
archivo
directorio
describe
directorio
sistema
archivos
operaciones
métodos
asociadas
soportar
sistemas
archivos
concretos
VFS
estructuras
datos
internas
incluyen-
do
tabla
montaje
arreglo
descriptores
archivos
ar-
chivos
abiertos
procesos
usuario
comprender
funciona
VFS
veamos
ejemplo
forma
cronológica
arranca
sistema
sistema
archivos
raíz
registra
VFS
mon-
sistemas
archivos
tiempo
arranque
operación
tam-
bién
registrar
VFS
sistema
archivos
registra
básicamente
proveer
lista
direcciones
funciones
requiere
VFS
vector
tabla
llamadas
extenso
objeto
VFS
se-
gún
demande
VFS
registrado
sistema
archivos
VFS
és-
leer
bloque
sistema
ejemplo
simplemente
llama
cuarta
función
vector
suministrado
sistema
archivos
similar
VFS
cabo
funciones
sumi-
nistrar
sistema
archivos
concreto
llama
función
cuya
dirección
suministró
cuan-
do
registró
sistema
archivos
montado
sistema
archivos
utilizar
ejemplo
montado
sistema
archivos
/usr
proceso
realiza
llamada
open(“/usr
include
unistd.h
O_RDONL
analizar
sintácticamente
ruta
VFS
ve
montado
sistema
archivos
/usr
localiza
superbloque
busca
lista
superbloques
sistemas
ar-
chivos
montados
Habiendo
encontrar
directorio
raíz
sistema
archi-
vos
montado
buscar
ruta
include
unistd.h
VFS
crea
nodo-v
llamada
sistema
archivos
concreto
devuelva
información
nodo-i
ar-
chivo
información
copia
nodo-v
RAM
información
im-
portante
apuntador
tabla
funciones
llamar
operaciones
nodos-v
read
write
close
etcétera
creado
nodo-v
VFS
crea
entrada
tabla
descriptores
ar-
chivos
proceso
llamada
establece
apunte
nodo-
puristas
descriptor
archivo
realidad
apunta
estructura
datos
contiene
posición
actual
archivo
apuntador
nodo-v
detalle
importan-
propósitos
VFS
devuelve
descriptor
archivo
llamador
utilizar
leer
escribir
cerrar
archivo
290
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.3
IMPLEMENTACIÓN
SISTEMAS
ARCHIVOS
291
Posteriormente
proceso
realiza
operación
readutilizando
descriptor
archi-
vo
VFS
localiza
nodo-v
proceso
tablas
descriptores
archivos
siguiendo
apun-
tador
tabla
funciones
direcciones
sistema
archivos
concreto
reside
archivo
solicitado
función
maneja
readse
llama
código
sistema
archivos
concreto
obtiene
bloque
solicitado
VFS
idea
acerca
datos
provienen
disco
local
sistema
archivos
remoto
red
CD-ROM
memoria
USB
distinto
estructuras
datos
involucradas
mues-
tran
figura
4-19
Empezando
número
proceso
llamador
descriptor
archi-
vo
localizan
forma
sucesiva
nodo-v
apuntador
función
ready
función
acceso
sistema
archivos
concreto
Tabla
procesos
Descriptores
archivos
Nodos-v
open
read
write
Apuntadores
funciones
VFS
Función
read
SA
Llamada
VFS
SA
1Figura
4-19
vista
simplificada
estructuras
datos
código
utilizados
VFS
sistema
archivos
concreto
read
forma
relativamente
directo
agregar
sistemas
archivos
diseñadores
obtienen
lista
llamadas
funciones
espera
VFS
es-
criben
sistema
archivos
proveer
alternativa
sistema
archivos
proveer
funciones
envoltura
hagan
VFS
necesita
general
realizando
llamadas
nativas
sistema
archivos
concreto
www
FreeLibros.me4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
sistema
archivos
funcione
cosa
funcione
eficiente
robusta
vida
real
distinto
siguientes
secciones
analizaremos
cuestiones
involucradas
administración
discos
4.4.1
Administración
espacio
disco
general
archivos
almacenan
disco
administración
espacio
disco
cuestión
importante
diseñadores
sistemas
archivos
estrategias
generales
posibles
almacenar
archivo
bytes
asignan
bytes
consecutivos
espacio
disco
archivo
divide
bloques
necesariamente
contiguos
concesión
pre-
sente
sistemas
administración
memoria
segmentación
pura
paginación
visto
almacenar
archivo
secuencia
contigua
bytes
pro-
blema
obvio
archivo
crece
probablemente
moverse
disco
problema
aplica
segmentos
memoria
operación
mover
segmento
memoria
rápida
comparación
operación
mover
archivo
posición
disco
razón
sistemas
archivos
dividen
archivos
bloques
tamaño
fijo
necesitan
adyacentes
Tamaño
bloque
decidido
almacenar
archivos
bloques
tamaño
fijo
surge
pregunta
acer-
ca
bloque
Dada
forma
organizados
discos
sec-
tor
pista
cilindro
candidatos
obvios
unidad
asignación
dependientes
dispositivo
desventaja
sistema
paginación
tamaño
página
principales
contendientes
tamaño
bloque
significa
archivo
archivo
byte
ocupa
cilindro
completo
significa
pequeños
archivos
desperdician
cantidad
espacio
disco
tamaño
bloque
pequeño
significa
mayoría
archivos
abarcarán
bloques
ende
necesitan
búsquedas
retrasos
rotacio-
nales
leerlos
reduce
rendimiento
ende
unidad
asignación
desperdiciamos
espacio
pequeña
desperdiciamos
tiempo
elección
información
distribución
ta-
maños
archivo
Tanenbaum
colaboradores
2006
estudiaron
distribución
tamaños
archivo
Departamento
Ciencias
Computacionales
universidad
investigación
VU
1984
2005
servidor
Web
comercial
hospedaba
sitio
Web
político
www.electoral-vote.com
resultados
muestran
figura
4-20
tamaño
archivo
potencia
lista
porcentaje
archivos
me-
nores
iguales
conjuntos
datos
ejemplo
2005
59.13%
archivos
VU
KB
menores
90.84%
archivos
292
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
293
64
KB
menores
tamaño
archivo
promedio
2475
bytes
per-
sonas
tamaño
pequeño
parezca
sorprendente
conclusiones
obtener
datos
tamaño
bloque
KB
30
50%
archivos
caben
bloque
bloque
KB
porcentaje
archivos
caben
bloque
aumenta
rango
60
70%
datos
artículo
muestran
bloque
KB
93%
bloques
disco
utilizados
10%
archivos
significa
desperdicio
espacio
pequeño
archivo
importante
disco
llena
cantidad
archivos
videos
cantidad
espacio
ocupado
pequeños
archivos
insignificante
duplica
espacio
90%
archivos
pequeños
ocu-
parían
insignificante
utilizar
bloque
pequeño
significa
archivo
consistirá
blo-
ques
leer
bloque
normalmente
requiere
búsqueda
retraso
rotacional
acción
leer
archivo
consista
bloques
pequeños
lenta
ejemplo
considere
disco
MB
pista
tiempo
rotación
8.33
mseg
tiempo
búsqueda
promedio
mseg
tiempo
milisegundos
leer
bloque
bytes
suma
tiempos
búsqueda
retraso
rotacional
transferencia
/H110014.165
/H11001(k/1000000
/H110038.33
curva
sólida
figura
4-21
muestra
velocidad
datos
disco
fun-
ción
tamaño
bloque
calcular
eficiencia
espacio
necesitamos
suposición
acerca
tamaño
archivo
promedio
simplicidad
suponer
archivos
KB
número
datos
medidos
VU
probable
Longitud
Longitud
Figura
4-20
Porcentaje
archivos
menores
tamaño
bytes
www.FreeLibros.meque
estudiantes
tengan
archivos
pequeños
estarían
presentes
centro
da-
tos
corporativo
aproximación
general
curva
punteada
figura
4-21
muestra
eficiencia
espacio
función
tamaño
bloque
294
SISTEMAS
ARCHIVOS
CAPÍTULO
KB
KB
16
KB
64
KB
256
KB
MB
100%
10
20
30
40
50
60
80%
60%
40%
20%
0%
Velocidad
datos
MB
seg
Utilización
espacio
disco
Figura
4-21
curva
sólida
escala
izquierdo
velocidad
datos
disco
curva
punteada
escala
derecho
eficiencia
espacio
dis-
co
archivos
KB
curvas
comprender
tiempo
acceso
blo-
completamente
dominado
tiempo
búsqueda
retraso
rotacional
requerir
mseg
acceder
bloque
datos
obtengan
consecuen-
cia
velocidad
datos
aumenta
forma
lineal
tamaño
bloque
trans-
ferencias
tardan
tiempo
transferencia
empieza
importante
considere
eficiencia
espacio
archivos
KB
bloques
KB
KB
KB
archivos
utilizan
bloques
respectivamente
desperdicio
bloque
KB
archivos
KB
eficiencia
espacio
disminuye
50%
bloque
16
KB
disminuye
25%
realidad
archivos
múltiplo
exacto
tamaño
bloque
disco
desperdicia
espacio
bloque
archivo
muestran
curvas
rendimiento
espacio
encuentran
inherentemente
conflicto
bloques
pequeños
malos
rendimiento
espacio
disco
datos
compromiso
razonable
disponible
tamaño
cercano
punto
cruzan
curvas
64
KB
velocidad
datos
só-
6.6
MB
seg
eficiencia
espacio
7%
valores
Históricamente
sistemas
archivos
elegido
tamaños
rango
KB
KB
pe-
ro
discos
exceden
TB
incrementar
tamaño
bloque
64
KB
aceptar
espacio
disco
desperdiciado
espacio
disco
escasea
experimento
archivos
Windows
NT
distinto
UNIX
Vogels
mediciones
archivos
universidad
Cornell
University
ogels
1999
observó
archivos
NT
complicado
UNIX
Escribió
escribimos
caracteres
editor
texto
bloc
notas
notepad),a
guardar
archivo
activarán
26
llamadas
sistema
incluyendo
intentos
aper-
tura
fallidos
sobrescritura
archivo
secuencias
adicionales
abrir
cerrar
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
295
observó
tamaño
promedio
ponderado
archivos
leídos
KB
archivos
escritos
2.3
KB
archivos
leídos
escritos
4.2
KB
Dadas
distintas
técnicas
medición
conjuntos
datos
año
resultados
duda
compatibles
resultados
VU
Registro
bloques
libres
elegido
tamaño
bloque
cuestión
registro
bloques
libres
métodos
utilizados
ampliamente
muestra
figura
4-22
pri-
mero
consiste
utilizar
lista
enlazada
bloques
disco
bloque
contiene
tantos
números
bloques
disco
libres
bloque
KB
número
bloque
disco
32
bits
bloque
lista
bloques
libres
contiene
números
255
bloques
libres
requiere
ranura
apuntador
bloque
Considere
disco
500
GB
488
millones
bloques
disco
almacenar
direcciones
255
bloque
requiere
cantidad
aproximada
1.9
millones
bloques
general
uti-
lizan
bloques
libres
mantener
lista
bloques
libres
esencia
almacenamien-
to
gratuito
Bloques
disco
libres
16
17
18
mapa
bitsUn
bloque
disco
KB
contener
256
números
bloque
disco
32
bits
86
234
897
422
140
223
223
160
126
142
141
1001101101101100
0110110111110111
1010110110110110
0110110110111011
1110111011101111
1101101010001111
0000111011010111
1011101101101111
1100100011101111
0111011101110111
1101111101110111
230
162
612
342
214
160
664
216
320
180
482
42
136
210
97
41
63
21
48
262
310
516
Figura
4-22
Almacenamiento
lista
bloques
libres
lista
enlazada
mapa
bits
técnica
administración
espacio
libre
mapa
bits
disco
bloques
re-
mapa
bits
bits
bloques
libres
representan
1s
mapa
blo-
ques
asignados
0s
viceversa
disco
500
GB
ejemplo
necesitamos
www
FreeLibros.me488
millones
bits
mapa
requieren
60,000
bloques
KB
al-
macenamiento
sorpresa
mapa
bits
requiera
espacio
utiliza
bit
bloque
comparación
32
bits
modelo
lista
enlazada
disco
lleno
bloques
libres
esquema
lista
enlazada
requiere
bloques
mapa
bits
bloques
libres
tienden
presentarse
series
largas
bloques
consecutivos
sistema
lista
bloques
libres
modificar
series
bloques
bloques
individuales
16
32
bits
asociar
bloque
dando
nú-
mero
bloques
libres
consecutivos
caso
disco
prácticamente
vacío
repre-
sentarse
números
dirección
bloque
libre
seguida
bloques
libres
disco
fragmenta
eficiente
registro
series
bloques
individuales
almacenar
dirección
cuestión
ilustra
problema
diseñadores
sistemas
operativos
enfrentan
estructuras
datos
algoritmos
utilizar
resolver
pro-
blema
elegir
requieren
datos
diseñadores
sistema
opere
utilice
frecuencia
datos
es-
tén
disponibles
ejemplo
mediciones
tamaños
archivo
VU
1984
1995
datos
sitio
Web
datos
Cornell
muestras
idea
vaga
acerca
representativos
computadoras
do-
mésticas
computadoras
empresariales
computadoras
gubernamentales
es-
fuerzo
podríamos
obtenido
par
muestras
tipos
computadoras
imprudente
extrapolar
computadoras
tipos
midieron
Regresando
momento
método
lista
bloques
libres
mantener
bloque
apuntadores
memoria
principal
crear
archivo
bloques
necesarios
toman
bloque
apuntadores
bloque
agota
lee
bloque
apuntadores
disco
similar
elimina
archivo
liberan
bloques
agregan
blo-
apuntadores
memoria
principal
bloque
llena
escribe
disco
circunstancias
método
produce
operaciones
disco
innecesarias
Considere
situación
figura
4-23(a
bloque
apuntadores
memoria
espa-
cio
entradas
libera
archivo
bloques
bloque
apuntadores
desborda
escribirse
disco
produce
situación
figura
4.23(b
escribe
archivo
bloques
volver
leer
bloque
completo
apun-
tadores
disco
regresa
figura
4-23(a
archivo
bloques
acaba
escribir
temporal
liberarlo
necesitará
escritura
disco
escribir
bloque
com-
pleto
apuntadores
vuelta
disco
resumen
bloque
apuntadores
vacío
serie
archivos
temporales
tiempo
corto
vida
producir
opera-
ciones
disco
método
alternativo
evita
operaciones
disco
dividir
bloque
completo
apuntadores
pasar
figura
4-23(a
figura
4-23(b
pasa-
mos
figura
4-23(a
figura
4-23(c
liberan
bloques
sistema
ma-
nejar
serie
archivos
temporales
operación
S.
bloque
memoria
llena
escribe
disco
lee
bloque
lleno
disco
idea
mantener
296
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
297
DiscoMemoria
principal
Figura
4-23
bloque
lleno
apuntadoras
bloques
disco
libres
memoria
bloques
apuntadores
disco
Resultado
liberar
archi-
vo
bloques
estrategia
alternativa
manejar
bloques
libres
entradas
sombreadas
representan
apuntadores
bloques
disco
libres
bloques
apuntadores
disco
llenos
minimizar
disco
pe-
ro
mantener
memoria
lleno
mitad
manejar
creación
remoción
archivos
necesidad
operaciones
disco
lista
bloques
libres
mapa
bits
mantener
bloque
memoria
usando
disco
obtener
llena
vacía
beneficio
adicional
método
asignación
bloque
mapa
bits
bloques
disco
estarán
cerca
minimiza
movimiento
brazo
disco
mapa
bits
estructura
datos
tamaño
fijo
kernel
paginado
parcialmente
mapa
bits
colocarse
memoria
virtual
paginen
páginas
requiera
Cuotas
disco
evitar
usuarios
ocupen
espacio
disco
sistemas
operativos
multiusua-
rio
proporcionan
mecanismo
imponer
cuotas
disco
idea
administrador
sistema
asigne
usuario
cantidad
máxima
archivos
bloques
sistema
ope-
rativo
asegure
usuarios
excedan
cuotas
continuación
describiremos
me-
canismo
común
usuario
abre
archivo
atributos
direcciones
disco
localizan
co-
locan
tabla
archivos
abiertos
memoria
principal
atributos
entra-
indica
propietario
aumento
tamaño
archivo
tomará
cuota
propietario
tabla
contiene
registro
cuotas
usuario
archivo
actualmen-
abierto
archivo
abierto
alguien
tabla
muestra
figura
4-24
extracto
archivo
cuotas
disco
usurarios
cuyos
archivos
actualmen-
abiertos
archivos
cierran
registro
escribe
vuelta
archivo
cuotas
www
FreeLibros.meCuando
crea
entrada
tabla
archivos
abiertos
introduce
apun-
tador
registro
cuotas
propietario
facilitar
búsqueda
diversos
límites
agrega
bloque
archivo
incrementa
número
bloques
cargan
propietario
realiza
verificación
límites
duro
suave
exceder
límite
suave
límite
duro
intento
agregar
datos
archivo
llegado
lí-
mite
bloques
duro
producirá
error
verificaciones
similares
número
archivos
usuario
iniciar
sesión
sistema
examina
archivo
cuotas
usuario
excedido
límite
suave
número
archivos
número
bloques
disco
violado
límites
muestra
advertencia
advertencias
restan-
tes
reduce
llega
cero
momento
usuario
ignorado
demasia-
das
advertencia
permite
iniciar
sesión
obtener
permiso
iniciar
sesión
hablar
administrador
sistema
método
propiedad
usuarios
sobrepasar
límites
suaves
du-
rante
sesión
eliminen
exceso
cierren
sesión
límites
duros
exceder
4.4.2
Respaldos
sistema
archivos
destrucción
sistema
archivos
desastre
destrucción
computadora
computadora
destruye
incendio
tormentas
eléctricas
derrama
taza
café
teclado
molesto
costará
dinero
general
comprar
reemplazo
problemas
computadoras
personales
económicas
reemplazar
lapso
hora
tienda
computadoras
298
SISTEMAS
ARCHIVOS
CAPÍTULO
Tabla
archivos
abiertos
Tabla
cuotas
Límite
bloques
suave
Límite
bloques
duro
Número
actual
bloques
Número
advertencias
bloques
pendientes
Límite
archivos
suave
Límite
archivos
duro
Número
actual
archivos
Número
advertencias
archivos
pendientes
Atributos
direcciones
disco
Usuario
Apuntador
cuota
Registro
cuotas
usuario
Figura
4-24
registro
cuotas
tabla
cuotas
usuario
usuario
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
299
universidades
emitir
orden
compra
requieren
comités
cin-
co
firmas
90
sistema
archivos
computadora
pierde
irrevocable
hardware
software
difícil
restaurar
información
llevará
tiempo
ca-
sos
imposible
personas
cuyos
programas
documentos
registros
fiscales
archivos
clientes
bases
datos
planes
comercialización
datos
pierden
con-
secuencias
catastróficas
sistema
archivos
ofrecer
protección
destrucción
física
equipo
medios
ayudar
proteger
información
sim-
ple
respaldos
sencillo
Demos
vistazo
mayoría
personas
creen
respaldos
archivos
valga
pena
tiempo
esfuerzo
disco
duro
deja
funcionar
forma
repentina
momento
mayoría
personas
cambian
opinión
embar-
go
empresas
general
comprenden
valor
datos
general
realizan
respaldo
cinta
cintas
modernas
contienen
cientos
gigabytes
costo
centavos
gigabyte
respaldos
trivial
oye
continuación
analizaremos
cuestiones
relacionadas
general
realizan
respaldos
cinta
manejar
problemas
potenciales
Recuperarse
desastre
Recuperarse
estupidez
problema
acerca
computadora
vuelva
funcionar
falla
general
disco
incendio
inundación
catástrofe
natural
práctica
cosas
ocurren
razón
personas
preocupan
respaldos
personas
tienden
seguros
incendios
ho-
gares
razón
razón
usuarios
remueven
accidental
archivos
vuelven
necesitar
problema
ocurre
tanta
frecuencia
elimina
archivo
Windows
elimina
mueve
directorio
especial
co-
nocido
Papelera
reciclaje
restaurarse
facilidad
momento
pos-
terior
respaldos
llevan
principio
allá
permiten
archivos
removieron
semanas
restauren
cintas
respaldo
antiguas
respaldo
requiere
tiempo
ocupa
cantidad
espacio
importante
eficiencia
conveniencia
consideraciones
pie
siguientes
cuestiones
lugar
respaldarse
sistema
completo
instalaciones
programas
ejecutables
binarios
mantienen
limitada
árbol
sistema
archivos
necesario
respaldar
archivos
volver
instalar-
CD-ROM
fabricantes
mayoría
sistemas
directorio
pa-
ra
archivos
temporales
general
razón
respaldarlos
UNIX
archivos
especiales
dispositivos
mantienen
directorio
/dev
innece-
sario
respaldar
directorio
peligroso
programa
respaldo
quedaría
paralizado
tratara
leer
archivos
com-
pletaran
resumen
general
conveniente
respaldar
directorios
específicos
contengan
respaldar
sistema
archivos
www
FreeLibros.meEn
lugar
desperdicio
respaldar
archivos
cambiado
respaldo
idea
vaciados
incrementales
forma
simple
vacia-
do
incremental
vaciado
completo
respaldo
forma
periódica
sema-
na
mes
vaciado
diario
archivos
hayan
modificado
vaciado
completo
vaciar
archivos
cambiado
últi-
ma
vaciaron
esquema
minimiza
tiempo
vaciado
complica
re-
cuperación
restaurar
vaciado
completo
reciente
seguido
vaciados
incrementales
orden
inverso
facilitar
recuperación
utilizan
frecuen-
cia
esquemas
vaciado
incremental
sofisticados
tercer
lugar
general
vacían
inmensas
cantidades
datos
conve-
niente
comprimir
datos
escribirlos
cinta
algoritmos
compresión
punto
malo
cinta
respaldo
frustrar
algoritmo
descompre-
sión
archivo
cinta
ilegible
ende
decisión
com-
primir
flujo
respaldo
considerar
cuidado
cuarto
lugar
difícil
cabo
respaldo
sistema
archivos
activo
es-
tán
agregando
eliminando
modificando
archivos
directorios
proceso
vaciado
vaciado
resultante
inconsistente
vaciado
requerir
horas
necesario
desconectar
sistema
red
noche
pa-
ra
respaldo
aceptable
razón
ideado
algoritmos
tomar
instantáneas
rápidas
sistema
archivos
copiar
estructuras
datos
críticas
requerir
futuros
cambios
archivos
directorios
copien
bloques
actualizarlos
instante
Hutchinson
colaboradores
1999
forma
sistema
archivos
efecto
congela
momento
instantánea
respaldar
conveniencia
quinto
lugar
respaldos
introducen
organización
pro-
blemas
técnicos
sistema
seguridad
línea
mundo
inútil
ad-
ministrador
sistema
mantiene
cintas
respaldo
oficina
deja
abierta
desprotegida
dirige
pasillo
recoger
resultados
impresora
espía
entrar
colocar
pequeña
cinta
bolsillo
salir
tranquilidad
confianza
Adiós
seguridad
respaldo
diario
utilidad
incendio
quemó
computadoras
quema
cintas
res-
paldo
razón
cintas
respaldo
mantener
sitio
introduce
riesgos
seguridad
asegurar
sitios
análisis
de-
tallado
cuestiones
administración
prácticas
consulte
Nemeth
colaboradores
2000
continuación
analizaremos
cuestiones
técnicas
implicadas
respaldos
sistema
archivos
utilizar
estrategias
vaciar
disco
cinta
vaciado
físico
va-
ciado
lógico
vaciado
físico
empieza
bloque
disco
escribe
bloques
dis-
co
cinta
salida
orden
detiene
acaba
copiar
programa
simple
probablemente
hacerse
100%
libre
errores
probablemente
acerca
programa
útil
vale
pena
comentarios
acerca
vaciado
físico
valor
respaldar
bloques
disco
utilizar
programa
vaciado
obte-
300
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
301
ner
acceso
estructura
datos
bloques
libres
evitar
vaciar
bloques
utilizados
omitir
bloques
utilizados
escribir
número
bloque
frente
equivalente
caso
aplica
bloque
cinta
bloque
disco
preocupación
vaciar
bloques
defectuosos
imposible
fabricar
dis-
cos
defecto
bloques
defectuosos
presentes
realiza
formato
nivel
detectan
bloques
defectuosos
marcan
reemplazan
bloques
reservados
pista
tales
emergencias
casos
controlador
disco
encarga
reemplazo
bloques
defectuosos
transparente
sistema
operativo
sepa
siquiera
acerca
bloques
vuelven
defectuosos
formato
cuyo
caso
sistema
operativo
detectará
momento
general
resuelve
problema
creando
archivo
consistente
bloques
malos
asegurarse
apa-
rezcan
reserva
bloques
libres
asignen
archivo
sobra
decirlo
com-
pletamente
ilegible
bloques
defectuosos
reasociados
controlador
disco
ocultan
sis-
tema
operativo
acabamos
describir
vaciado
físico
funciona
visibles
sistema
operativo
mantienen
archivos
bloques
defectuosos
mapas
bits
absoluto
esencial
programa
vaciado
físico
obtenga
acceso
in-
formación
evite
vaciarlos
evitar
interminables
errores
lectura
disco
tratar
respal-
archivo
bloques
defectuosos
principales
ventajas
vaciado
físico
simplicidad
velocidad
básicamen-
operar
velocidad
disco
principales
desventajas
incapacidad
omitir
directorios
seleccionados
vaciados
incrementales
restaurar
archivos
individuales
peti-
ción
usuario
razones
mayoría
instalaciones
realizan
vaciados
lógicos
vaciado
lógico
empieza
directorios
especificados
vacía
forma
recursiva
to-
archivos
directorios
encuentran
hayan
modificados
fecha
ba-
dada
ejemplo
respaldo
vaciado
incremental
instalación
sistema
vaciado
completo
vaciado
lógico
cinta
vaciado
obtiene
serie
directorios
archivos
cuidadosamente
identificados
facilita
restauración
archivo
directorio
espe-
cífico
petición
usuario
vaciado
lógico
forma
común
examinar
algoritmo
común
for-
ma
detallada
utilizando
ejemplo
figura
4-25
guiarnos
mayoría
sistemas
UNIX
utilizan
algoritmo
figura
árbol
archivos
directorios
cua-
dros
archivos
círculos
elementos
sombreados
modificado
fecha
base
ende
necesitan
vaciarse
sombreados
necesitan
vaciarse
algoritmo
vacía
directorios
modificado
encuentran
ruta
archivo
directorio
modificado
razones
lugar
restaurar
archivos
directorios
vaciados
sistema
archivos
fresco
computadora
distinta
forma
programas
vaciado
restauración
utili-
zar
transportar
sistemas
archivos
completos
computadoras
razón
vaciar
directorios
modificados
estén
archivos
modifica-
restaurar
archivo
forma
incremental
manejar
www.FreeLibros.mela
recuperación
causa
estupidez
Suponga
realiza
vaciado
completo
sistema
archivos
domingo
vaciado
incremental
lunes
martes
re-
mueve
directorio
/usr
jhs
proy
nr3
directorios
archivos
miércoles
mañana
usuario
desea
restaurar
archivo
/usr
jhs
proy
nr3
planes
resumen
restaurar
archivo
resumen
lugar
ponerlo
directorios
nr3
planes
restaurar
obtener
datos
correctos
propietarios
modos
horas
directorios
presentes
cinta
vaciado
hayan
modificados
ocurrió
vaciado
completo
algoritmo
vaciado
mantiene
mapa
bits
indexado
número
nodo-i
bits
nodo-i
bits
activarán
borrarán
mapa
medida
algoritmo
realice
trabajo
algoritmo
opera
fases
fase
empieza
directorio
inicial
directorio
raíz
ejemplo
examina
entradas
contiene
archivo
modificado
marca
nodo-i
mapa
bits
directorio
marca
modificado
inspecciona
recursiva
fase
marcado
archivos
directorios
modificados
mapa
bits
muestra
sombreado
figura
4-26(a
concepto
fase
reco-
rre
forma
recursiva
árbol
desmarcando
directorios
tengan
archivos
di-
rectorios
modificados
fase
deja
mapa
bits
muestra
figura
4-26(b
Observe
directorios
10
11
14
27
29
30
desmarcados
contienen
modificado
directorios
vaciarán
con-
trario
directorios
vaciarán
hayan
modificado
ne-
302
SISTEMAS
ARCHIVOS
CAPÍTULO
18
19
27
10
20
22
30
29
231411
12
13
15
31
28
32
24
25
26
16
17
21
Archivo
cambiado
Archivo
cambiado
Directorio
raíz
Directorio
cambiado
Figura
4-25
sistema
archivos
vaciar
cuadros
directorios
círculos
archivos
elementos
sombreados
modificados
últi-
mo
vaciado
directorio
archivo
etiquetado
base
número
nodo-i
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
303
cesitarán
restaurar
cambios
máquina
cuestión
eficiencia
fases
combinar
recorrido
árbol
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32(d
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32(c
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32(b
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32(a
Figura
4-26
Mapas
bits
utilizados
algoritmo
vaciado
lógico
punto
directorios
archivos
vaciar
mar-
cados
figura
4-26(b
fase
consiste
explorar
nodos-i
orden
numérico
vaciar
directorios
marcados
vaciado
muestran
figura
4-26(c
directo-
rio
prefijo
atributos
propietario
horas
etc.
restaurar
fase
vacían
archivos
marcados
figura
4.26(d
tie-
nen
prefijo
atributos
completa
vaciado
Restaurar
sistema
archivos
cintas
vaciado
proceso
directo
empezar
crea
sistema
archivos
vacío
disco
restaura
vaciado
comple-
to
reciente
directorios
aparecen
cinta
restauran
obtiene
esqueleto
sistema
archivos
restauran
archivos
Es-
proceso
repite
vaciado
incremental
vaciado
completo
des-
pués
sucesivo
vaciado
lógico
directo
cuestiones
engañosas
ejemplo
co-
mo
lista
bloques
libres
archivo
vacía
ende
reconstruir
ce-
ro
restaurado
vaciados
conjunto
bloques
libres
complemento
conjunto
bloques
contenidos
archivos
combinados
vínculos
cuestiones
archivo
vincula
directorios
im-
portante
archivo
restaure
directorios
apuntar
hagan
cuestiones
archivos
UNIX
contener
huecos
legal
abrir
archivo
escribir
bytes
búsqueda
des-
plazamiento
archivo
distante
escribir
bytes
bloques
forman
archivo
vaciarse
restaurarse
archivos
bá-
sicos
hueco
cientos
megabytes
segmento
datos
pila
ma-
nejan
forma
apropiada
archivo
básico
restaurado
llenará
área
ceros
ende
www.FreeLibros.meserá
tamaño
espacio
direcciones
virtuales
ejemplo
32
bytes
64
bytes
archivos
especiales
llamados
canales
equivalentes
vaciar-
importar
directorio
encuentren
necesitan
confinarse
/dev
obtener
información
acerca
respaldos
sistema
archivos
consulte
Chervenak
colaboradores
1998
Zwicky
1991
densidades
cintas
mejorando
tanta
rapidez
densidades
discos
conlleva
gradualmente
situación
respaldo
disco
requiera
cintas
robots
disponibles
cambiar
cintas
automática
tendencia
continúa
momento
cintas
pequeñas
utilizarlas
respaldo
caso
única
forma
respaldar
disco
disco
utilizar
método
reflejar
disco
repuesto
posibi-
lidad
capítulo
analizaremos
esquemas
sofisticados
conocidos
RAIDs
4.4.3
Consistencia
sistema
archivos
área
confiabilidad
cuestión
importante
consistencia
sistema
ar-
chivos
sistemas
archivos
leen
bloques
modifican
escriben
posteriormente
sistema
falla
escribir
bloques
modificados
sistema
archivos
que-
inconsistente
problema
crítico
bloques
escrito
bloques
nodos-i
bloques
directorios
bloques
contienen
lista
blo-
ques
libres
lidiar
problema
sistemas
archivos
inconsistentes
mayoría
compu-
tadoras
programa
utilitario
verifica
consistencia
sistema
archivos
ejem-
plo
UNIX
fsck
Windows
scandisk
herramienta
ejecutar
arranca
sistema
especial
falla
descripción
in-
dica
funciona
fsck
Scandisk
distinto
opera
sistema
archivos
di-
ferente
principio
general
utilizar
redundancia
inherente
sistema
archivos
repararlo
válido
verificadores
sistema
archivos
comprueban
siste-
ma
archivos
partición
disco
independiente
tipos
verificaciones
consistencia
archivos
bloques
com-
probar
consistencia
bloques
programa
crea
tablas
contiene
contador
bloque
principio
establece
contadores
ta-
bla
llevan
registro
presente
bloque
archivo
contadores
tabla
registran
frecuencia
presente
bloque
lista
bloques
libres
mapa
bits
bloques
libres
programa
lee
nodos-i
utilizando
dispositivo
puro
ignora
es-
tructura
archivos
devuelve
bloques
disco
empiezan
partimos
nodo-i
construir
lista
números
bloque
utilizados
archivo
correspondiente
medida
lee
número
bloque
incrementa
contador
pri-
mera
tabla
programa
examina
lista
mapa
bits
bloques
libres
encontrar
bloques
estén
ocurrencia
bloque
lista
bloques
libres
incremente
contador
tabla
304
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
305
sistema
archivos
consistente
bloque
tabla
se-
gunda
ilustra
figura
4-27(a
resultado
falla
tablas
po-
drían
verse
figura
4-27(b
bloque
ocurre
tablas
reportará
bloque
faltante
bloques
faltantes
daño
real
desperdi-
cian
espacio
ende
reducen
capacidad
disco
solución
bloques
faltantes
direc-
ta
verificador
sistema
archivos
agrega
lista
bloques
libres
0123456789
Número
bloque
Bloques
Bloques
libres
0123456789
Bloques
Bloques
libres
0123456789
11
12131415
Número
bloque
Bloques
Bloques
libres
0123456789
11
12131415
Bloques
Bloques
libres
Figura
4-27
sistema
archivos
Consistente
Bloque
faltante
Bloque
duplicado
lista
bloques
libres
Bloque
datos
duplicado
situación
ocurrir
figura
4-27(c
bloque
nú-
mero
ocurre
lista
bloques
libres
duplicados
lista
bloques
libres
realidad
lista
mapa
bits
imposible
solución
simple
reconstruir
lista
bloques
libres
ocurrir
bloque
datos
esté
presente
archi-
vos
muestra
figura
4.27(d
bloque
remueve
archivos
bloque
colocará
lista
bloques
libres
producirá
situación
mis-
mo
bloque
tiempo
esté
libre
remueven
archivos
bloque
colocará
lista
bloques
libres
acción
apropiada
tomar
verificador
sistema
archivos
asignar
blo-
libre
copiar
contenido
bloque
insertar
copia
archivos
forma
contenido
información
archivos
modifica
probable
termine
basura
estructura
sistema
archivos
con-
sistente
error
reportar
permitir
usuario
inspeccione
daños
verificar
bloque
contabilizado
apropiadamente
verificador
sistema
archivos
verifica
sistema
directorios
Utiliza
tabla
conta-
dores
archivo
bloque
Empieza
directorio
raíz
desciende
recursi-
vamente
árbol
inspeccionando
directorio
sistema
archivos
nodo-i
directorio
incrementa
contador
archivo
Recuerde
www.FreeLibros.mea
vínculos
duros
archivo
aparecer
directorios
vínculos
simbólicos
cuentan
incremente
contador
archivo
objetivo
verificador
termina
lista
indexada
número
nodo-i
indica
cuán-
tos
directorios
contienen
archivo
compara
números
cuentas
víncu-
almacenadas
nodos-i
cuentas
empiezan
crea
archivo
incrementan
crea
vínculo
duro
archivo
sistema
archivos
con-
sistentes
ambas
cuentas
concordarán
ocurrir
tipos
errores
vínculos
nodo-i
alta
baja
vínculos
número
entradas
directorio
remueven
archivos
directorios
seguirá
distinta
cero
nodo-i
removerá
error
grave
desperdicia
espacio
disco
archivos
directorio
corregirlo
establecer
vínculos
nodo-i
valor
correcto
error
potencialmente
catastrófico
entradas
directorio
vinculados
archivo
nodo-i
elimine
entradas
di-
rectorio
nodos-i
cero
nodos-i
queda
cero
sistema
archivos
marca
utilizada
libera
bloques
acción
hará
di-
rectorios
apunte
nodo-i
utilizar
cuyos
bloques
asignarse
archi-
vos
solución
obligar
vínculos
nodo-i
número
actual
entradas
directorio
operaciones
verificar
bloques
verificar
directorios
integran
cues-
tiones
eficiencia
requiere
nodos-i
posibles
comprobaciones
ejemplo
directorios
formato
definido
números
no-
dos-i
nombres
ASCII
número
nodo-i
número
nodos-i
dis-
co
directorio
dañado
nodo-i
legales
extraños
0007
permite
tipo
acceso
propietario
grupo
permite
usuarios
externos
leer
escribir
ejecutar
archivo
útil
reportar
archivos
usuarios
externos
derechos
propietario
directorios
1000
entradas
sospechosos
archivos
localizados
directorios
usuario
propiedad
superusuario
bit
SETUID
activado
problemas
potenciales
seguridad
dichos
archivos
adquieren
poderes
superusuario
ejecu-
tados
usuario
esfuerzo
reunir
lista
extensa
situaciones
técnicamente
legales
peculiares
valer
pena
reportar
párrafos
anteriores
analizado
problema
proteger
usuario
fallas
sistemas
archivos
preocupan
proteger
usuario
usuario
escribir
rm
.o
quitar
archivos
terminen
.o
archivos
objeto
generados
compilador
escribe
accidente
rm
.o
306
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
307
observe
espacio
asterisco
rm
eliminará
archivos
directorio
actual
quejará
encontrar
.o
MS-DOS
sistemas
remueve
archivo
ocurre
establece
bit
directorio
nodo-i
mar-
ca
archivo
removido
devuelven
bloques
disco
lista
bloques
libres
has-
ta
realmente
necesiten
usuario
descubre
error
inmediato
ejecutar
programa
utilería
especial
des-remueve
restaura
archivos
removidos
Windows
archivos
remueven
colocan
papelera
reciclaje
directorio
espe-
cial
recuperar
necesidad
re-
clama
espacio
almacenamiento
realmente
remuevan
directorio
4.4.4
Rendimiento
sistema
archivos
acceso
disco
lento
acceso
memoria
leer
palabra
memoria
32
bits
requerir
10
nseg
lectura
disco
duro
100
MB
seg
lenta
palabra
32
bits
agregar
10
mseg
búsqueda
pista
esperar
coloque
sector
deseado
cabeza
lectura
necesita
palabra
acceso
memoria
orden
millón
rápido
acceso
disco
resultado
diferencia
tiempo
acceso
sistemas
archivos
diseñado
optimizaciones
mejorar
ren-
dimiento
sección
hablaremos
caché
técnica
común
utilizada
reducir
accesos
disco
caché
bloques
caché
búfer
caché
deriva
francés
cacher
significa
ocultar
contexto
caché
colección
bloques
pertenecen
lógicamente
disco
mantienen
memoria
cuestiones
rendimiento
utilizar
algoritmos
administrar
caché
algoritmo
común
ve-
rificar
peticiones
lectura
bloque
necesario
caché
pe-
tición
lectura
satisfacer
necesidad
acceder
disco
bloque
caché
lee
caché
copia
necesario
peticiones
poste-
riores
bloque
satisfacer
caché
operación
caché
ilustra
figura
4-28
bloques
mi-
caché
necesita
forma
determinar
rapidez
bloque
presente
forma
usual
codificar
hash
dirección
dispositivo
disco
buscando
resultado
tabla
hash
bloques
valor
hash
encadenan
lista
enlaza-
seguir
cadena
colisiones
cargar
bloque
caché
llena
eliminar
bloque
volver
escribirlo
disco
modificado
trajo
situación
parecida
paginación
aplicar
algoritmos
reemplazo
página
usuales
descritos
capítulo
FIFO
oportunidad
LRU
diferencia
pla-
centera
paginación
caché
referencias
caché
relativamente
www.FreeLibros.meinfrecuentes
factible
mantener
bloques
orden
LRU
exacto
listas
enlazadas
figura
4-28
cadenas
colisión
empiezan
tabla
hash
lista
bidireccional
pasa
bloques
orden
bloque
reciente
frente
lista
bloque
reciente
referencia
bloque
quitar
posición
lista
bidireccio-
nal
colocarse
forma
mantener
orden
LRU
exacto
desgracia
desventaja
situación
LRU
exacto
resulta
deseable
problema
fallas
con-
sistencia
sistema
archivos
vimos
sección
bloque
crítico
bloque
nodos-i
lee
caché
modifica
vuelve
escribir
disco
fa-
lla
dejará
sistema
archivos
inconsistente
bloque
nodos-i
coloca
fi-
nal
cadena
LRU
pasar
tiempo
llegue
frente
vuelva
escribir
disco
raro
haga
referencia
bloques
bloques
nodos-i
ve-
ces
intervalo
corto
tiempo
consideraciones
conllevan
esquema
LRU
mo-
dificado
tomando
factores
probable
bloque
necesite
bloque
esencial
consistencia
sistema
archivos
ambas
preguntas
bloques
dividir
categorías
bloques
nodos-i
bloques
indirectos
bloques
directorios
bloques
datos
llenos
bloques
datos
parcialmen-
llenos
bloques
necesiten
pasan
frente
pasar
lista
LRU
búferes
reutilizarán
rapidez
bloques
necesitarse
bloque
parcialmente
lleno
escribiendo
pasan
lista
permanecerán
tiempo
pregunta
independiente
bloque
esencial
consisten-
cia
sistema
archivos
básicamente
bloques
datos
modificado
escribirse
inmediato
disco
importar
extremo
lista
LRU
esté
coloca-
308
SISTEMAS
ARCHIVOS
CAPÍTULO
MRU)Tabla
hash
Frente
LRU
Figura
4-28
Estructuras
datos
caché
búfer
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
309
do
escribir
bloques
críticos
rapidez
reducimos
forma
considerable
probabilidad
falla
estropee
sistema
archivos
usuario
inconforme
archivos
arruina
falla
probable
esté
inconforme
pierde
sistema
archivos
medida
mantener
intacta
integridad
sistema
archivos
inde-
seable
mantener
bloques
datos
caché
tiempo
escribirlos
Conside-
re
situación
apremiante
alguien
utiliza
computadora
personal
escribir
libro
escritor
indica
forma
periódica
editor
escriba
disco
archivo
editando
probabilidad
esté
caché
disco
sistema
falla
estructura
sistema
archivos
volverá
corrupta
per-
derá
trabajo
situación
necesita
ocurrir
frecuencia
usuario
esté
mo-
lesto
sistemas
utilizan
esquemas
lidiar
forma
utilizada
UNIX
ha-
cer
llamada
sistema
sync
obligue
escriban
bloques
modificados
disco
inmediato
sistema
arranca
programa
conocido
comúnmente
update
inicia
plano
permanecer
ciclo
emitiendo
llamadas
sync
permaneciendo
inactivo
30
segundos
llamada
resultado
pier-
den
30
segundos
trabajo
falla
Windows
llamada
sistema
equivalente
sync
conocida
FlushFileBuffers
estrategia
aspectos
esquema
UNIX
aspectos
hacía
escribir
bloque
modificado
disco
escrito
caché
ca-
chés
bloques
modificados
escriben
inmediato
disco
conocen
co-
mo
cachés
escritura
inmediata
Requieren
operaciones
disco
cachés
escritura
inmediata
diferencia
esquemas
programa
escribe
bloque
lle-
KB
carácter
UNIX
recolectará
caracteres
caché
escribirá
bloque
disco
30
segundos
bloque
elimine
caché
caché
escritura
inmediata
acceso
disco
carácter
escrito
mayoría
programas
utilizan
búfer
interno
generalmente
escriben
carác-
ter
línea
unidad
llamada
sistema
write
consecuencia
diferencia
estrategia
cachés
sacar
disco
flexible
sistema
UNIX
llamada
sync
perderán
da-
tos
frecuencia
obtendrá
sistema
archivos
corrupto
caché
escritu-
ra
inmediata
surge
problema
distintas
estrategias
eligieron
UNIX
desarrolló
entorno
discos
discos
duros
removibles
sistema
archivos
Windows
heredó
MS-DOS
empezó
mundo
disco
flexible
medida
discos
duros
convirtieron
norma
método
UNIX
eficiencia
confiabilidad
convirtió
norma
utiliza
Windows
discos
duros
NTFS
toma
medidas
bitácora
me-
jorar
confiabilidad
vimos
sistemas
operativos
integran
caché
búfer
caché
páginas
especial
atractivo
soportan
archivos
asociados
memoria
archivo
asocia
www
FreeLibros.me310
SISTEMAS
ARCHIVOS
CAPÍTULO
memoria
páginas
memoria
paginaron
ba-
jo
demanda
Dichas
páginas
distintas
bloques
archivos
caché
búfer
caso
tratar
forma
caché
bloques
archivos
co-
mo
páginas
Lectura
adelantada
bloque
técnica
mejorar
rendimiento
percibido
sistema
archivos
tratar
colocar
bloques
caché
necesiten
incrementar
proporción
aciertos
especial
archivos
leen
forma
secuencial
pide
sistema
archivos
produzca
bloque
archivo
termina
realiza
verificación
di-
simulada
caché
bloque
/H110011
planifica
lectura
bloque
/H110011
esperanza
necesite
llegado
caché
me-
camino
estrategia
lectura
adelantada
funciona
archivos
leen
forma
secuencial
accede
archivo
forma
aleatoria
lectura
adelantada
ayu-
afecta
ocupa
ancho
banda
disco
leer
bloques
inútiles
eliminar
blo-
ques
potencialmente
útiles
caché
ocupando
ancho
banda
disco
escribirlos
vuelta
disco
sucios
vale
pena
lectura
adelantada
siste-
ma
archivos
registro
patrones
acceso
archivo
abierto
ejem-
plo
bit
asociado
archivo
archivo
acceso
secuencial
acceso
aleatorio
principio
archivo
recibe
beneficio
du-
coloca
acceso
secuencial
realiza
búsqueda
bit
desactiva
empiezan
lecturas
secuenciales
bit
activa
es-
ta
sistema
archivos
estimación
razonable
acerca
utilizar
lectura
adelantada
equivoca
desastre
ancho
banda
disco
desperdiciado
Reducción
movimiento
brazo
disco
caché
lectura
adelantada
únicas
formas
incrementar
rendimiento
sistema
archivos
técnica
importante
reducir
cantidad
movimiento
brazo
dis-
co
colocar
bloques
tengan
probabilidad
utilizarse
secuencia
cerca
preferencia
cilindro
escribe
archivo
salida
sistema
archivos
asignar
bloques
demanda
bloques
libres
registran
mapa
bits
mapa
bits
memoria
principal
senci-
llo
elegir
bloque
libre
cerca
bloque
lista
bloques
libres
disco
difícil
asignar
bloques
estén
cerca
lista
bloques
libres
cabo
agrupación
bloques
truco
almacenamiento
disco
bloques
grupos
blo-
ques
consecutivos
sectores
consisten
512
bytes
sistema
utilizar
bloques
www
FreeLibros.meSECCIÓN
4.4
ADMINISTRACIÓN
OPTIMIZACIÓN
SISTEMAS
ARCHIVOS
311
KB
sectores
asignar
almacenamiento
disco
unidades
bloques
sectores
bloques
disco
KB
caché
seguiría
utilizando
bloques
KB
transferencias
disco
seguirían
KB
leer
archivo
forma
se-
cuencial
sistema
estaría
inactivo
reduciría
número
búsquedas
factor
mejoraría
rendimiento
forma
considerable
variación
tema
tomar
posicionamiento
rotacional
asignar
bloques
sistema
intenta
colo-
car
bloques
consecutivos
archivo
cilindro
factor
reduce
rendimiento
sistemas
utilizan
nodos-i
cosa
co-
mo
leer
archivo
corto
requieren
accesos
nodo-i
bloque
colocación
común
nodos-i
muestra
figura
4-29(a
nodos
cerca
principio
disco
distancia
promedio
nodo-i
bloques
mitad
número
cilindros
requieren
bús-
quedas
extensas
nodos-i
localizan
cerca
principio
disco
disco
divide
grupos
cilindros
nodos-i
Grupo
cilindros
Figura
4-29
nodos-i
colocados
principio
disco
Disco
dividido
grupos
cilindros
bloques
nodos-i
mejora
fácil
rendimiento
colocar
nodos-i
disco
hacer-
principio
reduce
búsqueda
promedio
nodo-i
bloque
factor
idea
muestra
figura
4-29(b
dividir
disco
grupos
ci-
lindros
nodos-i
bloques
lista
bloques
libres
McKusick
colabora-
dores
1984
crear
archivo
elegir
nodo-i
intento
encontrar
bloque
grupo
cilindros
nodo-i
disponible
utiliza
bloque
grupo
cilindros
cercano
4.4.5
Desfragmentación
discos
sistema
operativo
instala
programas
archivos
necesita
instalan
forma
consecutiva
empezando
principio
disco
siguiendo
directamente
espacio
libre
disco
unidad
contigua
www.FreeLibros.mede
archivos
instalados
medida
transcurre
tiempo
crean
eliminan
ar-
chivos
generalmente
disco
fragmenta
archivos
huecos
esparcidos
par-
tes
consecuencia
crea
archivo
bloques
utilizan
esparcidos
disco
produce
rendimiento
pobre
rendimiento
restaurar
moviendo
archivos
hacerlos
contiguos
colocando
to-
do
espacio
libre
mayoría
regiones
contiguas
disco
Windows
programa
llamado
defrag
realiza
usuarios
Windows
ejecutarlo
forma
regular
desfragmentación
funciona
sistemas
archivos
can-
tidad
espacio
libre
región
continua
partición
espacio
permite
pro-
grama
desfragmentación
seleccionar
archivos
fragmentados
cerca
inicio
partición
copiando
bloques
espacio
libre
acción
libera
bloque
contiguo
espacio
cerca
inicio
partición
colocar
archivos
originales
for-
ma
contigua
proceso
repetir
pedazo
espacio
disco
sucesivo
archivos
mover
incluyendo
archivo
paginación
hibernación
registro
bitácora
administración
requerida
problemática
ayuda
sistemas
áreas
contiguas
tamaño
fijo
formas
desfragmentar
única
falta
movilidad
representa
problema
encuentran
cerca
partición
usuario
desea
reducir
tamaño
única
resolver
problema
quitar
archivos
cambiar
tamaño
partición
recrearlos
sistemas
archivos
Linux
especial
ext2
ext3
general
sufren
desfragmentación
sistemas
Windows
forma
seleccionan
bloques
disco
raras
requiere
desfragmentación
manual
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
siguientes
secciones
analizaremos
sistemas
archivos
ejemplo
varían
simples
sofisticados
sistemas
modernos
UNIX
siste-
ma
archivos
nativo
Windows
Vista
cubren
capítulo
acerca
UNIX
capítulo
10
capítulo
acerca
Windows
Vista
capítulo
11
cubriremos
sistemas
em-
bargo
continuación
examinaremos
predecesores
4.5.1
Sistemas
archivos
CD-ROM
ejemplo
sistema
archivos
considerar
sistemas
archi-
vos
utilizados
CD-ROMs
sistemas
particularmente
simples
di-
señados
medios
escribir
cosas
ejemplo
provisión
registro
bloques
libres
CD-ROM
312
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
313
liberar
agregar
archivos
fabricar
disco
continuación
analizaremos
ti-
po
principal
sistema
archivos
CD-ROM
extensiones
años
CD-ROM
debut
introdujo
CD-R
CD
regraba-
ble
diferencia
CD-ROM
agregar
archivos
quemado
inicial
és-
tos
simplemente
adjuntan
CD-R.
archivos
eliminan
directorio
actualizar
ocultar
archivos
existentes
consecuencia
sistema
ar-
chivos
adjuntar
alteran
propiedades
fundamentales
especial
espa-
cio
trozo
contiguo
CD
sistema
archivos
ISO
9660
estándar
común
sistemas
archivos
CD-ROM
adoptó
Estándar
In-
ternacional
1998
nombre
ISO
9660
CD-ROM
actual-
mente
mercado
compatible
estándar
extensiones
analizaremos
continuación
objetivos
estándar
CD-ROM
pudiera
leer
computadoras
independientemente
orden
bytes
utilizado
sis-
tema
operativo
emplee
consecuencia
impusieron
limitaciones
siste-
ma
archivos
sistemas
operativos
débiles
MS-DOS
pudieran
leerlo
CD-ROMs
cilindros
concéntricos
discos
magnéticos
espiral
continua
contiene
bits
secuencia
lineal
posibles
búsquedas
espiral
bits
espiral
dividen
bloques
lógi-
cos
conocidos
sectores
lógicos
2352
bytes
preám-
bulos
corrección
errores
gasto
adicional
porción
carga
bloque
lógico
2048
bytes
utilizan
música
CDs
ranuras
introducción
ranu-
ras
salida
espacios
pistas
utilizan
CD-ROMs
datos
posición
bloque
espiral
expresa
minutos
segundos
convertir
número
bloque
lineal
utilizando
factor
conversión
seg
/H1100575
bloques
ISO
9660
soporta
conjuntos
CD-ROMs
16
/H110021
CDs
conjunto
CD-ROMs
individuales
particionar
volúmenes
lógicos
particiones
conti-
nuación
concentraremos
ISO
9660
CD-ROM
particiones
CD-ROM
empieza
16
bloques
cuya
función
definida
estándar
ISO
9660
fabricante
CD-ROMs
utilizar
área
proporcionar
programa
arranque
permitir
computadora
inicie
CD-ROM
propósi-
to
continuación
bloque
contiene
descriptor
volumen
primario
con-
información
general
acerca
CD-ROM
información
incluye
identificador
sistema
32
bytes
identificador
volumen
32
bytes
identificador
publicador
128
bytes
identificador
preparador
datos
128
bytes
fabricante
llenar
cam-
pos
forma
desee
utilizar
letras
mayúsculas
dígi-
tos
número
reducido
signos
puntuación
asegurar
compatibilidad
plataformas
www
FreeLibros.meEl
descriptor
volumen
primario
contiene
nombres
archivos
contener
resumen
aviso
copyright
información
bibliográfica
respectivamente
números
clave
presentes
incluyendo
tamaño
bloque
lógico
gene-
ral
2048
permiten
4096
8192
potencias
casos
número
bloques
CD-ROM
fechas
creación
expiración
CD-ROM
des-
criptor
volumen
primario
contiene
entrada
directorio
directorio
raíz
indica
encontrar
CD-ROM
bloque
empieza
directorio
localizar
resto
sistema
archivos
descriptor
volumen
primario
CD-ROM
contener
descriptor
vo-
lumen
suplementario
Contiene
información
similar
primario
importan-
cia
directorio
raíz
directorios
relacionados
consiste
número
varia-
ble
entradas
contiene
bit
marca
en-
tradas
directorio
longitud
variable
entrada
directorio
10
12
campos
ASCII
campos
numéricos
binario
campos
binarios
codificados
formato
little
endian
utiliza
Pen-
tiums
ejemplo
formato
big
endian
utiliza
SPARCs
ejemplo
número
16
bits
utiliza
bytes
número
32
bits
utiliza
bytes
codificación
redundante
necesario
evitar
lastimar
sentimientos
cualquiera
desarrolló
estándar
estándar
hubiera
dictado
formato
little
endian
personas
empresas
cuyos
productos
tuvieran
formato
big
endian
hubieran
sen-
tido
ciudadanos
clase
hubieran
aceptado
estándar
contenido
emocio-
nal
CD-ROM
cuantificarse
medirse
exactamente
kilobytes
hora
espacio
desperdiciado
formato
entrada
directorio
ISO
9660
ilustra
figura
4-30
entra-
das
directorios
longitudes
variables
campo
byte
indica
larga
entrada
byte
definido
bit
orden
izquierda
evitar
cual-
quier
ambigüedad
314
SISTEMAS
ARCHIVOS
CAPÍTULO
11
Ubicación
archivo
Longitud
registro
atributo
extendido
Longitud
entrada
directorio
Tamaño
archivo
Fecha
hora
Número
CD
Nombre
archivo
Sist
4-15
Relleno
Banderas
Intercalado
Nombre
base
Ext
Ver•
Bytes
Figura
4-30
entrada
directorio
ISO
9660
entradas
directorio
opcional
atributos
extendidos
utiliza
característica
byte
indica
largos
atributos
extendidos
www
FreeLibros.meSECCIÓN
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
315
continuación
viene
bloque
inicial
archivo
archivos
almacenan
se-
ries
contiguas
bloques
ubicación
archivo
completamente
especificada
bloque
inicial
tamaño
contenido
campo
fecha
hora
grabó
CD-ROM
almacena
campo
bytes
se-
parados
año
mes
hora
minuto
zona
horaria
años
empiezan
contar
1900
significa
CD-ROM
sufrirán
problema
año
2156
año
2155
1900
problema
retrasado
definir
origen
tiempo
1988
año
adoptó
estándar
hubiera
problema
hubiera
pospuesto
2244
88
años
extra
útiles
campo
Banderas
contiene
bits
misceláneos
incluyendo
ocultar
en-
trada
listados
característica
copió
MS-DOS
diferenciar
entra-
archivo
entrada
directorio
permitir
atributos
extendidos
marcar
entrada
directorio
bits
pre-
sentes
campo
importancia
campo
intercala-
ción
partes
archivos
utiliza
versión
simple
ISO
9660
veremos
detalle
campo
indica
CD-ROM
archivo
permite
entra-
directorio
CD-ROM
haga
referencia
archivo
ubicado
CD-ROM
con-
forma
crear
directorio
maestro
CD-ROM
liste
archivos
CD-ROM
conjunto
completo
campo
marcado
figura
4-30
proporciona
tamaño
nombre
archivo
bytes
seguido
nombre
archivo
nombre
archivo
consiste
nombre
base
punto
extensión
punto
coma
número
versión
binario
bytes
nombre
base
extensión
utilizar
letras
mayúsculas
dígitos
carácter
guión
ba-
jo
caracteres
prohibidos
asegurar
computadora
mane-
jar
nombre
archivo
nombre
base
caracteres
extensión
caracteres
opciones
impusieron
necesidad
compatibi-
lidad
MS-DOS
nombre
archivo
presente
directorio
siem-
pre
número
versión
distinto
campos
presentes
campo
Relleno
utiliza
forzar
entrada
directorio
número
par
bytes
alinear
campos
numéricos
entradas
subsiguientes
límites
bytes
necesita
relleno
utiliza
byte
úl-
timo
campo
sistema
sist
función
tamaño
definidos
número
par
bytes
distintos
sistemas
utilizan
formas
ejem-
plo
Macintosh
mantiene
banderas
Finder
entradas
directorio
listan
orden
alfabético
primeras
entrada
directorio
padre
aspecto
similares
entradas
directorio
UNIX
archivos
necesitan
or-
den
directorio
límite
explícito
número
entradas
directorio
límite
profundidad
anidamiento
máxima
profundidad
anidamiento
directorios
límite
estableció
forma
arbitraria
simplificar
implementa-
ciones
www
FreeLibros.meISO
9660
define
conoce
niveles
nivel
restrictivo
especi-
fica
nombres
archivos
limitados
/H110013
caracteres
requiere
archivos
contiguos
visto
especifica
nombres
directo-
rio
limitados
caracteres
extensiones
nivel
maximiza
pro-
babilidades
CD-ROM
leer
computadoras
nivel
reduce
restricción
longitud
Permite
archivos
directorios
tengan
nom-
bres
31
caracteres
siguen
teniendo
conjunto
caracteres
nivel
utiliza
límites
nombres
nivel
reduce
parcialmente
res-
tricción
archivos
contiguos
nivel
archivo
consistir
secciones
fragmentos
serie
contigua
bloques
serie
ocurrir
archivo
ocurrir
archivos
repiten
trozos
datos
archivos
nivel
ofrece
optimización
espacio
requerir
datos
estén
presentes
Extensiones
Rock
Ridge
visto
ISO
9660
altamente
restrictivo
formas
salió
mercado
personas
comunidad
UNIX
empezaron
trabajar
extensión
representar
sistemas
archivos
UNIX
CD-ROM
extensiones
llamaron
Rock
Ridge
honor
ciudad
película
Blazing
Saddles
Gene
Wilder
pro-
bablemente
miembros
comité
gustó
filme
extensiones
utilizan
campo
sistema
CD-ROMs
Rock
Ridge
pue-
leer
computadora
campos
retienen
significado
normal
ISO
9660
sistema
esté
extensiones
Rock
Ridge
ignora
ve
CD-ROM
normal
extensiones
dividen
siguientes
campos
PX
Atributos
POSIX
PN
Números
dispositivos
mayores
menores
SL
Vínculo
simbólico
NM
Nombre
alternativo
CL
Ubicación
hijo
PL
Ubicación
padre
RE
Reubicación
TF
Estampado
tiempo
campo
PX
contiene
bits
permiso
estándar
rwxrwxrwx
UNIX
propietario
gru-
po
contiene
bits
contenidos
palabra
bits
SETUID
SETGID
etcétera
316
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
317
permitir
dispositivos
puros
representen
CD-ROM
presente
campo
PN
contiene
números
dispositivos
mayores
menores
asociados
archivo
forma
contenido
directorio
/dev
escribir
CD-ROM
reconstruir-
correcta
sistema
destino
campo
SL
vínculos
simbólicos
Permite
archivo
sistema
archi-
vos
haga
referencia
archivo
sistema
archivos
distinto
campo
importante
NM
campo
permite
asociar
nombre
archivo
nombre
sujeto
restricciones
conjunto
caracteres
longitud
ISO
9660
expresar
nombres
archivos
UNIX
arbitrarios
CD-ROM
siguientes
campos
utilizan
conjunto
sobrepasar
límite
ISO
9660
directorios
niveles
anidamiento
especi-
ficar
directorio
reubicar
indicar
posición
jerarquía
efecto
solucionar
límite
profundidad
artificial
campo
TF
contiene
estampados
tiempo
incluidos
nodo-i
UNIX
hora
creó
archivo
hora
modificó
ho-
ra
accedió
conjunto
extensiones
copiar
sistema
archivos
UNIX
CD-ROM
restaurarlo
correcta
siste-
ma
Extensiones
Joliet
comunidad
UNIX
único
grupo
quería
extender
ISO
9660
Mi-
crosoft
pareció
restrictivo
MS-DOS
Microsoft
causó
restricciones
lugar
Microsoft
inventó
extensiones
llamó
Joliet
extensiones
diseñadas
permitir
sis-
temas
archivos
Windows
copiaran
CD-ROM
restauraran
precisamente
forma
diseñó
Rock
Ridge
UNIX
programas
ejecutan
Windows
utilizan
CD-ROMs
soporte
Joliet
incluyendo
programas
queman
CDs
grabables
general
programas
ofrecen
elección
diversos
niveles
ISO
9660
Joliet
principales
extensiones
proporciona
Joliet
Nombres
archivos
largos
Conjunto
caracteres
Unicode
niveles
anidamiento
directorios
Nombres
directorios
extensiones
extensión
permite
nombres
archivos
64
caracteres
extensión
permite
conjunto
caracteres
Unicode
nombres
archivos
extensión
importante
software
destinado
países
utilizan
alfabeto
latín
Japón
Israel
Grecia
caracteres
Unicode
bytes
nombre
archivo
Joliet
ocupa
128
bytes
www
FreeLibros.meAl
Rock
Ridge
Joliet
elimina
limitación
anidamiento
directorios
di-
rectorios
anidar
tantos
niveles
necesario
nombres
directorios
extensiones
incluyó
extensión
raras
directorios
Windows
utilizan
extensiones
hagan
4.5.2
sistema
archivos
MS-DOS
sistema
archivos
MS-DOS
sistemas
incluyeron
IBM
PC
sistema
principal
Windows
98
Windows
soporte
Windows
2000
Windows
XP
Windows
Vista
estándar
PCs
discos
flexibles
sistema
extensión
FAT-32
teniendo
va-
rios
sistemas
incrustados
mayoría
cámaras
digitales
utilizan
reproductores
MP3
utilizan
exclusiva
popular
iPod
Apple
utiliza
sistema
archivos
predeterminado
hackers
conocedores
volver
formato
iPod
instalar
sis-
tema
archivos
distinto
número
dispositivos
electrónicos
utilizan
sistema
archi-
vos
MS-DOS
inmensamente
actualidad
comparación
momento
duda
número
dispositivos
utilizan
sistema
archi-
vos
NTFS
moderno
única
razón
vale
pena
analizarlo
detalle
leer
archivo
programa
MS-DOS
llamada
sistema
open
obtener
manejador
archivo
llamada
sistema
open
especifica
ruta
absoluta
relativa
directorio
trabajo
actual
realiza
búsqueda
ru-
ta
componente
componente
localiza
directorio
lee
memoria
busca
archivo
desea
abrir
directorios
MS-DOS
tamaños
variables
utilizan
entrada
directo-
rio
tamaño
fijo
32
bytes
formato
entrada
directorio
MS-DOS
muestra
figura
4-31
Contiene
nombre
archivo
atributos
fecha
hora
creación
bloque
inicial
tamaño
exacto
archivo
nombres
archivo
menores
/H110013
caracteres
jus-
tifican
izquierda
rellenan
espacios
derecha
campo
separado
cam-
po
Atributos
contiene
bits
indicar
archivo
lectura
necesita
archivarse
oculto
archivo
sistema
escribir
archivos
só-
lectura
protegerlos
daños
accidentales
bit
archivado
función
sistema
operativo
actual
MS-DOS
examina
establece
intención
permi-
tir
programas
archivos
nivel
usuario
desactiven
archivar
archivo
programas
activen
modifiquen
archivo
programa
respaldo
só-
examinar
bit
atributo
archivo
archivos
respaldar
bit
oculto
establecer
evitar
archivo
aparezca
listados
directorios
principal
evitar
confundir
usuarios
novatos
archivos
entiendan
bit
sistema
oculta
archivos
archivos
sistema
eliminarse
accidental
comando
componentes
principales
MS-DOS
activado
bit
entrada
directorio
contiene
fecha
hora
creación
archivo
mo-
dificación
hora
precisión
±2
segundos
almacena
cam-
po
bytes
almacenar
65,536
valores
únicos
contiene
86,400
segundos
318
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
319
campo
tiempo
subdivide
segundos
bits
minutos
bits
horas
bits
fecha
usando
subcampos
bits
mes
bits
año
1980
bits
nú-
mero
bits
año
hora
empiezan
1980
año
expresarse
2107
MS-DOS
integrado
problema
año
2108
evitar
catástrofe
usuarios
MS-DOS
empezar
conformidad
año
2108
MS-DOS
hubiera
utilizado
campos
combinados
fecha
hora
contador
segundos
32
bits
representado
exactitud
hubiera
retrasado
catástrofe
2116
MS-DOS
almacena
tamaño
archivo
número
32
bits
teoría
archivos
GB
límites
describen
conti-
nuación
restringen
tamaño
máximo
archivo
GB
sorprendente
utiliza
entrada
10
bytes
MS-DOS
bloques
archivos
tabla
asignación
ar-
chivos
FAT
memoria
principal
entrada
directorio
contiene
número
blo-
archivo
número
utiliza
índice
FAT
entradas
64
KB
memoria
principal
seguir
cadena
encontrar
bloques
operación
FAT
ilustra
figura
4-12
sistema
archivos
FAT
viene
versiones
FAT-12
FAT-16
FAT-32
dependiendo
bits
contenga
dirección
disco
realidad
FAT-32
término
equi-
vocado
utilizan
28
bits
menor
orden
direcciones
disco
Debería
ha-
berse
llamado
FAT-28
potencias
oyen
FATs
bloque
disco
establecer
múltiplo
512
bytes
po-
siblemente
distinto
partición
conjunto
tamaños
bloque
permitidos
lla-
mados
tamaños
grupo
Microsoft
distinto
variante
versión
MS-DOS
utilizaba
FAT-12
bloques
512
bytes
proporcionar
tamaño
partición
má-
ximo
12
/H11003512
bytes
realidad
4086
512
bytes
10
direccio-
nes
disco
utilizaban
marcadores
especiales
archivo
bloque
defectuoso
etc.
parámetros
tamaño
máximo
partición
disco
aproxima-
damente
MB
tamaño
tabla
FAT
memoria
4096
entradas
bytes
Utilizar
entrada
tabla
12
bits
hubiera
lento
sistema
funcionaba
discos
flexibles
salieron
mercado
dis-
cos
duros
convirtió
problema
Microsoft
resolvió
problema
permitir
tamaños
blo-
adicionales
KB
KB
KB
cambio
preservó
estructura
tamaño
tabla
FAT-12
permitía
particiones
disco
16
MB
Tamaño
Extensión
Atributos
Reservado
Fecha
Número
bloque
Bytes
10
Nombre
archivo
Hora
Figura
4-31
entrada
directorio
MS-DOS
www
FreeLibros.me320
SISTEMAS
ARCHIVOS
CAPÍTULO
MS-DOS
soportaba
particiones
disco
unidad
disco
sis-
tema
archivos
FAT-12
podía
operar
discos
64
MB
allá
capacidad
po-
dría
fallar
ocurrió
introducción
FAT-16
apuntadores
disco
16
bits
permitieron
tamaños
bloque
KB
16
KB
32
KB
32,768
potencia
representar
16
bits
tabla
FAT-16
ocupaba
128
KB
me-
moria
principal
tiempo
memorias
dispo-
nibles
utilizó
ampliamente
reemplazó
rapidez
sistema
archivos
FAT-12
partición
disco
podía
soportar
FAT-16
GB
64
entradas
32
KB
disco
GB
particiones
GB
cartas
comerciales
límite
problema
almacenar
video
digital
uti-
lizando
estándar
DV
archivo
GB
contiene
minutos
video
consecuen-
cia
disco
PC
soportar
particiones
video
almacenar
disco
36
minutos
importar
disco
límite
significa
video
editar
línea
me-
18
minutos
necesitan
archivos
entrada
salida
Empezando
versión
Windows
95
introdujo
sistema
archivos
FAT-32
direcciones
disco
28
bits
versión
MS-DOS
operaba
Windows
95
adaptó
soporte
FAT-32
sistema
particiones
teoría
28
/H11003215
bytes
realidad
limitadas
TB
2048
GB
sistema
interna
tamaños
particiones
sectores
512
bytes
utilizando
número
32
bits
/H11003232
TB
tamaño
máximo
partición
diversos
tamaños
bloque
tipos
FAT
muestran
figura
4-32
Tamaño
bloque
Figura
4-32
Tamaño
máximo
partición
distintos
tamaños
bloque
cuadros
vacíos
representan
combinaciones
prohibidas
soportar
discos
sistema
archivos
FAT-32
venta-
jas
comparación
FAT-16
lugar
disco
GB
utiliza
FAT-32
partición
utiliza
FAT-16
particiones
aparece
usua-
rio
Windows
unidades
disco
lógicas
Depende
usuario
decidir
archivo
colocar
unidad
registro
encuentran
cosas
ventaja
FAT-32
FAT-16
partición
disco
tamaño
utilizar
tamaño
bloque
pequeño
ejemplo
partición
disco
GB
www
FreeLibros.meSECCIÓN
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
321
FAT-16
utilizar
bloques
32
KB
contrario
64
direcciones
disco
dispo-
nibles
cubrir
partición
contrario
FAT-32
utilizar
ejemplo
blo-
ques
KB
partición
disco
GB
ventaja
tamaño
bloque
pequeño
mayoría
archivos
menores
32
KB
tamaño
bloque
32
KB
archivo
10
bytes
ocupa
32
KB
espacio
disco
archivo
promedio
KB
bloque
32
KB
desperdiciarán
3/4
partes
disco
eficiente
utilizarlo
archivo
KB
bloque
KB
desperdicio
disco
precio
pagar
FAT
ocupa
RAM
bloque
KB
partición
disco
GB
512
bloques
FAT
512
entra-
das
memoria
ocupan
MB
RAM
MS-DOS
utiliza
FAT
bloques
disco
libres
bloque
esté
asignado
momento
marca
código
especial
MS-DOS
ne-
cesita
bloque
disco
busca
FAT
entrada
contenga
código
tan-
to
requiere
mapa
bits
lista
bloques
libres
4.5.3
sistema
archivos
V7
UNIX
primeras
versiones
UNIX
tenian
sistema
archivos
multiusuario
sofis-
ticado
derivaba
MULTICS
continuación
analizaremos
sistema
archivos
V7
diseñado
PDP-11
famoso
UNIX
capítulo
10
examinaremos
sistema
archivos
UNIX
moderno
contexto
Linux
sistema
archivos
forma
árbol
empieza
directorio
raíz
adición
vínculos
formar
gráfico
acíclico
dirigido
nombres
archivos
14
caracteres
contener
carácter
ASCII
separador
componentes
ruta
NUL
utiliza
rellenar
nombres
meno-
res
14
caracteres
NUL
valor
numérico
entrada
directorio
UNIX
contiene
entrada
archivo
directorio
entrada
extremo
simple
UNIX
utiliza
esquema
nodos-i
ilustrado
fi-
gura
4-13
entrada
directorio
contiene
campos
nombre
archivo
14
bytes
número
nodo-i
archivo
bytes
muestra
figura
4-33
paráme-
tros
limitan
número
archivos
sistema
archivos
64
K.
nodo-i
figura
4-13
nodos-i
UNIX
contienen
atributos
contienen
tamaño
archivo
tiempos
hora
creación
acceso
últi-
ma
modificación
propietario
grupo
información
protección
número
entradas
directorio
apuntan
nodo-i
campo
necesita
vínculos
Ca-
crea
vínculo
nodo-i
nodo-i
incrementa
elimina
vínculo
decrementa
llega
nodo-i
reclama
bloques
disco
devuelven
lista
bloques
libres
bloques
disco
utiliza
generalización
figura
4-13
pa-
ra
manejar
archivos
primeras
10
direcciones
disco
almacenan
nodo-i
archivos
pequeños
información
necesaria
www.FreeLibros.mejusto
nodo-i
obtiene
disco
memoria
principal
momento
abrir
archivo
archivos
direcciones
nodo-i
dirección
blo-
disco
llamado
bloque
indirecto
sencillo
bloque
contiene
direcciones
disco
adicio-
nales
suficiente
dirección
nodo-i
llamada
bloque
indirecto
doble
contiene
dirección
bloque
contiene
lista
bloques
indirectos
sencillos
bloques
indirectos
sencillos
apunta
cientos
bloques
datos
suficiente
utilizar
bloque
indirecto
triple
panorama
completo
muestra
figura
4-34
322
SISTEMAS
ARCHIVOS
CAPÍTULO
Figura
4-33
entrada
directorio
UNIX
V7
Figura
4-34
nodo-i
UNIX
abre
archivo
sistema
archivos
tomar
nombre
archivo
suminis-
trado
localizar
bloques
disco
consideremos
busca
nombre
ruta
www
FreeLibros.meSECCIÓN
4.5
EJEMPLOS
SISTEMAS
ARCHIVOS
323
/usr
ast
mbox
Utilizaremos
UNIX
ejemplo
algoritmo
básicamente
sistemas
directorios
jerárquicos
lugar
sistema
archivos
locali-
za
directorio
raíz
UNIX
nodo-i
localiza
lugar
fijo
disco
nodo-i
localiza
directorio
raíz
disco
digamos
bloque
lee
directorio
raíz
busca
componente
ruta
usr
directorio
raíz
encontrar
número
nodo-i
archivo
/usr
acción
localizar
nodo-i
par-
tir
número
simple
ubicación
fija
disco
nodo-i
sistema
localiza
directorio
/usr
busca
componente
ast
entrada
ast
nodo-i
directorio
/usr
ast
nodo-i
buscar
mbox
directorio
nodo-i
archivo
lee
memoria
mantiene
cierra
archivo
proceso
búsqueda
ilustra
figura
4-35
Figura
4-35
pasos
buscar
/usr
ast
mbox
nombres
rutas
relativas
buscan
forma
absolutas
em-
pieza
directorio
trabajo
empezar
directorio
raíz
directorio
en-
tradas
colocan
crea
directorio
entrada
número
nodo-i
directorio
actual
entrada
número
nodo-i
directorio
padre
procedimiento
busca
/dick
prog.c
simplemente
busca
directorio
trabajo
en-
cuentra
número
nodo-i
directorio
padre
busca
dick
directorio
necesita
mecanismo
especial
manejar
nombres
sistema
directorios
con-
cierne
cadenas
ASCII
ordinarias
nombre
único
truco
directorio
raíz
apunta
www
FreeLibros.me4.6
INVESTIGACIÓN
ACERCA
SISTEMAS
ARCHIVOS
sistemas
archivos
atraído
investigación
partes
sistema
operativo
caso
sistemas
archivos
estándar
comprendidos
investigación
acerca
optimizar
administración
caché
búfer
Burnett
colaboradores
2002
Ding
colaboradores
2007
Gnaidy
colaborado-
res
2004
Kroeger
Long
2001
Pai
colaboradores
2000
Zhou
colaboradores
2001
es-
tá
realizando
trabajo
acerca
tipos
sistemas
archivos
sistemas
archivos
nivel
usuario
Mazières
2001
sistemas
archivos
flash
Gal
colaboradores
2005
sistemas
archivos
bitácora
Prabhakaran
colaboradores
2005
Stein
colabo-
radores
2001
sistemas
archivos
control
versiones
Cornell
colaboradores
2004
sistemas
archivos
Muthitacharoen
colaboradores
2002
sistema
archivos
Google
inusual
tolerancia
errores
Ghemawat
co-
laboradores
2003
interés
distintas
formas
buscar
cosas
sistemas
archivos
Padioleau
Ridoux
2003
área
obteniendo
atención
procedencia
registro
historial
datos
incluyendo
provinieron
propietario
transformado
Muniswarmy-Reddy
colaboradores
2006
Shah
colaboradores
2007
información
utilizar
formas
realización
respaldos
recibiendo
aten-
ción
Cox
colaboradores
2002
Rycroft
2006
tema
relacionado
recupe-
ración
Keeton
colaboradores
2006
relacionado
respaldos
proceso
mantener
datos
disponibles
útiles
décadas
Baker
colaboradores
2006
Maniatis
colaboradores
2003
confiabilidad
seguridad
lejos
problemas
solucionados
Greenan
Miller
2006
Wires
Feeley
2007
Wright
colaboradores
2007
Yang
colaboradores
2006
rendimiento
tema
investigación
Caudill
Gavrikovska
2006
Chiang
Huang
2007
Stein
2006
Wang
colabora-
dores
2006a
Zhang
Ghose
2007
4.7
RESUMEN
Visto
exterior
sistema
archivos
colección
archivos
directorios
operaciones
realizan
archivos
leer
escribir
directorios
pue-
den
crear
destruir
archivos
mover
directorio
mayoría
sis-
temas
archivos
modernos
soportan
sistema
directorios
jerárquico
directorios
subdirectorios
subdirectorios
forma
infinita
Visto
interior
sistema
archivos
apariencia
distinta
diseñadores
sistema
archivos
preocupar
acerca
forma
asigna
almacenamien-
to
sistema
registro
bloque
archivo
posibilidades
incluyen
archivos
contiguos
listas
enlazadas
ligadas
tablas
asignación
archivos
nodos-i
dis-
tintos
sistemas
estructuras
directorios
atributos
directo-
rios
ejemplo
nodo-i
espacio
disco
administrar
324
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
325
listas
bloques
libres
mapas
bits
confiabilidad
sistema
aumenta
vaciados
incrementales
programa
reparar
sistemas
archivos
enfer-
mos
rendimiento
sistema
archivos
importante
mejorarse
formas
in-
cluyendo
cachés
lectura
adelantada
colocación
cuidadosa
bloques
archivo
cerca
sistemas
archivos
estructurados
registro
mejoran
rendimiento
escrituras
unidades
ejemplos
sistemas
archivos
ISO
9660
MS-DOS
UNIX
difieren
formas
incluyendo
llevan
registro
bloques
archivo
estructura
directorios
administración
espacio
libre
disco
PROBLEMAS
sistemas
UNIX
archivos
ejecutables
archivos
a.out
empezaban
núme-
ro
mágico
específico
elegido
azar
archivos
empezaban
encabezado
seguido
segmentos
texto
datos
cree
eligió
número
específico
archivos
ejecutables
tipos
archivos
tenían
número
má-
gico
aleatorio
palabra
figura
4-4
atributos
longitud
registro
preocupa
sistema
ope-
rativo
absolutamente
esencial
llamada
sistema
openen
UNIX
serían
consecuencias
tenerla
sistemas
soportan
archivos
secuenciales
operación
rebobinar
ar-
chivos
sistemas
soportan
archivos
acceso
aleatorio
necesitan
sistemas
operativos
proporcionan
llamada
sistema
renamepara
archivo
nombre
acaso
diferencia
utilizar
llamada
cambiar
nombre
archivo
copiar
archivo
nombre
eliminando
archi-
vo
sistemas
asociar
archivo
memoria
restricciones
imponer
dichos
sistemas
implementa
asociación
parcial
sistema
operativo
simple
soporta
directorio
permite
directorio
arbi-
trariamente
archivos
nombres
archivos
arbitrariamente
largos
simularse
al-
go
aproximado
sistema
archivos
jerárquico
UNIX
Windows
acceso
aleatorio
realiza
llamada
especial
sistema
mue-
ve
apuntador
posición
actual
asociado
archivo
byte
específico
archivo
Proponga
alternativa
acceso
aleatorio
llamada
sistema
Considere
árbol
directorios
figura
4-8
/usr
jim
directorio
trabajo
nombre
ruta
absoluto
archivo
cuyo
nombre
ruta
relativo
/ast
10
asignación
contigua
archivos
produce
fragmentación
disco
menciona
tex-
to
espacio
bloque
disco
desperdiciará
archivos
cuya
www.FreeLibros.melongitud
número
entero
bloques
fragmentación
interna
externa
Haga
analogía
descrito
capítulo
11
utilizar
asignación
contigua
disco
sufrir
huecos
compactar
disco
elimina
archivo
archivos
contiguos
copiar
archivo
requiere
búsqueda
retraso
rotacional
leerlo
seguidos
transferencia
ve-
locidad
escribir
vuelta
archivo
requiere
trabajo
Suponiendo
tiempo
búsqueda
mseg
retraso
rotacional
mseg
velocidad
transferencia
MB
seg
tamaño
archivo
promedio
KB
tiempo
requiere
leer
archivo
memoria
principal
escribirlo
vuelta
disco
ubicación
Utilizando
números
tiempo
requeriría
compactar
mitad
disco
16
GB
12
luz
respuesta
pregunta
sentido
compactar
disco
13
dispositivos
digitales
consumidor
necesitan
almacenar
datos
ejemplo
ar-
chivos
Nombre
dispositivo
moderno
requiera
almacenamiento
archivos
asignación
contigua
excelente
idea
14
implementa
MS-DOS
acceso
aleatorio
archivos
15
Considere
nodo-i
muestra
figura
4-13
contiene
10
direcciones
directas
bytes
bloques
disco
1024
KB
archivo
16
sugerido
eficiencia
mejorar
espacio
disco
ahorrar
almace-
nar
datos
archivo
corto
nodo-i
nodo-i
figura
4-13
bytes
datos
almacenarse
nodo-i
17
estudiantes
ciencias
computacionales
Carolyn
Elinor
hablando
acerca
nodos-
i.
Carolyn
sostiene
tamaño
memorias
aumentado
vuelto
econó-
micas
abre
archivo
simple
rápido
obtener
copia
nodo-i
colocarla
tabla
nodos-i
lugar
buscar
tabla
Elinor
es-
tá
desacuerdo
razón
18
Nombre
ventaja
vínculos
duros
ligas
duras
vínculos
simbólicos
ligas
simbólicas
ventaja
vínculos
simbólicos
vínculos
duros
19
espacio
libre
disco
contabilizar
lista
bloques
libres
mapa
bits
direcciones
disco
requieren
bits
disco
bloques
cua-
libres
indique
condición
lista
bloques
libres
utiliza
espacio
mapa
bits
valor
16
bits
exprese
respuesta
porcentaje
espacio
disco
libre
20
inicio
mapa
bits
espacio
libre
apariencia
for-
mato
partición
disco
1000
0000
0000
0000
bloque
utilizado
directorio
raíz
sistema
busca
bloques
libres
empezando
bloque
menor
numeración
escribir
archivo
utiliza
bloques
mapa
bits
ve
1111
1110
0000
0000
Muestre
mapa
bits
siguientes
accio-
nes
adicionales
escribe
archivo
utilizando
bloques
elimina
archivo
escribe
archivo
utilizando
bloques
elimina
archivo
B.
326
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
327
21
ocurriría
mapa
bits
lista
bloques
libres
contiene
información
acerca
bloques
disco
libres
perdiera
completo
falla
forma
re-
cuperarse
desastre
definitivamente
adiós
disco
duro
Analice
respues-
tas
sistemas
archivos
UNIX
FAT-16
separado
22
trabajo
nocturno
Oliver
Owl
centro
cómputo
universidad
cambiar
cintas
utilizan
respaldos
datos
nocturnos
espera
complete
cinta
trabaja
escritura
tesis
demuestra
obras
Shakespeare
escritas
vi-
sitantes
extraterrestres
procesador
texto
ejecuta
sistema
respaldando
único
problema
arreglo
23
texto
analizamos
detalle
forma
vaciados
incrementales
Windows
fácil
vaciar
archivo
archivo
bit
archivar
bit
UNIX
programas
respaldo
UNIX
archivos
vaciar
24
Suponga
archivo
21
figura
4-25
modificó
vacia-
do
forma
deberían
distintos
mapas
bits
figura
4-26
25
sugerido
archivo
UNIX
mantenerse
bloque
disco
nodo-i
beneficio
traería
26
Considere
figura
4-27
número
bloque
específico
contadores
ambas
listas
tengan
valor
debería
corregirse
problema
27
rendimiento
sistema
archivos
depende
proporción
aciertos
caché
fracción
bloques
encontrados
caché
requiere
mseg
satisfacer
solicitud
caché
40
mseg
satisfacer
solicitud
necesita
lectura
disco
proporcione
fórmu-
tiempo
promedio
requerido
satisfacer
solicitud
proporción
aciertos
h.
Grafique
función
valores
varían
1.0
28
Considere
idea
figura
4-21
disco
tiempo
búsqueda
pro-
mseg
velocidad
rotacional
15,000
rpm
262,144
bytes
pista
velocidades
datos
tamaños
bloque
KB
KB
KB
respectivamente
29
sistema
archivos
utiliza
bloques
disco
KB
tamaño
archivo
promedio
KB
archivos
fueran
exactamente
KB
fracción
espacio
disco
desperdiciaría
Piensa
desperdicio
sistema
archivos
real
es-
número
menor
Explique
respuesta
30
tabla
FAT-16
MS-DOS
contiene
64
entradas
Suponga
bits
necesita
propósito
tabla
contiene
exactamente
32,768
entradas
64
K.
nin-
gún
cambio
archivo
MS-DOS
condición
31
archivos
MS-DOS
competir
espacio
tabla
FAT-16
memoria
archivo
utiliza
entradas
entradas
disponibles
archivo
restricción
impone
longitud
archivos
combinados
32
sistema
archivos
UNIX
bloques
KB
direcciones
disco
bytes
tamaño
archivo
máximo
nodos-i
contienen
10
entradas
directas
entrada
indirecta
sen-
cilla
doble
triple
33
operaciones
disco
necesitan
obtener
nodo-i
archivo
/usr
ast
cursos
so-
/folleto.t
Suponga
nodo-i
directorio
raíz
memoria
www.FreeLibros.melo
ruta
memoria
Suponga
directorios
caben
bloque
disco
34
sistemas
UNIX
nodos-i
mantienen
inicio
disco
diseño
alternativo
asignar
nodo-i
crea
archivo
colocar
nodo-i
inicio
bloque
ar-
chivo
Hable
ventajas
desventajas
alternativa
35
Escriba
programa
invierta
bytes
archivo
byte
funcionar
archivo
arbitrariamente
pe-
ro
trate
eficiente
razonable
36
Escriba
programa
inicie
directorio
recorra
árbol
archivos
pun-
to
abajo
registrando
tamaños
archivos
encuentre
termine
debe-
rá
imprimir
histograma
tamaños
archivos
utilizando
anchura
contenedor
especificada
parámetro
ejemplo
1024
tamaños
archivos
1023
contenedor
1024
2047
contenedor
etcétera
37
Escriba
programa
explore
directorios
sistema
archivos
UNIX
busque
localice
nodos-i
vínculos
duros
archivos
listar
conjunto
nombres
archivos
apunten
archivo
38
Escriba
versión
programa
ls
UNIX
versión
tomar
argumento
nombres
directorios
directorio
listar
archivos
contiene
línea
archivo
campo
formato
razonable
conn
base
tipo
Liste
primeras
direcciones
disco
328
SISTEMAS
ARCHIVOS
CAPÍTULO
www
FreeLibros.me5
ENTRADA
SALIDA
329
proporcionar
abstracciones
procesos
hilos
espacios
direcciones
ar-
chivos
sistema
operativo
controla
dispositivos
Entrada
Salida
computadora
emitir
comandos
dispositivos
captar
interrupciones
manejar
errores
Adicionalmente
proporcionar
interfaz
simple
fácil
dispositivos
resto
sistema
interfaz
dispositivos
independencia
dispositivos
código
representa
fracción
considerable
sistema
operativo
tema
capítulo
forma
sistema
operativo
administra
S.
capítulo
organiza
veremos
principios
hardware
analizaremos
software
general
software
pue-
estructurar
niveles
tarea
definida
Analizaremos
niveles
describir
trabajan
conjunto
introducción
analizaremos
detalladamente
hardware
software
dis-
positivos
discos
relojes
teclados
pantallas
consideraremos
administración
energía
5.1
PRINCIPIOS
HARDW
ARE
Distintas
personas
ven
hardware
maneras
ingenieros
eléctricos
ven
términos
chips
cables
fuentes
motores
componentes
físicos
con-
stituyen
hardware
programadores
ven
interfaz
presenta
software
coman
www.FreeLibros.meque
acepta
hardware
funciones
cabo
errores
reportar
libro
enfocaremos
programación
dispositivos
diseño
cons-
trucción
mantenimiento
interés
limitará
programa
hardware
funciona
programación
dispositivos
íntimamente
conectada
operación
interna
siguien-
tes
secciones
proveeremos
historia
general
acerca
hardware
relaciona
programación
considerarse
repaso
expansión
material
in-
troductorio
sección
1.4
5.1.1
Dispositivos
dispositivos
dividir
básicamente
categorías
dispositivos
bloque
dispositivos
carácter
dispositivo
bloque
almacena
información
bloques
tamaño
fi-
jo
dirección
tamaños
bloque
comunes
varían
512
bytes
has-
ta
32,768
bytes
transferencias
realizan
unidades
bloques
completos
consecutivos
propiedad
esencial
dispositivo
bloque
leer
escribir
bloque
independiente
discos
duros
CD-ROMs
memorias
USBs
dispositivos
bloque
comunes
resultado
análisis
detallado
concluir
definido
lí-
mite
dispositivos
direccionarse
bloques
direccio-
nar
concuerdan
disco
dispositivo
direccionable
bloques
importa
encuentre
brazo
momento
buscar
cilindro
esperar
bloque
requerido
gire
cabeza
considere
unidad
cinta
utilizada
respaldos
disco
cintas
contienen
secuencia
blo-
ques
unidad
cinta
recibe
comando
leer
bloque
rebobinar
cin-
ta
avanzar
llegar
bloque
N.
operación
similar
disco
realizando
búsqueda
requiere
tiempo
volver
escribir
bloque
mitad
cinta
utilizar
cintas
dispositivos
bloque
acceso
aleatorio
sale
normal
cintas
utilizan
tipo
dispositivo
dispositivo
carácter
dispositivo
carácter
en-
vía
acepta
flujo
caracteres
importar
estructura
bloque
direccionable
operación
búsqueda
impresoras
interfaces
red
ratones
seña-
lar
ratas
experimentos
laboratorio
psicología
mayoría
dispo-
sitivos
parecidos
disco
considerar
dispositivos
carácter
esquema
clasificación
perfecto
dispositivos
simplemente
adaptan
ejemplo
relojes
direccionables
bloques
generan
aceptan
flujos
caracteres
producir
interrupciones
intervalos
definidos
pantallas
asignación
memoria
adaptan
modelo
modelo
dispositivos
bloque
carácter
general
utilizarlo
base
sistema
operativo
lidia
dispositivos
independiente
ejemplo
sistema
archivos
encarga
dispositivos
bloque
abstractos
deja
depen-
diente
dispositivos
software
nivel
330
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.1
PRINCIPIOS
HARDWARE
331
dispositivos
cubren
amplio
rango
velocidades
impone
presión
considerable
software
obtener
desempeño
órdenes
magnitud
velocidades
transferencia
datos
figura
5.1
muestra
velocidades
transferencia
datos
dispositivos
comunes
mayoría
dispositivos
tienden
hacerse
rá-
pidos
medida
pasa
tiempo
Dispositivo
Velocidad
transferencia
datos
Teclado
10
bytes
seg
Ratón
100
bytes
seg
Módem
56
KB
seg
Escáner
400
KB
seg
Cámara
video
digital
3.5
MB
seg
802.11
inalámbrico
6.75
MB
seg
CD-ROM
52X
7.8
MB
seg
Fast
Ethernet
12.5
MB
seg
Tarjeta
Compact
Flash
40
MB
seg
FireWire
IEEE
1394
50
MB
seg
USB
2.0
60
MB
seg
Red
SONET
OC-12
78
MB
seg
Disco
SCSI
Ultra
80
MB
seg
Gigabit
Ethernet
125
MB
seg
Unidad
disco
SATA
300
MB
seg
Cinta
Ultrium
320
MB
seg
Bus
PCI
528
MB
seg
Figura
5-1
Velocidades
transferencia
datos
comunes
dispositivos
redes
buses
5.1.2
Controladores
dispositivos
general
unidades
consisten
componente
mecánico
componente
elec-
trónico
separar
porciones
proveer
diseño
modular
ge-
neral
componente
electrónico
llama
controlador
dispositivo
adaptador
computadoras
personales
comúnmente
forma
chip
tarjeta
principal
tarje-
ta
circuito
integrado
insertar
ranura
expansión
PCI
componente
me-
cánico
dispositivo
arreglo
muestra
figura
1-6
tarjeta
controladora
general
contiene
conector
conectar
cable
conduce
dispositivo
controladores
manejar
inclusive
dispositivos
idénticos
interfaz
controlador
dispositivo
están-
estándar
oficial
ANSI
IEEE
ISO
estándar
facto
empresas
www.FreeLibros.mepueden
fabricar
controladores
dispositivos
adapten
interfaz
ejemplo
empresas
fabrican
unidades
disco
coinciden
interfaz
IDE
SATA
SCSI
USB
Fi-
reWire
IEEE
1394
interfaz
controlador
dispositivo
nivel
ejemplo
formato
disco
10,000
sectores
512
bytes
pista
realidad
sale
disco
flujo
serial
bits
empezando
preámbulo
4096
bits
sector
suma
comprobación
conocida
Código
Co-
rrección
Errores
ECC
preámbulo
escribe
formato
disco
contiene
cilindro
número
sector
tamaño
sector
datos
similares
información
sin-
cronización
trabajo
controlador
convertir
flujo
bits
serial
bloque
bytes
corrección
errores
necesaria
general
ensambla
bloque
by-
tes
bit
bit
búfer
controlador
verificado
suma
com-
probación
bloque
declarado
libre
errores
copiarse
memoria
principal
controlador
monitor
funciona
dispositivo
bits
serie
ni-
vel
Lee
bytes
contienen
caracteres
mostrar
memoria
genera
señales
utilizadas
modular
haz
CRT
escriba
pantalla
controlador
genera
señales
haz
CRT
realice
retrazado
horizontal
ha-
ber
terminado
línea
exploración
señales
realice
retrazado
vertical
explorado
pantalla
controlador
CRT
pro-
gramador
sistema
operativo
tendría
programar
explícita
exploración
análoga
tubo
controlador
sistema
operativo
inicializa
controlador
pará-
metros
número
caracteres
píxeles
línea
número
líneas
pantalla
de-
ja
controlador
encargue
manejar
haz
pantallas
TFT
planas
funcionan
igualmente
complicadas
5.1.3
asignación
memoria
controlador
registros
utilizan
comunicarse
CPU
es-
cribir
sistema
operativo
dispositivo
envíe
acepte
datos
encien-
apague
realice
acción
leer
registros
sistema
operativo
dispositivo
preparado
aceptar
comando
procediendo
registros
control
dispositivos
búfer
datos
siste-
ma
operativo
leer
escribir
ejemplo
común
computadoras
muestren
píxeles
pantalla
RAM
video
básicamente
búfer
datos
disponible
programas
sistema
operativo
escriban
surge
cuestión
acerca
comunica
CPU
registros
con-
trol
búferes
datos
dispositivos
alternativas
método
ca-
registro
control
asigna
número
puerto
entero
16
bits
conjunto
puertos
forma
espacio
puertos
protegido
332
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.1
PRINCIPIOS
HARDWARE
333
programas
usuario
ordinarios
puedan
utilizarlo
sistema
operativo
instrucción
especial
IN
REG
PUERTO
CPU
leer
registro
control
PUERTOy
almacenar
resultado
registro
CPU
llamado
REG
similar
OUT
PUERTO
REG
CPU
escribir
contenido
REG
registro
control
mayoría
primeras
computadoras
incluyendo
mainframes
IBM
360
sucesoras
tra-
bajaban
esquema
espacios
direcciones
memoria
distintos
muestra
figura
5-2(a
instrucciones
IN
R0,4
MOV
R0,4
completamente
distintas
diseño
lee
contenido
puerto
colo-
ca
RO
lee
contenido
palabra
memoria
coloca
RO
4s
ejemplos
refieren
espacios
direcciones
distintos
relacionados
direcciones
Espacio
dirección
espacios
direcciones
Memoria
Puertos
0xFFFF
Figura
5-2
Espacio
separado
memoria
asignación
me-
moria
Híbrido
método
introdujo
PDP-11
asignar
registros
control
espacio
memoria
muestra
figura
5-2(b
registro
control
asigna
dirección
memoria
única
memoria
asignada
sistema
conoce
asignación
memoria
mapped-memory
general
direcciones
asignadas
encuentran
superior
espacio
direcciones
figura
5-2(c
muestra
esque-
ma
híbrido
búferes
datos
asignación
memoria
puertos
separados
pa-
ra
registros
control
Pentium
utiliza
arquitectura
direcciones
640
reservan
búferes
datos
dispositivos
IBM
PC
compatibles
puertos
64K.
www
FreeLibros.me¿Cómo
funcionan
esquemas
casos
CPU
desea
leer
palabra
memoria
puerto
coloca
dirección
necesita
líneas
dirección
bus
impone
señal
READen
línea
control
bus
utiliza
línea
señal
indicar
necesita
espacio
memoria
espacio
memoria
res-
ponde
petición
espacio
dispositivo
responde
petición
espacio
memoria
figura
5-2(b
módulos
memoria
disposi-
tivos
comparan
líneas
dirección
rango
direcciones
servicio
dirección
rango
responde
petición
dirección
asigna
me-
moria
dispositivo
ambigüedad
conflicto
esquemas
direccionar
controladores
distintos
puntos
fuertes
débiles
empezar
ventajas
asignación
memoria
lugar
ne-
cesitan
instrucciones
especiales
leer
escribir
registros
control
acceder
requiere
código
ensamblador
forma
ejecutar
instrucción
INo
OUTen
C++
llamar
procedimiento
agrega
sobrecarga
controlar
S.
contraste
asignación
memoria
registros
control
dispositivos
só-
variables
memoria
direccionar
forma
varia-
ble
asignación
memoria
controlador
dispositivo
escribirse
completamente
C.
asignación
memoria
requiere
código
en-
samblador
lugar
asignación
memoria
requiere
mecanismo
protec-
ción
especial
evitar
procesos
realicen
operaciones
S.
sistema
opera-
tivo
abstenerse
colocar
porción
espacio
direcciones
contiene
registros
control
espacio
direcciones
virtuales
usuario
dis-
positivo
registros
control
página
distinta
espacio
direcciones
sistema
ope-
rativo
proporcionar
usuario
control
dispositivos
específicos
incluir
páginas
deseadas
tabla
páginas
esquema
permite
co-
loquen
distintos
controladores
dispositivos
espacios
direcciones
reduce
tamaño
kernel
evita
controlador
interfiera
tercer
lugar
asignación
memoria
instrucción
refe-
rencia
memoria
hacerla
registros
control
ejemplo
instruc-
ción
llamada
TESTque
evalúe
palabra
memoria
utilizar
evaluar
registro
control
señal
dispositivo
inactivo
po-
sición
aceptar
comando
código
lenguaje
ensamblador
CICLO
TEST
PUERTO_4
comprueba
puerto
BEQ
LISTO
listo
BRANCH
CICLO
caso
contrario
continúa
prueba
LISTO
asignación
memoria
presente
registro
control
leer
CPU
evaluar
requieren
instrucciones
caso
ciclo
mencionado
agregar
cuarta
instrucción
reduce
ligeramente
capacidad
respuesta
detectar
dispositivo
inactivo
334
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.1
PRINCIPIOS
HARDWARE
335
diseño
computadoras
implica
concesiones
caso
asignación
memoria
desventajas
lugar
mayo-
ría
computadoras
actuales
forma
colocar
caché
palabras
memoria
desastroso
colocar
caché
registro
control
dispositivos
Considere
ciclo
código
lenguaje
ensamblador
mostrado
presencia
caché
referencia
PUERTO_4
haría
colocara
caché
referencias
subsiguientes
tomarían
valor
caché
siquiera
preguntar
dispositivo
dispositivo
estuviera
listo
software
tendría
averiguarlo
ciclo
continuaría
evitar
situación
relacionada
asignación
memoria
hardware
capaz
deshabilitar
caché
forma
selectiva
ejemplo
página
característica
agrega
complejidad
adicional
hardware
sistema
operativo
encargarse
caché
selectiva
lugar
espacio
direcciones
módulos
memo-
ria
dispositivos
examinar
referencias
memoria
cuá-
responder
computadora
bus
figura
5-3(a
simple
analicen
dirección
CPU
Memoria
BusTodas
direcciones
memoria
CPU
Memoria
lecturas
escrituras
memoria
CPU
pasan
bus
alto
ancho
banda
puerto
memoria
permitir
dispositivos
accedan
memoria
Figura
5-3
Arquitectura
bus
Arquitectura
bus
dual
tendencia
computadoras
personales
modernas
bus
memoria
dedicado
alta
velocidad
muestra
figura
5-3(b
propiedad
en-
cuentra
incidentalmente
mainframes
bus
ajustado
optimizar
rendimiento
memoria
sacrificarse
bienestar
dispositivos
lentos
sistemas
Pentium
pue-
den
buses
memoria
PCI
SCSI
USB
ISA
muestra
figura
1-12
problema
bus
memoria
separado
equipos
asignación
memoria
dispositivos
forma
direcciones
memoria
medida
recorren
bus
memoria
responderles
necesario
tomar
medi-
das
especiales
asignación
memoria
funcione
sistema
buses
posibilidad
enviar
referencias
memoria
memoria
responde
CPU
prueba
buses
diseño
funcionar
requiere
complejidad
adicional
hardware
www
FreeLibros.meUn
diseño
colocar
dispositivo
husmeador
bus
memoria
pa-
sar
direcciones
presentadas
dispositivos
potencialmente
interesados
pro-
blema
dispositivos
puedan
procesar
peticiones
velocidad
procesarlas
memoria
tercer
diseño
utilizado
configuración
Pentium
figura
1-12
filtrar
direcciones
chip
puente
PCI
chip
contiene
registros
rango
car-
gan
previamente
tiempo
inicio
sistema
ejemplo
rango
640
marcar
rango
memoria
direcciones
ubicadas
rangos
marcados
reenvían
bus
PCI
reenviarse
memoria
desventaja
es-
quema
necesidad
averiguar
tiempo
inicio
sistema
direcciones
memoria
realidad
ende
esquema
argumentos
favor
sa-
crificios
concesiones
inevitables
5.1.4
Acceso
directo
memoria
DMA
importar
CPU
asignación
memoria
necesita
direccionar
con-
troladores
dispositivos
intercambiar
datos
CPU
solicitar
datos
controlador
bit
desperdicia
tiempo
CPU
utiliza
esquema
distinto
conocido
DMA
Acceso
Directo
Memoria
sis-
tema
operativo
utilizar
DMA
hardware
controlador
DMA
ma-
yoría
sistemas
controlador
integrado
controladores
disco
controladores
diseño
requiere
controlador
DMA
separado
ca-
dispositivo
común
controlador
DMA
disponible
ejemplo
tarjeta
principal
regular
transferencias
dispositivos
forma
con-
currente
importar
ubicación
física
controlador
DMA
acceso
bus
siste-
ma
independiente
CPU
muestra
figura
5-4
Contiene
regis-
tros
CPU
escribir
leer
incluyen
registro
dirección
memoria
registro
contador
bytes
registros
control
registros
control
especifican
puerto
utilizar
dirección
transferencia
leer
dispositivo
escribir
unidad
transferencia
byte
palabra
núme-
ro
bytes
transferir
ráfaga
explicar
funcionamiento
DMA
veamos
ocurren
lecturas
disco
utiliza
DMA
controlador
disco
lee
bloque
sectores
unidad
forma
serial
bit
bit
coloca
bloque
completo
búfer
interno
controlador
calcula
suma
comprobación
verificar
hayan
ocurrido
erro-
res
lectura
controlador
produce
interrupción
sistema
operativo
em-
pieza
ejecutarse
leer
bloque
disco
búfer
controlador
byte
palabra
ejecución
ciclo
iteración
lee
byte
palabra
regis-
tro
dispositivo
controlador
almacena
memoria
principal
utiliza
DMA
procedimiento
distinto
CPU
programa
controla-
dor
DMA
establece
registros
sepa
transferir
336
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.1
PRINCIPIOS
HARDWARE
337
paso
figura
5-4
emite
comando
controlador
disco
indicarle
de-
be
leer
datos
disco
búfer
interno
verificar
suma
comprobación
datos
válidos
búfer
controlador
disco
empezar
DMA
controlador
DMA
inicia
transferencia
enviando
petición
lectura
controlador
disco
bus
paso
petición
lectura
ve
petición
lectura
controlador
disco
importa
vino
CPU
contro-
lador
DMA
general
dirección
memoria
escribir
líneas
dirección
bus
controlador
disco
obtiene
palabra
búfer
interno
escribir
escritura
memoria
ciclo
bus
estándar
paso
completa
escritura
controlador
disco
envía
señal
reconocimiento
con-
trolador
DMA
bus
paso
controlador
DMA
incrementa
conti-
nuación
dirección
memoria
utilizar
disminuye
bytes
bytes
repiten
pasos
llega
momento
controlador
DMA
interrumpe
CPU
hacerle
transferencia
completa
sistema
operativo
inicia
copiar
bloque
disco
memoria
controladores
DMA
varían
considerablemente
sofisticación
simples
manejan
transferencia
describió
complejos
programar
manejar
transferencias
Dichos
controladores
conjun-
tos
registros
internos
canal
CPU
empieza
cargar
conjunto
regis-
tros
parámetros
relevantes
transferencia
transferencia
utilizar
controlador
dispositivo
distinto
transferir
palabra
pasos
figu-
ra
5-4
controlador
DMA
decide
dispositivo
servicio
continuación
configurar
utilizar
algoritmo
turno
rotatorio
round-robin
diseño
esquema
prioritario
favorecer
dispositivos
peticio-
nes
distintos
controladores
dispositivos
pendientes
tiempo
CPU
Controlador
DMA
Controlador
disco
Memoria
principal
Búfer
CPU
programa
controlador
DMA
Interrumpe
terminar
DMA
solicita
transferencia
memoria
Datos
transferidos
Bus
Recono-
cimiento
Dirección
Control
Unidad
Figura
5-4
Operación
transferencia
DMA
www.FreeLibros.meuna
ambigua
diferenciar
señales
reconocimiento
utiliza
línea
reconocimiento
distinta
bus
canal
DMA
razón
buses
operar
modos
palabra
blo-
controladores
DMA
operar
ante-
rior
operación
describe
controlador
DMA
solicita
transferencia
palabra
obtiene
CPU
desea
bus
esperar
mecanismo
llama
ro-
bo
ciclo
controlador
dispositivo
acerca
sigilosa
roba
ciclo
bus
CPU
retrasándola
ligeramente
bloque
controlador
DMA
indica
dispositivo
adquirir
bus
emitir
serie
transferencias
li-
berar
bus
forma
operación
conoce
ráfaga
eficiente
ro-
bo
ciclo
adquisición
bus
requiere
tiempo
transferir
palabras
adquisición
bus
desventaja
comparación
ráfaga
bloquear
CPU
dispositivos
periodo
considerable
transfi-
riendo
ráfaga
extensa
modelo
analizando
conocido
fly-by
controlador
DMA
indica
controlador
dispositivo
transfiera
datos
directamente
memoria
principal
alternativo
utilizan
controladores
DMA
controlador
dispositivo
envíe
palabra
controlador
DMA
emite
solicitud
bus
escribir
palabra
supone
esquema
re-
ciclo
bus
adicional
palabra
transferida
flexible
copias
dispositivo
dispositivo
copias
memoria
memoria
emite
lectura
memoria
escritura
memoria
direc-
ción
distinta
mayoría
controladores
DMA
utilizan
direcciones
físicas
memoria
transferencias
direcciones
físicas
requiere
sistema
operativo
convierta
dirección
virtual
búfer
memoria
deseado
dirección
física
escriba
dirección
física
registro
dirección
controlador
DMA
esquema
alternativo
utiliza
controladores
DMA
escribir
direcciones
virtuales
controlador
DMA
controlador
DMA
utilizar
MMU
traducción
dirección
virtual
física
caso
MMU
memoria
raro
formar
CPU
direcciones
virtuales
colocar
bus
mencionamos
anteriormente
iniciar
DMA
disco
lee
prime-
ro
datos
búfer
interno
lector
pregunte
controlador
alma-
cena
bytes
memoria
obtiene
disco
palabras
necesita
búfer
interno
razones
lugar
utilizar
búfer
interno
contro-
lador
disco
verificar
suma
comprobación
iniciar
transferencia
su-
ma
comprobación
incorrecta
señala
error
realiza
transferencia
inicia
transferencia
disco
bits
siguen
llegando
velocidad
cons-
tante
esté
listo
controlador
controlador
tratara
escribir
datos
directamen-
memoria
tendría
pasar
bus
sistema
palabra
transferida
bus
estuviera
ocupado
dispositivo
estuviera
utilizando
ejemplo
mo-
do
ráfaga
controlador
tendría
esperar
palabra
disco
llegar
almacenara
controlador
tendría
almacenarla
bus
estu-
338
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.1
PRINCIPIOS
HARDWARE
339
viera
ocupado
controlador
terminar
almacenando
palabras
tendría
trabajo
administración
bloque
coloca
búfer
interno
bus
necesita
empieza
DMA
diseño
controlador
mu-
cho
simple
transferencia
DMA
memoria
estricta
tiempo
controladores
antiguos
directamente
memoria
pequeña
cantidad
búfer
interno
bus
ocupado
terminar
transferencia
error
desbordamiento
computadoras
utilizan
DMA
argumento
CPU
principal
rápida
controlador
DMA
trabajo
fa-
cilidad
factor
limitante
velocidad
dispositivo
traba-
jo
CPU
rápida
esperar
controlador
DMA
lento
terminar
caso
deshacernos
controlador
DMA
CPU
reali-
ce
trabajo
software
ahorra
dinero
importante
computadoras
rendimiento
incrustadas
embebidas
5.1.5
Repaso
interrupciones
sección
1.4.5
vimos
introducción
interrupciones
sistema
computadora
personal
común
estructura
interrupciones
muestra
figura
5-5
nivel
hardware
interrupciones
funcionan
dispositivo
terminado
trabajo
asignó
produce
interrupción
suponien-
do
sistema
operativo
habilitado
interrupciones
impone
señal
línea
bus
asignado
señal
detectada
chip
controlador
interrupcio-
nes
tarjeta
principal
decide
CPU
Controlador
interrupciones3
CPU
reconoce
interrupción
controlador
emite
interrupción
dispositivo
termina
Disco
Teclado
Impresora
Reloj
Bus
12
93
11
210
Figura
5-5
ocurre
interrupción
conexiones
dispositivos
controlador
interrupciones
realidad
utilizan
líneas
interrupción
bus
cables
dedicados
interrupciones
pendientes
controlador
interrupciones
procesa
interrup-
ción
inmediato
progreso
dispositivo
petición
simultá-
nea
línea
petición
interrupción
prioridad
bus
dispositivo
www
FreeLibros.me340
ENTRADA
SALIDA
CAPÍTULO
ignora
momento
caso
continúa
imponiendo
señal
interrupción
bus
has-
ta
CPU
atiende
manejar
interrupción
controlador
coloca
número
líneas
dirección
especifican
dispositivo
desea
atención
impone
señal
interrumpir
CPU
señal
interrupción
CPU
deje
empiece
co-
sa
número
líneas
dirección
utiliza
índice
tabla
llamada
vector
in-
terrupciones
obtener
contador
programa
contador
programa
apunta
inicio
procedimiento
servicio
interrupciones
correspondiente
general
trampas
interrupciones
utilizan
mecanismo
punto
frecuencia
com-
parten
vector
interrupción
ubicación
vector
interrupción
determi-
nar
estática
hardwired
máquina
memoria
registro
CPU
cargado
sistema
operativo
apuntando
origen
empieza
ejecutar
procedimiento
servicio
interrupciones
re-
conoce
interrupción
escribir
valor
puertos
controlador
inte-
rrupciones
reconocimiento
indica
controlador
emitir
interrupción
CPU
retrase
reconocimiento
esté
lista
manejar
interrupción
evitar
condiciones
competencia
involucran
interrupciones
simul-
táneas
computadoras
antiguas
controlador
interrupciones
centralizado
controlador
dispositivo
solicita
interrupciones
hardware
guarda
información
iniciar
procedimiento
servicio
información
guarda
lugar
guarda
varía
considerable
CPU
mínimo
guardar
contador
programa
reiniciar
proceso
interrumpido
extremo
registros
visibles
número
registros
internos
guardar
cuestión
guardar
información
opción
colocarla
registros
internos
sistema
operativo
leer
necesario
problema
derivado
método
en-
tonces
controlador
interrupciones
recibir
señal
reconocimiento
leído
información
potencialmente
relevante
temor
interrupción
so-
brescriba
registros
internos
guardan
estrategia
conlleva
tiempos
inactivos
lar-
gos
deshabilitan
interrupciones
posiblemente
interrupciones
datos
perdidos
consecuencia
mayoría
CPUs
guardan
información
pila
es-
método
problemas
empezar
pila
utiliza
pila
actual
po-
dría
pila
proceso
usuario
apuntador
pila
siquiera
legal
produciría
error
fatal
hardware
tratara
escribir
palabras
dirección
estuviera
apuntando
apuntar
página
escrituras
memoria
exceder
límite
página
generar
fallo
página
ocurrir
fallo
página
procesamiento
interrupción
hardware
crea
ma-
yor
problema
guardar
manejar
fallo
página
utiliza
pila
kernel
probabilidad
apuntador
pi-
legal
apunte
página
marcada
cambiar
kernel
requiera
cambiar
contextos
MMU
probablemente
invalide
mayoría
ca-
ché
TLB
vuelven
cargar
forma
estática
dinámica
aumenta
tiempo
requerido
procesar
interrupción
ende
desperdiciará
tiempo
CPU
www
FreeLibros.meSECCIÓN
5.1
PRINCIPIOS
HARDWARE
341
Interrupciones
precisas
imprecisas
problema
ocasionado
mayoría
CPUs
modernas
líneas
tuberías
superescalares
paralelas
interior
sistemas
antiguos
instrucción
terminaba
ejecutarse
microprograma
hardware
comproba-
ba
interrupción
pendiente
contador
programa
PSW
metían
pila
empezaba
secuencia
interrupción
ejecutaba
manejador
interrup-
ciones
llevaba
cabo
proceso
inverso
PSW
antiguo
contador
programa
sacaban
pila
continuaba
proceso
modelo
suposición
implícita
ocurre
interrupción
justo
instrucción
instrucciones
incluyendo
instrucción
ejecutado
completo
ejecutado
instrucción
equipos
antiguos
su-
posición
válida
modernos
empezar
considere
modelo
línea
tubería
figura
1-7(a).¿Qué
pasa
ocurre
interrupción
línea
tubería
llena
caso
usual
instrucciones
en-
cuentran
etapas
ejecución
ocurre
interrupción
valor
contador
pro-
grama
refleje
límite
correcto
instrucciones
ejecutadas
ejecutadas
instrucciones
haberse
ejecutado
forma
parcial
distintas
instrucciones
completas
situación
contador
programa
refleja
probabilidad
dirección
instrucción
obtener
meter
línea
tubería
dirección
instrucción
acaba
procesada
unidad
ejecución
máquina
superescalar
figura
1-7(b
cosas
empeoran
instruccio-
nes
descomponer
microoperaciones
ejecutar
desorden
dependien-
do
disponibilidad
recursos
internos
unidades
funcionales
registros
momento
interrupción
instrucciones
iniciadas
tiempo
hayan
empeza-
do
hayan
empezado
recientemente
completas
momento
señala
interrupción
instrucciones
avance
me-
relación
contador
programa
interrupción
deja
equipo
definido
conoce
interrupción
precisa
Walker
Cragon
1995
Dicha
interrupción
propiedades
contador
programa
PC
guarda
lugar
conocido
instrucciones
instrucción
apunta
PC
ejecutado
completo
instrucción
allá
instrucción
apunta
PC
ejecutado
conoce
ejecución
instrucción
apunta
PC
Observe
prohibición
instrucciones
allá
instrucción
apun-
ta
PC
acerca
iniciar
cambios
realizan
registros
memoria
deshacer
ocurra
interrupción
permite
ejecutar
instrucción
apunta
permite
ejecutado
caso
aplica
interrupción
empezado
www.FreeLibros.meobstante
interrupción
realidad
trampa
fallo
página
PC
generalmen-
apunta
instrucción
ocasionó
fallo
reiniciarse
situación
figura
5-6(a
ilustra
interrupción
precisa
instrucciones
contador
pro-
grama
316
completado
allá
iniciado
rechazado
deshacer
efectos
342
ENTRADA
SALIDA
CAPÍTULO
300
304
308
PC
312
316
PC
ejecutado
ejecutado
ejecutado
ejecutado
ejecutó
completo
ejecutó
completo
ejecutó
completo
ejecutó
completo
ejecutó
80%
ejecutó
60%
ejecutó
20%
ejecutó
35%
ejecutó
40%
ejecutó
10%
ejecutó
completo
ejecutado
320
324
328
332
300
304
308
312
316
320
324
328
332
Figura
5-6
interrupción
precisa
interrupción
imprecisa
interrupción
cumple
requerimientos
conoce
interrupción
im-
precisa
vida
incómoda
escritor
sistema
operativo
averiguar
ocurrió
ocurrir
figura
5-6(b
muestra
interrupción
im-
precisa
distintas
instrucciones
cerca
contador
programa
distintos
avance
antiguas
necesariamente
completas
recientes
máquinas
interrupciones
imprecisas
general
vuelcan
cantidad
interno
pila
sistema
operativo
posibilidad
averiguar
pasando
código
ne-
cesario
reiniciar
máquina
general
complicado
guardar
canti-
dad
extensa
información
memoria
interrupción
reduce
velocidad
interrupciones
recuperación
conlleva
irónica
situación
CPUs
superescalares
veloces
adecuadas
trabajo
real
lentitud
interrupciones
computadoras
diseñadas
tipos
interrupciones
tram-
pas
traps
precisas
ejemplo
interrupciones
precisas
trampas
producidas
errores
programación
fatales
imprecisas
ma-
necesidad
intentar
reiniciar
proceso
ejecución
dividido
cero
máquinas
bit
establecer
forzar
inte-
rrupciones
precisas
desventaja
establecer
bit
obliga
CPU
registrar
cui-
dadosamente
mantener
copias
sombra
registros
generar
interrupción
precisa
instante
sobrecarga
im-
pacto
rendimiento
máquinas
superescalares
serie
Pentium
interrupciones
precisas
permitir
software
antiguo
funcione
correctamente
precio
pagar
interrupciones
precisas
lógica
interrupciones
extremo
compleja
CPU
necesaria
ase-
gurar
controlador
interrupciones
indique
desea
ocasionar
interrupción
www
FreeLibros.meSECCIÓN
5.2
FUNDAMENTOS
SOFTWARE
343
instrucciones
punto
puedan
terminar
allá
punto
efecto
considerable
máquina
precio
paga
tiempo
área
chip
complejidad
diseño
requirieran
interrupciones
precisas
pa-
ra
fines
compatibilidad
aplicaciones
antiguas
área
chip
estaría
disponible
ca-
chés
chip
CPU
veloz
interrupciones
sistema
operativo
complicado
lento
difícil
método
realidad
5.2
FUNDAMENTOS
SOFTW
ARE
alejarnos
hardware
analizar
software
S.
analizare-
mos
objetivos
software
distintas
formas
punto
vista
sistema
operativo
5.2.1
Objetivos
software
concepto
clave
diseño
software
conoce
independencia
dispositivos
significa
escribir
programas
puedan
acceder
disposi-
tivo
especificar
dispositivo
adelantado
ejemplo
programa
lee
archivo
entrada
capacidad
leer
archivo
disco
duro
CD-ROM
DVD
memoria
USB
modificar
programa
dispositivo
distinto
ma-
nera
similar
escribir
comando
sort
entrada
salida
funcione
datos
entrada
provenientes
tipo
disco
teclado
datos
salida
vayan
tipo
disco
pantalla
Depende
sistema
opera-
tivo
encargarse
problemas
producidos
dispositivos
realidad
requieren
secuencias
comandos
distintas
leer
escribir
objetivo
relacionado
independencia
dispositivos
denominación
uni-
forme
nombre
archivo
dispositivo
simplemente
cadena
entero
de-
pender
dispositivo
forma
UNIX
discos
integrar
jerarquía
sistema
archivos
maneras
arbitrarias
usuario
necesita
nombre
corresponde
dispositivo
ejemplo
memoria
USB
montar
directorio
/usr
ast
respaldo
copiar
archivo
/usr
ast
res-
paldo
lunes
archivo
copie
memoria
USB
forma
archivos
disposi-
tivos
direccionan
forma
nombre
ruta
cuestión
importante
relacionada
software
manejo
errores
ge-
neral
errores
manejar
cerca
hardware
controlador
des-
cubre
error
lectura
tratar
corregir
error
software
controlador
dispositivo
manejarlo
tratar
leer
bloque
nue-
vo
errores
transitorios
errores
lectura
ocasionados
pizcas
polvo
www
FreeLibros.me344
ENTRADA
SALIDA
CAPÍTULO
cabeza
lectura
comúnmente
desaparecen
repite
operación
niveles
inferio-
res
lidiar
problema
niveles
superiores
acerca
casos
recuperación
errores
transparente
nivel
niveles
superiores
enteren
siquiera
error
cuestión
clave
transferencias
síncronas
bloqueo
asíncronas
controladas
interrupciones
mayoría
operaciones
asíncronas
CPU
ini-
cia
transferencia
llega
interrupción
programas
usua-
rio
fáciles
escribir
operaciones
bloqueo
llamada
sistema
read
programa
suspende
automática
datos
dis-
ponibles
búfer
Depende
sistema
operativo
operaciones
realidad
controladas
interrupciones
parezcan
bloqueo
programas
usuario
cuestión
relacionada
software
búfer
datos
provienen
dispositivo
almacenar
directamente
destino
ejemplo
paquete
llega
red
sistema
operativo
colocarlo
alma-
cenado
paquete
examina
dispositivos
severas
res-
tricciones
tiempo
real
ejemplo
dispositivos
audio
digital
datos
colocar
búfer
salida
adelantado
desacoplar
velocidad
llena
búfer
velocidad
vacía
eviten
sub-desbordamientos
búfer
búfer
involucra
cantidad
considerable
copiado
importante
im-
pacto
rendimiento
S.
concepto
mencionaremos
comparación
dispositivos
comparti-
dispositivos
dedicados
dispositivos
discos
utilizados
usuarios
producen
problemas
usuarios
tengan
ar-
chivos
abiertos
disco
tiempo
dispositivos
unidades
cin-
ta
dedicados
usuario
termine
usuario
unidad
cinta
usuarios
escriben
bloques
entremezclados
azar
mis-
ma
cinta
definitivamente
funcionará
introducir
dispositivos
dedicados
compartidos
introduce
variedad
problemas
interbloqueos
sistema
operativo
capaz
manejar
dispositivos
compartidos
dedicados
evite
problemas
5.2.2
programada
maneras
fundamentalmente
distintas
cabo
S.
sección
analizaremos
programada
siguientes
secciones
examinaremos
controlada
interrupciones
DMA
forma
simple
CPU
trabajo
método
conoce
programada
simple
ilustrar
programada
ejemplo
Considere
proceso
usuario
desea
imprimir
cadena
caracteres
ABCDEFGH
impresora
ensambla
cadena
búfer
espacio
usuario
muestra
figura
5-7(a
proceso
usuario
adquiere
impresora
escribir
llamada
sis-
tema
abrirla
impresora
actualmente
utilizada
proceso
llamada
www
FreeLibros.meSECCIÓN
5.2
FUNDAMENTOS
SOFTWARE
345
fallará
devolverá
código
error
bloqueará
impresora
esté
disponible
depen-
diendo
sistema
operativo
parámetros
llamada
obtiene
impresora
proceso
usuario
llamada
sistema
indicar
sistema
operativo
imprima
ca-
dena
impresora
sistema
operativo
general
copia
búfer
cadena
arreglo
ejemplo
espacio
kernel
utilizar
facilidad
kernel
modificar
mapa
memoria
acceso
espacio
usuario
comprueba
impresora
disponible
momento
espera
esté
impresora
disponible
sistema
operativo
copia
carácter
re-
gistro
datos
impresora
ejemplo
asignación
memo-
ria
acción
activa
impresora
carácter
aparezca
impresoras
colocan
búfer
línea
página
imprimir
obstante
fi-
gura
5-7(b
impreso
carácter
sistema
marcado
carácter
imprimir
copia
carácter
impresora
sistema
operativo
comprueba
impresora
lista
aceptar
general
impresora
registro
pro-
porciona
acto
escribir
registro
datos
convierta
lista
controlador
impresora
procesado
carácter
actual
indica
dispo-
nibilidad
estableciendo
bit
registro
colocando
valor
punto
sistema
operativo
espera
impresora
vuelva
lista
ocurre
imprime
carácter
muestra
figura
5-7(c
ciclo
continúa
has-
ta
impreso
cadena
control
regresa
proceso
usuario
acciones
realizadas
sistema
operativo
sintetizan
figura
5-8
co-
pian
datos
kernel
sistema
operativo
entra
ciclo
estrecho
imprimiendo
caracteres
aspecto
esencial
programada
ilustra
claridad
es-
ta
figura
imprimir
carácter
CPU
sondea
forma
continua
dispositivo
Cadena
imprimirEspacio
usuario
Espacio
kernel
ABCD
EFGH
Página
impresa
ABCD
EFGH
ABCD
EFGH
Página
impresa
ASiguiente
ABSiguiente
Figura
5-7
Pasos
imprimir
cadena
www.FreeLibros.mepara
listo
aceptar
comportamiento
conoce
comúnmente
sondeo
ocupado
espera
copiar_del_usuario(bufer
búfer
kernel
for
i=0
i++
itera
carácter
while
reg_estado_impresora
READY
itera
esté
lista
registro_datos_impresora
p[i
imprime
carácter
regresar_al_usuario
Figura
5-8
escribir
cadena
impresora
usando
programada
programada
simple
desventaja
ocupar
CPU
tiempo
completo
has-
ta
completen
operaciones
S.
tiempo
imprimir
carácter
corto
impresora
copiar
carácter
búfer
interno
ocupado
espera
sistema
incrustado
embebido
CPU
ocupado
espera
razonable
sistemas
complejos
CPU
trabajos
ocupado
espera
ineficiente
necesita
método
S.
5.2.3
controlada
interrupciones
considerar
caso
imprimir
impresora
coloca
caracteres
búfer
imprime
medida
llegando
impresora
imprimir
ejemplo
100
caracteres
seg
carácter
requiere
10
mseg
imprimirse
significa
escribir
carácter
registro
datos
impresora
CPU
ciclo
inactividad
10
mseg
esperando
permita
imprimir
carácter
tiempo
suficiente
cambio
contexto
ejecutar
proceso
du-
rante
10
mseg
desperdiciarían
forma
permitir
CPU
haga
espera
impresora
esté
lista
utilizar
interrupciones
realiza
llamada
sistema
imprimir
cadena
búfer
copia
espacio
kernel
vimos
carácter
copia
impresora
pron-
to
esté
dispuesta
aceptar
carácter
momento
CPU
llama
planificador
ejecuta
proceso
proceso
pidió
imprimir
cadena
bloquea
im-
preso
cadena
trabajo
llamada
sistema
muestra
figura
5-9(a
impresora
impreso
carácter
preparada
aceptar
genera
interrupción
interrupción
detiene
proceso
actual
guarda
ejecu-
ta
procedimiento
servicio
interrupciones
impresora
versión
cruda
código
muestra
figura
5-9(b
caracteres
imprimir
manejador
interrupciones
rea-
liza
acción
desbloquear
usuario
caso
contrario
imprime
carácter
reco-
noce
interrupción
regresa
proceso
ejecutando
justo
interrupción
continúa
346
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.2
FUNDAMENTOS
SOFTWARE
347
copiar_del_usuario(bufer
if
cuenta==0
habilitar_interrupciones
desbloquear_usuario
while
reg_estado_impresora
READY
else
registro_datos_impresora
p[0
registro_datos_impresora
p[i
planificador
reconocer_interrupcion
regresar_de_interrupcion
Figura
5-9
escribir
cadena
impresora
usando
controlada
inte-
rrupciones
Código
ejecuta
momento
llamada
siste-
ma
imprimir
Procedimiento
servicio
interrupciones
impresora
5.2.4
DMA
obvia
desventaja
controlada
interrupciones
ocurre
interrupción
carácter
interrupciones
requieren
tiempo
esquema
desperdicia
can-
tidad
tiempo
CPU
solución
utilizar
DMA
idea
permitir
contro-
lador
DMA
alimente
caracteres
impresora
CPU
moleste
esencia
DMA
programada
controlador
DMA
realiza
trabajo
CPU
principal
estrategia
requiere
hardware
especial
controlador
DMA
libera
CPU
trabajo
figura
5-10
muestra
es-
quema
código
copiar_del_usuario(bufer
reconocer_interrupcion
establecer_controlador_DMA
desbloquear_usuario
planificador
regresar_de_interrupcion
Figura
5-10
imprimir
cadena
DMA
Código
ejecuta
llamada
sistema
imprimir
Procedimiento
ser-
vicio
interrupciones
ganancia
DMA
reducir
número
interrupciones
carácter
búfer
impreso
caracteres
interrupciones
lentas
mejora
controlador
DMA
comúnmente
lento
CPU
principal
controlador
DMA
controlar
dispositivo
velocidad
CPU
general
espera
interrupción
DMA
pue-
utilizar
controlada
interrupción
programada
for-
tiempo
vale
pena
DMA
www
FreeLibros.me5.3
CAPAS
SOFTW
ARE
general
software
organiza
capas
muestra
figura
5-11
capa
función
definida
interfaz
definida
nive-
adyacentes
funcionalidad
interfaces
difieren
sistema
análi-
sis
veremos
continuación
examina
capas
empezando
inferior
específico
máquina
348
ENTRADA
SALIDA
CAPÍTULO
Software
capa
usuario
Software
sistema
operativo
independiente
dispositivo
Controladores
dispositivos
Manejadores
interrupciones
Hardware
Figura
5-11
Capas
sistema
software
S.
5.3.1
Manejadores
interrupciones
programada
útil
operaciones
interrupciones
incómodo
vida
evitar
ocultarse
pro-
fundidad
entrañas
sistema
operativo
sepa
ocultarlas
controlador
inicia
operación
blo-
quee
completado
ocurra
interrupción
controlador
bloquear
realizando
llamada
downen
semáforo
llamada
waiten
variable
condición
llamada
receiveen
mensaje
similar
ejemplo
ocurre
interrupción
procedimiento
interrupciones
necesario
po-
der
manejarla
desbloquear
controlador
inició
casos
com-
pletará
up
semáforo
casos
realizará
llamada
signal
variable
condición
monitor
enviará
mensaje
controlador
bloqueado
casos
efecto
neto
interrupción
controlador
bloqueado
ejecu-
tarse
modelo
funciona
controladores
estructurados
procesos
kernel
pilas
contadores
programa
realidad
simple
Procesar
interrupción
cuestión
tomar
interrupción
llamar
up
semáforo
ejecutar
instrucción
IRET
regresar
interrupción
proceso
trabajo
involucrado
sis-
tema
operativo
veremos
esquema
trabajo
serie
pasos
cabo
software
completado
interrupción
hardware
recalcar
detalles
dependen
sistema
pasos
listan
www
FreeLibros.meSECCIÓN
5.3
CAPAS
SOFTWARE
349
continuación
necesarios
máquina
específica
requieran
estén
listados
pasos
llevan
cabo
distinto
orden
al-
gunas
máquinas
Guardar
registros
incluyendo
PSW
guardados
hardware
interrupción
Establecer
contexto
procedimiento
servicio
interrupciones
necesario
establecer
TLB
MMU
tabla
páginas
Establecer
pila
procedimiento
servicio
interrupciones
Reconocer
controlador
interrupciones
controlador
interrupciones
centralizado
rehabilitar
interrupciones
Copiar
registros
guardaron
posiblemente
pila
tabla
procesos
Ejecutar
procedimiento
servicio
interrupciones
extraerá
información
registros
controlador
dispositivos
provocó
interrupción
Elegir
proceso
ejecutar
continuación
interrupción
ocasionado
proceso
alta
prioridad
bloqueado
cambie
listo
elegirse
ejecutarlo
momento
Establecer
contexto
MMU
proceso
ejecutar
continuación
necesario
establecer
TLB
Cargar
registros
proceso
incluyendo
PSW
10
Empezar
ejecutar
proceso
procesamiento
interrupciones
carece
importancia
ocupa
considerable
número
instrucciones
CPU
especial
máquinas
me-
moria
virtual
necesario
establecer
tablas
páginas
guardar
MMU
ejemplo
bits
máquinas
TLB
caché
CPU
tengan
manejarse
cambiar
modos
usuario
kernel
requiere
ciclos
máquina
adicionales
5.3.2
Drivers
dispositivos
principio
capítulo
analizamos
drivers
Vimos
controlador
tie-
ne
registros
dispositivos
utilizan
darle
comandos
registros
dispo-
sitivos
utilizan
leer
número
registros
dispositivos
naturaleza
comandos
varían
radicalmente
dispositivo
ejemplo
driver
ratón
aceptar
información
ratón
indica
desplazado
bo-
tones
oprimidos
momento
contrario
driver
disco
acerca
sectores
pistas
cilindros
cabezas
movimiento
brazo
propulsores
www.FreeLibros.medel
motor
tiempos
asentamiento
cabezas
mecanismos
disco
funcione
forma
apropiada
Obviamente
drivers
distintos
consecuencia
dispositivo
conectado
computadora
necesita
có-
digo
específico
controlarlo
código
conocido
driver
escrito
fabricante
dispositivo
incluye
sistema
operativo
necesita
dri-
vers
fabricantes
dispositivos
común
proporcionan
sistemas
operativos
populares
driver
maneja
tipo
dispositivo
clase
dispositivos
estrechamen-
relacionados
ejemplo
driver
disco
SCSI
manejar
general
discos
SCSI
distintos
tamaños
velocidades
CD-ROM
SCSI
ratón
palanca
mandos
distintos
general
requieren
controladores
dife-
rentes
restricción
técnica
driver
controle
dis-
positivos
relacionados
Simplemente
idea
utilizar
hardware
dispositivo
registros
controlador
físico
driver
general
formar
kernel
sistema
operativo
arquitecturas
actuales
realidad
construir
controladores
ejecuten
espacio
usuario
llamadas
sistema
leer
escribir
registros
dispositivo
diseño
aísla
kernel
controladores
controlador
eliminando
fuente
importante
fallas
sistema
controladores
errores
interfieren
kernel
construir
sistemas
altamente
confiables
definitiva
ejemplo
sistema
controladores
dispositivos
ejecutan
procesos
usua-
rio
MINIX
mayoría
sistemas
operativos
escritorio
es-
peran
controladores
ejecuten
kernel
modelo
consideraremos
diseñadores
sistema
operativo
piezas
código
drivers
escritas
terceros
instalarán
necesita
arquitectura
permita
dicha
instalación
implica
modelo
definido
driver
forma
interactúa
resto
sistema
operativo
general
controladores
dispositivos
posicionan
resto
sistema
operativo
ilustra
figura
5-12
Generalmente
sistemas
operativos
clasifican
controladores
pequeño
nú-
mero
categorías
categorías
comunes
dispositivos
bloque
discos
contienen
bloques
datos
direccionar
independiente
dispositivos
carácter
teclados
impresoras
generan
aceptan
flujo
caracteres
mayoría
sistemas
operativos
definen
interfaz
estándar
controladores
bloque
aceptar
interfaces
consisten
procedimientos
resto
siste-
ma
operativo
llamar
controlador
realice
trabajo
procedimien-
tos
ordinarios
utilizan
leer
bloque
dispositivo
bloque
escribir
cadena
caracteres
dispositivo
carácter
sistemas
sistema
operativo
programa
binario
contiene
compila-
controladores
requerirá
esquema
norma
años
sis-
temas
UNIX
ejecutados
centros
computadoras
dispositivos
cambiaban
agregaba
dispositivo
administrador
sistema
simple-
mente
recompilaba
kernel
controlador
crear
binario
350
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.3
CAPAS
SOFTWARE
351
llegada
computadoras
personales
multitud
dispositivos
mo-
delo
funcional
usuarios
capaces
volver
compilar
vincular
kernel
código
fuente
módulos
código
objeto
caso
sistemas
operativos
empezando
MS-DOS
inclinaron
modelo
con-
trolador
carga
forma
dinámica
sistema
ejecución
sistemas
manejan
carga
controladores
distintas
formas
controlador
dispositivo
funciones
obvia
aceptar
peticiones
abs-
tractas
lectura
escritura
software
independiente
dispositivo
lleven
cabo
tantas
funciones
ejem-
plo
controlador
inicializar
dispositivo
necesario
admi-
nistrar
requerimientos
eventos
registro
tipos
controladores
dispositivos
estructura
general
similar
con-
trolador
ordinario
empieza
comprobar
parámetros
entrada
válidos
devuelve
error
válidos
necesaria
traducción
términos
Espacio
usuario
Espacio
kernel
Proceso
usuario
Programa
usuario
Resto
sistema
operativo
Controlador
impresora
Controlador
cámara
video
Controlador
CD-ROM
Controlador
impresora
Controlador
cámara
video
Controlador
CD-ROM
Hardware
Dispositivos
Figura
5-12
Posicionamiento
lógico
software
controlador
dispositivos
rea-
lidad
comunicación
software
controlador
controladores
dispo-
sitivos
pasa
bus
www.FreeLibros.meabstractos
concretos
controlador
disco
significar
convertir
número
bloque
lineal
números
cabeza
pista
sector
cilindro
geometría
disco
continuación
controlador
comprobar
dispositivo
petición
pondrá
cola
procesarla
dispositivo
inactivo
hardware
examinará
petición
manejar
momento
ne-
cesario
encender
dispositivo
iniciar
motor
puedan
empezar
transferencias
dispositivo
esté
encendido
listo
trabajar
empezar
control
Controlar
dispositivo
significa
enviarle
secuencia
comandos
controlador
lu-
gar
determina
secuencia
comandos
dependiendo
deba
controlador
comandos
emitir
empieza
escribirlos
registros
dispo-
sitivo
controlador
escribir
comando
controlador
necesario
comprobar
controlador
aceptó
comando
preparado
aceptar
se-
cuencia
continúa
hayan
emitido
comandos
controladores
re-
cibir
lista
comandos
memoria
indicar
procesen
necesidad
ayuda
sistema
operativo
emitido
comandos
dará
situaciones
casos
controlador
dispositivos
esperar
controlador
realice
trabajo
bloquea
llegue
interrupción
desbloquearlo
casos
operación
termina
retraso
controlador
necesita
bloquearse
Co-
mo
ejemplo
situación
desplazar
pantalla
carácter
requiere
es-
cribir
bytes
registros
controlador
necesario
tipo
movimiento
mecánico
operación
completar
nanosegundos
caso
controlador
bloqueado
despertado
interrupción
caso
pasará
inactivo
forma
completado
opera-
ción
controlador
comprobar
errores
controlador
pasen
datos
software
independiente
dispositivo
ejemplo
bloque
acaba
leer
devuelve
información
reportar
errores
vuelta
lla-
mó
peticiones
cola
seleccionar
iniciar
cola
controlador
bloquea
espera
petición
modelo
simple
aproximación
realidad
factores
código
complicado
dispositivo
completar
operación
mien-
controlador
ejecución
interrumpe
controlador
interrupción
pue-
ejecute
controlador
dispositivo
controlador
actual
ejecute
ejemplo
controlador
red
procesando
paquete
entrante
llegar
paquete
consecuencia
controlador
reentrante
signi-
fica
controlador
ejecución
esperar
llamado
completado
llamada
sistema
conexión
caliente
agregar
eliminar
dispositivos
computadora
ejecución
resultado
controlador
ocupado
leyendo
dispositivo
sistema
informarle
usuario
quitado
repentina
dispositivo
sistema
abortar
transferencia
actual
dañar
es-
tructura
datos
kernel
petición
pendiente
desaparecido
disposi-
352
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.3
CAPAS
SOFTWARE
353
tivo
eliminarse
cuidado
sistema
avisando
llamada
Ade-
adición
inesperada
dispositivos
kernel
haga
malabares
recursos
ejemplo
líneas
petición
interrupciones
quitando
anteriores
controla-
dor
dándole
recursos
controlador
llamadas
sistema
necesita
interactuar
resto
kernel
general
permiten
llamadas
procedimientos
kernel
ejem-
plo
comúnmente
llamadas
asignar
desasignar
páginas
fijas
memoria
usarlas
co-
mo
búferes
llamadas
útiles
necesitan
administrar
MMU
temporizadores
controlador
DMA
controlador
interrupciones
etcétera
5.3.3
Software
independiente
dispositivo
software
específico
dispositivo
partes
inde-
pendientes
dispositivos
límite
exacto
controladores
software
independiente
dispositivo
depende
sistema
dispositivo
funciones
realizarse
independiente
dispositivo
realizarse
controladores
eficiencia
razones
funciones
muestran
figura
5-13
realizan
comúnmen-
software
independiente
dispositivo
Interfaz
uniforme
controladores
dispositivos
búfer
Reporte
errores
Asignar
liberar
dispositivos
dedicados
Proporcionar
tamaño
bloque
independiente
dispositivo
Figura
5-13
Funciones
software
independiente
dispositivo
función
básica
software
independiente
dispositivo
funciones
comunes
dispositivos
proveer
interfaz
uniforme
software
ni-
vel
usuario
continuación
analizaremos
cuestiones
mencionadas
detalle
Interfaz
uniforme
controladores
software
dispositivos
importante
cuestión
sistema
operativo
dispositivos
controladores
vean
iguales
discos
impresoras
teclados
etc.
conectan
distintas
maneras
llegue
dispositivo
sistema
operativo
de-
berá
modificarse
conveniente
modificar
sistema
operativo
dispositivo
aspecto
cuestión
interfaz
controladores
dispositivos
resto
sistema
operativo
figura
5-14(a
ilustramos
situación
controlador
dis-
www.FreeLibros.mepositivo
interfaz
distinta
sistema
operativo
significa
funcio-
nes
controlador
disponibles
sistema
llamarlas
difieren
controlador
significar
funciones
kernel
controlador
necesita
difieren
controlador
controlador
conjunto
interfaz
controla-
dor
requiere
esfuerzo
programación
354
ENTRADA
SALIDA
CAPÍTULO
Sistema
operativo
Sistema
operativo
Controlador
disco
SATA
Controlador
disco
IDE
Controlador
disco
SCSI
Controlador
disco
SATA
Controlador
disco
IDE
Controlador
disco
SCSI
Figura
5-14
interfaz
controlador
estándar
interfaz
con-
trolador
estándar
contrario
figura
5-14(b
diseño
distinto
con-
troladores
interfaz
fácil
conectar
controlador
siem-
pre
compatible
interfaz
significa
escritores
controladores
espera
práctica
dispositivos
absoluta-
mente
idénticos
general
pequeño
número
tipos
dispositivos
inclu-
so
general
iguales
funciona
clase
dispositivos
discos
impresoras
sistema
operativo
define
conjunto
funciones
controlador
pro-
porcionar
disco
funciones
incluyen
naturalmente
lectura
escritura
tam-
bién
encender
apagar
unidad
aplicar
formato
cosas
relacionadas
discos
controlador
contiene
tabla
apuntadores
funciones
Cuan-
do
carga
controlador
sistema
operativo
registra
dirección
tabla
apuntadores
funciones
necesita
llamar
funciones
llamada
indi-
recta
tabla
tabla
apuntadores
funciones
define
interfaz
contro-
lador
resto
sistema
operativo
dispositivos
clase
dada
discos
impresoras
etc.
obedecerla
aspecto
interfaz
uniforme
forma
nombran
dispositivos
software
independiente
dispositivo
cargo
asignar
nombres
dispositivo
simbólicos
controlador
apropiado
ejemplo
UNIX
nombre
dispositivo
/dev
disk0
espe-
cifica
única
nodo-i
archivo
especial
nodo-i
contiene
número
dispositivo
utiliza
localizar
controlador
apropiado
nodo-i
contiene
www
FreeLibros.meSECCIÓN
5.3
CAPAS
SOFTWARE
355
número
menor
dispositivo
pasa
parámetro
controlador
espe-
cificar
unidad
leer
escribir
dispositivos
números
mayores
me-
nores
acceder
controladores
utiliza
número
dispositivo
seleccionar
controlador
protección
relacionada
denominación
evita
sistema
usua-
rios
accedan
dispositivos
prohibido
utilizar
UNIX
Windows
dis-
positivos
aparecen
sistema
archivos
objetos
nombre
significa
reglas
protección
ordinarias
archivos
aplican
dispositivos
S.
administrador
sistema
establecer
permisos
apropiados
dispositivo
búfer
búfer
cuestión
dispositivos
bloque
carácter
variedad
razones
considere
proceso
desea
leer
datos
módem
estrategia
lidiar
caracteres
entrantes
proceso
usuario
rea-
lice
llamada
sistema
ready
bloquee
espera
carácter
carácter
llega
pro-
duce
interrupción
procedimiento
servicio
interrupciones
entrega
carácter
proceso
usuario
desbloquea
colocar
carácter
proceso
lee
ca-
rácter
bloquea
modelo
indica
figura
5-15(a
Proceso
usuario
Espacio
usuario
Espacio
kernel
22
11
Módem
Módem
Módem
Módem
Figura
5-15
Entrada
búfer
búfer
espacio
usuario
búfer
kernel
seguido
acción
copiar
espacio
usuario
do-
ble
búfer
kernel
problema
forma
cosas
proceso
usuario
iniciarse
carácter
entrante
Permitir
proceso
ejecute
tiempos
cortos
ejecución
ineficiente
diseño
figura
5-15(b
muestra
mejora
proceso
usuario
proporciona
búfer
caracteres
espacio
usuario
realiza
lectura
ncaracteres
procedimiento
servicio
www.FreeLibros.mede
interrupciones
coloca
caracteres
entrantes
búfer
llena
despierta
proceso
usuario
esquema
eficiente
desventaja
ocurre
búfer
pagina
llega
carácter
búfer
bloquear
memo-
ria
procesos
empiezan
bloquear
páginas
memoria
reducirá
reserva
páginas
disponibles
degradará
rendimiento
método
crear
búfer
kernel
manejador
interrupcio-
nes
coloque
caracteres
muestra
figura
5-15(c
búfer
lleno
trae
página
búfer
usuario
caso
necesario
búfer
copia
ope-
ración
esquema
eficiente
esquema
presenta
inconveniente
ocurre
caracteres
llegan
trayendo
disco
página
búfer
usuario
búfer
es-
tá
lleno
lugar
ponerlos
solución
búfer
kernel
llena
vaciado
utiliza
mues-
tra
figura
5-15(d
llena
búfer
disponible
copiarlo
usuario
suponiendo
usuario
pedido
búfer
copia
espacio
usua-
rio
utilizar
caracteres
forma
búferes
toman
tur-
copia
espacio
usuario
acumulando
datos
entrada
esquema
búferes
conoce
doble
búfer
forma
búfer
utiliza
ampliamente
búfer
circular
Consiste
región
memoria
apuntadores
apuntador
apunta
palabra
libre
colocar
datos
apuntador
apunta
palabra
datos
búfer
removido
situaciones
hardware
avanza
apuntador
medida
agrega
datos
ejemplo
acaban
llegar
red
sistema
ope-
rativo
avanza
apuntador
medida
elimina
procesa
datos
apuntadores
re-
gresan
llegar
superior
búfer
importante
salida
ejemplo
considere
envían
da-
tos
módem
búfer
modelo
figura
5-15(b
proceso
usuario
eje-
cuta
llamada
sistema
writepara
imprimir
caracteres
sistema
opciones
punto
bloquear
usuario
hayan
escrito
caracteres
re-
querir
tiempo
línea
telefónica
lenta
liberar
inmediato
usuario
operación
usuario
realiza
cálculos
pro-
duce
problema
proceso
usuario
completado
salida
reutilizar
búfer
sistema
generar
señal
interrupción
software
estilo
programación
difícil
propenso
condiciones
competencia
solución
kernel
copie
datos
búfer
similar
figura
5-15(c
sentido
opuesto
desbloquee
llamada
inmediato
importa
cuán-
do
completado
operación
S.
usuario
libre
reutilizar
búfer
instante
desbloquea
búferes
constituyen
técnica
utilizada
desventaja
da-
tos
colocan
búfer
demasiadas
rendimiento
reduce
ejemplo
considere
red
figura
5-16
usuario
realiza
llamada
sistema
escribir
red
kernel
copia
paquete
búfer
kernel
permitir
usuario
proceda
inmediato
paso
punto
programa
usuario
reutilizar
búfer
356
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.3
CAPAS
SOFTWARE
357
llamada
controlador
copia
paquete
controlador
enviarlo
salida
paso
razón
envía
directamente
cable
memoria
kernel
iniciada
transmisión
paquete
continuar
velocidad
uniforme
controla-
dor
garantizar
llegar
memoria
velocidad
uniforme
canales
DMA
dispositivos
robando
ciclos
obtiene
palabra
tiempo
arruinar
paquete
colocar
búfer
paquete
con-
trolador
evita
problema
copiado
paquete
búfer
interno
controlador
copia
red
paso
bits
llegan
receptor
enviados
justo
enviar
bit
llega
receptor
paquete
colocado
búfer
con-
trolador
continuación
paquete
copia
búfer
kernel
receptor
paso
copia
búfer
proceso
receptor
paso
generalmente
receptor
envía
reconoci-
miento
emisor
recibe
reconocimiento
enviar
paquete
embar-
go
quedar
proceso
copia
reduce
velocidad
transmisión
considerable
pasos
cabo
forma
secuencial
Reporte
errores
errores
comunes
contexto
ocurren
sis-
tema
operativo
manejarlos
errores
específicos
ca-
dispositivo
controlador
apropiado
manejarlos
marco
trabajo
manejo
errores
independiente
dispositivo
errores
programación
clase
errores
S.
ocurren
proce-
so
pide
imposible
escribir
dispositivo
entrada
teclado
escáner
ratón
etc.
leer
dispositivo
salida
impresora
plotter
ejemplo
errores
propor-
Proceso
usuario
Red
Controlador
red
Espacio
usuario
Espacio
kernel
Figura
5-16
trabajo
red
involucrar
copias
paquete
www.FreeLibros.mecionar
dirección
búfer
inválida
parámetro
especificar
dispositivo
inválido
ejemplo
disco
sistema
acción
tomar
errores
simple
reporta
código
error
llamada
clase
errores
reales
ejemplo
tratar
escribir
bloque
disco
da-
ñado
tratar
leer
cámara
video
apagada
circunstancias
depende
controlador
determinar
controlador
pasar
problema
vuelta
software
independiente
dispositivo
software
depende
entorno
naturaleza
error
error
simple
lectura
usuario
interactivo
disponible
mostrar
cuadro
diálogo
pidien-
do
usuario
opciones
incluir
volver
intentar
número
ve-
ces
ignorar
error
eliminar
proceso
llamada
usuario
disponible
única
opción
real
llamada
sistema
falle
código
error
errores
manejar
forma
ejemplo
estructu-
ra
datos
crítica
directorio
raíz
lista
bloques
libres
haberse
destruido
caso
sistema
mostrar
mensaje
error
terminar
Asignación
liberación
dispositivos
dedicados
dispositivos
grabadores
CD-ROM
utilizados
proceso
momento
responsabilidad
sistema
operativo
examinar
peticiones
dispositivos
aceptarlas
rechazarlas
dependiendo
dispositivo
solicitado
disponible
simple
manejar
peticiones
requerir
procesos
rea-
licen
llamadas
openen
archivos
especiales
dispositivos
directamente
disposi-
tivo
disponible
llamada
open
falla
cerrar
dispositivo
dedicado
tipo
libera
método
alternativo
mecanismos
especiales
solicitar
liberar
dispositivos
de-
dicados
intento
adquirir
dispositivo
disponible
bloquea
proceso
llamada
fallar
procesos
bloqueados
ponen
cola
dispositivo
solicitado
disponible
proceso
cola
adquirirlo
conti-
nuar
ejecución
Tamaño
bloque
independiente
dispositivo
distintos
discos
tamaños
sectores
responsabilidad
software
independiente
dispositivo
ocultar
proporcionar
tamaño
bloque
uniforme
niveles
superiores
ejemplo
tratar
sectores
bloque
lógico
forma
niveles
superiores
lidian
dispositivos
abstractos
utilizan
tamaño
bloque
lógico
importar
tamaño
sector
físico
similar
dis-
positivos
carácter
envían
datos
byte
módems
en-
vían
datos
unidades
interfaces
red
diferencias
ocultar
358
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.3
CAPAS
SOFTWARE
359
5.3.4
Software
espacio
usuario
software
sistema
operativo
pequeña
porción
consiste
bibliotecas
vinculadas
programas
usuario
programas
enteros
ejecutan
exterior
kernel
llamadas
sistema
incluyendo
llama-
das
sistema
realizan
comúnmente
procedimientos
biblioteca
programa
contiene
llamada
write(da
bufer
nbytes
procedimiento
biblioteca
write
vinculará
programa
incluirá
programa
bi-
nario
presente
memoria
tiempo
ejecución
colección
procedimientos
biblioteca
duda
sistema
S.
procedimientos
colocar
parámetros
lugar
apropia-
do
llamada
sistema
procedimientos
realidad
realizan
trabajo
real
especial
formato
entrada
salida
cabo
procedimientos
bi-
blioteca
ejemplo
printf
toma
cadena
formato
posiblemente
variables
entrada
construye
cadena
ASCII
llama
sistema
writepara
imprimir
ca-
dena
ejemplo
printf
considere
instrucción
printf(“El
cuadrado
3d
6d\n
i*i
instrucción
formato
cadena
consiste
cadena
14
caracteres
cuadrado
seguida
valor
cadena
caracteres
cadena
caracteres
caracteres
salto
línea
ejemplo
procedimiento
similar
entrada
scanf
lee
datos
entrada
almacena
variables
descritas
cadena
formato
utiliza
sintaxis
printf
biblioteca
estándar
contiene
procedimientos
involucran
operaciones
ejecutan
programas
usuario
software
nivel
consiste
procedimientos
biblioteca
cate-
goría
importante
sistema
colas
colas
spooling
lidiar
dispositivos
dedicados
sistema
multiprogramación
Considere
dispositivo
co-
mún
utiliza
colas
impresora
técnicamente
sencillo
dejar
pro-
ceso
usuario
abriera
archivo
caracteres
especial
impresora
suponga
proceso
abriera
hiciera
horas
proceso
imprimir
crear
proceso
especial
conocido
demonio
di-
rectorio
especial
llamado
directorio
cola
impresión
imprimir
archivo
proceso
genera
archivo
imprimir
coloca
directorio
cola
impre-
sión
responsabilidad
demonio
único
proceso
permiso
archi-
vo
especial
impresora
imprimir
archivos
directorio
proteger
archivo
especial
directo
usuarios
elimina
problema
alguien
mantenga
abierto
tiempo
innecesariamente
extenso
colas
exclusivo
impresoras
utiliza
situaciones
S.
ejemplo
transferencia
archivos
red
utiliza
frecuencia
demo-
nio
red
enviar
archivo
usuario
coloca
directorio
cola
www.FreeLibros.mered
demonio
red
toma
transmite
específico
transmisión
archivos
cola
sistema
noticias
USENET
red
consiste
millo-
nes
máquinas
mundo
comunican
Internet
miles
grupos
noticias
temas
publicar
mensaje
usuario
invoca
programa
no-
ticias
acepta
mensaje
publicar
deposita
directorio
cola
trans-
mitirlo
máquinas
sistema
noticias
ejecuta
sistema
operativo
figura
5-17
resume
sistema
muestran
niveles
fun-
ciones
principales
nivel
Empezando
inferior
niveles
hardware
manejadores
interrupciones
controladores
dispositivos
software
independiente
dis-
positivo
procesos
usuario
360
ENTRADA
SALIDA
CAPÍTULO
Petición
Nivel
Respuesta
Funciones
llamada
aplicar
formato
cola
Nombramiento
protección
bloqueo
búfer
asignación
Establecer
registros
dispositivo
verificar
Despertar
controlador
completa
operación
Procesos
usuario
Software
independiente
dispositivo
Controladores
dispositivos
Manejadores
interrupciones
Hardware
Figura
5-17
Niveles
sistema
funciones
principales
nivel
flechas
figura
5-17
muestran
flujo
control
ejemplo
programa
usuario
leer
bloque
archivo
invoca
sistema
operativo
cabo
llamada
software
independiente
dispositivo
busca
bloque
caché
búfer
ejem-
plo
bloque
necesario
llama
controlador
dispositivo
enviar
petición
hardware
obtenerlo
disco
proceso
bloquea
completado
operación
disco
termina
disco
hardware
genera
interrupción
manejador
interrupciones
ejecuta
descubrir
ocurrió
dispositivo
desea
atención
momento
Des-
pués
extrae
dispositivo
despierta
proceso
inactivo
termine
petición
deje
proceso
usuario
continúe
5.4
DISCOS
estudiar
dispositivos
reales
Empezaremos
discos
concepto
simples
importantes
examinaremos
relojes
teclados
pantallas
www
FreeLibros.meSECCIÓN
5.4
DISCOS
361
5.4.1
Hardware
disco
discos
tipos
comunes
discos
magnéticos
discos
duros
flexibles
caracterizan
operaciones
lectura
escritura
rápidas
ideales
memoria
secundaria
paginación
sistemas
archivos
ejemplo
utilizan
arreglos
discos
ofrecer
almacenamiento
altamente
confia-
ble
distribución
programas
datos
películas
importantes
tipos
dis-
cos
ópticos
CD-ROMs
CD-grabable
DVD
siguientes
secciones
describiremos
hardware
software
dispositivos
Discos
magnéticos
discos
magnéticos
organizan
cilindros
contiene
tantas
pistas
co-
mo
cabezas
apiladas
forma
vertical
pistas
dividen
sectores
número
sectores
al-
rededor
circunferencia
general
32
discos
flexibles
cientos
discos
duros
número
cabezas
varía
16
discos
antiguos
componentes
electrónicos
producen
flujo
bits
se-
rial
simple
discos
controlador
realiza
trabajo
discos
es-
pecial
discos
IDE
Electrónica
Unidad
Integrada
SATA
ATA
Serial
unidad
disco
contiene
microcontrolador
realiza
trabajo
considerable
permite
controlador
real
emitir
conjunto
comandos
nivel
superior
controlador
coloca
pistas
ca-
ché
reasigna
bloques
defectuosos
característica
dispositivo
implicaciones
importantes
software
contro-
lador
disco
posibilidad
controlador
realice
búsquedas
unidades
tiempo
conocen
búsquedas
traslapadas
controlador
soft-
ware
esperan
complete
búsqueda
unidad
controlador
iniciar
bús-
queda
unidad
controladores
leer
escribir
unidad
buscan
unidades
controlador
disco
flexible
leer
escribir
unidades
tiempo
leer
escribir
controlador
desplazar
bits
escala
tiempo
microsegundos
transferencia
ocupa
cómputo
situación
distinta
discos
duros
controladores
integrados
sistema
unidades
disco
duro
operar
simultánea
transferencia
datos
disco
memoria
búfer
controlador
transferencia
controlador
memoria
principal
ca-
pacidad
operaciones
tiempo
reducir
tiempo
acceso
pro-
considerable
figura
5-18
comparan
parámetros
almacenamiento
estándar
IBM
PC
original
parámetros
disco
fabricado
20
años
mostrar
cambiado
discos
20
años
interesante
observar
parámetros
me-
jorado
tiempo
búsqueda
promedio
veloci-
dad
transferencia
1300
capacidad
aumentó
factor
www
FreeLibros.me50,000
patrón
relacionado
mejoras
relativamente
graduales
piezas
móviles
densidades
bits
mayores
superficies
grabación
362
ENTRADA
SALIDA
CAPÍTULO
Parámetro
Disco
flexible
IBM
360-KB
Disco
duro
WD
18300
Número
cilindros
40
10601
Pistas
cilindro
12
Sectores
pista
281
promedio
Sectores
disco
720
35742000
Bytes
sector
512
512
Capacidad
disco
360
KB
18.3
GB
Tiempo
búsqueda
cilindros
adyacentes
mseg
0.8
mseg
Tiempo
búsqueda
caso
promedio
77
mseg
6.9
mseg
Tiempo
rotación
200
mseg
8.33
mseg
Tiempo
arranque
paro
motor
250
mseg
20
seg
Tiempo
transferir
sector
22
mseg
17
µseg
Figura
5-18
Parámetros
disco
disco
flexible
IBM
PC
360
KB
original
disco
duro
Western
Digital
WD
18300
debemos
analizar
especificaciones
discos
duros
moder-
geometría
especificada
utilizada
controlador
distinta
formato
físico
discos
antiguos
número
sectores
pista
cilindros
discos
modernos
dividen
zonas
sectores
zonas
exteriores
interiores
figura
5-19(a
ilustra
pequeño
disco
zonas
zona
exterior
32
sectores
pista
interior
16
sectores
pista
disco
real
WD
18300
tie-
ne
general
16
zonas
número
sectores
incrementa
4%
zona
medida
avanza
zona
interior
exterior
ocultar
detalles
sectores
pista
mayoría
discos
mo-
dernos
geometría
virtual
presenta
sistema
operativo
instruye
software
pa-
ra
actúe
hubiera
cilindros
cabezas
sectores
pista
controlador
reasigna
petición
valores
reales
cilindro
cabeza
sector
geo-
metría
virtual
disco
físico
figura
5-19(a
muestra
figura
5-19(b
ca-
sos
disco
192
sectores
arreglo
publicado
distinto
real
PCs
valores
máximos
parámetros
5535
16
63
necesidad
compatibilidad
atrás
limitaciones
IBM
PC
original
máquina
utilizaron
campos
16
bits
especificar
números
cilin-
dros
sectores
enumerados
empiezan
cabezas
enumeradas
empiezan
pa-
rámetros
512
bytes
sector
disco
31.5
GB
sobrepasar
límite
discos
modernos
aceptan
sistema
llamado
direccionamiento
bloques
www
FreeLibros.meSECCIÓN
5.4
DISCOS
363
lógicos
sectores
disco
enumeran
forma
consecutiva
empezando
importar
geometría
disco
RAID
rendimiento
CPU
crecido
forma
exponencial
década
duplica
18
meses
pasa
rendimiento
disco
década
1970
tiempos
búsqueda
promedio
discos
minicomputadoras
50
100
mseg
ligeramente
10
mseg
mayoría
industrias
técnicas
ejem-
plo
automóviles
aviación
factor
10
mejora
rendimiento
dé-
cadas
serían
noticias
imagine
autos
300
millas
galón
industria
computadoras
vergüenza
ende
brecha
rendimiento
CPU
rendimien-
to
disco
vuelto
tiempo
visto
procesamiento
paralelo
utiliza
agilizar
rendi-
miento
CPU
paso
años
personas
ocurrido
para-
lelo
idea
artículo
1988
Patterson
colaboradores
sugirieron
organizaciones
discos
específicas
utilizar
mejorar
rendimiento
dis-
co
confiabilidad
ambas
características
Patterson
colaboradores
1988
ideas
adoptadas
inmediato
industria
conllevado
clase
dispositivo
co-
nocido
RAID
Patterson
colaboradores
definieron
RAID
Arreglo
Redundante
Discos
Económicos
Redundant
Array
of
Inexpensive
Disks
industria
redefinió
indicara
Independiente
económico
pudieran
cobrar
necesitaba
villano
RISC
CISC
Patterson
tipo
malo
SLED
Single
Large
Expensive
Disk
disco
costoso
6789101112131415
10
11
12
13141516171819
20
21
22
23
24
25
26
27
28
29
30
31
89
10
11121314
15
16
17
18
19
20
21
22
23
24
Figura
5-19
Geometría
física
disco
zonas
geome-
tría
virtual
disco
www
FreeLibros.meLa
idea
básica
RAID
instalar
caja
llena
discos
compu-
tadora
general
servidor
reemplazar
tarjeta
controladora
discos
controlador
RAID
copiar
datos
RAID
continuar
operación
normal
palabras
RAID
SLED
sistema
operativo
rendi-
miento
confiabilidad
discos
SCSI
rendimiento
costo
capa-
cidad
unidades
controlador
15
SCSI
amplio
natural
mayoría
RAIDs
consistan
controlador
RAID
SCSI
caja
discos
SCSI
sistema
operativo
considere
disco
forma
requieren
cam-
bios
software
utilizar
RAID
punto
venta
administradores
sistemas
aparecer
disco
software
RAIDs
propiedad
datos
distribuyen
unidades
permitir
operación
paralelo
Patterson
colaboradores
definieron
esquemas
distintos
conocen
RAID
nivel
RAID
nivel
niveles
menores
analizaremos
término
nivel
equivocado
jerarquía
involucrada
simplemen-
organizaciones
distintas
posibles
nivel
RAID
ilustra
figura
5-20(a
Consiste
disco
virtual
simulado
RAID
estuviera
dividido
bandas
sectores
sectores
/H110021
banda
sectores
2k
/H110021
banda
sucesivo
/H110051
ca-
banda
sector
/H110052
banda
sectores
etc.
organización
RAID
nivel
escribe
bandas
consecutivas
unidades
utilizando
método
turno
rotatorio
round-robin
muestra
figura
5-20(a
RAID
unidades
disco
proceso
distribuir
datos
unidades
forma
conoce
re
par-
to
bloques
striping
ejemplo
software
emite
comando
leer
blo-
datos
bloques
consecutivos
empieza
límite
bloque
controlador
RAID
descompondrá
comando
comandos
separados
cua-
tro
discos
hará
operen
paralelo
paralelo
software
sepa
nivel
RAID
funciona
peticiones
mayores
petición
número
unidades
multiplicado
tamaño
bloques
algu-
nas
unidades
obtendrán
peticiones
terminen
petición
empeza-
rán
responsabilidad
controlador
dividir
petición
alimentar
comandos
apropiados
discos
apropiados
secuencia
correcta
ensamblar
correctamente
resultados
memoria
rendimiento
excelente
implementación
sencilla
nivel
AID
funciona
sistemas
operativos
habitualmente
piden
datos
sector
resultados
correctos
paralelismo
ende
aumenta
rendimiento
desventaja
organización
confiabilidad
potencialmente
SLED
RAID
consiste
discos
tiempo
falla
promedio
20,000
horas
5,000
fallará
unidad
datos
perderán
completo
SLED
tiempo
promedio
falla
20,000
horas
confiable
redundancia
presente
diseño
realidad
RAID
opción
nivel
RAID
muestra
figura
5-20(b
RAID
ver-
dadero
Duplica
discos
discos
primarios
discos
respal-
364
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.4
DISCOS
365
do
operación
escritura
bloque
escribe
lectura
utili-
zar
cualquiera
copias
distribuye
carga
unidades
consecuencia
rendimiento
escritura
unidad
rendimiento
lectura
doble
tolerancia
fallas
excelente
unidad
falla
simplemente
utiliza
copia
recuperación
consiste
instalar
unidad
copiar
uni-
dad
respaldo
diferencia
niveles
funcionan
bandas
sectores
nivel
RAID
funciona
palabra
byte
Imagine
dividir
byte
disco
virtual
par
medios
bits
nibbles
bits
agregar
código
Hamming
for-
mar
palabra
bits
bits
bits
paridad
Imagine
uni-
dades
figura
5-20(c
sincronizan
términos
posición
brazo
posición
rotacional
escribir
palabra
código
Hamming
bits
unidades
byte
unidad
computadora
Thinking
Machines
CM-2
utilizaba
esquema
Tomaba
palabras
datos
32
bits
agregaba
bits
paridad
formar
palabra
Hamming
38
bits
bit
adicional
paridad
palabra
esparcía
palabra
39
unidades
disco
tasa
transferencia
inmensa
tiempo
sector
podía
escribir
32
sectores
datos
perder
disco
problemas
significaba
perder
bit
lectura
palabra
39
bits
código
Hamming
solucionaría
instante
negativo
esquema
requiere
unidades
sincronicen
forma
ro-
tacional
sentido
número
considerable
unidades
32
unidades
datos
unidades
paridad
sobrecarga
19%
exige
controlador
suma
comprobación
Hamming
tiempo
bit
nivel
RAID
versión
simplificada
nivel
RAID
ilustra
figura
5-20(d
calcula
bit
paridad
palabra
datos
escribe
unidad
pari-
dad
nivel
RAID
unidades
sincronización
exacta
palabras
datos
individuales
distribuidas
unidades
instancia
parecer
bit
paridad
proporciona
detección
corrección
errores
caso
errores
aleatorios
detectados
observación
caso
falla
unidad
proporciona
corrección
error
bit
posición
bit
defectuoso
conoce
unidad
falla
controlador
simula
bits
palabra
error
paridad
bit
unidad
defec-
tuosa
corrige
niveles
RAID
ofrecen
velocida-
des
transferencia
datos
altas
número
peticiones
separadas
manejar
unidad
niveles
RAID
funcionan
bloques
palabras
individuales
paridad
requieren
unidades
sincronizadas
nivel
RAID
véase
figura
5-20(e
co-
mo
nivel
escribe
paridad
banda
banda
unidad
adicional
ejem-
plo
banda
bytes
aplica
OR
EXCLUSIVO
bloques
obtiene
resultado
bloque
paridad
bytes
unidad
falla
bytes
perdidos
recalcular
bit
paridad
leyendo
conjunto
completo
unidades
diseño
protege
pérdida
unidad
desempeño
pobre
actualizaciones
pequeñas
cambia
sector
necesario
leer
unidades
re-
www
FreeLibros.me366
ENTRADA
SALIDA
CAPÍTULO
P16-19
Bloque
16
Bloque
17
Bloque
18
Bloque
12
P12-15
Bloque
13
Bloque
14
RAID
nivel
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
10
Bloque
Bloque
RAID
nivel
Bloque
11
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
10
Bloque
Bloque
Bloque
11
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
10
Bloque
Bloque
Bloque
11
Bloque
Bloque
Bit
Bit
Bit
Bit
Bit
Bit
RAID
nivel
Bit
Bit
Bit
Bit
Bit
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
10
Bloque
Bloque
Bloque
11
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
Bloque
P8-11
Bloque
Bloque
Bloque
10
P4-7
Bloque
Bloque
19
Bloque
15
RAID
nivel
RAID
nivel
RAID
nivel
Paridad
P8-11
P4-7
P0-3
Bloque
11
Bloque
P0-3
Figura
5-20
Niveles
RAID
unidades
respaldo
paridad
mues-
tran
sombreadas
www
FreeLibros.meSECCIÓN
5.4
DISCOS
367
calcular
paridad
volver
escribir
alternativa
leer
datos
antiguos
usuario
datos
antiguos
paridad
recalcular
paridad
optimización
pequeña
actualización
requiere
lecturas
es-
crituras
consecuencia
pesada
carga
unidad
paridad
convertirse
cuello
botella
elimina
nivel
RAID
distribuir
bits
paridad
unifor-
unidades
turno
rotatorio
round-robin
muestra
figura
5-20(f
caso
falla
unidad
reconstrucción
contenido
unidad
fallida
proceso
complejo
CD-ROMs
años
recientes
empezado
utilizar
discos
ópticos
contraste
magnéticos
Es-
tos
discos
densidades
grabación
altas
discos
magnéticos
convencio-
nales
discos
ópticos
desarrollaron
principio
grabar
programas
televisión
estético
dispositivos
almacenamiento
computadora
Debi-
do
capacidad
potencialmente
enorme
discos
ópticos
tema
cantidad
investigación
evolución
increíblemente
rápida
discos
ópticos
generación
inventados
conglomerado
electróni-
ca
holandés
Philips
contener
películas
Tenían
30
centímetros
diámetro
comercializa-
ron
nombre
LaserVision
tuvieron
popularidad
Japón
1980
Philips
Sony
desarrollaron
CD
Disco
Compacto
sustituyó
rápidamente
disco
vinilo
33
1/3
RPM
utilizaba
música
conocedores
preferían
vinilo
detalles
técnicos
precisos
CD
publicaron
Estándar
In-
ternacional
oficial
IS
10149
conocido
popularmente
Libro
rojo
color
portada
Estándares
Internacionales
emitidos
Organización
Internacional
Están-
dares
contraparte
internacional
grupos
estándares
nacionales
ANSI
DIN
etc.
número
IS
punto
publicar
especificaciones
discos
unidades
estándar
internacional
permitir
CDs
distintas
compa-
ñías
disqueras
reproductores
distintos
fabricantes
electrónicos
puedan
funcionar
con-
CDs
120
mm
diámetro
1.2
mm
grosor
hoyo
15
mm
CD
audio
almacenamiento
digital
masivo
mercado
supone
durar
100
años
favor
consulte
2080
lote
CD
prepara
pasos
consiste
utilizar
láser
infrarrojo
alto
po-
der
quemar
hoyos
0.8
micrones
diámetro
disco
maestro
cubierta
vidrio
disco
maestro
fabrica
molde
protuberancias
lugar
hoyos
láser
molde
inyecta
resina
policarbonato
fundido
formar
CD
patrón
hoyos
disco
maestro
vidrio
deposita
capa
delgada
aluminio
reflectivo
policarbonato
cubierta
laca
protectora
finalmente
etiqueta
de-
presiones
sustrato
policarbonato
llaman
hoyos
pits
áreas
quemadas
ho-
yos
llaman
áreas
lisas
lands
www
FreeLibros.meCuando
reproduce
diodo
láser
baja
energía
emite
luz
infrarroja
longitud
on-
0.78
micrones
hoyos
áreas
lisas
medida
pasando
láser
policarbonato
hoyos
salen
láser
protuberancias
superficie
área
lisa
hoyos
altura
cuarto
longitud
onda
luz
láser
luz
refleja
hoyo
desfasada
media
longitud
onda
luz
refleja
su-
perficie
circundante
resultado
partes
interfieren
forma
destructiva
devuelven
me-
luz
fotodetector
reproductor
luz
rebota
área
lisa
reproductor
diferenciar
hoyo
área
lisa
parecer
simple
utilizar
hoyo
grabar
área
lisa
grabar
confiable
utilizar
transición
hoyo
área
li-
sa
área
lisa
hoyo
ausencia
utiliza
esquema
hoyos
áreas
lisas
escriben
espiral
continua
empieza
cerca
ho-
recorre
distancia
32
mm
borde
espiral
realiza
22,188
revoluciones
alrede-
dor
disco
600
milímetro
desenredara
tendría
5.6
km
espiral
ilustra
figura
5-21
368
ENTRADA
SALIDA
CAPÍTULO
Ranura
espiral
Hoyo
Área
lisa
Bloque
datos
usuario
Figura
5-21
Estructura
grabación
disco
compacto
CD-ROM
reproducir
música
velocidad
uniforme
necesario
flujo
continuo
hoyos
áreas
velocidad
lineal
constante
consecuencia
velocidad
rotación
CD
reducir
forma
continua
medida
cabeza
lectura
desplaza
interna
CD
externa
interior
velocidad
rotación
530
RPM
lograr
ve-
locidad
flujo
continuo
deseada
120
cm
seg
exterior
reducirse
200
RMP
pa-
ra
proporcionar
velocidad
lineal
cabeza
unidad
velocidad
lineal
constante
distinta
unidad
disco
magnético
opera
velocidad
angular
constante
importar
encuentre
cabeza
momento
530
RPM
lejos
3600
7200
RPM
giran
mayoría
discos
magnéticos
1984
Philips
Sony
potencial
utilizar
CDs
almacenar
datos
computadora
publicaron
Libro
amarillo
define
estándar
preciso
www
FreeLibros.meSECCIÓN
5.4
DISCOS
369
conoce
CD-ROMs
Compact
disk-read
only
memory
Disco
compacto–memoria
lectura
apoyarse
mercado
CDs
audio
con-
siderable
CD-ROMs
tenían
tamaño
físico
CDs
audio
compa-
tibles
sentido
mecánico
óptico
debían
producir
utilizando
máquinas
moldeado
inyección
policarbonato
consecuencias
decisión
só-
requerían
motores
lentos
velocidad
variable
costo
fabricación
CD-ROM
estaría
dólar
volumen
moderado
definió
Libro
amarillo
formato
datos
computadora
mejoró
habilidades
corrección
errores
sistema
paso
esencial
amantes
música
importaba
perder
allá
amantes
computadoras
tendían
Exigentes
formato
básico
CD-ROM
consiste
codificar
byte
símbolo
14
bits
suficiente
código
Hamming
byte
bits
bits
sobra
utiliza
sistema
codificación
potente
asig-
nación
14
lectura
realiza
hardware
búsqueda
tabla
nivel
grupo
42
símbolos
consecutivos
forma
estructu-
ra
588
bits
estructura
contiene
192
bits
datos
24
bytes
396
bits
restantes
uti-
lizan
corrección
control
errores
252
bits
corrección
errores
símbolos
14
bits
144
llevan
transmisiones
símbolos
bits
esquema
idéntico
CDs
audio
CD-ROMs
agrega
Libro
amarillo
agrupamiento
98
estructuras
sector
CD-ROM
muestra
figura
5-22
sector
CD-ROM
empieza
preám-
bulo
16
bytes
12
00FFFFFFFFFFFFFFFFFFFF00
hexadecimal
pa-
ra
permitir
reproductor
reconozca
inicio
sector
CD-ROM
siguientes
bytes
contienen
número
sector
requiere
difícil
búsque-
das
CD-ROM
espiral
datos
disco
magnético
pistas
con-
céntricas
uniformes
buscar
software
unidad
calcula
desplaza
cabeza
empieza
buscar
preámbulo
aproximación
byte
preámbulo
Preámbulo
Bytes
16
Datos
2048
288
ECC
Sector
2352
bytes
estructura
contiene
192
bits
datos
24
bytes
396
bits
corrección
errores
símbolo
contiene
bits
datos
bits
corrección
errores
42
símbolos
forman
trama
14
42
588
bits
98
tramas
forman
sector
Figura
5-22
Distribución
lógica
datos
CD-ROM
Libro
amarillo
define
modos
utiliza
distribución
figura
5-22
preámbulo
16
bytes
2048
bytes
datos
código
corrección
errores
288
bytes
www
FreeLibros.me(un
código
Reed-Solomon
cruzado
entrelazado
combina
campos
datos
ECC
campo
datos
2336
bytes
aplicaciones
necesitan
darse
tiempo
cabo
corrección
errores
audio
video
ofrecer
excelente
confiabilidad
utilizan
esquemas
separados
correc-
ción
errores
símbolo
estructura
sector
CD-ROM
errores
bit
corrigen
nivel
errores
ráfagas
cortas
corrigen
nivel
estructura
errores
residuales
atrapan
nivel
sector
precio
pagar
confiabilidad
requieren
98
estructuras
588
bits
7203
bytes
ca-
bo
transferencia
2048
bytes
eficiencia
28%
unidades
CD-ROM
velocidad
operan
75
sectores
seg
ob-
velocidad
transferencia
datos
153,600
bytes
seg
175,200
by-
tes
seg
unidades
doble
velocidad
doble
rápidas
sucesivo
velocidad
alta
ende
unidad
40x
transferir
datos
velocidad
40
/H11003153,600
bytes
seg
suponiendo
interfaz
unidad
bus
sistema
operati-
vo
puedan
manejar
velocidad
transferencia
datos
CD
audio
estándar
es-
pacio
74
minutos
música
utilizan
datos
logran
capacidad
681,984,000
bytes
cifra
reporta
comúnmente
650
MB
MB
equi-
vale
20
bytes
1,048,576
bytes
1,000,000
bytes
siquiera
unidad
CD-ROM
32x
4,915,200
bytes
frente
unidad
disco
magnético
SCSI
rápida
10
MB
seg
unidades
CD-ROM
utilizan
interfaz
SCSI
unidades
IDE
CD-ROM
tiempo
búsqueda
generalmente
cientos
milisegundos
queda
cla-
ro
unidades
CD-ROM
categoría
rendimiento
unidades
disco
magnético
capacidad
1986
Philips
publicó
Libro
verde
agregando
gráficos
habilidad
entrelazar
audio
video
datos
sector
característica
esencial
CD-ROMs
multimedia
pieza
rompecabezas
CD-ROM
sistema
archivos
po-
sible
CD-ROM
distintas
computadoras
necesario
siste-
archivos
CD-ROM
llegar
reunieron
representantes
compañías
computadoras
Lake
Tahoe
región
High
Sierra
límite
California
Nevada
idearon
sistema
archivos
llamaron
High
Sierra
evolucionó
Estándar
Internacional
IS
9660
niveles
nivel
utiliza
nombres
archivo
caracteres
seguidos
opcionalmente
extensión
caracteres
convención
de-
nominación
archivos
MS-DOS
nombres
archivo
contener
letras
mayúscu-
dígitos
guión
directorios
anidar
niveles
nombres
directorios
contener
extensiones
nivel
requiere
archivos
contiguos
problema
escribe
CD-ROM
cumpla
nivel
IS
9660
leer
utilizando
MS-DOS
computadora
Apple
computadora
UNIX
computadora
editores
CD-ROMs
consideran
propiedad
ventaja
nivel
IS
9660
permite
nombres
32
caracteres
nivel
permite
archivos
contiguos
extensiones
Rock
Ridge
denominadas
honor
ciudad
desarrolla
filme
Gene
Wilder
llamado
Blazing
Saddles
permiten
nombres
largos
UNIX
370
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.4
DISCOS
371
UIDs
GIDs
vínculos
simbólicos
CD-ROMs
cumplan
nivel
leerse
computadoras
CD-ROMs
vuelto
extremo
populares
publicar
juegos
películas
enciclope-
atlas
trabajos
referencia
tipo
mayoría
software
comercial
viene
CD-ROM
combinación
capacidad
costo
fabricación
adecuados
innumerables
aplicaciones
CD-Grabables
principio
equipo
necesario
producir
CD-ROM
maestro
CD
audio
cuestión
extremadamente
costoso
industria
computadoras
na-
permanece
costoso
tiempo
mediados
década
1990
grabadores
CDs
reproductor
CD
periférico
común
disponible
mayoría
tiendas
computadoras
dispositivos
seguían
distintos
discos
magnéticos
por-
escribía
información
podía
borrarse
rápidamente
en-
contraron
nicho
respaldo
discos
duros
permitieron
individuos
empresas
iniciaban
operaciones
fabricaran
CD-ROMs
distribución
limitada
crear
CDs
maestros
entregarlos
plantas
duplicación
CDs
comerciales
al-
to
volumen
unidades
conocen
CD-Rs
CD-Grabables
Físicamente
CD-Rs
empiezan
discos
blanco
policarbonato
120
mm
similares
CD-ROMs
contienen
ranura
0.6
mm
ancho
guiar
láser
escritura
ranura
excursión
sinoidal
0.3
mm
frecuencia
exacta
22.05
kHz
proveer
retroalimentación
continua
velocidad
rotación
supervisar
ajustar
precisión
caso
necesario
CD-Rs
apa-
riencia
similar
CD-ROMs
superior
dorada
lugar
plateada
color
dorado
proviene
oro
aluminio
capa
reflec-
tora
diferencia
CDs
plateados
contienen
depresiones
físicas
CD-Rs
distinta
reflectividad
hoyos
áreas
lisas
simular
agregar
capa
co-
lorante
policarbonato
capa
oro
reflectiva
muestra
figura
5-23
uti-
lizan
tipos
colorante
cianina
verde
ptalocianina
color
naranja
amarillo
químicos
argumentar
indefinidamente
colorantes
similares
utilizan
fotografía
explica
Eastman
Kodak
Fuji
principales
fabricantes
CD-Rs
blanco
inicial
capa
colorante
transparente
permite
luz
láser
pase
tra-
vés
refleje
capa
dorada
escribir
láser
CD-R
pone
alto
16
mW
haz
golpea
punto
colorante
calienta
quebranta
lazo
químico
cambio
estructura
molecular
crea
punto
oscuro
lee
vuelta
0.5
mW
fotodetector
ve
diferencia
puntos
oscuros
golpeado
colorante
áreas
transparentes
intacto
diferencia
interpreta
diferencia
ho-
yos
áreas
lisas
lea
nuevamente
lector
CD-ROM
regular
reproductor
CD
audio
tipo
CD
andar
frente
alto
libro
colores
CD-R
Libro
naranja
publicado
1989
documento
define
CD-R
www.FreeLibros.menuevo
formato
CD-ROM
XA
permite
escribir
CD-Rs
forma
incremental
sectores
mañana
mes
grupo
sectores
conse-
cutivos
escriben
llama
pista
CD-ROM
usos
CD-R
PhotoCD
Kodak
sistema
clien-
trae
rollo
película
expuesta
viejo
PhotoCD
procesador
fotografías
obtiene
vuelta
PhotoCD
agregan
fotografías
anteriores
lote
crea
explorar
negativos
escribe
PhotoCD
pista
separa-
CD-ROM
requería
escritura
incremental
introdujo
pro-
ducto
CD-R
blanco
costosos
ofrecer
rollo
película
escritura
incremental
crea
problema
Libro
naranja
CD-ROMs
tenían
VTOC
Volume
Table
of
Contents
Tabla
contenido
volumen
principio
esquema
funciona
escrituras
incrementales
pistas
solución
Libro
naranja
proporcionar
pista
CD-ROM
VTOC
archivos
listan
VTOC
incluir
archivos
pistas
anteriores
inserta
CD-R
unidad
sistema
operativo
busca
pistas
CD-ROM
localizar
VTOC
reciente
proporciona
actual
disco
incluir
archivos
pistas
anteriores
VTOC
actual
ilu-
sión
eliminado
archivos
pistas
agrupar
sesiones
conlleva
CD-ROMs
multisesión
reproductores
CDs
audio
estándar
manejar
CDs
multisesión
esperan
VTOC
principio
aplicaciones
computadora
manejarlos
372
ENTRADA
SALIDA
CAPÍTULO
Etiqueta
impresa
Laca
protectora
Capa
dorada
reflectora
capa
Sustrato
Dirección
movimiento
Lentes
Fotodetector
Prisma
Diodo
láser
infrarrojo
Punto
oscuro
capa
colorante
quemada
láser
escribir
1.2
mm
Colorante
Policarbonato
Figura
5-23
Sección
transversal
disco
CD-R
láser
escala
CD-ROM
plateado
estructura
similar
capa
colorante
capa
aluminio
picada
capa
dorada
www
FreeLibros.meSECCIÓN
5.4
DISCOS
373
CD-R
individuos
empresas
copien
fácilmente
CD-ROMs
CDs
audio
general
violando
derechos
editor
ideado
esquemas
di-
ficultar
piratería
difícil
leer
CD-ROM
utilizando
cosa
soft-
ware
editor
implica
grabar
longitudes
archivos
CD-ROM
gigabytes
frustrar
intento
copiar
archivos
disco
duro
me-
diante
software
copiado
estándar
verdaderas
longitudes
incrustan
softwa-
re
editor
ocultan
posiblemente
cifradas
CD-ROM
lugar
inesperado
esquema
utiliza
ECCs
incorrectos
intencional
sectores
seleccionados
esperando
software
copiado
CDs
corrija
errores
software
aplicación
comprueba
ECCs
rehusándose
funcionar
correctos
huecos
estándar
pistas
defectos
físicos
CD-Regrabables
personas
acostumbradas
medios
escritura
pa-
pel
película
fotográfica
demanda
CD-ROM
regrabable
tecnología
aho-
ra
disponible
CD-RW
CD-Regrabable
utiliza
medios
tamaño
CD-R.
colorante
cianina
ptalocianina
CD-RW
utiliza
alea-
ción
plata
indio
antimonio
telurio
capa
grabación
aleación
estables
cristalino
amorfo
distintas
reflectividades
unidades
CD-RW
utilizan
láseres
potencias
posición
alta
energía
láser
funde
aleación
convierte
cristalino
alta
reflectividad
amorfo
baja
reflectividad
representar
hoyo
posición
energía
media
aleación
funde
vuelve
formar
cristalino
natural
convertirse
área
lisa
nuevamente
baja
energía
detecta
material
lectura
ocurre
transición
razón
CD-RW
sustituido
CD-R
CD-RW
blanco
costosos
aplicaciones
consisten
respaldar
discos
duros
escrito
CD-R
borrar
accidentalmente
ventaja
DVD
formato
básico
CD
CD-ROM
1980
tecnología
mejorado
discos
ópticos
capacidad
económicamente
viables
demanda
Hollywood
estaría
encantado
eliminar
cintas
video
aná-
logas
favor
discos
digitales
discos
calidad
económi-
cos
fabricar
duran
tiempo
ocupan
espacio
repisas
tiendas
video
rebobinarse
empresas
electrónica
consumidor
buscan-
do
producto
éxito
empresas
computadoras
desean
agre-
gar
características
multimedia
software
combinación
tecnología
demanda
industrias
inmensamente
ricas
poderosas
conllevó
DVD
originalmente
acrónimo
Video
disco
digital
Digital
Video
Disk
www.FreeLibros.mepero
conoce
oficialmente
Disco
versátil
digital
Digital
Versatile
Disk
DVDs
utilizan
diseño
general
CDs
discos
policarbonato
moldeado
in-
yección
120
mm
contienen
hoyos
áreas
lisas
iluminan
diodo
láser
leen
fotodetector
Hoyos
pequeños
0.4
micrones
comparación
0.8
micrones
CDs
espiral
estrecha
0.74
micrones
pistas
comparación
1.6
micrones
CDs
láser
rojo
0.65
micrones
comparación
0.78
micrones
CDs
conjunto
mejoras
elevan
capacidad
4.7
GB
unidad
DVD
1x
opera
1.4
MB
seg
comparación
150
KB
seg
CDs
desgracia
cambio
láseres
rojos
utilizados
supermercados
implica
reproductores
DVD
requieren
láser
óptica
compleja
conversión
leer
CDs
CD-ROMs
exis-
tentes
disminución
precio
láseres
mayoría
reproductores
DVD
tipos
láser
leer
tipos
medios
4.7
GB
suficiente
compresión
MPEG-2
estandarizada
IS
13346
disco
DVD
4.7
GB
contener
133
minutos
video
pantalla
movi-
miento
completo
alta
resolución
720
480
pistas
sonido
lenguajes
subtítulos
32
Cerca
92%
películas
hayan
Hollywood
133
minutos
aplicaciones
juegos
multimedia
obras
consulta
requerir
Hollywood
gustaría
colocar
películas
mis-
mo
disco
definido
formatos
capa
4.7
GB
doble
capa
8.5
GB
Doble
capa
9.4
GB
Doble
doble
capa
17
GB
tantos
formatos
palabra
política
Philips
Sony
querían
discos
so-
doble
capa
versión
alta
capacidad
Toshiba
Time
Warner
querían
discos
doble
capa
Philips
Sony
creyeron
gente
estuviera
dispuesta
vol-
tear
discos
Time
Warner
creía
colocar
capas
podía
funcionar
re-
sultado
combinaciones
mercado
defina
sobrevivirán
tecnología
doble
capa
capa
reflectora
inferior
capa
semi-
reflectora
Dependiendo
lugar
enfoque
láser
rebota
capa
capa
inferior
necesita
hoyos
áreas
lisas
ligeramente
leer
ma-
nera
confiable
capacidad
menor
capa
superior
discos
doble
fabrican
tomando
discos
0.6
mm
pegán-
dolos
posterior
grosor
versiones
disco
consiste
disco
0.6
mm
pegado
sustrato
blanco
futuro
374
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.4
DISCOS
375
consista
133
minutos
publicidad
esperanza
gente
curiosidad
contener
estructura
disco
doble
doble
capa
ilustra
figura
5-24
Sustrato
policarbonato
Sustrato
policarbonato
Capa
semi-reflectiva
Capa
semi-reflectiva
Reflector
aluminio
Reflector
aluminio
Disco
0.6
mm
Disco
0.6
mm
Capa
adhesiva
Figura
5-24
disco
DBD
doble
doble
capa
DVD
ideado
consorcio
10
empresas
aparatos
electrónicos
hogar
japonesas
estrecha
cooperación
principales
estudios
Hollywood
algu-
propiedad
empresas
electrónica
japonesas
consor-
cio
industrias
computadoras
telecomunicaciones
invitadas
picnic
enfoque
resultante
utilizar
DVD
exposiciones
renta
venta
películas
ejemplo
características
estándar
incluyen
omisión
tiempo
real
escenas
sucias
per-
mitir
padres
conviertan
película
clasificación
NC17
segura
bebés
sonido
canales
soporte
Pan-and-Scan
característica
permite
reproduc-
tor
DVD
decidir
forma
dinámica
cortar
bordes
izquierdo
derecho
película
cuya
proporción
anchura
altura
3:2
adaptarlas
televisores
actuales
cuya
propor-
ción
aspecto
4:3
cuestión
industria
computadoras
probablemente
hubiera
considerado
incompatibilidad
intencional
discos
destinados
Unidos
discos
destinados
Europa
estándares
continentes
Hollywood
exigía
característica
películas
estrenan
Uni-
envían
Europa
videos
salen
Unidos
idea
ha-
cer
tiendas
video
europeas
pudieran
comprar
videos
EE.UU.
demasiada
anticipación
disminuir
ventas
boletos
películas
cines
euro-
peos
Hollywood
hubiera
operado
industria
computadoras
tendríamos
discos
flexibles
3.5
pulgadas
Unidos
discos
flexibles
cm
Europa
personas
idearon
DVDs
doble
doble
capa
idean-
do
descubrimientos
generación
carece
estándar
disputas
políticas
participantes
industria
dis-
positivos
Blu-ray
utiliza
láser
0.405
micrones
azul
empaquetar
25
GB
disco
capa
50
GB
disco
doble
capa
HD
DVD
utiliza
mis-
mo
láser
azul
capacidad
15
GB
capa
30
GB
doble
capa
guerra
formatos
dividido
estudios
películas
fabricantes
computadoras
www.FreeLibros.melas
compañías
software
resultado
falta
estandarización
generación
des-
pegando
lentitud
medida
consumidores
esperan
asiente
polvo
formato
ganará
falta
sensibilidad
industria
trae
men-
famoso
comentario
George
Santayana
aprender
historia
destinados
repetirla
5.4.2
Formato
disco
disco
duro
consiste
pila
platos
aluminio
aleación
acero
vidrio
5.25
3.5
pulgadas
diámetro
pequeños
computadoras
notebook
plato
de-
posita
óxido
metal
delgado
magnetizable
fabricación
información
clase
disco
utilizar
disco
plato
recibir
formato
nivel
software
formato
consiste
serie
pistas
concéntricas
contiene
número
sectores
huecos
cortos
sectores
formato
sector
muestra
figura
5-25
376
ENTRADA
SALIDA
CAPÍTULO
Preámbulo
Datos
ECC
Figura
5-25
sector
disco
preámbulo
empieza
patrón
bits
permite
hardware
reconocer
inicio
sector
contiene
números
cilindro
sector
información
adicional
tamaño
porción
datos
determina
base
programa
formato
nivel
mayoría
discos
utilizan
sectores
512
bytes
campo
ECC
contiene
información
re-
dundante
utilizar
recuperarse
errores
lectura
tamaño
contenido
campo
varía
fabricante
dependiendo
espacio
disco
esté
dispuesto
perder
diseñador
obtener
confiabilidad
complejo
código
ECC
manejar
controlador
campo
ECC
16
bytes
común
discos
duros
cantidad
sectores
adicionales
asignan
utilizarlos
reemplazo
sectores
defecto
fabricación
posición
sector
pista
desfasada
pista
aplica
for-
mato
nivel
desplazamiento
conocido
desajuste
cilindros
realiza
me-
jorar
rendimiento
idea
permitir
disco
lea
pistas
operación
continua
perder
datos
naturaleza
problema
figura
5-19(a
Suponga
pe-
tición
necesita
18
sectores
empezando
sector
pista
interna
leer
16
sectores
requiere
rotación
disco
necesita
búsqueda
desplazarse
pista
llegar
sector
17
cabeza
desplazado
pista
sec-
tor
girado
allá
cabeza
necesita
rotación
vuelva
pa-
sar
cabeza
problema
elimina
desviar
sectores
muestra
figura
5-26
www
FreeLibros.meSECCIÓN
5.4
DISCOS
377
cantidad
desviación
cilindros
depende
geometría
disco
ejemplo
unidad
10,000
RPM
gira
mseg
pista
contiene
300
sectores
sector
pasa
de-
cabeza
20
µseg
tiempo
búsqueda
pista
pista
800
µseg
pasarán
40
sectores
búsqueda
desviación
cilindros
40
sectores
sectores
muestran
figura
5-26
Vale
pena
mencionar
cambio
cabeza
requiere
tiempo
finito
desajuste
ca-
bezas
desajuste
cilindros
desajuste
cabezas
resultado
formato
nivel
reduce
capacidad
disco
dependiendo
tamaños
preámbulo
hueco
sectores
ECC
número
sectores
adicio-
nales
reservados
capacidad
formato
20%
menor
capacidad
formato
sectores
adicionales
cuentan
capacidad
formato
discos
tipo
exactamente
capacidad
envían
importar
secto-
res
defectuosos
tengan
realidad
número
sectores
defectuosos
excede
número
adi-
cionales
unidad
rechazará
enviará
considerable
confusión
acerca
capacidad
disco
fabri-
cantes
anunciaban
capacidad
formato
unidades
parecieran
realmente
ejemplo
considere
unidad
cuya
capacidad
formato
200
/H1100310
bytes
vender
disco
200
GB
formato
170
/H1100310
bytes
datos
aumentar
confusión
sistema
operativo
proba-
91011121314151617181920212223242526272829
30
31
29
30
31
910111213141516171819
20
2122
23242526
27
28
26
27
28
29
30
31
7891011121314
15
16
17
18
19
20
2122
23
24
25
23
24
25
26
27
28
29
30
31
56789
10
11
12
13
14
15
16
17
18
19
20
21
22
20
21
22
23
24
25
26
27
28
29
30
31
2345
10
11
12
13
14
15
16
17
18
19
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31012
10
11
12
13
14
15
16
Dirección
rotación
disco
Figura
5-26
ilustración
desviación
cilindros
www.FreeLibros.meblemente
reportará
capacidad
158
GB
170
GB
software
con-
sidera
memoria
GB
30
1,073,741,824
bytes
109
1,000,000,000
bytes
empeorar
cosas
mundo
comunicaciones
datos
Gbps
significa
1,000,000,000
bits
seg
prefijo
giga
realidad
significa
10
kilómetro
equivale
1000
metros
1024
metros
tamaños
memorias
dis-
cos
kilo
mega
giga
tera
significan
10,220
230
240
respectivamente
formato
afecta
rendimiento
disco
10,000
RPM
300
sectores
pis-
ta
512
bytes
requieren
mseg
leer
153,600
bytes
pista
velo-
cidad
transferencia
datos
25,600,000
bytes
seg
24.4
MB
seg
rápido
importar
tipo
interfaz
esté
presente
interfaz
SCSI
80
MB
seg
160
MB
seg
realidad
leer
continua
velocidad
requiere
búfer
extenso
controlador
ejemplo
considere
controlador
búfer
sector
recibido
co-
mando
leer
sectores
consecutivos
leer
sector
disco
cálculo
ECC
datos
transferir
memoria
principal
llevando
cabo
transferencia
sector
pasará
cabeza
complete
copia
memoria
controlador
esperar
tiempo
rotación
completo
segun-
do
sector
vuelva
pasar
cabeza
problema
eliminar
enumerar
sectores
forma
entrelazada
aplicar
forma-
to
disco
figura
5-27(a
patrón
enumeración
usual
ignorando
desa-
juste
cilindros
figura
5-27(b
muestra
entrelazado
simple
proporciona
controlador
espacio
libre
sectores
consecutivos
copiar
búfer
memoria
principal
378
ENTRADA
SALIDA
CAPÍTULO
Figura
5-27
entrelazado
Entrelazado
simple
Entrelazado
doble
proceso
copia
lento
necesario
entrelazado
doble
figura
5-27(c
controlador
búfer
sector
importa
copia
búfer
memoria
principal
realiza
controlador
CPU
principal
chip
DMA
formas
requiere
tiempo
evitar
necesidad
entrelazado
controla-
dor
capaz
colocar
búfer
pista
completa
controladores
modernos
completa
formato
nivel
disco
particiona
sentido
lógico
ca-
partición
disco
separado
particiones
necesarias
permitir
coexistan
sistemas
operativos
casos
utilizar
partición
intercam-
bio
Pentium
mayoría
computadoras
sector
contiene
registro
inicio
www
FreeLibros.meSECCIÓN
5.4
DISCOS
379
maestro
MBR
siglas
inglés
contiene
código
inicio
tabla
particiones
tabla
particiones
proporciona
sector
inicial
tamaño
parti-
ción
Pentium
tabla
particiones
espacio
particiones
pa-
ra
Windows
llamarán
tratarán
unidades
separadas
Windows
UNIX
Windows
llamará
particiones
pri-
mer
CD-ROM
iniciar
disco
duro
partición
marcar
activa
tabla
particiones
paso
preparación
disco
utilizarlo
formato
alto
nivel
partición
separado
operación
establece
bloque
inicio
administración
espacio
almacenamiento
libre
lista
bloques
libres
mapa
bits
directorio
raíz
sis-
tema
archivos
vacío
coloca
código
entrada
tabla
particiones
in-
dicarle
sistema
archivos
utilizar
partición
sistemas
operativos
soportan
sistemas
archivos
incompatibles
cuestiones
históricas
punto
iniciar
sistema
enciende
máquina
BIOS
ejecuta
inicio
lee
registro
inicio
maestro
salta
programa
inicio
comprueba
partición
activa
Des-
pués
lee
sector
inicio
partición
ejecuta
sector
inicio
contiene
pequeño
pro-
grama
general
carga
programa
inicio
busca
sistema
archivos
kernel
sistema
operativo
programa
carga
memoria
ejecuta
5.4.3
Algoritmos
programación
brazo
disco
sección
analizaremos
cuestiones
relacionadas
controladores
disco
ge-
neral
lugar
considerar
tiempo
requiere
leer
escribir
blo-
disco
tiempo
requerido
determina
base
factores
Tiempo
búsqueda
tiempo
desplazar
brazo
cilindro
apropiado
Retraso
rotacional
tiempo
sector
apropiado
coloque
cabeza
Tiempo
transferencia
datos
actual
mayoría
discos
tiempo
búsqueda
domina
tiempos
re-
ducir
tiempo
búsqueda
promedio
mejorar
rendimiento
sistema
consi-
derable
software
controlador
disco
acepta
peticiones
cabo
orden
llegar
atendido
First-Come
Firsts-Served
FCFS
optimizar
tiempo
búsqueda
estrategia
disco
cargado
probable
brazo
esté
realizando
búsqueda
fa-
vor
petición
procesos
puedan
generar
peticiones
disco
controladores
disco
mantienen
tabla
indexada
número
cilindro
peticiones
pendientes
ca-
cilindro
encadenadas
lista
enlazada
encabezada
entradas
tabla
tipo
estructura
datos
mejorías
base
algoritmo
programación
llegar
atendido
considere
disco
imaginario
40
cilindros
Llega
petición
leer
bloque
cilindro
11
www.FreeLibros.mebúsqueda
cilindro
11
progreso
llegan
peticiones
cilindros
36
16
34
12
orden
introducen
tabla
peticiones
pendientes
lista
enlaza-
separada
cilindro
peticiones
muestran
figura
5-28
380
ENTRADA
SALIDA
CAPÍTULO
Posición
inicial
Peticiones
pendientes
Secuencia
búsquedas
Cilindro
XX
05
15
20
25
30
35
Tiempo
Figura
5-28
Algoritmo
planificación
disco
búsqueda
trabajo
corto
SSF
termina
petición
actual
cilindro
11
software
controlador
disco
elegir
petición
manejar
continuación
Utilizando
FCFS
cilindro
36
sucesivo
algoritmo
requiere
movimientos
brazo
10
35
20
18
25
respectivamente
111
cilindros
alternativa
manejar
petición
cercana
minimi-
zar
tiempo
búsqueda
Dadas
peticiones
figura
5-28
secuencia
12
16
34
36
muestra
línea
dentada
inferior
figura
5-28
secuen-
cia
movimientos
brazo
15
33
61
cilindros
algoritmo
búsqueda
trabajo
corto
Shortest
Seek
First
SSF
recorta
movimiento
brazo
mitad
comparación
FCFS
desgracia
SSF
problema
Suponga
siguen
llegando
peticiones
procesando
peticiones
figura
5-28
ejemplo
cilindro
16
petición
cilindro
petición
prioridad
cilindro
llega
petición
cilindro
13
brazo
irá
continuación
13
dis-
co
contenga
carga
brazo
tenderá
permanecer
media
disco
tiempo
peticiones
extremo
esperar
fluctuación
estadística
carga
ocasione
peticiones
cerca
media
peticiones
alejadas
media
llegar
obtener
servicio
objetivos
tiempo
respuesta
mínimo
equidad
conflicto
edificios
altos
lidiar
concesión
problema
planificar
elevador
edificio
alto
similar
planificar
brazo
disco
peticiones
llegan
forma
continua
llamando
elevador
pisos
cilindros
azar
computadora
opera
elevador
fácilmente
secuencia
clientes
oprimieron
botón
llama-
atenderlos
utilizando
FCFS
SSF
mayoría
elevadores
utilizan
algoritmo
distinto
reconciliar
metas
mutuamente
conflictivas
eficiencia
equidad
Siguen
avanzando
direc-
www
FreeLibros.meSECCIÓN
5.4
DISCOS
381
ción
peticiones
pendientes
dirección
cambian
direccio-
nes
algoritmo
conocido
algoritmo
elevador
mundo
discos
mundo
elevadores
requiere
software
mantenga
bit
bit
dirección
actual
ABAJO
termina
petición
software
controlador
disco
elevador
comprueba
bit
brazo
cabina
desplaza
petición
pendiente
prioridad
peticiones
pendientes
posiciones
mayores
bit
dirección
in-
vierte
bit
establece
ABAJO
movimiento
posición
petición
menor
prioridad
figura
5-29
muestra
algoritmo
elevador
usando
peticiones
figura
5-28
suponiendo
bit
dirección
principio
orden
servicio
cilindros
12
16
34
36
produce
movimientos
bra-
zo
18
27
60
cilindros
caso
algoritmo
elevador
li-
geramente
SSF
general
propiedad
algoritmo
elevador
dada
colección
peticiones
límite
superior
movimien-
to
fijo
doble
número
cilindros
Posición
inicial
Cilindro
XX
05
15
20
25
30
35
Tiempo
Secuencia
búsquedas
Figura
5-29
algoritmo
elevador
planificar
peticiones
disco
ligera
modificación
algoritmo
variación
menor
tiempos
res-
puesta
Teory
1972
explorar
dirección
cilindro
nu-
meración
petición
pendiente
atendido
brazo
pasa
cilindro
menor
numeración
petición
pendiente
continúa
desplazándose
dirección
arri-
ba
efecto
cilindro
menor
numeración
justo
cilindro
numeración
controladores
disco
proveen
forma
software
inspeccione
núme-
ro
sector
actual
cabeza
controlador
optimización
peticiones
cilindro
pendientes
controlador
emitir
petición
sector
pasará
cabeza
continuación
Observe
pistas
presentes
cilindro
peticiones
consecutivas
distintas
pistas
castigo
controla-
dor
seleccionar
cualquiera
cabezas
forma
instantánea
selección
cabezas
implica
movimiento
brazo
retraso
rotacional
www
FreeLibros.meSi
disco
propiedad
tiempo
búsqueda
rápido
retra-
so
rotacional
utilizar
optimización
distinta
peticiones
pendientes
ordenarse
número
sector
sector
esté
punto
pasar
de-
cabeza
brazo
moverse
rápidamente
pista
correcta
leer
escribir
disco
duro
moderno
retrasos
búsqueda
rotacional
dominan
rendimien-
to
ineficiente
leer
sectores
razón
controladores
disco
leen
colocan
caché
sectores
solicite
general
solicitud
leer
sector
hará
lea
sector
pista
actual
dependiendo
espacio
disponible
memoria
caché
controla-
dor
disco
descrito
figura
5-18
caché
MB
ejemplo
caché
determina
forma
dinámica
controlador
simple
caché
divide
secciones
lecturas
escrituras
lectura
subsiguiente
sa-
tisfacer
caché
controlador
devolver
datos
solicitados
inmediato
Vale
pena
recalcar
caché
controlador
disco
completamente
independiente
caché
sistema
operativo
general
caché
controlador
contiene
bloques
rea-
lidad
solicitado
conveniente
leer
pasaron
ca-
beza
efecto
secundario
lectura
contrario
caché
mantenida
sistema
operativo
consistirá
bloques
hayan
leído
explícita
sistema
operativo
considere
necesarios
futuro
cercano
ejemplo
blo-
disco
contiene
bloque
directorio
unidades
presentes
controlador
sistema
operativo
mantener
tabla
peticiones
pendiente
unidad
separado
uni-
dad
inactiva
emitirse
búsqueda
desplazar
brazo
cilindro
ne-
cesitará
continuación
suponiendo
controlador
permita
búsquedas
traslapadas
termine
transferencia
actual
comprobación
unidades
posi-
cionadas
cilindro
correcto
transferencia
iniciar
unidad
encuentre
cilindro
correcto
brazo
posición
correc-
ta
software
controlador
deberá
emitir
búsqueda
unidad
terminado
transferencia
deberá
esperar
interrupción
brazo
llega
destino
importante
algoritmos
planificación
disco
anteriores
asu-
men
tácita
geometría
disco
real
geometría
virtual
sentido
planificar
peticiones
disco
sistema
operativo
realidad
cilindro
40
cilindro
200
cerca
cilindro
39
controlador
disco
aceptar
peticiones
pendientes
utilizar
algoritmos
planificación
forma
interna
caso
algoritmos
siguen
válidos
nivel
abajo
controlador
5.4.4
Manejo
errores
fabricantes
disco
constantemente
exceden
límites
tecnología
incrementar
densidades
bits
lineales
pista
mitad
disco
5.25
pulgadas
circunfe-
rencia
300
mm
pista
contiene
300
sectores
512
bytes
densidad
382
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.4
DISCOS
383
grabación
lineal
5000
bits
mm
tomando
consideración
he-
cho
pierde
espacio
preámbulos
ECCs
huecos
sectores
grabar
5000
bits
mm
requiere
sustrato
extremo
uniforme
capa
óxido
fina
desgracia
fabricar
disco
tales
especificaciones
defectos
tecnología
fabricación
mejorado
grado
operar
erro-
res
dichas
densidades
diseñadores
discos
buscarán
densidades
altas
incremen-
tar
capacidad
probablemente
vuelvan
introducir
defectos
defectos
fabricación
incluyen
sectores
defectuosos
sectores
leen
correc-
tamente
valor
acaba
escribir
defecto
pequeño
ejemplo
bits
utilizar
sector
defectuoso
dejar
ECC
corrija
errores
defecto
error
enmascarar
métodos
generales
bloques
defectuosos
lidiar
controlador
lidiar
sistema
operativo
método
disco
salga
fá-
brica
prueba
escribe
lista
sectores
defectuosos
disco
sector
defectuoso
sustituye
sectores
adicionales
formas
sustitución
figura
5-30(a
pista
disco
30
sectores
datos
sectores
adicionales
sector
defectuoso
con-
trolador
reasignar
sectores
adicionales
sector
mues-
tra
figura
5-30(b
forma
desplazar
sectores
posición
muestra
figura
5-30(c
casos
controlador
sector
registro
información
tablas
internas
pista
volvien-
do
escribir
preámbulos
proporcionar
números
sectores
reasignados
vuel-
ven
escribir
preámbulos
método
figura
5-30(c
presenta
dificultad
volver
escribir
23
preámbulos
instancia
ofrece
rendimien-
to
formas
leer
pista
completa
rotación
Sectores
adicio-
nales
Sector
defectuoso
10
11
1213141516171819
20
21
22
23
24
25
26
27
2829
Sector
reemplazo
10
11
1213141516171819
20
21
22
23
24
25
26
27
2829
10
1112131415161718
19
20
21
22
23
24
25
26
272829
Figura
5-30
pista
disco
sector
defectuoso
Sustitución
sector
adicional
sector
defectuoso
Desplazar
sectores
omitir
defectuoso
desarrollar
errores
operación
normal
insta-
unidad
línea
defensa
obtener
error
ECC
manejar
tra-
tar
leerlo
errores
lectura
transitorios
producidos
www
FreeLibros.me384
ENTRADA
SALIDA
CAPÍTULO
partículas
polvo
cabeza
desaparecerán
intento
controlador
detec-
ta
obteniendo
errores
repetidos
sector
cambiar
sector
reemplazo
sector
defectuoso
falle
pierden
datos
sistema
operativo
usuario
siquiera
enteran
problema
general
utilizar
mé-
figura
5-30(b
sectores
contener
datos
utilizar
método
figura
5-30(c
habría
volver
escribir
preámbulos
co-
piar
datos
Anteriormente
dijimos
métodos
generales
manejar
errores
manejarlos
controlador
sistema
operativo
controlador
capacidad
reasignar
sectores
transparente
visto
sistema
operativo
soft-
ware
significa
adquirir
lista
sectores
defectuosos
leyéndolos
disco
simplemente
probando
disco
sepa
sectores
de-
fectuosos
construir
tablas
reasignación
sistema
operativo
desea
utilizar
método
figura
5-30(c
cambiar
datos
sectores
29
sector
sistema
operativo
cargo
reasignación
asegurarse
ha-
sectores
malos
archivo
lista
libre
mapa
bits
ma-
nera
crear
archivo
consista
sectores
malos
archivo
introduce
sistema
archivos
usuarios
leerán
accidente
libe-
rarán
problema
respaldos
disco
respalda
archivo
archivo
importante
herramienta
respaldo
trate
copiar
archivo
bloque
defectuoso
evitar
sistema
operativo
ocultar
archivo
bloque
defectuoso
siquiera
herramienta
respaldo
encontrarlo
disco
respalda
sector
sector
archivo
archivo
difícil
imposible
evitar
errores
lectura
duran-
respaldo
única
esperanza
programa
respaldo
suficiente
inteligencia
pa-
ra
rendirse
10
lecturas
fallidas
continúe
sector
sectores
defectuosos
única
fuente
errores
ocurren
errores
búsque-
producidos
problemas
mecánicos
brazo
controlador
registro
posición
brazo
interna
búsqueda
emite
serie
pulsos
motor
bra-
zo
pulso
cilindro
desplazarlo
cilindro
brazo
llega
destino
controlador
lee
número
cilindro
actual
preámbulo
sector
brazo
posición
incorrecta
ocurrido
error
búsqueda
mayoría
controladores
disco
duro
corrigen
errores
búsqueda
au-
tomática
mayoría
controladores
disco
flexible
incluyendo
Pentium
establecen
bit
error
dejan
resto
controlador
maneja
error
emitiendo
comando
recalibrate
alejar
brazo
restablecer
idea
interna
controlador
cilindro
actual
general
resuelve
problema
unidad
reparar
visto
controlador
realidad
pequeña
computadora
especializada
completa
software
variables
búferes
ocasiones
errores
se-
cuencia
inusual
eventos
interrupción
unidad
ocurre
simultá-
nea
comando
recalibratepara
unidad
desencadenará
error
hará
controlador
ciclo
pierda
diseñadores
contro-
www
FreeLibros.meSECCIÓN
5.4
DISCOS
385
ladores
general
planean
proporcionan
terminal
chip
aplica
señal
obliga
controlador
olvidar
restablece
mis-
mo
falla
controlador
disco
establecer
bit
invocar
señal
restablecer
controlador
ayuda
software
controlado
imprimir
mensaje
darse
vencido
recalibrar
disco
ruido
extraño
general
molesto
situación
recalibración
grave
problema
sistemas
res-
tricciones
tiempo
real
reproduciendo
video
disco
duro
que-
man
archivos
disco
duro
CD-ROM
esencial
bits
salgan
disco
duro
velocidad
uniforme
circunstancias
recalibraciones
insertan
huecos
flujo
bits
inaceptables
tales
aplicaciones
disponibles
unidades
especiales
cono-
cidas
discos
discos
Audio
Visuales
recalibrar
5.4.5
Almacenamiento
estable
visto
discos
cometen
errores
sectores
pron-
to
volverse
defectuosos
Discos
completos
dejar
funcionar
inesperadamente
RAIDs
protegen
sectores
vuelvan
defectuosos
falle
unidad
protegen
errores
escritura
establecen
datos
defectuo-
sos
lugar
protegen
fallas
escrituras
corrompen
da-
tos
originales
reemplazarlos
datos
aplicaciones
esencial
datos
pierdan
corrompan
fren-
errores
disco
CPU
teoría
disco
simplemente
trabajar
tiempo
errores
desgracia
lograr
lograr
subsistema
disco
propiedad
emita
escritura
disco
escribir
correctamente
datos
dejando
datos
existentes
intactos
sistema
conoce
al-
macenamiento
estable
implementa
software
Lampson
Sturgis
1979
objetivo
mantener
disco
consistente
costa
continuación
analizaremos
ligera
variante
idea
original
describir
algoritmo
importante
modelo
posibles
errores
modelo
asume
disco
escribe
bloque
sectores
escritura
correc-
ta
incorrecta
error
detectar
lectura
subsiguiente
examinar
valores
campos
ECC
principio
detección
errores
garantizada
ejemplo
campo
ECC
16
bytes
protege
sector
512
bytes
4096
valores
datos
144
valores
ECC
ende
daña
información
bloque
escritura
ECC
miles
millones
miles
millones
combinaciones
inco-
rrectas
producen
ECC
ocurre
cualquiera
error
detectará
gene-
ral
probabilidad
datos
aleatorios
tengan
ECC
16
bytes
apropiado
/H11002144
suficientemente
pequeño
llamarlo
cero
realidad
modelo
supone
sector
escrito
correctamente
volverse
defectuoso
repentina
quedando
ilegible
suposición
dichos
eventos
raros
probabilidad
sector
vuelva
defectuoso
unidad
www
FreeLibros.me(independiente
intervalo
tiempo
razonable
ejemplo
peque-
ña
ignorarla
modelo
supone
CPU
fallar
cuyo
caso
detiene
es-
critura
disco
progreso
falla
detiene
produce
datos
incorrectos
sector
ECC
incorrecto
detectar
posteriormente
condicio-
nes
almacenamiento
estable
100%
confiable
sentido
operaciones
escritura
funcionen
correctamente
contrario
dejarán
datos
antiguos
lugar
Des-
protege
desastres
físicos
ocurrencia
terremoto
compu-
tadora
caiga
fisura
100
metros
aterrice
charco
magma
hirviente
difícil
recuperarse
condición
software
almacenamiento
estable
utiliza
par
discos
idénticos
bloques
correspon-
dientes
funcionan
conjunto
formar
bloque
libre
errores
ausencia
errores
bloques
correspondientes
ambas
unidades
iguales
Cualquiera
leer
obtener
resultado
lograr
objetivo
definen
siguientes
operaciones
Escrituras
estables
escritura
estable
consiste
escribir
bloque
uni-
dad
volver
leerlo
verificar
escrito
correctamente
escribió
forma
correcta
operaciones
escribir
volver
leer
realizan
funcione
fallos
consecutivos
bloque
reasigna
bloque
adicional
operación
repite
éxito
importar
bloques
adicionales
probar
éxito
escritura
unidad
escribe
bloque
correspondiente
unidad
vuelve
leer
repetidas
necesario
éxito
operación
ausencia
fallas
CPU
completa
escritura
estable
bloque
escrito
correctamente
ambas
unidades
verificado
ambas
Lecturas
estables
lectura
estable
lee
bloque
unidad
produce
ECC
incorrecto
operación
lectura
vuelve
intentar
to-
das
operaciones
producen
ECCs
defectuosos
lee
bloque
correspondiente
unidad
escritura
estable
exitosa
deja
copias
correctas
bloque
base
suposición
probabilidad
bloque
vuelva
defectuoso
repentina
ambas
unidades
intervalo
tiempo
razo-
nable
insignificante
obtiene
lectura
estable
Recuperación
fallas
falla
programa
recuperación
explora
discos
compara
bloques
correspondientes
par
bloques
igua-
error
ECC
bloque
defectuoso
sobres-
cribe
bloque
correspondiente
par
bloques
distintos
bloque
unidad
escribe
unidad
ausencia
fallas
CPU
esquema
funciona
escrituras
estables
escriben
copias
válidas
bloque
asume
errores
espontáneos
ocurrirán
bloques
correspondientes
tiempo
presencia
fallas
386
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.4
DISCOS
387
CPU
escrituras
estables
Depende
momento
preciso
ocurra
falla
posibilidades
muestra
figura
5.31
Anti-
guo
Anti-
guo
Disco
Anti-
guo
Disco
Anti-
guo
Disco
Disco
Disco
Falla
Falla
Falla
Falla
Falla
Error
ECC
Figura
5-31
Análisis
influencia
fallas
escrituras
estables
figura
5-31(a
falla
CPU
ocurre
escribir
cualquiera
copias
bloque
recuperación
cambiará
bloques
valor
se-
guirá
existiendo
permitido
figura
5-31(b
CPU
falla
escritura
unidad
destruyendo
contenido
bloque
programa
recuperación
detecta
error
restaura
bloque
unidad
bloque
unidad
ende
efecto
falla
borra
restaura
completo
figura
5-31(c
falla
CPU
ocurre
escribe
unidad
an-
tes
escribir
unidad
traspasado
punto
retorno
programa
recuperación
copia
bloque
unidad
unidad
escritura
éxito
figura
5-31(d
figura
5-31(b
recuperación
bloque
sobres-
cribe
bloque
malo
valor
bloques
figura
5-31(e
programa
recuperación
ve
bloques
igua-
cambia
escritura
éxito
optimizaciones
mejoras
posibles
esquema
empezar
acción
comparar
bloques
pares
falla
costosa
enorme
mejora
bloque
escribiendo
escritura
esta-
ble
comprobar
bloque
recuperación
compu-
tadoras
pequeña
cantidad
RAM
volátil
memoria
CMOS
especial
energizada
batería
litio
Dichas
baterías
duran
años
posiblemente
vida
computadora
diferencia
memoria
principal
pierde
falla
pierde
RAM
volátil
falla
hora
mantiene
general
in-
crementa
circuito
especial
explica
computadoras
siguen
sabiendo
hora
hayan
desconectado
Suponga
bytes
RAM
volátil
disponibles
fines
sistema
ope-
rativo
escritura
estable
colocar
número
bloque
punto
actualizar
RAM
volátil
empezar
escritura
completa
éxito
escritura
estable
www.FreeLibros.meel
número
bloque
RAM
volátil
sobrescribe
número
bloque
inválido
ejemplo
/H110021
condiciones
falla
programa
recuperación
ve-
rificar
RAM
volátil
escritura
estable
progreso
falla
bloque
escribiendo
ocurrió
falla
comprobar
copias
bloque
correctas
consistentes
RAM
volátil
disponible
simular
inicio
escritura
estable
sobrescribe
bloque
disco
fijo
unidad
número
blo-
escritura
estable
bloque
vuelve
leer
verifi-
carlo
obtener
bloque
correcto
escribe
verifica
bloque
correspondiente
unidad
escritura
estable
completa
correctamente
bloques
sobrescriben
número
bloque
inválido
verifican
falla
fácil
determi-
nar
escritura
estable
progreso
falla
técnica
re-
operaciones
disco
adicionales
escribir
bloque
estable
debería
utilizarse
casos
necesarios
Vale
pena
mencionar
punto
Hicimos
suposición
ocurre
cambio
espontáneo
bloque
bloque
defectuoso
bloque
diario
pasan
suficien-
tes
volverse
defectuoso
exploración
completa
discos
reparar
daño
forma
mañana
am-
bos
discos
idénticos
bloques
par
vuelven
defectuosos
periodo
errores
reparan
forma
correcta
5.5
RELOJES
relojes
conocidos
temporizadores
esenciales
operación
cual-
quier
sistema
multiprogramación
variedad
razones
Mantienen
hora
evi-
proceso
monopolice
CPU
cosas
software
reloj
tomar
forma
software
controlador
dispositivo
reloj
dispositivo
bloque
co-
mo
disco
dispositivo
carácter
ratón
análisis
relojes
seguirá
patrón
sección
vistazo
hardware
reloj
vistazo
software
5.5.1
Hardware
reloj
tipos
relojes
común
computadoras
distintos
relojes
utilizan
personas
relojes
simples
enlazados
línea
energía
110
220
voltios
producen
interrupción
ciclo
voltaje
50
60
Hz
relojes
solían
dominar
mercado
raros
tipo
reloj
construye
componentes
oscilador
cristal
con-
tador
registro
contenedor
muestra
figura
5-32
pieza
cristal
cuarzo
corta
forma
apropiada
monta
tensión
generar
señal
periódica
precisión
general
rango
cientos
megahertz
dependiendo
cristal
elegido
componentes
electrónicos
señal
base
multiplicar-
388
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.5
RELOJES
389
pequeño
entero
obtener
frecuencias
1000
MHz
circuitos
comúnmente
computadora
proporciona
señal
sincronización
diversos
circuitos
señal
alimenta
contador
cuente
forma
descendente
cero
contador
llega
cero
produce
interrupción
CPU
Oscilador
cristal
contador
decrementa
pulso
registro
contenedor
utiliza
cargar
contador
Figura
5-32
reloj
programable
general
relojes
programables
modos
operación
disparo
inicia
reloj
copia
valor
registro
contenedor
contador
des-
pués
decrementa
contador
pulso
cristal
contador
llega
cero
produce
interrupción
detiene
vuelve
iniciado
forma
explícita
software
onda
cuadrada
llegar
cero
producir
interrupción
registro
con-
tenedor
copia
automáticamente
contador
proceso
repite
forma
in-
definida
interrupciones
periódicas
conocen
pulsos
reloj
ventaja
reloj
programable
frecuencia
interrupción
controlar
me-
diante
software
utiliza
cristal
500
MHz
aplica
pulso
contador
ca-
nseg
registros
32
bits
signo
programar
interrupciones
ocurran
intervalos
nseg
8.6
seg
chips
reloj
programables
general
con-
relojes
programarse
independiente
opciones
ejemplo
contar
forma
ascendente
descendente
deshabilitar
interrup-
ciones
evitar
pierda
hora
actual
apaga
computadora
mayoría
cuentan
reloj
respaldo
energizado
batería
implementado
tipo
circuitos
baja
energía
utilizan
relojes
digitales
reloj
batería
leerse
iniciar
sistema
presente
software
pedir
usuario
fecha
hora
actuales
forma
estándar
sistema
obtenga
hora
actual
host
remoto
caso
hora
traduce
número
pulsos
reloj
12
A.M.
UTC
Universal
Coordinated
Time
Tiempo
coordenado
universal
anteriormente
conocido
Tiempo
meridiano
Greenwich
enero
1970
UNIX
momento
re-
ferencia
origen
tiempo
Windows
enero
1980
pulso
reloj
tiempo
real
incrementa
conteo
general
proporcionan
programas
utilitarios
www.FreeLibros.meestablecer
reloj
sistema
reloj
respaldo
forma
manual
sincronizar
relojes
5.5.2
Software
reloj
hardware
reloj
generar
interrupciones
intervalos
conocidos
de-
relacione
tiempo
software
controlador
reloj
ta-
reas
exactas
controlador
reloj
varían
sistema
operativo
general
incluyen
mayoría
siguientes
tareas
Mantener
hora
Evitar
procesos
ejecuten
tiempo
permitido
Contabilizar
CPU
Manejar
llamada
sistema
alarmque
realizan
procesos
usuario
Proveer
temporizadores
guardianes
watchdogs
partes
sistema
perfilamiento
supervisión
recopilación
estadísticas
función
reloj
mantener
hora
conocida
tiempo
real
difícil
requiere
incrementar
contador
pulso
reloj
único
debemos
pendiente
número
bits
contador
hora
velocidad
reloj
60
Hz
contador
32
bits
desbordará
años
evidente
sistema
almacenar
tiempo
real
número
pulsos
reloj
enero
1970
32
bits
métodos
resolver
problema
utilizar
contador
64
bits
vuelve
complejo
mantenimiento
contador
mantener
hora
segundos
pulsos
usando
contador
subsidiario
contar
pulsos
acumulado
se-
gundo
completo
32
segundos
equivale
136
años
método
funcionará
siglo
XXII
tercer
método
contar
pulsos
relativa
hora
inició
sistema
momento
externo
fijo
reloj
respaldo
lee
usuario
es-
cribe
hora
real
tiempo
inicio
sistema
calcula
valor
hora
ac-
tual
almacena
memoria
forma
conveniente
solicita
hora
suma
contador
hora
almacenada
obtener
hora
actual
métodos
muestran
figura
5-33
función
reloj
evitar
procesos
ejecuten
tiempo
Ca-
inicia
proceso
planificador
inicializa
contador
valor
quantum
proceso
pulsos
reloj
interrupción
reloj
software
controlador
decrementa
contador
quantum
llega
cero
software
controlador
reloj
lla-
ma
planificador
establecer
proceso
390
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.5
RELOJES
391
función
reloj
contabilizar
CPU
forma
precisa
iniciar
temporizador
distinto
temporizador
principal
sistema
inicia
proceso
proceso
detiene
temporizador
leer
tiempo
ejecutado
proceso
correcto
temporizador
guardar
ocurre
interrupción
restaurar
termine
precisa
simple
contabilidad
mantener
va-
riable
global
apuntador
entrada
tabla
procesos
proceso
actual
ejecución
pulso
reloj
incrementa
campo
entrada
proceso
actual
forma
ca-
pulso
reloj
carga
proceso
ejecución
momento
pulso
problema
menor
estrategia
ocurren
interrupciones
ejecución
proceso
to-
das
formas
carga
pulso
completo
podido
trabajo
contabilidad
apropiada
CPU
interrupciones
complicada
reali-
za
raras
ocasiones
sistemas
proceso
solicitar
sistema
operativo
proporcione
ad-
vertencia
intervalo
advertencia
general
señal
interrupción
men-
saje
similar
aplicación
requiere
dichas
advertencias
trabajo
red
paquete
reconozca
intervalo
tiempo
volver
transmitir
aplicación
instrucción
asistida
computadora
estudiante
provee
res-
puesta
tiempo
recibe
automáticamente
software
controlador
reloj
tuviera
suficientes
relojes
establecer
reloj
sepa-
rado
petición
caso
simular
relojes
virtuales
so-
reloj
físico
forma
mantener
tabla
mantenga
tiempo
señal
temporizadores
pendientes
variable
proporcione
tiempo
señal
actualiza
hora
controlador
comprueba
ocurrido
señal
cercana
busca
tabla
entrada
ocurrir
esperan
señales
eficiente
simular
relojes
encadenar
pe-
ticiones
reloj
pendientes
ordenadas
base
tiempo
lista
enlazada
mues-
tra
figura
5.34
entrada
lista
indica
pulsos
reloj
esperar
producir
señal
ejemplo
señales
pendientes
4203
4207
4213
4215
4216
Hora
pulsos
Hora
segundos
Contador
pulsos
Tiempo
inicio
sistema
segundos
Número
pulsos
actual
64
bits
32
bits
32
bits
Figura
5-33
formas
mantener
hora
www
FreeLibros.meEn
figura
5-34
interrupción
ocurre
pulsos
pulso
decrementa
Si-
guiente
señal
llega
produce
señal
correspondiente
elemento
lista
elemento
elimina
señal
establece
valor
entrada
cabeza
lista
ejemplo
Observe
interrupción
reloj
software
controlador
cosas
incrementar
tiempo
real
decrementar
quantum
comprobar
reali-
zar
contabilidad
tiempo
CPU
decrementar
contador
alarma
ca-
operaciones
diseñado
cuidado
rápidas
repetirse
partes
sistema
operativo
necesitan
establecer
temporizadores
conoce
temporizadores
guardianes
watchdogs
ejemplo
discos
flexibles
gi-
ran
evitar
desgaste
cabeza
disco
ne-
cesitan
datos
disco
flexible
iniciar
motor
disco
flexible
girando
velocidad
iniciar
operación
S.
proceso
intenta
leer
disco
flexible
inactivo
software
controlador
inicia
motor
estable-
ce
temporizador
guardián
produzca
interrupción
intervalo
tiempo
suficientemente
extenso
interruptor
máxima
velocidad
disco
flexible
mecanismo
utilizado
software
controlador
reloj
manejar
temporizadores
guar-
dianes
señales
usuario
única
diferencia
temporizador
desactiva
producir
señal
software
controlador
reloj
llama
procedimien-
to
proporcionado
llamada
procedimiento
código
proceso
llamada
procedimiento
llamó
necesario
producir
interrupción
kernel
interrupciones
inconvenientes
señales
razón
proporciona
mecanismo
guardián
Vale
pena
observar
mecanismo
funciona
software
controlador
reloj
pro-
cedimiento
llamar
encuentran
espacio
direcciones
lista
perfilamiento
sistemas
operativos
proporcionan
mecanismo
programa
usuario
sistema
construya
his-
tograma
contador
programa
pasa
tiempo
perfila-
miento
posibilidad
pulso
controlador
comprueba
perfilando
proceso
actual
calcula
número
receptáculo
rango
direcciones
corresponde
contador
programa
actual
incrementa
receptáculo
mecanismo
tam-
bién
utilizar
perfilar
sistema
392
ENTRADA
SALIDA
CAPÍTULO
Hora
actual
señal
Encabezado
reloj
1X
4200
Figura
5-34
Simulación
temporizadores
reloj
www
FreeLibros.meSECCIÓN
5.5
RELOJES
393
5.5.3
Temporizadores
software
mayoría
computadoras
reloj
programable
establecer
pa-
ra
producir
interrupciones
temporizador
velocidad
requiera
programa
temporizador
aparte
temporizador
principal
sistema
cuyas
funciones
describieron
sección
frecuencia
interrupción
baja
problema
temporizador
fines
específicos
aplicación
problema
surge
fre-
cuencia
temporizador
específico
aplicación
alta
continuación
analizaremos
esquema
temporizador
basado
software
funciona
circunstancias
inclusive
frecuencias
mayores
idea
Aron
Druschel
1999
obtener
detalles
consulte
artículo
general
formas
manejar
interrupciones
sondeo
interrupcio-
nes
baja
latencia
ocurren
justo
evento
retraso
CPUs
modernas
interrupciones
sobrecarga
considera-
ble
necesidad
cambio
contexto
influencia
canalización
TLB
caché
alternativa
interrupciones
aplicación
sondee
evento
espera
evitan
interrupciones
latencia
considerable
de-
bido
ocurrir
evento
directamente
sondeo
cuyo
caso
espera
to-
do
intervalo
sondeo
promedio
latencia
equivale
mitad
intervalo
sondeo
aplicaciones
aceptable
sobrecarga
interrupciones
latencia
sondeo
ejemplo
considere
red
alto
rendimiento
Gigabit
Ethernet
red
ca-
paz
aceptar
enviar
paquete
tamaño
completo
12
µseg
ejecutarse
ren-
dimiento
óptimo
salida
enviarse
paquete
12
µseg
forma
lograr
velocidad
completarse
transmisión
paquete
produzca
interrupción
establezca
temporizador
produzca
interrup-
ción
12
µseg
problema
medir
interrupción
Pentium
II
300
MHz
tar-
4.45
µseg
Aron
Druschel
1999
sobrecarga
computadoras
década
1970
ejemplo
mayoría
minicomputadoras
interrupción
reque-
ría
ciclos
contador
programa
PSW
pila
cargar
contador
programa
PSW
Actualmente
lidiar
línea
tuberías
MMU
TLB
caché
aumenta
sobrecarga
forma
considerable
probable
efectos
empeoren
mejorar
tiempo
cancelando
velocidades
mayores
reloj
temporizadores
software
evitan
interrupciones
ker-
nel
ejecuta
razón
justo
regresar
usuario
comprueba
reloj
tiempo
real
expirado
temporizador
software
temporizador
expira-
do
realiza
evento
programado
ejemplo
transmitir
paquetes
comprobar
pa-
quete
necesidad
cambiar
kernel
sistema
trabajo
temporizador
software
restablece
empezar
copiar
valor
actual
reloj
temporizador
sumarle
intervalo
tiempo
inactividad
temporizadores
software
marcan
descienden
velocidad
realizan
en-
tradas
kernel
razones
razones
www
FreeLibros.me394
ENTRADA
SALIDA
CAPÍTULO
Llamadas
sistema
Fallos
TLB
Fallos
página
Interrupciones
S.
CPU
queda
inactiva
frecuencia
ocurrían
eventos
Aron
Druschel
realizaron
mediciones
va-
rias
cargas
CPU
incluyendo
servidor
Web
carga
completa
servidor
Web
tra-
plano
cálculos
reproducción
audio
tiempo
real
Internet
recompilación
kernel
UNIX
velocidad
entrada
promedio
kernel
varia-
ción
µseg
18
µseg
mitad
entradas
llamadas
sistema
aproximación
orden
viable
temporizador
software
active
12
µseg
fallando
tiempo
límite
ocasiones
aplicaciones
envío
paquetes
sondeo
paquetes
entrantes
retraso
10
µseg
interrupciones
ocupen
35%
CPU
periodos
llamadas
sistema
fallos
TLB
página
cuyo
caso
activarán
temporizadores
colocar
límite
superior
inter-
valos
establecer
temporizador
hardware
active
mseg
ejemplo
aplicación
sobrevivir
1000
paquetes
seg
intervalos
ocasionales
combinación
temporizadores
software
temporizador
hardware
baja
fre-
cuencia
controlada
interrupciones
sondeo
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
computadora
propósito
general
teclado
monitor
general
ratón
pa-
ra
permitir
personas
interactúen
teclado
monitor
dispositivos
téc-
nicamente
separados
trabajan
cerca
mainframes
frecuencia
usuarios
remotos
dispositivo
contiene
teclado
pantalla
conectados
unidad
dispositivos
conocen
históricamente
terminales
frecuencia
perso-
nas
siguen
utilizando
término
teclados
monitores
compu-
tadoras
personales
5.6.1
Software
entrada
entrada
usuario
proviene
principalmente
teclado
ratón
analicemos
dispositi-
vos
computadora
personal
teclado
contiene
microprocesador
integrado
ge-
neral
comunica
puerto
serial
especializado
chip
controlador
tarjeta
principal
frecuencia
teclados
conectan
puerto
USB
ge-
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
395
nera
interrupción
oprime
tecla
genera
interrupción
suelta
interrupciones
teclado
software
controlador
extrae
información
acerca
ocurre
puerto
asociado
teclado
ocurre
software
independiente
hardware
mayoría
resto
sección
comprender
escri-
ben
comandos
ventana
shell
interfaz
línea
comandos
trabajan
co-
múnmente
programadores
continuación
analizaremos
interfaces
gráficas
Software
teclado
número
puerto
número
tecla
conocido
código
exploración
código
ASCII
teclados
128
teclas
necesitan
bits
re-
presentar
número
tecla
octavo
bit
establece
oprime
tecla
cuan-
do
suelta
responsabilidad
controlador
registro
tecla
oprimida
suelta
ejemplo
oprime
tecla
código
exploración
30
coloca
regis-
tro
S.
responsabilidad
controlador
determinar
minúscula
mayúscula
CTRL-A
ALT-A
CTRL-ALT-A
combinación
controlador
teclas
oprimido
liberado
ejemplo
MAYÚS
suficiente
información
pa-
ra
trabajo
ejemplo
secuencia
teclas
OPRIMIR
MAYÚS
OPRIMIR
SOLTAR
SOLTAR
MAYÚS
indica
mayúscula
secuencia
teclas
OPRIMIR
MAYÚS
OPRIMIR
SOLTAR
MAYÚS
SOLTAR
indica
mayúscula
interfaz
teclado
pone
carga
softwa-
re
extremo
flexible
ejemplo
programas
usuario
querer
dígito
acaba
escribir
provino
fila
superior
teclas
teclado
numérico
lateral
prin-
cipio
controlador
proporcionar
información
adoptar
filosofías
posibles
controlador
trabajo
con-
trolador
aceptar
entrada
pasarla
modificarla
programa
lee
teclado
obtiene
secuencia
pura
códigos
ASCII
programas
usuario
códigos
exploración
primitivo
genera
alta
dependencia
teclado
filosofía
adapta
necesidades
editores
pantalla
sofisticados
emacs
permite
usuario
enlazar
acción
arbitraria
carácter
secuencia
ca-
racteres
significa
usuario
escribe
dste
date
corrige
error
oprimiendo
tecla
retroceso
ate
seguido
retorno
carro
programa
usua-
rio
recibirá
11
códigos
ASCII
teclearon
CR
programas
desean
detalle
quieren
entrada
corregida
secuencia
exacta
produjo
observación
conlleva
filosofía
con-
www.FreeLibros.metrolador
maneja
edición
líneas
envía
líneas
corregidas
programas
usuario
filosofía
orientada
caracteres
orientada
líneas
principio
conocieron
crudo
cocido
respectivamente
estándar
POSIX
utiliza
término
canónico
describir
orientado
líneas
canónico
equivalente
crudo
cambiar
detalles
comportamiento
sistemas
compatibles
POSIX
proporcionan
funciones
biblioteca
posibilitan
selec-
ción
modos
modificar
parámetros
teclado
canónico
cocido
caracteres
almacenar
acumulado
línea
completa
usuario
decida
posteriormente
borrar
teclado
crudo
programa
solicitado
entra-
caracteres
colocar
búfer
permitir
escritura
adelan-
tada
utilizar
búfer
dedicado
asignar
búferes
reserva
método
impone
límite
fijo
escritura
adelantada
cuestión
surge
fuerza
usuario
escribe
ventana
shell
ventana
línea
comandos
Win-
dows
acaba
emitir
comando
compilación
completado
siguientes
caracteres
escriban
colocarse
búfer
shell
es-
tá
listo
leerlos
diseñadores
sistemas
permiten
usuarios
escribir
adelan-
tado
deberían
bañados
brea
emplumados
obligados
utilizar
sistema
teclado
monitor
dispositivos
lógicamente
separados
usuarios
crecido
acostumbrados
caracteres
acaban
escribir
aparecer
pantalla
proceso
conoce
producir
eco
echo
producción
eco
complica
programa
escribien-
do
pantalla
usuario
teclea
piense
escribir
ventana
shell
controlador
teclado
averiguar
colocar
entrada
sobrescrita
salida
programa
producción
eco
complica
mostrar
80
caracteres
ventana
líneas
80
caracteres
número
Dependiendo
aplicación
apropiado
caracteres
ajusten
línea
controladores
sim-
plemente
truncan
líneas
80
caracteres
descartar
caracteres
allá
colum-
na
80
problema
manejo
tabuladores
general
responsabilidad
controla-
dor
calcular
posición
cursor
tomando
salida
programas
sa-
lida
eco
calcular
número
apropiado
espacios
imprimir
eco
llegamos
problema
equivalencia
dispositivos
Lógicamente
línea
texto
retorno
carro
desplazar
cursor
vuelta
columna
avance
línea
pasar
línea
atractivo
requerir
usuarios
es-
cribieran
caracteres
línea
responsabilidad
controlador
dispositivo
convertir
llegue
entrada
formato
utilizado
sistema
operativo
UNIX
tecla
INTRO
convierte
avance
página
almacenamiento
interno
Windows
convierte
retorno
carro
seguido
avance
línea
forma
estándar
almacenar
avance
línea
convención
UNIX
retornos
carro
creados
tecla
Intro
convertir
avances
línea
for-
396
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
397
mato
interno
almacenar
convención
Windows
controlador
gene-
rar
avance
línea
reciba
retorno
carro
retorno
carro
obtenga
avance
línea
importar
convención
interna
monitor
requerir
pro-
duzca
eco
avance
línea
retorno
carro
actualizar
pantalla
apropiada
sistemas
multiusuario
mainframes
distintos
usuarios
te-
ner
distintos
tipos
terminales
conectadas
responsabilidad
controlador
teclado
con-
vertir
distintas
combinaciones
retorno
carro
avance
línea
estándar
interno
sistema
encargarse
eco
produzca
correctamente
opera
canónico
caracteres
entrada
significado
especial
figura
5-35
muestra
caracteres
especiales
requeridos
POSIX
valores
predeter-
minados
caracteres
control
conflicto
entrada
texto
códigos
utilizados
programas
cambiar
control
programa
Figura
5-35
Caracteres
manejan
especial
canónico
Carácter
Nombre
POSIX
Comentario
CTRL-H
ERASE
Retrocede
carácter
CTRL-U
KILL
Borra
línea
escribiendo
CTRL-V
LNEXT
Interpreta
carácter
literalmente
CTRL-S
STOP
Detiene
salida
CTRL-Q
START
Inicia
salida
INTR
Proceso
interrupción
SIGINT
CTRL-\
QUIT
Obliga
vaciado
núcleo
SIGQUIT
CTRL-D
EOF
archivo
CTRL-M
CR
Retorno
carro
modificar
CTRL-J
NL
Avance
línea
modificar
carácter
ERASE
permite
usuario
borrar
carácter
acaba
escribir
general
carácter
retroceso
CTRL-H
agrega
cola
caracteres
elimina
ca-
rácter
cola
eco
producir
secuencia
caracteres
retro-
ceso
espacio
retroceso
eliminar
carácter
pantalla
carácter
tabulador
borrarlo
depende
procesó
escri-
bió
expande
inmediato
espacios
necesita
información
adicional
deter-
minar
retroceder
tabulador
almacena
cola
entrada
eliminar
imprime
línea
completa
mayoría
sistemas
te-
cla
retroceso
borra
caracteres
línea
actual
borrará
retorno
carro
retrocederá
línea
usuario
detecta
error
principio
línea
escribiendo
conveniente
borrar
línea
empezar
carácter
KILL
borra
línea
ma-
www.FreeLibros.meyoría
sistemas
línea
borrada
desaparezca
pantalla
antiguos
producen
eco
retorno
carro
avance
línea
usuarios
gusta
línea
consecuencia
forma
producir
eco
KILL
cuestión
gusto
ERASE
general
regresar
allá
lí-
nea
actual
elimina
bloque
caracteres
conveniente
softwa-
re
controlador
devuelva
búferes
reserva
utilizan
caracteres
ERASE
KILL
introducir
datos
ordinarios
ca-
rácter
LNEXT
sirve
carácter
escape
UNIX
CTRL-V
predeterminado
ejemplo
sistemas
UNIX
anteriores
utilizaban
signo
KILL
sistema
correo
Internet
utiliza
direcciones
forma
linda@cs.washington.edu
Alguien
sien-
ta
cómodo
convenciones
antiguas
redefinir
KILL
ten-
dría
introducir
literalmente
signo
utilizar
correo
electrónico
escribir
CTRL-V
carácter
CTRL-V
introducir
literalmente
escribir
CTRL-V
CTRL-V
CTRL-V
software
controlador
establece
bandera
indica
carácter
exento
procesamiento
especial
carácter
LNEXT
intro-
duce
cola
caracteres
permitir
usuarios
eviten
imagen
pantalla
salga
vista
pro-
porcionan
códigos
control
congelar
pantalla
reiniciarla
posteriormente
UNIX
es-
tos
códigos
STOP
CTRL-S
START
CTRL-Q
respectivamente
almacenan
utilizan
establecer
borrar
bandera
estructura
datos
teclado
intenta
operación
salida
inspecciona
bandera
activada
cabo
operación
salida
general
eco
suprime
salida
pro-
grama
necesario
eliminar
programa
fugitivo
depurando
utilizar
caracteres
INTR
SUPR
QUIT
CTRL-\
UNIX
SUPR
envía
señal
SI-
GINT
procesos
inician
teclado
Implementar
SUPR
engañoso
UNIX
diseñó
principio
manejar
usuarios
en-
caso
general
procesos
ejecutándose
beneficio
usuarios
tecla
SUPR
señalar
procesos
usuario
difícil
informa-
ción
controlador
sistema
encarga
señales
pedido
información
CTRL-\
similar
SUPR
envía
señal
SIGQUIT
obliga
vaciado
núcleo
atrapa
ignora
oprime
teclas
controla-
dor
producir
eco
retorno
carro
avance
línea
descartar
entrada
acumulada
permitir
empezar
cero
valor
predeterminado
INTR
CTRL-C
SUPR
programas
utilizan
SUPR
lugar
retroceso
editar
carácter
especial
EOF
CTRL-D
UNIX
cumpla
petición
lectura
pendiente
terminal
datos
estén
disponibles
búfer
aun-
esté
vacío
escribir
CTRL-D
inicio
línea
programa
obtiene
lectura
by-
tes
convención
interpreta
archivo
ocasiona
mayoría
programas
actúen
hubieran
visto
archivo
archivo
entrada
398
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
399
Software
ratón
mayoría
PCs
ratón
trackball
sencillamente
ratón
boca
tipo
común
ratón
bola
goma
interior
asoma
ho-
inferior
gira
medida
ratón
desplaza
superficie
dura
frotándose
rodillos
posicionados
ejes
ortogonales
movimiento
dirección
este-oeste
ha-
ce
gire
eje
paralelo
eje
movimiento
dirección
norte-sur
gire
eje
pa-
ralelo
eje
x.
tipo
popular
ratón
óptico
equipado
diodos
emisores
luz
fotodetectores
inferior
tenían
operar
tapete
especial
grabado
rejilla
rectangular
ratón
pudiera
contar
líneas
cruza-
ba
ratones
ópticos
modernos
chip
procesamiento
imágenes
sacan
fotos
continuas
baja
resolución
superficie
buscando
cambios
imagen
imagen
ratón
desplazado
distancia
mínima
dirección
cuan-
do
oprime
suelta
botón
envía
mensaje
computadora
distancia
mínima
0.1
mm
establecer
software
personas
lla-
man
unidad
mickey
ratones
botones
dependiendo
es-
timación
diseñadores
habilidad
intelectual
usuarios
botón
ratones
ruedas
enviar
datos
adicionales
compu-
tadora
ratones
inalámbricos
iguales
alámbricos
devolver
datos
computadora
cable
utilizan
radios
baja
energía
ejemplo
estándar
Bluetooth
mensaje
computadora
contiene
elementos
∆x
∆y
botones
elemento
cambio
posición
mensaje
viene
cambio
posición
mensaje
incluye
botones
formato
mensaje
de-
pende
sistema
número
botones
ratón
general
requiere
bytes
mayoría
ratones
reportan
computadora
máximo
40
seg
ratón
desplazado
mickeys
reporte
Observe
ratón
indica
cambios
posición
posición
absoluta
recoge
ratón
coloca
posición
gentilmente
bola
gire
en-
viarán
mensajes
GUIs
diferencian
clic
doble
clic
botón
ratón
clics
cerca
espacio
mickeys
tiempo
milisegundos
señala
do-
ble
clic
valor
máximo
cerca
depende
software
general
usua-
rio
ajustar
parámetros
5.6.2
Software
salida
consideremos
software
salida
analizaremos
salida
ejemplo
ven-
tana
texto
programadores
prefieren
utilizar
comúnmente
considera-
remos
interfaces
gráficas
usuario
usuarios
prefieren
www
FreeLibros.meVentanas
texto
salida
simple
entrada
envía
secuencialmente
tipo
letra
ta-
maño
color
programa
envía
caracteres
ventana
muestran
general
bloque
caracteres
ejemplo
línea
escribe
llamada
sistema
editores
pantalla
programas
sofisticados
necesitan
capacidad
ac-
tualizar
pantalla
formas
complejas
sustituir
línea
mitad
pantalla
satis-
facer
necesidad
mayoría
controladores
software
salida
proporcionan
serie
comandos
desplazar
cursor
insertar
eliminar
caracteres
líneas
cursor
tareas
comandos
conocen
secuencias
escape
termi-
nal
tonta
ASCII
25
80
cientos
tipos
terminales
secuen-
cias
escape
consecuencia
difícil
escribir
software
funcionara
tipo
terminal
solución
introdujo
Berkeley
UNIX
base
datos
terminales
cono-
cida
termcap
paquete
software
definía
variedad
acciones
básicas
des-
plazar
cursor
fila
columna
desplazar
cursor
ubicación
específica
software
editor
utilizaba
secuencia
escape
genérica
convertía
secuencia
escape
actual
terminal
escribiendo
forma
editor
funcionaba
terminal
tuviera
entrada
base
datos
termcap
mayoría
software
UNIX
funciona
computadoras
perso-
nales
momento
industria
vio
necesidad
estandarizar
secuencia
escape
desarrolló
estándar
ANSI
figura
5-36
muestran
valores
Considere
secuencias
escape
utilizadas
editor
texto
Su-
ponga
usuario
escribe
comando
indicando
editor
elimine
línea
cierre
hueco
líneas
editor
enviar
secuencia
escape
línea
serial
terminal
ESC
ESC
ESC
espacios
utilizan
separar
símbolos
transmiten
secuencia
des-
plaza
cursor
principio
línea
borra
línea
elimina
línea
vacía
provoca
líneas
empiezan
desplacen
línea
Enton-
ces
línea
convierte
línea
línea
convierte
línea
sucesivo
utilizar
secuencias
escape
análogas
agregar
texto
media
pantalla
palabras
agregar
eliminar
similar
sistema
Window
sistemas
UNIX
basan
interfaz
usuario
Sistema
Window
menu-
do
llama
desarrollado
M.I.T.
proyecto
Athena
década
1980
portátil
ejecuta
completo
espacio
usuario
principio
400
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
401
propósito
principal
conectar
número
terminales
usuario
remotas
servidor
cómputo
central
dividido
lógicamente
software
cliente
software
servidor
ejecutarse
potencialmente
distintas
computadoras
mayoría
computadoras
mo-
dernas
ambas
partes
ejecutar
equipo
sistemas
Linux
populares
entornos
escritorio
Gnome
KDE
ejecutan
X.
ejecuta
equipo
software
recolecta
entrada
teclado
ratón
escribe
salida
pantalla
llama
servidor
software
regis-
tro
ventana
seleccionada
momento
ratón
sa-
ber
cliente
enviar
entrada
teclado
comunica
programas
ejecución
posiblemente
red
llamados
clientes
X.
envía
entrada
ra-
tón
teclado
acepta
comandos
pantalla
parecer
extraño
servidor
esté
computadora
usuario
cliente
servidor
cómputo
remoto
piense
tra-
principal
servidor
mostrar
bits
pantalla
sentido
esté
cerca
usuario
punto
vista
programa
cliente
servidor
haga
cosas
mostrar
texto
figuras
geométricas
servidor
PC
local
justo
servidores
arreglo
cliente
servidor
muestra
figura
5.37
caso
cliente
servidor
encuentran
distintos
equipos
ejecutar
Gnome
KDE
equipo
cliente
programa
aplicación
utiliza
biblioteca
ser-
vidor
equipo
usando
conexión
TCP
sockets
caso
remoto
Secuencia
escape
Significado
ESC
desplaza
líneas
ESC
desplaza
líneas
abajo
ESC
desplaza
espacios
derecha
ESC
desplaza
espacios
izquierda
ESC
Desplaza
cursor
ESC
Borra
pantalla
cursor
inicio
ESC
Borra
línea
cursor
inicio
ESC
Inserta
líneas
cursor
ESC
Elimina
líneas
cursor
ESC
Elimina
caracteres
cursor
ESC
Inserta
caracteres
cursor
ESC
Habilita
reproducción
normal
negritas
parpadeo
inverso
ESC
Desplaza
pantalla
atrás
cursor
línea
superior
Figura
5-36
secuencias
escape
ANSI
aceptadas
software
controlador
terminal
salida
ESC
denota
carácter
escape
ASCII
0x1B
pa-
rámetros
numéricos
opcionales
www
FreeLibros.meLa
razón
ejecutar
Sistema
Window
UNIX
sistema
operativo
máquina
red
define
reali-
dad
protocolo
cliente
servidor
muestra
figura
5-37
im-
porta
cliente
servidor
equipo
separados
100
metros
red
área
local
miles
kilómetros
aparte
conectados
Internet
protocolo
opera-
ción
sistema
idéntico
casos
sistema
ventanas
GUI
completa
obtener
GUI
completa
ejecutan
capas
software
capas
Xlib
conjunto
procedimien-
tos
biblioteca
acceder
funcionalidad
X.
procedimientos
forman
base
Sis-
tema
Window
examinaremos
continuación
primitivos
mayoría
programas
usuario
utilicen
directa
ejemplo
clic
ratón
reporta
separado
proceso
determinar
clics
realidad
forman
doble
clic
manejar
Xlib
facilitar
programación
suministra
kit
herramientas
consiste
Intrinsics
nivel
maneja
botones
barras
desplazamiento
elementos
GUI
conocidos
widgets
crear
interfaz
GUI
apariencia
visual
uniforme
necesita
nivel
ejemplo
Motif
muestra
figura
5-37
forma
base
Entorno
Escritorio
Común
utilizado
Solaris
sistemas
UNIX
comerciales
mayoría
aplicaciones
llamadas
Motif
Xlib
Gnome
KDE
estructura
similar
figura
5-37
distintas
bibliote-
cas
Gnome
utiliza
biblioteca
GTK
H11001y
KDE
utiliza
biblioteca
Qt
caso
GUIs
debatirse
402
ENTRADA
SALIDA
CAPÍTULO
Host
remoto
Administrador
ventana
Programa
aplicación
Motif
Intrinsics
Xlib
Cliente
UNIX
Hardware
Servidor
UNIX
Hardware
Ventana
Espacio
usuario
Espacio
kernel
Protocolo
Red
Figura
5-37
Clientes
servidores
Sistema
Window
M.I.T.
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
403
vale
pena
recalcar
administración
ventanas
X.
decisión
omitir
característica
completamente
intencional
proceso
separado
cliente
conocido
administrador
ventana
controla
creación
eliminación
movi-
miento
ventanas
pantalla
administrar
ventanas
envía
comandos
servidor
indicarle
ejecuta
máquina
cliente
teoría
ejecutar
diseño
modular
consiste
niveles
programas
altamente
portátil
flexible
llevado
mayoría
versiones
UNIX
incluyendo
Solaris
varian-
tes
BSD
AIX
Linux
etcétera
forma
desarrolladores
aplicaciones
uti-
lizar
interfaz
usuario
estándar
plataformas
llevado
sistemas
operativos
contrario
Windows
sistemas
ventanas
GUI
mezcla-
GDI
encuentran
kernel
difíciles
mantener
des-
portátiles
analizar
brevemente
nivel
Xlib
inicia
programa
abre
conexión
servidores
llamar
estaciones
trabajo
colocar
equipo
programa
co-
nexión
confiable
mensajes
perdidos
duplicados
manejan
software
red
preocuparse
errores
comunicación
general
uti-
liza
TCP
IP
cliente
servidor
Pasan
tipos
mensajes
conexión
Comandos
dibujo
programa
estación
trabajo
Respuestas
estación
trabajo
solicitudes
programa
Mensajes
teclado
ratón
eventos
Mensajes
error
mayoría
comandos
dibujo
envían
programa
estación
trabajo
mensajes
vía
espera
respuesta
razón
diseño
procesos
cliente
servidor
distintos
equipos
requerir
periodo
considerable
comando
llegue
servidor
lleve
cabo
bloquea
programa
aplicación
tiempo
reduciría
velocidad
necesidad
programa
necesita
información
estación
trabajo
simplemente
esperar
respuesta
regrese
Windows
controlado
eventos
eventos
fluyen
estación
trabajo
programa
general
respuesta
acción
humana
pulsaciones
teclado
movimientos
ratón
acción
descubrir
ventana
men-
saje
evento
32
bytes
byte
indica
tipo
evento
siguientes
31
bytes
indican
información
adicional
docenas
tipos
eventos
progra-
ma
envían
eventos
manejar
ejemplo
programa
interesa-
do
eventos
ocurren
usuario
suelta
tecla
envían
eventos
liberación
tecla
Windows
eventos
ponen
cola
programas
leen
eventos
cola
entrada
www
FreeLibros.meSin
diferencia
Windows
sistema
operativo
llama
procedimientos
programa
aplicación
siquiera
procedimiento
maneja
evento
concepto
clave
recurso
recurso
estructura
datos
contiene
cier-
ta
información
programas
aplicación
crean
recursos
estaciones
trabajo
re-
cursos
compartir
procesos
estación
trabajo
recursos
tiempo
vida
corto
sobreviven
reinicios
estación
trabajo
recursos
típicos
ventanas
tipos
letra
mapas
colores
paletas
colores
mapas
pí-
xeles
mapas
bits
cursores
contextos
gráficos
utilizan
asociar
propiedades
ventanas
similares
concepto
contextos
dispositivos
Windows
figura
5-38
muestra
esqueleto
incompleto
programa
X.
Empieza
in-
cluir
encabezados
requeridos
declara
variables
conecta
ser-
vidor
especificado
parámetro
XOpenDisplay
asigna
recurso
ventana
almacena
manejador
recurso
win
práctica
ocurriría
inicializa-
ción
indica
administrador
ventanas
ventana
administrarla
llamada
XCreateGC
crea
contexto
gráfico
almacenan
propiedades
ventana
programa
completo
inicializarse
punto
instruc-
ción
llamada
XSelectInput
indica
servidor
eventos
preparado
progra-
ma
manejar
caso
interesado
clics
ratón
pulsaciones
teclas
ventanas
descubren
práctica
programa
real
estaría
interesado
eventos
llamada
XMapRaised
asigna
ventana
pantalla
ven-
tana
nivel
superior
punto
ventana
vuelve
visible
pantalla
ciclo
principal
consiste
instrucciones
sentido
lógico
simple
ciclo
correspondiente
Windows
instrucción
obtiene
evento
envía
tipo
evento
procesamiento
evento
indica
programa
terminado
ejecución
establece
ciclo
termina
salir
programa
libera
contexto
grá-
fico
ventana
conexión
Vale
pena
mencionar
gusta
GUI
programadores
prefieren
interfaz
línea
comandos
tipo
vimos
sección
5.6.2
encarga
programa
cliente
llamado
xterm
programa
emula
venerable
terminal
in-
teligente
VT102
completa
secuencias
escape
editores
vi
emacs
software
utiliza
termcap
funcionan
ventanas
modificación
Interfaces
gráficas
usuario
mayoría
computadoras
personales
ofrecen
GUI
Graphic
User
Interface
Interfaz
grá-
fica
usuario
GUI
inventada
Douglas
Engelbart
grupo
investigación
Stanford
Re-
search
Institute
copiada
investigadores
Xerox
PARC
Steve
Jobs
co-fundador
Apple
paseando
PARC
vio
GUI
computadora
Xerox
404
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
405
Dios
futuro
computación
GUI
idea
computadora
convirtió
Lisa
Apple
Lisa
costosa
fra-
caso
comercial
sucesora
Macintosh
enorme
éxito
Microsoft
obtuvo
prototipo
Macintosh
desarrollar
Microsoft
Offi-
ce
rogó
Apple
otorgara
licencia
quisieran
convertirla
estándar
industria
Microsoft
dinero
Office
MS-DOS
dispuesta
abandonar
MS-DOS
plataforma
Office
ejecutivo
Apple
cargo
Macintosh
Jean-Louis
Gassée
rehusó
Steve
Jobs
esta-
ba
contradecirlo
tiempo
Microsoft
obtuvo
licencia
elementos
in-
terfaz
formó
base
Windows
Windows
empezó
obtener
popularidad
Apple
demandó
Microsoft
arguyendo
Microsoft
excedido
licencia
juez
include
X11
Xlib.h
include
X11
Xutil.h
main(int
argc
char
argv
Display
pant
identificador
servidor
Window
vent
identificador
ventana
GC
gc
identificador
contexto
gráfico
XEvent
evento
almacenamiento
evento
int
enejecucion
pant
XOpenDisplay(“nombre_pantalla
conecta
servidor
vent
XCreateSimpleWindow(pant
asigna
memoria
ventana
XSetStandardProperties(pant
anuncia
ventana
admin
ventanas
gc
XCreateGC(pant
vent
crea
contexto
gráfico
XSelectInput(pant
vent
ButtonPressMask
KeyPressMask
ExposureMask
XMapRaised(pant
vent
muestra
ventana
envía
evento
Expose
while
enejecucion
XNextEvent(pant
evento
obtiene
evento
switch(evento.type
case
Expose
break
vuelve
dibujar
ventana
case
ButtonPress
break
procesa
click
ratón
case
Keypress
break
procesa
entrada
teclado
XFreeGC(pant
gc
libera
contexto
gráfico
XDestroyWindow(pant
vent
desasigna
espacio
memoria
ventana
XCloseDisplay(pant
apaga
conexión
red
Figura
5-38
esqueleto
programa
aplicación
Window
www.FreeLibros.mede
Windows
sobrepasó
Macintosh
Gassée
hubiera
personas
Apple
querían
otorgar
licencia
software
Macintosh
to-
Apple
hubiera
enriquecido
inmensamente
cuotas
licencia
Windows
existiría
momentos
GUI
elementos
esenciales
denotados
caracteres
WIMP
letras
re-
presentan
ventanas
Windows
iconos
Icons
menús
Menus
dispositivo
señalador
Pointing
device
respectivamente
ventanas
áreas
rectangulares
pantalla
utilizan
ejecutar
programas
iconos
pequeños
símbolos
clic
ocu-
rra
acción
menús
listas
acciones
elegir
dis-
positivo
señalador
ratón
trackball
dispositivo
hardware
utilizado
desplazar
cursor
pantalla
seleccionar
elementos
software
GUI
implementar
código
nivel
usuario
sistemas
UNIX
sistema
operativo
caso
Windows
entrada
sistemas
GUI
utilizando
teclado
ratón
salida
siem-
pre
hardware
especial
conocido
adaptador
gráficos
adaptador
gráficos
contiene
memoria
especial
conocida
RAM
video
contiene
imágenes
apa-
recen
pantalla
adaptadores
gráficos
alto
rendimiento
CPUs
pode-
rosas
32
64
bits
GB
RAM
separada
memoria
principal
computadora
adaptador
gráficos
produce
tamaños
pantalla
tamaños
comunes
1024
/H11003768
1280
/H11003960
1600
/H110031200
1920
/H110031200
1920
/H110031200
encuentran
proporción
4:3
adapta
proporción
aspecto
televisores
NTSC
PAL
ende
proporciona
pixeles
cuadrados
monitores
utilizan
televisores
tamaño
1920
/H110031200
destinado
monitores
pantalla
am-
plia
cuya
proporción
aspecto
coincide
resolución
resolución
alta
pan-
talla
colores
24
bits
pixel
requiere
6.5
MB
RAM
contener
imagen
256
adaptador
gráficos
contener
imágenes
pantalla
completa
actualiza
75
RAM
video
capaz
transferir
datos
forma
continua
489
MB
seg
software
salida
GUIs
tema
masivo
escrito
libros
1500
páginas
acerca
Windows
GUI
ejemplo
Petzold
1999
Simon
1997
Rector
Newcomer
1997
evidente
sección
rasguñar
superficie
presentar
conceptos
subyacentes
análisis
concreto
describiremos
API
Win32
proporcionada
versiones
32
bits
Windows
software
salida
GUIs
comparable
sentido
general
detalles
dis-
tintos
elemento
básico
pantalla
área
rectangular
llamada
ventana
posición
ta-
maño
ventana
determinan
forma
única
proporcionar
coordenadas
pixeles
esquinas
diagonalmente
opuestas
ventana
contener
barra
título
barra
menús
barra
desplazamiento
vertical
barra
desplazamiento
horizontal
fi-
gura
5-39
muestra
ventana
ordinaria
Observe
sistema
coordenadas
Windows
posiciona
origen
esquina
superior
izquierda
incrementa
abajo
distinto
coordenadas
cartesianas
utilizan
matemáticas
406
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
407
crea
ventana
parámetros
especifican
usuario
moverla
cambiar
tamaño
desplazarse
interior
arrastrando
control
deslizante
barra
desplaza-
miento
ventana
principal
producen
mayoría
programas
mover
cambiar
tamaño
desplazar
interior
enormes
consecuencias
forma
escriben
programas
Windows
especial
programas
informados
acerca
cambios
tamaño
ventanas
preparados
redibujar
con-
ventanas
momento
esperan
consecuencia
programas
Windows
orientados
mensajes
acciones
usuarios
involucran
teclado
ratón
capturadas
Windows
convierten
mensajes
programa
propietario
ventana
utilizando
programa
cola
mensajes
envían
mensajes
relacionados
ventanas
ciclo
principal
programa
consiste
extraer
mensaje
procesarlo
llamada
procedimiento
interno
tipo
mensaje
casos
Windows
lla-
mar
procedimientos
directamente
evadiendo
cola
mensajes
modelo
distinto
modelo
UNIX
código
procedimientos
realiza
llamadas
sistema
interactuar
sistema
operativo
orientado
eventos
Control
deslizante
Title
bar
File
Edit
View
Tools
Options
Help
Área
cliente
200
100
767
Barra
menús
Barra
herramientas
Ventana
Barra
desplaza-
miento
1023
767
1023
12
93
111
210
Figura
5-39
ventana
ejemplo
ubicada
200
100
pantalla
XGA
www
FreeLibros.mePara
modelo
programación
considere
ejemplo
figura
5-40
esqueleto
programa
principal
Windows
completo
realiza
com-
probación
errores
muestra
suficiente
detalle
fines
Empieza
incluir
archivo
encabezado
llamado
windows.h
contiene
macros
tipos
datos
constantes
prototipos
funciones
información
necesaria
programas
Windows
include
windows.h
int
WINAPI
WinMain(HINSTANCE
HINSTANCE
hprev
char
szCmd
int
iCmdShow
WNDCLASS
wndclass
objeto
clase
ventana
MSG
msg
mensajes
entrantes
almacenan
HWND
hwnd
manejador
apuntador
objeto
ventana
inicializa
wndclass
wndclass.lpfnWndProc
WndProc
indica
procedimiento
llamar
wndclass.lpszClassName
Nombre
programa
Texto
barra
título
wndclass.hIcon
LoadIcon(NULL
IDI_APPLICATION
carga
icono
programa
wndclass.hCursor
LoadCursor(NULL
IDC_ARROW
carga
cursor
ratón
RegisterClass(&wndclass
indica
Windows
acerca
wndclass
hwnd
CreateWindow
asigna
espacio
almacenamiento
ventana
ShowWindow(hwnd
iCmdShow
muestra
ventana
pantalla
UpdateWindow(hwnd
indica
ventana
pinte
while
GetMessage(&msg
NULL
obtiene
mensaje
cola
TranslateMessage(&msg
traduce
mensaje
DispatchMessage(&msg
envía
mensaje
procedimiento
apropiado
return(msg.wParam
long
CALLBACK
WndProc(HWND
hwnd
UINT
message
UINT
wParam
long
lParam
declaraciones
switch
mensaje
case
WM_CREATE
return
crea
ventana
case
WM_PAINT
return
vuelve
pintar
contenido
ventana
case
WM_DESTROY
return
destruye
ventana
return(DefWindowProc(hwnd
message
wParam
lParam
predeterminado
Figura
5-40
esqueleto
programa
principal
Windows
408
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
409
programa
principal
empieza
declaración
proporciona
nombre
pará-
metros
macro
WINAPI
instrucción
compilador
utilice
convención
paso
parámetros
relevante
parámetro
manejador
instancia
utiliza
identificar
programa
resto
sistema
grado
Win32
orientado
objetos
significa
sistema
contiene
objetos
ejemplo
pro-
gramas
archivos
ventanas
código
asociado
conocidos
mé-
operan
referencia
objetos
utilizan
manejadores
caso
identifica
programa
parámetro
presente
razones
compatibilidad
retroactiva
utiliza
tercer
parámetro
szCmd
cadena
termi-
nación
cero
contiene
línea
comandos
inició
programa
iniciado
línea
comandos
cuarto
parámetro
iCmdShow
indica
ventana
ini-
cial
programa
ocupar
pantalla
área
pantalla
só-
barra
tareas
declaración
ilustra
convención
ampliamente
utilizada
Microsoft
conocida
notación
húngara
nombre
juego
palabras
notación
polaca
sistema
postfi-
jo
inventado
lógico
polaco
J.
Lukasiewicz
representa
fórmulas
algebraicas
utilizar
precedencia
paréntesis
notación
húngara
inventada
programador
húngaro
Mi-
crosoft
llamado
Charles
Simonyi
utiliza
caracteres
identificador
especi-
ficar
tipo
letras
tipos
permitidos
incluyen
carácter
palabra
significa
entero
16
bits
signo
entero
signo
32
bits
long
entero
signo
32
bits
cadena
sz
cadena
terminada
byte
cero
apuntador
fn
función
mane-
jador
szCmd
cadena
terminación
cero
iCmdShow
entero
ejemplo
Mu-
chos
programadores
creen
codificar
tipo
nombres
variables
forma
valor
código
Windows
excepcionalmente
difícil
leer
análogo
convención
presente
UNIX
ventana
objeto
clase
asociado
defina
propiedades
figura
5-40
objeto
clase
wndclass
objeto
tipo
WNDCLASS
10
campos
inicializan
figura
5.40
programa
real
inicializarían
campo
importante
lpfnWndProc
apuntador
32
bits
fun-
ción
maneja
mensajes
dirigidos
ventana
campos
inicializan
indican
nombre
icono
barra
título
símbolo
cursor
ratón
inicializado
wndclass
llamada
RegisterClass
pasarlo
Windows
especial
llamada
Windows
procedimiento
llamar
ocu-
rran
eventos
pasen
cola
mensajes
llamada
CreateWin-
dow
asigna
memoria
estructura
datos
ventana
devuelve
manejador
referencia
posteriormente
programa
realiza
llamadas
fila
colo-
car
contorno
ventana
pantalla
rellena
completo
punto
llegamos
ciclo
principal
programa
consiste
obtener
mensaje
realizarle
traducciones
pasarlo
vuelta
Windows
invoque
WndProc
procese
responder
pregunta
mecanismo
hubiera
podido
simplificar
respuesta
forma
razones
históricas
cos-
tumbre
www
FreeLibros.meDespués
programa
principal
procedimiento
WndProc
maneja
diversos
men-
sajes
enviar
ventana
CALLBACK
WINAPI
anterior-
mente
especifica
secuencia
llamada
parámetros
parámetro
manejador
ventana
utilizar
parámetro
tipo
mensaje
parámetros
ter-
cero
cuarto
utilizar
proveer
información
adicional
necesario
tipos
mensajes
WM_CREATE
WM_DESTROYse
envían
inicio
progra-
ma
respectivamente
ejemplo
programa
oportunidad
asignar
memoria
es-
tructuras
datos
devolverla
tercer
tipo
mensaje
WM_PAINT
instrucción
programa
rellene
ven-
tana
llama
dibuja
ventana
llama
frecuencia
ejecución
programa
contraste
sistemas
basados
texto
Win-
dows
programa
asumir
dibuje
pantalla
permanecerá
quite
arrastrar
ventanas
desplegarse
menús
pue-
cuadros
diálogo
cuadros
información
herramientas
cubriendo
sucesivo
eliminan
elementos
ventana
volver
dibujar
forma
Windows
indica
programa
volver
dibujar
ventana
enviándole
mensaje
WM_PAINT
gesto
amigable
proporciona
información
acerca
par-
ventana
sobrescrito
caso
fácil
regenerar
ventana
volver
dibujarla
formas
Windows
programa
realice
publicar
mensaje
cola
mensajes
método
utiliza
entrada
teclado
ratón
temporizadores
expirado
forma
enviar
mensaje
ventana
impli-
ca
Windows
llame
directamente
WndProc
método
utiliza
even-
tos
Windows
notifica
mensaje
procesado
completo
abstenerse
llamada
termine
evitan
condiciones
competencia
tipos
mensajes
evitar
comportamiento
errático
caso
lle-
gue
mensaje
inesperado
programa
llamar
DefWindowProc
WndProc
dejar
manejador
predeterminado
encargue
casos
resumen
programa
Windows
general
crea
ventanas
objeto
clase
instancia
comportamiento
programa
controlado
eventos
entrantes
procesan
procedimientos
manejador
mo-
delo
mundo
visión
orientada
procedimientos
UNIX
acción
dibujar
pantalla
maneja
paquete
consiste
cientos
procedimientos
conjunto
forman
GDI
Graphics
Device
Interface
Interfaz
dispositi-
vo
gráfico
manejar
texto
tipo
gráficos
diseñada
independiente
plataforma
dispositivo
programa
dibujar
pintar
ventana
necesita
adquirir
contexto
dispositivo
estructura
datos
interna
contiene
propiedades
ventana
tipo
letra
actual
color
texto
color
fondo
et-
cétera
mayoría
llamadas
GDI
utilizan
contexto
dispositivo
dibujar
obtener
establecer
propiedades
formas
adquirir
contexto
dispositivo
ejemplo
simple
adqui-
sición
410
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
411
hdc
GetDC(hwnd
TextOut(hdc
psText
iLength
ReleaseDC(hwnd
hdc
instrucción
obtiene
manejador
contexto
dispositivo
hdc
uti-
liza
contexto
dispositivo
escribir
línea
texto
pantalla
especificar
coorde-
nadas
posición
inicia
cadena
apuntador
cadena
longitud
llamada
libera
contexto
dispositivo
indicar
programa
terminado
dibujar
momento
Observe
hdc
utiliza
análoga
descriptor
ar-
chivo
UNIX
Observe
ReleaseDC
contiene
información
redundante
hdc
especifica
ventana
forma
única
información
redundante
valor
actual
común
Windows
observación
interesante
hdc
adquiere
forma
programa
escribir
área
cliente
ventana
barra
título
partes
Cual-
quier
dibujo
región
recorte
ignora
forma
adquirir
con-
texto
dispositivo
GetWindowDC
establece
región
recorte
ventana
llamadas
restringen
versión
recorte
formas
llamadas
característico
Windows
análisis
detallado
GDI
excede
alcances
libro
lector
interesado
referencias
citadas
proveen
información
adicional
vale
pena
mencionar
palabras
acerca
GDI
dada
importancia
GDI
llamadas
proce-
dimientos
obtener
liberar
contextos
dispositivos
obtener
información
acerca
con-
textos
dispositivos
obtener
establecer
atributos
contexto
dispositivo
ejemplo
color
fondo
manipular
objetos
GDI
pluma
brochas
tipos
letra
atributos
número
llama-
das
GDI
dibujar
pantalla
procedimientos
dibujo
dividen
categorías
dibujo
líneas
curvas
dibu-
jo
áreas
rellenas
administración
mapas
bits
visualización
texto
Anteriormente
vimos
ejemplo
dibujar
texto
daremos
vistazo
rápido
llamada
Rectangle(hdc
xizq
ysup
xder
yinf
dibuja
rectángulo
relleno
cuyas
esquinas
xizq
ysup
xder
yinf
ejemplo
Rectangle(hdc
dibujará
rectángulo
muestra
figura
5-41
anchura
color
línea
color
relleno
toman
contexto
dispositivo
llamadas
GDI
similares
Mapas
bits
procedimientos
GDI
ejemplos
gráficos
vectoriales
utilizan
colocar
figu-
ras
geométricas
texto
pantalla
escalar
facilidad
pantallas
pe-
queñas
número
pixeles
pantalla
www.FreeLibros.merelativamente
independientes
dispositivo
colección
llamadas
procedimientos
GDI
ensamblar
archivo
describa
dibujo
completo
archivo
co-
noce
metarchivo
Windows
ampliamente
utilizado
transmitir
dibujos
pro-
grama
Windows
Dichos
archivos
extensión
.wmf
programas
Windows
permiten
usuario
copiar
dibujo
colocarlo
portapapeles
Windows
usuario
programa
pegar
contenido
portapapeles
documento
programa
represente
dibujo
metarchivo
Windows
coloque
portapapeles
formato
.wmf
Tam-
bién
formas
imágenes
manipular
computadoras
generar
gráficos
vectoriales
ejemplo
fotografías
videos
utilizan
gráficos
vectoriales
elementos
exploran
sobreponer
rejilla
imagen
valores
rojo
verde
azul
promedio
cuadro
rejilla
muestrean
guardan
valor
pixel
archivo
conoce
mapa
bits
herramientas
Windows
pa-
ra
manipular
mapas
bits
mapas
bits
texto
forma
representar
carácter
específico
tipo
letra
pequeño
mapa
bits
agregar
texto
pantalla
convier-
cuestión
mover
mapas
bits
forma
general
utilizar
mapas
bits
procedimiento
llamado
bitblt
llama
BitBlt(dsthdc
dx
dy
wid
ht
srchdc
sx
sy
rasterop
forma
simple
copia
mapa
bits
rectángulo
ventana
rectángulo
ventana
parámetros
especifican
ventana
destino
po-
sición
vienen
anchura
altura
ventana
origen
posición
Observe
412
ENTRADA
SALIDA
CAPÍTULO
12
345678
Figura
5-41
rectángulo
ejemplo
dibujado
Rectangle
cuadro
representa
pixel
www
FreeLibros.meSECCIÓN
5.6
INTERFACES
USUARIO
TECLADO
RATÓN
MONITOR
413
ventana
sistema
coordenadas
esquina
superior
izquierda
ventana
Describiremos
parámetro
continuación
efecto
BitBlt(hdc2
hdc1
SRCCOPY
muestra
figura
5-42
Observe
cuidado
copiado
área
le-
tra
incluyendo
color
fondo
02468
02468
Ventana
Ventana
02468
02468
Ventana
Ventana
Figura
5-42
Copiado
mapas
bits
usando
BitBlt
BitBlt
copiar
mapas
bits
parámetro
posibili-
dad
operaciones
booleanas
combinar
mapa
bits
origen
mapa
bits
destino
ejemplo
aplicar
OR
origen
destino
fusionarlos
aplicar
OR
EXCLUSIVO
mantienen
características
origen
destino
problema
mapas
bits
escalan
carácter
cuadro
12
pantalla
640
480
verá
razonable
obstante
mapa
bits
copia
página
impresa
1200
puntos
pulgada
equivale
10200
bits
13200
bits
anchura
carácter
pixeles
8/1200
pulgadas
0.17
mm
ancho
copiado
dispo-
sitivos
distintas
propiedades
color
monocromo
color
funciona
razón
Windows
soporte
estructura
datos
llamada
DIB
De-
vice
Independent
Bitmap
Mapa
bits
independiente
dispositivo
archivos
utilizan
es-
formato
extensión
.bmp
archivos
encabezados
archivo
información
tabla
color
pixeles
información
facilita
acción
mover
mapas
bits
dispositivos
similares
Tipos
letras
versiones
Windows
anteriores
3.1
caracteres
representaban
mapas
bits
copiaban
pantalla
impresora
BitBlt
problema
acabamos
mapa
bits
ve
pantalla
pequeño
impresora
www
FreeLibros.meAdemás
necesita
mapa
bits
carácter
tamaño
palabras
mapa
bits
tipo
letra
10
puntos
calcularlo
tipo
letra
12
puntos
carácter
tipo
letra
necesario
tama-
ños
varíen
120
puntos
necesaria
cantidad
enorme
mapas
bits
sistema
complejo
texto
solución
introducción
tipos
letra
TrueType
mapas
bits
contornos
caracteres
carácter
TrueType
define
secuencia
puntos
al-
rededor
perímetro
puntos
relativos
origen
sistema
fácil
escalar
caracteres
abajo
multiplicar
coordenada
factor
escala
forma
carácter
TrueType
es-
calar
abajo
tamaño
punto
tamaños
punto
frac-
cionados
tengan
tamaño
apropiado
puntos
conectar
utilizando
reconocido
algoritmo
seguir
puntos
enseña
preescolar
escuelas
preesco-
lar
modernas
utilizan
líneas
tipo
junquillo
splines
obtener
resultados
uniformes
completado
contorno
carácter
rellenar
figura
5-43
proporcio-
na
ejemplo
caracteres
escalados
distintos
tamaños
punto
414
ENTRADA
SALIDA
CAPÍTULO
20
pt
53
pt
81
pt
Figura
5-43
ejemplos
contornos
caracteres
distintos
tamaños
punto
carácter
relleno
disponible
forma
matemática
convertir
tramas
rasterizarse
convertirse
mapa
bits
resolución
deseada
escalar
pri-
mero
convertir
tramas
seguros
caracteres
mostrados
pan-
talla
aparezcan
impresora
parecidos
posibles
diferencias
error
cuantización
mejorar
calidad
emplear
técnica
hinting
ajusta
www
FreeLibros.meSECCIÓN
5.7
CLIENTES
DELGADOS
415
resultado
convertir
contorno
trama
ejemplo
patines
superior
letra
idénticos
error
redondeo
utiliza
hinting
téc-
nica
mejora
apariencia
5.7
CLIENTES
DELGADOS
paso
años
principal
paradigma
computación
oscilado
computación
centralizada
descentralizada
primeras
computadoras
ENIAC
compu-
tadoras
personales
extensas
persona
podía
usarlas
llegaron
sistemas
tiempo
compartido
usuarios
remotos
terminales
sim-
ples
compartían
computadora
central
PC
usua-
rios
tenían
computadoras
personales
modelo
PC
descentralizado
ventajas
desventajas
graves
empezando
tomar
seriedad
Probablemente
problema
PC
disco
duro
extenso
software
complejo
mantener
ejemplo
sale
mercado
versión
sistema
operativo
trabajar
rea-
lizar
actualización
equipo
separado
mayoría
empresas
costos
ma-
obra
tipo
mantenimiento
software
empequeñecen
costos
actuales
hardware
software
usuarios
domésticos
labor
técnicamente
gratuita
personas
capaces
realizarla
forma
correcta
personas
disfrutan
haciéndolo
sistema
centralizado
máquinas
actualizarse
má-
quinas
personal
expertos
trabajo
cuestión
relacionada
usuarios
respaldos
regularidad
sis-
temas
archivos
gigabytes
datos
ocurre
desastre
acompañado
gemidos
estrujamiento
manos
sistema
centralizado
pue-
den
respaldos
noche
robots
cintas
automatizados
desventaja
compartición
recursos
fácil
sistemas
centraliza-
sistema
256
usuarios
remotos
256
MB
RAM
par-
RAM
inactiva
tiempo
sistema
centralizado
64
GB
RAM
pasa
usuario
necesite
temporalmente
RAM
ob-
tenerla
PC
alguien
aplica
espacio
disco
recursos
empezando
cambio
computación
céntrica
PC
compu-
tación
céntrica
Web
área
cambio
adelantado
correo
electrónico
gente
solía
obtener
correo
electrónico
equipo
hogar
leía
per-
sonas
entran
Gmail
Hotmail
Yahoo
leen
correo
paso
personas
ini-
cien
sesión
sitios
Web
procesamiento
palabras
crear
hojas
cálculo
cosas
solían
requerir
software
PC
momento
único
soft-
ware
ejecute
gente
PC
navegador
Web
siquiera
Probablemente
conclusión
justa
mayoría
usuarios
desean
compu-
tación
interactiva
alto
rendimiento
realidad
quieren
administrar
computadora
Es-
to
llevado
investigadores
reexaminar
compartición
tiempo
utilizando
terminales
www
FreeLibros.me“tontas
conoce
términos
políticamente
correctos
clientes
delgados
cumplan
expectativas
terminales
modernas
paso
dirección
ter-
minales
dedicadas
populares
tiempo
perdieron
popularidad
costaban
PCs
podían
formas
necesitaban
grado
manteni-
miento
software
descubrimiento
año
sistema
cómputo
interactivo
alto
ren-
dimiento
máquinas
usuario
tuvieran
software
interesante
meta
lograr
continuación
describiremos
sistemas
cliente
delgado
conocido
THINC
desarrollado
investigadores
Universidad
Columbia
Baratto
co-
laboradores
2005
Kim
colaboradores
2006
Lai
Nieh
2006
idea
básica
eliminar
máquina
cliente
inteligencia
software
utili-
zarla
pantalla
cómputo
incluyendo
proceso
construir
mapa
bits
mostrar
realice
servidor
protocolo
cliente
servidor
indica
pantalla
actualizar
RAM
video
utilizan
comandos
protocolo
lados
comandos
listan
figura
5-44
416
ENTRADA
SALIDA
CAPÍTULO
Figura
5-44
comandos
visualización
protocolo
THINC
Comando
Descripción
Raw
Muestra
datos
pixeles
crudos
ubicación
dada
Copy
Copia
área
búfer
estructura
coordenadas
específicas
Sfill
Llena
área
valor
color
pixel
Pfill
Llena
área
patrón
pixeles
Bitmap
Llena
región
utilizando
imagen
mapa
bits
examinar
comandos
Rawse
utiliza
transmitir
datos
pixeles
muestren
directamente
pantalla
principio
único
comando
nece-
sario
optimizaciones
Copyinstruye
pantalla
mueva
datos
RAM
video
par-
útil
desplazar
pantalla
volver
transmitir
datos
Sfillllena
región
pantalla
valor
píxel
pantallas
fondo
uniforme
color
comando
utiliza
generar
fondo
pintar
texto
iconos
elementos
Pfillreplica
patrón
región
utiliza
fondos
complejos
color
cuyo
caso
comando
realiza
trabajo
Bitmaptambién
pinta
región
color
plano
color
fondo
comandos
simples
requieren
software
cliente
complejidad
construir
mapas
bits
llenan
pantalla
llevan
cabo
servidor
mejorar
eficiencia
agregar
comandos
paquete
transmitirlos
red
servidor
cliente
servidor
programas
gráficos
utilizan
comandos
alto
nivel
pintar
panta-
lla
interceptados
software
THINC
traducen
comandos
en-
viar
cliente
comandos
reordenar
mejorar
eficiencia
www
FreeLibros.meSECCIÓN
5.8
ADMINISTRACIÓN
ENERGÍA
417
artículo
proporciona
mediciones
rendimiento
ejecutan
numerosas
aplicacio-
nes
comunes
servidores
ubicados
distancias
varían
10
km
10,000
km
cliente
general
rendimiento
superior
sistemas
red
área
amplia
video
tiempo
real
obtener
información
consulte
artículos
5.8
ADMINISTRACIÓN
ENERGÍA
computadora
electrónica
propósito
general
ENIAC
18,000
tubos
vacío
consumía
140,000
watts
energía
resultado
generaba
factura
electricidad
tri-
vial
invención
transistor
energía
disminuyó
forma
considerable
industria
computadoras
perdió
interés
requerimientos
energía
administración
energía
vuelve
mira
razones
sistema
operativo
desempeña
papel
empezar
PCs
escritorio
PC
escritorio
fuente
energía
200
watts
general
eficiencia
85%
pierde
15%
energía
entrante
calor
encienden
100
millones
máquinas
tiem-
po
mundo
conjunto
utilizan
20,000
megawatts
electricidad
producción
20
plantas
energía
nuclear
tamaño
promedio
pudiera
reducir
mitad
re-
querimiento
energía
podríamos
deshacernos
10
plantas
nucleares
punto
vista
ambiental
deshacerse
10
plantas
energía
nuclear
número
equivalente
plantas
com-
bustible
fósil
avance
vale
pena
tratar
lograrlo
sitio
energía
cuestión
importante
computadoras
operadas
batería
incluyendo
notebooks
bolsillo
Webpads
núcleo
problema
baterías
contener
suficiente
carga
durar
tiempo
al-
canzan
horas
esfuerzos
investigación
masivos
em-
presas
baterías
computadoras
electrónica
consumidor
progreso
detenido
industria
acostumbrada
duplicar
rendimiento
18
meses
ley
Moore
nin-
gún
progreso
violación
leyes
física
situación
actual
Co-
mo
consecuencia
computadoras
utilicen
energía
baterías
existentes
duren
tiempo
alta
prioridad
sistema
operativo
desempeña
im-
portante
papel
veremos
continuación
nivel
distribuidores
hardware
tratando
componen-
tes
electrónicos
eficientes
energía
técnicas
utilizadas
incluyen
reducción
tamaño
transistores
empleo
escalas
voltaje
dinámicas
buses
adiabáticos
desviación
técnicas
similares
alcance
libro
lectores
in-
teresados
encontrar
estudio
artículo
Venkatachalam
Franz
2005
métodos
generales
reducir
consumo
energía
sistema
operativo
apague
partes
computadora
mayoría
dispositivos
estén
dispositivo
apagado
utiliza
energía
método
programa
aplicación
utilice
energía
posiblemente
degradaría
calidad
experiencia
usuario
alargar
tiempo
batería
Analizaremos
es-
tos
métodos
turno
hablaremos
acerca
diseño
hardware
respec-
to
energía
www
FreeLibros.me5.8.1
Cuestiones
hardware
baterías
tipos
generales
desechables
recargables
baterías
desechables
comunes
cuentan
AAA
AA
utilizar
operar
dispositivos
bol-
sillo
suficiente
energía
operar
computadoras
notebook
pan-
tallas
brillantes
contrario
batería
recargable
almacenar
suficiente
energía
operar
notebook
horas
baterías
níquel-cadmio
solían
domi-
nar
área
cedieron
paso
baterías
híbridas
níquel-metal
duran
tiempo
contaminan
ambiente
desechan
baterías
ion-litio
mejores
recargar
drenarse
completo
capacidad
limitada
método
general
mayoría
distribuidores
computadoras
utilizan
conser-
var
baterías
diseñar
CPU
memoria
dispositivos
múltiples
encendido
inactivo
hibernando
apagado
utilizar
dispositivo
encen-
dido
dispositivo
utilizar
tiempo
corto
inactivi-
dad
reduce
consumo
energía
utilizar
intervalo
hibernación
reduce
consumo
energía
concesión
sacar
dispositivo
hibernación
requiere
tiempo
energía
sacarlo
inactivo
dispositivo
apaga
con-
sume
energía
dispositivos
responsabi-
lidad
sistema
operativo
administrar
transiciones
momentos
apropiados
computadoras
botones
energía
computadora
inactivo
despertar
rápidamente
teclear
ca-
rácter
mover
ratón
botón
computadora
hibernación
despertarse
requiere
tiempo
casos
botones
general
enviar
señal
sistema
operativo
encarga
resto
software
países
dispositivos
eléctricos
ley
interruptor
energía
mecánico
inte-
rrumpa
circuito
retire
energía
dispositivo
razones
seguridad
cumplir
ley
necesario
interruptor
administración
energía
surjan
preguntas
sistema
opera-
tivo
lidiar
relacionan
hibernación
recursos
apagar
dispo-
sitivos
forma
selectiva
temporal
reducir
consumo
energía
inactivos
preguntas
responder
incluyen
siguientes
dispositivos
pue-
den
controlar
encendidos
apagados
intermedios
energía
aho-
rra
consumo
energía
gasta
energía
reiniciar
dispositivo
guardarse
contexto
pasa
consumo
energía
re-
regresar
energía
máxima
respuestas
pregun-
tas
varían
dispositivo
dispositivo
sistema
operativo
capaz
lidiar
rango
posibilidades
investigadores
examinado
computadoras
notebook
ener-
gía
Li
colaboradores
1994
midieron
cargas
trabajo
llegaron
conclusión
muestra
figura
5-45
Lorch
Smith
1998
mediciones
máquinas
llegaron
conclusiones
muestran
figura
5-45
Weiser
colaboradores
1994
hicie-
418
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.8
ADMINISTRACIÓN
ENERGÍA
419
ron
mediciones
publicaron
valores
numéricos
Simplemente
indicaron
princi-
pales
consumidores
energía
pantalla
disco
duro
CPU
orden
números
cerca
posiblemente
distintas
marcas
computadoras
midieron
duda
distintos
requerimientos
energía
ve
pantalla
disco
duro
CPU
objetivos
obvios
ahorrar
energía
Figura
5-45
Consumo
energía
partes
computadora
notebook
Dispositivo
Li
colaboradores
1994
Lorch
Smith
1998
Pantalla
68%
39%
CPU
12%
18%
Disco
duro
20%
12%
Módem
6%
Sonido
2%
Memoria
0.5%
1%
22%
5.8.2
Cuestiones
sistema
operativo
sistema
operativo
desempeña
papel
clave
administración
energía
Controla
dispositivos
decidir
apagar
apaga
dispositivo
és-
llega
necesitar
rápidamente
molesto
retraso
reinicia
espera
apagar
dispositivo
energía
desperdicia
truco
buscar
algoritmos
heurística
permitan
sistema
operativo
tomar
de-
cisiones
apagar
problema
subjetivo
usuario
encontrar
aceptable
30
segundos
utilizar
compu-
tadora
requieran
segundos
responda
pulsación
teclas
usuario
parecer
molesto
condiciones
ausencia
entrada
audio
computadora
distinguir
usuarios
pantalla
veamos
dispositivos
gastan
energía
ha-
cer
principal
elemento
consumidor
energía
pantalla
obtener
ima-
gen
nítida
brillante
pantalla
luz
posterior
requiere
energía
considerable
sistemas
operativos
tratan
ahorrar
energía
apagar
pantalla
actividad
número
minutos
usuario
decidir
in-
tervalo
desconexión
deja
usuario
elección
pantalla
blanco
frecuentemente
agotar
batería
rápidamente
usuario
desee
www.FreeLibros.meelección
Apagar
pantalla
inactividad
regenerar
RAM
video
forma
instantánea
oprime
tecla
mueve
disposi-
tivo
señalador
Flinn
Satyanarayanan
2004
propusieron
mejora
Sugirieron
panta-
lla
consista
número
zonas
apagar
encender
independiente
figura
5-46
ilustran
16
zonas
utilizando
líneas
punteadas
separarlas
cursor
ventana
muestra
figura
5-46(a
encender
zonas
esquina
inferior
derecha
12pueden
apagadas
aho-
rran
3/4
energía
pantalla
usuario
mueve
cursor
ventana
apagar
zonas
ventana
zonas
ventana
encender
ventana
extien-
zonas
necesita
energía
administrador
ventanas
detectar
ocurriendo
mover
automática
ventana
acomode
zonas
tipo
acción
ajuste
automático
zona
muestra
figura
5-46(b
lograr
reducción
9/16
energía
máxima
4/16
administrador
ventanas
com-
prender
administración
energía
capaz
aceptar
instrucciones
pieza
sistema
haga
sofisticado
habilidad
iluminar
forma
parcial
ven-
tana
esté
completamente
llena
ejemplo
ventana
contenga
líneas
cortas
tex-
to
mantener
apagada
derecha
420
ENTRADA
SALIDA
CAPÍTULO
Ventana
Ventana
Ventana
Ventana
Zona
Figura
5-46
zonas
iluminar
pantalla
posterior
Cuan-
do
selecciona
ventana
mueve
selecciona
ventana
mueve
reducir
número
zonas
iluminadas
disco
duro
principales
villanos
disco
duro
Requiere
energía
considerable
mantener-
girando
alta
velocidad
accesos
computadoras
espe-
cial
notebooks
disco
deje
girar
número
segundos
minutos
inactividad
necesita
vuelve
arrancar
desgracia
disco
detenido
www
FreeLibros.meSECCIÓN
5.8
ADMINISTRACIÓN
ENERGÍA
421
hibernación
inactividad
requieren
segundos
vuelva
girar
produce
retrasos
considerables
usuario
reiniciar
disco
consume
energía
adicional
considerable
consecuen-
cia
disco
tiempo
característico
Td
representa
punto
muerto
ran-
go
15
segundos
Suponga
acceso
disco
espera
tiempo
futuro
Td
requiere
energía
mantener
disco
girando
apagarlo
des-
pués
volver
encenderlo
rápidamente
Td
energía
ahorra
valga
pena
apa-
gar
disco
volver
encenderlo
pudiera
predicción
ejemplo
base
patrones
acceso
anteriores
sistema
operativo
pre-
dicciones
apagar
dispositivos
ahorrar
energía
práctica
mayoría
sistemas
conservadores
detienen
disco
minutos
inactividad
forma
ahorrar
energía
disco
caché
disco
tamaño
considerable
RAM
necesita
bloque
caché
reiniciar
disco
inactivo
satisfacer
lectura
similar
colocar
búfer
caché
escritura
disco
reiniciar
disco
detenido
escritura
dis-
co
permanecer
apagado
llene
caché
ocurra
fallo
lectura
forma
evitar
arranques
innecesarios
disco
sistema
operativo
mantenga
in-
formados
programas
acerca
disco
enviándoles
mensajes
señales
pro-
gramas
escrituras
discrecionales
omitir
retrasar
ejemplo
procesador
palabras
configurar
escriba
archivo
editando
disco
cier-
to
número
minutos
procesador
palabras
disco
apagado
momento
normalmente
escribiría
archivo
retrasar
escritura
disco
vuelva
encender
transcurrido
tiempo
adicional
CPU
CPU
administrar
ahorrar
energía
CPU
notebook
po-
ner
inactivo
software
reduce
energía
cero
único
despertarse
ocurra
interrupción
CPU
inactiva
espera
pasa
inactivo
computadoras
relación
voltaje
CPU
ciclo
reloj
energía
voltaje
CPU
reducir
software
ahorra
energía
reduce
ciclo
reloj
forma
lineal
energía
consumida
proporcional
cuadrado
voltaje
reducir
voltaje
mitad
CPU
vuel-
ve
mitad
rápida
1/4
energía
propiedad
explotar
programas
tiempos
entrega
definidos
visores
multimedia
descomprimir
mostrar
cuadro
40
mseg
vuel-
ven
inactivos
rapidez
Suponga
CPU
utiliza
joules
eje-
cución
velocidad
40
mseg
x/4
joules
opera
mitad
velocidad
visor
multimedia
descomprimir
mostrar
cuadro
20
mseg
sistema
operativo
operar
máxima
energía
20
mseg
apagarse
20
mseg
energía
x/2
joules
alternativa
operar
mitad
energía
www.FreeLibros.meentrega
x/4
joules
figura
5-47
muestra
comparación
operación
máxima
velocidad
máxima
energía
intervalo
tiempo
operación
mitad
velocidad
cuarto
energía
intervalo
doble
tiempo
casos
realiza
trabajo
figura
5-47(b
consume
mitad
energía
realizarlo
422
ENTRADA
SALIDA
CAPÍTULO
1.00
0.75
0.50
0.25
T/2
Tiempo
Energía
1.00
0.75
0.50
0.25
T/2
Tiempo
Energía
Figura
5-47
Operación
máxima
velocidad
Recorte
voltaje
velocidad
consumo
energía
similar
usuario
escribiendo
carácter
trabajo
necesa-
rio
procesar
carácter
requiere
100
mseg
sistema
operativo
detecte
exten-
sos
periodos
inactividad
reduzca
velocidad
CPU
factor
10
resumen
eficiente
operar
menor
velocidad
velocidad
memoria
opciones
posibles
ahorrar
energía
memoria
lugar
caché
vaciar
apagarse
volver
cargar
memoria
principal
pér-
dida
información
recarga
forma
dinámica
rápida
apagar
caché
completo
inactividad
opción
drástica
escribir
contenido
memoria
principal
disco
apagar
memoria
principal
método
hibernación
cortar
energía
memoria
expensas
tiempo
recarga
considerable
especial
disco
tam-
bién
apagado
apaga
memoria
CPU
apagarse
eje-
cutarse
ROM
CPU
apagada
interrupción
despierta
salte
código
ROM
memoria
recargar
utilizarla
to-
sobrecarga
desconectar
memoria
largos
periodos
horas
valer
pena
conveniente
reiniciar
segundos
reiniciar
sistema
operativo
disco
requiere
minuto
Comunicación
inalámbrica
computadoras
portátiles
conexión
inalámbrica
mundo
exterior
ejemplo
Internet
transmisor
receptor
radio
requeridos
consumido-
res
energía
especial
receptor
radio
encendido
escuchar
correo
www
FreeLibros.meSECCIÓN
5.8
ADMINISTRACIÓN
ENERGÍA
423
electrónico
entrante
batería
agotar
rapidez
radio
apa-
ga
ejemplo
minuto
inactivo
perder
mensajes
entrantes
duda
indeseable
Kravets
Krishnan
1998
propuesto
solución
eficiente
problema
núcleo
solución
explota
computadoras
móviles
comunican
estaciones
base
fija
memorias
discos
restricciones
energía
proponen
computadora
móvil
envíe
mensaje
estación
base
esté
punto
desco-
nectar
radio
estación
radio
coloca
búfer
mensajes
entrantes
disco
computadora
móvil
vuelve
encender
radio
estación
base
momento
enviar
mensaje
acumulado
mensajes
salientes
generan
radio
apagado
colocan
búfer
computadora
móvil
búfer
amenaza
llenarse
radio
enciende
cola
transmite
estación
base
apagarse
radio
posibilidad
dejar
usuario
programa
apli-
cación
decidan
apagarlo
segundos
inactividad
vol-
encenderse
usuario
programa
decidir
encender
forma
periódica
comprobar
tráfico
entrante
transmitir
mensajes
cola
tam-
bién
debería
encenderse
búfer
salida
esté
punto
llenarse
posibles
heurísticas
Administración
térmica
cuestión
distinta
relacionada
energía
administración
térmica
CPUs
modernas
calientan
extremo
alta
velocidad
equipos
es-
critorio
general
ventilador
eléctrico
interno
sacar
aire
caliente
chasis
reducción
consumo
energía
comúnmente
cuestión
preponderante
equipos
escritorio
normalmente
ventilador
encendido
tiempo
notebooks
situación
distinta
sistema
operativo
monitorear
tempe-
ratura
forma
continua
acerca
temperatura
máxima
permisible
sistema
opera-
tivo
tomar
decisión
encender
ventilador
ruido
consume
energía
alternativa
reducir
consumo
energía
reducir
luz
posterior
panta-
lla
reducir
velocidad
CPU
agresivo
desconectar
disco
similar
entrada
usuario
valiosa
guía
ejemplo
usuario
po-
dría
especificar
adelantado
ruido
ventilador
objetable
sistema
ope-
rativo
reduciría
consumo
energía
defecto
Administración
baterías
viejos
tiempos
batería
proporcionaba
corriente
agotaba
momento
detenía
actualmente
laptops
utilizan
baterías
inteligentes
pue-
den
comunicar
sistema
operativo
solicita
informar
máximo
voltaje
vol-
taje
actual
máxima
carga
carga
actual
máxima
proporción
agotamiento
proporción
www.FreeLibros.meagotamiento
actual
mayoría
computadoras
notebook
programas
ejecutar
consultar
mostrar
parámetros
baterías
inteligentes
tam-
bién
instruir
cambien
parámetros
operacionales
control
sis-
tema
operativo
notebooks
baterías
sistema
operativo
detecta
batería
punto
agotarse
completo
arreglar
cambio
batería
corte
energía
transición
batería
punto
agotarse
depen-
sistema
operativo
advertir
usuario
apagado
ordenado
ejemplo
asegurándose
sistema
archivos
corrompa
Interfaz
drivers
sistema
Windows
mecanismo
elaborado
administración
energía
co-
nocido
ACPI
Advanced
Configuration
and
Power
Interface
Interfaz
avanzada
configu-
ración
energía
sistema
operativo
enviar
controlador
cumpla
mecanismo
comandos
pedir
reporte
capacidades
dispositivos
actuales
característica
importante
combina
dispositivos
plug
and
play
justo
iniciarse
sistema
operativo
siquiera
dispo-
sitivos
presentes
propiedades
consumo
energía
capacidad
administración
enviar
comandos
controladores
pedirles
reduzcan
niveles
energía
base
capacidades
detectó
tráfico
sentido
contrario
especial
dispositivo
teclado
ratón
detecta
activi-
dad
periodo
inactividad
señal
sistema
regresar
operación
normal
5.8.3
Cuestiones
programas
aplicaciones
analizado
formas
sistema
operativo
reducir
ener-
gía
tipos
dispositivos
método
indicar
programas
utilicen
energía
significa
proporcionar
experiencia
pobre
usuario
experiencia
pobre
experiencia
batería
agota
lu-
ces
apagan
general
información
pasa
carga
batería
de-
valor
umbral
responsabilidad
programas
decidir
degradar
rendimiento
extender
vida
batería
mantener
rendimiento
arriesgarse
que-
darse
energía
preguntas
surge
acerca
programa
degradar
rendi-
miento
ahorrar
energía
pregunta
estudiada
Flinn
Satyanarayanan
2004
proporcionaron
ejemplos
rendimiento
degradado
ahorrar
energía
analizaremos
estudio
información
presenta
usuario
formas
degra-
dación
presenta
información
degradación
fidelidad
precisión
424
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.9
INVESTIGACIÓN
ACERCA
425
información
presenta
usuario
hubiera
podido
vere-
mos
ejemplos
medir
energía
Flinn
Satyanarayanan
idearon
herramienta
soft-
ware
llamada
PowerScope
proporcionar
perfil
energía
programa
usarlo
computadora
conectada
fuente
energía
externa
mul-
tímetro
digital
controlado
software
multímetro
software
leer
número
miliamperes
provienen
fuente
energía
determinar
energía
instantánea
consumiendo
computadora
PowerScope
muestrear
forma
periódica
contador
programa
energía
escribir
datos
archivo
ter-
minado
programa
analiza
archivo
obtener
energía
procedimiento
Es-
tas
mediciones
formaron
base
observaciones
utilizaron
mediciones
ahorro
energía
hardware
formaron
línea
base
midió
rendimiento
degradado
programa
midió
reproductor
video
degradado
repro-
duce
30
cuadros
resolución
completa
colores
forma
degradación
aban-
donar
información
color
mostrar
video
blanco
negro
forma
degradación
reducir
velocidad
cuadros
produce
parpadeos
proporciona
película
calidad
inferior
forma
degradación
reducir
número
pixeles
ambas
direcciones
reduciendo
resolución
espacial
imagen
mostrar
mediciones
tipo
ahorraron
30%
energía
programa
reconocedor
voz
Realizaba
muestreo
micrófono
construir
forma
onda
podía
analizarse
computadora
notebook
enviarse
tra-
vés
enlace
radio
analizarla
computadora
fija
ahorra
ener-
gía
CPU
utiliza
energía
radio
degradación
logró
utilizar
vocabulario
pequeño
modelo
acústico
simple
ganancia
aproxima-
damente
35%
ejemplo
visor
mapas
obtenía
mapa
enlace
radio
degradación
consistía
recortar
mapa
medidas
pequeñas
indicar
servidor
remo-
to
omitiera
caminos
pequeños
requiriendo
bits
transmitir
obtuvo
ganancia
35%
cuarto
experimento
transmisión
imágenes
JPEG
navegador
Web
es-
tándar
JPEG
permite
algoritmos
intercambiar
calidad
imagen
tamaño
archivo
ganancia
promedio
9%
Inlcuso
general
experimentos
mos-
traron
aceptar
degradación
calidad
usuario
trabajar
tiempo
batería
dada
5.9
INVESTIGACIÓN
ACERCA
cantidad
considerable
investigación
acerca
entrada
salida
mayoría
en-
focada
dispositivos
específicos
general
objetivo
mejorar
rendimiento
sistemas
disco
casos
cuestión
algoritmos
programación
brazo
disco
área
investigación
popular
Bachmat
Braverman
2006
Za-
randioon
Thomasian
2006
arreglos
discos
Arnan
colaboradores
2007
www.FreeLibros.meoptimización
ruta
completa
interés
Riska
colaboradores
2007
Tam-
bién
investigación
caracterización
carga
trabajo
disco
Riska
Riedel
2006
área
investigación
relacionada
discos
discos
flash
alto
ren-
dimiento
Birrell
colaboradores
2007
Chang
2007
controladores
dispositivos
obteniendo
atención
necesaria
Ball
colaboradores
2006
Ganapathy
colaboradores
2007
Padioleau
colaboradores
2006
tecnología
almacenamiento
MEMS
Micro-Electrical-Mechanical
Systems
Sistemas
micro
electromecánicos
reemplazar
complementar
discos
Rangaswami
colaboradores
2007
Yu
colaboradores
2007
área
investigación
pro-
metedora
CPU
controlador
disco
ejemplo
pa-
ra
mejorar
rendimiento
Gurumurthi
2007
detectar
virus
Paul
colaboradores
2005
sorprendente
modesto
reloj
tema
investigación
proveer
resolución
sistemas
operativos
operan
reloj
1000
Hz
produce
sobrecarga
considerable
investigación
enfoca
deshacerse
sobrecarga
Etsion
colaboradores
2003
Tsafir
colaboradores
2005
clientes
delgados
tema
considerable
interés
Kissler
Hoyt
2005
Rits-
chard
2006
Schwartz
Gerrazzi
2005
número
científicos
computacionales
computadoras
notebooks
micros-
cópico
tiempo
batería
mayoría
sorprender
enorme
interés
técnicas
software
reducir
consumo
energía
temas
especiali-
zados
analizando
encuentran
escribir
código
aplicaciones
maximizar
tiem-
pos
inactividad
disco
colaboradores
2006
discos
giren
menor
velocidad
utilicen
Gurumurthi
colaboradores
2003
utilizar
modelos
programa
pre-
desconectar
tarjetas
inalámbricas
Hom
Kremer
2003
ahorro
ener-
gía
oIP
Gleeson
colaboradores
2006
examinar
costo
energía
seguridad
Aaraj
colaboradores
2007
programación
multimedia
eficiente
energía
Yuan
Nahrstedt
2006
cámara
integrada
detecte
alguien
viendo
pantalla
desconectarla
esté
viendo
Dalton
Ellis
2003
extremo
rendimiento
tema
popular
energía
redes
monitoreo
Min
colaboradores
2007
Wang
Xiao
2006
extremo
espectro
guardar
energía
granjas
servidores
interés
Fan
colaboradores
2007
Tolentino
colaboradores
2007
5.10
RESUMEN
operaciones
entrada
salida
tema
ignorado
importante
fracción
considerable
sistema
operativo
relacionada
operaciones
S.
ope-
raciones
cabo
formas
lugar
programada
CPU
principal
recibe
envía
byte
palabra
entra
ciclo
estrecho
esperar
obtener
enviar
byte
lugar
controlada
in-
terrupciones
CPU
inicia
transferencia
carácter
palabra
pone
llega
interrupción
indicando
completó
operación
S.
tercer
lugar
DMA
chip
separado
administra
transferencia
completa
bloque
datos
recibe
interrupción
transferido
bloque
completo
426
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meSECCIÓN
5.10
RESUMEN
427
estructurar
niveles
procedimientos
servicio
interrupcio-
nes
controladores
dispositivos
software
independiente
dispositivo
biblio-
tecas
colas
ejecutan
espacio
usuario
controladores
dispositivos
encargan
detalles
operación
dispositivos
proporcionan
interfaces
uniformes
resto
sistema
operativo
software
independiente
dispositivo
rea-
liza
cosas
búfer
reporte
errores
discos
vienen
variedad
tipos
incluyendo
discos
magnéticos
RAIDs
tipos
discos
ópticos
utilizar
algoritmos
planificación
brazo
dis-
co
mejorar
rendimiento
presencia
geometría
virtual
complica
cosas
co-
locar
discos
formar
par
construir
almacenamiento
estable
propiedades
útiles
relojes
utilizan
hora
real
limitan
tiempo
ejecutar
procesos
manejan
temporizadores
guardianes
realizan
contabilidad
terminales
orientadas
caracteres
variedad
cuestiones
relacionadas
caracteres
especiales
introducir
secuencias
escape
especiales
imprimir
entrada
crudo
cocido
dependiendo
control
desee
programa
entrada
secuencias
escape
salida
controlan
movimiento
cur-
sor
permiten
insertar
eliminar
texto
pantalla
mayoría
sistemas
UNIX
utilizan
Sistema
Window
base
interfaz
usuario
Consiste
programas
enlazados
bibliotecas
especiales
emiten
comandos
di-
bujo
servidor
escribe
pantalla
computadoras
personales
utilizan
GUIs
mostrar
información
usuario
basan
paradigma
WIMP
ventanas
iconos
menús
dispositivo
señalador
progra-
basados
GUI
general
controlados
eventos
eventos
teclado
ratón
dispositivos
envían
programa
procesarlos
ocurren
sistemas
UNIX
GUIs
ejecutan
X.
clientes
delgados
ventajas
comparación
PCs
estándar
notables
simplicidad
menor
necesidad
mantenimiento
usuarios
ex-
perimentos
cliente
delgado
THINC
demostrado
primitivas
simples
po-
sible
construir
cliente
rendimiento
video
administración
energía
cuestión
importante
computadoras
notebook
tiempos
vida
baterías
limitados
sistema
operativo
em-
plear
técnicas
reducir
consumo
energía
programas
ayudar
sacrificar
calidad
tiempos
vida
largos
baterías
PROBLEMAS
avances
tecnología
chips
colocar
controlador
in-
cluyendo
lógica
acceso
bus
chip
económico
afecta
modelo
fi-
gura
1-5
Dadas
velocidades
listadas
figura
5-1
explorar
documentos
escáner
transmitirlos
red
802.11
máxima
velocidad
Defienda
respuesta
www
FreeLibros.me3
figura
5-3(b
muestra
forma
asignación
memoria
presencia
buses
separados
memoria
dispositivos
prueba
bus
memoria
falla
prueba
bus
S.
astuto
estudiante
ciencias
computacionales
ideado
mejora
idea
probar
paralelo
agilizar
proceso
acceder
dispositivos
S.
piensa
idea
Suponga
sistema
utiliza
DMA
transferencia
datos
controlador
disco
me-
moria
principal
Suponga
requieren
nseg
promedio
adquirir
bus
t2
nseg
par
transferir
palabra
bus
t2
CPU
programado
controla-
dor
DMA
tiempo
requiere
transferir
1000
palabras
controlador
disco
memoria
principal
utiliza
palabra
utiliza
ráfaga
Su-
ponga
comandar
controlador
disco
requiere
adquirir
bus
enviar
palabra
reconocer
transferencia
adquirir
bus
enviar
palabra
Suponga
computadora
leer
escribir
palabra
memoria
10
nseg
Suponga
ocurre
interrupción
meten
pila
32
registros
contador
programa
PSW
número
máximo
interrupciones
procesar
máquina
arquitectos
CPUs
escritores
sistemas
operativos
odian
interrupciones
im-
precisas
complacer
escritores
SO
CPU
deje
emitir
ins-
trucciones
señale
interrupción
permita
instrucciones
ejecutando
terminen
obligue
produzca
interrupción
méto-
do
desventaja
Explique
respuesta
figura
5-9(b
interrupción
reconoce
enviado
si-
guiente
carácter
impresora
haberse
reconocido
forma
justo
inicio
proce-
dimiento
servicio
interrupciones
mencione
razón
texto
computadora
línea
tubería
etapas
muestra
figura
1-6(a
ciclo
reloj
obtiene
instrucción
memoria
dirección
apunta
PC
coloca
instrucción
tubería
avanza
PC
instrucción
ocupa
exac-
tamente
palabra
memoria
instrucciones
tubería
avanzan
etapa
ocurre
interrupción
PC
actual
mete
pila
PC
asigna
dirección
manejador
interrupciones
tubería
desplaza
etapa
derecha
obtiene
pri-
mera
instrucción
manejador
interrupciones
coloca
tubería
máquina
in-
terrupciones
precisas
Defienda
respuesta
página
ordinaria
texto
contiene
50
líneas
80
caracteres
Imagine
im-
presora
imprimir
páginas
minuto
tiempo
escribir
carácter
regis-
tro
salida
impresora
corto
ignorarse
sentido
operar
impresora
controlada
eventos
carácter
impreso
requiere
interrupción
tar-
50
µseg
atendida
10
Explique
SO
facilitar
instalación
dispositivo
necesidad
volver
compilar
SO
11
niveles
software
realiza
siguientes
acciones
Calcular
pista
sector
cabeza
lectura
disco
428
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
429
Escribir
comandos
registros
dispositivo
Comprobar
usuario
permiso
utilizar
dispositivo
Convertir
enteros
binarios
ASCII
imprimirlos
12
red
área
local
utiliza
usuario
emite
llamada
sistema
pa-
ra
escribir
paquetes
datos
red
sistema
operativo
copia
datos
búfer
kernel
copia
datos
tarjeta
controladora
red
bytes
seguros
controlador
envían
red
velocidad
10
megabits
seg
contro-
lador
red
receptor
almacena
bit
microsegundo
enviarlo
llega
últi-
mo
bit
interrumpe
CPU
destino
kernel
copia
paquete
recién
llegado
búfer
kernel
inspeccionarlo
averigua
usuario
paquete
kernel
copia
datos
espacio
usuario
suponemos
interrupción
procesamiento
asociado
re-
mseg
paquetes
1024
bytes
ignore
encabezados
copiar
byte
requiere
µseg
velocidad
máxima
proceso
enviar
datos
Suponga
emisor
bloquea
termine
trabajo
receptor
devuelve
señal
reconocimiento
simplificar
suponga
tiempo
obtener
vuel-
ta
reconocimiento
pequeño
ignorar
13
archivos
salida
impresora
normalmente
ponen
cola
disco
imprimirlos
14
nivel
RAID
corregir
errores
bit
utilizando
unidad
paridad
objetivo
nivel
RAID
corregir
error
requiere
unidades
15
RAID
fallar
unidades
fallan
intervalo
tiempo
corto
Supon-
ga
probabilidad
unidad
falle
hora
específica
p.
probabilidad
falle
RAID
unidades
hora
específica
16
Compare
niveles
RAID
rendimiento
lectura
escritura
sobrecarga
espacio
confiabilidad
17
dispositivos
almacenamiento
ópticos
intrínsecamente
capaces
obtener
densidad
datos
dispositivos
almacenamiento
magnéticos
Nota
problema
requiere
conocimiento
física
secundaria
acerca
generan
campos
mag-
néticos
18
ventajas
desventajas
discos
ópticos
comparación
discos
magné-
ticos
19
controlador
disco
escribe
bytes
recibe
disco
memoria
recibe
interno
búfer
entrelazado
útil
Explique
20
disco
doble
entrelazado
necesita
desajuste
cilindros
evitar
pasar
al-
to
información
búsqueda
pista
pista
Explique
respuesta
21
Considere
disco
magnético
consiste
16
cabezas
400
cilindros
disco
dividido
zonas
100
cilindros
cilindros
distintas
zonas
contienen
160
200
240
280
sectores
respectivamente
Suponga
sector
contiene
512
bytes
tiempo
búsque-
promedio
cilindros
adyacentes
mseg
disco
gira
7200
RPM
Calcule
capacidad
disco
desajuste
óptimo
pistas
velocidad
máxima
transfe-
rencia
datos
www
FreeLibros.me22
fabricante
discos
discos
5.25
pulgadas
10,000
cilindros
doble
densidad
grabación
lineal
antiguo
propiedades
disco
mejores
unidad
reciente
iguales
23
fabricante
computadoras
decide
rediseñar
tabla
particiones
disco
duro
Pentium
proporcionar
particiones
consecuencias
cambio
24
peticiones
disco
llegan
controlador
disco
cilindros
10
22
20
40
38
orden
búsqueda
requiere
mseg
cilindro
desplazado
Determine
tiempo
búsqueda
requiere
llegar
atendido
cilindro
cercano
continuación
Algoritmo
elevador
principio
mueve
casos
brazo
principio
cilindro
20
25
ligera
modificación
algoritmo
elevador
planificar
peticiones
disco
explorar
dirección
aspecto
algoritmo
modificado
algorit-
mo
elevador
26
análisis
almacenamiento
estable
RAM
volátil
pasó
alto
punto
ocurre
completa
escritura
estable
ocurre
falla
sistema
operativo
escribir
número
bloque
inválido
RAM
volátil
Arruina
condición
competencia
abstracción
almacenamiento
estable
Explique
respuesta
27
análisis
almacenamiento
estable
demostró
disco
recuperar
es-
tado
consistente
escritura
completa
cabo
ocurre
falla
CPU
du-
rante
escritura
mantiene
propiedad
CPU
falla
procedimiento
recuperación
Explique
respuesta
28
manejador
interrupciones
reloj
computadora
requiere
mseg
incluyendo
so-
brecarga
conmutación
procesos
pulso
reloj
reloj
opera
60
Hz
frac-
ción
CPU
dedicada
reloj
29
computadora
utiliza
reloj
programable
onda
cuadrada
utiliza
reloj
500
MHz
valor
registro
contenedor
lograr
resolución
reloj
milisegundo
pulso
reloj
milisegundo
100
microsegundos
30
sistema
simula
relojes
encadenar
peticiones
reloj
conjunto
muestra
figura
5-34
Suponga
tiempo
actual
5000
peticiones
reloj
pen-
dientes
tiempos
5008
5012
5015
5029
5037
Muestre
valores
Encabezado
re-
loj
Hora
actual
señal
tiempos
5000
5005
5013
Suponga
llega
señal
pendiente
tiempo
5017
5033
Muestre
valores
Encabezado
reloj
Hora
actual
señal
tiempo
5023
31
versiones
LINUX
utilizan
entero
32
bits
signo
tiempo
número
segundos
transcurridos
origen
tiempo
terminarán
sistemas
año
mes
Espera
realmente
ocurra
430
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
431
32
terminal
mapa
bits
contiene
1280
960
pixeles
desplazarse
ventana
CPU
controlador
desplazar
líneas
texto
copiar
bits
RAM
video
ventana
específica
60
líneas
altura
80
caracte-
res
anchura
5280
caracteres
cuadro
carácter
pixeles
anchura
16
pixeles
altura
tiempo
requiere
desplazar
ventana
velocidad
copia
50
nseg
byte
líneas
80
caracteres
tasa
trans-
ferencia
baudios
equivalente
terminal
colocar
carácter
pantalla
requieren
µseg
líneas
mostrar
33
recibir
carácter
SUPR
SIGINT
controlador
pantalla
descarta
salida
cola
pantalla
34
pantalla
color
IBM
PC
original
escribir
RAM
video
momento
retrazado
vertical
haz
CRT
aparecían
puntos
desagradables
pantalla
imagen
pantalla
25
80
caracteres
ajusta
cuadro
pixeles
pixeles
fila
640
pixeles
dibuja
exploración
hori-
zontal
haz
requiere
63.6
µseg
incluyendo
retrazado
horizontal
pantalla
vuelve
dibujar
60
requiere
periodo
retrazado
ver-
tical
regresar
haz
superior
fracción
tiempo
disponible
RAM
video
escribir
35
diseñadores
sistema
computadora
esperaban
ratón
pudiera
mover
velo-
cidad
máxima
20
cm
seg
mickey
0.1
mm
mensaje
ratón
bytes
máxima
velocidad
transferencia
datos
ratón
suponiendo
mickey
reporte
separado
36
colores
aditivos
primarios
rojo
verde
azul
significa
fomar
cual-
quier
color
superposición
lineal
colores
alguien
pudiera
fotografía
color
pudiera
representar
color
completo
24
bits
37
forma
colocar
carácter
pantalla
mapa
bits
utilizar
bitblt
tabla
tipos
letras
Suponga
tipo
letra
específico
utiliza
caracteres
16
24
pixeles
color
RGB
espacio
tabla
tipos
letras
ocupa
carácter
copiar
byte
requieren
100
nseg
incluyendo
sobrecarga
velocidad
transferencia
salida
pantalla
caracteres
seg
38
Suponiendo
requieren
10
nseg
copiar
byte
tiempo
requiere
retrazar
completo
pantalla
asignación
memoria
texto
80
caracteres
/H1100325
lí-
neas
pantalla
gráfica
1024
/H11003768
pixeles
colores
24
bits
39
figura
5-40
clase
RegisterClass
código
Window
correspondiente
figura
5-38
dicha
llamada
parecido
40
texto
vimos
ejemplo
dibujar
rectángulo
pantalla
GDI
Windows
Rectangle(hdc
xizq
ysup
xder
yinf
www
FreeLibros.me¿Hay
necesidad
parámetro
hdc
to-
do
coordenadas
rectángulo
especifican
explícita
parámetros
41
terminal
THINC
utiliza
mostrar
página
Web
contenga
caricatura
animada
400
pixeles
160
pixeles
velocidad
10
cuadros
seg
fracción
conexión
Fast
Ethernet
100
Mbps
consume
mostrar
caricatura
42
observado
sistema
THINC
funciona
red
Mbps
prueba
Pue-
problemas
situación
multiusuario
Sugerencia
Considere
número
usuarios
ven
programa
TV
número
usuarios
navegan
World
Wide
Web
43
máximo
voltaje
CPU
recorta
consumo
energía
disminuye
n2
valor
original
velocidad
reloj
disminuye
valor
original
Suponga
usua-
rio
escribiendo
carácter
seg
tiempo
CPU
requerido
procesar
ca-
rácter
100
mseg
valor
óptimo
correspondiente
ahorro
energía
porcentaje
comparado
opción
cortar
voltaje
Suponga
CPU
inactiva
consume
energía
44
computadora
notebook
configura
sacar
máximo
provecho
características
ahorro
energía
incluyendo
apagar
pantalla
disco
duro
periodos
inactividad
usuario
ejecuta
programas
UNIX
texto
utiliza
Siste-
ma
Window
sorprende
descubrir
vida
batería
utiliza
pro-
gramas
texto
45
Escriba
programa
simule
almacenamiento
estable
Utilice
archivos
extensos
lon-
gitud
fija
disco
simular
discos
46
Escriba
programa
implementar
algoritmos
planificación
brazo
disco
Es-
criba
programa
controlador
genere
secuencia
números
cilindro
999
azar
ejecute
algoritmos
secuencia
imprima
distancia
número
cilin-
dros
necesita
brazo
desplazarse
algoritmos
47
Escriba
programa
implementar
temporizadores
usando
reloj
entrada
programa
consiste
secuencia
tipos
comandos
int
int
int
establece
tiempo
actual
int
pulso
reloj
int
programa
señal
ocurra
tiempo
int
imprime
valores
Tiempo
actual
señal
Encabe-
zado
reloj
programa
imprimir
instrucción
tiempo
ge-
nerar
señal
432
ENTRADA
SALIDA
CAPÍTULO
www
FreeLibros.me6
INTERBLOQUEOS
433
sistemas
computacionales
llenos
recursos
utilizados
pro-
ceso
ejemplos
comunes
impresoras
unidades
cinta
ranuras
tableros
internos
sistema
procesos
escriben
simultánea
impre-
sora
producen
incoherencias
procesos
utilizan
entrada
tabla
sistema
archivos
invariablemente
corrompe
sistema
archivos
consecuencia
sistemas
operativos
habilidad
otorgar
forma
temporal
proceso
acceso
exclusivo
recursos
aplicaciones
proceso
necesita
acceso
exclusivo
recurso
ejemplo
suponga
procesos
grabar
documento
digitaliza-
do
CD
proceso
pide
permiso
utilizar
escáner
otorga
proceso
pro-
grama
distinta
solicita
grabador
CDs
otorga
pide
grabador
CDs
petición
rechaza
libere
desgracia
liberar
grabador
CD
pide
escáner
punto
procesos
bloqueados
per-
manecerán
situación
conoce
interbloqueo
interbloqueos
ocurrir
máquinas
ejemplo
oficinas
tie-
nen
red
área
local
computadoras
conectadas
dispositivos
escáneres
grabadores
CD
impresoras
unidades
cinta
conectan
red
recursos
compartidos
disponibles
usuario
equipo
dispositivos
pue-
den
reservar
remota
equipo
doméstico
usuario
ocurrir
tipos
interbloqueos
descritos
situaciones
complicadas
ocasionar
interbloqueos
involucren
dispositivos
usuarios
www
FreeLibros.meLos
interbloqueos
ocurrir
variedad
situaciones
solicitar
disposi-
tivos
dedicados
ejemplo
sistema
bases
datos
programa
bloquear
registros
esté
utilizando
evitar
condiciones
competencia
proceso
bloquea
registro
R1
proceso
bloquea
registro
R2
proceso
blo-
quear
registro
interbloqueo
ende
interbloqueos
ocurrir
recursos
hardware
software
capítulo
analizaremos
tipos
interbloqueos
veremos
surgen
estudiare-
mos
formas
prevenirlos
evitarlos
libro
interbloqueos
contexto
sistemas
operativos
ocurren
sistemas
bases
datos
contextos
ciencias
computacionales
realidad
material
apli-
car
amplia
variedad
sistemas
multiproceso
escrito
interbloqueos
bibliografías
tema
aparecido
Operating
Systems
Review
consultarse
busca
referencias
Newton
1979
Zobel
1983
bibliografías
antiguas
ma-
yor
trabajo
interbloqueos
1980
utilidad
6.1
RECURSOS
clase
principal
interbloqueos
involucra
recursos
empezar
es-
tudio
veremos
interbloqueos
ocurrir
procesos
otorga
ac-
ceso
exclusivo
dispositivos
registros
datos
archivos
etcétera
análisis
interbloqueos
general
referiremos
objetos
otorgados
recur-
sos
recurso
dispositivo
hardware
ejemplo
unidad
cinta
pie-
za
información
registro
bloqueado
base
datos
general
computadora
recursos
adquirir
recursos
disponibles
instancias
idénticas
unidades
cinta
disponibles
copias
recurso
utilizar
satisfacer
petición
recurso
resumen
recurso
cosa
adquirir
utilizar
liberar
transcurso
tiempo
6.1.1
Recursos
apropiativos
apropiativos
recursos
tipos
apropiativos
apropiativos
recurso
apropiativo
quitar
proceso
posee
efectos
dañinos
memoria
ejemplo
re-
curso
apropiativo
ejemplo
considere
sistema
256
MB
memoria
usuario
im-
presora
procesos
256
MB
imprimir
proceso
solicita
obtiene
impresora
empieza
calcular
valores
imprimir
ter-
minar
cálculo
excede
quantum
tiempo
intercambia
proceso
proceso
ejecuta
éxito
adquirir
impresora
crea
situación
potencial
interbloqueo
impresora
memoria
pro-
ceder
recurso
posee
fortuna
apropiarse
quitar
memoria
434
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.1
RECURSOS
435
intercambiarlo
colocar
proceso
vuelta
ejecutar
impre-
sión
liberar
impresora
ocurre
interbloqueo
contrario
recurso
apropiativo
quitar
propietario
ac-
tual
cómputo
falle
proceso
empezado
quemar
CD-ROM
tratamos
quitarle
repentina
grabador
CD
otorgarlo
proceso
obtendrá
CD
basura
grabadores
CD
apropiativos
momento
arbitrario
general
interbloqueos
involucran
recursos
apropiativos
interbloqueos
po-
tenciales
involucrar
recursos
apropiativos
general
resolver
me-
diante
reasignación
recursos
proceso
ende
análisis
enfocará
recursos
apropiativos
secuencia
eventos
requerida
utilizar
recurso
proporciona
continuación
formato
abstracto
Solicitar
recurso
Utilizar
recurso
Liberar
recurso
recurso
disponible
solicita
proceso
solicitante
ve
obligado
espe-
rar
sistemas
operativos
proceso
bloquea
automática
falla
so-
licitud
recurso
despierta
recurso
disponible
sistemas
solicitud
falla
código
error
depende
proceso
llamada
decidir
esperar
intentar
proceso
negado
petición
recurso
general
permanece
ciclo
estrecho
solicitando
recurso
pasa
inactivo
intenta
proceso
bloqueado
intención
propósito
estuviera
de-
bido
trabajo
útil
análisis
suponer
proceso
niega
recurso
solicitado
pasa
inactivo
naturaleza
exacta
solicitar
recurso
medida
dependiente
sistema
al-
gunos
sistemas
proporciona
llamada
sistema
requestpara
permitir
procesos
pidan
recursos
forma
explícita
únicos
recursos
conoce
sistema
operativo
archivos
especiales
proceso
abiertos
momento
abren
llamada
sistema
openordinaria
archivo
proceso
llama
bloqueado
propietario
actual
cierra
6.1.2
Adquisición
recursos
tipos
recursos
registros
base
datos
responsabilidad
procesos
usuario
administrar
permitir
usuarios
administren
re-
cursos
asociar
semáforo
recurso
semáforos
inicializan
utilizar
mutexes
forma
pasos
listados
implementan
operación
www.FreeLibros.medown
semáforo
adquirir
recurso
usarlo
finalmente
operación
up
recurso
liberarlo
pasos
muestran
figura
6-1(a
typedef
int
semaforo
typedef
int
semaforo
semaforo
recurso_1
semaforo
recurso_1
semaforo
recurso_2
void
proceso_A(void
void
proceso_A(void
down(&recurso_1
down(&recurso_1
usar_recurso_1
down(&recurso_2
up(&recurso_1
usar_ambos_recursos
up(&recurso_2
up(&recurso_1
Figura
6-1
semáforo
proteger
recursos
recurso
re-
cursos
procesos
necesitan
recursos
adquirir
se-
cuencial
muestra
figura
6-1(b
necesitan
recursos
adquie-
ren
proceso
involucrado
funciona
pro-
blemas
proceso
necesidad
adquirir
formalmente
recur-
sos
competencia
consideremos
situación
procesos
recursos
figura
6-2
ilustran
escenarios
figura
6-2(a
procesos
piden
recursos
orden
figura
6-2(b
piden
orden
distinto
diferencia
parecer
insignificante
pe-
ro
figura
6-2(a
procesos
adquirirá
recurso
proceso
adquirirá
éxito
recurso
realizará
trabajo
proceso
intenta
ad-
quirir
recurso
liberado
proceso
simplemente
bloqueará
es-
té
disponible
figura
6-2(b
situación
distinta
ocurrir
procesos
adquiera
am-
bos
recursos
efecto
bloquee
proceso
termine
ocurrir
proceso
adquiera
recurso
proceso
adquiera
recurso
bloqueará
tratar
adquirir
procesos
volverá
ejecutar
situa-
ción
interbloqueo
diferencia
insignificante
estilo
codifi-
cación
recurso
adquirir
constituye
diferencia
programa
funcional
falle
difícil
detectar
interbloqueos
ocurrir
tanta
facili-
dad
investigación
enfocado
formas
lidiar
capítu-
analizaremos
interbloqueos
detalle
436
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.2
INTRODUCCIÓN
INTERBLOQUEOS
437
typedef
int
semaforo
semaforo
recurso_1
semaforo
recurso_1
semaforo
recurso_2
semaforo
recurso_2
void
proceso_A(void
void
proceso_A(void
down(&recurso_1
down(&recurso_1
down(&recurso_2
down(&recurso_2
usar_ambos_recursos
usar_ambos_recursos
up(&recurso_2
up(&recurso_2
up(&recurso_1
up(&recurso_1
void
proceso_B(void
void
proceso_B(void
down(&recurso_1
down(&recurso_2
down(&recurso_2
down(&recurso_1
usar_ambos_recursos
usar_ambos_recursos
up(&recurso_2
up(&recurso_1
up(&recurso_1
up(&recurso_2
Figura
6-2
Código
libre
interbloqueos
Código
potencial
interblo-
queo
6.2
INTRODUCCIÓN
INTERBLOQUEOS
interbloqueo
definir
formalmente
conjunto
procesos
interbloqueo
proceso
conjunto
esperando
evento
ocasionado
proceso
conjunto
procesos
espera
producirá
eventos
despertar
cualquiera
miembros
conjunto
procesos
segui-
rán
esperando
modelo
suponemos
procesos
hilo
interrupciones
posibles
despertar
proceso
bloqueado
condición
interrup-
ciones
necesaria
evitar
proceso
forma
estaría
interbloqueo
despertado
alarma
ejemplo
ocasione
eventos
liberen
proce-
sos
conjunto
mayoría
casos
evento
proceso
espera
liberación
re-
curso
actualmente
poseído
miembro
conjunto
palabras
miembro
conjunto
procesos
interbloqueo
esperando
recurso
posee
proceso
interbloqueo
procesos
ejecutar
liberar
recursos
despertado
número
procesos
número
tipo
recursos
poseídos
solicitados
irrelevante
resultado
aplica
tipo
recurso
hardware
softwa-
re
tipo
interbloqueo
conoce
interbloqueo
recursos
probablemente
tipo
www.FreeLibros.memás
común
único
estudiaremos
interbloqueos
recursos
detalle
des-
pués
regresaremos
brevemente
tipos
interbloqueos
capítulo
6.2.1
Condiciones
interbloqueos
recursos
Coffman
colaboradores
1971
mostraron
aplicarse
condiciones
inter-
bloqueo
recursos
Condición
exclusión
mutua
recurso
asigna
momento
pro-
ceso
disponible
Condición
contención
espera
procesos
actualmente
contienen
recursos
otorgaron
solicitar
recursos
Condición
apropiativa
recursos
otorgados
previamente
quitar
pro-
ceso
fuerza
liberados
explícita
proceso
contiene
Condición
espera
circular
cadena
circular
procesos
espera
recurso
contenido
miembro
cadena
condiciones
presentes
ocurra
interbloqueo
ausente
interbloqueo
recursos
Vale
pena
observar
condición
relaciona
política
sis-
tema
asignarse
recurso
proceso
proceso
contener
recurso
pedir
reemplazarse
procesos
existir
esperas
circulares
ade-
lante
veremos
atacar
interbloqueos
tratar
negar
condiciones
6.2.2
Modelado
interbloqueos
Holt
1972
mostró
modelar
condiciones
gráficos
di-
rigidos
gráficos
tipos
nodos
procesos
muestran
círculos
recursos
muestran
cuadros
arco
dirigido
nodo
recurso
cuadro
nodo
proceso
círculo
significa
recurso
solicitado
previamente
asignado
actualmente
conte-
nido
proceso
figura
6-3(a
recurso
asignado
actualmente
proceso
A.
arco
dirigido
proceso
recurso
significa
proceso
actualmente
bloquea-
do
espera
recurso
figura
6-3(b
proceso
espera
recurso
S.
figura
6-3(c
interbloqueo
proceso
esperando
recurso
actualmente
contenido
proceso
D.
proceso
liberar
recurso
esperando
recurso
contenido
C.
procesos
esperarán
ciclo
gráfico
in-
dica
interbloqueo
involucra
procesos
recursos
ciclo
suponiendo
recurso
tipo
ejemplo
ciclo
C-T-D-U-C.
veamos
ejemplo
utilizar
gráficos
recursos
Imagine
te-
nemos
procesos
recursos
T.
peticiones
liberaciones
pro-
438
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.2
INTRODUCCIÓN
INTERBLOQUEOS
439
cesos
proporcionan
figuras
6-4(a
sistema
operativo
libre
ejecutar
proceso
desbloqueado
momento
optar
ejecutar
ter-
minara
trabajo
completara
C.
orden
produce
interbloqueos
competencia
recursos
pe-
ro
paralelismo
solicitar
liberar
recursos
procesos
realizan
cálcu-
operaciones
S.
procesos
ejecutan
forma
secuencial
posibilidad
proceso
espera
utilizar
CPU
ende
ejecutar
pro-
cesos
estrictamente
forma
secuencial
óptimo
procesos
realiza
operaciones
algoritmo
trabajo
corto
al-
goritmo
turno
rotatorio
round-robin
circunstancias
ejecutar
procesos
forma
secuencial
suponer
procesos
realizan
operaciones
cálculos
algoritmo
turno
rotatorio
algoritmo
programación
razonable
peticiones
recursos
ocurrir
orden
figura
6-4(d
solicitudes
llevan
cabo
orden
gráficos
recursos
resultantes
muestran
figuras
6-4(e
Des-
pués
petición
bloquea
espera
muestra
figura
6-4(h
siguientes
pasos
bloquean
instancia
conduce
ciclo
interbloqueo
figura
6-4(j
mencionado
sistema
operativo
ejecutar
pro-
cesos
orden
especial
particular
otorgar
petición
específica
producir
interbloqueo
sistema
operativo
simplemente
suspender
proceso
otorgar
solicitud
programar
proceso
seguro
figura
6-4
sistema
opera-
tivo
supiera
acerca
interbloqueo
inminente
suspender
otorgarle
recurso
S.
ejecutar
obtendríamos
peticiones
liberaciones
figura
6-4(k
figura
6.4(d
secuencia
produce
gráficos
recursos
figuras
6-4(l
producen
interbloqueo
paso
otorgar
recurso
proceso
terminado
necesita
hubiera
bloqueado
solicitar
ocurrir
interbloqueo
esperará
termine
Figura
6-3
Gráficos
asignación
recursos
Contención
recurso
Pe-
tición
recurso
Interbloqueo
www
FreeLibros.me440
INTERBLOQUEOS
CAPÍTULO
Solicitud
Solicitud
Liberación
Liberación
Solicitud
Solicitud
Liberación
Liberación
Solicitud
Solicitud
Liberación
Liberación
solicita
solicita
solicita
solicita
solicita
solicita
interbloqueo
solicita
solicita
solicita
solicita
libera
libera
interbloqueo
e)(d
c)(b)(a
l)(k
Figura
6-4
ejemplo
ocurrir
interbloqueo
evitar
www
FreeLibros.meSECCIÓN
6.3
ALGORITMO
VESTRUZ
441
capítulo
estudiaremos
algoritmo
detallado
decisiones
asignación
produzcan
interbloqueos
punto
comprender
gráficos
recursos
herramienta
permite
secuencia
petición
liberación
dada
conduce
interbloqueo
llevamos
cabo
peticiones
liberaciones
paso
paso
paso
comprobamos
gráfico
contiene
ciclos
interblo-
queo
caso
contrario
análisis
gráficos
recursos
pa-
ra
caso
recurso
tipo
gráficos
recursos
generalizar
manejar
recursos
tipo
Holt
1972
general
utilizan
estrategias
lidiar
interbloqueos
ignorar
problema
ignora
ignorará
Detección
recuperación
Dejar
ocurran
interbloqueos
detectarlos
tomar
acción
Evitarlos
forma
dinámica
asignación
cuidadosa
recursos
Prevención
evitar
estructuralmente
condiciones
requeridas
Analizaremos
métodos
siguientes
secciones
6.3
ALGORITMO
VESTRUZ
método
simple
algoritmo
avestruz
meta
cabeza
arena
pretenda
problema.†
personas
reaccionan
estrategia
diversas
formas
matemá-
ticos
encuentran
totalmente
inaceptable
interbloqueos
prevenir
costa
ingenieros
preguntan
frecuencia
espera
problema
frecuencia
falla
sistema
razones
grave
interbloqueo
ocurren
interbloqueos
prome-
años
fallos
sistema
hardware
errores
compi-
lador
errores
sistema
operativo
ocurren
semana
mayoría
ingenieros
estarán
dispuestos
reducir
considerablemente
rendimiento
conveniencia
eliminar
interbloqueos
contraste
específico
considere
sistema
operativo
bloquea
pro-
ceso
llamador
cabo
llamada
sistema
openen
dispositivo
físi-
co
unidad
CD-ROM
impresora
dispositivo
ocupado
general
responsabilidad
driver
controlador
dispositivos
decidir
acción
tomar
tales
circunstancias
Bloquear
devolver
clave
error
posibilidades
obvias
proceso
abre
exitosamente
unidad
CD-ROM
impresora
proceso
abrir
recurso
bloquea
intento
interbloqueo
sistemas
ac-
tuales
detectarán
realidad
imagen
dominio
público
realista
avestruces
correr
60
km
hora
pata-
potente
matar
león
planes
cenar
pollo
www
FreeLibros.me6.4
DETECCIÓN
RECUPERACIÓN
INTERBLOQUEO
técnica
detección
recuperación
utiliza
técnica
sistema
evitar
interbloqueos
intenta
detectarlos
ocurran
realiza
acción
recuperarse
sección
analizaremos
for-
detectar
interbloqueos
maneras
cabo
recuperación
6.4.1
Detección
interbloqueos
recurso
tipo
empezar
caso
simple
recurso
tipo
sistema
escáner
grabador
CD
trazador
plotter
unidad
cinta
recurso
clase
palabras
excluyendo
sistemas
impresoras
momento
lidiaremos
usando
método
distinto
sistema
construir
gráfico
recursos
tipo
ilustrado
figura
6-3
gráfico
contiene
ciclos
interbloqueo
proceso
forme
ciclo
interbloqueo
ciclos
sistema
interbloqueo
ejemplo
sistema
complejo
analizado
conside-
re
sistema
procesos
recursos
W.
recursos
contenidos
proceso
solicitados
proceso
contiene
S.
proceso
contiene
recurso
T.
proceso
contiene
recurso
S.
proceso
contiene
T.
proceso
contiene
V.
proceso
contiene
S.
proceso
contiene
U.
pregunta
sistema
interbloqueo
procesos
involucrados
responder
pregunta
construir
gráfico
recursos
figura
6-5(a
Es-
gráfico
contiene
ciclo
inspección
visual
ciclo
muestra
figura
6-5(b
ciclo
procesos
interbloqueo
pro-
cesos
interbloqueo
asignarse
cualquiera
termina
devuelve
tomarlo
turno
completarse
observe
ejemplo
interesante
permitido
procesos
pidan
recursos
442
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.4
DETECCIÓN
RECUPERACIÓN
INTERBLOQUEO
443
relativamente
fácil
distinguir
procesos
interbloqueo
simple
vista
sencillo
gráfico
método
sistemas
reales
necesitamos
algoritmo
formal
detección
interbloqueos
algoritmos
conocidos
detectar
ciclos
grá-
ficos
dirigidos
continuación
veremos
algoritmo
simple
inspecciona
gráfico
termi-
na
encontrado
ciclo
demostrado
Utiliza
estructura
dinámica
datos
lista
nodos
lista
arcos
algorit-
mo
arcos
marcarán
indicar
inspeccionados
evitar
repetir
inspec-
ciones
algoritmo
opera
cabo
siguientes
pasos
especificado
nodo
gráfico
siguientes
pasos
nodo
ini-
cial
Inicializar
lista
vacía
designar
arcos
desmarcados
Agregar
nodo
actual
comprobar
nodo
aparece
L.
gráfico
contiene
ciclo
listado
algoritmo
termina
nodo
arcos
salientes
desmarcados
paso
caso
con-
trario
paso
Elegir
arco
saliente
desmarcado
azar
marcarlo
seguirlo
no-
do
actual
paso
nodo
inicial
gráfico
contiene
ciclos
algoritmo
termina
caso
con-
trario
llegado
punto
muerto
Eliminarlo
regresar
nodo
de-
cir
justo
nodo
actual
paso
GG
Figura
6-5
gráfico
recursos
ciclo
extraído
www
FreeLibros.me444
INTERBLOQUEOS
CAPÍTULO
algoritmo
tomar
nodo
turno
raíz
espera
ár-
bol
realiza
búsqueda
nivel
profundidad
regresa
nodo
encontrado
encontrado
ciclo
agota
arcos
nodo
regresa
nodo
regresa
raíz
avanzar
subgráfico
alcanzar
nodo
actual
contiene
ciclos
propiedad
aplica
nodos
gráfico
completo
libre
ciclos
sistema
interbloqueo
funciona
algoritmo
práctica
utilizarlo
gráfico
fi-
gura
6-5(a
orden
procesamiento
nodos
arbitrario
inspecciona-
remos
izquierda
derecha
abajo
ejecutando
algoritmo
empezando
sucesivamente
sucesivo
llegamos
ciclo
algoritmo
detiene
Empezamos
inicializamos
lista
vacía
agregamos
lista
avan-
zamos
única
posibilidad
agregamos
/H11005[R
pa-
samos
obtener
/H11005[R
arcos
salientes
punto
muerto
obliga
regresar
A.
arcos
salientes
desmarcados
regresamos
com-
pletando
inspección
R.
reiniciamos
algoritmo
empezando
restablecemos
lista
vacía
bús-
queda
detiene
rápidamente
empezamos
B.
continuamos
si-
guiendo
arcos
salientes
llegar
/H11005[B
debemos
elección
azar
elegimos
llegamos
punto
muerto
regresamos
D.
se-
gunda
elegimos
actualizamos
descu-
brimos
ciclo
detenemos
algoritmo
algoritmo
lejos
óptimo
consulte
Even
1979
sirve
demostrar
algoritmo
detección
interbloqueo
6.4.2
Detección
interbloqueo
recursos
tipo
copias
recursos
necesita
método
distinto
detec-
tar
interbloqueos
presentaremos
algoritmo
basado
matrices
detectar
interbloqueos
procesos
Pn
Hagamos
número
clases
recursos
E1
recursos
clase
recursos
clase
general
Ei
recursos
clase
vector
recursos
existentes
vector
proporciona
número
instancias
recur-
so
existencia
ejemplo
clase
unidades
cinta
E1
/H110052
significa
sistema
unidades
cinta
instante
recursos
asignados
disponibles
Hagamos
vector
recursos
disponibles
Ai
proporciona
número
instancias
re-
curso
disponibles
momento
asignar
ambas
uni-
dades
cinta
asignadas
necesitamos
arreglos
matriz
asignaciones
actuales
matriz
pe-
ticiones
i-ésima
fila
indica
instancias
clase
recurso
contiene
Pi
momento
Cij
número
instancias
recurso
contenidas
pro-
ceso
i.
similar
Rij
número
instancias
recurso
desea
Pi
es-
tructuras
datos
muestran
figura
6-6
www
FreeLibros.meSECCIÓN
6.4
DETECCIÓN
RECUPERACIÓN
INTERBLOQUEO
445
importante
invariante
aplica
estructuras
datos
especial
recurso
asignado
disponible
observación
significa
palabras
agregamos
instancias
recurso
asignado
agregamos
instancias
disponibles
resultado
número
instancias
existentes
clase
recursos
algoritmo
detección
interbloqueos
basa
comparación
vectores
de-
finir
relación
vectores
indicar
elemento
menor
elemento
correspondiente
B.
sentido
matemático
aplica
Ai
Bi
m.
principio
proceso
desmarcado
medida
algoritmo
progrese
marcarán
procesos
indicando
completarse
ende
interbloqueo
algoritmo
termine
proceso
desmarcado
interbloqueo
algoritmo
supone
escenario
caso
procesos
mantienen
recursos
ad-
quiridos
terminan
algoritmo
detección
interbloqueos
muestra
continuación
Buscar
proceso
desmarcado
i-ésima
fila
menor
A.
proceso
agregar
i-ésima
fila
marcar
proceso
regresar
paso
proceso
algoritmo
termina
algoritmo
termina
procesos
desmarcados
interbloqueo
Cij
Aj
Ej
Recursos
existencia
E1
E2
E3
Matriz
asignaciones
actuales
C11
C21
Cn1
C12
C22
Cn2
C13
C23
Cn3
C1
C2
Cnm
fila
asignación
actual
proceso
Recursos
disponibles
A1
A2
A3
Matriz
solicitudes
R11
R21
Rn1
R12
R22
Rn2
R13
R23
Rn3
R1
R2
Rnm
fila
necesita
proceso
Figura
6-6
estructuras
datos
necesita
algoritmo
detección
interbloqueos
www
FreeLibros.meLo
algoritmo
paso
buscar
proceso
ejecutar
com-
pletarse
proceso
caracteriza
demandas
recursos
satisfacer
base
recursos
disponibles
actuales
proceso
seleccionado
ejecuta
termina
momento
devuelve
recursos
contiene
reserva
recursos
disponibles
marca
completado
procesos
instancia
ejecutarse
completarse
interbloqueo
termi-
nar
interbloqueo
algoritmo
determinístico
ejecutar
procesos
orden
resultado
ejemplo
acerca
funciona
algoritmo
detección
interbloqueos
considere
figura
6-7
procesos
clases
recursos
etiquetado
for-
ma
arbitraria
unidades
cinta
trazadores
escáner
unidad
CD-ROM
proceso
tie-
ne
escáner
proceso
unidades
cinta
unidad
CD-ROM
proceso
trazador
escáneres
proceso
necesita
recursos
adicionales
muestra
base
matriz
R.
446
INTERBLOQUEOS
CAPÍTULO
Unidades
cintaTrazadoresEscáneresUnidades
CD-ROM
Unidades
cintaTrazadoresEscáneresUnidades
CD-ROM
Matriz
asignaciones
actuales
Matriz
peticiones
Figura
6-7
ejemplo
algoritmo
detección
interbloqueos
ejecutar
algoritmo
detección
interbloqueos
buscamos
proceso
cuya
petición
recursos
satisfacer
satisfacer
unidad
CD-ROM
disponible
satisfacer
escáner
libre
for-
tuna
satisfacer
proceso
ejecuta
momento
devuel-
ve
recursos
obtener
/H11005(2
punto
ejecutar
proceso
devolver
recursos
obtenemos
/H11005(4
ejecutar
proceso
restante
interbloqueo
sistema
www
FreeLibros.meSECCIÓN
6.4
DETECCIÓN
RECUPERACIÓN
INTERBLOQUEO
447
Consideremos
variación
menor
situación
figura
6-7
Suponga
pro-
ceso
necesita
unidad
CD-ROM
unidades
cinta
trazador
peticiones
satisfacer
sistema
interbloqueo
detectar
interbloqueos
conocen
ante-
mano
peticiones
recursos
estáticas
surge
pregunta
buscarlos
posibi-
lidad
comprobar
realiza
petición
recurso
duda
detectará
potencialmente
costoso
términos
tiempo
CPU
es-
trategia
alternativa
comprobar
minutos
disminuido
CPU
valor
umbral
razón
consideración
sufi-
cientes
procesos
interbloqueo
procesos
ejecutables
CPU
inactiva
frecuencia
6.4.3
Recuperación
interbloqueo
Suponga
algoritmo
detección
interbloqueos
éxito
detectó
interblo-
queo
debemos
necesita
forma
recuperarse
funcionar
sis-
tema
sección
analizaremos
formas
recuperarse
interbloqueo
especial
atractiva
Recuperación
apropiación
casos
quitar
temporalmente
recurso
propietario
actual
otor-
garlo
proceso
casos
requerir
intervención
manual
especial
sis-
temas
operativos
procesamiento
lotes
ejecutan
mainframes
ejemplo
quitar
impresora
láser
propietario
operador
recolectar
to-
das
hojas
impresas
colocarlas
pila
suspender
proceso
mar-
ca
ejecutable
punto
impresora
asignar
proceso
proceso
termina
pila
hojas
impresas
colocar
vuelta
bandeja
salida
impresora
reiniciar
proceso
original
habilidad
quitar
recurso
proceso
proceso
utilice
re-
gresarlo
proceso
note
depende
naturaleza
recurso
frecuen-
cia
difícil
imposible
recuperarse
Elegir
proceso
suspender
depende
procesos
recursos
quitar
facilidad
Recuperación
retroceso
diseñadores
sistemas
operadores
máquinas
probable
interblo-
queos
procesos
realicen
puntos
comprobación
forma
periódica
Rea-
lizar
puntos
comprobación
proceso
significa
escribe
archivo
reiniciarlo
punto
comprobación
contiene
imagen
memoria
recurso
palabras
recursos
asignados
proceso
www
FreeLibros.me448
INTERBLOQUEOS
CAPÍTULO
momento
efectivos
puntos
comprobación
sobres-
cribir
anteriores
escribirse
archivos
acumule
se-
cuencia
completa
medida
proceso
ejecute
detecta
interbloqueo
fácil
recursos
necesitan
re-
cuperación
proceso
posee
recurso
necesario
revierte
punto
tiempo
adquirido
recurso
inicia
puntos
comprobación
anterio-
res
pierde
trabajo
punto
comprobación
ejemplo
salida
im-
presa
punto
comprobación
descartar
volverá
imprimir
efecto
proceso
restablece
momento
recurso
asigna
procesos
interbloqueo
proceso
reiniciado
adquirir
recurso
esperar
vuelva
disponible
Recuperación
eliminación
procesos
forma
cruda
simple
romper
interbloqueo
eliminar
procesos
po-
sibilidad
eliminar
procesos
ciclo
suerte
procesos
continuar
ayuda
repetir
rompa
ciclo
alternativa
elegir
víctima
proceso
esté
ciclo
pa-
ra
liberar
recursos
método
proceso
eliminar
elige
cuidado
conteniendo
recursos
necesita
proceso
ciclo
ejemplo
proceso
po-
dría
contener
impresora
querer
trazador
proceso
contener
traza-
dor
querer
impresora
procesos
interbloqueo
tercer
proceso
contener
impresora
idéntica
trazador
idéntico
felizmente
ejecución
elimi-
nar
tercer
proceso
liberarán
recursos
romperá
interbloqueo
involucra
pri-
meros
eliminar
proceso
volver
ejecutar
prin-
cipio
efectos
dañinos
ejemplo
compilación
volver
ejecutarse
leer
archivo
código
fuente
producir
archivo
código
objeto
elimina
mitad
proceso
ejecución
influencia
proceso
actualiza
base
datos
ejecutar
se-
gunda
forma
segura
proceso
agrega
campo
tabla
base
datos
ejecutarlo
eliminarlo
volverlo
ejecutar
agregará
campo
incorrecto
6.5
EVITAR
INTERBLOQUEOS
análisis
detección
interbloqueos
hicimos
suposición
proceso
pide
recursos
pide
matriz
figura
6-6
mayoría
sistemas
recursos
solicitan
sistema
capaz
decidir
segu-
ro
otorgar
recurso
asignación
seguro
ende
surge
pregunta
algoritmo
evitar
interbloqueo
elección
correcta
tiempo
respuesta
calificado
evitar
interbloqueos
só-
www
FreeLibros.meSECCIÓN
6.5
EVITAR
INTERBLOQUEOS
449
información
disponible
antemano
sección
examinaremos
formas
evitar
interbloqueo
asignación
cuidadosa
recursos
6.5.1
Trayectorias
recursos
principales
algoritmos
evitar
interbloqueos
basan
concepto
seguros
describir
algoritmos
haremos
ligera
digresión
analizar
concepto
se-
guridad
forma
gráfica
fácil
comprender
método
gráfico
traduce
direc-
tamente
algoritmo
utilizable
ofrece
sensación
intuitiva
naturaleza
problema
figura
6-8
modelo
lidiar
procesos
recursos
ejem-
plo
impresora
trazador
eje
horizontal
representa
número
instrucciones
ejecutadas
proceso
A.
eje
vertical
representa
número
instrucciones
ejecutadas
proceso
solicita
impresora
I2
necesita
trazador
impresora
trazador
liberan
I3
I4
respectivamente
proceso
necesita
trazador
I5
I7
impresora
I6
I8
Trazador
Impresora
Impresora
Trazador
procesos
terminaron
pq
I8
I7
I6
I5
I4I3I2I1
Figura
6-8
Trayectorias
recursos
procesos
punto
diagrama
representa
conjunto
procesos
principio
es-
tado
procesos
ejecutado
instrucciones
programador
opta
ejecutar
llegamos
punto
ejecutado
número
instruccio-
nes
ejecutado
punto
trayectoria
vuelve
vertical
indicando
programador
optado
ejecutar
B.
procesador
rutas
horizonta-
verticales
diagonales
movimiento
norte
sur
oeste
procesos
ejecutarse
revés
tiempo
cruza
línea
ruta
solicita
impresora
otorga
llega
punto
solicita
trazador
www
FreeLibros.meLas
regiones
sombreadas
especial
interesantes
región
líneas
inclinan
suroeste
noreste
representa
procesos
impresora
regla
exclusión
mutua
imposible
entrar
región
similar
región
sombreada
for-
ma
representa
procesos
trazador
imposible
sistema
entra
cuadro
delimitado
I2
lados
I5
I6
superior
inferior
entrará
interbloqueo
momento
llegue
intersec-
ción
I6
punto
solicitando
trazador
impresora
recursos
asignados
cuadro
inseguro
entrar
punto
único
segu-
ro
ejecutar
proceso
llegue
allá
trayectoria
bastará
importante
considerar
punto
solicitando
recurso
sistema
decidir
otorga
otorga
recurso
sistema
entrará
región
insegura
interbloqueo
momento
evitar
interbloqueo
suspender
solicitado
liberado
trazador
6.5.2
seguros
inseguros
algoritmos
evitar
interbloqueos
estudiaremos
utilizan
información
figura
6-6
instante
actual
consiste
R.
se-
guro
orden
programación
ejecutar
proceso
comple-
tarse
solicitaran
repentina
número
máximo
recursos
inmediato
fácil
ilustrar
concepto
ejemplo
utiliza
recurso
figura
6-9(a
instancias
recurso
ne-
cesitar
momento
actualidad
necesitar
similar
necesitar
Exis-
10
instancias
recurso
recursos
asignados
libres
450
INTERBLOQUEOS
CAPÍTULO
Libres
Libres
Libres
Libres
Libres
Máx
Máx
Máx
Máx
Máx
Figura
6-9
Demostración
seguro
figura
6-9(a
seguro
secuencia
asignaciones
permite
completar
procesos
programador
simplemente
ejecutar
forma
exclusiva
pidiera
obtuviera
instancias
recurso
figura
6-9(b
completarse
obtenemos
figura
6-9(c
programador
ejecutar
obtendríamos
momento
figura
6-9(d
www
FreeLibros.meSECCIÓN
6.5
EVITAR
INTERBLOQUEOS
451
complete
obtendremos
figura
6.9(e
obtener
instancias
recurso
necesita
completarse
ende
figura
6-9(a
seguro
sistema
programación
cuidadosa
evitar
interbloqueo
suponga
inicial
muestra
figura
6-10(a
solicita
obtiene
recurso
obtenemos
figura
6-10(b
encontrar
secuencia
garantice
funcione
intentarlo
programador
ejecutar
pidiera
recursos
muestra
figura
6-10(c
Libres
Libres
Libres
Libres
Máx
Máx
Máx
Máx
Figura
6-10
Demostración
seguro
momento
completará
llegaremos
situación
figura
6-10(d
punto
atorados
instancias
recurso
libres
procesos
activos
necesita
secuencia
garantice
procesos
comple-
tarán
decisión
asignación
cambió
sistema
figura
6-10(a
figura
6-10(b
pasó
seguro
inseguro
funciona
ejecutamos
continuación
empezando
figura
6-10(b
retrospectiva
petición
debería
haberse
otorgado
Vale
pena
observar
inseguro
interbloqueo
Empezando
figura
6-10(b
sistema
ejecutarse
tiempo
proceso
completar
libere
recurso
pedir
completar
evitaría
interbloqueo
completo
ende
diferencia
seguro
inseguro
seguro
sistema
garantizar
procesos
terminarán
inseguro
garantía
6.5.3
algoritmo
banquero
recurso
Dijkstra
1965
ideó
algoritmo
programación
evitar
interbloqueos
algoritmo
conoce
algoritmo
banquero
extensión
algoritmo
detección
inter-
bloqueos
proporciona
sección
3.4.1
modela
forma
banquero
pequeña
ciudad
tratar
grupo
clientes
otorgado
líneas
crédito
algoritmo
comprobar
otorgar
petición
produce
inseguro
petición
rechaza
otorgar
petición
produce
seguro
cabo
www.FreeLibros.mela
figura
6-11(a
clientes
recibido
número
unidades
crédito
ejemplo
unidad
dólares
banquero
clientes
necesitan
crédito
máximo
inmediato
reservado
10
uni-
dades
22
darles
servicio
analogía
clientes
procesos
unidades
ejemplo
unidades
cinta
banquero
sistema
operativo
452
INTERBLOQUEOS
CAPÍTULO
Máx
Libres
10
Máx
Libres
Máx
Libres
Figura
6-11
asignación
recursos
Seguro
Seguro
In-
seguro
clientes
respectivas
labores
pidiendo
préstamos
so-
licitando
recursos
momento
situación
muestra
figura
6-11(b
seguro
unidades
restantes
banquero
retrasar
pe-
tición
deja
termine
libere
recursos
cua-
tro
unidades
mano
banquero
dejar
tengan
unidades
necesarias
sucesivo
Considere
ocurriría
otorgara
petición
unidades
figu-
ra
6-11(b
Tendríamos
situación
figura
6-11(c
insegura
clientes
pidie-
ran
repentina
préstamos
máximos
banquero
satisfacer
tendríamos
interbloqueo
inseguro
conducir
interbloqueo
cliente
necesitaría
línea
crédito
disponible
banquero
po-
dría
contar
comportamiento
algoritmo
banquero
petición
medida
ocurriendo
analiza
otorgarla
produce
seguro
otorga
petición
caso
contrario
pospo-
ne
seguro
banquero
comprueba
suficientes
recursos
satisfacer
cliente
asume
préstamos
volverán
pagar-
comprueba
cliente
cercano
límite
etcétera
préstamos
pue-
den
volver
pagar
momento
seguro
petición
inicial
otorgar
6.5.4
algoritmo
banquero
recursos
algoritmo
banquero
generalizar
manejar
recursos
figura
6-12
mues-
tra
funciona
figura
6-12
muestran
matrices
izquierda
muestra
instancias
recurso
asignadas
momento
procesos
matriz
www
FreeLibros.meSECCIÓN
6.5
EVITAR
INTERBLOQUEOS
453
derecha
muestra
recursos
necesitando
proceso
completarse
Es-
tas
matrices
figura
6-6
caso
recurso
proce-
sos
declarar
necesidades
totales
recursos
ejecutarse
sistema
calcular
matriz
derecha
instante
vectores
derecha
figura
muestran
recursos
existentes
recursos
po-
seídos
recursos
disponibles
respectivamente
sistema
unidades
cinta
trazadores
impresoras
unidades
CD-ROM
asignados
unidades
cinta
trazadores
impresoras
unidades
CD-ROM
verse
agregar
columnas
recursos
matriz
izquierda
vector
recursos
disponibles
simplemente
diferencia
sistema
momento
declarar
algoritmo
comprobar
seguro
Buscar
fila
cuyas
necesidades
recursos
satisfechas
menores
iguales
A.
dicha
fila
sistema
entrará
interbloqueo
momento
proceso
ejecutar
completarse
suponiendo
procesos
man-
recursos
terminan
Suponer
proceso
seleccionado
fila
solicita
recursos
necesita
garantiza
termina
Marcar
proceso
terminado
agregar
recursos
vector
A.
Repetir
pasos
procesos
marquen
terminados
cuyo
caso
inicial
seguro
proceso
cuyas
necesidades
recursos
puedan
satisfacer
cuyo
caso
interbloqueo
procesos
elegirse
paso
importa
esté
seleccionado
re-
serva
recursos
disponibles
aumentará
caso
permanecerá
ProcesoUnidades
cintaTrazadores
6342
5322
1020
Recursos
asignados
ProcesoUnidades
cintaTrazadores
Recursos
necesitan
ImpresorasUnidades
CD-ROMsImpresorasUnidades
CD-ROMs
Figura
6-12
algoritmo
banquero
recursos
www
FreeLibros.meAhora
regresemos
ejemplo
figura
6-12
actual
seguro
Suponga
proceso
pide
impresora
petición
otorgarse
resultante
se-
guro
proceso
terminar
procesos
seguidos
resto
imagine
otorgar
impresoras
restantes
úl-
tima
impresora
otorgar
petición
reduciría
vector
recursos
disponibles
produce
interbloqueo
evidente
petición
diferir
momentos
algoritmo
banquero
publicado
Dijkstra
1965
enton-
ces
libros
sistemas
operativos
descrito
detalle
escrito
innu-
merables
artículos
aspectos
desgracia
autores
audacia
recalcar
teoría
algoritmo
maravilloso
práctica
esencia
inútil
de-
bido
procesos
raras
antemano
máximas
necesidades
re-
cursos
número
procesos
fijo
varía
forma
dinámica
medida
usuarios
inician
cierran
sesión
recursos
consideraban
dispo-
nibles
desvanecerse
unidades
cinta
descomponer
ende
práctica
acaso
sistemas
existentes
utilizan
algoritmo
banquero
evitar
inter-
bloqueos
6.6
PREVENIR
INTERBLOQUEOS
Habiendo
visto
evitar
interbloqueos
esencia
imposible
requiere
información
peticiones
futuras
conocen
evitan
sistemas
reales
in-
terbloqueo
respuesta
volver
condiciones
establecidas
Coffman
colabora-
dores
1971
proporcionarnos
pista
asegurar
condiciones
cumpla
interbloqueos
estructuralmente
impo-
sibles
Havender
1968
6.6.1
atacar
condición
exclusión
mutua
atacar
condición
exclusión
mutua
recurso
asignara
exclusiva
proceso
tendríamos
interbloqueos
obstante
permitir
procesos
escriban
impresora
tiempo
producirá
caos
colo-
car
salida
impresora
cola
impresión
procesos
generar
salida
mis-
mo
tiempo
modelo
único
proceso
realmente
solicita
impresora
física
demonio
impresión
demonio
solicita
recurso
eliminar
interbloqueo
impresora
demonio
programa
imprimir
salida
esté
cola
im-
presión
impresora
permanecer
inactiva
proceso
salida
decide
esperar
ho-
ras
ráfaga
salida
razón
demonios
comúnmente
programan
imprimirse
esté
disponible
archivo
salida
completo
decisión
provocar
interbloqueo
ocurriría
procesos
llenaran
mitad
espacio
cola
impresión
disponible
datos
salida
termi-
nara
producir
salida
completa
caso
tendríamos
procesos
454
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.6
PREVENIR
INTERBLOQUEOS
455
terminado
salida
continuar
procesos
termi-
nará
interbloqueo
disco
germen
idea
aplica
frecuencia
evite
asignar
recurso
absolutamente
necesario
trate
asegurarse
menor
cantidad
posi-
ble
procesos
reclamen
recurso
6.6.2
atacar
condición
contención
espera
condición
establecida
Coffman
colaboradores
ve
prometedora
evitar
procesos
contienen
recursos
esperen
recursos
elimi-
nar
interbloqueos
forma
lograr
meta
requerir
procesos
soliciten
to-
recursos
empezar
ejecución
disponible
proceso
asignará
necesite
ejecutarse
completarse
recursos
ocupados
asig-
nará
proceso
esperará
problema
inmediato
método
procesos
recursos
necesitarán
hayan
empezado
ejecutarse
supieran
utilizar
algoritmo
banquero
problema
recursos
utilizarán
óptima
método
Tome
ejemplo
proceso
lee
datos
cinta
entrada
anali-
za
hora
escribe
cinta
salida
traza
resultados
recur-
sos
solicitar
antemano
proceso
ocupará
unidad
cinta
salida
trazador
hora
sistemas
procesamiento
lotes
mainframes
requieren
usuario
liste
recursos
línea
trabajo
sistema
adquiere
to-
recursos
inmediato
mantiene
trabajo
termina
método
im-
pone
carga
programador
desperdicia
recursos
evita
interbloqueos
ligeramente
distinta
romper
condición
contención
espera
requerir
proceso
solicita
recurso
libere
temporalmente
recursos
contiene
mo-
mento
tratar
obtener
necesite
6.6.3
atacar
condición
apropiativa
atacar
condición
apropiativa
proceso
asignado
impresora
mitad
imprimir
salida
quitarle
impresora
fuerza
trazador
necesita
disponible
engañoso
máximo
imposible
caso
recursos
virtualizar
evitar
situación
colocar
cola
impresión
disco
salida
impresora
permitir
demonio
im-
presión
acceso
impresora
real
eliminan
interbloqueos
involucran
impre-
sora
crea
espacio
disco
obstante
discos
improbable
quedarse
espacio
recursos
virtualizar
ejemplo
re-
gistros
bases
datos
tablas
sistema
operativo
bloquear
utilizarse
potencial
interbloqueo
www
FreeLibros.me6.6.4
atacar
condición
espera
circular
queda
condición
espera
circular
eliminar
formas
simplemente
regla
diga
proceso
derecho
recurso
momento
necesita
recurso
liberar
proceso
necesita
co-
piar
enorme
archivo
cinta
impresora
restricción
inaceptable
evitar
espera
circular
proporcionar
numeración
global
re-
cursos
muestra
figura
6-13(a
regla
procesos
solicitar
recursos
quieran
peticiones
orden
numérico
proceso
pedir
impresora
unidad
cinta
pedir
trazador
impresora
456
INTERBLOQUEOS
CAPÍTULO
A1
Fotocomponedora
Escáner
Trazador
Unidad
cinta
Unidad
CD-ROM
Figura
6-13
Recursos
ordenados
forma
numérica
gráfico
recursos
regla
gráfico
asignación
recursos
ciclos
Veamos
caso
procesos
figura
6-13(b
obtener
interbloqueo
solicita
recurso
solicita
recurso
i.
Suponiendo
recursos
distintos
números
solicitar
menor
solicitar
menor
forma
interbloqueo
imposible
procesos
aplica
lógica
instante
recursos
asig-
nados
alto
proceso
contiene
recurso
pedirá
recurso
esté
asignado
Terminará
caso
solicitará
recursos
numeración
es-
tán
disponibles
momento
terminará
liberará
recursos
punto
proceso
contendrá
recurso
alto
terminar
resumen
escenario
procesos
terminan
interbloqueo
presente
variación
menor
algoritmo
retirar
requerimiento
recursos
ad-
quieran
secuencia
estricta
simplemente
insistir
proceso
solicitar
recurso
menor
contiene
principio
proceso
solicita
10
libera
recursos
efecto
empezando
razón
prohibirle
solicite
recurso
ordenamiento
numérico
recursos
elimina
problema
interbloqueos
imposible
encontrar
ordenamiento
satisfaga
recursos
inclu-
yen
entradas
tabla
procesos
espacio
cola
impresión
disco
registros
bloquea-
www
FreeLibros.meSECCIÓN
6.7
CUESTIONES
457
base
datos
recursos
abstractos
número
recursos
potenciales
usos
distin-
tos
ordenamiento
funcionar
diversos
métodos
evitar
interbloqueo
sintetizan
figura
6-14
Figura
6-14
Resumen
métodos
evitar
interbloqueos
Condición
Método
Exclusión
mutua
cola
impresión
Contención
espera
Solicitar
recursos
principio
apropiativa
Quitar
recursos
Espera
circular
Ordenar
recursos
forma
numérica
6.7
CUESTIONES
sección
analizaremos
cuestiones
relacionadas
interbloqueos
incluyen
bloqueo
fases
interbloqueos
recursos
inanición
6.7.1
Bloqueo
fases
métodos
evitar
prevenir
interbloqueos
prometedores
ca-
so
general
aplicaciones
específicas
conocen
algoritmos
excelentes
propósito
especial
ejemplo
sistemas
bases
datos
operación
ocurre
frecuencia
solicitar
bloqueos
registros
actualizar
registros
blo-
queados
procesos
ejecución
tiempo
peligro
real
in-
terbloqueo
método
conoce
bloqueo
fases
fase
pro-
ceso
bloquear
registros
necesita
éxito
pasa
segun-
fase
realizando
actualizaciones
liberando
bloqueos
realiza
trabajo
real
fase
fase
necesita
registro
esté
bloqueado
proceso
li-
bera
bloqueos
inicia
fase
principio
sentido
método
similar
solicitar
recursos
necesita
antemano
al-
go
irreversible
versiones
bloqueo
fases
liberación
reinicio
en-
cuentra
registro
bloqueado
fase
versiones
ocurrir
interbloqueo
estrategia
aplicable
general
ejemplo
sistemas
tiem-
po
real
sistemas
control
procesos
aceptable
terminar
proceso
mitad
recurso
disponible
empezar
aceptable
iniciar
proceso
leído
escrito
mensajes
red
actualizado
archivos
cosa
repetir
seguridad
algoritmo
funciona
situaciones
www.FreeLibros.medonde
programador
ordenado
cosas
cuidado
programa
detener
punto
fase
reinicie
aplicaciones
estructurar
forma
6.7.2
Interbloqueos
comunicaciones
trabajo
concentrado
interbloqueos
recursos
proceso
desea
proceso
esperar
libere
re-
cursos
objetos
hardware
software
unidades
CD-ROM
registros
bases
datos
abstractos
figura
6-2
vimos
interbloqueo
recursos
recursos
mutexes
abstracto
unidad
CD-ROM
ejemplo
proceso
adquirió
éxito
recurso
mutexes
entró
interbloqueo
tratando
adquirir
mutex
situación
interblo-
queo
recursos
clásico
dijimos
inicio
capítulo
interbloqueos
recursos
tipo
común
único
tipo
interbloqueo
ocurrir
sistemas
comu-
nicaciones
redes
procesos
comunican
envío
men-
sajes
arreglo
común
proceso
envía
mensaje
petición
proceso
bloquea
envía
vuelta
mensaje
respuesta
Suponga
mensaje
peti-
ción
pierde
bloquea
espera
respuesta
bloquea
espera
petición
haga
interbloqueo
clásico
interbloqueo
recursos
posesión
recurso
viceversa
recursos
vista
interbloqueo
definición
formal
conjunto
procesos
bloqueado
espera
evento
provocar
situación
conoce
interblo-
queo
comunicación
contrastarlo
interbloqueo
recursos
común
interbloqueos
comunicación
evitar
ordenamiento
recursos
evitar
programación
cuidadosa
momentos
posponer
petición
fortuna
técnica
ge-
neral
utilizar
romper
interbloqueos
comunicación
tiempos
espera
mayoría
sistemas
comunicación
red
envía
mensaje
es-
pera
respuesta
inicia
temporizador
temporizador
termina
conteo
llegue
respuesta
emisor
mensaje
asume
perdido
envía
necesario
forma
evita
interbloqueo
mensaje
original
perdió
respuesta
simplemente
retrasó
receptor
destinado
recibir
mensaje
consecuencias
indesea-
bles
Piense
sistema
bancario
electrónico
mensaje
contiene
instrucciones
rea-
lizar
pago
evidente
repetir
ejecutar
red
lenta
tiempo
espera
corto
diseño
reglas
comunicación
funcione
conocen
protocolo
tema
complejo
alejado
alcance
libro
lectores
interesados
protocolos
red
interesarles
libro
escrito
autor
Computer
Networks
Tanenbaum
2003
458
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.7
CUESTIONES
459
interbloqueos
ocurren
sistemas
comunicaciones
redes
interbloqueos
comunicación
ocurrir
interbloqueos
recursos
ejem-
plo
considere
red
figura
6-15
figura
vista
simplificada
Internet
sim-
plificada
Internet
consiste
tipos
computadoras
hosts
servidores
enrutadores
host
computadora
usuario
PC
alguien
hogar
PC
empresa
servidor
corporativo
hosts
funcionan
personas
enrutador
compu-
tadora
comunicaciones
especializada
desplaza
paquetes
datos
origen
destino
host
conectado
enrutadores
línea
DSL
cone-
xión
TV
cable
LAN
línea
marcación
telefónica
red
inalámbrica
fibra
óptica
Host
Host
Host
Host
Búfer
Enrutador
Figura
6-15
interbloqueo
recursos
red
llega
paquete
enrutador
proveniente
hosts
coloca
bú-
fer
transmitirlo
continuación
enrutador
llega
destino
Es-
tos
búferes
recursos
número
finito
figura
6-15
enrutador
búferes
práctica
millones
cambia
naturaleza
interbloqueo
po-
tencial
frecuencia
Suponga
paquetes
enrutador
necesitan
paquetes
necesitan
paquetes
necesitan
paquetes
necesitan
A.
paquete
mover
búfer
extremo
interbloqueo
recursos
clásico
mitad
sistema
comu-
nicaciones
6.7.3
Bloqueo
activo
situaciones
utiliza
sondeo
ocupado
espera
estrategia
utiliza
exclusión
mutua
tiempo
corto
sobrecarga
suspensión
comparación
trabajo
Considere
primitiva
atómica
pro-
ceso
llama
prueba
mutex
sostiene
devuelve
falla
www
FreeLibros.meAhora
imagine
par
procesos
utilizan
recursos
muestra
figura
6-16
necesita
recursos
utilizan
primitiva
sondeo
entrar_region
tratar
adquirir
bloqueos
necesarios
falla
intento
proceso
intenta
figura
6-16
proceso
ejecuta
adquiere
recurso
ejecuta
pro-
ceso
adquiere
recurso
importar
ejecute
continuación
progresará
pe-
ro
procesos
bloqueará
utiliza
quantum
CPU
progresar
bloquearse
ende
interbloqueo
nin-
gún
proceso
bloqueado
funcionalmente
equivalente
interbloqueo
blo-
queo
activo
livelock
void
proceso_A(void
entrar_region(&recurso_1
entrar_region(&recurso_2
usar_ambos_recursos
salir_region(&recurso_2
salir_region(&recurso_1
void
proceso_B(void
entrar_region(&recurso_2
entrar_region(&recurso_1
usar_ambos_recursos
salir_region(&recurso_1
salir_region(&recurso_2
Figura
6-16
ocupado
espera
conducir
bloqueo
activo
bloqueo
activo
ocurrir
formas
sorprendentes
sistemas
número
to-
procesos
permitidos
determina
base
número
entradas
tabla
procesos
entradas
tabla
procesos
recursos
finitos
operación
forkfalla
tabla
llena
método
razonable
programa
realiza
operación
forkes
es-
perar
tiempo
aleatorio
probar
suponga
sistema
UNIX
100
entradas
procesos
ejecutan
progra-
necesita
crear
12
sub)procesos
proceso
creado
procesos
10
procesos
originales
90
procesos
agotado
tabla
10
procesos
originales
ciclo
bifurcando
fallando
interblo-
queo
probabilidad
ocurra
minúscula
ocurrir
Debemos
abandonar
procesos
llamada
forkpara
eliminar
problema
número
máximo
archivos
abiertos
restringido
similar
tamaño
tabla
nodos-i
ocurre
problema
similar
llena
espacio
intercambio
disco
recurso
limitado
tablas
sistema
operativo
repre-
sentan
recurso
finito
Debemos
abolir
ocurrir
colección
procesos
reclamar
1/
tratar
reclamarse
Probablemente
idea
460
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meSECCIÓN
6.8
INVESTIGACIÓN
INTERBLOQUEOS
461
mayoría
sistemas
operativos
incluyendo
UNIX
Windows
ignoran
proble-
ma
base
suposición
mayoría
usuarios
preferirían
bloqueo
activo
oca-
sional
interbloqueo
regla
restrinja
usuarios
proceso
archivo
abierto
cosa
problemas
pudieran
eliminar
costo
habría
discusión
problema
precio
alto
tér-
minos
imponer
restricciones
inconvenientes
procesos
enfrentamos
concesión
desagradable
conveniente
correcto
discusión
importante
Vale
pena
mencionar
personas
distinción
inanición
in-
terbloqueo
casos
progreso
positivo
sienten
fundamen-
talmente
distintos
proceso
programarse
fácilmente
tratar
fallara
probar
cosa
proceso
bloqueado
opción
6.7.4
Inanición
problema
relacionado
interbloqueo
bloqueo
activo
inanición
siste-
ma
dinámico
peticiones
recursos
ocurren
tiempo
necesita
política
deci-
dir
acerca
obtiene
recurso
política
razonable
ocasionar
procesos
reciban
atención
estén
interbloqueo
ejemplo
considere
asignación
impresora
Imagine
sistema
utiliza
algoritmo
asegurar
asignación
impresora
produzca
interbloqueo
su-
ponga
procesos
quieren
tiempo
obtenerla
algoritmo
asignación
otorgar
impresora
proceso
archivo
pe-
queño
imprimir
suponiendo
información
esté
disponible
método
maximiza
nú-
mero
clientes
satisfechos
razonable
considere
ocurre
sistema
ocupado
proceso
imprimir
archivo
enorme
impresora
es-
té
libre
sistema
buscará
elegirá
proceso
archivo
pequeño
flujo
cons-
tante
procesos
archivos
cortos
proceso
archivo
enorme
recibirá
impresora
Simplemente
pospondrá
indefinida
bloqueado
inanición
evitar
política
asignación
recursos
tipo
llegar
atendido
método
proceso
espere
tiempo
se-
rá
atienda
tiempo
proceso
convertirá
antiguo
ende
obtendrá
recurso
necesita
6.8
INVESTIGACIÓN
INTERBLOQUEOS
existió
tema
investigara
misericordia
sistemas
operativos
interbloqueos
razón
detección
interblo-
queos
pequeño
agradable
problema
teoría
gráficos
estudiante
graduado
inclinaciones
matemáticas
digiriendo
años
idearon
tipo
algorit-
mos
exótico
práctico
trabajo
de-
saparecido
artículos
publican
aspectos
interbloqueos
www.FreeLibros.meincluyen
detección
tiempo
ejecución
interbloqueos
ocasionados
incorrec-
to
bloqueos
semáforos
Agarwal
Stoller
2006
Bensalem
colaboradores
2006
evi-
tar
interbloqueos
hilos
Java
Permandia
colaboradores
2007
Williams
colaboradores
2005
lidiar
interbloqueos
redes
Jayasimha
2003
Karol
colaboradores
2003
Schafer
colaboradores
2005
modelado
interbloqueos
sistemas
flujos
datos
Zhou
Lee
2006
detección
interbloqueos
dinámicos
Li
colaboradores
2005
Levine
2003a
2003b
comparó
distintas
definiciones
contradictorias
interbloqueos
literatura
ideó
esquema
clasificación
análisis
diferen-
cia
prevenir
interbloqueos
evitarlos
Levine
2005
estudian
métodos
pa-
ra
recuperarse
interbloqueos
David
colaboradores
2007
investigación
teórica
detección
interbloqueos
distribuidos
trataremos
alcance
libro
si-
quiera
remotamente
práctico
sistemas
reales
función
principal
mantener
teorizadores
gráficos
desempleados
calles
6.9
RESUMEN
interbloqueo
problema
potencial
sistema
operativo
Ocurre
miembros
conjunto
procesos
bloquean
espera
evento
miembros
conjunto
ocasionar
situación
procesos
esperen
Comúnmente
evento
procesos
esperan
liberación
recurso
contenido
miembro
conjunto
situación
interbloqueo
con-
procesos
comunicación
espera
mensaje
canal
comunicación
es-
tá
vacío
tiempos
espera
pendientes
interbloqueo
recursos
evitar
seguros
inseguros
seguro
secuencia
eventos
garan-
tizan
procesos
terminar
inseguro
dicha
garantía
algo-
ritmo
banquero
evita
interbloqueo
otorgar
petición
colocará
sistema
inseguro
interbloqueo
recursos
prevenir
estructuralmente
construir
sistema
forma
ocurrir
diseño
ejemplo
permitir
proceso
contenga
recurso
instante
rompe
condición
espera
circular
requerida
interblo-
queo
interbloqueo
recursos
prevenir
enumerar
recursos
ha-
cer
procesos
soliciten
orden
estrictamente
ascendente
interbloqueo
recursos
único
tipo
interbloqueo
interbloqueo
comunica-
ción
problema
potencial
sistemas
manejar
establecimiento
tiempos
espera
apropiados
bloqueo
activo
similar
interbloqueo
detener
progreso
positivo
técnicamente
involucra
procesos
realidad
blo-
queados
inanición
evitar
política
asignación
tipo
lle-
gar
atendido
462
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
463
PROBLEMAS
Proporcione
ejemplo
interbloqueo
tomado
políticas
estudiantes
trabajan
PCs
individuales
laboratorio
computadoras
envían
ar-
chivos
imprima
servidor
coloca
archivos
cola
impresión
dis-
co
duro
condiciones
ocurrir
interbloqueo
espacio
disco
cola
impresión
limitado
evitarse
interbloqueo
figura
6-1
recursos
devuelven
orden
inverso
adquisición
con-
veniente
devolverlos
orden
condiciones
exclusión
mutua
contención
espera
apropiativo
espera
circular
necesarias
ocurra
interbloqueo
recursos
Proporcione
ejemplo
mostrar
condiciones
suficientes
ocurra
interbloqueo
recursos
su-
ficientes
condiciones
ocurra
interbloqueo
recursos
figura
6-3
muestra
concepto
gráfico
recursos
gráficos
ilegales
de-
cir
violan
estructuralmente
modelo
utilizado
recursos
proporcione
ejemplo
Suponga
interbloqueo
recursos
sistema
Proporcione
ejemplo
mostrar
conjunto
procesos
interbloqueo
incluir
procesos
cadena
circular
ruta
asignación
recursos
correspondiente
análisis
algoritmo
avestruz
menciona
posibilidad
llenen
entradas
tabla
procesos
tablas
sistema
sugerir
forma
permitir
adminis-
trador
sistema
recupere
dicha
situación
Explique
recuperar
sistema
interbloqueo
problema
usando
Re-
cuperación
apropiativo
Recuperación
retroceso
Recuperación
eliminación
procesos
Suponga
figura
6-6
ij
Rij
Ej
valor
i.
implicaciones
pa-
ra
sistema
10
diferencia
clave
modelo
muestra
figura
6-8
seguro
inseguro
descritos
sección
6.5.2
consecuencia
diferencia
11
utilizar
esquema
trayectorias
recursos
figura
6-8
ilustrar
problema
interbloqueos
procesos
recursos
caso
contrario
12
teoría
gráficos
trayectorias
recursos
utilizar
evitar
interbloqueos
Me-
diante
programación
astuta
sistema
operativo
evitar
regiones
inseguras
Sugiera
problema
práctico
haga
13
sistema
encontrarse
esté
interbloqueo
seguro
proporcione
ejemplo
caso
contrario
demuestre
interblo-
queo
seguros
14
Considere
sistema
utilice
algoritmo
banquero
evitar
interbloqueos
momento
proceso
solicita
recurso
petición
rechaza
www.FreeLibros.medisponible
momento
Significa
sistema
asignara
entraría
interblo-
queo
15
limitación
clave
algoritmo
banquero
requiere
conocimiento
necesida-
des
máximas
recursos
procesos
diseñar
algoritmo
evitar
inter-
bloqueos
requiera
información
Explique
respuesta
16
Analice
cuidado
figura
6-11(b
pide
unidad
conduce
seguro
inseguro
pasa
petición
proviene
17
sistema
procesos
recursos
idénticos
proceso
necesita
máximo
recursos
interbloqueo
Explique
respuesta
18
Considere
problema
procesos
necesita
máximo
recursos
recursos
disponibles
condición
aplicar
sistema
esté
libre
interbloqueos
19
Suponga
proceso
figura
6-12
solicita
unidad
cinta
Conduce
acción
interbloqueo
20
computadora
unidades
cinta
procesos
compiten
proceso
pue-
necesitar
unidades
valores
sistema
libre
interbloqueos
21
algoritmo
banquero
ejecutando
sistema
clases
recursos
procesos
límite
valores
número
operaciones
com-
probar
seguro
proporcional
ma
nb
valores
22
sistema
procesos
recursos
asignables
asignación
actual
necesida-
des
máximas
siguientes
Asignado
Máximo
Disponible
Proceso
Proceso
Proceso
Proceso
valor
menor
seguro
23
eliminar
espera
circular
regla
determine
proceso
de-
recho
recurso
momento
Proporcione
ejemplo
mostrar
restric-
ción
inaceptable
casos
24
procesos
necesitan
registros
base
datos
pide
orden
pide
orden
interbloqueo
obstante
pide
orden
interbloqueo
recursos
posibles
combinaciones
proceso
solicitar
recursos
fracción
to-
das
combinaciones
garantiza
esté
libre
interbloqueo
25
sistema
distribuido
utiliza
buzones
correo
primitivas
IPC
sendy
receive
primitiva
especifica
proceso
recibir
mensajes
bloquea
men-
464
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
465
saje
disponible
proceso
mensajes
espera
procesos
recursos
compartidos
procesos
necesitan
comunicar
frecuencia
cues-
tiones
interbloqueo
Explique
26
sistema
electrónico
transferencia
fondos
cientos
procesos
idénticos
funcio-
nan
proceso
lee
línea
entrada
especifica
monto
dine-
ro
acreditar
monto
restar
bloquea
ambas
cuentas
transfiere
dinero
liberando
bloqueos
termine
procesos
ejecutándose
paralelo
peligro
real
bloqueada
bloquear
bloqueada
proceso
espera
x.
Idee
esquema
evite
interbloqueos
libere
registro
completado
tran-
sacciones
palabras
permiten
soluciones
bloquean
li-
beran
inmediato
bloqueada
27
evitar
interbloqueos
eliminando
condición
contención
espera
tex-
to
propuso
pedir
recurso
proceso
liberar
recursos
contenga
suponiendo
introduce
peligro
obte-
ner
recurso
perder
existentes
procesos
competidores
Propon-
ga
mejora
esquema
28
estudiante
ciencias
computacionales
asignado
trabajar
interbloqueos
piensa
forma
brillante
eliminar
interbloqueos
proceso
solicita
recurso
especi-
fica
límite
tiempo
proceso
bloquea
recurso
disponible
ini-
cia
temporizador
excede
límite
tiempo
proceso
libera
permite
ejecutarse
profesor
calificación
daría
proposición
29
Explique
diferencias
interbloqueo
bloqueo
activo
inanición
30
Cenicienta
Príncipe
divorciando
dividir
propiedad
acordado
al-
goritmo
mañana
enviar
carta
abogado
solicitando
artículo
propiedad
requiere
entregar
cartas
acordado
des-
cubren
solicitado
artículo
enviarán
carta
cancelar
petición
pertenencias
perro
Woofer
casa
Woofer
canario
Tweeter
jaula
Tweeter
animales
adoran
hogares
acordado
cual-
quier
división
propiedad
separe
animal
casa
inválida
división
empezar
cero
Cenicienta
Príncipe
quieren
desesperadamente
Woofer
puedan
salir
vacaciones
separadas
esposo
programado
computadora
per-
sonal
manejar
negociación
regresan
vacaciones
computadoras
negociando
interbloqueo
inanición
Explique
31
estudiante
especialidad
antropología
licenciatura
ciencias
computacionales
em-
barcado
proyecto
investigación
babuinos
africanos
aprender
interbloqueos
estudiante
localiza
cañón
profundo
sujeta
cuerda
babuinos
puedan
cruzar
manos
babuinos
cruzar
tiem-
po
vayan
dirección
babuinos
avanzan
es-
avanzan
oeste
llegan
cuerda
tiempo
producirá
interbloqueo
babuinos
quedarán
atorados
mitad
imposible
babuino
trepe
suspendido
cañón
babuino
desea
cruzar
cañón
comprobar
babuino
cruzando
dirección
opuesta
Escriba
programa
utilice
semáforos
www.FreeLibros.meevite
interbloqueo
preocupe
serie
babuinos
avanzan
detie-
nen
babuinos
avanzan
oeste
tiempo
indefinido
32
Repita
problema
evite
inanición
babuino
desea
cruzar
llega
cuerda
babuinos
cruzando
oeste
espera
cuerda
esté
vacía
permite
babuinos
avanzan
oeste
empiecen
has-
ta
babuino
cruzado
33
Programe
simulación
algoritmo
banquero
programa
recorrer
forma
cíclica
clientes
banco
petición
evalúan
seguro
inseguro
Escriba
registro
peticiones
decisiones
archivo
34
Escriba
programa
implementar
algoritmo
detección
interbloqueos
recur-
sos
tipo
programa
leer
archivo
siguientes
entradas
número
proce-
sos
número
tipos
recursos
número
recursos
tipo
existencia
vector
matriz
asignaciones
actuales
fila
seguida
fila
sucesivo
matriz
peticiones
fila
seguida
fila
sucesivo
salida
programa
deberá
indicar
interbloqueo
sistema
caso
inter-
bloqueo
sistema
programa
deberá
imprimir
identidades
procesos
estén
interbloqueo
35
Escriba
programa
detecte
interbloqueo
sistema
utilizar
gráfico
asig-
nación
recursos
programa
deberá
leer
archivo
siguientes
entradas
número
pro-
cesos
número
recursos
proceso
leer
números
número
recursos
contiene
momento
IDs
recursos
contiene
número
recursos
solicita
momento
IDs
recursos
solicitando
salida
programa
indicar
interbloqueo
sistema
caso
interbloqueo
sistema
programa
imprimir
identidades
procesos
interbloqueo
466
INTERBLOQUEOS
CAPÍTULO
www
FreeLibros.me7
SISTEMAS
OPERATIVOS
MULTIMEDIA
467
películas
digitales
clips
video
música
convirtiendo
forma
común
presentar
información
entretenimiento
computadora
archivos
audio
video
almacenar
disco
reproducirse
pedido
em-
bargo
características
distintas
archivos
texto
tradicionales
fue-
ron
diseñados
sistemas
archivos
actuales
consecuencia
necesitan
tipos
sistemas
archivos
manejarlos
proceso
almacenar
reproducir
audio
vi-
deo
impone
demandas
programador
partes
sistema
operativo
ca-
pítulo
estudiaremos
cuestiones
implicaciones
sistemas
operativos
diseñados
manejar
multimedia
general
películas
digitales
entran
clasificación
multimedia
sentido
literal
significa
medios
definición
libro
trabajo
multimedia
contiene
medios
texto
imágenes
figuras
mayoría
perso-
nas
utilizan
término
multimedia
indicar
documento
contiene
medios
continuos
medios
reproducirse
intervalo
libro
utilizare-
mos
término
multimedia
sentido
término
mbiguo
video
sentido
técnico
porción
ima-
gen
película
contraste
porción
sonido
cámaras
video
te-
levisiones
conectores
etiquetado
video
audio
señales
separadas
término
video
digital
refiere
general
producto
completo
imagen
sonido
continuación
utilizaremos
término
película
re-
ferirnos
producto
completo
película
sentido
necesita
www.FreeLibros.mefilme
horas
producido
estudio
Hollywood
costo
excede
Boeing
747
definición
clip
noticias
30
segundos
transmitido
flujo
continuo
página
inicio
CNN
Internet
película
cier-
to
utilizaremos
término
clips
video
referencia
películas
cortas
7.1
INTRODUCCIÓN
MULTIMEDIA
entrar
detalles
tecnología
multimedia
utilidad
pa-
labras
actual
futuro
establecer
escenario
computadora
multime-
significa
reproducir
película
pregrabada
DVD
Disco
versátil
digital
DVDs
discos
ópticos
discos
blanco
policarbonato
120
mm
plás-
tico
CD-ROMs
grabados
densidad
obtiene
capacidad
GB
17
GB
dependiendo
formato
candidatos
tratando
sucesor
DVD
conoce
Blu-ray
contiene
25
GB
formato
capa
50
GB
formato
doble
capa
conoce
HD
DVD
contiene
15
GB
formato
capa
30
GB
formato
doble
capa
formato
respaldado
consorcio
distinto
compañías
computadoras
películas
apariencia
industrias
electrónica
entretenimiento
sien-
ten
nostalgia
guerras
formatos
décadas
1970
1980
Betamax
VHS
decidieron
repetirlas
duda
guerra
formatos
retrasará
popularidad
am-
bos
sistemas
años
medida
consumidores
esperen
ganar
multimedia
descargar
clips
video
Internet
páginas
Web
elementos
clic
descargar
películas
cortas
sitios
Web
YouTube
miles
clips
video
disponibles
medida
tecnologías
distribu-
ción
veloces
TV
cable
ADSL
Asymmetric
Digital
Suscriber
Line
Línea
sus-
criptor
digital
asimétrica
vayan
dominando
mercado
conviertan
norma
seguir
presencia
clips
video
Internet
aumentará
vertiginosamente
área
soportar
multimedia
creación
videos
Exis-
ten
sistemas
edición
multimedia
obtener
rendimiento
necesitan
ejecutar
sistema
operativo
multimedia
trabajo
tradicional
campo
importante
multimedia
juegos
computadora
juegos
reproducen
clips
video
describir
ti-
po
acción
general
clips
cortos
correcto
selecciona
for-
ma
dinámica
dependiendo
acción
usuario
sofisticados
juego
generar
cantidades
animación
ma-
nejar
video
generado
programa
distinto
mostrar
película
santo
grial
mundo
multimedia
video
demanda
refiere
capacidad
consumidores
seleccionar
película
hogar
usando
control
remoto
televisión
ratón
verla
televisión
monitor
computadora
instante
ha-
bilitar
video
demanda
necesita
infraestructura
especial
figura
7-1
infraestructuras
posibles
video
demanda
contiene
componentes
esencia-
servidores
video
red
distribución
aparato
conectado
televisor
468
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.1
INTRODUCCIÓN
MULTIMEDIA
469
decodificar
señal
servidor
video
poderosa
computadora
almacena
pe-
lículas
sistema
archivos
reproduce
demanda
mainframes
utilizan
servidores
video
proceso
conectar
ejemplo
1000
discos
exten-
sos
mainframe
simple
conectar
1000
discos
tipo
com-
putadora
personal
problema
serio
material
siguientes
secciones
acerca
servidores
video
sistemas
operativos
Red
distribución
Red
distribución
Fibra
Servidor
video
Servidor
video
Par
trenzado
cobre
Caja
unión
Caja
unión
Casa
Cable
coaxial
TV
cable
Fibra
Figura
7-1
Video
demanda
utiliza
distintas
tecnologías
distribución
local
ADSL
TV
cable
red
distribución
usuario
servidor
video
capaz
transmitir
da-
tos
alta
velocidad
tiempo
real
diseño
dichas
redes
interesante
complejo
alcance
libro
diremos
acerca
recalcar
redes
utilizan
fibra
óptica
servidor
video
caja
unión
vecindario
viven
clientes
sistemas
ADSL
proporcionados
www.FreeLibros.melas
compañías
telefónicas
línea
telefónica
par
trenzado
existente
provee
kilómetro
transmisión
sistemas
TV
cable
proporcionados
operadores
cable
cableado
TV
cable
existente
utiliza
distribución
local
ADSL
ventaja
proporcionar
usuario
canal
dedicado
garantiza
ancho
banda
megabits
seg
limitaciones
ca-
ble
telefónico
existente
TV
cable
utiliza
cable
coaxial
alto
ancho
banda
gigabits-
/seg
usuarios
compartir
cable
dada
disputa
produce
ancho
banda
garantizado
usuario
competir
compañías
cable
compañías
telefónicas
empezando
instalar
fibra
ho-
gares
individuales
cuyo
caso
ADSL
fibra
ancho
banda
cable
pieza
sistema
decodificador
set-top
box
termina
línea
ADSL
cable
TV
dispositivo
computadora
normal
chips
especiales
decodificación
descompresión
video
mínimo
contiene
CPU
RAM
ROM
interfaz
ADSL
cable
conector
televisión
alternativa
decodificador
utilizar
PC
existente
cliente
mostrar
pelícu-
monitor
interesante
razón
consideran
decodificadores
mayoría
consumidores
tengan
computadora
operadores
video
demanda
esperan
personas
vean
películas
salas
general
contie-
nen
TV
raras
computadora
perspectiva
técnica
utilizar
compu-
tadora
personal
aparato
dedicado
sentido
potente
disco
duro
resolución
pantalla
forma
frecuen-
cia
haremos
distinción
servidor
video
proceso
cliente
extremo
usuario
decodifica
visualiza
película
términos
diseño
sistema
importa
proceso
cliente
ejecuta
aparato
dedicado
PC
sistema
edi-
ción
video
escritorio
procesos
ejecutan
equipo
seguiremos
uti-
lizando
terminología
servidor
cliente
proceso
llevando
cabo
función
Volviendo
concepto
multimedia
características
clave
comprenderse
lidiar
exitosa
multimedia
utiliza
velocidades
datos
extremo
altas
multimedia
requiere
reproducción
tiempo
real
altas
velocidades
datos
provienen
naturaleza
información
visual
acústica
ojo
oído
procesar
cantidades
prodigiosas
información
alimen-
tarse
velocidad
producir
experiencia
observación
aceptable
figura
7-2
lis-
velocidades
datos
fuentes
multimedia
digital
dispositivos
hardware
comunes
Analizaremos
formatos
codificación
ca-
pítulo
debemos
altas
velocidades
transmisión
datos
requeridas
multimedia
necesidad
comprensión
cantidad
almacenamiento
requerida
ejemplo
película
HDTV
horas
comprimir
llena
archivo
570
GB
servidor
470
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.1
INTRODUCCIÓN
MULTIMEDIA
471
demanda
impone
multimedia
sistema
necesidad
enviar
datos
tiempo
real
porción
video
película
digital
consiste
número
cuadros
sistema
NTSC
utiliza
Norteamérica
Sudamérica
Japón
opera
30
cua-
dros
seg
29.97
purista
sistemas
PAL
SECAM
utilizan
ma-
yoría
resto
mundo
operan
25
cuadros
seg
25.00
purista
cuadros
enviar
intervalos
precisos
33.3
mseg
40
mseg
respectivamente
película
verá
entre-
cortada
Oficialmente
NTSC
significa
Comité
Nacional
Estándares
Televisión
National
Televi-
sion
Standards
Committee
mala
forma
color
adoptó
estándar
inventó
televisión
color
pie
broma
industria
realidad
significa
Color
Never
Twice
the
Same
Color
PAL
significa
Línea
Fase
Alternante
Phase
Alternating
Line
Técnicamente
sistemas
SECAM
utiliza
Francia
intención
proteger
fabricantes
televisiones
franceses
competencia
extran-
jera
significa
Color
Secuencial
Memoria
SEquentiel
Couleur
Avec
Memoire
SECAM
tam-
bién
utiliza
Europa
introdujo
televisión
gobiernos
comunistas
querían
evitar
vieran
televisión
alemana
PAL
eligieron
sistema
incompatible
oído
sensible
ojo
variación
milisegundos
tiempos
respuesta
notar
variabilidad
velocidades
entrega
conoce
fluctuación
vinculada
estrictamente
rendimiento
fluctuación
retraso
red
distribución
figura
7-1
retrasa
forma
uniforme
bits
exactamente
5.000
seg
película
empezará
pe-
ro
verá
retrasa
cuadros
azar
valor
100
200
mseg
película
verá
filme
antiguo
Charlie
Chaplin
importar
estelarice
Fuente
Mbps
GB
hra
Dispositivo
Mbps
Teléfono
PCM
0.064
0.03
Fast
Ethernet
100
Música
MP3
0.14
0.06
Disco
EIDE
133
CD
audio
1.4
0.62
Red
ATM
OC-3
156
Película
MPEG-2
640
480
1.76
IEEE
1394b
FireWire
800
Cámara
video
digital
720
480
25
11
Gigabit
Ethernet
1000
TV
compresión
640
480
221
97
Disco
SATA
3000
HDTV
comprimir
1280
720
648
288
Disco
SCSI
Ultra-640
5120
Figura
7-2
velocidades
datos
dispositivos
multimedia
alto
rendimiento
Observe
Mbps
10
bits
seg
GB
230
bytes
video
almacene
1000
películas
necesitará
570
TB
espacio
disco
cantidad
trivial
estándares
actuales
debemos
com-
presión
datos
hardware
actual
par
velocidades
tranmisión
datos
producen
capítulo
analizaremos
compresión
video
www
FreeLibros.meLas
propiedades
tiempo
real
requeridas
reproducir
multimedia
acepta-
ble
describen
parámetros
calidad
servicio
Incluyen
ancho
ban-
promedio
disponible
ancho
banda
pico
disponible
retraso
mínimo
máximo
conjunto
vinculan
fluctuación
probabilidad
pérdida
bits
ejemplo
operador
red
ofrecer
servicio
garantizara
ancho
banda
promedio
Mbps
99%
retrasos
transmisión
intervalo
105
110
mseg
velocidad
pérdida
bits
10
/H1100210
estaría
películas
MPEG-2
operador
ofrecer
ser-
vicio
económico
menor
grado
ancho
banda
promedio
Mbps
ejemplo
ADSL
cuyo
caso
calidad
tendría
comprometerse
forma
reduciendo
resolución
disminuyendo
velocidad
cuadros
descartando
información
colores
mostrando
película
blanco
negro
común
proveer
garantías
calidad
servicio
reservar
capaci-
dad
adelantado
cliente
recursos
reservados
incluyen
CPU
búferes
memoria
capacidad
transferencia
disco
ancho
banda
red
llega
cliente
desea
observar
película
servidor
video
red
calcula
capacidad
suficiente
cliente
necesario
rechazar
cliente
evitar
degra-
servicio
proporciona
clientes
actuales
consecuencia
servidores
multimedia
necesitan
esquemas
reservación
recursos
algoritmo
control
admisión
decidir
manejar
trabajo
7.2
ARCHIVOS
MULTIMEDIA
mayoría
sistemas
archivo
texto
ordinario
consiste
secuencia
lineal
by-
tes
estructura
sistema
operativo
conozca
preocupe
multimedia
situación
complicada
empezar
video
audio
completamente
capturan
distintos
dispositivos
chip
CCD
comparación
micrófono
estructura
interna
distinta
video
25
30
cuadros
seg
audio
44,100
muestras-
/seg
reproducen
distintos
dispositivos
monitor
comparación
bocinas
películas
Hollywood
orientadas
audiencia
mundial
mayoría
entiende
inglés
formas
lidiar
punto
países
produce
pista
sonido
adicional
voces
doblan
lenguaje
local
efec-
tos
sonido
Japón
televisiones
canales
sonido
espectador
escuchar
filmes
extranjeros
lenguaje
original
japonés
utiliza
botón
control
remoto
seleccionar
lenguaje
países
utiliza
pista
sonido
original
subtítulos
lenguaje
local
películas
TV
ofrecen
subtítulos
inglés
permitir
personas
inglesa
discapacidad
auditiva
puedan
disfrutar
película
resul-
tado
neto
película
digital
consistir
realmente
archivos
archivo
video
archivos
audio
archivos
texto
subtítulos
lenguajes
DVDs
capacidad
almacenar
32
archivos
lenguajes
subtítulos
fi-
gura
7-3
muestra
conjunto
simple
archivos
multimedia
capítulo
ex-
plicaremos
significado
adelanto
rápido
atraso
rápido
472
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.2
ARCHIVOS
MULTIMEDIA
473
consecuencia
sistema
archivos
necesita
subarchivos
archivo
esquema
administrar
subarchivo
archivo
tradicional
ejemplo
nodo-i
bloques
estructura
datos
liste
subarchivos
archivo
multimedia
forma
inventar
tipo
nodo-i
dimensiones
columna
liste
bloques
subarchivo
gene-
ral
organización
espectador
seleccionar
forma
dinámica
pistas
audio
subtítulos
utilizar
momento
película
casos
necesita
forma
mantener
sincronizados
subarchi-
vos
reproduzca
pista
audio
seleccionada
permanezca
sincronía
video
audio
video
desfasan
ligeramente
espectador
escuchar
palabras
actor
muevan
labios
molesto
comprender
forma
organizan
archivos
multimedia
necesario
comprender
funcionan
audio
video
digital
detalle
veremos
in-
troducción
temas
7.2.1
Codificación
video
ojo
humano
propiedad
proyecta
imagen
retina
retiene
du-
rante
número
milisegundos
deteriorarse
proyecta
secuencia
imáge-
nes
50
imágenes
seg
ojo
viendo
imágenes
discretas
14
325
678
Hello
Bob
Hello
Alice
Nice
day
Sure
is
How
are
you
Great
And
you
Good
Dag
Bob
Dag
Alice
Mooie
dag
Jazeker
Hoe
gaat
het
Prima
jij
Goed
Video
Audio
inglés
Audio
francés
Audio
alemán
Subtítulos
inglés
Subtítulos
holandés
Adelanto
rápido
Atraso
rápido
Cuadro
Figura
7-3
película
consistir
archivos
www.FreeLibros.melos
sistemas
imágenes
movimiento
basadas
video
filme
explotan
principio
producir
películas
movimiento
comprender
sistemas
video
fácil
empezar
televisión
blanco
ne-
gro
simple
anticuada
representar
imagen
bidimensional
volta-
je
unidimensional
función
tiempo
cámara
pasa
haz
electrones
rápidamente
imagen
lentitud
recorre
abajo
grabando
intensi-
dad
luz
medida
avanza
barrido
conoce
cuadro
haz
re-
gresa
posición
original
intensidad
función
tiempo
transmite
receptores
repiten
proceso
exploración
reconstruir
imagen
patrón
exploración
utilizado
tan-
to
cámara
receptor
muestra
figura
7-4
información
adicional
cámaras
CCD
integran
explorar
cámaras
monitores
CRT
ex-
ploran
474
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Línea
exploración
11
13
15
483
Tiempo
campo
empieza
línea
exploración
pinta
pantalla
Retrazado
horizontal
Retrazado
vertical
Figura
7-4
patrón
exploración
utilizado
video
televisión
NTSC
parámetros
exactos
exploración
varían
país
NTSC
525
líneas
ex-
ploración
proporción
aspecto
horizontal
vertical
4:3
30
realidad
29.97
cuadros-
/seg
sistemas
europeos
PAL
SECAM
625
líneas
exploración
proporción
aspecto
4:3
25
cuadros
seg
sistemas
muestran
primeras
lí-
neas
superiores
inferiores
aproximar
imagen
rectangular
CRTs
redondos
originales
muestran
483
525
líneas
exploración
NTSC
576
625
líneas
exploración
PAL
SECAM
25
cuadros
seg
suficiente
capturar
movimiento
uniforme
velocidad
cuadro
personas
especial
adultos
mayores
percibirán
imagen
parpadea
imagen
borrado
retina
aparezca
imagen
www
FreeLibros.meSECCIÓN
7.2
ARCHIVOS
MULTIMEDIA
475
aumentar
velocidad
cuadro
requeriría
escaso
ancho
ban-
utiliza
método
distinto
mostrar
líneas
exploración
orden
abajo
muestran
líneas
exploración
impares
pares
medios
cuadros
conoce
campo
experimentos
demostrado
personas
notan
parpadeo
25
cuadros
seg
notaron
50
campos
seg
técnica
conoce
entrelazado
televisión
video
entrelazado
progresivo
video
color
utiliza
patrón
exploración
monocromático
blanco
ne-
gro
mostrar
imagen
haz
móvil
utilizan
mueven
unísono
utiliza
haz
colores
primarios
aditivos
rojo
verde
azul
RGB
técnica
funciona
color
construir
superposición
lineal
rojo
verde
azul
intensidades
apropiadas
transmisión
canal
señales
color
combinar
señal
com-
puesta
transmisiones
color
receptores
blanco
negro
sistemas
combinan
forma
lineal
señales
RGB
señal
luminancia
brillo
crominan-
cia
color
utilizan
distintos
coeficientes
construir
señales
RGB
Curiosamente
ojo
sensible
señal
luminancia
crominan-
cia
necesitan
transmitir
tanta
precisión
consecuencia
señal
lu-
minancia
transmitir
frecuencia
antigua
señal
blanco
negro
recibir
televisores
blanco
negro
señales
crominancia
trans-
miten
bandas
estrechas
frecuencias
altas
televisores
perillas
controles
eti-
quetadas
brillo
tinte
saturación
brillo
tinte
color
controlar
señales
separado
necesario
comprender
luminancia
crominancia
entender
funciona
compresión
video
visto
video
análogo
procedamos
describir
video
digital
repre-
sentación
simple
video
digital
secuencia
cuadros
consis-
rejilla
rectangular
elementos
imagen
píxeles
video
color
utilizan
bits
pixel
colores
RGB
obtienen
24
16
millones
co-
lores
suficiente
ojo
humano
alcanza
distinguir
colores
me-
cantidad
producir
movimiento
uniforme
video
digital
video
análogo
mostrar
25
cuadros
seg
monitores
computadora
calidad
vuelven
explorar
pantalla
imágenes
almacenadas
RAM
video
75
necesita
entrelazado
consecuencia
monitores
computadora
utilizan
exploración
progresiva
volver
pintar
redibujar
cua-
dro
seguidas
suficiente
eliminar
parpadeo
palabras
uniformidad
movimiento
determina
base
número
dis-
tintas
imágenes
parpadeo
número
pinta
pan-
talla
parámetros
distintos
imagen
inmóvil
pinte
20
cuadros
seg
mostrará
movimiento
entrecortado
parpadeará
cuadro
desaparecerá
retina
aparezca
película
20
cuadros
distintos
pinta
seguidas
80
Hz
parpadeará
movimiento
aparecerá
entrecortado
www
FreeLibros.meLa
importancia
parámetros
vuelve
clara
consideramos
ancho
ban-
requerido
transmitir
video
digital
red
monitores
computadora
utilizan
proporción
aspecto
4:3
utilizar
tubos
imagen
económicos
producidos
masa
diseñados
mercado
televisiones
consumidor
configuraciones
co-
munes
640
/H11003
480
VGA
800
/H11003
600
SVGA
1024
/H11003
768
XGA
1600
/H11003
1200
UXGA
pantalla
UXGA
24
bits
píxel
25
cuadros
seg
necesita
alimentarse
1.2
Gbps
pantalla
VGA
necesita
184
Mbps
conveniente
duplicar
proporciones
evi-
tar
parpadeo
solución
transmitir
25
cuadros
seg
computadora
alma-
cene
pinte
televisión
transmisión
utiliza
estrategia
televisores
memoria
caso
señales
análogas
alma-
cenar
RAM
convertirlas
formato
digital
requiere
hardware
adi-
cional
consecuencia
necesita
entrelazado
televisión
transmisión
video
digital
7.2.2
Codificación
audio
onda
audio
sonido
onda
presión
acústica
unidimensional
onda
acústica
entra
oído
tímpano
vibra
pequeños
huesos
oído
interno
vibren
jun-
to
enviando
pulsos
nerviosos
cerebro
espectador
percibe
pulsos
sonido
similar
onda
acústica
golpea
micrófono
genera
señal
eléctrica
representa
amplitud
sonido
función
tiempo
rango
frecuencia
oído
humano
20
Hz
20,000
Hz
animales
espe-
cial
perros
escuchar
frecuencias
altas
oído
escucha
forma
logarítmica
proporción
sonidos
amplitudes
expresa
convencional
dB
decibeles
fórmula
dB
/H1100520
log
10(A
definimos
límite
inferior
audibilidad
aproximada
presión
0.0003
dinas
cm
onda
senoidal
kHz
dB
conversación
ordinaria
50
dB
umbral
dolor
120
dB
rango
dinámico
factor
millón
evitar
confusión
valores
mencionados
amplitudes
utilizáramos
ni-
vel
potencia
proporcional
cuadrado
amplitud
coeficiente
logaritmo
10
20
ondas
audio
convertir
formato
digital
ADC
Analog
Digi-
Converter
Convertidor
análogo
digital
ADC
recibe
voltaje
eléctrico
entrada
genera
número
binario
salida
figura
7-5(a
ejemplo
onda
se-
noidal
representar
señal
forma
digital
muestrearla
∆T
segundos
muestra
alturas
barras
figura
7-5(b
onda
sonido
onda
senoidal
pura
superposición
ondas
senoidales
componente
frecuen-
cia
alta
presente
basta
muestreos
frecuencia
2f
resul-
476
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.2
ARCHIVOS
MULTIMEDIA
477
tado
demostrado
forma
matemática
Bell
Labs
físico
llamado
Harry
Nyquist
1924
conoce
teorema
Nyquist
caso
muestreos
seguido
frecuencias
altas
detectar
muestreo
presentes
1.00
0.75
0.50
0.25
0.25
0.50
0.75
1.00
TTT
TFigura
7-5
onda
senoidal
Muestreo
onda
senoidal
Cuantifica-
ción
muestras
bits
muestras
digitales
exactas
muestras
figura
7-5(c
permiten
nue-
ve
valores
/H110021.00
/H110011.00
incrementos
0.25
consecuencia
necesitan
bits
re-
presentarlos
muestra
bits
permitiría
256
valores
distintos
muestra
16
bits
permitiría
65,536
valores
distintos
error
introducido
número
finito
bits
muestreo
conoce
ruido
cuantificación
oído
detecta
ejemplos
conocidos
sonido
muestreado
teléfono
discos
compactos
au-
modulación
código
pulsos
utiliza
sistema
telefónico
muestras
bits
Norteamérica
Japón
bits
Europa
8000
sistema
produce
veloci-
dad
datos
56,000
bps
64,000
bps
8000
muestras
seg
pierden
frecuencias
ma-
yores
kHz
CDs
audio
digitales
velocidad
muestreo
44,100
muestras
seg
sufi-
ciente
capturar
frecuencias
22,050
Hz
personas
malo
pa-
ra
perros
muestras
16
bits
lineales
rango
amplitudes
muestras
16
bits
permiten
65,536
valores
distintos
rango
dinámico
oído
millón
mide
incrementos
soni-
do
audible
pequeño
ende
utilizar
16
bits
muestra
introduce
ruido
cuantificación
cubre
rango
dinámico
completo
supone
CDs
lastimar
44,100
muestras
seg
16
bits
CD
audio
necesita
ancho
ban-
705.6
Kbps
monoaural
1,411
Mbps
estéreo
vea
figura
7-2
compresión
audio
base
modelos
psicoacústicos
forma
funciona
oído
huma-
compresión
10x
utiliza
sistema
MPEG
nivel
MP3
reproduc-
tores
música
portátiles
formato
comunes
años
recientes
sonido
digitalizado
procesado
facilidad
software
computadoras
docenas
programas
computadoras
personales
permitan
usuarios
grabar
mostrar
editar
mezclar
almacenar
ondas
sonido
fuentes
www
FreeLibros.me478
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
grabaciones
ediciones
sonido
profesionales
digitales
actualidad
análogo
de-
saparece
completo
7.3
COMPRESIÓN
VIDEO
punto
obvio
manipulación
material
multimedia
forma
descomprimi-
completamente
consideración
única
esperanza
compresión
masiva
fortuna
cuerpo
investigación
décadas
descubierto
técnicas
compresión
algoritmos
factible
transmi-
sión
multimedia
siguientes
secciones
estudiaremos
métodos
comprimir
datos
multimedia
especial
imágenes
obtener
detalles
vea
Fluckiger
1995
Steinmetz
Nahrstedt
1995
sistemas
compresión
requieren
algoritmos
comprimir
datos
origen
descomprimirlos
destino
literatura
algoritmos
co-
noce
algoritmos
codificación
decodificación
respectivamente
utilizare-
mos
terminología
algoritmos
asimetrías
importantes
comprender
lugar
aplicaciones
documento
multimedia
película
codifica
almacena
servidor
multimedia
decodificará
miles
vean
clientes
asimetría
indica
aceptable
algoritmo
codificación
len-
to
requerir
hardware
costoso
algoritmo
decodificación
rápido
re-
quiera
hardware
costoso
multimedia
tiempo
real
conferencias
video
aceptable
codificación
lenta
codificación
ocurrir
instante
tiem-
po
real
asimetría
proceso
codificación
decodificación
necesita
100%
invertible
comprimir
archivo
transmitirlo
descomprimirlo
usuario
es-
pera
original
precisión
bit
multimedia
reque-
rimiento
general
aceptable
señal
video
codificación
decodificación
distinta
señal
original
salida
decodificada
exacta-
mente
entrada
original
sistema
pérdidas
sistemas
com-
presión
utilizados
multimedia
pérdidas
proporcionan
compresión
7.3.1
estándar
JPEG
estándar
JPEG
Joint
Photographic
Experts
Group
Grupo
expertos
unidos
fotografía
comprimir
imágenes
fijas
tono
continuo
fotografías
desarrollado
exper-
tos
fotográficos
trabajaban
auspicios
unidos
ITU
ISO
IEC
cuerpo
están-
dares
importante
multimedia
aproximación
estándar
multimedia
imágenes
movimiento
MPEG
codificación
JPEG
cuadro
separado
características
adicionales
compresión
cuadros
compen-
www
FreeLibros.meSECCIÓN
7.3
COMPRESIÓN
VIDEO
479
sación
movimiento
JPEG
define
Estándar
Internacional
10918
modos
opciones
preocuparemos
forma
utiliza
video
RGB
24
bits
omitiremos
detalles
paso
codificación
imagen
JPEG
preparación
bloques
aras
simplicidad
suponer
entrada
JPEG
imagen
RGB
640
/H11003480
24
bits-
/pixel
muestra
figura
7-6(a
luminancia
crominancia
proporciona
compresión
luminancia
señales
crominancia
calculan
valores
RGB
NTSC
conocen
respectivamente
PAL
fórmulas
distintas
continuación
utilizaremos
nombres
NTSC
algoritmo
compresión
480
640
RGB
YI
640
480
240
320
240
bloque
Bloque
4799
Pixel
bits
Pixel
24
bits
Figura
7-6
Datos
entrada
RGB
preparación
bloques
construyen
matrices
separadas
elementos
rango
255
continuación
promedian
bloques
píxeles
matrices
reducirlas
320
/H11003240
reducción
pérdidas
ojo
detecta
responde
luminancia
crominancia
comprime
datos
factor
Aho-
ra
resta
128
elemento
matrices
rango
últi-
mo
matriz
divide
bloques
/H110038
matrix
4800
bloques
1200
bloques
muestra
figura
7.6(b
paso
JPEG
aplicar
DCT
Discrete
Cosine
Transformation
Transformación
coseno
discreta
7200
bloques
separado
salida
DCT
ma-
triz
/H110038
coeficientes
DCT
elemento
DCT
0,0
valor
promedio
bloque
de-
elementos
indican
espectral
presente
frecuencia
espacial
lectores
familiarizados
transformadas
Fourier
DCT
tipo
transformada
Fourier
espacial
bidimensional
teoría
DCT
pérdidas
práctica
números
punto
flotante
funciones
trascendentales
introduce
error
redondeo
produce
pequeña
cantidad
pérdida
información
general
elementos
dete-
rioran
rápidamente
distancia
origen
0,0
sugiere
figura
7-7(b
completa
DCT
JPEG
avanza
paso
conocido
cuantificación
coeficientes
DCT
importantes
eliminan
transformación
pérdidas
realiza
www
FreeLibros.me480
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Amplitud
DCT
xF
Fy
Figura
7-7
bloque
matriz
Y.
coeficientes
DCT
dividiendo
coeficientes
matriz
DCT
/H110038
peso
toma
tabla
pesos
transformación
obstante
pesos
aumentan
forma
abrupta
origen
frecuencias
espaciales
altas
decaen
rapidez
figura
7-8
muestra
ejemplo
paso
matriz
DCT
inicial
tabla
cuantificación
resultado
obtiene
dividir
elemento
DCT
elemen-
to
tabla
cuantificación
correspondiente
valores
tabla
cuantificación
forman
estándar
JPEG
aplicación
suministrar
tabla
cuantificación
otor-
gándole
habilidad
controlar
intercambio
pérdida-compresión
150
92
52
12
80
75
38
40
36
26
14
10
Coeficientes
DCT
150
92
26
80
75
19
20
18
13
Coeficientes
cuantificados
16
32
64
16
32
64
16
32
64
16
32
64
16
32
64
16
16
16
16
16
16
32
64
32
32
32
32
32
32
32
64
64
64
64
64
64
64
64
64
Tabla
cuantificación
Figura
7-8
Cálculo
coeficientes
DCT
cuantificados
paso
reduce
valor
0,0
bloque
esquina
superior
izquierda
sustituir-
cantidad
difiere
elemento
correspondiente
bloque
es-
tos
elementos
promedios
bloques
respectivos
cambiar
lentitud
obtener
valores
diferenciales
reducir
mayoría
valores
pequeños
calculan
diferenciales
valores
valores
0,0
conocen
componentes
DC
valores
componentes
AC
www
FreeLibros.meSECCIÓN
7.3
COMPRESIÓN
VIDEO
481
paso
linealiza
64
elementos
aplica
codificación
longitud
ejecución
lista
explorar
bloque
izquierda
derecha
abajo
ceros
concentrarán
punto
utiliza
patrón
exploración
zigzag
mues-
tra
figura
7-9
ejemplo
patrón
zigzag
produce
instancia
38
ceros
con-
secutivos
matriz
cadena
reducir
indique
38
ceros
150
92
26
80
75
19
20
18
13
Figura
7-9
orden
transmiten
valores
cuantificados
lista
números
representa
imagen
espacio
transformación
paso
utiliza
codificación
Huffman
números
almacenamiento
transmisión
JPEG
parecer
complicado
produce
compresión
20:1
utiliza
ampliamente
decodificar
imagen
JPEG
requiere
ejecutar
al-
goritmo
sentido
inverso
JPEG
simétrico
requiere
tiempo
decodificar
imagen
codificarla
7.3.2
estándar
MPEG
llegado
meollo
asunto
estándares
MPEG
Motion
Picture
Expert
Groups
Grupo
expertos
películas
principales
algoritmos
utilizados
comprimir
videos
estándares
internacionales
1993
MPEG-1
Estándar
Internacio-
nal
11172
diseñó
salida
calidad
grabadora
video
352
240
NTSC
uti-
lizando
velocidad
bits
1.2
Mbps
MPEG-2
Estándar
Internacional
13818
diseñó
comprimir
video
calidad
transmisión
Mbps
pudiera
caber
canal
transmisión
NTSC
PAL
Ambas
versiones
aprovechan
tipos
redundancias
películas
espa-
cial
temporal
redundancia
espacial
utilizar
codificar
cuadro
separa-
do
JPEG
obtener
compresión
adicional
aprovechar
www
FreeLibros.me482
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
cuadros
consecutivos
idénticos
redundancia
temporal
sistema
DV
Video
Di-
gital
utilizan
cámaras
video
utiliza
esquema
parecido
JPEG
codificación
cabo
tiempo
real
rápido
codificar
cuadro
separado
consecuencias
decisión
figura
7-2
cámaras
video
digitales
velocidad
datos
menor
video
comprimir
lejos
MPEG-2
comparación
honesta
cámaras
video
DV
muestrean
luminancia
bits
señal
crominancia
bits
formas
factor
compresión
utilizar
codificación
similar
JPEG
escenas
cámara
fondo
rígidamente
estacionarios
ac-
tores
moviendo
lentitud
píxeles
idénticos
cuadro
habría
restar
cuadro
ejecutar
JPEG
diferencia
escenas
cámara
mueve
acerca
aleja
lentamente
técnica
fallas
necesita
forma
compensar
movimiento
MPEG
principal
diferencia
MPEG
JPEG
salida
MPEG-2
consiste
tipos
distintos
cuadros
procesados
programa
visor
Cuadros
intracodificados
imágenes
fijas
autocontenidas
codificadas
JPEG
Cuadros
predictivos
diferencia
cuadro
bloque
bloque
Cuadros
bidireccionales
diferencias
cuadro
cuadros
imágenes
fijas
codificadas
JPEG
utilizan
luminancia
resolución
completa
crominancia
resolución
media
eje
ne-
cesario
cuadros
aparezcan
flujo
salida
forma
periódica
razones
lugar
MPEG
utilizar
transmisiones
televisión
espectadores
sintonizan
voluntad
cuadros
dependieran
predecesores
regresar
pri-
mer
cuadro
cualquiera
perdiera
cuadro
decodificar
cuadros
sub-
siguientes
haría
imposible
espectadores
sintonizaran
película
empezado
lugar
recibiera
cuadro
error
continuar
decodificación
tercer
lugar
cuadros
adelanto
atraso
rápido
decodifi-
cador
tendría
calcular
cuadro
pasara
valor
completo
cua-
dro
detuviera
cuadros
avanzar
retroceder
encontrar
cuadro
empezar
razones
cuadros
insertan
salida
contrario
cuadros
codifican
diferencias
cuadros
basan
idea
macrobloques
cubren
16
/H1100316
píxeles
espacio
luminancia
/H110038
píxeles
espa-
cio
crominancia
codificar
macrobloque
busca
cuadro
distinto
figura
7-10
muestra
ejemplo
utilidad
cuadros
P.
cuadros
consecutivos
fondo
difieren
posición
persona
Di-
chas
escenas
comunes
cámara
fija
trípode
actores
mueven
alrede-
www
FreeLibros.meSECCIÓN
7.3
COMPRESIÓN
VIDEO
483
dor
macrobloques
contienen
escena
fondo
coincidirán
exactitud
contienen
persona
estarán
desplazados
posición
canti-
dad
desconocida
rastrearse
Figura
7-10
cuadros
video
consecutivos
estándar
MPEG
especifica
buscar
buscar
coincidencia
cuente
Depende
implementación
ejemplo
implemen-
tación
buscar
macrobloque
posición
actual
cuadro
posiciones
desplazan
distancia
∆x
dirección
±∆y
dirección
y.
po-
sición
calcular
número
coincidencias
matriz
luminancia
posición
puntuación
alta
declararía
ganadora
estuviera
umbral
predefinido
caso
contrario
diría
falta
macrobloque
po-
sible
utilizar
algoritmos
sofisticados
macrobloque
codifica
sacando
diferencia
valor
cuadro
luminancia
ambas
crominancias
matrices
diferencia
suje-
tas
codificación
JPEG
valor
macrobloque
flujo
salida
vec-
tor
movimiento
alejó
macrobloque
posición
dirección
seguido
diferencias
codificadas
JPEG
cuadro
macrobloque
cuadro
valor
actual
codifica
JPEG
cua-
dro
I.
cuadros
similares
permiten
macrobloque
referencia
es-
té
cuadro
subsiguiente
cuadro
P.
libertad
adi-
cional
permite
compensación
mejorada
movimiento
útil
objetos
pasan
objetos
ejemplo
juego
béisbol
terce-
ra
base
lanza
pelota
base
cuadro
pelota
oscurezca
ca-
beza
base
mueve
fondo
cuadro
cabeza
parcialmente
visible
izquierda
pelota
aproximación
cabeza
derive
cuadro
pelota
esté
cabeza
cuadros
per-
miten
basar
cuadro
cuadro
futuro
codificación
cuadro
codificador
necesita
contener
cuadros
deco-
dificados
memoria
tiempo
actual
futuro
simplificar
decodi-
ficación
cuadros
presentes
flujo
MPEG
orden
dependencia
estarlo
orden
visualización
sincronización
perfecta
ve
www.FreeLibros.mevideo
red
requiere
búfer
equipo
usuario
reordenar
cuadros
visualizarlos
forma
apropiada
diferencia
orden
depen-
dencia
visualización
tratar
reproducir
película
orden
inverso
funcionará
considerable
búfer
algoritmos
complejos
filmes
acción
cortes
rápidos
guerra
requieren
cuadros
I.
filmes
director
orientar
cámara
tomar
café
actores
recitan
líneas
historias
amor
utilizar
largos
tirajes
cuadros
cua-
dros
utilizan
capacidad
almacenamiento
cuadros
I.
punto
vista
eficiencia
disco
empresa
opere
servicio
multimedia
tra-
tar
obtener
tantos
clientes
femeninos
7.4
COMPRESIÓN
AUDIO
audio
calidad
CD
requiere
ancho
banda
transmisión
1.411
Mbps
aca-
bamos
duda
requiere
compresión
considerable
transmisión
Inter-
net
práctica
razón
desarrollado
algoritmos
compresión
audio
Probablemente
popular
audio
MPEG
niveles
variantes
MP3
audio
MPEG
nivel
potente
conocido
cantidades
pistas
música
formato
MP3
disponibles
Internet
legales
originado
nume-
rosas
demandas
artistas
propietarios
derechos
autor
MP3
pertenece
porción
audio
estándar
compresión
video
MPEG
compresión
audio
formas
codificación
formas
onda
señal
transforma
matemáticamente
transformada
Fourier
componentes
frecuencia
figura
7-11
muestra
ejemplo
función
tiempo
prime-
ras
15
amplitudes
Fourier
continuación
amplitud
componente
codifica
for-
ma
mínima
objetivo
reproducir
forma
onda
precisión
extremo
menor
cantidad
bits
forma
codificación
perceptual
explota
fallas
sistema
auditivo
humano
codificar
señal
forma
suene
oyente
humano
ve
dis-
tinta
osciloscopio
codificación
perceptual
basa
ciencia
psicoacústica
ma-
nera
gente
percibe
sonido
MP3
basa
codificación
perceptual
propiedad
clave
codificación
perceptual
sonidos
enmascarar
Imagine
transmitiendo
concierto
flauta
vivo
cálido
verano
grupo
trabajadores
cerca
encienden
martillos
neumáticos
empiezan
romper
calle
escuchar
flauta
sonidos
opacados
martillos
neumáticos
fines
transmisión
basta
codificar
banda
frecuencia
utili-
zada
martillos
neumáticos
oyentes
escuchar
flauta
formas
conoce
enmascaramiento
frecuencia
capacidad
sonido
fuer-
banda
frecuencia
ocultar
sonido
suave
banda
frecuencia
se-
ría
audible
ausencia
sonido
fuerte
detengan
martillos
neumáticos
flauta
inaudible
corto
periodo
oído
reduce
484
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.4
COMPRESIÓN
AUDIO
485
011000101
Tiempo
Tiempo
amplitud
rms
11
5234567
11
12
13
148
0.50
0.25
Número
armónico
armónica
armónicas
armónicas
armónicas
12
1234
123
45678
Número
armónico
Figura
7-11
señal
binaria
amplitudes
Fourier
raíz
cuadrada
me-
Aproximaciones
sucesivas
señal
original
www.FreeLibros.menivel
ganancia
empiezan
martillos
tarda
tiempo
finito
volver
subir
nivel
efecto
conoce
enmascaramiento
temporal
concebir
efectos
forma
claramente
cuantitativa
imagine
experimento
persona
salón
silencioso
coloca
audífonos
conectados
tarjeta
sonido
computadora
computadora
genera
onda
senoidal
pura
100
Hz
potencia
baja
pe-
ro
aumenta
forma
gradual
instruye
persona
oprima
tecla
escu-
che
tono
computadora
graba
nivel
potencia
actual
repite
experimento
200
Hz
300
Hz
frecuencias
límite
escucha
humano
pro-
media
gente
gráfica
utilizada
funciones
logarítmicas
potencia
requerida
tono
audible
apariencia
similar
figura
7-12(a
consecuen-
cia
directa
curva
necesario
codificar
frecuencias
cuya
potencia
esté
umbral
audible
ejemplo
potencia
100
Hz
20
dB
fi-
gura
7-12(a
omitirse
salida
pérdida
perceptible
calidad
20
dB
100
Hz
nivel
audibilidad
486
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Señal
enmascara-
miento
150
Hz
Umbral
audibilidad
80
60
40
20
.1
Frecuencia
kHz
Potencia
dB
10
205.5
.2.05
.02
80
60
40
20
Frecuencia
kHz
Señal
enmascarada
Umbral
audibilidad
Potencia
dB
.1
10
205.5
.2.05
.02
Figura
7-12
umbral
audibilidad
función
frecuencia
efecto
enmascaramiento
considere
experimento
computadora
ejecuta
experimento
es-
ta
onda
senoidal
amplitud
constante
ejemplo
150
Hz
superimpuesta
fre-
cuencia
prueba
descubrimos
umbral
audibilidad
frecuencias
cerca
150
Hz
eleva
muestra
figura
7-12(b
consecuencia
observación
registro
señales
enmascaradas
señales
poderosas
bandas
cercanas
frecuencia
omi-
tir
frecuencias
señal
codificada
ahorrando
bits
figura
7-12
señal
125
Hz
omitir
completo
salida
escuchar
diferencia
detenga
señal
poderosa
banda
frecuencia
conocimiento
pro-
piedades
enmascaramiento
temporal
permite
omitir
frecuencias
enmascaradas
intervalo
oído
recupere
esencia
codificación
MP3
aplicar
transformada
Fourier
sonido
obtener
potencia
frecuencia
transmi-
tir
frecuencias
desenmascaradas
codificándolas
menor
cantidad
bits
www
FreeLibros.meSECCIÓN
7.5
PROGRAMACIÓN
PROCESOS
MULTIMEDIA
487
información
antecedente
realiza
codificación
compresión
audio
cabo
muestreo
forma
onda
32
kHz
44.1
kHz
48
kHz
valor
números
enteros
valor
44.1
kHz
utili-
za
CDs
audio
eligió
suficiente
capturar
información
audio
escuchar
oído
humano
muestreo
canales
cualquiera
configuraciones
Monofónico
flujo
entrada
Monofónico
dual
ejemplo
pista
sonido
inglés
japonés
Estéreo
desunido
canal
comprime
separado
Estéreo
unido
explota
completo
redundancia
canales
lugar
selecciona
velocidad
bits
MP3
comprimir
CD
rock
and
roll
sonido
estéreo
96
kbps
pérdida
perceptible
calidad
fa-
náticos
ro
ck
and
roll
conserven
capacidad
auditiva
pérdida
concier-
to
piano
requieren
128
bits
diferencia
proporción
señal
ruido
ro
ck
and
roll
concierto
piano
sentido
ingeniería
seleccionar
velocidades
salida
bajas
aceptar
pérdida
calidad
muestras
procesan
grupos
1152
26
mseg
grupo
pasa
32
filtros
digitales
obtener
32
bandas
frecuencia
mis-
mo
tiempo
entrada
alimenta
modelo
psicoacústico
determinar
frecuencias
enmascaradas
32
bandas
frecuencia
transforma
proveer
re-
solución
espectral
fina
fase
presupuesto
bits
disponibles
divide
bandas
asignan
bits
bandas
potencia
espectral
enmascarada
bits
bandas
desen-
mascaradas
potencia
espectral
bit
asigna
bandas
enmascaradas
úl-
timo
bits
codifican
utilizando
codificación
Huffman
asigna
códigos
cortos
números
aparecen
frecuencia
códigos
largos
ocurren
frecuencia
realidad
detalles
proceso
utilizan
técnicas
reduc-
ción
ruido
antialias
explotar
redundancia
canales
en-
cuentra
allá
alcance
libro
7.5
PROGRAMACIÓN
PROCESOS
MULTIMEDIA
sistemas
operativos
soportan
multimedia
difieren
sistemas
tradicionales
for-
principales
programación
procesos
sistema
archivos
programación
disco
Empeza-
remos
programación
procesos
continuaremos
temas
secciones
subsiguientes
www
FreeLibros.me7.5.1
Procesos
programación
homogéneos
tipo
simple
servidor
video
permite
visualización
número
fijo
películas
utilizan
velocidad
cuadro
resolución
video
velo-
cidad
datos
parámetros
circunstancias
algoritmo
programación
sim-
ple
efectivo
película
proceso
hilo
cuyo
trabajo
leer
película
disco
cuadro
transmitir
cuadro
usuario
procesos
importancia
trabajo
cua-
dro
bloquean
terminar
procesar
cuadro
actual
utilizar
programación
turno
rotatorio
problemas
única
adición
necesaria
algoritmos
programación
están-
mecanismo
sincronización
asegurar
proceso
ejecute
frecuencia
correcta
lograr
sincronización
apropiada
reloj
maestro
emita
pulsos
ejemplo
30
NTSC
pulso
procesos
ejecutan
forma
secuencial
orden
proceso
completa
trabajo
emite
llamada
sistema
suspend
libera
CPU
reloj
maestro
vuelve
emitir
pulso
Cuan-
do
ocurre
procesos
ejecutan
orden
núme-
ro
procesos
suficientemente
pequeño
trabajo
tiempo
cuadro
basta
utilizar
programación
turno
rotatorio
round-robin
7.5.2
Programación
general
tiempo
real
desgracia
modelo
aplica
raras
realidad
número
usuarios
cambia
me-
dida
espectadores
vienen
tamaños
cuadros
varían
natu-
raleza
compresión
video
cuadros
cuadros
distintas
películas
resoluciones
consecuencia
distintos
pro-
cesos
tengan
ejecutarse
distintas
frecuencias
cantidades
trabajo
distintos
tiempos
respuesta
completar
trabajo
consideraciones
conllevan
modelo
distinto
procesos
compiten
CPU
trabajo
tiempos
respuesta
siguientes
modelos
su-
sistema
conoce
frecuencia
ejecutar
proceso
trabajo
tie-
ne
tiempo
respuesta
programación
disco
aspecto
consideraremos
programación
procesos
compiten
en-
tre
tiempos
respuesta
cumplir
conoce
co-
mo
programación
tiempo
real
ejemplo
tipo
entorno
trabaja
programador
multimedia
tiem-
po
real
considere
procesos
muestra
figura
7-13
proceso
ejecuta
ca-
30
mseg
velocidad
NTSC
cuadro
requiere
10
mseg
tiempo
CPU
ausencia
competencia
ejecutaría
ráfagas
A2
A3
etc.
empe-
zando
30
mseg
ráfaga
CPU
maneja
cuadro
tiempo
respuesta
completar
empiece
488
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.5
PROGRAMACIÓN
PROCESOS
MULTIMEDIA
489
figura
7-13
muestran
procesos
C.
proceso
ejecuta
25
seg
ejemplo
PAL
proceso
ejecuta
20
seg
ejemplo
flujo
NTSC
PAL
velocidad
reducida
destinado
usuario
conexión
ancho
banda
servidor
video
tiempo
cómputo
cuadro
muestra
15
mseg
mseg
respectivamente
problema
programación
general
tiempos
iguales
pregunta
programación
programar
asegurar
cumplan
respectivos
tiempos
respuesta
buscar
siquiera
algoritmo
programación
conjunto
procesos
programarse
sección
2.4.4
vimos
proce-
so
periodo
mseg
requiere
Ci
mseg
tiempo
CPU
cuadro
siste-
ma
programarse
número
procesos
caso
Observe
Ci
/Pi
fracción
CPU
utilizando
proceso
i.
ejemplo
figura
7-13
ocupa
10/30
CPU
15/40
5/50
conjunto
fracciones
suman
0.808
CPU
sistema
procesos
programar
asumido
proceso
flujo
realidad
procesos
flujo
ejemplo
audio
video
ejecutarse
distintas
velocidades
consumir
distintas
cantidades
tiempo
CPU
ráfaga
embar-
go
agregar
procesos
audio
mezcla
modifica
modelo
general
su-
poniendo
procesos
ejecuta
frecuencia
fija
cantidad
fija
trabajo
necesaria
ráfaga
CPU
sistemas
tiempo
real
procesos
preferentes
sis-
temas
multimedia
procesos
general
significa
proceso
peligro
A1
A2
A3
A4
A5
B1
B2
B3
B4
Momento
inicial
A1
B1
C1
Tiempo
respuesta
A1
Tiempo
respuesta
B1
Tiempo
respuesta
C1
01
05
06
07
08
09
100
110
120
130
140
Tiempo
mseg
C2
C3C1
Figura
7-13
procesos
periódicos
muestra
película
velocidades
cuadro
requerimientos
procesamiento
cuadro
distintos
película
Pi
Ci
www.FreeLibros.mede
pasarse
tiempo
respuesta
interrumpir
procesos
ejecución
proceso
ejecución
terminado
cuadro
terminar
proceso
conti-
nuar
comportamiento
multiprogramación
visto
Estudiaremos
algoritmos
programación
tiempo
real
preferentes
objeción
sis-
temas
multimedia
proporcionan
rendimiento
preferentes
única
preocu-
pación
llenando
búfer
transmisión
pequeñas
ráfagas
búfer
completamente
lleno
llega
tiempo
respuesta
enviar
usua-
rio
operación
caso
introducir
fluctuación
algoritmos
tiempo
real
estáticos
dinámicos
algoritmos
estáticos
asignan
proceso
prioridad
fija
adelantado
realizan
programación
preferente
priorida-
des
utilizando
algoritmos
dinámicos
prioridades
fijas
continuación
estudiare-
mos
ejemplo
tipo
7.5.3
Programación
monotónica
frecuencia
algoritmo
programación
tiempo
real
estático
clásico
procesos
periódicos
preferen-
tes
RMS
Rate
Monotonic
Scheduling
Programación
monotónica
frecuencia
Liu
Layland
1973
utilizar
procesos
cumplen
siguientes
condiciones
proceso
periódico
completar
periodo
proceso
dependiente
proceso
necesita
cantidad
tiempo
CPU
ráfaga
proceso
periódico
tiempo
respuesta
preferencia
procesos
ocurre
forma
instantánea
sobrecarga
primeras
condiciones
razonables
duda
facilita
mane-
ra
considerable
modelado
sistema
RMS
funciona
asignar
proceso
prioridad
fija
frecuencia
ocurrencia
evento
activación
ejemplo
proceso
ejecutar
30
mseg
33
seg
obtiene
prioridad
33
proceso
ejecutar
40
mseg
25
seg
obtiene
prioridad
25
proceso
ejecutar
50
mseg
20
seg
obtiene
prioridad
20
prioridades
lineales
frecuen-
cia
número
ejecuta
proceso
explica
llama
mono-
tónica
frecuencia
tiempo
ejecución
programador
ejecuta
proceso
esté
listo
prioridad
reemplazando
proceso
ejecución
necesita
Liu
Layland
demostraron
RMS
óptima
clase
algoritmos
programación
estáticos
figura
7-14
muestra
funciona
programación
monotónica
ejemplo
figura
7-13
procesos
prioridades
estáticas
33
25
20
respectivamente
sig-
nifica
necesita
ejecutar
reemplazando
proceso
utilice
CPU
proceso
reemplazar
A.
proceso
esperar
CPU
esté
inactiva
ejecutarse
490
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.5
PROGRAMACIÓN
PROCESOS
MULTIMEDIA
491
figura
7-14
principio
procesos
listos
ejecutarse
selecciona
pro-
ceso
prioridad
permite
ejecutarse
completa
15
mseg
muestra
línea
RMS
terminar
ejecutan
orden
conjunto
procesos
tardan
30
mseg
ejecutarse
termina
tiempo
ejecute
nue-
vo
rotación
continúa
sistema
queda
inactivo
70
/H1100580
listo
ejecuta
/H1100590
listo
proceso
prioridad
reemplaza
ejecuta
terminar
/H11005100
punto
sistema
elegir
terminar
empezar
selecciona
proceso
prioridad
B.
7.5.4
Programación
menor
tiempo
respuesta
algoritmo
programación
tiempo
real
popular
Menor
tiempo
respuesta
pri-
mero
EDF
algoritmo
dinámico
requiere
procesos
periódicos
algoritmo
monotónico
frecuencia
requiere
tiempo
ejecución
ráfaga
CPU
RMS
proceso
necesita
tiempo
CPU
anuncia
presencia
tiempo
respuesta
programador
mantiene
lista
procesos
eje-
cutables
ordenados
base
tiempo
respuesta
algoritmo
ejecuta
proceso
lista
tiempo
respuesta
cercano
proceso
listo
sistema
comprueba
ocurra
tiempo
respuesta
proceso
actual
ejecu-
ción
proceso
reemplaza
actual
figura
7-14
muestra
ejemplo
EDF
principio
procesos
listos
ejecutan
orden
tiempos
respuesta
terminar
/H1100530
terminar
pa-
ra
/H1100540
terminar
/H1100550
tiempo
respuesta
cercano
ende
/H1100590
opciones
iguales
RMS
/H1100590
vuelve
listo
tiempo
respuesta
/H11005120
tiempo
respuesta
B.
planificador
po-
dría
elegir
ejecutar
legítimamente
cualquiera
priorizar
costo
asociado
A1
A1
A1
B1
B1
A2
A2
A2
A3
A3
B3
A4
A3
B3
A4
A5
B4
A5
B4
A4
A5
B1
B2
B2
B2
B3
B4
01
05
06
07
08
09
100
110
120
130
140
Tiempo
mseg
EDF
RMS
C1
C1
C1
C2
C2
C2
C3
C3
C3
Figura
7-14
ejemplo
programación
tiempo
real
RMS
EDF
www.FreeLibros.mediferente
cero
dejar
continúe
ejecutándose
incurrir
problema
cambiar
procesos
disipar
idea
RMS
EDF
resultados
veamos
ejemplo
muestra
figura
7-15
ejemplo
periodos
iguales
pe-
ro
necesita
15
mseg
tiempo
CPU
ráfaga
10
mseg
prueba
capacidad
programación
calcula
CPU
0.500
/H110010.375
/H110010.100
/H110050.975
queda
2.5%
CPU
teoría
exceso
solicitudes
posi-
ble
encontrar
programación
legal
492
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
A1
A1
B1
B1
A1
A2
B2
B3A3
A4
A5
B4
A5
B1
B2
B2
Falla
A2
B3
B4
01
06
07
08
09
100
110
120
130
140
Tiempo
mseg
EDF
RMS
A2
A3
A4
C2
C3
C3
C1
C1
C2
Figura
7-15
ejemplo
programación
tiempo
real
RMS
EDF
RMS
prioridades
procesos
siguen
33
25
20
importa
periodo
tiempo
ejecución
B1
termina
/H1100530
momento
listo
ejecutarse
termina
/H1100545
listo
teniendo
prioridad
alta
ejecuta
pasa
tiempo
respues-
ta
RMS
falla
veamos
maneja
EDF
caso
/H1100530
concurso
A2
C1
tiempo
respuesta
C1
50
A2
60
programa
distinto
RMS
prioridad
alta
gana
/H1100590
listo
cuarta
tiempo
respuesta
proceso
actual
120
planificador
opción
reemplazar
reemplazar
necesario
permite
B3
completar
ejecución
ejemplo
figura
7-15
CPU
100%
ocupada
/H11005150
momento
creará
hueco
CPU
utiliza
97%
tiempos
inicio
múltiplos
mseg
hueco
mseg
lograr
2.5%
tiempo
inactividad
requerido
hueco
mseg
ocurrir
200
meg
ex-
plica
muestra
figura
7-15
www
FreeLibros.meSECCIÓN
7.6
PARADIGMAS
SISTEMAS
ARCHIVOS
MULTIMEDIA
493
pregunta
interesante
falló
RMS
Básicamente
prioridades
estáticas
funciona
CPU
alto
Liu
Layland
1973
demostraron
pa-
ra
sistema
procesos
periódicos
garantiza
RMS
funcionará
10
20
100
usos
máximos
permiti-
0.780
0.757
0.743
0.718
0.705
0.696
Sq
máximo
asintótico
ln
palabras
Liu
Layland
demostraron
procesos
RMS
funciona
CPU
menor
0.780
ejemplo
0.808
RMS
funcionó
tuvimos
suerte
distintos
periodos
tiempos
ejecución
0.808
fallar
ejemplo
CPU
alto
0.975
esperanza
RMS
pudiera
funcionar
contrario
EDF
funciona
conjunto
programable
procesos
Pue-
lograr
100%
CPU
precio
pagar
algoritmo
complejo
servidor
video
real
CPU
límite
RMS
utilizar
algoritmo
caso
contrario
utilizar
EDF
7.6
PARADIGMAS
SISTEMAS
ARCHIVOS
MULTIMEDIA
visto
programación
procesos
sistemas
multimedia
continuar
estudio
analizando
sistemas
archivos
multimedia
utilizan
paradigma
distin-
to
sistemas
archivos
tradicionales
veremos
repaso
archivos
tra-
dicional
enfocaremos
forma
organizan
servidores
archivos
multimedia
acceder
archivo
proceso
emite
llamada
sistema
open
éxito
proceso
llamada
recibe
tipo
token
conocido
descriptor
archivos
UNIX
manejador
Windows
usarlo
futuras
llamadas
punto
proceso
emitir
llamada
sistema
read
proporcionando
token
dirección
búfer
conteo
bytes
parámetros
sistema
operativo
devuelve
datos
solicitados
búfer
llamadas
adicionales
readhasta
termine
proceso
momento
llama
closepara
cerrar
archivo
devolver
recursos
modelo
funciona
multimedia
necesidad
comportamiento
tiempo
real
especial
funciona
inadecuada
hora
mostrar
archivos
multimedia
provienen
servidor
video
remoto
problemas
usuario
reali-
zar
llamadas
readcon
espaciamiento
preciso
tiempo
proble-
ma
servidor
video
capaz
suministrar
bloques
datos
retraso
difícil
llegan
peticiones
planeadas
reservado
recursos
adelantado
resolver
problemas
servidores
archivos
multimedia
utilizan
paradigma
completamente
distinto
actúan
VCRs
Grabadoras
Video
Casete
leer
archivo
Pi
Ci
m(21
www.FreeLibros.memultimedia
proceso
usuario
emite
llamada
sistema
start
especificando
archivo
leer
parámetros
ejemplo
pistas
audio
subtítulos
utilizar
servidor
video
empieza
enviar
cuadros
velocidad
requerida
responsabilidad
usua-
rio
manejarlos
velocidad
llegan
usuario
aburre
película
llamada
sistema
stoptermina
flujo
servidores
archivos
modelo
flujo
continuo
co-
nocen
servidores
push
empujan
datos
usuario
contrastan
servidores
pull
tradicionales
usuario
extraer
datos
bloque
llamando
repetidas
readpara
obtener
bloque
dife-
rencia
modelos
ilustra
figura
7-16
494
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Servidor
video
Cliente
Petición
Petición
Bloque
Bloque
Petición
Bloque
Tiempo
Servidor
video
Cliente
Inicio
Bloque
Bloque
Bloque
Bloque
Bloque
Figura
7-16
servidor
pull
servidor
push
7.6.1
Funciones
control
VCR
mayoría
servidores
video
implementan
funciones
control
VCR
estándar
incluyendo
pausa
adelanto
rápido
rebobinado
pausa
simple
usuario
envía
mensaje
vuelta
servidor
video
indicándole
detenga
punto
recordar
cuadro
usuario
indica
servidor
continuar
simplemente
continúa
complicación
lograr
rendimiento
aceptable
servidor
reservar
recursos
ancho
banda
disco
búferes
memoria
flujo
sa-
liente
continúan
acaparando
recursos
película
pausa
desperdi-
cian
recursos
especial
usuario
planea
viaje
cocina
localizar
microondas
cocinar
comer
pizza
congelada
extra
recursos
liberar
facilidad
momento
pausar
película
introduce
peligro
usuario
trate
reanudarla
puedan
volver
adquirir
rebobinado
realidad
sencillo
complicaciones
servidor
cuadro
enviar
www
FreeLibros.meSECCIÓN
7.6
PARADIGMAS
SISTEMAS
ARCHIVOS
MULTIMEDIA
495
sencillo
adelanto
rápido
retroceso
rápido
reproducir
re-
trocede
complicados
compresión
avanzar
10x
velocidad
mostrar
10-ésimo
cuadro
avanzar
velocidad
20x
habría
mostrar
20-ésimo
cuadro
compresión
fácil
avanzar
retroceder
velocidad
retroceder
velocidad
normal
direc-
ción
opuesta
método
funciona
efectividad
servidores
pull
push
compresión
complica
movimiento
rápido
dirección
cinta
DV
cámara
video
cuadro
comprime
independiente
utilizar
estrategia
encontrar
rápido
cuadro
necesario
Co-
mo
cuadro
comprime
cantidad
distinta
dependiendo
contenido
cuadro
tamaño
salto
cuadros
archivo
cálculo
numérico
compresión
audio
realiza
inde-
pendiente
compresión
video
video
muestre
alta
velocidad
deberá
localizarse
cuadro
audio
correcto
sonido
apague
avanza
retrocede
velocidad
rápida
normal
ende
avance
rápido
archivo
DV
requiere
índice
permita
localizar
cuadros
rápidamente
teoría
MPEG
esquema
funciona
siquiera
teoría
cuadros
B.
saltar
cuadros
suponiendo
pudiera
podríamos
caer
cuadro
esté
basado
cuadro
cuadro
base
inútil
reali-
zar
cambios
incrementales
contiene
cuadro
MPEG
requiere
archivo
reproduzca
forma
secuencial
atacar
problema
tratar
reproducir
archivo
forma
secuencial
velocidad
10x
requiere
extraer
datos
disco
velocidad
10x
punto
servidor
tratar
descomprimir
cuadros
ge-
neral
averiguar
cuadro
necesita
volver
comprimir
10-ésimo
cuadro
cuadro
I.
impone
enorme
carga
servidor
Ade-
servidor
comprender
formato
compresión
general
ne-
cesita
alternativa
enviar
datos
red
usuario
dejar
se-
leccionen
cuadros
correctos
requiere
red
opere
velocidad
10x
duda
fácil
alta
velocidad
operar
general-
mente
Dadas
condiciones
solución
fácil
única
estrategia
factible
requiere
planeación
adelantado
construir
archivo
especial
contenga
ejemplo
10-ésimo
cuadro
comprimir
archivo
utilizando
algoritmo
MPEG
nor-
archivo
muestra
figura
7-3
avance
rápido
cambiar
mo-
do
avance
rápido
servidor
averiguar
usuario
actualmente
archivo
avance
rápido
ejemplo
cuadro
actual
48,210
archi-
vo
avance
rápido
ejecuta
10x
servidor
localizar
cuadro
4821
archivo
avance
rápido
empezar
reproducir
velocidad
normal
cua-
dro
cuadro
proceso
decodificación
cliente
simplemente
www.FreeLibros.meomitir
cuadros
vea
cuadro
I.
retroceder
utiliza
forma
análoga
archivo
preparado
forma
especial
usuario
cambia
vuelta
velocidad
normal
truco
inver-
so
cuadro
actual
archivo
avance
rápido
5734
servidor
cambia
vuelta
archivo
regular
continúa
cuadro
57,340
cuadro
cuadro
proceso
decodificación
cliente
ignorar
cuadros
vea
cuadro
I.
archivos
adicionales
funciona
método
desventajas
lugar
requiere
espacio
adicional
disco
almacenar
archivos
adiciona-
lugar
avance
retroceso
rápidos
velocidades
corres-
pondan
archivos
especiales
tercer
lugar
necesita
complejidad
adicional
cambiar
archivos
regular
avance
rápido
retroceso
rápido
7.6.2
Video
demanda
usuarios
reciben
película
impone
carga
servidor
cuan-
do
reciben
películas
distintas
pequeño
cambio
modelo
ob-
considerables
ganancias
rendimiento
problema
video
demanda
usuarios
empezar
recibir
flujo
continuo
película
momento
arbitrario
100
usuarios
empiezan
película
P.M.
probable
usuarios
empiecen
película
instante
exacto
compartir
flujo
continuo
modificación
op-
timización
usuarios
películas
empiezan
hora
minutos
ejemplo
usuario
desea
película
8:02
esperar
8:05
ventaja
película
horas
necesitan
24
flujos
continuos
importar
clientes
muestra
figura
7-17
flujo
continuo
empie-
za
8:00
8:05
flujo
cuadro
9000
empieza
flujo
8:10
flujo
cuadro
18,000
flujo
cuadro
9000
em-
pieza
flujo
sucesivo
flujo
24
empieza
9:55
10:00
termina
flujo
vuelve
empezar
cuadro
esquema
conoce
video
demanda
video
realidad
empieza
demanda
parámetro
clave
frecuencia
inicia
flujo
inicia
minutos
requerirán
60
flujos
película
horas
máximo
tiempo
espe-
ra
empezar
película
minutos
operador
decidir
tiempo
es-
tarán
dispuestas
esperar
personas
tiempo
estén
dispuestas
esperar
eficiente
sistema
mostrar
películas
estrategia
alternativa
te-
ner
opción
espera
cuyo
caso
inicia
flujo
instante
cobra-
ría
inicio
instantáneo
sentido
video
demanda
utilizar
taxi
llamamos
viene
ca-
video
demanda
autobús
itinerario
fijo
esperar
si-
guiente
tránsito
masa
sentido
masa
centro
Manhattan
autobús
opere
minutos
contar
recogerá
pasa-
496
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.6
PARADIGMAS
SISTEMAS
ARCHIVOS
MULTIMEDIA
497
jeros
autobús
viaje
carreteras
secundarias
Wyoming
vacío
tiempo
similar
mostrar
producción
reciente
Steven
Spielberg
atraer
suficientes
clientes
garantizar
inicie
flujo
minutos
viento
llevó
conveniente
ofrecerla
demanda
video
demanda
usuarios
controles
VCR
usuario
pue-
pausar
película
viaje
cocina
regre-
sar
cocina
cambie
flujo
empezado
verá
minutos
material
repetido
realidad
modelo
video
demanda
anunciar
adelantado
película
específica
empezará
minutos
personas
pedir
pelí-
culas
deseen
minutos
sistema
ve
películas
pedido
em-
pieza
reproducir
método
película
empezar
8:00
8:10
8:15
8:25
tiempos
intermedios
dependiendo
demanda
resultado
transmitirán
flujos
espectadores
ahorrando
ancho
banda
disco
memoria
capacidad
red
atacar
refrigerador
arriesgado
garantía
iniciar
flujo
continuo
minutos
flujo
espectador
viendo
ope-
rador
proveer
opción
usuario
muestre
lista
flujos
concurren-
tes
mayoría
personas
piensan
controles
remotos
TV
botones
necesarios
probable
reciban
entusiasmo
9000
18000
27000
36000
45000
54000
63000
72000
81000
8:00
8:05
8:10
8:15
8:20
8:25
8:30
8:35
8:40
8:45
9000
18000
27000
36000
45000
54000
63000
72000
02
9000
18000
27000
36000
45000
54000
63000
03
9000
18000
27000
36000
45000
54000
04
9000
18000
27000
36000
45000
05
9000
18000
27000
36000
06
9000
18000
27000
07
9000
18000
08
9000
09
cuadro
9000
flujo
envía
8:20
min
Tiempo
Flujo
continuo
Figura
7-17
método
video
demanda
inicia
flujo
inter-
valos
regulares
ejemplo
minutos
9000
cuadros
www
FreeLibros.me7.6.3
Video
demanda
funciones
VCR
combinación
ideal
video
demanda
cuestión
eficiencia
contro-
VCR
completos
espectador
individual
comodidad
usuario
modificaciones
modelo
diseño
continuación
proporcionaremos
descripción
simplificada
lograr
objetivo
Abram-Profeta
Shin
1998
Empezaremos
esquema
video
demanda
estándar
figura
7-17
agre-
garemos
requerimiento
equipo
cliente
coloque
búfer
∆Tmin
tam-
bién
∆T
min
forma
local
búfer
∆Tmin
fácil
guarda
mostrarlo
búfer
∆T
min
difícil
clientes
capacidad
leer
flujos
tiempo
ilustrar
establecer
búfer
ejemplo
usuario
em-
pieza
película
8:15
equipo
cliente
lee
muestra
flujo
8:15
en-
cuentra
cuadro
paralelo
lee
almacena
flujo
8:10
momento
marca
minutos
cuadro
9000
8:20
almacena-
do
cuadros
17,999
usuario
espera
cuadro
9000
continuación
abandona
flujo
8:15
búfer
llena
flujo
8:10
cuadro
18,000
visualización
controla
media
búfer
cuadro
9000
me-
dida
lee
cuadro
agrega
cuadro
búfer
quita
cuadro
inicio
búfer
cuadro
actual
visualizando
conocido
punto
reproduc-
ción
búfer
figura
7-18(a
muestra
situación
minuto
75
película
cuadros
minutos
70
80
búfer
velocidad
datos
Mbps
búfer
10
minutos
requiere
300
millones
bytes
almacenamiento
precios
actuales
duda
búfer
mantener
disco
posiblemente
RAM
desea
RAM
300
millones
bytes
utilizar
bú-
fer
pequeño
suponga
usuario
decide
adelanto
retroceso
rápido
pun-
to
reproducción
permanezca
rango
70
80
minutos
pantalla
alimentar
búfer
obstante
punto
reproducción
mueve
intervalo
cual-
quier
extremo
surge
problema
solución
activar
flujo
privado
video
de-
manda
servicio
usuario
movimiento
rápido
dirección
manejar
técnicas
descritas
general
punto
usuario
adaptará
decidirá
película
velocidad
normal
punto
pensar
cambiar
usuario
flujos
video
demanda
quitar
flujo
privado
ejemplo
suponga
usuario
decide
regresar
marca
12
minutos
muestra
figura
7-18(b
punto
ale-
jado
búfer
pantalla
alimentar
ocurrió
cambio
instantánea
75
minutos
flujos
muestran
película
10
15
20
minutos
12
minutos
solución
continuar
viendo
flujo
privado
empezar
llenar
búfer
flujo
15
minutos
película
minutos
situación
ilustra
figura
7-18(c
punto
reproducción
15
minutos
búfer
contiene
minutos
15
18
498
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.7
COLOCACIÓN
ARCHIVOS
499
flujos
video
demanda
13
18
23
minutos
punto
quitar
flujo
privado
pantalla
alimentar
búfer
búfer
llenando
flujo
minuto
18
minuto
punto
reproducción
16
minutos
búfer
contiene
minutos
15
19
flujo
alimenta
búfer
mi-
nuto
19
muestra
figura
7-18(d
transcurren
minutos
adicionales
búfer
lleno
punto
reproduc-
ción
22
minutos
punto
reproducción
mitad
búfer
arre-
glarse
necesario
7.7
COLOCACIÓN
ARCHIVOS
archivos
multimedia
escriben
leen
tienden
utilizarse
forma
secuencial
reproducción
cumplir
estric-
tos
criterios
calidad
conjunto
requerimientos
sugieren
distribuciones
sistema
ar-
chivos
distintas
utilizan
sistemas
operativos
tradicionales
continuación
hablaremos
cuestiones
disco
discos
3006
120
Punto
reproducción
minuto
12
Punto
reproducción
minuto
75
Punto
reproducción
minuto
15
Punto
reproducción
minuto
16
Punto
reproducción
minuto
22
Minutos
Figura
7-18
Situación
inicial
retroceder
minuto
12
Des-
pués
esperar
minutos
empezar
rellenar
búfer
Búfer
lleno
www
FreeLibros.me7.7.1
Colocación
archivo
disco
requerimiento
importante
datos
colocar
flujo
continuo
red
dispositivo
salida
velocidad
requerida
fluctuación
razón
conveniente
búsquedas
cuadro
eliminar
búsquedas
en-
tre
archivos
servidores
video
utilizar
archivos
contiguos
general
archivos
contiguos
funciona
servidor
video
precargado
cuidadosamen-
películas
adelantado
cambian
funcionar
complicación
presencia
video
audio
texto
muestra
figura
7-3
video
audio
texto
almacenan
archivos
contiguos
separados
requerirá
búsqueda
avanzar
archivo
video
audio
archi-
vo
texto
necesario
sugiere
arreglo
almacenamiento
don-
video
audio
texto
entrelazan
muestra
figura
7-19
archivo
completo
contiguo
video
cuadro
seguido
directamente
diversas
pistas
audio
cuadro
diversas
pistas
texto
cuadro
Dependiendo
pistas
audio
texto
simple
leer
piezas
cuadro
operación
lectura
disco
transmitir
partes
ne-
cesarias
usuario
500
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Video
Video
Video
Cuadro
3Cuadro
2Cuadro
Pista
audio
Pista
texto
Figura
7-19
Entrelazado
video
audio
texto
archivo
contiguo
pe-
lícula
organización
requiere
operación
disco
adicional
leer
audio
tex-
to
deseados
espacio
búfer
adicional
memoria
almacenarlos
eli-
mina
búsquedas
sistema
usuario
requiere
sobrecarga
cuadro
disco
película
archivo
contiguo
acceso
aleatorio
imposible
distribución
necesita
pérdida
grave
similar
imposible
avance
rápido
retroceso
rá-
pido
estructuras
datos
complejidad
adicionales
ventaja
película
completa
archivo
contiguo
pierde
ser-
vidor
video
flujos
salida
concurrentes
leer
cuadro
pe-
lícula
disco
leer
cuadros
películas
regresar
sistema
realizan
escrituras
lecturas
películas
ejemplo
sistema
utilizado
producción
edición
video
archivos
contiguos
difícil
útil
www
FreeLibros.meSECCIÓN
7.7
COLOCACIÓN
ARCHIVOS
501
7.7.2
estrategias
alternativas
organización
archivos
observaciones
conllevan
organizaciones
colocación
archivos
multime-
modelo
bloques
pequeños
ilustra
figura
7-20(a
or-
ganización
tamaño
bloque
disco
selecciona
considerablemente
menor
tamaño
cuadro
promedio
cuadros
B.
MPEG-2
Mbps
30
cuadros
seg
cuadro
promedio
16
KB
tamaño
bloque
KB
KB
funcionaría
idea
estructura
datos
índice
cuadro
pe-
lícula
entrada
cuadro
apuntando
inicio
cuadro
cuadro
consiste
pistas
video
audio
texto
cuadro
tirada
contigua
bloques
disco
muestra
lectura
cuadro
consiste
indexar
índice
cuadro
buscar
k-ésima
entrada
leer
cuadro
completo
operación
dis-
co
distintos
cuadros
tamaños
necesita
tamaño
cuadro
blo-
ques
índice
cuadro
bloques
disco
KB
campo
bits
manejar
cuadro
255
KB
suficiente
cuadro
NTSC
descomprimido
pistas
audio
Bloque
disco
pequeño
cuadro
Audio
Texto
Índice
cuadro
Bloque
disco
cuadro
Índice
bloque
Cuadro
Cuadro
utilizar
Figura
7-20
Almacenamiento
película
contiguo
Bloques
disco
peque-
ños
Bloques
disco
forma
almacenar
película
bloque
disco
256
KB
colocar
cuadros
bloque
muestra
figura
7-20(b
formas
necesita
índice
índice
bloque
cuadro
índice
básicamente
nodo-i
figura
6-15
adición
información
indica
cuadro
inicio
bloque
localizar
www.FreeLibros.meun
cuadro
específico
rapidez
general
bloque
contendrá
número
entero
cuadros
opciones
opción
ilustra
figura
7-20(b
cuadro
cabe
bloque
actual
resto
bloque
deja
vacío
espacio
desperdiciado
fragmentación
interna
sistemas
memoria
virtual
páginas
tamaño
fijo
necesario
búsqueda
cuadro
opción
llenar
bloque
dividiendo
cuadros
bloques
opción
introduce
necesidad
búsquedas
cuadros
da-
ñar
rendimiento
ahorra
espacio
disco
eliminar
fragmentación
interna
fines
comparación
bloques
pequeños
figura
7-20(a
des-
perdicia
espacio
disco
utiliza
fracción
bloque
ca-
cuadro
bloque
disco
KB
película
NTSC
horas
consiste
216,000
cuadros
espacio
disco
desperdiciado
108
KB
3.6
GB
difícil
calcular
espacio
desperdiciado
figura
7-20(b
quedarán
100
KB
bloque
cua-
dro
cuadro
índice
bloque
menor
índice
cuadro
bloque
256
KB
cuadro
promedio
16
KB
caben
16
cuadros
bloque
película
216,000
cuadros
necesita
13,500
entradas
índice
bloque
com-
paración
216,000
índice
cuadro
cuestiones
rendimiento
casos
índice
listar
cuadros
bloques
bloques
indirectos
UNIX
enlazar
13,500
entradas
bytes
memoria
bytes
dirección
dis-
co
byte
tamaño
cuadro
bytes
número
cuadro
inicial
comparación
216,000
entradas
bytes
dirección
disco
tamaño
ahorra
MB
RAM
reproduce
película
consideraciones
conllevan
siguientes
concesiones
Índice
cuadro
pesado
RAM
reproduce
película
des-
perdicio
disco
Índice
bloque
dividen
cuadros
bloques
RAM
desperdicio
disco
Índice
bloque
dividir
cuadros
bloques
RAM
desperdicio
disco
búsquedas
adicionales
concesiones
implican
RAM
reproducción
desperdicio
espacio
disco
tiempo
pérdida
rendimiento
reproducción
búsque-
das
adicionales
obstante
atacar
problemas
formas
RAM
reducir
paginar
partes
tabla
cuadros
justo
tiempo
búsquedas
transmisión
cuadros
enmascarar
búfer
suficiente
introduce
necesidad
memoria
adicional
probablemente
copiado
adicional
dise-
ño
analizar
cuidado
factores
elección
aplica-
ción
cuestión
502
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.7
COLOCACIÓN
ARCHIVOS
503
factor
administración
almacenamiento
disco
complicada
figura
7-20(a
almacenar
cuadro
requiere
encontrar
tirada
con-
secutiva
bloques
tamaño
correcto
teoría
tirada
bloques
debería
cruzar
límite
pista
disco
desviación
cabezas
pérdida
grave
embar-
go
evitar
cruzar
límite
cilindros
requerimientos
significan
almacena-
miento
libre
disco
organizarse
lista
hoyos
tamaño
variable
lista
bloques
simple
mapa
bits
utilizar
fi-
gura
7-20(b
casos
colocar
bloques
cuadros
película
rango
estrecho
ejemplo
cilindros
posi-
ble
Dicha
colocación
significa
búsquedas
realizan
rapidez
quede
tiempo
actividades
tiempo
real
soportar
flujos
continuos
vi-
deo
adicionales
lograr
colocación
restringida
tipo
dividir
disco
gru-
pos
cilindros
mantener
grupo
listas
mapas
bits
separados
bloques
libres
ejemplo
utilizan
hoyos
lista
hoyos
KB
hoyos
KB
hoyos
KB
KB
hoyos
KB
KB
sucesivo
fácil
encontrar
hoyo
tamaño
grupo
cilindros
especí-
fico
diferencia
métodos
búfer
método
bloques
peque-
ños
lectura
obtiene
cuadro
consecuencia
estrategia
simple
búfer
doble
fun-
ciona
búfer
reproducir
cuadro
actual
obtener
utilizan
búferes
fijos
búfer
contener
cuadro
po-
sible
asigna
búfer
distinto
reserva
cuadro
tamaño
cuadro
leerlo
elegir
búfer
pequeño
cuadro
B.
caso
bloques
requiere
estrategia
compleja
blo-
contiene
cuadros
posiblemente
incluya
fragmentos
cuadros
extremo
bloque
dependiendo
opción
elegido
mostrar
transmitir
cuadros
contiguos
copiar
copiado
operación
costosa
evitar
requiere
contigüidad
enviar
cuadros
abarquen
límites
bloque
red
dispositivo
visualización
partes
doble
búfer
utilizar
bloques
bloques
gran-
des
desperdicia
memoria
resolver
desperdicio
memoria
búfer
transmisión
circular
bloque
disco
flujo
continuo
alimen-
red
pantalla
contenido
búfer
disminuye
umbral
lee
bloque
disco
contenido
copia
búfer
transmisión
búfer
bloque
devuelve
reserva
común
tamaño
búfer
circular
elegir
forma
llegue
umbral
espacio
bloque
disco
lleno
lectura
dis-
co
directamente
búfer
transmisión
tendría
envolvente
copiado
memoria
intercambian
factor
comparar
métodos
rendimiento
disco
blo-
ques
disco
opere
máxima
velocidad
cuestión
im-
portante
eficiente
leer
pequeños
cuadros
unidades
separadas
www.FreeLibros.medividir
bloques
bandas
unidades
veremos
continuación
mien-
dividir
bandas
cuadros
individuales
unidades
organización
bloques
pequeños
figura
7-20(a
conoce
lon-
gitud
tiempo
constante
apuntador
índice
representa
número
mi-
lisegundos
tiempo
reproducción
contrario
organización
figura
7-20(b
conoce
longitud
datos
constante
bloques
datos
mis-
mo
tamaño
diferencia
organizaciones
archivos
tipos
cuadros
almace-
nan
índice
figura
7-20(a
avance
rápido
mostrar
cuadros
I.
dependiendo
frecuencia
aparezcan
cuadros
flujo
velocidad
percibir
rápida
lenta
caso
organización
figura
7-20(b
avance
rápido
realidad
leer
archivo
forma
secuencial
elegir
cuadros
deseados
requiere
disco
masiva
método
utilizar
archivo
especial
reproduzca
velocidad
normal
dé
ilusión
avance
rápido
velocidad
10x
archivo
estructu-
rar
forma
archivos
utilizando
índice
cuadro
índice
bloque
abrir
archivo
sistema
capaz
buscar
archivo
avance
rápido
necesa-
rio
usuario
oprime
botón
avance
rápido
sistema
buscar
abrir
ins-
tantánea
archivo
avance
rápido
saltar
lugar
correcto
archivo
número
cuadro
necesita
capacidad
localizar
cuadro
correspondiente
archivo
avance
rápido
ejemplo
cuadro
4816
archi-
vo
avance
rápido
10x
localizar
cuadro
482
archivo
empezar
reproducir
utiliza
índice
cuadro
fácil
localizar
cuadro
específico
indexa
ín-
cuadro
utiliza
índice
bloque
necesita
información
adicional
entrada
identificar
cuadro
bloque
búsqueda
bina-
ria
índice
bloque
retroceso
rápido
funciona
análoga
avance
rápido
7.7.3
Colocación
archivos
video
demanda
analizado
estrategias
colocación
video
demanda
video
demanda
eficiente
estrategia
colocación
archivos
distinta
Recuerde
película
saliendo
flujos
escalonados
película
almacena
co-
mo
archivo
contiguo
requiere
búsqueda
flujo
Chen
Thapar
1997
idea-
do
estrategia
colocación
archivos
eliminar
búsquedas
ilustra
figura
7-21
película
reproduce
30
cuadros
seg
inicia
nue-
vo
flujo
minutos
figura
7-17
parámetros
necesitan
24
flujos
con-
currentes
película
horas
colocación
conjuntos
24
cuadros
concatenan
escriben
disco
registro
leer
vuelta
operación
lectura
Considere
ins-
tante
empieza
flujo
24
Necesitará
cuadro
flujo
23
empezó
minu-
tos
necesitará
cuadro
9000
flujo
22
necesitará
cuadro
18,000
sucesivo
504
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.7
COLOCACIÓN
ARCHIVOS
505
regresar
flujo
necesitará
cuadro
207,000
colocar
cuadros
forma
con-
secutiva
pista
disco
servidor
video
satisfacer
24
flujos
orden
inver-
so
búsqueda
cuadro
cuadros
invertir
disco
razón
servicio
flujos
orden
ascendente
da-
do
servicio
flujo
brazo
disco
mover
pista
prepararse
ser-
vicio
flujos
esquema
requiere
archivo
contiguo
formas
logra
rendimiento
flujos
estrategia
búfer
simple
doble
búfer
reproduce
contenido
búfer
24
flujos
cargando
búfer
adelantado
termina
actual
búferes
intercambian
utilizaba
reproducir
carga
operación
disco
pregunta
interesante
búfer
duda
contener
24
cuadros
cuadros
tamaño
variable
elegir
tamaño
correcto
bú-
fer
operación
trivial
exagerado
búfer
contener
24
cuadros
tamaño
suficiente
24
cuadros
promedio
vivir
peligrosamente
fortuna
película
conoce
antemano
cuadro
senti-
do
figura
7-21
elegir
búfer
exactamente
tamaño
em-
bargo
ocurrir
pista
ejemplo
16
cuadros
pista
cuadros
I.
acertado
elegir
búfer
caso
Elegir
opción
significa
truncar
pis-
ta
niega
flujos
acceso
cuadro
película
evitar
falla
volver
mostrar
cuadro
notará
entramos
detalles
método
pista
tie-
ne
cuadros
vale
pena
utilizar
búfer
capaz
contener
cuadros
20
cuadros
P.
Probablemente
aceptable
introducir
cuadros
repetidos
flujos
película
termina
tamaño
búfer
9000
18000
27000
36000
45000
54000
72000
81000
20700063000
Flujo
24
Flujo
23
Flujo
15
Flujo
9001
18001
27001
36001
45001
54001
72001
81001
20700163001
9002
18002
27002
36002
45002
54002
72002
81002
20700263002
Cuadro
27002
15
minutos
película
Pista
Pista
Pista
Orden
leen
bloques
disco
Figura
7-21
Colocación
óptima
cuadros
video
demanda
www.FreeLibros.mepara
99%
cuadros
concesión
memoria
utilizada
búferes
calidad
películas
Observe
flujos
simultáneos
estadísticas
uniformes
conjuntos
cuadros
7.7.4
Colocación
archivos
disco
analizado
colocación
película
servi-
dor
video
películas
esparcen
aleatoria
disco
des-
perdiciará
tiempo
mover
cabeza
disco
película
película
distintos
clientes
estén
viendo
películas
tiempo
situación
mejorar
observar
películas
populares
popularidad
colocar
películas
disco
popularidad
películas
específicas
general
aparte
estrellas
renombre
ayudar
popularidad
relativa
películas
general
tipos
concursos
popularidad
películas
rentan
libros
sacan
biblioteca
páginas
Web
referencia
palabras
inglés
utilizan
novela
población
ciudades
aproximación
razonable
popularidad
relativa
patrón
sorprendentemente
predecible
patrón
descubierto
profesor
lingüística
Harvard
George
Zipf
1902
1950
conoce
ley
Zipf
establece
películas
libros
páginas
Web
pa-
labras
clasifican
base
popularidad
probabilidad
cliente
seleccio-
ne
elemento
clasificado
k-ésimo
lista
constante
normalización
fracción
ocurrencias
primeras
películas
C/1
C/2
C/3
respectiva-
mente
calcula
forma
suma
términos
palabras
películas
C/1
/H11001C/2
/H11001C/3
/H11001C/4
/H11001
/H11001C
/H110051
ecuación
calcular
C.
valores
poblaciones
10
100
1000
10,000
elementos
0.341
0.193
0.134
0.102
respectivamente
ejemplo
1000
pelí-
culas
probabilidades
primeras
películas
0.134
0.067
0.045
0.034
0.027
res-
pectivamente
ley
Zipf
ilustra
figura
7-22
diversión
aplicado
pobla-
ciones
20
ciudades
EE.UU.
ley
Zipf
predice
ciudad
población
equivalente
mitad
ciudad
ciudad
población
equivalente
tercio
ciudad
etcé-
tera
difícilmente
perfecto
cerca
serlo
películas
servidor
video
ley
Zipf
establece
película
popular
selecciona
frecuencia
película
popular
frecuencia
película
popular
sucesivo
dis-
tribución
disminuye
rapidez
principio
larga
cola
ejemplo
película
506
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.7
COLOCACIÓN
ARCHIVOS
507
50
popularidad
C/50
película
51
popularidad
C/51
pe-
lícula
51
50/51
popular
película
50
diferencia
2%
medida
avanzamos
cola
porcentaje
diferencia
películas
consecutivas
vuelve
menor
conclusión
servidor
necesita
películas
demanda
consi-
derable
películas
primeras
10
popularidades
relativas
distintas
películas
modelar
rendi-
miento
servidor
video
utilizar
información
colocar
archivos
estudios
mostrado
estrategia
sorprendente
simple
independiente
distribu-
ción
conoce
algoritmo
órgano
tubos
Grossman
Silverman
1973
Wong
1983
Consiste
colocar
película
popular
disco
colocar
terce-
ra
películas
populares
cualquiera
lados
películas
vienen
cuarta
quinta
sucesivo
muestra
figura
7-23
colocación
funciona
película
archivo
contiguo
tipo
muestra
figura
7-19
pue-
utilizar
grado
película
restringida
rango
estrecho
cilindros
nombre
algoritmo
proviene
histograma
probabilidades
apa-
riencia
órgano
ligeramente
oblicuo
algoritmo
tratar
mantener
cabeza
disco
disco
1000
películas
distribución
ley
Zipf
primeras
películas
representan
pro-
babilidad
0.307
significa
cabeza
disco
permanecerá
cilindros
asig-
nados
primeras
películas
cerca
30%
tiempo
cantidad
sorprendentemente
1000
películas
disponibles
0.300
0.250
0.200
0.150
0.100
0.050
12
3456789
Clasificación
Frecuencia
Figura
7-22
curva
proporciona
ley
Zipf
/H1100520
cuadros
represen-
poblaciones
20
ciudades
EE.UU.
orden
clasi-
ficación
York
Angeles
Chicago
etcétera
www
FreeLibros.me7.7.5
Colocación
archivos
discos
obtener
rendimiento
alto
servidores
video
frecuencia
dis-
cos
operar
paralelo
utilizan
RAIDs
frecuencia
ofrecen
RAIDs
confiabilidad
cambio
rendimiento
gene-
ral
servidores
video
desean
alto
rendimiento
preocupan
corregir
errores
transitorios
dispositivos
controladores
RAID
convertir
cue-
llo
botella
demasiados
discos
manejar
configuración
común
simplemente
número
discos
conoce
granja
discos
discos
giran
sincronizada
contienen
bits
paridad
ocurre
RAIDs
configuración
colocar
película
disco
película
disco
sucesivo
muestra
figura
7-24(a
práctica
discos
modernos
colocar
películas
disco
organización
simple
implementar
características
fallas
directas
dis-
co
falla
películas
contenga
estarán
disponibles
empresa
pierde
disco
lleno
películas
tantos
problemas
empresa
pierde
disco
lleno
datos
películas
recargar
fácilmente
disco
repuesto
des-
DVD
desventaja
método
carga
esté
balanceada
al-
gunos
discos
contienen
películas
demanda
discos
contienen
películas
populares
sistema
utilizará
máxima
capacidad
duda
conocen
frecuencias
películas
mover
balancear
car-
ga
forma
manual
organización
dividir
bandas
película
discos
ejemplo
figura
7-24(b
suponer
momento
cua-
dros
tamaño
compresión
número
fijo
bytes
pelícu-
escribe
disco
escribe
número
bytes
disco
sucesivo
llegar
disco
caso
unidad
A3
división
ban-
das
continúa
disco
A4
sucesivo
escrito
archivo
punto
dividen
películas
bandas
utilizando
patrón
508
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Película
10
Película
Película
Película
Película
Película
Película
Película
Película
Película
Película
11
Cilindro
Frecuencia
Figura
7-23
distribución
tipo
órgano
tubos
archivos
servidor
video
www
FreeLibros.meSECCIÓN
7.7
COLOCACIÓN
ARCHIVOS
509
desventaja
patrón
bandas
películas
empiezan
disco
carga
discos
esté
balanceada
esparcir
carga
escalonar
discos
iniciales
muestra
figura
7-24(c
forma
tratar
balancear
carga
utilizar
patrón
bandas
aleatorias
archivo
muestra
figura
7-24(d
cuadros
tamaño
películas
MPEG-2
suposición
falsa
cuadros
cuadros
P.
formas
lidiar
complicación
dividir
bandas
cuadro
bloque
dividir
bandas
cuadro
cuadro
película
disco
unidad
contigua
importar
tamaño
cuadro
disco
sucesivo
película
divide
bandas
similar
empezando
disco
utili-
zan
bandas
escalonadas
disco
aleatorio
cuadros
leen
forma
división
bandas
agiliza
lectura
película
esparce
carga
discos
conveniente
figura
7-24(a
compor-
tar
personas
deciden
observar
película
noche
desea
película
C.
general
esparcir
carga
discos
utiliza
ancho
banda
dis-
co
ende
incrementa
número
clientes
servicio
forma
dividir
bandas
bloque
película
escriben
unidades
tamaño
fijo
discos
sucesión
azar
bloque
contiene
A0
A1
A2
A3
A4
A5
A6
A7
B0
B1
B2
B3
B4
B5
B6
B7
C0
C1
C2
C3
C4
C5
C6
C7
D0
D1
D2
D3
D4
D5
D6
D7
A0
A4
B0
B4
C0
C4
D0
D4
A1
A5
B1
B5
C1
C5
D1
D5
A2
A6
B2
B6
C2
C6
D2
D6
A3
A7
B3
B7
C3
C7
D3
D7
A0
A4
B3
B7
C2
C6
D1
D5
A1
A5
B0
B4
C3
C7
D2
D6
A2
A6
B1
B5
C0
C4
D3
D7
A3
A7
B2
B6
C1
C5
D0
D4
A0
A6
B3
B4
C0
C7
D1
D6
A2
A5
B1
B7
C2
C6
D2
D5
A1
A4
B2
B5
C3
C4
D3
D4
A3
A7
B0
B6
C1
C5
D0
D7
1234
1234
1234
1234
Disco
Figura
7-24
maneras
organizar
archivos
multimedia
discos
bandas
patrón
bandas
archivos
Bandas
esca-
lonadas
Bandas
aleatorias
www.FreeLibros.mecuadros
fragmentos
sistema
emitir
peticiones
bloques
película
petición
leer
datos
colocarlos
búfer
distinto
me-
moria
forma
completen
peticiones
trozo
contiguo
película
contenga
cuadros
ensamblado
memoria
forma
contigua
peticiones
proceder
paralelo
cumplido
petición
proceso
solicitud
recibe
señal
trabajo
completado
empe-
zar
transmitir
datos
usuario
cuadros
búfer
encuentre
cuadros
emiten
peticiones
cargar
búfer
forma
anticipada
méto-
do
utiliza
cantidades
memoria
búfer
discos
mantengan
ocupados
sistema
1000
usuarios
activos
búferes
MB
ejemplo
utilizando
bloques
256
KB
discos
necesita
GB
RAM
búferes
Di-
cha
cantidad
relativamente
servidor
1000
usuarios
problema
cuestión
relación
división
bandas
discos
necesario
utili-
zar
extremo
película
divide
bandas
discos
ejemplo
pe-
lículas
GB
discos
1000
escribir
bloque
MB
disco
película
utilice
disco
extremo
discos
particionan
pe-
queños
grupos
figura
7.24
película
restringe
partición
método
conocido
división
bandas
amplias
realiza
trabajo
balancear
car-
ga
discos
principal
problema
película
utiliza
discos
dis-
co
falla
mostrar
película
método
conocido
división
bandas
estrechas
sufrir
puntos
activos
particiones
populares
pérdida
disco
arruina
películas
partición
división
bandas
cuadros
tamaño
va-
riable
analiza
detalle
sentido
matemático
Shenoy
Vin
1999
7.8
CACHÉ
caché
archivos
LRU
tradicional
funciona
archivos
multimedia
patrones
acceso
películas
distintos
patrones
acceso
archivos
texto
idea
cachés
tradicionales
búfer
LRU
utilizar
blo-
mantener
caché
caso
vuelva
necesitar
inmediato
ejem-
plo
editar
archivo
conjunto
bloques
escribe
archivo
tienden
utilizarse
termine
sesión
edición
palabras
probabi-
lidad
relativamente
alta
reutilizará
bloque
intervalo
corto
vale
pena
mantenerlo
mano
eliminar
futuro
acceso
disco
multimedia
patrón
acceso
ordinario
película
vea
principio
forma
secuencial
improbable
bloque
utilice
usua-
rio
rebobine
película
escena
consecuencia
técnicas
caché
normales
funcionan
caché
ayudar
formas
utiliza
distinta
siguientes
secciones
analizaremos
caché
multi-
media
510
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meSECCIÓN
7.8
CACHÉ
511
7.8.1
Caché
bloque
sentido
mantener
bloque
mano
esperanza
volver
utilizar
rápidamente
predictibilidad
sistemas
multimedia
explotar
caché
vuelva
utilidad
Suponga
usuarios
viendo
película
empezó
segundos
usuario
obtenido
vis-
to
bloque
probable
usuario
necesitar
blo-
segundos
sistema
fácilmente
películas
espectador
espectadores
espaciados
intervalo
corto
lee
bloque
película
necesitará
tiempo
sentido
colocarlo
caché
dependiendo
tiempo
caché
tanta
memoria
disponible
mantener
bloques
disco
caché
descartar
bloque
reciente
llena
utilizar
estrategia
di-
ferente
película
espectador
intervalo
∆T
espectador
marcar
colocarse
caché
bloques
colocar
ca-
ché
espectador
posiblemente
utilizado
pe-
lículas
utiliza
caché
tipo
idea
llevarse
lejos
casos
factible
combinar
flujos
Suponga
usuarios
viendo
película
retraso
10
segun-
contener
bloques
caché
10
segundos
desperdicia
memoria
método
alternativo
furtivo
tratar
sincronizar
películas
lograr
cambiar
velocidad
cuadro
ambas
películas
idea
ilustra
figura
7-25
figura
7.25(a
ambas
películas
reproducen
velocidad
NTSC
1800
cuadros
mi-
nuto
usuario
empezó
10
segundos
continuará
desfasamiento
10
se-
gundos
película
figura
7-25(b
reduce
velocidad
flujo
usuario
aparece
usuario
reproducir
1800
cuadros
minuto
siguientes
minutos
reproduce
1750
cuadros
minuto
minutos
cua-
dro
5550
flujo
usuario
reproduce
1850
cuadros
minuto
minutos
coloca
cuadro
5550
punto
flu-
jos
reproducen
velocidad
normal
periodo
recuperación
flujo
usuario
reproduce
2.8%
lento
flu-
jo
usuario
2.8%
rápido
probable
usuarios
detecten
preocupante
periodo
recuperación
distribuir
intervalo
mi-
nutos
alternativa
reducir
velocidad
flujo
usuario
combinarlo
flujo
usuarios
opción
comerciales
películas
ofrecerlas
menor
costo
películas
comerciales
usuario
elegir
catego-
rías
productos
comerciales
intrusivos
probabilida-
des
vistos
manipular
número
longitud
sincronización
comerciales
flujo
retener
tiempo
suficiente
sincronizarse
flujo
deseado
Krish-
nan
1999
www
FreeLibros.me7.8.2
Caché
archivo
caché
útil
sistemas
multimedia
distinta
tamaño
mayoría
películas
GB
común
servidores
video
pue-
almacenar
películas
disco
mantienen
DVD
cinta
necesita
película
copiar
disco
tiempo
inicio
conside-
rable
localizar
película
copiarla
disco
consecuencia
mayoría
servidores
video
mantienen
caché
disco
películas
populares
guardan
comple-
tamente
disco
utilizar
caché
mantener
minutos
película
dis-
co
forma
solicite
película
reproducción
empezar
inmediato
des-
archivo
disco
película
copiará
DVD
cinta
disco
almacenar
cantidad
suficiente
película
disco
momento
probabilidad
alta
pieza
película
obtenido
necesitar-
sale
película
completa
disco
necesitarla
Des-
512
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
10
seg
min
min
min
min
Usuario
Usuario
Empieza
10
seg
Tiempo
Usuario
Usuario
reproduce
rapidez
Velocidad
normal
reproduce
lentitud
Velocidad
normal
Figura
7-25
usuarios
viendo
película
desfasados
10
segundos
Combinación
flujos
www
FreeLibros.meSECCIÓN
7.9
PROGRAMACIÓN
DISCOS
MULTIMEDIA
513
pués
pasará
caché
permanecerá
disco
caso
peticiones
posteriormen-
pasa
tiempo
petición
película
eliminará
caché
ha-
cer
espacio
película
popular
7.9
PROGRAMACIÓN
DISCOS
MULTIMEDIA
multimedia
impone
distintas
demandas
discos
aplicaciones
tradicionales
orientadas
texto
compiladores
procesadores
palabras
especial
mul-
timedia
demanda
velocidad
datos
extremo
alta
entrega
tiempo
real
datos
irrelevante
caso
servidor
video
presión
económica
servidor
maneje
cientos
clientes
tiempo
requerimientos
impactan
sistema
sección
analizamos
sistema
archivos
continuación
veremos
programación
discos
multimedia
7.9.1
Programación
discos
estática
multimedia
impone
enormes
demandas
tiempo
real
velocidad
datos
partes
sistema
propiedad
manejo
proceso
sencillo
sistema
tradicional
predictibilidad
sistema
operativo
tradicional
realizan
pe-
ticiones
bloques
disco
impredecible
subsis-
tema
disco
lectura
adelantada
bloque
archivo
abierto
Aparte
esperar
lleguen
peticiones
procesarlas
demanda
Multimedia
distinta
flujo
activo
impone
carga
definida
sistema
predecible
reproducción
NTSC
33.3
mseg
cliente
desea
cuadro
archivo
sistema
33.3
mseg
proporcionar
cuadros
sistema
necesita
co-
locar
búfer
cuadro
flujo
obtención
cuadro
/H110011
pue-
proceder
paralelo
reproducción
cuadro
carga
predecible
utilizar
programar
disco
algoritmos
optimizados
operación
multimedia
continuación
consideraremos
disco
idea
aplicar
discos
ejemplo
suponer
10
usuarios
viendo
película
distinta
supondremos
películas
tie-
nen
resolución
velocidad
cuadro
propiedades
Dependiendo
resto
sistema
computadora
10
procesos
flu-
jo
video
proceso
10
hilos
proceso
hilo
maneje
10
flujos
turno
rotatorio
detalles
importantes
importa
tiempo
divide
rondas
ronda
tiempo
cuadro
33.3
mseg
NTSC
40
mseg
PAL
inicio
ronda
genera
petición
disco
usuario
muestra
figura
7-26
llegan
peticiones
inicio
ronda
disco
ronda
llegarán
peticiones
hayan
pro-
cesado
existentes
empezado
ronda
consecuencia
ordenar
pe-
ticiones
óptima
probablemente
orden
cilindro
orden
www.FreeLibros.mesector
casos
procesarlas
orden
óptimo
figura
7-26
peticiones
muestran
ordenadas
cilindro
instancia
podríamos
pensar
caso
optimizar
disco
forma
disco
cumpla
tiempo
respuesta
importa
cumple
mseg
10
mseg
sobra
obstante
conclusión
falsa
optimizar
búsquedas
forma
tiempo
promedio
procesar
petición
reduce
significa
disco
ma-
nejar
flujos
ronda
promedio
palabras
optimizar
peticiones
disco
forma
incrementa
número
películas
servidor
transmitir
tiempo
tiempo
sobra
ronda
utilizar
servicio
peticiones
puedan
existir
tiempo
real
servidor
demasiados
flujos
cumplirá
tiempo
res-
puesta
pida
obtenga
cuadros
partes
distantes
disco
tiem-
pos
respuesta
cumpla
ocurran
frecuencia
tolerarse
cambio
manejar
flujos
importa
número
flujos
obtener
Te-
ner
clientes
flujo
afecta
rendimiento
disco
programación
flujo
datos
clientes
movimiento
uniforme
necesita
doble
búfer
servidor
ronda
utiliza
conjunto
búferes
búfer
flu-
jo
termina
ronda
desbloquea(n
proceso(s
salida
le(s
indica
transmita(n
cuadro
tiempo
llegan
peticiones
cuadro
pelí-
cula
hilo
disco
hilo
salida
película
peticiones
de-
ben
cumplir
conjunto
búferes
ocupados
empieza
ronda
conjunto
búferes
libre
reutili-
zar
obtener
cuadro
asumido
ronda
cuadro
limitación
estrictamente
nece-
saria
rondas
cuadro
reducir
cantidad
espacio
búfer
requerido
cambio
doble
operaciones
disco
similar
obtener
cua-
514
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
701
92
281
130
326
410
160
466
204
10
524
92
130
160
204
281
326
410
466
524
701
Flujo
Algoritmo
optimización
Orden
procesan
peticiones
disco
Búfer
cuadros
impares
Búfer
cuadros
pares
solicita
bloque
Figura
7-26
ronda
película
pide
cuadro
www
FreeLibros.meSECCIÓN
7.9
PROGRAMACIÓN
DISCOS
MULTIMEDIA
515
dros
disco
ronda
suponiendo
almacenen
pares
cuadros
forma
contigua
disco
diseño
recorta
número
operaciones
disco
mitad
cambio
dupli-
car
cantidad
espacio
búfer
requerido
Dependiendo
disponibilidad
relativa
rendi-
miento
costo
memoria
comparación
disco
calcular
utilizar
estrategia
óptima
7.9.2
Programación
disco
dinámica
ejemplo
hicimos
suposición
flujos
resolución
ve-
locidad
cuadro
propiedades
retirar
suposición
distintas
pelícu-
distintas
velocidades
datos
ronda
33.3
mseg
obtener
cuadro
flujo
peticiones
llegan
disco
for-
ma
aleatoria
petición
lectura
especifica
bloque
leer
momento
ne-
cesita
bloque
tiempo
respuesta
aras
simplicidad
suponer
tiempo
servicio
actual
petición
definitiva
cier-
to
forma
restar
tiempo
servicio
fijo
petición
obtener
tiempo
retrasado
iniciar
petición
dejar
cumplir
tiempo
respues-
ta
simplifica
modelo
preocupa
programador
disco
tiempo
respuesta
programar
petición
sistema
inicia
peticiones
disco
pendientes
llega
pe-
tición
atiende
inmediato
realiza
búsqueda
llegar
peticio-
nes
termina
petición
driver
controlador
disco
opción
elegir
petición
procesar
selecciona
petición
inicia
completa
petición
conjunto
peticiones
posibles
selecciona-
ron
peticiones
llegaron
procesando
pe-
tición
general
completa
petición
disco
driver
conjunto
peticiones
pendientes
elegir
pregunta
algoritmo
utiliza
seleccionar
petición
servicio
factores
participan
selección
petición
disco
tiempos
res-
puesta
cilindros
punto
vista
rendimiento
mantener
peticiones
ordenadas
cilindro
utilizar
algoritmo
elevador
minimiza
tiempo
búsqueda
pue-
provocar
peticiones
cilindros
periféricos
cumplan
tiempo
respuesta
punto
vista
tiempo
real
ordenar
peticiones
base
tiempo
respuesta
procesarlas
orden
tiempo
respuesta
cercano
minimiza
probabilidad
cumplir
tiempos
respuesta
aumenta
tiempo
búsqueda
factores
combinar
algoritmo
scan-EDF
Reddy
Wyllie
1994
idea
básica
algoritmo
recolectar
peticiones
cuyos
tiempos
entrega
estén
re-
lativamente
cerca
colocarlas
lotes
procesarlas
orden
cilindro
ejemplo
conside-
re
situación
figura
7-27
/H11005700
driver
disco
11
peticiones
pendientes
tiempos
respuesta
cilindros
ejemplo
optar
tratar
peticiones
tiempos
respuesta
cercanos
lote
ordenarlas
número
www.FreeLibros.mede
cilindro
utilizar
algoritmo
elevador
atenderlas
orden
cilindro
orden
110
330
440
676
680
petición
complete
tiempo
respuesta
peticiones
volver
ordenar
problemas
minimizar
tiempo
búsqueda
requerido
516
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
Peticiones
ordenadas
tiempo
respuesta
676
700
710
720
730
740
750
330
110
680
440
220
755
280
550
812
103
Tiempo
respuesta
mseg
Cilindro
Juntar
lote
Figura
7-27
algoritmo
scan-EDF
utiliza
tiempos
respuesta
números
cilindro
programación
flujos
distintas
velocidades
datos
surge
pregunta
importante
aparece
cliente
admitir
admisión
cliente
ocasionar
flujos
cumplan
tiempos
respuesta
frecuencia
respuesta
probablemen-
formas
calcular
admitir
cliente
asumir
cliente
necesita
cantidad
recursos
promedio
ejemplo
ancho
banda
disco
búferes
memoria
tiempo
CPU
etc.
suficiente
recurso
cliente
promedio
admite
cliente
algoritmo
detallado
análisis
película
especifica
desea
nue-
vo
cliente
analiza
velocidad
datos
calculada
anterioridad
película
dis-
tinta
dependiendo
blanco
negro
color
dibujos
animados
filmada
actores
historia
amor
filme
guerra
historias
amor
mueven
lentitud
escenas
largas
desvanecimientos
cruzados
lentos
comprime
problema
filmes
guerra
cortes
rápidos
acción
violenta
requieran
cuadros
cuadros
servidor
suficiente
capacidad
filme
específico
desea
cliente
admite
cliente
caso
con-
trario
niega
acceso
7.10
INVESTIGACIÓN
MULTIMEDIA
Multimedia
tema
moda
cantidad
considerable
investigación
campo
investigación
contenido
herramientas
aplicaciones
construcción
allá
alcance
libro
tema
popular
multimedia
redes
alcance
trabajo
servidores
mul-
timedia
especial
distribuidos
relacionado
sistemas
operativos
Sarhan
Das
2004
Matthur
Mundur
2004
Zaia
colaboradores
2004
soporte
sistemas
archi-
www
FreeLibros.meSECCIÓN
7.11
RESUMEN
517
vos
multimedia
tema
investigación
comunidad
sistemas
operativos
Ahn
colaboradores
2004
Cheng
colaboradores
2005
Kang
colaboradores
2006
Park
Ohm
2006
codificación
audio
video
especial
aplicaciones
3D
importan-
alto
rendimiento
temas
sujetos
investigación
Chatto-
padhyay
colaboradores
2006
Hari
colaboradores
2006
Kum
Mayer-Patel
2006
calidad
servicio
importante
sistemas
multimedia
tema
recibe
atención
Childs
Ingram
2001
Tamai
colaboradores
2004
programación
re-
lacionada
calidad
servicio
CPU
Etsion
colaboradores
2004
Etsion
co-
laboradores
2006
Nieh
Lam
2003
Yuan
Nahrstedt
2006
disco
Lund
Goebel
2003
Reddy
colaboradores
2005
transmitir
programación
multimedia
clientes
paga
seguridad
importan-
recibiendo
atención
Barni
2006
7.11
RESUMEN
Multimedia
área
aplicación
computadoras
amplio
crecimiento
tamaño
archivos
multimedia
estrictos
requerimientos
reproducción
tiempo
real
sistemas
operativos
diseñados
texto
óptimos
multimedia
archivos
multimedia
consisten
pistas
paralelas
general
pista
video
me-
audio
incluyen
pistas
subtítulos
pistas
de-
ben
sincronizadas
reproducción
grabar
audio
muestrea
volumen
forma
periódica
general
44,100
veces-
/segundo
sonido
calidad
CD
aplicar
compresión
señal
audio
obtiene
proporción
compresión
uniforme
10x
compre-
sión
video
utiliza
compresión
cuadro
JPEG
compresión
cuadros
MPEG
representa
cuadros
diferencias
cuadro
cuadros
basar
cuadro
Multimedia
necesita
programación
tiempo
real
cumplir
tiempos
respuesta
Comúnmente
utilizan
algoritmos
programación
monotónica
frecuencia
algoritmo
preferente
estático
asigna
prioridades
fijas
procesos
base
periodos
tiempo
respuesta
cercano
algorit-
mo
dinámico
selecciona
proceso
tiempo
respuesta
cercano
algo-
ritmo
EDF
complicado
obtener
100%
utilización
RMS
lograr
sistemas
archivos
multimedia
utilizan
general
modelo
empuje
push
modelo
extracción
pull
inicia
flujo
bits
llegan
disco
peticiones
usuario
método
distinto
sistemas
ope-
rativos
convencionales
necesita
cumplir
requerimientos
tiempo
real
archivos
almacenar
forma
contigua
caso
unidad
longitud
variable
bloque
contiene
cuadro
longitud
fija
bloque
contiene
mu-
chos
cuadros
métodos
distintas
concesiones
www
FreeLibros.meLa
colocación
archivos
disco
afecta
rendimiento
archivos
algu-
nas
utiliza
algoritmo
órgano
tubos
común
dividir
bandas
archivos
discos
bandas
estrechas
amplias
utilizan
estrategias
ca-
ché
bloque
archivo
mejorar
rendimiento
PROBLEMAS
enviar
televisión
NTSC
blanco
negro
compresión
Fast
Ethernet
canales
enviar
HDTV
doble
resolución
horizontal
TV
regular
1280
píxeles
comparación
640
píxeles
Utilizando
información
proporciona
texto
requiere
an-
cho
banda
TV
estándar
figura
7-3
archivos
separados
avance
rápido
retroceso
rápido
servidor
video
intenta
soporte
movimiento
cámara
lenta
requiere
archivo
movimiento
cámara
lenta
sentido
sentido
inverso
señal
sonido
muestrea
utilizando
número
16
bits
signo
bit
signo
15
bits
magnitud
máximo
ruido
cuantificación
porcentaje
problema
conciertos
flauta
rock
and
roll
Explique
res-
puesta
estudio
grabación
capaz
grabación
digital
maestra
utilizando
muestreo
20
bits
distribución
oyentes
utilizará
16
bits
Sugiera
reducir
efec-
to
ruido
cuantificación
explique
ventajas
desventajas
esquema
transformación
DCT
utiliza
bloque
/H110038
algoritmo
utiliza
compen-
sación
movimiento
utiliza
bloque
16
/H1100316
Acaso
diferencia
ocasiona
problemas
resuelven
MPEG
figura
7-10
vimos
funciona
MPEG
fondo
estacionario
actor
movimien-
to
Suponga
crea
video
MPEG
escena
cámara
monta
trípode
mueve
lentamente
izquierda
derecha
velocidad
cuadros
consecutivos
iguales
Acaso
cuadros
cuadros
Suponga
procesos
figura
7-13
acompañado
proceso
so-
porta
flujo
audio
opera
periodo
proceso
video
bú-
feres
audio
actualizar
cuadros
video
procesos
audio
idénticos
tiempo
CPU
disponible
ráfaga
proceso
audio
procesos
tiempo
real
ejecutan
computadora
ejecuta
25
mseg
10
mseg
ejecuta
40
mseg
15
mseg
Funcionará
RMS
procesos
10
CPU
servidor
video
utilización
65%
películas
mostrar
uti-
lizando
programación
RMS
518
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
519
11
figura
7-15
EDF
mantiene
ocupada
CPU
100%
tiempo
/H11005150
man-
ocupada
CPU
tiempo
indefinido
975
mseg
trabajo
Extienda
figura
allá
150
mseg
determine
CPU
inactiva
EDF
12
DVD
contener
datos
suficientes
película
completa
velocidad
transferen-
cia
adecuada
mostrar
programa
calidad
televisión
utilizar
granja
unidades
DVD
origen
datos
servidor
video
13
operadores
sistema
video
demanda
descubierto
personas
cier-
ta
ciudad
desean
esperar
minutos
empiece
película
flujos
pa-
ralelo
necesitan
película
horas
14
Considere
sistema
utilice
esquema
Abram-Profeta
Shin
operador
ser-
vidor
video
desea
clientes
puedan
buscar
atrás
minuto
to-
do
tiempo
forma
local
Suponiendo
flujo
video
MPEG-2
Mbps
espacio
búfer
cliente
forma
local
15
Considere
método
Abram-Profeta
Shin
usuario
RAM
50
MB
pue-
utilizar
búfer
valor
∆T
flujo
video
Mbps
16
sistema
video
demanda
HDTV
utiliza
modelo
bloques
pequeños
figura
7-20(a
bloque
disco
KB
resolución
video
1280
/H11003720
flujo
datos
12
Mbps
espacio
disco
desperdicia
fragmentación
interna
película
horas
utiliza
NTSC
17
Considere
esquema
asignación
almacenamiento
figura
7-20(a
NTSC
PAL
Pa-
ra
bloque
disco
tamaño
película
específicos
acaso
sufre
frag-
mentación
interna
18
Considere
alternativas
muestran
figura
7-20
Favorece
cambio
HDTV
sistemas
Explique
respuesta
19
Considere
sistema
bloque
disco
KB
almacena
película
PAL
horas
promedio
16
KB
cuadro
espacio
promedio
desperdiciado
utiliza
método
almacenamiento
bloques
pequeños
disco
20
ejemplo
entrada
cuadro
requiere
bytes
utiliza
byte
pa-
ra
indicar
número
bloques
disco
cuadro
tamaño
película
almacenar
21
esquema
video
demanda
Chen
Thapar
funciona
conjunto
cuadros
tamaño
Suponga
mostrar
película
24
flujos
simultáneos
cuadro
10
cuadro
I.
Suponga
cuadros
10
gran-
des
cuadros
P.
cuadros
tamaño
cuadros
P.
probabi-
lidad
búfer
cuadros
20
cuadros
Cree
tamaño
búfer
aceptable
problema
rastrear
suponga
tipos
cuadros
distribuyen
forma
aleatoria
independiente
flujos
22
método
Chen
Thapar
pistas
requieren
cuadros
35
pistas
requieren
cua-
dros
45
pistas
requieren
cuadros
15
cuadros
requieren
cuadros
debería
tamaño
búfer
asegurar
búfer
contener
95
cuadros
www
FreeLibros.me23
método
Chen
Thapar
suponga
película
horas
codificada
formato
PAL
necesita
transmitirse
flujo
continuo
15
minutos
flujos
concurrentes
necesitan
24
resultado
figura
7-18
punto
reproducción
búfer
Idee
esquema
minutos
punto
reproducción
mi-
nutos
Haga
suposición
razonable
requiera
establézcala
ma-
nera
explícita
25
diseño
figura
7-19
requiere
lean
pistas
lenguaje
cuadro
Supon-
ga
diseñadores
servidor
video
soportar
cantidad
lenguajes
quieren
dedicar
tanta
RAM
búferes
contener
cuadro
alternativas
disponibles
ventajas
desventajas
26
servidor
video
pequeño
películas
predice
ley
Zipf
probabili-
dades
película
popular
película
popular
sucesivo
pe-
lícula
popular
27
disco
14
GB
1000
cilindros
utiliza
contener
1000
clips
video
MPEG-2
30
segundos
reproducen
Mbps
almacenan
algoritmo
órgano
tu-
bos
Suponiendo
ley
Zipf
fracción
tiempo
invertirá
brazo
disco
10
cilin-
dros
28
Suponiendo
demanda
relativa
filmes
describe
ley
Zipf
utilización
relativa
esperada
discos
figura
7-24
méto-
división
bandas
muestran
29
clientes
video
demanda
empezaron
película
PAL
segundos
di-
ferencia
sistema
aumenta
velocidad
flujo
disminuye
velocidad
puedan
combinar
porcentaje
aumento
disminución
velocidad
necesita
combi-
narlos
minutos
30
servidor
video
MPEG-2
utiliza
esquema
rondas
figura
7-26
video
NTSC
videos
provienen
disco
SCSI
UltraWide
10,800
rpm
tiempo
bús-
queda
promedio
mseg
flujos
soportar
31
Repita
problema
suponga
scan-EDF
reduce
tiempo
búsqueda
pro-
20%
flujos
soportar
32
Considere
conjunto
peticiones
disco
petición
representa
tupla
Tiempo
respuesta
mseg
Cilindro
utiliza
algoritmo
scan-EDF
agrupan
tiempos
respuesta
servicio
tiempo
promedio
servicio
petición
mseg
deja
cumplir
tiempo
respuesta
32
300
36
500
40
210
34
310
Suponga
tiempo
actual
15mseg
33
Repita
problema
suponga
cuadro
divide
bandas
discos
algoritmo
scan-EDF
proporciona
20%
disco
flujos
soportar
520
SISTEMAS
OPERATIVOS
MULTIMEDIA
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
521
34
texto
describe
lote
peticiones
disco
programar
situación
descrita
figura
7-27(a
peticiones
requieren
cantidad
tiempo
equitativa
máximo
tiempo
petición
permisible
ejemplo
35
imágenes
mapa
bits
proporcionan
generar
papel
tapiz
compu-
tadora
utilizan
colores
comprimen
facilidad
esquema
compresión
simple
elegir
valor
datos
aparezca
archivo
entrada
utilizarlo
bandera
Leer
archivo
byte
byte
buscando
valores
bytes
repetidos
Copiar
valores
individuales
bytes
repetidos
directamente
archivo
salida
encuentre
cade-
na
repetida
bytes
escribir
archivo
salida
cadena
bytes
consista
byte
bandera
byte
indique
255
valor
actual
encontró
archivo
entrada
Escriba
programa
compresión
utilice
algoritmo
programa
descompresión
restaurar
archivo
original
Crédito
adicional
lidiar
archivos
contienen
byte
bandera
datos
36
animación
computadora
logra
mostrar
secuencia
imágenes
ligeramente
distintas
Escriba
programa
calcular
diferencia
byte
byte
imágenes
mapa
bits
descomprimidas
dimensiones
salida
tamaño
archivos
entrada
Utilice
archivo
diferencias
entrada
programa
compre-
sión
problema
compare
efectividad
método
compresión
imágenes
individuales
37
Implemente
algoritmos
básicos
RMS
EDF
descripción
texto
principal
entrada
programa
archivo
líneas
línea
denote
petición
pro-
ceso
obtener
CPU
siguientes
parámetros
periodo
segundos
tiempo
cómputo
segundos
tiempo
inicio
segundos
tiempo
segundos
Compare
algoritmos
términos
número
promedio
peticiones
CPU
bloquean
CPU
programar
promedio
CPU
tiempo
espera
promedio
petición
CPU
número
promedio
tiempos
respuesta
cumplieron
38
Implemente
técnicas
longitud
tiempo
constante
longitud
datos
constante
almace-
nar
archivos
multimedia
entrada
principal
programa
conjunto
archivos
don-
archivo
contiene
metadatos
acerca
cuadro
archivo
multimedia
comprimido
MPEG-2
ejemplo
película
metadatos
incluyen
tipo
cuadro
longitud
cuadro
cuadros
audio
asociados
etc.
distintos
tamaños
bloques
archi-
vo
compare
técnicas
términos
almacenamiento
requerido
espacio
disco
des-
perdiciado
RAM
promedio
requerida
39
sistema
agregue
programa
lector
seleccione
archivos
azar
entrada
reproducirlos
modos
video
demanda
video
demanda
fun-
ción
VCR
Implemente
algoritmo
scan-EDF
ordenar
peticiones
lectura
disco
Compare
esquemas
longitud
tiempo
constante
longitud
datos
constante
términos
número
promedio
búsquedas
disco
archivo
www.FreeLibros.me
www
FreeLibros.me8
SISTEMAS
MÚLTIPLES
PROCESADORES
523
inicio
industria
computadoras
orientado
fundamentalmente
buscar
pausa
cómputo
ENIAC
podía
300
operaciones
segun-
do
1000
rápida
calculadora
personas
satisfechas
máquinas
actuales
millones
rápidas
ENIAC
existiendo
demanda
potencia
cómputo
astrónomos
tratando
entender
universo
biólogos
tratan
comprender
implicaciones
genoma
humano
ingenieros
aeronáuticos
interesados
construir
aeronaves
seguras
efi-
cientes
requieren
ciclos
CPU
importa
cómputo
disponible
suficiente
solución
reloj
operara
velocidad
des-
gracia
comenzando
toparnos
límites
fundamentales
velocidad
reloj
teoría
especial
relatividad
Einstein
señal
eléctrica
propagar
rápido
velocidad
luz
30
cm
nseg
vacío
20
cm
nseg
alambre
cobre
fibra
óptica
significa
compu-
tadora
reloj
10
GHz
señales
viajar
cm
com-
putadora
100
GHz
longitud
ruta
mm
computadora
THz
1000
GHz
tendría
pequeña
100
micrones
dejar
señal
pase
extremo
regrese
ciclo
reloj
fabricar
computadoras
pequeñas
llegamos
pro-
blema
fundamental
disipación
calor
rápido
opera
computadora
calor
ge-
nera
pequeña
difícil
deshacerse
calor
antemano
sistemas
www
FreeLibros.mePentium
alto
rendimiento
enfriador
CPU
CPU
pasar
MHz
GHz
requirió
ingeniería
proceso
fabri-
cación
chip
pasar
GHz
THz
requerir
metodología
radicalmente
distinta
metodología
obtener
velocidad
computadoras
masiva-
mente
paralelo
máquinas
consisten
CPUs
opera
velocidad
normal
signifique
año
específico
conjunto
cómputo
CPU
sistemas
1000
CPUs
disponibles
comercialmente
probable
construyan
sistemas
millón
CPUs
dé-
metodologías
potenciales
obtener
velocidad
compu-
tadoras
biológicas
capítulo
enfocaremos
sistemas
CPUs
conven-
cionales
computadoras
altamente
paralelas
utilizan
frecuencia
cálculo
numérico
in-
tensivo
Problemas
predicción
clima
modelado
flujo
aire
ala
aeronave
simulación
economía
mundial
comprensión
interacciones
receptores
fármacos
cerebro
actividades
requieren
cómputo
intensivo
so-
luciones
requieren
largas
ejecuciones
CPUs
sistemas
múltiples
proce-
sadores
analizaremos
capítulo
utilizan
problemas
similares
ciencia
ingeniería
áreas
desarrollo
relevante
increíblemente
rápido
crecimiento
Internet
diseñó
origen
prototipo
sistema
control
militar
tolerante
fallas
po-
pular
científicos
computacionales
universitarios
tiempo
adquirió
usos
vincular
miles
computadoras
mundo
trabajen
conjunto
problemas
científicos
grado
sistema
consiste
1000
computadoras
esparcidas
mundo
distinto
consiste
1000
computado-
ras
cuarto
retraso
características
técnicas
con-
sideraremos
sistemas
capítulo
fácil
colocar
millón
computadoras
relacionadas
habitación
cuan-
do
dinero
suficiente
habitación
Esparcir
millón
compu-
tadoras
relacionadas
mundo
sencillo
segun-
do
problema
dificultades
empiezan
computadoras
comuniquen
trabajen
conjunto
problema
consecuencia
trabajo
tecnología
interconexión
distintas
tecnologías
interconexión
producido
tipos
sistemas
calidad
distintas
organizaciones
software
instancia
comunicación
componentes
electrónicos
ópticos
ba-
sa
envío
mensajes
cadenas
bits
definidas
diferencias
escala
tiempo
escala
distancia
organización
lógica
involucrada
extremo
encuentran
multiprocesadores
memoria
compartida
cantidad
CPUs
en-
tre
1000
comunican
memoria
compartida
modelo
CPU
acceso
memoria
física
leer
escribir
palabras
individua-
instrucciones
LOADy
STORE
acceder
palabra
memoria
general
requieren
10
nseg
modelo
ilustra
figura
8-1(a
simple
realidad
sencillo
implementarlo
general
implica
paso
mensajes
524
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORESPROCESOS
525
interna
explicaremos
proceso
paso
mensajes
invisible
programadores
CC
CMemoria
compar-
tida
Interco-
nexión
CPU
Memoria
local
C+
C+
C+
C+
C+
C+
Sistema
completo
Internet
Figura
8-1
multiprocesador
memoria
compartida
multicompu-
tadora
paso
mensajes
sistema
distribuido
área
amplia
continuación
sistema
figura
8-1(b
pares
CPU-memoria
conectan
interconexión
alta
velocidad
tipo
sistema
conoce
multi-
computadora
paso
mensajes
memoria
local
CPU
utilizada
CPU
CPUs
comunican
enviando
mensajes
palabras
in-
terconexión
interconexión
mensaje
corto
enviar
tiempo
10
50
µseg
tiempo
acceso
memoria
figura
8-1(a
me-
moria
global
compartida
diseño
multicomputadoras
sistemas
paso
men-
sajes
fáciles
construir
multiprocesadores
memoria
compartida
difíciles
programar
género
admiradores
tercer
modelo
ilustra
figura
8-1(c
conecta
sistemas
cómputo
completos
tra-
vés
red
área
amplia
Internet
formar
sistema
distribuido
es-
tos
sistemas
memoria
sistemas
comunican
paso
mensajes
única
diferencia
real
figura
8-1(b
figura
8-1(c
utilizan
compu-
tadoras
completas
tiempos
mensajes
comúnmente
10
100
mseg
retraso
obliga
sistemas
débilmente
acoplados
utilicen
maneras
distintas
sis-
temas
fuertemente
acoplados
figura
8-1(b
tipos
sistemas
difieren
retrasos
cantidad
aproximada
órdenes
magnitud
diferencia
años
capítulo
consta
secciones
principales
corresponden
modelos
figura
8-1
sección
virtualización
software
crear
apa-
riencia
CPUs
sección
empezaremos
introducción
hardware
rele-
vante
pasaremos
software
especial
cuestiones
relacionadas
sistema
operativo
tipo
sistema
veremos
caso
cuestiones
presen-
tes
requieren
distintas
metodologías
www
FreeLibros.me8.1
MULTIPROCESADORES
multiprocesador
memoria
compartida
multiprocesador
sistema
cómputo
CPUs
comparten
acceso
RAM
común
programa
ejecuta
cualquiera
CPUs
ve
espacio
normal
direcciones
virtuales
general
paginadas
única
propiedad
inusual
sistema
CPU
escribir
valor
palabra
memoria
volver
leer
palabra
obtener
valor
distinto
CPU
cambió
organiza
forma
correcta
pro-
piedad
forma
base
comunicación
procesadores
CPU
escribe
datos
memoria
lee
datos
sistemas
operativos
multiprocesadores
sistemas
operativos
re-
gulares
Manejan
llamadas
sistema
administran
memoria
proveen
sistema
archivos
administran
dispositivos
S.
áreas
característi-
cas
únicas
áreas
sincronización
procesos
administración
recursos
progra-
mación
tareas
continuación
analizaremos
brevedad
hardware
multiprocesadores
pasaremos
cuestiones
relacionadas
sistemas
operativos
8.1.1
Hardware
multiprocesador
multiprocesadores
propiedad
CPU
direccionar
memoria
característica
adicional
palabra
memoria
leer
velocidad
palabra
memoria
máquinas
conocen
multipro-
cesadores
UMA
Uniform
Memory
Access
Acceso
uniforme
memoria
contrario
mul-
tiprocesadores
NUMA
Non-uniform
Memory
Access
Acceso
uniforme
memoria
propiedad
aclararemos
diferencia
examinaremos
multiprocesadores
UMA
NUMA
Multiprocesadores
UMA
arquitecturas
basadas
bus
multiprocesadores
simples
basan
bus
ilustra
figura
8-2(a
CPUs
módulos
memoria
utilizan
bus
comunicarse
CPU
desea
leer
palabra
memoria
comprueba
bus
ocupado
inactivo
CPU
coloca
dirección
palabra
desea
bus
declara
seña-
control
espera
memoria
coloque
palabra
deseada
bus
bus
ocupado
CPU
desea
leer
escribir
memoria
CPU
espera
só-
bus
esté
inactivo
problema
diseño
CPUs
contención
bus
manejable
32
64
imposible
sistema
esta-
rá
totalmente
limitado
ancho
banda
bus
mayoría
CPUs
estarán
inactivas
tiempo
solución
problema
agregar
caché
CPU
ilustra
figu-
ra
8.2(b
caché
chip
CPU
tablero
procesa-
dor
combinación
opciones
anteriores
permite
satisfacer
526
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
527
operaciones
lectura
caché
local
tráfico
bus
sistema
soportar
CPUs
general
caché
realiza
palabra
individual
bloques
32
64
bytes
referencia
palabra
obtiene
bloque
completo
conocido
línea
caché
coloca
caché
CPU
contacto
bloque
caché
marca
lectura
cuyo
caso
presente
cachés
tiempo
lectura-escritura
presente
ca-
chés
CPU
escribir
palabra
cachés
remotas
hardware
bus
detecta
escritura
coloca
señal
bus
informar
cachés
so-
bre
operación
escritura
cachés
copia
limpia
copia
exacta
memoria
descartar
copias
dejar
CPU
escri-
bir
obtenga
bloque
caché
memoria
modificarla
caché
copia
sucia
modificada
escribirla
vuelta
memoria
conti-
nuar
escritura
transferirla
directamente
CPU
operación
escritura
bus
conjunto
reglas
conoce
protocolo
coherencia
cachés
posibilidad
diseño
figura
8-2(c
CPU
caché
memoria
privada
local
utiliza
bus
dedicado
privado
utilizar
es-
ta
configuración
óptima
compilador
colocar
texto
programa
cade-
nas
constantes
datos
lectura
pilas
variables
locales
memorias
privadas
forma
memoria
compartida
utiliza
escribir
variables
compartidas
mayoría
casos
cuidadosa
colocación
reducirá
considerable
tráfico
bus
requiere
cooperación
activa
compilador
Multiprocesadores
UMA
utilizan
interruptores
barras
cruzadas
caché
bus
limita
tamaño
multiprocesador
UMA
16
32
CPUs
lograr
necesita
tipo
distinto
interconexión
circuito
simple
conectar
CPUs
memorias
interruptor
conmutador
ba-
rras
cruzadas
muestra
figura
8-3
interruptores
barras
cruzadas
utiliza-
do
décadas
puntos
intercambio
conmutadores
telefónicos
conectar
grupo
líneas
entrantes
conjunto
líneas
salientes
arbitraria
CPU
CPU
Memoria
compartida
Memoria
compartida
Bus
CPU
CPU
Memoria
privada
CPU
CPU
Caché
Figura
8-2
multiprocesadores
basados
bus
caché
caché
caché
memorias
privadas
www
FreeLibros.meEn
intersección
línea
horizontal
entrante
vertical
saliente
punto
cruce
pequeño
interruptor
abierto
cerrado
sentido
eléctrico
dependiendo
líneas
horizontal
vertical
conectarse
figura
8-3(a
pode-
mos
puntos
cruce
cerrados
tiempo
permiten
conexiones
en-
tre
pares
CPU
memoria
010
000
101
101
110
010
tiempo
posibles
combinaciones
número
combinaciones
número
distintas
formas
colocar
torres
tablero
ajedrez
528
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Memorias
CPUs
Conmutador
punto
cruce
cerrado
Conmutador
punto
cruce
abierto
conmutador
punto
cruce
cerrado
conmutador
punto
cruce
abierto
000
001
010
011
100
101
110
111
100
101
110
111
000
001
010
011
Figura
8-3
conmutador
barras
cruzadas
/H110038
punto
cruce
abierto
punto
cruce
cerrado
propiedades
agradables
interruptor
barras
cruzadas
red
bloqueos
significa
CPU
niega
conexión
necesita
de-
bido
punto
cruce
línea
estén
ocupados
suponiendo
módulo
me-
moria
esté
disponible
necesita
planeación
adelantado
conexiones
arbitrarias
establecidas
conectar
CPU
restante
memoria
restante
contención
memoria
CPUs
desean
acceder
módulo
tiempo
particionar
memoria
unidades
conten-
ción
reduce
factor
comparación
modelo
figura
8-2
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
529
peores
propiedades
conmutador
barras
cruzadas
nú-
mero
puntos
cruce
aumenta
base
n2
1000
CPUs
1000
módulos
memoria
necesitamos
millón
puntos
cruce
factible
interruptor
barras
cruzadas
es-
tamaño
sistemas
tamaño
mediano
utilizar
diseño
barras
cruzadas
Multiprocesadores
UMA
utilizan
redes
conmutación
multietapa
diseño
completamente
distinto
multiprocesador
basa
humilde
conmutador
/H110032
muestra
figura
8-4(a
interruptor
entradas
salidas
mensajes
llegan
cualquiera
líneas
entrada
conmutar
cualquiera
líneas
sali-
fines
mensajes
contener
partes
muestra
fi-
gura
8-4(b
campo
Módulo
indica
memoria
utilizar
Dirección
especifica
dirección
módulo
CódigoOp
proporciona
operación
READo
WRITE
cam-
po
Valor
opcional
contener
operando
palabra
32
bits
escribir
operación
WRITE
interruptor
inspecciona
campo
Módulo
utiliza
determinar
men-
saje
enviar
Y.
Módulo
Dirección
CódigoOp
Valor
Figura
8-4
conmutador
/H11003
líneas
entrada
líneas
salida
formato
mensaje
conmutadores
/H110032
organizar
formas
construir
redes
conmutación
multietapa
Adams
colaboradores
1987
Bhuyan
colaboradores
1989
Kumar
Reddy
1987
posibilidad
red
omega
clase
económica
adornos
ilustra
figura
8-5
conectado
CPUs
memorias
utilizando
12
con-
mutadores
general
CPUs
memorias
necesitaríamos
log
2n
etapas
n/2
conmutadores
etapa
n/2)log2n
conmutadores
n2
puntos
cruce
especial
valores
n.
patrón
cableado
red
omega
conoce
comúnmente
barajado
perfecto
mezcla
señales
etapa
asemeja
proceso
cortar
mitad
mazo
cartas
mezclarlas
carta
carta
funciona
red
omega
suponga
CPU
011
desea
leer
palabra
módulo
memoria
110
CPU
envía
mensaje
READal
in-
terruptor
1D
contiene
valor
110
campo
Módulo
interruptor
toma
bit
izquierda
110
utiliza
enrutamiento
enruta
salida
superior
inferior
bit
mensaje
enruta
salida
inferior
2D.
interruptores
etapa
incluyendo
2D
utilizan
bit
enrutamiento
mensaje
reenvía
salida
in-
ferior
3D.
evalúa
tercer
bit
consecuencia
mensaje
www.FreeLibros.mepasa
salida
superior
llega
memoria
110
desea
ruta
seguida
men-
saje
marcada
figura
8-5
letra
a.
medida
mensaje
pasa
red
conmutación
bits
extremo
izquier-
do
número
módulo
necesitan
registrar
núme-
ro
línea
entrante
respuesta
encontrar
camino
regreso
ruta
líneas
entrantes
entrada
superior
1D
entrada
inferior
2D
entrada
inferior
3D
respectivamente
respuesta
enruta
vuelta
utilizando
011
lee
dere-
cha
izquierda
tiempo
ocurre
CPU
001
desea
escribir
palabra
módulo
memoria
001
ocurre
proceso
análogo
mensaje
enruta
salidas
superior
superior
inferior
respectivamente
marcadas
letra
b.
llega
campo
Módulo
lee
001
representa
ruta
tomó
peticiones
utilizan
nin-
guno
conmutadores
líneas
módulos
memoria
proceder
paralelo
considere
ocurriría
CPU
000
quisiera
acceder
tiempo
módulo
memoria
000
petición
entraría
conflicto
petición
CPU
001
interruptor
3A.
tendría
esperar
diferencia
conmutador
barras
cruzadas
red
omega
red
bloqueo
conjuntos
peticiones
procesarse
tiempo
conflictos
cable
conmutador
peticiones
memoria
respuestas
memoria
duda
conveniente
esparcir
referencias
memoria
uniforme
módulos
técnica
común
utilizar
bits
menor
orden
número
módulo
ejemplo
considere
espacio
direcciones
orientado
bytes
computadora
general
utiliza
palabras
completas
32
bits
bits
menor
orden
general
00
pe-
ro
siguientes
bits
estarán
distribuidos
uniforme
utilizar
bits
nú-
mero
módulo
palabras
consecutivas
estarán
módulos
consecutivos
sistema
memoria
palabras
consecutivas
distintos
módulos
entrelazado
me-
morias
entrelazadas
maximizan
paralelismo
mayoría
referencias
memo-
530
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
CPUs
aa
etapas
Memorias
000
001
010
011
100
101
110
111
000
001
010
011
100
101
110
111
1A
1B
1C
1D
2A
2B
2C
2D
3A
3B
3C
3D
Figura
8-5
red
conmutación
omega
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
531
ria
direcciones
consecutivas
diseñar
redes
conmutación
bloqueo
ofrezcan
rutas
CPU
módulo
memoria
esparcir
me-
jor
tráfico
Multiprocesadores
NUMA
multiprocesadores
UMA
bus
general
limitados
cuan-
tas
docenas
CPUs
multiprocesadores
barras
cruzadas
conmutadores
necesitan
mu-
cho
hardware
costoso
100
CPUs
ceder
general
cede
idea
módulos
memoria
tiempo
acceso
concesión
idea
multiprocesadores
NUMA
diji-
mos
parientes
UMA
proveen
espacio
direcciones
to-
das
CPUs
diferencia
máquinas
UMA
acceso
módulos
memoria
locales
rápido
acceso
remotos
ende
programas
UMA
ejecutarán
cambios
máquinas
NUMA
rendimiento
máquina
UMA
mis-
ma
velocidad
reloj
máquinas
NUMA
poseen
características
clave
conjunto
distinguen
multiprocesadores
espacio
direcciones
visible
CPUs
acceso
memoria
remota
instrucciones
LOADy
STORE
acceso
memoria
remota
lento
acceso
memoria
local
tiempo
acceso
memoria
remota
oculto
caché
sis-
tema
llama
NC-NUMA
Cache
NUMA
NUMA
caché
cachés
coheren-
tes
presentes
sistema
llama
CC-NUMA
Cache-Coherent
NUMA
NUMA
cachés
coherentes
método
popular
construir
multiprocesadores
CC-NUMA
actualidad
multiprocesador
basado
directorios
idea
mantener
base
datos
indique
línea
caché
referencia
línea
caché
consulta
base
datos
averiguar
limpia
sucia
modificada
base
datos
consultar
instrucción
referencia
memoria
mantenerse
hardware
propósito
especial
extremo
veloz
responder
fracción
ciclo
bus
idea
multiprocesador
basado
directorios
concreta
considerar
ejemplo
simple
hipotético
sistema
256
nodos
nodo
consista
CPU
16
MB
RAM
conectados
CPU
bus
local
memoria
32
bytes
divide
226
líneas
caché
64
bytes
memoria
asigna
forma
estática
nodos
16
nodo
16
32
nodo
sucesivo
nodos
conectan
red
interconexión
muestra
figura
8-6(a
Ca-
nodo
contiene
entradas
directorio
18
líneas
caché
64
bytes
www.FreeLibros.meconforman
memoria
224
bytes
momento
suponer
línea
con-
caché
532
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Directorio
Nodo
Nodo
Nodo
255
Bits
81
Red
interconexión
CPU
Memoria
Bus
local
CPU
Memoria
Bus
local
CPU
Memoria
Bus
local
Nodo
Bloque
Despla-
zamiento
18-1
82
Figura
8.6
multiprocesador
basado
directorio
256
nodos
División
dirección
memoria
32
bits
campos
directorio
nodo
36
funciona
directorio
rastrear
instrucción
LOADdesde
CPU
20
referencia
línea
caché
CPU
emite
instrucción
presenta
MMU
traduce
dirección
física
ejemplo
0x24000108
MMU
divide
dirección
partes
muestran
figura
8-6(b
decimal
partes
nodo
36
línea
desplazamiento
MMU
ve
palabra
memoria
referencia
nodo
36
nodo
20
envía
mensaje
petición
red
interconexión
nodo
inicio
línea
36
pregunta
línea
caché
petición
llega
nodo
36
red
interconexión
enruta
hardware
directorio
hardware
indexa
tabla
18
entradas
líneas
caché
extrae
entrada
figura
8-6(c
línea
caché
hardware
obtiene
línea
RAM
local
envía
vuelta
nodo
20
actualiza
entrada
directorio
indicar
línea
caché
nodo
20
consideremos
petición
preguntando
línea
nodo
36
figura
8-6(c
línea
caché
nodo
82
punto
hard-
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
533
ware
actualizar
entrada
directorio
línea
no-
do
20
enviar
mensaje
nodo
82
indicarle
pasar
línea
nodo
20
invalidar
caché
Observe
multiprocesador
memoria
compartida
realiza
mu-
chas
operaciones
paso
mensajes
interna
observación
rápida
adicional
calcular
memoria
ocupa-
directorios
nodo
16
MB
RAM
18
entradas
bits
cuen-
ta
RAM
ende
sobrecarga
directorio
/H11003218
bits
dividida
16
MB
1.76%
general
aceptable
memoria
alta
velocidad
incrementa
costo
líneas
caché
32
bytes
sobrecarga
4%
líneas
caché
128
bytes
menor
1%
limitación
obvia
diseño
línea
colocar
caché
no-
do
permitir
coloquen
líneas
caché
nodos
necesitaríamos
forma
localizarlos
ejemplo
invalidarlos
actualizarlos
escritura
op-
ciones
posibles
permitir
caché
nodos
tiempo
análisis
opciones
allá
alcance
libro
Chips
multinúcleo
medida
mejora
tecnología
fabricación
chips
transistores
pequeños
colocar
chip
observación
empí-
rica
conoce
Ley
Moore
honor
co-fundador
Intel
Gordon
Moore
descubrió
chips
clase
Intel
Core
Duo
contienen
cerca
300
millones
transistores
pregunta
obvia
transistores
vimos
sección
1.3.1
opción
agregar
megabytes
caché
chip
opción
seria
chips
MB
caché
chip
comunes
cachés
camino
cier-
to
punto
incrementar
tamaño
caché
eleve
tasa
aciertos
99%
99.5%
mejora
rendimiento
aplicaciones
opción
colocar
CPUs
completas
generalmente
denomina
núcleos
chip
técnicamente
pastilla
chips
doble
núcleo
cuádruple
núcleo
comunes
fabricado
chips
80
núcleos
chips
cientos
núcleos
horizonte
CPUs
compartir
cachés
ejemplo
vea
figura
1-8
comparten
memoria
principal
consistente
sentido
valor
único
palabra
memoria
circuitos
hardware
especiales
aseguran
palabra
presente
cachés
CPUs
modifica
palabra
remueva
forma
automática
atómica
cachés
mantener
consistencia
pro-
ceso
conoce
snooping
resultado
diseño
chips
multinúcleo
pequeños
multiprocesadores
chips
multinúcleo
conoce
CMPs
Multiprocesadores
nivel
chip
perspectiva
software
CMPs
realidad
distintos
multiprocesadores
basados
bus
multiprocesadores
utilizan
redes
conmutación
www
FreeLibros.me534
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
diferencias
empezar
multiprocesador
basado
bus
CPU
caché
figura
8-2(b
diseño
AMD
figu-
ra
1-8(b
diseño
caché
compartida
figura
1-8(a
Intel
utiliza
ocurre
multiprocesadores
caché
L2
compartida
afectar
rendimiento
núcleo
necesita
mu-
cha
memoria
caché
diseño
permite
núcleo
tome
necesite
caché
compartida
núcleo
avaricioso
dañe
rendimiento
núcleos
área
CMPs
difieren
primos
tolerancia
fallas
Co-
mo
CPUs
conexión
estrecha
fallas
componentes
compartidos
afectar
CPUs
probable
multiprocesadores
tradicionales
chips
multinúcleo
simétricos
núcleos
idénticos
categoría
chip
multinúcleo
conocida
sistema
chip
chips
CPUs
principales
núcleos
propósito
especial
decodificadores
vi-
deo
audio
criptoprocesadores
interfaces
red
obtiene
sistema
cómputo
completo
chip
ocurrido
frecuencia
hardware
adelantado
software
chips
multinúcleo
habilidad
escribir
aplicaciones
lenguajes
programación
actuales
preparados
escribir
programas
altamente
paralelos
compiladores
herramientas
depuración
escasos
Po-
cos
programadores
experiencia
programación
paralelo
mayoría
acerca
dividir
trabajo
paquetes
puedan
ejecutar
paralelo
sincronización
eliminación
condiciones
carrera
prevención
interbloqueo
pesadillas
rendimiento
sufrirá
considerable
resultado
semáforos
respuesta
allá
problemas
iniciales
lejos
obvio
tipo
aplicación
realmente
necesita
cientos
núcleos
reconocimiento
voz
lenguaje
natural
probablemente
absorber
cómputo
problema
falta
ciclos
algoritmos
funcionen
resumen
diseñadores
hardware
ofreciendo
producto
diseñadores
software
usuarios
quieren
8.1.2
Tipos
sistemas
operativos
multiprocesador
pasar
hardware
multiprocesador
software
multiprocesador
espe-
cial
sistemas
operativos
multiprocesador
metodologías
posibles
continuación
estudiaremos
Observe
aplicar
forma
sistemas
mul-
tinúcleo
sistemas
CPUs
discretas
CPU
sistema
operativo
simple
organizar
sistema
operativo
multiprocesador
dividir
estáti-
camente
memoria
copia
privada
sistema
operativo
efecto
CPUs
operan
computadoras
independientes
optimización
obvia
permitir
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
535
CPUs
compartan
código
sistema
operativo
obtengan
copias
privadas
estructuras
datos
sistema
operativo
muestra
figura
8-7
SO
privado
CPU
SO
privado
CPU
SO
privado
CPU
SO
privado
CPU
Memoria
12
Datos
Datos
34
Datos
Datos
Código
Bus
Figura
8-7
Particionamiento
memoria
multiprocesador
CPUs
compartiendo
copia
código
sistema
operativo
cuadros
mar-
cados
Datos
datos
privados
sistema
operativo
CPU
esquema
computadoras
separadas
permite
máquinas
compartan
conjunto
discos
dispositivos
permite
com-
memoria
flexibilidad
ejemplo
asignación
estática
memoria
CPU
recibir
porción
extra-grande
memoria
manejar
eficiencia
programas
procesos
comunicarse
eficiente
permitir
productor
escriba
datos
directamente
memoria
consumidor
obtenga
lugar
escribió
productor
perspectiva
siste-
ma
operativo
CPU
sistema
operativo
primitivo
Vale
pena
mencionar
aspectos
diseño
obvios
lugar
proceso
realiza
llamada
sistema
atrapa
maneja
CPU
usando
estructuras
datos
tablas
sistema
operativo
lugar
sistema
operativo
tablas
pro-
pio
conjunto
procesos
programa
compartición
procesos
usua-
rio
conecta
CPU
procesos
ejecutan
CPU
consecuencia
ocurrir
CPU
esté
inactiva
CPU
cargada
trabajo
tercer
lugar
compartición
páginas
ocurrir
CPU
páginas
sobra
CPU
esté
paginando
forma
continua
forma
CPU
pi-
prestadas
páginas
CPU
asignación
memoria
fija
cuarto
lugar
sistema
operativo
mantiene
caché
búfer
bloques
disco
reciente
sistema
operativo
independiente
de-
ende
ocurrir
bloque
disco
presente
sucio
cachés
búfer
tiempo
producirán
resultados
inconsistentes
única
forma
evi-
tar
problema
eliminar
cachés
búfer
difícil
daña
rendimiento
forma
considerable
razones
raro
utilice
modelo
multiprocesadores
utilizaba
objetivo
portar
sistemas
operativos
existentes
multiprocesador
rápido
www
FreeLibros.meMultiprocesadores
maestro-esclavo
figura
8-8
muestra
modelo
copia
sistema
operativo
ta-
blas
presente
CPU
llamadas
sistema
redirigen
CPU
procesarlas
CPU
ejecutar
proceso
usuario
tiempo
sobra
modelo
conoce
maestro-esclavo
CPU
maestro
de-
esclavos
536
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
maestro
ejecuta
SO
CPU
esclavo
ejecuta
procesos
usuario
esclavo
ejecuta
procesos
usuario
esclavo
ejecuta
procesos
usuario
CPU
CPU
Procesos
usuario
SO
CPU
Memoria
Bus
Figura
8.8
modelo
multiprocesador
maestro-esclavo
modelo
maestro-esclavo
resuelve
mayoría
problemas
modelo
estructura
datos
ejemplo
lista
conjunto
listas
prioridades
procesos
listos
CPU
inactiva
pide
sistema
operativo
CPU
proceso
ejecutarlo
asigna
ende
ocurrir
CPU
esté
inac-
tiva
esté
sobrecargada
similar
asignar
páginas
to-
procesos
forma
dinámica
caché
búfer
ocurren
inconsistencias
problema
modelo
CPUs
maestro
convertirá
cuello
botella
manejar
llamadas
sistema
CPUs
ejemplo
10%
tiempo
manejando
llamadas
sistema
10
CPUs
maestro
saturará
20
CPUs
completamente
sobrecargado
ende
modelo
sim-
ple
funciona
pequeños
multiprocesadores
Multiprocesadores
simétricos
tercer
modelo
SMP
Multiprocesador
simétrico
elimina
asimetría
co-
pia
sistema
operativo
memoria
CPU
ejecutarlo
llamada
sistema
CPU
llamada
sistema
atrapa
kernel
procesa
llamada
sistema
modelo
SMP
ilustra
figura
8-9
modelo
equilibra
procesos
memoria
forma
dinámica
con-
tablas
sistema
operativo
elimina
cuello
botella
CPU
maestro
introduce
problemas
especial
CPUs
ejecutando
código
sistema
operativo
tiempo
producir
desastre
Imagine
CPUs
seleccionan
proceso
ejecutarlo
reclaman
página
memoria
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
537
Ejecuta
procesos
usuarios
SO
compartido
Ejecuta
procesos
usuarios
SO
compartido
Ejecuta
procesos
usuarios
SO
compartido
Ejecuta
procesos
usuarios
SO
compartido
CPU
CPU
CPU
SO
CPU
Memoria
Bloqueos
Bus
Figura
8-9
modelo
multiprocesador
SMP
libre
solución
simple
problemas
asociar
mutex
bloqueo
sistema
operativo
convirtiendo
sistema
región
crítica
CPU
de-
ejecutar
código
sistema
operativo
adquirir
mutex
mutex
bloquea-
do
espera
forma
CPU
ejecutar
sistema
operativo
modelo
funciona
modelo
maestro-esclavo
suponga
10%
tiempo
ejecución
invierte
sistema
operativo
20
CPUs
ha-
brá
largas
colas
CPUs
esperando
entrar
fortuna
fácil
mejorar
partes
sis-
tema
operativo
independientes
ejemplo
habría
problema
CPU
ejecutara
planificador
CPU
manejara
llamada
sistema
archivos
CPU
estuviera
procesando
fallo
página
observación
ocasiona
divida
sistema
operativo
regiones
críticas
inde-
pendientes
interactúan
región
crítica
protegida
mutex
CPU
ejecutarlo
forma
lograr
parale-
lismo
ocurrir
tablas
procesos
utilizadas
va-
rias
regiones
críticas
ejemplo
tabla
procesos
necesaria
programación
llamada
sistema
forky
manejo
señales
tabla
uti-
lizada
regiones
críticas
necesita
mutex
forma
región
crítica
ejecutar
CPU
tabla
crítica
utilizar
CPU
mayoría
multiprocesadores
modernos
utilizan
organización
difícil
so-
bre
escribir
sistema
operativo
máquina
tipo
código
actual
distinto
sistema
operativo
regular
difícil
dividirlo
regiones
críticas
puedan
ejecutar
concurrente
distintas
CPUs
interferir
si-
quiera
formas
sutiles
indirectas
tabla
utilizada
regiones
críticas
protegida
separado
mutex
código
utilice
tabla
utilizar
mutex
forma
correcta
cuidado
evitar
interbloqueos
regiones
críticas
necesitan
tabla
tabla
reclama
tabla
reclama
tabla
ocurrirá
interbloqueo
sabrá
teoría
www
FreeLibros.me538
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
tablas
asignar
valores
enteros
regiones
críticas
requerir
adqui-
sición
tablas
orden
ascendente
estrategia
evita
interbloqueos
requiere
programador
piense
cuidado
tablas
necesita
región
crítica
realice
peticiones
orden
correcto
medida
código
evoluciona
tiempo
región
crítica
llegar
necesitar
tabla
necesitaba
programador
comprende
lógica
com-
pleta
sistema
tentación
colocar
mutex
tabla
punto
necesite
liberarlo
necesario
importar
razonable
parecer
es-
to
producir
interbloqueos
usuario
percibirá
sistema
paralizara
fácil
mantenerlo
periodo
años
frente
cambios
progra-
madores
difícil
8.1.3
Sincronización
multiprocesadores
frecuencia
CPUs
multiprocesador
necesitan
sincronizarse
Acabamos
caso
regiones
críticas
kernel
tablas
proteger
mutexes
analizar
detalle
forma
funciona
sincronización
multiprocesa-
dor
carece
importancia
veremos
empezar
realmente
necesitan
primitivas
sincronización
apropiadas
proceso
máquina
uniprocesador
CPU
realiza
llamada
sistema
requiera
acceder
tabla
crítica
kernel
código
kernel
deshabilitar
interrupciones
an-
tes
tocar
tabla
trabajo
sabiendo
terminar
proceso
entrometa
toque
tabla
terminado
sistema
multiproce-
sador
deshabilitar
interrupciones
afecta
CPU
desshilitándola
CPUs
si-
guen
ejecutando
tocar
tabla
crítica
consecuencia
utilizar
protocolo
mutex
apropiado
respetado
CPUs
garantizar
funcione
exclusión
mutua
corazón
protocolo
mutex
práctico
instrucción
especial
permite
inspeccionar
palabra
memoria
establecerla
operación
indivisible
figura
2-22
vimos
utilizaba
TSL(Probar
establecer
bloqueo
implementar
regiones
críticas
Co-
mo
vimos
instrucción
leer
palabra
memoria
almacenarla
registro
tiempo
escribe
valor
distinto
cero
palabra
memoria
requieren
ciclos
bus
operaciones
lectura
escritura
memoria
uniprocesador
instrucción
descomponer
mitad
ejecución
TSLsiempre
funcionará
espera
piense
ocurrir
multiprocesador
figura
8-10
sincronización
caso
palabra
memoria
1000
utiliza
bloqueo
principio
paso
CPU
lee
palabra
obtiene
paso
CPU
oportunidad
volver
escribir
palabra
CPU
entra
tam-
bién
lee
palabra
paso
CPU
escribe
palabra
paso
CPU
escribe
palabra
Ambas
CPUs
obtuvieron
instrucción
TSL
ambas
acceso
región
crítica
falla
exclusión
mutua
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
539
evitar
problema
instrucción
TSLdebe
bloquear
bus
evitar
CPUs
utilicen
accesos
memoria
desbloquear
bus
general
bloquear
bus
petición
bus
usando
protocolo
petición
bus
común
declara
establece
lógico
línea
bus
especial
hayan
completado
ciclos
esté
declarada
línea
especial
nin-
guna
CPU
obtendrá
acceso
bus
instrucción
implementarse
bus
líneas
necesarias
protocolo
hardware
utilizarlas
buses
modernos
facilidades
tenían
implementar
instrucción
TSLen
forma
correcta
razón
inventó
protocolo
Peterson
sincro-
nizar
completo
software
Peterson
1981
instrucción
TSL
implementa
utiliza
forma
correcta
garantiza
exclusión
mutua
llegar
funcionar
método
exclusión
mutua
utiliza
bloqueo
giro
CPU
petición
espera
ciclo
estrecho
evaluando
bloqueo
rápido
desperdicia
completo
tiempo
CPU
CPUs
petición
imponer
carga
masiva
bus
memoria
reduciendo
considerablemente
CPUs
tratan
trabajo
normal
instancia
parecer
presencia
caché
debería
eliminar
problema
contención
bus
teoría
CPU
petición
leí-
do
palabra
bloqueo
obtener
copia
caché
CPU
in-
tente
utilizar
bloqueo
CPU
petición
capaz
salir
caché
CPU
posee
bloqueo
escribe
caché
liberarla
protocolo
caché
inva-
lida
automática
copias
cachés
remotas
volver
obtener
valor
correcto
problema
cachés
operan
bloques
32
64
bytes
general
CPU
contiene
bloqueo
necesita
palabras
rodean
instrucción
TSL
escritura
modifica
bloqueo
necesita
acceso
exclusivo
bloque
caché
contiene
blo-
queo
instrucción
TSLinvalida
bloqueo
caché
CPU
contiene
bloqueo
obtiene
copia
privada
exclusiva
CPU
petición
co-
mo
CPU
contiene
bloqueo
toca
palabra
adyacente
bloque
caché
CPU
Memoria
CPU
Bus
principio
palabra
1000
CPU
lee
CPU
escribe
CPU
lee
CPU
escribe
Figura
8-10
instrucción
TSLpuede
fallar
bus
bloquear
cua-
tro
pasos
muestran
secuencia
eventos
demuestra
falla
www.FreeLibros.memueve
máquina
consecuencia
bloque
caché
contiene
bloqueo
trans-
porta
constantemente
propietario
bloqueo
solicita
bloqueo
generando
tráfico
bus
lecturas
individuales
palabra
bloqueo
pudiéramos
deshacernos
escrituras
inducidas
TSL
petición
podríamos
reducir
thrashing
caché
forma
considerable
objetivo
lograr
CPU
petición
realice
lectura
pura
blo-
queo
libre
bloqueo
libre
realiza
TSLpara
ad-
quirirlo
resultado
pequeño
cambio
mayoría
sondeos
lecturas
escrituras
CPU
contiene
bloqueo
lee
variables
bloque
caché
copia
bloque
caché
lectura
compartido
eliminando
transferencias
bloque
caché
libera
bloqueo
propietario
realiza
escritura
requiere
acceso
exclusivo
in-
validan
copias
cachés
remotas
lectura
realice
CPU
petición
bloque
caché
volverá
cargar
Observe
CPUs
contendiendo
bloqueo
ocurrir
ambas
vean
libre
tiem-
po
ambas
puedan
llegar
operación
TSL
simultánea
adquirirlo
operaciones
éxito
condición
competencia
adquisición
realiza
instrucción
TSL
instrucción
atómica
Detectar
bloqueo
libre
tratar
obtenerlo
inmediato
operación
TSL
garantiza
ob-
tención
Alguien
ganar
algoritmo
correcto
impor-
ta
obtenga
éxito
lectura
pura
sugerencia
mo-
mento
adquirir
bloqueo
constituye
garantía
adquisición
éxito
forma
reducir
tráfico
bus
popular
algoritmo
backoff
exponencial
binario
Ethernet
Anderson
1990
sondear
forma
continua
figura
2-22
insertar
ciclo
retraso
sondeos
principio
retraso
instrucción
bloqueo
ocupado
retraso
duplica
instrucciones
cua-
tro
instrucciones
llegar
valor
máximo
máximo
ofrece
respuesta
rá-
pida
libera
bloqueo
desperdicia
ciclos
bus
thrashing
caché
máximo
alto
reduce
thrashing
caché
expensas
observar
bloque
libre
tanta
rapidez
algoritmo
backoff
exponencial
binario
utilizar
lecturas
puras
instrucción
TSL
idea
proporcionar
CPU
desea
adquirir
mutex
va-
riable
bloqueo
privada
evaluarla
ilustra
figura
8-11
Mellor-Crummey
Scott
1991
variable
residir
bloque
caché
utilizado
evitar
conflictos
algoritmo
funciona
CPU
adquirir
bloqueo
asigne
variable
bloqueo
adjunte
lista
CPUs
esperan
bloqueo
CPU
contiene
bloque
sale
región
crítica
libera
bloqueo
privado
CPU
lista
evaluando
caché
CPU
entra
región
crítica
termina
libera
bloqueo
usando
sucesora
sucesivo
protocolo
complicado
evitar
CPUs
adjunten
lista
tiempo
eficiente
libre
inanición
obtener
detalles
lectores
deberán
con-
sultar
artículo
540
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
541
Comparación
espera
activa
conmutación
asumido
CPU
necesita
mutex
bloqueado
espera
sondeo
continuo
sondeo
intermitente
adjuntándose
lista
CPUs
espera
alternativa
CPU
petición
espe-
re
ejemplo
suponga
CPU
inactiva
necesita
acceder
lista
compartida
procesos
listos
elegir
proceso
ejecutarlo
lista
procesos
listos
bloqueada
CPU
decidir
suspender
ejecutar
proceso
tendría
leer
lista
procesos
listos
esperar
adquirir
lista
casos
opción
ejemplo
hilo
CPU
necesita
acceso
caché
búfer
sistema
archivos
actualmente
bloqueada
CPU
de-
cidir
cambiar
hilo
distinto
esperar
cuestión
espera
activa
cambio
hilo
tema
investigación
analizaremos
con-
tinuación
Observe
cuestión
ocurre
uniprocesador
senti-
do
espera
activa
CPU
liberar
bloqueo
subproceso
adquirir
bloqueo
falla
bloquea
propietario
bloqueo
oportunidad
ejecutarse
liberar
bloqueo
Suponiendo
espera
activa
cambio
hilo
opciones
viables
ha-
cer
concesión
espera
activa
desperdicia
ciclos
CPU
directa
evaluar
bloqueo
forma
repetida
trabajo
productivo
cambiar
hilo
desperdicia
ciclos
CPU
guardar
hilo
actual
adquirir
bloqueo
lista
procesos
listos
seleccionar
hilo
cargar
de-
be
iniciarse
caché
CPU
contendrá
bloques
incorrectos
ocu-
rrirán
fallos
caché
medida
hilo
empiece
ejecutar
probable
ocurran
fallos
TLB
momento
realizará
cambio
vuelta
hilo
original
seguirán
fallos
caché
fallos
caché
desperdician
ci-
clos
invertidos
cambios
contexto
CPU
CPU
gira
bloqueo
privado
CPU
gira
bloqueo
privado
CPU
gira
bloqueo
privado
CPU
termina
bloqueo
real
libera
libera
bloqueo
privado
gira
CPU
2La
CPU
contiene
bloqueo
real
Memoria
compartida
42
Figura
8-11
bloqueos
evitar
thrashing
caché
www
FreeLibros.mePor
ejemplo
mutexes
contienen
generalmente
50
µseg
re-
mseg
cambiar
hilo
actual
mseg
volver
cambiar
posteriormente
eficiente
espera
activa
mutex
mutex
promedio
contiene
duran-
10
mseg
vale
pena
esfuerzo
cambios
contexto
problema
regiones
críticas
variar
considerable
duración
mé-
diseño
espera
activa
tiempo
diseño
cambiar
ter-
cer
diseño
tomar
decisión
separado
encontramos
mutex
blo-
queado
momento
tomar
decisión
espera
activa
cambiar
sistema
rastreo
activi-
dad
analizarla
línea
retrospectiva
decisión
me-
jor
tiempo
desperdició
caso
algoritmo
retrospección
convierte
punto
referencia
medir
algoritmos
viables
investigadores
estudiado
problema
Karlin
colaboradores
1989
Karlin
colabo-
radores
1991
Ousterhout
1982
trabajo
utiliza
modelo
hilo
adquirir
mutex
gira
periodo
excede
umbral
cambio
casos
corrige
umbral
general
sobrecarga
conocida
cambiar
hilo
cambiar
vuelta
casos
dinámico
dependiendo
historia
observada
mutex
espera
mejores
resultados
obtienen
sistema
rastro
tiempos
espera
activa
observados
asume
similar
anteriores
ejemplo
suponiendo
tiempo
cambio
contexto
mseg
hilo
realiza
espera
activa
má-
ximo
mseg
observe
tiempo
giró
realidad
adquirir
bloqueo
detecta
ejecuciones
anteriores
esperó
promedio
200
µseg
es-
pera
activa
mseg
cambiar
hilo
detecta
espera
activa
dura
mseg
completos
intentos
anteriores
cambiar
inmediato
es-
pera
activa
Encontrará
detalles
Karlin
colaboradores
1991
8.1.4
Planificación
multiprocesadores
analizar
forma
realiza
planificación
multiprocesadores
necesario
determinar
planificar
antaño
procesos
tenían
hilo
procesos
planificaban
pudiera
planificar
sistemas
operativos
modernos
soportan
procesos
multihilo
complica
planificación
importante
hilos
kernel
usuario
ejecución
hilos
cabo
biblioteca
espacio
usuario
kernel
acerca
hilos
en-
tonces
planificación
cabo
base
proceso
kernel
si-
quiera
hilos
difícil
planificarlos
hilos
kernel
sucede
distinto
kernel
hilos
elegir
seleccionar
hilos
pertenecen
proceso
sistemas
tendencia
kernel
seleccione
hilo
ejecutarlo
proceso
pertenece
542
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
543
pequeño
papel
algoritmo
selección
hilos
continuación
hablaremos
planificación
hilos
sistema
procesos
hilo
hilos
implementados
espacio
usuario
procesos
pro-
graman
Proceso
hilo
única
cuestión
planificación
uniprocesador
planifi-
cación
dimensión
única
pregunta
responder
repetidas
hilo
ejecutar
continuación
multiprocesador
planificación
dimensiones
planificador
decidir
hilo
ejecutar
CPU
ejecutar
dimensión
adicional
complica
considerable
planificación
multiprocesa-
dores
factor
complica
cosas
sistemas
hilos
re-
lacionado
dividen
grupos
pertenecen
aplica-
ción
trabajan
conjunto
ejemplo
caso
sistema
tiempo
compartido
usuarios
independientes
inician
procesos
independientes
hilos
distintos
proce-
sos
relacionados
planificar
independiente
ejemplo
caso
ocurre
regularidad
entornos
desarrollo
progra-
sistemas
extensos
consisten
número
archivos
encabezado
contienen
macros
definiciones
tipos
declaraciones
variables
utilizan
archivos
có-
digo
actuales
modifica
archivo
encabezado
volver
compilar
archivos
código
incluyen
programa
make
utiliza
comúnmente
administrar
desarrollo
invoca
make
inicia
compilación
archivos
código
volver
compilar
modificaciones
realizadas
encabezado
archivos
código
archivos
código
objeto
siguen
válidos
regeneran
versión
original
make
realizaba
trabajo
forma
secuencial
versiones
recientes
diseñadas
multiprocesadores
iniciar
compilaciones
necesitan
10
compilaciones
caso
programar
ejecuten
inmediato
dejar
usuario
percibirá
trabajo
terminado
si-
termine
compilación
caso
sentido
considerar
hilos
rea-
lizan
compilaciones
fueran
grupo
tomar
programarlos
Tiempo
compartido
analizar
caso
programación
hilos
independientes
consideraremos
planificar
hilos
relacionados
algoritmo
planificación
simple
lidiar
hilos
relacionados
estructura
datos
nivel
sistema
hilos
estén
lis-
tos
lista
probable
conjunto
listas
hilos
distintas
prioridades
ilustra
figura
8-12(a
16
CPUs
ocu-
padas
momento
conjunto
14
hilos
orden
prioridad
esperando
ejecutados
CPU
terminar
trabajo
actual
hilo
bloquee
CPU
bloquea
colas
programación
selecciona
hilo
prioridad
muestra
figura
8-12(b
continuación
CPU
12
queda
inactiva
selecciona
hilo
ilustra
figura
8-12(c
hilos
estén
relacionados
nin-
www.FreeLibros.meguna
opción
razonable
cabo
planificación
forma
sim-
ple
implementar
eficiencia
544
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
12
13
10
14
11
15
Prioridad
CPU
12
13
10
14
11
15
Prioridad
CPU
queda
inactiva
CPU
12
queda
inactiva
13
10
14
11
15
333
666
Prioridad
Figura
8-12
estructura
datos
programar
multiprocesador
estructura
datos
planificación
utilizada
CPUs
comparten
tiempo
forma
sistema
uniprocesador
proporciona
balance
automático
carga
CPU
inactiva
mien-
sobrecargadas
desventajas
método
potencial
contención
estructura
datos
utiliza
programación
medida
aumenta
número
CPUs
sobrecarga
usual
produce
cambio
contexto
hilo
bloquea
espera
operación
S.
ocurra
cambio
contexto
momento
expire
quantum
hilo
ejemplo
multiprocesador
propiedades
presen-
tes
uniprocesador
Suponga
hilo
contiene
bloqueo
espera
activa
momento
expira
quantum
CPUs
esperan
libere
bloqueo
espera
activa
só-
desperdician
tiempo
espera
activa
vuelve
programar
hilo
libera
bloqueo
uniprocesador
bloqueos
espera
activa
utilizan
raras
proceso
suspende
contiene
mutex
hilo
inicia
adquirir
mu-
tex
bloqueará
inmediato
desperdicia
tiempo
solucionar
anomalía
sistemas
utilizan
planificación
inteligente
hilo
adquiere
bloqueo
espera
activa
establece
bandera
nivel
proceso
mostrar
actualmente
bloqueo
espera
activa
Zahorjan
colaboradores
1991
li-
berar
bloqueo
borra
bandera
planificador
detiene
hilo
contenga
blo-
queo
espera
activa
tiempo
complete
región
crítica
libere
bloqueo
cuestión
desempeña
papel
planificación
CPUs
iguales
CPUs
iguales
especial
subproceso
ejecutado
tiempo
CPU
caché
CPU
llena
bloques
A.
vuelve
ejecutar
tiempo
rendimiento
ejecuta
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
545
CPU
caché
CPU
contenga
bloques
A.
cargan
previamente
bloques
caché
incrementa
proporción
aciertos
consecuencia
velocidad
hilo
caso
TLB
contenga
pá-
ginas
correctas
reducen
fallas
multiprocesadores
toman
efecto
utilizan
conoce
pla-
nificación
afinidad
Vaswani
Zahorjan
1991
idea
básica
esforzarse
serio
hilo
ejecute
CPU
ejecutó
crear
afinidad
algoritmo
planificación
niveles
crea
hilo
asigna
CPU
ejemplo
base
CPUs
menor
carga
momento
asignación
hilos
CPUs
nivel
superior
algoritmo
resulta-
do
directiva
CPU
adquiere
colección
hilos
planificación
actual
hilos
nivel
inferior
algoritmo
CPU
realiza
separado
prioridades
tratar
mantener
hilo
CPU
tiempo
vida
maximiza
afinidad
caché
obstante
CPU
hilos
ejecutar
obtiene
CPU
quedar
inactiva
planificación
niveles
beneficios
lugar
distribuye
carga
uniforme
CPUs
disponibles
lugar
aprovecha
afinidad
caché
tercer
lugar
CPU
lista
hilos
listos
minimiza
contención
listas
frecuente
CPU
intente
utilizar
lista
hilos
listos
CPU
Espacio
compartido
método
general
planificación
multiprocesadores
utilizar
hilos
relacionados
Anteriormente
mencionamos
ejemplo
programa
make
paralelo
casos
ocurre
frecuencia
proceso
va-
rios
hilos
trabajen
conjunto
ejemplo
hilos
proceso
comunican
frecuencia
conveniente
ejecuten
tiempo
planificación
hilos
tiempo
esparcidos
CPUs
conoce
espacio
compartido
algoritmo
espacio
compartido
simple
funciona
Suponga
crea
grupo
completo
hilos
relacionados
tiempo
momento
creación
programador
comprueba
tantas
CPUs
libres
número
hilos
hilo
proporciona
CPU
dedicada
multiprogramación
empiezan
ejecución
suficientes
CPUs
hilos
iniciará
sufi-
cientes
CPUs
disponibles
hilo
aferra
CPU
termina
momento
CPU
regresa
reserva
CPUs
disponibles
hilo
bloquea
espera
operación
formas
retiene
CPU
simplemente
queda
inactiva
hilo
despierta
aparece
lote
hilos
aplica
algoritmo
instante
conjunto
CPUs
divide
estática
número
particiones
ejecuta
hilos
hilo
ejemplo
figura
8-13
particiones
12
CPUs
CPUs
asignar
tiempo
cambiará
número
tamaño
particiones
medida
creen
hilos
anteriores
terminen
ejecutarse
www
FreeLibros.meDe
tomar
decisiones
planificación
sistemas
uniproce-
sador
algoritmo
trabajo
corto
algoritmo
popular
programación
lotes
algoritmo
análogo
multiprocesador
seleccionar
proceso
necesita
me-
nor
número
ciclos
CPU
hilo
cuyo
valor
multiplicación
CPU
/H11003tiempo
ejecución
menor
obstante
práctica
información
raras
disponible
difícil
cabo
algoritmo
estudios
de-
mostrado
práctica
difícil
vencer
algoritmo
llegar
aten-
dido
Krueger
colaboradores
1994
modelo
simple
particionamiento
hilo
pide
número
CPUs
ob-
esperar
estén
disponibles
metodología
distinta
hi-
administren
activa
grado
paralelismo
método
administrar
paralelismo
servidor
central
lleve
hilos
ejecutando
cuá-
desean
ejecutarse
requerimientos
CPU
mínimos
máximos
Tucker
Gup-
ta
1989
aplicación
sondea
servidor
central
CPUs
utilizar
aumenta
reduce
número
hilos
ajustarse
disponi-
ble
ejemplo
servidor
Web
10
20
número
hilos
ejecután-
dose
paralelo
momento
10
hilos
aumenta
demanda
CPUs
repentina
servidor
Web
reducir
número
hilos
siguientes
hilos
terminen
trabajo
actual
dejar
ejecutarse
recibir
trabajo
es-
quema
permite
tamaños
particiones
varíen
forma
dinámica
adaptarse
car-
ga
trabajo
actual
forma
sistema
fijo
figura
8-13
Planificación
pandilla
ventaja
clara
compartición
espacio
eliminación
multiprogramación
elimina
sobrecarga
impuesta
cambio
contexto
desventaja
tam-
bién
clara
tiempo
desperdicia
CPU
bloquea
vuelva
lista
consecuencia
personas
buscado
algoritmos
intenten
planificación
tiempo
espacio
especial
hilos
crean
va-
rios
hilos
general
necesitan
comunicar
546
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
Partición
CPUs
Partición
12
CPUsCPU
asignar
Partición
CPUs
Partición
CPUs
Figura
8-13
conjunto
32
CPUs
divididas
particiones
CPUs
disponibles
www
FreeLibros.meSECCIÓN
8.1
MULTIPROCESADORES
547
tipo
problema
ocurrir
hilos
proceso
planifican
independiente
considere
sistema
hilos
A0
A1
pertenecen
proceso
hilos
B0
B1
pertenecen
proceso
B.
hilos
A0
B0
comparten
tiempo
CPU
hilos
A1
B1
comparten
tiempo
CPU
hilos
A0
A1
necesitan
comunicarse
fre-
cuencia
patrón
comunicación
A0
envía
mensaje
A1
A1
envía
regre-
so
respuesta
A0
seguida
secuencia
similar
Suponga
A0
B1
inician
muestra
figura
8-14
A0
B0
A0
B0
A0
B0
B1
A1
B1
A1
B1
A1
Hilo
A0
ejecución
100
200
300
400
500
600
CPU
CPU
Tiempo
Petición
Petición
Respuesta
2Respuesta
Figura
8-14
Comunicación
hilos
pertenecen
hilo
es-
tán
ejecutando
fase
intervalo
A0
envía
petición
A1
recibe
ejecuta
intervalo
empieza
100
mseg
Envía
respuesta
inmediato
A0
re-
cibe
vuelve
ejecutar
200
mseg
resultado
neto
secuen-
cia
solicitud-respuesta
200
mseg
solución
problema
planificación
pandilla
consecuencia
co-planificación
Ousterhout
1982
planificación
pandilla
consta
partes
grupos
hilos
relacionados
programan
unidad
pandilla
miembros
plantilla
ejecutan
forma
simultánea
distintas
CPUs
tiempo
compartido
miembros
pandilla
inician
terminan
intervalos
conjunto
truco
funcionar
planificación
pandilla
CPUs
planifican
for-
ma
asíncrona
significa
tiempo
divide
quantums
discretos
figura
8-14
inicio
quantum
CPUs
reprograman
inicia
hilo
ca-
CPU
inicio
quantum
ocurre
evento
planificación
intervalo
realiza
planificación
hilo
bloquea
CPU
permanece
inactiva
quantum
figura
8-15
muestra
ejemplo
funcionamiento
planificación
pandilla
multiprocesador
CPUs
utilizadas
procesos
24
hilos
listos
ejecutarse
ranura
tiempo
programan
hilos
www.FreeLibros.mea
A6
ejecutan
ranura
tiempo
programan
hilos
B0
B1
B2
C0
C1
C2
ejecutan
ranura
tiempo
ejecutan
hilos
E0
hilos
res-
tantes
pertenecen
hilo
ejecutan
ranura
tiempo
repite
ciclo
don-
ranura
ranura
sucesivo
548
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
012
345
A0
B0
B1
D1
E2
A1
B1
D1
E2
A1
A2
B2
D2
E3
A2
B2
D2
E3
A3
D3
E4
A3
C0
D3
E4
C1
D4
E5
A4
C1
D4
E5
C2
E0
E6
A5
C2
E0
E6
C0
A4
A5
D0
E1
A0
B0
D0
E1
CPU
Ranura
tiempo
Figura
8-15
Planificación
pandilla
idea
planificación
pandilla
hilos
hilo
ejecuten
conjun-
to
envía
petición
recibirá
mensaje
inmediato
responder
inmediato
figura
8-15
hilos
ejecutando
conjunto
quantum
enviar
recibir
cantidad
mensa-
jes
elimina
problema
figura
8-14
8.2
MULTICOMPUTADORAS
multiprocesadores
populares
atractivos
ofrecen
modelo
comunica-
ción
simple
CPUs
comparten
memoria
común
procesos
escribir
men-
sajes
memoria
procesos
lean
sincronización
mutexes
semáforos
monitores
técnicas
establecidas
único
con-
tratiempo
dificultad
construir
multiprocesadores
proceso
costoso
resolver
problemas
investigado
multicomputadoras
CPUs
acoplamiento
fuerte
comparten
memoria
memoria
muestra
figura
8-1(b
sistemas
conocidos
variedad
nombres
in-
cluyendo
clúster
computadoras
COWS
Clusters
of
Workstations
Clústeres
estaciones
trabajo
fácil
construir
multicomputadoras
componente
básico
PC
só-
componentes
esenciales
tarjeta
interfaz
red
alto
rendimiento
secreto
obtener
alto
rendimiento
diseñar
inteligente
red
in-
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
549
terconexión
tarjeta
interfaz
problema
completamente
análogo
construir
me-
moria
compartida
multiprocesador
objetivo
enviar
mensajes
esca-
tiempo
microsegundos
acceder
memoria
escala
tiempo
nanosegundos
simple
económico
fácil
lograr
siguientes
secciones
analizaremos
brevedad
hardware
multicompu-
tadora
especial
hardware
interconexión
pasaremos
software
empezaremos
software
comunicación
nivel
continuaremos
comunicación
alto
nivel
analizaremos
obtener
memoria
compartida
sistemas
examinaremos
planificación
equilibrio
carga
8.2.1
Hardware
multicomputadora
nodo
básico
multicomputadora
consiste
CPU
memoria
interfaz
red
disco
duro
nodo
empaquetado
gabinete
PC
estándar
pe-
ro
adaptador
gráficos
monitor
teclado
ratón
presentes
casos
PC
contiene
tablero
multiprocesador
vías
nodo
posiblemen-
chip
doble
cuádruple
núcleo
CPU
cuestión
sim-
plicidad
suponer
nodo
CPU
conectan
cientos
miles
nodos
formar
multicomputadora
continuación
hablaremos
acerca
organización
hardware
Tecnología
interconexión
nodo
tarjeta
interfaz
red
salen
cables
fibras
ca-
bles
conectan
nodos
switches
sistema
pequeño
switch
conectados
nodos
topología
estrella
figura
8-16(a
redes
Ethernet
modernas
switches
utilizan
topología
alternativa
diseño
switch
nodos
formar
anillo
ca-
bles
provienen
tarjeta
interfaz
red
entra
nodo
izquierda
sale
nodo
derecha
muestra
figura
8-16(b
topología
necesi-
switches
muestra
rejilla
malla
figura
8-16(c
diseño
bidimensional
utilizado
mu-
chos
sistemas
comerciales
regular
facilidad
escalar
tamaños
mayores
diámetro
ruta
larga
nodos
cualesquiera
aumenta
base
raíz
cuadrada
número
nodos
variante
malla
doble
toroide
fi-
gura
8-16(d
rejilla
bordes
conectados
tolerante
fallas
rejilla
diámetro
menor
esquinas
opuestas
comu-
nicar
saltos
cubo
figura
8-16(e
constituye
topología
tridimensional
regular
ilustrado
cubo
/H110032
/H110032
caso
general
cubo
/H11003k
/H11003k
figu-
ra
8-16(f
cubo
dimensiones
construido
cubos
tridimensiona-
correspondientes
nodos
conectados
Podríamos
cubo
dimensiones
www.FreeLibros.meclonamos
estructura
figura
8-16(f
conectamos
nodos
correspondientes
formar
bloque
cubos
obtener
dimensiones
podríamos
duplicar
bloque
cubos
interconectar
nodos
correspondientes
sucesivo
cubo
dimensiones
forma
conoce
hipercubo
computadoras
paralelas
utilizan
topo-
logía
diámetro
aumenta
proporción
lineal
dimensiones
for-
ma
diámetro
logaritmo
base
número
nodos
ejemplo
hipercubo
10
dimensiones
1024
nodos
diámetro
10
obtienen
excelentes
pro-
piedades
retraso
Observe
contrario
organizan
1024
nodos
rejilla
32
/H1100332
diámetro
62
hipercubo
desven-
taja
diámetro
pequeño
factor
salida
fanout
ende
número
víncu-
costo
mayores
hipercubo
multicomputadoras
utilizan
tipos
esquemas
conmutación
mensaje
divide
haga
usuario
interfaz
red
trozo
longitud
máxima
conocido
paquete
esquema
conmutación
conocido
al-
macenamiento
conmutación
paquetes
retransmisión
consiste
inyectar
paquete
switch
tarjeta
interfaz
red
nodo
origen
muestra
fi-
gura
8-17(a
bits
llegan
llega
paquete
búfer
entrada
copia
línea
conduce
switch
ruta
muestra
figura
8-17(b
llega
paquete
switch
conectado
nodo
destino
muestra
550
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Figura
8-16
topologías
interconexión
switch
anillo
rejilla
dobel
toroide
cubo
hipercubo
4D.
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
551
figura
8-17(c
paquete
copia
tarjeta
interfaz
red
nodo
momento
da-
do
copia
RAM
CPU
Puerto
entrada
Puerto
salida
Paquete
completo
Paquete
completo
Interruptor
puertos
CPU
Paquete
completo
Figura
8-17
Almacenamiento
conmutación
paquetes
retransmisión
almacenamiento
conmutación
paquetes
retransmisión
flexible
eficien-
problema
latencia
retraso
aumenta
red
interconexión
Su-
ponga
tiempo
paquete
dé
salto
figura
8-17
nseg
paquete
copiar
CPU
CPU
finalmente
CPU
destino
iniciar
copia
terminado
copia
ante-
rior
latencia
red
interconexión
4T.
solución
diseñar
red
paquete
dividir
lógicamente
unidades
pequeñas
llega
unidad
switch
retransmitir
llegado
par-
unidad
llegue
pequeña
bit
régimen
conmutación
conocido
conmutación
circuitos
consiste
switch
establece
ruta
switches
switch
destino
establecido
ruta
bits
inyectan
origen
destino
de-
tenerse
rapidez
búfer
switches
intermedios
conmutación
circuitos
requiere
fase
configuración
requiere
tiempo
rápida
completado
fase
enviarse
paquete
ruta
deshacer
varia-
ción
conmutación
circuitos
conocida
enrutamiento
segmentado
wormhole
rou-
ting
divide
paquete
subpaquetes
permite
subpaquete
empiece
fluir
construido
ruta
completa
Interfaces
red
nodos
multicomputadora
tarjeta
insertable
contiene
conexión
nodo
red
interconexión
mantiene
unida
multicomputadora
for-
ma
construidas
tarjetas
conectan
CPU
principal
www
FreeLibros.meRAM
consecuencias
considerables
sistema
operativo
analizaremos
breve-
mente
cuestiones
relacionadas
material
basa
Bhoedjang
2000
multicomputadoras
tarjeta
interfaz
contiene
cantidad
considerable
RAM
contener
paquetes
salientes
entrantes
general
paquete
saliente
tie-
ne
copiar
RAM
tarjeta
interfaz
transmitirlo
switch
ra-
zón
diseño
redes
interconexión
asíncronas
inicia
transmisión
paquete
bits
seguir
fluyendo
ritmo
constante
pa-
quete
RAM
principal
garantizar
flujo
continuo
red
tráfico
adicional
bus
memoria
eliminar
problema
utiliza
RAM
dedicada
tarjeta
interfaz
diseño
muestra
figura
8-18
552
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
CPU
CPU
CPU
CPU
Switch
Nodo
RAM
principal
RAM
principal
Nodo
4Tarjeta
interfaz
CPU
opcional
tarjetaRAM
tarjeta
interfaz
Nodo
RAM
principal
RAM
principal
Nodo
Usuario
SO
Figura
8-18
Posición
tarjetas
interfaz
red
multicomputadora
paquetes
entrantes
produce
problema
bits
llegan
red
ve-
locidad
constante
extremo
alta
tarjeta
interfaz
red
almacenar-
tiempo
real
medida
vayan
llegando
perderán
datos
riesgoso
tratar
pasar
bus
sistema
ejemplo
bus
PCI
RAM
principal
general
tarjeta
red
inserta
bus
PCI
única
conexión
RAM
principal
inevitable
competir
bus
disco
dispo-
sitivo
S.
seguro
almacenar
paquetes
entrantes
RAM
privada
tarjeta
interfaz
copiarlos
RAM
principal
tarjeta
interfaz
canales
DMA
contener
CPU
completa
CPUs
canales
DMA
copiar
paquetes
en-
tre
tarjeta
interfaz
RAM
principal
velocidad
alta
solicitan
transferen-
cias
bloques
bus
sistema
transfieren
palabras
solicitar
bus
palabra
separado
precisamente
tipo
transferencia
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
553
bloques
mantiene
ocupado
bus
sistema
ciclos
bus
necesita
RAM
tarjeta
interfaz
tarjetas
interfaz
contienen
CPU
completa
posiblemente
canales
DMA
CPUs
conoce
procesadores
red
ca-
potentes
diseño
indica
CPU
principal
descargar
trabajo
pasarlo
tarjeta
red
manejo
transmisión
confiable
caso
hard-
ware
subyacente
perder
paquetes
multitransmisión
enviar
paquete
des-
tino
compresión
descompresión
cifrado
descifrado
manejo
protección
sistema
procesos
CPUs
significa
sincronizadas
evitar
condiciones
competencia
agrega
sobrecarga
trabajo
sis-
tema
operativo
8.2.2
Software
comunicación
nivel
enemigo
comunicación
alto
rendimiento
sistemas
multicomputadora
co-
piado
paquetes
exceso
caso
copia
RAM
tarjeta
interfaz
nodo
origen
copia
tarjeta
interfaz
origen
tarjeta
interfaz
destino
almacenamiento
retransmisión
ruta
copia
RAM
destino
copias
sistemas
especial
tar-
jeta
interfaz
asignada
espacio
direcciones
virtuales
kernel
espacio
direc-
ciones
virtuales
usuario
proceso
usuario
enviar
paquete
emite
llamada
sistema
atrape
kernel
kernels
tengan
copiar
paquetes
memoria
entrada
salida
ejemplo
evitar
fallos
pá-
gina
transmiten
red
kernel
receptor
sepa
co-
locar
paquetes
entrantes
oportunidad
examinarlos
pasos
copia
ilustran
figura
8-18
copias
RAM
provienen
cuello
botella
copias
adicionales
kernel
duplicar
retraso
extremo
reducir
tasa
transferencia
mitad
evitar
impacto
rendimiento
multicomputadoras
asignan
tarjeta
interfaz
directamente
espacio
usuario
permiten
proceso
usua-
rio
coloquen
paquetes
tarjeta
directamente
kernel
involucre
de-
finitiva
método
ayuda
rendimiento
introduce
problemas
lugar
procesos
ejecución
nodo
necesitan
acceso
red
enviar
paquetes
obtiene
tarjeta
interfaz
espacio
direcciones
problemático
llamada
sistema
asignar
tarjeta
desasignarla
espacio
direcciones
virtuales
proceso
obtiene
tarjeta
envían
paquetes
procesos
ocurre
tarjeta
asignada
espacio
direcciones
virtuales
proceso
llega
paquete
proceso
especial
distintos
propietarios
desea
esfuerzo
ayudar
solución
asignar
tarjeta
interfaz
procesos
necesitan
enton-
ces
requiere
mecanismo
evitar
condiciones
competencia
ejemplo
reclama
búfer
tarjeta
interfaz
intervalo
ejecuta
reclama
www.FreeLibros.mebúfer
produce
desastre
necesita
tipo
mecanismo
sincronización
mecanismos
mutexes
funcionan
asume
procesos
cooperar
entorno
tiempo
compartido
usuarios
prisa
trabajo
usuario
bloquear
mutex
asociado
tarjeta
liberarlo
conclusión
proceso
asignar
tarjeta
interfaz
espacio
usuario
funciona
proceso
usuario
ejecución
nodo
tomen
precauciones
especiales
ejemplo
distintos
procesos
asignen
distintas
porciones
RAM
interfaz
espacios
direcciones
problema
kernel
necesite
acceso
red
interconexión
ejemplo
acceder
sistema
archivos
nodo
remoto
conveniente
ker-
nel
comparta
tarjeta
interfaz
usuarios
siquiera
tiempo
compartido
Su-
ponga
asigna
tarjeta
espacio
usuario
llega
paquete
kernel
suponga
proceso
usuario
envió
paquete
máquina
remota
pretendiendo
kernel
conclusión
diseño
simple
tarjetas
interfaz
red
asignada
es-
pacio
usuario
tráfico
aplicaciones
asignada
espacio
kernel
utilice
sistema
operativo
multicomputadoras
precisamente
Interfaz
comunicación
nodo
red
cuestiones
paquetes
interfaz
red
rápida
utilizar
chip
DMA
tarjeta
copiar
paquetes
RAM
problema
método
DMA
utiliza
direcciones
físicas
virtuales
ejecuta
mane-
ra
independiente
CPU
empezar
duda
proceso
usuario
conoce
dirección
virtual
paquete
desea
enviar
general
conoce
dirección
física
conveniente
llamada
sistema
asignación
dirección
virtual
dirección
física
objetivo
colocar
tarjeta
interfaz
espacio
usuario
pri-
mer
lugar
evitar
llamada
sistema
paquete
enviar
sistema
operativo
decide
sustituir
página
chip
DMA
copia
paquete
página
transmitirán
datos
incorrectos
sistema
operativo
sus-
tituye
página
chip
DMA
copia
paquete
entrante
página
per-
derá
paquete
entrante
arruinará
página
memoria
inocente
evitar
problemas
llamadas
sistema
marcar
desmar-
car
páginas
memoria
marcándolas
indicar
paginar
temporalmente
problemático
llamada
sistema
marcar
página
contenga
paquetes
salientes
llamada
desmar-
carla
paquetes
pequeños
ejemplo
64
bytes
menores
sobrecarga
marcar
desmarcar
búfer
alta
paquetes
ejemplo
KB
pue-
tolerable
tamaños
intermedios
depende
detalles
hardware
im-
pactar
rendimiento
proceso
marcar
desmarcar
páginas
software
complejo
554
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
555
8.2.3
Software
comunicación
nivel
usuario
comunicarse
procesos
distintas
CPUs
multicomputadora
envían
mensajes
en-
tre
forma
simple
proceso
paso
mensajes
expuesto
procesos
usuario
palabras
sistema
operativo
proporciona
forma
enviar
recibir
mensa-
jes
procedimientos
biblioteca
llamadas
subyacentes
estén
disponibles
pa-
ra
procesos
usuario
forma
sofisticada
proceso
actual
paso
mensajes
oculto
usuarios
comunicación
remota
llamada
proce-
dimiento
continuación
estudiaremos
métodos
Enviar
recibir
mínima
expresión
servicios
comunicación
proporcionen
reducir
llamadas
biblioteca
enviar
mensajes
recibirlos
llamada
en-
viar
mensaje
send(dest
mptr
llamada
recibir
mensaje
receive(direc
mptr
llamada
envía
mensaje
apunta
mptr
proceso
identificado
dest
proceso
llamada
bloquee
enviado
mensaje
llamada
proceso
llamada
bloquee
llegue
mensaje
pasa
mensaje
copia
búfer
apunta
mptr
proceso
llamada
des-
bloquea
parámetro
direc
especifica
dirección
receptor
escuchando
mu-
chas
variantes
posibles
procedimientos
parámetros
cuestiones
realiza
direccionamiento
multicomputadoras
estáticas
número
fijo
CPUs
sencilla
manejar
direccionamiento
addr
dirección
compuesta
partes
número
CPU
número
proceso
puerto
CPU
direccionada
forma
CPU
administrar
pro-
pias
direcciones
conflictos
potenciales
Comparación
llamadas
bloqueo
bloqueo
llamadas
descritas
llamadas
bloqueo
conoce
lla-
madas
síncronas
proceso
llama
send
especifica
destino
búfer
enviar-
destino
enviando
mensaje
proceso
emisor
bloquea
suspende
instrucción
llamada
send
ejecuta
mensaje
enviado
completo
muestra
figura
8-19(a
similar
llamada
receive
devuelve
control
recibido
realidad
mensaje
www.FreeLibros.mecolocado
búfer
apunta
parámetro
proceso
permanece
suspendido
receive
has-
ta
llega
mensaje
horas
llegar
sistemas
receptor
espe-
cificar
proceso
desea
recibir
cuyo
caso
permanece
bloqueado
llega
mensaje
emisor
556
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Emisor
bloqueado
Emisor
bloqueado
atrapa
kernel
bloquea
emisor
mensaje
enviando
mensaje
enviando
Emisor
ejecución
Emisor
ejecución
Regresa
Emisor
ejecución
Emisor
ejecución
atrapa
mensaje
copia
búfer
kernel
Regresa
kernel
libera
emisor
Figura
8-19
llamada
envío
bloqueo
llamada
envío
blo-
queo
alternativa
llamadas
bloqueo
llamadas
bloqueo
al-
gunas
conoce
llamadas
asíncronas
send
bloqueo
devuelve
inme-
diato
control
proceso
llamada
enviar
mensaje
ventaja
esquema
proceso
emisor
seguir
operando
paralelo
transmisión
men-
saje
CPU
quede
inactiva
suponiendo
ejecutar
pro-
ceso
general
diseñadores
sistema
eligen
utilizar
primitivas
bloqueo
bloqueo
disponible
primitivas
sis-
temas
disponibles
ambas
primitivas
usuarios
elegir
favorita
ventaja
rendimiento
ofrecen
primitivas
bloqueo
contrarresta-
seria
desventaja
emisor
modificar
búfer
mensaje
enviado
consecuencias
proceso
sobrescriba
mensaje
transmisión
horribles
contemplarlas
proceso
emisor
idea
terminará
transmisión
sabrá
seguro
volver
utilizar
búfer
difícil
evitar
usarlo
indefinida
posibles
soluciones
kernel
copie
mensaje
búfer
in-
terno
kernel
permita
continúe
proceso
muestra
figura
8-19(b
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
557
punto
vista
emisor
esquema
llamada
bloqueo
recibe
control
vuelta
reutilizar
búfer
mensaje
enviado
emisor
estorba
desventaja
método
mensaje
saliente
copiarse
espacio
usuario
espacio
kernel
inter-
faces
red
mensaje
copiar
posteriormente
búfer
transmisión
hardware
formas
básicamente
desperdicia
copia
copia
adicional
reducir
rendimiento
sistema
forma
considerable
solución
interrumpir
emisor
enviado
mensaje
comple-
to
informarle
búfer
disponible
caso
requiere
copia
ahorra
tiempo
interrupciones
nivel
usuario
programación
engañosa
difícil
esté
sujeta
condiciones
competencia
irreproducibles
impo-
sibles
depurar
solución
búfer
copie
escribir
marca
lec-
tura
enviado
mensaje
búfer
vuelve
utilizar
enviar
mensa-
je
obtiene
copia
problema
solución
búfer
esté
aislado
página
escrituras
variables
cercanas
obligarán
obtenga
copia
Ade-
requiere
administración
adicional
enviar
mensaje
afecta
implícita
lectura
escritura
página
probable
vuelva
escribir
página
activará
copia
necesaria
consecuencia
opciones
emisor
Envío
bloqueo
CPU
queda
inactiva
transmisión
mensaje
Envío
bloqueo
copia
desperdicia
tiempo
CPU
copia
adicional
Envío
bloqueo
interrupción
dificulta
programación
Copia
escribir
probablemente
requiera
copia
adicional
momento
condiciones
normales
opción
especial
hilos
disponi-
bles
hilo
bloquee
tratando
enviar
hilos
puedan
continuar
trabajo
requiere
administración
búferes
kernel
comparar
figura
8-19(a
figura
8-19(b
general
mensaje
saldrá
rapidez
requiere
copia
conste
gustaría
recalcar
autores
utilizan
criterio
distinto
di-
ferenciar
primitivas
asíncronas
asíncronas
opinión
alternativa
llamada
sín-
crona
emisor
bloquea
recibido
mensaje
enviado
reconocimiento
vuelta
Andrews
1991
mundo
comunicación
tiempo
real
pa-
labra
síncrona
significado
desgracia
provocar
confusión
send
receive
bloqueo
bloqueo
llamada
bloqueo
só-
suspende
emisor
llegado
mensaje
hilos
disponibles
método
simple
alternativa
llamada
receive
bloqueo
indica
kernel
búfer
devuelve
control
inmediato
utilizar
interrupción
indi-
car
llegado
mensaje
interrupciones
difíciles
programar
www.FreeLibros.mede
lentas
preferible
receptor
realice
sondeos
busca
men-
sajes
entrantes
procedimiento
poll
indique
mensajes
espera
emisor
llamar
et_message
devuelve
mensaje
llega-
do
sistemas
compilador
insertar
llamadas
sondeo
código
lugares
apropiados
difícil
frecuencia
sondear
opción
esquema
llegada
mensaje
provoca
creación
hilo
espontánea
espacio
direcciones
proceso
receptor
hilo
conoce
hilo
emergente
hilo
ejecuta
procedimiento
especifica
adelan-
tado
cuyo
parámetro
apuntador
mensaje
entrante
procesar
mensaje
sim-
plemente
termina
destruye
automática
variante
idea
ejecutar
código
receptor
directamente
manejador
in-
terrupciones
evitar
dificultad
crear
hilo
emergente
esquema
rápido
mensaje
contiene
dirección
manejador
llegue
men-
saje
llamar
manejador
instrucciones
ventaja
necesita
tipo
copia
manejador
recibe
mensaje
tarjeta
interfaz
pro-
cesa
instante
esquema
conoce
mensajes
activos
on
Eicken
colaboradores
1992
mensaje
contiene
dirección
manejador
mensajes
activos
funcio-
nan
emisores
receptores
confían
completo
8.2.4
Llamada
procedimiento
remoto
modelo
paso
mensajes
ofrece
conveniente
estructurar
sistema
operativo
multicomputadora
falla
incorregible
paradigma
básico
ba-
sa
comunicación
entrada
salida
esencia
procedimientos
send
receive
dedi-
can
operaciones
personas
creen
modelo
programación
incorrecto
problema
conoce
tiempo
respec-
to
Birrel
Nelson
1984
escribieron
artículo
introdujeron
forma
completamente
distinta
atacarlo
idea
gratificante
simple
alguien
pensó
implicaciones
sutiles
sección
examinaremos
concepto
im-
plementación
puntos
fuertes
puntos
débiles
resumen
Birrell
Nelson
sugirieron
permitir
programas
llamen
pro-
cedimientos
encuentran
CPUs
proceso
máquina
llama
proce-
dimiento
máquina
proceso
llamada
máquina
suspende
cabo
ejecución
procedimiento
llamó
máquina
información
transpor-
tar
proceso
llamada
procedimiento
llamó
parámetros
de-
volverse
resultado
procedimiento
programador
paso
mensajes
operaciones
S.
técnica
conoce
RPC
Remote
Procedure
Call
Llamada
pro-
cedimiento
remoto
convertido
base
cantidad
software
multicomputa-
dora
tradición
procedimiento
llamada
denomina
cliente
procedimiento
llamó
denomina
servidor
libro
utilizaremos
nombres
idea
RPC
llamada
procedimiento
remoto
parecida
llamada
local
forma
simple
llamar
procedimiento
remoto
programa
558
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
559
cliente
enlazar
pequeño
procedimiento
biblioteca
conocido
resguardo
stub
cliente
representa
procedimiento
servidor
espacio
direcciones
cliente
similar
servidor
enlaza
procedimiento
conocido
resguardo
servi-
dor
procedimientos
ocultan
llamada
procedimiento
cliente
servidor
local
figura
8-20
muestran
pasos
cabo
RPC
paso
cliente
llama
resguardo
cliente
llamada
llamada
procedimiento
local
don-
parámetros
meten
pila
usual
paso
resguardo
clien-
empaqueta
parámetros
mensaje
realiza
llamada
sistema
enviarlo
proceso
empaquetar
parámetros
conoce
marshaling
paso
ker-
nel
envía
mensaje
máquina
cliente
máquina
servidor
paso
kernel
pa-
sa
paquete
entrante
resguardo
servidor
general
llama
receive
paso
resguardo
servidor
llama
procedimiento
servidor
res-
puesta
ruta
dirección
opuesta
CPU
cliente
Resguardo
clienteCliente
Sistema
operativo
CPU
servidor
Resguardo
servidor
Sistema
operativo
Ser-
vidor
Red
Figura
8-20
Pasos
llamada
procedimiento
remoto
resguar-
sombreados
color
gris
elemento
clave
procedimiento
cliente
escrito
usuario
llamada
procedimiento
normal
local
resguardo
cliente
nom-
bre
procedimiento
servidor
procedimiento
cliente
resguardo
clien-
espacio
direcciones
parámetros
pasan
usual
similar
procedimiento
llama
procedimiento
servidor
espacio
direcciones
parámetros
espera
procedimiento
servidor
común
forma
operaciones
send
receive
cabo
comunica-
ción
remota
fingir
llamada
procedimiento
normal
Aspectos
implementación
elegancia
conceptual
RPC
problemas
tratar
importantes
parámetros
tipo
apuntador
general
problema
pasar
www.FreeLibros.meapuntador
procedimiento
procedimiento
llama
utilizar
apuntador
forma
procedimiento
llamada
procedimien-
tos
residen
espacio
direcciones
virtuales
RPC
imposible
pasar
apuntado-
res
cliente
servidor
encuentran
distintos
espacios
direcciones
casos
emplear
trucos
pasar
apuntadores
Suponga
parámetro
apuntador
entero
k.
resguardo
cliente
empaquetar
enviarlo
servidor
resguardo
servidor
crea
apuntador
pasa
procedimiento
servidor
esperarse
procedimiento
servidor
devuel-
ve
control
resguardo
servidor
envía
vuelta
cliente
co-
pia
caso
servidor
cambiado
efecto
secuencia
llamada
estándar
llamada
referencia
sustituido
copia-restauración
desgra-
cia
truco
funciona
ejemplo
apuntador
apunta
grafo
estructu-
ra
datos
compleja
razón
imponer
restricciones
parámetros
procedimientos
llama
remota
problema
lenguajes
tipificación
débil
perfectamente
válido
escribir
procedimiento
calcule
producto
interno
vectores
arreglos
es-
pecificar
longitud
vector
terminar
valor
especial
conocido
procedimiento
llamada
procedimiento
llamó
circunstan-
cias
esencia
imposible
talón
cliente
empaquetar
parámetros
determinar
tercer
problema
deducir
tipos
parámetros
si-
quiera
especificación
formal
código
función
printf
ejemplo
número
parámetros
mezcla
arbitraria
enteros
enteros
cortos
enteros
largos
caracteres
cadenas
números
punto
flotan-
longitudes
tipos
Prácticamente
imposible
tratar
llamar
printf
procedimiento
remoto
permisivo
regla
diga
utilizar
RPC
lenguaje
programación
H11001
H11001
popular
cuarto
problema
relaciona
variables
globales
general
proce-
dimientos
llamadas
llama
comunicar
variables
globales
parámetros
procedimiento
llama
cambia
máquina
remota
código
fallará
variables
globales
compartidas
problemas
indican
RPC
remedio
utiliza
ampliamente
pe-
ro
cuidado
considerar
restricciones
funcione
práctica
8.2.5
Memoria
compartida
distribuida
RPC
atractivos
programadores
prefieren
modelo
memoria
compartida
gustaría
utilizarlo
multicomputadora
sorpresa
po-
sible
preservar
ilusión
memoria
compartida
realidad
técnica
llamada
DSM
Distributed
Shared
Memory
Memoria
compartida
distribuida
Li
1986
Li
Hudak
1989
DSM
página
localiza
560
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
561
memorias
figura
8-1
máquina
memoria
virtual
tablas
pá-
ginas
CPU
realiza
operación
LOADo
STOREen
página
produce
interrupción
pasa
sistema
operativo
sistema
operativo
localiza
página
pi-
CPU
contiene
desasigne
envíe
red
interconexión
lle-
gar
página
asigna
reinicia
instrucción
fracasó
efecto
sistema
operativo
dando
servicio
fallos
página
RAM
remota
dis-
co
local
usuario
máquina
tuviera
memoria
compartida
figura
8-21
ilustra
diferencia
memoria
compartida
DSM
figura
8-21(a
multiprocesador
memoria
compartida
física
implementa
hardware
figura
821(b
DSM
implementada
sistema
operativo
figura
8-21(c
forma
memoria
compartida
implementa
niveles
altos
software
capítulo
regresaremos
opción
concentraremos
DSM
Máquina
Máquina
Sistema
tiempo
ejecución
Sistema
operativo
Memoria
compartida
Aplicación
Hardware
Sistema
tiempo
ejecución
Sistema
operativo
Aplicación
Hardware
Máquina
Máquina
Sistema
tiempo
ejecución
Sistema
operativo
Memoria
compartida
Aplicación
Hardware
Sistema
tiempo
ejecución
Sistema
operativo
Aplicación
Hardware
Máquina
Máquina
Sistema
tiempo
ejecución
Sistema
operativo
Memoria
compartida
Aplicación
Hardware
Sistema
tiempo
ejecución
Sistema
operativo
Aplicación
Hardware
Figura
8-21
niveles
implementar
memoria
compartida
hardware
sistema
operativo
Software
nivel
usuario
veamos
detalle
forma
funciona
DSM
sistema
DSM
espacio
direcciones
divide
páginas
esparcen
nodos
siste-
ma
CPU
referencia
dirección
local
produce
trampa
soft-
ware
DSM
obtiene
página
contiene
dirección
reinicia
instrucción
fallida
www.FreeLibros.mese
completa
éxito
concepto
ilustra
figura
8-22(a
espacio
direcciones
16
páginas
nodos
capaz
contener
páginas
562
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Memoria
virtual
compartida
forma
global
consiste
16
páginas
Memoria
Red
0123456789
CPU
025
CPU
13
81
CPU
47
12
14
CPU
13
15
CPU
025
CPU
13
810
10
CPU
47
12
14
CPU
13
15
CPU
025
CPU
13
81
CPU
47
12
14
CPU
13
15
Figura
8-22
Páginas
espacio
direcciones
distribuidas
máqui-
nas
situación
CPU
referencia
página
10
mueve
situación
ocurre
lee
página
10
utiliza
dupli-
cación
ejemplo
CPU
referencia
instrucciones
datos
páginas
referencias
resuelven
forma
local
referencias
páginas
producen
trampas
ejemplo
referencia
dirección
página
10
producirá
trampa
software
DSM
moverá
página
10
nodo
nodo
muestra
figura
8-22(b
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
563
Duplicación
mejora
sistema
básico
mejorar
rendimiento
forma
considerable
dupli-
cación
páginas
lectura
ejemplo
texto
programa
constantes
lec-
tura
estructuras
datos
lectura
ejemplo
página
10
figura
8-22
sección
texto
programa
CPU
utilice
probabilidad
en-
víe
copia
CPU
perturbar
texto
original
memoria
CPU
mues-
tra
figura
8-22(c
forma
CPUs
referencia
página
10
requieran
producir
trampas
obtener
memoria
faltante
posibilidad
duplicar
páginas
lectura
páginas
estén
realizando
lecturas
realidad
diferencia
duplicar
pá-
gina
lectura
duplicar
página
lectura-escritura
modifica
forma
repen-
tina
página
duplicada
acción
especial
evitar
copias
inconsistentes
siguientes
secciones
veremos
evitar
inconsistencia
Compartición
falsa
sistemas
DSM
similares
multiprocesadores
puntos
clave
sis-
temas
referencia
palabra
memoria
local
obtiene
trozo
memoria
contiene
palabra
ubicación
actual
coloca
máquina
hacien-
do
referencia
memoria
principal
caché
respectivamente
cuestión
importante
diseño
tamaño
trozo
multiprocesadores
tamaño
bloque
caché
general
32
64
bytes
evitar
ocupar
tiempo
bus
trans-
ferencia
sistemas
DSM
unidad
múltiplo
tamaño
página
de-
bido
MMU
funciona
páginas
páginas
efecto
simula
tamaño
página
ventajas
desventajas
tamaño
página
DSM
ma-
yor
ventaja
tiempo
inicio
transferencia
red
sustancial
realidad
requiere
tiempo
transferir
4096
bytes
transferir
1024
by-
tes
transferir
datos
unidades
mover
pieza
espacio
direcciones
reducir
número
transferencias
propiedad
especial
importante
programas
exhiben
localidad
referencia
significa
programa
referencia
palabra
página
probable
haga
referen-
cia
palabras
página
futuro
inmediato
red
ocupada
tiempo
transferencia
bloquea-
rá
fallas
provocadas
procesos
tamaño
efectivo
página
de-
masiado
presenta
problema
conocido
compartición
falsa
ilustra
figura
8-23
página
contiene
variables
compartidas
relacionadas
procesador
utiliza
intensiva
variable
operaciones
lectura
escritura
similar
proceso
utiliza
variable
frecuencia
es-
tas
circunstancias
página
contiene
ambas
variables
viajando
constantemente
máquina
www
FreeLibros.meEl
problema
variables
relacionadas
aparecen
casualidad
página
proceso
utiliza
obtiene
compartición
falsa
ocurrirá
frecuencia
tamaño
efectivo
página
contrario
ocurrirá
frecuencia
menor
sistemas
memoria
virtual
ordinarios
análogo
fenómeno
compiladores
inteligentes
comprenden
problema
colocan
variables
espacio
direcciones
necesario
ayudar
reducir
compartición
falsa
mejorar
ren-
dimiento
decirlo
fácil
compartición
falsa
con-
siste
nodo
utilice
elemento
arreglo
nodo
utilice
elemento
distinto
arreglo
siquiera
compilador
inteligente
eliminar
problema
lograr
consistencia
secuencial
duplican
páginas
escribir
datos
problema
lograr
consistencia
copia
página
escribir
trasla-
dinámica
necesario
adelantado
cuá-
páginas
escribir
sistemas
DMS
proceso
leer
página
remota
crea
copia
local
copia
remota
establecen
MMUs
respectivas
lectura
referencias
lecturas
to-
do
obstante
proceso
intenta
escribir
página
duplicada
surge
problema
consistencia
potencial
aceptable
modificar
copia
dejar
modificar
situación
similar
ocurre
multiprocesador
CPU
modificar
palabra
presente
cachés
solución
caso
CPU
punto
escritura
coloque
señal
bus
indicar
CPUs
descartar
copia
bloque
caché
general
sistemas
DMS
564
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
CPU
Código
utiliza
variable
Página
compartida
CPU
Código
utiliza
variable
Red
variables
compartidas
relacionadas
simplemente
encuentran
página
Figura
8-23
Compartición
falsa
página
contiene
variables
relacio-
nadas
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
565
funcionan
forma
escribir
página
compartida
envía
men-
saje
CPUs
contienen
copia
página
indicarles
desa-
signar
descartar
página
CPUs
hayan
respondido
terminado
desasignación
CPU
original
proceder
escritura
tolerar
copias
páginas
escribir
circuns-
tancias
cuidadosamente
restringidas
forma
permitir
proceso
adquiera
bloqueo
so-
bre
porción
espacio
direcciones
virtuales
realice
operaciones
lectura
escritura
memoria
bloqueada
momento
libere
bloqueo
pro-
pagar
cambios
copias
CPU
bloquear
pá-
gina
momento
esquema
preservar
consistencia
alternativa
escribe
página
lle-
gar
escribir
datos
realiza
copia
limpia
guarda
CPU
realizando
escritu-
ra
adquirir
bloqueos
página
actualiza
liberan
bloqueos
proceso
máquina
remota
trate
adquirir
bloqueo
página
CPU
escribió
compara
actual
página
copia
limpia
crea
mensa-
je
lista
palabras
modificado
lista
envía
CPU
adquirió
bloqueo
actualice
copia
invalidarla
Keleher
colaboradores
1994
8.2.6
Planificación
multicomputadoras
multiprocesador
procesos
residen
memoria
CPU
termi-
na
tarea
actual
selecciona
proceso
ejecuta
principio
procesos
can-
didatos
potenciales
multicomputadora
situación
distinta
nodo
memoria
conjunto
procesos
CPU
decidir
repen-
tina
ejecutar
proceso
localizado
nodo
cantidad
considerable
trabajo
obtenerlo
diferencia
significa
fácil
planificación
multicompu-
tadoras
importante
asignación
procesos
nodos
continuación
estudia-
remos
cuestiones
planificación
multicomputadoras
proceso
similar
planificación
multiproce-
sadores
algoritmos
aplican
algo-
ritmo
multiprocesador
simple
mantener
lista
central
procesos
listos
funciona
proceso
ejecutar
CPU
ubica-
do
crear
proceso
elegir
colocarlo
ejemplo
balancear
carga
nodo
procesos
utilizar
algoritmo
planifica-
ción
local
obstante
utilizar
planificación
pandilla
multiproce-
sadores
requiere
inicial
proceso
ejecutar
ranura
tiempo
forma
coordinar
inicio
ranuras
tiempo
8.2.7
Balanceo
carga
realidad
planificación
multicomputadoras
asigna
proceso
nodo
utilizar
algoritmo
planificación
local
www.FreeLibros.memenos
esté
utilizando
planificación
pandilla
precisamente
control
asigna
proceso
nodo
importante
decidir
nodo
proceso
contrario
sistemas
multiprocesadores
proceso
viven
memoria
programar
CPU
desee
consecuencia
conveniente
analizar
forma
asignar
procesos
nodos
efectiva
algoritmos
heurística
asignación
conocen
co-
mo
algoritmos
asignación
procesador
años
propuesto
algoritmos
asignación
procesador
nodo
algoritmos
difieren
supone
objetivo
pro-
piedades
conocerse
proceso
incluyen
requerimientos
CPU
memoria
comunicación
procesos
posibles
objetivos
incluyen
mi-
nimizar
ciclos
desperdiciados
CPU
trabajo
local
minimizar
ancho
banda
comunicación
asegurar
equidad
usuarios
procesos
con-
tinuación
examinaremos
algoritmos
idea
Algoritmo
determinístico
basado
teoría
grafos
clase
algoritmos
estudia
sistemas
consisten
procesos
requerimientos
CPU
memoria
conocidos
matriz
conocida
proporciona
cantidad
promedio
tráfico
par
procesos
número
procesos
número
CPUs
asignar
procesos
CPU
idea
asignación
pa-
ra
minimizar
tráfico
red
sistema
representar
grafo
ponderado
vértice
proceso
arco
representa
flujo
mensajes
procesos
sentido
matemático
problema
reduce
buscar
forma
particionar
recortar
grafo
subgrafos
separados
sujetos
restricciones
ejemplo
requerimientos
totales
CPU
memoria
de-
límites
subgrafo
solución
cumpla
restricciones
arcos
encuentran
completo
subgrafo
representan
comunicación
en-
tre
máquinas
ignorar
arcos
subgrafo
representan
tráfico
red
objetivo
encontrar
particionamiento
minimice
tráfico
red
tiempo
cumpla
restricciones
ejemplo
figura
8-24
muestra
sis-
tema
procesos
arco
etiquetado
carga
comunicación
media
procesos
correspondientes
ejemplo
Mbps
figura
8-24(a
particionado
grafo
procesos
nodo
procesos
nodo
procesos
nodo
tráfico
red
suma
arcos
intersecados
cortes
líneas
punteadas
30
unidades
figura
8-24(b
particionamiento
distinto
28
unidades
tráfico
red
Supo-
niendo
cumpla
restricciones
memoria
CPU
opción
de-
bido
requiere
comunicación
intuición
buscar
clústeres
tengan
acoplamiento
fuerte
flujo
alto
tráfico
clústeres
interactúen
clústeres
flujo
tráfico
clústeres
artículos
analizan
problema
Chow
Abraham
1982
1984
Stone
Bokhari
1978
566
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.2
MULTICOMPUTADORAS
567
algoritmo
heurístico
iniciado
emisor
veamos
algoritmos
distribuidos
algoritmo
crea
proceso
ejecuta
nodo
creó
nodo
esté
sobrecargado
métrica
sobre-
carga
implicar
demasiados
procesos
conjunto
trabajo
métrica
nodo
sobrecargado
selecciona
nodo
azar
pregunta
carga
usando
métrica
carga
nodo
menor
valor
umbral
pro-
ceso
envía
nodo
Eager
colaboradores
1986
menor
selecciona
máqui-
na
sondeo
proceso
sondeo
indefinido
host
adecuado
sondeos
algoritmo
termina
proceso
ejecuta
máquina
originó
idea
nodos
carga
traten
deshacerse
exceso
trabajo
mues-
tra
figura
8-25(a
ilustra
balanceo
carga
iniciado
emisor
Nodo
Nodo
32
812
42
Nodo
Nodo
Nodo
32
812
42
Nodo
Tráfico
Proceso
Figura
8-24
formas
asignar
procesos
nodos
llenoAquí
envío
proceso
cedo
trabajo
sobrecargado¡Ayuda
Bostezo
aburrido
libre
noche
Necesitas
ayuda
Figura
8-25
nodo
sobrecargado
busca
nodo
carga
darle
al-
gunos
procesos
nodo
vacío
busca
www
FreeLibros.meEager
colaboradores
1986
construyeron
modelo
puesta
cola
analítico
algoritmo
modelo
estableció
algoritmo
comporta-
miento
estable
amplio
rango
parámetros
incluyendo
diversos
valores
umbral
costos
transferencia
límites
sondeo
condiciones
carga
máqui-
nas
enviarán
sondas
constantemente
máquinas
intento
inútil
encontrar
es-
té
dispuesta
aceptar
trabajo
descargarán
procesos
máquina
producir
considerable
sobrecarga
tratar
algoritmo
heurístico
distribuido
iniciado
receptor
algoritmo
complementario
analizamos
sección
inicia
emisor
sobrecargado
inicia
receptor
carga
muestra
figu-
ra
8-25(b
algoritmo
proceso
termina
sistema
comprueba
su-
ficiente
trabajo
selecciona
máquina
azar
pide
trabajo
máquina
ofrecer
selecciona
máquina
trabajo
sondeos
nodo
deja
pedir
trabajo
temporalmente
realiza
traba-
jo
puesto
cola
intenta
termina
proceso
trabajo
disponible
máquina
queda
inactiva
intervalo
fijo
empieza
sondear
ventaja
algoritmo
impone
carga
adicional
sistema
mo-
mentos
críticos
algoritmo
iniciado
emisor
realiza
sondeos
precisamente
sistema
capacidad
tolerarlos
carga
algoritmo
inicia-
do
receptor
sistema
carga
probabilidad
má-
quina
suficiente
trabajo
ocurra
fácil
encontrar
trabajo
trabajo
algoritmo
iniciado
receptor
crea
tráfico
sondeo
considerable
máquinas
desempleadas
buscando
traba-
jo
desesperación
obstante
aumente
sobrecarga
sistema
carga
sobrecargado
combinar
algoritmos
máquinas
traten
deshacerse
trabajo
tengan
traten
adquirir
trabajo
tengan
suficiente
máquinas
puedan
mejorar
sondeo
azar
mantienen
historial
sondeos
anteriores
determinar
problema
crónico
carga
carga
probar
algoritmos
dependiendo
iniciador
tratando
deshacerse
tra-
adquirir
8.3
VIRTUALIZACIÓN
situaciones
empresa
multicomputadora
realidad
ejemplo
común
empresa
servidor
correo
electrónico
servidor
Web
servidor
FTP
servidores
comercio
electrónico
servidores
ser-
vidores
ejecutan
distintas
computadoras
bastidor
equipos
conec-
568
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.3
VIRTUALIZACIÓN
569
tados
red
alta
velocidad
palabras
multicomputadora
casos
servidores
ejecutan
máquinas
separadas
máquina
manejar
carga
casos
razón
principal
ejecutar
servi-
cios
procesos
máquina
confiabilidad
administración
simplemente
confía
sistema
operativo
ejecute
24
horas
365
366
año
fa-
llas
colocar
servicio
computadora
separada
falla
servidores
me-
verán
afectados
forma
logra
tolerancia
fallas
solución
costosa
difícil
administrar
máquinas
involucradas
propuesto
solución
tecnología
máquinas
virtuales
conoce
virtualización
40
años
vimos
sección
1.7.5
tecnología
permite
computadora
contenga
máquinas
virtua-
llegar
ejecutar
sistema
operativo
distinto
ventaja
método
falla
máquina
virtual
ocasiona
fallen
auto-
mática
sistema
virtualizado
ejecutar
distintos
servidores
máquinas
virtuales
mantiene
modelo
parcial
fallas
computadora
costo
menor
administración
sencilla
consolidar
servidores
forma
huevos
ca-
nasta
falla
servidor
ejecuta
máquinas
virtuales
resultado
catastró-
fico
falla
servidor
dedicado
razón
virtualización
funcionar
mayoría
fallas
servicios
hardware
defec-
tuoso
software
presuntuoso
confiable
lleno
errores
especial
sistemas
ope-
rativos
tecnología
máquinas
virtuales
único
software
ejecuta
kernel
hipervisor
100
líneas
código
sistema
operativo
completo
ende
100
errores
ejecución
software
máquinas
virtuales
ventajas
sólido
ais-
lamiento
máquinas
físicas
ahorro
hardware
electri-
cidad
ocupa
espacio
oficina
compañía
Amazon
Yahoo
Microsoft
Google
cientos
miles
servidores
realizan
enorme
variedad
tareas
distintas
reducción
demandas
físicas
centros
datos
representa
enorme
ahorro
costos
general
empresas
departamentos
individuales
gru-
pos
piensan
idea
interesante
compran
servidor
implementarla
idea
éxito
requieren
cientos
miles
servidores
expande
centro
datos
cor-
porativo
difícil
mover
software
máquinas
existentes
apli-
cación
necesita
frecuencia
versión
distinta
sistema
operativo
bibliotecas
archivos
configuración
máquinas
virtuales
aplicación
entorno
ventaja
máquinas
virtuales
fácil
puntos
comprobación
migrar
datos
máquina
virtual
ejemplo
balancear
carga
ser-
vidores
migrar
procesos
ejecutan
sistema
operativo
normal
caso
mantiene
cantidad
considerable
información
crítica
proceso
ta-
blas
sistema
operativo
incluyendo
información
relacionada
apertura
archivos
alarmas
manejadores
señales
migrar
máquina
virtual
mover
imagen
memoria
tablas
sistema
operativo
mueven
www
FreeLibros.meOtro
máquinas
virtuales
ejecutar
aplicaciones
heredadas
sistemas
operativos
versiones
sistemas
operativos
soporte
funcionan
hardware
actual
aplicaciones
heredadas
ejecutar
tiempo
mis-
mo
hardware
aplicaciones
actuales
habilidad
ejecutar
tiempo
apli-
caciones
utilizan
distintos
sistemas
operativos
argumento
favor
máquinas
virtuales
desarrollo
software
importante
máquinas
virtuales
progra-
mador
quiera
asegurarse
software
funcione
Windows
98
Windows
2000
Windows
XP
Windows
Vista
versiones
Linux
FreeBSD
OpenBSD
NetBSD
Mac
docena
computadoras
instalar
distintos
sistemas
operativos
único
crear
docena
máquinas
virtuales
compu-
tadora
instalar
distintos
sistemas
operativos
máquina
virtual
progra-
mador
particionado
disco
duro
instalar
sistema
operativo
distinto
partición
método
dificultoso
lugar
PCs
estándar
soportan
cua-
tro
particiones
primarias
disco
importar
lugar
po-
dría
instalar
programa
multiarranque
bloque
arranque
necesario
reiniciar
computadora
trabajar
sistema
operativo
máquinas
virtuales
sistemas
operativos
ejecutar
tiempo
realidad
procesos
glorificados
8.3.1
Requerimientos
virtualización
vimos
capítulo
métodos
virtualización
figura
1-29(a
mues-
tra
tipo
hipervisor
denominado
hipervisor
tipo
monitor
máquina
virtual
realidad
sistema
operativo
único
programa
ejecuta
kernel
trabajo
soportar
copias
hardware
actual
conocidas
máquinas
virtuales
similar
procesos
soporta
sistema
operativo
normal
contrario
hiper-
visor
tipo
muestra
figura
1-29(b
completamente
distinto
pro-
grama
usuario
ejecuta
Windows
Linux
interpreta
conjunto
instrucciones
máquina
crea
máquina
virtual
Pusimos
interpreta
en-
tre
comillas
general
trozos
código
procesan
forma
des-
pués
colocarlos
caché
ejecutarlos
directamente
mejorar
rendimiento
interpretación
completa
funcionaría
principio
lentitud
sistema
operativo
ejecuta
hipervisor
casos
denomina
sistema
operativo
invitado
caso
hipervisor
tipo
sistema
operativo
ejecuta
hardware
denomina
sistema
operativo
anfitrión
importante
casos
máquinas
virtuales
actuar
justo
forma
hardware
real
Específicamente
iniciarlas
máquinas
rea-
instalar
sistema
operativo
justo
hardwa-
re
real
tarea
hipervisor
brindar
ilusión
eficiencia
intérprete
completo
razón
tipos
hipervisores
defectos
arquitectura
Intel
386
acarrearon
servilmente
CPUs
20
años
mantener
com-
patibilidad
inversa
síntesis
CPU
kernel
usuario
conjun-
570
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.3
VIRTUALIZACIÓN
571
to
instrucciones
ejecutar
kernel
instrucciones
rea-
lizan
operaciones
modifican
opciones
MMU
etcétera
Popek
Goldberg
1974
desarrollaron
trabajo
clásico
virtualización
instrucciones
lla-
maron
instrucciones
sensibles
conjunto
instrucciones
producen
tram-
pa
interrupción
ejecutan
usuario
instrucciones
Popek
Goldberg
llamaron
instrucciones
privilegiadas
artículo
declararon
máquina
virtualizar
instrucciones
sensibles
subconjunto
instrucciones
pri-
vilegiadas
explicarlo
lenguaje
simple
usua-
rio
deba
hardware
deberá
producir
interrupción
diferencia
IBM/370
propiedad
Intel
386
ignoraban
instrucciones
sensibles
386
ejecutaba
usuario
ejemplo
instrucción
POPF
sustituye
registro
banderas
modifica
bit
habilita
deshabilita
interrupciones
usuario
bit
simplemente
modifica
consecuencia
386
sucesores
po-
dían
virtualizar
podían
soportar
hipervisor
tipo
realidad
situación
muestra
problemas
instrucciones
atrapar
usuario
instrucciones
leer
sensible
usuario
producir
interrupción
ejemplo
Pentium
programa
determinar
ejecutando
usuario
kernel
leer
selector
segmento
código
sistema
operativo
hiciera
descubriera
usuario
tomar
decisión
incorrecta
base
infor-
mación
problema
resolvió
Intel
AMD
introdujeron
virtualización
CPUs
em-
pezando
2005
CPUs
Intel
Core
conoce
VT
Tecnología
virtualización
CPUs
AMD
Pacific
conoce
SVM
Máquina
virtual
segura
continuación
uti-
lizaremos
término
VT
sentido
genérico
Ambas
tecnologías
inspiraron
trabajo
IBM
VM/370
diferencias
idea
básica
crear
contenedores
puedan
ejecutar
máquinas
virtuales
inicia
sistema
operativo
invitado
contenedor
ejecutando
produce
excepción
atrapa
hipervisor
ejemplo
ejecución
instrucción
S.
conjunto
operaciones
atrapan
controla
mapa
bits
hardware
establecido
hipervisor
extensiones
utilizar
clásico
método
atrapar
emular
máquina
virtual
8.3.2
Hipervisores
tipo
capacidad
virtualización
cuestión
importante
examinaremos
de-
talle
figura
8-26
hipervisor
tipo
soporta
máquina
virtual
hipervisores
tipo
ejecuta
kernel
máquina
virtual
eje-
cuta
proceso
usuario
usuario
ejecutar
instrucciones
sensibles
máquina
virtual
ejecuta
sistema
operativo
invitado
piensa
kernel
usuario
llamaremos
kernel
virtual
máquina
virtual
ejecuta
procesos
usuario
creen
encuentran
usuario
realidad
www
FreeLibros.me¿Qué
ocurre
sistema
operativo
cree
kernel
eje-
cuta
instrucción
sensible
permite
kernel
CPUs
VT
instrucción
falla
general
sistema
operativo
virtualización
imposible
duda
podríamos
argumentar
instrucciones
sensibles
atrapar
ejecutarse
usuario
forma
trabaja-
ba
386
sucesores
utilizaban
tecnología
VT
CPUs
VT
sistema
operativo
invitado
ejecuta
instrucción
sensible
produce
interrupción
kernel
muestra
figura
8-26
hipervisor
inspeccionar
instrucción
sistema
operativo
anfitrión
emitió
máquina
virtual
programa
usuario
máquina
virtual
caso
preparaciones
pa-
ra
ejecute
instrucción
caso
emula
haría
hardware
real
confron-
tarlo
instrucción
sensible
ejecuta
usuario
máquina
virtual
VT
general
instrucción
ignora
VT
atrapa
sistema
operativo
invitado
ejecuta
máquina
virtual
8.3.3
Hipervisores
tipo
proceso
crear
sistema
máquina
virtual
simple
VT
disponible
hacían
personas
duda
ejecutar
sistema
operativo
completo
máquina
virtual
ignorarían
instrucciones
sensibles
sistema
fallaría
ocurrió
invención
conoce
hipervisores
tipo
muestra
figura
1-29(b
hipervisores
VMware
Adams
Agesen
2006
Waldspurger
2002
fruto
proyecto
investigación
DISCO
Universidad
Stanford
Bugnion
colaboradores
1997
VMware
ejecuta
programa
usuario
ordinario
sistema
operativo
anfitrión
Windows
Linux
inicia
actúa
computadora
acaba
iniciar
espera
encontrar
unidad
CD-ROM
disco
contenga
sistema
operativo
572
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Hipervisor
tipo
Máquina
virtual
Sistema
operativo
invitado
kernel
virtual
usuario
virtual
Hardware
atrapa
instrucción
privilegiada
Proceso
usuario
kernel
usuario
Figura
8-26
sistema
operativo
máquina
virtual
ejecuta
instruc-
ción
ejecutar
kernel
atrapa
hipervisor
tec-
nología
virtualización
presente
www
FreeLibros.meSECCIÓN
8.3
VIRTUALIZACIÓN
573
instala
sistema
operativo
disco
virtual
realidad
archivo
Windows
Linux
ejecuta
programa
instalación
CD-ROM
instala
sistema
operativo
invitado
disco
virtual
ini-
ciar
ejecutarlo
veamos
funciona
VMware
detalle
ejecutar
programa
binario
Pentium
obtener
CD-ROM
instalación
disco
virtual
ex-
plora
código
buscar
bloques
básicos
ejecuciones
instrucciones
seguidas
ter-
minan
salto
llamada
interrupción
instrucción
modifica
flujo
control
definición
bloque
básico
contiene
instrucción
modifique
contador
programa
inspecciona
bloque
básico
contiene
instrucciones
sensibles
sentido
Popek
Goldberg
instrucciones
susti-
tuye
llamada
procedimiento
VMware
maneja
instrucción
sustituye
llamada
VMware
realicen
pasos
bloque
básico
coloca
caché
VMware
des-
pués
ejecuta
bloque
básico
contenga
instrucciones
sensibles
ejecutará
mis-
ma
rapidez
VMware
máquina
básica
ejecutando
máquina
instrucciones
sensitivas
atrapan
emulan
técnica
conoce
traducción
binaria
bloque
básico
completado
ejecución
control
regresa
VMware
localiza
sucesor
traducido
sucesor
ejecutar
inmediato
traduce
coloca
caché
ejecuta
momento
par-
programa
caché
ejecutará
velocidad
completa
utilizan
optimizaciones
ejemplo
bloque
básico
termina
saltar
llamar
sus-
tituir
instrucción
salto
llamada
directamente
bloque
básico
traducido
elimina
sobrecarga
asociada
búsqueda
bloque
sucesor
necesidad
sustituir
instrucciones
sensibles
programas
usuario
hardware
ig-
norará
formas
funcionan
hipervisores
tipo
hardware
virtualizar
instrucciones
sensibles
sustituyen
llamadas
proce-
dimientos
emulan
instrucciones
hardware
ejecuta
instrucciones
sensibles
emite
sistema
operativo
invitado
convierten
llamadas
hipervisor
emula
podríamos
esperar
CPUs
VT
tuvieran
rendimiento
técnicas
software
utilizan
hipervisores
tipo
mediciones
muestran
cosa
Adams
Agesen
2006
Resulta
método
atrapar
emular
utiliza
hardwa-
re
VT
genera
interrupciones
costosas
hardware
moderno
debi-
do
arruinan
cachés
CPUs
TLBs
tablas
predicción
bifurcación
internas
CPU
contrario
instrucciones
sensibles
sustituyen
lla-
madas
procedimientos
VMware
proceso
ejecución
produce
sobre-
carga
cambio
contexto
muestran
Adams
Agesen
software
vence
hardware
dependiendo
carga
trabajo
razón
hiperviso-
res
tipo
realizan
traducción
binaria
cuestiones
rendimiento
software
ejecute
correcta
www
FreeLibros.me8.3.4
Paravirtualización
hipervisores
tipo
tipo
funcionan
sistemas
operativos
invitados
estén
modi-
ficados
esfuerzo
obtener
rendimiento
razonable
método
distinto
popular
modificar
código
fuente
sistema
operativo
invitado
ejecutar
instrucciones
sensibles
realiza
llamadas
hipervisor
efec-
to
sistema
operativo
invitado
actúa
programa
usuario
realiza
llamadas
siste-
ma
operativo
hipervisor
utiliza
método
hipervisor
definir
interfaz
consiste
conjunto
llamadas
procedimientos
sistemas
operativos
invitados
puedan
utilizar
conjunto
llamadas
forma
efecto
API
Interfaz
programación
aplicaciones
interfaz
utilicen
sistemas
operativos
invitados
programas
aplicación
paso
allá
eliminar
instrucciones
sensibles
sistema
operativo
haga
llamadas
hipervisor
obtener
servicios
sistema
convertido
hipervisor
microkernel
figura
1-26
sistema
ope-
rativo
invitado
eliminado
intencional
instrucciones
sensi-
bles
paravirtualizado
Barham
colaboradores
2003
Whitaker
colaboradores
2002
emulación
instrucciones
peculiares
hardware
tarea
desagradable
consume
mu-
cho
tiempo
Requiere
llamada
hipervisor
emular
semántica
exacta
instrucción
complicada
sistema
operativo
invitado
llame
hipervisor
microkernel
operaciones
sucesivo
principal
razón
hipervisores
emulaban
máquina
completa
falta
disponibilidad
código
fuente
sistema
operativo
invitado
ejemplo
Windows
debi-
do
cantidad
variantes
Linux
futuro
estandarizará
API
hi-
pervisor
microkernel
sistemas
operativos
diseñarán
llamar
API
utilizar
instrucciones
sensibles
facilitaría
soporte
tecnología
máquinas
virtuales
figura
8-27
ilustra
diferencia
virtualización
paravirtualiza-
ción
máquinas
virtuales
soportan
hardware
VT
izquier-
versión
modificar
Windows
sistema
operativo
invitado
ejecuta
instrucción
sensible
hardware
atrape
hipervisor
emula
regresa
derecha
versión
Linux
modificada
contiene
instrucciones
sensibles
necesita
operaciones
modificar
registros
in-
ternos
críticos
apunta
tablas
páginas
realiza
llamada
hipervisor
trabajo
forma
programa
aplicación
llamada
siste-
ma
Linux
estándar
figura
8-27
mostrado
hipervisor
divide
partes
separadas
línea
punteada
realidad
programa
ejecuta
hardware
programa
responsable
interpretar
instrucciones
sensibles
atrapan
caso
Windows
programa
cabo
llamadas
hipervisor
fi-
gura
programa
etiqueta
microkernel
hipervisor
ejecuta
sistemas
operativos
invitados
paravirtualizados
necesidad
emular
instrucciones
sensibles
microkernel
proporciona
servicios
básicos
despachar
574
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.3
VIRTUALIZACIÓN
575
procesos
administrar
MMU
límite
hipervisor
tipo
microkernel
impreciso
empeorará
medida
hipervisores
adquieran
funcio-
nalidad
llamadas
tema
controversial
pro-
grama
ejecute
kernel
hardware
básico
pequeño
confiable
consistir
miles
líneas
código
millones
líneas
investigadores
hablado
tema
Hand
colaboradores
2005
Heiser
colaboradores
2006
Hohmuth
colabora-
dores
2004
Roscoe
colaboradores
2007
paravirtualizar
sistema
operativo
invitado
surgen
cuestiones
lugar
instrucciones
sensibles
sustituyen
llamadas
hipervisor
ejecutar
sis-
tema
operativo
hardware
nativo
hardware
comprende
llamadas
hipervisor
lugar
pasa
hipervisores
disponibles
mercado
VMware
Xen
código
fuente
abierto
diseñado
originalmente
Universidad
Cambridge
Microsoft
Viridian
APIs
hipervisor
distintas
pue-
modificar
kernel
ejecutarse
Amsden
colaboradores
2006
propuesto
solución
modelo
kernel
modifica
llamar
procedimientos
especiales
necesita
sensible
conjunto
procedimientos
conocidos
VMI
Virtual
Machina
Interface
Interfaz
máquina
virtual
forman
capa
nivel
actúa
interfaz
hardware
hiper-
visor
procedimientos
diseñados
genéricos
enlazados
hardware
hipervisor
especial
figura
8-28
muestra
ejemplo
técnica
versión
paravirtualizada
Li-
nux
conocida
VMI
Linux
VMIL
VMI
Linux
ejecuta
hardware
básico
tie-
ne
vincularse
biblioteca
emite
instrucción
actual
sensible
necesaria
trabajo
muestra
figura
8.28(a
ejecutarse
hipervisor
ejemplo
VM-
ware
Xen
sistema
operativo
invitado
vincula
distintas
bibliotecas
componen
lla-
madas
apropiadas
distintas
hipervisor
hipervisor
subyacente
forma
núcleo
sistema
operativo
portable
amigable
hipervisores
eficiente
Windows
modificar
Linux
modificado
atrapa
instrucciones
sensibles
atrapa
llamada
hipervisor
ParavirtualizaciónVirtualización
Microkernel
Hipervisor
tipo
Hardware
Figura
8-27
hipervisor
soporta
virtualización
paravirtualiza-
ción
www
FreeLibros.meTambién
propuesto
técnicas
interfaz
máquina
virtual
populares
paravirt
ops
idea
similar
concepto
visto
difie-
re
detalles
8.3.5
Virtualización
memoria
tratado
cuestión
virtualizar
CPU
sistema
cómputo
componentes
aparte
CPU
memoria
dispositivos
S.
virtualizar
Veamos
sistemas
operativos
modernos
soportan
memoria
virtual
esencia
asignación
páginas
espacio
direcciones
virtuales
páginas
memoria
física
asignación
define
tablas
páginas
multinivel
general
asignación
establece
movimiento
sistema
operativo
establezca
registro
control
CPU
apunte
tabla
páginas
nivel
superior
virtualización
complica
con-
siderable
administración
memoria
ejemplo
suponga
ejecutando
máquina
virtual
sistema
operativo
in-
vitado
decide
asignar
páginas
virtuales
páginas
físicas
10
11
12
respec-
tivamente
Crea
tablas
páginas
contienen
asignación
carga
registro
hardware
apunte
página
tablas
nivel
superior
instrucción
sensible
CPU
VT
producirá
interrupción
VMware
producirá
llamada
procedimiento
VMware
sistema
operativo
paravirtualizado
generará
llamada
hipervisor
aras
simplicidad
suponer
atrapa
hipervisor
tipo
problema
casos
hipervisor
solución
asignar
páginas
físicas
10
11
12
máquina
virtual
establecer
páginas
tablas
actuales
asignen
páginas
virtuales
máquina
virtual
utilizarlas
576
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Hardware
Biblioteca
interfaz
VMIL
HW
HW
ejecuta
instrucción
sensible
VMI
Linux
Hardware
VMware
VMI
Linux
VMIL
biblioteca
VMware
Llamada
hipervisor
Hardware
Xen
VMI
Linux
VMIL
biblioteca
Xen
Llamada
hipervisor
Figura
8-28
VMI
Linux
ejecutándose
hardware
básico
VMware
Xen
www
FreeLibros.meSECCIÓN
8.3
VIRTUALIZACIÓN
577
suponga
inicia
máquina
virtual
asigna
páginas
virtuales
páginas
físicas
10
11
12
carga
registro
control
apunte
ta-
blas
páginas
hipervisor
atrapa
interrupción
utilizar
asignación
páginas
físicas
10
11
12
buscar
páginas
li-
bres
ejemplo
20
21
22
utilizarlas
crear
páginas
tablas
asignar
páginas
virtuales
máquina
virtual
páginas
físicas
20
21
22
inicia
máquina
virtual
utilizar
páginas
físicas
10
11
12
crear
asignación
general
máquina
virtual
hipervisor
necesita
crear
ta-
bla
páginas
oculta
shadow
asigne
páginas
virtuales
utiliza
máquina
virtual
páginas
actuales
hipervisor
otorgó
sistema
operativo
invitado
cambie
tablas
páginas
hipervisor
cambiar
tablas
páginas
ocultas
ejemplo
SO
invita-
do
reasigna
página
virtual
ve
página
virtual
200
10
hipervisor
acerca
cambio
problema
sistema
operativo
invitado
cam-
biar
tablas
páginas
escribir
memoria
requieren
operaciones
sensibles
hipervisor
siquiera
entera
cambio
definitiva
actualizar
tablas
páginas
ocultas
utiliza
hardware
actual
solución
burda
hipervisor
lleve
registro
página
memoria
virtual
invitado
contiene
tabla
páginas
nivel
superior
obtener
in-
formación
invitado
intente
cargar
registro
software
apunta
instrucción
sensible
produce
interrupción
hipervisor
crear
tabla
pá-
ginas
oculta
punto
asignar
tabla
páginas
nivel
superior
ta-
blas
páginas
apunta
lectura
intentos
subsiguientes
sistema
operativo
invitado
modificar
cualquiera
páginas
producirán
fallo
página
consecuencia
otorgarán
control
hipervisor
analizar
flujo
instrucciones
averiguar
tratando
SO
invitado
actualizar
tablas
páginas
ocul-
tas
necesario
bonito
principio
área
futuras
versiones
VT
ofrecer
asistencia
asignación
niveles
hardware
hardware
asignar
página
virtual
idea
invitado
página
física
asignar
dirección
hardware
ve
dirección
virtual
dirección
física
produzcan
interrup-
ciones
forma
habría
marcar
tabla
páginas
lectura
hipervisor
simplemente
tendría
proveer
asignación
espacio
direcciones
virtua-
invitado
memoria
física
cambiar
máquinas
virtuales
cambiaría
asignación
forma
sistema
operativo
normal
cambia
asignación
cam-
biar
procesos
sistema
operativo
paravirtualizado
situación
SO
paravirtualiza-
do
invitado
termine
cambiar
tabla
páginas
proceso
informar
hipervisor
consecuencia
cambia
tabla
páginas
completo
des-
pués
emite
llamada
hipervisor
indicarle
tabla
páginas
obtener
fallo
protección
actualización
tabla
páginas
llamada
hiper-
visor
actualizaciones
eficiente
cosas
www
FreeLibros.me8.3.6
Virtualización
analizamos
virtualización
CPU
memoria
paso
examinar
virtualización
S.
general
sistema
operativo
invitado
empezará
sondeo
hardware
averiguar
tipos
dispositivos
conectados
sondas
produci-
rán
interrupciones
hipervisor
hipervisor
método
reporte
vuelta
discos
impresoras
dispositivos
realmente
hardware
invitado
cargará
drivers
dispositivos
tratará
utilizarlos
dri-
vers
dispositivos
traten
operaciones
leerán
escribirán
registros
dispositivo
hardware
dispositivo
correspondiente
instrucciones
sensibles
atraparán
hipervisor
copiar
valores
necesarios
entran
salen
registros
hardware
necesario
problema
SO
invitado
piensa
posee
parti-
ción
disco
máquinas
virtuales
cientos
particiones
disco
solución
usual
hipervisor
cree
archivo
región
disco
disco
físico
máquina
virtual
SO
invitado
tratando
controlar
disco
hardware
real
tie-
ne
hipervisor
conoce
convertir
número
bloque
accediendo
desplazamiento
archivo
región
utilizando
almacenamiento
pue-
operación
S.
disco
utiliza
invitado
disco
real
ejem-
plo
disco
actual
disco
alto
rendimiento
RAID
interfaz
hi-
pervisor
anunciar
SO
invitado
simple
disco
IDE
antiguo
permitirle
instale
driver
disco
IDE
driver
emite
comandos
disco
IDE
hipervisor
convierte
comandos
controlar
disco
estrategia
utilizar
ac-
tualizar
hardware
cambiar
software
habilidad
máquinas
virtuales
reasignar
dispositivos
hardware
razones
VM/370
popular
empresas
querían
comprar
hardware
veloz
querían
cambiar
software
gracias
tecnología
máquinas
virtuales
problema
resolver
DMA
utiliza
di-
recciones
memoria
absolutas
esperarse
hipervisor
intervenir
reasignar
direcciones
inicie
DMA
empezando
aparecer
hardware
MMU
virtualiza
forma
MMU
virtuali-
za
memoria
hardware
elimina
problema
DMA
método
distinto
manejar
dedicar
máquinas
virtuales
eje-
cute
sistema
operativo
estándar
refleje
llamadas
máqui-
nas
virtuales
método
mejora
utiliza
paravirtualización
comando
emite
hipervisor
realidad
indica
SO
invitado
desea
ejemplo
leer
bloque
1403
disco
serie
comandos
escribir
registros
disposi-
tivo
cuyo
caso
hipervisor
jugar
Sherlock
Holmes
averiguar
tratando
Xen
utiliza
método
máquina
virtual
encarga
llama
dominio
virtualización
área
hipervisores
tipo
ventaja
práctica
hipervisores
tipo
sistema
operativo
anfitrión
contiene
drivers
dis-
578
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.3
VIRTUALIZACIÓN
579
positivos
extraños
maravillosos
dispositivos
conectados
computadora
programa
aplicación
intenta
acceder
dispositivo
extraño
código
traduci-
do
llamar
driver
dispositivo
existente
realice
trabajo
hipervisor
tipo
hipervisor
contener
driver
llamada
driver
dominio
similar
sistema
operativo
anfitrión
medida
madure
tecnología
máquinas
virtuales
probable
futuro
hardware
permita
programas
aplicación
ac-
cedan
hardware
directamente
segura
significa
drivers
disposi-
tivos
vincularse
directamente
código
aplicación
colocar
servidores
separados
usuario
eliminará
problema
8.3.7
Dispositivos
virtuales
máquinas
virtuales
ofrecen
interesante
solución
problema
tiem-
po
perturba
usuarios
especial
software
código
fuente
abierto
instalar
programas
aplicación
problema
aplicaciones
dependen
tantas
aplicaciones
bibliotecas
dependen
paquetes
software
sucesivo
dependencias
versiones
específicas
compilado-
res
lenguajes
secuencias
comandos
sistema
operativo
disponibles
máquinas
virtuales
desarrollador
software
cons-
truir
cuidado
máquina
virtual
cargarla
sistema
operativo
compiladores
bibliotecas
código
aplicación
requeridos
congelar
unidad
completa
lista
ejecutarse
ima-
gen
máquina
virtual
colocar
CD-ROM
sitio
Web
clientes
instalen
descarguen
método
implica
desarrollador
software
cono-
cer
dependencias
clientes
reciben
paquete
completo
funciona
importar
sistema
operativo
estén
ejecutando
software
paquetes
bibliotecas
tengan
instalados
máquinas
virtuales
empaquetadas
listas
usarse
conoce
común-
mente
dispositivos
virtuales
8.3.8
Máquinas
virtuales
CPUs
multinúcleo
combinación
máquinas
virtuales
CPUs
multinúcleo
abre
mundo
número
CPUs
disponibles
establecer
software
ejemplo
núcleos
utilizar
ejecutar
digamos
máquinas
virtuales
configurar
CPU
escritorio
multicomputadora
32
nodos
necesario
CPUs
dependiendo
necesidades
softwa-
re
diseñador
aplicaciones
seleccionara
CPUs
escribir
software
acorde
duda
representa
nue-
fase
computación
común
duda
concebible
máquinas
virtuales
pudieran
compartir
memoria
asignar
páginas
físicas
espacios
www.FreeLibros.medirecciones
máquinas
virtuales
computadora
convertir
multiprocesador
virtual
núcleos
chip
multinúcleo
comparten
RAM
chip
cuádruple
núcleo
configurar
fácilmente
mul-
tiprocesador
32
nodos
multicomputadora
32
nodos
necesario
combinación
multinúcleo
máquinas
virtuales
hipervisores
microkernels
cambiar
radical
forma
personas
piensan
sistemas
cómputo
software
actual
lidiar
idea
programador
determine
CPUs
necesitan
establecer
multicomputadora
multiprocesador
papel
desempeñan
kernels
mínimos
tipo
software
futuro
lidiar
cuestiones
8.3.9
Cuestiones
licencias
licencias
mayoría
software
CPU
palabras
com-
pra
programa
derecho
ejecutarlo
CPU
Acaso
contrato
otorga
derecho
ejecutar
software
máquinas
virtuales
ejecutan
mis-
ma
máquina
distribuidores
software
inseguros
problema
empresas
licencia
permite
má-
quinas
ejecutando
software
tiempo
especial
aumenta
disminuye
deman-
máquinas
virtuales
casos
distribuidores
software
colocado
cláusula
explícita
li-
cencia
prohíbe
concesionario
ejecutar
software
máquina
virtual
máquina
virtual
autorizada
verse
restricciones
válida
cor-
usuarios
responderán
8.4
SISTEMAS
DISTRIBUIDOS
completado
estudio
multiprocesadores
multicomputadoras
máquinas
virtuales
tiempo
analizar
tipo
sistema
múltiples
procesadores
sistema
distribuido
sistemas
similares
multicomputadoras
nodo
memoria
privada
memoria
física
compartida
sistema
sistemas
distribuidos
acoplamiento
débil
multicomputadoras
empezar
nodos
multicomputadora
comúnmente
CPU
RAM
in-
terfaz
red
disco
duro
paginación
contrario
nodo
sistema
distribuido
computadora
completa
complemento
periféricos
no-
multicomputadora
general
cuarto
co-
municar
red
dedicada
alta
velocidad
nodos
sistema
distribuido
esparcidos
mundo
nodos
compu-
tadora
ejecutan
sistema
operativo
comparten
sistema
archivos
administración
común
nodos
sistema
distribuido
ejecu-
tar
sistema
operativo
sistema
archivos
580
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
581
administración
ejemplo
típico
multicomputadora
512
nodos
cuarto
empresa
universidad
trabajando
modelado
farmacéutico
sistema
distribuido
típico
consiste
miles
máquinas
cooperan
libremente
Internet
figura
8-29
comparan
multiprocesadores
multicomputadoras
sistemas
distribuidos
puntos
mencionados
Elemento
Multiprocesador
Multicomputadora
Sistema
distribuido
Configuración
nodo
CPU
CPU
RAM
interfaz
Computadora
red
completa
Periféricos
nodo
compartidos
Compartidos
Conjunto
completo
disco
nodo
Ubicación
bastidor
cuarto
Posiblemente
nivel
mundial
Comunicación
nodos
RAM
compartida
Interconexión
dedicada
Red
tradicional
Sistemas
operativos
compartido
Posiblemente
distintos
Sistemas
archivos
compartido
compartido
nodo
Administración
organización
organización
organizaciones
evidente
multicomputadoras
encuentran
media
métrica
pregunta
interesante
multicomputadoras
parecidas
multiprocesadores
sistemas
distribuidos
parezca
mentira
respuesta
depende
pers-
pectiva
perspectiva
técnica
multiprocesadores
memoria
com-
partida
sistemas
diferencia
produce
distintos
modelos
programación
pensamientos
perspectiva
aplicaciones
multiprocesa-
dores
multicomputadoras
bastidores
equipo
cuarto
máquinas
sis-
temas
utilizan
resolver
problemas
requieren
cálculos
intensivos
sistema
distribuido
conecta
computadoras
Internet
general
involucrado
comunicación
computación
utiliza
distinta
grado
débilmente
acoplamiento
computadoras
sistema
distribuido
ventaja
desventaja
ventaja
computadoras
utilizar
variedad
aplicaciones
desventaja
difícil
pro-
gramar
aplicaciones
modelo
subyacente
común
aplicaciones
comunes
Internet
incluyen
acceso
computadoras
remotas
telnet
ssh
rlogin
acceso
información
remota
World
Wide
Web
FTP
Protocolo
Transferencia
Archivos
comunicación
persona
persona
correo
electrónico
programas
chat
aplicaciones
emergentes
ejemplo
comercio
elec-
trónico
telemedicina
aprendizaje
distancia
problema
aplicaciones
Figura
8-29
Comparación
tipos
sistemas
múltiples
CPUs
www.FreeLibros.mees
reinventar
rueda
ejemplo
correo
electrónico
FTP
World
Wi-
Web
fundamentalmente
desplazan
archivos
punto
punto
aplicación
convenciones
nomenclatura
protocolos
trans-
ferencia
técnicas
duplicación
navegadores
Web
ocultan
usuario
promedio
diferencias
mecanismos
subyacentes
completamente
distintos
Ocultarlos
nivel
interfaz
usuario
persona
sitio
Web
agencia
viajes
servicio
completo
ordene
viaje
York
San
Francisco
averiguar
compró
boleto
avión
tren
autobús
agregan
sistemas
distribuidos
red
subyacente
paradigma
modelo
co-
mún
ofrece
uniforme
sistema
intención
sistema
distribuido
convertir
grupo
máquinas
conexión
débil
sistema
coherente
base
concepto
paradigma
simple
elaborado
idea
proveer
unifique
sistema
UNIX
encontrar
ejemplo
simple
paradigma
unificador
contexto
li-
geramente
distinto
dispositivos
crean
parezcan
archi-
vos
teclados
impresoras
líneas
serie
operen
forma
primitivas
facilita
proceso
lidiar
distintos
concepto
formas
sistema
distribuido
obtener
medida
uniformidad
frente
distintos
sistemas
operativos
hardware
subyacente
nivel
software
en-
cima
sistema
operativo
nivel
conocido
middleware
ilustra
figura
8-30
Es-
nivel
provee
estructuras
datos
operaciones
permiten
procesos
usuarios
máquinas
remotas
interoperar
consistente
582
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Pentium
Windows
Middleware
Middleware
Middleware
Middleware
Aplicación
Pentium
Linux
Aplicación
SPARC
Solaris
Aplicación
Mac
Aplicación
Macintosh
Base
común
aplicaciones
Red
Figura
8-30
Posicionamiento
middleware
sistema
distribuido
sentido
middleware
sistema
operativo
sistema
distribuido
ex-
plica
analizando
libro
sistemas
operativos
reali-
dad
sistema
operativo
realizaremos
análisis
detalle
tratamiento
extenso
sistemas
distribuidos
consulte
obra
Sistemas
distribuidos
Tanenbaum
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
583
Steen
2006
resto
capítulo
analizaremos
brevemente
hardware
utiliza
sistema
distribuido
red
computadoras
subyacente
software
co-
municación
protocolos
red
consideraremos
variedad
paradigmas
utilizan
sistemas
8.4.1
Hardware
red
sistemas
distribuidos
construyen
redes
computadoras
veremos
peque-
ña
introducción
tema
redes
clasifican
variedades
principales
LANs
Redes
área
local
cubren
edificio
campus
WANs
Redes
área
amplia
nivel
ciudad
país
nivel
mundial
tipo
LAN
importante
Ether-
net
examinaremos
ejemplo
LAN
Analizaremos
Internet
ejem-
plo
WAN
técnicamente
Internet
red
federación
miles
redes
separadas
fines
basta
considerarla
WAN
Ethernet
Ethernet
clásica
describe
Estándar
IEEE
802.3
consiste
cable
coaxial
conectan
computadoras
cable
conoce
Ethernet
relación
éter
lu-
miníferopor
pensaba
tiempo
propagaba
radiación
electromagnéti-
ca
físico
inglés
James
Clerk
Maxwell
siglo
diecinueve
descubrió
radiación
electromagnética
podía
describir
ecuación
onda
científicos
asumieron
espacio
debía
llenarse
etéreo
propagara
radiación
famoso
experimento
Michelson-Morley
1887
detec-
tar
éter
físicos
radiación
podía
propagar
vacío
versión
Ethernet
conectar
computadora
cable
literalmente
per-
foraba
agujero
mitad
cable
atornillaba
cable
iba
computadora
conocía
vampire
tap
punción
vampiro
muestra
simbólica
figu-
ra
8-31(a
difícil
punciones
utilizaban
conectores
largos
apropiados
relación
electricidad
computadoras
conectadas
cables
tarjetas
interfaz
red
estuvieran
soldados
enviar
paquete
red
Ethernet
computadora
escucha
cable
pa-
ra
computadora
esté
transmitiendo
momento
empieza
transmitir
paquete
consiste
encabezado
corto
seguido
carga
útil
1500
bytes
cable
computadora
espera
termine
transmisión
ac-
tual
empieza
enviar
paquete
computadoras
empiezan
transmitir
tiempo
produce
colisión
am-
bas
detectan
computadoras
responden
terminando
transmisiones
esperan
cantidad
aleatoria
tiempo
µseg
empiezan
ocurre
colisión
computadoras
participan
colisión
esperan
cantidad
aleatoria
tiempo
intervalo
µseg
intentan
colisión
subsiguiente
intervalo
www.FreeLibros.memáximo
espera
duplica
reduce
probabilidad
colisiones
Es-
algoritmo
conoce
backoff
exponencial
binario
secciones
anteriores
vimos
utiliza
algoritmo
reducir
sobrecarga
sondeo
bloqueos
red
Ethernet
longitud
máxima
cable
número
máximo
compu-
tadoras
conectar
exceder
cualquiera
límites
edificio
campus
gran-
cablear
redes
Ethernet
conectan
dispositivos
conocidos
puentes
bridges
puente
permite
tráfico
pase
red
Ethernet
origen
destino
evitar
problema
colisiones
redes
Ethernet
modernas
utilizan
switches
muestra
figura
8-31(b
switch
número
puertos
conectar
computadora
red
Ethernet
switch
paquete
evita
éxito
to-
das
colisiones
llega
switch
coloca
búfer
envía
puerto
vive
má-
quina
destino
computadora
puerto
eliminar
colisiones
expensas
requerir
switches
posibles
compromisos
computadoras
puerto
figura
8-31(b
red
Ethernet
clásica
computadoras
conectadas
cable
punciones
vampiro
conectada
puertos
switch
Internet
Internet
evolucionó
ARPANET
red
conmutación
paquetes
experimental
fundada
Agencia
Proyectos
Avanzados
Investigación
Departamento
Defensa
EE.UU.
puso
operación
diciembre
1969
computadoras
California
Utah
diseñó
Guerra
Fría
red
alta
tolerancia
fallas
con-
tinuara
transmitiendo
tráfico
militar
inclusive
caso
red
sufriera
golpes
nucleares
directos
partes
re-enrutamiento
automático
tráfico
má-
quinas
inutilizadas
584
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Computadora
Ethernet
Interruptor
Computadora
Ethernet
b)(a
Vampire
tap
punción
vampiro
Figura
8-31
Ethernet
clásica
Ethernet
conmutada
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
585
ARPANET
creció
rapidez
década
1970
cientos
computadoras
conectaron
red
radiopaquetes
red
satelital
finalmente
miles
redes
Ethernet
surgió
federación
redes
conocemos
Internet
Internet
consiste
tipos
computadoras
hosts
enrutadores
hosts
PCs
note-
books
dispositivos
bolsillo
servidores
mainframes
computadoras
poseen
individuos
empresas
desean
conectar
Internet
enrutadores
computadoras
conmutación
especializadas
aceptan
paquetes
entrantes
líneas
entrantes
envían
líneas
salientes
enrutador
similar
interruptor
figura
8-31(b
pe-
ro
diferencias
incumbencia
momento
enru-
tadores
conectan
redes
enrutador
cables
fibras
enrutadores
hosts
compañías
telefónicas
ISPs
Proveedores
Servicio
Internet
operan
extensas
redes
enrutadores
nacionales
mundiales
clientes
figura
8-32
muestra
porción
Internet
superior
backbones
controlado
comúnmente
operador
backbone
Consiste
número
enru-
tadores
conectados
fibra
óptica
alta
capacidad
ancho
banda
conexiones
backbones
operados
compañías
telefónicas
competidoras
general
host
conecta
directamente
backbone
excepción
máquinas
mantenimiento
prueba
opera
compañía
telefónica
Backbone
Fibra
óptica
alta
capacidad
ancho
banda
Enrutador
ISP
Línea
ADSL
PC
doméstica
PC
doméstica
Fibra
óptica
capacidad
media
ancho
banda
Enrutador
Host
Ethernet
Fibra
óptica
cable
cobre
Enrutador
local
Red
regional
Figura
8-32
porción
Internet
redes
regionales
enrutadores
ISPs
conectan
enrutadores
backbone
fibra
óptica
velocidad
media
redes
Ethernet
corporativas
con-
www.FreeLibros.metiene
enrutador
enrutadores
conectan
enrutadores
redes
regionales
enrutadores
ISPs
conectan
bancos
módems
utilizados
clientes
ISP
forma
host
Internet
ruta
rutas
ca-
hosts
tráfico
Internet
envía
forma
paquetes
paquete
interior
dirección
destino
dirección
utiliza
enrutamiento
llega
pa-
quete
enrutador
extrae
dirección
destino
busca
tabla
línea
saliente
enviar
paquete
ende
enrutador
procedimiento
repite
paquete
llega
host
destino
tablas
enrutamiento
dinámi-
cas
actualizan
forma
continua
enrutadores
enlaces
interrumpen
reanudan
conexión
medida
cambian
condiciones
tráfico
8.4.2
Protocolos
servicios
red
redes
computadoras
ofrecen
servicios
usuarios
hosts
procesos
im-
plementan
reglas
intercambios
mensajes
legales
continua-
ción
veremos
introducción
temas
Servicios
red
redes
computadoras
proveen
servicios
hosts
procesos
utilizan
servicio
orientado
conexión
modela
base
sistema
telefónico
hablar
alguien
toma
teléfono
marca
número
cuelga
similar
utiliza
ser-
vicio
red
orientado
conexión
usuario
servicio
establece
conexión
utili-
za
libera
aspecto
esencial
conexión
actúa
tubo
emisor
mete
objetos
bits
extremo
receptor
saca
orden
extremo
contrario
servicio
orientado
conexión
modela
base
sistema
postal
mensaje
carta
dirección
destino
completa
enruta
sistema
ma-
nera
independiente
mensajes
general
envían
mensajes
destino
envíe
llegar
obstante
envíe
retraso
llegue
servicio
orientado
conexión
imposible
servicio
caracterizar
base
calidad
servicio
servicios
confiables
pierden
datos
general
implementar
servicio
con-
fiable
receptor
confirmar
recepción
mensaje
envía
vuelta
pa-
quete
reconocimiento
especial
emisor
esté
seguro
mensaje
proceso
reconocimiento
introduce
sobrecarga
retrasos
necesarios
detec-
tar
pérdida
paquetes
disminuyen
velocidad
operación
situación
común
apropiado
servicio
orientado
conexión
confiable
transferencia
archivo
propietario
archivo
desea
seguro
bits
lleguen
forma
correcta
orden
enviaron
clientes
transferencias
586
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
587
archivos
preferirían
servicio
ocasiones
revolviera
perdiera
bits
rápido
servicio
orientado
conexión
confiable
variantes
menores
secuencias
mensa-
jes
flujos
bytes
variante
preservan
límites
mensajes
en-
vían
mensajes
KB
llegan
mensajes
distintos
KB
mensaje
KB
variante
conexión
simplemente
flujo
bytes
límites
mensajes
llegan
bytes
receptor
forma
enviaron
mensaje
KB
mensajes
KB
2048
mensajes
byte
en-
vían
páginas
libro
red
compositor
imagen
mensajes
separa-
importante
preservar
límites
mensajes
terminal
conecta
sistema
remoto
tiempo
compartido
necesita
flujo
bytes
terminal
computadora
aplicaciones
retrasos
introducen
reconocimientos
ina-
ceptables
aplicaciones
tráfico
voz
preferible
usuarios
teléfonos
escuchen
ruido
línea
palabra
confusa
introducir
retraso
esperar
reconocimientos
aplicaciones
requieren
conexiones
ejemplo
evaluar
red
necesita
enviar
paquete
alta
probabilidad
llegar
garantía
servicio
conexión
confiable
significa
reconocimientos
conoce
servicio
datagramas
similitud
servicio
telegramas
envía
señal
reconocimiento
vuelta
emisor
situaciones
conveniente
establecer
conexión
enviar
men-
saje
corto
confiabilidad
esencial
aplicaciones
proporcionar
servi-
cio
datagramas
reconocimiento
enviar
carta
registrada
solicitar
acuse
recibo
acuse
recibo
regrese
emisor
absolutamente
seguro
carta
entregó
interesada
perdió
camino
servicios
servicio
solicitud-respuesta
servicio
emisor
transmi-
datagrama
contiene
solicitud
petición
contiene
respuesta
ejemplo
categoría
entra
consulta
biblioteca
local
idioma
Uigur
servicio
solicitud-respuesta
utiliza
comúnmente
implementar
comunicación
modelo
cliente-servidor
cliente
emite
solicitud
servidor
responde
figu-
ra
8-33
sintetizan
tipos
servicios
descritos
Protocolos
red
redes
reglas
especializadas
establecer
mensajes
enviar
respuestas
devolver
relación
mensajes
ejemplo
cir-
cunstancias
transferencia
archivo
mensaje
envía
origen
destino
requiere
destino
envíe
reconocimiento
vuelta
indicar
recibió
mensaje
correctamente
circunstancias
telefonía
digital
espera
re-
conocimiento
conjunto
reglas
comunican
computadoras
específicas
co-
noce
protocolo
protocolos
incluyendo
enrutador
enrutador
www
FreeLibros.me588
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Servicio
Flujo
mensajes
confiable
Flujo
bytes
confiable
Conexión
confiable
Datagrama
confiable
Datagrama
reconocido
Solicitud-respuesta
Ejemplo
Secuencia
páginas
libro
Inicio
sesión
remoto
Voz
digitalizada
Paquetes
prueba
red
Correo
registrado
Consulta
base
datos
Orientado
conexión
Orientado
conexión
Figura
8-33
tipos
distintos
servicio
red
host
host
tratamiento
detallado
redes
computadoras
proto-
colos
consulte
obra
Computer
Networks
Tanenbaum
2003
redes
modernas
utilizan
pila
protocolos
distribuir
distintos
protoco-
niveles
nivel
lidia
distintas
cuestiones
ejemplo
nivel
inferior
protocolos
definen
forma
empieza
termina
paquete
flujo
bits
nivel
alto
protocolos
definen
enrutar
paquetes
redes
complejas
origen
destino
nivel
alto
aseguran
paquetes
mensaje
compuesto
paquetes
hayan
llegado
forma
correcta
orden
apropiado
mayoría
sistemas
distribuidos
utilizan
Internet
base
protocolos
base
utilizan
sistemas
protocolos
principales
Internet
IP
TCP
IP
Protocolo
Internet
protocolo
datagramas
emisor
inyecta
datagrama
64
KB
red
espera
llegue
garantías
datagrama
fragmentar
pa-
quetes
pequeños
medida
pasa
Internet
paquetes
viajan
independien-
distintas
rutas
piezas
llegan
destino
ensamblan
orden
correcto
entregan
actualidad
utilizan
versiones
IP
v4
v6
analizar
versión
v4
domina
mercado
v6
ganando
terreno
paquete
v4
empieza
enca-
bezado
40
bytes
contiene
dirección
origen
32
bits
dirección
destino
32
bits
campos
conoce
direcciones
IP
forman
base
enru-
tamiento
Internet
convención
escriben
números
decimales
rango
255
separados
puntos
192.31.231.65
paquete
llega
enrutador
és-
extrae
dirección
IP
destino
utiliza
enrutar
paquete
datagramas
IP
utilizan
señales
reconocimiento
suficiente
protocolo
IP
comunicación
confiable
Internet
proveer
comunicación
confiable
ge-
neral
utiliza
protocolo
conocido
TCP
Protocolo
control
transmisión
coloca
nivel
IP
TCP
utiliza
IP
proveer
flujos
orientados
conexión
utilizar
TCP
proceso
establece
conexión
proceso
remoto
proceso
requeri-
do
especifica
dirección
IP
máquina
número
puerto
máquina
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
589
escuchan
procesos
interesados
recibir
conexiones
entrantes
rea-
lizado
inyectan
bytes
conexión
garantiza
saldrán
extremo
daños
orden
correcto
lograr
garantía
implementación
TCP
utiliza
números
secuencia
sumas
comprobación
retransmisiones
paquetes
reciben
forma
incorrecta
transparente
procesos
emisor
receptor
ven
comu-
nicación
confiable
procesos
justo
canalización
UNIX
interactúan
protocolos
considere
caso
simple
mensaje
pequeño
necesita
fragmentar
nivel
host
red
Ether-
net
conectada
Internet
ocurre
exactitud
proceso
usuario
genera
mensaje
rea-
liza
llamada
sistema
enviarlo
conexión
TCP
establecido
antemano
pila
protocolos
kernel
agrega
encabezado
TCP
encabezado
IP
frontal
pasa
driver
Ethernet
agrega
encabezado
Ethernet
di-
rigir
paquete
enrutador
Ethernet
enrutador
inyecta
paquete
Internet
co-
mo
ilustra
figura
8-34
Internet
Encabezado
Ethernet
Encabezados
Enrutador
Mensaje
Host
Ethernet
TCP
MensajeIP
Figura
8-34
Acumulación
encabezados
paquetes
establecer
conexión
host
remoto
enviarle
datagrama
necesario
dirección
IP
inconveniente
personas
administrar
listas
direcciones
IP
32
bits
inventó
esquema
llamado
DNS
Sistema
nombres
domi-
nio
base
datos
asignar
nombres
ASCII
hosts
direcciones
IP
ende
utilizar
nombre
DNS
star.cs.vu.nl
correspondiente
dirección
IP
130.37.24.6
nombres
DNS
conocidos
direcciones
correo
elec-
trónico
Internet
forma
nombre-usuario@nombre-host-DNS
sistema
nomen-
clatura
permite
programa
correo
host
emisor
busque
dirección
IP
host
destino
base
datos
DNS
establezca
conexión
TCP
proceso
demonio
co-
rreo
envíe
mensaje
archivo
nombre-usuario
envía
identificar
bandeja
correo
colocar
mensaje
www
FreeLibros.me8.4.3
Middleware
basado
documentos
antecedentes
redes
protocolos
empezar
ana-
lizar
distintos
niveles
middleware
superponer
red
básica
producir
paradigma
constante
aplicaciones
usuarios
Empezaremos
ejemplo
simple
conocido
World
Wide
Web
Tim
Berners-Lee
inventó
servicio
Web
1989
CERN
Centro
Europeo
Investigación
Física
Nuclear
esparcido
fue-
go
arrasador
mundo
paradigma
original
Web
simple
computadora
podía
contener
documentos
llamados
páginas
Web
página
Web
contiene
texto
imágenes
iconos
so-
nidos
películas
hipervínculos
apuntadores
páginas
Web
usuario
solicita
página
Web
programa
llamado
navegador
Web
pági-
na
muestra
pantalla
clic
vínculo
página
actual
sustituye
panta-
lla
página
apunta
vínculo
años
recientes
agregado
complementos
Web
evidente
paradigma
subyacente
presente
Web
grafo
dirigido
documentos
apuntar
documentos
muestra
figu-
ra
8-35
590
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
University
of
North
South
School
of
Humanities
School
of
Sciences
School
of
Social
Sciences
Northern
University
Geography
History
Languages
Main
page
Geography
Dept
Big
countries
Small
countries
Rich
countries
Poor
countries
Humanities
History
Dept
Ancient
times
Medieval
times
Modern
times
Future
times
Humanities
Languages
Dept
English
French
Dutch
Frisian
Spanish
Humanities
Science
Astronomy
Biology
Chemistry
Physics
Main
page
Social
sciences
Anthropology
Psychology
Sociology
Main
page
Astronomy
Dept
Galaxies
Nebulas
Planets
Quasars
Stars
Sciences
Biology
Dept
Arachnids
Mammals
Protozoa
Worms
Sciences
Chemistry
Dept
Acids
Bases
Esters
Proteins
Sciences
Physics
Dept
Electrons
Mesons
Neutrons
Neutrinos
Protons
Sciences
Anthropology
Dept
African
tribes
Australian
tribes
New
Guinean
tribes
Social
sciences
Psychology
Dept
Freud
Rats
Social
sciences
Sociology
Dept
Class
struggle
Gender
struggle
Generic
struggle
Social
sciences
Figura
8-35
Web
grafo
dirigido
documentos
página
Web
dirección
única
conocida
URL
Uniform
Resource
Lovator
Localizador
uniforme
recursos
forma
protocolo://nombre-DNS
nombre-archivo
pro-
tocolo
común
http
Protocolo
transferencia
hipertexto
protocolos
ftp
utiliza
nombre
DNS
host
contiene
archivo
últi-
mo
nombre
archivo
local
indica
archivo
necesita
continuación
veremos
forma
funciona
sistema
completo
esencia
Web
sistema
cliente-servidor
usuario
cliente
sitio
Web
servidor
usuario
proporciona
URL
navegador
escribiéndolo
clic
hipervínculo
página
actual
navegador
realiza
pasos
obtener
página
Web
solicitada
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
591
ejemplo
simple
suponga
URL
proporciona
http://www.minix3.org/doc/faq.html
navegador
realiza
siguientes
pasos
obtener
página
navegador
pide
DNS
dirección
IP
www.minix3.org
DNS
responde
130.37.20.20
navegador
realiza
conexión
TCP
puerto
80
130.37.20.20
envía
petición
archivo
doc
faq.html
servidor
www.acm.org
envía
archivo
doc
faq.html
libera
conexión
TCP
navegador
muestra
texto
doc
faq.html
navegador
obtiene
muestra
imágenes
doc
faq.html
principio
base
Web
forma
funciona
agre-
gado
características
Web
básico
incluyendo
hojas
estilo
cascada
páginas
Web
dinámicas
generan
instante
páginas
Web
contienen
pequeños
programas
se-
cuencias
comandos
ejecutan
máquina
cliente
queda
alcance
análisis
8.4.4
Middleware
basado
sistemas
archivos
idea
básica
Web
sistema
distribuido
apariencia
co-
lección
gigante
documentos
hipervinculados
método
sistema
dis-
tribuido
apariencia
sistema
archivos
sección
analizaremos
cuestiones
involucradas
diseño
sistema
archivos
nivel
mundial
Utilizar
modelo
sistema
archivos
sistema
distribuido
significa
sistema
archivos
global
usuarios
mundo
autorización
leer
escribir
archivos
lograr
comunicación
proceso
escribir
datos
archivo
procesos
leer
datos
vuelta
surgen
problemas
estándar
sistemas
archivos
aparecen
problemas
relacionados
distribución
Modelo
transferencia
cuestión
elección
modelo
envío
descarga
modelo
acceso
remo-
to
modelo
muestra
figura
8-36(a
proceso
utilizar
archivo
copiarlo
servidor
remoto
archivo
leer
lee
local
obtener
alto
rendimiento
archivo
escribir
escribe
local
proceso
termina
archivo
coloca
archivo
actuali-
zado
vuelta
servidor
modelo
acceso
remoto
archivo
permanece
servidor
cliente
envía
comandos
trabajo
muestra
figura
8-36(b
www
FreeLibros.meLas
ventajas
modelo
envío
descarga
simplicidad
efi-
ciente
transferir
datos
archivos
transferirlos
piezas
pequeñas
des-
ventajas
suficiente
espacio
almacenamiento
archivo
forma
local
desplazar
archivo
completo
desperdicio
necesitan
piezas
surgen
problemas
consistencia
usuarios
concurrentes
jerarquía
directorios
archivos
historia
sistema
directorios
sis-
temas
archivos
distribuidos
aceptan
directorios
contienen
archivos
problema
diseño
clientes
vista
jerarquía
directorios
ejemplo
considere
figura
8-37
figura
8-37(a
mostramos
servidores
archivos
contiene
directorios
archivos
figura
8-37(b
sistema
clientes
máquinas
mis-
ma
vista
sistema
archivos
distribuido
ruta
/D
válida
máquina
váli-
contraste
figura
8-37(c
distintas
máquinas
distintas
vistas
sistema
archivos
repetir
ejemplo
ruta
/D
válida
cliente
cliente
sistemas
administran
sistemas
archivos
montaje
remoto
figura
8-37(c
norma
flexible
simple
implementar
desventaja
sistema
comporte
sistema
individual
tiempo
compartido
antigua
sistema
tiempo
compartido
procesos
ven
sis-
tema
archivos
modelo
figura
8-37(b
propiedad
facilita
programación
comprensión
sistema
pregunta
relacionada
directorio
raíz
global
má-
quinas
reconozcan
directorio
raíz
directorio
raíz
global
raíz
contenga
entrada
servidor
circunstancias
rutas
toman
forma
/servidor
ruta
desventajas
sistema
592
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
accesos
realizan
cliente
cliente
termina
devuelve
archivo
servidor
Archivo
Archivo
antiguoServidor
ServidorClienteCliente
cliente
obtiene
archivo
archivo
permanece
servidor
Respuesta
Petición
Figura
8-36
modelo
envío
descarga
modelo
acceso
remoto
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
593
Transparencia
nomenclatura
principal
problema
forma
nomenclatura
totalmente
transparente
formas
transparencia
relevantes
contexto
vale
pena
distinguir
conocida
transparencia
localización
nombre
ruta
pista
ubi-
cación
archivo
ruta
/servidor1
dir1
dir2
indica
archivo
ubicado
servidor
indica
servidor
servidor
mover
cual-
quier
red
cambiar
nombre
ruta
ende
sistema
trans-
parencia
ubicación
suponga
archivo
espacio
restringido
servidor
suponga
espacio
servidor
sistema
mover
archivo
Raíz
BC
Servidor
archivos
Cliente
EF
Raíz
BC
Cliente
EF
Raíz
BC
Servidor
archivos
Cliente
EF
Raíz
BC
Cliente
Figura
8-37
servidores
archivos
cuadros
directorios
círculos
archivos
sistema
clientes
vista
sis-
tema
archivos
sistema
distintos
clientes
distintas
vis-
tas
sistema
archivos
www.FreeLibros.meservidor
automática
desgracia
componente
nom-
bres
ruta
servidor
sistema
mover
archivo
servidor
auto-
mática
dir1
dir2
servidores
problema
mover
archivo
automática
cambia
nombre
ruta
/servidor1
dir1
dir2
/servidor2
dir1
dir2
x.
programas
contienen
cadena
dejarán
funcionar
cambia
ruta
sistema
mover
archivos
cambiar
nombres
independencia
ubica-
ción
sistema
distribuido
incrusta
nombres
máquinas
servidores
nombres
rutas
definitiva
independiente
ubicación
sistema
basado
montaje
remoto
mover
archivo
grupo
archivos
unidad
monta-
je
seguir
utilizando
nombre
ruta
fácil
lograr
independencia
ubicación
propiedad
conveniente
sistema
distribuido
resumir
dijimos
métodos
comunes
nombrar
archivos
directo-
rios
sistema
distribuido
nomenclatura
máquina
ruta
/máquina
ruta
máquina
ruta
Montar
sistemas
archivos
remotos
jerarquía
archivos
local
espacio
nombres
máquinas
métodos
fáciles
implementar
especial
forma
conectar
sistemas
existentes
diseñados
distribuido
tercer
método
difícil
requiere
diseño
cuidadoso
facilita
vida
programadores
usuarios
Semántica
compartición
archivos
usuarios
comparten
archivo
necesario
definir
semántica
leer
escribir
precisión
evitar
problemas
sistemas
procesador
semánti-
ca
general
establece
llamada
sistema
readva
llamada
sistema
write
llamada
readdevuelve
valor
acaba
escribir
muestra
figura
8-38(a
similar
realizan
llamadas
writeen
sucesión
rápida
se-
guidas
llamada
read
valor
leído
valor
almacenado
escritura
efec-
to
sistema
implementa
orden
llamadas
sistema
procesadores
ven
orden
modelo
llamaremos
consistencia
secuencial
sistema
distribuido
consistencia
secuencial
obtener
fácilmente
ha-
servidor
archivos
clientes
coloquen
archivos
caché
llamadas
ready
writevan
directamente
servidor
archivos
procesa
estrictamente
forma
se-
cuencial
práctica
rendimiento
sistema
distribuido
peti-
ciones
archivos
enviarse
servidor
frecuencia
pobre
pro-
blema
resuelve
permitir
clientes
mantengan
copias
locales
archivos
frecuente
cachés
privadas
obstante
cliente
modifica
local
archivo
caché
tiempo
cliente
lee
archivo
servidor
cliente
obtendrá
archi-
vo
obsoleto
ilustra
figura
8-38(b
594
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
595
solucionar
dificultad
propagar
cambios
archivos
ca-
ché
vuelta
servidor
inmediata
método
simple
concepto
ine-
ficiente
solución
alternativa
relajar
semántica
compartición
archivos
requerir
llamada
readpara
efectos
llamadas
anteriores
write
regla
establezca
cambios
archivo
abierto
visibles
principio
proceso
cierre
archivo
vi-
sibles
cambios
procesos
adopción
dicha
regla
cambia
ocurre
figura
8-38(b
redefine
comportamiento
actual
recibe
valor
original
archi-
vo
correcto
cliente
cierra
archivo
envía
copia
vuelta
servidor
pa-
ra
llamadas
subsiguientes
readobtengan
valor
requiere
efecto
modelo
envío
descarga
figura
8-36
regla
semántica
implementa
ampliamen-
conoce
semántica
sesión
utilizar
semántica
sesión
surge
cuestión
ocurre
clientes
usando
caché
modificando
archivo
solución
medida
cerrando
archivo
valor
envíe
vuelta
servidor
resultado
dependerá
procesador
Archivo
original
Escribe
leer
obtiene
abc
Cliente
lee
ab”2
Escribe
Servidor
archivos
leer
obtiene
ab
Cliente
bB
Figura
8-38
Consistencia
secuencial
sistema
distribuido
caché
leer
archivo
obtener
valor
obsoleto
www.FreeLibros.mede
archivo
cierre
alternativa
placentera
fácil
imple-
mentar
resultado
candidatos
dejar
especificar
opción
archivo
elegir
método
alternativo
semántica
sesión
utilizar
modelo
envío
descarga
bloquear
automática
archivo
descargado
clientes
intenten
descargar
archivo
quedarán
espera
cliente
regresado
demanda
archivo
servidor
enviar
mensajes
cliente
contiene
archi-
vo
pedirle
apure
ayude
general
difícil
obtener
se-
mántica
correcta
archivos
compartidos
soluciones
elegantes
eficientes
8.4.5
Middleware
basado
objetos
analizar
tercer
paradigma
documento
to-
do
archivo
decimos
objeto
objeto
colección
variables
incluyen
conjunto
procedimientos
acceso
llamados
métodos
permite
procesos
accedan
directamente
variables
invocar
métodos
lenguajes
programación
H11001
H11001y
Java
orientados
objetos
objetos
nivel
lenguaje
objetos
tiempo
ejecución
sistema
conocido
basa
objetos
tiempo
ejecución
CORBA(Common
Object
Request
Broker
Architechture
Ar-
quitectura
común
intermediarios
peticiones
objetos
Vinoski
1997
CORBA
sistema
cliente-servidor
procesos
cliente
máquinas
cliente
invocar
operaciones
ob-
jetos
ubicados
máquinas
servidores
posiblemente
remotos
CORBA
diseñó
sistema
he-
terogéneo
ejecuta
variedad
plataformas
hardware
sistema
operativos
programado
variedad
lenguajes
cliente
plataforma
invo
servi-
dor
plataforma
distinta
interponen
ORBs
Object
Request
Broker(Intermediarios
peticio-
nes
objetos
cliente
servidor
permitir
coincidan
ORBs
desempeñan
papel
importante
CORBA
incluyen
nombre
sistema
objeto
CORBA
define
definición
interfaz
lenguaje
conocido
co-
mo
IDL
Interfaz
Definition
Language
Lenguaje
definición
interfaz
indica
mé-
exportar
objeto
tipos
parámetros
espera
método
especificación
IDL
compilar
procedimiento
resguardo
cliente
almacenar
biblioteca
proceso
cliente
antemano
necesitará
acceder
objeto
vincu-
código
resguardo
cliente
objeto
especificación
IDL
compilar
procedimiento
esqueleto
utiliza
servidor
proceso
antema-
objetos
CORBA
necesitar
invocación
dinámica
funcio-
namiento
allá
alcance
libro
crea
objeto
CORBA
crea
referencia
objeto
devuelve
proceso
creó
referencia
forma
proceso
identifica
objeto
subsiguientes
invocaciones
métodos
referencia
pasar
procesos
pue-
almacenar
directorio
objetos
proceso
cliente
invocar
método
objeto
adquirir
referencia
objeto
referencia
provenir
directamente
proceso
creó
596
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
597
probable
busque
nombre
función
tipo
directorio
es-
tá
disponible
referencia
objeto
proceso
cliente
organiza
parámetros
llamadas
métodos
estructura
conveniente
pone
contacto
ORB
cliente
ORB
cliente
envía
mensaje
ORB
servidor
invoca
método
objeto
mecanismo
similar
RPC
función
ORBs
ocultar
código
cliente
servidor
detalles
distribu-
ción
comunicación
nivel
especial
ORBs
ocultan
cliente
ubicación
servi-
dor
programa
binario
secuencia
comandos
hardware
sistema
operativo
ejecuta
servidor
objeto
activo
momento
comunican
ORBs
ejemplo
TCP
IP
RPC
memoria
compartida
etcétera
versión
CORBA
especificaba
protocolo
ORB
cliente
ORB
servidor
resultado
distribuidor
ORBs
utilizaba
protocolo
distinto
ORBs
distribuidor
podían
comunicar
distribuidores
versión
2.0
especificó
protocolo
comunicarse
Internet
protocolo
llama
IIOP
Internet
InterOrb
Protocol
Protocolo
InterOrb
Internet
utilizar
sistemas
CORBA
objetos
hayan
escrito
COR-
BA
objeto
equipar
adaptador
objeto
envoltura
maneja
tareas
registro
objeto
generación
referencias
objeto
activación
invoca
esté
activo
distribución
partes
CORBA
muestra
fi-
gura
8-39
Cliente
Resguardo
cliente
Sistema
operativo
ORB
cliente
Código
cliente
Adaptador
objeto
Sistema
operativo
Código
servidor
ServidorEsqueleto
Protocolo
IIOP
Red
ORB
servidor
Figura
8-39
principales
elementos
sistema
distribuido
basado
CORBA
partes
CORBA
muestran
color
gris
problema
grave
CORBA
objeto
servidor
significa
rendimiento
terrible
objetos
utilizan
frecuencia
máquinas
cliente
mundo
práctica
CORBA
funciona
aceptable
sistemas
pequeña
escala
utilizan
conectar
procesos
compu-
tadora
LAN
empresa
www
FreeLibros.me8.4.6
Middleware
basado
coordinación
paradigma
sistema
distribuido
llama
middleware
basado
coordina-
ción
Empezaremos
sistema
Linda
proyecto
académico
investigación
inició
campo
analizaremos
ejemplos
comerciales
inspiraron
sistema
Linda
publicar
suscribir
Jini
Linda
David
Gelernter
estudiante
Nick
Carriero
Carriero
Gelernter
1986
Carriero
Gelernter
1989
Gelernter
1985
desarrollaron
Universidad
Yale
sistema
Linda
sis-
tema
novel
comunicación
sincronización
Linda
procesos
independientes
comuni-
can
espacio
tuplas
abstracto
espacio
tuplas
global
sistema
procesos
máquina
insertar
quitar
tuplas
espacio
tuplas
impor-
tar
estén
almacenadas
usuario
espacio
tuplas
memoria
com-
partida
global
visto
formas
anteriores
figura
8-21(c
tupla
estructura
Java
Consiste
campos
valor
tipo
soportado
lenguaje
base
implementar
Linda
agre-
ga
biblioteca
lenguaje
existente
C-Linda
tipos
campos
enteros
enteros
largos
números
punto
flotante
tipos
compuestos
arreglos
in-
cluyendo
cadenas
estructuras
tuplas
diferencia
objetos
tuplas
só-
datos
métodos
asociados
figura
8-40
muestran
ejemplos
tuplas
abc”,2,5
matriz-1”,1
3.14
familia
es-hermana
Stephany
Roberta
Figura
8-40
tuplas
Linda
tuplas
operaciones
out
coloca
tupla
espacio
tuplas
ejemplo
out(“abc
2,5
coloca
tupla
abc
espacio
tuplas
general
campos
out
constan-
tes
variables
expresiones
out(“matriz-1
3.14
envía
tupla
campos
determinan
ba-
valores
actuales
variables
j.
obtener
tuplas
espacio
tuplas
utiliza
primitiva
in
tratan
contenido
nombre
dirección
campos
in
expresiones
parámetros
formales
ejemplo
considere
598
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
599
in(“abc
operación
busca
espacio
tuplas
tupla
consista
cadena
abc
entero
tercer
campo
contenga
entero
suponiendo
entero
tupla
elimina
espacio
tuplas
variable
asigna
valor
tercer
campo
operaciones
buscar
coincidencia
eliminarla
atómicas
procesos
ejecutan
operación
in
tiempo
éxito
tuplas
coincidan
Inclusive
espacio
tuplas
contener
copias
tupla
algoritmo
buscar
coincidencias
utiliza
in
simple
campos
primitiva
in
conocen
plantilla
comparan
concepto
campos
correspondientes
tuplas
espacio
tuplas
produce
coincidencia
cumplen
siguientes
condiciones
plantilla
tupla
número
campos
tipos
campos
correspondientes
iguales
constante
variable
plantilla
coincide
campo
tupla
parámetros
formales
indican
signo
interrogación
seguido
nombre
tipo
variable
participan
búsqueda
coincidencias
comprobación
tipos
parámetros
contienen
nombre
variable
asignan
coincidencia
exitosa
tupla
coincida
suspende
proceso
llamada
pro-
ceso
inserte
tupla
necesaria
momento
proceso
llamada
revive
automática
recibe
tupla
procesos
bloqueen
desbloqueen
ma-
nera
automática
significa
proceso
enviar
tupla
proceso
punto
recibirla
importa
ejecuta
única
diferencia
realiza
primitiva
in
primitiva
out
ligero
retraso
tupla
esté
disponible
removerla
usos
procesos
bloqueen
tupla
necesi-
presente
ejemplo
utilizar
implementar
semáforos
crear
reali-
zar
operación
upen
semáforo
proceso
ejecutar
out(“semaphore
operación
down
ejecuta
in(“semaphore
semáforo
determina
base
número
tuplas
semaphore
es-
pacio
tuplas
intento
obtener
tupla
bloqueará
proceso
suministre
out
in
Linda
primitiva
ead
in
qui-
ta
tupla
espacio
tuplas
primitiva
eval
parámetros
evalúen
paralelo
tupla
resultante
coloque
espacio
tuplas
utilizar
mecanismo
cálculo
arbitrario
forma
crean
procesos
pa-
ralelos
Linda
www
FreeLibros.mePublicar
suscribir
ejemplo
modelo
basado
coordinación
inspirado
Linda
co-
noce
publicar
suscribir
Oki
colaboradores
1993
Consiste
procesos
conecta-
red
transmisión
proceso
productor
información
consumidor
información
productor
información
pieza
información
ejemplo
precio
acciones
transmite
información
red
tupla
acción
conoce
publicar
tupla
contiene
línea
tema
jerárquica
contiene
campos
separados
puntos
procesos
interesados
información
sus-
cribir
temas
incluyen
comodines
línea
tema
suscripción
indicar
temas
buscar
proceso
demonio
tupla
máquina
monitorea
tuplas
publicadas
figura
8-41
ilustra
implementar
modelo
publicar
suscribir
Cuan-
do
proceso
tupla
desea
publicar
transmite
LAN
local
demonio
tu-
pla
máquina
copia
RAM
tuplas
transmitido
inspecciona
línea
tema
procesos
interesados
tupla
reenvía
copia
proceso
interesado
tuplas
transmitir
red
área
amplia
Internet
máquina
LAN
actúa
enrutador
infor-
mación
recolectando
tuplas
publicadas
reenviándolas
posteriormente
LANs
pa-
ra
vuelvan
transmitir
reenvío
inteligente
reenvía
tupla
LAN
remota
suscriptor
quiera
tupla
enrutadores
información
intercambiar
datos
suscriptores
600
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
Enrutador
información
DemonioConsumidor
LAN
Productor
WAN
Figura
8-41
arquitectura
modelo
publicar
suscribir
implementar
tipos
semántica
incluyendo
entrega
confiable
en-
trega
garantizada
exista
posibilidad
fallas
caso
necesario
alma-
cenar
tuplas
anteriores
caso
necesiten
posteriormente
almacenarlas
conectar
sistema
base
datos
sistema
suscriba
tuplas
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
601
envolver
sistema
base
datos
adaptador
permitir
base
datos
existente
funcione
modelo
publicar
suscribir
medida
lleguen
tuplas
adapta-
dor
capturará
colocará
base
datos
modelo
publicar
suscribir
desacopla
completo
productores
consumidores
forma
Linda
útil
adqui-
rir
información
publicar
tupla
realice
pregunta
básica
interesado
respuestas
llegan
forma
tuplas
interesado
Jini
50
años
computación
centrada
CPU
computadora
dispositivo
independiente
consiste
CPU
memoria
primaria
dispo-
sitivo
almacenamiento
masivo
disco
modelo
Jini
variación
palabra
ge-
nio
inglés
Sun
Microsystems
intento
cambiar
modelo
describir
centrado
red
Waldo
1999
mundo
Jini
consiste
número
dispositivos
Jini
auto-contenidos
ofrece
servicios
dispositivo
Jini
conectar
red
empezar
ofrecer
utilizar
servicios
instante
necesidad
procedimiento
ins-
talación
complejo
dispositivos
conectan
red
computadora
comúnmente
dispositivo
Jini
computadora
tradicio-
nal
impresora
computadora
bolsillo
teléfono
celular
televisión
estéreo
dispositivo
CPU
memoria
conexión
red
po-
siblemente
inalámbrica
sistema
Jini
federación
libre
dispositivos
Jini
operar
voluntad
administración
central
dispositivo
Jini
desea
unirse
federación
Jini
transmite
paquete
LAN
local
celda
inalámbrica
local
preguntando
servicio
búsqueda
presente
pro-
tocolo
utiliza
encontrar
servicio
búsqueda
protocolo
descubrimiento
protocolos
fijos
Jini
alternativa
dispositivo
Jini
espe-
rar
llegue
anuncios
periódicos
servicio
búsqueda
libro
analizaremos
mecanismo
servicio
búsqueda
detecta
dispositivo
registrar
respon-
pieza
código
registro
Jini
sistema
desarrollado
exclusivamente
Java
código
envía
JVM
lenguaje
máquina
virtual
Java
dispositivos
Jini
capaces
ejecutar
general
in-
térprete
dispositivo
ejecuta
código
contacta
servicio
búsque-
registra
periodo
fijo
dispositivo
volver
registrar
desea
justo
expire
tiempo
mecanismo
implica
dispositivo
Jini
salir
sistema
apagarse
olvidará
existencia
necesidad
admi-
nistración
central
concepto
registrarse
intervalo
fijo
conoce
adquirir
concesión
Observe
código
registrar
dispositivo
descarga
cambiar
medida
evolucione
sistema
afectar
hardware
software
dispositivo
www.FreeLibros.mehecho
dispositivo
siquiera
conoce
protocolo
registro
dispositivo
conoce
proceso
registro
consiste
proveer
atributos
código
proxy
dis-
positivos
utilizarán
acceder
dispositivo
dispositivo
usuario
busque
servicio
específico
preguntar
servicio
bús-
queda
conoce
petición
involucrar
atributos
utilizan
dispo-
sitivos
registrarse
petición
éxito
proxy
suministró
dispositivo
momento
registrarse
devuelve
dispositivo
petición
ejecuta
contactarse
dispositivo
dispositivo
usuario
hablar
dispositivo
necesidad
protocolo
utiliza
clientes
servicios
Jini
dispositivos
hardware
software
comunican
sincro-
nizan
JavaSpaces
modelan
espacio
tuplas
Linda
diferencias
importantes
JavaSpace
consiste
número
entradas
fuerte-
mente
tipificadas
entradas
tuplas
Linda
fuertemente
tipifica-
das
tuplas
Linda
tipo
entrada
consiste
número
campos
tipo
básico
Java
ejemplo
entrada
tipo
em-
pleado
consistir
cadena
nombre
persona
entero
depar-
tamento
entero
extensión
telefónica
valor
Booleano
trabaja
tiempo
completo
JavaSpace
definen
métodos
forma
variante
Write
coloca
entrada
JavaSpace
Read
copia
entrada
coincide
plantilla
saca
JavaSpace
Take
copia
elimina
entrada
coincide
plantilla
Notify
notifica
proceso
llamada
escribe
entrada
coincida
método
write
proporciona
entrada
especifica
tiempo
concesión
de-
be
descartar
contrario
tuplas
Linda
permanecen
quitan
JavaSpace
contener
entrada
conjunto
matemático
Linda
métodos
ead
take
proporcionan
plantilla
entrada
buscando
Ca-
campo
plantilla
contener
valor
específico
coincidir
contener
comodín
importa
coincida
valores
tipo
apropiado
coincidencia
devuelve
caso
take
elimina
JavaSpace
es-
tos
métodos
JavaSpace
variantes
difieren
caso
entrada
coin-
cida
variante
devuelve
indicación
falla
inmediato
espera
expirado
tiempo
límite
proporciona
parámetro
método
notify
registra
interés
plantilla
introduce
entrada
coincida
invoca
método
notify
proceso
llamada
602
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.4
SISTEMAS
DISTRIBUIDOS
603
diferencia
espacio
tuplas
Linda
JavaSpace
soporta
transacciones
atómicas
utilizar
transacciones
agrupar
métodos
ejecuten
ejecute
transacción
modificaciones
JavaSpace
visibles
transacción
procesos
llamada
cambios
has-
ta
termine
transacción
JavaSpace
utilizar
sincronizar
procesos
comunican
ejemplo
situación
productor-consumidor
productor
coloca
elementos
JavaSpace
medi-
produce
consumidor
quita
take
bloquea
elementos
disponibles
JavaSpace
garantiza
métodos
ejecute
forma
atómica
peligro
proceso
trate
leer
entrada
encuentre
mitad
8.4.7
Grids
Mallas
análisis
sistemas
distribuidos
estaría
completo
mencionar
desarro-
llo
reciente
importante
futuro
grids
grid
colección
máquinas
dispersas
geográficamente
general
heterogénea
conecta
red
privada
Internet
ofrece
conjunto
servicios
usuarios
com-
supercomputadora
virtual
colección
computadoras
in-
dependientes
general
dominios
administrativos
ejecutan
nivel
común
middleware
permitir
programas
usuarios
accedan
recursos
ma-
nera
conveniente
consistente
motivación
original
construir
grid
compartición
ciclos
CPU
idea
organización
necesita
cómputo
ejemplo
no-
che
organización
encuentre
zonas
horarias
distancia
reco-
lectar
ciclos
regresarle
favor
12
horas
investigadores
grids
interesados
compartir
recursos
específicamente
hardware
especia-
lizado
bases
datos
general
grids
funcionan
máquina
participante
ejecuta
conjunto
pro-
gramas
administran
máquina
integran
grid
software
comúnmente
encarga
autenticación
inicio
sesión
usuarios
remotos
anunciar
descubrir
recursos
programar
ubicar
trabajos
etcétera
usuario
trabajo
software
grid
determina
capacidad
inactiva
recursos
hardware
software
datos
trabajo
envía
trabajo
prepara
ejecución
devuel-
ve
resultados
usuario
middleware
popular
mundo
grids
Globus
Toolkit
disponible
plataformas
soporta
estándares
emergentes
grids
Foster
2005
Globus
pro-
vee
marco
trabajo
usuarios
compartan
computadoras
archivos
recursos
flexible
segura
sacrificar
autonomía
local
utiliza
base
cons-
truir
aplicaciones
distribuidas
www
FreeLibros.me8.5
INVESTIGACIÓN
SISTEMAS
MÚLTIPLES
PROCESADORES
capítulo
analizado
tipos
sistemas
múltiples
procesadores
multiproce-
sadores
multicomputadoras
máquinas
virtuales
sistemas
distribuidos
analizaremos
brevedad
investigación
realizada
áreas
investigación
multiprocesadores
relaciona
hardware
es-
pecial
forma
construir
memoria
compartida
mantenerla
coherente
ejemplo
Higham
colaboradores
2007
trabajos
multiprocesado-
res
especial
multiprocesadores
chip
incluyendo
modelos
programación
cuestio-
nes
sistema
operativo
multiprocesadores
chip
Fedorova
colaboradores
2005
colaboradores
2007
mecanismos
comunicación
Brisolara
colaboradores
2007
admi-
nistración
energía
software
Park
colaboradores
2007
seguridad
Yang
Peng
2006
futuros
retos
Wolf
2004
planificación
tema
po-
pular
Chen
colaboradores
2007
Lin
Rajaraman
2007
Rajagolapan
colaboradores
2007
Tam
colaboradores
2007
Yahav
colaboradores
2007
fácil
construir
multicomputadoras
multiprocesadores
nece-
sita
colección
PCs
estaciones
trabajo
red
alta
velocidad
razón
popular
tema
investigación
universidades
trabajo
relaciona
memoria
compartida
distribuida
forma
basa
páginas
basa
completo
software
Byung-Hyun
colaboradores
2004
Chapman
Heiser
2005
Huang
colaboradores
2001
Kontothanassis
colaboradores
2005
Nikolopoulos
colaborado-
res
2001
Zhang
colaboradores
2006
analizando
modelos
programa-
ción
Dean
Ghemawat
2004
energía
centros
datos
cuestiones
Bash
Forman
2007
Ganesh
colaboradores
2007
Villa
2006
escalar
decenas
miles
CPUs
Friedrich
Rolia
2007
máquinas
virtuales
tema
activo
artículos
distintos
aspectos
tema
incluyendo
administración
energía
Moore
colaboradores
2005
Stoess
colabora-
dores
2007
administración
memoria
Lu
Shen
2007
administración
confianza
Garfinkel
colaboradores
2003
Lie
colaboradores
2003
seguridad
Jaeger
colaboradores
2007
optimización
rendimiento
tema
interés
especial
rendimiento
CPU
King
colaboradores
2003
rendimiento
red
Menon
colaboradores
2006
rendimiento
Cherkasova
Gardner
2005
Liu
colaboradores
2006
máquinas
virtuales
migración
inte-
rés
tema
Bradford
colaboradores
2007
Huang
colaboradores
2007
máquinas
vir-
tuales
utilizado
depurar
sistemas
operativos
King
colaboradores
2005
crecimiento
computación
distribuida
investigación
sistemas
archivos
almacenamiento
distribuidos
incluyendo
cuestiones
capacidad
manutención
plazo
frente
fallas
hardware
software
errores
humanos
rupturas
entorno
Baker
colaboradores
2006
Kotla
colaboradores
2007
Maniatis
colaboradores
2005
Shah
colaboradores
2007
Storer
colaboradores
2007
servidores
desconfiables
Adya
colaboradores
2002
Popescu
colaboradores
2003
autenticación
Kaminsky
colaboradores
2003
escalabilidad
sistemas
archivos
distribuidos
Ghemawat
co-
604
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meSECCIÓN
8.6
RESUMEN
605
laboradores
2003
Saito
2002
Weil
colaboradores
2006
investigado
extensión
sistemas
archivos
distribuidos
Peek
colaboradores
2007
examinado
am-
pliamente
sistemas
archivos
distribuidos
punto
punto
Dabek
colaboradores
2001
Gum-
madi
colaboradores
2003
Muthitacharoen
colaboradores
2002
Rowstron
Druschel
2001
nodos
móviles
eficiencia
energía
cuestión
importante
Nightingale
Flinn
2004
8.6
RESUMEN
sistemas
computacionales
rápidos
confiables
CPUs
organizaciones
sistemas
múltiples
CPUs
multiprocesadores
multi-
computadoras
máquinas
virtuales
sistemas
distribuidos
organizaciones
propiedades
cuestiones
multiprocesador
consiste
CPUs
comparten
RAM
común
CPUs
interconectar
bus
conmutador
barras
cruzadas
red
conmu-
tación
multietapa
configuraciones
posibles
sistemas
operativos
otorgar
CPU
sistema
operativo
sistema
operativo
maestro
resto
esclavos
te-
ner
multiprocesador
simétrico
copia
sistema
operativo
CPU
ejecutar
caso
requieren
bloqueos
proveer
sincronización
bloqueo
disponible
CPU
girar
cambio
contexto
algorit-
mos
programación
posibles
tiempo
compartido
espacio
compartido
planificación
pandilla
multicomputadoras
CPUs
CPUs
memoria
privada
comparten
tipo
RAM
común
comuni-
cación
utiliza
paso
mensajes
casos
tarjeta
interfaz
red
CPU
cuyo
caso
comunicación
CPU
principal
CPU
tarjeta
interfaz
organizarse
cuidado
evitar
condiciones
carrera
comunicación
ni-
vel
usuario
multicomputadoras
utiliza
llamadas
procedimientos
remotos
utilizar
memoria
compartida
distribuida
cuestiones
balance
car-
ga
procesos
diversos
algoritmos
utilizan
algoritmos
iniciados
emi-
sor
algoritmos
iniciados
receptor
algoritmos
subasta
máquinas
virtuales
permiten
CPUs
provean
ilusión
CPUs
realmente
forma
ejecutar
sistemas
operativos
va-
rias
versiones
incompatibles
sistema
operativo
tiempo
pieza
hardware
combinarse
diseños
multinúcleo
computadora
convierte
multicomputadora
potencial
escala
sistemas
distribuidos
sistemas
débilmente
acoplados
nodos
computadora
completa
conjunto
completo
periféricos
sistema
operati-
vo
sistemas
esparcen
área
geográfica
frecuencia
coloca
middleware
sistema
operativo
ofrecer
nivel
uniforme
aplicaciones
interactúen
diversos
tipos
middleware
middleware
basado
documentos
basa-
do
archivos
basado
objetos
basado
coordinación
ejemplos
World
Wide
Web
CORBA
Linda
Jini
www
FreeLibros.mePROBLEMAS
considerar
sistemas
distribuidos
sistema
grupos
noticias
USENET
proyec-
to
SETI@home
SETI@home
utiliza
millones
computadoras
personales
inactivas
analizan
datos
radiotelescópicos
buscar
inteligencia
extraterrestre
relacionan
categorías
descritas
figura
8-1
ocurre
CPUs
multiprocesador
intentan
utilizar
palabra
memoria
instante
CPU
emite
petición
memoria
instrucción
computadora
ejecuta
200
MIPS
CPUs
requieren
saturar
bus
400
MHz
Suponga
referencia
memoria
requiere
ciclo
bus
repita
problema
sistema
utiliza
caché
memorias
caché
tasa
aciertos
90%
tasa
aciertos
caché
necesitaría
permitir
32
CPUs
compartan
bus
sobre-
cargarlo
Suponga
rompe
cable
conmutador
2A
conmutador
3B
red
omega
figura
8-5
desconectado
realiza
manejo
señales
modelo
figura
8-7
Vuelva
escribir
código
entrar_region
figura
2-22
utilizando
lectura
reducir
th-
rashing
inducido
instrucción
TSL
CPUs
multinúcleo
empezando
aparecer
máquinas
escritorio
convencionales
computadoras
laptop
lejanos
equipos
escritorio
decenas
cientos
núcleos
aprovechar
paralelizar
aplicaciones
escrito-
rio
estándar
procesador
palabras
navegador
Web
aprove-
char
paralelizar
servicios
ofrecidos
sistema
operativo
procesamiento
TCP
servicios
biblioteca
común
funciones
biblioteca
http
seguro
método
ve
prometedor
realmente
necesarias
regiones
críticas
secciones
código
sistema
operativo
SMP
evitar
condiciones
competencia
utilizar
mutexes
es-
tructuras
datos
utiliza
instrucción
TSLpara
sincronización
multiprocesadores
bloque
caché
contiene
mutex
transportará
CPU
contiene
bloqueo
CPU
solicita
ambas
contacto
bloque
reducir
tráfico
bus
CPU
solicita
bloqueo
ejecutar
instrucción
TSLcada
50
ciclos
bus
CPU
contiene
bloqueo
contacto
bloque
caché
instrucciones
TSL
bloque
caché
compuesto
16
palabras
32
bits
requiere
ci-
clo
bus
transferirse
bus
opera
400
MHz
fracción
ocupa
ancho
banda
bus
mover
bloque
caché
10
texto
sugirió
utilizar
algoritmo
backoff
exponencial
binario
usos
TSLpa-
ra
sondear
bloqueo
sugirió
máximo
retraso
sondeos
Funcionaría
correctamente
algoritmo
hubiera
retraso
máximo
11
Suponga
disponible
instrucción
TSLpara
sincronizar
multiprocesador
lugar
provee
instrucción
SWPpara
intercambiar
atómica
contenido
registro
606
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
607
palabra
memoria
utilizar
instrucción
mantener
sincronización
multiprocesadores
utilizar
caso
contrario
funcio-
naría
12
problema
calcular
carga
bus
impone
bloqueo
espera
activa
Imagine
instrucción
ejecutada
CPU
requiere
nseg
completarse
instruc-
ción
llevan
cabo
ciclos
necesarios
ejemplo
instrucción
TSL
ciclo
bus
requiere
10
nseg
adicionales
tiempo
ejecución
instrucción
proce-
so
intenta
entrar
región
crítica
ciclo
TSL
fracción
ancho
banda
consume
Suponga
funcionando
caché
normal
obtener
instruc-
ción
ciclo
consumen
ciclos
bus
13
figura
8-12
describía
entorno
tiempo
compartido
muestra
proceso
14
programación
afinidad
reduce
fallos
caché
Reduce
fallos
TLB
fallos
página
15
topologías
figura
8-16
diámetro
red
interconexión
Cuente
saltos
host-enrutador
enrutador-enrutador
forma
problema
16
Considere
topología
doble
anillo
figura
8-16(d
expandida
tamaño
/H11003k
diámetro
red
Sugerencia
considere
valores
impares
valores
pares
distinta
17
ancho
banda
bisección
red
interconexión
utiliza
medida
capacidad
calcularlo
elimina
número
mínimo
vínculos
dividen
red
unidades
tamaño
suma
capacidad
vínculos
eliminados
mu-
chas
formas
división
obtenga
mínimo
ancho
banda
ancho
banda
bisección
red
interconexión
consiste
cubo
/H110038
/H110038
an-
cho
banda
bisección
vínculo
Gbps
18
Considere
multicomputadora
interfaz
red
usuario
só-
necesitan
copias
RAM
origen
RAM
destino
Suponga
desplazar
palabra
32
bits
tarjeta
interfaz
red
requieren
20
nseg
red
opera
Gbps
retraso
enviar
paquete
64
bytes
origen
destino
pudiéramos
ignorar
tiempo
copia
retraso
tiempo
copia
consi-
dere
caso
necesitan
copias
adicionales
kernel
emisor
proviene
kernel
receptor
retraso
caso
19
Repita
problema
caso
copias
caso
copias
cal-
cule
ancho
banda
retraso
20
diferencias
implementaciones
send
receive
sistema
multiprocesador
memoria
compartida
multicomputadora
afecta
rendi-
miento
21
transferir
datos
RAM
interfaz
red
marcar
página
suponga
llamadas
sistema
marcar
desmarcar
páginas
requieren
µseg
proceso
copia
bytes
nseg
utiliza
DMA
20
nseg
byte
utiliza
programada
paquete
valga
pena
marcar
página
DMA
www
FreeLibros.me22
recoge
procedimiento
máquina
coloca
llamado
me-
diante
RPC
ocurrir
problemas
texto
recalcamos
apuntadores
tamaños
arreglos
desconocidos
tipos
parámetros
desconocidos
variables
globales
cuestión
analizamos
ocurre
procedimiento
remoto
ejecuta
llamada
sis-
tema
problemas
ocasionar
podríamos
resolverlos
23
ocurre
fallo
página
sistema
DSM
localizar
página
necesi-
ta
Liste
formas
posibles
buscar
página
24
Considere
asignación
procesadores
figura
8-24
Suponga
proceso
mueve
nodo
nodo
peso
tráfico
externo
25
multicomputadoras
permiten
migrar
procesos
ejecución
nodo
sufi-
ciente
detener
proceso
congelar
imagen
memoria
enviarlo
nodo
distinto
Nombre
problemas
triviales
resolver
funcione
26
Considere
hipervisor
tipo
soportar
máquinas
virtuales
tiempo
PCs
máximo
particiones
primarias
disco
almacenar
datos
27
manejar
sistemas
operativos
invitados
modifican
tablas
páginas
me-
diante
instrucciones
ordinarias
privilegiadas
marcar
tablas
páginas
lectura
tomar
interrupción
modifiquen
forma
mante-
ner
tablas
páginas
ocultas
Explique
eficiencia
método
comparación
tablas
páginas
lectura
28
VMware
realiza
traducción
binaria
bloque
básico
ejecuta
bloque
empie-
za
traducir
traducir
programa
completo
adelantado
ejecutar-
ventajas
desventajas
técnica
29
sentido
paravirtualizar
sistema
operativo
disponible
código
fuente
pasa
30
PCs
pequeñas
diferencias
nivel
inferior
forma
administran
temporizadores
interrupciones
detalles
DMA
Significan
diferen-
cias
dispositivos
virtuales
realidad
funcionar
práctica
Explique
respuesta
31
límite
longitud
cables
red
Ethernet
32
ejecutar
máquinas
virtuales
PC
requieren
cantidades
memoria
pensar
reducir
memoria
Explique
33
figura
8-30
niveles
cuarto
etiquetan
Middleware
Aplicación
cua-
tro
máquinas
sentido
iguales
plataforma
sentido
distintos
34
figura
8-33
listan
tipos
distintos
servicio
siguientes
aplicacio-
nes
tipo
servicio
apropiado
Video
demanda
Internet
Descargar
página
Web
35
nombres
DNS
estructura
jerárquica
cs.uni.edu
ventas.generalwidget.com
mantener
base
datos
DNS
base
datos
centralizada
es-
608
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
609
to
obtendrían
demasiadas
peticiones
Proponga
mane-
ra
pudiera
mantener
base
datos
DNS
práctica
36
análisis
forma
navegador
procesa
URLs
estableció
conexio-
nes
realizan
puerto
80
37
fácil
migrar
máquinas
virtuales
procesos
migración
formas
pue-
difícil
problemas
surgir
migrar
máquina
virtual
38
URLs
utilizan
Web
exhibir
transparencia
ubicación
Explique
res-
puesta
39
navegador
obtiene
página
Web
realiza
conexión
TCP
obtener
texto
página
lenguaje
HTML
cierra
conexión
examina
página
figuras
iconos
realiza
conexión
TCP
separado
obtener
figura
icono
Sugiera
diseños
alternativos
mejorar
rendimiento
proceso
40
utiliza
semántica
sesión
modificaciones
archivo
es-
tán
visibles
inmediato
proceso
realiza
cambio
visibles
pro-
cesos
máquinas
visibles
inmediato
procesos
máquina
Proporcione
argumento
casos
41
procesos
necesitan
acceso
datos
acceso
basado
objetos
memoria
compartida
42
realiza
operación
in
Linda
localizar
tupla
ineficiente
buscar
to-
do
espacio
tuplas
forma
lineal
Diseñe
organizar
espacio
tuplas
agilicen
búsquedas
operaciones
in
43
proceso
copiar
búferes
requiere
tiempo
Escriba
programa
averiguar
tiem-
po
requiere
sistema
acceso
Use
funciones
clock
times
deter-
minar
tiempo
requiere
copiar
arreglo
extenso
Pruebe
tamaños
distintos
arreglo
separar
tiempo
copia
tiempo
sobrecarga
44
Escriba
funciones
puedan
utilizar
resguardos
cliente
servidor
llamada
RPC
función
printf
estándar
programa
principal
evaluar
funciones
cliente
servidor
comunicar
estructura
datos
transmi-
tir
red
imponer
límites
razonables
longitud
cadena
formato
número
tipos
tamaños
variables
aceptará
resguardo
cliente
45
Escriba
programas
simular
balanceo
carga
multicomputadora
pro-
grama
establecer
procesos
distribuidos
máquinas
archivo
ini-
cialización
proceso
deberá
tiempo
ejecución
elegido
azar
distribución
gaussiana
cuya
media
desviación
estándar
parámetros
simulación
ejecución
proceso
crea
número
procesos
seleccionan
distribución
Poisson
proceso
termina
CPU
decidir
procesos
CPUs
tratar
buscar
procesos
programa
utilizar
algoritmo
ini-
ciado
servidor
trabajo
CPUs
procesos
máqui-
na
programa
utilizar
algoritmo
iniciado
receptor
obtener
trabajo
necesario
Haga
suposiciones
razonables
necesite
indíquelas
claridad
www
FreeLibros.me46
Escriba
programa
implemente
algoritmos
balanceo
carga
iniciado
emisor
iniciado
receptor
analizan
sección
8.2
algoritmos
recibir
entra-
lista
trabajos
recién
creados
especificados
proceso_creador
tiempo_inicial
tiem-
po_requerido_CPU
proceso_creador
número
CPU
creó
trabajo
tiempo_inicial
tiempo
creó
trabajo
tiempo_requerido_CPU
cantidad
tiempo
CPU
necesita
trabajo
completarse
especificado
segundos
Suponga
nodo
sobrecargado
trabajo
crea
trabajo
Suponga
nodo
carga
trabajos
Imprima
número
mensajes
sondeo
en-
viados
algoritmos
cargas
trabajo
pesada
ligera
Imprima
números
mínimo
máximo
sondas
enviadas
host
recibidas
host
crear
cargas
trabajo
escriba
generadores
carga
trabajo
simular
car-
ga
trabajo
pesada
genere
promedio
trabajos
AJL
segundos
AJL
longitud
trabajo
promedio
número
procesadores
longitudes
trabajos
pue-
den
mezcla
trabajos
cortos
largos
longitud
trabajo
promedio
AJL
trabajos
crearse
colocarse
azar
procesadores
generador
simular
carga
ligera
genere
azar
N/3
trabajos
AJLsegundos
Juegue
configuraciones
parámetros
generadores
carga
trabajo
vea
afecta
número
mensajes
sonda
47
maneras
simples
implementar
sistema
publicar
suscribir
in-
termediario
centralizado
reciba
artículos
publicados
distribuya
suscriptores
apro-
piados
Escriba
aplicación
multihilo
emule
sistema
publicar
suscribir
basado
intermediario
hilos
publicador
suscriptor
comunicar
intermediario
memoria
compartida
mensaje
empezar
longitud
campo
seguida
cantidad
caracteres
editores
envían
mensajes
intermediario
línea
mensaje
contiene
línea
tema
jerárquica
separada
puntos
seguida
líneas
componen
artículo
publicado
suscriptores
envían
mensaje
intermediario
línea
contiene
línea
interés
jerárquica
separada
puntos
expresan
artícu-
interesados
línea
interés
contener
símbolo
comodín
in-
termediario
responder
enviando
artículos
anteriores
coincidan
interés
suscriptor
artículos
mensaje
separan
línea
INICIO
ARTÍCU-
suscriptor
imprimir
mensaje
reciba
identidad
suscriptores
línea
interés
suscriptor
seguir
recibiendo
artículos
publi-
quen
coincidan
intereses
crear
hilos
publicador
suscriptor
dinámi-
ca
terminal
escribiendo
letra
publicador
suscriptor
seguida
línea
tema
interés
jerárquica
publicadores
pedirán
artículo
escribir
línea
contenga
indicará
artículo
proyecto
implementar
procesos
comuniquen
TCP
610
SISTEMAS
MÚLTIPLES
PROCESADORES
CAPÍTULO
www
FreeLibros.me9
SEGURIDAD
611
empresas
poseen
información
valiosa
desean
protegida
informa-
ción
técnica
ejemplo
diseño
chip
software
comercial
ejemplo
estudios
competencia
planes
marketing
financiera
ejemplo
planes
oferta
acciones
legal
ejemplo
documentos
fusión
absorción
empresa
tipos
frecuencia
proteger
información
pone
guar-
uniformado
entrada
edificio
asegura
adecuada
identificación
en-
tre
Asimismo
archiveros
oficinas
cierran
llave
asegurar
personas
autorizadas
tengan
acceso
información
computadoras
domésticas
contienen
datos
valiosos
perso-
nas
mantienen
información
financiera
devoluciones
impuestos
números
tarjetas
crédito
computadora
cartas
amor
vuelto
digitales
discos
du-
ros
tiempos
llenos
fotografías
videos
películas
importantes
medida
almacena
información
tipo
sistemas
computacio-
nales
vuelve
importante
necesidad
protegerla
proteger
in-
formación
autorizado
principales
preocupaciones
sistemas
operativos
desgracia
difícil
amplia
aceptación
sistemas
inflados
errores
acompañan
fenómeno
normal
siguientes
secciones
analizaremos
variedad
cuestiones
relacionadas
seguridad
protección
analogías
protección
real
información
papel
únicas
sistemas
computacionales
capítulo
examinaremos
seguridad
computadoras
aplicada
sistemas
operativos
www
FreeLibros.meLas
cuestiones
relacionadas
seguridad
sistemas
operativos
cambiado
mane-
ra
radical
décadas
principios
década
1990
personas
tenían
computadora
casa
mayoría
trabajos
cómputo
realizaban
empresas
universidades
organizaciones
computadoras
multiusuario
mainframes
minicomputadoras
máquinas
aisladas
conexión
red
consecuencia
seguridad
enfocada
completo
forma
evitar
usuarios
entrometieran
asuntos
usuarios
Tracy
Marcia
usuarios
registrados
computadora
truco
asegurar
pudiera
leer
archivos
modificarlos
permitir
compartieran
archivos
querían
com-
desarrollaron
modelos
mecanismos
elaborados
asegurar
usuario
pudie-
ra
obtener
derechos
acceso
archivos
debía
modelos
mecanismos
implicaban
clases
usuarios
in-
dividuos
ejemplo
computadora
militar
datos
tenían
marcarse
secre-
tos
secretos
confidenciales
públicos
evitar
cabos
husmearan
directorios
generales
importar
cabo
general
temas
investi-
garon
detallada
reportes
implementaron
dé-
cadas
suposición
tácita
elegía
modelo
realizaba
implementación
software
básicamente
correcto
cumpliría
reglas
general
modelos
software
simples
suposición
válida
ende
teoría
Tracy
permitido
archivo
Marcia
práctica
podía
situación
cambió
surgimiento
computadora
personal
Internet
desa-
parición
mainframe
minicomputadoras
compartidas
cambió
completo
servidores
LANs
corporativas
minicomputadoras
compartidas
usuarios
domésticos
amenaza
husmeara
archivos
personas
usaran
computadora
desgracia
medida
disminuyó
amenaza
surgió
ocupar
lugar
ley
conservación
amenazas
ataques
exterior
Surgieron
virus
gusanos
pla-
gas
digitales
entraron
computadoras
Internet
establecidos
causaron
tipo
estragos
ayudó
daño
explosivo
crecimiento
bugware
in-
flado
sustituido
formidable
software
eficiente
años
anteriores
siste-
operativos
contienen
millones
líneas
código
kernel
aplicaciones
100
MB
regla
excepción
cantidades
errores
plagas
digitales
pue-
den
explotar
cosas
reglas
permiten
situación
mostrar
formalmente
sistema
seguro
compro-
metido
facilidad
error
código
permite
programa
salvaje
haga
cosas
formalmente
prohibido
capítulo
consta
partes
cubrir
detalles
Empieza
analizar
ame-
nazas
detalle
proteger
sección
9.2
in-
troduce
criptografía
moderna
herramienta
básica
importante
mundo
seguridad
viene
sección
9.3
modelos
formales
seguridad
for-
ma
razonar
acceso
seguro
protección
usuarios
datos
confiden-
ciales
comparten
datos
usuarios
612
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.1
ENTORNO
SEGURIDAD
613
punto
entra
juego
realidad
siguientes
secciones
tratan
problemas
seguridad
prácticos
ocurren
vida
diaria
cerrar
nota
optimista
terminaremos
capítulo
secciones
defensas
plagas
mundo
real
análisis
investigación
continua
seguridad
computado-
ras
resumen
vale
pena
observar
libro
sistemas
operativos
seguridad
red
cuestiones
entrelazadas
realmente
imposible
sepa-
rarlas
ejemplo
virus
entran
red
afectan
sistema
operativo
general
preferido
pecar
prudentes
incluimos
material
vinculado
tema
aun-
realidad
cuestión
sistemas
operativos
9.1
ENTORNO
SEGURIDAD
empezar
estudio
seguridad
definición
terminología
Al-
gunas
personas
utilizan
términos
seguridad
protección
indistinta
embar-
go
frecuencia
útil
distinguir
problemas
generales
involucrados
proceso
evitar
personas
autorizadas
lean
modifiquen
archivos
incluye
cuestio-
nes
técnicas
administrativas
legales
políticas
incluye
mecanismos
específicos
sistema
operativo
brindar
seguridad
evitar
confusión
utilizaremos
término
segu-
ridad
referencia
problema
general
mecanismos
protección
referirnos
mecanismos
específicos
sistema
operativo
utilizan
salvaguardar
información
computadora
límite
definido
términos
estu-
diaremos
seguridad
naturaleza
problema
capítulo
ana-
lizaremos
mecanismos
protección
modelos
disponibles
ayudar
obtener
seguridad
seguridad
facetas
importantes
naturaleza
ame-
nazas
naturaleza
intrusos
pérdida
accidental
datos
analizaremos
facetas
orden
9.1.1
Amenazas
perspectiva
seguridad
sistemas
computacionales
objetivos
genera-
correspondientes
amenazas
muestra
lista
figura
9-1
objeti-
vo
conocido
confidencialidad
datos
implica
datos
secretos
permanezcan
ejemplo
propietario
datos
decidido
disponibles
só-
personas
sistema
garantizar
personas
autorizadas
tengan
acceso
datos
mínimo
absoluto
propietario
capaz
especificar
cosa
sistema
cumplir
especificaciones
teoría
aplicar
archivo
forma
individual
www
FreeLibros.meObjetivo
Amenaza
Confidencialidad
datos
Exposición
datos
Integridad
datos
Alteración
datos
Disponibilidad
sistema
Negación
servicio
Exclusión
usuarios
externos
virus
apropian
sistema
Figura
9-1
Objetivos
amenazas
seguridad
objetivo
conocido
integridad
datos
significa
usuarios
au-
torización
capaces
modificar
datos
permiso
propietario
modificación
datos
contexto
incluye
modificación
datos
eliminación
inclusión
datos
falsos
sistema
garantizar
datos
depositados
permane-
cerán
modificación
usuario
decida
valor
sistema
in-
formación
tercer
objetivo
conocido
disponibilidad
sistema
significa
per-
turbar
sistema
inutilizable
Dichos
ataques
negación
servicio
comunes
ejemplo
computadora
servidor
Internet
alguien
envía
avalancha
peticiones
dejarlo
inhabilitado
ocupar
tiempo
CPU
só-
examinar
descartar
peticiones
entrantes
ejemplo
requiere
100
µseg
procesar
petición
entrante
leer
página
Web
cualquiera
arregle
pa-
ra
enviar
10,000
peticiones
aniquilarlo
disponibles
modelos
razonables
tec-
nología
lidiar
ataques
confidencialidad
integridad
difícil
frustrar
ataques
negación
servicio
años
recientes
surgió
amenaza
usuarios
externos
tomar
control
computadoras
hogar
personas
vi-
rus
medios
convertirlas
zombies
dispuestas
cumplir
deseos
usuario
exterior
órdenes
zombies
utilizan
enviar
spam
rastrear
cerebro
ataque
spam
sentido
amenaza
amenaza
sociedad
usuarios
individuales
rencor
país
específico
grupo
étnico
enojados
mundo
general
desean
destruir
infraestructura
pue-
importar
naturaleza
daños
víctimas
específicas
general
dichas
personas
sienten
atacar
computadoras
enemigos
ataques
estén
enfocados
aspecto
problema
seguridad
privacidad
proteger
individuos
información
generando
problemas
legales
morales
gobierno
compilar
expedientes
personas
atrapar
engañan
asistencia
social
impuestos
dependiendo
intereses
políticos
capaz
policía
buscar
información
persona
detener
crimen
organizado
patrones
compañías
seguros
derechos
ocurre
cuan-
do
derechos
entran
conflicto
derechos
individuales
cuestiones
importantes
allá
alcance
libro
614
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.1
ENTORNO
SEGURIDAD
615
9.1.2
Intrusos
mayoría
personas
obedecen
ley
preocuparnos
se-
guridad
desgracia
personas
quieren
ocasio-
nar
problemas
posiblemente
obtener
ganancia
comercial
literatura
seguridad
personas
husmean
lugares
conocen
co-
mo
intrusos
adversarios
intrusos
actúan
formas
distintas
intrusos
pasivos
quieren
leer
archivos
autorización
intrusos
ac-
tivos
maliciosos
desean
modificaciones
autorizadas
datos
diseñar
sistema
seguro
intrusos
importante
tipo
intruso
con-
tra
tratamos
protegerlo
categorías
comunes
Usuarios
técnicos
entrometen
forma
casual
personas
compu-
tadoras
personales
escritorios
conectadas
servidor
archi-
vos
compartidos
naturaleza
curiosa
humanos
personas
capaces
leer
correo
electrónico
archivos
ba-
rreras
detengan
ejemplo
mayoría
usuarios
UNIX
op-
ción
predeterminada
archivos
recién
creados
permisos
lectura
Intrusos
husmean
estudiantes
programadores
sistemas
operadores
personal
técnico
consideran
reto
personal
acción
irrumpir
se-
guridad
sistema
computacional
local
general
habilidosos
dis-
puestos
dedicar
cantidad
considerable
tiempo
Intentos
determinados
obtener
dinero
programadores
bancos
trata-
do
robar
banco
trabajan
esquemas
varían
cambiar
software
truncar
redondear
interés
quedarse
fracción
centavo
desviar
cuentas
utilizado
años
llegar
chantaje
pagan
des-
truiré
registros
banco
Espionaje
comercial
militar
espionaje
refiere
intento
serio
fundamenta-
do
competidor
país
robar
programas
secretos
comerciales
ideas
patentables
tecnología
diseños
circuitos
planes
negocios
etcétera
intervienen
líneas
telefónicas
montan
antenas
dirigidas
computadora
recoger
radiación
electromagnética
dejar
tratar
evitar
gobierno
extranjero
hostil
robe
secretos
militares
distinto
tratar
evitar
estudiantes
inserten
diario
mensaje
gracioso
sistema
cantidad
esfuerzo
necesaria
seguridad
protección
depende
duda
creamos
enemigo
virus
categoría
plaga
seguridad
manifestado
años
recientes
hablaremos
detalle
capítulo
esencia
virus
pieza
www.FreeLibros.mecódigo
duplica
general
realiza
daño
escritor
virus
intruso
habilidades
técnicas
elevadas
diferencia
intruso
convencional
virus
refiere
persona
irrumpir
sistema
motivos
personales
ocasionar
daños
progra-
ma
escrito
dicha
persona
suelta
mundo
esperanza
provo-
daños
intrusos
tratan
irrumpir
sistemas
específicos
ejemplo
pertenezca
banco
Pentágono
robar
destruir
datos
específicos
escritor
virus
comúnmente
provocar
daños
general
importa
9.1.3
Pérdida
accidental
datos
amenazas
ocasionadas
intrusos
maliciosos
accidente
perder
datos
valiosos
causas
comunes
pérdida
accidental
datos
Accidentes
desastres
naturales
incendios
inundaciones
terremotos
guerras
disturbios
ratas
roen
cintas
magnéticas
Errores
hardware
software
fallas
CPU
discos
cintas
leer
errores
telecomunicaciones
errores
programas
Errores
humanos
error
introducir
datos
montar
cinta
CD-ROM
mane-
ra
incorrecta
ejecutar
programa
incorrecto
perder
disco
cinta
error
mayoría
causas
prevenir
realización
respaldos
adecuados
guardan
preferencia
lejos
datos
originales
acción
proteger
datos
con-
tra
pérdidas
accidentales
parecer
mundana
comparación
acción
proteger
intrusos
astutos
práctica
probable
daños
ocasionados
pérdidas
acci-
dentales
intrusos
9.2
FUNDAMENTOS
CRIPTOGRAFÍA
CIFRADO
criptografía
desempeña
importante
papel
seguridad
personas
familiari-
zadas
criptogramas
periódicos
pequeños
rompecabezas
letra
sustituido
sistemática
letra
distinta
realidad
criptografía
moderna
sección
daremos
vistazo
criptografía
computadoras
útil
comprender
resto
capítulo
cual-
quiera
esté
preocupado
seguridad
fundamentos
em-
bargo
análisis
detallado
criptografía
tema
allá
alcance
libro
libros
excelentes
seguridad
computadoras
analizan
tema
detalle
lector
interesado
consultar
libros
ejemplo
Kaufman
colaboradores
616
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.2
FUNDAMENTOS
CRIPTOGRAFÍA
CIFRADO
617
2002
Pfleeger
Pfleeger
2006
continuación
veremos
análisis
criptogra-
fía
lectores
estén
familiarizados
propósito
criptografía
tomar
mensaje
archivo
conocido
texto
simple
convertirlo
texto
cifrado
forma
personas
autorizadas
sepan
convertirlo
nuevamente
texto
simple
texto
cifrado
sucesión
incompren-
sible
bits
parecer
extraño
principiantes
área
algoritmos
ci-
frado
descifrado
funciones
siempredeben
públicos
mantener
secretos
personas
tratan
mantener
secretos
falsa
sensación
seguridad
práctica
táctica
conoce
seguridad
oscuridad
emplean
amateurs
seguridad
extraño
categoría
amateurs
incluye
empresas
mul-
tinacionales
realidad
deberían
informadas
secreto
depende
parámetros
algoritmos
de-
nomina
claves
archivo
texto
simple
clave
cifrado
texto
cifrado
algoritmo
cifrado
función
/H11005E
KE
definición
cifrado
indica
texto
cifrado
obtiene
algoritmo
cifrado
texto
simple
clave
cifrado
secreta
parámetros
idea
algoritmos
públicos
secreto
residir
exclusivamente
claves
conoce
Principio
Kerckhoffs
formulado
criptógrafo
holandés
Auguste
Kerckhoffs
si-
glo
XIX
actualidad
criptógrafos
serios
adoptado
idea
similar
/H11005D
KD
algoritmo
descifrado
KD
clave
descifrado
indica
obtener
vuelta
texto
simple
texto
ci-
frado
clave
descifrado
KD
ejecutar
algoritmo
KD
parámetros
figura
9-2
muestra
relación
diversas
piezas
KE
Clave
cifrado
Clave
descifrado
Texto
simple
entrada
Texto
simple
salidaAlgoritmo
cifrado
KD
Algoritmo
descifrado
Texto
cifrado
E(P
KE
D(C
KD
DescifradoCifrado
Figura
9-2
Relación
texto
simple
texto
cifrado
9.2.1
Criptografía
clave
secreta
considere
algoritmo
letra
sustituye
letra
distinta
ejemplo
As
sustituyen
Qs
Bs
sustituyen
Ws
Cs
sustituyen
sucesivo
www.FreeLibros.metexto
simple
texto
cifrado
sistema
general
conoce
sustitución
monoalfabética
clave
ca-
dena
26
letras
correspondiente
alfabeto
completo
clave
cifrado
ejemplo
QWERTYUIOPASDFGHJKLZXCVBNM
Utilizando
clave
texto
simple
ATTACK
transformaría
texto
cifrado
QZZQEA
clave
descifrado
indica
obtener
vuelta
texto
simple
texto
cifrado
ejemplo
clave
descifrado
KXVMC-
NOPHQRSZYIJADLEGWBUFT
texto
cifrado
texto
sim-
ple
texto
cifrado
texto
simple
sucesivamente
instancia
parecer
sistema
seguro
criptoanalista
co-
nozca
sistema
general
sustitución
letra
letra
26
/H112294
/H1100310
26
posi-
bles
claves
utilizando
texto
cifrado
clave
descubrir
facilidad
ataque
básico
saca
provecho
propiedades
estadísticas
lengua-
jes
naturales
ejemplo
inglés
letra
común
seguida
etc.
com-
binaciones
comunes
letras
conocidas
bigramas
th
in
er
re
sucesivo
fácil
quebrantar
cifrado
utiliza
tipo
información
sistemas
criptográficos
propiedad
dada
clave
ci-
frado
fácil
encontrar
clave
descifrado
viceversa
dichos
sistemas
conoce
criptografía
clave
secreta
criptografía
clave
simétrica
cifrados
sustitución
monoalfabética
completamente
inútiles
algoritmos
clave
simétrica
conocidos
relativamente
seguros
claves
largas
seguridad
formal
utilizar
mínimo
claves
256
bits
obtiene
espacio
búsqueda
256
/H112291.2
/H110031077
claves
claves
cortas
frustrar
amateurs
prin-
cipales
gobiernos
9.2.2
Criptografía
clave
pública
sistemas
clave
secreta
eficientes
monto
cálculos
requeridos
ci-
frar
descifrar
mensaje
razonable
desventaja
emisor
receptor
de-
ben
clave
secreta
compartida
tengan
reunirse
físicamente
entregue
clave
resolver
problema
utiliza
criptografía
clave
pública
Diffie
Hellman
1976
sistema
propiedad
utilizan
distintas
cla-
ves
cifrado
descifrado
elige
clave
cifrado
imposible
descubrir
clave
descifrado
correspondiente
circunstancias
clave
cifrado
ha-
cer
pública
mantener
secreta
clave
descifrado
privada
lector
vea
funciona
criptografía
clave
pública
considere
siguientes
preguntas
Pregunta
314159265358979
/H11003314159265358979
Pregunta
raíz
cuadrada
3912571506419387090594828508241
618
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.2
FUNDAMENTOS
CRIPTOGRAFÍA
CIFRADO
619
mayoría
estudiantes
sexto
grado
contestar
pregunta
ho-
ras
damos
lápiz
papel
prometemos
cono
helado
obtienen
respuesta
co-
rrecta
mayoría
adultos
necesitaría
calculadora
computadora
tipo
ayuda
externa
resolver
pregunta
damos
lápiz
papel
promesa
reducción
50%
vida
impuestos
cuadrado
raíz
cuadrada
operaciones
inversas
tie-
nen
diferencias
complejidad
computacional
tipo
asimetría
forma
base
criptografía
clave
pública
cifrado
utiliza
operación
sencilla
desci-
frado
clave
necesita
operación
difícil
sistema
clave
pública
llamado
RSA
explota
compu-
tadora
fácil
multiplicar
números
obtener
factorial
números
especial
operaciones
aritméticas
realizan
aritmé-
tica
módulo
números
involucrados
cientos
dígitos
Rivest
colaboradores
1978
sistema
utiliza
mundo
criptografía
utilizan
sistemas
basados
logaritmos
discretos
Gamal
1985
principal
problema
criptografía
cla-
ve
pública
mil
lenta
criptografía
simétrica
Veamos
funciona
criptografía
clave
pública
eligen
par
clave
pública
clave
privada
publican
clave
pública
clave
pública
clave
cifrado
clave
privada
clave
descifrado
general
proceso
generación
clave
automatizado
contraseña
seleccionada
usuario
alimenta
algoritmo
semilla
enviar
mensaje
secreto
usuario
corresponsal
cifra
mensaje
clave
pública
receptor
receptor
clave
privada
desci-
frar
mensaje
9.2.3
Funciones
vía
situaciones
veremos
deseable
función
propiedad
dada
parámetro
fácil
calcular
/H11005f(x
imposible
calcular
valor
x.
Comúnmente
dicha
función
manipula
bits
formas
comple-
jas
empezar
inicializar
x.
ejecutar
ciclo
itere
ve-
ces
bits
iteración
permutarían
bits
independiente
iteración
agregando
constante
distinta
iteración
mezclando
general
bits
minuciosamente
dicha
función
conoce
función
hash
criptográ-
fica
9.2.4
Firmas
digitales
frecuencia
necesario
firmar
documento
forma
digital
ejemplo
suponga
cliente
pide
banco
compre
acciones
envía
mensaje
correo
elec-
trónico
hora
enviado
ejecutado
orden
acciones
desploman
Aho-
ra
cliente
niega
enviado
correo
electrónico
banco
presentar
correo
electrónico
cliente
afirmar
banco
falsificó
ob-
comisión
juez
diciendo
www
FreeLibros.me620
SEGURIDAD
CAPÍTULO
firmas
digitales
firmar
correos
electrónicos
documentos
di-
gitales
forma
emisor
repudiar
común
pasar
pri-
mero
documento
algoritmo
hashing
criptográfico
vía
difícil
invertir
general
función
hashing
produce
resultado
longitud
fija
independien-
tamaño
documento
original
funciones
hashing
populares
MD5
Algo-
ritmo
firma
mensajes
produce
resultado
16
bytes
Rivest
1992
SHA-1
Algoritmo
hash
seguro
produce
resultado
20
bytes
NIST
1995
versiones
recientes
SHA-1
SHA-256
SHA-512
producen
resultados
32
64
bytes
res-
pectivamente
utilizan
frecuencia
actualidad
paso
asume
utilizando
criptografía
clave
pública
vimos
an-
tes
propietario
documento
aplica
clave
privada
hash
obtener
D(hash
valor
conocido
bloque
firma
adjunta
documento
envía
receptor
muestra
figura
9-3
proceso
aplicar
hash
conoce
des-
cifrar
hash
realidad
descifrado
hash
cifrado
transformación
matemática
aplicada
hash
Documento
original
Documento
original
documento
comprime
valor
hash
valor
hash
pasa
D(Hash
D(Hash)Bloque
firma
Hash
Figura
9-3
Cálculo
bloque
firma
obtiene
receptor
llegan
documento
hash
receptor
calcula
hash
documento
me-
diante
MD5
SHA
hayan
acordado
antemano
receptor
apli-
ca
clave
pública
emisor
bloque
firma
obtener
E(D(hash
efecto
cifra
hash
descifrado
cancela
obtiene
hash
vuelta
hash
calculado
coincide
hash
bloque
firma
significa
alteró
documento
bloque
firma
modi-
ficaron
accidente
valor
esquema
aplica
criptografía
clave
pública
len-
ta
pieza
datos
relativamente
pequeña
hash
método
funciona
E(D(x
/H11005x
garantiza
priori
funciones
cifrado
vayan
propiedad
habíamos
pedido
principio
D(E(x
/H11005x
www
FreeLibros.meSECCIÓN
9.2
FUNDAMENTOS
CRIPTOGRAFÍA
CIFRADO
621
función
cifrado
función
descifrado
obtener
propiedad
firma
suma
orden
aplicación
importar
funciones
con-
mutativas
fortuna
algoritmo
RSA
propiedad
utilizar
esquema
firma
receptor
clave
pública
emisor
Al-
gunos
usuarios
publican
clave
pública
página
Web
temor
intruso
sistema
altere
clave
enteren
requiere
me-
canismo
alternativo
distribuir
claves
públicas
método
común
emisores
mensaje
adjunten
certificado
contiene
nombre
usuario
clave
públi-
ca
firmado
digitalmente
confianza
usuario
ad-
quirido
clave
pública
confianza
aceptar
certificados
emisores
utilicen
confianza
generar
certificados
confianza
firma
certificados
conoce
CA
Certification
Authority
Autoridad
certificación
usuario
verificar
certificado
firma-
do
CA
necesita
clave
pública
proviene
usuario
real
general
requiere
esquema
administrar
claves
públicas
conocido
PKI
Public
Key
Infrastructure(Infraestructura
claves
públicas
navegadores
Web
proble-
ma
resuelve
ad
hoc
navegadores
cargadas
claves
públicas
aproxima-
damente
40
CAs
populares
Acabamos
utilizar
criptografía
clave
pública
firmas
digi-
tales
Vale
pena
mencionar
esquemas
involucran
criptografía
clave
pública
9.2.5
Módulo
plataforma
confiable
criptografía
requiere
claves
comprometen
claves
compromete
seguridad
basa
esencial
almacenar
claves
forma
segura
almacenamos
claves
forma
segura
sistema
seguro
industria
propuesto
utilizar
chip
llamado
TPM
Trusted
Platform
Modules
Módu-
plataforma
confiables
criptoprocesador
contiene
almacenamiento
volátil
pa-
ra
guardar
claves
TPM
operaciones
criptográficas
cifrar
bloques
texto
simple
descifrar
bloques
texto
cifrado
memoria
principal
verifi-
car
firmas
digitales
operaciones
hardware
especializado
reali-
zar
velocidad
probable
utilicen
frecuencia
computadoras
chips
TPM
probable
computadoras
vayan
incluir
fu-
turo
TPM
controversial
distintas
partes
ideas
acerca
controlar
TPM
proteger
Microsoft
defensor
con-
cepto
desarrollado
serie
tecnologías
utilizarlo
incluyendo
Palladium
NGSCB
BitLocker
punto
vista
sistema
operativo
controla
TPM
evitar
ejecute
software
autorizado
software
autorizado
software
pirata
copias
ile-
gales
software
sistema
operativo
autorice
TPM
involucrado
pro-
ceso
arranque
iniciar
sistemas
operativos
firmados
fabricante
clave
secreta
colocada
TPM
divulgue
distribuidores
sistemas
www
FreeLibros.me622
SEGURIDAD
CAPÍTULO
operativos
Microsoft
TPM
utilizar
limitar
opciones
usuarios
software
puedan
seleccionar
software
aprobado
fabri-
cante
computadoras
industrias
música
películas
interés
TPM
utilizar
evitar
pirateen
contenido
abrir
modelos
ne-
gocios
rentar
canciones
películas
periodo
específico
dejar
descifrarlas
fecha
expiración
TPM
usos
falta
espacio
veremos
interesante
TPM
ayuda
computadoras
seguras
ataques
externos
rea-
lidad
enfoca
criptografía
evitar
usuarios
hagan
esté
apro-
bado
directa
indirecta
entidad
controle
TPM
desea
aprender
tema
artículo
Trusted
Computing
Computación
confiable
Wikipedia
lugar
empezar
9.3
MECANISMOS
PROTECCIÓN
fácil
obtener
seguridad
modelo
proteger
permite
cosa
campo
cantidad
considerable
trabajo
arañar
superficie
concentraremos
modelos
generales
mecanismos
llevarlos
cabo
9.3.1
Dominios
protección
sistema
computacional
contiene
objetos
necesitan
protección
objetos
pue-
den
hardware
ejemplo
CPUs
segmentos
memoria
unidades
disco
impresoras
software
ejemplo
procesos
archivos
bases
datos
semáforos
objeto
nombre
único
utiliza
referencia
conjunto
finito
operaciones
procesos
cabo
objetos
operaciones
ready
write
apropiadas
archivo
upy
downse
utilizan
semáforo
obvio
necesita
prohibir
procesos
utilicen
objetos
autoriza-
ción
mecanismo
restringir
procesos
pue-
utilizar
conjunto
operaciones
legales
necesario
ejemplo
proceso
permiso
leer
escribir
archivo
F.
analizar
distintos
mecanismos
protección
conveniente
introducir
concepto
dominio
dominio
conjunto
pares
objeto
permisos
par
especifica
ob-
jeto
subconjunto
operaciones
permiso
con-
texto
indica
permiso
operaciones
dominio
corresponde
usuario
indica
dominio
general
usuario
ejemplo
miembros
equipo
programación
traba-
jan
proyecto
pertenecer
dominio
tengan
acceso
archivos
proyecto
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
623
asignan
objetos
dominios
depende
detalles
necesita
conceptos
básicos
POLA
Principle
of
Least
Au-
thority
Principio
menor
autoridad
necesidad
general
seguridad
funciona
dominio
mínimos
objetos
privilegios
trabajo
figura
9-4
muestran
dominios
objetos
dominio
permisos
dispo-
nibles
objeto
lectura
escritura
ejecución
Observe
Impresora1
dominios
tiempo
permisos
Archivo1
dominios
distintos
permisos
Dominio
Dominio
Dominio
Archivo1[R
Archivo2[RW
Archivo1[RW
Archivo4[RWX
Archivo5[RW
Impresora
1[W
Archivo6[RWX
Plotter2[W
Figura
9-4
dominios
protección
instante
proceso
ejecuta
dominio
protección
palabras
colección
objetos
acceder
objeto
conjunto
permisos
procesos
cambiar
dominio
ejecución
re-
glas
cambiar
domino
dependientes
sistema
idea
dominio
protección
concreta
analizar
UNIX
incluyendo
Linux
FreeBSD
amigos
UNIX
dominio
proceso
define
me-
diante
UID
GID
usuario
inicia
sesión
shell
recibe
archivo
contrase-
ñas
UID
GID
contenidos
entrada
hijos
heredan
Dada
combinación
UID
GID
crear
lista
completa
objetos
archivos
inclu-
yendo
dispositivos
representados
archivos
especiales
etc.
acce-
der
utilizar
leer
escribir
ejecutar
procesos
combinación
UID
GID
acceso
conjunto
exacto
objetos
procesos
distintos
valo-
res
UID
GID
acceso
conjunto
distinto
archivos
traslapar
forma
considerable
proceso
UNIX
mitades
usuario
kernel
proceso
realiza
llamada
sistema
cambia
usuario
ker-
nel
acceso
conjunto
distinto
objetos
usuario
ejem-
plo
kernel
acceder
páginas
memoria
física
disco
recursos
protegidos
ende
llamada
sistema
produce
cambio
dominio
proceso
realiza
operación
execen
archivo
bit
SETUID
SETGID
en-
cendido
adquiere
UID
GID
efectivo
combinación
distinta
UID
GID
disposición
conjunto
distinto
archivos
operaciones
ejecución
programa
www
FreeLibros.me624
SEGURIDAD
CAPÍTULO
SETUID
SETGID
produce
cambio
dominio
cambian
permisos
dis-
ponibles
cuestión
importante
forma
sistema
registro
dominios
objetos
pertenecen
concepto
imaginar
ma-
triz
filas
dominios
columnas
objetos
cuadro
lista
permisos
contiene
dominio
objeto
figura
9-5
muestra
matriz
figu-
ra
9-4
Dada
matriz
número
dominio
actual
sistema
permite
ac-
ceso
objeto
específica
dominio
Impresora1
Plotter2
Dominio
Archivo1
Archivo2
Archivo3
Archivo4
Archivo5
Archivo6
Objeto
Lectura
Lectura
Lectura
Escritura
Lectura
Escritura
Lectura
Escritura
Ejecución
Lectura
Escritura
Ejecución
Escritura
Escritura
Escritura
Figura
9-5
matriz
protección
incluir
facilidad
cambio
dominio
modelo
matriz
dominio
objeto
operación
enter
figu-
ra
9-6
muestra
matriz
figura
9-5
dominios
ob-
jetos
procesos
dominio
cambiar
dominio
regresar
situación
modela
ejecución
programa
SETUID
UNIX
ejemplo
permite
cambio
dominio
Objeto
Dominio2
Dominio3Dominio1
Enter
Impresora1
Plotter2
Dominio
Archivo1
Archivo2
Archivo3
Archivo4
Archivo5
Archivo6
Lectura
Lectura
Lectura
Escritura
Lectura
Escritura
Lectura
Escritura
Ejecución
Lectura
Escritura
Ejecución
Escritura
Escritura
Escritura
Figura
9-6
matriz
protección
dominios
objetos
9.3.2
Listas
control
acceso
práctica
raras
almacena
matriz
figura
9-6
extensa
escasa
mayoría
dominios
acceso
mayoría
objetos
desperdicia
espacio
disco
almacenar
matriz
vacía
em-
bargo
métodos
prácticos
almacenar
matriz
filas
columnas
almacenar
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
625
elementos
vacíos
métodos
extremo
sección
anali-
zaremos
método
almacenar
matriz
columna
sección
estudiaremos
método
técnica
consiste
asociar
objeto
lista
ordenada
contenga
dominios
acceder
objeto
forma
lista
conoce
Lista
control
acceso
Access
Control
List
ACL
ilustra
figura
9-7
pode-
mos
procesos
pertenece
dominio
distinto
ar-
chivos
F1
F2
F3
simplicidad
suponer
dominio
corresponde
usuario
caso
usuarios
C.
literatura
seguridad
usuarios
denomina
frecuencia
sujetos
protagonistas
contrastarlos
cosas
due-
ño
objetos
archivos
Proceso
Propietario
F1
RW
F2
RW
F3
RWX
RX
Archivo
Espacio
usuario
Espacio
kernel
ACL
Figura
9-7
listas
control
acceso
administrar
acceso
archivos
archivo
ACL
asociada
archivo
F1
entradas
ACL
separadas
punto
coma
entrada
indica
proceso
propiedad
usua-
rio
leer
escribir
archivo
entrada
indica
proceso
propiedad
usuario
leer
archivo
accesos
usuarios
accesos
usuarios
prohibidos
Observe
permisos
otorgan
usuario
proceso
sistema
protección
concierne
proceso
pro-
piedad
usuario
leer
escribir
archivo
F1
importa
proceso
100
importa
propietario
ID
proceso
archivo
F2
entradas
ACL
leer
archivo
pue-
escribir
permiten
accesos
archivo
F3
programa
ejecu-
table
leerlo
ejecutarlo
escribir
ejemplo
ilustra
forma
básica
protección
ACLs
utilizan
sis-
temas
sofisticados
práctica
empezar
mostrado
permi-
sos
lectura
escritura
ejecución
permisos
adicionales
genéricos
apliquen
objetos
específi-
cos
objeto
ejemplos
permisos
genéricos
destroy
object(destruir
objeto
www
FreeLibros.me626
SEGURIDAD
CAPÍTULO
copy
object(copiar
objeto
permisos
aplicar
objeto
importar
tipo
permisos
específicos
objeto
append
message(adjun-
tar
mensaje
objeto
bandeja
correo
sort
alphabetically(ordenar
alfabéticamente
pa-
ra
objeto
directorio
entradas
ACL
usuarios
individuales
sistemas
in-
tegran
concepto
grupo
usuarios
grupos
nombres
incluir
ACLs
variaciones
posibles
semántica
grupos
sistemas
pro-
ceso
ID
usuario
UID
ID
grupo
GID
dichos
sistemas
entrada
ACL
contiene
entradas
forma
UID1
GID1
permisos1
UID2
GID2
permisos2
condiciones
petición
acceder
objeto
realiza
com-
probación
UID
GUID
proceso
llamada
presentes
ACL
disponibles
permisos
listados
combinación
UID
GID
lis-
ta
permite
acceso
utilizar
grupos
forma
introduce
efecto
concepto
rol
Considere
instalación
computadoras
Tana
administradora
sistema
ende
gru-
po
sysadm
suponga
empresa
clubs
empleados
Tana
miembro
club
colombófilos
miembros
club
pertenecen
grupo
fanpichones
tie-
nen
acceso
computadoras
empresa
administrar
base
datos
pichones
figura
9-8
muestra
porción
ACL
Archivo
Lista
control
acceso
Password
Tana
sysadm
RW
Pichones_data
bill
fanpichones
RW
tana
fanpichones
RW
Figura
9-8
listas
control
acceso
Tana
acceder
archivos
resultado
depende
grupo
en-
cuentre
conectada
momento
inicie
sesión
sistema
pedir
seleccione
grupos
utilizando
inclusive
distintos
nombres
inicio
sesión
contraseñas
mantenerlos
separados
objetivo
esquema
evitar
Tana
acceda
archivo
contraseñas
esté
utilizando
grupo
fanáticos
pichones
esté
conectada
administradora
sistema
casos
usuario
acceso
archivos
importar
grupo
es-
té
utilizando
momento
manejar
caso
introducir
concepto
comodín
representa
usuarios
ejemplo
entrada
tana
RW
archivo
contraseñas
proporciona
acceso
Tana
importar
grupo
encuentre
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
627
posibilidad
usuario
pertenece
cualquiera
grupos
tengan
cier-
tos
permisos
acceso
permite
acceso
ventaja
usuario
pertenezca
va-
rios
grupos
especificar
grupo
momento
iniciar
sesión
grupos
válidos
momento
desventaja
método
encapsu-
lamiento
Tana
editar
archivo
contraseñas
reunión
club
pichones
utilizar
grupos
comodines
introduce
posibilidad
bloquear
selectiva
usuario
específico
evitar
acceda
archivo
ejemplo
entrada
virgil
none
RW
proporciona
Virgil
acceso
lectura
escritura
archivo
funciona
de-
bido
entradas
exploran
orden
toma
aplique
entradas
sub-
siguientes
siquiera
examinan
coincidencia
Virgil
entrada
aplican
derechos
acceso
encontrados
caso
none
bús-
queda
termina
punto
resto
mundo
acceso
siquiera
con-
sidera
lidiar
grupos
entradas
ACL
consistan
pares
UID
GID
entrada
UID
GID
ejemplo
entrada
archivo
pichones_data
debbie
RW
phil
RW
fanpichones
RW
significa
Debbie
Phil
miembros
grupo
fanpichones
acceso
lectura
escritura
archivo
sucede
usuario
grupo
permisos
ar-
chivo
posteriormente
propietario
archivo
desea
revocar
permisos
listas
control
acceso
sencillo
revocar
acceso
otorgado
editar
ACL
cambio
obstante
ACL
revisa
abre
archivo
probable
cambio
efecto
únicamente
futuras
llamadas
open
archivo
encuentre
abierto
seguirá
derechos
abrió
usuario
autorizado
utilizarlo
9.3.3
Capacidades
dividir
matriz
figura
9-6
filas
utilizar
método
pro-
ceso
asocia
lista
objetos
utilizar
indicación
operacio-
nes
permitidas
objeto
palabras
dominio
lista
conoce
lista
capacidades
lista-C
elementos
individuales
contiene
conoce
capacida-
des
Dennis
Horn
1966
Fabry
1974
figura
9-9
muestra
conjunto
pro-
cesos
listas
capacidades
capacidad
otorga
propietario
derechos
objeto
ejemplo
figu-
ra
9-9
proceso
pertenece
usuario
leer
archivos
F1
F2
general
capacidad
consiste
identificador
archivo
objeto
sentido
general
mapa
bits
diversos
permisos
sistema
UNIX
identificador
archivo
proba-
www.FreeLibros.meblemente
número
nodo-i
listas
capacidades
objetos
listas
ca-
pacidades
apuntar
facilita
acción
compartir
subdominios
obvio
debemos
proteger
listas
capacidades
usuarios
quie-
ran
alterarlas
métodos
protegerlas
requiere
arquitectura
etiqueta-
diseño
hardware
palabra
memoria
bit
adicional
etiqueta
indica
palabra
contiene
capacidad
bit
etiqueta
utiliza
instruccio-
nes
aritméticas
comparación
instrucciones
ordinarias
similares
programas
ejecutan
kernel
sistema
operativo
modificarlo
construido
máquinas
arquitectura
etiquetada
funcionar
Feustal
1972
IBM
AS/400
ejemplo
popular
método
mantener
lista-C
sistema
operativo
referencia
capacidades
base
posición
lista
proceso
Leer
KB
ar-
chivo
apunta
capacidad
forma
direccionamiento
similar
des-
criptores
archivos
UNIX
Hydra
Wulf
colaboradores
1974
trabajaba
forma
tercer
método
mantener
lista-C
espacio
usuario
administrar
capacidades
criptográfica
forma
usuarios
puedan
alterarlas
método
adapta
especial
sistemas
distribuidos
funciona
proceso
clien-
envía
mensaje
servidor
remoto
ejemplo
servidor
archivos
crear
ob-
jeto
servidor
crea
objeto
genera
número
aleatorio
extenso
campo
comprobación
corresponda
reserva
posición
tabla
archivos
servidor
objeto
campo
comprobación
almacena
servidor
nodo-i
envía
vuelta
usuario
pone
red
servidor
genera
devuelve
capacidad
usuario
forma
muestra
figura
9-10
capacidad
devuelve
usuario
contiene
identificador
servidor
número
objeto
índice
tablas
servidor
número
nodo-i
derechos
al-
macenado
mapa
bits
objeto
recién
creado
encienden
bits
per-
misos
propietario
campo
consiste
628
SEGURIDAD
CAPÍTULO
Proceso
Propietario
F1
F1
F2
F1
F2
RW
F3
RWX
F2
F3
RXF2
F3
Espacio
usuario
Espacio
kernel
Lista-C
Figura
9-9
utilizan
capacidades
proceso
lista
capacidades
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
629
concatenación
objeto
permisos
campo
comprobación
pasan
función
vía
criptográficamente
segura
tipo
vimos
usuario
desea
acceder
objeto
envía
capacidad
servidor
pe-
tición
servidor
extrae
número
objeto
indexarlo
tablas
encontrar
objeto
calcula
f(Objeto
Permisos
Comprobación
toma
pa-
rámetros
capacidad
tablas
resultado
coincide
cuarto
campo
capacidad
respeta
petición
caso
contrario
rechaza
usuario
tra-
ta
acceder
objeto
alguien
fabricar
cuarto
campo
correctamente
conoce
campo
comprobación
petición
rechaza
usuario
pedir
servidor
produzca
capacidad
débil
ejemplo
acceso
lectura
servidor
verifica
capacidad
válida
calcula
Objeto
Nuevos_permisos
Comprobación
genera
capacidad
coloca
valor
cuarto
campo
Observe
utiliza
valor
original
Comprobación
capacida-
des
destacadas
dependen
capacidad
envía
vuelta
proceso
petición
usuario
pue-
proporcionarla
amigo
enviarla
mensaje
amigo
enciende
bits
per-
misos
apagados
servidor
detectará
utilice
capacidad
valor
corresponderá
campo
permisos
falsos
amigo
conoce
ver-
dadero
campo
comprobación
fabricar
capacidad
corresponda
bits
permisos
falsos
esquema
desarrolló
sistema
Amoeba
Tanenbaum
colaboradores
1990
derechos
específicos
dependientes
objeto
lectura
ejecución
ca-
pacidades
protegen
kernel
criptografía
general
permisos
gené-
ricos
aplicar
objetos
ejemplos
permisos
genéricos
Capacidad
copia
crea
capacidad
objeto
Copiar
objeto
crea
objeto
duplicado
capacidad
Eliminar
capacidad
elimina
entrada
lista-C
objeto
ve
afectado
Destruir
objeto
elimina
objeto
capacidad
permanente
comentario
vale
pena
sistemas
capacidades
difícil
revocar
acceso
objeto
versión
administrada
kernel
difícil
sis-
tema
encontrar
capacidades
destacadas
objeto
quitárselas
almacenadas
listas-C
disco
método
capacidad
apunte
objeto
indirecto
apunte
objeto
objeto
indirecto
apunte
Servidor
Objeto
Permisos
f(Objetos
Permisos
Comprobación
Figura
9-10
capacidad
protegida
criptografía
www.FreeLibros.meal
objeto
real
sistema
interrumpir
conexión
invalidan
capa-
cidades
presente
sistema
capacidad
objeto
indirecto
usuario
descubrirá
objeto
indirecto
apunta
objeto
nulo
esquema
Amoeba
fácil
revocar
permisos
cambiar
campo
comprobación
almacenado
objeto
golpe
invalidan
capaci-
dades
existentes
esquema
permite
revocación
selectiva
quitar
permiso
John
general
reconoce
defecto
proble-
ma
sistemas
capacidades
problema
general
asegurar
usuario
capacidad
válida
proporcione
copia
1000
mejores
amigos
problema
resuelve
kernel
administre
capacidades
Hydra
solución
funciona
sistema
distribuido
co-
mo
Amoeba
resumen
ACLs
capacidades
propiedades
complementan
for-
ma
capacidades
eficientes
proceso
Abrir
archivo
apun-
ta
capacidad
necesita
comprobación
ACLs
requiera
búsqueda
potencialmente
extensa
ACL
aceptan
grupos
otorgar
permiso
lectura
archivo
requiere
enumerar
usuarios
ACL
capa-
cidades
permiten
encapsular
proceso
facilidad
ACLs
ACLs
permiten
revocación
selectiva
permisos
capacidades
elimina
objeto
dejan
capacidades
eliminan
capacidades
deja
objeto
surgen
problemas
ACLs
sufren
problema
9.3.4
Sistemas
confiables
noticias
leer
tiempo
virus
gusanos
problemas
persona
ingenua
lógica
preguntas
cosas
construir
sistema
computacional
seguro
respuesta
pregunta
básicamente
décadas
conoce
forma
construir
sistema
seguro
ejemplo
sistema
MULTICS
diseñó
década
1960
seguridad
objetivos
principales
logró
cuestión
construyendo
sistemas
seguros
complicada
resume
razones
fundamentales
lugar
sistemas
actuales
seguros
usuarios
desean
descartarlos
Microsoft
anunciara
Windows
nue-
vo
producto
llamado
SOSeguro
resistente
virus
ejecute
aplicaciones
Win-
dows
probable
personas
empresas
dejen
utilizar
Windows
compren
sistema
inmediato
Microsoft
SO
seguro
Fandrich
co-
laboradores
2006
comercializa
630
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
631
cuestión
sutil
única
forma
conocida
construir
sistema
seguro
mantenerlo
simple
características
enemigas
seguridad
diseñadores
sistemas
creen
equivocados
usuarios
quieren
características
significa
complejidad
código
errores
errores
seguridad
ejemplos
simples
sistemas
correo
electrónico
enviaban
mensajes
forma
texto
ASCII
completamente
seguros
mensaje
en-
trante
código
ASCII
dañar
sistema
cómputo
personas
tuvieron
idea
expandir
correo
electrónico
incluir
tipos
documentos
ejemplo
archivos
Word
contener
programas
macros
Leer
documento
tipo
significa
eje-
cutar
programa
alguien
computadora
importa
cajas
arena
utilicen
ejecutar
programa
externo
computadora
peligroso
texto
ASCII
Exigieron
usuarios
habilidad
cambiar
correo
electrónico
enviara
programas
activos
documentos
pasivos
Probablemente
diseñadores
sistemas
creye-
ron
idea
ingeniosa
preocuparse
implicaciones
seguridad
ejemplo
páginas
Web
servicio
Web
consistía
pági-
nas
HTML
pasivas
imponía
problema
grave
seguridad
páginas
Web
contienen
programas
applets
usuario
ejecutar
contenido
aparece
fuga
seguridad
corrige
toma
lugar
servicio
Web
completamente
estático
usuarios
demandaban
contenido
dinámico
autor
recuerda
introducción
contenido
dinámico
trajo
múltiples
problemas
seguridad
vicepresidente
cargo
estuviera
dormido
si-
llón
realidad
organizaciones
piensan
importante
seguri-
dad
características
ingeniosas
militares
ejemplo
principal
siguien-
tes
secciones
analizaremos
cuestiones
involucradas
sintetizar
enunciado
construir
sistema
seguro
modelo
seguridad
nú-
cleo
sistema
operativo
simple
diseñadores
puedan
com-
prenderlo
resistan
presión
desviarse
modelo
agregar
características
9.3.5
Base
cómputo
confiable
mundo
seguridad
frecuencia
sistemas
confiables
sistemas
seguros
sistemas
declarado
formalmente
requerimientos
seguridad
cumplen
centro
sistema
confiable
TCB
Trusted
Computing
Base
Base
cómputo
confiable
mínima
consiste
hardware
software
necesarios
cumplir
reglas
seguridad
base
cómputo
confiable
funciona
especificacio-
nes
comprometer
seguridad
sistema
importar
cosa
esté
general
TCB
consiste
mayoría
hardware
dispositivos
afectan
seguridad
porción
kernel
sistema
operativo
mayoría
pro-
gramas
usuario
superusuario
ejemplo
programas
raíz
SETUID
UNIX
funciones
sistema
operativo
formar
TCB
creación
pro-
cesos
cambio
procesos
administración
mapa
memoria
administración
www
FreeLibros.me632
SEGURIDAD
CAPÍTULO
archivos
S.
diseño
seguro
frecuente
TCB
esté
separada
resto
sistema
operativo
minimizar
tamaño
verificar
correcto
monitor
referencia
importante
TCB
muestra
figura
9-11
monitor
referencia
acepta
llamadas
sistema
relacionadas
seguridad
abrir
archivos
decide
procesar
ende
monitor
referencia
permite
decisiones
seguridad
coloquen
lugar
posibilidad
pasarlo
alto
mayoría
sistemas
operativos
diseñados
forma
razones
inseguros
Proceso
usuario
llamadas
sistema
pasan
monitor
referencia
comprobar
seguridad
Monitor
referencia
Base
cómputo
confiable
Kernel
sistema
operativo
Espacio
usuario
Espacio
kernel
Figura
9-11
monitor
referencia
objetivos
investigación
actual
seguridad
reducir
base
cómputo
confiable
millones
líneas
código
decenas
miles
figura
1-26
vimos
estructura
sistema
operativo
MINIX
sistema
conforma
POSIX
estructura
radicalmente
distinta
Linux
FreeBSD
MINIX
ejecutan
4000
líneas
código
kernel
ejecuta
conjunto
procesos
usuario
procesos
sistema
archivos
administrador
procesos
forman
base
cómputo
confiable
comprometer
fa-
cilidad
seguridad
sistema
partes
driver
impresora
driver
audio
forman
base
cómputo
confiable
importa
problema
virus
apodera
comprometer
seguridad
sis-
tema
reducir
base
cómputo
confiable
órdenes
magnitud
sistemas
MI-
NIX
ofrecer
potencia
seguridad
diseños
convencionales
9.3.6
Modelos
formales
sistemas
seguros
matrices
protección
figura
9-5
estáticas
Cambian
frecuencia
me-
dida
crean
objetos
objetos
antiguos
destruyen
propietarios
deciden
aumentar
restringir
conjunto
usuarios
objetos
puesto
atención
modelado
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
633
sistemas
protección
matriz
protección
cambia
constante
Aho-
ra
daremos
vistazo
trabajo
décadas
Harrison
colaboradores
1976
identificaron
operaciones
primi-
tivas
matriz
protección
utilizar
base
modelar
sistema
protección
operaciones
primitivas
create
object
delete
object
create
domain
de-
lete
domain
insert
righty
remove
right
primitivas
insertan
eliminan
permisos
elementos
específicos
matriz
otorgar
dominio
permiso
leer
Archivo6
primitivas
combinar
comandos
protección
programas
usuario
ejecutar
comandos
protección
cambiar
matriz
ejecutar
primiti-
vas
forma
directa
ejemplo
sistema
comando
crear
archivo
realizaría
prueba
archivo
caso
contrario
crearía
objeto
proporcionaría
propietario
permisos
comando
per-
mitir
usuario
otorgar
permiso
leer
archivo
usuarios
sistema
efec-
to
insertaría
permiso
lectura
entrada
archivo
dominios
instante
matriz
determina
proceso
domi-
nio
autorizado
matriz
sistema
cumplir
autorización
relacionada
directiva
administración
ejemplo
distinción
consideremos
sistema
simple
figura
9-12
dominios
corresponden
usuarios
figu-
ra
9-12(a
directiva
protección
deseada
Henry
leer
escribir
bandeja-
correo7
Robert
leer
escribir
secreto
usuarios
leer
ejecutar
compilador
Compilador
Bandejacorreo7
Objetos
Secreto
Lectura
Ejecución
Lectura
Ejecución
Lectura
Escritura
Lectura
Ejecución
Lectura
Escritura
Eric
Henry
Robert
Compilador
Bandejacorreo7
Objetos
Secreto
Lectura
Ejecución
Lectura
Ejecución
Lectura
Escritura
LecturaLectura
Ejecución
Lectura
Escritura
Eric
Henry
Robert
Figura
9-12
autorizado
autorizado
imagine
Robert
listo
descubierto
emitir
comandos
cambiar
matriz
figura
9-12(b
acceso
bandejacorreo7
al-
go
autorizado
leer
archivo
sistema
operativo
llevará
ca-
bo
petición
figura
9-12(b
autorizado
conjunto
matrices
posibles
particionar
conjuntos
desunidos
conjunto
autorizados
conjunto
es-
tados
autorizados
pregunta
girado
investigación
teórica
www.FreeLibros.meun
inicial
autorizado
conjunto
comandos
probar
sistema
po-
drá
llegar
autorizado
efecto
preguntando
mecanismo
disponible
comandos
protección
adecuado
implementar
directiva
protección
Dada
directiva
inicial
matriz
conjunto
comandos
modificarla
conveniente
forma
probar
sistema
seguro
Dicha
prueba
resulta
difícil
adquirir
sistemas
propósi-
to
general
seguros
teoría
Harrison
colaboradores
1976
demostraron
ca-
so
configuración
arbitraria
sistema
protección
arbitrario
establecer
seguridad
teórica
sistema
específico
demostrar
sistema
pasar
momento
autorizado
autorizado
Pa-
ra
obtener
información
consulte
Landwehr
1981
9.3.7
Seguridad
multinivel
mayoría
sistemas
operativos
permiten
usuarios
individuales
determinar
leer
escribir
archivos
objetos
directiva
conoce
control
ac-
ceso
discrecional
entornos
modelo
funciona
requiere
seguridad
estricta
computación
militar
departamentos
paten-
tes
corporativas
hospitales
entornos
organización
establecido
reglas
soldados
abogados
doctores
modificar
re-
glas
obtener
permiso
especial
jefe
entornos
necesitan
con-
troles
acceso
obligatorio
asegurar
sistema
implemente
directivas
seguridad
establecidas
controles
acceso
discrecional
estándar
controles
acceso
obligatorio
regular
flujo
información
asegurar
fugue
ma-
nera
esté
considerada
modelo
Bell-La
Padula
modelo
seguridad
multinivel
utilizado
mundo
modelo
Bell-La
Padula
empezaremos
Bell
Padula
1973
modelo
diseñó
manejar
seguri-
dad
militar
aplicar
organizaciones
mundo
militar
docu-
mentos
objetos
nivel
seguridad
clasificado
confidencial
secreto
alta
confidencialidad
personas
asignan
niveles
dependiendo
documentos
puedan
general
permiso
documentos
mien-
teniente
restringir
documentos
clasificados
confidencia-
nivel
menor
seguridad
proceso
ejecute
beneficio
usuario
adquiere
nivel
seguridad
usuario
niveles
seguridad
esquema
co-
noce
sistema
seguridad
multinivel
modelo
Bell-La
Padula
reglas
forma
fluir
información
propiedad
seguridad
simple
proceso
ejecuta
nivel
seguridad
leer
objetos
estén
nivel
menor
ejemplo
general
pue-
634
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
635
leer
documentos
teniente
teniente
leer
documentos
general
propiedad
proceso
ejecuta
nivel
seguridad
escribir
ob-
jetos
nivel
ejemplo
teniente
adjuntar
mensaje
bandeja
correo
general
decirle
general
ad-
juntar
mensaje
bandeja
correo
teniente
decirle
general
visto
documentos
alta
confidencialidad
di-
vulgar
teniente
síntesis
procesos
leer
niveles
menores
escribir
niveles
mayores
revés
sistema
implementa
rigor
propiedades
demostrar
fuga
información
nivel
seguridad
alto
propiedad
de-
nominó
informe
original
autores
podían
idear
nombre
utilizaron
receptáculo
temporal
pudieran
idear
nombre
Nun-
ca
informe
imprimió
modelo
procesos
leen
escriben
ob-
jetos
comunican
directa
modelo
Bell-La
Padula
ilustra
gráfico
figura
9-13
43
Nivel
seguridad
Leyenda
Proceso
Objeto
Lectura
Escritura
Figura
9-13
modelo
seguridad
multinivel
Bell-La
Padula
figura
flecha
sólida
objeto
proceso
indica
proceso
leyen-
do
objeto
información
fluye
objeto
proceso
similar
flecha
punteada
proceso
objeto
indica
proceso
escribiendo
objeto
www
FreeLibros.me636
SEGURIDAD
CAPÍTULO
información
fluye
proceso
objeto
ende
información
fluye
dirección
flechas
ejemplo
proceso
leer
objeto
objeto
propiedad
seguridad
simple
establece
flechas
sólidas
lectura
ha-
cia
lados
propiedad
establece
flechas
punteadas
escritura
lados
información
fluye
forma
horizontal
información
empieza
nivel
aparecer
nivel
infe-
rior
palabras
ruta
mueva
información
abajo
ga-
rantiza
seguridad
modelo
modelo
Bell-La
Padula
referencia
estructura
organizacional
instan-
cia
sistema
operativo
implementarlo
asignar
ca-
usuario
nivel
seguridad
almacenar
datos
específicos
usuario
UID
GID
momento
iniciar
sesión
shell
usuario
adquiere
ni-
vel
seguridad
hijos
heredan
proceso
ejecuta
nivel
seguridad
abrir
archivo
objeto
cuyo
nivel
seguridad
sistema
opera-
tivo
rechazar
intento
apertura
intentos
similares
abrir
objeto
nivel
seguridad
menor
escribir
fallar
modelo
Biba
sintetizar
modelo
Bell-La
Padula
términos
militares
teniente
pedir
solda-
do
raso
revele
copiar
información
archivo
ge-
neral
violar
seguridad
usemos
modelo
términos
civiles
Imagine
empresa
conserjes
nivel
seguridad
programadores
nivel
seguridad
presidente
empresa
nivel
seguridad
mode-
Bell-La
Padula
programador
consultar
conserje
futuros
planes
empresa
sobrescribir
archivos
presidente
contengan
estrategia
corporativa
empresas
sentirían
entusiasmadas
modelo
problema
modelo
Bell-La
Padula
ideó
guardar
secretos
garan-
tizar
integridad
datos
necesitamos
precisamente
propiedades
inversas
Biba
1977
principio
integridad
simple
proceso
ejecuta
nivel
seguridad
só-
escribir
objetos
nivel
inferior
escrituras
propiedad
integridad
proceso
ejecute
nivel
seguridad
leer
objetos
nivel
superior
lecturas
abajo
conjunto
propiedades
aseguran
programador
actualizar
archivos
con-
serje
información
adquirida
presidente
viceversa
orga-
nizaciones
desean
propiedades
Bell-La
Padula
Biba
conflicto
directo
difícil
obtener
propiedades
modelos
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
637
9.3.8
Canales
encubiertos
ideas
modelos
formales
sistemas
definitivamente
seguros
suenan
realidad
funcionan
palabra
sistema
modelo
seguridad
sub-
yacente
demostrado
seguro
esté
implementado
forma
correcta
fugas
seguridad
sección
analizaremos
fuga
información
demostrado
rigor
dicha
fuga
matemáticamente
imposible
ideas
Lampson
1973
modelo
Lampson
formuló
originalmente
términos
sistema
tiempo
compartido
adaptar
ideas
LANs
entornos
multiusuario
forma
pura
implica
procesos
máquina
protegida
proceso
clien-
desea
servidor
realice
trabajo
cliente
servidor
confían
com-
pletamente
ejemplo
trabajo
servidor
ayudar
clientes
llenen
formularios
fiscales
clientes
preocupa
servidor
registre
secreto
datos
fi-
nancieros
ejemplo
mantener
lista
secreta
gana
ven-
der
lista
servidor
preocupa
clientes
traten
robar
valioso
programa
fiscal
tercer
proceso
colaborador
conspirando
servidor
robar
datos
confidenciales
clientes
general
colaborador
servidor
propiedad
mis-
ma
persona
procesos
muestran
figura
9-14
objeto
ejercicio
diseñar
sistema
imposible
proceso
servidor
filtre
proceso
colaborador
informa-
ción
recibido
legítima
proceso
cliente
problema
Lampson
llamó
problema
confinamiento
Cliente
Servidor
Colaborador
Kernel
Kernel
Servidor
encapsulado
Canal
encubierto
Figura
9-14
procesos
cliente
servidor
colaborador
servidor
encap-
sulado
seguir
filtrando
información
colaborador
canales
en-
cubiertos
punto
vista
diseñador
objetivo
encapsular
confinar
servidor
for-
ma
pasar
información
colaborador
esquema
matriz
protección
garantizar
facilidad
servidor
comunicar
colabo-
rador
escritura
archivo
colaborador
acceso
lectura
pro-
bable
podamos
asegurar
servidor
comunicar
colaborador
mecanismo
comunicación
procesos
sistema
www
FreeLibros.mePor
desgracia
existir
canales
comunicación
sutiles
ejemplo
ser-
vidor
tratar
comunicar
flujo
bits
binario
enviar
bit
realiza
cálculos
intervalo
fijo
enviar
bit
permanece
inactivo
cantidad
tiempo
colaborador
tratar
detectar
flujo
bits
monitorear
cuidadosamente
tiem-
po
respuesta
general
obtendrá
respuesta
servidor
envíe
cuan-
do
envíe
canal
comunicación
conoce
canal
encubierto
ilustra
figura
9-14(b
canal
encubierto
canal
ruidoso
contiene
información
ex-
traña
enviar
confiable
canal
ruidoso
utiliza
có-
digo
corrección
errores
ejemplo
código
Hamming
inclusive
sofisticado
utilizar
código
corrección
errores
reduce
ancho
banda
canal
encubierto
formas
suficiente
filtrar
cantidad
considerable
información
obvio
modelo
protección
basado
ma-
triz
objetos
dominios
evitar
tipo
fuga
modulación
CPU
único
canal
encubierto
velocidad
pagina-
ción
modular
fallos
página
fallo
página
forma
degradar
rendimiento
sistema
sin-
cronizada
candidato
sistema
proporciona
forma
bloquear
archivos
en-
tonces
servidor
bloquear
archivo
indicar
desbloquearlo
indicar
sistemas
proceso
detecte
bloqueo
archivo
utilizar
canal
encubierto
muestra
figura
9-15
archivo
bloquea
desbloquea
intervalo
fijo
conocido
servidor
pa-
ra
colaborador
ejemplo
transmitiendo
flujo
bits
secreto
11010100
638
SEGURIDAD
CAPÍTULO
Servidor
servidor
bloquea
archivo
enviar
Tiempo
Colaborador
servidor
desbloquea
archivo
enviar
Flujo
bits
enviando
Figura
9-15
canal
encubierto
utiliza
bloqueo
archivos
Bloquear
desbloquear
archivo
preparado
anticipación
canal
especialmente
ruidoso
requiere
sincronización
precisa
velocidad
bits
baja
confiabilidad
rendimiento
incrementar
utiliza
www
FreeLibros.meSECCIÓN
9.3
MECANISMOS
PROTECCIÓN
639
protocolo
reconocimiento
protocolo
utiliza
archivos
F1
F2
bloqueados
servidor
colaborador
respectivamente
mantener
procesos
sincronizados
servidor
bloquea
desbloquea
cambia
bloqueo
F1
indicar
enviado
bit
colaborador
lee
bit
cambia
bloqueo
F2
pa-
ra
indicar
servidor
listo
recibir
bit
espera
cambia
blo-
queo
F1
indicar
bit
presente
S.
protocolo
confiable
requiere
sincronización
inclusive
sistema
ocupado
proceder
tanta
rapidez
co-
mo
puedan
programar
procesos
obtener
ancho
banda
alto
utilizamos
archivos
bit
creamos
canal
anchura
byte
archivos
señalización
S0
S7
adquisición
liberación
recursos
dedicados
unidades
cinta
plotters
ejem-
plo
utilizar
señalización
servidor
adquiere
recurso
enviar
libera
enviar
UNIX
servidor
crear
archivo
indicar
eli-
minarlo
indicar
colaborador
utilizar
llamada
sistema
accesspara
archivo
llamada
funciona
colaborador
permiso
archi-
vo
desgracia
canales
encubiertos
Lampson
forma
filtrar
información
propietario
humano
pro-
ceso
servidor
supone
proceso
servidor
derecho
indicar
propietario
cuán-
to
trabajo
cliente
cobrarle
factura
cálculo
100
ejemplo
ingreso
cliente
53,000
servidor
reportar
factura
100.53
propietario
difícil
encontrar
canales
encubiertos
difícil
blo-
quearlos
práctica
acción
introducir
proceso
produz-
ca
fallos
página
azar
invierta
tiempo
forma
degrade
rendimiento
sistema
reducir
ancho
banda
canales
encubiertos
proposición
atractiva
Esteganografía
utilizar
tipo
ligeramente
distinto
canal
encubierto
pasar
información
secreta
en-
tre
procesos
humano
censor
automatizado
inspeccionar
mensajes
procesos
vetar
sospechosos
ejemplo
considere
empresa
comprueba
forma
manual
correo
electrónico
saliente
envían
empleados
pa-
ra
asegurar
estén
filtrando
secretos
cómplices
competidores
empresa
forma
empleado
contrabandee
volúmenes
considerables
información
confidencial
justo
nariz
censor
Resulta
Considere
figura
9-16(a
ejemplo
fotografía
tomó
autor
Ke-
nya
contiene
cebras
contemplan
árbol
figura
9-16(b
cebras
árbol
acacia
atracción
adicional
Contiene
texto
íntegro
obras
Shakespeare
Hamlet
Rey
Lear
Macbeth
mercader
Veneciay
Julio
Cé-
sar
conjunto
obras
contienen
700
KB
texto
www
FreeLibros.me¿Cómo
funciona
canal
encubierto
imagen
color
original
1024
/H11003768
pixeles
pixel
consiste
números
bits
intensidad
color
rojo
verde
azul
pixel
color
píxel
forma
superposición
lineal
colores
mé-
codificación
utiliza
bit
menor
orden
valor
color
RGB
canal
encu-
bierto
píxel
espacio
bits
información
secreta
valor
rojo
valor
verde
valor
azul
imagen
tamaño
almacenar
has-
ta
1024
/H11003768
/H110033
bits
294,912
bytes
información
secreta
texto
completo
obras
aviso
corto
suman
734,891
bytes
comprimió
cerca
274
KB
algoritmo
compresión
estándar
resultado
comprimido
cifró
insertó
bits
menor
orden
valor
color
Co-
mo
realidad
existencia
información
completamente
in-
visible
invisible
versión
color
foto
ojo
distinguir
facilidad
color
bits
color
bits
archivo
imagen
logra
burlar
cen-
sor
receptor
extrae
bits
menor
orden
aplica
algoritmos
cifrado
des-
compresión
recupera
734,891
bytes
originales
proceso
ocultar
existencia
información
conoce
esteganografía
palabras
griegas
escri-
tura
encubierta
esteganografía
popular
dictaduras
tratan
restringir
co-
municación
ciudadanos
popular
personas
creen
firmemente
libertad
expresión
imágenes
blanco
negro
baja
resolución
realidad
justicia
expresar
técnica
lector
idea
concisa
for-
ma
funciona
esteganografía
autor
preparado
demostración
incluyendo
ima-
gen
color
figura
9-16(b
obras
incrustadas
demostración
www.cs.vu.nl/~ast
Haga
clic
vínculo
covered
writing
sección
STEGANOGRAPHY
DEMO
siga
instrucciones
página
descargar
imagen
herramientas
esteganografía
necesarias
extraer
obras
640
SEGURIDAD
CAPÍTULO
Figura
9-16
cebras
árbol
cebras
árbol
texto
completo
obras
William
Shakespeare
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
641
usos
esteganografía
insertar
marcas
agua
ocultas
imáge-
nes
utilizan
páginas
Web
detectar
robo
reutilizarlas
páginas
Web
página
Web
contiene
imagen
mensaje
secreto
Copyright
2008
General
Images
Corporation
problemas
convencer
juez
produjo
imagen
aplicar
marcas
agua
música
películas
tipos
materiales
marcas
agua
utilicen
forma
anima
cier-
tas
personas
buscar
maneras
quitarlas
vencer
esquema
almacena
información
bits
menor
orden
píxel
gira
imagen
grado
sentido
favor
ma-
necillas
reloj
convierte
sistema
pérdidas
JPEG
gira
grado
sentido
contrario
imagen
volver
convertir
sistema
co-
dificación
original
gif
bmp
tif
conversión
JPEG
pérdidas
desordenará
bits
menor
orden
giros
requieren
cálculos
punto
flotante
introducen
errores
redondeo
agregan
ruido
bits
menor
orden
personas
ponen
mar-
cas
agua
deberían
saberlo
colocan
información
copyright
redundante
utilizan
esquemas
bits
menor
orden
píxeles
estimula
atacantes
busquen
mejores
técnicas
remoción
acaba
9.4
AUTENTICACIÓN
sistema
computacional
seguro
requerir
usuarios
autentiquen
momen-
to
iniciar
sesión
sistema
operativo
seguro
usuario
archivos
recursos
acceder
autentica-
ción
parecer
tema
trivial
complicado
esperar
Siga
le-
yendo
autenticación
usuarios
cosas
queríamos
expresar
on-
togenia
recapitula
filogenia
sección
1.5.7
primeras
mainframes
ENIAC
te-
nían
sistema
operativo
procedimiento
inicio
sesión
posteriores
sistemas
mainframe
procesamiento
lotes
tiempo
compartido
tenían
general
pro-
cedimiento
inicio
sesión
autenticar
trabajos
usuarios
primeras
minicomputadoras
ejemplo
PDP-1
PDP-8
tenían
procedimiento
inicio
sesión
esparcimiento
UNIX
minicomputadora
PDP-11
necesario
primeras
computadoras
personales
ejemplo
Apple
II
IBM
PC
ori-
ginal
tenían
procedimiento
inicio
sesión
sistemas
operativos
computado-
ra
personal
sofisticados
Linux
Windows
Vista
usuarios
imprudentes
deshabilitar
máquinas
LANs
corporativas
configurado
procedimiento
inicio
sesión
usuarios
puedan
evitar
personas
inician
sesión
indirecta
computadoras
re-
motas
operaciones
bancarias
Internet
compras
electrónicas
descargar
música
actividades
comerciales
actividades
requieren
inicio
sesión
autenticado
autenticación
usuarios
tema
importante
www
FreeLibros.meHabiendo
determinado
autenticación
importante
paso
en-
contrar
funcione
mayoría
métodos
autenticar
usua-
rios
tratan
iniciar
sesión
basan
principios
generales
identifican
usuario
conoce
usuario
usuario
requieren
principios
seguridad
adicional
principios
producen
distintos
esquemas
autenticación
distintas
complejidades
propiedades
seguri-
dad
siguientes
secciones
examinaremos
orden
personas
desean
ocasionar
problemas
sistema
particular
iniciar
sesión
sistema
pasar
procedimiento
autenticación
utilice
prensa
popular
personas
conoce
hackers
mundo
computadoras
palabra
hacker
término
honorario
reserva
programadores
granujas
prensa
equivocó
caso
diferenciar
verdaderos
hackers
utilizaremos
término
sen-
tido
original
personas
tratan
irrumpir
sistemas
computacionales
pertenecen
llamaremos
crackers
personas
hackers
sombrero
blanco
referirse
tipos
hackers
sombrero
negro
referirse
tipos
malos
base
experiencia
mayoría
hackers
permanecen
interior
tiempo
utilizan
sombreros
diferenciar
9.4.1
Autenticación
contraseñas
forma
utilizada
autenticación
requerir
usuario
escriba
nombre
inicio
sesión
contraseña
protección
contraseñas
fácil
comprender
imple-
mentar
implementación
simple
mantiene
lista
central
pares
nombre-inicio-
sesión
contraseña
nombre
inicio
sesión
introduce
busca
lista
contra-
seña
introducida
compara
contraseña
almacenada
coinciden
permite
usuario
inicie
sesión
caso
contrario
rechaza
necesidad
escribe
contraseña
computadora
mostrar
caracteres
escritos
evitar
alguien
cercano
monitor
vea
Windows
medida
escribe
carácter
aparece
asterisco
UNIX
aparece
carácter
medida
escribe
contraseña
esquemas
distintas
propiedades
es-
quema
Windows
servir
usuarios
distraídos
vean
fácilmente
caracte-
res
escrito
momento
divulga
longitud
contraseña
fisgones
perspectiva
seguridad
silencio
oro
área
implicaciones
graves
realiza
trabajo
mues-
tra
figura
9-17
figura
9-17(a
muestra
inicio
sesión
exitoso
salida
642
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
643
sistema
mayúsculas
entrada
usuario
minúsculas
figura
9-17(b
muestra
intento
fallido
cracker
iniciar
sesión
Sistema
A.
figura
9-17(c
muestra
intento
fallido
cracker
iniciar
sesión
Sistema
B.
USUARIO
mitch
CONTRASEÑA
FooBar!-7
INICIO
SESION
EXITOSO
Figura
9-17
inicio
sesión
exitoso
rechaza
inicio
sesión
introducir
nombre
rechaza
inicio
sesión
escribir
nom-
bre
contraseña
figura
9-17(b
sistema
queja
ve
nombre
inicio
sesión
in-
válido
error
permite
cracker
seguir
probando
nombres
inicio
sesión
has-
ta
válido
figura
9-17(c
cracker
pide
contraseña
recibe
pista
nombre
inicio
sesión
válido
aprende
combinación
nombre
inicio
sesión
contraseña
incorrecta
observación
adicional
inicio
sesión
mayoría
computadoras
note-
book
configuran
requerir
nombre
usuario
contraseña
conte-
nido
esté
protegido
caso
pierdan
robadas
Cualquiera
apodere
notebook
iniciarla
inmediato
programa
configuración
BIOS
oprimiendo
SUPR
F8
tecla
específica
BIOS
general
aparece
pantalla
inicie
sistema
operativo
modificar
secuencia
arranque
computadora
arranque
me-
moria
USB
intentar
disco
duro
saboteador
inserta
memoria
USB
contenga
sistema
operativo
completo
arranca
computadora
eje-
cución
disco
duro
montar
UNIX
utilizar
unidad
Windows
evi-
tar
situación
mayoría
BIOS
permiten
usuario
proteja
programa
configuración
contraseña
propietario
cambiar
secuencia
arranque
computadora
notebook
deje
leer
momento
pon-
ga
contraseña
BIOS
regrese
entran
fuerza
crackers
entrar
fuerza
mayoría
crackers
conectan
computadora
destino
ejem-
plo
Internet
prueban
combinaciones
nombre
usuario
contraseña
encuentran
funciona
personas
utilizan
nombre
forma
nombre
inicio
sesión
Ellen
Ann
Smith
candidatos
razonables
ellen
smith
ellen_smith
ellen-smith
ellen.smith
emith
easmith
eas
libros
ti-
USUARIO
carol
NOMBRE
USUARIO
INVALIDO
USUARIO
USUARIO
carol
CONTRASEÑA
yonose
INICIO
SESION
INVALIDO
USUARIO
www
FreeLibros.me644
SEGURIDAD
CAPÍTULO
tulado
4096
nombres
bebé
agenda
telefónica
llena
apellidos
cracker
compilar
facilidad
lista
computarizada
nombres
inicio
potenciales
apropiados
país
atacar
ellen_smith
funcionar
Unidos
Inglate-
rra
Japón
basta
adivinar
nombre
inicio
sesión
adivinar
contraseña
difícil
fácil
creer
Morris
Thompson
1979
realizaron
trabajo
clásico
seguridad
contraseñas
sistemas
UNIX
Compilaron
lista
contraseñas
probables
nombres
apellidos
nombres
calles
nombres
ciudades
pa-
labras
diccionario
tamaño
moderado
palabras
deletreadas
inversa
números
placas
automóviles
cadenas
cortas
caracteres
aleatorios
compararon
lista
archivo
contraseñas
sistema
coincidencias
Cerca
86%
contrase-
ñas
aparecieron
lista
Klein
1990
obtuvo
resultado
similar
alguien
piense
usuarios
calidad
eligen
contraseñas
ca-
lidad
seguridad
1997
encuesta
contraseñas
utilizadas
distrito
financiero
Londres
reveló
82%
podían
adivinar
facilidad
contraseñas
común
términos
sexuales
expresiones
abusivas
nombres
personas
miembro
familiar
deportista
famoso
destinos
vacacionar
objetos
comunes
oficina
Kabay
1997
cracker
compilar
lista
nombres
potenciales
ini-
cio
sesión
lista
contraseñas
potenciales
trabajo
crecimiento
Web
empeorado
problema
con-
traseña
personas
docena
difícil
recordarlas
tienden
elegir
contraseñas
simples
débiles
reutilizan
sitios
Web
Florencio
Herley
2007
Gaw
Felten
2006
Realmente
importa
contraseñas
fáciles
adivinar
Definitivamente
1998
pe-
riódico
San
Jose
Mercury
News
reportó
residente
Berkeley
llamado
Peter
Shipley
configurado
computadoras
war
dialers
marcaban
10,000
números
telefónicos
pertenecían
central
telefónica
ejemplo
415
770-xxxx
general
orden
aleatorio
frustrar
compañías
telefónicas
reprueban
traten
de-
tectarlo
2.6
millones
llamadas
localizó
20,000
computadoras
área
bahía
200
tenían
tipo
seguridad
Peter
estimó
cracker
deter-
minado
irrumpir
75%
computadoras
Denning
1999
época
Periodo
Jurásico
computadora
marcar
2.6
millones
núme-
ros
telefónicos
crackers
California
cracker
australiano
trató
sistemas
irrumpió
computadora
Citibank
Arabia
Saudita
permitió
obtener
números
tarjetas
crédito
límites
crédito
caso
millones
re-
gistros
transacciones
incluyendo
visita
burdel
crackers
colegas
irrumpió
banco
recolectó
4000
números
tarjetas
crédito
Denning
1999
utilizara
dicha
información
malicia
banco
duda
negaría
énfasis
vigor
pudie-
ra
falla
afirmaría
cliente
debió
divulgado
información
crackers
Internet
regalo
Dios
elimina
aspectos
tediosos
trabajo
necesidad
marcar
números
telefónicos
war
dialing
funciona
computadora
Internet
dirección
IP
32
bits
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
645
utiliza
identificarla
general
personas
escriben
direcciones
notación
deci-
puntos
w.x.y.z
componentes
dirección
IP
entero
255
decimal
cracker
probar
facilidad
computadora
tie-
ne
dirección
IP
funcionando
comando
ping
w.x.y.z
shell
símbolo
sistema
computadora
viva
responderá
programa
ping
indi-
cará
tiempo
duró
viaje
redondo
milisegundos
sitios
deshabili-
comando
ping
evitar
tipo
ataque
fácil
escribir
programa
ping
números
direcciones
IP
sistemática
parecido
hacía
war
dialer
computadora
encendida
w.x.y.z
cracker
tratar
entrar
me-
diante
comando
telnet
w.x.y.z
acepta
intento
conexión
probable
administrado-
res
sistemas
desean
inicios
sesión
aleatorios
Internet
cracker
empezar
probar
nombres
inicio
sesión
contraseñas
listas
principio
proceso
prue-
ba
error
cracker
irrumpir
capturar
archivo
contraseñas
ubica
/etc
passwd
sistemas
UNIX
permiso
pú-
blico
lectura
empezará
recolectar
información
estadística
frecuencias
nombres
inicio
sesión
optimizar
búsquedas
futuro
demonios
telnet
interrumpen
conexión
TCP
subyacente
intentar
éxito
inicios
sesión
intento
detener
crackers
responden
iniciando
mu-
chos
hilos
paralelo
trabajando
máquinas
objetivo
intentos
permita
ancho
banda
salida
punto
vista
desventaja
dividir
esfuerzo
máquinas
atacan
tiempo
ping
máquinas
orden
dirección
IP
cracker
enfo-
car
empresa
universidad
organización
gubernamental
específica
ejemplo
Univer-
sidad
Foobar
foobar.edu
averiguar
direcciones
IP
utiliza
escribir
dnsquery
foobar.edu
obtendrá
lista
direcciones
IP
alternativa
utilizar
programas
nslookup
dig
posibilidades
escribir
consulta
DNS
motor
búsqueda
encontrar
sitio
Web
realice
búsquedas
DNS
gratuitas
ejemplo
www.dnsstuff.com
organizaciones
65,536
direcciones
IP
consecutivas
unidad
asignación
común
averigüe
bytes
direc-
ciones
IP
dnsqueryproporciona
sencillo
ping
65,536
direcciones
responden
aceptan
conexiones
telnet
volver
adivinar
nombres
inicio
sesión
contraseñas
tema
vimos
necesidad
decirlo
proceso
empezar
nombre
dominio
buscar
bytes
direcciones
IP
ping
direcciones
activas
comprobar
acepta
conexiones
telnet
tratar
adivinar
pares
nombre
www.FreeLibros.meinicio
sesión
contraseña
probabilidad
estadística
proceso
presta
automatización
requerirán
intentos
irrumpir
computadoras
repetir
secuencia
comandos
lo-
grar
objetivo
cracker
cable
alta
velocidad
conexión
DSL
programar
proceso
irrumpir
computadoras
ejecute
necesita
revisar-
resultados
servicio
telnet
computadoras
variedad
servicios
disponibles
Internet
servicios
conectado
65,536
puertos
asociados
dirección
IP
cracker
dirección
IP
activa
frecuencia
ejecuta
exploración
puertos
disponible
puertos
producir
op-
ciones
adicionales
irrumpir
sistema
ataque
telnet
exploración
puertos
ataque
war
dialer
rápido
pierde
tiempo
marcar
números
telefónicos
económico
cargos
telefónicos
larga
distancia
funciona
máquinas
es-
tán
Internet
aceptan
conexiones
telnet
empresas
univer-
sidades
aceptan
conexiones
telnet
empleados
viaje
negocios
sucursal
estudiantes
hogar
puedan
iniciar
sesión
remota
frecuencia
contraseñas
usuarios
débiles
contraseña
usuario
raíz
especial
instalaciones
molestan
cambiar
contraseñas
predeterminadas
sale
sistema
fábrica
Cliff
Stoll
as-
trónomo
Berkeley
observado
irregularidades
sistema
preparó
trampa
cracker
tratando
entrar
Stoll
1989
Observó
sesión
muestra
fi-
gura
9-18
escrita
cracker
irrumpido
máquina
Lawrence
Berkeley
Laboratory
LBL
tratando
entrar
uucp
Programa
copia
UNIX
UNIX
utiliza
tráfico
red
máquinas
superusuario
cracker
encontraba
máquina
Departamento
Energía
EE.UU.
superusuario
fortuna
LBL
diseña
armas
nucleares
laboratorio
hermano
Li-
vermore
Esperamos
seguridad
razones
creer
laboratorio
armas
nucleares
Alamos
perdió
disco
duro
lleno
información
clasificada
2000
LBL
telnet
elxsi
ELXSI
AT
LBL
LOGIN
root
PASSWORD
root
INCORRECT
PASSWORD
TRY
AGAIN
LOGIN
guest
PASSWORD
guest
INCORRECT
PASSWORD
TRY
AGAIN
LOGIN
uucp
PASSWORD
uucp
WELCOME
TO
THE
ELXSI
COMPUTER
AT
LBL
Figura
9-18
entró
cracker
computadora
Departamento
Ener-
gía
EE.UU.
LBL
646
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
647
cracker
entra
sistema
convierte
superusuario
instalar
husmeador
paquetes
software
examina
paquetes
entrantes
sa-
lientes
red
busca
patrones
patrón
interesante
buscar
per-
sonas
máquina
comprometida
inician
sesión
máquinas
remotas
especial
superusuarios
información
esconder
archivo
cracker
lea
desee
cracker
irrumpe
máquina
seguridad
débil
aprovechar
irrumpir
máquinas
seguridad
sólida
usuarios
conocimientos
computación
irrumpen
sistemas
ejecutar
secuencias
comandos
encuentran
Internet
secuencias
comandos
utilizan
ataques
fuerza
bruta
tipo
descrito
tratan
explotar
errores
conocidos
pro-
gramas
específicos
verdaderos
hackers
refieren
desprecio
niños
script
script
kiddies
general
niño
script
objetivo
específico
información
específica
trate
robar
busca
máquinas
fácil
entrar
secuencias
comandos
in-
cluso
seleccionan
red
azar
atacarla
número
red
aleatorio
superior
direcciones
IP
sondean
máquinas
red
cuá-
responden
adquiere
base
datos
direcciones
IP
válidas
ataca
máquina
separado
consecuencia
metodología
darse
probabilidad
realice
ataque
máquina
instalación
militar
segura
horas
ha-
berla
conectado
Internet
administrador
sepa
máquina
fun-
cionando
Seguridad
contraseñas
UNIX
sistemas
operativos
antiguos
mantienen
archivo
contraseñas
disco
for-
mato
cifrado
protegido
mecanismos
usuales
protección
sistema
peligroso
contraseñas
archivo
disco
formato
cifrado
personas
acceso
archivo
frecuencia
personas
administradores
sistema
operadores
máquinas
personal
mantenimiento
programadores
gerencia
secretarias
solución
UNIX
utiliza
programa
inicio
sesión
pide
usuario
escriba
nombre
contraseña
contraseña
cifra
inme-
diato
utilizarla
clave
cifrar
bloque
fijo
datos
efecto
ejecuta
fun-
ción
vía
contraseña
entrada
función
contraseña
salida
realidad
proceso
cifrado
fácil
considerarlo
progra-
ma
inicio
sesión
lee
archivo
contraseñas
serie
líneas
ASCII
usuario
línea
contiene
nombre
inicio
sesión
usuario
contraseña
cifrada
contiene
línea
coincide
contraseña
cifrada
acaba
calcular
permite
inicio
sesión
caso
contrario
rechaza
ventaja
esquema
siquiera
superusuario
contraseñas
usuarios
almacenan
formato
descifrado
sistema
esquema
atacar
muestra
continuación
Prime-
ro
cracker
crea
diccionario
palabras
probables
Morris
www
FreeLibros.meThompson
contraseñas
cifran
algoritmo
conocido
gusto
cracker
im-
porta
tiempo
proceso
realiza
intento
entrar
sistema
armado
lista
pares
contraseña
contraseña
cifrada
cracker
ataca
Lee
archivo
contraseñas
acceso
público
extrae
contraseñas
cifradas
compara
contraseñas
cifradas
lista
coincidencia
nom-
bre
inicio
sesión
contraseña
descifrada
secuencia
comandos
shell
simple
pue-
automatizar
proceso
cabo
fracción
ejecución
típica
secuencia
comandos
producirá
docenas
contraseñas
reconocer
posibilidad
ataque
Morris
Thompson
describieron
técnica
inutiliza
ataque
completo
idea
asociar
contraseña
número
aleatorio
bits
conocido
salt
número
aleatorio
modifica
cambia
contraseña
número
aleatorio
almacena
archivo
contraseñas
formato
descifrado
to-
puedan
leerlo
almacenar
contraseña
cifrada
archivo
contraseñas
pri-
mero
concatenan
contraseña
número
aleatorio
cifran
juntos
resultado
cifrado
almacena
archivo
contraseña
muestra
figura
9-19
archi-
vo
contraseñas
usuarios
Robbie
Tony
Laura
Mark
Deborah
usuario
línea
archivo
entradas
separadas
comas
nombre
inicio
sesión
salt
contraseña
cifrada
salt
notación
e(Perro
4238
representa
resultado
concatenar
con-
traseña
Bobbie
Perro
salt
asignado
azar
4238
ejecutarlo
función
cifrado
e.
resultado
cifrado
almacena
tercer
campo
entrada
Bobbie
Bobbie
4238
e(Perro
4238
Tony
2918
e(6%%TaeFF
2918
Laura
6902
e(Shakespeare
6902
Mark
1694
e(XaB#Bwcz
1694
Deborah
1092
e(LordByron
1092
Figura
9-19
salt
evitar
contraseñas
cifradas
calculen
anticipación
considere
implicaciones
cracker
desea
crear
lista
contraseñas
pro-
bables
cifrarlas
guardar
resultados
archivo
ordenado
buscar
facilidad
contraseña
cifrada
intruso
sospecha
Perro
contra-
seña
basta
cifrar
Perro
colocar
resultado
f.
cifrar
2n
cadenas
co-
mo
Perro0000
Perro0001
Perro0002
sucesivo
introducirlas
f.
técnica
incrementa
tamaño
2n
UNIX
utiliza
método
/H1100512
obtener
seguridad
adicional
versiones
modernas
UNIX
ar-
chivo
contraseñas
ilegible
proporcionan
programa
buscar
entradas
base
petición
agregan
suficiente
retraso
atrasar
considerable
ata-
cante
general
combinación
número
salt
archivo
contraseñas
ilegible
indirecta
lento
soportar
mayoría
ataques
648
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
649
Contraseñas
mayoría
superusuarios
exhortan
usuarios
mortales
cambien
contrase-
ñas
mes
mayoría
usuarios
caso
omiso
extremoso
cambiar
contraseña
inicio
sesión
contraseñas
conoce
contraseñas
so-
utilizan
contraseñas
usuario
recibe
libro
contiene
lista
contraseñas
inicio
sesión
utiliza
contraseña
lista
in-
truso
llega
descubrir
contraseña
servirá
próxima
utilizar
contraseña
distinta
sugiere
usuario
trate
perder
libro
contraseñas
actualidad
necesita
libro
elegante
esquema
ideado
Leslie
Lam-
port
permite
usuario
iniciar
sesión
forma
segura
red
insegura
me-
diante
contraseñas
Lamport
1981
método
Lamport
utilizar
permitir
usuario
PC
doméstica
inicie
sesión
servidor
Internet
intrusos
puedan
copiar
tráfico
ambas
direcciones
almacenar
secretos
sistema
archivos
servidor
PC
usuario
mé-
conoce
cadena
hash
vía
algoritmo
basa
función
vía
función
/H11005f(x
pro-
piedad
dada
fácil
encontrar
dada
imposible
calcular
valor
x.
en-
trada
salida
longitud
ejemplo
256
bits
usuario
selecciona
contraseña
secreta
memoriza
selecciona
en-
tero
representa
contraseñas
generar
algoritmo
ejemplo
considere
/H110054
práctica
utilizaría
valor
n.
contraseña
secreta
contraseña
obtiene
ejecutar
función
vía
/H11005f(f(f(f
contraseña
obtiene
ejecutar
función
vía
/H110021
P2
/H11005f(f(f
contraseña
ejecuta
cuarta
ejecuta
general
Pi
H110021
H11005f(Pi
clave
observar
dada
contraseña
secuencia
fácil
calcular
secuencia
numérica
imposible
calcular
ejemplo
da-
P2
fácil
encontrar
imposible
encontrar
P3
servidor
inicializa
f(P1
valor
almacena
entrada
ar-
chivo
contraseñas
asociada
nombre
inicio
sesión
usuario
entero
indica
contraseña
requerida
usuario
desea
iniciar
sesión
envía
nombre
inicio
sesión
servidor
responde
envian-
do
entero
archivo
contraseñas
máquina
usuario
responde
calcular
forma
local
escribe
instante
servidor
calcula
f(P1
compara
resultado
valor
almacenado
archivo
contraseñas
P0
va-
lores
coinciden
permite
inicio
sesión
entero
incrementa
P1
sobrescribe
P0
archivo
contraseñas
www
FreeLibros.me650
SEGURIDAD
CAPÍTULO
inicio
sesión
servidor
envía
usuario
máquina
calcula
P2
servidor
calcula
P2
compara
resultado
entrada
archivo
contra-
señas
valores
coinciden
permite
inicio
sesión
entero
incrementa
P2
so-
brescribe
P1
archivo
contraseñas
propiedad
funcionar
esquema
intruso
llegar
capturar
Pi
forma
calcular
i+1
Pi
calcular
Pi
H110021pero
valor
utilizó
valor
utilizado
to-
das
contraseñas
servidor
reinicializa
clave
secreta
Autenticación
reto-respuesta
variación
idea
contraseñas
usuario
proporcione
larga
lista
preguntas
respuestas
posteriormente
almacenan
servidor
forma
segura
ejemplo
formato
cifrado
preguntas
elegir
forma
usuario
anotarlas
preguntas
posibles
hermana
Marjolein
calle
encontraba
escuela
primaria
enseñaba
Sra.
Woroboff
momento
iniciar
sesión
servidor
preguntas
azar
comprueba
res-
puesta
obstante
esquema
práctico
necesitan
pares
pregunta-
respuesta
autenticación
reto-respuesta
variación
utiliza
usuario
elige
algo-
ritmo
registrarse
usuario
ejemplo
usuario
inicia
sesión
servi-
dor
envía
argumento
ejemplo
cuyo
caso
usuario
escribe
49
algoritmo
distinto
mañana
distintos
semana
sucesivo
dispositivo
usuario
cómputo
computadora
perso-
nal
asistente
digital
personal
teléfono
celular
utilizar
forma
poderosa
reto-respuesta
usuario
selecciona
adelantado
clave
secreta
principio
sistema
servidor
forma
manual
mantiene
copia
forma
segura
computadora
usuario
momento
iniciar
sesión
servidor
envía
número
aleatorio
computadora
usuario
calcula
f(r
envía
resultado
vuelta
función
conocida
públicamente
servidor
realiza
cálculo
comprueba
resul-
tado
recibió
computadora
usuario
coincide
resultado
cálculo
ventaja
esquema
comparación
contraseña
persona
interviene
cables
red
ve
registra
tráfico
ambas
direcciones
aprenderá
ayu-
próxima
función
complicada
deducir
valor
conjunto
extenso
observaciones
funcio-
nes
hash
criptográficas
opciones
argumento
función
XOR
k.
difícil
invertir
funciones
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
651
9.4.2
Autenticación
objeto
físico
método
autenticar
usuarios
comprobar
objeto
físico
tengan
sepan
utilizado
llaves
puertas
metálicas
siglos
objeto
físico
utiliza
frecuencia
tarjeta
plástico
inserta
lector
asociado
computadora
general
usuario
insertar
tarjeta
si-
escribir
contraseña
evitar
alguien
utilice
tarjeta
perdida
ro-
bada
Visto
forma
ATM
Cajero
automático
bancario
empieza
usuario
inicia
sesión
computadora
banco
terminal
remota
máquina
ATM
tarjeta
plástico
contraseña
actualidad
código
NIP
dígitos
mayoría
países
evitar
costo
colocar
teclado
completo
máquina
ATM
tarjetas
plástico
contienen
información
vienen
variedades
tarjetas
tira
magnética
tarjetas
chip
tarjetas
tira
magnética
contienen
140
bytes
información
escrita
pieza
cinta
magnética
pegada
posterior
tarjeta
terminal
leer
información
enviarla
computadora
central
infor-
mación
contiene
contraseña
usuario
ejemplo
código
NIP
terminal
comprobación
identidad
enlace
computadora
principal
es-
té
desconectado
general
contraseña
cifra
clave
banco
cono-
ce
tarjetas
cuestan
0.10
0.50
dependiendo
calcomanía
holográfica
frontal
volumen
producción
identificar
usuarios
ge-
neral
tarjetas
tira
magnética
riesgosas
equipo
leerlas
escribir
económico
disponible
partes
tarjetas
chip
contienen
pequeño
circuito
integrado
chip
tarjetas
subdividir
categorías
tarjetas
valor
almacenado
tarjetas
inteligentes
tarjetas
valor
almacenado
contienen
pequeña
cantidad
memoria
general
KB
utiliza
tecnología
ROM
permitir
valor
recuerde
quite
tar-
jeta
lector
ende
desconecte
energía
CPU
tarjeta
valor
almacenado
modificar
CPU
externa
lector
tarjetas
producen
masa
millones
costo
utilizan
ejemplo
tarjetas
tele-
fónicas
prepagadas
llamada
teléfono
reduce
valor
tarjeta
pe-
ro
realidad
intercambio
dinero
razón
comúnmente
empresa
emite
tarjetas
utilizarlas
máquinas
ejemplo
teléfonos
máquinas
expende-
doras
utilizar
autenticar
inicios
sesión
almacenando
contraseña
KB
lector
enviaría
computadora
central
raras
obstante
actualidad
trabajo
seguridad
enfoca
tar-
jetas
inteligentes
cuya
configuración
actual
CPU
bits
MHz
16
KB
ROM
KB
ROM
512
bytes
RAM
reutilizable
canal
comunicación
9600
bps
lector
tiempo
tarjetas
volviendo
inteligentes
restringidas
formas
incluyendo
profundidad
chip
incrustado
tarjeta
an-
chura
chip
rompa
usuario
doble
tarjeta
costo
general
20
dependiendo
CPU
tamaño
memoria
presencia
ausen-
cia
coprocesador
criptográfico
www
FreeLibros.meLas
tarjetas
inteligentes
utilizar
guardar
dinero
tarjetas
valor
almacenado
seguridad
universalidad
tarjetas
cargar
di-
nero
máquina
ATM
hogar
teléfono
utilizando
lector
especial
sumi-
nistrado
banco
inserta
lector
comerciante
usuario
autorizar
tarjeta
deducir
cantidad
dinero
escribir
tarjeta
envía
pequeño
mensaje
cifrado
comerciante
comerciante
mensaje
banco
cobrar
monto
pagó
ventaja
tarjetas
inteligentes
tarjetas
crédito
débito
ejemplo
necesitan
conexión
línea
banco
piensa
ventaja
realice
experimento
Trate
comprar
caramelo
tienda
insista
pagar
tar-
jeta
crédito
comerciante
rehúsa
diga
trae
efectivo
necesi-
ta
millas
viajero
frecuente
Descubrirá
comerciante
entusiasmado
idea
costos
asociados
reducirían
ganancia
artículo
tarjetas
inteligentes
útiles
compras
pequeñas
tiendas
teléfonos
paga
parquímetros
máquinas
expendedoras
dispositivos
general
requie-
ren
monedas
utilizan
Europa
empezando
partes
tarjetas
inteligentes
usos
potenciales
codificar
alergias
condiciones
médicas
portador
forma
segura
utilizar
información
emer-
gencias
veremos
interesa
forma
utilizar
autenticación
inicio
sesión
segura
concepto
básico
simple
tarjeta
inteligente
computadora
pequeña
prueba
falsificaciones
entablar
discusión
protoco-
computadora
central
autenticar
usuario
ejemplo
usuario
desee
comprar
cosas
sitio
Web
comercio
electrónico
insertar
tarjeta
inteligente
lector
doméstico
conectado
PC
sitio
comercio
electrónico
utilizaría
tarje-
ta
inteligente
autenticar
usuario
segura
contraseña
deducir
precio
compra
tarjeta
inteligente
directa
eliminan-
do
sobrecarga
riesgo
asociada
tarjeta
crédito
pa-
ra
compras
línea
utilizar
esquemas
autenticación
tarjeta
inteligente
autentica-
ción
específica
reto-respuesta
simple
funciona
servidor
envía
núme-
ro
aleatorio
512
bits
tarjeta
inteligente
suma
contraseña
512
bits
usuario
almacenada
ROM
aplica
cuadrado
suma
512
bits
media
envían
vuelta
servidor
conoce
contraseña
usuario
calcular
resultado
correcto
secuencia
muestra
figura
9-20
persona
interven-
ga
cables
red
ve
mensajes
averiguar
información
inútil
guardarlos
posterior
inicio
sesión
enviará
número
alea-
torio
512
bits
distinto
utilizar
algoritmo
elegante
aplicar
cuadrado
desventaja
protocolo
criptográfico
fijo
curso
tiempo
alguien
quebrantarlo
tarjeta
inteligente
inutilizable
evitar
utilizar
ROM
tarjeta
protocolo
criptográfico
intérprete
Java
descarga
protocolo
criptográfico
tarjeta
programa
binario
Java
ejecuta
intérprete
forma
quebrante
protocolo
652
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
653
instalar
nivel
mundial
forma
simple
próxima
utilice
tarjeta
instalará
software
desventaja
método
reduce
velocidad
tarjeta
lenta
medida
mejora
tecnología
método
flexible
des-
ventaja
tarjetas
inteligentes
tarjeta
perdida
robada
sujeta
ata-
canal
lateral
ataque
análisis
energía
observar
energía
eléctrica
consume
operaciones
cifrado
repetidas
experto
equipo
adecuado
de-
ducir
clave
mide
tiempo
cifrar
claves
elegidas
especial
tam-
bién
proporcionar
información
valiosa
clave
9.4.3
Autenticación
biométrica
tercer
método
autenticación
mide
características
físicas
usuario
difíciles
fal-
sificar
características
conoce
biométricas
Pankanti
colaboradores
2000
ejemplo
lector
huellas
digitales
voz
conectado
computadora
verificar
identidad
usuario
sistema
biométrico
común
consta
partes
inscripción
identificación
ins-
cripción
miden
características
usuario
digitalizan
resultados
características
importantes
extraen
almacenan
registro
asociado
usuario
registro
guardar
base
datos
central
ejemplo
iniciar
sesión
computadora
remota
almacenar
tarjeta
inteligente
usuario
inserta
lec-
tor
remoto
ejemplo
máquina
ATM
identificación
usuario
aparece
proporciona
nombre
inicio
se-
sión
sistema
realiza
medición
valores
coinciden
muestrearon
momento
inscripción
acepta
inicio
sesión
caso
contrario
re-
chaza
nombre
inicio
sesión
necesita
mediciones
exactas
difícil
indexarlas
buscar
base
índice
personas
características
firme
requerir
características
medidas
reto
envía
tarjeta
inteligente
devuelve
respuesta
Computadora
remota
Tarjeta
inteligente
tarjeta
inteligente
calcula
respuesta
Lector
tarjetas
inteligentes
Figura
9-20
tarjeta
inteligente
autenticación
www.FreeLibros.mecoincidan
usuario
específico
requerir
coincidan
usuario
característica
elegida
suficiente
variabilidad
sistema
distinguir
personas
error
ejemplo
color
cabello
indica-
dor
personas
comparten
color
característica
variar
tiempo
personas
color
cabello
propiedad
simi-
lar
voz
persona
distinta
resfriado
rostro
verse
barba
traer
maquillaje
momento
inscribirse
muestras
poste-
riores
coincidir
exacta
valores
inscripción
diseñadores
sistema
decidir
calidad
coincidencia
aceptarla
especial
tie-
nen
decidir
rechazar
usuario
legítimo
dejar
impostor
sitio
comercio
electrónico
decida
rechazar
cliente
leal
aceptar
pequeña
cantidad
fraude
sitio
ar-
nucleares
decidir
rehusar
acceso
empleado
genuino
dejar
en-
trar
extraños
azar
año
analizar
forma
medidas
biométricas
utilizan
actualidad
análisis
longitud
dedos
sorprendentemente
práctico
uti-
liza
computadora
dispositivo
figura
9-21
usuario
inserta
mano
continuación
mide
longitud
dedos
comprueba
base
datos
654
SEGURIDAD
CAPÍTULO
Resorte
Placa
presión
Figura
9-21
dispositivo
medir
longitud
dedos
mediciones
longitud
dedos
perfectas
sistema
atacado
moldes
manos
hechos
Yeso
París
material
dedos
ajustables
permitir
experimentación
www
FreeLibros.meSECCIÓN
9.4
AUTENTICACIÓN
655
biométrica
comercial
amplio
reconocimiento
iris
personas
tengan
patrones
siquiera
gemelos
idénticos
método
huellas
digitales
automatiza
facilidad
Daugman
2004
su-
jeto
ve
cámara
distancia
metro
fotografía
ojos
sujeto
extrae
características
conoce
transformación
on-
dículas
Gabor
comprime
resultados
256
bytes
cadena
compara
valor
ob-
momento
inscripción
distancia
Hamming
valor
umbral
crítico
persona
autenticada
distancia
Hamming
cadenas
bits
número
mínimo
cambios
necesarios
transformar
cadena
técnica
base
imágenes
sujeta
suplantación
identidad
ejem-
plo
persona
llegar
equipo
digamos
cámara
máquina
ATM
usando
lentes
oscuros
estuvieran
pegadas
fotografías
ojos
persona
cáma-
ra
ATM
tomar
foto
iris
metro
personas
mayores
distancias
utilizan
teleobjetivos
razón
necesiten
contramedidas
co-
mo
cámara
dispare
flash
fines
iluminación
pupila
contrae
respuesta
temido
efecto
ojos
rojos
fotógrafo
amateur
aparece
imagen
flash
ausente
utiliza
flash
aeropuerto
Amsterdam
esta-
do
utilizando
tecnología
reconocimiento
iris
2001
permitir
viajeros
fre-
cuentes
eviten
línea
inmigración
normal
análisis
firmas
técnica
distinta
usuario
firma
pluma
especial
co-
nectada
computadora
compara
espécimen
conocido
almacenado
línea
tarjeta
inteligente
comparar
firma
movimientos
pluma
pre-
sión
ejerce
escribir
falsificador
copiar
firma
idea
orden
exacto
trazos
velocidad
presión
biométrica
voz
esquema
basa
hardware
especial
mínimo
Markowitz
2001
requiere
micrófono
teléfono
resto
software
contraste
sistemas
reconocimiento
voz
tratan
determinar
ora-
dor
sistemas
tratan
determinar
orador
sistemas
requieren
usuario
diga
contraseña
secreta
fisgón
vencerlos
grabar
cinta
contra-
señas
reproducirlas
posteriormente
sistemas
avanzados
usuario
piden
repita
utilizan
textos
distintos
inicio
sesión
empresas
em-
pezando
utilizar
identificación
voz
aplicaciones
compras
hogar
vía
telefónica
propensa
fraudes
código
NIP
identifi-
cación
Podríamos
continuar
indefinida
ejemplos
mencionaremos
aclarar
punto
importante
gatos
animales
marcan
territorio
orinar
perímetro
Aparentemente
gatos
identificar
forma
Suponga
llega
alguien
pequeño
dispositivo
capaz
análisis
ori-
na
instantáneo
proveer
identificación
prueba
errores
compu-
tadora
estaría
equipada
dispositivos
anuncio
discreto
leyenda
iniciar
sesión
deposite
muestra
sistema
com-
pletamente
inquebrantable
tendría
grave
problema
aceptación
usuarios
www
FreeLibros.meSe
sistema
consistente
chincheta
pequeño
espectró-
grafo
pediría
usuario
presionara
pulgar
chincheta
extraería
gota
sangre
análisis
espectrográfico
punto
esquema
autenticación
psicológicamente
aceptable
comunidad
usuarios
mediciones
lon-
gitud
dedos
provoquen
problema
intrusivo
alma-
cenar
huellas
digitales
línea
inaceptable
personas
asocian
toma
huellas
digitales
fichaje
criminales
9.5
ATAQUES
INTERIOR
visto
detalle
forma
funciona
autenticación
usuarios
desgra-
cia
evitar
visitantes
indeseables
inicien
sesión
problemas
se-
guridad
existentes
trabajos
internos
categoría
completamente
distinta
problemas
seguridad
programadores
empleados
empresa
operan
computadora
proteger
crean
software
crítico
ejecutan
tipos
trabajos
ataques
distintos
externos
usuarios
internos
conocimiento
acceso
especializados
externos
continuación
veremos
ejemplos
ocurrido
repetidas
diferen-
cias
persona
realiza
ataque
atacado
lograr
atacante
9.5.1
Bombas
lógicas
tiempos
externalización
masiva
programadores
preocupan
comúnmente
trabajos
realizan
pasos
potencial
partida
involuntaria
dolorosa
inclinan
favor
chantaje
estrategia
crear
bomba
lógica
dispositivo
pieza
código
escrita
programadores
empresa
momento
empleados
inserta
secreta
sistema
producción
programador
proporcione
contraseña
diaria
hará
obstante
programador
despedido
repentina
desaloja
físicamente
ins-
talaciones
advertirle
semana
bomba
lógica
recibirá
con-
traseña
diaria
activará
posibles
variantes
tema
caso
famoso
bomba
lógica
comprobaba
nómina
número
personal
programador
aparecía
periodos
nómina
consecutivos
activaba
Spafford
colaborado-
res
1989
activarse
bomba
empiece
borrar
contenido
disco
eliminando
archivos
azar
realizando
cuidadosamente
cambios
difíciles
detectar
programas
clave
cifrando
archivos
esenciales
caso
empresa
tomar
difícil
decisión
lla-
mar
policía
resultar
condena
meses
duda
restaurará
archivos
faltantes
ceder
chantaje
volver
contratar
programador
con-
656
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.5
ATAQUES
INTERIOR
657
sultor
suma
astronómica
corrija
problema
esperar
plante
bombas
lógicas
registrado
casos
virus
plantó
bomba
lógica
computadoras
infectó
general
bombas
programaron
activarse
tiempo
fecha
hora
futuro
programador
antemano
computadoras
su-
frirán
ataques
bombas
lógicas
utilizar
proteger
trabajo
chantaje
configuran
activarse
fecha
significado
político
bombas
conoce
bombas
tiempo
9.5.2
Trampas
hoyo
seguridad
producen
usuarios
internos
trampa
problema
crea
código
inserta
programador
sistemas
evitar
chequeo
rutina
ejemplo
programador
agregar
código
programa
inicio
sesión
permitir
cualquiera
iniciar
sesión
nombre
zzzzz
importar
archivo
contraseñas
código
normal
programa
inicio
sesión
figu-
ra
9-22(a
trampa
cambio
figura
9-22(b
llamada
strcmp
com-
probar
nombre
inicio
sesión
zzzzz
inicio
sesión
éxito
importar
contraseña
utilice
código
trampa
insertara
programador
traba-
je
fabricante
computadoras
enviara
computadoras
programador
iniciar
sesión
computadora
fabricada
empresa
importar
dueño
información
contenga
archivo
contraseñas
aplica
pro-
gramador
trabaja
distribuidor
sistemas
operativos
puerta
simplemente
pasa
alto
proceso
autenticación
while
TRUE
printf(“usuario
obtener_cadena(nombre
deshabilitar_eco
printf(“contrasenia
obtener_cadena(contrasenia
habilitar_eco
comprobar_validez(nombre
contrasenia
if
break
ejecutar_shell(nombre
Figura
9-22
Código
normal
Código
inserta
trampa
empresas
evitar
trampas
revisiones
código
práctica
estándar
técnica
programador
termina
escribir
while
TRUE
printf(“usuario
obtener_cadena(nombre
deshabilitar_eco
printf(“contrasenia
obtener_cadena(contrasenia
habilitar_eco
comprobar_validez(nombre
contrasenia
if
||
strcmp(nombre
zzzzz
break
ejecutar_shell(nombre
www.FreeLibros.meprobar
módulo
comprueba
base
datos
código
tiempo
reú-
nen
programadores
equipo
frente
grupo
explicar
código
línea
línea
estrategia
aumenta
probabilidad
alguien
pue-
detectar
trampa
riesgo
programador
atrapan
ma-
masa
carrera
beneficiará
programadores
protestan
proponerles
método
compañeros
trabajadores
comprueben
código
9.5.3
Suplantación
identidad
inicio
sesión
ataque
interno
perpetrador
usuario
legítimo
recolectar
contraseñas
personas
técnica
conocida
suplantación
identidad
inicio
sesión
general
emplea
empresas
computadoras
públicas
LAN
utilizada
usuarios
ejemplo
universidades
salones
llenos
compu-
tadoras
estudiantes
iniciar
sesión
cualquiera
funciona
Nor-
malmente
conectado
computadora
UNIX
aparece
pantalla
similar
figura
9-23(a
usuario
sienta
escribe
nombre
inicio
sesión
sistema
pide
contraseña
correcta
usuario
comienza
sesión
inicia
shell
posiblemente
GUI
658
SEGURIDAD
CAPÍTULO
Usuario
Usuario
Figura
9-23
Pantalla
correcta
inicio
sesión
Pantalla
falsa
inicio
sesión
considere
caso
usuario
malicioso
nombre
escribe
programa
mostrar
pantalla
figura
9-23(b
apariencia
sorprendente
pantalla
fi-
gura
9-23(a
ejecutando
programa
inicio
sesión
sistema
falso
escrito
ejecuta
programa
inicio
sesión
falso
aleja
observar
diversión
distancia
segura
usuario
sienta
escribe
nombre
inicio
sesión
programa
responde
pidiendo
contraseña
deshabilita
eco
panta-
lla
recolectan
nombre
inicio
sesión
contraseña
anotan
archi-
vo
programa
falso
envía
señal
eliminar
shell
acción
desconecta
sistema
activa
programa
inicio
sesión
muestre
indicador
fi-
gura
9-23(a
usuario
asume
error
escritura
simplemente
vuelve
escribir
datos
funciona
adquirido
par
nombre
inicio
sesión
contraseña
iniciar
sesión
computadoras
ejecutar
suplantador
recolectar
contraseñas
www
FreeLibros.meSECCIÓN
9.6
EXPLOTAR
ERRORES
BUGS
CÓDIGO
659
única
real
evitar
secuencia
inicio
sesión
empiece
combinación
teclas
usuarios
programas
puedan
detectar
Windows
utili-
za
CTRL-ALT-SUPR
usuario
sienta
computadora
escribe
CTRL-ALT-SUPR
usuario
actual
desconecta
inicia
programa
inicio
sesión
sistema
forma
evadir
mecanismo
9.6
EXPLOTAR
ERRORES
BUGS
CÓDIGO
visto
formas
usuarios
internos
peligro
se-
guridad
tiempo
iniciar
estudio
atacar
usuarios
externos
tras-
tornar
sistema
operativo
exterior
general
Internet
mecanismos
ataque
aprovechan
errores
sistema
operativo
programa
apli-
cación
popular
Internet
Explorer
Microsoft
Office
escenario
típico
alguien
descu-
bre
error
sistema
operativo
explotarlo
comprometer
computadoras
ejecutan
código
defectuoso
explotación
implica
error
específico
programa
específico
va-
rias
categorías
generales
errores
ocurren
vale
pena
estudiarlos
funcionan
ataques
siguientes
secciones
examinaremos
métodos
libro
sistemas
operativos
enfoque
tras-
tornar
sistema
operativo
trataremos
diversas
formas
explo-
tar
errores
software
atacar
sitios
Web
bases
datos
formas
explotar
errores
simple
directa
atacante
inicie
secuencia
comandos
realice
Ejecutar
exploración
puertos
automatizada
encontrar
máquinas
acepten
co-
nexiones
telnet
Tratar
iniciar
sesión
adivinando
combinaciones
nombre
inicio
sesión
con-
traseña
adentro
ejecutar
programa
defectuoso
datos
entrada
activen
error
programa
contiene
errores
SETUID
root
crear
shell
SETUID
root
Obtener
iniciar
programa
zombie
escuche
puerto
IP
espera
comandos
programa
zombie
inicie
sistema
reinicie
secuencia
comandos
ejecutar
tiempo
probabilidad
éxito
momento
asegurar
programa
zombie
inicie
reinicie
computadora
atacante
asegura
computadora
zombie
escenario
común
iniciar
virus
infecte
máquinas
Internet
explotar
error
virus
instale
máquina
esencia
reemplazan
pasos
secuencia
siguen
aplicando
forma
programa
atacante
ejecutará
máquina
destino
usuario
sepa
programa
divulgue
presencia
www
FreeLibros.me9.6.1
Ataques
desbordamiento
búfer
fuentes
extensas
ataques
sistemas
opera-
tivos
mayoría
programas
sistemas
escritos
lenguaje
programación
programadores
gusta
compilar
eficiencia
extrema
desgracia
compilador
realiza
comprobación
límites
arreglos
con-
secuencia
revisa
secuencia
código
válida
int
char
c[1024
12000
c[i
resultado
sobrescribe
byte
memoria
esté
posición
10,976
bytes
arreglo
posiblemente
consecuencias
desastrosas
realiza
comprobación
tiempo
ejecución
evitar
error
propiedad
produce
ataques
tipo
descrito
continuación
figura
9-24(a
po-
demos
ejecución
programa
principal
variables
locales
pila
pun-
to
llama
procedimiento
muestra
figura
9.24(b
secuencia
llamadas
estándar
empieza
meter
dirección
retorno
apunta
instrucción
lla-
mada
pila
transfiere
control
incrementa
apuntador
pila
asig-
nar
espacio
variables
locales
660
SEGURIDAD
CAPÍTULO
Variables
locales
main
Programa
0xFFFF
Apuntador
pila
Espacio
direcciones
virtuales
Pila
Variables
locales
main
Programa
Apuntador
pila
Espacio
direcciones
virtuales
Programa
Apuntador
pila
Espacio
direcciones
virtuales
Variables
locales
Búfer
Variables
locales
mainDirección
retorno
Dirección
retorno
Variables
locales
Figura
9-24
Situación
programa
principal
ejecución
Des-
pués
llamar
procedimiento
A.
desbordamiento
búfer
muestra
co-
lor
gris
Suponga
trabajo
necesita
adquirir
ruta
archivo
completa
concatenan-
do
ruta
directorio
actual
nombre
archivo
abrir
archivo
www
FreeLibros.meSECCIÓN
9.6
EXPLOTAR
ERRORES
BUGS
CÓDIGO
661
operación
búfer
arreglo
tamaño
fijo
guardar
nombre
archivo
muestra
figura
9-24(b
fácil
programar
búfer
tamaño
fijo
guardar
nombre
archivo
determinar
tamaño
actual
asignar
suficiente
espacio
forma
dinámica
búfer
1024
bytes
basta
manejar
to-
nombres
archivo
especial
sistema
operativo
limita
nombres
archivo
rutas
completas
máximo
255
caracteres
número
fijo
desgracia
razonamiento
contiene
error
fatal
Suponga
usuario
programa
proporciona
nombre
archivo
2000
caracteres
longitud
utiliza
nombre
archivo
abrirá
atacante
preocupa
procedimiento
copia
nombre
archivo
búfer
nombre
desborde
búfer
sobrescribe
memoria
muestra
área
gris
figura
9-24(c
nombre
archivo
sobrescribirá
dirección
retorno
regrese
procedimiento
di-
rección
retorno
tomará
media
nombre
archivo
dirección
basura
azar
programa
saltará
dirección
aleatoria
probablemente
fallará
instrucciones
pasa
nombre
archivo
contiene
basura
azar
pasa
contiene
programa
binario
válido
diseño
cuidadoso
palabra
superpone
dirección
retorno
dirección
inicio
programa
ejemplo
direc-
ción
ocurrirá
regrese
empezará
ejecutar
programa
B.
efecto
atacante
sobrescrito
memoria
código
logrado
ejecute
truco
aplica
objetos
nombres
archivos
Funciona
cadenas
entorno
largas
datos
entrada
usuarios
cosa
progra-
mador
creado
búfer
tamaño
fijo
manejar
cadena
corta
suminis-
trada
usuario
proporcionar
cadena
larga
creada
mano
contenga
programa
lograr
meter
programa
pila
ejecute
función
gets
biblioteca
lee
cadena
tamaño
desconocido
coloca
búfer
tamaño
fijo
comprobar
desbordamiento
notoria
padecer
tipo
ataque
Algu-
compiladores
detectan
gets
emiten
advertencia
viene
mala
Suponga
programa
sufriendo
ataque
SETUID
root
UNIX
Administrador
Windows
código
insertado
crear
llamadas
sistema
convertir
archivo
shell
atacante
dis-
co
SETUID
root
ejecute
superusuario
al-
ternativa
asignar
biblioteca
compartida
preparada
forma
especial
tipo
daños
simplemente
llamada
sistema
execpara
super-
shell
programa
actual
creando
shell
poderes
superusuario
descargar
programa
secuencia
comandos
Internet
alma-
cenarlo
disco
crear
proceso
ejecutar
programa
secuencia
co-
mandos
proceso
escuchar
puerto
IP
específico
esperando
comandos
exterior
ejecutarlos
convertir
máquina
zombie
evitar
zombie
pierda
reinicie
máquina
código
atacante
arreglos
programa
secuencia
comandos
recién
obtenido
inicie
inicie
máquina
Es-
to
fácil
sistemas
Windows
UNIX
www
FreeLibros.meUna
fracción
considerable
problemas
seguridad
error
di-
fícil
corregir
programas
comprueban
desbordamiento
búfer
fácil
detectar
programa
problemas
desbordamiento
búfer
suministrarle
nombres
archivo
10,000
caracteres
similar
inesperado
vacía
núcleo
paso
analizar
vaciado
núcleo
guarda
flujo
lar-
go
difícil
averiguar
carácter
sobrescribe
dirección
re-
torno
disponible
código
fuente
mayoría
programas
UNIX
ataque
sencillo
distribución
pila
conoce
antemano
defenderse
ataque
corregir
código
compruebe
explícita
longitud
cadenas
suministradas
usuario
insertarlas
búferes
longi-
tud
fija
desgracia
programa
vulnerable
tipo
ataques
general
muestra
ataque
exitoso
9.6.2
Ataques
cadenas
formato
programadores
detestan
escribir
computadora
excelentes
mecanógrafos
nombrar
variable
cuenta_referencia
obvio
cr
significa
ahorra
15
pulsaciones
tecla
ocurrencia
renuencia
escribir
producir
fallas
catastróficas
sistema
veremos
continuación
Considere
fragmento
programa
imprime
tradicional
bienvenida
lenguaje
inicio
programa
char
Hola
programador
printf(“%s”,s
programa
declara
variable
cadena
inicializa
cadena
consiste
Hola
programador
byte
cero
indicar
cadena
llamada
función
printf
argumentos
cadena
formato
indica
imprimir
cadena
dirección
ejecutarse
pieza
código
imprime
cadena
pantalla
salida
estándar
código
correcto
prueba
balas
suponga
programador
vuelve
flojo
escribe
char
Hola
programador
printf(s
llamada
printf
permite
printf
número
variable
argumentos
cua-
cadena
formato
cadena
contenga
información
formato
legal
versión
práctica
pro-
gramación
permitida
funciona
ahorra
escritura
caracte-
res
duda
ganancia
meses
instruye
programador
modifique
código
pida
usuario
nombre
darle
bienvenida
nombre
estudiar
código
forma
apresurada
cambia
662
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.6
EXPLOTAR
ERRORES
BUGS
CÓDIGO
663
char
s[100
g[100
Hola
declara
inicializa
gets(s
lee
cadena
teclado
coloca
strcat(g
concatena
printf(g
imprime
lee
cadena
coloca
variable
concatena
cadena
inicializada
construir
mensaje
salida
g.
funciona
gets
sujeto
ataques
desbordamiento
búfer
fácil
popular
usuario
conocedor
viera
código
daría
rapidez
entrada
acepta
teclado
cadena
cadena
formato
funcionarán
especificaciones
formato
permitidas
printf
mayoría
indicadores
formato
tales
imprimir
cadenas
imprimir
enteros
de-
cimales
formato
salida
especiales
ejemplo
im-
prime
calcula
caracteres
enviado
salida
posición
aparezca
cadena
almacena
valor
argumento
printf
pro-
cesarlo
programa
ejemplo
int
main(int
argc
char
argv
int
i=0
printf(“Hola
nprogramador\n
almacena
printf(“i=%d\n
programa
compila
ejecuta
resultado
Hola
programador
i=6
Observe
variable
modificado
llamada
printf
obvio
pa-
ra
característica
útil
significa
imprime
cade-
na
formato
almacene
palabra
memoria
idea
incluir
característica
printf
Definitivamente
parecía
útil
Mu-
chas
vulnerabilidades
software
empezaron
forma
vimos
ejemplo
programador
modificó
código
permitió
acci-
dente
usuario
programa
introdujera
saberlo
cadena
formato
impri-
mir
cadena
formato
llegar
sobrescribir
memoria
herramientas
necesarias
sobrescribir
dirección
retorno
función
printf
pila
saltar
cual-
quier
ejemplo
cadena
formato
acaba
introducir
método
conoce
ataque
cadenas
formato
usuario
habilidad
sobrescribir
memoria
forzar
salto
código
recién
inyectado
código
acceso
programa
atacan-
do
programa
SETUID
root
atacante
crear
shell
privilegios
usua-
rio
raíz
root
detalles
funcione
ataque
complicados
especializados
www.FreeLibros.mecomo
reproducirlos
basta
ataque
problema
grave
us-
ted
escribe
ataque
cadena
formato
Google
encontrará
información
problema
información
adicional
arreglos
caracteres
tamaño
fijo
ejemplo
sujeto
ataque
desbordamiento
búfer
9.6.3
Ataques
retorno
libc
ataque
desbordamiento
búfer
cadenas
formato
requieren
proporcionen
datos
pila
función
actual
vuelva
datos
regresar
método
llamada
forma
combatir
ataques
marcar
páginas
pila
lectura
escritura
ejecución
CPUs
Pentium
modernas
mayoría
sistemas
operativos
aprovechan
posibilidad
ataque
funciona
programas
pila
ejecutar
conoce
ataque
retorno
libc
Suponga
ataque
desbordamiento
búfer
cadenas
formato
sobrescribe
dirección
retorno
función
actual
ejecutar
código
suministrado
ata-
cante
pila
pudiera
regresar
com-
prometer
máquina
programas
vinculados
biblioteca
libc
general
compartida
contiene
funciones
clave
mayoría
programas
necesitan
funciones
strcpy
copia
cadena
bytes
arbitraria
dirección
dirección
naturaleza
ataque
engañar
strcpy
co-
pie
programa
atacante
conoce
shellcode
código
shell
seg-
mento
datos
ejecute
veamos
detalles
técnicos
funcionamiento
ataque
figura
9.25(a
pila
justo
programa
llamado
función
f.
suponer
programa
ejecutando
privilegios
superusuario
SETUID
root
error
explotar
permite
atacante
código
shell
memoria
ilustra
figura
9-25(b
figura
muestra
superior
pila
ejecutar
código
shell
pila
ataque
sobrescribir
letras
sombreadas
muestran
figura
9-25(b
palabra
inferior
dirección
retorno
main
dirección
strcpy
irá
vuelta
strcpy
punto
apuntador
pila
apuntará
dirección
retorno
extraña
función
strcpy
utili-
zará
termine
dirección
indica
lugar
localizará
código
palabras
superiores
mencionamos
direcciones
origen
destino
copia
strcpy
termine
código
shell
hogar
segmento
datos
ejecu-
table
strcpy
regresará
código
shell
ejecuta
poderes
progra-
ma
atacado
crear
shell
atacante
use
iniciar
secuencia
comandos
monitorear
puerto
IP
esperar
comandos
entrantes
punto
máquina
convertido
zombie
utilizar
enviar
spam
lanzar
ataques
ne-
gación
servicio
maestro
664
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.6
EXPLOTAR
ERRORES
BUGS
CÓDIGO
665
9.6.4
Ataques
desbordamiento
enteros
computadoras
realizan
aritmética
enteros
números
longitud
fija
general
16
32
64
bits
suma
números
sumar
multiplicar
excede
máximo
en-
tero
representar
produce
desbordamiento
programas
atrapan
error
almacenan
utilizan
valor
incorrecto
especial
variables
enteros
sig-
resultado
sumar
multiplicar
enteros
positivos
almacenar
entero
negativo
variables
signo
resultados
positivos
acarreo
cíclico
ejemplo
considere
enteros
16
bits
signo
con-
valor
40,000
multiplican
conjunto
resultado
almacena
entero
16
bits
signo
producto
aparente
4096
habilidad
producir
desbordamientos
numéricos
indetectables
convertir
ataque
suministrar
programa
parámetros
válidos
sabiendas
sumarán
multiplicarán
producirán
desbordamiento
ejemplo
algu-
programas
gráficos
parámetros
línea
comandos
proporcionan
altura
anchura
archivo
imagen
ejemplo
tamaño
convertir
imagen
entrada
anchura
altura
destino
eligen
provoque
desbordamien-
to
forzoso
programa
calculará
incorrecta
memoria
necesita
almacenar
imagen
llamar
malloc
asignar
búfer
pequeño
situación
enton-
ces
ideal
ataque
desbordamiento
búfer
cabo
explotaciones
si-
milares
suma
producto
enteros
positivos
signo
produce
entero
negativo
Espacio
direcciones
virtuales
Variables
locales
main
Variables
locales
Programa
Espacio
direcciones
virtuales
Variables
parcialmente
desechadas
Variables
locales
Programa
Dirección
strcpyDirección
retorno
main
dst
Código
shell
Apuntador
pila
Apuntador
pila
Dirección
retorno
strcpy
src
Figura
9-25
pila
ataque
pila
sobrescrito
www
FreeLibros.me9.6.5
Ataques
inyección
código
tipo
explotación
implica
programa
ejecute
código
darse
Con-
sidere
programa
punto
necesita
duplicar
archivo
suministrado
usuario
ba-
jo
nombre
distinto
respaldo
programador
perezoso
escribir
código
utilizar
función
system
crea
bifurcación
shell
ejecuta
argumento
comando
shell
ejemplo
código
system(“ls
lista-archivos
crea
bifurcación
shell
ejecuta
comando
ls
lista-archivos
lista
archivos
directorio
actual
escribe
archivo
llamado
lista-ar-
chivos
código
programador
haragán
utilizar
duplicar
archivo
muestra
figura
9-26
int
main(int
argc
char
argv
char
org[100
dst[100
cmd[205
cp
declara
cadenas
printf(“Escriba
nombre
archivo
origen
pide
archivo
origen
gets(org
obtiene
entrada
teclado
strcat(cmd
scr
concatena
src
cp
strcat(cmd
agrega
espacio
cmd
printf(“Escriba
nombre
archivo
destino
pide
nombre
archivo
salida
gets(dst
obtiene
entrada
teclado
strcat(cmd
dst
completa
cadena
comandos
system(cmd
ejecuta
comando
cp
Figura
9-26
Código
provocar
ataque
inyección
código
programa
pedir
nombres
archivos
origen
destino
crea
línea
comandos
cp
llama
system
ejecute
usua-
rio
escribe
abc
xyz
respectivamente
comando
ejecuta
cp
abc
xyz
definitiva
copia
archivo
desgracia
código
abre
enorme
agujero
seguridad
utiliza
técni-
ca
conocida
inyección
código
Suponga
usuario
escribe
abc
xyz
rm
rf
comando
construye
ejecuta
cp
abc
xyz
rm
rf
comando
copia
archivo
eliminar
recursiva
archi-
vo
directorio
sistema
archivos
programa
ejecuta
superusuario
666
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
667
probabilidades
lograrlo
problema
punto
coma
ejecuta
comando
shell
ejemplo
argumento
xyz
mail
husmeador@tipos-malos.com
/etc
passwd
produce
cp
abc
xyz
mail
husmeador@tipos-malos.com
/etc
passwd
envía
archivo
contraseñas
dirección
desconocida
confiable
9.6.6
Ataques
escalada
privilegios
ataque
escalada
privilegiosel
atacante
engaña
sistema
proporcione
permisos
acceso
general
engaña
haga
super-
usuario
famoso
ejemplo
programa
utilizó
demonio
cron
permite
usuarios
programar
trabajo
hora
semana
frecuencia
Comúnmente
demonio
ejecuta
root
poderoso
acceder
archivos
usuario
directorio
almacena
comandos
programados
ejecu-
tarse
usuarios
escribir
directorio
daría
habi-
lidad
cosa
ataque
funcionaba
programa
atacante
establecía
directorio
trabajo
directorio
demonio
cron
obvio
escribir
im-
portó
fallaba
obligara
vaciado
núcleo
dejaba
sistema
eliminara
forma
tuviera
vaciado
núcleo
vaciados
núcleo
ocurren
directorio
caso
directorio
demonio
cron
Co-
mo
sistema
vaciados
sistema
protección
prohibía
escribir
imagen
memoria
programa
atacante
estructuraba
conjunto
válido
co-
mandos
demonio
cron
ejecutaba
root
comando
cambiaba
programa
especificado
atacante
SETUID
root
ejecutaba
programa
punto
atacante
programa
arbitrario
ejecutaba
superusuario
ho-
específico
corrigió
tiempo
idea
tipo
ataque
9.7
MALW
ARE
tiempos
antiguos
ejemplo
2000
adolescentes
aburridos
inteligen-
tes
utilizaban
horas
ocio
escribir
software
malicioso
libera-
ban
mundo
software
incluía
troyanos
virus
gusanos
conjunto
conoce
malware
esparcía
rápidamente
mundo
medida
publicaba
millones
dólares
daños
provocado
malware
personas
ha-
bían
perdido
valiosos
datos
resultado
autores
impresionaban
habi-
lidades
programación
travesura
divertida
obteniendo
dinero
www
FreeLibros.meEsos
desaparecido
criminales
organizados
escriben
malware
demanda
prefieren
trabajo
publique
periódicos
único
inte-
resa
dinero
actualidad
malware
diseñada
esparcirse
rapidez
Internet
infectar
máquinas
in-
fecta
máquina
instala
software
reporta
dirección
máquina
capturada
vuelta
máquinas
países
sistemas
judiciales
desarrollados
corruptos
ejemplo
anteriores
repúblicas
soviéticas
instala
puerta
trase-
ra
máquina
permite
criminales
enviaron
malware
controlar
facilidad
máquina
haga
indiquen
máquina
controla
forma
denomi-
na
zombie
colección
máquinas
conoce
botnet
contracción
robot
network
red
robots
criminal
controla
botnet
rentar
fines
nefastos
co-
merciales
propósitos
comunes
enviar
spam
comercial
ocurre
ataque
serio
spam
policía
rastrear
origen
ven
proviene
miles
máquinas
mundo
logran
ubicar
propietarios
máquinas
descubrirán
niños
propietarios
negocios
pequeños
amas
casa
abuelas
personas
to-
das
niegan
rotundamente
spammers
masivos
criminales
operación
utilizan
máquinas
personas
realicen
trabajo
sucio
difícil
ras-
trearlos
instalado
malware
utilizar
fines
criminales
chanta-
je
posibilidad
Imagine
pieza
malware
cifre
archivos
disco
duro
víctima
muestre
mensaje
SALUDOS
GENERAL
CIFRADO
COMPRAR
CLAVE
DESCIFRADO
DISCO
DURO
FAVOR
ENVÍE
100
BILLETES
PEQUEÑOS
DESMARCADOS
DIRECCIÓN
BOX
2154
CIUDAD
PANAMÁ
PANAMÁ
GRACIAS
GUSTO
NEGOCIOS
aplicaciones
comunes
malware
instalar
keylogger
máquina
infectada
Es-
programa
simplemente
registra
pulsaciones
tecla
envía
forma
periódica
al-
guna
máquina
secuencia
máquinas
incluyendo
zombies
entreguen
información
criminal
difícil
proveedor
Internet
servicio
máquina
entregas
coopere
investigación
proveedores
confa-
bulados
criminal
ocasiones
propietario
oro
extraer
pulsaciones
teclas
consiste
números
tarjetas
crédito
utilizar
comprar
artículos
víctimas
idea
alguien
robado
números
tarjetas
crédito
reciben
ciclo
cobro
criminales
andar
compras
semanas
protegerse
ataques
empresas
tarjetas
crédito
utilizan
software
in-
teligencia
artificial
detectar
patrones
peculiares
gastos
ejemplo
persona
comúnmente
utiliza
tarjeta
crédito
tiendas
locales
repentina
orde-
na
docena
computadoras
notebook
costosas
entreguen
dirección
668
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
669
ejemplo
Tajikistan
empieza
sonar
alarma
empresa
tarjetas
crédito
general
empleado
llama
tarjetahabiente
preguntarle
amablemente
transacción
criminales
conocen
software
tratan
ajustar
hábitos
gas-
to
permanecer
justo
radar
datos
recolectados
keylogger
combinar
datos
recolectados
software
instalado
computadora
zombie
criminal
enfrascar
robo
identidad
extenso
crimen
criminal
recolecta
suficientes
datos
persona
fecha
nacimiento
apellido
soltera
madre
número
seguro
social
nú-
meros
cuentas
bancarias
contraseñas
etcétera
hacerse
pasar
víctima
éxito
obtener
documentos
físicos
licencia
conducir
reemplazo
tarjeta
dé-
bito
adicional
banco
certificado
nacimiento
datos
pue-
den
vender
criminales
sigan
explotando
forma
delito
comete
malware
permanecer
invisible
usuario
inicie
sesión
correcta
bancaria
Internet
ejecuta
rápida-
mente
transacción
dinero
transfiere
inmediato
cuen-
ta
criminal
transfiere
inmediato
distintos
países
corruptos
policía
necesite
semanas
reco-
lectar
órdenes
cateo
requeridas
seguir
dinero
respeten
lleguen
obtenerlas
tipo
delitos
implica
volumen
negocios
importante
adolescentes
molestos
crimen
organizado
malware
aplicaciones
in-
dustriales
empresa
liberar
pieza
malware
compruebe
ejecutando
fábrica
competidor
administrador
sistema
conectado
momento
moros
costa
interferir
proceso
producción
reducir
calidad
productos
causaría
problemas
competidor
casos
haría
na-
difícil
detectar
ejemplo
malware
dirigido
programa
escrito
vicepresidente
cor-
porativo
ambicioso
liberarlo
LAN
local
virus
comprobaría
ejecutando
máquina
presidente
buscaría
hoja
cálculo
intercambiaría
celdas
azar
presidente
tomaría
mala
decisión
base
salida
hoja
cálculo
provocar
despido
puesto
estaría
abierto
personas
caminan
chip
cuestas
confundir
personas
chip
RFID
introducido
espalda
rencilla
real
imagina-
ria
mundo
desean
desquitarse
malware
ayudar
computadoras
moder-
nas
guardan
BIOS
memoria
flash
volver
escribir
control
programa
permitir
fabricante
distribuya
correcciones
errores
medios
elec-
trónicos
malware
escribir
basura
azar
memoria
flash
computadora
arrancar
chip
memoria
flash
zócalo
corregir
problema
abrir
computadora
reemplazar
chip
chip
memoria
flash
soldado
tarje-
ta
principal
desechar
tarjeta
comprar
Podríamos
seguir
indefinida
lector
comprendido
punto
desea
historias
horror
escriba
malware
motor
búsqueda
www
FreeLibros.meLas
personas
preguntar
malware
esparce
tanta
facilidad
va-
rias
razones
lugar
90%
computadoras
mundo
ejecutan
versiones
sistema
operativo
Windows
objetivo
fácil
hubiera
10
sistemas
operativos
10%
mercado
difícil
esparcir
malware
mundo
biológico
diversidad
defensa
lugar
Microsoft
puesto
énfasis
per-
sonas
conocimientos
técnicos
puedan
utilizar
Windows
facilidad
ejemplo
sistemas
Windows
configuran
normalmente
permitir
inicio
sesión
contraseña
sistemas
UNIX
requerido
contraseña
excelente
práctica
es-
tá
debilitando
medida
Linux
parecerse
Windows
concesiones
formas
seguridad
facilidad
Microsoft
optado
facilidad
estrategia
marketing
piensa
seguridad
importante
facilidad
deje
leer
configure
teléfono
celular
requiera
código
NIP
quiera
llamada
teléfonos
celulares
capaces
descargue
manual
usuario
sitio
Web
fabricante
Recibió
mensaje
siguientes
secciones
analizaremos
formas
comunes
malware
construyen
esparcen
capítulo
examinaremos
algu-
nas
formas
defender
malware
9.7.1
Caballos
Troya
troyanos
Escribir
malware
cosa
rato
libre
millones
personas
instalen
computadoras
difícil
escritor
malware
práctica
común
escribir
programa
utilidad
genuina
in-
crustar
malware
interior
juegos
reproductores
música
visores
porno
espe-
ciales
cosa
gráficos
espectaculares
probable
candidato
personas
descargarán
instalarán
aplicación
voluntaria
bono
gratuito
instalan
malware
método
conoce
ataque
caballo
Troyao
troyano
honor
ca-
ballo
madera
lleno
soldados
griegos
describe
Odisea
Homero
mundo
seguridad
computadoras
representa
tipo
malware
oculto
software
página
Web
personas
descargan
forma
voluntaria
inicia
programa
gratuito
llama
función
escribe
malware
dis-
co
programa
ejecutable
inicia
malware
daño
diseñado
eliminar
modificar
cifrar
archivos
buscar
números
tarjetas
crédito
contraseñas
datos
útiles
enviarlos
vuelta
Internet
probable
adjunte
puerto
IP
espere
indicaciones
con-
virtiendo
máquina
zombie
lista
enviar
spam
cosa
amo
remoto
de-
see
general
malware
invoca
comandos
necesarios
asegurar
reinicie
reinicia
máquina
sistemas
operativos
670
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
671
belleza
ataque
caballo
Troya
requiere
autor
irrumpa
compu-
tadora
víctima
víctima
trabajo
formas
engañar
víctima
ejecute
programa
caballo
Troya
ejemplo
usuarios
UNIX
variable
entorno
llamada
PATH
controla
directorios
buscar
comando
verla
escribir
si-
guiente
comando
shell
echo
PATH
configuración
potencial
usuario
ast
sistema
consistir
siguientes
directorios
/usr
ast
bin:/usr
local
bin:/usr
bin:/bin:/usr
bin
X11:/usr
ucb:/usr
man\
/usr
java
bin:/usr
java
lib:/usr
local
man:/usr
openwin
man
probable
usuarios
tengan
ruta
búsqueda
distinta
usuario
escribe
prog
shell
comprueba
programa
ubicación
/usr
ast
bin
prog
ejecuta
shell
prueba
/usr
local
bin
prog
/usr
bin
prog
/bin-
/prog
sucesivo
probando
10
directorios
orden
rendirse
Suponga
só-
directorios
desprotegido
cracker
colocó
programa
ocurrencia
programa
lista
ejecutará
caballo
Troya
mayoría
programas
/bin
/usr
bin
sirve
colocar
caballo
Troya
/usr
bin
X11
Is
programa
común
encontrará
suponga
cracker
inserta
/usr
bin
X11
usuario
escribe
ls
programa
listar
directorios
ejecutará
caballo
Troya
realiza-
rá
trabajo
sucio
emitirá
mensaje
correcto
indicar
inser-
tar
caballos
Troya
directorios
complicados
busca
darles
nombres
representar
errores
comunes
escritura
probabilidad
alguien
invoque
alguien
superusuario
co-
meten
errores
escritura
cuyo
caso
caballo
Troya
tendría
oportunidad
reemplazar
/bin
ls
versión
contenga
caballo
Troya
invo-
cará
tiempo
malicioso
válido
usuario
llamado
dejar
trampa
superusuario
coloca
versión
ls
contenga
caballo
Tro-
directorio
sospechoso
seguridad
atraerá
atención
superusuario
iniciar
100
procesos
vinculados
cálculos
tiempo
probable
comprobar
acción
superusuario
escriba
cd
/home
ls
www.FreeLibros.mepara
directorio
inicio
shells
prueban
directo-
rio
local
buscar
PATH
usuario
invocado
caballo
Troya
superusuario
caballo
Troya
operación
/home
bin
bin
sh
SETUID
root
establecerse
raíz
requieren
llamadas
sistema
chmodpara
cambiar
propietario
/home
bin
sh
rooty
chmodpara
activar
bit
SETUID
convertir
superusuario
quiera
ejecutar
shell
queda
corto
efectivo
frecuencia
utilizar
siguientes
estafas
caballos
Troya
obtener
liquidez
estafa
caballo
Troya
comprue-
ba
víctima
instalado
programa
bancario
línea
Quicken
caballo
Troya
indica
programa
transfiera
cantidad
dinero
víctima
señuelo
preferencia
país
lejano
recolectar
efectivo
poste-
riormente
estafa
caballo
Troya
desactiva
sonido
módem
marca
número
900
paga
preferencia
país
lejano
Moldova
par-
Unión
Soviética
usuario
línea
inició
caballo
Tro-
número
telefónico
900
Moldova
necesita
proveedor
Internet
costoso
usuario
note
perman
ezca
línea
horas
técnicas
hipotética
ambas
ocurrido
reportan
Denning
1999
es-
tafa
acumularon
800,000
minutos
tiempo
conexión
Moldova
Comisión
Federal
Comercio
EE.UU.
pudiera
desconectar
máquina
entablara
acción
legal
personas
Long
Island
Finalmente
acordaron
reembolsar
2.74
millones
38,000
víc-
timas
9.7.2
Virus
difícil
abrir
periódico
leer
acerca
virus
gusano
computado-
ra
ataca
computadoras
mundo
evidente
problema
seguridad
pa-
ra
individuos
empresas
sección
examinaremos
virus
veremos
gusanos
seguro
escribir
sección
detalle
malas
ideas
personas
libros
existentes
proporcionan
detalle
incluyen
código
real
ejemplo
Ludwig
1998
Internet
llena
in-
formación
virus
genio
salió
botella
Aparte
difícil
personas
defenderse
virus
funcionan
circulan
ideas
equivocadas
virus
necesitan
corregirse
forma
virus
resumir
virus
programa
re-
producir
adjuntar
código
programa
similar
forma
reproducen
virus
biológicos
virus
cosas
reproducirse
gusanos
virus
duplican
forma
automática
diferencia
interesa
momento
utilizaremos
término
virus
tratar
am-
bos
términos
sección
9.7.3
analizaremos
gusanos
672
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
673
funcionan
virus
veamos
tipos
virus
funcionan
escritor
virus
llamémoslo
Virgi-
lio
probablemente
trabaja
ensamblador
obtener
producto
pequeño
eficiente
escribir
virus
inserta
programa
máquina
utilizan-
do
herramienta
conocida
dropper
programa
infectado
distribuye
publicándolo
colección
software
gratuito
Internet
programa
juego
emocionante
versión
pirata
software
comercial
cosa
considerar
deseable
personas
empiezan
descargar
programa
in-
fectado
instalado
máquina
víctima
virus
permanece
dormido
ejecu-
ta
programa
infectado
iniciado
general
empieza
infectar
programas
máquina
ejecuta
carga
útil
casos
carga
útil
haga
fecha
asegurarse
virus
esparcido
par-
tes
personas
empiecen
detectarlo
fecha
elegida
enviar
mensaje
político
ejemplo
activa
aniversario
100
500
grave
insulto
grupo
étnico
autor
análisis
examinaremos
tipos
virus
base
infecta
virus
compañía
programa
ejecutable
residentes
memoria
sector
arranque
driver
dispositivo
macro
código
fuente
duda
aparecerán
tipos
futuro
Virus
compañía
virus
compañía
realidad
infecta
programa
ejecuta
programa
concepto
fácil
explicar
ejemplo
MS-DOS
usuario
escribe
prog
MS-DOS
busca
programa
llamado
prog.com
encontrar
busca
programa
llamado
prog.exe
Windows
usuario
clic
Inicio
Eje-
cutar
ocurre
mayoría
programas
archivos
.exe
archivos
.com
raros
Suponga
Virgilio
personas
ejecutan
prog.exe
indicador
MS-
comando
Ejecutar
Windows
liberar
virus
llamado
prog-
.com
ejecute
alguien
trate
ejecutar
prog
escriba
nombre
completo
prog.exe
prog.com
termina
trabajo
ejecuta
prog.exe
usuario
ataque
relacionado
utiliza
escritorio
Windows
contiene
accesos
directos
vínculos
simbólicos
programas
virus
cambiar
destino
acceso
di-
recto
apunte
virus
usuario
doble
clic
icono
ejecuta
virus
termina
virus
ejecuta
programa
destino
original
www
FreeLibros.meVirus
programa
ejecutable
virus
infectan
programas
ejecutables
complejos
compañía
tipo
simple
virus
programa
ejecutable
sobrescribe
programa
conoce
virus
sobrescritura
figura
9-27
proporciona
lógica
infección
virus
include
sys
types.h
encabezados
POSIX
estándar
include
sys
stat.h
include
dirent.h
include
fcntl.h
include
unistd.h
struct
stat
buf
llamar
lstat
archivo
vínculo
simbólico
buscar(char
nombre_dir
búsqueda
recursiva
ejecutables
DIR
dirp
apuntador
flujo
directorio
abierto
struct
dirent
dp
apuntador
entrada
directorio
dirp
opendir(nombre_dir
abre
directorio
if
dirp
NULL
return
abrir
directorio
while(TRUE
dp
readdir(dirp
lee
entrada
directorio
olvidarlo
if
dp
NULL
NULL
significa
terminamos
chdir
regresa
directorio
padre
break
sale
ciclo
if
dp->d_name[0]==
continue
omite
directorios
lstat(dp->d_name,&sbuf
entrada
vínculo
simbólico
if
S_ISLNK(sbuf.st_mode
continue
omite
vínculos
simbólicos
if
chdir(dp->d_name)==0
chdir
éxito
dir
buscar
entra
busca
else
archivo
infecta
if(access(dp->d_name
X_OK)==0
ejecutable
infecta
infectar(dp-d_name
closedir(dirp
procesó
directorio
cierra
regresa
Figura
9-27
procedimiento
recursivo
busca
archivos
ejecutables
siste-
ma
UNIX
programa
principal
virus
copia
programa
binario
arreglo
abre
argv[0
lee
contenido
guardarlo
lugar
seguro
recorre
sis-
tema
archivos
empezando
directorio
raíz
cambia
directorio
raíz
llama
buscar
directorio
raíz
parámetro
674
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
675
procesar
directorio
procedimiento
recursivo
buscarlo
abre
lee
entradas
utilizando
readdir
devuelva
NULL
indica
entradas
entrada
directorio
procesarlo
cambia
directorio
llama
buscar
forma
recursiva
archivo
ejecutable
infecta
llamando
infectarcon
nombre
archivo
infectar
parámetro
archivos
empiezan
omiten
evitar
problemas
directorios
especiales
omiten
vínculos
simbólicos
progra-
ma
asume
entrar
directorio
llamada
sistema
chdiry
re-
gresar
encontraba
válido
vínculos
duros
simbólicos
programa
elegante
manejar
vínculos
simbólicos
procedimiento
infección
llamado
infecta
muestra
simplemente
tie-
ne
abrir
archivo
cuyo
nombre
parámetro
copiar
virus
guardado
arreglo
so-
bre
archivo
cerrar
archivo
virus
mejorar
formas
lugar
insertar
prue-
ba
infectar
generar
número
aleatorio
regresar
mayoría
casos
ejemplo
infección
llevaría
cabo
128
llamadas
re-
duciría
probabilidad
alguien
detectara
virus
pudiera
esparcirse
virus
biológicos
propiedad
matan
rápido
víctimas
esparcen
tan-
ta
rapidez
producen
muerte
lenta
prolongada
dando
víctimas
opor-
tunidades
esparcir
virus
diseño
alternativo
tasa
infección
alta
ejemplo
25%
disminución
número
archivos
infectados
reducir
actividad
disco
ende
conspicuo
lugar
infectar
comprobar
archivo
infectado
Infectar
archivo
pérdida
tiempo
tercer
lugar
tomar
medidas
dejar
hora
modificación
tamaño
archivo
ayudar
ocultar
infección
pro-
gramas
virus
tamaño
modificará
programas
pequeños
virus
programa
mayoría
virus
pequeños
programas
problema
grave
programa
extenso
programa
completo
ocupa
página
segmento
texto
compila
KB
versión
ensamblador
virus
corta
Ludwig
1998
proporciona
programa
código
ensamblador
MS-
infecta
archivos
directorio
ocupa
44
bytes
ensambla
capítulo
estudiaremos
programas
antivirus
ras-
trean
eliminan
virus
interesante
observar
lógica
figura
9-27
virus
buscar
archivos
ejecutables
infectarlos
utilizar
programa
antivirus
rastrear
programas
infectados
eliminar
virus
tecnologías
infección
desinfección
mano
mano
razón
necesario
compren-
der
detalle
funcionan
virus
combatirlos
efectiva
punto
vista
Virgilio
problema
virus
sobrescritura
detec-
ta
facilidad
ejecute
programa
infectado
esparcir
virus
usuario
detectará
instante
conse-
cuencia
mayoría
virus
adjuntan
programa
realizan
trabajo
sucio
permite
programa
funcione
normal
dichos
virus
llama
virus
parasíticos
www
FreeLibros.me676
SEGURIDAD
CAPÍTULO
virus
parasíticos
adjuntar
frontal
posterior
media
programa
eje-
cutable
virus
adjunta
frontal
copiar
programa
RAM
colocarse
frente
volver
copiar
programa
RAM
mues-
tra
figura
9-28(b
desgracia
programa
ejecutará
dirección
virtual
virus
reubicar
programa
momento
moverlo
moverlo
direc-
ción
virtual
terminar
ejecución
Programa
ejecutable
Encabezado
Programa
ejecutable
Encabezado
Virus
Programa
ejecutable
Encabezado
Encabezado
Virus
Virus
Virus
Virus
Virus
Dirección
inicial
Figura
9-28
programa
ejecutable
virus
frontal
virus
virus
esparcido
espacio
libre
programa
evitar
cualquiera
complejas
opciones
requeridas
virus
cargan
des-
frontal
mayoría
virus
cargan
posterior
adjuntan
programa
ejecutable
frontal
cambian
campo
direc-
ción
inicial
encabezado
apunte
inicio
virus
ilustra
figura
9.28(c
virus
ejecutará
dirección
virtual
distinta
dependiendo
programa
infecta-
do
esté
ejecutando
significa
Virgilio
asegurarse
virus
in-
dependiente
posición
difícil
programador
experimentado
compiladores
pide
formatos
programas
ejecutables
complejos
archivos
.exe
Windows
formatos
binarios
modernos
UNIX
permiten
programa
segmentos
texto
datos
cargador
ensambla
memoria
encarga
reubicación
ins-
tante
sistemas
Windows
ejemplo
segmentos
secciones
múltiplos
512
bytes
segmento
lleno
vinculador
llena
0s
virus
compren-
tratar
ocultarse
hoyos
cabe
completo
figura
9-28(d
tamaño
archivo
permanece
archivo
desinfectado
duda
ventaja
virus
oculto
virus
feliz
virus
utilizan
principio
llaman
virus
cavi-
dad
cargador
carga
áreas
cavidad
memoria
virus
nece-
sitará
forma
iniciarse
Virus
residentes
memoria
asumido
ejecuta
programa
infectado
ejecuta
virus
pasa
control
programa
real
termina
contrario
virus
residente
memoria
per-
www
FreeLibros.meSECCIÓN
9.7
MALWARE
677
manece
memoria
RAM
tiempo
ocultándose
superior
memo-
ria
escondiéndose
inferior
vectores
interrupción
últi-
mos
cientos
bytes
utilizan
virus
inteligente
modificar
mapa
bits
RAM
sistema
operativo
sistema
piense
memoria
virus
ocupada
evitar
sobrescriba
virus
residente
memoria
típico
captura
trampas
vectores
interrupción
pa-
ra
copia
contenido
variable
reutilizable
coloca
dirección
interrupción
trampa
apunte
elección
interrupción
llamadas
sistema
forma
virus
ejecuta
kernel
llamada
sistema
Cuan-
do
termina
invoca
llamada
real
sistema
salta
dirección
trampa
guardada
querría
virus
ejecutarse
llamadas
sistema
infectar
programas
virus
esperar
llegue
llamada
sistema
execy
archivo
mano
binario
ejecutable
probablemente
útil
infecta
proceso
requiere
actividad
masiva
disco
figura
9-27
me-
conspicuo
atrapar
llamadas
sistema
virus
obtiene
potencial
espiar
datos
tipo
travesuras
Virus
sector
arranque
vimos
capítulo
mayoría
computadoras
encienden
BIOS
lee
registro
maestro
arranque
inicial
disco
arranque
coloca
RAM
eje-
cutarlo
programa
determina
partición
activa
lee
sector
sector
arranque
partición
ejecutarlo
programa
carga
sistema
operativo
utiliza
carga-
dor
cargarlo
desgracia
años
amigos
Virgil
idea
crear
virus
pudiera
sobrescribir
registro
maestro
arranque
sector
arranque
resulta-
devastadores
Dichos
virus
conocidos
virus
sector
arranque
comunes
Normalmente
virus
sector
arranque
incluye
virus
MBR
Registro
maes-
tro
arranque
copia
sector
arranque
lugar
seguro
disco
pa-
ra
iniciar
sistema
operativo
termine
programa
formato
discos
Microsoft
fdisk
omite
pista
lugar
ocultarse
máquinas
Windows
opción
utilizar
sector
disco
libre
actualizar
lista
sectores
defectuosos
marcar
sector
oculto
defectuoso
virus
disfrazarse
sectores
defectuosos
virus
realmente
agresivo
asignar
espacio
disco
normal
sector
arranque
actuali-
zar
mapa
bits
lista
sectores
libres
disco
acorde
requiere
conocimiento
detallado
estructuras
datos
internas
sistema
operativo
Virgil
tu-
vo
excelente
profesor
curso
sistemas
operativos
estudió
duro
inicia
computadora
virus
copia
RAM
superior
inferior
vectores
interrupciones
utilizan
punto
máqui-
na
kernel
MMU
desactivada
sistema
operativo
programa
antivirus
ejecute
tiempo
fiesta
virus
listo
inicia
sistema
operativo
general
permanece
residente
memoria
observar
acción
www
FreeLibros.meSin
problemas
obtener
control
for-
ma
usual
explotar
conocimiento
específico
forma
sistema
operativo
admi-
nistra
vectores
interrupción
ejemplo
Windows
sobrescribe
vectores
interrupción
golpe
carga
driver
dispositivo
captura
vector
interrupciones
necesita
proceso
durar
minuto
diseño
virus
obtiene
manejador
desea
Empieza
capturar
vec-
tores
interrupción
muestra
figura
9-29(a
medida
cargan
drivers
sobrescriben
vectores
cargue
driver
reloj
interrupciones
reloj
iniciar
virus
figura
9.29(b
muestra
pérdida
interrupción
impresora
virus
ve
vectores
interrupción
sobrescrito
volver
sobrescribir
vector
certeza
aho-
ra
seguro
realidad
vectores
interrupción
sobrescriben
arranque
patrón
determinístico
Virgilio
figura
9-29(c
muestra
re-
captura
impresora
carga
virus
restaura
vectores
interrupción
guarda
vector
interrupciones
llamadas
sistema
punto
virus
residente
memoria
controla
llamadas
sistema
forma
mayoría
virus
residentes
memoria
empiezan
vida
678
SEGURIDAD
CAPÍTULO
Sistema
operativo
Virus
Vector
disco
Vector
relojVector
impresora
Vector
impresora
Sistema
operativo
Virus
Vector
disco
Vector
reloj
Sistema
operativo
Virus
Interrupciones
llamadas
sistemaInterrupciones
llamadas
sistema
Vector
disco
Vector
reloj
Figura
9-29
virus
capturado
vectores
interrup-
ción
trampa
sistema
recapturado
vector
interrupción
impresora
virus
observado
pérdida
vector
in-
terrupciones
impresora
recaptura
Virus
driver
dispositivo
Entrar
memoria
forma
similar
espeleología
exploración
cavernas
contorsiones
preocuparse
caer
pegue
cabeza
simple
sistema
operativo
cargara
virus
oficial
trabajo
lograr
objetivo
truco
infectar
driver
dispositivos
produce
virus
driver
dispositivo
Windows
sistemas
UNIX
drivers
dispo-
www
FreeLibros.meSECCIÓN
9.7
MALWARE
679
sitivos
programas
ejecutables
viven
disco
cargan
tiempo
arranque
infectar
programas
virus
cargará
oficialmente
tiempo
arranque
drivers
ejecutan
kernel
sistema
carga
driver
llama
virus
oportunidad
capturar
vector
trampas
llamadas
sistema
realidad
sólido
argumento
ejecutar
dri-
vers
dispositivos
programas
usuario
infectan
da-
ño
drivers
kernel
Virus
macro
programas
Word
Excel
permiten
usuarios
escribir
macros
agrupar
comandos
ejecutar
pulsación
tecla
macros
adjuntar
elementos
menús
seleccione
ejecute
macro
Microsoft
Office
macros
contener
programas
completos
Vi-
sual
Basic
lenguaje
programación
completo
macros
interpretan
compilarlas
afecta
velocidad
ejecución
macros
específicas
documento
Office
almacena
macros
docu-
mento
documento
viene
problema
Virgilio
escribe
documento
Word
crea
macro
adjun-
ta
función
OPEN
FILE
abrir
archivo
macro
contiene
virus
macro
envía
documento
e-mail
víctima
abre
suponiendo
programa
correo
electrónico
abrir
documento
ejecuta
macro
OPEN
FILE
macro
contener
programa
arbitrario
cosa
infectar
documentos
Word
borrar
archivos
ejemplo
justicia
Microsoft
Word
proporciona
advertencia
abrir
archivo
macros
mayoría
usuarios
en-
tienden
significa
formas
abren
archivo
documentos
legítimos
contener
macros
programas
siquiera
proporcionan
adver-
tencia
difícil
detectar
virus
crecimiento
adjuntos
correo
electrónico
problema
inmenso
enviar
do-
cumentos
virus
incrustados
macros
fácil
escribir
virus
ocultar
sector
arranque
lista
bloques
defectuosos
ocultar
virus
vectores
interrupción
capturar
vector
trampas
llamadas
sistema
sig-
nifica
personas
conocimientos
técnicos
escribir
virus
reduce
calidad
general
producto
virus
mala
reputación
Virus
código
fuente
virus
parasíticos
sector
arranque
específicos
plataforma
virus
documentos
específicos
Word
ejecuta
Windows
Macintosh
UNIX
virus
portátiles
virus
código
fuente
Imagine
virus
figura
9-27
modificación
buscar
archivos
ejecutables
binarios
busca
programas
cambiar
línea
llamada
access
www
FreeLibros.meHay
cambiar
procedimiento
infectar
insertarle
línea
include
virus.h
superior
programa
código
fuente
C.
insertar
siguien-
línea
ejecutar_virus
activar
virus
decidir
colocar
línea
requiere
habilidad
analizar
código
fuente
lugar
permita
llamadas
procedimientos
problemas
sintácticos
lugar
código
estaría
muerto
ejemplo
instrucción
return
sirve
colocarlo
mitad
comentario
colocarlo
ciclo
suponemos
llamada
colo-
car
forma
apropiada
justo
main
instrucción
return
momento
compilar
programa
incluirá
virus
tomado
virus.h
proj.h
po-
dría
atraer
atención
caso
alguien
viera
ejecute
programa
hará
llamada
virus
quie-
ra
ejemplo
buscar
programas
infectarlos
incluir
líneas
descritas
funcionará
máquina
local
supone
virus.h
instalado
funcione
máquina
remota
incluir
có-
digo
fuente
virus
incluir
código
fuente
virus
cadena
ca-
racteres
inicializada
preferencia
lista
enteros
hexadecimales
32
bits
evitar
alguien
averigüe
cadena
larga
código
actual
consta
cantidad
exorbitante
líneas
pasar
desapercibido
lector
experiencia
métodos
parecer
complicados
pregunte
funcionar
práctica
Virgilio
excelen-
programador
tiempo
libre
Compruebe
periódico
local
encontrar
pruebas
esparcen
virus
escenarios
distribución
Empecemos
clásico
Virgilio
escribe
virus
inserta
programa
escrito
robado
empieza
distribuirlo
ejemplo
co-
locar
sitio
Web
shareware
momento
alguien
descarga
programa
eje-
cuta
punto
opciones
empezar
virus
infecte
archivos
disco
duro
caso
víctima
decida
compartir
amigo
Tam-
bién
tratar
infectar
sector
arranque
disco
duro
infectado
sector
fácil
iniciar
virus
residente
memoria
kernel
siguientes
arranques
actualidad
opciones
disponibles
Virgilio
virus
escri-
bir
compruebe
máquina
infectada
LAN
probable
máquina
pertenece
empresa
universidad
virus
empezar
in-
fectar
archivos
desprotegidos
servidores
conectados
LAN
infección
ex-
tiende
archivos
protegidos
resolverlo
programas
infectados
680
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
681
actúen
forma
extraña
probable
usuario
ejecute
programa
pida
ayu-
administrador
sistema
administrador
probará
programa
extraño
ocurre
administrador
realiza
esté
conectado
superusuario
virus
infectar
archivos
binarios
sistema
drivers
dispositivos
sistema
operativo
sectores
arranque
requiere
error
má-
quinas
LAN
estarán
comprometidas
máquinas
LAN
autorización
conectarse
máquinas
remo-
tas
Internet
red
privada
autorización
ejecutar
comandos
forma
remota
iniciar
sesión
habilidad
ofrece
virus
oportunidad
esparcirse
ende
error
inocente
infectar
empresa
evitar
escenario
empresas
directiva
general
indique
administradores
cometer
errores
forma
esparcir
virus
publicar
programa
infectado
grupo
noticias
USENET
sitio
Web
publiquen
programas
regularidad
crear
página
Web
requiera
complemento
navegador
especial
verla
asegurarse
complementos
estén
infectados
ataque
distinto
infectar
documento
enviarlo
correo
electrónico
mu-
chas
personas
transmitirlo
lista
correo
grupo
noticias
USENET
general
adjunto
personas
imaginarían
ejecutar
programa
envió
extraño
den
clic
adjunto
abrirlo
libe-
rar
virus
máquina
empeorar
cosas
virus
buscar
libreta
direcciones
usuario
enviarse
correo
remitentes
lista
general
línea
Asunto
apariencia
legítima
interesante
Asunto
Cambio
planes
Asunto
Re
correo
electrónico
Asunto
perro
murió
anoche
Asunto
gravemente
enfermo
Asunto
amo
llega
correo
electrónico
receptor
ve
emisor
amigo
colega
tan-
to
sospecha
abre
correo
virus
LOVE
YOU
esparció
mundo
junio
2000
trabajaba
forma
daños
mil
millones
dólares
esparcimiento
tecnología
virus
relacionado
esparcimiento
actual
virus
activos
grupos
escritores
virus
comunican
constantemente
Internet
ayudan
desarrollar
tecnología
herramientas
virus
probable
personas
aficionados
criminales
efectos
devastadores
militares
categoría
escritores
virus
ven
arma
guerra
potencialmente
deshabilitar
computadoras
enemigo
cuestión
relacionada
esparcimiento
virus
evitar
detección
cárce-
notorias
instalaciones
cómputo
deficientes
Virgilio
preferiría
evitar-
publica
virus
inicial
computadora
casa
corre
riesgo
www.FreeLibros.meataque
éxito
policía
rastrearlo
buscar
etiqueta
hora
fecha
reciente
mensaje
virus
probablemente
cercana
origen
ataque
minimizar
exposición
Virgilio
café
Internet
ciudad
distante
co-
nectarse
virus
memoria
USB
CD-ROM
implantarlo
computadora
máquinas
puertos
USB
unidades
CD-ROM
pe-
dir
amable
asistente
favor
lea
archivo
libro.doc
imprimirlo
disco
duro
cambia
nombre
virus.exe
ejecuta
infectando
LAN
virus
activa
mes
caso
policía
decida
pedir
aerolíneas
lista
personas
viajaron
avión
semana
alternativa
memoria
USB
CD-ROM
obtener
virus
sitio
FTP
remo-
to
notebook
conectarla
puerto
Ethernet
proporcione
café
Internet
pa-
ra
turistas
viajan
notebook
desean
leer
correo
electrónico
conectado
LAN
Virgilio
prepararse
infectar
máquinas
estén
conectadas
virus
especial
forma
tratan
ocultarse
software
antivirus
eliminarlos
capítulo
volveremos
tocar
temas
defensas
malware
9.7.3
Gusanos
violación
seguridad
computacional
Internet
escala
empezó
noviembre
1998
estudiante
graduado
Cornel
llamado
Robert
Tappan
Morris
liberó
programa
tipo
gusano
Internet
acción
inhabilitó
miles
computadoras
uni-
versidades
empresas
laboratorios
gubernamentales
mundo
pudieran
ras-
trear
eliminar
gusano
continuación
analizaremos
puntos
importantes
suceso
obtener
información
técnica
consulte
artículo
Spafford
1989
libro
Hafner
Mar-
koff
1991
presenta
historia
thriller
policiaco
historia
empezó
momento
1998
Morris
descubrió
errores
Ber-
keley
UNIX
permitían
obtener
acceso
autorizado
máquinas
Internet
Traba-
jando
escribió
programa
llamado
gusano
duplicaba
podía
explotar
errores
duplicarse
segundos
máquina
podía
obtener
ac-
ceso
Trabajó
programa
meses
tiempo
optimizó
cuidado
tratara
ocultar
pista
liberación
noviembre
1998
prueba
real
caso
mayoría
sistemas
Sun
AX
Internet
doblegaran
ho-
ras
liberación
gusano
motivación
Morris
desconoce
considerara
broma
alta
tecnología
error
programación
sa-
lido
manos
Técnicamente
gusano
consistía
programas
bootstrap
gusano
boots-
trap
99
líneas
llamaba
l1.c
compilaba
ejecutaba
sistema
ata-
cando
ejecución
conectaba
máquina
llegado
enviaba
programa
principal
gusano
ejecutaba
esforzarse
ocultar
existencia
682
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
683
gusano
analizaba
tablas
enrutamiento
host
máquinas
co-
nectado
trataba
esparcir
bootstrap
máquinas
intentaban
métodos
infectar
máquinas
método
tratar
eje-
cutar
shell
remoto
comando
rsh
máquinas
confían
ejecutan
rsh
tipo
autenticación
funcionaba
shell
remoto
actualizaba
programa
gu-
sano
seguía
infectando
máquinas
método
utilizaba
programa
presente
sistemas
llamado
finger
per-
mite
usuario
Internet
escriba
finger
nombre@sitio
mostrar
información
persona
instalación
específica
general
infor-
mación
incluye
nombre
real
persona
nombre
inicio
sesión
direcciones
hogar
empleo
números
telefónicos
nombre
secretaria
número
telefóni-
co
número
FAX
información
similar
equivalente
electrónico
agenda
telefónica
Finger
funciona
sitio
proceso
plano
llama-
do
demonio
finger
ejecuta
tiempo
atendiendo
respondiendo
consultas
Internet
hacía
gusano
llamar
finger
cadena
especial
536
bytes
parámetro
larga
cadena
desbordaba
búfer
demonio
sobrescribía
pila
muestra
figura
9-24(c
error
explotaba
demonio
compro-
baba
desbordamiento
demonio
regresaba
procedimiento
encontraba
momento
recibir
petición
regresaba
main
procedimiento
cade-
na
536
bytes
pila
procedimiento
trataba
ejecutar
sh
funcionaba
gusano
aho-
ra
shell
ejecutándose
máquina
atacando
método
dependía
error
sistema
correo
sendmail
permitía
gusano
enviara
copia
boostrap
ejecutarla
establecido
gusano
trataba
quebrantar
contraseñas
usuarios
Morris
investigar
acerca
lograr
pre-
guntar
padre
experto
seguridad
Agencia
Nacional
Seguridad
agencia
go-
bierno
EE.UU.
dedicada
quebrantar
códigos
proporcionara
reimpresión
artículo
clásico
tema
padre
Ken
Thompson
escrito
década
Bell
Labs
Morris
Thompson
1979
contraseña
quebrantada
permitía
gusano
iniciar
se-
sión
máquina
propietario
contraseña
tuviera
cuentas
gusano
obtenía
acceso
máquina
comprobaba
copias
activas
gusano
copia
dejaba
ejecutarse
ve-
ces
seguía
ejecución
intento
seguir
propagando
gusano
administrador
sistema
iniciara
versión
gusano
engañar
gusano
real
es-
proceso
creaban
demasiados
gusanos
razón
máquinas
infec-
tadas
dejaban
funcionar
momento
infestadas
gusanos
Morris
hubiera
omitido
gusano
simplemente
dejara
ejecutarse
detectar
gusano
hubieran
detectado
Morris
atraparon
amigos
habló
reportero
computadoras
New
York
TimesJohn
Markoff
trató
convencerlo
incidente
accidente
www.FreeLibros.meque
gusano
inofensivo
autor
sentía
amigo
darse
nom-
bre
inicio
sesión
perpetrador
rtm
fácil
convertir
rtm
nombre
propieta-
rio
Markoff
ejecutar
finger
historia
sección
principal
página
inclusive
eclipsó
elección
presidencial
des-
pués
corte
federal
juzgó
condenó
Morris
sentenciado
multa
10,000
años
libertad
condicional
400
horas
servicio
comunitario
costos
legales
probablemente
exce-
150,000
sentencia
generó
controversia
comunidad
compu-
tacional
sentían
brillante
estudiante
graduado
cuya
broma
inofensiva
salido
control
gusano
sugería
Morris
tratara
robar
dañar
sentían
criminal
serio
debería
ido
cárcel
Tiempo
Morris
obtuvo
Ph
D.
Har-
vard
profesor
M.I.T.
efecto
permanente
incidente
establecimiento
CERT
Computer
Emer-
gency
Response
Team
Equipo
respuesta
emergencias
computacionales
proporciona
lugar
central
reportar
intentos
entrar
sistema
autorización
grupo
ex-
pertos
analizar
problemas
seguridad
diseñar
correcciones
duda
ac-
ción
paso
negativo
CERT
recolecta
información
fallas
sistemas
sufrir
ataques
maneras
corregirlas
necesidad
po-
ne
información
circulación
nivel
mundial
miles
administradores
sistemas
In-
ternet
desgracia
tipos
malos
hagan
pasar
administradores
sistemas
obtener
reportes
errores
explotar
lagunas
horas
cierren
gusano
Morris
liberó
variedad
gusanos
operan
lineamientos
gusano
Morris
explotan
distintos
errores
tipo
software
Tienden
esparcirse
rapidez
virus
desplazan
consecuencia
desarrollando
tecnología
anti-gusanos
atraparlos
justo
aparecen
esperar
cataloguen
introduzcan
gusano
base
datos
central
Portokalidis
Bos
2007
9.7.4
Spyware
spyware
tipo
malware
común
general
spyware
software
carga
clandestina
PC
propietario
entere
ejecuta
pla-
cosas
espaldas
propietario
definirlo
complicado
ejem-
plo
Windows
Update
descarga
automática
parches
seguridad
máquinas
Windows
propietarios
enteren
forma
programas
antivirus
actua-
lizan
automática
plano
spyware
Potter
Stewart
estuviera
vivo
probablemente
diría
definir
spyware
reconozco
veo
684
SEGURIDAD
CAPÍTULO
Potter
Stewart
juez
Suprema
Corte
EUA
1958
1981
famoso
escribir
opinión
so-
bre
caso
relacionado
pornografía
admitió
definir
pornografía
reconozco
cuan-
do
veo
www
FreeLibros.meSECCIÓN
9.7
MALWARE
685
esforzado
definirlo
Barwinski
colaboradores
2006
características
lugar
oculta
víctima
encontrarlo
facilidad
lugar
recolecta
datos
usuario
sitios
Web
visitados
contraseñas
números
tarjetas
crédito
tercer
lugar
comunica
información
recolectada
vuelta
amo
distante
cuarto
lugar
sobrevivir
distintos
intentos
eliminar-
spyware
modifica
configuración
realiza
actividades
maliciosas
mo-
lestas
veremos
continuación
Barwinsky
colaboradores
dividieron
spyware
amplias
categorías
marketing
spyware
recolecta
información
envía
vuelta
amo
general
publicidad
dirigida
máquinas
específicas
categoría
vigilancia
empresas
colocan
spyware
intencional
máquinas
empleados
registro
sitios
Web
visitan
categoría
acerca
malware
clásico
máquina
infectada
convierte
arreglo
zombies
espera
amo
órdenes
desplazarse
investigadores
experimento
tipos
sitios
Web
contienen
spy-
ware
visitar
5000
sitios
Observaron
principales
proveedores
spyware
sitios
Web
relacionados
entretenimiento
adultos
viajes
línea
bienes
raíces
Universidad
Washington
estudio
Moshchuk
colaboradores
2006
estudio
inspeccionaron
18
millones
URLs
descubrió
6%
contiene
spyware
ende
sorpresa
estudio
AOL
NCSA
citan
80%
computadoras
domésticas
inspeccionadas
infestadas
spywa-
re
promedio
93
piezas
spyware
computadora
estudio
UW
descubrió
sitios
adultos
celebridades
papel
tapiz
computadora
tenían
tasas
infec-
ción
examinaron
viajes
bienes
raíces
esparce
spyware
pregunta
obvia
infecta
spyware
computadora
formas
caballo
Troya
troyano
similar
malware
can-
tidad
considerable
software
gratuito
contiene
spyware
autor
software
dinero
spyware
software
compartición
archivos
punto
punto
Kazaa
lleno
spyware
sitios
Web
muestran
anuncios
pancarta
llevan
navegan-
tes
páginas
Web
infestadas
spyware
ruta
principal
infección
conoce
descarga
paso
ad-
quirir
spyware
tipo
malware
visitar
página
Web
infectada
variantes
tecnología
infección
lugar
página
Web
redirigir
navegador
archivo
ejecutable
.exe
navegador
ve
archivo
aparece
cuadro
diálogo
preguntando
usuario
desea
ejecutar
guardar
programa
descargas
legíti-
utilizan
mecanismo
mayoría
usuarios
clic
Ejecutar
navegador
descarga
ejecuta
software
punto
máquina
infectada
spy-
ware
libertad
quiera
ruta
común
barra
herramientas
infectada
Internet
Explorer
Fi-
refox
soportan
barras
herramientas
terceras
partes
escritores
spyware
crean
www.FreeLibros.mebarra
herramientas
agradable
característica
útiles
publicidad
grandioso
complemento
gratuito
personas
instalan
barra
herra-
mientas
reciben
spyware
ejemplo
popular
barra
herramientas
Alexa
contiene
spywa-
re
esencia
esquema
caballo
Troya
empaqueta
distinta
variante
infección
sinuosa
páginas
Web
utilizan
tecnología
Microsoft
llamada
controles
activeX.
controles
programas
binarios
Pentium
conectan
Internet
Explorer
extienden
funcionalidad
ejemplo
visualizar
tipos
es-
peciales
páginas
Web
imágenes
audio
video
principio
tecnología
perfectamen-
legítima
práctica
peligrosa
principal
método
ocurren
infecciones
spyware
método
dirigido
IE
Internet
Explorer
Fire-
fox
navegadores
visita
página
control
activeX
ocurre
depende
configuración
seguridad
IE
baja
spyware
descarga
instala
automáti-
ca
razón
personas
establecen
configuración
seguridad
nivel
nivel
alto
sitios
Web
muestran
correctamente
muestran
completo
IE
pidiendo
permiso
constante
acción
usuario
comprende
suponga
usuario
nivel
configuración
seguridad
alto
visitar
página
Web
IE
detecta
control
activeX
muestra
cuadro
diálogo
contiene
mensaje
proporcionado
página
Web
mensaje
Desea
instalar
ejecutar
programa
agilice
acceso
Internet
mayoría
personas
piensa
clic
ACEPTAR
es-
to
quedan
infectados
usuarios
sofisticados
revisen
resto
cuadro
diálogo
don-
encontrarán
elementos
vínculo
certificado
página
Web
vimos
sección
9.2.4
proporciona
CA
oído
contiene
in-
formación
útil
aparte
CA
afirma
empresa
suficiente
dine-
ro
pagar
certificado
hipervínculo
página
Web
distinta
proporciona
página
Web
visitando
propósito
explicar
control
ac-
tiveX
cosa
general
explica
maravilloso
control
activeX
ayudará
usuario
mejorar
experiencia
navegación
Armados
información
falsa
usuarios
sofisticados
clic
clic
común
secuencia
comandos
página
Web
utilice
error
IE
tratar
descargar
spyware
formas
error
disponible
explotarlo
tratar
descargar
control
activeX
intento
IE
mues-
tra
cuadro
diálogo
mayoría
personas
punto
administrador
tareas
cierran
IE
momento
rinden
clic
quedan
infectados
ocurre
continuación
spyware
muestra
licencia
20
30
páginas
escrito
lenguaje
Geoffrey
Chaucer
abogado
especializado
en-
tenderían
usuario
acepta
licencia
perder
derecho
demandar
dis-
tribuidor
spyware
consentir
ejecute
libremente
leyes
locales
invalidan
licencias
licencia
concesionario
otorgante
686
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
687
licencia
irrevocable
derecho
matar
madre
concesionario
reclamar
herencia
otorgante
licencia
problemas
convencer
cortes
quie-
ra
cobrar
dinero
concesionario
aceptó
condiciones
Acciones
realiza
spyware
veamos
spyware
frecuencia
puntos
lista
co-
munes
Modifica
página
inicio
navegador
Modifica
lista
páginas
favoritas
sitios
favoritos
navegador
Agrega
barras
herramientas
navegador
Cambia
reproductor
medios
predeterminado
usuario
Cambia
motor
búsqueda
predeterminado
usuario
Agrega
iconos
escritorio
Windows
Reemplaza
anuncios
pancarta
banners
páginas
Web
elije
mis-
mo
spyware
Coloca
anuncios
cuadros
diálogo
estándar
Windows
Genera
flujo
continuo
imparable
anuncios
emergentes
pop-up
puntos
modifican
comportamiento
navegador
general
forma
reiniciando
sistema
restaurar
valores
anteriores
ataque
conoce
co-
mo
secuestro
navegador
puntos
modifican
opciones
registro
Windows
usuario
entere
llevan
reproductor
medios
distinto
muestra
anuncios
elegidos
spyware
motor
búsqueda
distinto
devuelve
resultados
búsquedas
sitios
Web
spyware
desea
Agregar
iconos
escritorio
intento
obvio
usuario
ejecute
software
recién
instalado
reemplazar
anuncios
pancarta
banners
imágenes
.gif
468
/H1100360
páginas
Web
subsiguientes
parecer
páginas
Web
visitan
anunciando
sitios
spyware
selecciona
últi-
mo
punto
molesto
anuncio
emergente
cerrar
genera
in-
mediato
anuncio
emergente
ilimitada
forma
detenerlos
spyware
deshabilita
firewall
elimina
spyware
competencia
ca-
bo
acciones
maliciosas
programas
spyware
incluyen
desinstaladores
funcionan
usuarios
experimentados
eliminar
spyware
fortuna
creando
industria
software
antispyware
empresas
antivirus
existentes
empezando
participar
confundir
spyware
adware
distribuidores
software
legí-
timo
pequeño
ofrecen
versiones
producto
gratuito
anuncios
www.FreeLibros.metiene
costo
anuncios
empresas
claras
existencia
versiones
producto
ofrecen
usuarios
opción
actualizar
software
versión
comercial
deshacerse
anuncios
9.7.5
Rootkits
rootkit
programa
conjunto
programas
archivos
intenta
ocultar
existencia
frente
esfuerzos
determinados
propietario
máquina
infectada
localizarlo
eliminarlo
general
rootkit
contiene
malware
oculta
rootkits
pue-
den
instalar
cualquiera
métodos
analizados
incluyendo
virus
gu-
sanos
spyware
medios
analizaremos
Tipos
rootkits
analizar
tipos
rootkits
posibles
actualidad
abajo
casos
cuestión
oculta
rootkit
Rootkits
firmware
teoría
ocultar
rootkit
BIOS
reprograma
incluye
copia
rootkit
rootkit
obtendría
control
iniciara
máquina
hiciera
llamada
función
BIOS
rootkit
cifrara
descifrara
difícil
detectar
observado
tipo
rootkit
co-
munidad
computadoras
Rootkits
hipervisor
tipo
rootkit
sigiloso
ejecutar
sistema
ope-
rativo
aplicaciones
máquina
virtual
control
prueba
con-
cepto
blue
pill
referencia
película
llamada
The
Matrix
hacker
polaca
llamada
Joanna
Rutkowska
demostró
2006
general
tipo
rootkit
modifica
secuencia
arranque
forma
encender
máquina
ejecute
hi-
pervisor
directamente
hardware
inicia
sistema
operativo
aplica-
ciones
máquina
virtual
fortaleza
método
oculto
sistema
operativo
bibliotecas
programas
mane-
ra
detectores
rootkits
busquen
encontrarán
Rootkits
kernel
tipo
común
rootkit
actualidad
infecta
sis-
tema
operativo
oculta
driver
dispositivo
módulo
ker-
nel
cargar
opcional
rootkit
reemplazar
facilidad
driver
extenso
complejo
cambia
frecuencia
contenga
dri-
rootkit
Rootkits
biblioteca
lugar
ocultar
rootkit
biblioteca
sistema
ejemplo
libc
Linux
ubicación
malware
oportunidad
inspeccionar
argumentos
valores
retorno
llamadas
sistema
modi-
fica
necesario
mantenerse
oculto
688
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
689
Rootkits
aplicación
lugar
ocultar
rootkit
programa
apli-
cación
extenso
especial
cree
archivos
ejecuta
per-
files
usuario
vistas
previas
imágenes
etc.
archivos
lugares
ocultar
cosas
extraño
existan
figura
9-30
muestra
lugares
ocultar
rootkits
Sistema
operativo
Sistema
operativo
Sistema
operativo
Sistema
operativo
Sistema
operativo
Biblioteca
Aplica-
ción
HW
Biblioteca
Aplica-
ciónHipervisor
HW
BIOS
Biblioteca
Aplica-
ciónHW
BIOS
Biblioteca
Aplica-
ciónHW
BIOS
Biblioteca
Aplica-
ciónHW
BIOS
Figura
9-30
lugares
ocultar
rootkit
Detección
rootkits
difícil
detectar
rootkits
confiar
hardware
sistema
operativo
bibliotecas
aplicaciones
ejemplo
obvia
buscar
rootkit
listados
archivos
disco
llamada
sistema
lee
directo-
rio
procedimiento
biblioteca
realiza
llamada
sistema
programa
realiza
listado
potencialmente
maliciosos
censurar
resultados
omitiendo
ar-
chivos
relacionados
rootkit
situación
irremediable
veremos
continuación
complicado
detectar
rootkit
inicie
hipervisor
ejecute
sistema
operativo
aplicaciones
máquina
virtual
control
imposible
analizar
cuidado
discrepancias
menores
rendimiento
funcionalidad
máquina
virtual
real
Garfinkel
colaboradores
2007
sugerido
veremos
continuación
Carpenter
colaboradores
2007
hablado
tema
clase
completa
métodos
detección
basa
hipervisor
utiliza
recursos
físicos
detectar
pérdida
recursos
ejemplo
hipervisor
necesita
entradas
TLB
compite
máquina
virtual
escasos
re-
cursos
programa
detección
presión
TLB
observar
rendimiento
compararlo
rendimiento
obtenido
hardware
www
FreeLibros.meOtra
clase
métodos
detección
relacionada
sincronización
especial
dispositivos
virtualizados
Suponga
requieren
100
ciclos
reloj
leer
re-
gistro
dispositivos
PCI
máquina
real
probabilidades
repro-
ducirse
entorno
virtual
valor
registro
proviene
memoria
tiempo
lectura
depende
caché
nivel
CPU
RAM
progra-
ma
detección
tendría
dificultades
obligar
registro
cambiar
medir
variabilidad
tiempos
lectura
Observe
variabilidad
importa
tiem-
po
lectura
área
sondear
tiempo
requerido
ejecutar
instrucciones
privilegia-
das
especial
requieren
ciclos
reloj
hardware
real
requie-
ren
cientos
miles
ciclos
reloj
emular
ejemplo
leer
registro
protegido
CPU
requiere
nseg
hardware
real
forma
puedan
reali-
zar
mil
millones
interrupciones
emulaciones
hipervisor
pue-
trampa
reportar
tiempo
emulado
tiempo
real
llamadas
sistema
involucre
tiempo
detector
evitar
tiempo
emulado
conectar-
máquina
remota
sitio
Web
proporcione
base
tiempo
precisa
detector
necesita
medir
intervalos
ejemplo
tiempo
requiere
ejecutar
mil
millones
lecturas
registro
protegido
importa
variación
reloj
local
remoto
hipervisor
escabullido
hardware
sistema
operativo
rootkit
oculto
difícil
detectarlo
iniciar
computadora
pude
confiar
sistema
operativo
ejemplo
rootkit
instalar
nú-
mero
archivos
cuyos
nombres
empiecen
lea
directorios
progra-
usuario
reportará
existencia
dichos
archivos
detectar
rootkits
circunstancias
iniciar
computadora
externo
confiable
CD-ROM
DVD
memoria
USB
originales
ex-
plorar
disco
programa
antirootkit
temor
rootkit
interfiera
exploración
alternativa
hash
criptográfico
archivo
sistema
operativo
comparar
resultados
lista
creado
momen-
to
instalar
sistema
almacenado
alte-
rar
hubieran
dichos
cálculos
hashes
principio
calcular
CD-ROM
DVD
instalación
momento
comparar
ar-
chivos
rootkits
bibliotecas
programas
aplicación
difíciles
ocultar
sistema
operativo
cargó
externo
confiable
hashes
comparar
hashes
almacenados
CD-ROM
analizado
rootkits
pasivos
interfieren
software
detec-
ción
rootkits
activos
buscan
destruyen
software
detección
rootkits
modifican
anunciar
ENCONTRARON
ROOTKITS
Es-
tos
rootkits
requieren
medidas
complicadas
fortuna
aparecido
rootkits
ac-
tivos
comunidad
computadoras
corrientes
opinión
descubrir
rootkit
establece
administrador
sistema
comportar
cirujano
690
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.7
MALWARE
691
cáncer
extirparlo
cuidado
corriente
establece
peli-
groso
tratar
eliminar
rootkit
piezas
ocultas
punto
vista
úni-
ca
solución
regresar
respaldo
completo
esté
limpio
respaldo
disponible
requiere
instalación
CD-ROM
DVD
original
rootkit
Sony
2005
Sony
BMG
liberó
CDs
audio
contenían
rootkit
Mark
Russinovich
cofundador
sitio
Web
herramientas
administrativas
Windows
www.sysinternals.com
descubrió
trabajando
desarrollar
detector
rootkits
sorprendió
encontrar
rootkit
sistema
Mark
escribió
blog
historia
Internet
medios
masivos
Algu-
científicos
escribieron
artículos
Arnab
Hutchison
2006
Bishop
Frincke
2006
Felten
Halderman
2006
Halderman
Felten
2006
Levine
colaboradores
2006
furor
resultante
tardó
años
desaparecer
continuación
veremos
descripción
ocurrió
usuario
inserta
CD
unidad
computadora
Windows
sistema
ope-
rativo
busca
archivo
llamado
autorun.inf
contiene
lista
acciones
inicia
programa
CD
asistente
instalación
general
CDs
audio
archivos
reproductores
CD
independientes
ignoran
presentes
Aparentemente
genio
Sony
pensó
inteligencia
detener
piratería
música
colocar
archivo
autorun.inf
CDs
justo
insertaba
computadora
instalaba
silenciosa
rootkit
12
MB
apa-
recía
licencia
mencionaba
acerca
software
iba
instalar
mostraba
licencia
software
Sony
comprobaba
ejecución
200
programas
copia
conocidos
pedía
usuario
cerrara
usuario
es-
taba
licencia
detenía
programas
reproducía
música
caso
contrario
reproducía
caso
usuario
rechazara
licencia
rootkit
per-
manecía
instalado
rootkit
funcionaba
Insertaba
kernel
Windows
ar-
chivos
cuyos
nombres
empezaban
sys$.
archivos
filtro
intercepta-
ba
llamadas
sistema
relacionadas
unidad
CD-ROM
prohibía
programas
reproductor
música
Sony
leyeran
CD
acción
im-
copiar
CD
disco
duro
legal
filtro
interceptaba
llamadas
leían
listados
archivos
procesos
registros
eliminaban
entradas
empeza-
ban
sys$
programas
tenían
relación
Sony
música
cubrir
rootkit
método
estándar
diseñadores
rootkits
principiantes
Russinovich
descubriera
rootkit
instalado
compu-
tadoras
sorprendente
20
millones
CDs
Ka-
minsky
2006
estudió
extensión
descubrió
computadoras
infectadas
500,000
redes
www
FreeLibros.meCuando
difundieron
noticias
reacción
inicial
Sony
derecho
proteger
propiedad
intelectual
entrevista
Radio
Pública
Nacional
presiden-
negocios
digitales
globales
Sony
BMG
nombre
Thomas
Hesse
ma-
yoría
personas
siquiera
rootkit
deberían
preocupar
respuesta
provocó
tormenta
fuego
Sony
retractó
liberó
parche
eliminaba
cobertura
archivos
sys$
mantenía
rootkit
lugar
presión
Sony
liberó
momento
desinstalador
sitio
Web
obtenerlo
usuarios
tenían
proporcionar
dirección
co-
rreo
electrónico
tenían
Sony
enviarles
material
promocional
futuro
mayoría
personas
llaman
spam
medida
historia
continuaba
resultó
desinstalador
Sony
contenía
fallas
téc-
nicas
dejaban
computadora
infectada
vulnerable
ataques
Internet
reveló
rootkit
contenía
código
proyectos
código
fuente
abierto
violaban
de-
rechos
autor
permitía
libre
software
liberara
código
fuente
desastre
incomparable
relaciones
públicas
Sony
enfrentó
riesgo
legal
Texas
demandó
Sony
violar
ley
antispyware
vio-
lar
ley
prácticas
comerciales
engañosas
rootkit
instalaba
rechazara
licencia
presentaron
demandas
colectivas
39
diciembre
2006
es-
tas
demandas
resolvieron
Sony
acordó
pagar
4.25
millones
dejar
incluir
rootkit
CDs
futuros
víctima
derecho
descargar
álbumes
catálogo
mú-
sica
limitado
enero
2007
Sony
admitió
software
monitoreaba
hábitos
escucha
usuarios
reportaba
vuelta
Sony
violación
ley
EE.UU.
FTC
Sony
acordó
pagar
compensación
150
personas
cuyas
computadoras
dañaron
software
Incluimos
historia
rootkit
Sony
beneficio
lectores
pudieran
llegar
pensar
rootkits
curiosidad
académica
implicaciones
reales
busca
Sony
rootkit
Internet
recibirá
información
adicional
9.8
DEFENSAS
problemas
merodeando
lados
esperanza
sistemas
puedan
seguros
realidad
siguientes
secciones
analizaremos
formas
diseñar
implementar
sistemas
incrementar
seguridad
concep-
tos
importantes
defensa
profundidad
idea
básica
debemos
va-
rios
niveles
seguridad
viola
quedan
niveles
defensa
Piense
casa
barda
hierro
cerrada
alta
picos
detec-
tores
movimiento
jardín
candados
industriales
puerta
frontal
sistema
alar-
ma
robos
computarizado
interior
técnica
valiosa
robar
casa
ladrón
tendría
vencerlas
sistemas
computacionales
seguridad
apropiada
casa
niveles
seguridad
veremos
692
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
693
realidad
defensas
jerárquicas
empezaremos
exteriores
ge-
nerales
avanzaremos
específicas
9.8.1
Firewalls
habilidad
conectar
computadora
compu-
tadora
ventaja
claroscuros
material
valioso
Web
computadora
conectada
Internet
expuesta
tipos
peligros
entrantes
sa-
lientes
peligros
entrantes
incluyen
crackers
tratan
entrar
computadora
virus
spyware
malware
peligros
salientes
incluyen
información
confidencial
números
tarjetas
crédito
contraseñas
devoluciones
impuestos
tipo
informa-
ción
corporativa
consecuencia
requieren
mecanismos
mantener
bits
adentro
bits
malos
afuera
métodos
firewall
adaptación
mo-
derna
antiguo
recurso
seguridad
medieval
cavar
foso
profundo
castillo
diseño
obligaba
entraban
salían
castillo
pasar
puente
leva-
dizo
policía
podía
inspeccionarlos
redes
truco
empresa
LANs
conectadas
formas
arbitrarias
tráfico
entrante
saliente
empresa
pasa
obligatoria
puente
levadizo
electrónico
firewall
variedades
básicas
firewall
hardware
software
general
empre-
sas
proteger
LANs
optan
firewalls
hardware
individuos
hogar
eligen
frecuencia
firewalls
software
analizaremos
firewalls
hardware
figura
9-31
ilustra
firewall
hardware
genérico
conexión
cable
fibra
óptica
proveedor
red
conecta
firewall
conecta
LAN
entrar
paque-
tes
LAN
salir
firewall
apruebe
práctica
firewalls
combinan
enrutadores
cajas
resolución
direcciones
sistemas
detección
intrusos
cosas
enfoque
funcionalidad
firewall
207.68.160.190:80
207.68.160.191:25
207.68.160.192:21
Servidor
Web
Servidor
correo
electrónico
Servidor
FTPFirewall
Red
área
local
Conexión
red
Figura
9-31
vista
simplificada
firewall
hardware
protege
LAN
computadoras
firewalls
configuran
reglas
describen
entrar
salir
propietario
firewall
cambiar
reglas
común
interfaz
Web
www.FreeLibros.memayoría
firewalls
mini
servidor
Web
integrado
permitir
tipo
firewall
simple
fir
ewall
inspecciona
encabezado
paquete
pa-
sa
toma
decisión
aceptar
rechazar
paquete
base
información
encabezado
reglas
firewall
información
encabezado
paquete
incluye
di-
recciones
IP
origen
destino
puertos
origen
destino
tipo
servicio
protocolo
campos
disponibles
ocurren
raras
reglas
ejemplo
figura
9-31
servidores
dirección
IP
única
forma
207.68.160.x
190
191
192
respectivamente
di-
recciones
enviar
paquetes
lleguen
servidores
paque-
tes
entrantes
contienen
número
puerto
16
bits
especifica
proceso
máquina
recibir
paquete
proceso
escuchar
puerto
tráfico
entrante
Al-
gunos
puertos
servicios
asociados
especial
puerto
80
utiliza
Web
puerto
25
correo
electrónico
puerto
21
servicio
FTP
transferencia
archivos
mayoría
puertos
disponibles
servicios
definidos
usuario
es-
tas
condiciones
firewall
configurar
forma
Dirección
IP
Puerto
Acción
207.68.160.190
80
Aceptar
207.68.160.191
25
Aceptar
207.68.160.192
21
Aceptar
Rechazar
reglas
permiten
paquetes
máquina
207.68.160.190
dirigidos
pa-
ra
puerto
80
puertos
máquina
prohibidos
firewall
descartará
silencio
paquetes
envíen
similar
paquetes
servidores
dirigidos
puertos
25
21
respectivamente
resto
tráfico
des-
carta
conjunto
reglas
difícil
atacante
obtenga
acceso
LAN
servicios
públicos
ofrecen
firewall
atacar
LAN
ejemplo
servidor
Web
apache
cracker
descubre
error
apache
explotar
enviar
URL
dirección
207.68.160.190
puerto
80
forzar
desbordamiento
búfer
contro-
laría
máquinas
firewall
utilizar
lanzar
ataque
máquinas
LAN
ataque
potencial
escribir
publicar
juego
multijugador
lograr
amplia
aceptación
software
juego
necesita
puerto
conectarse
jugado-
res
diseñador
juego
seleccionar
ejemplo
9876
indicar
jugadores
cambien
configuración
firewall
permitir
tráfico
entrante
saliente
puerto
personas
abran
puerto
estarán
sujetas
sufrir
ataques
sencillo
juego
contiene
caballo
Troya
acepte
comandos
remotos
ejecute
juego
legítimo
contener
errores
puedan
explotar
En-
tre
puertos
estén
abiertos
probabilidad
ataque
exitoso
ho-
incrementa
posibilidad
infiltre
ataque
694
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
695
firewalls
firewalls
mantienen
regis-
tro
conexiones
encuentran
firewalls
mejores
vencer
tipos
ataques
especial
relacionados
establecimiento
conexio-
nes
tipos
firewalls
implementan
IDS
Intrusion
Detection
System
Sistema
detección
intrusos
firewall
inspecciona
encabezados
paquetes
contenido
busca
material
sospechoso
firewalls
software
conoce
fi
rewalls
personales
firewalls
hardware
software
filtros
conectan
código
red
kernel
sistema
operativo
filtran
paquetes
forma
firewall
hardware
9.8.2
antivirus
técnicas
anti-antivirus
firewalls
tratan
mantener
intrusos
computadora
fallar
di-
versas
formas
veremos
continuación
caso
línea
defensa
com-
puesta
programas
antimalware
conocen
comúnmente
programas
antivirus
combaten
gusanos
spyware
virus
tratan
ocultarse
usuarios
tratan
encontrarlos
parecido
juego
gato
ratón
sentido
virus
rootkits
mayoría
escritores
virus
enfocan
rápi-
do
esparcimiento
virus
jugar
escondidas
rootkits
analizaremos
técnicas
utilizadas
software
antivirus
forma
Virgilio
escritor
virus
responde
Exploradores
virus
duda
usuario
promedio
encontrar
virus
esfuer-
zo
ocultarse
desarrollado
mercado
software
antivirus
continuación
analizaremos
forma
funciona
software
empresas
software
antivirus
labo-
ratorios
científicos
dedicados
trabajan
largas
horas
rastrear
comprender
virus
paso
virus
infecte
programa
conocido
ar-
chivo
señuelo
goat
file
obtener
copia
virus
forma
pura
paso
listado
exacto
código
virus
introducirlo
base
datos
virus
conocidos
empresas
compiten
tamaño
bases
datos
inventar
virus
aumentar
tamaño
base
datos
conducta
deportiva
instala
programa
antivirus
máquina
cliente
ha-
ce
explorar
archivos
ejecutables
disco
busca
cualquiera
virus
base
datos
virus
conocidos
mayoría
empresas
antivirus
sitio
Web
clientes
descargar
descripciones
virus
recién
descubiertos
bases
datos
usuario
10,000
archivos
base
datos
10,000
virus
duda
requie-
re
programación
inteligente
agilizar
proceso
surgen
variantes
menores
virus
conocidos
tiempo
necesita
búsqueda
difusa
asegurar
cambio
bytes
virus
evite
detección
www.FreeLibros.mebúsquedas
difusas
lentas
exactas
activar
falsas
alarmas
falso
positivo
advertencias
archivos
legítimos
contienen
código
al-
go
similar
virus
reportado
Pakistán
años
supone
usuario
mensaje
ADVERTENCIA
archivo
xyz.exe
contener
virus
lahore-9x
Desea
eliminarlo
virus
base
datos
amplio
criterio
declarar
ocurrencia
falsas
alarmas
demasiadas
disgustado
usuario
rendirá
explorador
virus
insiste
ocurrencia
cercana
pasar
alto
virus
modificados
Ob-
detección
acertada
balance
delicado
heurística
teoría
laboratorio
debería
tratar
identificar
código
básico
virus
probabilidades
cambiar
utili-
zarlo
firma
virus
buscar
disco
declarado
libre
virus
semana
significa
esté
ejecutar
explorador
virus
frecuencia
exploración
lenta
eficiente
comprobar
archivos
modificado
fecha
úl-
tima
exploración
problema
virus
inteligente
restablecerá
fecha
archivo
infec-
tado
fecha
original
evitar
detectado
respuesta
programa
antivirus
acción
comprobar
fecha
modificó
directorio
contiene
archivo
respuesta
vi-
rus
acción
restablecer
fecha
directorio
inicio
juego
gato
ratón
mencionamos
forma
programa
antivirus
detectar
infección
archivos
registrar
almacenar
disco
longitudes
archivos
archivo
creció
tamaño
comprobación
infectado
muestra
figura
9-32(a
embar-
go
virus
inteligente
evitar
detección
comprimir
programa
rellenar
espacio
li-
bre
archivo
longitud
original
esquema
funcionar
virus
contener
procedimientos
compresión
descompresión
muestra
figura
9-32(c
forma
virus
tratar
evitar
detección
asegurarse
representación
disco
apariencia
representación
base
datos
soft-
ware
antivirus
lograr
objetivo
cifre
clave
distin-
ta
archivo
infectado
copia
virus
genera
clave
cifrado
aleatoria
32
bits
ejemplo
aplicando
XOR
tiempo
actual
contenido
ejemplo
palabras
memoria
72,008
319,992
aplica
XOR
código
clave
palabra
palabra
producir
virus
cifrado
almacena
archivo
infectado
muestra
figura
9-32(d
clave
almacena
archivo
fines
mantener-
secreto
ideal
colocar
clave
archivo
objetivo
frustrar
explora-
dor
virus
evitar
científicos
dedicados
laboratorio
antivirus
apliquen
ingeniería
inversa
código
ejecutarse
virus
descifrarse
prime-
ro
necesita
función
descifrado
archivo
esquema
perfecto
procedimientos
compresión
descompresión
cifrado
descifrado
copias
programa
antivirus
utilizar
firma
antivirus
buscar
proceso
exploración
fácil
ocultar
procedimien-
tos
compresión
descompresión
cifrado
cifran
resto
virus
muestra
figura
9-32(e
código
descifrado
cifrar
tie-
696
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
697
ne
ejecutar
hardware
descifrar
resto
virus
presente
tex-
to
simple
programas
antivirus
buscan
procedimiento
descifrado
Programa
ejecutable
Encabezado
Programa
ejecutable
Encabezado
Descompresor
Compresor
Programa
ejecutable
comprimido
Programa
ejecutable
comprimido
Encabezado
Descifrador
Encabezado
Cifrador
Compresor
Virus
cifrado
Descompresor
Programa
ejecutable
comprimido
Cifrador
Compresor
Virus
cifrado
Descompresor
Encabezado
archivo
Virus
Tamaño
original
Virus
Tamaño
original
Tamaño
original
Cifrado
Clave
Descifrador
Clave
utilizar
Figura
9-32
programa
programa
infectado
programa
infecta-
do
comprimido
virus
cifrado
virus
comprimido
código
com-
presión
cifrado
obstante
Virgilio
disfruta
palabra
procede
ma-
nera
Suponga
procedimiento
descifrado
necesita
cálculo
/H11005(A
figura
9-33(a
muestra
código
ensamblador
directo
cálculo
computado-
ra
genérica
direcciones
dirección
origen
destino
MOV
R1mueve
variable
registro
R1
código
figura
9.33(b
eficiencia
instrucciones
NOP(ninguna
operación
inter-
caladas
código
real
Figura
9-33
Ejemplos
virus
polimórfico
www
FreeLibros.mePero
terminamos
disfrazar
código
descifrado
formas
representar
instrucción
NOP
ejemplo
sumar
registro
aplicar
OR
mis-
ma
instrucción
desplazarla
izquierda
bits
saltar
instrucción
procedimientos
programa
figura
9-33(c
función
figura
9-33(a
copiarse
virus
utilizar
figura
9-33(c
9-33(a
seguir
funcionando
ejecutado
virus
muta
copia
cono-
ce
virus
polimórfico
suponga
necesita
R5para
pieza
código
fi-
gura
9-33(d
equivalente
9-33(a
casos
intercam-
biar
instrucciones
cambiar
programa
terminamos
figura
9-33(e
fragmento
código
equivalencia
lógica
figura
9-33(a
pieza
código
mutar
secuencia
instrucciones
máquina
cambiar
funcionali-
dad
conoce
motor
mutación
virus
sofisticados
contienen
mutar
desci-
frador
copia
mutaciones
consistir
inserción
código
inútil
inofensivo
permutación
instrucciones
intercambio
registros
reemplazo
instrucción
equivalente
motor
mutación
ocultarse
ci-
fra
cuerpo
virus
pedir
pobre
software
antivirus
comprenda
figuras
9-33
fun-
cionalmente
equivalentes
especial
motor
mutación
trucos
manga
software
antivirus
analizar
código
tratar
simular
operación
código
debemos
recordar
miles
virus
miles
archivos
analizar
tiempo
prueba
ejecutará
lentitud
terrible
información
adicional
incluyó
operación
almacenamiento
variable
difícil
detectar
código
relacionado
R5es
código
muerto
fragmentos
código
leen
valor
escriben
variable
código
apariencia
perfectamente
legítima
motor
mutación
escrito
ge-
nere
código
polimórfico
calidad
dolores
cabeza
escritores
software
antivirus
único
positivo
motor
difícil
escribir
amigos
Virgilio
utilizan
código
significa
tantos
virus
distintos
cir-
culación
hablado
tratar
reconocer
virus
archivos
ejecutables
infecta-
explorador
virus
comprobar
MBR
sectores
arranque
lista
sectores
defectuosos
memoria
flash
memoria
CMOS
cosas
pasa
virus
residente
memoria
esté
ejecutando
momento
detec-
tado
suponga
virus
ejecución
monitorea
llamadas
sistema
forma
detectar
facilidad
programa
antivirus
leyendo
sector
arranque
pa-
ra
comprobar
virus
frustrar
programa
antivirus
virus
realiza
llamada
sis-
tema
devuelve
sector
arranque
lugar
oculto
lista
bloques
defectuosos
anotación
mental
volver
infectar
archi-
vos
explorador
virus
termine
evitar
engañado
virus
programa
antivirus
lecturas
directas
disco
pasando
alto
sistema
operativo
requiere
drivers
dispositivos
discos
IDE
SCSI
discos
comunes
programa
antivirus
698
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
699
portátil
estaría
sujeto
fallas
computadoras
discos
inusuales
co-
mo
pasar
alto
sistema
operativo
leer
sector
arranque
leer
archivos
ejecutables
peligro
virus
producir
datos
frau-
dulentos
archivos
ejecutables
Comprobadores
integridad
comprobación
integridad
método
completamente
distinto
detectar
virus
pro-
grama
antivirus
funciona
explora
disco
duro
busca
virus
convencido
disco
limpio
calcula
suma
comprobación
archivo
ejecutable
algoritmo
sumas
comprobación
simple
tratar
palabras
texto
programa
enteros
32
64
bits
sumarlas
hash
criptográfico
imposible
invertir
escribe
archivo
llamado
sumacomp
lista
sumas
comprobación
archivos
relevantes
di-
rectorio
directorio
próxima
ejecuta
vuelve
calcular
sumas
com-
probación
verifica
coincidan
archivo
sumacomp
archivo
infectado
lista
identificar
inmediato
problema
Virgilio
brazos
cruzados
escribir
virus
elimine
archivo
comprobación
escribir
virus
calcule
suma
comprobación
archivo
infectado
reemplace
entrada
archivo
sumas
comprobación
protegerse
tipo
comportamiento
programa
antivirus
tratar
ocultar
archivo
sumas
comprobación
probable
funcio-
nar
Virgilio
estudiar
programa
antivirus
cuidado
escribir
vi-
rus
idea
firmarlo
digitalmente
fácil
detectar
alteración
teoría
firma
digital
implicar
tarjeta
inteligente
clave
almacenada
forma
externa
programas
puedan
alcanzar
Comprobadores
comportamiento
comprobación
comportamiento
estrategia
utiliza
software
antivirus
método
programa
antivirus
vive
memoria
computadora
funcionando
atrapa
llamadas
sistema
idea
monitorear
actividad
trate
atrapar
vea
sospechoso
ejemplo
programa
normal
debe-
ría
tratar
sobrescribir
sector
arranque
intento
virus
forma
cambiar
memoria
flash
actitud
sospechosa
casos
claros
ejemplo
sobrescribir
archivo
ejecutable
peculiar
haga
compilador
software
antivirus
detecta
dicha
escritura
emi-
advertencia
espera
usuario
sepa
sentido
sobrescribir
ejecutable
con-
texto
trabajo
actual
similar
Word
sobrescriba
archivo
.doc
documento
lleno
macros
necesariamente
trabajo
virus
Windows
progra-
separar
archivo
ejecutable
permanecer
residentes
memoria
llamada
sistema
especial
dijimos
legítimo
formas
útil
advertencia
www
FreeLibros.meLos
virus
permanecer
pasivos
espera
programa
antivirus
elimi-
ne
ganado
sacrificar
responder
ataque
cabo
batalla
acalorada
virus
residente
memoria
antivirus
encuentran
mis-
ma
computadora
años
juego
llamado
Core
Wars
enfrentaban
pro-
gramadores
colocaba
programa
espacio
direcciones
vacío
programas
tomaban
turnos
sondear
memoria
objetivo
juego
localizar
borrar
oponente
hiciera
confrontación
virus
antivirus
simi-
lar
campo
batalla
máquina
pobre
usuario
realidad
confrontación
ocurra
virus
ventaja
escritor
ave-
riguar
detalles
programa
antivirus
comprar
copia
virus
libera
equipo
antivirus
modificar
programa
obligar
Virgi-
lio
comprar
copia
evitar
virus
historia
necesita
moraleja
historia
seguro
arrepentido
fácil
evitar
virus
tratar
rastrearlos
infectado
compu-
tadora
continuación
veremos
lineamientos
usuarios
individuales
tam-
bién
cosas
industria
general
cabo
reducir
problemas
forma
considerable
usuarios
evitar
infección
virus
lugar
elegir
sistema
operativo
ofrezca
alto
nivel
seguridad
límite
sólido
kernel
usuario
contraseñas
separadas
usuario
administrador
sistema
condiciones
virus
escabulla
forma
infectar
archivos
binarios
sistema
lugar
instalar
software
legal
compre
fabricante
con-
fiable
garantiza
ayuda
ocurrido
casos
em-
pleados
descontentos
introducen
virus
producto
software
comercial
riesgoso
descargar
software
sitios
Web
tableros
anuncios
electrónicos
tercer
lugar
comprar
paquete
software
antivirus
usarlo
indi-
caciones
asegurarse
obtener
actualizaciones
periódicas
sitio
Web
fabricante
cuarto
lugar
clic
adjuntos
correo
electrónico
pedir
envíen
adjuntos
correo
electrónico
envía
texto
ASCII
simple
seguro
adjuntos
contener
virus
activan
abrirlos
quinto
lugar
copias
frecuentes
archivos
clave
externo
disco
flexible
CD
grabable
cinta
conveniente
mantener
generaciones
ar-
chivo
serie
medios
respaldo
forma
usuario
descubre
virus
te-
ner
oportunidad
restaurar
archivos
tenían
infectados
ayuda
restaurar
archivo
infectado
ayer
versión
semana
ayuda
700
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
701
sexto
lugar
resistir
tentación
descargar
ejecutar
software
os-
tentoso
gratuito
fuente
desconocida
razón
gratuito
fabricante
desea
computadora
ejército
zombies
soft-
ware
máquina
virtual
seguro
ejecutar
software
desconocido
industria
debería
tomar
serio
amenaza
virus
modificar
prác-
ticas
peligrosas
lugar
sistemas
operativos
simples
característi-
cas
espectaculares
tengan
hoyos
seguridad
vida
lugar
olvidarse
contenido
activo
punto
vista
segu-
ridad
desastre
documento
alguien
envió
obligatorio
eje-
cutar
programa
ejemplo
archivos
JPEG
contienen
programas
ende
contener
virus
documentos
deberían
tercer
lugar
forma
proteger
escritura
cilindros
disco
evitar
virus
infecten
programas
contienen
protección
implemen-
tar
mapa
bits
controlador
liste
cilindros
protegidos
escri-
tura
mapa
debería
modificarse
usuario
active
interruptor
mecánico
panel
frontal
computadora
cuarto
lugar
memoria
flash
idea
debería
modificarse
activar
interruptor
externo
ocurrirá
usuario
instale
consciente
ac-
tualización
BIOS
tomará
seriedad
llegue
virus
realmente
ejemplo
ataque
mundo
financiero
restablezca
cuentas
bancarias
9.8.3
Firma
código
método
completamente
distinto
impedir
malware
computadora
recuerde
defensa
profundidad
ejecutar
software
distribuidores
confiables
mo-
dificaciones
cuestiones
surgen
rapidez
forma
usuario
pue-
software
realmente
proviene
distribuidor
correcto
modificado
salió
fábrica
cuestión
importante
descar-
ga
software
tiendas
línea
reputación
desconocida
descargar
controles
activeX
sitios
Web
control
activeX
proviene
empresa
software
reconocida
pro-
bable
contenga
caballo
Troya
ejemplo
seguro
usuario
método
utiliza
frecuencia
firma
digital
describe
sec-
ción
9.2.4
usuario
ejecuta
programas
complementos
drivers
controles
activeX
tipos
software
escritos
firmados
fuentes
confiables
probabilidades
problemas
menores
consecuencia
método
probablemente
juego
espectacular
ingenioso
gratuito
Snarky
Software
aprobará
prueba
firma
juego
firma
código
basa
criptografía
clave
pública
distribuidor
software
ge-
nera
par
clave
pública
clave
privada
pone
clave
disposición
público
guarda
clave
recelo
firmar
pieza
software
distribuidor
calcu-
función
hash
código
obtener
número
128
160
256
bits
dependiendo
utiliza
MD5
SHA-1
SHA-256
firmar
valor
hash
cifra
clave
www.FreeLibros.meprivada
realidad
descifra
utilizando
notación
figura
9-3
firma
acompaña
software
usuario
recibe
software
aplica
función
hash
guarda
resultado
descifra
firma
acompaña
clave
pública
distribuidor
compara
resultado
distribuidor
función
hash
resultado
acaba
calcular
coinciden
código
acepta
genuino
caso
contrario
rechaza
falsificación
cálculos
matemáticos
involucrados
difícil
alguien
alterar
softwa-
re
forma
función
hash
coincida
función
hash
obtiene
descifrar
firma
genuina
difícil
generar
firma
falsa
coincida
clave
privada
figura
9-34
ilustran
procesos
firma
verificación
702
SEGURIDAD
CAPÍTULO
Distribuidor
software
Generación
firma
hash(Programa
Firma
cifrar(H
Programa
Firma
Usuario
Programa
Firma
Internet
Verificación
firma
H1
hash(Programa
H2
descifrar(Firma
Acepta
programa
H1
H2
Figura
9-34
funciona
firma
código
páginas
Web
contener
código
controles
activeX
código
diversos
lenguajes
secuencias
comandos
código
firmado
cuyo
caso
navegador
examina
firma
automática
verificarla
navegador
nece-
sita
clave
pública
distribuidor
software
general
incluye
código
certificado
firmado
CA
responde
autenticidad
clave
pública
navegador
guardada
clave
pública
CA
verificar
certificado
cuen-
ta
certificado
firmado
CA
navegador
desconoce
aparecerá
cuadro
diálogo
preguntando
usuario
desea
aceptar
certificado
9.8.4
Encarcelamiento
viejo
ruso
Confiar
verificar
duda
software
men-
acuñó
viejo
ruso
pieza
software
esté
firmada
conveniente
verificar
comportamiento
correcto
figura
9-35
muestra
técnica
conocida
encarcelamiento
programa
recién
adquirido
ejecuta
proceso
figura
denomina
prisione-
ro
carcelero
proceso
confiable
sistema
monitorea
comportamiento
prisionero
proceso
encarcelado
realiza
llamada
sistema
ejecute
llamada
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
703
control
transfiere
carcelero
trampa
kernel
envía
número
llamada
sistema
parámetros
carcelero
decide
permitir
llamada
sistema
ejemplo
proceso
encarcelado
abrir
conexión
red
host
remoto
desconocido
carcelero
rechazar
llamada
eliminar
prisione-
ro
llamada
sistema
aceptable
carcelero
informa
kernel
cabo
llamada
forma
atrapar
comportamiento
erróneo
ocasione
problemas
implementaciones
encarcelamiento
Noordende
colaboradores
2007
describieron
implementación
funciona
sistema
UNIX
necesidad
modificar
kernel
resumen
esquema
utiliza
herramientas
depuración
normales
UNIX
carcelero
depurador
prisionero
depurado
circunstancias
depurador
pedir
kernel
encapsule
depurado
pase
llamadas
sistema
inspeccionarlas
9.8.5
Detección
intrusos
basada
modelos
método
defender
máquina
instalar
IDS
Intrusion
Detection
System
Sistema
detección
intrusos
tipos
básicos
IDS
concentra
inspeccionar
paque-
tes
red
entrantes
enfoca
buscar
anomalías
CPU
sección
firewalls
mencionamos
brevemente
IDS
red
hablaremos
IDS
basado
host
limitaciones
espacio
contemplar
diversos
tipos
IDS
basado
host
veremos
bosquejo
tipo
IDS
lector
idea
funcionamiento
IDS
conoce
detección
intrusos
basada
modelos
estáticos
Wagner
Dean
2001
implementar
técnica
encar-
celamiento
describimos
sección
formas
figura
9-36(a
pequeño
programa
abre
archivo
llamado
datos
lee
carácter
llega
byte
cero
imprime
número
bytes
distintos
cero
encuentran
inicio
archivo
termina
figura
9-36(b
po-
demos
gráfico
llamadas
sistema
realizadas
programa
imprimir
llama
write
indica
gráfico
empezar
llamada
sistema
progra-
ma
condición
open
read
write
dependiendo
Kernel
Carcelero
Prisionero
Sistema
Figura
9-35
operación
cárcel
www
FreeLibros.me704
SEGURIDAD
CAPÍTULO
int
main(int
argc
char
argv
int
fd
char
buf[1
fd
open("datos
if
fd
printf("Archivo
datos
defectuoso\n
exit(1
else
while
read(fd
buf
if
buf[0
close(fd
printf("n
d\n
exit(0
exit
exit
write
write
open
close
read
Figura
9-36
programa
Gráfico
llamadas
sistema
bifurcación
ifque
seleccione
llamada
write
significa
abrir
archivo
llamada
exit
llamada
read
nú-
mero
arbitrariamente
llamadas
adicionales
read
momento
llamadas
close
writey
exit
ausencia
intruso
secuencias
posibles
programa
encarcelado
carcelero
verá
llamadas
sistema
verificar
facilidad
secuencia
válida
suponga
alguien
error
programa
activa
desbordamiento
búfer
insertar
ejecutar
código
hostil
ejecute
código
hostil
probable
ejecute
secuencia
distinta
llamadas
sistema
ejemplo
tratar
abrir
ar-
chivo
desee
copiar
abrir
conexión
red
telefonear
casa
lla-
mada
sistema
encaje
patrón
carcelero
sabrá
definitiva
ocurrido
ataque
tomar
acción
eliminar
proceso
alertar
administrador
sistema
forma
sistemas
detección
intrusos
detectar
ataques
ocu-
rriendo
análisis
estático
llamadas
sistema
formas
fun-
cionar
IDS
utiliza
tipo
detección
intrusión
basada
modelo
estático
carcele-
ro
modelo
gráfico
llamadas
sistema
forma
simple
aprender
compilador
genere
autor
programa
firme
ad-
junte
certificado
forma
intento
modificar
programa
ejecutable
ade-
lantado
detectará
momento
ejecución
comportamiento
actual
coincidirá
comportamiento
firmado
esperado
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
705
desgracia
atacante
inteligente
lance
conoce
ataque
mímica
código
insertado
realiza
llamadas
sistema
supone
programa
Wagner
Soto
2002
necesitan
modelos
sofisticados
rastrean
llamadas
sistema
defensa
profundidad
IDS
papel
IDS
basado
modelos
único
tipo
existente
IDS
utilizan
con-
cepto
llamado
tarro
miel
trampa
atraer
atrapar
crackers
malware
general
máquina
aislada
defensas
contenido
apariencia
interesante
valioso
lis-
to
recolectado
personas
preparan
tarro
miel
monitorean
cuidadosamente
ataque
tratar
aprender
naturaleza
IDS
ponen
tarros
miel
máquinas
virtuales
evitar
daños
sistema
actual
subyacente
obvio
malware
tratará
determinar
ejecutando
máquina
virtual
mencio-
nó
9.8.6
Encapsulamiento
código
móvil
virus
gusanos
programas
entran
computadora
propietario
entere
voluntad
personas
importan
ejecutan
código
extraño
máquinas
voluntaria
distante
mundo
Internet
significa
años
mayoría
páginas
Web
archivos
HTML
estáticos
imágenes
asociadas
actualidad
pági-
nas
Web
contienen
pequeños
programas
conocidos
applets
descarga
pá-
gina
Web
contiene
applets
sistema
obtiene
applets
ejecuta
ejemplo
applet
contener
formulario
llene
usuario
ayuda
interactiva
ayudar-
proceso
llenado
llenar
formulario
enviar
ubicación
In-
ternet
procesarlo
formularios
fiscales
pedidos
productos
personalizados
tipos
formularios
beneficiar
método
agentes
ejemplo
programas
envían
máquina
ejecutarlos
máquina
destino
agentes
programas
usuario
inicia
tarea
reportan
resultados
ejemplo
pedir
agente
revi-
sitios
Web
viajes
encontrar
vuelo
económico
Amsterdam
San
Francisco
llegar
sitio
agente
ejecuta
obtiene
información
necesita
des-
pués
avanza
sitio
Web
terminar
trabajo
regresar
casa
reportar
aprendió
tercer
ejemplo
código
móvil
archivo
PostScript
imprimir
im-
presora
PostScript
realidad
archivo
PostScript
programa
lenguaje
programa-
ción
PostScript
ejecuta
impresora
general
indica
impresora
dibuje
curvas
rellene
cosa
applets
agentes
PostScript
ejemplos
código
móvil
extenso
análisis
virus
gusanos
vimos
momentos
lector
decisión
permitir
ejecute
código
extraño
máquina
pequeño
riesgo
personas
quieren
ejecutar
programas
www.FreeLibros.meextraños
surge
pregunta
ejecutar
código
móvil
seguri-
dad
respuesta
corta
facilidad
problema
fundamental
proceso
importa
applet
código
móvil
espacio
direcciones
ejecuta
có-
digo
ejecuta
proceso
válido
usuario
usua-
rio
incluyendo
habilidad
leer
escribir
borrar
cifrar
archivos
disco
usuario
enviar
correo
electrónico
datos
países
lejanos
tiempo
sistemas
operativos
desarrollaron
concepto
proceso
crear
paredes
usuarios
idea
proceso
espacio
direcciones
protegido
UID
acceder
archivos
recursos
pertene-
cen
usuarios
concepto
proceso
útil
proveer
protección
proceso
applet
resto
hilos
permiten
hilos
control
proceso
proteger
hilo
teoría
ayuda
ejecutar
applet
proceso
separado
im-
ejemplo
página
Web
contener
applets
interactúen
interactúen
datos
página
Web
navegador
Web
necesite
interactuar
applets
iniciarlos
detenerlos
proporcionarles
datos
etcétera
applet
coloca
proceso
funcionará
applet
coloca
espacio
direcciones
difícil
robar
dañar
datos
acaso
fácil
observándolo
propuesto
implementado
métodos
lidiar
applets
código
móvil
general
continuación
analizaremos
métodos
cajas
arena
interpretación
utilizar
firma
código
verificar
origen
applet
ventajas
desventajas
Cajas
arena
método
conocido
caja
arena
confinar
applet
rango
limitado
direcciones
virtuales
implementan
tiempo
ejecución
Wahbe
colaboradores
1993
función
método
dividir
espacio
direcciones
virtuales
regiones
tamaño
conoce
cajas
arena
caja
arena
propiedad
direcciones
comparten
cadena
bits
orden
superior
Podríamos
dividir
espacio
direcciones
32
bits
256
cajas
arena
límites
16
MB
bits
superiores
direcciones
caja
arena
comunes
for-
ma
podríamos
512
cajas
arena
límites
MB
caja
arena
prefijo
dirección
bits
elegir
tamaño
caja
arena
tamaño
suficiente
contener
applet
desperdiciar
espacio
direc-
ciones
virtuales
memoria
física
problema
paginación
demanda
applet
recibe
cajas
arena
código
datos
co-
mo
ilustra
figura
9-37(a
caso
16
cajas
arena
16
MB
idea
básica
caja
arena
garantizar
applet
saltar
códi-
go
esté
caja
arena
código
referencia
datos
es-
tán
caja
arena
datos
razón
cajas
arena
evitar
applet
706
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
707
modifique
código
ejecución
evitar
restricciones
evitar
almacenen
datos
caja
arena
código
eliminamos
peligro
código
modifica
applet
esté
confinado
forma
dañar
navegador
applets
plantar
virus
memoria
tipo
daño
memoria
carga
applet
reubica
empiece
inicio
caja
arena
realizan
comprobaciones
referencias
código
datos
confina-
das
caja
arena
apropiada
análisis
veremos
referencias
código
instrucciones
JMPy
CALL
ocurre
referencias
datos
instruc-
ciones
JMPestáticas
utilizan
direccionamiento
directo
fáciles
comprobar
dirección
destino
límites
caja
arena
código
similar
instrucciones
JMPrelativas
comprobar
facilidad
applet
código
salir
caja
arena
código
rechaza
ejecuta
forma
applet
intenta
acceder
datos
caja
arena
datos
rechaza
difícil
instrucciones
JMPdinámicas
mayoría
máquinas
ins-
trucción
dirección
salto
calcula
tiempo
ejecución
coloca
registro
salto
dirección
indirecta
ejemplo
JMP
R1
saltar
dirección
contiene
registro
validez
dichas
instrucciones
comprobar
tiempo
ejecución
insertar
código
justo
salto
indirec-
to
evaluar
dirección
destino
figura
9-37(b
muestra
ejemplo
prueba
Recuerde
direcciones
válidas
bits
superiores
prefijo
almacenar
registro
reutilizable
ejemplo
S2
applet
pue-
utilizar
registro
volver
escribir
applet
evite
registro
256
224
192
160
128
96
64
32
Monitor
referencias
Código
Datos
Código
Datos
Monitor
referencias
comprobar
sistema
Applet
Applet
MOV
R1
S1
SHR
24
S1
CMP
S1
S2
TRAPNE
JMP
R1
Dirección
virtual
MBFigura
9-37
memoria
dividida
cajas
arena
16
MB
forma
comprobar
validez
instrucción
www
FreeLibros.meEl
código
funciona
copia
dirección
destino
es-
tá
inspeccionando
registro
reutilizable
S1
registro
desplaza
derecha
número
preciso
bits
aislar
prefijo
común
S1
continuación
prefijo
aislado
compara
prefijo
correcto
cargó
principio
S2
coinciden
produce
trampa
elimina
applet
secuencia
código
requiere
instrucciones
regis-
tros
reutilizables
reparar
programa
binario
ejecución
requiere
trabajo
cabo
simple
applet
presentara
formato
código
fuente
compilara
forma
local
compilador
confiable
comprobara
automática
direcciones
estáticas
insertara
código
verificar
dinámicas
ejecución
forma
sobrecarga
tiempo
ejecución
asociada
comprobaciones
di-
námicas
Wahbe
colaboradores
1993
realizaron
mediciones
obtuvieron
resul-
tado
4%
generalmente
aceptable
problema
resolver
ocurre
applet
llamada
sistema
solución
simple
instrucción
llamada
sistema
reem-
plaza
llamada
módulo
especial
llamado
monitor
referenciasen
pa-
sada
insertan
comprobaciones
direcciones
dinámicas
código
fuente
disponible
vincula
biblioteca
especial
llama
monitor
referencias
llamadas
sistema
forma
monitor
referencias
examina
inten-
to
llamada
decide
seguro
llamada
aceptable
es-
cribir
archivo
temporal
directorio
reutilizable
designado
permite
llamada
continúe
llamada
peligrosa
monitor
referencias
saberlo
eli-
mina
applet
monitor
referencias
applet
llamada
moni-
tor
referencias
memoria
manejar
peticiones
applets
general
monitor
referencias
conoce
permisos
archivo
configuración
Interpretación
forma
ejecutar
applets
confiables
ejecutarlos
interpretativa
permitir
obtengan
control
hardware
método
utilizado
navegado-
res
Web
applets
páginas
Web
escriben
comúnmente
Java
lenguaje
programación
normal
lenguaje
secuencias
comandos
alto
nivel
TCL
segu-
ro
Javascript
applets
Java
compilan
lenguaje
máquina
orientado
pila
virtual
conocido
JVM
Java
Virtual
Machine
Máquina
virtual
Java
ap-
plets
JVM
colocan
página
Web
descargarlos
insertan
intérprete
JVM
navegador
ilustra
figura
9-38
ventaja
echar
andar
código
interpretado
código
compilado
ejecutado
intérprete
examina
instrucción
ejecutarla
intérprete
oportunidad
comprobar
dirección
válida
atrapan
interpretan
llamadas
siste-
ma
forma
manejan
llamadas
depende
directiva
seguridad
ejemplo
applet
confiable
proviene
disco
local
cabo
llama-
das
sistema
cuestionamiento
obstante
applet
confiable
Internet
colocar
caja
arena
restringir
comportamiento
708
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.8
DEFENSAS
709
lenguajes
secuencias
comandos
alto
nivel
interpretar
utilizan
direcciones
máquinas
peligro
secuencia
comandos
trate
acceder
memoria
permitida
desventaja
interpretación
ge-
neral
lentitud
comparación
ejecución
código
nativo
compilado
9.8.7
Seguridad
Java
lenguaje
programación
Java
sistema
tiempo
ejecución
acompaña
diseña-
ron
permitir
escribir
programa
compilarlo
enviarlo
In-
ternet
formato
binario
ejecutarlo
máquina
soporte
Java
seguridad
diseño
Java
principio
sección
analizaremos
funcionamiento
Java
lenguaje
seguridad
tipos
significa
compilador
rechazará
cual-
quier
intento
utilizar
variable
forma
compatible
tipo
con-
trario
considere
código
func_atrevida
char
rand
código
genera
número
aleatorio
almacena
apuntador
p.
almacena
byte
dirección
contiene
sobrescribiendo
contenga
código
datos
Java
construcciones
mezclan
tipos
prohibidos
gramática
Ade-
Java
variables
apuntadores
conversiones
asignación
almacenamiento
controlada
usuario
malloc
free
referencias
arreglos
comprueban
tiempo
ejecución
Applet
confiable
Applet
confiable
Navegador
Web
Caja
arena
Intérprete
Espacio
direcciones
virtuales
0xFFFFFFFF
Figura
9-38
navegador
Web
interpretar
applets
www
FreeLibros.meEn
Java
programas
compilan
código
intermedio
binario
conocido
código
by-
JVM
JVM
100
instrucciones
mayoría
meten
ob-
jetos
tipo
específico
pila
sacan
combinan
elementos
pila
operaciones
aritméticas
general
programas
JVM
interpretan
casos
compilar
lenguaje
máquina
agilizar
ejecución
modelo
Java
applets
envían
Internet
ejecutarlos
forma
remota
programas
JVM
llega
applet
pasa
verificador
código
byte
JVM
comprueba
applet
obedece
reglas
applet
compilado
forma
apropiada
obedecerá
au-
tomática
evite
usuario
malicioso
escriba
applet
JVM
lengua-
je
ensamblador
JVM
comprobaciones
applet
intenta
falsificar
apuntadores
Viola
restricciones
acceso
miembros
clases
privadas
utilizar
variable
tipo
tipo
Genera
desbordamientos
subdesbordamientos
pila
Convierte
ilegal
variables
tipo
applet
pasa
pruebas
ejecutar
segura
temor
acceda
memoria
applets
llamadas
sistema
llamadas
métodos
procedimientos
Java
proporcionan
forma
Java
maneja
pro-
ceso
evolucionado
tiempo
versión
Java
JDK
Java
Development
Kit
Kit
desarrollo
Java
1.0
applets
dividían
clases
confiables
confiables
applets
obtenían
disco
duro
confiables
podían
llamadas
siste-
ma
quisieran
contrario
applets
obtenían
Internet
confiables
ejecutaban
caja
arena
muestra
figura
9-38
podían
obtener
experiencia
modelo
Sun
decidió
restricti-
vo
JDK
1.1
utilizó
firma
código
llegaba
applet
Internet
realizaba
comprobación
firmado
persona
organización
confiable
usuario
definido
lista
firmadores
confiables
usuario
permitía
applet
quisiera
caso
contrario
ejecutaba
caja
arena
restringía
severamente
obtener
experiencia
proceso
insatisfactorio
modificó
modelo
seguridad
JDK
1.2
introdujo
directiva
seguridad
detalla-
restrictiva
aplicaba
applets
locales
remotos
modelo
segu-
ridad
complicado
escribió
libro
completo
describirlo
Gong
1999
sintetizaremos
puntos
importantes
applet
caracteriza
cosas
viene
firmó
URL
determina
lugar
viene
determinar
firmó
utiliza
clave
privada
firma
usuario
crear
directiva
seguridad
consiste
lista
reglas
regla
listar
URL
firmante
objeto
acción
applet
obje-
710
SEGURIDAD
CAPÍTULO
www
FreeLibros.meSECCIÓN
9.9
INVESTIGACIÓN
SEGURIDAD
711
to
URL
firmante
coinciden
regla
tabla
figura
9-39
muestra
infor-
mación
proporcionada
forma
conceptual
formato
real
distinto
relacionado
jerarquía
clases
Java
Figura
9-39
ejemplos
protección
especificar
JDK
1.2
URL
Firmante
Objeto
Acción
www.taxprep.com
TaxPrep
/usr
susan/1040.xls
Leer
/usr
tmp/
Leer
Escribir
www.microsoft.com
Microsoft
/usr
susan
Office/
Leer
Escribir
Eliminar
tipo
acción
permite
acceso
archivo
acción
especificar
archi-
vo
directorio
conjunto
archivos
directorio
conjunto
ar-
chivos
directorios
contenidos
recursiva
directorio
líneas
figu-
ra
9-39
corresponden
casos
línea
usuaria
Susan
configurado
archivo
permisos
applets
originen
máquina
empresa
declaraciones
fiscales
llamada
www.taxprep.com
estén
firmados
tengan
acceso
lectura
datos
fiscales
encuentran
archivo
1040.xls
único
archivo
leer
applet
leer
archivo
ap-
plets
orígenes
estén
firmados
leer
escribir
archivos
/usr
tmp
Susan
confía
suficiente
Microsoft
permitir
applets
ori-
ginen
sitio
estén
firmados
empresa
tengan
permiso
leer
escribir
eliminar
to-
archivos
directorio
Office
árbol
directorios
ejemplo
corregir
errores
instalar
versiones
software
verificar
firmas
Susan
cla-
ves
públicas
necesarias
disco
adquirirlas
forma
dinámica
ejemplo
for-
ma
certificado
firmado
empresa
confía
cuya
clave
pública
posee
archivos
únicos
recursos
proteger
proteger
acceso
red
objetos
puertos
específicos
computadoras
específicas
compu-
tadora
especifica
dirección
IP
nombre
DNS
puertos
máquina
es-
pecifican
rango
números
acciones
posibles
incluyen
solicitar
conexión
computadora
remota
aceptar
conexiones
originadas
computadora
remota
for-
ma
applet
recibir
acceso
red
restringido
comunicarse
computadoras
aparezcan
explícita
lista
permisos
applets
cargar
forma
dinámica
código
adicional
clases
requieran
cargadores
clases
su-
ministrados
usuario
controlar
precisión
máquinas
originar
clases
características
seguridad
presentes
9.9
INVESTIGACIÓN
SEGURIDAD
seguridad
computadoras
tema
activo
llevando
cabo
cantidad
investigación
computación
confiable
tema
importante
especial
plataformas
Erickson
2003
Garfinkel
colaboradores
2003
Reid
Caelli
2005
Thibadeau
2006
di-
www.FreeLibros.merectivas
públicas
asociadas
Anderson
2003
tema
investigación
continua
mo-
delos
implementación
flujo
información
Castro
colaboradores
2006
Efstathopoulos
colaboradores
2005
Hicks
colaboradores
2007
Zeldovich
colaboradores
2006
autenticación
usuarios
incluyendo
biométrica
tema
importante
Bhargav-Spantzel
colaboradores
2006
Bergadano
colaboradores
2002
Pusara
Brodley
2004
Sasse
2007
Yoon
colaboradores
2004
Dados
problemas
malware
investigación
desbordamientos
búfer
explotaciones
forma
lidiar
Hackett
colaboradores
2006
Jones
2007
Kuperman
colaboradores
2005
Soffa
2007
Prasad
Chiueh
2003
malware
formas
estudia
detalle
incluyendo
caballos
Troya
Agra-
wal
colaboradores
2007
Franz
2007
Moffie
colaboradores
2006
virus
Bruschi
cola-
boradores
2007
Cheng
colaboradores
2007
Rieback
colaboradores
2006
gusanos
Abdelhafez
colaboradores
2007
Jiang
Xu
2006
Kienzle
Elder
2003
Tang
Chen
2007
spyware
Egele
colaboradores
2007
Felten
Halderman
2006
Wu
colaboradores
2006
rootkits
Kruegel
colaboradores
2004
Levine
colaboradores
2006
Quynh
Takefuji
2007
Wang
Dasgupta
2007
virus
spyware
rootkits
tratan
ocultarse
reali-
zado
trabajos
tecnología
furtiva
detectar
formas
Car-
penter
colaboradores
2007
Garfinkel
colaboradores
2007
Lyda
Hamrock
2007
examinado
esteganografía
Harmsen
Pearlman
2005
Kratzer
colaboradores
2006
necesidad
decirlo
trabajo
defensa
sistemas
con-
tra
malware
enfoca
software
antivirus
Henchiri
Japkowicz
2006
Sanok
2005
Stiegler
colaboradores
2006
Uluski
colaboradores
2005
sistemas
detección
intrusos
tema
especialmente
activo
realiza
trabajo
intrusos
tiempo
real
intrusos
históricos
King
Chen
2005
2006
Saidi
2007
Wang
colaboradores
2006b
Wheeler
Fulp
2007
duda
tarros
miel
aspecto
importante
IDS
reciben
cantidad
atención
Anagnostakis
colaboradores
2005
Asrigo
colabo-
radores
2006
Portokalidis
colaboradores
2006
9.10
RESUMEN
frecuencia
computadoras
contienen
datos
valiosos
confidenciales
incluyendo
declaracio-
nes
fiscales
números
tarjetas
crédito
planes
negocios
secretos
comerciales
general
propietarios
computadoras
preocupan
privadas
alterarlas
motivos
requiere
sistema
operativo
proporcione
bue-
na
seguridad
mantener
información
secreta
cifrarla
administrar
claves
cuidado
necesario
demostrar
autenticidad
información
digital
cu-
caso
utilizar
hashes
criptográficos
firmas
digitales
certificados
firmados
au-
toridad
certificación
confiable
derechos
acceso
información
modelar
matriz
filas
dominios
usuarios
columnas
objetos
ejemplo
archivos
cel-
especifica
derechos
acceso
dominio
objeto
matriz
escasa
712
SEGURIDAD
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
713
almacenar
fila
convierte
lista
capacidades
indica
do-
minio
almacenar
columna
cuyo
caso
convierte
lista
control
acceso
indica
acceder
objeto
forma
técnicas
modelado
formales
modelar
limitar
flujo
información
sis-
tema
fugas
canales
encubiertos
modulación
CPU
sistema
seguro
usuarios
autenticar
utilizar
usuario
conozca
usuario
usuario
biométrica
utilizar
identificación
factores
exploración
iris
contraseña
mejo-
rar
seguridad
internos
empleados
empresa
vencer
seguridad
sistema
variedad
formas
incluyen
bombas
lógicas
activan
fecha
futura
puertas
trampa
permitir
interno
acceso
autorizado
momento
pos-
terior
suplantación
nombres
inicio
sesión
explotar
tipos
errores
código
tomar
control
progra-
sistemas
errores
incluyen
desbordamientos
búfer
ataques
cadenas
for-
mato
ataques
retorno
libc
ataques
desbordamiento
enteros
ataques
inyección
código
ataques
escalada
privilegios
Internet
llena
malware
incluyendo
caballos
Troya
conocidos
troya-
virus
gusanos
spyware
rootkits
tipos
malware
amenaza
confidencialidad
datos
integridad
ataque
malware
capacidad
tomar
control
máquina
convertirla
zombie
envíe
spam
utilice
lan-
zar
ataques
fortuna
formas
sistemas
defender
me-
jor
estrategia
defensa
profundidad
técnicas
in-
cluyen
firewalls
exploradores
virus
firma
código
encarcelamiento
sistemas
detección
intrusos
encapsulamiento
código
móvil
PROBLEMAS
Quebrante
cifrado
monoalfabético
texto
simple
consiste
letras
ex-
tracto
conocido
poema
Lewis
Caroll
idioma
inglés
Considere
cifrado
clave
secreta
matriz
26
26
encabezado
columnas
ABC
filas
ABC
Z.
texto
simple
cifra
caracteres
carácter
columna
fila
celda
formada
intersec-
ción
fila
columna
contiene
caracteres
texto
cifrado
restricción
ad-
herir
matriz
claves
kfd
ktbd
fzm
eubd
kfd
pzyiom
mztx
ku
kzyg
ur
bzha
kfthcm
ur
mfudm
zhx
mftnm
zhx
mdzythc
pzq
ur
ezsszcdm
zhx
gthcm
zhx
pfa
kfd
mdz
tm
sutythc
fuk
zhx
pfdkfdi
ntcm
fzld
pthcm
sok
pztk
stk
kfd
uamkdim
eitdx
sdruid
pd
fzld
uoi
efzk
rui
mubd
ur
om
zid
uok
ur
sidzkf
zhx
zyy
ur
om
zid
rzk
hu
foiia
mztx
kfd
ezindhkdi
kfda
kfzhgdx
ftb
boef
rui
kfzk
www
FreeLibros.me3
criptografía
clave
secreta
eficiente
criptografía
clave
pública
requiere
emisor
receptor
estén
clave
adelantado
Suponga
emisor
receptor
reunido
confianza
comparte
clave
secreta
emisor
comparte
clave
secreta
distinta
receptor
pue-
den
emisor
receptor
establecer
clave
secreta
compartida
circunstancias
Proporcione
ejemplo
simple
función
matemática
aproximación
de-
sempeñe
función
vía
Suponga
extraños
desean
comunicarse
criptografía
clave
secreta
comparten
clave
Suponga
confían
cu-
clave
pública
conocida
extraños
establecer
clave
se-
creta
compartida
circunstancias
Suponga
sistema
1000
objetos
100
dominios
momento
ciento
objetos
accesibles
combinación
dominios
10%
accesi-
bles
dominios
89%
restante
accesibles
dominio
Suponga
requiere
uni-
dad
espacio
almacenar
permiso
acceso
combinación
ID
objeto
ID
dominio
espacio
requiere
almacenar
matriz
protección
ma-
triz
protección
ACL
matriz
protección
lista
capacidades
distintos
mecanismos
protección
analizado
listas
capacidades
listas
control
acceso
siguientes
problemas
protección
indique
siguientes
mecanismos
utilizar
Ken
desea
puedan
leer
archivos
compañero
oficina
Mitch
Steve
desean
compartir
archivos
secretos
Linda
desea
archivos
públicos
Represente
propiedades
permisos
muestran
listado
directorio
UNIX
matriz
protección
Nota
asw
miembro
grupos
users
devel
gmw
miembro
só-
users
Trate
usuarios
grupos
dominio
matriz
filas
dominio
columnas
archivo
Exprese
permisos
muestran
listado
directorio
problema
listas
control
acceso
10
esquema
Amoeba
proteger
capacidades
usuario
pedir
servidor
pro-
duzca
capacidad
permisos
otorgar
amigo
ocu-
rre
amigo
pide
servidor
elimine
derechos
otorgar
alguien
11
figura
9-13
flecha
proceso
objeto
permitiría
dicha
flecha
regla
violaría
12
permitieran
mensajes
proceso
figura
9-13
reglas
aplicarían
proceso
particular
procesos
enviar
mensajes
714
SEGURIDAD
CAPÍTULO
rw
gmw
users
908
May
26
16:45
PPP
Notes
wx
asw
devel
432
May
13
12:35
prog1
rw
rw
asw
users
50094
May
30
17:51
project.t
rw
asw
devel
13124
May
31
14:30
splash.gif
www
FreeLibros.meCAPÍTULO
PROBLEMAS
715
13
Considere
sistema
esteganográfico
figura
9-16
píxel
representar
espa-
cio
color
punto
sistema
tridimensional
ejes
valores
B.
Uti-
lice
espacio
explicar
ocurre
resolución
color
emplea
esteganografía
figura
14
texto
lenguaje
natural
ASCII
comprimir
mínimo
50%
algoritmos
compresión
Utilice
conocimiento
calcular
capacidad
acarreo
es-
teganográfico
texto
ASCII
bytes
imagen
1600
/H110031200
almacenada
bits
orden
inferior
píxel
incrementa
tamaño
imagen
me-
diante
técnica
suponiendo
cifrado
expansión
cifrado
eficiencia
esquema
carga
útil/(bytes
transmitidos
15
Suponga
grupo
estrecho
disidentes
políticos
vive
país
represivo
utiliza
esteganografía
enviar
mundo
mensajes
condiciones
país
gobierno
consciente
combatirlos
envía
imágenes
falsas
contienen
mensajes
esteganográfi-
cos
falsos
disidentes
tratar
ayudar
personas
distingan
mensajes
reales
falsos
16
www.cs.vu.nl/asty
haga
clic
vínculo
covered
writing
Siga
instrucciones
extraer
obras
Responda
siguientes
preguntas
tamaños
archivos
cebras
originales
cebras
modificadas
obras
almacenadas
secreto
archivo
cebras
bytes
almacenan
secreto
archivo
cebras
17
seguro
computadora
utilice
eco
imprimir
contraseña
utilice
eco
imprimir
asterisco
carácter
escrito
opción
divulga
longitud
contraseña
cualquiera
esté
cerca
pantalla
Suponiendo
contraseñas
consis-
ten
letras
mayúsculas
minúsculas
dígitos
mínimo
caracteres
máximo
seguridad
adicional
obtiene
mostrar
18
recibir
título
solicita
trabajo
director
centro
computacional
universidad
acaba
cambiar
viejo
sistema
mainframe
servidor
LAN
ejecuta
UNIX
obtiene
empleo
Quince
minutos
empezar
trabajar
asistente
irrumpe
oficina
gritando
estudiantes
descubrieron
algoritmo
utilizamos
pa-
ra
cifrar
contraseñas
publicaron
Internet
19
esquema
protección
Morris-Thompson
números
aleatorios
bits
salt
diseñó
pa-
ra
dificultar
intruso
labor
descubrir
número
contraseñas
cifrar
cadenas
co-
munes
adelantado
esquema
ofrece
protección
estudiante
adivinar
contraseña
superusuario
máquina
Suponga
archivo
contraseñas
disponible
leerlo
20
Explique
diferencia
mecanismo
contraseñas
UNIX
cifrado
21
Suponga
archivo
contraseñas
sistema
disponible
cracker
tiem-
po
adicional
necesita
cracker
descubrir
contraseñas
sistema
utiliza
esquema
protección
Morris-Thompson
número
salt
bits
tiempo
necesita
sistema
utiliza
esquema
22
Mencione
características
indicador
biométrico
útil
autenticador
inicio
sesión
www
FreeLibros.me23
departamento
ciencias
computacionales
extensa
colección
máquinas
UNIX
red
local
usuarios
máquina
emitir
comando
forma
rexec
maquina4
who
comando
ejecute
maquina4
usuario
iniciar
sesión
máquina
remota
implementar
característica
kernel
usuario
enviar
co-
mando
UID
máquina
remota
esquema
seguro
kernels
confian-
za
pasa
máquinas
computadoras
personales
estudiantes
protección
24
propiedad
común
implementación
contraseñas
UNIX
esquema
Lam-
port
iniciar
sesión
red
insegura
25
esquema
contraseña
Lamport
utiliza
contraseñas
orden
inverso
simple
utilizar
f(s
sucesivo
26
utilizar
hardware
MMU
evitar
tipo
ataque
desborda-
miento
muestra
figura
9-24
Explique
27
Mencione
característica
compilador
pudiera
eliminar
cantidad
hoyos
seguridad
implementa
amplitud
28
funcionar
ataque
caballo
Troya
sistema
protegido
capacidades
29
elimina
archivo
general
bloques
regresan
lista
bloques
libres
pe-
ro
borran
Cree
conveniente
sistema
operativo
borrara
bloque
an-
tes
liberarlo
Considere
factores
seguridad
rendimiento
respuesta
explique
efecto
30
virus
parasítico
asegurar
ejecutará
programa
host
pa-
sar
control
vuelta
host
trabajo
31
sistemas
operativos
requieren
particiones
disco
empiecen
principio
pis-
ta
facilita
trabajo
virus
sector
arranque
32
Modifique
programa
figura
9-27
encuentre
programas
archivos
ejecutables
33
virus
figura
9-32(d
cifrado
científicos
dedicados
labo-
ratorio
antivirus
archivo
clave
descifrar
virus
aplicarle
ingenie-
ría
inversa
Virgilio
dificultar
trabajo
34
virus
figura
9-32(c
compresor
descompresor
descompresor
necesita
expandir
ejecutar
programa
ejecutable
comprimido
sirve
com-
presor
35
Nombre
desventaja
virus
cifrado
polimórfico
punto
vista
escritor
virus
36
siguientes
instrucciones
recuperarse
ataque
virus
Iniciar
sistema
infectado
Respaldar
archivos
externo
Ejecutar
fdisk
formato
disco
716
SEGURIDAD
CAPÍTULO
www
FreeLibros.meCAPÍTULO
PROBLEMAS
717
Reinstalar
sistema
operativo
CD-ROM
original
olver
cargar
archivos
externo
Mencione
errores
graves
instrucciones
37
virus
compañía
virus
modifican
archivos
existentes
UNIX
38
diferencia
virus
gusano
reproduce
39
archivos
auto-extraíbles
contienen
archivos
comprimidos
empaquetan
programa
extracción
utilizan
frecuencia
entregar
programas
actualizacio-
nes
Analice
implicaciones
seguridad
técnica
40
Analice
posibilidad
escribir
programa
reciba
programa
entrada
determine
programa
contiene
virus
41
sección
9.8.1
describe
conjunto
reglas
firewall
limitan
acceso
exterior
só-
servicios
Describa
conjunto
reglas
agregar
firewall
restringir
acceso
servicios
42
máquinas
instrucción
SHRque
utiliza
figura
9-37(b
llena
bits
utiliza-
ceros
máquinas
bit
signo
extiende
derecha
figura
9-37(b
correcta
importa
tipo
instrucción
desplazamiento
utilice
43
verificar
distribuidor
confianza
firmado
applet
distribuidor
applet
pue-
incluir
certificado
firmado
confianza
contenga
clave
pública
em-
bargo
leer
certificado
usuario
necesita
clave
pública
confianza
cuarta
confianza
proveer
clave
usuario
necesitaría
clave
pú-
blica
forma
salir
sistema
verificación
ayu-
navegadores
existentes
utilizan
funcionar
44
Describa
características
Java
lenguaje
programación
es-
cribir
programas
seguros
45
Suponga
sistema
utiliza
JDK
1.2
Muestre
reglas
similares
figura
9-39
utilizará
permitir
applet
www.apletsRus.com
ejecute
máquina
applet
descargar
archivos
adicionales
www.appletsRus.com
leer
escribir
archivos
/usr
tmp/
leer
archivos
/usr
appletdir
46
Escriba
par
programas
secuencias
comandos
shell
enviar
recibir
mensaje
canal
encubierto
sistema
UNIX
Sugerencia
bit
permiso
archivo
inaccesible
garantiza
comando
llamada
sistema
sleep
producirá
retraso
tiempo
fijo
establecido
base
argumen-
to
Mida
velocidad
datos
sistema
inactivo
cree
carga
artificial
pesada
iniciar
procesos
distintos
plano
vuelva
medir
velocidad
datos
47
sistemas
UNIX
utilizan
algoritmo
DES
cifrar
contraseñas
general
siste-
aplican
DES
25
seguidas
obtener
contraseña
cifrada
Descargue
implemen-
tación
DES
Internet
escriba
programa
cifre
contraseña
compruebe
válida
sistema
Genere
lista
10
contraseñas
cifradas
utilizando
esquema
protección
Morris-Thompson
Use
número
salt
16
bits
www
FreeLibros.me48
Suponga
sistema
utiliza
ACLs
mantener
matriz
protección
Escriba
conjunto
funciones
administrativas
administrar
ACLs
cree
objeto
elimine
objeto
cree
dominio
elimine
dominio
otorguen
permisos
acceso
combinación
dominio
acceder
objeto
revoquen
per-
misos
acceso
existentes
dominio
acceder
objeto
otorguen
permi-
sos
acceso
dominios
acceder
objeto
8)
revoquen
permisos
acceso
objeto
dominios
718
SEGURIDAD
CAPÍTULO
www
FreeLibros.me10
CASO
ESTUDIO
LINUX
719
capítulos
anteriores
examinamos
principios
abstracciones
algoritmos
técnicas
ge-
neral
sistemas
operativos
llegado
momento
analizar
sistemas
concretos
pa-
ra
principios
examinados
aplican
mundo
real
Empezaremos
Linux
variante
popular
UNIX
ejecuta
amplia
variedad
computadoras
sistemas
operativos
dominantes
estaciones
trabajo
servidores
alto
rendimiento
utiliza
sistemas
varían
teléfonos
celulares
supercomputadoras
ilustra
principios
diseño
importantes
forma
apropiada
análisis
empezará
historia
evolución
UNIX
Linux
veremos
generalidades
Linux
lector
sepa
utiliza
generalidades
va-
lor
especial
lectores
conozcan
Windows
sistema
operativo
oculta
ca-
detalles
sistema
usuarios
interfaces
gráficas
sencillas
principiantes
proporcionan
flexibilidad
detalle
acerca
funciona-
miento
interno
sistema
llegaremos
corazón
capítulo
análisis
procesos
administración
memoria
sistema
archivos
seguridad
Linux
tema
analizaremos
pri-
mero
conceptos
fundamentales
llamadas
sistema
implementación
empezar
debemos
plantear
pregunta
Linux
Linux
variante
UNIX
versiones
variantes
UNIX
incluyendo
AIX
FreeBSD
HP-UX
SCO
UNIX
System
Solaris
fortuna
principios
fundamentales
llamadas
sistema
iguales
variantes
diseño
estrategias
implementa-
ción
general
algoritmos
estructuras
datos
similares
diferencias
www
FreeLibros.mePara
ejemplos
concretos
elegir
variantes
describirla
mane-
ra
consistente
probable
mayoría
lectores
hayan
topado
Linux
variantes
utilizaremos
ejemplo
funcional
teniendo
excepción
información
implementación
capítu-
aplica
sistemas
UNIX
libros
escritos
UNIX
características
avanzadas
aspectos
internos
sistema
Bovet
Cesati
2005
Maxwell
2001
McKusick
Neville-Neil
2004
Pate
2003
Stevens
Rago
2008
Vahalia
2007
10.1
HISTORIA
UNIX
LINUX
UNIX
Linux
historia
larga
interesante
iniciaremos
estudio
empezó
proyecto
favorito
joven
investigador
Ken
Thompson
convertido
industria
miles
millones
dólares
involucran
universidades
empresas
multinacionales
gobiernos
órganos
estandarización
internacionales
siguientes
páginas
indicaremos
desarrollado
historia
10.1.1
UNICS
décadas
1940
1950
computadoras
personales
sentido
forma
normal
utilizar
computadora
iniciar
sesión
hora
ocupar
máquina
periodo
máquinas
inmensas
aspecto
físico
persona
programador
podía
utilizarlas
momento
llegaron
sistemas
procesamiento
lotes
década
1960
programador
en-
viaba
trabajo
tarjetas
perforadas
llevaba
cuarto
máquina
ensam-
blado
suficientes
trabajos
operador
leía
lote
general
requería
hora
enviar
trabajo
devolviera
resultado
circunstancias
depuración
proceso
consumía
tiempo
coma
ubicada
po-
ocasionar
programador
desperdiciara
horas
tiempo
solucionar
consideraban
arreglo
insatisfactorio
improductivo
inven-
tó
tiempo
compartido
Dartmouth
College
M.I.T.
sistema
Darmouth
ejecutaba
só-
BASIC
disfrutó
éxito
comercial
corto
plazo
desaparecer
sistema
M.I.T.
llamado
CTSS
propósito
general
enorme
éxito
comunidad
científica
tiempo
investigadores
M.I.T.
unieron
fuerzas
Bell
Labs
General
Electric
distribuidor
computadoras
empezaron
diseñar
sistema
ge-
neración
conocido
MULTICS
Multiplexed
Information
and
Computing
Service
Servicio
multiplexado
información
cómputo
vimos
capítulo
Bell
Labs
socios
fundad
ores
proyecto
MULTICS
tiempo
retiró
investigadores
nombre
Ken
Thompson
buscaba
interesante
pudiera
trabajar
momento
decidió
escribir
versión
simplificada
MULTICS
ensamblador
minicomputadora
PDP-7
desechada
pequeño
ta-
maño
PDP-7
sistema
Thompson
funcionaba
podía
soportar
esfuerzo
desarrollo
720
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.1
HISTORIA
UNIX
LINUX
PROCESOS
721
consecuencia
investigadores
Bell
Labs
llamado
Brian
Kernighan
broma
llamó
UNICS
Uniplexed
Information
and
Computing
Service
Servicio
uniplexado
in-
formación
cómputo
inglés
pronuncia
eunuco
albures
EUNUCHS
MULTICS
castrado
nombre
ortografía
cambió
UNIX
10.1.2
UNIX
PDP-11
trabajo
Thompson
impresionó
colegas
Bell
Labs
unió
Dennis
Ritchie
departamento
época
ocurrieron
desarrollos
importantes
lugar
UNIX
trasladó
obsoleta
PDP-7
PDP-11/20
mu-
cho
moderna
PDP-11/45
PDP-11/70
máquinas
do-
minaron
mundo
minicomputadoras
década
1970
PDP-11/45
PDP-11/70
potentes
máquinas
memorias
físicas
época
256
KB
MB
respectivamente
tenían
hardware
protección
memoria
soporte
usuarios
tiempo
ambas
máquinas
16
bits
limi-
taban
procesos
individuales
64
KB
espacio
instrucciones
64
KB
espacio
datos
máquina
memoria
física
desarrollo
relacionado
lenguaje
escribió
UNIX
en-
tonces
llegando
dolorosa
conclusión
divertido
reescribir
sis-
tema
completo
máquina
Thompson
decidió
reescribir
UNIX
lenguaje
alto
nivel
diseño
llamado
B.
forma
simplificada
BCPL
forma
simplificada
CPL
PL
funcionó
de-
bilidades
especial
falta
estructuras
intento
éxito
Ritchie
dise-
ñó
sucesor
llamó
naturalmente
escribió
excelente
compilador
lenguaje
Thompson
Ritchie
trabajaron
conjunto
reescribir
UNIX
C.
len-
guaje
adecuado
momento
apropiado
dominado
programación
sis-
temas
1974
Ritchie
Thompson
publicaron
famoso
artículo
UNIX
Ritchie
Thomp-
1974
trabajo
describieron
artículo
recibieron
prestigioso
Premio
Turing
ACM
Ritchie
1984
Thompson
1984
publicación
artículo
es-
timuló
universidades
pidieran
Bell
Labs
copia
UNIX
AT&T
empresa
matriz
Bell
Labs
monopolio
podía
negocio
computadoras
objeción
licenciar
UNIX
universidades
modesta
cuota
coincidencias
forma
historia
PDP-11
compu-
tadora
preferida
departamentos
ciencias
computacionales
universidades
profesores
estudiantes
consideraban
pésimos
sistemas
operativos
in-
cluía
minicomputadora
UNIX
llenó
vacío
rapidez
incluía
códi-
go
fuente
completo
personas
pudieran
juguetear
parar
organizaron
numerosas
reuniones
científicas
UNIX
oradores
distinguidos
hablaban
error
oscuro
kernel
descubierto
corregido
profesor
australiano
nombre
www
FreeLibros.meJohn
Lions
escribió
comentario
código
fuente
UNIX
tipo
general
reserva
obras
Chaucer
Shakespeare
reimprimió
Lions
1996
libro
des-
cribió
versión
cuyo
nombre
describió
sexta
edición
Manual
pro-
gramador
UNIX
código
fuente
constaba
8200
líneas
900
líneas
código
ensamblador
resultado
actividad
ideas
mejoras
sistema
es-
parcieron
rapidez
años
versión
reemplazó
versión
versión
portátil
UNIX
ejecutaba
PDP-11
Interdata
8/32
contenía
18,800
líneas
2100
líneas
ensamblador
generación
estudiantes
creció
versión
contribuyeron
esparcimiento
graduaron
entraron
trabajar
industria
me-
diados
década
1980
UNIX
utilizaba
ampliamente
minicomputadoras
estaciones
trabajo
ingeniería
variedad
distribuidores
empresas
obtuvieron
licencia
código
fuente
crearon
versión
UNIX
Microsoft
pequeña
empresa
empezaba
operar
vendió
ver-
sión
nombre
XENIX
años
perdió
interés
sistema
ope-
rativo
10.1.3
UNIX
portable
UNIX
escrito
sencillo
moverlo
portarlo
má-
quina
portar
sistema
operativo
escribir
compilador
máquina
escribir
drivers
dispositivos
máquina
co-
mo
monitores
impresoras
discos
código
drivers
mo-
verlo
máquina
compilarlo
ejecutarlo
discos
funcionen
reescribir
pequeña
cantidad
código
dependiente
má-
quina
manejadores
interrupciones
rutinas
administración
memoria
general
lenguaje
ensamblador
máquina
portó
UNIX
PDP-11
minicomputadora
Interdata
8/32
ejercicio
reveló
suposiciones
UNIX
hacía
implícita
so-
bre
máquina
ejecutaba
suposición
tácita
enteros
contenían
16
bits
apuntadores
contenían
16
bits
implicaba
tamaño
máximo
64
KB
pa-
ra
programas
máquina
registros
disponibles
contener
variables
im-
portantes
Interdata
requería
trabajo
considerable
limpiar
UNIX
problemas
compilador
Ritchie
rápido
producía
có-
digo
objeto
producía
código
objeto
PDP-11
escribir
compilador
específico
Interdata
Steve
Johnson
Bell
Labs
diseñó
implementó
compilador
portable
podía
redirigir
producir
código
máquina
razonable
pequeño
esfuerzo
años
compiladores
máquinas
distintas
PDP-11
basaron
compilador
Johnson
ayudó
forma
considerable
UNIX
esparciera
computadoras
722
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.1
HISTORIA
UNIX
LINUX
723
principio
UNIX
portó
Interdata
ejecutaba
lentitud
trabajo
desarrollo
única
máquina
funcionaba
UNIX
PDP-11
encontraba
quinto
piso
Bell
Labs
Interdata
piso
Pa-
ra
generar
versión
compilarla
quinto
piso
físicamente
cinta
magnética
piso
funcionaba
meses
transportar
cintas
magnéticas
desconocido
compañía
telefónica
Acaso
pode-
mos
conectar
cable
máquinas
nació
UNIX
red
portarlo
Interdata
portó
AX
computadoras
gobierno
estadounidense
dividió
AT&T
1984
empresa
legalmente
libre
establecer
subsidiaria
computadoras
inmediato
AT&T
publicó
producto
UNIX
comercial
conocido
System
III
recibi-
do
año
reemplazó
versión
mejorada
System
gran-
des
misterios
resolver
ciencias
computacionales
paradero
System
IV
versión
System
original
reemplazado
System
versiones
complicada
antecesora
proceso
idea
original
UNIX
sistema
simple
elegante
ido
evaporando
forma
gra-
dual
grupo
Ritchie
Thompson
produjo
8ª
9ª
10ª
edición
UNIX
pusieron
circulación
AT&T
puso
esfuerzo
marketing
ver-
sión
System
incorporando
ideas
ediciones
10
versión
System
momento
AT&T
decidió
quería
compañía
telefó-
nica
empresa
computadoras
vendió
negocio
UNIX
Novell
1993
Novell
vendió
Santa
Cruz
Operation
1995
irrele-
vante
propietario
principales
empresas
computadoras
tenían
licencias
10.1.4
Berkeley
UNIX
Universidad
California
Berkeley
primeras
universidades
adquirieron
versión
UNIX
disponible
código
fuente
completo
Berkeley
mo-
dificaciones
importantes
sistema
ayuda
concesiones
ARPA
Agencia
Proyec-
tos
Investigación
Avanzados
Departamento
Defensa
EE.UU.
Berkeley
produjo
liberó
versión
mejorada
PDP-11
conocida
1BSD
First
Berkeley
Software
Distribution
distribución
software
Berkeley
produjo
ver-
sión
llamada
2BSD
PDP-11
versiones
importantes
3BSD
especial
sucesora
4BSD
AX
AT&T
versión
UNIX
AX
conocida
32V
esencia
ver-
sión
contrario
4BSD
contenía
cantidad
mejoras
impor-
tantes
memoria
virtual
paginación
programas
podían
memoria
física
paginar
partes
necesario
modifi-
caciones
permitir
nombres
archivos
tuvieran
14
caracteres
mo-
dificó
implementación
sistema
archivos
rápido
manejo
señales
confiable
introdujo
concepto
redes
protocolo
red
www.FreeLibros.meutilizó
TCP
IP
convirtió
estándar
omisión
mundo
UNIX
posteriormente
Internet
dominada
servidores
basados
UNIX
Berkeley
cantidad
considerable
programas
utilitarios
UNIX
incluyen-
do
editor
vi
shell
csh
compiladores
Pascal
Lisp
mejoras
Sun
Microsystems
DEC
distribuidores
computadoras
basa-
ran
versiones
UNIX
Berkeley
UNIX
versión
oficial
AT&T
System
consecuencia
Berkeley
UNIX
estableció
firmemente
áreas
académicas
investigación
defensa
obtener
información
Berkeley
UNIX
consulte
McKusick
colaboradores
1996
10.1.5
UNIX
estándar
finales
década
1980
versiones
populares
distintas
forma
in-
compatibles
UNIX
4.3BSD
System
Release
distribuidores
computadoras
agregaban
mejoras
estándar
división
mundo
UNIX
aunada
estándares
formatos
programas
binarios
in-
hibió
éxito
comercial
UNIX
imposible
distribuidores
software
escribir
empaquetar
programas
UNIX
expectativa
ejecutarían
sistema
UNIX
hacía
rutinaria
MS-DOS
principio
intentos
estandarizar
UNIX
fracasaron
ejemplo
AT&T
emitió
SVID
System
Interfa-
ce
Definition
Definición
interfaz
System
definía
llamadas
sistema
formatos
archivos
etcétera
documento
intento
mantener
alineados
to-
distribuidores
System
efecto
campo
enemigo
BSD
ignoraron
intento
serio
reconciliar
versiones
UNIX
inició
auspicios
Consejo
Estándares
IEEE
órgano
respetado
importante
neutral
Cien-
tos
personas
industria
universidades
gobierno
participaron
trabajo
nom-
bre
colectivo
asignó
proyecto
POSIX
primeras
letras
significan
Sistema
operativo
portable
letras
IX
agregaron
nombre
tuviera
estilo
UNIX
argumentos
contraargumentos
refutaciones
contrarrefutaciones
co-
mité
POSIX
produjo
estándar
conocido
1003.1
estándar
define
conjunto
procedimientos
biblioteca
sistema
UNIX
esté
conformidad
proveer
ma-
yoría
procedimientos
invocan
llamada
sistema
imple-
mentar
kernel
procedimientos
comunes
open
read
fork
idea
POSIX
distribuidor
software
escriba
programa
utilice
procedimientos
definidos
estándar
1003.1
seguridad
programa
ejecutará
sistemas
UNIX
estén
conformidad
mayoría
organizaciones
estándares
tendencia
pro-
ducir
horrible
solución
intermedia
características
favoritas
están-
1003.1
cantidad
partes
involucradas
respectivos
intereses
personales
tomar
unión
características
System
BSD
punto
inicial
norma
mayoría
organizaciones
estándares
co-
724
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.1
HISTORIA
UNIX
LINUX
725
mité
IEEE
intersección
metodología
cruda
característica
presente
System
BSD
incluía
estándar
caso
contrario
incluía
con-
secuencia
algoritmo
estándar
1003.1
asemeja
ancestro
directo
Sys-
tem
BSD
versión
documento
estándar
1003.1
escrito
forma
implementadores
sistemas
operativos
escritores
software
pue-
comprenderlo
novedad
mundo
estándares
trabajando
re-
mediar
estándar
1003.1
llamadas
sistema
documentos
relacionados
estandarizan
hilos
programas
utilitarios
trabajo
red
características
UNIX
ANSI
ISO
estandarizado
lenguaje
C.
10.1.6
MINIX
propiedad
sistemas
UNIX
modernos
complicados
sentido
antítesis
idea
original
UNIX
código
fuente
estu-
viera
disponible
mayoría
casos
impensable
persona
comprenderlo
situación
orilló
autor
libro
escribir
nue-
vo
sistema
parecido
UNIX
pequeño
comprenderlo
dispo-
nible
código
fuente
podía
utilizar
fines
educativos
sistema
consistía
11,800
líneas
800
líneas
código
ensamblador
liberó
1987
equivalente
función
versión
UNIX
pilar
principal
mayoría
departamentos
cien-
cias
computacionales
PDP-11
MINIX
sistemas
parecidos
UNIX
basaban
diseño
microkernel
idea
microkernel
proveer
funcionalidad
mínima
kernel
pa-
ra
confiable
eficiente
consecuencia
administración
memoria
sistema
archivos
dejaron
procesos
usuario
kernel
encargaba
paso
mensajes
procesos
cosas
kernel
1600
líneas
800
líneas
en-
samblador
cuestiones
técnicas
relacionadas
arquitectura
procesador
8088
drivers
dispositivos
2900
líneas
adicionales
kernel
sistema
archivos
5100
líneas
administrador
memoria
2200
líneas
ejecutaban
procesos
usuario
separados
microkernels
ventaja
sistemas
monolíticos
fáciles
comprender
mantener
estructura
sumamente
modular
proceso
pasar
código
kernel
usuario
confiables
fa-
lla
proceso
usuario
producen
daños
falla
componente
mo-
do
kernel
principal
desventaja
rendimiento
disminuye
cambios
adicionales
kernel
usuario
rendimiento
to-
do
sistemas
UNIX
modernos
ejecutan
Windows
usuario
simplemente
aceptan
reducción
rendimiento
obtener
modularidad
contrario
Win-
dows
GUI
Graphical
User
Interface
Interfaz
Gráfica
Usuario
kernel
diseños
microkernels
conocidos
época
Mach
Accetta
colabo-
radores
1986
Chorus
Rozier
colaboradores
1998
www
FreeLibros.meUnos
meses
aparición
MINIX
convirtió
artículo
culto
grupo
noticias
USENET
Google
comp.os.minix
40,000
usuarios
usuarios
contribuyeron
comandos
programas
usuario
MINIX
convirtió
compromiso
colectivo
involucrados
muchísimos
usuarios
Internet
prototipo
esfuerzos
colaborativos
llegaron
des-
pués
1997
liberó
versión
2.0
MINIX
sistema
base
incluye
trabajo
red
creció
62,200
líneas
código
2004
dirección
desarrollo
MINIX
cambiado
radical
enton-
ces
énfasis
construcción
sistema
extremo
confiable
seguro
pudie-
ra
reparar
automática
fallas
siguiera
funcionando
correcta
frente
activación
repetida
errores
software
consecuencia
idea
modularización
presentó
versión
expandió
considerable
MINIX
3.0
drivers
dispositivos
movieron
espacio
usuario
driver
ejecutaba
proceso
separado
tamaño
kernel
completo
redujo
drás-
tica
4000
líneas
código
programador
podía
comprender
fa-
cilidad
mecanismos
internos
modificaron
mejorar
tolerancia
errores
formas
portaron
500
programas
populares
UNIX
MINIX
3.0
incluyendo
Sistema
Window
llama
compiladores
incluyendo
gcc
software
procesamiento
texto
software
red
navegadores
Web
di-
ferencia
versiones
anteriores
tenían
naturaleza
educativa
MI-
NIX
3.0
sistema
podía
utilizar
aspectos
enfoque
orientado
alta
confiabilidad
objetivo
máximo
botones
reinicio
Posteriormente
apareció
edición
libro
describía
detalladamente
nue-
vo
sistema
código
fuente
proporcionaba
apéndice
Tanenbaum
Woodhull
2006
sistema
continúa
evolución
comunidad
activa
usuarios
obtener
detalles
versión
actual
costo
visitar
sitio
www.minix3.org
10.1.7
Linux
años
desarrollo
MINIX
discusión
Internet
personas
so-
licitaron
casos
exigieron
mejores
características
autor
fre-
cuencia
decía
mantener
sistema
pequeño
estudiantes
comprendieran
totalidad
curso
universitario
semestre
conti-
nuo
fastidió
usuarios
época
sistema
FreeBSD
disponible
opción
años
estudiante
finlandés
llamado
Linus
Torvalds
decidió
escribir
clon
UNIX
conocido
Linux
sis-
tema
producción
completo
características
MINIX
principio
pri-
mera
versión
Linux
0.01
liberó
1991
desarrollo
cruzado
máquina
MINIX
tomó
prestadas
numerosas
ideas
sistema
estructura
árbol
código
fuente
distribución
sistema
archivos
diseño
monolítico
microkernel
sistema
operativo
residía
kernel
código
9300
lí-
726
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.1
HISTORIA
UNIX
LINUX
727
neas
950
líneas
ensamblador
similar
versión
MINIX
cuan-
to
tamaño
podía
comparar
relación
funcionalidad
rediseño
MINIX
único
sistema
Torvalds
código
fuente
Linux
aumentó
tamaño
rapidez
evolucionó
convertirse
clon
UNIX
com-
pleto
producción
medida
agregaron
memoria
virtual
sistema
archivos
sofisticado
características
principio
ejecutaba
386
in-
cluso
incrustado
código
ensamblador
386
procedimientos
llevó
rápidamente
plataformas
ejecuta
amplia
variedad
máquinas
UNIX
diferencia
distinguirse
UNIX
Linux
utiliza
características
especiales
compilador
gcc
requeriría
trabajo
com-
pilarlo
compilador
estándar
ANSI
revisión
Linux
versión
1.0
liberó
1994
aproxima-
damente
165,000
líneas
código
incluía
sistema
archivos
asignación
memoria
red
compatible
BSD
sockets
TCP
IP
incluyó
drivers
dispositivos
siguientes
años
produjeron
revisiones
menores
Linux
compatible
UNIX
portó
enorme
cantidad
soft-
ware
sistema
Linux
logró
utilidad
Linux
atrajo
cantidad
personas
empezaron
trabajar
código
extendieron
maneras
supervisión
general
Torvalds
revisión
2.0
liberó
1996
Consistía
470,000
lí-
neas
8000
líneas
código
ensamblador
Incluía
aceptación
arquitecturas
64
bits
multiprogramación
simétrica
protocolos
red
características
exten-
sa
colección
drivers
dispositivos
ocupaba
fracción
masa
código
Des-
pués
liberaron
frecuencia
versiones
adicionales
números
versión
kernel
Linux
consisten
números
A.B.C.D
2.6.9.11
número
indica
versión
kernel
número
indica
revisión
ma-
yor
kernel
2.6
números
revisión
pares
correspondían
versiones
estables
ker-
nel
impares
correspondían
revisiones
inestables
desarrollo
kernel
2.6
números
manejaron
forma
distinta
tercer
número
corresponde
revisiones
menores
aceptación
drivers
cuarto
número
corresponde
correcciones
errores
menores
parches
seguridad
selección
software
estándar
UNIX
portado
Linux
incluyendo
Sistema
Window
cantidad
software
red
escrito
GUIs
dis-
tintas
GNOME
KDE
Linux
resumen
crecido
convertirse
clon
UNIX
completo
adornos
desear
amante
UNIX
característica
inusual
Linux
modelo
negocios
software
gratuito
descargar
sitios
Internet
ejemplo
www.kernel.org
Linux
incluye
licencia
idea-
Richard
Stallman
fundador
Fundación
software
libre
Linux
libre
licencia
conocida
GPL
GNU
Public
License
Licencia
pública
GNU
larga
licencia
Microsoft
Windows
especifica
código
usuarios
utilizar
copiar
modificar
redistribuir
código
fuente
binario
libremente
principal
restricción
obras
derivadas
kernel
Linux
www
FreeLibros.me728
CASO
ESTUDIO
LINUX
CAPÍTULO
10
vender
redistribuir
formato
binario
enviar
código
fuente
producto
disponible
petición
desee
Torvalds
controla
kernel
cerca
programadores
es-
crito
cantidad
software
nivel
usuario
migraron
prin-
cipio
comunidades
línea
MINIX
BSD
GNU
medida
Linux
evoluciona
usuarios
comunidad
Linux
desean
manipular
códi-
go
fuente
observe
cientos
libros
indican
instalar
utilizar
Linux
analizan
código
funciona
usuarios
Li-
nux
renuncian
distribución
gratuita
Internet
comprar
distribuciones
CD-ROM
disponibles
empresas
comerciales
competidoras
popu-
lar
sitio
Web
llamado
www.distrowatch.org
listan
100
distribuciones
Linux
populares
medida
empresas
software
empiezan
vender
versiones
Linux
empresas
hardware
ofrecen
preinstalarlo
computado-
ras
venden
línea
software
comercial
libre
empezado
borrar
considerable
anotación
pie
página
historia
Linux
interesante
observar
justo
cuan-
do
sistema
operativo
empezaba
crecer
popularidad
recibió
impulso
fuente
inesperada
AT&T.
1992
Berkeley
quedando
patrocinio
deci-
dió
terminar
desarrollo
BSD
versión
4.4BSD
formó
base
FreeBSD
esencia
versión
contenía
código
AT&T
Berkeley
liberó
softwa-
re
licencia
código
fuente
abierto
GPL
permitía
quisieran
cosa
demandar
Universidad
California
subsidiaria
AT&T
controlaba
UNIX
reaccionó
prontitud
adivinó
demandar
Universidad
Cali-
fornia
demandó
empresa
llamada
BSDI
establecida
desarrolladores
BSD
empaquetar
sistema
vender
soporte
forma
parecida
Red
Hat
empresas
Linux
código
AT&T
involucrado
demanda
basaba
violación
derechos
autor
marca
registrada
incluyendo
elementos
número
telefónico
1-800-ITS-UNIX
BSDI
instancia
caso
resolvió
corte
mantuvo
FreeBSD
mercado
tiempo
suficiente
Linux
pudiera
es-
tablecerse
caso
hubiera
llevado
cabo
demanda
principio
1993
hubiera
desencadenado
seria
competencia
sistemas
UNIX
gratuitos
código
fuen-
abierto
campeón
reinante
BSD
sistema
maduro
estable
seguimiento
acadé-
mico
remonta
1977
retador
vigoroso
joven
llamado
Linux
años
edad
seguidores
hubiera
terminado
ba-
talla
UNICES
libres
10.2
GENERALIDADES
LINUX
sección
veremos
introducción
general
Linux
forma
utiliza
bene-
ficio
lectores
familiarizados
sistema
operativo
material
aplica
mayoría
variantes
UNIX
pequeñas
modificaciones
www
FreeLibros.meSECCIÓN
10.2
GENERALIDADES
LINUX
729
Linux
interfaces
gráficas
enfoque
forma
Linux
aparece
pa-
ra
programador
trabaja
ventana
shell
X.
siguientes
secciones
con-
centraremos
llamadas
sistema
funcionamiento
interno
10.2.1
Objetivos
Linux
UNIX
sistema
interactivo
diseñado
manejar
procesos
usuarios
mis-
mo
tiempo
diseñado
programadores
programadores
utilizaran
entor-
mayoría
usuarios
relativamente
sofisticados
involucrados
proyectos
desarrollo
software
frecuencia
complejos
casos
cantidad
programadores
cooperan
activa
producir
sis-
tema
UNIX
herramientas
permitir
personas
trabajen
con-
compartan
información
formas
controladas
modelo
grupo
programadores
experimentados
trabajan
conjunto
cerca
producir
software
avanzado
du-
distinto
modelo
computadora
personal
principiante
trabaja
procesador
palabras
diferencia
refleja
UNIX
principio
na-
tural
Linux
heredado
tantos
objetivos
versión
computadora
personal
quieren
programadores
sistema
empezar
mayoría
desean
sistemas
simples
elegantes
consistentes
ejemplo
nivel
archivo
colección
bytes
distintas
clases
archivos
acceso
secuencial
acceso
aleatorio
acceso
manipulado
acceso
remoto
etcétera
mainframes
estor-
ba
similar
comando
ls
indica
listar
archivos
empiecen
comando
rm
indica
eliminar
archivos
empiecen
eliminar
archivo
cuyo
nombre
consiste
asterisco
característica
conoce
principio
menor
sorpresa
cosas
desean
programadores
experimentados
general
potencia
fle-
xibilidad
significa
sistema
pequeño
número
elementos
básicos
puedan
combinar
variedad
formas
adaptarse
aplicación
lineamientos
básicos
Linux
programa
cosa
hacerla
en-
compiladores
producen
listados
programas
mayoría
programadores
disgusto
redundancia
inútil
escribir
copy
basta
cp
extraer
líneas
contengan
cadena
ard
archivo
programador
Linux
escribe
grep
ard
método
opuesto
programador
seleccione
programa
grep
argumen-
tos
haga
grep
anuncie
diciendo
Hola
grep
busco
patrones
www
FreeLibros.me730
CASO
ESTUDIO
LINUX
CAPÍTULO
10
archivos
favor
escriba
patrón
recibir
patrón
grep
pide
nombre
archivo
pregunta
nombres
archivos
sintetiza
pregunta
correcto
tipo
interfaz
usuario
ideal
no-
vatos
desesperante
programadores
experimentados
desean
sirviente
niñera
10.2.2
Interfaces
Linux
sistema
Linux
considerar
tipo
pirámide
ilustra
figura
10-1
inferior
hardware
consiste
CPU
memoria
discos
monitor
teclado
dispositivos
hardware
básico
ejecuta
sistema
operativo
función
controlar
hardware
proveer
interfaz
llamadas
sistema
programas
llama-
das
sistema
permiten
programas
usuario
crear
administrar
procesos
archivos
recursos
Usuarios
Programas
utilitarios
estándar
shell
editores
compiladores
etc.
Biblioteca
estándar
open
close
read
write
fork
etc.
Sistema
operativo
Linux
administración
procesos
administración
memoria
sistema
archivos
etc.
Hardware
CPU
memoria
discos
terminales
etc.
Interfaz
usuario
Interfaz
biblioteca
Interfaz
llamadas
sistema
usuario
kernel
Figura
10-1
niveles
sistema
Linux
llamadas
sistema
programas
colocan
argumentos
registros
pila
emiten
instrucciones
trampa
cambiar
usuario
kernel
forma
escribir
instrucción
trampa
proporciona
biblio-
teca
procedimiento
llamada
sistema
procedimientos
escriben
len-
guaje
ensamblador
llamar
C.
coloca
argumentos
lugar
apropiado
ejecuta
instrucción
trampa
ejecutar
llamada
sistema
read
programa
llamar
procedimiento
biblioteca
read
información
adi-
cional
interfaz
biblioteca
interfaz
llamadas
sistema
especifica
POSIX
palabras
POSIX
indica
procedimientos
biblioteca
proveer
siste-
ma
esté
conformidad
parámetros
resultados
regresar
siquiera
menciona
llamadas
actuales
sistema
www
FreeLibros.meSECCIÓN
10.2
GENERALIDADES
LINUX
731
sistema
operativo
biblioteca
llamadas
sistema
versiones
Li-
nux
proporcionan
cantidad
programas
estándar
especifican
estándar
POSIX
1003.2
difieren
versión
Linux
incluyen
procesador
comandos
shell
compiladores
editores
programas
procesamiento
texto
herramientas
manipulación
archivos
programas
invoca
usuario
me-
diante
teclado
ende
hablar
interfaces
distintas
Linux
in-
terfaz
llamadas
sistema
interfaz
biblioteca
interfaz
formada
conjunto
programas
utilitarios
estándar
mayoría
distribuciones
computadora
personal
Linux
reemplazado
in-
terfaz
usuario
orientada
teclado
interfaz
gráfica
usuario
orientada
ratón
mo-
dificar
sistema
operativo
precisamente
flexibilidad
Linux
popular
permitido
sobrevivir
problemas
numerosos
cambios
tecnología
subyacente
GUI
Linux
similar
primeras
GUIs
desarrollaron
sistemas
UNIX
década
1970
popularizaron
plataformas
Macintosh
Windows
PC
GUI
crea
entorno
escritorio
metáfora
familiar
ventanas
iconos
car-
petas
barras
herramientas
capacidades
arrastrar
soltar
entorno
escritorio
comple-
to
contiene
administrador
ventanas
controla
posición
apariencia
ventanas
diversas
aplicaciones
proporciona
interfaz
gráfica
consistente
entornos
escritorio
populares
Linux
GNOME
Entorno
modelo
objetos
Red
GNU
KDE
Entorno
escritorio
Linux
GUIs
proporcionan
Sistema
Windowing
conocido
comúnmen-
X11
simplemente
define
protocolos
comunicación
visualización
manipular
ventanas
visualizaciones
mapas
bits
UNIX
sistemas
similares
servi-
dor
componente
principal
controla
dispositivos
teclado
ratón
pantalla
responsable
redirigir
entrada
aceptar
salida
programas
clientes
general
entorno
actual
GUI
crea
biblioteca
nivel
llamada
xlib
con-
funcionalidad
interactuar
servidor
X.
interfaz
gráfica
extiende
funcionali-
dad
básica
X11
enriquecer
vista
ventanas
proveer
botones
menús
iconos
opciones
servidor
iniciar
forma
manual
línea
comandos
general
inicia
proceso
arranque
administrador
pantalla
muestra
pantalla
gráfica
inicio
sesión
usuario
trabajar
sistemas
Linux
interfaz
gráfica
usuarios
utilizar
clics
ratón
ejecutar
aplicaciones
abrir
archivos
arrastrar
soltar
copiar
archivos
ubicación
etcétera
usuarios
invocar
programa
emulador
ter-
minales
xterm
proporciona
interfaz
básica
línea
comandos
sistema
operativo
sección
veremos
descripción
10.2.3
shell
sistemas
Linux
interfaz
gráfica
usuario
mayoría
programadores
usuarios
sofisticados
prefieren
interfaz
línea
comandos
conocida
shell
me-
nudo
inician
ventanas
shell
interfaz
gráfica
usuario
ponen
trabajar
www
FreeLibros.me732
CASO
ESTUDIO
LINUX
CAPÍTULO
10
interfaz
línea
comandos
shell
rápida
utilizar
poderosa
ex-
tiende
facilidad
usuario
contraiga
lesión
esfuerzo
repetitivo
ratón
tiempo
continuación
veremos
descripción
bash
shell
Es-
shell
basa
shell
original
UNIX
Bourne
shell
nombre
acrónimo
SHell
vuelto
nacer
Bourne
Again
SHell
utilizan
shells
ksh
csh
ejemplo
bash
shell
predeterminado
mayoría
sis-
temas
Linux
shell
inicia
inicializa
escribe
carácter
indicador
me-
nudo
signo
ciento
dólar
conocido
prompt
pantalla
espera
usuario
escriba
línea
comandos
usuario
escribe
línea
comandos
shell
extrae
palabra
asume
nombre
programa
ejecutar
busca
programa
ejecuta
shell
suspende
programa
termina
momento
leer
comando
importante
observación
shell
programa
usuario
ordinario
requiere
habilidad
leer
teclado
escribir
monitor
ejecutar
programas
comandos
recibir
argumentos
pasan
programa
llamó
ca-
denas
caracteres
ejemplo
línea
comandos
cp
org
dest
invoca
programa
cp
argumentos
org
dest
programa
interpreta
argu-
mento
nombre
archivo
existente
Realiza
copia
archivo
llama
dest
argumentos
nombres
archivos
head
20
archivo
argumento
/H1100220
indica
head
imprimir
primeras
20
líneas
archivo
número
predeterminado
líneas
10
argumentos
controlan
operación
comando
especifican
valor
opcional
banderas
convención
indican
me-
diante
guión
corto
guión
corto
requiere
evitar
ambigüedad
co-
mando
head
20
archivo
perfectamente
válido
indica
head
imprimir
10
líneas
iniciales
ar-
chivo
llamado
20
imprimir
10
líneas
iniciales
archivo
llamado
archivo
mayoría
comandos
Linux
aceptan
banderas
argumentos
facilitar
especificación
nombres
archivos
shell
acepta
caracteres
má-
gicos
comodines
ejemplo
asterisco
coincide
cadenas
posibles
ls
.c
indica
ls
listar
archivos
cuyo
nombre
termina
.c
archivos
llamados
x.c
y.c
z.c
comando
equivale
escribir
ls
x.c
y.c
z.c
www
FreeLibros.meSECCIÓN
10.2
GENERALIDADES
LINUX
733
signo
interrogación
comodín
coincide
carácter
individual
lista
caracteres
corchetes
selecciona
cualquiera
ls
ape
lista
archivos
empiecen
programa
shell
abrir
terminal
monitor
teclado
leer
escri-
bir
shell
programa
inicia
acceso
automá-
tico
archivo
llamado
entrada
estándar
leer
archivo
llamado
salida
estándar
escribir
salida
normal
archivo
llamado
error
estándar
escribir
mensajes
error
general
valor
predeterminado
terminal
lecturas
entrada
estándar
provienen
teclado
escrituras
salida
error
estándar
panta-
lla
programas
Linux
leen
entrada
estándar
escriben
salida
estándar
opciones
predeterminadas
ejemplo
sort
invoca
programa
sort
lee
líneas
terminal
usuario
escriba
CTRL-D
indicar
archivo
ordena
alfabética
escribe
resultado
pantalla
redirigir
entrada
estándar
salida
estándar
útil
sintaxis
redirigir
entrada
estándar
utiliza
signo
menor
seguido
nombre
archivo
entrada
similar
salida
estándar
redirige
utilizar
signo
comando
redirigir
ejemplo
comando
sort
ent
sal
sort
reciba
entrada
archivo
ent
escriba
salida
archivo
sal
redirigido
error
estándar
mensaje
pantalla
conoce
filtro
progra-
ma
lee
entrada
entrada
estándar
realiza
procesamiento
escribe
sa-
lida
salida
estándar
Considere
línea
comandos
consiste
comandos
separados
sort
ent
temp
head
30
temp
rm
temp
ejecuta
sort
recibe
entrada
ent
escribe
salida
temp
completar
coman-
do
shell
ejecuta
head
indica
imprima
primeras
30
líneas
temp
salida
están-
cuya
opción
predeterminada
terminal
elimina
archivo
frecuencia
ocurre
programa
línea
comandos
produce
salida
utiliza
entrada
programa
ejemplo
utilizamos
archivo
temp
contener
salida
Linux
proporciona
construcción
simple
sort
ent
head
30
barra
vertical
conocida
símbolo
tubería
pipe
indica
recibir
salida
sort
utilizarla
entrada
head
elimina
necesidad
crear
utilizar
www
FreeLibros.me734
CASO
ESTUDIO
LINUX
CAPÍTULO
10
eliminar
archivo
temporal
colección
comandos
conectados
símbolos
tubería
co-
noce
tubería
línea
pipeline
contener
comandos
arbitrarios
si-
guiente
ejemplo
muestra
tubería
línea
componentes
grep
ter
.t
sort
head
20
tail
foo
líneas
contengan
cadena
ter
archivos
terminen
.t
es-
criben
salida
estándar
ordenan
primeras
20
líneas
seleccionan
comando
head
pasa
tail
comando
escribe
líneas
16
20
lista
ordenada
líneas
foo
ejemplo
forma
Linux
ofrece
blo-
ques
construcción
básicos
numerosos
filtros
trabajo
mecanismo
reúnan
formas
ilimitadas
Linux
sistema
multiprogramación
propósito
general
usuario
ejecu-
tar
programas
proceso
separado
sintaxis
shell
ejecutar
proceso
plano
colocar
signo
comando
wc
ejecuta
programa
conteo
palabras
wc
cuente
número
líneas
bandera
entrada
escribe
resultado
plano
escribe
programa
shell
escribe
indicador
listo
aceptar
manejar
comando
canalizaciones
plano
ejemplo
sort
head
ejecutar
canalizaciones
plano
tiempo
colocar
lista
comandos
shell
archivo
iniciar
shell
archivo
entrada
estándar
shell
simplemente
procesa
orden
forma
comandos
escriben
teclado
archivos
contienen
co-
mandos
shell
llaman
secuencias
comandos
shell
secuencias
comandos
pue-
den
asignar
valores
variables
shell
leerlos
parámetros
utilizar
construcciones
if
for
whiley
case
secuencia
comandos
shell
realidad
programa
escrito
lenguaje
shell
shell
Berkeley
shell
alternativo
diseñado
secuencias
comandos
shell
lenguaje
comandos
general
vean
programas
aspectos
shell
pro-
grama
usuario
personas
escrito
distribuido
variedad
shells
10.2.4
Programas
utilitarios
Linux
interfaz
usuario
shell
línea
comandos
Linux
consiste
número
pro-
gramas
utilitarios
estándar
programas
dividir
categorías
muestra
continuación
www
FreeLibros.meSECCIÓN
10.2
GENERALIDADES
LINUX
735
Comandos
manipulación
archivos
directorios
Filtros
Herramientas
desarrollo
programas
editores
compiladores
Procesamiento
texto
Administración
sistema
Misceláneos
estándar
POSIX
1003.2
especifica
sintaxis
semántica
100
pro-
gramas
principalmente
primeras
categorías
idea
estandarizarlos
posi-
ble
cualquiera
escribir
secuencias
comandos
shell
utilicen
programas
funcionen
sistemas
Linux
herramientas
estándar
programas
aplicación
navegadores
Web
visores
imágenes
etcétera
considerar
ejemplos
programas
empezando
manipulación
archivos
directorios
cp
copia
archivo
archivo
deja
intacto
archivo
original
contrario
mv
copia
elimina
original
efecto
mueve
archivo
copia
sentido
usual
concatenar
archivos
cat
lee
archivos
entrada
copia
salida
estándar
eliminar
archi-
vos
comando
rm
comando
chmod
permite
propietario
cambiar
bits
permi-
sos
modificar
permisos
acceso
directorios
crear
mkdir
eliminar
rmdir
lista
archivos
directorio
utilizar
ls
número
banderas
controlar
nivel
detalle
mostrar
archivo
ejem-
plo
tamaño
propietario
grupo
fecha
creación
determinar
ordenamiento
ejemplo
alfabético
hora
modificación
invertido
especificar
distribución
panta-
lla
visto
filtros
grep
extrae
líneas
contienen
patrón
específico
entrada
estándar
archivos
entrada
sort
ordena
entrada
escribe
sali-
estándar
head
extrae
líneas
iniciales
entrada
tail
extrae
líneas
finales
entrada
filtros
definidos
estándar
1003.2
cut
paste
permiten
cortar
pegar
colum-
nas
texto
archivos
od
convierte
entrada
general
binaria
texto
ASCII
valor
octal
decimal
hexadecimal
tr
realiza
traducción
caracteres
ejemplo
minúscula
mayúscula
pr
formato
salida
impresora
incluyendo
opciones
incluir
cabeceras
números
páginas
ejemplo
compiladores
herramientas
programación
incluyen
gcc
llama
compilador
ar
recopila
procedimientos
biblioteca
archivos
archivos
www
FreeLibros.meOtra
herramienta
importante
make
utiliza
mantenimiento
programas
ex-
tensos
cuyo
código
consiste
archivos
general
archivos
encabezado
contienen
declaraciones
tipos
variables
macros
archi-
vos
código
fuente
incluyen
archivos
encabezado
directiva
inclu-
sión
especial
archivos
código
fuente
compartir
declaraciones
obstante
modifica
archivo
encabezado
necesario
buscar
archivos
código
fuente
dependan
recompilarlos
función
make
re-
gistro
dependencias
archivos
encabezados
operaciones
similares
arre-
glar
compilaciones
necesarias
ocurran
automática
programas
Linux
pequeños
configuran
compilarlos
make
figura
10-2
lista
selección
programas
utilitarios
POSIX
bre-
ve
descripción
sistemas
Linux
programas
736
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Programa
común
cat
Concatena
archivos
coloca
salida
estándar
chmod
Modifica
protección
archivo
cp
Copia
archivos
cut
Recorta
columnas
texto
archivo
grep
Busca
patrón
archivo
head
Extrae
primeras
líneas
archivo
ls
Lista
directorio
make
Compila
archivos
crear
binario
mkdir
Crea
directorio
od
Realiza
vaciado
octal
archivo
paste
Pega
columnas
texto
archivo
pr
formato
archivo
imprimirlo
ps
Lista
proceso
ejecución
rm
Elimina
archivos
rmdir
Elimina
directorio
sort
Ordena
archivo
líneas
forma
alfabética
tail
Extrae
líneas
archivo
tr
Traduce
conjuntos
caracteres
Figura
10-2
programas
utilitarios
Linux
requeridos
POSIX
10.2.5
Estructura
kernel
figura
10-1
vimos
estructura
general
sistema
Linux
veamos
detalle
kernel
examinar
diversas
partes
programación
procesos
sistema
archivos
www
FreeLibros.meSECCIÓN
10.2
GENERALIDADES
LINUX
737
kernel
posiciona
directamente
hardware
permite
interacciones
disposi-
tivos
unidad
administración
memoria
controla
acceso
CPU
dispositivos
muestra
figura
10-3
nivel
contiene
manejadores
interrupciones
forma
principal
interactuar
dispositivos
meca-
nismo
despachamiento
nivel
despachamiento
ocurre
produce
inte-
rrupción
código
nivel
detiene
proceso
ejecución
guarda
estructuras
procesos
kernel
inicia
driver
apropiado
despachamiento
procesos
ocurre
kernel
completa
operaciones
tiempo
iniciar
proceso
usuario
código
despachamiento
ensamblador
distinto
planifi-
cación
procesos
dividir
diversos
subsistemas
kernel
componentes
principales
componente
figura
10-3
contiene
piezas
kernel
responsables
interac-
tuar
dispositivos
operaciones
red
almacenamiento
nivel
al-
to
operaciones
integradas
nivel
Sistema
archivos
virtuales
nivel
superior
operación
lectura
archivo
encuentre
memoria
disco
obtener
carácter
entrada
terminal
nivel
operaciones
pasan
driver
dispositivo
drivers
Linux
clasifican
drivers
dispositivos
caracteres
drivers
disposi-
tivos
bloques
principal
diferencia
dispositivos
bloques
permiten
ac-
cesos
aleatorios
búsquedas
dispositivos
caracteres
Técnicamente
Llamadas
sistema
Interrupciones
Despachador
Sistema
archivos
virtuales
Terminales
Sockets
Sistemas
archivos
Protocolos
red
Drivers
controlado-
res
red
Drivers
controladores
bloques
Drivers
controladores
caracteres
Planificador
Nivel
blo-
genérico
Disciplina
línea
Caché
páginas
Reemplazo
páginas
paginación
Memoria
virtual
Manejo
señales
Creación
terminación
procesos/
hilos
Planificación
CPU
Componente
Componente
administración
memoria
Componente
administración
procesos
Figura
10-3
Estructura
kernel
Linux
www.FreeLibros.medispositivos
red
realidad
dispositivos
caracteres
manejan
distinta
separarlos
hicimos
figura
nivel
driver
dispositivos
código
kernel
distinto
tipo
dis-
positivo
dispositivos
caracteres
utilizar
maneras
programas
co-
mo
editores
visuales
vi
emacs
requieren
pulsación
tecla
medida
escribe
terminal
cruda
tty
programas
shell
orientados
lí-
neas
permiten
usuarios
editar
línea
completa
oprimir
INTRO
enviarla
programa
caso
flujo
caracteres
dispositivo
terminal
pasa
conoce
disciplina
línea
aplica
formato
apropiado
software
red
modular
admite
distintos
dispositivos
protocolos
nivel
drivers
red
maneja
tipo
función
enrutamiento
asegurar
paquete
correcto
llegue
dispositivo
manejador
protocolo
correcto
mayoría
siste-
Linux
contienen
funcionalidad
enrutador
hardware
kernel
rendimiento
menor
enrutador
hardware
código
enrutador
pila
protocolos
actual
incluye
IP
TCP
pro-
tocolos
adicionales
interfaz
sockets
cubre
red
permite
programas
creen
soc-
kets
redes
protocolos
específicos
obtiene
vuelta
descriptor
archivos
socket
utilice
programador
drivers
disco
componente
respon-
sable
ordenar
emitir
peticiones
operar
disco
forma
trate
evitar
desperdicie
movimiento
cabeza
disco
cumplir
directiva
sis-
tema
superior
columna
dispositivos
bloques
sistemas
archivos
Linux
sistemas
archivos
coexisten
forma
concu-
rrente
ocultar
espantosas
diferencias
arquitectónicas
diversos
dispositivos
hardware
implementación
sistema
archivos
nivel
dispositivos
bloques
gené-
ricos
ofrece
abstracción
utilizan
sistemas
archivos
derecha
figura
10.3
componentes
clave
kernel
Linux
És-
tos
responsables
memoria
tareas
administración
procesos
tareas
administración
memoria
incluyen
mantenimiento
asignaciones
memoria
vir-
tual
memoria
física
mantenimiento
caché
páginas
acceso
reciente
imple-
mentación
directiva
reemplazo
páginas
proceso
traer
memoria
páginas
código
datos
necesarias
demanda
responsabilidad
clave
componente
administración
procesos
creación
termi-
nación
procesos
incluye
planificador
procesos
selecciona
proceso
hilo
ejecutar
continuación
veremos
sección
kernel
Linux
consi-
dera
procesos
hilos
simplemente
entidades
ejecutables
planifica
base
directiva
planificación
global
código
manejo
señales
pertene-
ce
componente
componentes
representan
separado
figura
interdependien-
tes
general
sistemas
archivos
acceden
archivos
dispositivos
bloques
ocultar
latencias
accesos
disco
archivos
copian
caché
páginas
memoria
principal
archivos
crear
738
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
739
forma
dinámica
representación
memoria
archi-
vos
proporcionan
información
recursos
tiempo
ejecución
sistema
memoria
virtual
depender
partición
disco
área
intercam-
bio
archivo
respaldar
partes
memoria
principal
necesite
liberar
páginas
depende
componente
S.
interdepen-
dencias
componentes
estáticos
kernel
Linux
acepta
módulos
cargan
forma
dinámica
módulos
utilizar
agregar
reemplazar
drivers
dis-
positivos
predeterminados
sistema
archivos
componentes
red
códigos
ker-
nel
módulos
muestran
figura
10-3
superior
interfaz
llamadas
sistema
kernel
llamadas
sistema
llegan
producen
interrupción
cambia
ejecución
usuario
kernel
protegido
pasa
control
componentes
kernel
an-
tes
descritos
10.3
PROCESOS
LINUX
secciones
anteriores
empezamos
análisis
Linux
punto
vista
teclado
usuario
ve
ventana
xterm
Vimos
ejemplos
comandos
shell
programas
utilitarios
utilizan
frecuencia
Terminamos
descripción
general
bre-
ve
estructura
sistema
llegado
momento
profundizar
kernel
analizar
detalle
conceptos
básicos
Linux
procesos
memoria
sistema
archivos
entra-
salida
nociones
importantes
llamadas
sistema
interfaz
sistema
operativo
manipulan
ejemplo
llamadas
sistema
crear
proce-
sos
hilos
asignar
memoria
abrir
archivos
operaciones
S.
desgracia
tantas
versiones
Linux
existencia
diferencias
capítulo
concentraremos
características
comunes
versiones
Li-
nux
enfocarnos
versión
específica
secciones
es-
pecial
secciones
implementación
análisis
aplique
forma
versiones
10.3.1
Conceptos
fundamentales
entidades
activas
principales
sistema
Linux
procesos
similares
procesos
secuenciales
clásicos
estudiamos
capítulo
proceso
ejecuta
programa
principio
hilo
control
palabras
contador
pro-
grama
instrucción
ejecutar
Linux
permite
proceso
cree
hilos
adicionales
empieza
ejecutarse
Linux
sistema
multiprogramación
procesos
indepen-
dientes
ejecución
tiempo
usuario
procesos
activos
sistema
cientos
miles
procesos
eje-
www
FreeLibros.me740
CASO
ESTUDIO
LINUX
CAPÍTULO
10
cución
mayoría
estaciones
trabajo
usuario
usuario
ausente
docenas
procesos
ejecutándose
plano
procesos
llama
demonios
procesos
inician
secuencia
comandos
shell
cuan-
do
inicia
sistema
demonios
comunes
cron
despierta
minuto
revisar
tra-
realiza
trabajo
regresa
inactividad
hora
verificación
demonio
necesario
Linux
programar
actividades
lleven
cabo
minutos
horas
meses
ejemplo
suponga
usua-
rio
cita
dentista
punto
martes
crear
entrada
base
datos
demonio
cron
indicarle
emita
sonido
ejemplo
2:30
Cuan-
do
lleguen
hora
cita
demonio
cron
ve
trabajo
empieza
co-
mo
proceso
programa
genera
sonido
demonio
cron
utiliza
iniciar
actividades
periódicas
respal-
disco
diarios
A.M.o
recordar
usuarios
olvidadizos
31
octubre
año
comprar
dulces
halloween
demonios
encargan
correo
electróni-
co
entrante
saliente
administran
línea
cola
impresora
comprueban
suficien-
tes
páginas
libres
memoria
tareas
similares
implementación
demonios
Linux
simple
proceso
separado
independiente
procesos
Linux
procesos
crean
forma
especialmente
simple
llamada
sistema
fork
crea
copia
exacta
proceso
original
proceso
bifurcación
proce-
so
padre
proceso
conoce
proceso
hijo
padre
hijo
imágenes
memoria
privadas
padre
cambia
variables
cam-
bios
visibles
hijo
viceversa
archivos
abiertos
comparten
padre
hijo
abrió
archivo
padre
fork
seguirá
abierto
padre
hijo
cambios
realice
cualquiera
procesos
visibles
comportamien-
to
razonable
cambios
visibles
proceso
relacionado
abra
archivo
imágenes
memoria
variables
registros
idéntico
padre
hijo
genera
pequeña
dificultad
procesos
eje-
cutar
código
padre
ejecutar
código
hijo
secreto
llamada
sis-
tema
forkdevuelve
hijo
valor
distinto
cero
PID
Process
Identifer
Identificador
proceso
hijo
padre
general
procesos
revisan
valor
retorno
actúan
acorde
muestra
figura
10-4
procesos
denominan
PIDs
crea
proceso
padre
re-
cibe
PID
hijo
hijo
desea
PID
llamada
sistema
getpidse
proporciona
PIDs
utilizan
formas
ejemplo
proceso
hijo
termina
padre
recibe
PID
hijo
acaba
terminar
im-
portante
padre
hijos
hijos
hijos
proceso
original
construir
árbol
completo
hijos
nietos
descen-
dientes
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
741
pid
fork
fork
éxito
pid
padre
if
pid
manejar_error
fork
falló
memoria
tabla
llenas
else
if
pid
código
padre
else
código
hijo
Figura
10-4
Creación
procesos
Linux
Linux
procesos
comunicar
forma
paso
mensajes
crear
canal
procesos
proceso
escribir
flujo
bytes
lea
canales
conocen
tuberías
sincronización
po-
sible
proceso
leer
canalización
vacía
bloquea
datos
disponibles
tuberías
línea
shell
implementan
símbolos
tubería
shell
ve
línea
sort
head
crea
procesos
sort
head
establece
tubería
canalización
forma
salida
estándar
sort
conecta
entrada
estándar
head
forma
da-
tos
escribe
sort
directamente
head
archivo
tubería
llena
sis-
tema
deja
ejecutar
sort
head
eliminado
datos
procesos
comunicar
forma
interrupciones
software
pro-
ceso
enviar
conoce
señal
proceso
procesos
indicar
sistema
quieren
ocurra
llegue
señal
opciones
ignorarla
atraparla
dejar
señal
elimine
proceso
opción
predeterminada
mayoría
señales
proceso
elige
atrapar
señales
envían
especificar
procedimiento
ma-
nejo
señales
llega
señal
control
cambia
abrupta
manejador
Cuan-
do
manejador
termina
regresa
control
regresa
lugar
provino
análogo
interrupciones
hardware
proceso
enviar
señales
miembros
grupo
procesos
consiste
padre
ancestros
hermanos
hijos
descendientes
proceso
enviar
señal
miembros
gru-
po
procesos
llamada
sistema
señales
utilizan
fines
ejemplo
proceso
realizando
ope-
raciones
aritméticas
punto
flotante
manea
inadvertida
realiza
división
recibe
señal
SIGFPE
excepción
punto
flotante
señales
requeridas
POSIX
listan
figura
10-5
sistemas
Linux
señales
adicionales
programas
utilizan
portátiles
versiones
Linux
UNIX
general
10.3.2
Llamadas
sistema
administrar
procesos
Linux
veamos
llamadas
sistema
Linux
tratan
administración
procesos
principales
listan
figura
10-6
Fork
lugar
empezar
análisis
www.FreeLibros.mellamada
sistema
fork
sistemas
UNIX
tradicionales
aceptan
principal
forma
crear
proceso
sistemas
Linux
subsección
analizaremos
alternativa
Crea
duplicado
exacto
proceso
original
incluyendo
descriptores
archivos
registros
fork
proceso
original
copia
padre
hijo
caminos
separados
variables
valores
idénticos
momento
fork
copia
espacio
direcciones
padre
crear
hijo
cambios
poste-
riores
afectan
llamada
forkdevuelve
valor
cero
hi-
jo
PID
hijo
padre
PID
devuelto
procesos
padre
hijo
mayoría
casos
forkel
hijo
ejecutar
código
distinto
padre
Considere
caso
shell
Lee
comando
terminal
bifurca
proceso
hijo
espe-
ra
hijo
ejecute
comando
lee
comando
hijo
termina
esperar
hijo
termine
padre
ejecuta
llamada
sistema
waitpid
espera
hijo
termine
hijo
Waitpidtiene
parámetros
per-
mite
proceso
llamada
esperar
hijo
específico
/H110021
hi-
jo
hijo
termine
parámetro
dirección
variable
establecerá
salida
hijo
terminación
normal
anormal
valor
salida
determina
proceso
llamada
bloquea
regresa
hi-
jo
terminado
caso
shell
proceso
hijo
ejecutar
comando
escrito
usuario
utiliza
llamada
sistema
exec
imagen
núcleo
reemplace
archivo
nombrado
parámetro
figura
10-7
muestra
shell
simplificado
ilustra
fork
waitpidy
exec
742
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Señal
Causa
SIGABRT
envía
abortar
proceso
forzar
vaciado
núcleo
SIGALRM
activó
reloj
alarma
SIGFPE
Ocurrió
error
punto
flotante
ejemplo
división
SIGHUP
línea
telefónica
utilizaba
proceso
colgó
SIGILL
usuario
oprimió
SUPR
interrumpir
proceso
SIGQUIT
usuario
oprimió
tecla
solicita
vaciado
núcleo
SIGKILL
envió
eliminar
proceso
atrapar
ignorar
SIGPIPE
proceso
escribió
tubería
lectores
SIGSEGV
proceso
referencia
dirección
memoria
inválida
SIGTERM
utiliza
solicitar
proceso
termine
forma
correcta
SIGUSR1
Disponible
propósitos
definidos
aplicación
SIGUSR2
Disponible
propósitos
definidos
aplicación
Figura
10-5
señales
requeridas
POSIX
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
743
caso
general
exectiene
parámetros
nombre
archivo
ejecutar
apuntador
arreglo
argumentos
apuntador
arreglo
entorno
describi-
remos
proporcionan
procedimientos
biblioteca
execl
execv
execle
execve
permitir
omitan
parámetros
especifiquen
formas
es-
tos
procedimientos
invocan
llamada
sistema
subyacente
llamada
sistema
exec
procedimiento
biblioteca
nombre
utilizar
considerar
caso
comando
escribe
shell
cp
archivo1
archivo2
utiliza
copiar
archivo1
archivo2
bifurcación
shell
hijo
locali-
za
ejecuta
archivo
cp
pasa
información
archivos
copiar
programa
principal
cp
programas
contiene
declaración
funciones
main
argc
argv
envp
argc
número
elementos
línea
comandos
incluyendo
nombre
programa
ejemplo
argc
parámetro
argv
apuntador
arreglo
elemento
arreglo
apuntador
i-ésima
cadena
línea
comandos
ejemplo
argv[0
apuntaría
cadena
cp
similar
argv[1
apuntaría
cadena
archivo1
caracteres
argv
debería
apuntar
cadena
caracteres
archivo2
tercer
parámetro
main
envp
apuntador
entorno
arreglo
cadenas
contie-
nen
asignaciones
forma
nombre
valor
utiliza
pasar
información
programa
Llamada
sistema
Descripción
pid
fork
Crea
proceso
hijo
idéntico
padre
pid
waitpid(pid
statloc
opts
Espera
hijo
termine
execve(name
argv
envp
Reemplaza
imagen
núcleo
proceso
exit(status
Termina
ejecución
proceso
devuelve
sigaction(sig
act
oldact
Define
acción
señales
sigreturn(&context
Regresa
señal
sigprocmask(how
set
old
Examina
cambia
máscara
señal
sigpending(set
Obtiene
conjunto
señales
bloqueadas
sigsuspend(sigmask
Reemplaza
máscara
señal
suspende
proceso
kill(pid
sig
Envía
señal
proceso
residual
alarm(seconds
Establece
reloj
alarma
pause
Suspende
proceso
llamada
señal
Figura
10-6
llamadas
sistema
relacionadas
procesos
código
retorno
/H110021
ocurre
error
pides
ID
proceso
residual
tiempo
res-
tante
alarma
parámetros
nombres
sugieren
www
FreeLibros.me744
CASO
ESTUDIO
LINUX
CAPÍTULO
10
tipo
terminal
nombre
directorio
inicio
figura
10-7
pasa
entorno
hijo
tercer
parámetro
ex
ecve
cero
caso
execle
complicado
desespere
llamada
sistema
compleja
resto
llamadas
simples
ejemplo
llamada
simple
considere
exit
proce-
sos
terminar
ejecución
parámetro
salida
255
devuelve
padre
variable
status
llamada
sistema
waitpid
byte
orden
infe-
rior
status
contiene
terminación
terminación
normal
valo-
res
diversas
condiciones
error
byte
orden
superior
contiene
salida
hijo
255
especificado
llamada
hijo
exit
ejemplo
proceso
padre
eje-
cuta
instrucción
waitpid(/H110021
status
proceso
suspenderá
hijos
termine
ejemplo
hijo
termina
valor
parámetro
xit
padre
despierte
PID
hijo
status
se-
rá
0x0400
prefijo
0x
indica
valor
hexadecimal
byte
orden
inferior
status
relaciona
señales
valor
hijo
devolvió
llamada
exit
proceso
termina
padre
espera
proceso
entra
tipo
animación
suspendida
conocida
zombie
padre
esperando
proceso
termina
llamadas
sistema
relacionadas
señales
utilizan
formas
ejemplo
usuario
indica
accidente
editor
texto
muestre
contenido
completo
archivo
extenso
error
necesita
forma
interrumpir
editor
opción
usual
usuario
oprima
tecla
especial
ejemplo
SUPR
CTRL-C
envíe
señal
editor
atrapará
señal
detendrá
impresión
while(TRUE
repite
escribir_indicador
muestra
prompt
pantalla
leer_comando(comando
params
lee
línea
entrada
teclado
pid
fork
bifurca
proceso
hijo
if
pid
printf(“No
bifurcar0
condición
error
continue
repite
ciclo
if
pid
waitpid
/H110021
padre
espera
hijo
else
execve(comando
params
hijo
trabajo
Figura
10.7
shell
simplificado
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
745
anunciar
dispuesto
atrapar
señal
proceso
llamada
sistema
sigaction
parámetro
señal
atrapar
vea
figura
10-5
apuntador
estructura
proporciona
apuntador
procedimien-
to
manejo
señales
bits
banderas
apunta
estructura
sistema
devuelve
información
manejo
señales
efecto
caso
restaurar
manejador
señales
ejecutar
tiempo
quiera
prác-
tica
común
encontrar
manejadores
señales
cortos
termina
procedimiento
manejo
señales
regresa
punto
interrumpió
llamada
sistema
sigactiontambién
utilizar
ignore
señal
restaurar
acción
predeterminada
eliminar
proceso
Oprimir
SUPR
única
forma
enviar
señal
llamada
sistema
killpermite
proceso
envíe
señal
proceso
relacionado
elección
nombre
kill
es-
ta
llamada
sistema
mayoría
procesos
envían
señales
procesos
intención
atrapen
aplicaciones
tiempo
real
interrumpir
proceso
inter-
valo
específico
acción
volver
transmitir
paquete
haberse
perdido
línea
comunicación
confiable
manejar
situación
utiliza
llamada
sistema
alarm
parámetro
especifica
intervalo
segundos
envía
señal
SIGALARM
proceso
proceso
alarma
pendiente
momento
llamada
alarmcon
parámetro
10
segundos
segun-
llamada
alarmcon
parámetro
30
segundos
generará
señal
20
segundos
llamada
llamada
alarmcancela
prime-
ra
atrapa
señal
alarma
realiza
acción
predeterminada
elimina
proceso
envió
señal
Técnicamente
señales
alarma
ignorar
sentido
sucede
proceso
llegue
señal
ejemplo
considere
programa
capacitación
asistida
computadora
evalúa
velocidad
lectura
comprensión
Muestra
texto
pantalla
llama
alarmpara
envíe
señal
30
segundos
estudiante
lee
texto
programa
esperar
ciclo
estrecho
desperdiciaría
tiempo
CPU
proceso
plano
usuario
necesitar
solución
utilizar
llamada
sistema
pause
indica
Linux
suspender
proceso
llegue
próxima
señal
10.3.3
Implementación
procesos
hilos
Linux
Linux
proceso
iceberg
agua
importante
proceso
usuario
ejecuta
programa
usuario
hilos
realiza
llamada
sistema
atrapa
kernel
empieza
ejecutarse
contexto
kernel
ma-
www.FreeLibros.mepa
memoria
distinto
acceso
completo
recursos
máquina
mis-
mo
hilo
pila
kernel
contador
pro-
grama
kernel
elementos
importantes
llamada
sistema
llegar
bloquear
proceso
ejemplo
esperar
complete
operación
disco
Des-
pués
contador
programa
registros
guardan
hilo
reiniciar
mo-
do
kernel
kernel
Linux
representa
procesos
interna
tareas
es-
tructura
task_struct
diferencia
métodos
sistemas
operativos
distinguen
proceso
proceso
ligero
hilo
Linux
utiliza
estructura
tarea
representar
cual-
quier
contexto
ejecución
proceso
hilo
representará
es-
tructura
tarea
proceso
multihilo
estructura
tarea
hilos
nivel
usuario
kernel
multihilo
hilos
nivel
kernel
es-
tán
asociados
proceso
usuario
ejecutan
código
kernel
sec-
ción
regresaremos
procesos
multihilo
hilos
general
analizaremos
detalle
proceso
descriptor
tipo
task_struct
residente
memoria
momen-
to
descriptor
contiene
información
vital
necesaria
kernel
administre
procesos
incluyendo
parámetros
programación
listas
descriptores
archivos
abier-
tos
etcétera
descriptor
proceso
memoria
pila
proceso
kernel
crean
momento
crea
proceso
compatibilidad
sistemas
UNIX
Linux
identifica
procesos
Identificador
proceso
PID
kernel
organiza
procesos
lista
doblemente
en-
lazada
estructuras
tareas
utilizarlo
recorrer
listas
enlazadas
acceder
descriptores
procesos
PID
asignar
dirección
estructura
tarea
acceder
información
proceso
inmediato
estructura
tarea
contiene
campos
contienen
apuntadores
estructuras
datos
segmentos
contienen
información
archivos
abiertos
segmentos
relacionan
estructura
proceso
nivel
usuario
interés
proceso
usuario
ejecutar
campos
pue-
den
intercambiar
paginar
memoria
desperdiciarla
información
necesaria
ejemplo
proceso
reciba
señal
momento
in-
tercambiarlo
memoria
lea
archivo
razón
infor-
mación
señales
memoria
momento
proceso
esté
presente
memoria
información
descriptores
archivos
mantener
estructura
usuario
memoria
proceso
encuentre
memoria
ejecutar
información
descriptor
proceso
clasificar
siguientes
catego-
rías
Parámetros
planificación
Prioridad
proceso
cantidad
tiempo
CPU
consumió
recientemente
tiempo
inactivo
recientemente
conjunto
es-
tos
parámetros
utilizan
determinar
proceso
ejecutar
continuación
746
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
747
Imagen
memoria
Apuntadores
segmentos
texto
datos
pila
tablas
pági-
nas
segmento
texto
compartido
apuntador
texto
apunta
tabla
texto
compartida
proceso
memoria
información
encontrar
partes
disco
Señales
Máscaras
muestran
señales
ignoran
señales
atrapan
bloquean
forma
temporal
proceso
entregarlas
Registros
máquina
ocurre
trampa
kernel
registros
má-
quina
incluyendo
punto
flotante
utilizan
guardan
llamada
sistema
Información
llamada
sistema
actual
incluyendo
parámetros
resultados
Tabla
descriptores
archivos
invoca
llamada
involucra
descriptor
archivos
utiliza
descriptor
índice
tabla
localizar
estructura
datos
núcleo
nodo-i
corresponde
archivo
Contabilidad
Apuntador
tabla
tiempo
CPU
usuario
sistema
utilizó
proceso
sistemas
mantienen
límites
cantidad
tiempo
CPU
utilizar
proceso
tamaño
máximo
pila
número
marcos
página
consumir
elementos
Pila
kernel
pila
fija
kernel
proceso
utilice
Misceláneos
actual
proceso
evento
espera
tiempo
de-
be
transcurrir
active
alarma
PID
PID
proceso
padre
identificación
usuario
grupo
información
fácil
explicar
crean
procesos
Linux
mecanismo
crear
proceso
realidad
simple
crean
descriptor
proceso
área
usuario
proceso
hijo
llenan
datos
pa-
dre
hijo
recibe
PID
establece
mapa
memoria
recibe
acceso
compartido
ar-
chivos
padre
establecen
registros
listo
ejecutarse
ejecuta
llamada
sistema
fork
proceso
llamada
atrapa
kernel
crea
estructura
tarea
estructuras
datos
adicionales
pila
kernel
estructura
thread_info
estructura
asigna
desplazamiento
fijo
pila
proceso
contiene
parámetros
direc-
ción
descriptor
proceso
almacenar
dirección
descriptor
proceso
ubicación
fija
Linux
necesita
operaciones
eficientes
localizar
estructura
tarea
pa-
ra
proceso
ejecución
contenido
descriptor
proceso
llena
base
valores
descriptor
padre
Linux
busca
PID
disponible
actualiza
entrada
tabla
www.FreeLibros.mehash
PIDs
apunte
estructura
tarea
caso
colisiones
tabla
hash
descriptores
procesos
encadenar
establece
campos
task_struct
pa-
ra
apunten
proceso
correspondiente
arreglo
tareas
principio
punto
debería
asignar
memoria
segmentos
datos
pila
hijo
copias
exactas
segmentos
padre
semántica
forkindica
compartir
memoria
padre
hijo
segmento
texto
copiar
com-
lectura
punto
hijo
listo
ejecutarse
requieren
recursos
copiar
memoria
siste-
Linux
modernos
trampa
proporcionan
hijo
tablas
páginas
apunten
páginas
padre
marcándolas
lectura
hijo
escribir
página
recibe
fallo
protección
kernel
ve
asigna
copia
página
hijo
marca
lectura
escritura
forma
copiar
páginas
realmente
vayan
escribir
datos
mecanismo
conoce
copia
escribir
beneficio
adicional
requerir
copias
programa
memoria
ahorra
RAM
proceso
hijo
empieza
ejecutarse
código
ejecuta
copia
shell
realiza
llamada
sistema
execy
proporciona
nombre
comando
parámetro
kernel
busca
verifica
archivo
ejecutable
copia
argumentos
cadenas
entor-
kernel
libera
espacio
direcciones
antiguo
tablas
páginas
crear
llenar
espacio
direcciones
sistema
acepta
archivos
asignación
Linux
sistemas
basados
UNIX
establecen
tablas
pá-
ginas
indicar
páginas
memoria
página
pila
espacio
direcciones
respaldado
archivo
ejecutable
disco
proceso
empiece
ejecutarse
recibirá
inmediato
fallo
página
página
có-
digo
paginará
archivo
ejecutable
forma
cargar
adelanta-
do
programas
iniciar
rapidez
recibir
fallos
páginas
necesitan
estrategia
paginación
demanda
forma
pura
vimos
capítulo
copian
argumentos
cadenas
entorno
pila
restablecen
señales
registros
inicializan
cero
punto
comando
empezar
ejecutarse
figura
10-8
ilustran
pasos
descritos
ejemplo
usuario
escribe
comando
lsen
terminal
shell
crea
proceso
bifurcar
clon
shell
llama
execpara
cubrir
memoria
contenido
archi-
vo
ejecutable
ls
Hilos
Linux
capítulo
analizamos
generalidades
hilos
enfocaremos
hilos
kernel
Linux
enfoque
específico
diferencias
modelo
hilos
Linux
sistemas
UNIX
comprender
capacidades
únicas
ofrece
modelo
Linux
empezaremos
análisis
decisiones
desafiantes
presentes
sis-
temas
multihilo
748
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
749
cuestión
principal
introducir
hilos
mantener
semántica
tradicional
correcta
UNIX
consideremos
fork
Suponga
proceso
hilos
kernel
reali-
za
llamada
sistema
fork
crear
hilos
proceso
mo-
mento
responder
pregunta
forma
afirmativa
Suponga
hilos
bloqueó
leer
teclado
bloquear
hilo
correspondiente
pro-
ceso
leer
teclado
hilo
obtiene
línea
escriba
caso
contrario
hilo
proceso
problema
aplica
cosas
hilos
proceso
hilo
produce
proble-
ma
único
hilo
bloquear
llamar
fork
considere
caso
hilos
crean
proceso
hijo
Suponga
hilos
creados
contiene
mutex
único
hilo
proceso
adquirir
llamada
fork
mutex
liberará
hilo
único
esperará
pro-
blemas
solución
simple
archivos
área
problemática
Suponga
hilo
bloquea
leer
ar-
chivo
hilo
cierra
archivo
realiza
operación
lseekpara
cambiar
apuntador
archivo
actual
ocurre
manejo
señales
cuestiones
espinosas
dirigir
señales
hi-
específico
proceso
general
señal
SIGFPE
excepción
punto
flotante
de-
bería
atrapada
hilo
produjo
pasa
atrapa
eliminar
hilo
hilos
considere
señal
SIGINT
usuario
genera
tecla-
do
hilo
atrapar
señal
compartir
hilos
conjunto
común
más-
caras
señales
general
soluciones
problemas
sh
sh
ls
Código
fork
Código
exec
proceso
proceso
Llamada
fork
Llamada
exec
sh
cubre
ls2
creó
sh
PID
501
PID
748
PID
748
Asigna
estructura
tarea
hijo
Llena
estructura
tarea
hijo
datos
padre
Asigna
pila
área
usuario
hijo
Llena
área
usuario
hijo
datos
padre
Asigna
PID
hijo
Establece
hijo
comparta
texto
padre
Copia
tablas
páginas
datos
pila
Establece
compartición
archivos
abiertos
Copia
registros
padre
hijo
Busca
programa
ejecutable
Verifica
permiso
ejecución
Lee
verifica
encabezado
Copia
argumentos
entorno
kernel
Libera
antiguo
espacio
direcciones
Asigna
espacio
direcciones
Copia
argumentos
entorno
pila
Restablece
señales
Inicializa
registros
Figura
10-8
pasos
ejecutar
comando
ls
escribe
shell
www.FreeLibros.medescomponga
Obtener
semántica
correcta
hilos
mencionar
có-
digo
carece
importancia
Linux
acepta
hilos
kernel
interesante
vale
pena
analizar
im-
plementación
basa
idea
4.4BSD
hilos
kernel
habilitaron
distri-
bución
Berkeley
dinero
reescribir
biblioteca
resolver
problemas
descritos
Históricamente
procesos
contenedores
recursos
hilos
unidades
eje-
cución
proceso
contenía
hilos
compartían
espacio
direcciones
archi-
vos
abiertos
manejadores
señales
alarmas
simple
describió
2000
Linux
introdujo
poderosa
llamada
sistema
clone
disolvió
distinción
procesos
hilos
posiblemente
invirtió
primacía
conceptos
Cloneno
presente
versión
UNIX
Tradicionalmente
creaba
hilo
hilo(s
original(es
compartía(n
registros
especial
descriptores
archivos
abiertos
manejadores
señales
alarmas
propieda-
des
globales
proceso
hilo
llamada
clonehizo
aspectos
fueran
específicos
proceso
hilo
llamada
pid
clone(función
pila_ptr
banderas_compart
arg
llamada
crea
hilo
proceso
actual
proceso
dependiendo
bande-
ras_compart
hilo
proceso
actual
comparte
espacio
direcciones
hilos
existentes
escritura
subsiguiente
byte
espacio
direcciones
rea-
lice
hilo
visible
hilos
proceso
espacio
direcciones
compartido
hilo
obtiene
copia
exacta
espacio
direc-
ciones
subsiguientes
escrituras
realice
hilo
estarán
visibles
hilos
anteriores
semántica
llamada
forkde
POSIX
casos
hilo
empieza
ejecución
función
cuya
llamada
realiza
arg
único
parámetro
casos
hilo
obtiene
pila
priva-
apuntador
pila
inicializa
pila_ptr
parámetro
banderas_compart
mapa
bits
permite
detalle
fino
compar-
tición
sistemas
UNIX
tradicionales
bits
establecer
forma
inde-
pendiente
determina
hilo
copiar
estructura
datos
compartir
hilo
llamada
figura
10-9
muestra
elementos
compartir
copiar
bits
banderas_compart
bit
CLONE_VM
determina
compartir
copiar
memoria
virtual
es-
pacio
direcciones
hilos
anteriores
activado
hilo
pasa
hi-
existentes
llamada
clonecrea
efecto
hilo
proceso
existente
bit
desactivado
hilo
obtiene
espacio
direcciones
privado
signifi-
ca
efecto
instrucciones
STOREno
visible
hilos
existentes
compor-
tamiento
similar
fork
indica
continuación
creación
espacio
direcciones
efecto
definición
proceso
750
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
751
bit
CLONE_FS
controla
compartición
directorios
raíz
trabajo
bande-
ra
umask
bit
activado
hilos
anteriores
comparten
directorios
traba-
jo
hilo
espacio
direcciones
significa
llamada
chdirrealizada
hilo
cambia
directorio
trabajo
hilo
espacio
direcciones
UNIX
llamada
chdirrealizada
hilo
siem-
pre
cambia
directorio
trabajo
hilos
proceso
hilos
proceso
ende
bit
permite
tipo
compartición
versio-
nes
UNIX
tradicionales
bit
CLONE_FILES
análogo
bit
CLONE_FS
activa
hilo
comparte
descriptores
archivos
hilos
anteriores
llamadas
lseekque
realice
hi-
visibles
normalmente
hilos
proceso
hilos
distintos
procesos
similar
CLONE_SIG-
HAND
habilita
deshabilita
compartición
tabla
manejadores
señales
hilos
anteriores
tabla
comparte
hilos
distintos
espacios
direcciones
cambio
manejador
hilo
afecta
manejadores
CLONE_PID
controla
hilo
obtiene
PID
comparte
PID
padre
característica
necesaria
inicio
sistema
procesos
usuario
habilitarla
proceso
padre
bit
CLONE_PARENT
controla
padre
hilo
hilo
llamada
cuyo
caso
hilo
hermano
llamada
hilo
llamada
cuyo
caso
hilo
hijo
llamada
bits
controlan
elementos
pe-
ro
importantes
nivel
detallado
compartición
Linux
mantiene
estructuras
datos
separadas
diversos
elementos
listan
sección
10.3.3
parámetros
pro-
gramación
imagen
memoria
etcétera
estructura
tarea
apunta
estructuras
datos
fácil
crear
estructura
datos
hilo
clonado
apunte
estructuras
datos
programación
memoria
estructuras
hilo
copias
Bandera
Significado
activado
Significado
desactivado
CLONE_VM
Crea
hilo
Crea
proceso
CLONE_FS
Comparte
umask
directorios
raíz
trabajo
comparte
CLONE_FILES
Comparte
descriptores
archivos
Copia
descriptores
archivos
CLONE_SIGHAND
Comparte
tabla
manejadores
señales
Copa
tabla
CLONE_PID
hilo
obtiene
PID
hilo
obtiene
PID
CLONE_PARENT
hilo
padre
padre
hilo
hilo
llamada
llamada
Figura
10-9
Bits
mapa
bits
banderas_compart
www
FreeLibros.me752
CASO
ESTUDIO
LINUX
CAPÍTULO
10
nivel
detallado
compartición
signi-
fica
útil
especial
versiones
UNIX
tradicionales
ofrecen
funciona-
lidad
programa
Linux
aproveche
funcionalidad
portar
UNIX
modelo
hilos
Linux
presenta
dificultad
sistemas
UNIX
asocian
PID
proceso
importar
hilo
compatible
sistemas
UNIX
Linux
diferencia
identificador
proceso
PID
identificador
tarea
TID
campos
almacenan
estructura
tarea
uti-
liza
clonepara
crear
proceso
comparte
creador
PID
establece
valor
caso
contrario
tarea
recibe
TID
hereda
PID
forma
hilos
proceso
recibirán
PID
hilo
proceso
10.3.4
Planificación
Linux
analizar
algoritmo
planificación
Linux
empezar
hilos
Linux
hilos
kernel
planificación
basa
hilos
procesos
Linux
diferencia
clases
hilos
fines
planificación
Planificación
llegar
atendido
FIFO
tiempo
real
Planificación
circular
round-robin
tiempo
real
Tiempo
compartido
hilos
planificación
FIFO
tiempo
real
prioridad
preferentes
ex-
cepto
hilo
FIFO
tiempo
real
recién
preparado
prioridad
hilos
pla-
nificación
circular
tiempo
real
iguales
hilos
planificación
FIFO
tiempo
real
tiempo
asociados
reloj
preferencia
hilos
planificación
circular
tiempo
real
listos
ejecuta
quantum
des-
pués
pasa
lista
hilos
planificación
rotativa
tiempo
real
clases
realidad
tiempo
real
sentido
especificar
tiempos
lí-
mite
garantías
clases
simplemente
prioridad
hilos
cla-
tiempo
compartido
estándar
razón
Linux
llama
tiempo
real
conformidad
estándar
P1003.4
extensiones
tiempo
real
UNIX
utiliza
nombres
hilos
tiempo
real
representan
forma
interna
niveles
prioridad
99
nivel
prioridad
99
menor
prioridad
tiempo
real
hilos
convencionales
tiempo
real
planifican
algoritmo
interior
hilos
tiempo
real
asocian
niveles
prioridad
100
139
Linux
diferencia
interna
140
niveles
prioridad
pa-
ra
tareas
tiempo
real
tiempo
real
hilos
planificación
circular
tiempo
real
Linux
asocia
valores
quantums
tiempo
niveles
prioridad
tiempo
real
quantum
número
pulsos
reloj
duran-
hilo
ejecutarse
versión
actual
Linux
reloj
opera
1000
Hz
pulso
ms
conoce
jiffy
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
753
mayoría
sistemas
UNIX
Linux
asocia
valor
hilo
predeterminado
modificar
utilizamos
llamada
sistema
nice(valor
don-
valor
/H1100220
+19
valor
determina
prioridad
estática
hilo
usuario
calculara
mil
millones
posiciones
decimales
plano
es-
ta
llamada
programa
causar
problemas
usuarios
administrador
sistema
pedir
servicio
normal
valores
/H1100220
/H110021
Dejamos
lector
trabajo
deducir
razón
regla
planificador
Linux
utiliza
estructura
datos
clave
conocida
cola
ejecu-
ción
runqueue
cola
ejecución
asociada
CPU
sistema
mantiene
en-
tre
información
arreglos
activas
expiradas
muestra
figura
10-10
campos
apuntador
arreglo
140
cabezas
listas
corresponde
prioridad
distinta
cabeza
lista
apunta
lista
doblemente
enlazada
procesos
prioridad
específica
operación
básica
planificador
describir
Expiradas
Activas
Banderas
Arreglo[1
Arreglo[0
Prioridad
Prioridad
139
Prioridad
Prioridad
139
Cola
ejecución
CPU
CPU
Static_prio
Figura
10-10
Ilustración
estructura
cola
ejecución
Linux
arreglos
prioridad
planificador
selecciona
tarea
arreglo
activo
prioridad
expira
ranu-
ra
tiempo
quantum
tarea
pasa
lista
tareas
expiradas
nivel
prioridad
distinto
tarea
bloquea
ejemplo
esperar
evento
an-
tes
expire
ranura
tiempo
ocurra
evento
reanudar
ejecu-
ción
coloca
vuelta
arreglo
tareas
activas
ranura
tiempo
disminuye
reflejar
tiempo
CPU
consumió
agote
completo
ranura
www.FreeLibros.metiempo
colocará
arreglo
tareas
expiradas
tareas
nin-
guno
arreglos
tareas
activas
planificador
simplemente
intercambiará
apuntadores
arreglos
tareas
expiradas
conviertan
arreglos
tareas
activas
vice-
versa
método
asegura
tareas
menor
prioridad
sufran
inanición
hilos
planificación
FIFO
tiempo
real
acaparen
CPU
completo
improbable
distintos
niveles
prioridad
asignan
distintos
valores
ranura
tiempo
Li-
nux
asigna
quantums
altos
procesos
prioridad
ejemplo
tareas
ejecutan
nivel
prioridad
100
recibirán
quantums
800
mseg
tareas
nivel
prioridad
139
recibirán
mseg
idea
esquema
sacar
procesos
kernel
rapidez
proceso
leer
archivo
disco
velocidad
reducirá
forma
considerable
espere
llamada
read
dejar
ejecute
justo
complete
petición
llamada
rapidez
ma-
nera
similar
proceso
bloquea
esperar
entrada
teclado
duda
proceso
interac-
tivo
recibir
prioridad
alta
esté
listo
asegurar
procesos
interactivos
obtengan
servicio
sentido
procesos
ligados
CPU
ob-
básicamente
servicio
sobrante
bloquean
procesos
ligados
interactivos
Linux
priori
tarea
ligada
CPU
resto
SO
basa
mantenimiento
continuo
heurísticas
interactividad
for-
ma
Linux
diferencia
prioridad
estática
dinámica
prioridad
dinámica
hilos
volver
calcular
continua
recompensar
hilos
interacti-
vos
castigar
hilos
acaparan
CPU
bono
prioridad
máximo
/H110025
valores
menor
prioridad
corresponden
prioridad
alta
recibe
planificador
cas-
tigo
prioridad
máximo
+5
forma
específica
planificador
mantiene
variable
llamada
sleep_avg
aso-
ciada
tarea
despierta
tarea
variable
incrementa
reemplaza
tarea
expira
quantum
variable
decrementa
base
valor
correspondiente
valor
utiliza
asignar
forma
dinámica
bono
tarea
valo-
res
/H110025
+5
planificador
Linux
vuelve
calcular
nivel
prioridad
medi-
hilo
avanza
lista
tareas
activas
lista
tareas
expiradas
algoritmo
planificación
descrito
sección
refiere
kernel
2.6
introdujo
kernel
2.5
inestable
algoritmos
exhibían
rendimiento
pobre
entornos
multiprocesador
escalaban
aumentaba
número
tareas
des-
cripción
presentamos
párrafos
anteriores
indica
decisión
pla-
nificación
acceso
lista
apropiada
tareas
activas
tiempo
O(1
constante
importar
número
procesos
sistema
planificador
incluye
características
especialmente
útiles
plataformas
mul-
tiprocesador
multinúcleo
lugar
estructura
cola
ejecución
asocia
CPU
plataforma
multiprocesador
planificador
mantener
beneficios
planifica-
ción
afinidad
planificar
tareas
CPU
ejecutaban
lu-
gar
conjunto
llamadas
sistema
disponibles
especificar
modificar
754
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
755
requerimientos
afinidad
hilo
seleccionado
planificador
realiza
balanceo
cargas
periódico
estructuras
cola
ejecución
distintas
CPUs
asegurar
carga
sistema
esté
balanceada
tiempo
cumple
requerimientos
rendi-
miento
afinidad
planificador
tareas
ejecutables
colocadas
estructura
cola
ejecución
apropiada
tareas
ejecutables
espera
ope-
raciones
eventos
kernel
colocan
estructura
datos
conocida
co-
espera
waitqueue
asocia
estructura
cola
espera
evento
tareas
puedan
esperando
cabeza
cola
espera
incluye
apuntador
lista
enlazada
tareas
espera
activa
espera
activa
necesaria
asegurar
estructura
cola
espera
manipular
concurrente
código
principal
kernel
manejadores
interrupciones
invocaciones
asíncronas
código
kernel
contiene
variables
sincronización
ubicaciones
kernels
Linux
tenían
bloqueo
kernel
BLK
resultó
ineficiente
especial
plataformas
multiprocesador
evitaba
procesos
distintas
CPUs
ejecutaran
código
kernel
forma
concurrente
ende
introdujeron
puntos
sincronización
niveles
detalle
finos
10.3.5
Arranque
Linux
detalles
varían
plataforma
general
siguientes
pasos
representan
pro-
ceso
arranque
booteo
inicia
computadora
BIOS
realiza
Auto
prueba
encen-
dido
POST
descubrimiento
inicialización
dispositivos
iniciales
proceso
inicio
SO
requerir
acceso
discos
pantallas
teclados
etcétera
con-
tinuación
lee
sector
disco
inicio
MBR
Master
Boot
Record
Registro
maes-
tro
inicio
coloca
ubicación
memoria
fija
ejecuta
sector
contiene
pequeño
programa
512
bytes
carga
programa
independiente
llamado
boot
dispositivo
inicio
general
disco
IDE
SCSI
programa
boot
copia
dirección
libre
superior
memoria
liberar
inferior
memoria
sistema
operativo
traslada
bootlee
directorio
raíz
dispositivo
inicio
com-
prender
sistema
archivos
formato
directorios
caso
carga-
dores
inicio
GRUB
GRand
Unified
Bootloader
cargador
inicio
unificado
cargadores
inicio
populares
LILO
Intel
basan
sistema
archivos
específico
requieren
mapa
bloques
direcciones
nivel
inferior
descri-
ben
sectores
físicos
cabezas
cilindros
buscar
sectores
relevantes
cargar
boot
lee
kernel
sistema
operativo
coloca
memoria
salta
pun-
to
termina
trabajo
kernel
ejecución
código
inicio
kernel
escrito
lenguaje
ensamblador
dependiente
máquina
trabajo
típico
consiste
establecer
pila
kernel
identificar
tipo
CPU
www.FreeLibros.mecalcular
cantidad
RAM
presente
deshabilitar
interrupciones
habilitar
MMU
últi-
mo
llamar
procedimiento
main
lenguaje
inicie
principal
sistema
ope-
rativo
código
inicialización
considerable
lógica
física
Empieza
asignar
búfer
mensajes
ayudar
depurar
problemas
inicio
me-
dida
procede
inicialización
escriben
mensajes
ocurriendo
ma-
nera
puedan
extraer
falla
inicio
programa
especial
diagnóstico
Considere
grabadora
vuelo
cabina
sistema
operativo
caja
negra
buscan
investigadores
estrella
avión
asignan
estructuras
datos
kernel
mayoría
tamaño
fijo
caché
páginas
estructuras
tablas
páginas
dependen
cantidad
RAM
disponible
punto
sistema
empieza
autoconfiguración
archivos
confi-
guración
indican
tipos
dispositivos
presentes
empieza
son-
dear
dispositivos
presentes
realidad
sondear
dispositivo
responde
agrega
tabla
dispositivos
conectados
responde
asume
au-
sente
ignora
punto
diferencia
versiones
UNIX
tradicionales
drivers
dispositivos
Linux
necesitan
vínculos
estáticos
cargar
forma
dinámica
versiones
MS-DOS
Windows
argumentos
favor
carga
dinámica
drivers
interesantes
vale
pena
mencionarlos
principal
argumento
carga
dinámica
seguridad
opera
sitio
seguro
base
datos
banco
servidor
Web
corporativo
quiera
evitar
alguien
inserte
código
aleatorio
kernel
administrador
sistema
mantener
archivos
código
fuente
código
objeto
sistema
operativo
máquina
segura
construcción
sistema
enviar
binario
kernel
máquinas
red
área
local
drivers
cargar
forma
dinámica
esce-
nario
evita
operadores
máquina
conozcan
contraseña
superusuario
inyecten
código
malicioso
errores
kernel
lugares
extensos
conoce
con-
figuración
hardware
exactamente
hora
compila
vincula
sistema
cambios
raros
volver
vincular
sistema
agregar
dispositivo
hardwa-
re
problema
configurado
hardware
crear
forma
manual
cuidado
proceso
establecer
pila
ejecutarlo
proceso
continúa
inicialización
reali-
za
actividades
programar
reloj
tiempo
real
montar
sistema
archivos
raíz
crear
init
proceso
demonio
paginación
proceso
Init
comprueba
banderas
usuario
multiu-
suario
caso
bifurca
proceso
ejecuta
shell
espera
proceso
ter-
mine
caso
bifurca
proceso
ejecuta
secuencia
comandos
shell
inicialización
sistema
/etc
rc
comprobaciones
consistencia
mon-
tar
sistemas
archivos
adicionales
iniciar
procesos
demonios
etcétera
lee
/etc
ttys
lista
terminales
propiedades
terminal
habilitada
bifurca
copia
realiza
labores
mantenimiento
ejecuta
programa
llamado
getty
756
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.3
PROCESOS
LINUX
757
programa
establece
velocidad
línea
propiedades
línea
módems
ejemplo
escribe
login
pantalla
terminal
leer
nombre
usuario
teclado
alguien
sienta
terminal
proporciona
nombre
inicio
sesión
getty
termina
ejecutar
/bin-
/login
programa
inicio
sesión
login
pide
contraseña
cifra
compara
contraseña
cifrada
almacenada
archivo
contraseñas
/etc
passwd
co-
rrecta
login
reemplaza
shell
usuario
espera
coman-
do
incorrecta
login
pide
nombre
usuario
mecanismo
muestra
figura
10-11
sistema
terminales
Proceso
Proceso
Proceso
Demonio
paginación
Terminal
Terminal
Terminal
Login
Password
cp
f1
f2login
sh
cp
getty
init
Figura
10-11
secuencia
procesos
utilizados
iniciar
sistemas
Linux
figura
proceso
etty
ejecuta
terminal
esperando
entrada
terminal
usuario
escrito
nombre
inicio
sesión
getty
sobrescribió
login
pidiendo
contraseña
terminal
ocurrió
inicio
sesión
exitoso
shell
imprimió
indicador
usuario
escribió
cp
f1
f2
shell
bifurca
proceso
hijo
ejecute
programa
cp
shell
blo-
quea
espera
hijo
termine
momento
escribirá
indicador
esperar
entrada
teclado
usuario
terminal
hubiera
escrito
cc
cp
hubiera
inicia-
do
programa
principal
compilador
hubiera
bifurcado
procesos
ejecutar
diversas
pasadas
compilador
www
FreeLibros.me758
CASO
ESTUDIO
LINUX
CAPÍTULO
10
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
modelo
memoria
Linux
simple
programas
portátiles
im-
plementar
Linux
máquinas
unidades
administración
memoria
tengan
amplias
di-
ferencias
ejemplo
IBM
PC
original
hardware
paginación
sofisticado
área
diseño
cambiado
décadas
funcionado
necesitado
revisión
examinaremos
modelo
forma
implementa
10.4.1
Conceptos
fundamentales
proceso
Linux
espacio
direcciones
consiste
lógicamente
segmen-
tos
texto
datos
pila
figura
10-12(a
muestra
espacio
direcciones
proceso
ejemplo
proceso
A.
segmento
texto
contiene
instrucciones
máquina
for-
man
código
ejecutable
programa
producido
compilador
ensamblador
tradu-
cir
programa
C++
lenguaje
código
máquina
general
segmento
texto
lectura
programas
automodificables
quedaron
estilo
allá
1950
difícil
comprenderlos
depurarlos
segmento
texto
aumenta
disminuye
cambia
forma
Texto
BSS
Datos
Apuntador
pila
Apuntador
pila
20
Memoria
24
BSS
Texto
Datos
SO
Memoria
físicaProceso
Proceso
Figura
10-12
Espacio
direcciones
virtuales
proceso
A.
Memoria
física
Espacio
direcciones
virtuales
proceso
B.
segmento
datos
contiene
almacenamiento
variables
programa
cade-
nas
arreglos
datos
partes
datos
inicializados
datos
inicializar
cuestiones
históricas
tipos
datos
conocen
BSS
conocido
históricamen-
Bloque
iniciado
símbolo
inicializada
segmento
datos
con-
www
FreeLibros.meSECCIÓN
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
759
variables
constantes
compilador
necesitan
valor
inicial
empieza
pro-
grama
variables
BSS
inicializan
cero
cargarlas
ejemplo
declarar
cadena
caracteres
inicializarla
tiem-
po
inicia
programa
espera
cadena
valor
inicial
implementar
construcción
compilador
asigna
cadena
ubicación
espacio
direcciones
asegura
inicie
programa
ubicación
contenga
cadena
apropiada
punto
vista
sistema
operativo
datos
inicializados
distintos
texto
pro-
grama
contienen
patrones
bits
producidos
compilador
cargar
me-
moria
iniciarse
programa
existencia
datos
inicializar
realidad
optimización
variable
global
inicializa
forma
explícita
semántica
lenguaje
indica
valor
inicial
práctica
mayoría
variables
globales
inicializan
explícita
con-
secuencia
implementar
necesita
sección
archivo
binario
ejecuta-
ble
exactamente
número
bytes
datos
inicializan
incluyendo
tengan
valor
predeterminado
ahorrar
espacio
archivo
ejecutable
cabo
archivo
contiene
variables
inicializadas
explícita
texto
programa
variables
inicializar
recopilan
conjunto
inicializadas
compilador
necesita
colocar
palabra
encabezado
indique
cuán-
tos
bytes
asignar
punto
explícito
considere
figura
10-12(a
texto
programa
KB
datos
inicializados
KB
datos
inicializar
BSS
KB
archivo
ejecutable
16
KB
texto
datos
inicializados
encabe-
zado
corto
indica
sistema
asigne
KB
datos
inicializados
asig-
ne
iniciar
programa
truco
evita
almacenar
KB
ceros
archivo
ejecutable
evita
asignación
marco
página
física
lleno
ceros
iniciali-
zación
Linux
asigna
página
cero
estática
página
protegida
escritura
llena
ceros
carga
proceso
región
datos
inicializar
establece
apuntar
página
cero
proceso
intenta
escribir
área
entra
acción
mecanismo
copia
escribir
asigna
marco
página
real
proceso
diferencia
segmento
texto
cambiar
segmento
datos
cam-
biar
programas
modifican
variables
tiempo
programas
necesitan
asignar
espacio
forma
dinámica
ejecución
manejar
Linux
permite
segmento
datos
crezca
reduzca
medida
asigna
desasigna
memoria
lla-
mada
sistema
brk
disponible
permitir
programa
establezca
tamaño
segmen-
to
datos
asignar
memoria
programa
aumentar
tamaño
segmento
datos
procedimiento
malloc
biblioteca
utilizaba
frecuencia
asig-
nar
memoria
intensivo
llamada
sistema
descriptor
espacio
direc-
ciones
proceso
contiene
información
rango
áreas
memoria
asignan
forma
dinámica
proceso
general
conoce
montículo
tercer
segmento
segmento
pila
mayoría
máquinas
empieza
cer-
ca
superior
espacio
direcciones
virtuales
crece
abajo
llegar
www.FreeLibros.meejemplo
plataformas
x86
32
bits
pila
empieza
dirección
0xC0000000
límite
direcciones
virtuales
GB
visible
proceso
usuario
pila
crece
allá
inferior
segmento
pila
produce
fallo
hardware
sistema
ope-
rativo
baja
inferior
segmento
pila
página
programas
administran
explícita
tamaño
segmento
pila
inicia
programa
pila
vacía
contiene
variables
entorno
shell
línea
comandos
escribió
shell
invocarlo
forma
programa
descubrir
argumentos
ejemplo
escribe
comando
cp
orig
dest
ejecuta
programa
cp
cadena
cp
orig
dest
pila
averiguar
nom-
bres
archivos
origen
destino
cadena
representa
arreglo
apuntadores
símbolos
cadena
facilitar
análisis
sintáctico
usuarios
ejecutan
programa
editor
ine-
ficiente
mantener
copias
texto
programa
editor
memoria
tiempo
mayoría
sistemas
Linux
aceptan
segmentos
texto
compartidos
fi-
guras
10-12(a
10-12(c
procesos
segmento
tex-
to
figura
10-12(b
distribución
memoria
física
procesos
comparten
pieza
texto
asignación
realiza
hardware
memoria
virtual
segmentos
datos
pila
comparten
llamada
fork
páginas
modifican
necesita
crecer
espacio
ad-
yacente
problema
páginas
virtuales
adyacentes
tie-
nen
asignar
páginas
físicas
adyacentes
computadoras
hardware
proporciona
espacios
direcciones
separados
instrucciones
datos
característica
disponible
Linux
utilizar
ejemplo
computadora
direcciones
32
bits
característica
disponible
habría
32
bits
espacio
direcciones
instrucciones
32
bits
adicionales
espacio
direccio-
nes
segmentos
datos
pila
puedan
compartir
salto
pasa
direc-
ción
espacio
texto
mientas
movimiento
utiliza
dirección
espacio
datos
característica
duplica
espacio
direcciones
disponible
asignar
memoria
forma
dinámica
procesos
Linux
acceder
datos
archivos
archivos
mapeo
memoria
característica
asignación
archivo
porción
espacio
direcciones
proceso
ma-
nera
leer
escribir
archivo
arreglo
bytes
memoria
asignar
archivo
facilita
acceso
aleatorio
utilizar
llamadas
sistema
ready
write
acceder
bibliotecas
compartidas
asignan
me-
diante
mecanismo
figura
10-13
archivo
asigna
procesos
tiempo
distintas
direcciones
virtuales
ventaja
adicional
asignar
archivo
procesos
asignar
mis-
mo
archivo
tiempo
escrituras
cualquiera
procesos
realicen
archivo
visibles
instantánea
asignar
archivo
reutilizable
760
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
761
descartará
terminen
procesos
mecanismo
provee
alto
ancho
banda
procesos
puedan
compartir
memoria
caso
extremo
procesos
asignar
archivo
cubra
espacio
direcciones
obtie-
ne
forma
compartición
procesos
hilos
separados
espa-
cio
dirección
comparte
hilos
proceso
mantiene
archivos
abiertos
señales
ejemplo
hilos
prác-
tica
tratamos
espacios
direcciones
correspondan
exactamente
10.4.2
Llamadas
sistema
administración
memoria
Linux
POSIX
especifica
llamadas
sistema
administración
memoria
tema
con-
sideraba
dependiente
máquina
estandarizarlo
ocultó
programas
requieren
administración
dinámica
memoria
utilizar
procedimiento
biblioteca
malloc
definido
estándar
ANSI
forma
im-
plementa
malloc
estándar
POSIX
círculos
metodología
conoce
pasar
cubeta
práctica
mayoría
sistemas
Linux
llamadas
sistema
administrar
memoria
comunes
listan
figura
10-14
Brkespecifica
tamaño
segmento
datos
proporcionar
dirección
byte
valor
segmento
datos
caso
contrario
reduce
llamadas
sistema
mmap
munmapcontrolan
archivos
mapeados
memoria
parámetro
mmap(direc
determina
dirección
asigna
archivo
por-
ción
correspondiente
múltiplo
tamaño
página
parámetro
sis-
tema
determina
dirección
devuelve
a.
parámetro
lon
indica
bytes
asignar
múltiplo
tamaño
página
tercer
pa-
rámetro
prot
determina
protección
archivo
asignado
marcar
lectura
Texto
BSS
Datos
Texto
Apuntador
pila
Apuntador
pila
20
24
SO
Memoria
física
Archivo
mapeado
Archivo
mapeado
Proceso
Proceso
BSS
Datos
Memoria
Figura
10-13
procesos
compartir
archivo
asignado
www.FreeLibros.meescritura
ejecutable
combinación
permisos
cuarto
parámetro
banderas
con-
trola
archivo
privado
compartir
direc
requerimiento
suge-
rencia
quinto
parámetro
fd
descriptor
archivo
asignar
asignar
archivos
abiertos
asignar
archivo
abrirlo
últi-
mo
despl
indica
archivo
iniciar
asignación
necesario
empezar
asignación
byte
bastará
límite
página
llamada
unmap
elimina
archivo
asignado
desasigna
porción
ar-
chivo
resto
permanece
asignado
10.4.3
Implementación
administración
memoria
Linux
proceso
Linux
máquina
32
bits
obtiene
general
GB
espacio
direccio-
nes
virtuales
GB
restante
reserva
tablas
páginas
datos
kernel
gigabyte
kernel
visible
proceso
ejecuta
usuario
vuelve
accesible
proceso
atrapa
kernel
general
memoria
kernel
reside
memoria
física
inferior
asigna
gigabyte
superior
espacio
direcciones
virtua-
proceso
direcciones
0xC0000000
0xFFFFFFFF
GB
espacio
direcciones
crea
momento
crear
proceso
sobrescribe
llamada
sistema
exec
permitir
procesos
compartan
memoria
física
subyacente
Linux
moni-
torea
memoria
física
asigna
memoria
requieran
procesos
usuario
componentes
kernel
asigna
forma
dinámica
porciones
memoria
física
es-
pacio
direcciones
distintos
procesos
saca
mete
memoria
archivos
ejecutables
programa
archivos
información
necesario
utilizar
eficiencia
recursos
plataforma
asegurar
progreso
ejecución
resto
capítulo
analizaremos
implementación
mecanismos
kernel
Linux
res-
ponsables
operaciones
Administración
memoria
física
limitaciones
idiosincrásicas
hardware
sistemas
memoria
fí-
sica
tratar
forma
especial
memoria
virtual
Li-
nux
trabaja
zonas
memoria
762
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Llamada
sistema
Descripción
brk(direc
Cambia
tamaño
segmento
datos
mmap(direc
lon
prot
banderas
fd
despl
Asigna
archivo
unmap(direc
lon
Desasigna
archivo
Figura
10-14
llamadas
sistema
relacionadas
administración
memoria
código
retorno
/H110021
ocurrió
error
ay
direc
direcciones
memoria
lon
longitud
prot
controla
protección
banderas
bits
misce-
láneos
fd
descriptor
archivos
despl
desplazamiento
archivo
www
FreeLibros.meSECCIÓN
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
763
ZONE_DMA
páginas
utilizar
operaciones
DMA
ZONE_NORMAL
páginas
normales
asignan
usual
ZONE_HIGHMEM
páginas
direcciones
memoria
superior
asignan
permanente
límites
exactos
distribución
zonas
memoria
dependen
arquitectura
hardware
x86
dispositivos
operaciones
DMA
16
MB
espacio
direcciones
ZONE_DMA
rango
16
MB
hardware
asignar
forma
directa
direcciones
memoria
896
MB
ZONE_HIGHMEM
marca
ZONE_NORMAL
ubicación
zonas
anteriores
plataformas
x86
prime-
ros
896
MB
espacio
direcciones
Linux
asignan
forma
directa
128
MB
restantes
espacio
direcciones
kernel
utilizan
acceder
regiones
memoria
superior
kernel
mantiene
estructura
zona
zonas
pue-
asignaciones
memoria
zonas
separado
memoria
principal
Linux
consiste
partes
primeras
partes
kernel
mapa
memoria
re
sidentes
fijadas
memoria
paginan
és-
ta
residentes
resto
memoria
divide
marcos
página
contener
página
texto
datos
pila
página
tabla
páginas
lista
libre
kernel
mantiene
mapa
memoria
principal
contiene
información
so-
bre
memoria
física
sistema
zonas
marcos
página
libres
etcéte-
ra
información
ilustra
figura
10-15
organiza
lugar
Linux
mantiene
arreglo
descriptores
páginas
tipo
página
marco
página
física
sistema
conocido
mem_map
descriptor
página
contiene
apuntador
espacio
direcciones
pertenece
caso
página
esté
libre
par
apuntadores
permitan
formar
listas
doblemente
enlazadas
descrip-
tores
ejemplo
mantener
juntos
marcos
página
libres
campos
figura
10-15
descriptor
página
150
contiene
asignación
espacio
di-
recciones
pertenece
página
páginas
70
80
200
libres
enlazadas
tamaño
descriptor
página
32
bytes
mem_mapcompleto
consumir
me-
1%
memoria
física
marco
página
KB
memoria
física
divide
zonas
Linux
mantiene
descriptor
zona
descriptor
zona
contiene
información
memoria
ca-
zona
número
páginas
activas
inactivas
marcas
agua
superior
inferior
utilizar
algoritmo
reemplazo
página
veremos
capítulo
mu-
chos
campos
descriptor
zona
contiene
arreglo
áreas
libres
i-ésimo
elemento
arreglo
identifica
descriptor
página
bloque
páginas
libres
bloques
2i
páginas
libres
Linux
utiliza
par
apuntadores
descriptores
pá-
gina
elemento
pagepara
enlazarlos
información
utiliza
operaciones
asignación
memoria
Linux
proporciona
figura
10-15
muestra
area_libre[o
www.FreeLibros.meidentifica
áreas
libres
memoria
principal
consistan
marco
página
20
apunta
página
70
áreas
libres
llegar
bloques
libres
tamaño
enlaces
descriptores
página
Linux
portar
arquitecturas
NUMA
distintas
direc-
ciones
memoria
distintos
tiempos
acceso
diferenciar
memoria
física
distintos
nodos
evitar
asignar
estructuras
datos
nodos
utiliza
descriptor
nodo
descriptor
nodo
contiene
información
memoria
zonas
nodo
específico
plataformas
UMA
Linux
describe
memoria
descriptor
nodo
bits
descriptor
página
utilizan
identificar
nodo
zona
pertenece
marco
página
mecanismo
paginación
eficiente
arquitecturas
32
64
bits
Linux
utiliza
esquema
paginación
niveles
Linux
2.6.10
expandió
esque-
ma
paginación
niveles
utilizó
originalmente
sistema
Alpha
ver-
sión
2.6.11
utiliza
esquema
paginación
niveles
dirección
virtual
divide
campos
muestra
figura
10-16
campos
directorio
utilizan
índice
directorio
página
apropiado
privado
proceso
va-
764
CASO
ESTUDIO
LINUX
CAPÍTULO
10
zonas_nodos[3
nodo_mem_map
id_nodo
ZONE_HIGHMEM
ZONE_NORMAL
ZONE_DMA
Paginas_libres
Paginas_inf
Paginas_sup
area_libre[0
area_libre[1
area_libre[10
lista_activas
lista_inactivas
nombre
node
descriptor
descriptor
zona
Mem_map
arreglo
descriptores
páginas
Memoria
física
70
80
150
200
200
página
libre
150
mapeada
80
página
libre
70
página
libre
~~~~
~~~~
~~~~
~~
~~
Asignación
espacio_direcciones
Figura
10-15
Representación
memoria
principal
Linux
www
FreeLibros.meSECCIÓN
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
765
lor
contiene
apuntador
directorios
nivel
indexan
nue-
vo
campo
dirección
virtual
entrada
seleccionada
directorio
pági-
na
intermedia
apunta
tabla
páginas
indexa
campo
página
dirección
virtual
entrada
apunta
página
requerida
Pentium
utiliza
paginación
niveles
directorios
superior
intermedio
página
entrada
entrada
directorio
global
selecciona
efectividad
tabla
pá-
ginas
utilizar
similar
utilizar
paginación
niveles
cuan-
do
necesario
establece
tamaño
campo
directorio
página
superior
cero
Directorio
global
Directorio
superior
Directorio
intermedio
Página
Desplazamiento
Página
Tabla
páginas
Directorio
intermedio
página
Directorio
superior
página
Directorio
global
página
Dirección
virtual
Figura
10-16
Linux
utiliza
tablas
páginas
niveles
memoria
física
utiliza
fines
kernel
fijo
totalidad
pagina
memoria
resto
memoria
disponible
pá-
ginas
usuario
caché
paginación
fines
caché
páginas
guarda
páginas
contienen
bloques
archivos
leyeron
recientemente
leyeron
adelantado
expectativa
utilizarlos
futuro
cercano
guarda
páginas
bloques
archivos
necesitan
escribir
disco
crearon
procesos
usuario
intercambiaron
memoria
disco
tamaño
dinámico
compite
reserva
páginas
procesos
usuario
caché
paginación
realidad
caché
separada
conjunto
páginas
usuario
necesarias
esperando
sistema
pagine
memoria
página
caché
pá-
ginas
reutiliza
sacarla
memoria
reclamar
rapidez
Linux
acepta
módulos
cargan
forma
dinámica
mayoría
drivers
dispositivos
tamaño
arbitrario
asignar
pieza
contigua
memoria
kernel
consecuencia
directa
requerimientos
Linux
www.FreeLibros.meadministra
memoria
física
forma
adquirir
pieza
memoria
tamaño
arbitrario
desee
algoritmo
utiliza
conoce
algoritmo
colegas
buddy
algorithm
analizaremos
continuación
Mecanismos
asignación
memoria
Linux
proporciona
mecanismos
asignar
memoria
mecanismo
principal
asig-
nar
marcos
páginas
memoria
física
asignador
páginas
opera
median-
conocido
algoritmo
colegas
idea
básica
administrar
trozo
memoria
principio
memo-
ria
cosiste
pieza
contigua
64
páginas
ejemplo
simple
figura
10-17(a
llega
petición
memoria
redondea
potencia
ejemplo
páginas
trozo
memoria
completo
divide
mitad
muestra
Co-
mo
piezas
pieza
inferior
divide
mitad
vuelve
dividir
trozo
tamaño
correcto
asigna
proceso
llamada
muestra
sombreado
766
CASO
ESTUDIO
LINUX
CAPÍTULO
10
64
32
32
32
16
16
32
32
32
32
16
44
32
16
16
32
Figura
10-17
Operación
algoritmo
colegas
suponga
llega
petición
páginas
satisfacer
ma-
nera
directa
punto
llega
petición
páginas
trozo
pequeño
disponible
divide
reclama
mitad
libera
trozos
páginas
libera
trozo
páginas
trozos
páginas
adyacentes
acaban
liberar
provienen
trozo
16
páginas
com-
binan
obtener
vuelta
trozo
16
páginas
Linux
utiliza
algoritmo
colegas
administrar
memoria
característica
adicio-
nal
arreglo
elemento
cabeza
lista
bloques
unidad
tamaño
elemento
cabeza
lista
bloques
unidades
tama-
ño
elemento
apunta
bloques
unidades
sucesivo
forma
encontrar
rapidez
bloque
potencia
algoritmo
produce
fragmentación
interna
considerable
desea
trozo
65
páginas
pedirlo
obtiene
trozo
128
páginas
www
FreeLibros.meSECCIÓN
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
767
solucionar
problema
Linux
mecanismo
asignar
memoria
asignador
losas
slab
allocator
toma
trozos
algoritmo
colegas
crea
losas
unidades
pequeñas
administra
unidades
pequeñas
separado
kernel
crea
destruye
frecuencia
objetos
tipo
ejemplo
task_struct
basa
conoce
cachés
objetos
cachés
consisten
apuntadores
losas
almacenar
objetos
tipo
losas
es-
tar
llena
parcialmente
llena
vacía
ejemplo
kernel
necesita
asignar
descriptor
proceso
nue-
task_struct
busca
estructuras
tarea
caché
objetos
encontrar
lo-
sa
parcialmente
llena
asignarle
objeto
task_struct
disponible
busca
lista
losas
vacías
necesario
asigna
losa
coloca
estructu-
ra
tarea
enlaza
caché
objetos
estructura
tarea
servicio
kernel
kmalloc
asigna
regiones
memoria
contigua
física
espacio
direcciones
kernel
construye
interfaz
losa
caché
objetos
descrita
tercer
asignador
memoria
disponible
conocido
vmalloc
utiliza
memoria
solicitada
necesita
contigua
espacio
virtual
me-
moria
física
práctica
aplica
mayoría
memoria
solicita
excepción
dispositivos
viven
extremo
bus
memoria
unidad
administra-
ción
memoria
entienden
direcciones
virtuales
vma-
llocproduce
degradación
rendimiento
utiliza
principalmente
asignar
cantidades
espacio
direcciones
virtuales
contiguas
insertar
módulos
kernel
forma
dinámica
asignadores
memoria
derivan
utilizan
System
Representación
espacio
direcciones
virtuales
espacio
direcciones
virtuales
divide
áreas
regiones
homogéneas
contiguas
alinea-
das
páginas
área
consiste
serie
páginas
consecutivas
propiedades
protección
paginación
segmento
texto
archivos
asignados
ejem-
plos
áreas
vea
figura
10-15
hoyos
espacio
direcciones
virtuales
áreas
referencia
memoria
hoyo
produce
fallo
página
fatal
tamaño
página
fijo
ejemplo
KB
Pentium
KB
Alpha
Empezando
Pen-
tium
acepta
marcos
página
MB
Linux
aceptar
marcos
página
jumbo
MB
PAE
Physical
Address
Extension
Extensión
Dirección
Física
utiliza
arquitecturas
32
bits
incrementar
espacio
direcciones
pro-
ceso
allá
GB
admiten
tamaños
página
MB
área
describe
kernel
entrada
vm_area_struct
entradas
vm_area_struct
proceso
enlazan
lista
ordenada
dirección
virtual
puedan
encontrar
páginas
lista
32
entradas
crea
árbol
agilizar
búsqueda
entrada
vm_area_struct
lista
pro-
piedades
área
propiedades
incluyen
protección
ejemplo
lectura
www.FreeLibros.melectura/escritura
fijada
memoria
paginar
dirección
aumenta
tamaño
segmentos
datos
abajo
pilas
entrada
vm_area_struct
registra
área
privada
proceso
com-
procesos
llamada
fork
Linux
crea
copia
lista
áreas
proceso
hijo
establece
hijo
padre
apunten
ta-
blas
páginas
áreas
marcan
lectura
escritura
páginas
marcan
lectura
proceso
escribir
página
produce
fallo
protección
kernel
ve
escribir
lógica
área
página
otorga
proceso
copia
página
lectura
escritura
mecanismo
forma
implementa
copia
escribir
entrada
vm_area_structtambién
registra
área
asignado
almacenamiento
res-
paldo
disco
ubicación
segmentos
texto
utilizan
archivo
bi-
nario
ejecutable
almacenamiento
respaldo
archivos
asignación
memoria
utilizan
archivo
disco
almacenamiento
respaldo
áreas
pila
tie-
nen
asignado
almacenamiento
respaldo
paginarlas
memoria
descriptor
memoria
nivel
superior
conocido
mm_struct
recopila
información
áreas
memoria
virtual
pertenecen
espacio
direcciones
in-
formación
distintos
segmentos
texto
datos
pila
usuarios
comparten
espacio
direcciones
etcétera
acceder
elementos
vm_area_struct
es-
pacio
direcciones
descriptor
memoria
formas
método
organizan
listas
enlazadas
ordenadas
direcciones
memoria
virtual
método
útil
requiere
acceso
áreas
memoria
virtual
kernel
busca
asignar
región
memoria
virtual
tamaño
específico
entradas
vm_area_struct
or-
ganizan
árbol
binario
tipo
rojo-negro
estructura
datos
optimizada
búsquedas
rápidas
método
utiliza
acceder
memoria
virtual
específica
permi-
tir
acceso
elementos
espacio
direcciones
proceso
méto-
Linux
utiliza
proceso
permite
distintas
operaciones
kernel
utilicen
método
acceso
eficiente
tarea
10.4.4
paginación
Linux
sistemas
UNIX
dependían
proceso
intercambiador
swapper
process
desplazar
procesos
completos
memoria
disco
procesos
activos
po-
dían
caber
memoria
física
versiones
modernas
UNIX
Linux
desplaza
procesos
completos
unidad
administración
memoria
principal
página
componentes
administración
memoria
operan
nivel
página
subsiste-
ma
intercambio
opera
nivel
página
acoplado
Algoritmo
re-
clamación
marcos
página
analizaremos
sección
idea
básica
paginación
Linux
simple
proceso
necesita
com-
pletamente
memoria
ejecutarse
realidad
requiere
estructura
usuario
tablas
páginas
elementos
intercambian
memoria
proceso
memoria
programar
ejecución
páginas
segmen-
tos
texto
datos
pila
llevan
memoria
forma
dinámica
medida
768
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.4
ADMINISTRACIÓN
MEMORIA
LINUX
769
referencia
estructura
usuario
tabla
páginas
memoria
pro-
ceso
ejecutar
intercambiador
lleve
memoria
paginación
implementa
kernel
nue-
vo
proceso
conocido
demonio
paginación
demonio
proceso
proceso
proceso
inactivo
tradicionalmente
conoce
intercambiador
proceso
init
muestra
figura
10-11
demonios
demonio
pagina-
ción
ejecuta
forma
periódica
despierto
busca
alrededores
traba-
jo
ve
número
páginas
lista
páginas
memoria
libres
empieza
liberar
páginas
Linux
sistema
paginación
demanda
paginación
previa
concepto
conjun-
to
trabajo
llamada
sistema
usuario
sugerir
re-
quiera
página
esperando
esté
necesite
segmentos
texto
archivos
asignados
paginan
respectivos
archivos
disco
pagina
par-
tición
paginación
presente
archivos
paginación
longitud
fija
conoci-
do
área
intercambio
archivos
paginación
agregar
eliminar
forma
dinámica
prioridad
paginación
partición
separada
accede
dispositivo
puro
eficiente
paginación
archivo
razones
lugar
asignación
bloques
archivo
bloques
disco
necesaria
ahorra
opera-
ciones
disco
leer
bloques
indirectos
lugar
escrituras
físicas
tamaño
tamaño
bloque
archivo
tercer
lugar
página
escribe
forma
contigua
disco
archivo
paginación
haga
páginas
asignan
dispositivo
partición
paginación
necesi-
ten
dispositivo
archivo
inicia
mapa
bits
indica
páginas
libres
saca
memoria
página
almacenamiento
respaldo
selecciona
parti-
ción
archivo
paginación
prioridad
espacio
asigna
página
general
partición
paginación
presente
prioridad
archivo
paginación
tabla
páginas
actualiza
reflejar
página
pre-
sente
memoria
ejemplo
activa
bit
página
presente
escribe
ubicación
disco
entrada
tablas
páginas
algoritmo
reemplazo
página
reemplazo
páginas
funciona
Linux
mantener
páginas
libres
puedan
reclamar
necesario
reserva
reponerse
forma
continua
PFRA
Page
Frame
Reclaiming
Algorithm
Algoritmo
reclama-
ción
marcos
página
utiliza
trabajo
Linux
distinción
tipos
distintos
páginas
reclama-
ble
intercambiable
sincronizable
descartable
páginas
reclamables
páginas
re-
servadas
bloqueadas
pilas
kernel
páginas
similares
paginar
memoria
páginas
intercambiables
escribir
vuelta
área
intercambio
partición
disco
paginación
reclamar
página
páginas
sincronizables
de-
ben
escribir
vuelta
disco
marcaron
sucias
páginas
descartables
reclamar
inmediato
www
FreeLibros.meEn
tiempo
inicio
init
inicia
demonio
paginación
kswapd
nodo
memo-
ria
configura
ejecuten
forma
periódica
despierta
kswapd
com-
prueba
suficientes
páginas
libres
disponibles
compara
marcas
agua
inferior
superior
memoria
actual
zona
memoria
suficiente
me-
moria
regresa
inactivo
despertar
requieren
pá-
ginas
memoria
disponible
cualquiera
zonas
reduce
umbral
kswapd
inicia
algoritmo
reclamación
marcos
página
ejecución
reclama
número
páginas
objetivo
general
32
número
limita
con-
trolar
presión
número
escrituras
disco
crearon
operaciones
PFRA
número
páginas
reclamadas
número
páginas
exploradas
parámetros
configurar
ejecuta
PFRA
reclamar
páginas
sencillas
in-
tenta
difíciles
páginas
descartables
referenciadas
reclamar
inmediato
desplazarlas
lista
páginas
libres
zona
busca
páginas
alma-
cenamiento
respaldo
hayan
referenciado
recientemente
algorit-
mo
parecido
reloj
buscan
páginas
compartidas
usuarios
parezca
utilizado
desafío
páginas
compartidas
reclama
entrada
página
actualizar
forma
síncrona
tablas
páginas
es-
pacios
direcciones
compartían
originalmente
página
Linux
mantiene
estructuras
da-
tos
eficientes
tipo
árbol
encontrar
fácilmente
usuarios
página
compartida
continuación
buscan
páginas
usuario
ordinarias
sacar
memoria
de-
be
programar
escritura
área
intercambio
capacidad
intercambio
sistema
proporción
páginas
almacenamiento
respaldo
comparadas
páginas
necesitan
intercambiarse
seleccionaron
FPRA
parámetro
algoritmo
ajustar
página
inválida
memoria
compartida
bloqueada
memoria
usando
DMA
omite
PFRA
utiliza
algoritmo
tipo
reloj
seleccionar
páginas
antiguas
sa-
car
memoria
categoría
núcleo
algoritmo
ciclo
ex-
plora
listas
páginas
activas
inactivas
zona
tratando
reclamar
distintos
tipos
páginas
distintas
urgencias
valor
urgencia
pasa
parámetro
indicar
pro-
cedimiento
esfuerzo
emplear
reclamar
páginas
general
signi-
fica
páginas
inspeccionar
rendirse
PFRA
páginas
desplazan
listas
páginas
activas
inactivas
forma
descrita
figura
10-18
mantener
heurística
tratar
encontrar
páginas
referencia
improbable
requieran
futuro
cercano
PFRA
mantiene
banderas
página
activa
inactiva
referenciada
referenciada
banderas
codifican
muestra
figura
10-18
explora-
ción
conjunto
páginas
PFRA
borra
bits
referencia
exploración
página
determina
referencia
avanza
probable
reclamen
caso
contrario
página
mueve
probable
saquen
memoria
páginas
estén
lista
inactivas
referencia
inspeccionaron
mejores
candidatas
sacar
memoria
pági-
770
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.5
ENTRADA
SALIDA
LINUX
771
nas
PG_active
PG_referenced
cero
figura
10-18
obstante
ne-
cesario
páginas
reclamar
encuentren
esta-
flechas
rellenar
figura
10-18
ilustran
Inactivas
Usadas
Usadas
UsadasTiempo
agotado
Tiempo
agotado
Rellenar
Rellenar
RellenarPG_active
PG_referenced
PG_active
PG_referenced
PG_active
PG_referenced
PG_active
PG_referenced
Activas
Figura
10-18
página
considerados
algoritmo
reemplazo
marcos
página
razón
PFRA
mantiene
páginas
lista
inactivas
pudiera
he-
cho
referencia
evitar
situaciones
Considere
proceso
accede
forma
periódica
distintas
páginas
periodo
hora
página
accedido
ciclo
activada
bandera
referencia
necesitará
hora
razón
considerarla
candidata
reclamación
aspecto
sistema
administración
memoria
mencionado
se-
gundo
demonio
llamado
pdflush
realidad
conjunto
hilos
demonios
plano
hilos
pdflush
despiertan
forma
periódica
general
500
mseg
es-
cribir
vuelta
disco
páginas
sucias
antiguas
despiertan
explícita
kernel
niveles
memoria
disponible
umbral
pa-
ra
escribir
vuelta
páginas
sucias
caché
páginas
disco
laptop
conservar
vida
baterías
páginas
sucias
escriben
disco
hilos
pdflush
despiertan
páginas
sucias
escribir
disco
pe-
ticiones
explícitas
sincronización
llamadas
sistema
sync
orfsync
fda-
tasync
versiones
anteriores
Linux
utilizaban
demonios
separados
kupdate
escribir
vuelta
páginas
antiguas
bdflush
escribir
vuelta
páginas
condiciones
po-
ca
memoria
kernel
2.4
funcionalidad
integró
hilos
pdflush
eligieron
hilos
múltiples
ocultar
extensas
latencias
disco
10.5
ENTRADA
SALIDA
LINUX
sistema
Linux
simple
similar
versiones
UNIX
Esencial-
mente
dispositivos
archivos
utilizar
www.FreeLibros.mellamadas
sistema
ready
writeque
utilizan
acceder
archivos
ordinarios
al-
gunos
casos
necesario
establecer
parámetros
dispositivos
llamada
sistema
especial
siguientes
secciones
analizaremos
cuestiones
10.5.1
Conceptos
fundamentales
computadoras
ejecutan
Linux
dispositivos
dis-
cos
impresoras
redes
conectados
requiere
forma
permitir
programas
accedan
dispositivos
soluciones
posibles
utiliza
Linux
integrar
dispositivos
sistema
archivos
conoce
archivos
especiales
dispositivo
asigna
nombre
ruta
general
/dev
ejemplo
disco
po-
dría
/dev
hd1
impresora
/dev
lp
red
/dev
net
archivos
especiales
utilizar
forma
archivo
requieren
comandos
llamadas
sistema
especiales
Basta
utilizar
llamadas
sistema
usuales
open
ready
write
ejemplo
comando
cp
archivo
/dev
lp
copia
archivo
impresora
imprima
suponiendo
usuario
per-
miso
acceder
/dev
lp
programas
abrir
leer
escribir
archivos
especia-
forma
archivos
regulares
cp
ejemplo
siquiera
imprimiendo
forma
requiere
mecanismo
especial
operaciones
S.
archivos
especiales
dividen
categorías
bloques
caracteres
archivo
especial
bloques
consiste
secuencia
bloques
enumerados
propiedad
clave
ar-
chivo
especial
bloques
direccionar
utilizar
bloque
separado
palabras
programa
abrir
archivo
especial
bloques
leer
ejemplo
bloque
124
leer
bloques
123
general
archivos
especiales
bloques
utilizan
discos
archivos
especiales
caracteres
utilizan
común
dispositivos
reciben
envían
flujo
caracteres
teclados
impresoras
redes
ratones
plotters
mayoría
dispositivos
aceptan
producen
datos
personas
utilizan
archivos
especiales
caracteres
sentido
buscar
bloque
124
ratón
archivo
especial
asocia
driver
dispositivo
encarga
manejar
dis-
positivo
correspondiente
driver
conoce
número
dispositivo
sirve
identificarlo
driver
acepta
dispositivos
ejemplo
discos
mis-
mo
tipo
disco
número
dispositivo
menor
identifica
conjunto
nú-
meros
dispositivo
menor
especifican
dispositivos
forma
única
casos
driver
maneja
dispositivos
relacionados
ejemplo
driver
corresponde
/dev
tty
controla
teclado
pantalla
dispositivo
terminal
acceder
forma
aleatoria
mayoría
archivos
especiales
ca-
racteres
requiere
controlarlos
formas
requieren
archivos
especia-
bloques
ejemplo
considere
entrada
escribe
teclado
muestra
772
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.5
ENTRADA
SALIDA
LINUX
773
pantalla
usuario
comete
error
teclado
desea
borrar
carácter
escri-
bió
oprime
tecla
personas
prefieren
tecla
retroceso
prefieren
SUPR
similar
borrar
línea
acaba
escribir
convencio-
nes
tradición
utilizaba
popularidad
correo
electrónico
utiliza
den-
tro
direcciones
sistemas
adoptado
CTRL-U
carácter
forma
interrumpir
programa
ejecución
oprimir
tecla
especial
distintas
personas
distintas
preferencias
CTRL-C
opción
común
universal
seleccionar
opción
obligar
utilicen
Linux
permite
usuario
personalizar
funciones
general
proporciona
llamada
sis-
tema
especial
establecer
opciones
llamada
sistema
permite
expandir
tabulador
habilitar
deshabilitar
eco
caracteres
conversión
retorno
carro
avance
página
cosas
similares
llamada
sistema
permite
ar-
chivos
regulares
archivos
especiales
bloque
10.5.2
Redes
redes
ejemplo
Berkeley
UNIX
promover
des-
pués
Linux
siguió
convención
pie
letra
concepto
clave
diseño
Berkeley
socket
sockets
análogos
bandejas
correo
conectores
pared
teléfonos
actúan
interfaz
usuarios
red
forma
bandejas
correo
actúan
interfaz
personas
sistema
postal
conectores
pared
teléfono
permiten
enchufar
teléfonos
conectarse
sistema
telefónico
posición
sockets
muestra
figura
10-19
Espacio
usuario
Espacio
kernel
Proceso
receptorProceso
emisor
Socket
Conexión
Red
Figura
10-19
usos
sockets
redes
sockets
crear
destruir
forma
dinámica
crear
socket
devuelve
descriptor
archivo
requiere
establecer
conexión
leer
datos
escribir
datos
liberar
conexión
socket
admite
tipo
particular
red
especifica
momento
crear
soc-
ket
tipos
comunes
www
FreeLibros.me1
Flujo
bytes
confiable
orientado
conexión
Flujo
paquetes
confiable
orientado
conexión
Transmisión
paquetes
desconfiable
tipo
socket
permite
procesos
distintas
máquinas
establezcan
equivalen-
canalización
ente
bytes
meten
extremo
salen
orden
extremo
sistema
garantiza
lleguen
bytes
enviados
orden
enviaron
tipo
similar
preserva
límites
paquetes
emisor
realiza
llamadas
separadas
write
512
bytes
receptor
pide
2560
by-
tes
socket
tipo
devolverán
2560
sockets
tiempo
socket
ti-
po
devolverán
512
bytes
requieren
llamadas
obtener
resto
tercer
tipo
socket
utiliza
acceso
usuario
red
cruda
tipo
especialmente
útil
pa-
ra
aplicaciones
tiempo
real
situaciones
usuario
desea
implementar
esquema
manejo
errores
especializado
red
perder
paquetes
cambiar
orden
garantías
casos
ventaja
rendimiento
importante
confiabilidad
ejemplo
en-
trega
contenido
multimedia
importante
velocidad
integridad
crea
socket
parámetros
especifica
protocolo
utili-
zar
flujos
bytes
confiables
protocolo
popular
TCP
Transmission
Control
Protocol
Protocolo
control
transmisión
transmisión
confiable
orientada
pa-
quetes
opción
común
UDP
User
Datagram
Protocol
Protocolo
datagramas
usuario
protocolos
nivel
IP
Internet
Protocol
Protocolo
Internet
To-
protocolos
originaron
red
ARPANET
Departamento
Defensa
EE.UU.
forman
base
Internet
protocolo
común
flujos
paque-
tes
confiables
socket
trabajar
red
enlazarlo
dirección
És-
ta
dominios
nombramiento
dominio
común
dominio
nombramiento
Internet
utiliza
enteros
32
bits
nombrar
puntos
extremos
versión
enteros
128
bits
versión
versión
sistema
experimental
nun-
ca
ligas
mayores
crean
sockets
computadoras
origen
destino
estable-
cer
conexión
comunicación
orientada
conexión
partes
realiza
llamada
sistema
listenen
socket
local
crea
búfer
bloquea
lleguen
datos
realiza
llamada
sistema
connecty
proporciona
pará-
metros
descriptor
archivo
socket
local
dirección
socket
remoto
remota
acepta
llamada
sistema
establece
conexión
sockets
establecida
conexión
funciona
análoga
tubería
proceso
leer
escribir
datos
descriptor
archivo
socket
local
requiere
conexión
cerrar
forma
usual
llamada
sistema
close
774
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.5
ENTRADA
SALIDA
LINUX
775
10.5.3
Llamadas
sistema
Entrada
Salida
Linux
general
dispositivo
sistema
Linux
asociado
archivo
especial
mayoría
operaciones
archivo
apropiado
eliminan-
do
necesidad
llamadas
especiales
sistema
necesidad
específico
dispositivo
POSIX
mayoría
sistemas
UNIX
te-
nían
llamada
sistema
ioctlque
realizaba
variedad
acciones
específicas
dispositivo
archivos
especiales
años
resultado
desastre
POSIX
solucionó
dividir
funciones
llamadas
funciones
separadas
principalmente
dis-
positivos
terminal
Linux
sistemas
UNIX
modernos
depende
implementación
acciones
llamada
sistema
separada
comparten
llamada
sistema
forma
primeras
llamadas
listan
figura
10-20
utilizan
establecer
obte-
ner
velocidad
terminal
proporcionan
distintas
llamadas
entrada
salida
módems
operan
velocidad
dividida
ejemplo
antiguos
sistemas
videotex
permitían
personas
acceso
bases
datos
públicas
peticiones
cortas
hogar
ser-
vidor
75
bits
seg
peticiones
regresaban
1200
bits
seg
estándar
adoptó
épo-
ca
costoso
1200
bits
seg
conexión
hogar
tiempos
cambian
mundo
redes
asimetría
persiste
compañías
telefó-
nicas
ofrecen
servicio
recepción
Mbps
servicio
envío
512
kbps
nombre
ADSL
Asymmetric
Digital
Suscriber
Line
Línea
suscriptor
digital
asimétrica
Llamada
función
Descripción
cfsetospeed(&termios
velocidad
Establece
velocidad
salida
cfsetispeed(&termios
velocidad
Establece
velocidad
entrada
cfgetospeed(&termios
velocidad
Obtiene
velocidad
salida
cfgtetispeed(&termios
velocidad
Obtiene
velocidad
entrada
tcsetattr(fd
opc
termios
Establece
atributos
tcgetattr(fd
termios
Obtiene
atributos
Figura
10-20
principales
llamadas
POSIX
administrar
terminal
llamadas
lista
establecer
leer
vuelta
caracteres
es-
peciales
utilizan
borrar
caracteres
líneas
interrumpir
procesos
etcétera
ha-
bilitan
deshabilitan
eco
manejan
flujo
control
funciones
relacionadas
llamadas
funciones
adicionales
especializadas
ana-
lizaremos
disponible
ioctl
10.5.4
Implementación
entrada
salida
Linux
Linux
implementa
colección
drivers
dispositivos
ti-
po
dispositivo
función
drivers
aislar
resto
sistema
idiosincrasias
www.FreeLibros.mehardware
proveer
interfaces
estándar
drivers
resto
sistema
operativo
sistema
colocar
kernel
independiente
máquina
usuario
accede
archivo
especial
sistema
archivos
determina
números
dispositivo
menor
pertenecen
archivo
especial
bloques
archi-
vo
especial
caracteres
número
dispositivo
utiliza
indexar
ta-
blas
hash
internas
contienen
estructuras
datos
dispositivos
caracteres
bloques
estructura
localiza
forma
contiene
apuntadores
procedimientos
llamar
abrir
dispositivo
leer
dispositivo
escribir
dispositivo
etcétera
número
dispositivo
menor
pasa
parámetro
Agregar
tipo
dispositivo
Linux
sig-
nifica
agrega
entrada
tablas
suministrar
procedimientos
correspon-
dientes
manejar
diversas
operaciones
dispositivo
figura
10-21
muestran
operaciones
asociar
distintos
dispositivos
caracteres
fila
refiere
dispositivo
driver
columnas
representan
funciones
aceptar
drivers
caracteres
funciones
realiza
operación
archivo
especial
caracteres
siste-
ma
indexa
tabla
hash
dispositivos
caracteres
seleccionar
estructura
apropiada
llama
función
correspondiente
trabajo
operacio-
nes
archivos
contiene
apuntador
función
contenida
driver
correspondiente
776
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Dispositivo
Abrir
Cerrar
Leer
Escribir
Ioctl
Null
Null
null
null
null
null
Memoria
null
null
mem_read
mem_write
null
Teclado
k_open
k_close
k_read
error
k_ioctl
Tty
tty_open
tty_close
tty_read
tty_write
tty_ioctl
Impresora
lp_open
lp_close
error
lp_write
lp_ioctl
Figura
10-21
operaciones
archivos
aceptan
dispositivos
caracteres
comunes
driver
divide
partes
ambas
forman
kernel
Linux
ejecutan
kernel
mitad
superior
ejecuta
contexto
llamada
sirve
interfaz
resto
Linux
mitad
inferior
ejecuta
contexto
kernel
interactúa
dispositivo
drivers
llamadas
procedimientos
kernel
asignar
memoria
administrar
temporizador
controlar
DMA
cosas
conjunto
funciones
kernel
llamar
define
documento
conocido
Interfaz
driver-kernel
escritura
drivers
dispositivos
Linux
detalle
Egan
Teixeira
1992
Ru-
bini
colaboradores
2005
sistema
divide
componentes
principales
manejo
archivos
espe-
ciales
bloques
archivos
especiales
caracteres
analizaremos
es-
tos
componentes
turno
objetivo
sistema
realiza
operaciones
archivos
especiales
blo-
ques
ejemplo
discos
minimizar
número
transferencias
www
FreeLibros.meSECCIÓN
10.5
ENTRADA
SALIDA
LINUX
777
lograr
objetivo
sistemas
Linux
caché
drivers
disco
siste-
ma
archivos
muestra
figura
10-22
kernel
2.2
Linux
mantenía
cachés
página
búfer
completamente
separadas
archivo
residía
bloque
disco
podía
colocar
ambas
cachés
versiones
recientes
Linux
caché
uni-
ficada
nivel
bloques
genérico
mantiene
unidos
componentes
realiza
traducciones
necesarias
sectores
disco
bloques
búferes
páginas
datos
permite
operacio-
nes
caché
tabla
kernel
contener
miles
bloques
reciente
requiere
bloque
disco
propósito
nodo-i
directorio
datos
pri-
mero
realiza
comprobación
caché
toma
evi-
ta
acceso
disco
obtienen
mejoras
rendimiento
sistema
Driver
dispositivo
bloques
Driver
dispositivo
bloques
Driver
dispositivo
caracteres
Driver
dispositivos
red
Planificador
Archivo
regular
Archivo
especial
caracteres
Socket
red
Caché
Sistema
archivos
virtual
Disciplina
línea
opcional
Drivers
protocolos
Sistema
archivos
SA
Planificador
Archivo
especial
bloques
Figura
10-22
sistema
Linux
muestra
sistema
archivos
detalle
bloque
caché
páginas
lee
disco
coloca
caché
copia
necesita
caché
páginas
espacio
número
fijo
bloques
invoca
algoritmo
reemplazo
páginas
describimos
sección
caché
páginas
funciona
escrituras
lecturas
programa
escribe
blo-
caché
disco
demonio
pdflush
vacía
bloque
disco
caso
caché
aumente
valor
especificado
evitar
bloques
queden
tiempo
caché
escribirlos
disco
bloques
sucios
escriben
disco
30
segundos
minimizar
latencia
movimientos
repetidos
cabeza
disco
Linux
basa
planificador
cuyo
propósito
reordenar
agrupar
peticiones
lectura
es-
critura
dispositivos
bloques
variantes
planificador
optimizadas
www.FreeLibros.medistintos
tipos
cargas
trabajo
planificador
básico
Linux
basa
planificador
elevador
linus
operaciones
planificador
elevador
sintetizar
siguien-
operaciones
disco
ordenan
lista
doblemente
enlazada
ordena
base
dirección
sector
petición
disco
peticiones
insertan
es-
ta
lista
forma
ordenada
evita
movimientos
repetidos
costosos
cabeza
disco
lista
peticiones
combina
operaciones
adyacentes
emitan
petición
disco
programador
elevador
básico
producir
inanición
versión
revisada
programador
disco
Linux
incluye
listas
adicionales
mantiene
orden
operaciones
lectura
escritura
base
tiempos
límite
tiem-
pos
límite
predeterminados
0.5
segundos
peticiones
lectura
segundos
pa-
ra
peticiones
escritura
tiempo
límite
definido
sistema
operación
escritura
antigua
punto
expirar
atenderá
petición
escritura
cual-
quiera
peticiones
lista
doblemente
enlazada
principal
archivos
disco
regulares
archivos
especiales
bloques
cono-
cidos
bloques
disco
crudos
archivos
permiten
programas
accedan
disco
números
bloque
absolutos
importar
sistema
archivos
utilizan
frecuencia
cosas
paginación
mantenimiento
sistema
interacción
dispositivos
caracteres
simple
dispositivos
caracte-
res
producen
consumen
flujos
caracteres
bytes
datos
sentido
acepta-
ción
acceso
aleatorio
excepción
disciplinas
línea
asociar
disciplina
línea
dispositivo
terminal
representa
estructura
tty
struct
representa
intérprete
datos
intercambian
dispositivo
terminal
ejemplo
edición
líneas
local
eliminar
líneas
caracteres
borrados
retornos
carro
asignar
avances
línea
completar
procesamiento
especial
obstante
proceso
interactúa
ca-
rácter
línea
crudo
cuyo
caso
ignorará
disciplina
línea
to-
dispositivos
disciplinas
línea
salida
funciona
similar
expanden
tabuladores
espacios
convierten
avances
línea
retornos
carro
avances
línea
agregan
caracteres
relleno
retornos
carro
terminales
mecánicas
lentas
etcétera
entrada
salida
pasar
disciplina
línea
cocido
ignorarla
crudo
crudo
especialmente
útil
envían
datos
binarios
computadoras
línea
se-
rial
GUIs
desean
conversiones
interacción
dispositivos
red
distinta
dispositivos
red
tam-
bién
producen
consumen
flujos
caracteres
naturaleza
asíncrona
adecuados
integrarse
facilidad
interfaz
dispositivos
caracteres
driver
dispositivo
red
produce
paquetes
consisten
bytes
datos
encabe-
zados
red
paquetes
enrutan
serie
drivers
protocolos
red
pasan
aplicación
espacio
usuario
estructura
búfer
socket
sk-
buff
estructura
datos
clave
utiliza
representar
porciones
memoria
lle-
nas
datos
paquete
datos
búfer
skbuff
empiezan
inicial
búfer
medida
protocolos
pila
red
procesan
eliminar
agre-
gar
encabezados
protocolo
procesos
usuario
interactúan
dispositivos
red
tra-
778
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
779
vés
sockets
Linux
brinda
API
sockets
original
BSD
drivers
proto-
colos
ignorar
permite
acceso
directo
dispositivo
red
subyacente
raw_sockets
superusuarios
crear
sockets
crudos
10.5.5
módulos
Linux
décadas
drivers
dispositivos
UNIX
vinculado
forma
estática
ker-
nel
presentes
memoria
iniciaba
sistema
en-
torno
creció
UNIX
mayoría
minicomputadoras
departamentales
estaciones
trabajo
alto
rendimiento
pequeños
conjuntos
dispositivos
cambiaban
esquema
funcionaba
Básicamente
centro
cómputo
construía
kernel
tuviera
drivers
dispositivos
año
centro
compraba
disco
volvía
vincular
kernel
problema
llegada
Linux
plataforma
PC
cambió
repentina
nú-
mero
dispositivos
disponibles
PC
minicomputa-
dora
usuarios
Linux
obtener
facilidad
código
fuente
completo
mayoría
hubiera
considerado
difícil
agregar
driver
ac-
tualizar
estructuras
datos
relacionadas
driver
dispositivo
volver
vincular
kernel
instalarlo
sistema
capacidad
inicio
mencionar
lidiar
desgracia
construir
kernel
inicia
Linux
resolvió
problema
concepto
módulos
cargables
piezas
código
cargar
kernel
sistema
ejecuta
módulos
comunes
drivers
dispositivos
caracteres
bloques
sistemas
ar-
chivos
completos
protocolos
red
herramientas
monitoreo
rendimiento
cosa
desee
cargar
módulo
ocurrir
cosas
lugar
módulo
reubi-
car
instante
carga
lugar
sistema
comprobar
disponi-
bles
recursos
necesita
driver
ejemplo
niveles
peticiones
interrupciones
marca
tercer
lugar
establecer
vectores
interrupción
necesarios
cuarto
lugar
actualizar
tabla
cambio
drivers
apro-
piada
manejar
tipo
dispositivo
permite
ejecución
dri-
inicialización
específica
dispositivo
requiera
completan
pasos
driver
completamente
instalado
forma
driver
estático
sistemas
modernos
UNIX
admiten
módulos
cargables
10.6
SISTEMA
ARCHIVOS
LINUX
visible
sistema
operativo
incluyendo
Linux
sistema
archivos
siguientes
secciones
examinaremos
ideas
básicas
sistema
archivos
Linux
llamadas
sistema
forma
implementa
sistema
ideas
derivan
MULTICS
copiado
MS-DOS
Windows
sistemas
www.FreeLibros.mepero
únicas
sistemas
basados
UNIX
diseño
Linux
especial
intere-
sante
ilustra
claridad
principio
pequeño
hermoso
contar
mecanismo
mínimo
número
limitado
llamadas
sistema
Linux
ofrece
po-
deroso
elegante
sistema
archivos
10.6.1
Conceptos
fundamentales
sistema
archivos
inicial
Linux
MINIX
limita-
ba
nombres
archivos
14
caracteres
compatible
versión
UNIX
tamaño
máximo
archivos
64
MB
exageración
discos
duros
10
MB
época
interés
mejores
sistemas
archivos
inicio
desarrollo
Linux
empezó
años
liberar
MINIX
mejora
sistema
archivos
ext
permitía
nombres
archivos
255
caracteres
archivos
GB
lento
sistema
archivos
MINIX
búsque-
continuó
tiempo
momento
inventó
sistema
archivos
ext2
nom-
bres
archivos
largos
archivos
extensos
rendimiento
convirtió
sistema
archivos
principal
obstante
Linux
admite
docenas
sistemas
archivos
nivel
Sistema
archivos
virtual
VFS
analizaremos
sección
vincular
Linux
ofrece
opción
sistemas
archivos
incluir
kernel
cargar
forma
dinámica
módulos
ejecución
nece-
sario
archivo
Linux
secuencia
bytes
contienen
información
arbitraria
distinción
archivos
ASCII
archivos
binarios
tipo
archi-
vo
significado
bits
archivo
depende
completo
propietario
sistema
importa
nombres
archivos
limitan
255
caracteres
permiten
carac-
teres
ASCII
NUL
nombres
archivos
nombre
archivo
con-
sista
retornos
carro
válido
conveniente
convención
programas
esperan
nombres
archivos
consistan
nombre
base
extensión
separados
punto
carácter
prog.c
general
programa
prog.f90
general
programa
FORTRAN
90
pro-
g.o
general
archivo
código
objeto
producido
compilador
convencio-
nes
implementa
sistema
operativo
compiladores
programas
esperan
extensiones
longitud
archivos
ex-
tensiones
prog.java.gz
probablemente
programa
Java
comprimido
gzip
archivos
agrupar
directorios
conveniencia
directorios
almacenan
archivos
grado
tratar
directorios
contener
subdirectorios
sistema
archivos
jerárquico
directorio
raíz
llama
general
contiene
subdirectorios
carácter
utiliza
separar
nombres
directorios
nombre
/usr
ast
denota
archivo
ubicado
directorio
ast
directorio
/usr
directorios
principales
cerca
su-
perior
árbol
muestran
figura
10-23
780
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
781
formas
especificar
nombres
archivos
Linux
shell
abrir
archivo
interior
programa
forma
ru-
ta
absoluta
indica
llegar
archivo
directorio
raíz
ejemplo
ruta
absoluta
/usr
ast
libros
mos3
cap-10
indica
sistema
buscar
directorio
raíz
directorio
llamado
usr
buscar
directorio
llamado
ast
directorio
contiene
directorio
llamado
libros
contiene
directorio
mos3
contiene
archivo
cap-10
nombres
rutas
absolutas
largos
inconvenientes
razón
Linux
per-
mite
usuarios
procesos
designar
directorio
actual
encuentran
trabajando
directorio
trabajo
nombres
rutas
especificar
forma
relativa
di-
rectorio
trabajo
nombre
ruta
especifica
ruta
relativa
ejem-
plo
/usr
ast
libros
mos3es
directorio
trabajo
comando
shell
cp
cap-10
respaldo-10
exactamente
efecto
comando
cp
/usr
ast
libros
mos3
cap-10
/usr
ast
libros
mos3
respaldo-10
frecuencia
ocurre
usuario
necesita
referencia
archivo
pertenece
usuario
archivo
directorios
ejemplo
usuarios
comparten
archivo
encontrará
directorio
pertenezca
usuario
utilizar
nombre
ruta
absoluta
refe-
rirse
archivo
cambiar
directorio
trabajo
ruta
larga
pue-
irritante
escribirla
Linux
ofrece
solución
problema
permitir
usuarios
creen
entrada
directorio
apunte
archivo
existen-
dicha
entrada
conoce
vínculo
ejemplo
considere
situación
figura
10-24(a
Fred
Lisa
trabajan
juntos
proyecto
necesita
acceso
archivos
Fred
/usr
fred
di-
rectorio
trabajo
referencia
archivo
directorio
Lisa
/usr
lisa
x.
alternativa
Fred
crear
entrada
directorio
muestra
fi-
gura
10-24(b
utilizar
indicar
/usr
lisa
x.
ejemplo
acabamos
sugerimos
vinculación
única
forma
Fred
hiciera
referencia
archivo
Lisa
ruta
absoluta
realidad
Directorio
Contenido
bin
Programas
binarios
ejecutables
dev
Archivos
especiales
dispositivos
etc
Archivos
misceláneos
sistema
lib
Bibliotecas
usr
Directorios
usuario
Figura
10-23
directorios
importantes
encuentran
mayoría
sistemas
Linux
www.FreeLibros.mees
completamente
crea
directorio
crean
automática
en-
tradas
entrada
refiere
directorio
trabajo
refiere
padre
directorio
directorio
lista
directorio
trabajo
directorio
/usr
fred
utilizar
ruta
archivo
Lisa
/lisa
x.
archivos
regulares
Linux
acepta
archivos
especiales
caracteres
archivos
especiales
bloques
archivos
especiales
caracteres
utilizan
modelar
dispositivos
serie
teclados
impresoras
abrir
leer
/dev
tty
lee
teclado
abrir
escribir
/dev
lp
escribe
impresora
archivos
especiales
bloques
frecuencia
nombres
/dev
hd1
utilizar
leer
escribir
particio-
nes
disco
crudas
importar
sistema
archivos
búsqueda
byte
seguida
lectura
empezará
leer
-ésimo
byte
partición
correspondiente
ignorando
completo
nodo-i
estructura
archivos
ejemplo
dispositivos
bloques
crudos
uti-
lizan
paginación
intercambio
programas
establecen
sistemas
archivos
ejem-
plo
mkfs
programas
corrigen
sistemas
archivos
enfermos
ejemplo
fsck
computadoras
discos
ejemplo
mainframes
bancos
frecuencia
necesario
100
discos
máquina
contener
enormes
bases
datos
requeridas
computadoras
personales
normalmente
discos
disco
duro
unidad
disco
óptico
DVD
unidades
disco
surge
cuestión
manejarlos
solución
colocar
sistema
archivos
auto
contenido
unidad
mantener-
separados
ejemplo
considere
situación
muestra
figura
10-25(a
disco
duro
llamaremos
DVD
llamaremos
di-
rectorio
raíz
archivos
solución
usuario
especificar
dispo-
sitivo
archivo
necesita
valor
predeterminado
ejemplo
copiar
archivo
directorio
suponiendo
predeterminado
escribir
cp
D:/x
/a
782
CASO
ESTUDIO
LINUX
CAPÍTULO
10
bin
dev
etc
lib
tmp
usr
fred
lisa
bin
dev
etc
lib
tmp
usr
fred
lisa
Vínculo
Figura
10-24
vinculación
vinculación
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
783
método
utilizan
sistemas
incluyendo
MS-DOS
Windows
98
VMS
ba
cd
DVD
Disco
duroDisco
duro
Figura
10-25
Sistemas
archivos
separados
montarlos
solución
Linux
permitir
montar
disco
árbol
archivos
disco
nues-
tro
ejemplo
podríamos
montar
DVD
directorio
/b
produce
sistema
ar-
chivos
figura
10-25(b
usuario
ve
árbol
archivos
preocupar
archivo
reside
dispositivo
comando
copia
convierte
cp
/b
/a
exactamente
hubiera
hubiera
disco
duro
principio
propiedad
interesante
sistema
archivos
Linux
bloqueo
aplica-
ciones
procesos
usando
archivo
tiempo
producir
condiciones
competencia
solución
programar
aplicación
regiones
críti-
cas
obstante
procesos
pertenecen
usuarios
independientes
siquiera
conocen
general
tipo
coordinación
inconveniente
ejemplo
considere
base
datos
consiste
archivos
direc-
torios
acceden
usuarios
relacionados
duda
asociar
se-
máforo
directorio
archivo
lograr
exclusión
mutua
procesos
realicen
operación
downen
semáforo
apropiado
acceder
datos
desventaja
directorio
archivo
estaría
inaccesible
requiera
registro
razón
POSIX
ofrece
mecanismo
flexible
detallado
procesos
bloqueen
byte
archivo
operación
indivisible
mecanismo
bloqueo
re-
proceso
llamada
especifique
archivo
bloquear
byte
inicial
nú-
mero
bytes
operación
éxito
sistema
crea
entrada
tabla
indicar
bytes
cuestión
ejemplo
registro
base
datos
bloqueados
www
FreeLibros.me784
CASO
ESTUDIO
LINUX
CAPÍTULO
10
tipos
bloqueos
bloqueos
compartidos
bloqueos
exclusivos
porción
archivo
contiene
bloqueo
compartido
permite
intento
colocar
blo-
queo
compartido
archivo
intento
bloqueo
exclusivo
fraca-
sará
porción
archivo
contiene
bloqueo
exclusivo
intentos
bloquear
porción
fracasarán
libere
bloqueo
colocar
blo-
queo
éxito
bytes
región
desea
bloquear
disponibles
colocar
bloqueo
proceso
especificar
desea
bloquear
caso
colocar
bloqueo
opta
bloquearse
eliminado
bloqueo
exis-
tente
proceso
desbloqueará
colocará
bloqueo
archivo
proceso
opta
bloquearse
colocar
bloqueo
archivo
llamada
sistema
regresará
inmediato
código
indicará
bloqueo
archivo
éxito
fracasó
pro-
ceso
llamada
decidir
continuación
ejemplo
esperar
intentar
regiones
bloqueadas
traslapar
figura
10-26(a
proce-
so
colocado
bloqueo
compartido
bytes
archivo
proceso
coloca
bloqueo
compartido
bytes
muestra
figura
10-26(b
úl-
timo
bloquea
bytes
11
bloqueos
compartidos
co-existir
123
89
123
11
13
14
15
Bloqueo
compartido
proceso
Bloqueo
compartido
Bloqueo
compartido
Bloqueo
compartido
4567
456
789
2345
89
76
Figura
10-26
archivo
bloqueo
Adición
bloqueo
tercer
bloqueo
considere
ocurre
proceso
adquirir
bloqueo
exclusivo
by-
archivo
figura
10-26(c
proceso
solicita
bloquearse
caso
fracase
bloqueo
byte
bloqueos
anteriores
bloque
proceso
llamada
bloqueará
permanecerá
liberen
bloqueos
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
785
10.6.2
Llamadas
sistema
archivos
Linux
llamadas
sistema
relacionadas
archivos
sistema
archivos
analizaremos
llamadas
sistema
operan
archivos
individuales
exami-
naremos
llamadas
sistema
involucran
directorios
sistema
archivo
crear
archivo
utilizar
llamada
creat
preguntó
Ken
Thompson
hubiera
distinta
tuviera
oportunidad
reinventar
UNIX
res-
pondió
utilizaría
createen
creat
parámetros
proporcionan
nombre
archivo
protección
fd
creat(“abc
crea
archivo
llamado
abc
cuyos
bits
protección
obtienen
bits
determinan
usuarios
acceder
archivo
forma
analizaremos
llamada
creatno
crea
archivo
abre
escri-
tura
permitir
siguientes
llamadas
sistema
accedan
archivo
llamada
exitosa
creatdevuelve
resultado
pequeño
entero
negativo
conocido
descriptor
archivo
fd
ejemplo
llama
createn
archivo
existente
longitud
archivo
trunca
descarta
contenido
crear
archivos
llamada
open
argumentos
apropiados
sigamos
analizando
principales
llamadas
sistema
archivos
listan
figura
10-27
leer
escribir
archivo
existente
abrir
open
Es-
ta
llamada
especifica
nombre
archivo
abrir
abrir
lectura
es-
critura
ambas
especificar
opciones
creat
llamada
opendevuelve
descriptor
archivo
utilizar
leer
escribir
archi-
vo
cerrar
close
descriptor
archivo
reutilizar
llamada
subsiguiente
creatu
open
llamadas
devuelven
descriptor
archi-
vo
menor
numeración
encuentre
actualmente
programa
empieza
ejecutar
estándar
descriptores
abiertos
entrada
estándar
salida
estándar
error
estándar
respectivamente
forma
filtro
programa
sort
leer
entrada
descriptor
archivo
es-
cribir
salida
descriptor
archivo
archivos
mecanismo
funciona
shell
encarga
valores
refieran
archivos
correctos
redirigidos
inicie
programa
llamadas
utilizan
frecuencia
duda
ready
write
parámetros
descriptor
archivo
indica
archivo
abierto
leer
escribir
dirección
búfer
indica
datos
obtener
indica
bytes
transferir
diseño
simple
llamada
típica
read(fd
bufer
nbytes
programas
leen
escriben
archivos
forma
secuencial
progra-
necesitan
capacidad
acceder
archivo
azar
archivo
www.FreeLibros.metiene
asociado
apuntador
indica
posición
actual
archivo
leer
escribir
forma
secuencial
general
apunta
byte
leer
escribir
ejemplo
apuntador
4096
leer
1024
bytes
desplazará
automática
posi-
ción
5120
llamada
sistema
readexitosa
llamada
lseekcambia
valor
apuntador
posición
llamadas
subsiguientes
reado
writepueden
empezar
cual-
quier
archivo
allá
llama
lseekpara
evitar
confundirla
seek
llamada
obsoleta
utilizaba
computadoras
16
bits
búsquedas
Lseektiene
parámetros
descriptor
archivo
po-
sición
archivo
indica
posición
archivo
relativa
inicio
posición
ac-
tual
valor
devuelto
lseek
posición
absoluta
archivo
modificar
apuntador
archivo
irónico
lseeksea
única
llamada
sistema
archivos
produce
búsqueda
actual
disco
actua-
lizar
posición
actual
archivo
número
memoria
archivo
Linux
registro
archivo
regular
directorio
archivo
es-
pecial
tamaño
fecha
modificación
información
programas
pe-
dir
información
llamada
sistema
stat
parámetro
nombre
archivo
apuntador
estructura
colocar
información
so-
licitada
figura
10-28
muestran
campos
estructura
llamada
fstates
stat
opera
archivo
abierto
cuyo
nombre
conozca
ha-
cerlo
nombre
ruta
llamada
sistema
pipese
utiliza
crear
tuberías
Crea
tipo
seudoarchivo
co-
loca
búfer
datos
componentes
tubería
devuelve
descriptores
archivo
leer
escribir
búfer
tubería
sort
ent
head
/H1100230
786
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Llamada
sistema
Descripción
creat(nombre
forma
crear
archivo
fd
open(archivo
Abre
archivo
lectura
escritura
ambas
close(fd
Cierra
archivo
abierto
read(fd
bufer
nbytes
Lee
datos
archivo
coloca
búfer
write(fd
bufer
nbytes
Escribe
datos
búfer
archivo
posicion
lseek(fd
despl
de_donde
Desplaza
apuntador
archivo
stat(nombre
buf
Obtiene
información
archivo
fstat(fd
buf
Obtiene
información
archivo
pipe(&fd[0
Crea
tubería
fcntl(fd
cmd
Bloqueo
archivos
operaciones
Figura
10-27
llamadas
sistema
relacionadas
archivos
có-
digo
retorno
/H110021
ocurrió
error
daes
descriptor
archivo
posicion
desplazamiento
parámetros
explican
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
787
descriptor
archivo
salida
estándar
proceso
ejecuta
sort
establece
shell
escribir
tubería
descriptor
archivo
entrada
estándar
proceso
ejecuta
head
establece
leer
tubería
forma
sort
simplemente
lee
descriptor
archivo
estableció
archivo
ent
escribe
descriptor
tubería
consciente
siquiera
descriptores
redirigieron
hubieran
redirigido
sort
lee-
ría
automática
teclado
escribiría
pantalla
dispositivos
predeterminados
similar
head
lee
descriptor
archivo
leyendo
datos
sort
co-
locó
búfer
tubería
siquiera
utilizando
ejemplo
concepto
simple
redirección
implementación
simple
descriptores
archi-
vo
producir
poderosa
herramienta
conectar
programas
formas
arbitrarias
modificarlos
llamada
sistema
figura
10-27
fcntl
utiliza
bloquear
desbloquear
archivos
aplicar
bloqueos
compartidos
exclusivos
operaciones
específicas
archivos
veamos
llamadas
sistema
relacionan
directorios
sistema
archivos
archivo
específico
llamadas
comunes
listan
figura
10-29
directorios
crean
destruyen
mkdiry
rmdir
respectivamente
directorio
eliminar
vacío
vimos
figura
10-24
crear
vínculo
archivo
crea
entrada
directorio
apunta
archivo
existente
llamada
sistema
linkcrea
vínculo
pa-
rámetros
especifican
nombres
original
respectivamente
entradas
directorio
eliminan
unlink
elimina
vínculo
archivo
llamada
unlinkhace
desaparezca
archivo
vinculado
llamada
un-
linkhace
desaparezca
directorio
trabajo
cambia
llamada
sistema
chdir
efecto
cambiar
interpretación
nombres
rutas
relativas
llamadas
figura
10-29
leer
directorios
abrir
ce-
rrar
leer
forma
similar
archivos
ordinarios
llamada
readdirdevuelve
exactamen-
entrada
directorio
formato
fijo
forma
usuarios
escriban
Dispositivo
archivo
Número
nodo-i
archivo
dispositivo
archivo
incluye
información
protección
Número
vínculos
archivo
Identidad
propietario
archivo
Grupo
pertenece
archivo
Tamaño
archivo
bytes
Hora
creación
Hora
acceso
Hora
modificación
Figura
10-28
campos
devueltos
llamada
sistema
stat
www.FreeLibros.medirectorio
mantener
integridad
sistema
archivos
agregar
archivos
directorio
creato
linky
eliminar
unlink
forma
buscar
archivo
específico
directorio
rewinddirpermite
volver
leer
directo-
rio
abierto
principio
10.6.3
Implementación
sistema
archivos
Linux
sección
analizaremos
abstracciones
proporciona
nivel
Sistema
Ar-
chivos
Virtual
VFS
oculta
procesos
aplicaciones
nivel
superior
diferencias
en-
tre
tipos
sistemas
archivos
Linux
acepta
residan
dispositivos
locales
almacenen
forma
remota
acceder
red
acceder
dispositivos
archivos
especiales
nivel
VFS
continua-
ción
analizaremos
implementación
sistema
archivos
Linux
extenso
ext2
sistema
archivos
extendido
analizaremos
mejoras
siste-
ma
archivos
ext3
utilizan
sistemas
archivos
sistemas
Li-
nux
manejar
particiones
disco
sistema
archivos
distinto
sistema
archivos
virtual
Linux
permitir
aplicaciones
interactúen
distintos
sistemas
archivos
implemen-
tados
distintos
tipos
dispositivos
locales
remotos
Linux
adopta
metodología
uti-
liza
sistemas
UNIX
Sistema
Archivos
Virtual
VFS
VFS
define
conjunto
abstracciones
básicas
sistema
archivos
operaciones
permiten
abstraccio-
nes
invocaciones
llamadas
sistema
describimos
sección
acceden
estructuras
datos
VFS
determinan
sistema
archivos
exacto
pertenece
ar-
788
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Llamada
sistema
Descripción
mkdir(ruta
Crea
directorio
rmdir(ruta
Elimina
directorio
link(rutaant
rutanueva
Crea
vínculo
archivo
existente
unlink(ruta
Elimina
vínculo
archivo
chdir(ruta
Cambia
directorio
trabajo
dir
opendir(ruta
Abre
directorio
leerlo
closedir(dir
Cierra
directorio
dirent
readdir(dir
Lee
entrada
directorio
rewinddir(dir
Rebobina
directorio
volverlo
leer
Figura
10-29
llamadas
sistema
relacionadas
directorios
código
retorno
/H110021
ocurrió
error
diridentifica
flujo
directorios
dirent
entrada
directorio
parámetros
explican
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
789
chivo
utilizado
apuntadores
funciones
almacenados
estructuras
datos
VFS
invocan
operación
correspondiente
sistema
archivos
especificado
figura
10-30
sintetizan
estructuras
principales
sistemas
archivos
VFS
acepta
superbloque
contiene
información
crítica
distribución
sistema
ar-
chivos
destruye
superbloque
sistema
archivos
leer
no-
dos-i
abreviación
nodos
índice
llama
personas
perezosas
omitieron
guión
corto
llamaron
nodosi
describe
archivo
Observe
Linux
directorios
dispositivos
representan
archivos
corres-
pondientes
nodos-i
superbloques
nodos-i
estructura
correspondien-
mantiene
disco
físico
reside
sistema
archivos
Objeto
Descripción
Operación
Superbloque
sistema
archivos
específico
read_inode
sync_fs
Dentry
entrada
directorio
componente
ruta
create
link
Nodo-i
archivo
específico
d_compare
d_delete
Archivo
abre
archivo
asociado
proceso
read
write
Figura
10-30
Abstracciones
sistema
archivos
VFS
acepta
facilitar
operaciones
directorios
recorridos
rutas
/usr
ast
bin
VFS
proporciona
estructura
datos
conocida
dentry
representa
entrada
directo-
rio
estructura
datos
crea
sistema
archivos
instante
entradas
direc-
torio
colocan
caché
estructura
dentry_cache
ejemplo
dentry_cache
contendría
entradas
/usr
/usr
ast
etcétera
procesos
acceden
archivo
mis-
mo
vínculo
duro
ruta
objeto
archivo
apuntará
entrada
caché
estructura
datos
archivo
representación
memoria
archivo
abierto
crea
respuesta
llamada
sistema
open
Acepta
operaciones
read
write
sendfile
locky
llamadas
sistema
describen
sección
sistemas
archivos
actuales
implementan
VFS
necesitan
utili-
zar
abstracciones
operaciones
forma
interna
implementar
ope-
raciones
sistema
archivos
equivalencia
semántica
especifican
objetos
VFS
elementos
estructuras
datos
operaciones
cua-
tro
objetos
VFS
apuntadores
funciones
sistema
archivos
subyacente
sistema
archivos
ext2
Linux
continuación
analizaremos
sistema
archivos
disco
popular
utiliza
Linux
ext2
versión
Linux
utilizaba
sistema
archivos
MINIX
limitado
nombres
archivos
cortos
tamaños
archivos
64
MB
momento
sistema
MINIX
reemplazó
sistema
archivos
extendido
ext
permitía
nombres
www.FreeLibros.mearchivos
tamaños
archivos
largos
ineficiencias
rendimiento
ext
reem-
plazó
sucesor
ext2
utiliza
partes
partición
disco
ext2
Linux
contiene
sistema
archivos
distribución
muestra
figura
10-31
Linux
utiliza
bloque
contiene
código
pa-
ra
iniciar
computadora
bloque
partición
disco
divide
grupos
blo-
ques
importar
estén
límites
cilindros
grupo
organiza
bloque
superbloque
contiene
información
distribución
sis-
tema
archivos
incluyendo
número
nodos-i
número
bloques
disco
inicio
lista
bloques
disco
libres
general
cientos
entradas
continua-
ción
viene
descriptor
grupo
contiene
información
ubicación
mapas
bits
número
bloques
libres
nodos-i
grupo
número
directorios
grupo
Es-
ta
información
importante
ext2
intenta
esparcir
directorios
uniforme
disco
790
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Inicio
Grupo
bloques
Super-
bloque
Descriptor
grupo
Grupo
bloques
Mapa
bits
bloques
Bloques
datos
Mapa
bits
nodos-i
Nodos-i
Grupo
bloques
Grupo
bloques
Grupo
bloques
Figura
10-31
Distribución
disco
sistema
archivos
ext2
Linux
mapas
bits
llevan
registro
bloques
libres
nodos-i
libres
respectivamente
es-
ta
opción
heredó
sistema
archivos
MINIX
contraria
mayoría
sistemas
archivos
UNIX
utilizan
lista
bloques
libres
mapa
bloque
lon-
gitud
bloque
KB
diseño
limita
grupo
bloques
8192
bloques
8192
no-
dos-i
restricción
real
práctica
superbloque
nodos-i
enumeran
máximo
nodo-i
128
bytes
longitud
describe
archivo
nodo-i
contiene
informa-
ción
contable
incluyendo
información
devuelta
stat
simplemente
toma
nodo-
información
suficiente
localizar
bloques
disco
contienen
datos
archivo
nodos-i
bloques
datos
archivos
directorios
almace-
nan
archivo
directorio
consiste
bloque
bloques
con-
tiguos
disco
probable
bloques
archivo
extenso
estén
esparcidos
disco
nodos-i
corresponden
directorios
dispersos
grupos
bloques
disco
Ext2
intenta
colocar
archivos
ordinarios
grupo
bloques
direc-
torio
padre
archivos
datos
bloque
nodo-i
archivo
original
espacio
suficiente
idea
proviene
Sistema
Archivos
Rápido
Berkeley
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
791
McKusick
colaboradores
1984
mapas
bits
utilizan
tomar
decisiones
rápidas
relación
lugar
asignar
datos
sistema
archivos
asignan
bloques
archivo
ext2
asigna
previamente
número
bloques
adicionales
archivo
minimice
fragmentación
archivos
futuras
operaciones
escritura
esquema
balancea
carga
sistema
archivos
disco
rendimiento
tendencias
colocación
fragmenta-
ción
reducida
acceder
archivo
llamadas
sistema
Linux
co-
mo
open
requiere
nombre
ruta
archivo
nombre
ruta
analiza
extraer
directorios
individuales
especifica
ruta
relativa
búsqueda
empieza
directorio
actual
proceso
caso
contrario
empieza
directorio
raíz
caso
nodo-i
directorio
localizar
facilidad
apuntador
nodo-i
descriptor
proceso
caso
directorio
raíz
general
almacena
blo-
predeterminado
disco
archivo
directorios
permite
nombres
archivos
255
caracteres
ilustra
figura
10-32
directorio
consiste
número
integral
bloques
disco
puedan
escribir
directorios
forma
atómica
disco
directorio
entradas
archivos
directorios
desordenadas
entrada
justo
an-
terior
entradas
abarcar
bloques
disco
número
bytes
utilizar
bloque
disco
19
19F8
F1
08
8D
grandircolosal
Voluminoso
utilizar
19
88
grandircolosal
utilizarSin
utilizar
Número
nodo-i
Tamaño
entrada
Tipo
Longitud
nombre
archivo
Figura
10-32
directorio
Linux
archivos
directorio
eliminar
archivo
voluminoso
entrada
directorio
figura
10-32
consiste
campos
longitud
fija
campo
longitud
variable
campo
número
nodo-i
19
archivo
colosal
42
archivo
voluminoso
88
directorio
grandir
continuación
viene
campo
re-
c_len
indica
entrada
bytes
posiblemente
incluye
relle-
nombre
campo
requiere
buscar
entrada
caso
www.FreeLibros.meque
nombre
archivo
rellene
base
longitud
desconocida
significado
flecha
figura
10-32
viene
campo
tipo
archivo
directorio
etcétera
úl-
timo
campo
fijo
longitud
nombre
archivo
actual
bytes
10
ejemplo
viene
nombre
archivo
agrega
byte
terminación
re-
llena
límite
32
bits
relleno
adicional
figura
10-32(b
directorio
eliminar
entrada
vo-
luminoso
incrementar
tamaño
campo
entrada
colosal
ac-
tivando
campo
voluminoso
rellenando
entrada
relleno
utilizar
entrada
subsiguente
búsquedas
directorios
lineales
requerir
tiempo
en-
contrar
entrada
directorio
extenso
sistema
mantiene
caché
directorios
acceso
reciente
buscar
caché
utiliza
nombre
archivo
ocu-
rre
coincidencia
evita
búsqueda
lineal
requiere
recursos
introduce
ob-
jeto
dentry
caché
dentry
componentes
ruta
nodo-i
busca
directorio
entrada
elemento
subsiguiente
ruta
llegue
nodo-i
archivo
actual
ejemplo
buscar
archivo
especificado
nombre
ruta
absoluta
/usr/
ast
archivo
requieren
siguientes
pasos
lugar
sistema
localiza
directorio
raíz
general
utiliza
nodo-i
especial
nodo-i
reservado
manejo
bloques
defectuosos
Coloca
entrada
caché
dentry
futuras
búsquedas
di-
rectorio
raíz
busca
cadena
usr
directorio
raíz
obtener
número
nodo-i
directorio
/usr
introduce
caché
dentry
obtiene
no-
do-i
extraen
bloques
disco
leer
directorio
/usry
buscar
cade-
na
ast
cadena
obtener
número
nodo-i
directorio
/usr
ast
Armado
número
nodo-i
directorio
/usr
ast
leer
nodo-
localizar
bloques
directorio
busca
archivo
número
nodo-i
ende
nombre
ruta
relativa
conveniente
usua-
rio
ahorra
cantidad
considerable
trabajo
sistema
archivo
presente
sistema
extrae
número
nodo-i
utiliza
índice
tabla
nodos-i
disco
localizar
nodo-i
correspondiente
llevarlo
memoria
nodo-i
coloca
tabla
nodos-i
estructura
datos
kernel
contiene
nodos-i
archivos
directorios
abiertos
momento
formato
en-
tradas
nodo-i
mínimo
contener
campos
devueltos
llamada
sis-
tema
stat
llamada
funcionar
vea
figura
10-28
figura
10-28
muestran
campos
incluidos
estructura
nodos-i
nivel
sistema
ar-
chivos
Linux
admite
estructura
nodos-i
actual
contiene
campos
estructura
utiliza
representar
directorios
dispositivos
archivos
espe-
ciales
estructura
nodos-i
contiene
campos
reservan
futuro
his-
toria
demostrado
bits
permanecen
tiempo
veamos
sistema
lee
archivo
Recuerde
llamada
típica
pro-
cedimiento
biblioteca
invocar
llamada
sistema
reades
similar
read(fd
bufer
nbytes
792
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
793
kernel
control
empezar
parámetros
informa-
ción
tablas
internas
relacionadas
usuario
elementos
tablas
internas
arreglo
descriptores
archivos
indexa
descriptor
archivo
contiene
entrada
archivo
abierto
número
máximo
cuyo
valor
predeterminado
co-
múnmente
32
idea
empezar
descriptor
archivo
terminar
nodo-i
correspondiente
Va-
mos
considerar
diseño
coloca
apuntador
nodo-i
tabla
descripto-
res
archivos
método
simple
desgracia
funciona
problema
descriptor
archivo
asocia
posición
archivo
indica
byte
empe-
zar
lectura
escritura
posibilidad
colocarlo
tabla
nodos-i
método
falla
procesos
relacionados
intentan
abrir
mis-
mo
archivo
tiempo
posición
archivo
posibilidad
colocar
posición
archivo
tabla
descriptores
archi-
vos
forma
proceso
abra
archivo
recibe
posición
privada
archivo
desgracia
esquema
fracasa
razonamiento
sutil
relacionado
naturaleza
compartición
archivos
Linux
Considere
secuencia
comandos
shell
consiste
comandos
p1
p2
ejecutar
orden
llamada
secuencia
comandos
shell
línea
comandos
esperar
p1
escriba
salida
p2
escribirá
salida
empezando
lugar
detuvo
p1
shell
bifurca
proceso
p1
variable
vacía
p1
simplemente
em-
pieza
escribir
posición
archivo
termina
p1
requiere
me-
canismo
asegurar
posición
inicial
archivo
vea
p2
caso
posición
archivo
mantuviera
tabla
descriptores
archivos
valor
terminó
p1
Campo
Bytes
Descripción
Mode
Tipo
archivo
bits
protección
bits
setuid
setgid
Nlinks
Número
entradas
directorio
apuntan
nodo-i
Uid
UID
propietario
archivo
Gid
GID
propietario
archivo
Size
Tamaño
archivo
bytes
Addr
60
Dirección
12
bloques
disco
bloques
indirectos
Gen
Número
generación
incrementa
reutiliza
nodo-i
Atime
Hora
acceso
archivo
Mtime
Hora
modificación
archivo
Ctime
Hora
cambió
nodo-i
Figura
10-33
campos
estructura
nodos-i
Linux
www
FreeLibros.meEn
figura
10-34
muestra
lograr
truco
introducir
tabla
conocida
tabla
descripción
archivos
abiertos
tabla
descriptores
archivos
tabla
nodos-i
colocar
posición
archivo
bit
lectura
escritura
figura
padre
shell
hijo
p1y
p2
shell
bifurca
proceso
p1
estructura
usuario
incluyendo
tabla
descriptores
archivos
copia
exacta
shell
ambas
apuntan
entrada
tabla
descripción
archivos
abiertos
termina
p1
descriptor
archivo
shell
apuntando
descripción
archivos
abiertos
contiene
posición
archivo
p1
shell
bifurca
proceso
p2
hijo
hereda
automática
posición
archivo
shell
tengan
posición
794
CASO
ESTUDIO
LINUX
CAPÍTULO
10
nodo-1
vínculos
Uid
Gid
Tamaño
archivo
Horas
Direcciones
12
bloques
disco
Sencillo
indirecto
Doble
indirecto
Triple
indirecto
Tabla
descriptores
archivos
padre
Tabla
descriptores
archivos
hijo
Tabla
descriptores
archivos
proceso
relacionado
Descripción
archivos
abiertos
Posición
archivo
Apuntador
nodo-i
Posición
archivo
Apuntador
nodo-i
Apuntadores
bloques
disco
Bloque
triple
indirecto
Bloque
doble
indirecto
Bloque
sencillo
indirecto
Figura
10-34
relación
tabla
descriptores
archivos
tabla
des-
cripción
archivos
abiertos
tabla
nodos-i
obstante
proceso
relacionado
abre
archivo
recibe
entrada
descripción
archivos
abiertos
posición
archivo
precisamente
necesita
objetivo
tabla
descripción
archivos
abiertos
permitir
padre
hijo
compartan
posición
archivo
proveer
procesos
relacionados
valores
regresamos
problema
llamada
read
mostrado
localizan
posición
archivo
nodo-i
nodo-i
contiene
direcciones
disco
12
blo-
ques
archivo
posición
archivo
12
bloques
lee
bloque
copian
datos
usuario
archivos
mayores
12
bloques
campo
nodo-i
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
795
contiene
dirección
disco
bloque
sencillo
indirecto
muestra
figura
10-34
bloque
contiene
direcciones
disco
bloques
disco
ejemplo
bloque
KB
dirección
disco
bytes
bloque
sencillo
indirecto
contener
256
direc-
ciones
disco
ende
esquema
funciona
archivos
268
KB
tamaños
mayores
utiliza
bloque
doble
indirecto
bloque
contiene
direccio-
nes
256
bloques
sencillos
indirectos
contiene
direcciones
256
blo-
ques
datos
mecanismo
suficiente
manejar
archivos
10
16
bloques
67,119,104
bytes
suficiente
nodo-i
espacio
bloque
triple
indirec-
to
apuntadores
apuntan
bloques
dobles
indirectos
esquema
direccionamien-
to
manejar
tamaños
archivos
24
bloques
KB
16
GB
tamaños
bloque
KB
esquema
direccionamiento
admitir
tamaños
archivos
64
TB
sistema
archivos
ext3
Linux
evitar
pérdida
datos
fallas
sistema
fallas
energía
siste-
ma
archivos
ext2
tendría
escribir
bloque
datos
disco
hu-
biera
creado
latencia
producida
operación
requerida
búsqueda
cabezas
disco
alta
rendimiento
intolerable
escrituras
retrasan
confirmar
cambios
disco
periodo
menor
30
segundos
in-
tervalo
contexto
hardware
computadora
moderno
mejorar
solidez
sistema
archivos
Linux
basa
sistemas
archivos
transaccionales
sistema
archivos
ext3
continuación
sistema
archivos
ext2
ejemplo
sistema
archivos
transaccional
idea
básica
tipo
sistema
archivos
mantener
re
gistro
transaccio-
nes
describe
operaciones
sistema
archivos
orden
secuencial
escribir
forma
secuencial
cambios
datos
metadatos
sistema
archivos
nodos-i
super-
bloque
etc.
operaciones
sufren
sobrecargas
movimiento
cabeza
disco
accesos
aleatorios
momento
escribirán
cambios
confir-
marán
ubicación
apropiada
disco
descartar
entradas
correspondientes
registro
transacciones
ocurre
falla
sistema
falla
energía
confirmar
cambios
reinicio
sistema
detectará
sistema
archivos
desmontó
forma
apropiada
recorrerá
registro
transacciones
aplicará
cambios
sistema
archi-
vos
estén
descritos
registro
sistema
ext3
diseñado
compatibilidad
extrema
ext2
to-
das
estructuras
datos
básicas
distribución
disco
iguales
sistemas
Ade-
sistema
archivos
desmonte
sistema
ext2
montar
sistema
ext3
ofrecer
capacidad
registro
transacciones
registro
transacciones
archivo
administra
búfer
circular
alma-
cenar
dispositivo
dispositivo
separado
sistema
archivos
principal
operaciones
registro
transacciones
registran
transacciones
maneja
sistema
archivos
ext3
utiliza
JBD
Journaling
Block
Device
Dispos-
itivo
bloque
transaccional
separado
operaciones
lectura
escritura
registro
transacciones
www
FreeLibros.meEl
JBD
proporciona
estructuras
datos
principales
registro
diario
manejador
ope-
ración
atómica
transacción
registro
diario
describe
operación
sistema
archivos
nivel
general
produce
cambios
bloque
llamada
sistema
writeincluye
cambios
lugares
nodos-i
bloques
archivo
existentes
blo-
ques
archivo
lista
bloques
libres
etc.
registros
diario
relacionados
agrupan
ope-
raciones
atómicas
sistema
ext3
notifica
JBD
inicio
procesamiento
llamada
sistema
JBD
asegurar
apliquen
registros
diario
operación
atómica
aplique
principalmente
cuestiones
eficiencia
JBD
colecciones
operaciones
atómicas
fueran
transacciones
registros
diario
almacenan
forma
consecutiva
transacción
JBD
permite
descarten
partes
archivo
registro
transacciones
confirman
seguridad
disco
registros
diario
pertenecen
transacción
requerir
recursos
escribir
entrada
diario
cam-
bio
disco
sistema
ext3
configurar
mantener
registro
transacciones
cambios
disco
cambios
relacionados
metadatos
sistema
archivos
nodos-i
superbloques
mapas
bits
etc.
registran
transacciones
metadatos
produce
menor
sobrecarga
sistema
obtiene
rendimiento
garantías
corrupción
datos
archivo
sistemas
archivos
transaccionales
mantienen
registros
operaciones
metadatos
ejemplo
XFS
SGI
sistema
archivos
/proc
sistemas
archivos
Linux
/proc
proceso
idea
desarrolló
original-
mente
8a
edición
UNIX
Bell
Labs
copió
posteriormente
versiones
4.4BSD
System
Linux
extiende
idea
formas
concepto
básico
proceso
sistema
crea
directorio
/proc
nombre
directorio
PID
proceso
expresado
número
decimal
ejemplo
/proc/619
directorio
corresponde
proceso
PID
619
directorio
archivos
parecen
contener
infor-
mación
proceso
línea
comandos
cadenas
entorno
máscaras
se-
ñales
archivos
disco
leen
sistema
obtiene
información
proceso
actual
necesaria
devuelve
formato
estándar
extensiones
Linux
relacionan
archivos
directorios
ubicados
/proc
Contienen
amplia
variedad
información
CPU
particiones
disco
dis-
positivos
vectores
interrupción
contadores
kernel
sistemas
archivos
mó-
dulos
cargados
programas
usuario
privilegios
leer
información
aprender
comportamiento
sistema
forma
segura
pue-
escribir
archivos
modificar
parámetros
sistema
10.6.4
NFS
sistema
archivos
red
redes
desempeñado
papel
importante
LINUX
UNIX
general
justo
ini-
cio
red
UNIX
construyó
trasladar
kernels
PDP-11/70
Interdata
8/32
creación
puerto
UNIX
sección
examina-
796
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
797
remos
NFS
Network
File
System
Sistema
archivos
red
Sun
Microsystems
uti-
liza
sistemas
modernos
Linux
unir
sistemas
archivos
computadoras
separadas
lógico
actualidad
implementación
dominante
NFS
versión
introdujo
1994
NSFv4
introdujo
2000
provee
mejoras
ar-
quitectura
NFS
aspectos
interés
NFS
arquitectura
protocolo
implementación
examinaremos
turno
contexto
versión
NFS
simple
analizaremos
brevedad
mejoras
in-
cluyen
v4
Arquitectura
NFS
idea
básica
NFS
permitir
colección
arbitraria
clientes
servidores
com-
partan
sistema
archivos
común
casos
clientes
servidores
encuen-
tran
LAN
obligatorio
NFS
red
área
amplia
servidor
alejado
cliente
cuestión
simplicidad
hablaremos
clientes
servidores
estuvieran
distintas
máquinas
NFS
per-
mite
máquina
cliente
servidor
tiempo
servidor
NFS
exporta
directorios
clientes
remotos
pue-
utilizarlos
comparte
directorio
comparten
subdirectorios
árboles
directorios
completos
exportan
normalmente
unidad
lista
directorios
exporta
servidor
mantiene
archivo
llama
/etc
exports
directorios
exportar
automática
inicia
sis-
tema
acceder
directorios
exportados
clientes
montarlos
clien-
monta
directorio
remoto
convierte
jerarquía
directorios
muestra
figura
10-35
ejemplo
cliente
montó
directorio
bin
servidor
directorio
bin
referir
shell
/bin
sh
obtener
shell
servidor
esta-
ciones
trabajo
discos
sistema
archivos
esqueleto
RAM
obtienen
archivos
servidores
remotos
similar
cliente
montó
directorio
/proyectos
servidor
directorio
/usr
ast
trabajo
aho-
ra
acceder
archivo
/usr
ast
trabajo
proy1
a.
cliente
montó
directorio
proyectos
acceder
archivo
/mnt
proy1
a.
archivo
distintos
nombres
distintos
clientes
monta
lugar
distinto
respectivos
árboles
punto
montaje
completamente
local
clientes
servidor
montado
cualquiera
clientes
Protocolos
NFS
objetivos
NFS
proporcionar
sistema
heterogéneo
clientes
servidores
posiblemente
ejecuten
distintos
sistemas
operativos
hardware
distinto
esencial
interfaz
clientes
servidores
esté
definida
alguien
escribir
implementación
cliente
esperar
funcione
correctamente
ser-
vidores
existentes
viceversa
www
FreeLibros.mePara
lograr
objetivo
NFS
define
protocolos
cliente-servidor
protocolo
conjunto
peticiones
clientes
envían
servidores
correspondientes
res-
puestas
servidores
envían
vuelta
clientes
protocolo
NFS
encarga
montaje
cliente
enviar
nombre
ruta
servidor
solicitar
permiso
montar
directorio
jerarquía
directorios
lugar
montar
contenido
mensaje
servi-
dor
importa
montar
nombre
ruta
legal
exportado
di-
rectorio
especificado
servidor
devuelve
manejador
archivo
cliente
manejador
contiene
campos
identifican
forma
única
tipo
sistema
archivos
disco
núme-
ro
nodo-i
directorio
información
seguridad
siguientes
llamadas
leer
es-
cribir
archivos
directorio
montado
cualquiera
subdirectorios
utilizan
manejador
archivo
inicia
Linux
ejecuta
secuencia
comandos
shell
/etc
rc
pasar
mo-
do
multiusuario
comandos
montar
sistemas
remotos
colocar
secuen-
cia
comandos
montan
automática
sistemas
archivos
remotos
necesarios
permitir
inicio
sesión
alternativa
mayoría
ver-
siones
Linux
admiten
automontaje
característica
permite
asociar
conjunto
directorios
remotos
directorio
local
directorios
remotos
montan
contacto
servidores
inicia
cliente
abre
archivo
remoto
sistema
operativo
envía
mensaje
servidores
pri-
mero
responder
gana
monta
directorio
798
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Cliente
Cliente
Servidor
Servidor
/usr
/usr
ast
/usr
ast
trabajo
/bin
/bin
cat
cp
Is
mv
sh
abc
/proy2
proy1
/proyectos
/mnt
bin
Montaje
Figura
10-35
Ejemplos
montaje
sistemas
archivos
remotos
directorios
muestran
cuadros
archivos
círculos
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
799
automontaje
ventajas
principales
comparación
montaje
estático
median-
archivo
/etc
rc
lugar
servidores
NFS
nombrados
/etc
rc
caído
imposible
funcionar
cliente
dificultad
retraso
men-
sajes
error
usuario
siquiera
necesita
servidor
momento
desperdicia
trabajo
lugar
permitir
cliente
pruebe
conjunto
servidores
pa-
ralelo
obtener
grado
tolerancia
fallas
necesita
funcionando
mejorar
rendimiento
seleccionar
responder
carga
asume
tácitamente
sistemas
archivos
especificados
al-
ternativas
automontaje
idénticos
NFS
provee
soporte
duplicación
archivos
directorios
responsabilidad
usuario
encargarse
sistemas
ar-
chivos
iguales
consecuencia
automontaje
utiliza
frecuencia
siste-
archivos
lectura
contienen
archivos
binarios
sistema
archivos
modifican
raras
protocolo
NFS
acceso
directorios
archivos
clientes
pue-
den
enviar
mensajes
servidores
manipular
directorios
operaciones
lectura
escritura
archivos
acceder
atributos
archivos
tamaño
hora
modificación
NFS
admite
mayoría
llamadas
sistema
Linux
excepciones
openy
close
sorprendente
lector
omisión
openy
closeno
accidente
completo
intencional
necesario
abrir
archivo
leerlo
cerrarlo
terminar
leer
archivo
clien-
envía
servidor
mensaje
lookupque
contiene
nombre
archivo
petición
buscarlo
devolver
manejador
archivos
estructura
identifica
archivo
contiene
identificador
sistema
archivos
número
nodo-i
datos
diferencia
llamada
open
operación
lookupno
copia
información
tablas
inter-
nas
sistema
llamada
readcontiene
manejador
archivo
leer
desplaza-
miento
archivo
empezar
leer
número
bytes
deseados
mensajes
autocontenido
ventaja
esquema
servidor
re-
cordar
conexiones
abiertas
llamadas
ende
servidor
falla
des-
pués
recupera
pierde
información
archivos
abiertos
servidor
tipo
mantiene
información
archivos
abier-
tos
servidor
desgracia
método
NFS
dificulta
acción
lograr
semántica
exacta
ar-
chivos
Linux
ejemplo
Linux
archivo
abrir
bloquear
procesos
puedan
utilizarlo
cierra
archivo
liberan
bloqueos
servidor
NFS
bloqueos
asociar
archivos
abiertos
servidor
archivos
abiertos
NFS
necesita
mecanis-
mo
adicional
independiente
manejar
bloqueo
NFS
utiliza
mecanismo
protección
estándar
UNIX
bits
rwx
propieta-
rio
grupo
mencionamos
capítulo
analizaremos
detalle
continuación
principio
mensaje
petición
simplemente
contiene
IDs
usuario
grupo
pro-
ceso
llamada
servidor
NFS
utiliza
validar
acceso
efecto
confía
clientes
hagan
trampa
años
experiencia
demostraron
abundancia
dicha
www.FreeLibros.mesuposición
podríamos
decirlo
ingenua
actualidad
utilizar
criptografía
claves
públicas
establecer
clave
segura
validar
cliente
servidor
petición
respuesta
utiliza
opción
cliente
malicioso
hacerse
pa-
sar
cliente
conoce
clave
secreta
cliente
Implementación
NFS
implementación
código
cliente
servidor
independiente
protocolos
NFS
mayoría
sistemas
Linux
utilizan
implementación
niveles
similar
figura
10-36
nivel
superior
nivel
llamadas
sistema
nivel
maneja
llamadas
open
ready
close
analizar
llamada
comprobar
parámetros
invoca
se-
gundo
nivel
nivel
Sistema
Archivos
Virtual
VFS
800
CASO
ESTUDIO
LINUX
CAPÍTULO
10
Kernel
cliente
Kernel
servidor
Nivel
llamadas
sistema
Caché
búfer
Caché
búfer
Nivel
sistema
archivos
virtual
Nivel
sistema
archivos
virtual
Local
SA
Local
SA
Local
SA
Local
SA
Cliente
NFS
Servidor
NFS
Driver
Driver
Driver
Driver
Mensaje
servidor
Mensaje
cliente
Discos
locales
Discos
locales
Nodo-v
Figura
10-36
estructura
niveles
NFS
tarea
nivel
VFS
mantener
tabla
entrada
archivo
abierto
ni-
vel
VFS
entrada
nodo-i
virtual
nodo-v
archivo
abierto
nodos-v
utilizan
archivo
local
remoto
archivos
remotos
proporciona
informa-
ción
suficiente
acceder
archivos
locales
registran
sistema
archi-
vos
nodo-i
sistemas
Linux
modernos
aceptan
sistemas
archivos
ejemplo
ext2fs
/proc
FAT
etc.
VFS
inventó
aceptar
NFS
mayoría
sistemas
Linux
admiten
integral
sistema
operativo
utilice
nodos-v
trazar
secuencia
llamadas
sistema
mount
openy
read
montar
sistema
archivos
remoto
administrador
sistema
/etc
rc
www
FreeLibros.meSECCIÓN
10.6
SISTEMA
ARCHIVOS
LINUX
801
llama
programa
mount
especifica
directorio
remoto
directorio
local
mon-
tar
información
necesaria
programa
mount
analiza
nombre
directorio
remoto
montar
descubre
nombre
servidor
NFS
pone
contacto
máquina
pide
manejador
archivo
directorio
remoto
direc-
torio
disponible
montaje
remoto
servidor
devuelve
manejador
archi-
vo
directorio
realiza
llamada
sistema
mounty
pasa
manejador
kernel
kernel
construye
nodo-v
directorio
remoto
pide
código
cliente
NFS
figura
10-36
crear
nodo-r
nodo-i
remoto
tablas
internas
guardar
manejador
archivo
nodo-v
apunta
nodo-r
nodo-v
nivel
VFS
contiene
apuntador
nodo-r
código
cliente
NFS
apuntador
nodo-i
sis-
temas
archivos
locales
figura
10-36
muestran
líneas
punteadas
nodo-
archivo
directorio
local
remoto
local
localizar
sistema
archivos
nodo-i
correctos
remoto
localizar
host
remoto
maneja-
dor
archivo
abre
archivo
remoto
cliente
punto
análisis
nombre
ruta
kernel
directorio
montado
sistema
archivos
remoto
kernel
ve
directorio
remoto
nodo-v
directorio
apuntador
nodo-r
pide
código
cliente
NFS
abrir
archivo
código
cliente
NFS
bus-
ca
porción
restante
nombre
ruta
servidor
remoto
asociado
directorio
montado
recibe
vuelta
manejador
archivo
Crea
nodo-r
archivo
remoto
tablas
reporta
vuelta
nivel
VFS
coloca
tablas
nodo-v
archi-
vo
apunta
nodo-r
archivo
directorio
abierto
nodo-v
apunta
nodo-r
nodo-i
proceso
llamada
recibe
descriptor
archivo
remoto
descriptor
archivo
asigna
nodo-v
tablas
nivel
VFS
Observe
entradas
tabla
servidor
servidor
preparado
proporcionar
ma-
nejadores
archivo
soliciten
registro
archivos
maneja-
dores
archivo
pendientes
envía
manejador
archivo
acceder
archivo
comprueba
manejador
válido
utiliza
validación
incluir
verificación
clave
auténtica
contenida
encabezados
RPC
seguridad
habi-
litada
utiliza
descriptor
archivo
llamada
subsiguiente
sistema
ejemplo
read
nivel
VFS
localiza
nodo-v
correspondiente
determina
local
remoto
nodo-i
nodo-r
describe
envía
mensaje
servidor
con-
manejador
desplazamiento
archivo
mantiene
cliente
ser-
vidor
bytes
cuestiones
eficiencia
transferencias
cliente
servidor
realizan
trozos
general
8192
bytes
solicitan
bytes
mensaje
petición
llega
servidor
pasa
nivel
VFS
determi-
na
sistema
archivos
local
contiene
archivo
solicitado
nivel
VFS
realiza
llamada
sistema
archivos
local
leer
devolver
bytes
datos
pasan
vuelta
cliente
nivel
VFS
cliente
recibe
trozo
KB
pi-
dió
emite
automática
petición
trozo
tenerlo
caso
www.FreeLibros.menecesitarlo
característica
conoce
lectura
adelantada
mejora
rendimiento
considerable
escrituras
ruta
análoga
cliente
servidor
transferencias
realizan
trozos
KB
llamada
sistema
writesuministra
KB
datos
simplemente
acumulan
forma
local
esté
lleno
trozo
comple-
to
KB
envía
servidor
cierra
archivo
da-
tos
envían
servidor
inmediato
técnica
utiliza
mejorar
rendimiento
caché
sistema
UNIX
ordinario
servidores
colocan
datos
caché
evitar
accesos
disco
invisible
clientes
mantienen
cachés
atributos
archivo
no-
dos-i
datos
necesita
nodo-i
bloque
archivo
realiza
comprobación
satisfacer
caché
evitar
tráfico
red
caché
clientes
ayuda
considerable
rendimiento
in-
troduce
problemas
serios
Suponga
clientes
colocan
caché
bloque
archivo
modifica
lea
bloque
obtendrá
valor
ran-
cio
caché
coherente
Dada
severidad
potencial
problema
implementación
NFS
cosas
pa-
ra
mitigarla
lugar
asocia
temporizador
bloque
caché
expira
tem-
porizador
descarta
entrada
general
temporizador
segundos
bloques
datos
30
segundos
bloques
directorios
reduce
riesgo
grado
abre
archivo
caché
envía
mensaje
servidor
averi-
guar
modificó
modificación
ocurrió
colocar
caché
copia
local
descarta
copia
local
obtiene
copia
servidor
últi-
mo
temporizador
expira
30
segundos
bloques
sucios
de-
cir
modificados
caché
envían
servidor
perfectos
parches
aumentan
utilidad
sistema
mayoría
circunstancias
prácticas
NFS
versión
versión
Sistema
archivos
red
NFS)se
diseñó
simplificar
operaciones
predecesor
diferencia
NSFv3
analizamos
anteriormente
NFSv4
sistema
archivos
permite
invocación
operaciones
openen
archivos
remotos
servidor
NFS
remoto
mantendrá
estructuras
relacionadas
sistema
archi-
vos
incluyendo
apuntador
archivo
necesario
operaciones
lectura
inclu-
yan
rangos
lectura
absolutos
aplicar
forma
incremental
posición
apuntador
archivo
produce
mensajes
cortos
habilidad
in-
tegrar
operaciones
NFSv3
transacción
red
naturaleza
NFSv4
facilita
integración
variedad
protocolos
NFSv3
describieron
sección
protocolo
coherente
necesi-
dad
aceptar
protocolos
separados
montar
colocar
caché
bloquear
asegurar
opera-
ciones
NFSv4
funciona
semántica
sistemas
archivos
Linux
UNIX
general
Windows
802
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meCAPÍTULO
10.7
SEGURIDAD
LINUX
803
10.7
SEGURIDAD
LINUX
clon
MINIX
UNIX
Linux
sistema
multiusuario
principio
Es-
ta
historia
significa
seguridad
control
información
integraron
prin-
cipio
siguientes
secciones
analizaremos
aspectos
seguridad
Linux
10.7.1
Conceptos
fundamentales
comunidad
usuarios
sistema
Linux
consiste
número
usuarios
registrados
UID
User
ID
ID
usuario
único
UID
entero
65,535
archivos
procesos
recursos
marcan
UID
pro-
pietario
predeterminada
propietario
archivo
persona
creó
forma
cambiar
propiedad
usuarios
organizar
grupos
enumeran
enteros
16
bits
cono-
cidos
GIDs
Group
IDs
IDs
grupo
proceso
asignar
usuarios
grupos
for-
ma
manual
administrador
sistema
consiste
crear
entradas
base
datos
sistema
indique
grupo
pertenece
usuario
usuario
gru-
pos
tiempo
cuestión
simplicidad
analizaremos
característica
detalle
mecanismo
básico
seguridad
Linux
simple
proceso
UID
GID
propietario
crea
archivo
recibe
UID
GID
proceso
creó
ar-
chivo
recibe
conjunto
permisos
determinados
proceso
creador
permisos
especifican
acceso
propietario
miembros
grupo
propietario
resto
usuarios
archivo
categorías
accesos
potenciales
lectura
escritura
ejecución
designados
letras
respectivamente
lue-
go
habilidad
ejecutar
archivo
sentido
archivo
programa
binario
ejecutable
usuario
intenta
ejecutar
archivo
permiso
ejecución
ejecutable
empiece
encabezado
válido
producirá
error
categorías
usuarios
bits
categoría
requieren
bits
representar
permisos
acceso
figura
10-37
muestran
ejemplos
números
bits
significado
Binario
Simbólico
Accesos
permitidos
archivo
111000000
rwx
propietario
leer
escribir
ejecutar
111111000
rwxrwx—-
propietario
grupo
leer
escribir
ejecutar
110100000
rw-r——-
propietario
leer
escribir
grupo
leer
110100100
rw-r—r
propietario
leer
escribir
leer
111101101
rwxr-xr-x
propietario
resto
leer
ejecutar
000000000
acceso
000000111
rwx
usuarios
externos
acceso
extraño
válido
Figura
10-37
ejemplos
modos
protección
archivos
www
FreeLibros.meLas
primeras
entradas
figura
10-37
claras
permiten
propietario
grupo
propietario
acceso
completo
respectivamente
entrada
permite
gru-
po
propietario
leer
archivo
modificarlo
evita
usuarios
externos
tengan
acceso
cuarta
entrada
común
archivo
datos
propietario
desea
pú-
blico
similar
quinta
entrada
común
programa
disponible
público
sexta
entrada
niega
tipo
acceso
usuarios
emplea
mo-
do
archivos
señuelo
utilizan
exclusión
mutua
intento
crear
archivo
fracasará
procesos
intentan
mis-
mo
tiempo
crear
archivo
bloqueo
éxito
ejem-
plo
duda
extraño
proporciona
resto
mundo
acceso
propietario
existencia
resultado
reglas
protección
fortuna
propietario
cambie
protección
acceso
archivo
usuario
UID
especial
conoce
superusuario
root
superusuario
leer
escribir
archivos
sistema
importar
propieta-
rio
forma
estén
protegidos
procesos
UID
habilidad
pequeño
número
llamadas
protegidas
sistema
niegan
usuarios
ordina-
rios
general
administrador
sistema
conoce
contraseña
superusuario
aun-
estudiantes
universitarios
consideran
deporte
tratar
buscar
fallas
seguridad
sistema
puedan
iniciar
sesión
superusuario
contrase-
ña
administración
tiende
dicha
actividad
directorios
archivos
modos
protección
archivos
ordi-
narios
bits
refieren
permiso
búsqueda
permiso
ejecutar
directorio
rwxr-xr-x
permite
propietario
leer
modificar
bús-
quedas
directorio
permite
leer
buscar
agregar
elimi-
nar
archivos
archivos
especiales
corresponden
dispositivos
bits
protección
archivos
regulares
mecanismo
utilizar
limitar
acceso
dispositivos
S.
ejemplo
archivo
especial
impresora
/dev
lp
propiedad
usuario
root
usuario
especial
demonio
rw------
evitar
alguien
acceso
impresora
cualquiera
pudiera
imprimir
volun-
tad
produciría
caos
demonio
propietario
/dev
lp
protección
rw------
significa
impresora
salvaría
árboles
inocentes
muerte
anticipada
usuarios
necesidad
legítima
imprimir
problema
general
permitir
acceso
controlado
dis-
positivos
recursos
sistema
problema
resolvió
agregar
bit
protección
bit
SETUID
bits
protección
descritos
ejecuta
programa
bit
SETUID
activado
UID
efectivo
proceso
convierte
UID
propietario
archivo
ejecutable
UID
usuario
invocó
proceso
abrir
archivo
comprueba
UID
efectivo
UID
real
subyacente
programa
utiliza
impresora
propie-
dad
demonio
bit
SETUID
encendido
usuario
utilizarlo
804
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meCAPÍTULO
10.7
SEGURIDAD
LINUX
805
demonio
ejemplo
acceso
/dev
lp
ejecutar
programa
trabajos
impresión
cola
imprimir
forma
ordenada
programas
sensibles
Linux
propiedad
usuario
root
activado
bit
SETUID
ejemplo
programa
permite
usuarios
modificar
contraseñas
pass-
wd
necesita
escribir
archivo
contraseñas
conveniente
mundo
pudiera
escribir
archivo
contraseñas
programa
propiedad
usuario
root
activado
bit
SETUID
programa
acceso
completo
archivo
contraseñas
modificará
contraseña
llama
permitirá
tipo
acceso
archivo
contraseñas
bit
SETUID
bit
SETGID
trabaja
forma
similar
otorga
ma-
nera
temporal
GID
efectivo
programa
usuario
bit
utiliza
raras
práctica
10.7.2
Llamadas
sistema
seguridad
Linux
pequeño
número
llamadas
sistema
relacionadas
seguridad
impor-
tantes
listan
figura
10-38
llamada
sistema
seguridad
utiliza
fre-
cuencia
chmod
utiliza
cambiar
protección
ejemplo
chmod(“/usr
ast
nuevojuego
0755
establece
permisos
nuevojuego
rwxr-xr-x
puedan
ejecutarlo
observe
0755
constante
octal
conveniente
bits
protección
vienen
grupos
bits
propietario
archivo
superusuario
modificar
bits
protección
Llamada
sistema
Descripción
chmod(ruta
Cambia
protección
archivo
access(ruta
Comprueba
acceso
usando
UID
GID
reales
uid
getuid
Obtiene
UID
real
uid
geteuid
Obtiene
UID
efectivo
gid
getgid
Obtiene
GID
real
gid
getegid
Obtiene
GID
efectivo
chown(ruta
propietario
grupo
Cambia
propietario
grupo
setuid(uid
Establece
UID
setgid(gid
Establece
GID
Figura
10-38
llamadas
sistema
relacionadas
seguridad
código
retorno
/H110021
ocurrió
error
uidy
gid
UID
GID
respectivamente
parámetros
explican
llamada
accessprueba
permite
acceso
específico
UID
GID
verdaderos
llamada
sistema
necesita
evitar
fugas
seguridad
programas
activo
bit
SETUID
propiedad
usuario
root
programa
www.FreeLibros.mecualquier
cosa
necesario
programa
averiguar
permite
usuario
rea-
lizar
acceso
programa
probarlo
acceso
éxito
llamada
access
programa
averiguar
permite
acceso
UID
GID
reales
siguientes
llamadas
sistema
devuelven
UID
GID
efectivos
permiten
superusuario
Modifican
propietario
archivo
valores
UID
GID
proceso
10.7.3
Implementación
seguridad
Linux
usuario
inicia
sesión
programa
inicio
sesión
login
SETUID
root
pide
nombre
inicio
sesión
contraseña
Aplica
función
hash
contraseña
busca
archivo
contraseñas
/etc
passwd
hash
coincide
contraseña
archivo
sistemas
red
funcionan
distinta
razón
utilizar
hashes
evitar
almacene
contraseña
forma
cifrada
sistema
contraseña
correcta
programa
inicio
sesión
busca
/etc
passwd
nombre
shell
preferido
usuario
posiblemente
bash
shell
csh
ksh
programa
inicio
sesión
utiliza
setuidy
setgidpara
darse
UID
GID
usuario
recuerde
empezó
SETUID
root
abre
teclado
entrada
estándar
descriptor
archivo
pantalla
salida
estándar
descriptor
archivo
pantalla
error
estándar
descriptor
archivo
ejecuta
shell
preferi-
do
termina
punto
shell
preferido
ejecutando
UID
GID
correctos
entrada
salida
error
estándar
valores
predeterminados
procesos
bifurquen
comandos
escriba
usuario
heredan
automática
UID
GID
shell
propietario
grupo
correctos
archivos
creen
obtendrán
valores
proceso
intenta
abrir
archivo
sistema
comprueba
bits
protección
nodo-i
archivo
compara
UID
GID
efectivos
lla-
mada
permite
acceso
archivo
abre
devuelve
descriptor
archivo
caso
contrario
archivo
abre
devuelve
/H110021
realizan
comproba-
ciones
siguientes
llamadas
reado
write
consecuencia
protección
cambia
abre
archivo
afectará
procesos
tengan
archivo
abierto
esencia
modelo
seguridad
Linux
implementación
iguales
mayo-
ría
sistemas
UNIX
tradicionales
10.8
RESUMEN
Linux
empezó
vida
clon
UNIX
completo
código
fuente
abierto
utili-
za
máquinas
computadoras
notebook
supercomputadoras
inter-
faces
Linux
shell
biblioteca
llamadas
sistema
utiliza
806
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meSECCIÓN
10.8
RESUMEN
807
interfaz
gráfica
usuario
simplificar
interacción
usuario
sistema
shell
permite
usuarios
escribir
comandos
ejecutarlos
comandos
simples
tu-
berías
estructuras
complejas
entrada
salida
redirigir
biblioteca
contiene
llamadas
sistema
llamadas
mejoradas
printf
escribir
sa-
lida
formato
archivos
interfaz
actual
llamadas
sistema
dependiente
ar-
quitectura
plataformas
x86
consiste
250
llamadas
necesario
conceptos
clave
Linux
incluyen
proceso
modelo
memoria
sistema
archivos
procesos
bifurcar
subprocesos
produce
árbol
proce-
sos
administración
procesos
Linux
distinta
comparación
sistemas
UNIX
Linux
entidad
ejecución
proceso
hilo
hilo
proceso
multihilo
kernel
tarea
distinguible
proceso
tarea
general
representa
componentes
clave
estructura
tarea
in-
formación
adicional
describe
espacio
direcciones
usuario
memoria
datos
componente
paginar
memoria
creación
procesos
cabo
duplicación
estructura
tarea
proceso
establece
información
imagen
memoria
apunte
imagen
me-
moria
padre
copias
actuales
páginas
imagen
memoria
crean
permite
compartición
requiere
modificación
memoria
mecanismo
co-
noce
copiar
escribir
programación
realiza
algoritmo
basado
prioridades
favorece
procesos
interactivos
modelo
memoria
consiste
segmentos
proceso
texto
datos
pila
adminis-
tración
memoria
realiza
paginación
mapa
memoria
registro
página
demonio
paginación
utiliza
algoritmo
reloj
doble
mane-
cilla
modificado
mantener
suficientes
páginas
libres
mano
acceder
dispositivos
archivos
especiales
tie-
ne
número
dispositivo
número
dispositivo
menor
dispositivos
bloques
utiliza
memoria
principal
colocar
caché
bloques
disco
reducir
núme-
ro
accesos
caracteres
crudo
flujos
ca-
racteres
modificar
disciplinas
línea
dispositivos
red
tratan
distinta
asociar
módulos
protocolo
red
completos
procesar
flujo
pa-
quetes
red
proceso
usuario
sistema
archivos
jerárquico
archivos
directorios
discos
montan
árbol
directorios
empieza
raíz
única
archivos
individuales
vincu-
lar
directorio
sistema
archivos
utilizar
archivo
abrir
produce
descriptor
archivo
usarlo
operaciones
lec-
tura
escritura
archivo
interior
sistema
archivos
utiliza
tablas
principales
tabla
descriptores
archivos
tabla
descripción
archivos
abiertos
tabla
nodos-i
importante
tablas
contiene
información
administrativa
archivo
ubicación
bloques
directorios
dispositivos
represen-
archivos
archivos
especiales
protección
basa
control
acceso
lectura
escritura
ejecución
propie-
tario
grupo
directorios
bit
ejecución
indica
permiso
búsqueda
www
FreeLibros.mePROBLEMAS
directorio
contiene
siguientes
archivos
archivos
listará
comando
ls
abc]*e
tubería
pipe
shell
Linux
grep
nd
xyz
wc
Escriba
tubería
Linux
imprima
octava
línea
archivo
salida
estándar
Linux
distingue
salida
estándar
error
estándar
terminal
co-
mo
valor
predeterminado
usuario
terminal
escribe
siguientes
comandos
shell
procese
procesos
ejecución
shell
Linux
empieza
proceso
coloca
copias
variables
entorno
HOME
pila
proceso
averiguar
directorio
inicio
proceso
bifurca
hijo
obtendrá
automática
variables
Determine
tiempo
requiere
sistema
UNIX
tradicional
bifurcar
proceso
hijo
siguientes
condiciones
tamaño
texto
100
KB
tamaño
datos
20
KB
tamaño
pila
10
KB
estructura
tarea
KB
estructura
usuario
KB
trampa
kernel
retorno
requieren
mseg
máquina
copiar
palabra
32
bits
50
nseg
segmentos
texto
compartidos
datos
pila
medida
programas
megabytes
comunes
tiempo
invertido
ejecutar
llamada
sistema
forky
copiar
segmentos
datos
pila
proceso
hacía
llamada
aumentó
forma
proporcional
ejecuta
forken
Linux
copia
espa-
cio
direcciones
padre
indica
semántica
tradicional
fork
evita
Linux
hijo
haga
cambiaría
completo
semántica
fork
sentido
quitar
memoria
proceso
entra
zombie
10
cree
diseñadores
Linux
imposible
proceso
en-
viar
señal
proceso
esté
grupo
procesos
808
CASO
ESTUDIO
LINUX
CAPÍTULO
10
aardvark
feret
koala
porpoise
bonefish
grunion
llama
quacker
capybara
hyena
marmot
rabbit
dingo
ibex
nuthatch
seahorse
emu
jellyfish
ostrich
tuna
www
FreeLibros.meCAPÍTULO
10
PROBLEMAS
809
11
llamada
sistema
general
implementa
instrucción
interrup-
ción
trampa
software
utilizar
procedimiento
ordinario
forma
hard-
ware
Pentium
condiciones
caso
contrario
12
general
piensa
demonios
menor
prioridad
procesos
inte-
ractivos
13
bifurca
proceso
asignar
entero
único
PID
Basta
contador
kernel
incremente
creación
proceso
utilice
contador
PID
Explique
respuesta
14
entrada
proceso
estructura
tarea
almacena
PID
padre
15
combinación
bits
banderas_compart
utiliza
comando
clonede
Linux
correspon-
llamada
forken
UNIX
convencional
crear
hilo
UNIX
convencional
16
programador
Linux
pasó
revisión
kernel
2.4
2.6
programador
actual
tomar
decisiones
programación
tiempo
O(1
Explique
pasa
17
iniciar
Linux
mayoría
sistemas
operativos
cuestión
cargador
arran-
bootstrap
sector
disco
carga
programa
inicio
carga
sistema
operativo
necesario
paso
adicional
duda
sencillo
cargador
arranque
sector
simplemente
cargara
sistema
operativo
directamente
18
editor
100
KB
texto
programa
30
KB
datos
inicializados
50
KB
BSS
pila
inicial
10
KB
Suponga
inician
copias
editor
tiempo
Cuán-
ta
memoria
física
requiere
utiliza
texto
compartido
utiliza
19
necesarias
tablas
descriptores
páginas
Linux
20
Linux
segmentos
datos
pila
paginan
intercambian
copia
reutilizable
mantiene
disco
partición
paginación
especial
segmento
texto
utiliza
ar-
chivo
binario
ejecutable
21
Describa
forma
mmapy
señales
construir
mecanismo
comunicación
procesos
22
archivo
asigna
llamada
sistema
mmap
mmap
65536
32768
READ
FLAGS
fd
páginas
KB
byte
accede
archivo
leer
byte
dirección
me-
moria
72,000
23
ejecutar
llamada
sistema
problema
realiza
llamada
munmap(65536
8192
éxito
bytes
archivo
permanecen
asignados
caso
contrario
fracasó
24
fallo
página
ocasionar
proceso
falló
termine
proporcione
ejemplo
caso
contrario
www
FreeLibros.me25
sistema
colegas
administrar
memoria
dé
caso
co-exis-
bloques
adyacentes
memoria
libre
tamaño
combinarse
bloque
explique
caso
contrario
muestre
imposible
26
texto
declara
partición
paginación
desempeño
archivo
paginación
27
Proporcione
ejemplos
ventajas
nombres
rutas
relativas
comparación
rutas
absolutas
28
colección
procesos
realiza
siguientes
llamadas
bloqueo
llamada
explique
ocurre
proceso
obtener
bloqueo
archivo
bloquea
desea
bloqueo
compartido
bytes
10
desea
bloqueo
exclusivo
bytes
20
30
desea
bloqueo
compartido
bytes
40
desea
bloqueo
compartido
bytes
25
35
desea
bloqueo
exclusivo
byte
29
Considere
archivo
bloqueado
figura
10-26(c
Suponga
proceso
bloquear
bytes
10
11
bloquea
libere
bloqueo
proceso
blo-
quear
bytes
10
11
bloquea
tipos
problemas
introducen
semán-
tica
situación
Proponga
defienda
soluciones
30
Suponga
llamada
sistema
lseekbusca
datos
desplazamiento
negativo
archi-
vo
Mencione
formas
posibles
lidiar
31
archivo
Linux
protección
755
octal
propietario
grupo
propietario
archivo
32
unidades
cinta
bloques
enumerados
habilidad
sobrescribir
bloque
es-
pecífico
lugar
perturbar
bloques
frente
dis-
positivo
contener
sistema
archivos
Linux
montado
33
figura
10-24
Fred
Lisa
acceso
archivo
respectivos
directorios
vinculación
acceso
completamente
simétrico
sentido
cualquie-
ra
archivo
34
visto
nombres
rutas
absolutas
buscan
empezando
directorio
raíz
nombres
rutas
relativas
buscan
directorio
trabajo
Sugiera
eficien-
implementar
tipos
búsquedas
35
abrir
archivo
/usr
ast
trabajo
requieren
accesos
disco
leer
nodo-i
bloques
directorios
Calcule
número
accesos
disco
requeridos
suponiendo
nodo-i
directorio
raíz
memoria
directorios
bloque
36
nodo-i
Linux
12
direcciones
disco
bloques
datos
direccio-
nes
bloques
indirectos
sencillos
dobles
triples
bloques
contiene
256
di-
recciones
disco
tamaño
archivo
manejar
suponiendo
bloque
disco
KB
37
lee
nodo-i
disco
proceso
abrir
archivo
coloca
tabla
nodos-i
memoria
tabla
campos
presentes
disco
810
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.meCAPÍTULO
10
PROBLEMAS
811
contador
número
abierto
nodo-i
necesita
campo
38
plataformas
CPUs
Linux
mantiene
estructura
cola
ejecución
runqueue
CPU
ida
Explique
respuesta
39
hilos
pdflush
despertar
forma
periódica
escribir
disco
páginas
an-
tiguas
30
segundos
necesario
40
falla
sistema
reinicia
general
ejecuta
programa
recuperación
Suponga
programa
descubre
vínculos
nodo-i
disco
pe-
ro
entrada
directorio
referencia
nodo-i
corregir
problema
haría
41
Haga
conjetura
llamada
sistema
Linux
rápida
42
desvincular
archivo
vinculado
ocurre
43
base
información
presentada
capítulo
colocara
sistema
archivos
ext2
Linux
disco
flexible
1.44
Mbyte
cantidad
máxima
datos
archivos
usuario
almacenar
disco
Suponga
bloques
disco
KB
44
vista
problema
ocasionar
estudiantes
llegan
superusuarios
concepto
lugar
45
profesor
comparte
archivos
estudiantes
colocarlos
directorio
acceso
públi-
co
sistema
Linux
departamento
ciencias
computacionales
archivo
colocó
permiso
escritura
mundo
Cambia
permisos
verifica
archivo
idéntico
copia
maestra
des-
cubre
archivo
modificado
ocurrido
hubiera
podido
evitar
46
Linux
admite
sistema
llamado
fsuid
diferencia
setuid
otorga
usuario
per-
misos
id
efectivo
asociado
programa
ejecutando
fsuidotorga
usuario
ejecuta
programa
permisos
especiales
acceso
archivos
útil
característica
47
Escriba
shell
simplificado
permita
iniciar
comandos
simples
permitir
iniciar-
plano
48
Utilice
lenguaje
ensamblador
llamadas
BIOS
escribir
programa
inicie
mis-
mo
disco
flexible
computadora
clase
Pentium
programa
utilizar
llamadas
BIOS
leer
teclado
eco
caracteres
escritos
demostrar
ejecu-
tando
49
Escriba
programa
terminal
tonta
conectar
computadoras
Linux
puertos
seriales
Use
llamadas
administración
terminales
POSIX
configurar
puertos
50
Escriba
aplicación
cliente
servidor
petición
transfiera
archivo
extenso
soc-
kets
Vuelva
implementar
aplicación
utilizando
memoria
compartida
versión
es-
pera
rendimiento
Realice
mediciones
rendimiento
código
escribió
utilizando
distintos
tamaños
archivos
observaciones
cree
ocurra
kernel
Linux
produzca
comportamiento
www
FreeLibros.me51
Implemente
biblioteca
básica
subprocesos
nivel
usuario
ejecute
Linux
API
biblioteca
contener
llamadas
funciones
mythreads_init
mythreads-
create
mythreads_join
mythreads_exit
mythreads_yield
mythreads_selfy
implemente
variables
sincronización
permitir
operaciones
con-
currentes
seguras
mythreads_mutex_init
mythreads_mutex_lock
mythreads_mutex_unlock
iniciar
defina
claridad
API
especifique
semántica
llamadas
implemente
biblioteca
nivel
usuario
planificador
preferente
turno
rotativo
round-robin
apropiativo
necesitará
escribir
aplicaciones
multihilo
utili-
cen
biblioteca
probarla
reemplace
mecanismo
planificación
apro-
piativa
comporte
planificador
O(1
Linux
2.6
descrito
capítulo
Compare
rendimiento
recibe(n
su(s
aplicación(es
utilizar
planificadores
812
CASO
ESTUDIO
LINUX
CAPÍTULO
10
www
FreeLibros.me11
CASO
ESTUDIO
WINDOWS
VISTA
813
Windows
sistema
operativo
moderno
ejecuta
PCs
escritorio
consumido-
res
negocios
servidores
empresariales
versión
escritorio
reciente
Windows
Vista
versión
servidor
Windows
Vista
conoce
Windows
Server
2008
capítulo
examinaremos
aspectos
Windows
Vista
empezaremos
historia
pasaremos
arquitectura
analizaremos
procesos
administración
memoria
caché
sistema
archivos
seguridad
11
HISTORIA
WINDOWS
VISTA
desarrollo
sistema
operativo
Microsoft
Windows
PCs
servidores
dividir
MS-DOS
Windows
basado
MS-DOS
Windows
basado
NT
Técnicamente
sistemas
distinto
sistema
dominó
duran-
distintas
décadas
historia
computadora
personal
figura
11-1
muestra
fechas
liberación
versiones
mayores
sistema
operativo
Microsoft
computadoras
es-
critorio
omitimos
popular
versión
Microsoft
Xenix
basada
UNIX
Microsoft
vendió
Santa
Cruz
Operation
SCO
1987
continuación
presentaremos
bosquejo
sintetizado
muestran
tabla
www
FreeLibros.me11.1.1
1980
MS-DOS
principios
década
1980
IBM
momento
empresa
computadoras
poderosa
mundo
desarrollando
computadora
personal
basada
mi-
croprocesador
Intel
8088
mediados
década
1970
Microsoft
convirtió
pro-
veedor
principal
lenguaje
programación
BASIC
microcomputadoras
bits
basadas
8080
Z-80
IBM
pidió
Microsoft
licencia
BASIC
IBM
PC
Microsoft
sugirió
IBM
pusiera
contacto
Digital
Re-
search
obtener
licencia
sistema
operativo
CP
Microsoft
es-
taba
negocio
sistemas
operativos
IBM
presidente
Gari
Kildall
Digital
Research
ocupado
reunirse
IBM
regresó
Microsoft
Microsoft
compró
clon
CP
empresa
local
Seattle
Compu-
ter
Products
portó
IBM
PC
otorgó
licencia
IBM
cambió
nombre
MS-DOS
1.0
MicroSoft
Disk
Operating
System
Sistema
operativo
disco
Microsoft
in-
cluyó
IBM
PC
1981
MS-DOS
sistema
operativo
línea
comandos
16
bits
real
usuario
consistía
KB
código
residente
memoria
década
PC
MS-
continuaron
evolución
incorporando
características
herramientas
1986
cuan-
do
IBM
construyó
PC
AT
base
Intel
286
MS-DOS
crecido
36
KB
seguía
sistema
operativo
operado
línea
comandos
capaz
ejecutar
aplicación
814
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Windows
basado
Windows
basado
Año
MS-DOS
MS-DOS
NT
Observaciones
1981
MS-DOS
1.0
Liberación
inicial
IBM
PC
1983
MS-DOS
2.0
Soporte
PC
XT
1984
MS-DOS
3.0
Soporte
PC
AT
1990
Windows
3.0
millones
copias
años
1991
MS-DOS
5.0
administración
memoria
1992
Windows
3.1
ejecuta
286
posteriores
1993
Windows
NT
3.1
1995
MS-DOS
7.0
Windows
95
MS-DOS
incrustado
Win
95
1996
Windows
NT
4.0
1998
Windows
98
2000
MS-DOS
8.0
Windows
Windows
2000
Win
inferior
Win
98
2001
Windows
XP
Reemplazó
Windows
98
2006
Windows
Vista
Figura
11-1
Liberaciones
versiones
mayores
historia
sistemas
opera-
tivos
Microsoft
PCs
escritorio
www
FreeLibros.meSECCIÓN
11.1
HISTORIA
WINDOWS
VISTA
815
11.1.2
1990
Windows
basado
MS-DOS
Inspirado
interfaz
gráfica
usuario
sistemas
investigación
Stanford
Research
Ins-
titute
Xerox
PARC
progenie
comercial
computadoras
Lisa
Macintosh
Apple
Microsoft
decidió
proveer
MS-DOS
interfaz
gráfica
usuario
deno-
minó
Windows
primeras
versiones
Windows
1985
1987
tuvieron
éxi-
to
limitaciones
hardware
PC
disponible
momento
1990
Microsoft
liberó
Windows
3.0
Intel
386
vendió
millón
copias
meses
Windows
3.0
sistema
operativo
entorno
gráfico
construyó
MS-DOS
control
máquina
sistema
archivos
pro-
gramas
ejecutaban
espacio
direcciones
error
cualquiera
podía
provocar
sistema
detuviera
agosto
1995
liberó
Windows
95
contenía
características
sis-
tema
operativo
completo
incluyendo
memoria
virtual
administración
procesos
multiprogra-
mación
introdujo
interfaces
programación
32
bits
faltaba
seguridad
ofrecía
aislamiento
pobre
aplicaciones
sistema
operativo
ende
problemas
inestabilidad
continuaron
liberaciones
subsecuentes
Windows
98
Windows
MS-DOS
seguía
ejecutando
código
ensamblador
16
bits
corazón
sistema
operativo
Windows
11.1.3
2000
Windows
basado
NT
finales
década
1980
Microsoft
continuar
desarrollo
siste-
ma
operativo
MS-DOS
componente
central
forma
hard-
ware
PC
seguía
aumentando
velocidad
capacidad
mercado
PCs
entraría
conflicto
servidores
empresariales
estaciones
trabajo
escritorio
UNIX
dominaba
Microsoft
preocupaba
familia
micropro-
cesadores
Intel
seguiría
competitiva
arquitecturas
RISC
re-
presentaban
reto
lidiar
Microsoft
reclutó
grupo
ingenieros
DEC
dirigido
Dave
Cutler
diseñadores
clave
sistema
operativo
VMS
DEC
Cu-
tler
designado
desarrollar
sistema
operativo
32
bits
intención
im-
plementar
OS/2
API
sistema
operativo
Microsoft
desarrollando
conjunto
IBM
documentos
diseño
originales
equipo
Cutler
llamó
sis-
tema
NT
OS/2
sistema
Cutler
llamó
NT
Tecnología
procesador
destino
original
Intel
860
nombre
clave
N10
NT
diseñó
pudiera
portarse
distintos
procesadores
énfasis
seguridad
confiabilidad
fue-
ra
compatible
versiones
Windows
basadas
figura
11-2
muestra
traba-
jo
desarrollado
Cutler
DEC
similitud
pasajera
diseño
NT
VMS
sistemas
operativos
diseñados
www
FreeLibros.meCuando
ingenieros
DEC
abogados
vieron
similitud
NT
VMS
sucesor
MICA
liberó
produjo
discusión
DEC
Mi-
crosoft
relación
propiedad
intelectual
DEC
problema
resolvió
últi-
ma
instancia
corte
Microsoft
soporte
NT
DEC
Alpha
periodo
suficiente
salvar
DEC
obsesión
minicomputadoras
desdén
computadoras
personales
tipificado
comentario
1977
Ken
Olsen
fundador
DEC
razón
alguien
desearía
computadora
sic
hogar
1998
quedaba
DEC
vendió
Compaq
comprada
Hewlett-Packard
programadores
familiarizados
UNIX
encuentran
arquitectura
NT
distinta
influencia
VMS
diferencias
sistemas
cómputo
comunes
época
diseño
UNIX
diseñó
prime-
ra
década
1970
sistemas
intercambio
procesador
16
bits
memoria
proceso
unidad
concurrencia
composición
fork
exec
operaciones
requerían
recursos
sistemas
intercambio
copian
fre-
cuencia
procesos
disco
formas
NT
diseñó
principios
década
1990
comunes
sistemas
multiprocesador
32
bits
megabytes
memoria
vir-
tual
NT
hilos
unidad
concurrencia
bibliotecas
dinámicas
unidades
composición
operaciones
fork
exec
implementan
operación
crear
proceso
ejecutar
programa
copia
versión
Windows
basado
NT
Windows
NT
3.1
liberó
1993
llamó
3.1
corresponder
actual
Windows
3.1
consumidor
proyecto
conjun-
to
IBM
hundido
daba
soporte
interfaces
OS/2
interfa-
ces
primarias
extensiones
32
bits
APIs
Windows
conocidas
Win32
tiempo
inició
NT
tiempo
embarque
liberado
Windows
3.0
éxito
comercial
podía
ejecutar
programas
Win32
me-
diante
biblioteca
compatibilidad
Win32s
versión
Windows
basado
MS-DOS
Windows
basado
NT
éxito
principio
NT
requería
memoria
aplicaciones
disponibles
32
bits
incompatibilidades
drivers
dispositivos
aplicaciones
provocaron
mu-
chos
clientes
prefirieran
Windows
basado
MS-DOS
Microsoft
seguía
mejorando
liberó
Windows
95
1995
sistema
operativo
proveía
interfaces
programación
nativas
32
bits
NT
compatibilidad
software
aplicaciones
16
bits
existentes
816
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Año
Sistema
operativo
DEC
Características
1973
RSX-11
16
bits
multiusuario
tiempo
real
intercambios
1978
VAX
VMS
32
bits
memoria
virtual
1987
VAXELAN
Tiempo
real
1988
PRISM
Mica
canceló
favor
MIPS
Ultrix
Figura
11-2
sistemas
operativos
DEC
desarrollados
Dave
Cutler
www
FreeLibros.meSECCIÓN
11.1
HISTORIA
WINDOWS
VISTA
817
sorprende
éxito
anticipado
NT
mercado
servidores
com-
petencia
VMS
NetWare
NT
cumplió
objetivos
portabilidad
versiones
adicionales
liberaron
1994
1995
agregaron
soporte
arquitecturas
MIPS
little-endian
PowerPC
actua-
lización
importante
NT
indows
NT
4.0
1996
sistema
potencia
se-
guridad
confiabilidad
NT
interfaz
usuario
popular
Windows
95
figura
11-3
muestra
relación
API
Win32
Windows
importante
API
común
Windows
basado
MS-DOS
Windows
NT
tuviera
éxito
compatibilidad
facilitó
considerable
usuarios
migración
Windows
95
NT
sistema
operativo
convirtió
participante
sólido
mercado
compu-
tadoras
escritorio
alto
rendimiento
servidores
clien-
tes
dispuestos
adoptar
arquitecturas
procesadores
Windows
NT
4.0
compatible
1996
DEC
Alpha
versión
x86
familia
Pentium
activa
lanzó
versión
Windows
2000
Programa
aplicación
Win32
Interfaz
programación
aplicaciones
Win32
Windows
3.x
Windows
95/98/98SE
Windows
NT/2000
XP
Vista
Win32s
Figura
11-3
API
Win32
permite
ejecutar
programas
versiones
Windows
Windows
2000
representó
evolución
considerable
NT
tecnologías
clave
agregaron
plug-and-play
consumidores
instalaban
tarjeta
PCI
eliminaba
necesidad
experimentar
jumpers
servicios
directorio
red
clientes
empresariales
administración
energía
mejorada
portátiles
GUI
mejorada
éxito
técnico
Windows
2000
Microsoft
empezó
presionar
dejar
utilizar
Windows
98
mejorar
compatibilidad
aplicaciones
dispositivos
versión
NT
Windows
XP
sistema
operativo
incluía
apariencia
amigable
inter-
faz
gráfica
reforzar
estrategia
Microsoft
enganchar
consumidores
presionaran
empleadores
adoptaran
sistemas
familiarizados
es-
trategia
exitosa
abrumadora
Windows
XP
instaló
cientos
millones
PCs
años
permitió
Microsoft
lograr
objetivo
terminar
efectividad
Windows
basado
MS-DOS
www
FreeLibros.meWindows
XP
representaba
realidad
desarrollo
Microsoft
versiones
se-
paradas
clientes
escritorio
servidores
empresariales
sistema
complejo
producir
versiones
cliente
servidor
alta
calidad
tiempo
Win-
dows
2003
versión
servidor
complementaba
sistema
operativo
cliente
Windows
XP
Ofrecía
soporte
Intel
Itanium
64
bits
IA64
Service
Pack
soporte
pa-
ra
arquitectura
x64
AMD
servidores
equipos
escritorio
Microsoft
utilizó
tiempo
liberaciones
versiones
cliente
servidor
agregar
característi-
cas
específicas
servidor
pruebas
exhaustivas
enfocadas
aspectos
sistema
principalmente
negocios
figura
11-4
muestra
relación
versiones
cliente
servidor
Windows
818
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Año
Versión
cliente
Año
Versión
servidor
1996
Windows
NT
1996
Windows
NT
Server
1999
Windows
2000
1999
Windows
2000
Server
2001
Windows
XP
2003
Windows
Server
2003
2006
Windows
Vista
2007
Windows
Server
2008
Figura
11-4
Versiones
separadas
cliente
servidor
Windows
Microsoft
seguimiento
Windows
XP
embarcarse
versión
ambiciosa
desper-
tar
emoción
renovada
consumidores
PCs
resultado
Windows
Vista
completó
finales
2006
años
Windows
XP
embarcara
pri-
mera
Windows
Vista
jactaba
diseño
interfaz
gráfica
características
seguridad
interior
mayoría
cambios
realizaron
experiencias
herramien-
tas
visibles
consumidor
tecnologías
sistema
mejoraron
forma
incre-
mental
limpieza
código
mejoras
rendimiento
escalabilidad
confiabilidad
versión
servidor
Vista
Windows
Server
2008
salió
mercado
año
des-
pués
versión
consumidor
Comparte
componentes
básicos
sistema
co-
mo
kernel
drivers
bibliotecas
nivel
programas
Vista
historia
humana
años
desarrollo
NT
relata
libro
Showstop-
per
Zachary
1994
libro
personas
clave
involucradas
dificultades
asumir
proyecto
desarrollo
software
ambicioso
11.1.4
Windows
Vista
liberación
Windows
Vista
culminó
proyecto
extenso
sistema
operativo
Mi-
crosoft
fecha
planes
iniciales
ambiciosos
años
empezar
de-
sarrollo
Vista
reiniciar
menor
alcance
planes
basarse
lenguaje
.NET
seguridad
tipos
recolección
basura
Microsoft
pospusieron
características
considerables
sistema
almacenamiento
unificado
WinFS
buscar
organizar
datos
fuentes
distintas
tamaño
sistema
opera-
tivo
completo
pasmoso
versión
original
NT
millones
líneas
C++
www
FreeLibros.meSECCIÓN
11.2
PROGRAMACIÓN
WINDOWS
VISTA
819
aumentado
16
millones
NT
30
millones
Windows
2000
50
millones
XP
Vis-
ta
alcanzó
70
millones
líneas
tamaño
énfasis
Microsoft
agregar
caracte-
rísticas
productos
versión
directorio
system32
principal
1600
bibliotecas
vínculos
dinámicos
DLLs
400
ejecutables
EXEs
incluir
directorios
contie-
nen
multitud
applets
incluidos
sistema
operativo
permiten
usuarios
navegar
Web
reproducir
música
video
enviar
correo
electrónico
digitalizar
documentos
organizar
fo-
tografías
películas
Microsoft
desea
clientes
cambien
versiones
mantiene
compatibilidad
mantener
general
características
APIs
ap-
plets
pequeñas
aplicaciones
etc.
versión
raro
eliminen
cosas
re-
sultado
Windows
crece
forma
notoria
versión
tecnología
mantenido
par
medios
distribución
Windows
cambiado
disco
flexible
CD
Windows
Vista
DVD
aumento
características
applets
Windows
comparaciones
ta-
maño
significativas
sistemas
operativos
problemáticas
difícil
deci-
dir
definición
forma
sistema
operativo
niveles
inferiores
sistemas
operativos
correspondencia
funciones
realizan
similares
diferencia
tamaño
Windows
figura
11-5
comparan
kernels
Windows
Linux
áreas
funcionales
clave
programación
CPU
infraestructura
memoria
virtual
componentes
Windows
componente
memoria
virtual
extenso
número
características
modelo
memoria
virtual
uti-
liza
técnicas
implementación
utilizan
código
tamaño
obtener
rendimiento
Área
kernel
Linux
Vista
Programador
CPU
50,000
75,000
Infraestructura
45,000
60,000
Memoria
virtual
25,000
175,000
Figura
11-5
Comparación
líneas
código
módulos
kernel
Linux
Windows
Mark
Russinovich
co-autor
Microsoft
Windows
In-
ternals
11.2
PROGRAMACIÓN
WINDOWS
VISTA
momento
empezar
estudio
técnico
Windows
Vista
entrar
detalles
estructura
interna
analizaremos
API
NT
nativa
llamadas
siste-
ma
subsistema
programación
Win32
disponibilidad
POSIX
código
escrito
Windows
utiliza
Win32
directamente
.NET
ejecu-
ta
Win32
www
FreeLibros.meLa
figura
11-6
muestra
niveles
Sistema
operativo
Windows
niveles
applet
GUI
Windows
interfaces
programación
basan
aplica-
ciones
mayoría
sistemas
operativos
consisten
bibliote-
cas
código
DLLs
programas
vinculan
dinámica
acceder
características
sistema
operativo
Windows
incluye
interfaces
programación
implementan
servicios
ejecutan
procesos
separados
aplicacio-
nes
comunican
servicios
usuario
llamadas
procedimientos
re-
motos
RPC
820
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
usuario
kernel
Applets
pequeños
ejecutables
Win32
GUI
shell32.dll
user32.dll
gdi32.dll
API
NT
nativa
C++
tiempo
ejecución
ntdll.dll
Nivel
abstracción
hardware
hal.dll
Nivel
kernel
NTOS
ntoskrnl.exe
Nivel
ejecutivo
NTOS
ntoskrnl.exe
Proceso
subsistema
csrss
Driver
GUI
Win32k.sys
Servicios
NT
smss
Isass
services
winlogon
Drivers
dispositivos
sistemas
archivos
red
Bibliotecas
dinámicas
ole32.dll
rpc.dll
API
subsistema
kernel32.dll
advapi32I.dll
Figura
11-6
niveles
programación
Windows
núcleo
sistema
operativo
NT
programa
kernel
NTOS
ntoskrnl.exe
proporciona
interfaces
tradicionales
llamadas
sistema
base
construye
resto
sistema
operativo
Windows
programadores
Microsoft
escriben
ni-
vel
llamadas
sistema
interfaces
publicadas
usuario
pertenecen
perso-
nalidades
sistema
operativo
implementan
subsistemas
ejecutan
niveles
NTOS
principio
NT
admitía
personalidades
OS/2
POSIX
Win32
OS/2
descartó
Windows
XP
POSIX
eliminó
clientes
obtener
subsistema
POSIX
mejorado
llamado
Interix
Servicios
UNIX
SFU
Microsoft
infraestructura
soporte
POSIX
permanece
sistema
mayoría
aplicaciones
Windows
escriben
utilizar
Win32
Microsoft
acepta
APIs
diferencia
Win32
.NET
construye
subsistema
artificial
interfaces
kernel
nativas
NT
.NET
construye
modelo
programación
Win32
permite
.NET
interoperar
programas
existentes
Win32
nun-
ca
objetivo
subsistemas
POSIX
OS/2
API
WinFX
incluye
carac-
terísticas
Win32
funciones
Biblioteca
clase
base
WinFX
simplemente
envolturas
APIs
Win32
ventajas
WinFX
relacio-
nadas
complejidad
tipos
objetos
aceptados
interfaces
consistentes
simplifica-
www
FreeLibros.meSECCIÓN
11.2
PROGRAMACIÓN
WINDOWS
VISTA
821
das
Lenguaje
común
.NET
tiempo
ejecución
CLR
incluyendo
recolección
basura
muestra
figura
11-7
subsistemas
NT
crean
compo-
nentes
proceso
subsistema
conjunto
bibliotecas
ganchos
CreateProcess
so-
porte
kernel
proceso
subsistema
realidad
servicio
única
propiedad
especial
inicia
programa
smss.exe
administrador
sesión
programa
ini-
cial
usuario
NT
inicia
respuesta
petición
CreateProcess
Win32
API
correspondiente
subsistema
distinto
Proceso
subsistema
Proceso
programa
Bibliotecas
subsistema
Biblioteca
tiempo
ejecución
sistema
gancho
CreateProcess
Soporte
kernel
subsistema
Ejecutivo
NTOS
Llamada
procedimiento
local
LPC)Servicios
sistema
NT
nativo
usuario
kernel
API
NT
nativa
tiempo
ejecución
Figura
11-7
componentes
utilizan
crear
subsistemas
NT
conjunto
bibliotecas
implementa
funciones
sistema
operativo
nivel
especí-
ficas
subsistema
contiene
rutinas
resguardo
stub
comunican
pro-
cesos
subsistema
muestra
izquierda
proceso
subsistema
muestra
derecha
llamadas
proceso
subsistema
general
llevan
cabo
me-
diante
herramientas
LPC
Local
Procedure
Call
Llamada
procedimiento
local
kernel
implementan
llamadas
procedimientos
proceso
gancho
CreateProcessde
Win32
detecta
subsistema
requerido
programa
analizar
imagen
binaria
pide
smss.exe
empiece
proceso
crss.exe
subsiste-
ma
caso
esté
ejecución
proceso
subsistema
asume
responsa-
bilidad
cargar
programa
implementación
subsistemas
gancho
similar
ejemplo
llamada
sistema
execen
POSIX
kernel
NT
diseñó
herramientas
propósito
general
puedan
utilizar
escribir
subsistemas
específicos
sistema
operativo
código
espe-
cial
agregarse
implementar
subsistema
forma
correcta
ejemplos
llamada
sistema
nativa
NtCreateProcessimplementa
duplicación
procesos
soporte
llamada
sistema
forkde
POSIX
kernel
implementa
tipo
específico
tabla
www
FreeLibros.me822
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
cadenas
Win32
conocidas
átomos
permite
compartir
cadenas
lectura
eficiencia
proceso
procesos
subsistema
programas
nativos
NT
utilizan
llamadas
sistema
nativas
proporcionan
kernel
NT
servicios
básicos
smss.exe
lsass.exe
admi-
nistración
seguridad
local
llamadas
nativas
sistema
incluyen
herramientas
procesos
administrar
direcciones
virtuales
hilos
manejadores
excepciones
procesos
crean
ejecutar
programas
escritos
utilizar
subsistema
específico
11.2.1
Interfaz
programación
aplicaciones
NT
nativa
sistemas
operativos
Windows
Vista
conjunto
llamadas
sistema
Windows
Vista
llamadas
implementan
nivel
ejecutivo
NTOS
ejecuta
kernel
Microsoft
publicado
detalles
lla-
madas
nativas
sistema
programas
menor
nivel
envían
sistema
ope-
rativo
servicios
subsistemas
utilizan
llamadas
forma
interna
drivers
dispositivos
kernel
llamadas
sistema
nativas
NT
realidad
cambian
versión
Microsoft
optó
hacerlas
públicas
pa-
ra
aplicaciones
escritas
Windows
basen
Win32
probable
funcionen
sistemas
Windows
basados
MS-DOS
sistemas
Windows
basados
NT
API
Win32
común
mayoría
llamadas
sistema
nativas
NT
operan
objetos
kernel
tipo
incluyendo
archivos
procesos
hilos
tuberías
semáforos
etcétera
figura
11-8
muestra
lista
categorías
comunes
objetos
kernel
sopor-
tados
NT
Windows
Vista
analicemos
administrador
objetos
pro-
porcionaremos
detalles
tipos
objetos
específicos
Categoría
objetos
Ejemplos
Sincronización
Semáforos
mutexes
eventos
puertos
IPC
colas
compleción
Archivos
dispositivos
drivers
temporizadores
Programa
Trabajos
procesos
hilos
secciones
tokens
GUI
Win32
Escritorios
devolución
llamadas
aplicaciones
Figura
11.8
Categorías
comunes
tipos
objetos
kernel
término
objeto
relación
estructuras
datos
manipuladas
sistema
operativo
confuso
confunde
orientado
objetos
objetos
sistema
operativo
proporcionan
ocultamiento
abstracción
datos
carecen
al-
gunas
propiedades
básicas
sistemas
orientados
objetos
herencia
polimorfismo
API
nativa
NT
llamadas
disponibles
crear
objetos
kernel
acceder
objetos
existentes
llamada
crear
abrir
objeto
devuelve
resultado
conocido
manejador
proceso
llamada
utilizar
manejador
www
FreeLibros.meSECCIÓN
11.2
PROGRAMACIÓN
WINDOWS
VISTA
823
operaciones
objeto
manejadores
específicos
proceso
creó
general
manejadores
pasar
directa
proceso
utilizarse
referencia
objeto
circunstancias
dupli-
car
manejador
tabla
manejadores
procesos
protegida
permite
procesos
compartir
acceso
objetos
accesibles
espa-
cio
nombres
proceso
duplique
manejador
manejadores
pro-
ceso
origen
destino
objeto
asociado
descriptor
seguridad
indica
detalle
tipos
operaciones
objeto
base
acceso
solicitado
duplican
manejadores
procesos
agregar
restricciones
acceso
específicas
manejador
duplicado
forma
proceso
duplicar
manejador
lectura-escritura
convertirlo
versión
lectura
proceso
destino
estructuras
datos
creadas
sistema
objetos
obje-
tos
kernel
únicos
verdaderos
objetos
kernel
ne-
cesitan
denominar
proteger
compartir
forma
general
objetos
kernel
representan
tipo
abstracción
programación
implementa
kernel
Ca-
objeto
kernel
tipo
definido
sistema
operaciones
definidas
ocupa
almacenamiento
memoria
kernel
programas
usuario
pue-
den
operaciones
llamadas
sistema
acceder
datos
directa
figura
11-9
presenta
muestreo
APIs
nativas
utilizan
manejado-
res
explícitos
manipular
objetos
kernel
procesos
hilos
puertos
IPC
sec-
ciones
utilizan
describir
objetos
memoria
asignar
espacios
direcciones
NtCreateProcessdevuelve
manejador
objeto
proceso
recién
creado
representa
instancia
ejecución
programa
representado
SectionHandle
Debug-
PortHandlese
utiliza
comunicarse
depurador
otorga
control
proceso
excepción
ejemplo
división
cero
acceso
memoria
inválida
Except-
PortHandlese
utiliza
comunicarse
proceso
subsistema
ocurren
errores
és-
tos
manejan
depurador
adjunto
Figura
11-9
Ejemplos
llamadas
API
nativa
NT
utilizan
manejadores
manipular
objetos
límites
procesos
www
FreeLibros.me824
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
NtCreateThreadtoma
ProcHandledebido
crear
subproceso
pro-
ceso
proceso
llamada
manejador
suficientes
permisos
acceso
similar
NtAllocateVirtualMemory
NtMapViewOfSection
NtReadVirtualMemory
NtWriteVirtualMemorypermiten
proceso
opere
espacio
direccio-
nes
asigne
direcciones
virtuales
secciones
mapas
lea
escriba
memoria
virtual
procesos
NtCreateFilees
llamada
API
nativa
crear
abrir
archivo
NtDuplicateObjectes
llamada
API
duplicar
manejadores
proceso
objetos
kernel
únicos
Windows
sistemas
UNIX
admiten
variedad
objetos
kernel
archivos
sockets
red
tuberías
dispositivos
procesos
herramientas
comunicación
proceso
IPC
memo-
ria
compartida
puertos
mensajes
semáforos
dispositivos
S.
UNIX
variedad
formas
denominar
acceder
objetos
descriptores
archivos
IDs
pro-
ceso
IDs
enteros
objetos
IPC
System
nodos-i
dispositivos
imple-
mentación
clase
objetos
UNIX
específica
clase
archivos
sockets
utilizan
distintas
herramientas
mecanismos
procesos
dispositivos
IPC
System
objetos
kernel
Windows
utilizan
herramienta
uniforme
basada
manejadores
espacio
nombres
NT
referencia
objetos
kernel
implemen-
tación
unificada
administrador
objetos
centralizado
manejadores
corresponden
proceso
vimos
duplicarlos
administrador
objetos
permi-
otorgarles
nombres
momento
crearlos
abrirlos
nombre
obtener
maneja-
dores
administrador
objetos
utiliza
Unicode
caracteres
extensos
representar
nombres
espacio
nombres
NT
diferencia
UNIX
NT
general
distingue
letras
mayús-
culas
minúsculas
preserva
mayúsculas
minúsculas
insensible
mayúsculas
minúsculas
espacio
nombres
NT
colección
jerárquica
directorios
estructurada
forma
árbol
vínculos
simbólicos
objetos
administrador
objetos
ofrece
herramientas
unificadas
sincronización
seguridad
administración
tiempo
vida
objetos
decisión
herramien-
tas
generales
proporciona
administrador
objetos
estén
disponibles
usuarios
objeto
específico
responsabilidad
componentes
ejecutivos
pro-
porcionan
APIs
nativas
manipulan
tipo
objeto
administrador
objetos
administra
aplicaciones
utilizan
objetos
siste-
ma
operativo
crear
utilizar
objetos
frecuencia
ma-
yoría
objetos
crean
permitir
componente
sistema
almacene
información
periodo
considerable
pasar
estructura
datos
compo-
nente
beneficiarse
soporte
nomenclatura
tiempo
vida
administrador
ob-
jetos
ejemplo
descubre
objeto
crean
objetos
dispositivo
representar
dispositivo
describir
forma
lógica
conectado
dispositivo
resto
sistema
controlar
dispositivo
carga
driver
crea
objeto
driver
contie-
ne
propiedades
proporciona
apuntadores
funciones
implementa
procesar
pe-
ticiones
S.
sistema
operativo
referencia
driver
utiliza
objeto
acceder
driver
directa
nombre
www
FreeLibros.meSECCIÓN
11.2
PROGRAMACIÓN
WINDOWS
VISTA
825
indirecta
dispositivos
controla
ejemplo
establecer
parámetros
go-
biernan
operación
usuario
diferencia
UNIX
coloca
raíz
espacio
nombres
sistema
archivos
raíz
espacio
nombres
NT
mantiene
memoria
virtual
kernel
significa
NT
recrear
espacio
nombres
nivel
superior
inicia
sistema
memoria
virtual
kernel
permite
NT
almacenar
información
espacio
nombres
iniciar
sistema
archivos
ejecución
fácil
pa-
ra
NT
agregar
tipos
objetos
kernel
sistema
formatos
sistemas
archivos
modificar
tipo
objeto
objeto
nombre
marcar
permanente
significa
continúa
exis-
tiendo
elimina
explícita
sistema
reinicia
proceso
momento
manejador
objeto
Dichos
objetos
extender
es-
pacio
nombres
NT
proporcionar
rutinas
análisis
permitan
objetos
funcionar
forma
parecida
puntos
montaje
UNIX
sistemas
archivos
registro
utili-
zan
herramienta
montar
volúmenes
grupos
masivos
archivos
hives
espacio
nombres
NT
acceder
objeto
dispositivo
volumen
obtiene
acceso
volumen
puro
objeto
dispositivo
representa
montaje
implícito
volumen
es-
pacio
nombres
NT
acceder
archivos
individuales
volumen
concate-
nar
nombre
archivo
relativo
volumen
nombre
objeto
dispositivo
volumen
nombres
permanentes
utilizan
representar
objetos
sincronización
memoria
compartida
procesos
puedan
compartirlos
recrearlos
continua
medida
procesos
detengan
inicien
objetos
dispositivos
objetos
drivers
reciben
nombres
permanentes
obtienen
propiedades
persistencia
nodos-i
especiales
mantienen
directorio
/devde
UNIX
sección
describiremos
características
API
nativa
NT
analizaremos
APIs
Win32
proporcionan
envolturas
llamadas
sis-
tema
NT
11.2.2
interfaz
programación
aplicaciones
Win32
llamadas
funciones
Win32
conocen
forma
colectiva
API
Win32
in-
terfaces
divulgan
forma
pública
documentadas
totalidad
implementan
procedimientos
biblioteca
envuelven
llamadas
sistema
nativas
NT
empleadas
trabajo
casos
realizan
trabajo
usuario
APIs
na-
tivas
NT
publican
funcionalidad
ofrecen
utilizar
tra-
vés
API
Win32
llamadas
existentes
API
Win32
cambian
raras
ocasiones
versiones
Windows
agregan
funciones
API
figura
11-10
muestra
llamadas
nivel
API
Win32
llamadas
nativas
API
NT
envuelven
interesante
figura
interesante
asignación
mayoría
funciones
Win32
nivel
equivalentes
nativos
NT
www
FreeLibros.me826
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
sorpresa
Win32
diseñó
NT
mente
casos
nivel
Win32
mani-
pular
parámetros
Win32
asignarlos
NT
ejemplo
utilizar
nombres
ruta
ca-
nónicos
asignarlos
nombres
ruta
apropiados
NT
incluyendo
nombres
dispositivos
especiales
MS-DOS
LPT
APIs
Win32
crear
procesos
hilos
tam-
bién
notificar
proceso
subsistema
Win32
llamado
csrss.exe
procesos
hilos
supervise
veremos
sección
11.4
Llamada
API
nativa
NTLlamada
Win32
Figura
11-10
Ejemplos
llamadas
API
Win32
llamadas
API
nativa
NT
envuelven
llamadas
Win32
reciben
nombres
rutas
llamadas
equivalentes
NT
utilizan
manejadores
rutinas
envolventes
abrir
archivos
llamar
NT
cerrar
manejador
envolturas
traducen
APIs
Win32
ANSI
Unicode
funciones
Win32
muestran
figura
11-10
utilizan
cadenas
co-
mo
parámetros
realidad
APIs
ejemplo
CreateProcessW
CreateProcessA.
cadenas
pasan
API
traducir
Unicode
llamar
API
NT
subyacente
NT
funciona
Unicode
realizan
cambios
interfaces
Win32
existentes
versión
Windows
teoría
programas
binarios
ejecutaban
correcta
ver-
sión
seguirán
ejecutándose
forma
correcta
versión
prác-
tica
problemas
compatibilidad
versiones
Windows
complejo
cambios
parecen
inconsecuentes
provocar
fallas
aplicaciones
culpar
aplicaciones
frecuencia
realizan
comproba-
ciones
explícitas
versiones
específicas
SO
caen
víctimas
errores
latentes
exponen
ejecutarlas
versión
Microsoft
esfuerzo
versión
evaluar
amplia
variedad
aplicaciones
buscar
incompatibilidades
corre-
girlas
proveer
soluciones
específicas
aplicación
Windows
proporciona
entornos
ejecución
especiales
conocidos
Windows
Windows
WOW
WOW32
utiliza
sistemas
x86
32
bits
ejecutar
aplicaciones
www
FreeLibros.meSECCIÓN
11.2
PROGRAMACIÓN
WINDOWS
VISTA
827
Windows
3.x
asignación
llamadas
sistema
parámetros
mundos
16
bits
32
bits
similar
WOW64
permite
ejecutar
aplicaciones
Windows
32
bits
sistemas
x64
filosofía
API
Windows
distinta
UNIX
funcio-
nes
sistema
operativo
simples
parámetros
lugares
for-
operación
Win32
ofrece
interfaces
extensas
parámetros
formas
mezcla
funciones
nivel
alto
nivel
CreateFiley
CopyFile
significa
Win32
ofrece
conjunto
completo
interfaces
intro-
duce
complejidad
mala
distribución
niveles
sistema
entremez-
cla
funciones
nivel
alto
nivel
API
estudio
sistemas
operativos
relevantes
funciones
nivel
API
Win32
envuelve
API
nativa
NT
enfocaremos
Win32
llamadas
crear
administrar
procesos
hilos
llamadas
relacionadas
comunicación
procesos
crear
destruir
utilizar
mutexes
semáfo-
ros
eventos
puertos
comunicación
objetos
IPC
sistema
administración
memoria
invisible
programa-
dores
característica
importante
visible
habilidad
proceso
asignar
archivo
región
memoria
virtual
permite
hilos
ejecutan
proceso
habilidad
leer
escribir
partes
archivo
apuntadores
operacio-
nes
lectura
escritura
explícita
transferir
datos
disco
memoria
archivos
asignación
memoria
sistema
administración
memoria
realiza
operaciones
necesario
paginación
demanda
implementar
archivos
asignación
memoria
Windows
utiliza
herramientas
completamente
distintas
lugar
proporciona
interfaces
permiten
procesos
ad-
ministrar
espacio
direcciones
virtuales
incluyendo
rangos
reservados
direccio-
nes
usarlas
lugar
Win32
proporciona
abstracción
conocida
asignación
archivos
utiliza
representar
objetos
direccionables
archivos
asignación
archivo
conoce
sección
nivel
NT
mayoría
asignaciones
archivos
crean
referencia
archivos
ma-
nejador
archivo
crear
referencia
páginas
privadas
asignan
archivo
páginas
sistema
herramienta
asigna
vistas
asignaciones
archivos
espacio
direc-
ciones
proceso
Win32
permite
crear
vista
proceso
curso
herra-
mienta
subyacente
NT
general
permite
crear
vistas
proceso
manejador
permisos
apropiados
Separar
creación
asignación
archivo
operación
asignar
archivo
espacio
direcciones
método
distinto
uti-
liza
función
mmapen
UNIX
Windows
asignaciones
archivo
objetos
kernel
representados
manejador
mayoría
manejadores
asignaciones
archivo
dupli-
car
procesos
procesos
dirigir
asignación
archivo
pro-
pio
espacio
direcciones
parezca
apropiado
útil
compartir
memoria
privada
procesos
crear
archivos
compartirlos
nivel
NT
www
FreeLibros.me828
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
asignaciones
archivos
secciones
persistentes
espacio
nom-
bres
NT
acceder
nombre
área
importante
programas
archivos
vista
básica
Win32
archivo
secuencia
lineal
bytes
Win32
proporciona
60
llamadas
crear
destruir
archivos
directorios
abrir
cerrar
archivos
leer
escribir
solicitar
estable-
cer
atributos
archivos
bloquear
rangos
bytes
operaciones
fundamentales
tan-
to
organización
sistema
archivos
acceso
archivos
individuales
herramientas
avanzadas
administrar
datos
archivos
flujo
datos
primario
archivos
almacenan
sistema
archivos
NTFS
te-
ner
flujos
datos
adicionales
archivos
volúmenes
completos
cifrar
archivos
comprimir
representar
flujo
disperso
bytes
regiones
datos
faltantes
media
ocupan
espacio
almacenamiento
disco
volúme-
nes
sistema
archivos
organizar
particiones
disco
separadas
me-
diante
niveles
almacenamiento
RAID
modificaciones
subárboles
archivos
directorios
detectar
mecanismo
notificación
lectura
registro
transacciones
NTFS
mantiene
volumen
volumen
sistema
archivos
monta
implícita
espacio
nombres
NT
nombre
volumen
ejemplo
archivo
\foo\bar
llamar
\Dispositivo\VolumenDiscoDuro\foo\bar
volumen
NTFS
proporcionan
interna
puntos
montaje
llamados
puntos
reanálisis
Windows
vínculos
simboli-
cos
ayudar
organizar
volúmenes
individuales
modelo
nivel
Windows
básicamente
asíncrono
inicia
operación
llamada
sistema
regresar
permitir
hilo
inició
continúe
paralelo
operación
S.
Windows
admite
cancelación
mecanismos
distintos
sincronizar
hilos
operaciones
completan
Windows
permite
programas
especifiquen
deba
síncrona
abrir
archivo
funciones
biblioteca
biblioteca
llamadas
Win32
especifican
síncrona
compatibilidad
simplificar
modelo
programación
casos
ejecutivo
sincronizará
explícita
compleción
regresar
usuario
seguridad
área
Win32
proporciona
llamadas
hilo
asocia
objeto
kernel
conocido
token
proporciona
información
identi-
dad
privilegios
asociados
hilo
objeto
ACL
Access
Control
List
Lista
control
acceso
indique
detalle
precisión
usuarios
acceso
operaciones
método
ofrece
seguridad
detallada
permitir
prohibir
determinados
usuarios
acceso
específico
objeto
modelo
seguridad
extensible
permite
aplicaciones
agregar
reglas
seguridad
co-
mo
limitar
horas
permite
acceso
espacio
nombres
Win32
distinto
espacio
nombres
nativo
NT
descri-
be
sección
partes
espacio
nombres
NT
visibles
APIs
Win32
acceder
espacio
nombres
completo
NT
alteración
Win32
utiliza
cadenas
prefijos
especiales
Win32
acceso
archivos
relativo
letras
unidades
directorio
NT
\DosDevices
contiene
con-
www
FreeLibros.meSECCIÓN
11.2
PROGRAMACIÓN
WINDOWS
VISTA
829
vínculos
simbólicos
letras
unidades
objetos
dispositivos
actuales
ejemplo
\DosDevices\C
vínculo
\Device\HarddiskVolume1
directorio
tam-
bién
contiene
vínculos
dispositivos
Win32
COM1
LPT1
NUL
puer-
tos
serial
impresora
importantísimo
dispositivo
nulo
realidad
\DosDevices
vínculo
simbólico
seleccionó
cuestión
eficiencia
directorio
NT
llamado
\BaseNamedObjects
empleado
almacenar
objetos
diversos
kernel
utilizar
API
Win32
incluyen
objetos
sincronización
semáforos
memoria
compartida
temporizadores
puertos
comunicación
nombres
MS-DOS
dispo-
sitivos
interfaces
sistema
nivel
descrito
API
Win32
proporciona
funciones
operaciones
GUI
incluyendo
llamadas
pa-
ra
administrar
interfaz
gráfica
sistema
llamadas
crear
destruir
administrar
uti-
lizar
ventanas
menús
barras
herramientas
barras
desplazamiento
cuadros
diálogo
iconos
elementos
aparecen
pantalla
llamadas
dibujar
figuras
geométricas
rellenarlas
administrar
paletas
colores
utilizan
gestionar
fuentes
colocar
iconos
pantalla
llamadas
gestionar
teclado
ratón
dispositivos
entrada
humana
dispositivos
audio
impresión
salida
operaciones
GUI
trabajan
directamente
driver
win32k.sys
interfaces
especiales
acceder
funciones
kernel
bibliotecas
mo-
do
usuario
llamadas
involucran
llamadas
sistema
básicas
ejecutivo
NTOS
hablaremos
11.2.3
registro
Windows
raíz
espacio
nombres
NT
mantiene
kernel
almacenamiento
vo-
lúmenes
sistema
archivos
adjunta
espacio
nombres
NT
espacio
construye
cero
sistema
inicia
sistema
de-
talle
específico
configuración
sistema
respuesta
Windows
adjunta
tipo
es-
pecial
sistema
archivos
optimizado
archivos
pequeños
espacio
nombres
NT
sistema
archivos
conoce
registro
registro
organizado
volúmenes
separados
conocidos
grupo
masivo
archivos
hives
grupo
masivo
archivos
mantiene
archivo
separado
directorio
C:\Windows\system32\config\
volumen
ini-
cio
inicia
sistema
Windows
carga
memoria
grupo
masivo
archivos
es-
pecífico
llamado
SYSTEM
programa
inicio
carga
kernel
archivos
inicio
drivers
inicio
volumen
inicio
Windows
mantiene
cantidad
información
crucial
grupo
masivo
archivos
llamado
SYSTEM
incluyendo
información
drivers
dispositivos
soft-
ware
ejecutar
principio
parámetros
gobiernan
operación
sistema
programa
inicio
utiliza
información
determinar
drivers
necesitan
inmediato
momento
arranque
dichos
drivers
incluyen
comprenden
sistema
archivos
drivers
disco
volumen
contiene
sistema
operativo
www
FreeLibros.meDespués
sistema
inicia
utilizan
grupos
masivos
archivos
configuración
describir
información
software
instalado
sistema
usuarios
específicos
clases
objetos
COM
Component
Object-Model
Modelo
objetos
componentes
usuario
instalan
sistema
información
inicio
sesión
usuarios
locales
mantiene
grupo
masivo
archivos
SAM
Administrador
Cuentas
Seguridad
Security
Ac-
cess
Manager
información
usuarios
red
mantiene
servicio
lsassen
hive
SECURITY
coordina
servidores
directorio
red
usuarios
puedan
nombre
común
contraseña
red
completa
figura
11-11
muestra
lista
grupos
masivos
archivos
utilizan
Windows
Vista
830
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Archivo
grupo
Nombre
masivo
archivos
montado
SYSTEM
HKLM
TEM
Información
configuración
SO
kernel
utiliza
HARDWARE
HKLM
DWARE
Hardware
grabación
grupos
archivos
masivos
memoria
detectado
BCD
HKLM
BCD
Base
datos
configuración
inicio
SAM
HKLM
Información
cuentas
usuario
locales
SECURITY
HKLM
URITY
Información
cuentas
lsass
infor-
mación
seguridad
DEFAULT
HKEY_USERS.DEFAULT
Grupo
masivo
archivos
predeterminado
pa-
ra
usuarios
NTUSER.DAT
HKEY_USERS
id
usuario
Grupo
masivo
archivos
específico
usuario
mantiene
directorio
inicio
SOFTWARE
HKLM
TWARE
Clases
aplicaciones
registradas
COM
COMPONENTS
HKLM
NENTS
Manifiestos
dependencias
compo-
nentes
sistema
Figura
11-11
grupos
archivos
masivos
registro
Windows
Vista
HKLM
abreviación
HKEY_LOCAL_MACHINE
introducción
registro
información
configuración
Windows
mante-
nía
cientos
archivos
.ini
inicialización
esparcidos
disco
registro
recopila
archivos
depósito
central
disponible
primeras
etapas
proceso
inicio
sistema
importante
implementar
funcionalidad
plug-and-play
Windows
registro
vuelto
desorganizado
medida
Windows
evoluciona
convenciones
defini-
das
forma
ordenar
información
aplicaciones
utilizan
me-
todología
ad
hoc
mayoría
usuarios
aplicaciones
drivers
operan
privilegios
frecuencia
modifican
parámetros
sistema
directamente
registro
al-
gunas
interfieren
desestabiliza
sistema
registro
extraña
cruza
sistema
archivos
base
datos
tiempo
escrito
libros
completos
describir
registro
Born
1998
Hipson
2000
Ivens
1998
surgido
empresas
vender
software
es-
pecial
administrar
complejidad
registro
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
831
explorar
registro
Windows
programa
GUI
llamado
regedit
per-
mite
abrir
explorar
directorios
conocidos
claves
elementos
datos
conocidos
valores
lenguaje
secuencias
comandos
PowerShell
Microsoft
utilizar
recorrer
claves
valores
registro
fueran
directorios
archi-
vos
interesante
utilizar
herramienta
procmon
disponible
sitio
Web
he-
rramientas
Microsoft
www.microsoft.com/technet/sysinternals
Procmon
vigila
accesos
registro
llevan
cabo
sistema
reve-
lador
programas
acceden
clave
decenas
miles
nombre
indica
regedit
permite
usuarios
editar
registro
cuidado
fácil
dejar
sistema
incapacitado
iniciarse
dañar
instalación
aplicaciones
corregir
utilice
magia
Microsoft
prometió
limpiar
registro
versiones
futuras
enorme
desas-
tre
complicado
información
configuración
mantiene
UNIX
Empezando
Windows
Vista
Microsoft
introdujo
administrador
transacciones
basa-
do
kernel
soporte
transacciones
coordinadas
abarcan
sistema
ar-
chivos
operaciones
registro
Microsoft
planea
utilizar
herramienta
futuro
evitar
problemas
corrupción
metadatos
ocurren
insta-
lación
software
completa
correcta
deja
parcial
directorios
sistema
grupos
masivos
archivos
registro
programador
Win32
acceder
registro
llamadas
crear
eliminar
claves
buscar
valores
claves
útiles
listan
figura
11.12
Función
API
Win32
Descripción
RegCreateKeyEx
Crea
clave
registro
RegDeleteKey
Elimina
clave
registro
RegOpenKeyEx
Abre
clave
obtener
manejador
RegEnumKeyEx
Enumera
subclaves
subordinadas
clave
manejador
RegQueryValueEx
Busca
datos
valor
clave
Figura
11-12
llamadas
API
Win32
utilizar
registro
sistema
apaga
información
registro
almacena
dis-
co
grupos
masivos
archivos
integridad
imprescindible
sistema
funcione
correcta
realizan
respaldos
automática
escrituras
metadatos
vacían
disco
evitar
corrupción
caso
falla
sistema
pierde
registro
reinstalar
software
sistema
11.3
ESTRUCTURA
SISTEMA
secciones
anteriores
examinamos
Windows
Vista
punto
vista
programador
escribe
código
usuario
analizaremos
detalles
internos
organi-
zación
sistema
diversos
componentes
forma
interactúan
www.FreeLibros.mecon
programas
usuario
sistema
ve
programador
implementa
código
usuario
nivel
subsistemas
servicios
nativos
vis-
ta
sistema
escritores
drivers
dispositivos
libros
utilizar
Windows
tantos
funciona
mejores
fuentes
buscar
información
adicional
tema
Microsoft
Windows
Internals
4a
edición
Russinovich
Solomon
2004
libro
describe
Windows
XP
descripción
precisa
interior
Windows
XP
Windows
Vista
similares
Microsoft
información
disponible
kernel
Windows
miem-
bros
docentes
estudiantes
universidades
Programa
Académico
Windows
programa
proporciona
código
fuente
kernel
Windows
Server
2003
documentos
diseño
originales
NT
equipo
Cutler
extenso
conjunto
materiales
presentación
derivan
libro
Windows
Internals
Windows
Driver
Kit
tam-
bién
ofrece
información
funcionamiento
interno
kernel
drivers
dispositivos
utilizan
herramientas
procesos
hilos
memoria
virtual
IPC
11.3.1
Estructura
sistema
operativo
vimos
sistema
operativo
Windows
Vista
consiste
niveles
mues-
tra
figura
11-6
siguientes
secciones
entraremos
detalles
niveles
bajos
sistema
operativo
ejecutan
kernel
nivel
central
mis-
mo
kernel
NTOS
carga
ntoskrnl.exe
Windows
inicia
NTOS
nive-
ejecutivoque
contiene
mayoría
servicios
nivel
pequeño
conoce
kernel
implementa
abstracciones
programación
sincronización
hilos
subyacentes
kernel
kernel
implementa
manejadores
trampas
interrupciones
aspectos
forma
administra
CPU
división
NTOS
kernel
ejecutivo
reflexión
raíces
AX
VMS
NT
sistema
operativo
VMS
diseñado
Cutler
niveles
implementa-
hardware
usuario
supervisor
ejecutivo
kernel
corresponden
modos
protección
proporciona
arquitectura
procesador
AX
CPUs
Intel
tam-
bién
proporcionan
anillos
protección
procesadores
des-
tino
NT
hacían
niveles
kernel
ejecutivo
representan
abstracción
implementada
software
funciones
VMS
proporciona
supervisor
cola
impresión
proveen
NT
servicios
usuario
figura
11-13
muestran
niveles
kernel
NT
nivel
kernel
NTOS
muestra
nivel
ejecutivo
implementa
mecanismos
trampa
interrupción
utilizan
pasar
usuario
kernel
nivel
supe-
rior
figura
11-13
biblioteca
sistema
ntdll.dll
realidad
ejecuta
usuario
biblioteca
sistema
incluye
funciones
soporte
bibliotecas
tiem-
po
ejecución
nivel
compilador
similar
libc
UNIX
biblioteca
ntdll.dll
contiene
puntos
entrada
código
especiales
kernel
utiliza
832
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
833
inicializar
hilos
despachar
excepciones
APCs
Asynchronous
Procedure
Calls
Lla-
madas
procedimientos
asíncronas
usuario
biblioteca
sistema
in-
tegral
operación
kernel
proceso
usuario
creado
NTOS
asignada
biblioteca
ntdll
dirección
fija
NTOS
inicializa
sistema
crea
objeto
sección
usarlo
asignar
ntdll
registra
direcciones
puntos
en-
trada
ntdll
kernel
utiliza
niveles
kernel
ejecutivo
NTOS
software
conocido
HAL
Hardware
Abstraction
Layer
Nivel
abstracción
hardware
abstrae
detalles
hard-
ware
nivel
acceso
registros
dispositivos
operaciones
DMA
forma
firmware
BIOS
representa
información
configuración
lidia
dife-
rencias
chips
soporte
CPU
controladores
interrupción
BIOS
es-
tá
disponible
empresas
integra
memoria
persistente
EEPROM
reside
tarjeta
principal
computadora
componentes
principales
kernel
drivers
dispositivos
Windows
utiliza
herramienta
kernel
forma
NTOS
HAL
incluye
sistemas
archivos
pilas
protocolo
red
extensiones
kernel
software
antivirus
DRM
Digital
Rights
Management
Administración
derechos
digitales
drivers
administrar
dispositivos
físicos
actuar
interfaz
buses
hardware
ejemplo
componentes
memoria
virtual
cooperan
cargar
descargar
controlado-
res
dispositivos
memoria
kernel
enlazarlos
niveles
NTOS
HAL
admi-
nistrador
proporciona
interfaces
permiten
descubrir
organizar
operar
dispositivos
incluyendo
arreglos
cargar
driver
dispositivo
apropiado
informa-
ción
configuración
administrar
dispositivos
drivers
mantiene
grupo
masivo
ar-
chivos
registro
llamado
SYSTEM
subcomponente
plug-and-play
administrador
usuario
kernel
Rutinas
despacho
usuario
kernel
biblioteca
sistema
ntdll.dll
Nivel
abstracción
hardware
Monitor
seguridad
Administrador
objetos
Administrador
configuración
Biblioteca
tiempo
ejecución
ejecutivo
Despacho
trampas
excepciones
interrupciones
Programación
sincronización
CPU
hilos
ISRs
DCPs
APCs
Nivel
kernel
NTOS
Nivel
ejecutivo
NTOS
Administrador
Memoria
virtual
Administrador
caché
Procesos
hilos
LPC
sistemas
archi-
vos
administrador
volumen
pilas
TCP
IP
interfaces
red
dispositivos
gráficos
dispositivos
Hardware
CPU
MMU
controladores
interrupciones
memoria
dispositivos
Drivers
Figura
11-13
Organización
Windows
kernel
www
FreeLibros.me834
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
mantiene
información
hardware
detectado
volátil
grupo
masivo
archi-
vos
HARDWARE
mantiene
memoria
disco
recrea
com-
pleto
inicia
sistema
examinaremos
detalle
diversos
componentes
sistema
opera-
tivo
capa
abstracción
hardware
versiones
basadas
NT
Windows
objetivos
Windows
Vista
portable
plataformas
hardware
teoría
sistema
operati-
vo
tipo
sistema
computacional
habría
recompilar
sistema
operativo
compilador
equipo
ejecutara
desgracia
simple
componentes
niveles
sistema
operativo
portables
mayoría
tratan
estructuras
datos
internas
abstracciones
aceptan
modelo
programación
niveles
lidiar
registros
dispositivos
interrupciones
DMA
características
hardware
difieren
ma-
nera
considerable
máquina
código
fuente
kernel
NTOS
escrito
lengua-
je
ensamblador
2%
ensamblador
x86
1%
x64
código
simplemente
sacar
sistema
x86
ponerse
sistema
SPARC
ejemplo
volverse
compilar
reiniciarse
diversas
diferencias
hard-
ware
arquitecturas
procesadores
distintos
con-
juntos
instrucciones
compilador
ocultar
lenguajes
dificultan
tarea
abstraer
estructuras
datos
hardware
parámetros
formato
en-
tradas
tabla
páginas
tamaños
páginas
memoria
física
longitud
pa-
labras
producir
severos
castigos
rendimiento
optimizaciones
específicas
hardware
tendría
portar
forma
manual
esté
escrito
có-
digo
ensamblador
detalles
hardware
forma
organizada
memoria
servidores
primitivas
sincronización
hardware
disponibles
impacto
niveles
altos
sistema
ejemplo
administrador
memoria
virtual
NT
nivel
kernel
conscientes
detalles
hardware
relacionados
caché
localidad
memoria
NT
utiliza
primitivas
sincronización
compare&swap
sis-
tema
difícil
portarlo
sistema
tuviera
de-
pendencias
sistema
ordenamiento
bytes
palabras
sistemas
portado
NT
hardware
estableció
little-endian
cuestiones
mayores
portabilidad
número
peque-
ñas
cuestiones
distintas
tarjetas
principales
distintos
fabricantes
diferen-
cias
versiones
CPUs
afectan
forma
implementan
primitivas
sincronización
espera
activa
familias
chips
soporte
crean
diferen-
cias
forma
aplica
prioridad
interrupciones
hardware
forma
accede
registros
dispositivos
administración
transferencias
DMA
control
temporizadores
reloj
tiempo
real
sincronización
mul-
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
835
tiprocesadores
trabajo
herramientas
BIOS
ACPI
Interfaz
avanzada
con-
figuración
energía
etcétera
Microsoft
intento
serio
ocultar
tipos
depen-
dencias
máquinas
nivel
delgado
inferior
conocido
HAL
vimos
trabajo
HAL
presentar
resto
sistema
operativo
hardware
abstrac-
to
oculta
detalles
específicos
versión
procesador
conjunto
chips
so-
porte
variaciones
configuración
abstracciones
HAL
presentan
forma
servicios
independientes
máquina
llamadas
procedimientos
macros
NTOS
drivers
utilizar
utilizar
servicios
HAL
dirigirse
hardware
directa
drivers
kernel
requieren
cambios
portarse
procesadores
mayoría
casos
pue-
den
operar
modificación
sistemas
arquitectura
procesadores
diferencias
versiones
chips
soporte
HAL
proporciona
abstracciones
servicios
dispositivos
específicos
teclados
ratones
discos
unidad
administración
memoria
herramientas
esparcen
componentes
kernel
HAL
cantidad
código
habría
modificar
momento
portar
sistema
operativo
considerable
di-
ferencias
actuales
hardware
fueran
pequeñas
simple
portar
HAL
código
dependiente
máquina
concentrado
lugar
objetivos
puerto
definidos
implementar
servicios
HAL
versiones
Mi-
crosoft
proporcionaba
Kit
desarrollo
HAL
permitía
fabricantes
sistemas
construir
HAL
permitir
componentes
kernel
funcionaran
sistemas
necesidad
modificarlos
cambios
hardware
fueran
ejemplo
nivel
abstracción
hardware
considere
cuestión
asignación
memoria
comparación
puertos
S.
máquinas
programar
driver
asignación
memoria
forzar
opción
driver
portar
máquina
utilizara
solución
nivel
abstracción
hardware
ofrece
procedimientos
escritores
drivers
utilizar
leer
registros
dispositivos
es-
cribir
uc
READ_PORT_UCHAR(puerto
WRITE_PORT_UCHART(puerto
uc
us
READ_PORT_USHORT(puerto
WRITE_PORT_USHORT(puerto
us
ul
READ_PORT_ULONG(puerto
WRITE_PORT_LONG(puerto
ul
procedimientos
leen
escriben
enteros
signo
16
32
bits
respectivamente
puer-
to
especificado
responsabilidad
nivel
abstracción
hardware
decidir
necesita
asignación
memoria
forma
driver
mover
necesidad
mo-
dificación
máquinas
difieran
forma
implementan
registros
dispositivos
frecuencia
drivers
necesitan
acceso
dispositivos
específicos
fines
nivel
hardware
dispositivo
direcciones
bus
to-
das
computadoras
modernas
múltiples
buses
ISA
PCI
PCI-X
USB
1394
www.FreeLibros.meetcétera
ocurrir
dispositivo
llegue
dirección
distintos
buses
necesita
forma
diferenciarlos
HAL
proporciona
servicio
pa-
ra
identificar
dispositivos
asignación
direcciones
dispositivos
relativos
bus
direcciones
lógicas
nivel
sistema
forma
drivers
cuen-
ta
dispositivo
conectado
bus
mecanismo
protege
niveles
su-
periores
propiedades
estructuras
bus
alternativas
convenciones
direccionamiento
interrupciones
problema
similar
dependientes
bus
tam-
bién
HAL
proporciona
servicios
denominar
interrupciones
forma
nivel
sistema
permitir
drivers
adjunten
rutinas
servicio
interrupciones
interrupciones
portable
vector
interrupción
corresponde
bus
administración
nivel
peticiones
interrupción
mane-
ja
HAL
servicios
HAL
establecer
administrar
transferencias
DMA
independiente
dispositivo
manejar
motor
DMA
nivel
sistema
motores
DMA
tarjetas
específicas
referencia
dispositi-
vos
utilizan
direcciones
lógicas
HAL
implementa
esparcimiento
recopilación
soft-
ware
escribir
leer
bloques
contiguos
memoria
física
HAL
administra
relojes
temporizadores
portable
tiempo
unidades
100
nanosegundos
empezando
enero
1601
pri-
mera
fecha
cuarto
centenario
simplifica
cálculos
año
bisiesto
Pregun-
ta
rápida
1800
año
bisiesto
Respuesta
rápida
servicios
tiempo
desacoplan
drivers
frecuencias
actuales
operan
relojes
componentes
kernel
necesitan
sincronizarse
nivel
es-
pecial
evitar
condiciones
competencia
sistemas
multiprocesador
HAL
proporcio-
na
primitivas
administrar
sincronización
espera
activa
CPU
simplemente
espera
liberación
recurso
retenido
CPU
especial
situaciones
recurso
retiene
general
instrucciones
máquina
inicia
sistema
HAL
comunica
BIOS
inspecciona
configuración
sistema
averiguar
buses
dispositivos
contiene
forma
configurado
información
coloca
registro
figura
11-14
muestra
resumen
cosas
HAL
capa
kernel
nivel
abstracción
hardware
NTOS
consiste
niveles
kernel
ejecutivo
Kernel
término
confuso
Windows
referir
có-
digo
ejecuta
kernel
procesador
archivo
ntoskrnl.exe
contiene
NTOS
núcleo
sistema
operativo
Windows
referir
capa
kernel
NTOS
utilizaremos
sección
Inclusive
utiliza
nombrar
biblioteca
Win32
usuario
proporciona
envolturas
llamadas
sistema
nativas
kernel32.dll
836
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
837
sistema
operativo
Windows
capa
kernel
muestra
nivel
ejecuti-
vo
figura
11-13
proporciona
conjunto
abstracciones
administrar
CPU
abs-
tracción
central
hilos
kernel
implementa
manejo
excepciones
trampas
tipos
interrupciones
creación
destrucción
estructuras
datos
soporte
hilos
implementan
nivel
ejecutivo
capa
kernel
responsable
planificación
sincronización
subprocesos
soporte
hilos
nivel
separado
nivel
ejecutivo
implementar
modelo
multihilo
pre-
ferente
utiliza
escribir
código
concurrente
usuario
primitivas
sincronización
especializadas
planificador
hilos
kernel
responsable
determinar
hilo
ejecuta
CPU
sistema
hilo
ejecuta
interrupción
temporizador
indique
tiempo
cambiar
hilo
expiró
quantum
hilo
esperar
ocu-
rra
ejemplo
complete
operación
libere
bloqueo
hilo
prioridad
pase
ejecutable
necesite
CPU
cambiar
hilo
planificador
ejecuta
CPU
asegura
guardar
registros
hard-
ware
planificador
selecciona
hilo
ejecutarlo
CPU
restaura
guardado
ejecutó
hilo
hilo
ejecutar
espacio
direcciones
distinto
proceso
hilo
cambio
planificador
cambiar
espacios
direcciones
capítulo
lleguemos
procesos
hilos
analizare-
mos
detalles
algoritmo
planificación
proporcionar
nivel
abstracción
hardware
manejar
cambios
hilos
nivel
kernel
función
clave
proporcionar
soporte
nivel
clases
mecanismos
sincronización
objetos
control
objetos
despacha-
dor
objetos
control
estructuras
datos
capa
kernel
proporciona
co-
mo
abstracciones
nivel
ejecutivo
administrar
CPU
ejecutivo
asigna
manipulan
rutinas
proporciona
capa
kernel
objetos
despachadores
clase
objetos
ejecutivos
ordinarios
utilizan
estructura
datos
común
sincronización
Registros
dispositivos
Direcciones
dispositivos
Interrupciones
DMA
Temporizadores
Espera
activa
BIOS
Disco
RAM
Impresora
MOV
EAX
ABC
ADD
EAX
BAX
BNE
LABEL
MOV
EAX
ABC
MOV
EAX
ABC
ADD
EAX
BAX
BNE
LABEL
MOVE
AX
ABC
ADD
EAX
BAX
BNE
LABEL
Nivel
abstracción
hardware
Figura
11-14
funciones
hardware
maneja
HAL
www
FreeLibros.me838
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Llamadas
procedimientos
diferidas
objetos
control
incluyen
objetos
primitivos
hilos
interrupciones
temporizadores
sin-
cronización
creación
perfiles
objetos
especiales
implementar
DPCs
APCs
ob-
jetos
DPC
Deferred
Procedure
Call
Llamada
procedimiento
diferido
utilizan
reducir
tiempo
requerido
ejecutar
ISRs
Interrupt
Service
Routines
Rutinas
servicio
interrup-
ción
respuesta
interrupción
dispositivo
específico
hardware
sistema
asigna
nivel
prioridad
hardware
interrupciones
CPU
asocia
nivel
prioridad
trabajo
realiza
CPU
responde
interrup-
ciones
nivel
prioridad
utiliza
momento
niveles
prioridad
normales
incluyendo
nivel
prioridad
trabajo
usuario
inte-
rrupciones
dispositivos
ocurren
prioridad
ISR
interrupción
dis-
positivo
ejecuta
general
nivel
prioridad
interrupción
evitar
ocurran
interrupciones
importantes
procesa
importante
ISR
ejecuta
tiempo
retrasará
servicio
interrupciones
me-
nor
prioridad
pierdan
datos
obstaculice
velocidad
transferencia
sis-
tema
ISRs
progreso
momento
ISR
sucesiva
interrupciones
niveles
prioridad
altos
reducir
tiempo
invierte
procesamiento
ISRs
realizan
ope-
raciones
críticas
capturar
resultado
operación
reinicializar
dispositivo
posterior
procesamiento
interrupción
difiere
reduce
nivel
prioridad
CPU
bloquea
servicio
interrupciones
objeto
DPC
utiliza
represen-
tar
trabajo
posterior
ISR
llama
capa
kernel
cola
DPC
lista
DPCs
procesador
específico
DPC
lista
kernel
regis-
tra
petición
especial
hardware
interrumpir
CPU
prioridad
NT
llama
nivel
DISPATCH
complete
ISRs
ejecución
nivel
in-
terrupción
procesador
regresará
nivel
menor
desbloqueará
interrupción
procesar
DPC
ISR
interrupción
DPC
procesará
objetos
DPC
kernel
puesto
cola
técnica
interrupciones
software
diferir
procesamiento
interrupcio-
nes
método
establecido
reducir
latencia
ISRs
UNIX
sistemas
em-
pezaron
utilizar
procesamiento
diferido
década
1970
lidiar
hardware
lento
búfer
limitado
conexiones
seriales
terminales
ISR
lidiar
proceso
obtener
caracteres
hardware
ponerlos
cola
completaba
pro-
cesamiento
interrupciones
nivel
superior
interrupción
software
ejecutaría
ISR
menor
prioridad
procesamiento
caracteres
implementar
ca-
rácter
retroceso
enviar
caracteres
control
terminal
borrar
carácter
visua-
lizado
desplazar
cursor
atrás
actualidad
ejemplo
similar
Windows
dispositivo
teclado
opri-
mir
tecla
ISR
teclado
lee
código
tecla
registro
vuelve
habili-
tar
interrupción
teclado
procesando
tecla
inmediato
utiliza
DPC
cola
procesamiento
código
tecla
hayan
procesado
interrupciones
dispositivos
pendientes
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
839
DPCs
ejecutan
nivel
evitan
ejecuten
ISRs
previenen
ejecute
hilo
completen
DPCs
puestas
cola
reduzca
nivel
prioridad
CPU
nivel
menor
drivers
dispositivos
sistema
cuidado
ejecutar
ISRs
DPCs
tiempo
permite
ejecución
hilos
ISRs
DPCs
sistema
parezca
lento
producir
fallas
reproducir
música
atascamiento
hilos
escriben
búfer
música
dis-
positivo
sonido
común
DPCs
ejecutar
rutinas
respuesta
inte-
rrupción
temporizador
evitar
bloqueo
hilos
eventos
temporizador
necesiten
ejecutarse
tiempo
extendido
cola
peticiones
reserva
hilos
trabajadores
mantiene
kernel
actividades
plano
hilos
tie-
nen
prioridad
programación
12
13
15
veremos
sección
programación
hilos
prioridades
significan
elementos
trabajo
ejecutarán
mayoría
hilos
interferirán
hilos
tiempo
real
Llamadas
procedimientos
asíncronas
objeto
control
especial
kernel
objeto
APC
llamada
procedimiento
asíncrona
APCs
DPCs
difieren
procesamiento
rutina
sistema
diferencia
DPCs
operan
contexto
CPUs
específicas
APCs
ejecu-
contexto
hilo
determinado
procesa
tecla
oprimió
importa
contexto
ejecute
DPC
procesamiento
interrupcio-
nes
interrupciones
necesitan
manejar
dispositivo
físico
operaciones
indepen-
dientes
hilos
grabar
datos
búfer
espacio
kernel
rutina
DPC
ejecuta
contexto
hilo
ejecución
ocurrió
interrupción
original
Llama
sistema
reportar
completa-
do
operación
sistema
pone
cola
APC
ejecutarla
contexto
hilo
realiza
petición
original
acceder
espacio
direcciones
mo-
do
usuario
hilo
procesará
entrada
momento
conveniente
capa
kernel
entrega
APC
hilo
planifica
hilo
ejecutar
APC
diseñada
apariencia
llamada
inesperada
pro-
cedimiento
parecido
manejadores
señales
UNIX
APC
kernel
completar
ejecuta
contexto
hilo
inició
operación
kernel
permite
APC
acceso
búfer
kernel
espacio
di-
recciones
usuario
pertenece
proceso
contiene
hilo
momento
exacto
entregará
APC
depende
esté
hilo
momento
tipo
sistema
sistema
multiprocesador
hilo
recibe
APC
empezar
ejecu-
tarse
DPC
termine
ejecución
APCs
usuario
utilizar
entregar
información
com-
pleción
operación
usuario
hilo
inició
operación
S.
APCs
usuario
invocan
procedimiento
usuario
designado
apli-
cación
hilo
destino
bloqueado
kernel
marca
dispues-
to
aceptar
APCs
kernel
interrumpe
espera
hilo
regresa
usuario
www.FreeLibros.mela
pila
usuario
registros
modificados
ejecutar
rutina
despacho
APC
biblioteca
sistema
ntdll.dll
rutina
despacho
APC
invoca
rutina
usuario
aplicación
asoció
operación
S.
especificar
APCs
usuario
ejecutar
código
completan
operaciones
fun-
ción
QueueUserAPCde
API
Win32
permite
utilizar
APCs
fines
arbitrarios
nivel
ejecutivo
utiliza
APCs
operaciones
distintas
compleción
S.
De-
bido
mecanismo
APC
diseñado
cuidado
entregar
APCs
seguro
utilizar
terminar
hilos
forma
segura
momento
terminar
hilo
declarado
entrando
región
crítica
difirió
en-
tregas
APCs
salga
hilos
kernel
marcan
entran
regiones
críticas
diferir
APCs
adquirir
bloqueos
recursos
puedan
terminar
siguen
reteniendo
recurso
Objetos
despachador
objeto
despachador
tipo
objeto
sincronización
cualquiera
objetos
ordi-
narios
kernel
tipo
usuarios
referencia
manejado-
res
contienen
estructura
datos
llamada
dispatcher_header
muestra
figura
11-15
840
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Bandera
notificación
sincronización
señalado
Encabezado
lista
hilos
espera
Datos
específicos
objeto
Encabezado
objeto
Objeto
ejecutivo
DISPATCHER_HEADER
Figura
11-15
estructura
datos
dispatcher_header
incrustada
objetos
ejecutivos
objetos
despachador
objetos
incluyen
semáforos
mutexes
eventos
temporizadores
espera
objetos
hilos
esperar
sincronizar
ejecución
hilos
incluyen
obje-
tos
representan
archivos
abiertos
procesos
hilos
puertos
IPC
estructura
datos
des-
pachador
contiene
bandera
representa
señalado
objeto
cola
hilos
esperan
señale
objeto
semáforos
primitivas
sincronización
objetos
despachadores
natura-
temporizadores
archivos
puertos
hilos
procesos
utilizan
mecanismos
ob-
jetos
despachadores
notificaciones
activa
temporizador
operación
completa
archivo
datos
disponibles
puerto
termina
hilo
proceso
se-
ñala
objeto
despachador
asociado
despiertan
hilos
esperan
evento
Windows
utiliza
mecanismo
unificado
simple
sincronización
obje-
tos
kernel
necesitan
APIs
especializadas
wait3para
esperar
proce-
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
841
sos
hijos
UNIX
esperar
eventos
hilos
desean
esperar
eventos
UNIX
proceso
esperar
datos
estén
disponibles
cualquiera
64
sockets
red
llamada
sistema
select
Windows
API
similar
lla-
mada
WaitForMultipleObjects
permite
hilo
espere
tipo
objeto
despachador
manejador
especificar
64
manejadores
WaitForMultipleObjects
valor
tiempo
límite
opcional
hilo
pasa
eje-
cutable
señala
eventos
asociados
manejadores
ocurre
tiempo
límite
realidad
kernel
utiliza
procedimientos
distintos
hilos
esperen
objeto
despachador
ejecutable
señalar
objeto
notificación
hilos
estén
espera
ejecutables
objetos
sincronización
hilo
espera
ejecutable
utilizan
objetos
despachadores
implementan
primitivas
bloqueo
mutexes
hilo
espera
bloqueo
empieza
ejecutarse
tratar
adquirir
bloqueo
hilo
retener
bloqueo
to-
ejecutables
bloquearse
inmediato
produci-
rían
cambios
contexto
innecesario
diferencia
objetos
despachadores
utilizan
sincronización
comparación
notificación
bandera
estructura
dispat-
cher_header
información
adicional
mutexes
Windows
conocen
mutantes
có-
digo
implementar
semántica
OS/2
desbloquearse
forma
automática
termine
hilo
contenga
mutexes
Cutler
consideraba
estrafalario
nivel
ejecutivo
muestra
figura
11-13
capa
kernel
NTOS
ejecutivo
ni-
vel
ejecutivo
escrito
independiente
arquitectura
adminis-
trador
memoria
notable
excepción
portado
procesadores
esfuerzo
modesto
MIPS
x86
PowerPC
Alpha
IA64
x64
ejecutivo
contiene
compo-
nentes
distintos
ejecutan
abstracciones
control
proporciona
ca-
pa
kernel
componente
divide
estructuras
datos
interfaces
internas
externas
aspec-
tos
internos
componente
ocultos
utilizan
componente
aspectos
externos
disponibles
componentes
ejecutivo
exporta
subconjunto
interfaces
externas
ejecutable
ntoskrnl.exe
dri-
vers
dispositivos
crear
vínculos
ejecutivo
biblioteca
Micro-
soft
llama
gerentes
componentes
ejecutivo
cargo
administrar
aspecto
servicios
operativos
memoria
procesos
objetos
etcétera
mayoría
sistemas
operativos
funcionalidad
eje-
cutivo
Windows
código
biblioteca
ejecuta
kernel
compartir
estructuras
datos
protegerse
acceso
código
usuario
www.FreeLibros.mey
acceder
hardware
privilegiado
registros
control
MMU
aparte
ejecutivo
simplemente
ejecuta
funciones
SO
beneficio
llama
ende
ejecuta
hilo
proceso
llamó
cualquiera
funciones
ejecutivo
bloquea
espera
sincronizarse
hilos
hilo
usuario
bloquea
sentido
trabaja
beneficio
hilo
usuario
específico
injusto
realiza
traba-
jo
relacionado
tareas
comunes
mantenimiento
evitar
sabotear
hilo
actual
ejecutivo
determina
necesitan
tareas
mantenimiento
crear
hi-
kernel
sistema
inicia
dedicar
tareas
específicas
asegurarse
páginas
modificadas
escriban
disco
tareas
predecibles
baja
frecuencia
hilo
ejecuta
lista
elementos
manejar
trabajo
predecible
reserva
hilos
trabajadores
alta
prioridad
mencionamos
utilizar
ejecutar
ta-
reas
delimitadas
cola
petición
señalar
evento
sincronización
esperan
hilos
trabajadores
administrador
objetos
administra
mayoría
objetos
interesantes
ker-
nel
utilizan
nivel
ejecutivo
incluyen
procesos
hilos
archivos
semáforos
dis-
positivos
drivers
temporizadores
vimos
objetos
kernel
realidad
estructuras
datos
asignadas
utilizadas
kernel
Windows
estructuras
datos
kernel
común
conveniente
administrar
mu-
chas
herramienta
unificada
herramientas
proporciona
administrador
objetos
incluyen
administrar
asigna-
ción
liberación
memoria
objetos
contabilizar
cuotas
soporte
acceso
objetos
manejadores
mantener
conteos
referencia
referencias
apun-
tadores
referencias
manejadores
nombres
objetos
espacio
nombres
NT
proveer
mecanismo
extensible
administrar
ciclo
vida
objeto
adminis-
trador
objetos
administra
estructuras
datos
kernel
necesitan
es-
tas
herramientas
estructuras
datos
objetos
control
utilizan
capa
kernel
objetos
extensiones
objetos
kernel
ad-
ministradas
objeto
administrador
objetos
tipo
utiliza
especificar
administrar
ciclo
vida
objetos
tipo
tipos
sentido
orien-
tado
objetos
colección
parámetros
especifican
crear
objeto
crear
tipo
componente
ejecutivo
simplemente
llama
API
administrador
objetos
crear
tipo
objetos
centrales
funcionamiento
Win-
dows
sección
analizaremos
detalle
administrador
objetos
administrador
proporciona
marco
trabajo
implementar
drivers
dispositivos
número
servicios
ejecutivo
específicos
configurar
utilizar
operaciones
dispositivos
Windows
drivers
dispositivos
manejan
dispositivos
físicos
ofrecen
extensibilidad
sistema
operativo
Mu-
chas
funciones
compilan
kernel
sistemas
cargan
dinámica
vinculan
kernel
Windows
incluyendo
pilas
protocolos
sistemas
ar-
chivos
842
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
843
versiones
recientes
Windows
soporte
ejecutar
drivers
dispo-
sitivos
usuario
modelo
preferido
drivers
dispositivos
cientos
miles
drivers
dispositivos
distintos
Windows
Vista
funcionan
millón
dispositivos
distintos
difícil
código
trabaje
for-
ma
correcta
errores
impidan
acceso
dispositivo
fallar
pro-
ceso
usuario
comprobación
errores
sistema
errores
drivers
dispositivos
kernel
principal
fuente
temida
BSOD
Blue
Screen
of
Death
Pantalla
azul
muerte
Windows
detecta
error
fatal
mo-
do
kernel
apaga
reinicia
sistema
BSODs
comparables
pánicos
kernel
sistemas
UNIX
esencia
Microsoft
reconocido
oficial
investigadores
área
microkernels
MINIX
L4
conocido
años
código
ker-
nel
errores
drivers
dispositivos
representan
70%
có-
digo
kernel
drivers
puedan
mover
proceso
usuario
error
activará
falla
driver
falle
sistema
espera
tendencia
mover
código
kernel
proceso
usuario
acelere
años
venir
administrador
incluye
instalaciones
plug-and-play
administración
energía
Plug-and-play
entra
acción
detectan
dispositivos
sistema
notifica
subcomponente
plug-and-play
Funciona
servicio
administrador
plug-and-play
usuario
buscar
driver
dispositivo
apropiado
cargarlo
sistema
fácil
encontrar
driver
dispositivo
correcto
depende
proceso
sofisticado
asociar
versión
dispositivo
hardware
específico
ver-
sión
específica
drivers
dispositivo
admite
interfaz
estándar
aceptada
drivers
escritos
distintas
empresas
administración
energía
reduce
consumo
extiende
vida
baterías
portátiles
ahorra
energía
equipos
escritorio
servidores
Pue-
difícil
administrar
energía
forma
correcta
dependencias
sutiles
en-
tre
dispositivos
buses
conectan
CPU
memoria
consumo
energía
ve
afectado
dispositivos
encendidos
velocidad
re-
loj
CPU
administrador
energía
controla
sección
11.7
estudiaremos
detalle
sección
11.8
estudiaremos
sis-
tema
archivos
NT
importante
NTFS
administrador
procesos
encarga
creación
terminación
procesos
hi-
incluyendo
establecimiento
directivas
parámetros
gobiernan
as-
pectos
operacionales
hilos
determinan
base
nivel
kernel
controla
programación
sincronización
hilos
interacción
objetos
control
co-
mo
APCs
procesos
contienen
hilos
espacio
direcciones
tabla
mane-
jadores
proceso
utilizar
referencia
objetos
kernel
procesos
incluyen
información
necesita
planificador
cambiar
espa-
cio
direcciones
administrar
información
hardware
específica
proce-
so
descriptores
segmentos
sección
11.4
estudiaremos
administración
procesos
hilos
www
FreeLibros.meEl
administrador
memoria
ejecutivo
implementa
arquitectura
memoria
virtual
paginación
demanda
Administra
asignación
páginas
virtuales
marcos
pá-
ginas
físicas
administración
marcos
físicos
disponibles
administración
archivo
paginación
disco
utiliza
respaldar
instancias
privadas
páginas
virtuales
cargan
memoria
administrador
memoria
provee
herramientas
espe-
ciales
aplicaciones
servidor
extensas
bases
datos
componentes
tiem-
po
ejecución
lenguajes
programación
tales
recolectores
basura
sección
11.5
estudiaremos
administración
memoria
administrador
caché
optimiza
rendimiento
sistema
archivos
mantiene
caché
páginas
sistema
archivos
espacio
direcciones
vir-
tuales
kernel
administrador
caché
utiliza
caché
direcciones
virtuales
or-
ganiza
páginas
caché
base
ubicación
archivos
difiere
caché
bloques
físicos
UNIX
sistema
mantiene
caché
bloques
direc-
ciones
físicas
volumen
disco
puro
administración
caché
implementa
asignación
memoria
archivos
actual
caché
administrador
memoria
adminis-
trador
caché
preocuparse
decidir
partes
archivos
caché
asegura
datos
caché
vacíen
disco
forma
oportuna
ad-
ministra
direcciones
virtuales
kernel
utilizan
asignar
páginas
archivos
caché
requiere
página
operación
archivo
caché
producirá
fallo
página
traerá
página
requerida
administrador
memoria
sección
11.6
estudiaremos
administrador
caché
monitor
referencia
seguridad
implementa
elaborados
mecanismos
seguridad
Windows
aplican
estándares
internacionales
seguridad
computacional
cono-
cidos
Criterios
comunes
evolución
requerimientos
seguridad
Libro
na-
ranja
Departamento
Defensa
Unidos
estándares
especifican
cantidad
reglas
cumplir
sistema
conformidad
inicio
sesión
autenticado
auditorías
puesta
cero
memoria
asignada
re-
glas
requiere
comprobaciones
acceso
implementen
módulo
sistema
Windows
módulo
monitor
referencia
seguridad
kernel
sección
11.9
estudiaremos
detalle
sistema
seguridad
ejecutivo
contiene
componentes
analizaremos
administrador
configuración
componente
ejecutivo
implementa
registro
vimos
registro
contiene
datos
configuración
sistema
archivos
sistema
conocidos
grupo
masivo
archivos
hives
grupo
masivo
archivos
crítico
SYSTEM
carga
memoria
momento
iniciar
sistema
nivel
ejecutivo
inicializa
éxito
componentes
clave
incluyendo
drivers
comunican
disco
sistema
vuelve
asociar
copia
memoria
grupo
masivo
archivos
copia
sistema
archivos
sale
hora
tratar
iniciar
sistema
probable
corrompa
copia
disco
componente
LPC
ofrece
comunicación
procesos
eficiente
utiliza
procesos
ejecutan
sistema
transportes
datos
uti-
liza
herramienta
llamadas
procedimientos
remotos
RPC
basada
estándares
im-
844
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
845
plementar
modelo
computación
cliente
servidor
RPC
utiliza
tuberías
nombres
TCP
IP
transportes
Windows
Vista
mejoró
componente
LPC
considerable
conoce
ALPC
LPC
avanzado
admitir
características
RPC
incluyendo
RPC
componentes
kernel
drivers
LPC
componente
crítico
diseño
original
NT
nivel
subsistema
utiliza
implementar
comu-
nicación
rutinas
resguardo
stub
biblioteca
ejecutan
proceso
proceso
subsistema
implementa
herramientas
comunes
personalidad
específi-
ca
sistema
operativo
Win32
POSIX
Windows
NT
4.0
código
relacionado
interfaz
gráfica
Win32
tras-
ladó
kernel
hardware
actual
podía
ofrecer
rendi-
miento
requerido
código
residía
proceso
subsistema
crss.exe
implementaba
interfaces
Win32
código
GUI
basado
kernel
reside
driver
especial
win32k.sys
esperaba
cambio
mejorara
rendimiento
Win32
eliminado
transiciones
adicionales
usuario
kernel
costo
cambiar
espacios
direcciones
implementar
comunicación
componente
LPC
éxito
esperado
requerimientos
código
ejecuta
kernel
estrictos
sobrecarga
adicional
ejecución
kernel
contrarresta
al-
gunas
ganancias
obtienen
reducir
costos
drivers
dispositivos
figura
11-13
consiste
drivers
dispositivos
Windows
drivers
bibliotecas
vínculos
dinámicos
cargan
ejecutivo
NTOS
principal
implementar
drivers
hardware
específico
dispositivos
fí-
sicos
buses
mecanismo
driver
dispositivo
utiliza
mecanis-
mo
extensibilidad
general
kernel
vimos
subsistema
Win32
carga
driver
administrador
organiza
ruta
flujo
datos
instancia
disposi-
tivo
muestra
figura
11-16
ruta
conoce
pila
dispositivos
con-
siste
instancias
privadas
objetos
dispositivo
kernel
asignan
ruta
objeto
dispositivo
pila
dispositivos
vincula
objeto
driver
específico
contiene
tabla
rutinas
utilizar
paquetes
peticiones
fluyen
pila
dispositivos
casos
dispositivos
pila
representan
drivers
cuyo
único
propósito
filtrar
operaciones
orientadas
dispositivo
bus
driver
red
especí-
fico
filtrado
utiliza
razones
preprocesamiento
pos-
procesamiento
operaciones
obtiene
arquitectura
limpia
pragmático
código
fuente
permisos
modificar
driver
disponibles
utiliza
filtrado
solución
alterna
filtros
imple-
mentar
funcionalidad
completamente
convertir
discos
particiones
dis-
cos
volúmenes
RAID
www
FreeLibros.me846
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
sistemas
archivos
cargan
drivers
instancia
volumen
sistema
archivos
crea
objeto
dispositivo
pila
dispositivos
volumen
objeto
dispositivo
vinculará
objeto
driver
sistema
archivos
apropiado
formato
volumen
drivers
filtros
especiales
conocidos
drivers
filtros
sistema
archivos
insertar
objetos
dispositivo
objeto
dispositivo
sistema
archivos
aplicar
funcionalidad
peticiones
envían
volumen
inspección
datos
leen
escriben
asegurar
tengan
virus
protocolos
red
implementación
IPv4
IPv6
TCP
IP
integrada
Windows
Vis-
ta
cargan
drivers
modelo
S.
compatibilidad
Windows
anteriores
basados
MS-DOS
driver
TCP
IP
implementa
protocolo
es-
pecial
comunicarse
interfaces
red
modelo
Windows
Filtro
sistema
archivos
Filtro
sistema
archivos
Sistema
archivo
Volumen
Dispositivo
clase
disco
Partición(es
disco
IRP
Driver
filtro
sistema
archivos
Driver
filtro
sistema
archivos
Driver
NTFS
Driver
administrador
volúmenes
Driver
clase
disco
Driver
minipuerto
disco
Filtro
sistema
archivos
Filtro
sistema
archivos
Sistema
archivo
Volumen
Dispositivo
clase
disco
Partición(es
disco
IRP
Administrador
Figura
11-16
Representación
simplificada
pilas
dispositivos
volú-
menes
archivos
NTFS
paquete
peticiones
pasa
infe-
rior
pila
llamadas
rutinas
apropiadas
drivers
asociados
nivel
pila
pilas
dispositivos
consisten
objetos
disposi-
tivo
asignan
específica
pila
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
847
drivers
implementan
dichos
arreglos
Windows
llama
minipuertos
funcionalidad
compartida
driver
clase
ejemplo
driver
clase
suministra
fun-
cionalidad
común
discos
SCSI
IDE
dispositivos
USB
drivers
minipuer-
tos
crean
vínculo
drivers
clase
tipo
específico
dichos
dispositivos
biblioteca
capítulo
analizaremos
driver
dispositivo
específico
sección
11.7
proporcionaremos
detalles
forma
administrador
interactúa
dri-
vers
dispositivos
11.3.2
Booteo
Windows
Vista
ejecute
sistema
operativo
requieren
pasos
enciende
computadora
hardware
inicializa
CPU
empieza
ejecutar
programa
memo-
ria
único
código
disponible
forma
CMOS
volátil
fabricante
computadora
inicializa
usuario
actualiza
proceso
conocido
flashing
mayoría
PCs
programa
inicial
BIOS
Basic
Input
Output
Sys-
tem
Sistema
básico
entrada
salida
comunicarse
tipos
estándar
dispositivos
encuentran
PC
iniciar
Windows
Vista
BIOS
carga
pequeños
programas
tipo
bootstrap
encuentran
inicio
particiones
unidad
disco
programas
bootstrap
leer
suficiente
información
volumen
sistema
archivos
encontrar
programa
BootMgr
independiente
Windows
directorio
raíz
BootMgr
determina
sistema
hibernado
suspendido
modos
es-
peciales
ahorro
energía
permiten
volver
encender
sistema
ini-
ciarlo
BootMgr
carga
ejecuta
inResume.exe
caso
contrario
carga
ejecuta
WinLoad.exe
inicio
cero
WinLoad
carga
componentes
inicio
sis-
tema
memoria
kernel
ejecutivo
general
ntoskrnl.exe
HAL
hal.dll
archi-
vo
contiene
grupo
masivo
archivos
SYSTEM
driver
Win32k.sys
contiene
partes
subsistema
Win32
kernel
imágenes
drivers
listados
grupo
masivo
archivos
SYSTEM
drivers
booteo
significa
necesi-
sistema
arranca
cargan
componentes
inicio
Windows
memoria
proporciona
control
código
nivel
NTOS
procede
inicializar
niveles
HAL
kernel
ejecutivo
vincula
imágenes
drivers
utiliza
actualiza
datos
configu-
ración
grupo
masivo
archivos
SYSTEM
inicializan
componen-
tes
kernel
crea
proceso
usuario
utiliza
ejecutar
programa
smss.exe
/etc
init
sistemas
UNIX
programas
inicio
Windows
lógica
lidiar
problemas
comunes
encuentran
usuarios
falla
inicio
sistema
instalación
dri-
dispositivo
defectuoso
ejecución
programa
regedit
corromper
grupo
masivo
archivos
SYSTEM
evitan
sistema
inicie
normal
sopor-
ignorar
cambios
recientes
iniciar
configuración
válida
conocida
sistema
opciones
inicio
incluyen
booteo
seguro
desactiva
drivers
www.FreeLibros.meopcionales
consola
recuperación
activa
ventana
cmd.exe
línea
comandos
proporciona
experiencia
similar
usuario
UNIX
problema
común
usuarios
ocasiones
sistemas
Windows
pa-
recen
quebradizos
fallas
frecuentes
parecer
aleatorias
sistema
aplicaciones
datos
toman
programa
Análisis
fallas
línea
Microsoft
muestran
evidencia
fallas
memoria
física
defectuosa
proceso
inicio
Windows
Vista
ofrece
opción
ejecutar
diagnóstico
me-
moria
exhaustivo
futuro
hardware
PC
soporte
común
ECC
paridad
memoria
mayoría
sistemas
escritorio
portátiles
actualidad
vulnerables
errores
bit
miles
millones
bits
memoria
contienen
11.3.3
Implementación
administrador
objetos
Probablemente
administrador
objetos
componente
individual
importante
ejecu-
tivo
Windows
razón
introducido
conceptos
dijimos
proporciona
interfaz
uniforme
consistente
administrar
recursos
sistema
estructuras
datos
archivos
abiertos
procesos
hilos
secciones
memoria
temporizadores
dispositivos
drivers
semáforos
administrador
objetos
maneja
objetos
es-
pecializados
representan
cosas
transacciones
kernel
perfiles
tokens
seguridad
escritorios
Win32
objetos
dispositivos
vinculan
descripciones
sistema
en-
tre
proporcionan
vínculo
espacio
nombres
NT
volúmenes
sis-
tema
archivos
administrador
configuración
utiliza
objeto
tipo
Key
crear
vínculos
grupos
masivos
archivos
registro
administrador
objetos
ob-
jetos
utiliza
administrar
espacio
nombres
NT
implementar
objetos
utilicen
herramienta
común
objetos
directorio
vínculo
simbólico
tipo
objeto
uniformidad
proporciona
administrador
objetos
facetas
objetos
utilizan
mecanismo
creación
destrucción
contabilización
sistema
cuotas
utilizar
procesos
usuario
maneja-
dores
convención
unificada
administrar
referencias
apuntadores
objetos
interior
kernel
objetos
recibir
nombres
espacio
nombres
NT
manejado
administrador
objetos
objetos
despachadores
objetos
empiezan
estructura
datos
común
señalar
eventos
utilizar
interfaces
comunes
sin-
cronización
notificación
WaitForMultipleObjects
sistema
seguridad
común
ACLs
implementa
objetos
abren
nombre
comprobaciones
acce-
so
manejador
herramientas
ayudar
desarrolladores
mo-
do
kernel
depurar
problemas
rastreo
objetos
clave
comprender
objetos
objeto
ejecutivo
estructura
datos
memoria
virtual
accesible
kernel
estructuras
datos
utilizan
comúnmente
representar
conceptos
abstractos
ejemplo
crean
objetos
archivos
ejecutivo
instancia
archivo
sistema
archivos
abierto
objetos
procesos
crean
representar
proceso
848
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
849
consecuencia
objetos
estructuras
datos
kernel
sistema
reinicia
falla
pierden
sistema
arranca
ob-
jetos
presentes
siquiera
descriptores
tipo
objetos
tipos
objetos
objetos
crear
forma
dinámica
componentes
nivel
eje-
cutivo
llamada
interfaces
proporciona
administrador
objetos
crean
objetos
especifica
nombre
referencia
espacio
nombres
NT
crear
objetos
sistema
inicia
crea
espacio
nombres
NT
objetos
estructura
muestra
figura
11-17
objeto
contiene
encabezado
información
común
objetos
tipos
campos
encabezado
incluyen
nombre
objeto
directorio
espacio
nom-
bres
NT
apuntador
descriptor
seguridad
representa
ACL
objeto
Encabezado
objeto
Datos
objeto
Datos
específicos
objeto
Nombre
objeto
Directorio
vive
objeto
Información
seguridad
objeto
utilizar
Cargos
cuota
costo
utilizar
objeto
Lista
procesos
manejadores
Conteos
referencia
Apuntador
objeto
tipo
Nombre
tipo
Tipos
acceso
Permisos
acceso
Cargos
cuota
sincronizar
paginar
Método
abrir
Método
cerrar
Método
eliminar
Método
consultar
nombre
Método
analizar
Método
seguridad
Figura
11-17
estructura
objeto
ejecutivo
administrado
adminis-
trador
objetos
memoria
asigna
objetos
proviene
montículos
reservas
me-
moria
mantenidos
nivel
ejecutivo
funciones
utilitarias
malloc
ejecutivo
permiten
componentes
kernel
asignar
memoria
paginable
kernel
memo-
ria
paginable
kernel
memoria
paginable
requiere
estructura
datos
objeto
kernel
utilizar
nivel
prioridad
CPU
incluye
ISRs
DPCs
APCs
planificador
hilos
manejador
fallos
página
requiere
asignar
estructuras
datos
memo-
ria
kernel
paginable
evitar
recursividad
mayoría
asignaciones
administrador
montículo
kernel
obtienen
median-
listas
búsqueda
lateral
lookaside
contienen
listas
LIFO
UEPS
asignacio-
nes
tamaño
listas
optimizan
operación
bloqueos
mejoran
rendimiento
escalabilidad
sistema
www
FreeLibros.meEl
encabezado
objeto
contiene
campo
cargo
cuota
cobra
proceso
abrir
objeto
cuotas
utilizan
evitar
usuario
utilice
demasiados
recursos
sistema
límites
separados
memoria
kernel
paginable
requiere
asignación
memoria
física
direcciones
virtuales
kernel
memoria
kernel
paginable
utiliza
direcciones
virtuales
kernel
cargos
acumulados
cual-
quiera
tipos
memoria
llegan
límite
cuota
asignaciones
proceso
fallan
recursos
insuficientes
administrador
memoria
utiliza
cuo-
tas
controlar
tamaño
conjunto
trabajo
administrador
hilos
utiliza
li-
mitar
proporción
CPU
memoria
física
direcciones
virtuales
kernel
recursos
valiosos
Cuan-
do
necesita
objeto
eliminarlo
reclamar
memoria
direcciones
reclama
objeto
memoria
asignar
objeto
probable
estructuras
datos
corrompan
fácil
ocurra
nivel
ejecutivo
Windows
multihilo
implementa
opera-
ciones
asíncronas
funciones
regresan
proceso
llamó
terminar
trabajo
estructuras
datos
reciben
evitar
liberar
objetos
tiempo
condiciones
competencia
adminis-
trador
objetos
implementa
mecanismo
conteo
referencias
concepto
apunta-
dor
referenciado
tipo
apuntador
requiere
acceder
objeto
peligro
eliminado
Dependiendo
convenciones
relacionadas
ti-
po
objeto
específico
momentos
hilo
llegar
eliminar
objeto
momentos
bloqueos
dependencias
estructuras
datos
hilo
apuntador
objeto
suficientes
evi-
tar
objeto
elimine
forma
prematura
Manejadores
referencias
usuario
objetos
kernel
utilizar
apuntado-
res
difícil
validarlos
objetos
kernel
deno-
minar
forma
código
usuario
referencia
Windows
utiliza
manejadores
referencia
objetos
kernel
manejadores
valores
opacos
administrador
objetos
convierte
referencias
estructura
datos
es-
pecífica
kernel
representa
objeto
figura
11-18
muestra
estructura
da-
tos
tabla
manejadores
utiliza
traducir
manejadores
apuntadores
objetos
tabla
manejadores
expandir
agregan
niveles
adicionales
indirección
proceso
tabla
incluyendo
proceso
sistema
contiene
hilos
kernel
asociados
proceso
usuario
figura
11-19
muestra
tabla
manejadores
niveles
adicionales
indirec-
ción
máximo
admitido
conveniente
código
ejecuta
kernel
utilizar
manejadores
apuntadores
referenciados
conoce
co-
mo
manejadores
kernel
codifican
especial
distinguirlos
ma-
nejadores
usuario
manejadores
kernel
mantienen
tabla
manejadores
850
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
851
procesos
sistema
acceder
usuario
comparte
espacio
direcciones
virtuales
kernel
procesos
ta-
bla
manejadores
sistema
comparte
componentes
kernel
importar
proceso
actual
usuario
Apuntador
tabla
Entradas
tabla
manejadores
512
Descriptor
tabla
manejadores
Objeto
Objeto
Objeto
Figura
11-18
Estructuras
datos
tabla
manejadores
tabla
simpli-
ficada
utiliza
página
512
manejadores
usuarios
crear
objetos
abrir
objetos
existentes
llamadas
Win32
CreateSemaphoreu
OpenSemaphore
llamadas
procedimientos
biblioteca
instancia
producen
llamadas
apropiadas
sistema
resultado
lla-
mada
exitosa
crear
abrir
objeto
entrada
tabla
manejadores
64
bits
almacena
tabla
manejadores
privada
proceso
memoria
kernel
índice
32
bits
posición
lógica
manejador
tabla
regresa
usuario
utilice
posteriores
llamadas
entrada
tabla
manejadores
64
bits
kernel
contiene
pa-
labras
32
bits
palabra
contiene
apuntador
29
bits
encabezado
objeto
bits
menor
orden
utilizan
banderas
ejemplo
manejador
heredado
proce-
sos
crea
bits
enmascaran
siga
apuntador
palabra
contiene
Entradas
tabla
manejadores
512
Apuntadores
tabla
manejadores
1024
Entradas
tabla
manejadores
512
Apuntadores
tabla
manejadores
32
Apuntadores
tabla
manejadores
1024
Entradas
tabla
manejadores
512
Apuntador
tabla
Descriptor
tabla
manejadores
Objeto
Objeto
Objeto
Figura
11-19
Estructuras
datos
tabla
manejadores
tabla
máxima
16
millones
manejadores
www
FreeLibros.me852
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
máscara
permisos
32
bits
necesaria
comprobación
permisos
realiza
momento
crear
abrir
objeto
proceso
permiso
lectura
obje-
to
bits
permisos
máscara
sistema
operativo
re-
chazar
operación
objeto
lectura
espacio
nombres
objetos
procesos
compartir
objetos
proceso
duplicar
manejador
objeto
procesos
requiere
proceso
duplicador
ma-
nejadores
procesos
ende
práctico
situaciones
procesos
comparten
objeto
relacionados
protegidos
casos
importante
objetos
persistan
proceso
utilice
objetos
dispositivo
representan
dispositivos
físicos
volúmenes
montados
obje-
tos
utilizan
implementar
administrador
objetos
espacio
nombres
NT
lidiar
requerimientos
compartición
persistencia
general
administrador
objetos
permite
objetos
arbitrarios
reciban
nombres
espacio
nombres
NT
mo-
mento
creación
responsabilidad
componente
ejecutivo
manipula
objetos
tipo
proveer
interfaces
admitan
herramientas
denominación
administrador
objetos
espacio
nombres
NT
jerárquico
administrador
objetos
implementa
di-
rectorios
vínculos
simbólicos
espacio
nombres
extensible
permite
tipo
objeto
especifique
extensiones
espacio
nombre
pro-
porcionar
rutina
llamada
Parse
rutina
Parse
procedimientos
proveer
tipo
objeto
momento
crearlo
muestra
figura
11-20
Procedimiento
llama
Observaciones
Open
manejador
utiliza
raras
Parse
tipos
objetos
utiliza
archivos
claves
extienden
espacio
nombres
registro
Close
cierra
Limpia
efectos
secundarios
manejador
visibles
Delete
desreferencia
objeto
punto
eliminarse
apuntador
Security
obtener
establecer
Protección
descriptor
seguridad
objeto
QueryName
obtener
nombre
objeto
utiliza
raras
kernel
Figura
11-20
procedimientos
objetos
suministran
especifica
tipo
objeto
procedimiento
Open
utiliza
raras
comportamiento
predeterminado
administrador
objetos
comúnmente
necesita
procedimiento
especifica
NULL
tipos
objetos
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
853
procedimientos
Close
Delete
representan
distintas
fases
terminar
objeto
Cuan-
do
cierra
manejador
objeto
acciones
necesarias
limpiar
es-
tado
encarga
procedimiento
Close
elimina
referencia
apuntador
objeto
llamada
procedimiento
Delete
preparar
objeto
pa-
ra
eliminado
reutilizar
memoria
objetos
archivos
procedimientos
implementan
llamadas
retorno
callbacks
administrador
componente
declaró
tipo
objeto
archivo
operaciones
administrador
objetos
producen
ope-
raciones
correspondientes
envían
pila
dispositivos
asociada
objeto
archivo
sistema
archivos
realiza
trabajo
procedimiento
Parse
utiliza
abrir
crear
objetos
archivos
claves
registro
extienden
espacio
nombres
NT
administrador
objetos
abrir
objeto
nombre
nodo
hoja
espacio
nombres
ad-
ministra
comprueba
tipo
objeto
nodo
hoja
especificado
procedimiento
Par-
invoca
procedimiento
pasa
utilizada
nombre
ruta
utilizamos
objeto
archivos
ejemplo
nodo
hoja
objeto
dispositivo
representa
volumen
específico
sistema
archivos
proceso
Parse
implementa
me-
diante
administrador
produce
operación
sistema
archivos
lle-
ne
objeto
archivo
haga
referencia
instancia
abierta
archivo
refiere
nombre
ruta
volumen
continuación
exploraremos
ejemplo
específico
paso
paso
procedimiento
QueryName
utiliza
buscar
nombre
asociado
objeto
pro-
cedimiento
Security
utiliza
obtener
establecer
eliminar
descriptores
seguridad
objeto
mayoría
tipos
objetos
procedimiento
proporciona
pun-
to
entrada
estándar
componente
Monitor
Referencia
Seguridad
ejecutivo
Observe
procedimientos
figura
11-20
realizan
operaciones
interesan-
tes
tipo
objeto
proporcionan
funciones
llamadas
retorno
ad-
ministrador
objetos
necesita
implementar
funciones
correcta
proporcionan
acceso
objetos
limpian
terminan
usarlos
lla-
madas
retorno
administrador
objetos
proporciona
conjunto
rutinas
obje-
tos
genéricos
operaciones
crear
objetos
tipos
objetos
duplicar
manejadores
obtener
apuntador
referenciado
manejador
nombre
agregar
restar
conteos
referencia
encabezado
objeto
operaciones
interesantes
objetos
llamadas
sistema
API
nativa
NT
muestran
figura
11-9
NtCreateProcess
NtCreateFileo
NtClose(la
función
genérica
cierra
tipos
manejadores
espacio
nombres
objetos
crucial
operación
completa
sistema
po-
cas
personas
siquiera
visible
usuarios
herramien-
tas
visualización
especiales
herramientas
winobj
disponible
costo
www.microsoft.com/technet/sysinternals
ejecutar
herramienta
describe
espacio
nombres
objetos
general
contiene
directorios
objetos
listan
figura
11-21
directorio
extraño
nombre
contiene
nombres
dispositivos
estilo
MS-DOS
disco
flexible
disco
duro
nombres
rea-
lidad
vínculos
simbólicos
directorio
\Device
viven
objetos
eligió
nombre
www.FreeLibros.mepara
estuviera
orden
alfabético
agilizar
búsqueda
nombres
rutas
empiecen
letra
unidad
contenido
directorios
objetos
explica
vimos
administrador
objetos
mantiene
conteo
separado
manejadores
objeto
apuntadores
referenciados
manejador
válido
apuntador
referenciado
objeto
entrada
tabla
manejadores
razón
conteo
separado
manejadores
tipos
objetos
necesiten
limpiar
es-
tado
desaparezca
referencia
usuario
estén
listos
toda-
vía
eliminar
memoria
ejemplo
objetos
archivos
representan
instancia
archivo
abierto
Windows
archivos
abrir
acceso
exclusivo
cierra
manejador
objeto
archivo
importante
eliminar
acceso
exclusivo
punto
esperar
desaparezca
referencia
incidental
kernel
momen-
to
ejemplo
vaciado
datos
memoria
ca-
so
procesos
cerrar
volver
abrir
archivo
usuario
funcionen
espera
archivo
administrador
objetos
mecanismos
extensos
administrar
tiempos
vida
objetos
kernel
APIs
NT
APIs
Win32
proporcionan
me-
canismo
referencia
lidiar
manejadores
hilos
concurrentes
mo-
do
usuario
ende
aplicaciones
multihilo
condiciones
competencia
errores
cerrarán
manejador
hilo
terminar
hilo
cerrarán
ma-
nejador
cerrarán
manejador
hilo
esté
utilizando
volverán
abrir
referencia
objeto
distinto
APIs
Windows
deberían
haberse
diseñado
requirieran
fun-
ción
API
cerrar
tipo
objeto
operación
NtClosegenérica
854
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Directorio
Contenido
Lugar
inicial
buscar
dispositivos
MS-DOS
DosDevices
Nombre
oficial
realidad
vínculo
simbólico
Device
dispositivos
descubiertos
Driver
objetos
corresponden
driver
dispositivo
cargado
ObjectTypes
objetos
tipos
listan
figura
11-22
Windows
Objetos
enviar
mensajes
ventanas
GUI
Win32
BaseNamedObjects
Objetos
Win32
creados
usuario
semáforos
mutexes
etc.
Arcname
Nombres
particiones
descubiertas
cargador
inicio
NLS
Objetos
Soporte
Lenguaje
Nacional
FileSystem
Objetos
drivers
sistema
archivos
objetos
reconocedor
sistema
archivos
Security
Objetos
pertenecen
sistema
seguridad
KnownDLLs
Bibliotecas
compartidas
clave
abren
principio
mantienen
abiertas
Figura
11-21
directorios
comunes
espacio
nombres
objetos
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
855
habría
reducido
frecuencia
errores
producen
hilos
usuario
cierran
manejadores
incorrectos
solución
incrustar
campo
se-
cuencia
manejador
índice
tabla
manejadores
ayudar
escritores
aplicaciones
encontrar
problemas
progra-
Windows
verificador
aplicaciones
desarrolladores
software
descargar
Microsoft
verificador
aplicaciones
verificador
drivers
analizaremos
sección
11.7
realiza
comprobación
extensa
reglas
ayudar
programadores
encontrar
errores
pruebas
ordinarias
encontrar
activar
ordenamiento
tipo
FIFO
lista
manejadores
libres
ma-
nejadores
vuelvan
utilizar
inmediato
desactive
ordenamiento
LIFO
rendimiento
utiliza
general
tablas
manejadores
evitar
vuelvan
utilizar
manejadores
rapidez
transforman
situaciones
ope-
ración
utiliza
manejador
incorrecto
situaciones
manejador
cerrado
fácil
detectar
objeto
dispositivo
importantes
versátiles
kernel
eje-
cutivo
tipo
especifica
administrador
drivers
dispo-
sitivos
principales
usuarios
objetos
dispositivo
relacionados
drivers
general
objeto
dispositivo
vínculo
objeto
controlador
es-
pecífico
describe
acceder
rutinas
procesamiento
driver
co-
rresponde
dispositivo
objetos
dispositivo
representan
dispositivos
hardware
interfaces
buses
particiones
disco
lógicas
volúmenes
disco
sistemas
archivos
extensiones
kernel
filtros
antivirus
drivers
dispositivos
reciben
nombres
utilizar
abrir
manejadores
instancias
dispositivos
UNIX
Utilizaremos
objetos
dispositivo
ilustrar
forma
utiliza
procedimiento
Parse
muestra
figura
11-22
componente
ejecutivo
administrador
implementa
lla-
mada
sistema
nativa
NtCreateFile
llama
ObOpenObjectByNameen
administrador
objetos
pasa
nombre
ruta
Unicode
espacio
nombres
NT
de-
cir
\??\C:\foo\bar
administrador
objetos
busca
directorios
vínculos
simbólicos
últi-
ma
instancia
\??\C
refiere
objeto
dispositivo
tipo
definido
administrador
objeto
dispositivo
nodo
hoja
espa-
cio
nombres
NT
administrador
objetos
administra
administrador
objetos
llama
procedimiento
Parse
tipo
obje-
to
resulta
lopParseDevice
implementado
administrador
S.
pasa
apuntador
objeto
dispositivo
encontró
cadena
restante
\foo\bar
administrador
creará
IRP
Request
Packet
Paquete
peticiones
asignará
objeto
archivo
enviará
petición
pila
dispositivos
deter-
minada
objeto
dispositivo
encontró
administrador
objetos
www
FreeLibros.me5
IRP
pasa
pila
llega
objeto
dispositivo
representa
instancia
sistema
archivos
etapa
control
pasa
punto
entrada
objeto
driver
asociado
objeto
dispositivo
nivel
punto
entrada
utiliza
caso
operaciones
CREATE
petición
crear
abrir
archivo
llamado
\foo\bar
volumen
objetos
dispositivo
IRP
medida
avanza
sistema
archivos
representan
drivers
filtro
sistema
archivos
modificar
operación
llegue
objeto
dispositivo
sistema
archivos
general
dispositivos
intermedios
representan
extensiones
sistema
filtros
antivirus
objeto
dispositivo
sistema
archivos
vínculo
objeto
driver
sis-
tema
archivos
NTFS
objeto
driver
contiene
dirección
operación
CREATE
NTFS
NTFS
llenará
objeto
archivo
devolverá
administrador
regresa
dispositivos
pila
lopParseDeviceregresa
adminis-
trador
objetos
vea
sección
11.8
administrador
objetos
terminó
búsqueda
espacio
nombres
Recibió
vuelta
objeto
inicializado
rutina
Parse
resulta
objeto
archivo
objeto
dispositivo
original
encontró
administrador
objetos
crea
manejador
objeto
archivo
tabla
manejadores
proceso
actual
de-
vuelve
manejador
proceso
llamó
856
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
NtCreateFile(\??\C:\foo\bar
IoCallDriver
IRP
Filtros
sistema
archivos
Win32
CreateFile(C:\foo\bar
OpenObjectByName(\??\C:\foo\bar
Administrador
Administrador
Administrador
objetos
IopParseDevice(DeviceObject,\foo\bar
Pila
dispositivos
NTFS
NtfsCreateFile
IoCallDriver
IoCompleteRequest
usuario
kernel
Devices
Harddisk1
SYMLINK
\Devices\Harddisk1
DEVICE
OBJECT
volumen
2)(3
8)
10
Manejador
Objeto
archivo
Figura
11-22
Pasos
administrador
administrador
objetos
crear
abrir
archivo
recuperar
manejador
archivo
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
857
10
paso
regresar
proceso
usuario
llamada
ejemplo
CreateFilede
API
Win32
devolverá
manejador
aplicación
componentes
ejecutivo
crear
tipos
forma
dinámica
lla-
mada
interfaz
ObCreateObjectTypepara
administrador
objetos
lista
definiti-
tipos
objetos
cambian
versión
comunes
Windows
Vista
listan
figura
11-23
continuación
veremos
análisis
tipos
objetos
figura
Tipo
Descripción
Proceso
Proceso
usuario
Hilo
Hilo
proceso
Semáforo
Semáforo
conteo
utiliza
sincronización
procesos
Mutex
Semáforo
binario
utiliza
entrar
región
crítica
Evento
Objeto
sincronización
persistente
señalado
señalado
Puerto
ALPC
Mecanismo
pasar
mensajes
procesos
Temporizador
Objeto
permite
proceso
permanecer
inactivo
intervalo
fijo
Cola
Objeto
utiliza
notificar
compleción
operación
asíncrona
Archivo
abierto
Objeto
asociado
archivo
abierto
Token
acceso
Descriptor
seguridad
objeto
Perfil
Estructura
datos
utiliza
crear
perfiles
CPU
Sección
Objeto
utiliza
representar
archivos
asignar
Clave
Clave
registro
utiliza
adjuntar
registro
espacio
nombres
administrador
objetos
Directorio
objetos
Directorio
agrupar
objetos
administrador
objetos
Vínculo
simbólico
refiere
objeto
administrador
objetos
nombre
ruta
Dispositivo
Objeto
dispositivo
dispositivo
físico
bus
driver
instancia
volumen
Driver
dispositivo
driver
dispositivo
carga
objeto
Figura
11-23
tipos
objetos
comunes
ejecutivo
maneja
adminis-
trador
objetos
Proceso
hilo
obvios
objeto
proceso
hilo
contiene
pro-
piedades
principales
necesarias
administrar
proceso
hilo
siguientes
objetos
se-
máforo
mutex
evento
lidian
sincronización
procesos
semáforos
mutexes
funcionan
esperada
características
adicionales
ejemplo
valores
máximos
tiempos
límite
eventos
señalados
señala-
hilo
espera
evento
señalado
hilo
libera
inmediato
evento
señalado
bloquea
hilo
señala
evento
libe-
ra
hilos
bloqueados
eventos
notificación
hilo
bloqueado
eventos
www.FreeLibros.mesincronización
establecer
evento
esperado
se-
ñal
éxito
regrese
automática
señalado
permanecer
esta-
do
señalado
objetos
puerto
temporizador
cola
relacionan
comunicación
sin-
cronización
puertos
canales
procesos
intercambiar
mensajes
LPC
tempo-
rizadores
proporcionan
bloquear
intervalo
específico
colas
utilizan
notificar
hilos
empezado
operación
asíncrona
puer-
to
mensaje
espera
diseñados
administrar
nivel
concurrencia
apli-
cación
utilizan
aplicaciones
multiprocesador
alto
rendimiento
SQL
objetos
archivo
abierto
crean
abre
archivo
archivos
abiertos
objetos
administrados
administrador
objetos
tokens
acceso
objetos
seguridad
Identifican
usuario
indican
privilegios
especiales
perfiles
estructuras
utilizan
almacenar
muestras
periódicas
contador
pro-
grama
hilo
ejecución
invierte
tiempo
programa
secciones
utilizan
representar
objetos
memoria
aplicaciones
pedir
administrador
memoria
asigne
espacio
direcciones
Guardan
sección
archivo
archivo
paginación
representa
páginas
objeto
memoria
disco
claves
representan
punto
montaje
espacio
nombres
registro
espacio
nombres
administrador
objetos
general
objeto
clave
llamado
\REGISTRY
conecta
nombres
claves
valores
registro
espacio
nombres
NT
directorios
objetos
vínculos
simbólicos
completo
locales
espacio
nombres
NT
maneja
administrador
objetos
similares
contrapar-
tes
sistema
archivos
directorios
permiten
recolectar
objetos
relacionados
vínculos
simbólicos
permiten
nombre
espacio
nombres
objetos
refiera
objeto
distinta
espacio
nombres
dispositivo
conocido
sistema
operativo
objetos
dispositivo
contienen
información
sistema
utiliza
referencia
dispositivo
úl-
timo
driver
dispositivo
cargado
objeto
driver
espacio
obje-
tos
objetos
drivers
compartidos
objetos
dispositivos
representan
instancias
dispositivos
controlados
drivers
objetos
muestran
propósitos
especializados
interactuar
transacciones
kernel
fábrica
hilos
trabajadores
reserva
hilos
Win32
11.3.4
Subsistemas
DLLs
servicios
usuario
regresamos
figura
11-6
sistema
operativo
Windows
Vista
consiste
componentes
kernel
componentes
usuario
completado
descripción
general
componentes
kernel
tiempo
ana-
lizar
componentes
usuario
tipos
especialmente
im-
portantes
Windows
subsistemas
entorno
DLLs
procesos
servicio
descrito
modelo
subsistemas
Windows
entraremos
detalles
mencionaremos
diseño
original
NT
subsistemas
veían
858
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.3
ESTRUCTURA
SISTEMA
859
forma
proporcionar
personalidades
sistema
operativo
ejecuta
software
subyacente
kernel
intento
evitar
sistemas
operativos
compitieran
plataforma
VMS
Berkeley
UNIX
VAX
DEC
Microsoft
sabía
OS/2
tendría
éxito
interfaz
progra-
mación
cubriendo
apuestas
forma
OS/2
irrelevante
participante
tardío
API
Win32
diseñada
compartirla
Windows
95
terminó
interfaz
dominante
aspecto
clave
diseño
usuario
Windows
biblioteca
víncu-
dinámicos
DLL
consiste
código
vincula
programas
ejecutables
tiem-
po
ejecución
tiempo
compilación
bibliotecas
compartidas
concepto
mayoría
sistemas
operativos
modernos
utilizan
Windows
ca-
bibliotecas
DLLs
biblioteca
sistema
ntdll.dll
carga
pro-
ceso
bibliotecas
alto
nivel
funciones
comunes
destinadas
permitir
desarrolladores
aplicaciones
reutilicen
código
proliferante
DLLs
mejoran
eficiencia
sistema
permiten
compartir
código
común
procesos
reducen
tiempos
carga
programas
disco
mantener
código
común
memoria
incrementan
capacidad
servicio
sistema
permitir
actualizar
código
biblioteca
sistema
operativo
recompilar
volver
enlazar
programas
aplicación
utilizan
bibliotecas
compartidas
introducen
problema
control
versiones
aumentan
complejidad
sistema
cambios
introducidos
biblioteca
comparti-
ayudar
programa
específico
potencial
exponer
errores
latentes
aplicaciones
fallen
cambios
implementación
problema
mundo
Windows
conoce
infierno
DLLs
implementación
DLLs
simple
concepto
compilador
emita
código
llame
directamente
subrutinas
imagen
ejecutable
introduce
ni-
vel
indirección
IAT
Import
Address
Table
Tabla
direcciones
importación
carga
ejecutable
busca
lista
DLLs
cargar
grafo
general
general
DLLs
aparezcan
lista
requerirán
lista
DLLs
ejecutarse
DLLs
requeridas
cargan
llena
IAT
realidad
complicada
problema
grafos
representan
relaciones
DLLs
contener
ciclos
comportamientos
determinísticos
cálculo
lista
DLLs
cargar
producir
secuencia
funcione
Ade-
Windows
bibliotecas
DLL
oportunidad
ejecutar
código
car-
gan
proceso
crea
hilo
general
puedan
inicialización
asignar
almacenamiento
hilo
DLLs
realizan
cálcu-
rutinas
adjuntar
cualquiera
funciones
llamadas
rutina
adjun-
tar
necesita
examinar
lista
DLLs
cargadas
ocurrir
interbloqueo
deje
suspendido
proceso
DLLs
utilizan
compartir
código
común
Permiten
modelo
hos-
ting
extender
aplicaciones
Internet
Explorer
descargar
crear
vínculos
DLLs
co-
nocidas
controles
ActiveX
extremo
Internet
servidores
Web
www.FreeLibros.mepueden
cargar
código
dinámico
producir
experiencia
Web
páginas
muestran
aplicaciones
Microsoft
Office
vinculan
ejecutan
DLLs
utilizar
Office
plataforma
construir
aplicaciones
estilo
COM
modelo
objetos
componentes
programación
permite
programas
buscar
cargar
forma
dinámica
có-
digo
escrito
proporcionar
interfaz
publicada
específica
produce
hosting
DLLs
proceso
aplicaciones
utilizan
COM
carga
dinámica
código
producido
complejidad
sistema
operativo
administración
versiones
bibliotecas
cuestión
asociar
ejecutables
versiones
correctas
DLLs
cargar
versiones
DLL
proceso
Microsoft
denomina
pro-
grama
hospedar
bibliotecas
código
dinámicas
distintas
cargar
biblioteca
Windows
distintos
requerimientos
versión
biblioteca
solución
hospedar
código
procesos
separados
hospedar
código
fue-
ra
proceso
produce
menor
rendimiento
casos
modelo
programa-
ción
complicado
Microsoft
desarrollado
solución
complejidad
usuario
razón
programadores
anhelan
simplicidad
relati-
kernel
razones
kernel
complejidad
usuario
proporciona
relativamente
oportunidades
extensibilidad
modelo
driver
dispositivo
Windows
funcionalidad
sistema
extiende
escritu-
ra
servicios
usuario
funciona
subsistemas
proporcionan
servicios
personalidad
completa
sistema
operati-
vo
relativamente
diferencias
funcionales
servicios
implementan
kernel
servicios
implementan
procesos
usuario
kernel
co-
mo
proceso
proporcionan
espacios
direcciones
privadas
proteger
es-
tructuras
datos
escudriñar
peticiones
servicio
diferencias
considerables
rendimiento
servicios
kernel
servicios
procesos
usuario
proceso
entrar
kernel
usuario
lento
hardware
moderno
ve-
ces
cambiar
proceso
comunicación
proceso
menor
an-
cho
banda
código
kernel
acceder
cuidado
datos
direccio-
nes
usuario
pasan
parámetros
llamadas
sistema
servicios
usuario
datos
copiar
proceso
servicio
jugar
asig-
nación
memoria
proceso
herramientas
ALPC
Windows
Vista
en-
cargan
plano
futuro
reduzcan
requerimientos
hardware
cam-
biar
espacios
direcciones
modos
protección
vuelva
irrelevante
proyecto
Singularidad
Microsoft
Research
Fandrich
colaboradores
2006
utiliza
técnicas
tiempo
ejecución
utilizan
Java
protección
cues-
tión
software
requiere
cambiar
hardware
espacios
direccio-
nes
modos
protección
860
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
861
Windows
Vista
utiliza
considerable
procesos
servicio
usuario
pa-
ra
extender
funcionalidad
sistema
servicios
lazos
estrechos
operación
componentes
kernel
lsass.exe
servicio
autenticación
se-
guridad
local
administra
objetos
token
representan
identidad
usuario
tam-
bién
administra
claves
cifrado
utilizadas
sistema
archivos
administrador
plug-and-play
usuario
responsable
determinar
driver
correcto
utilizar
encontrar
dispositivo
hardware
instalarlo
kernel
cargue
herramientas
proporcionadas
terceras
partes
antivirus
administración
de-
rechos
digitales
implementan
combinación
drivers
kernel
servicios
usuario
Windows
Vista
taskmgr.exe
ficha
identifica
servicios
ejecutan
sistema
versiones
anteriores
Windows
muestran
lista
servicios
comando
net
start
servicios
ejecución
proceso
svchost.exe
Windows
ha-
ce
servicios
tiempo
inicio
reducir
tiempo
necesario
iniciar
sistema
servicios
combinar
proceso
puedan
operar
forma
segura
credenciales
seguridad
procesos
servicio
compartidos
servicios
individuales
car-
gan
DLLs
general
comparten
reserva
hilos
herramienta
reserva
hilos
Win32
mínimo
número
hilos
ejecución
en-
tre
servicios
residentes
servicios
fuentes
comunes
vulnerabilidades
seguridad
sistema
frecuencia
acceder
forma
remota
dependiendo
configuracio-
nes
firewall
TCP
IP
seguridad
IP
programadores
escriben
servi-
cios
cuidadosos
deberían
validar
parámetros
búferes
pasan
RPC
número
servicios
ejecutan
constante
Windows
asombroso
servicios
reciben
petición
probable
proven-
gan
atacante
trate
explotar
vulnerabilidad
resultado
servi-
cios
Windows
desactivan
predeterminada
especial
versiones
Windows
Server
11.4
PROCESOS
HILOS
WINDOWS
VISTA
Windows
conceptos
administrar
CPU
agrupar
recursos
si-
guientes
secciones
examinaremos
conceptos
analizaremos
llamadas
relevan-
tes
API
Win32
implementan
11.4.1
Conceptos
fundamentales
Windows
Vista
procesos
contenedores
programas
Contienen
espacio
di-
recciones
virtuales
manejadores
referencia
objetos
kernel
hi-
papel
contenedor
hilos
contienen
recursos
comunes
utilizan
www.FreeLibros.mepara
ejecución
hilos
apuntador
estructura
cuotas
objeto
token
compar-
tido
parámetros
predeterminados
utilizan
inicializar
hilos
incluyendo
prioridad
clase
planificación
proceso
datos
sistema
usuario
conocidos
co-
mo
PEB
Process
Environment
Block
Bloque
entorno
proceso
PEB
incluye
lista
módulos
cargados
EXEs
DLLs
memoria
contiene
cadenas
entorno
di-
rectorio
actual
trabajo
datos
administrar
montículos
proceso
montículo
código
Win32
casos
especiales
acumulado
tiempo
hilos
abstracción
kernel
programar
CPU
Windows
asignan
priorida-
des
hilo
base
valor
prioridad
proceso
contenedor
hilos
afinidad
ejecutarse
procesadores
ayuda
programas
concurrentes
ejecutan
multiprocesadores
esparcir
trabajo
explícita
hilo
pilas
llamadas
separadas
ejecución
usuario
kernel
TEB
Thread
Environment
Block
Bloque
entorno
hilo
mantie-
ne
datos
usuario
específicos
hilo
incluyendo
almacenamiento
hilo
Thread
Local
Storage
Almacenamiento
local
hilo
campos
Win32
lenguaje
locali-
zación
cultural
campos
especializados
agregado
herra-
mientas
PEBs
TEBs
estructura
datos
kernel
compar-
proceso
datos
compartidos
usuario
página
kernel
escribir
lectura
procesos
usuario
Contiene
valores
mantenidos
kernel
formas
hora
información
versión
cantidad
memoria
física
número
banderas
compartidas
utilizan
componentes
usuario
COM
servicios
terminal
depuradores
página
compartida
lectura
optimización
rendimiento
valores
obtener
llamada
sistema
kernel
llamadas
sistema
costosas
acceso
memoria
campos
mantenidos
sistema
hora
sentido
campos
zona
horaria
ac-
tual
cambian
frecuencia
código
depende
campos
consultar
frecuencia
cambiado
Procesos
procesos
crean
objetos
sección
describe
objeto
memoria
respaldado
archivo
disco
crea
proceso
proceso
creador
re-
cibe
manejador
proceso
creado
permite
modificar
proceso
asignación
secciones
memoria
virtual
escritura
parámetros
datos
entor-
duplicación
descriptores
archivos
tabla
manejadores
creación
hilos
Es-
to
distinto
forma
crean
procesos
UNIX
refleja
diferencia
sistemas
destino
diseños
originales
UNIX
comparación
Windows
vimos
sección
11.1
UNIX
diseñó
sistemas
procesador
16
bits
utilizaban
intercambio
compartir
memoria
procesos
dichos
sistemas
idea
brillante
proceso
unidad
concurrencia
utilizar
operación
fork
crear
procesos
ejecutar
proceso
memoria
hardware
me-
862
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
863
moria
virtual
procesos
memoria
intercambiar
disco
crear
espacio
principio
Unix
implementaba
fork
intercambiar
proceso
padre
disco
pasar
memoria
física
hijo
operación
repercusiones
contrario
entorno
hardware
equipo
Cutler
escribió
NT
siste-
multiprocesadores
32
bits
hardware
memoria
virtual
compartir
16
MB
memoria
física
multiprocesadores
ofrecen
oportunidad
ejecutar
partes
progra-
forma
concurrente
NT
utilizaba
procesos
contenedores
compartir
memoria
recursos
objetos
utilizaba
hilos
unidad
concurrencia
programación
sistemas
años
parecerán
entornos
destino
espacios
direcciones
64
bits
docenas
cientos
núcleos
CPU
socket
chip
GB
memoria
física
dispositivos
flash
tipos
almacenamiento
volátil
agregados
jerarquía
memoria
soporte
virtualización
redes
ubicuas
soporte
innovaciones
sincronización
me-
moria
transaccional
Windows
UNIX
seguirán
adaptándose
realidades
hardwa-
re
realmente
interesante
sistemas
operativos
diseñados
específica
sistemas
base
avances
Trabajos
fibras
Windows
agrupar
procesos
trabajos
abstracción
trabajo
general
diseñó
específica
agrupar
procesos
aplicar
restricciones
hilos
contienen
limitación
recurso
cuota
compartida
imple-
mentación
token
restringido
evitar
hilos
accedan
objetos
sistema
propiedad
importante
trabajos
administración
recursos
proceso
trabajo
procesos
hilos
creen
procesos
es-
tarán
tarea
escapatoria
sugiere
nombre
trabajos
diseñaron
si-
tuaciones
parecen
procesamiento
lotes
computación
interactiva
ordinaria
proceso
trabajo
sentido
difícil
definir
significado
proceso
esté
sujeto
cuotas
compartidas
tokens
restringidos
es-
to
significa
servicios
sistema
tratan
trabajos
administrar
procesos
conflictos
intentan
administrar
procesos
ejemplo
herramienta
admi-
nistrativa
tratara
restringir
recursos
colocar
procesos
tareas
frustraría
proceso
inserta
trabajo
herramienta
seguridad
hubiera
colocado
proceso
trabajo
token
restringido
limitar
acceso
objetos
sistema
resultado
trabajos
Windows
raro
figura
11-24
muestra
relación
trabajos
procesos
hilos
fibras
trabajos
contie-
nen
procesos
procesos
contienen
hilos
hilos
contienen
fibras
relación
hilos
fibras
general
crear
fibras
asigna
pila
estructura
datos
tipo
fibra
usuario
pa-
ra
almacenar
registros
datos
asociados
fibra
hilos
convierten
fibras
fibras
crear
forma
independiente
hilos
Dichas
fibras
ejecutarán
www.FreeLibros.mesino
fibra
esté
ejecutando
hilo
llame
explícita
Switch-
ToFiberpara
ejecutar
fibra
hilos
tratar
cambiar
fibra
ejecutan-
do
programador
proporcionar
sincronización
evitarlo
principal
ventaja
fibras
sobrecarga
cambiar
fibra
bas-
tante
menor
sobrecarga
cambiar
hilo
cambio
hilo
requiere
entrar
salir
kernel
cambio
fibra
guardan
restauran
registros
cambiar
modos
fibras
programan
forma
cooperativa
hilos
programan
fi-
bras
requiere
sincronización
cuidadosa
asegurar
interfieran
Pa-
ra
simplificar
interacción
hilos
fibras
conveniente
crear
cantidad
hilos
equivalente
número
procesadores
disponibles
ejecutarlos
afi-
nidad
hilos
ejecute
conjunto
distinto
procesadores
dispo-
nibles
procesador
hilo
ejecutar
subconjunto
específico
fibras
establecer
rela-
ción
hilos
fibras
simplifique
sincronización
formas
dificultades
fibras
mayoría
bibliotecas
Win32
conocen
fibras
absoluto
aplicaciones
tratan
utilizarlas
fueran
hilos
encontra-
rán
fallas
kernel
conocimiento
fibras
entra
ker-
nel
hilo
ejecuta
bloquear
kernel
programará
hilo
arbitrario
procesador
ejecutar
fibras
razones
fibras
utilizan
raras
portar
código
sistemas
necesitan
explícita
funcionali-
dad
proporcionan
figura
11-25
muestra
resumen
abstracciones
Hilos
general
proceso
empieza
hilo
crear
forma
dinámica
hilos
forman
base
programación
CPU
sistema
operativo
selec-
ciona
hilo
ejecutarlo
proceso
consecuencia
hilo
listo
864
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Tarea
Proceso
Proceso
Hilo
Hilo
Hilo
Hilo
Hilo
Fibra
Fibra
Fibra
Fibra
Fibra
Fibra
Fibra
Fibra
Figura
11-24
relación
tareas
procesos
hilos
fibras
tareas
fibras
opcionales
procesos
tareas
contienen
fibras
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
865
ejecución
bloqueado
etc.
procesos
planificación
hilos
crear
forma
dinámica
llamada
Win32
especifique
dirección
den-
tro
espacio
direcciones
proceso
circundante
empezar
ejecución
hilo
ID
hilo
toma
espacio
nombres
IDs
proceso
proceso
hilo
utilizar
ID
tiempo
IDs
procesos
hilos
múltiplos
realidad
asigna
eje-
cutivo
tabla
manejadores
especial
separa
asignación
IDs
sis-
tema
reutiliza
herramienta
administración
manejadores
escalable
muestra
figuras
11-18
11-19
tabla
manejadores
referencias
objetos
utiliza
campo
apuntador
apuntar
proceso
hilo
búsqueda
proceso
hilo
ID
eficiente
ordenamiento
FIFO
lista
manejadores
libres
acti-
tabla
IDs
versiones
recientes
Windows
IDs
reutilicen
inmediato
capítulo
exploraremos
problemas
reutilización
inmediata
sección
problemas
general
hilo
ejecuta
usuario
llamada
sistema
cambia
kernel
continúa
ejecución
hilo
propiedades
límites
usuario
hilo
pilas
usarla
mo-
do
usuario
usarla
kernel
hilo
entra
kernel
cambia
pila
kernel
valores
registros
usuario
guardan
estruc-
tura
datos
llamada
CONTEXT
base
pila
kernel
única
forma
hilo
usuario
ejecute
kernel
contexto
CONTEXT
hilo
contiene
registros
ejecuta
contexto
CONTEXT
hilo
examinar
modificar
proceso
manejador
hilo
general
hilos
ejecutan
token
acceso
proceso
contiene
casos
relacionados
modelo
cliente
servidor
hilo
ejecuta
pro-
ceso
servicio
hacerse
pasar
cliente
token
acceso
tempo-
ral
base
token
cliente
operaciones
beneficio
general
servicio
utilizar
token
actual
cliente
cliente
servidor
ejecutar
distintos
sistemas
hilos
punto
focal
normal
S.
hilos
bloquean
ope-
raciones
síncronas
paquetes
petición
restantes
operaciones
asíncronas
vinculan
hilo
hilo
termina
ejecución
concluir
Nombre
Descripción
Notas
Tarea
Colección
procesos
comparten
cuotas
límites
utiliza
raras
Proceso
Contenedor
guardar
recursos
Hilo
Entidad
programada
kernel
Fibra
Hilo
ligero
administra
completo
espacio
usuario
utiliza
raras
Figura
11-25
Conceptos
básicos
utilizan
administración
CPU
recursos
www.FreeLibros.mepetición
pendiente
hilo
cancelará
hilo
esté
activo
proce-
so
termine
proceso
terminará
importante
hilos
concepto
programación
propiedad
recursos
hilo
acceder
objetos
pertenecen
proceso
utilizar
valor
manejador
llamada
apropiada
Win32
restricción
hilo
acceder
objeto
hilo
distinto
abier-
to
creado
sistema
siquiera
mantiene
registro
hilo
creó
objeto
manejador
coloca
tabla
manejadores
proceso
hilo
proceso
pue-
utilizarlo
pasar
usuario
distinto
vimos
hilos
normales
ejecutan
procesos
usua-
rio
Windows
hilos
sistema
ejecutan
kernel
asociados
proceso
usuario
hilos
sistema
ejecutan
proceso
especial
conocido
proceso
sistema
proceso
espacio
direcciones
usuario
Proporciona
entorno
ejecutan
hilos
operan
bene-
ficio
proceso
específico
usuario
estudiaremos
pro-
cesos
administración
memoria
realizan
tareas
administrativas
escritura
páginas
sucias
disco
forman
reserva
hilos
trabajadores
asignan
ejecutar
tareas
corto
plazo
delegadas
componentes
ejecutivo
drivers
necesitan
trabajo
proceso
sistema
11.4.2
Llamadas
API
administrar
trabajos
procesos
hilos
fibras
procesos
crean
función
CreateProcessde
API
Win32
función
parámetros
opciones
Recibe
nombre
archivo
ejecutar
cade-
nas
línea
comandos
analizar
apuntador
cadenas
entorno
banderas
valores
controlan
detalles
forma
configura
seguridad
proceso
hilo
configuración
depurador
prioridades
planificación
bandera
especifica
manejadores
abiertos
proceso
creador
pasar
proceso
función
recibe
directorio
actual
trabajo
pro-
ceso
estructura
datos
opcional
información
acerca
Ventana
GUI
uti-
lizar
proceso
devolver
ID
proceso
Win32
devuelve
manejadores
IDs
proceso
hilo
inicial
número
parámetros
revela
diferencias
comparación
diseño
creación
procesos
UNIX
ruta
actual
búsqueda
encontrar
programa
ejecutar
enterrada
código
biblioteca
Win32
administra
explícita
UNIX
UNIX
directorio
actual
trabajo
concepto
kernel
Win-
dows
cadena
usuario
Windows
síabre
manejador
directorio
ac-
tual
proceso
efecto
molesto
UNIX
eliminar
directorio
encuentre
red
866
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
867
UNIX
analiza
línea
comandos
pasa
arreglo
parámetros
Win32
deja
análisis
argumentos
haga
programa
individual
conse-
cuencia
distintos
programas
manejar
comodines
ejemplo
.txt
símbolos
especiales
inconsistente
opción
heredar
descriptores
archivos
UNIX
propiedad
ma-
nejador
Windows
propiedad
manejador
parámetro
creación
proceso
Win32
orientado
GUI
procesos
reciben
información
ma-
nera
directa
ventana
primaria
información
pasa
forma
parámetros
aplicaciones
GUI
UNIX
Windows
bit
SETUID
propiedad
ejecutable
proceso
crear
proceso
ejecute
usuario
distinto
obte-
ner
token
credenciales
usuario
manejador
proceso
hilo
devuelven
Windows
utilizar
pa-
ra
modificar
proceso
hilo
formas
sustantivas
incluyendo
duplica-
ción
manejadores
establecimiento
variables
entorno
proceso
UNIX
realiza
modificaciones
procesos
llamadas
fork
exec
diferencias
históricas
filosóficas
UNIX
diseñó
orientado
línea
comandos
GUI
Windows
usuarios
UNIX
sofisticados
comprenden
conceptos
variables
PATH
Windows
Vista
heredó
características
MS-DOS
comparación
torcida
Win32
envoltura
usuario
alre-
dedor
ejecución
proceso
nativo
NT
forma
parecida
envolturas
fork
exec
función
biblioteca
system
UNIX
llamadas
sistema
actuales
NT
crear
pro-
cesos
hilos
NtCreateProcessy
NtCreateThread
simples
versiones
Win32
principales
parámetros
creación
procesos
NT
manejador
sección
representa
archivo
programa
ejecutar
bandera
especifica
proceso
predeterminada
heredar
manejadores
creador
parámetros
re-
lacionados
modelo
seguridad
detalles
establecer
cadenas
entorno
crear
hilo
inicial
dejan
código
usuario
utilizar
manejador
nue-
vo
proceso
manipular
espacio
direcciones
virtuales
directa
soporte
subsistema
POSIX
creación
procesos
nativos
opción
crear
proceso
copiar
espacio
direcciones
virtuales
proceso
asignar
objeto
sección
programa
utiliza
implementar
forkpara
POSIX
Win32
creación
hilos
pasa
contexto
CPU
utilice
hilo
incluye
apuntador
pila
apuntador
instrucción
inicial
plantilla
TEB
www.FreeLibros.mebandera
indica
hilo
ejecutar
inmediato
crear
suspen-
dido
espera
alguien
llame
NtResumeThread
manejador
acciones
crear
pila
usuario
meter
parámetros
argv
argc
dejan
código
usuario
llamadas
APIs
administración
memoria
nativas
NT
mane-
jador
proceso
versión
Windows
Vista
incluyó
API
nativa
procesos
mue-
ve
pasos
usuario
ejecutivo
kernel
combina
creación
proceso
creación
hilo
inicial
razón
cambio
aceptar
procesos
límites
seguridad
general
procesos
creados
usua-
rio
confianza
usuario
representa
token
determi-
na
límite
confianza
cambio
Windows
Vista
permite
procesos
proporcionar
límites
confianza
significa
proceso
creador
per-
misos
suficientes
relación
manejador
procesos
implementar
detalles
creación
procesos
usuario
Comunicación
procesos
hilos
comunicar
formas
incluyendo
tuberías
tuberías
nombre
ranuras
correo
sockets
llamadas
procedimientos
remotos
archivos
compartidos
tuberías
modos
byte
mensaje
selecciona
momento
crea-
ción
tuberías
byte
funcionan
UNIX
tuberías
mensa-
je
similares
preservan
límites
mensajes
escrituras
128
bytes
leerán
mensajes
128
bytes
mensaje
512
bytes
ocurrir
tuberías
byte
tuberías
nombre
modos
regulares
tuberías
nombre
utilizar
tra-
vés
red
regulares
ranuras
correo
característica
sistema
operativo
OS/2
implementó
Windows
cuestión
compatibilidad
similares
tuberías
formas
ejemplo
vía
tuberías
vías
utilizar
red
ofrecer
entrega
garantizada
permiten
proceso
emisor
transmita
mensaje
receptores
ranuras
correo
tuberías
nombre
implementan
sistemas
archivos
Windows
implementarse
funciones
ejecutivo
forma
utilizar
red
protocolos
existentes
sistemas
archivos
remotos
sockets
tuberías
general
conectan
procesos
distintas
máquinas
ejemplo
proceso
escribe
socket
máquina
remota
lee
infor-
mación
sockets
utilizar
conectar
procesos
má-
quina
generan
sobrecarga
tuberías
general
utilizan
contexto
red
sockets
diseñaron
originalmente
Berkeley
UNIX
implementación
disponible
partes
estructuras
datos
código
Ber-
keley
siguen
presentes
Windows
actualidad
reconoce
notas
versión
sistema
868
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
869
RPCs
llamadas
procedimientos
remotos
forma
proceso
haga
proceso
llame
procedimiento
espacio
direcciones
beneficio
devuelva
resultado
A.
restricciones
parámetros
ejemplo
sentido
pasar
apuntador
proceso
distinto
estructuras
datos
empaquetar
transmitir
específica
procesos
general
RPC
implemen-
ta
nivel
abstracción
nivel
transporte
caso
Windows
trans-
porte
sockets
TCP
IP
tuberías
nombre
ALPC
ALPC
Llamada
avanzada
procedimiento
local
herramienta
pasar
mensajes
ejecutivo
kernel
optimizado
comunicación
procesos
máquina
local
ope-
ra
red
diseño
básico
enviar
mensajes
generan
respuesta
imple-
menta
versión
ligera
llamada
procedimientos
remotos
paquete
RPC
crear
nivel
superior
proporcionar
conjunto
extenso
características
disponibles
ALPC
herramienta
implementa
combinación
parámetros
co-
pia
asignación
temporal
memoria
compartida
base
tamaño
mensajes
procesos
compartir
objetos
incluye
objetos
sesión
asignar
espacio
direcciones
virtuales
distintos
procesos
tiempo
escrituras
realice
proceso
aparecerán
espacios
direcciones
procesos
mecanismo
implementar
facilidad
búfer
compar-
tido
utiliza
problemas
productor-consumidor
Sincronización
procesos
utilizar
tipos
objetos
sincronización
Windows
Vista
proporciona
mecanismos
comunicación
procesos
proporciona
mu-
chos
mecanismos
sincronización
incluyendo
semáforos
mutexes
regiones
críticas
eventos
mecanismos
funcionan
hilos
procesos
cuan-
do
bloquea
hilo
semáforo
hilos
proceso
vean
afec-
tados
puedan
seguir
ejecución
crear
semáforo
utiliza
función
CreateSempahorede
API
Win32
ini-
cializarlo
valor
definir
valor
máximo
semáforos
objetos
ker-
nel
ende
descriptores
seguridad
manejadores
manejador
semáforo
duplicar
DuplicateHandley
pasar
proceso
puedan
sincronizar
procesos
semáforo
semáforo
recibir
nombre
espacio
nombres
Win32
ACL
protegerlo
apropiado
compartir
semáforo
nombre
duplicar
manejador
llamadas
upy
down
siguientes
nombres
raros
ReleaseSemapho-
re
up
WaitForSingleObject(para
down
tiempo
límite
Wait-
ForSingleObject
liberar
hilo
llamada
momento
semáforo
permanece
temporizadores
vuelven
introducir
condiciones
competencia
WaitForSingleObjecty
WaitForMultipleObjectsson
interfaces
comunes
utilizan
esperar
objetos
despachadores
vimos
sección
11.3
hubiera
envolver
versión
objeto
APIs
envoltura
nombre
www.FreeLibros.mepoco
amigable
semáforos
hilos
utilizan
versión
objetos
pue-
incluir
esperar
tipos
objetos
sincronización
eventos
ter-
minación
procesos
hilos
compleción
operaciones
disponibilidad
mensajes
sockets
puertos
mutexes
objetos
kernel
utilizan
sincronización
simples
semáforos
contadores
esencia
bloqueos
funciones
API
bloquear
WaitForSingleObjecty
desbloquear
ReleaseMutex
manejadores
semáforos
manejadores
mutexes
duplicar
pasar
procesos
hilos
distintos
procesos
puedan
acceder
mutex
tercer
mecanismo
sincronización
llamado
secciones
críticas
implementa
concepto
regiones
críticas
similares
mutexes
Windows
lo-
cales
espacio
direcciones
hilo
creador
secciones
críticas
objetos
kernel
manejadores
explícitos
descriptores
seguridad
pa-
sar
procesos
operaciones
bloqueo
desbloqueo
realizan
EnterCriticalSection
LeaveCriticalSection
respectivamente
funciones
API
ejecutan
principio
espacio
usuario
llamadas
kernel
necesita
bloqueo
rápidas
mutexes
secciones
críticas
optimizan
combinar
espera
activa
multiprocesadores
sincronización
kernel
utiliza
necesario
aplicaciones
raro
contiendas
mayoría
secciones
críticas
tiem-
pos
contención
cortos
necesario
asignarles
objeto
sincronización
ker-
nel
produce
ahorros
considerables
memoria
kernel
mecanismo
sincronización
analizaremos
utiliza
objetos
kernel
co-
nocidos
eventos
vimos
tipos
eventos
notificación
eventos
sin-
cronización
evento
señalado
señalado
hilo
esperar
señale
evento
WaitForSingleObject
hilo
señala
evento
SetEvent
ocurra
dependerá
tipo
evento
evento
notificación
hi-
espera
liberan
evento
permanece
activo
borra
forma
manual
median-
ResetEvent
evento
sincronización
hilos
espera
libera
hilo
borra
evento
operación
alternativa
PulseEvent
SetEventsólo
esperando
pierde
pulso
borra
evento
contrario
operación
SetEventque
ocurre
hilos
espera
recuerda
evento
deja
se-
ñalado
hilo
subsiguiente
llame
función
espera
API
evento
esperar
número
llamadas
API
Win32
lidian
procesos
hilos
fibras
100
mayoría
tratan
IPC
forma
figura
11-26
muestra
resu-
men
llamadas
descritas
llamadas
importantes
llamadas
sistema
envolventes
contienen
cantidad
considerable
código
biblioteca
asigna
se-
mántica
Win32
APIs
nativas
NT
APIs
fibras
funciones
utilizan
usuario
vimos
kernel
Windows
Vis-
ta
fibras
implementan
completo
bibliotecas
usuario
870
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
871
11.4.3
Implementación
procesos
hilos
sección
analizaremos
detalle
forma
Windows
crea
proceso
hilo
inicial
Win32
interfaz
documentada
empezaremos
bajaremos
ra-
pidez
nivel
kernel
comprender
implementación
llamada
API
nativa
pa-
ra
crear
proceso
detalles
específicos
ignoraremos
ejemplo
WOW16
WOW64
código
especial
ruta
creación
for-
ma
sistema
suministra
correcciones
específicas
aplicaciones
sortear
pe-
queñas
incompatibilidades
errores
latentes
aplicaciones
enfocaremos
rutas
código
principal
ejecutan
crean
procesos
analizaremos
al-
gunos
detalles
rellenan
huecos
relación
visto
proceso
crea
proceso
realiza
llamada
CreateProcessde
Win32
lla-
mada
invoca
procedimiento
usuario
kernel32.dll
crea
proceso
va-
rios
pasos
llamadas
sistema
realización
trabajo
Función
API
Win32
Descripción
CreateProcess
Crea
proceso
CreateThread
Crea
hilo
proceso
existente
CreateFiber
Crea
fibra
ExitProcess
Termina
proceso
actual
hilos
ExitThread
Termina
hilo
ExitFiber
Termina
fibra
SwitchToFiber
Ejecuta
fibra
distinta
hilo
actual
SetPriorityClass
Establece
clase
prioridad
proceso
SetThreadPriority
Establece
prioridad
hilo
CreateSemaphore
Crea
semáforo
CreateMutex
Crea
mutex
OpenSemaphore
Abre
semáforo
existente
OpenMutex
Abre
mutex
existente
WaitForSingleObject
bloquea
semáforo
mutex
etc.
WaitForMultipleObjects
bloquea
conjunto
objetos
cuyos
manejadores
proporcionan
PulseEvent
Establece
evento
señalado
señalado
ReleaseMutex
Libera
mutex
hilo
adquirir
ReleaseSemaphore
Incrementa
conteo
semáforos
EnterCriticalSection
Adquiere
bloqueo
sección
crítica
LeaveCriticalSection
Libera
bloqueo
sección
crítica
Figura
11-26
llamadas
Win32
administrar
procesos
hilos
fibras
www
FreeLibros.me1
convierte
nombre
archivo
ejecutable
recibe
parámetro
nombre
ruta
Win32
nombre
ruta
NT
ejecutable
nombre
nombre
ruta
directorio
busca
directorios
lista
directorios
predeter-
minados
incluyen
limitan
aparecen
variable
PATH
en-
torno
empaquetan
parámetros
creación
procesos
pasan
nombre
ruta
completo
programa
ejecutable
llamada
NtCreateProcessde
API
nativa
es-
ta
API
Windows
Vista
detalles
creación
procesos
pu-
dieran
manejar
kernel
procesos
pudieran
utilizar
límite
confianza
APIs
nativas
anteriores
describimos
llama-
CreateProcessde
Win32
utiliza
ejecutarse
kernel
NtCreateUserProcessprocesa
parámetros
abre
imagen
programa
crea
objeto
sección
utilizar
asignar
programa
espacio
direcciones
virtuales
proceso
administrador
procesos
asigna
inicializa
objeto
proceso
estructura
da-
tos
kernel
representa
proceso
nivel
kernel
nivel
ejecutivo
administrador
memoria
crea
espacio
direcciones
proceso
asigna
inicializa
directorios
páginas
descriptores
direcciones
virtua-
describen
porción
correspondiente
kernel
incluyendo
regiones
específicas
proceso
entrada
directorio
páginas
autoasignación
otorga
proceso
acceso
kernel
páginas
físicas
tabla
páginas
direcciones
virtuales
kernel
sección
11.5
descri-
biremos
detalle
autoasignación
crea
tabla
manejadores
proceso
permite
heredar
dupli-
car
manejadores
proceso
llamada
asigna
página
usuario
compartida
administrador
memoria
inicializa
es-
tructuras
datos
conjunto
trabajo
utilizan
decidir
páginas
recortar
proceso
memoria
física
esté
nivel
piezas
imagen
ejecutable
representadas
objeto
sección
asignan
espacio
di-
recciones
usuario
proceso
ejecutivo
crea
inicializa
Bloque
Entorno
Proceso
PEB
usuario
utiliza
usuario
kernel
mantener
infor-
mación
nivel
proceso
apuntadores
montón
usua-
rio
lista
bibliotecas
cargadas
DLLs
asigna
memoria
virtual
proceso
utiliza
pasar
parámetros
inclu-
yendo
cadenas
entorno
línea
comandos
872
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
873
10
asigna
ID
proceso
tabla
manejadores
especial
tabla
IDs
mantie-
ne
kernel
asignar
eficiencia
IDs
únicos
forma
local
proce-
sos
hilos
11
asigna
inicializa
objeto
hilo
asigna
pila
usuario
Bloque
Entorno
Hilo
TEB
inicializa
registro
CONTEXT
contiene
va-
lores
iniciales
hilo
registros
CPU
incluyendo
apuntadores
instruc-
ción
pila
12
agrega
objeto
proceso
lista
global
procesos
manejadores
ob-
jetos
proceso
hilo
asignan
tabla
manejadores
proceso
llama-
asigna
ID
hilo
inicial
tabla
IDs
13
NtCreateUserProcessregresa
usuario
proceso
recién
creado
contenien-
do
hilo
suspendido
listo
ejecución
14
falla
API
NT
código
Win32
comprueba
proceso
perte-
neciente
subsistema
WOW64
programa
esté
marcado
forma
deba
ejecutar
depurador
casos
especiales
manejan
códi-
go
especial
código
CreateProcessen
usuario
15
NtCreateUserProcesstiene
éxito
queda
trabajo
procesos
Win32
registrar
proceso
subsistema
Win32
csrss.exe
Kernel32.dll
envía
mensaje
csrss
indicarle
proceso
manejadores
proceso
hilo
duplicar
proceso
hilos
rein-
troducen
tablas
subsistemas
tengan
lista
completa
to-
procesos
hilos
Win32
subsistema
muestra
cursor
contiene
apuntador
reloj
arena
indicar
usuario
ocurriendo
utilizar
cursor
proceso
realiza
llama-
GUI
general
crear
ventana
cursor
quita
acaba
tiempo
límite
segundos
próxima
llamada
16
proceso
restringido
Internet
Explorer
permisos
token
mo-
difica
restringir
objetos
acceder
proceso
17
programa
aplicación
marca
necesita
corrección
ejecutarse
ma-
nera
compatible
versión
actual
Windows
aplican
correcciones
necesarias
general
correcciones
envuelven
llamadas
biblioteca
modificar
comportamiento
devolver
número
versión
falso
retrasar
libera-
ción
memoria
18
llamada
NtResumeThreadpara
reanudar
ejecución
hilo
devuelve
estructura
proceso
llamada
contiene
IDs
mane-
jadores
proceso
hilo
acaban
crear
www
FreeLibros.mePlanificación
kernel
Windows
hilo
planificación
central
hilo
seguir
ejecutándose
entra
kernel
llama
planificador
hilo
cambiar
siguientes
condiciones
ocasionan
hilo
actual
ejecución
ejecu-
código
planificador
hilo
actual
ejecución
bloquea
semáforo
mutex
evento
operación
etc.
hilo
señala
objeto
ejemplo
realiza
operación
upen
semáforo
señale
evento
quantum
expira
caso
hilo
ejecutando
kernel
cabo
operación
despachador
objeto
S.
continuar
llama
código
planificador
elija
sucesor
cargue
registro
CONTEXTde
hilo
continuar
ejecución
caso
hilo
ejecución
kernel
señalar
objeto
seguir
ejecución
acción
señalizar
objeto
produce
bloqueo
hilo
llamar
planificador
resultado
acción
liberado
hilo
prioridad
planificación
listo
ejecutarse
produce
cambio
hilos
Windows
completamente
preferente
cambios
hilos
ocurrir
momento
quantum
hilo
actual
em-
bargo
caso
multiprocesador
hilo
listo
planifi-
CPU
distinta
hilo
original
seguir
ejecutándose
CPU
actual
prioridad
planificación
menor
caso
produce
interrupción
kernel
punto
hilo
ejecuta
código
planificador
ejecutar
continuación
Dependiendo
hilos
estén
esperando
seleccionar
hilo
cuyo
caso
recibe
quantum
continúa
ejecución
caso
contrario
produce
cambio
hilo
planificador
llama
condiciones
completa
operación
S.
Expira
tiempo
espera
caso
hilo
esperando
operación
se-
guir
ejecutando
comprobación
reemplazar
hilo
ejecu-
ción
tiempo
ejecución
mínimo
garantizado
planificador
ejecuta
manejador
interrupciones
interrupciones
desactivadas
demasia-
do
tiempo
pone
cola
DPC
realizarla
termine
manejador
interrupciones
caso
hilo
operación
downen
semáforo
bloqueado
objeto
tiempo
límite
acaba
ex-
pirar
necesario
manejador
interrupciones
ponga
cola
DPC
evi-
tar
ejecute
manejador
interrupciones
reloj
hilo
listo
874
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
875
termine
tiempo
límite
ejecutará
planificador
hilo
ejecutable
prioridad
reemplazará
hilo
actual
caso
llegamos
algoritmo
planificación
API
Win32
proporciona
APIs
influir
planificación
hilos
lugar
llamada
SetPriorityClassque
establece
clase
prioridad
hilos
proceso
llamada
valores
permitidos
tiempo
real
alto
normal
normal
normal
inactivo
cla-
prioridad
determina
prioridades
relativas
procesos
Windows
Vista
clase
prioridad
procesos
utilizar
proceso
marcarse
temporal
plano
significa
interferir
actividad
sistema
Observe
clase
prioridad
establece
proceso
afec-
ta
prioridad
actual
hilos
proceso
establecer
prioridad
base
empieza
hilo
momento
creación
API
Win32
SetThreadPriority
Establece
prioridad
relativa
hilo
necesariamente
hilo
llamada
clase
prioridad
proceso
valores
permitidos
tiempo
crítico
normal
normal
de-
normal
menor
inactivo
hilos
tiempo
crítico
obtienen
prioridad
programa-
ción
alta
tiempo
real
hilos
inactivos
obtienen
menor
importar
clase
prioridad
valores
prioridad
ajustan
prioridad
base
hilo
valor
normal
determinado
clase
prioridad
/H110012
/H110011
/H110021
/H110022
respecti-
vamente
clases
prioridad
prioridades
relativas
hilos
facilita
aplicacio-
nes
decisión
prioridades
especificar
planificador
funciona
sistema
32
prioridades
enumeradas
31
combinaciones
clase
prioridad
prioridad
relativa
asignan
32
prio-
ridades
hilo
absolutas
tabla
figura
11-27
número
tabla
determi-
na
prioridad
base
hilo
hilo
prioridad
actual
menor
prioridad
base
analizaremos
Prioridades
clases
procesos
Win32
Tiempo
crítico
normal
Normal
normal
Inactivo
Menor
Tiempo
real
Alta
normal
Normal
normal
Inac-
tivo
Prioridades
hilos
Win32
Figura
11-27
Asignación
prioridades
Win32
prioridades
Windows
www
FreeLibros.mePara
utilizar
prioridades
planificación
sistema
mantiene
arreglo
32
listas
hilos
corresponden
prioridades
31
derivan
tabla
figura
11-27
lista
contiene
hilos
listos
prioridad
correspondiente
algoritmo
plani-
ficación
básico
consiste
buscar
arreglo
prioridad
31
momento
en-
contrar
lista
esté
vacía
selecciona
hilo
cabeza
cola
ejecuta
quantum
quantum
expira
hilo
pasa
cola
nivel
prioridad
se-
lecciona
continuación
hilo
frontal
palabras
hi-
listos
nivel
prioridad
alto
ejecutan
turno
rotatorio
quantum
hilo
listo
procesador
queda
inactivo
establece
energía
espera
ocurra
interrupción
cabo
planificación
elegir
hilo
im-
portar
proceso
pertenezca
planificador
elije
proceso
hi-
proceso
ve
hilos
toma
hilo
pertenece
proceso
determinar
necesita
cambiar
espacios
direcciones
cambiar
hilos
mejorar
escalabilidad
algoritmos
planificación
multiprocesadores
número
procesadores
planificador
tomar
bloqueo
sincroniza
acceso
arreglo
global
listas
prioridad
verifica
despachar
mane-
ra
directa
hilo
esté
listo
ejecutarse
procesador
correspondiente
hilo
planificador
mantiene
noción
procesador
ideal
planifi-
carlo
procesador
mejora
rendimiento
sistema
probable
datos
utilice
hilo
estén
disponibles
caché
pertenece
procesador
ideal
planificador
multiprocesadores
CPU
tie-
ne
memoria
ejecutar
programas
memoria
costo
memoria
local
sistemas
conoce
máquinas
NUMA
NonUni-
form
Memory
Access
Acceso
uniforme
memoria
planificador
optimizar
colo-
cación
hilos
dichas
máquinas
administrador
memoria
asignar
páginas
físicas
nodo
NUMA
pertenece
procesador
ideal
hilos
produce
fallo
página
figura
11-28
muestra
arreglo
encabezados
cola
figura
muestra
realidad
categorías
prioridades
tiempo
real
usuario
cero
inactivo
efecto
/H110021
prioridades
merecen
comentarios
prioridades
16
31
llaman
tiempo
real
diseñadas
crear
sistemas
cumplan
restricciones
tiempo
real
tiempos
límite
hilos
prioridades
tiempo
real
ejecutan
cualquiera
hilos
prioridades
dinámicas
DPCs
ISRs
aplicación
tiem-
po
real
desea
ejecutarse
sistema
requiera
drivers
dispositivos
tengan
cuidado
ejecutar
DPCs
ISRs
periodo
extendido
hilos
tiem-
po
real
excedieran
tiempos
límite
usuarios
ordinarios
ejecutar
hilos
tiempo
real
hilo
usuario
ejecu-
tara
prioridad
hilo
teclado
ratón
entrara
ciclo
hi-
teclado
ratón
ejecutaría
sistema
quedaría
paralizado
permiso
establecer
clase
prioridad
tiempo
real
habilitar
privilegio
especial
token
proceso
usuarios
normales
privilegio
876
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.4
PROCESOS
HILOS
WINDOWS
VISTA
877
general
hilos
aplicaciones
ejecutan
prioridades
15
esta-
blecer
prioridades
proceso
hilos
aplicación
determinar
hilos
preferencia
hilos
sistema
página
cero
ZeroPage
ejecutan
prioridad
con-
vierten
páginas
libres
páginas
ceros
hilo
ZeroPage
separado
procesa-
dor
real
hilo
prioridad
base
dependiendo
clase
prioridad
proceso
prio-
ridad
relativa
hilo
prioridad
utiliza
determinar
32
listas
de-
be
hilo
cola
determina
base
prioridad
actual
general
prioridad
base
condiciones
kernel
impulsa
priori-
dad
actual
hilo
tiempo
real
prioridad
base
prioridad
15
arreglo
figura
11-28
basa
prioridad
actual
cambiar
prioridad
ve
afectada
programación
ajustes
hilos
tiem-
po
real
veamos
eleva
prioridad
hilo
lugar
completa
operación
libera
hilo
espera
prioridad
impulsa
opor-
tunidad
volverse
ejecutar
rapidez
iniciar
operaciones
S.
idea
mantener
ocupados
dispositivos
S.
cantidad
impulso
depende
dispositivo
general
disco
línea
serial
teclado
tarjeta
so-
nido
lugar
hilo
espera
semáforo
mutex
evento
liberarlo
prioridad
impulsa
niveles
proceso
plano
proceso
controla
ventana
envía
entrada
teclado
impulsa
nivel
caso
con-
trario
corrección
tiende
elevar
procesos
interactivos
multitud
hilo
ejecutar
Prioridad
Prioridades
sistema
Prioridades
usuario
Hilo
página
cero
31
24
16
Hilo
inactivo
Figura
11-28
Windows
Vista
proporciona
32
prioridades
hilos
www
FreeLibros.me878
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
nivel
hilo
GUI
despierta
datos
entrada
disponibles
ventana
obtiene
impulso
razón
impulsos
efecto
inmediato
ocasionar
CPU
reprograme
hilo
utiliza
quantum
pierde
nivel
prioridad
mueve
cola
abajo
arreglo
prioridades
utiliza
quantum
completo
mue-
ve
nivel
abajo
sucesivo
llega
nivel
base
permanece
vuelve
impulsar
caso
sistema
juega
prioridades
Imagine
hilos
traba-
jando
problema
tipo
productor-consumidor
trabajo
productor
duro
recibe
prioridad
alta
12
comparación
consumidor
pun-
to
productor
llena
búfer
compartido
bloquea
semáforo
muestra
fi-
gura
11-29(a
12
12
Realiza
operación
down
semáforo
bloquea
Semáforo
Semáforo
Bloqueado
ejecución
Listo
espera
semáforo
Desea
operación
up
semáforo
programa
Figura
11-29
ejemplo
inversión
prioridad
consumidor
oportunidad
ejecutarse
hilo
relaciona-
do
prioridad
pasa
listo
empieza
ejecutarse
muestra
figura
11-29(b
hilo
quiera
ejecutarse
prioridad
pla-
nificación
alta
consumidor
productor
prioridad
bloqueado
circunstancias
productor
ejecutar
hi-
prioridad
permita
resolver
problema
Windows
utiliza
denominar
forma
caritativa
arreglo
sistema
registro
tiempo
transcurrido
ejecutó
hilo
listo
excede
valor
umbral
mueve
prioridad
15
quantums
darle
oportunidad
desbloquear
productor
transcu-
rren
quantums
elimina
impulso
forma
abrupta
disminuirlo
forma
gradual
solución
penalizar
hilos
utilizan
quantum
reducir
prioridad
problema
ocasionado
hilo
hambrien-
to
hilo
avaricioso
problema
conoce
nombre
inversión
prioridad
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
879
problema
análogo
ocurre
hilo
prioridad
16
obtiene
mutex
oportunidad
ejecutarse
tiempo
dejando
hambrientos
hilos
importan-
tes
sistema
esperan
mutex
problema
evitado
sistema
operativo
hilo
necesite
mutex
periodo
corto
simplemente
desha-
bilite
planificación
ocupado
multiprocesador
debería
utilizar
blo-
queo
giro
terminar
tema
planificación
vale
pena
palabras
quantum
sistemas
clientes
Windows
valor
predeterminado
20
mseg
sis-
temas
servidores
Windows
180
mseg
quantum
corto
favorece
usuarios
interacti-
vos
reduce
cambios
contexto
ende
proporciona
eficiencia
valores
predeterminados
incrementar
forma
manual
2x
4x
6x
desea
parche
algoritmo
planificación
indica
ventana
con-
vierte
ventana
plano
hilos
obtienen
quantum
cantidad
toma
registro
cambio
otorga
tiempo
CPU
gene-
ral
traduce
experiencia
usuario
aplicación
cuya
ventana
acaba
mover
plano
11.5
ADMINISTRACIÓN
MEMORIA
Windows
Vista
sistema
memoria
virtual
sofisticado
funciones
Win32
utilizarlo
implementan
administrador
memoria
com-
ponente
nivel
ejecutivo
NTOS
siguientes
secciones
analizaremos
conceptos
fundamentales
llamadas
API
Win32
implementación
11.5.1
Conceptos
fundamentales
Windows
Vista
procesos
usuario
espacio
direcciones
virtuales
máquinas
x86
direcciones
virtuales
32
bits
proceso
GB
es-
pacio
direcciones
virtuales
espacio
asignar
GB
direcciones
mo-
do
usuario
proceso
sistemas
servidores
Windows
configurar
sistema
opcional
ofrecer
GB
usuario
GB
GB
utilizan
kernel
máquinas
x64
ejecutan
64
bits
direcciones
pue-
den
32
64
bits
direcciones
32
bits
utilizan
procesos
ejecutan
WOW64
compatibilidad
32
bits
kernel
direcciones
disponi-
bles
dichos
proceso
32
bits
realidad
obtener
GB
completos
espacio
direccio-
nes
desean
x86
x64
espacio
direcciones
virtuales
pagina
demanda
tamaño
página
fijo
KB
casos
veremos
utilizan
páginas
MB
directorio
páginas
pasan-
do
alto
tabla
páginas
correspondiente
figura
11-30
muestran
distribuciones
espacio
direcciones
virtuales
proceso
x86
forma
simplificada
64
KB
inferior
superior
espacio
www.FreeLibros.mede
direcciones
virtuales
proceso
general
desasignados
elección
ma-
nera
intencional
ayudar
captar
errores
programación
apuntadores
invá-
lidos
/H110021
intentos
utilizarlos
Windows
producirán
trampa
inmediata
leer
basura
escribir
ubicación
incorrecta
memoria
880
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Proceso
GB
GB
Reserva
paginación
Tablas
páginas
Pilas
datos
etc.
HAL
SO
Datos
sistema
Código
datos
privados
proceso
Proceso
Reserva
paginación
Reserva
paginación
Tablas
páginas
Pilas
datos
etc.
HAL
SO
Datos
sistema
Código
datos
privados
proceso
Reserva
paginación
Reserva
paginación
Tablas
páginas
Pilas
datos
etc.
HAL
SO
Datos
sistema
Código
datos
privados
proceso
Reserva
paginación
Proceso
64
KB
inferiores
superiores
inválidos
Figura
11-30
Distribución
espacio
direcciones
virtuales
procesos
usuario
x86
áreas
blanco
privadas
proceso
áreas
sombrea-
das
comparten
procesos
código
datos
privados
usuario
empiezan
64
KB
extienden
ca-
GB
GB
superiores
contienen
sistema
operativo
incluyendo
código
datos
reservas
paginación
GB
superiores
memoria
virtual
kernel
compar-
ten
procesos
exceptuando
datos
memoria
virtual
tablas
pági-
nas
listas
conjuntos
trabajo
proceso
memoria
virtual
kernel
accesible
sistema
ejecuta
kernel
razón
compartir
memoria
virtual
proceso
kernel
hilo
realiza
llamada
sistema
atrapa
kernel
continuar
ejecución
cambiar
mapa
memoria
cambiar
pila
kernel
hilo
páginas
usuario
pro-
ceso
accesibles
código
kernel
leer
parámetros
acceder
búferes
alternar
espacios
direcciones
dobles
asignaciones
tem-
porales
páginas
desventaja
espacio
direcciones
pri-
vadas
proceso
cambio
llamadas
sistema
rápidas
Windows
permite
hilos
adjuntarse
espacios
direcciones
ejecutan
kernel
adjuntarse
espacio
direcciones
hilo
acceder
espacio
di-
recciones
usuario
porciones
espacio
direcciones
kernel
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
881
específicas
proceso
autoasignación
tablas
páginas
hilos
cambiar
espacio
direcciones
original
regresar
usuario
Asignación
direcciones
virtuales
página
direcciones
virtuales
inválida
reservada
con-
firmada
página
inválida
asignada
objeto
sección
memoria
momen-
to
referencia
produce
fallo
página
origina
violación
acceso
asignan
código
datos
página
virtual
página
con-
firmada
fallo
página
página
confirmada
ocasiona
asigne
página
con-
dirección
virtual
provocó
falla
páginas
representadas
objeto
sección
almacenadas
archivo
paginación
caso
requiere
asig-
nar
página
física
operación
archivo
representado
ob-
jeto
sección
leer
datos
disco
fallos
página
ocurrir
entrada
tabla
páginas
necesita
actualizar
página
física
referencia
caché
memoria
cuyo
caso
requiere
operación
S.
conoce
fallos
suaves
analizaremos
detalle
página
virtual
encontrar
reservado
página
virtual
re-
servada
inválida
propiedad
administrador
memoria
asignará
direcciones
virtuales
propósito
ejemplo
crea
proceso
reservan
páginas
espacio
pila
usuario
espacio
direcciones
virtuales
proceso
confirma
página
medida
crezca
pila
administrador
memo-
ria
confirmará
automática
páginas
adicionales
plano
reserva
ca-
esté
agotada
páginas
reservadas
funcionan
páginas
guardia
evitar
pila
crezca
sobrescriba
datos
proceso
Reservar
páginas
virtuales
signi-
fica
pila
crecer
momento
tamaño
máximo
riesgo
puedan
otorgar
propósito
páginas
contiguas
espacio
direcciones
vir-
tuales
necesarias
pila
atributos
inválida
reservada
confirmada
páginas
atributos
lectura
escritura
caso
procesadores
compatibles
AMD64
ejecutable
Archivos
paginación
interesante
concesión
ocurre
confirmar
espacio
almacenamiento
páginas
con-
firmadas
asignar
archivos
específicos
páginas
utilizan
archivo
pagi-
nación
pregunta
asignar
página
virtual
ubicación
específica
archivo
paginación
estrategia
simple
asignar
página
virtual
página
archivos
paginación
disco
momento
confirmara
página
virtual
garantiza
lugar
conocido
escribir
página
confirmada
caso
necesario
sacarla
memoria
Windows
utiliza
estrategia
denominada
justo
tiempo
páginas
confirmadas
res-
palda
archivo
paginación
reciben
espacio
archivo
pa-
www.FreeLibros.meginarse
memoria
asigna
espacio
disco
páginas
paginan
memoria
memoria
virtual
memoria
física
disponi-
ble
necesita
archivo
paginación
conveniente
sistemas
in-
crustados
basan
Windows
forma
inicia
sistema
archivos
paginación
inicializan
empieza
ejecutar
proceso
usuario
smss.exe
estrategia
preasignación
memoria
virtual
sistema
utiliza
datos
privados
pilas
montículo
páginas
código
copia
escribir
limita
tamaño
archivos
paginación
asignación
justo
tiempo
memoria
virtual
tamaño
combinado
archivos
paginación
memoria
física
discos
económicos
comparación
memoria
física
ahorros
espacio
considerables
incremento
rendimiento
paginación
demanda
peticiones
leer
páginas
disco
necesitan
iniciarse
inmediato
hilo
encontró
página
falta
continuar
complete
operación
paginación
memoria
posibles
optimizaciones
pa-
ginar
páginas
faltantes
memoria
implican
tratar
prepaginar
páginas
adicionales
mis-
ma
operación
S.
operaciones
escriben
páginas
modificadas
disco
general
sincronizadas
ejecución
hilos
estrategia
asignación
jus-
to
tiempo
espacio
archivo
paginación
aprovecha
impulsar
rendimiento
escribir
páginas
modificadas
archivo
paginación
páginas
modificadas
agrupan
escriben
trozos
asignación
espacio
archivo
paginación
ocu-
rre
escriben
páginas
número
búsquedas
requeridas
escribir
lote
páginas
optimizar
asignar
páginas
archivo
paginación
estén
cer-
ca
hacerlas
contiguas
páginas
almacenadas
archivo
paginación
leen
memoria
mantienen
asignación
archivo
paginación
modifican
página
nun-
ca
modifica
pasará
lista
especial
páginas
físicas
libres
conocida
lista
espera
volver
utilizar
escribirla
vuelta
disco
modifica
administrador
memoria
liberará
página
archivo
páginas
única
copia
página
memoria
implementar
administrador
memoria
marca
pá-
gina
lectura
cargarla
hilo
intente
escribir
pági-
na
administrador
memoria
detectará
situación
liberará
página
archivo
páginas
otorgará
acceso
escritura
página
permitirá
hilo
intente
Windows
admite
16
archivos
paginación
general
esparcen
discos
separados
obtener
ancho
banda
S.
archivo
tamaño
inicial
tamaño
máximo
crecer
necesita
crear
archivos
tengan
tamaño
máximo
momento
instalar
sistema
necesario
aumentar
archi-
vo
paginación
sistema
archivos
lleno
probable
espacio
archivo
paginación
esté
fragmentado
reduce
rendimiento
sistema
operativo
registro
página
virtual
asigna
archivo
paginación
escribir
información
entradas
tabla
páginas
proceso
páginas
privadas
entradas
tabla
páginas
prototipo
asociadas
objeto
sesión
páginas
compartidas
páginas
respaldadas
archi-
882
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
883
vo
paginación
páginas
proceso
asignan
archivos
regulares
sistema
archivos
código
ejecutable
datos
lectura
archivo
programa
ejemplo
EXE
DLL
asignar
espacio
direcciones
proceso
utilice
páginas
modificar
paginarse
memoria
pe-
ro
páginas
físicas
reutilizar
inmediato
marcan
asignacio-
nes
tabla
páginas
inválidas
necesite
página
futuro
administrador
memoria
leerá
archivo
programa
páginas
empiezan
lectura
terminan
modificándose
ejemplo
establecer
punto
interrupción
código
depurar
proceso
corregir
có-
digo
reubicarlo
distintas
direcciones
proceso
modificaciones
páginas
datos
empezaron
compartidas
casos
Windows
mayo-
ría
sistemas
operativos
modernos
admite
tipo
página
conocido
copia
escribir
páginas
empiezan
páginas
asignadas
ordinarias
intenta
modificar
cual-
quier
página
administrador
memoria
realiza
copia
privada
escribir
actualiza
tabla
páginas
página
virtual
apunte
co-
pia
privada
hilo
intente
volver
escribir
éxito
copia
necesita
paginarse
memoria
escribirá
archivo
paginación
ar-
chivo
original
asignar
código
datos
programa
archivos
EXE
DLL
asig-
nar
archivos
ordinarios
memoria
programas
puedan
referencia
datos
archivos
operaciones
explícitas
lectura
escritura
formas
requieren
operaciones
administrador
memoria
proporciona
im-
plícita
objeto
sección
representar
asignación
páginas
memo-
ria
bloques
archivos
disco
objetos
sección
referencia
archivo
re-
ferencias
regiones
anónimas
memoria
asignar
objetos
sección
anónimos
procesos
compartir
memoria
asignar
archivo
disco
sec-
ciones
recibir
nombres
espacio
nombres
NT
procesos
encontrar
abrir
objetos
sección
nombre
duplicar
manejadores
objetos
sección
procesos
Direccionamiento
memorias
físicas
extensas
años
espacios
direcciones
16
bits
20
bits
estándar
má-
quinas
tenían
megabytes
memoria
física
idearon
tipo
trucos
permitir
pro-
gramas
utilizaran
memoria
física
cabía
espacio
direcciones
trucos
conocían
nombre
conmutación
bancos
programa
podía
sus-
tituir
bloque
memoria
límite
16
20
bits
bloque
memoria
introdujeron
máquinas
32
bits
mayoría
equipos
escritorio
tenían
megabytes
memoria
física
medida
memoria
densa
circuitos
integrados
cantidad
memoria
comúnmente
disponible
www.FreeLibros.meaumentó
dramática
afecta
lugar
servidores
aplicacio-
nes
requieren
memoria
chips
Xeon
Intel
admiten
Extensiones
direccio-
nes
físicas
PAE
permiten
direccionar
memoria
física
36
bits
32
significa
64
GB
memoria
física
sistema
GB
direccionar
proceso
direcciones
virtuales
32
bits
usuario
aplicaciones
bases
datos
SQL
diseñadas
ejecutarse
espacio
direcciones
proceso
conmuta-
ción
bancos
vuelve
entrar
acción
conoce
AWE
Address
Windowing
Ex-
tensions
Extensiones
ventana
dirección
Windows
herramienta
permite
programas
ejecutan
privilegio
apropiado
solicitar
asignación
memoria
física
proceso
solicita
asignación
reservar
direcciones
virtuales
solicitar
sistema
opera-
tivo
asigne
regiones
páginas
virtuales
directamente
páginas
físicas
AWE
solu-
ción
provisional
servidores
utilicen
direccionamiento
64
bits
11.5.2
Llamadas
sistema
administrar
memoria
API
Win32
contiene
funciones
permiten
proceso
administrar
memoria
virtual
explícita
funciones
importantes
listan
figura
11-31
operan
región
consiste
página
secuencia
páginas
consecuti-
vas
espacio
direcciones
virtuales
884
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Función
API
Win32
Descripción
VirtualAlloc
Reserva
confirma
región
VirtualFree
Libera
desconfirma
región
VirtualProtect
Cambia
protección
lectura
escritura
ejecución
región
VirtualQuery
Consulta
región
VirtualLock
región
residente
memoria
deshabilita
paginación
VirtualUnlock
región
paginable
usual
CreateFileMapping
Crea
objeto
asignación
archivos
opcional
asigna
nombre
MapViewOfFile
Asigna
archivo
espacio
direcciones
UnmapViewOfFile
Quita
archivo
asignado
espacio
direcciones
OpenFileMapping
Abre
objeto
asignación
archivos
creado
anterioridad
primeras
funciones
API
utilizan
asignar
liberar
proteger
consultar
regiones
espacio
direcciones
virtuales
regiones
asignadas
empiezan
lími-
tes
64
KB
minimizar
problemas
portabilidad
futuras
arquitecturas
páginas
actuales
cantidad
actual
espacio
direcciones
asignado
me-
nor
64
KB
múltiplo
tamaño
página
siguientes
funciones
Figura
11.31
principales
funciones
API
Win32
administrar
memo-
ria
virtual
Windows
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
885
API
otorgan
proceso
habilidad
fijar
páginas
memoria
puedan
paginar
deshacer
propiedad
ejemplo
programa
tiempo
real
po-
dría
necesitar
páginas
propiedad
evitar
fallos
página
disco
ope-
raciones
críticas
sistema
operativo
implementa
límite
evitar
procesos
vuelvan
avariciosos
realidad
páginas
quitar
memoria
intercambia
proceso
memoria
vuelve
traer
memoria
to-
das
páginas
bloqueadas
vuelven
cargar
hilo
volver
ejecutar-
muestra
figura
11-31
Windows
Vista
funciones
API
nativa
permitir
proceso
acceda
memoria
virtual
proceso
distinto
recibido
control
manejador
vea
figura
11-9
funciones
API
listan
administrar
archivos
asig-
nación
memoria
asignar
archivo
crear
objeto
asignación
ar-
chivo
vea
figura
11-23
CreateFileMapping
función
devuelve
manejador
objeto
asignación
archivo
objeto
sección
introduce
opcional
nom-
bre
espacio
nombres
Win32
procesos
puedan
utilizar
siguientes
funciones
asignan
desasignan
vistas
objetos
sección
espacio
direcciones
virtuales
proceso
proceso
utilizar
API
asignar
com-
partición
asignación
creado
proceso
CreateFileMapping
general
creado
asignar
memoria
anónima
forma
procesos
compartir
regiones
espacios
direcciones
técnica
permite
proceso
escribir
regiones
limitadas
memoria
virtual
proceso
11.5.3
Implementación
administración
memoria
x86
Windows
Vista
admite
espacio
direcciones
lineal
GB
paginación
de-
manda
proceso
segmentación
admite
forma
teoría
tamaños
página
potencia
64
KB
Pentium
general
fijan
KB
sistema
operativo
utilizar
páginas
MB
mejorar
efectividad
TLB
Translation
Lookaside
Buffer
Búfer
traducción
adelantada
unidad
adminis-
tración
memoria
procesador
kernel
aplicaciones
extensas
utilizan
páginas
MB
mejora
rendimiento
considerable
aumentar
proporción
coincidencias
TLB
reducir
número
recorrer
tablas
páginas
bus-
car
entradas
faltan
TLB
diferencia
planificador
selecciona
hilos
individuales
ejecutarlos
preo-
cupan
procesos
administrador
memoria
procesos
preocu-
pan
hilos
procesos
hilos
propietarios
espacio
direcciones
importa
administrador
memoria
asigna
re-
gión
espacio
direcciones
virtuales
regiones
proceso
figura
11-32
administrador
memoria
crea
VAD
Virtual
Address
Descriptor
Descrip-
tor
direcciones
virtuales
proceso
lista
rango
direcciones
asignadas
sección
representa
archivo
almacenamiento
respaldo
desplazamiento
es-
tá
asignado
permisos
contacto
página
crea
di-
rectorio
tablas
páginas
inserta
dirección
física
objeto
proceso
lista
www
FreeLibros.meVADs
define
espacio
direcciones
completo
ADs
organizan
árbol
balanceado
encontrar
eficiencia
descriptor
dirección
específica
esquema
admite
espacios
direcciones
escasos
áreas
utilizar
regiones
asig-
nadas
utilizan
recursos
memoria
disco
esencia
libres
886
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Proceso
Proceso
Almacenamiento
respaldo
disco
Archivo
paginación
Lib.dll
Prog1.exe
Prog2.exe
Programa
Programa
Biblioteca
compartida
Biblioteca
compartida
Datos
PilaPila
DatosRegión
Figura
11-32
Regiones
asignadas
páginas
sombra
shadow
disco
ar-
chivo
lib.dll
asigna
espacios
direcciones
tiempo
Manejo
fallos
página
proceso
inicia
Windows
Vista
páginas
asignan
archivos
imagen
EXE
DLL
programa
encuentren
memoria
comparten
procesos
páginas
escribir
imágenes
marcan
copiar
escribir
puedan
compartir
punto
necesiten
modificarse
sistema
operativo
reconoce
EXE
ejecución
registrado
patrón
referen-
cia
páginas
tecnología
Microsoft
llama
SuperFetch
intenta
prepaginar
páginas
necesarias
proceso
producido
fallos
página
reduce
latencia
momento
iniciar
aplicaciones
traslapar
lectura
pá-
ginas
disco
ejecución
código
inicialización
imágenes
Mejora
velocidad
transferencia
disco
fácil
drivers
disco
organizar
lecturas
reducir
tiempo
búsqueda
necesario
prepaginación
procesos
utiliza
inicio
sistema
aplicación
plano
pasa
plano
cuan-
do
reinicia
sistema
hibernación
administrador
memoria
acepta
prepaginación
implementa
componen-
separado
sistema
páginas
traen
memoria
insertan
tabla
páginas
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
887
proceso
lista
espera
insertar
rápidamente
proceso
necesario
acceder
disco
páginas
asignadas
distintas
inicializan
leer
ar-
chivo
accede
página
asignada
administrador
memoria
proporciona
página
física
asegura
contenido
ceros
cuestiones
seguridad
fallos
subsiguientes
página
asignada
necesite
en-
contrarse
memoria
contrario
leerla
archivo
paginación
paginación
demanda
administrador
memoria
controla
fallos
página
fallo
página
produce
trampa
kernel
kernel
crea
descrip-
tor
independiente
máquina
indica
ocurrió
pasa
información
ad-
ministrador
memoria
correspondiente
ejecutivo
administrador
memoria
comprueba
validez
acceso
página
produjo
fallo
re-
gión
confirmada
busca
dirección
lista
ADs
crea
entrada
tabla
páginas
proceso
caso
página
compartida
administrador
memoria
utili-
za
entrada
tabla
páginas
prototipo
asociada
objeto
sección
llenar
entrada
tabla
páginas
tablas
páginas
proceso
formato
entradas
tabla
páginas
difiere
base
arquitectura
proce-
sador
x86
x64
entradas
página
asignada
muestran
figura
11-33
entrada
marca
válida
hardware
interpreta
contenido
direc-
ción
virtual
traducir
página
física
correcta
páginas
asignadas
entradas
marcan
inválidas
hardware
ignora
resto
entrada
formato
software
distinto
formato
hardware
determina
administrador
me-
moria
ejemplo
página
asignada
asignar
ceros
po-
der
utilizarla
observa
entrada
tabla
páginas
63
AVL
Physical
page
number
62
52
51
12
AVL
11
NX
ejecutar
AVL
Disponible
SO
Página
global
PAT
Tabla
atributos
página
Sucia
modificada
Utilizada
referenciada
PCD
Deshabilita
caché
página
PWT
Escritura
inmediata
página
Usuario
supervisor
Acceso
lectura
escritura
Presente
válida
Número
página
física
31
12
AVL
11
Figura
11-33
entrada
tabla
páginas
PTE
página
asignada
arquitecturas
Intel
x86
AMD
x64
bits
importantes
entrada
tabla
páginas
actualizan
hardware
directamente
bits
acceso
página
sucia
bits
llevan
www.FreeLibros.meel
registro
utilizado
asignación
página
específica
acceder
pá-
gina
acceso
modificado
página
escribir
realmente
ayuda
rendimiento
sistema
administrador
memoria
bit
acceso
im-
plementar
estilo
paginación
LRU
Least-Recently
Used
reciente
principio
LRU
indica
páginas
utilizado
tiempo
probables
uti-
lizar
bit
acceso
permite
administrador
memoria
determinar
ac-
cedió
página
bit
sucio
permite
administrador
memoria
página
modificado
página
modificado
modificado
pá-
gina
leyó
disco
administrador
memoria
escribir
contenido
página
disco
usarla
general
x86
utiliza
entrada
tabla
páginas
32
bits
x64
utiliza
entrada
tabla
páginas
64
bits
muestra
figura
11-33
única
diferencia
campos
campo
número
página
física
30
bits
20
embar-
go
procesadores
x64
existentes
admiten
cantidad
menor
páginas
físicas
representar
arquitectura
x86
soporta
especial
PAE
Physical
Address
Extension
Extensión
dirección
física
utiliza
permitir
proce-
sador
acceder
GB
memoria
física
bits
marco
página
física
adicional
re-
quieren
entradas
tabla
páginas
PAE
aumenten
64
bits
considerar
fallo
página
categorías
página
referenciada
confirmada
intento
acceder
página
violó
permisos
página
compartida
copiar
escribir
punto
modificarse
pila
necesita
crecer
página
referenciada
confirmada
actualmente
asignada
casos
errores
programación
programa
dirección
asignación
válida
intenta
operación
inválida
escri-
bir
página
lectura
conoce
violación
accesoy
general
oca-
siona
proceso
termine
violaciones
acceso
resultado
apuntadores
defectuosos
incluyendo
acceso
memoria
liberó
desasignó
proceso
tercer
caso
síntomas
intento
escribir
página
lectura
tratamiento
distinto
página
marcó
copiar
escribir
administrador
memoria
reporta
violación
acceso
realiza
copia
priva-
página
proceso
actual
devuelve
control
hilo
trató
escribir
página
hilo
reintentará
escritura
completará
provocar
fallo
cuarto
caso
ocurre
hilo
mete
valor
pila
topa
página
asignado
administrador
memoria
programado
reconocer
ca-
so
especial
espacio
páginas
virtuales
reservadas
pila
administrador
memoria
suministrará
página
física
pondrá
ceros
asignará
proceso
Cuan-
do
hilo
termine
ejecución
reintentará
acceso
éxito
888
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
889
quinto
caso
fallo
página
normal
subcasos
página
asigna
archivo
administrador
memoria
buscar
estructuras
datos
tabla
páginas
prototipo
asociada
objeto
sección
asegurarse
antemano
copia
memoria
proceso
lis-
tas
espera
páginas
modificadas
compartirá
marque
copiar
es-
cribir
supone
cambios
compartir
copia
administrador
memoria
asignará
página
física
libre
encargará
página
archivo
copie
disco
administrador
memoria
satisfacer
fallo
página
buscar
página
ne-
cesaria
memoria
leerla
disco
fallo
clasifica
fallo
suave
necesita
copia
disco
fallo
duro
fallos
suaves
dañinos
impacto
so-
bre
rendimiento
aplicaciones
comparación
fallos
duros
fallos
suaves
pue-
den
ocurrir
página
compartida
asignado
proceso
necesita
página
cero
página
necesaria
recortó
conjunto
trabajo
proce-
so
solicitando
oportunidad
volver
utilizarse
tabla
páginas
asignada
página
física
proceso
pasa
listas
páginas
libres
modificadas
espera
páginas
volverán
necesitar
páginas
pila
proceso
terminando
liberan
inmediato
pági-
nas
provocar
fallo
pasan
lista
modificadas
lista
espera
dependien-
do
estableció
bit
sucio
entradas
tabla
páginas
asignaban
página
leyó
disco
páginas
lista
modifica-
das
escribirán
momento
disco
pasarán
lista
espera
administrador
memoria
asignar
páginas
necesario
lista
páginas
libres
lista
páginas
espera
asignar
página
copiarla
dis-
co
administrador
memoria
comprueba
listas
páginas
espera
modificadas
página
memoria
esquema
prepaginación
Windows
Vista
convier-
fallos
duros
ocurrir
fallos
suaves
lee
páginas
llegar
necesitar
mete
lista
páginas
espera
administrador
memoria
realiza
pequeña
cantidad
prepaginación
ordinaria
acceder
grupos
páginas
consecuti-
vas
acceder
páginas
individuales
páginas
adicionales
colocan
inmediato
lista
páginas
espera
general
desperdicio
sobrecarga
ad-
ministrador
memoria
dominada
costo
operación
S.
duda
costoso
leer
clúster
páginas
página
entradas
tabla
páginas
figura
11-33
refieren
números
páginas
físicas
virtuales
actualizar
entradas
tabla
páginas
directorio
páginas
kernel
necesita
utilizar
direcciones
virtuales
Windows
asigna
tablas
páginas
directorios
páginas
proceso
actual
espacio
direcciones
virtuales
kernel
entrada
autoasignación
directorio
páginas
muestra
figura
11-34
asignar
entrada
directorio
páginas
apunte
directorio
autoasignación
direcciones
virtuales
utilizar
referencia
entradas
directorio
páginas
entradas
tabla
páginas
autoasignación
ocupa
MB
direcciones
virtuales
kernel
proceso
x86
fortuna
mis-
mos
MB
actualidad
MB
www
FreeLibros.meEl
algoritmo
reemplazo
página
número
páginas
memoria
física
libres
empieza
bajar
administrador
memo-
ria
empieza
trabajar
páginas
físicas
disponibles
quita
páginas
procesos
usuario
proceso
sistema
representa
páginas
mo-
do
kernel
objetivo
páginas
virtuales
importantes
presentes
memoria
disco
truco
determinar
significa
importante
Windows
responde
frecuente
concepto
conjunto
trabajo
proceso
hilo
conjunto
trabajo
conjunto
consiste
páginas
asignadas
memoria
ende
referenciar
produzca
fallo
página
tamaño
composición
conjunto
trabajo
fluctúa
medida
ejecutan
hilos
proceso
conjunto
trabajo
proceso
describe
parámetros
tamaño
míni-
mo
tamaño
máximo
límites
duros
proceso
pá-
ginas
memoria
valor
mínimo
circunstancias
valor
máximo
proceso
empieza
valor
mínimo
máximo
límites
cambiar
tiempo
determinar
objeto
tarea
procesos
conte-
nidos
tarea
valor
mínimo
inicial
predeterminado
rango
20
50
páginas
valor
inicial
máximo
predeterminado
rango
45
345
páginas
dependiendo
cantidad
memoria
física
sistema
administrador
sistema
890
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
CR3
PD
0x300
Autoasignación
PD[0xc0300000>>22
PD
directorio
páginas
Dirección
virtual
PTE
0xc0300c00
apunta
PD[0x300
entrada
directorio
páginas
autoasignada
Dirección
virtual
PTE
0xc0390c84
apunta
PTE
dirección
virtual
0xe4321000
1100
0000
00
11
1001
0000
1100
1000
01
00
c0390c84
1100
0000
00
11
0000
0000
1100
0000
00
00Dirección
virtual
Dirección
virtual
c0300c00
CR3
PD
0x300
0x390
PT
0x321
Figura
11-34
entrada
autoasignación
Windows
utiliza
asignar
pá-
ginas
físicas
tablas
páginas
directorio
páginas
direcciones
virtuales
kernel
x86
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
891
cambiar
valores
predeterminados
usuarios
domésticos
intentarán
admi-
nistradores
servidores
conjuntos
trabajo
entran
acción
memoria
física
disponible
ago-
tando
sistema
caso
permite
procesos
consumir
memoria
deseen
exceden
valor
máximo
conjunto
trabajo
sistema
presión
memoria
administrador
memoria
empieza
presionar
proceso
regresen
conjuntos
trabajo
empezando
procesos
máximo
administrador
conjunto
trabajo
realiza
niveles
actividad
periódico
base
temporizador
agrega
actividad
nivel
memoria
disponible
Explora
páginas
restablece
bits
acceso
utiliza
valores
representar
edad
página
Mantiene
estimado
páginas
utilizan
conjunto
trabajo
memoria
empezando
escasear
proceso
proporción
con-
siderable
páginas
utilizar
deja
agregar
páginas
conjunto
trabajo
empieza
reemplazar
antiguas
necesita
página
páginas
reem-
plazadas
pasan
lista
espera
páginas
modificadas
memoria
escasa
Recorta
reduce
conjuntos
trabajo
estén
valor
máximo
quita
páginas
antiguas
administrador
conjunto
trabajo
ejecuta
llama
hilo
administrador
conjunto
balanceo
administrador
conjunto
trabajo
acelera
can-
tidad
trabajo
realiza
evitar
sobrecargar
sistema
monitorea
escritura
páginas
lista
modificadas
disco
asegurarse
lista
haga
gran-
despierta
hilo
ModifiedPageWritersegún
necesario
Administración
memoria
física
Anteriormente
mencionamos
listas
distintas
páginas
físicas
lista
páginas
libres
lis-
ta
páginas
espera
lista
páginas
modificadas
cuarta
lista
contiene
páginas
libres
establecido
ceros
frecuencia
sistema
necesita
páginas
contienen
ceros
otorgan
páginas
procesos
lee
página
par-
cial
archivo
necesita
página
cero
requiere
tiempo
escribir
página
ceros
crear
páginas
cero
plano
hilo
baja
prioridad
quinta
lista
utiliza
contener
páginas
detectado
errores
hardware
detección
errores
hardware
páginas
sistema
referenciadas
entrada
tabla
páginas
válida
encuentran
listas
forma
colectiva
conoce
Ba-
datos
números
marco
página
base
datos
PFN
figura
11-35
muestra
es-
tructura
base
datos
PFN
tabla
indexa
número
marco
página
física
entradas
longitud
fija
utilizan
distintos
formatos
tipos
entradas
ejemplo
compartida
privada
entradas
válidas
mantienen
página
conteo
tablas
páginas
apuntan
página
sistema
www.FreeLibros.mepueda
página
páginas
conjunto
trabajo
indican
entrada
referencia
apuntador
tabla
páginas
pro-
ceso
apunta
página
páginas
compartidas
tabla
páginas
prototipo
páginas
compartidas
vínculo
página
lista
campos
ban-
deras
lectura
progreso
escritura
progreso
etcétera
ahorrar
espacio
listas
vinculan
campos
referencia
elemento
índice
tabla
apuntadores
entradas
tabla
páginas
físicas
uti-
lizan
sintetizar
bits
sucios
encuentran
diversas
entradas
tabla
páginas
apuntan
página
física
páginas
compartidas
informa-
ción
utiliza
par
representar
diferencias
páginas
memoria
sistemas
servi-
dores
extensos
memoria
rápida
procesadores
conocen
máquinas
NUMA
892
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Con-
teo
CT
PT
Limpia
Limpia
Limpia
Sucia
Sucia
Sucia
Activa
Activa
Activa
Activa
Libre
Libre
ceros
ceros
13
12
11
20
10
84
36
11
14
espera
Modificadas
Libres
ceros
Tablas
páginas
Base
datos
marcos
página
ceros
Encabezados
listas
Figura
11-35
principales
campos
base
datos
marcos
pá-
gina
página
válida
páginas
mueven
conjuntos
trabajo
diversas
listas
adminis-
trador
conjunto
trabajo
hilos
sistema
examinar
transiciones
Cuan-
do
administrador
conjunto
trabajo
elimina
página
conjunto
trabajo
página
pasa
lista
páginas
espera
páginas
modificadas
dependiendo
limpieza
transición
muestra
figura
11-36
páginas
ambas
listas
siguen
páginas
válidas
ocurre
fallo
pá-
gina
necesita
elimina
lista
envía
conjunto
trabajo
operación
disco
termina
proceso
páginas
compartidas
regresar
fallo
páginas
válidas
tabla
páginas
cualquiera
páginas
listas
modificadas
espera
pasan
lista
libre
Cual-
quier
espacio
archivo
paginación
utilice
proceso
libera
www
FreeLibros.meSECCIÓN
11.5
ADMINISTRACIÓN
MEMORIA
893
Conjuntos
trabajo
Lista
páginas
modifica-
das
Lista
páginas
espera
Lista
páginas
libres
Lista
páginas
ceros
Lista
páginas
memoria
DEFECTUOSA
Escritor
páginas
modifica-
das(4
Desasigna-
ción
Hilo
página
cero
Página
desalojada
conjuntos
trabajo
Terminación
proceso
Fallo
página
suave
necesita
página
cero
8)
Página
referenciada
Figura
11-36
diversas
listas
páginas
transiciones
transiciones
provocadas
hilos
sistema
segundos
hilo
admi-
nistrador
conjunto
balanceo
ejecuta
busca
procesos
hilos
hayan
inactivos
número
segundos
procesos
desmarcan
pi-
kernel
memoria
física
páginas
pasan
listas
páginas
espera
modifica-
das
muestra
hilos
sistema
escritor
páginas
asignadas
escritor
páginas
mo-
dificadas
despiertan
forma
periódica
suficientes
páginas
limpias
toman
páginas
superior
lista
páginas
modificadas
escriben
vuelta
disco
pasan
lista
páginas
espera
hilo
maneja
escrituras
archivos
asignados
maneja
escrituras
archivos
paginación
resul-
tado
escrituras
transformar
páginas
modificadas
sucias
páginas
espera
limpias
razón
hilos
archivo
asignado
crecer
resultado
escritura
requiere
acceso
estructuras
datos
disco
asig-
ne
bloque
disco
libre
espacio
memoria
traer
páginas
volver
escribir
producir
interbloqueo
hilo
resolver
problema
escribir
páginas
archivo
paginación
veamos
transiciones
figura
11-36
proceso
desasigna
página
asociada
proceso
pasar
lista
páginas
libres
caso
esté
compartida
fallo
página
requiere
marco
página
contenga
página
leer
memoria
marco
página
saca
lista
páginas
libres
importa
página
contener
información
confidencial
punto
sobrescrita
completo
situación
distinta
crece
pila
caso
necesita
marco
página
va-
cío
reglas
seguridad
requieren
página
contenga
ceros
razón
hilo
sistema
kernel
hilo
ZeroPage
ejecuta
prioridad
baja
vea
figura
11-28
borra
páginas
lista
libre
coloca
lista
páginas
ceros
CPU
inactiva
páginas
libres
ceros
www.FreeLibros.mepágina
tipo
llegar
útil
página
libre
cuesta
poner-
ceros
CPU
inactiva
existencia
listas
conlleva
opciones
directivas
sutiles
ejem-
plo
suponga
página
traer
disco
lista
páginas
libres
vacía
sistema
ve
obligado
elegir
tomar
página
limpia
lista
páginas
es-
pera
formas
haberse
traído
posteriormente
fallo
página
pági-
na
lista
páginas
ceros
descargando
trabajo
ponerla
ceros
opción
administrador
memoria
decidir
agresividad
hilos
sistema
mover
páginas
lista
modificadas
lista
espera
páginas
limpias
dis-
ponibles
páginas
sucias
reutilizar
inmediato
directiva
lim-
pieza
agresiva
implica
operaciones
disco
probabilidad
página
recién
limpiada
regresar
vuelta
conjunto
trabajo
fallo
página
volvería
ensuciar
formas
general
Windows
resuelve
tipos
desventajas
algoritmos
heurística
pronósticos
antecedentes
históricos
reglas
empíricas
configura-
ciones
parámetros
controlados
administrador
administración
memoria
componente
ejecutivo
complejo
estructuras
datos
algoritmos
heurística
intenta
auto-ajustable
controles
administradores
ajustar
afectar
rendi-
miento
sistema
controles
contadores
asociados
utili-
zar
diversos
kits
herramientas
mencionados
importante
recordar
administración
memoria
sistemas
reales
simple
algoritmo
paginación
reloj
envejecimiento
11.6
CACHÉ
WINDOWS
VISTA
caché
Windows
mejora
rendimiento
sistemas
archivos
mantener
memo-
ria
regiones
archivos
reciente
frecuente
caché
bloques
diseccio-
nados
forma
física
disco
administrador
caché
administra
bloques
diseccionados
forma
virtual
regiones
archivos
método
adapta
estructura
Sistema
Archivos
NT
nativo
NTFS
veremos
sección
11.8
NTFS
almacena
to-
datos
archivos
incluyendo
metadatos
sistema
archivos
regiones
archivos
caché
conocen
vistas
representan
regiones
direcciones
virtuales
kernel
asignan
archivos
sistema
archivos
ende
administrador
memoria
encarga
administración
actual
memoria
física
caché
papel
administrador
caché
administrar
direcciones
virtuales
kernel
vistas
ponerse
administrador
memoria
marcar
páginas
memoria
física
proporcionar
interfaces
sistemas
archivos
herramientas
administrador
caché
Windows
comparten
sis-
temas
archivos
caché
direcciona
forma
virtual
archivos
indi-
viduales
administrador
caché
facilidad
lectura
adelantada
archivo
archivo
peticiones
acceso
datos
caché
provienen
sistema
archivos
caché
virtual
conveniente
sistemas
archivos
traducir
894
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.6
CACHÉ
WINDOWS
VISTA
895
desplazamientos
archivos
números
bloques
físicos
solicitar
página
ar-
chivo
caché
traducción
ocurre
administrador
me-
moria
llama
sistema
archivos
acceder
página
disco
administración
recursos
direcciones
virtuales
kernel
memo-
ria
física
utilizan
caché
administrador
caché
coordinarse
sistemas
archivos
relación
cuestiones
coherencia
vistas
vacia-
do
disco
mantenimiento
correcto
marcas
archivo
especial
medida
expanden
archivos
aspectos
difíciles
archivo
administrar
sistema
archivos
administrador
caché
administrador
memoria
des-
plazamiento
byte
archivo
conocido
ValidDataLength
programa
escri-
be
allá
archivo
bloques
omitieron
rellenar
ceros
cuestiones
seguridad
imprescindible
bit
ValidDataLengthregistrado
metada-
tos
archivo
permita
acceso
bloques
inicializados
escribir
bloques
cero
disco
metadatos
actualicen
longitud
esperarse
sistema
falla
bloques
archivo
hayan
actualiza-
do
memoria
aceptable
bloques
puedan
contener
datos
pertene-
cían
archivos
examinar
forma
funciona
administrador
caché
ha-
ce
referencia
archivo
administrador
caché
asigna
trozo
256
KB
espacio
direcciones
virtuales
kernel
archivo
256
KB
asigna
porción
archivo
administrador
caché
queda
trozos
256
KB
espacio
direcciones
virtuales
desasignar
archivo
asignar
asigna
archivo
administrador
memoria
satisfacer
peticiones
bloques
copiarlos
espacio
direcciones
virtuales
kernel
búfer
usuario
bloque
copiar
memoria
física
producirá
fallo
página
administrador
memoria
atenderá
forma
usual
administrador
caché
siquiera
blo-
memoria
copia
éxito
administrador
caché
funciona
páginas
asignan
memoria
virtual
utilizan
apuntadores
copiarlas
búferes
kernel
usuario
hilo
accede
dirección
virtual
asignada
archivo
produce
fallo
pági-
na
casos
administrador
satisfacer
acceso
fallo
suave
necesita
acceder
disco
descubre
página
memoria
física
admi-
nistrador
caché
asignó
caché
apropiado
aplicaciones
aplicaciones
empre-
sariales
SQL
prefieren
administrar
caché
operaciones
S.
Windows
permite
abrir
archivos
búfer
ignora
administrador
caché
tra-
vés
historia
dichas
aplicaciones
preferirían
intercambiar
caché
sistemas
operativos
espacio
direcciones
virtuales
usuario
sistema
proporciona
configuración
reiniciar
proveer
GB
espacio
direcciones
usuario
aplicaciones
soliciten
utiliza
GB
kernel
división
convencional
GB/2
GB
operación
conocido
/3
GB
opción
inicio
activa
flexible
sistemas
operativos
permiten
ajustar
división
espacio
direcciones
usuario
kernel
www.FreeLibros.menivel
detalle
Windows
ejecuta
/3
GB
disponible
mitad
di-
recciones
virtuales
kernel
administrador
caché
ajusta
asignar
archi-
vos
SQL
preferiría
formas
Windows
Vista
introdujo
forma
caché
sistema
conocida
ReadyBoost
distinta
administrador
caché
usuarios
insertar
memo-
rias
flash
puertos
USB
puertos
arreglos
sistema
operativo
utilice
memoria
flash
caché
escritura
inmediata
memoria
flash
introduce
nivel
jerarquía
memoria
útil
incrementar
cantidad
caché
operaciones
lectura
datos
disco
lecturas
memoria
flash
relativa-
mente
rápidas
RAM
dinámica
utiliza
memoria
normal
Co-
mo
memoria
flash
relativamente
económica
comparación
DRAM
alta
velocidad
característica
Vista
permite
sistema
obtener
rendimiento
DRAM
abrir
cubierta
computadora
ReadyBoostcomprime
datos
general
2x
cifra
implementación
utiliza
driver
filtro
procesa
peticiones
sistema
archivos
envían
administrador
volúmenes
tecnología
similar
conocida
ReadyBoot
utiliza
agilizar
tiempo
inicio
sistemas
Windows
Vista
datos
caché
flash
tecnologías
impacto
sistemas
GB
DRAM
ayudan
sistemas
tratan
ejecutar
Windows
Vista
512
MB
DRAM
Cerca
GB
sistema
memoria
suficiente
paginación
demanda
in-
frecuente
operaciones
disco
provoquen
problemas
mayoría
casos
método
escritura
inmediata
importante
minimizar
pérdida
datos
caso
desconecte
memoria
flash
futuro
hardware
PC
incorpore
memoria
flash
directamente
tarjeta
principal
memoria
flash
escritura
inmedia-
ta
sistema
colocar
caché
datos
críticos
requiera
persistir
falla
utilizar
disco
rendimiento
reducir
consumo
energía
consecuencia
aumentar
vida
baterías
portátiles
disco
funciona
tiempo
portátiles
modernas
eliminan
completo
disco
electromecánico
lugar
memoria
flash
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
objetivos
administrador
Windows
proporcionar
marco
trabajo
básica-
mente
extensivo
flexible
manejar
eficiencia
amplia
variedad
dispositivos
servicios
ofrecer
soporte
descubrimiento
automático
dispositivos
instalación
controladores
plug-and-play
administración
energía
dispositivos
CPU
to-
do
estructura
básicamente
asíncrona
permita
traslapar
cálculos
transferencias
S.
cientos
miles
dispositivos
funcionan
Windows
Vista
número
dispositivos
comunes
siquiera
necesario
instalar
driver
de-
bido
incluido
sistema
operativo
Windows
contamos
versiones
millón
binarios
drivers
distintos
ejecutan
Windows
Vis-
ta
siguientes
secciones
examinaremos
cuestiones
relacionadas
S.
896
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
897
11.7.1
Conceptos
fundamentales
administrador
mantiene
relación
estrecha
administrador
plug-and-play
idea
básica
plug-and-play
bus
enumerable
diseñado
buses
PC
Card
PCI
PCI-x
AGP
USB
IEEE
1394
EIDE
SATA
adminis-
trador
plug-and-play
enviar
petición
ranura
pedir
dispositivo
identifique
descubierto
dispositivos
conectados
adminis-
trador
asigna
recursos
hardware
niveles
interrupción
localiza
drivers
apro-
piados
carga
memoria
Conforme
carga
driver
crea
objeto
driver
asigna
objeto
dispositivo
dispositivo
buses
SCSI
enumeración
ocurre
tiempo
inicio
buses
USB
ocurrir
momento
requiere
estrecha
cooperación
ad-
ministrador
plug-and-play
drivers
bus
encargan
enumeración
administrador
S.
Windows
sistemas
archivos
filtros
antivirus
administradores
volúmenes
pilas
protocolos
red
servicios
kernel
hardware
asociado
im-
plementan
drivers
S.
configuración
sistema
establecer
produzca
carga
drivers
dispositivo
asocia-
do
enumerarlo
bus
sistemas
archivos
cargan
código
es-
pecial
detecta
necesarios
reconocedor
sistema
archivos
analiza
volumen
puro
descifra
tipo
formato
sistema
archivos
contiene
característica
interesante
Windows
aceptación
discos
dinámicos
discos
abarcar
particiones
discos
reconfigurar
ins-
tantánea
siquiera
reiniciar
forma
volúmenes
lógicos
restrin-
gidos
partición
disco
sistema
archivos
abarcar
unidades
transparente
volúmenes
filtrar
driver
especial
Windows
pro-
ducir
Copias
sombra
volúmenes
driver
filtro
crea
instantánea
volumen
montar
separado
representa
volumen
punto
tiempo
registro
cambios
posteriores
punto
obtuvo
instantánea
conveniente
recuperar
archivos
borraron
accidente
viajar
atrás
tiempo
archivo
instantáneas
periódicas
realizaron
an-
teriormente
copias
sombra
valiosas
respaldos
precisos
sistemas
servidores
sistema
funciona
aplicaciones
servidor
lleguen
punto
conve-
niente
copia
limpia
persistente
volumen
aplicaciones
listas
sistema
inicializa
instantánea
volumen
indica
apli-
caciones
continuar
respaldo
realiza
volumen
punto
ins-
tantánea
aplicaciones
bloquean
periodo
corto
desconectarse
red
respaldo
aplicaciones
participan
proceso
instantánea
respaldo
refleja
es-
tado
fácil
recuperar
caso
falla
futuro
caso
respal-
do
seguir
útil
capturó
parecería
sistema
www.FreeLibros.mehubiera
fallado
difícil
imposible
recuperarse
sistema
pun-
to
falla
fallas
ocurren
tiempos
arbitrarios
ejecución
aplicación
Ley
Murphy
establece
probable
ocurran
fallas
tiempo
datos
aplicación
encuentran
recuperación
imposible
aspecto
Windows
soporte
operaciones
asíncronas
hilo
inicie
operación
continúe
ejecución
paralelo
S.
ca-
racterística
importante
servidores
formas
hilo
ave-
riguar
completó
operación
S.
especificar
objeto
evento
realiza
llamada
esperar
ocurra
momento
forma
especifi-
car
cola
sistema
publicará
evento
compleción
realice
operación
S.
forma
proveer
procedimiento
llamada
retorno
sistema
llame
completado
operación
S.
cuarta
forma
sondear
ubicación
me-
moria
administrador
actualice
complete
operación
S.
aspecto
mencionaremos
prioridades
introdujo
Windows
Vista
prioridad
determina
base
prioridad
hilo
emisor
es-
tablecer
explícita
prioridades
especificadas
crítica
alta
normal
baja
baja
prioridad
crítica
reserva
administrador
memoria
evite
interbloqueos
ocurrir
caso
sistema
experimenta
presión
memoria
extrema
prioridades
baja
baja
utilizan
procesos
plano
ser-
vicio
desfragmentación
disco
exploradores
spyware
búsqueda
escritorio
tratan
evitar
interferir
operaciones
normales
sistema
operacio-
nes
obtienen
prioridad
normal
aplicaciones
multimedia
marcar
ope-
raciones
prioridad
alta
evitar
errores
aplicaciones
multimedia
utilizar
alternativa
reservación
ancho
banda
solicitar
ancho
banda
garanti-
zado
acceder
archivos
tiempo
crítico
música
video
sistema
proveerá
aplicación
tamaño
transferencia
óptimo
número
operaciones
pen-
dientes
mantener
permitir
sistema
garantizado
ancho
banda
solicitado
11.7.2
Llamadas
API
entrada
salida
APIs
llamadas
sistema
proporciona
administrador
distintas
ofrecen
mayoría
sistemas
operativos
operaciones
básicas
open
read
wri-
ioctly
close
operaciones
plug-and-play
energía
operaciones
establecer
parámetros
vaciar
búferes
sistema
etcétera
nivel
Win32
APIs
envuelven
interfaces
proporcionan
operaciones
nivel
específicas
cier-
tos
dispositivos
fondo
envolturas
abren
dispositivos
realizan
tipos
básicos
operaciones
operaciones
metadatos
cambiar
nombre
archivo
implementan
llamadas
específicas
sistema
utilizan
versión
especial
ope-
raciones
ioctl
sentido
expliquemos
implementación
pilas
dis-
positivos
forma
administrador
utiliza
paquetes
peticiones
IRPs
898
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
899
mantener
filosofía
general
Windows
llamadas
sistema
nativas
NT
reciben
parámetros
incluyen
variaciones
figura
11-37
lista
interfaces
pri-
marias
llamadas
sistema
administrador
S.
NtCreateFilese
utiliza
abrir
ar-
chivos
existentes
Proporciona
descriptores
seguridad
archivos
extensa
descripción
permisos
acceso
solicitados
otorga
creador
archivos
control
forma
asignarán
bloques
NtReadFiley
NtWriteFilereciben
manejador
archivo
búfer
longitud
reciben
desplazamiento
archivo
ex-
plícito
permiten
especificar
clave
acceder
rangos
bloqueados
bytes
archi-
vo
mayoría
parámetros
relacionados
especificación
distintos
métodos
utilizar
reportar
compleción
operaciones
posiblemente
asíncronas
describe
NtQueryDirectoryFilees
ejemplo
paradigma
estándar
ejecutivo
exis-
ten
APIs
consulta
utilizar
modificar
información
tipos
específicos
objetos
caso
objetos
archivo
refieren
directorios
parámetro
especi-
fica
tipo
información
solicitada
lista
nombres
directorio
información
detallada
archivo
requiere
listado
directorios
extendido
rea-
lidad
operación
admiten
formas
estándar
reportar
comple-
tó
operación
S.
NtQueryVolumeInformationFilees
operación
consulta
directorios
espera
manejador
archivo
representa
volumen
abierto
contener
sistema
archivos
diferencia
directorios
parámetros
modificar
volúmenes
ende
API
NtSetVolumeInformationFileseparada
Llamada
sistema
Descripción
NtCreateFile
Abre
archivos
dispositivos
existentes
NtReadFile
Lee
archivo
dispositivo
NtWriteFile
Escribe
archivo
dispositivo
NtQueryDirectoryFile
Solicita
información
directorio
incluyendo
archivos
NtQueryVolumeInformationFile
Solicita
información
volumen
NtSetVolumeInformationFile
Modifica
información
volumen
NtNotifyChangeDirectoryFile
completa
modifica
archivo
directorio
subárbol
NtQueryInformationFile
Solicita
información
archivo
NtSetInformationFile
Modifica
información
archivo
NtLockFile
Bloquea
rango
bytes
archivo
NtUnlockFile
Elimina
bloqueo
rango
NtFsControlFile
operaciones
archivo
NtFlushBuffersFile
Vacía
búferes
archivos
memoria
disco
NtCancelloFile
Cancela
operaciones
pendientes
archivo
NtDeviceIoControlFile
Operaciones
especiales
dispositivo
Figura
11-37
Llamadas
API
nativa
NT
operaciones
S.
www
FreeLibros.meNtNotifyChangeDirectoryFilees
ejemplo
interesante
paradigma
NT
hilos
operaciones
determinar
ocurre
cambio
objetos
princi-
palmente
directorios
sistema
archivos
caso
claves
registro
asíncrona
hilo
regresa
continúa
notifica
mo-
difica
petición
pendiente
pone
cola
sistema
archivos
operación
pendiente
Paquete
peticiones
IRP
notificaciones
pro-
blemáticas
usuario
desea
eliminar
volumen
sistema
archivos
sistema
operaciones
pendientes
Windows
proporciona
herramientas
cancelar
operaciones
pendientes
incluyendo
soporte
sistema
archivos
desmontar
fuerza
volumen
pendiente
NtQueryInformationFilees
versión
específica
archivos
llamada
sistema
directorios
llamada
sistema
complementaria
NtSetInformationFile
interfaces
utilizan
modifican
tipo
información
nombres
archivos
características
cifrado
compresión
dispersión
atributos
detalles
archivos
incluyendo
búsqueda
id
archivo
interno
asignación
nombre
binario
único
id
objeto
archivo
esencia
llamadas
sistema
forma
ioctlespecífica
archivos
operación
setse
utilizar
cambiar
nombre
archivo
eliminarlo
te-
ner
reciben
manejadores
nombres
archivos
abrir
archivo
cambiarle
nombre
eliminarlo
utilizar
cambiar
nombre
flujos
datos
alternativos
NTFS
vea
sección
11.8
APIs
separadas
NtLockFiley
NtUnlockFilepara
establecer
eliminar
bloqueos
rangos
bytes
archivos
NtCreateFilepermite
restringir
acceso
archivo
completo
me-
diante
compartición
alternativa
APIs
bloqueo
aplican
restricciones
acceso
obligatorias
rango
bytes
archivo
lecturas
escrituras
de-
ben
proporcionar
clave
coincida
clave
proporciona
NtLockFilepara
operar
rangos
bloqueados
herramientas
similares
UNIX
discrecional
aplicaciones
conside-
ran
bloqueos
rangos
NtFsControlFilees
parecido
operaciones
Query
Set
anteriores
operación
genérica
orientada
manejo
operaciones
específicas
archivos
ajustan
APIs
ejemplo
operaciones
específi-
cas
sistema
archivos
particular
llamadas
variadas
NtFlushBuffersFile
llamada
syncde
UNIX
obliga
escribir
datos
sistema
archivos
vuelta
disco
NtCancelloFilese
uti-
liza
cancelar
peticiones
pendientes
archivo
específico
NtDeviceIoCon-
trolFileimplementa
operaciones
ioctlpara
dispositivos
realidad
lista
operaciones
llamadas
sistema
eliminar
archivos
nombre
consultar
atribu-
tos
archivo
específico
envolturas
operaciones
ad-
ministrador
listado
realidad
necesitaban
implementar
llamadas
sitema
separadas
llamadas
sistema
lidiar
puertos
compleción
instalación
colas
Windows
ayuda
servidores
multihilo
utilizar
eficien-
cia
operaciones
asíncronas
hilos
estén
listos
demanda
reducir
número
cambios
contexto
requeridos
atender
operaciones
hilos
dedicados
900
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
901
11.7.3
Implementación
sistema
Windows
consiste
servicios
plug-and-play
administrador
ener-
gía
administrador
modelo
driver
dispositivos
Plug-and-play
detecta
cam-
bios
configuración
hardware
crea
derriba
pilas
dispositivos
dispositivo
producir
carga
descarga
drivers
dispositivos
administra-
dor
energía
ajusta
energía
dispositivos
reducir
consumo
energía
sistema
dispositivos
utilizan
administrador
proporciona
so-
porte
manipular
objetos
kernel
operaciones
basadas
IRP
IoCallDrivers
IoCompleteRequest
trabajo
requerido
proveer
Windows
implementa
drivers
dispositivos
Drivers
dispositivos
asegurar
drivers
dispositivos
funcionen
resto
Windows
Vista
Micro-
soft
definido
modelo
WDM
Windows
Driver
Model
Modelo
drivers
Windows
drivers
dispositivos
seguir
WDM
diseñó
trabajar
Windows
98
Win-
dows
basado
NT
Windows
2000
permitir
drivers
escritos
cui-
dadosa
fueran
compatibles
sistemas
kit
desarrollo
Kit
Drivers
Windows
diseñado
ayudar
escritores
drivers
producir
drivers
estén
conformidad
modelo
mayoría
drivers
Windows
empiezan
copiar
dri-
muestra
apropiado
modifican
Microsoft
provee
ve
rificador
drivers
valida
acciones
drivers
asegurar
estén
conformidad
requerimientos
WDM
estructu-
ra
protocolos
peticiones
administración
memoria
etcétera
verifi-
cador
incluye
sistema
administradores
controlarlo
ejecutar
verifier.exe
permite
configurar
drivers
comprobar
extensivas
cos-
tosas
comprobaciones
soporte
desarrollo
verificación
drivers
difícil
escribir
drivers
simples
Windows
Microsoft
creado
sistema
envoltu-
ras
conocidas
WDF
Windows
Driver
Foundation
Fundamento
Drivers
Windows
ejecuta
WDM
simplifica
requerimientos
comunes
relacionados
interacción
correcta
administración
energía
opera-
ciones
plug-and-play
simplificar
escritura
drivers
incrementar
solidez
sistema
WDF
incluye
UMDF
User-Mode
Driver
Framework
Marco
trabajo
drivers
usuario
escribir
drivers
servicios
ejecutan
procesos
KMDF
Kernel-Mode
Driver
Framework
Marco
trabajo
drivers
kernel
escribir
drivers
servicios
ejecutan
kernel
detalles
WDM
automáticamente
marcos
trabajo
WDM
proporciona
modelo
drivers
enfocaremos
sección
dispositivos
Windows
representan
objetos
dispositivo
objetos
utilizan
representar
hardware
buses
abstracciones
software
www.FreeLibros.mesistemas
archivos
motores
protocolos
red
extensiones
kernel
dri-
vers
filtros
antivirus
objetos
organizan
producción
Win-
dows
denomina
pila
dispositivos
mostró
figura
11-16
iniciar
operaciones
administrador
llama
API
IoCallDriverdel
ejecutivo
apuntadores
objeto
dispositivo
superior
IRP
representa
petición
S.
rutina
busca
objeto
driver
asociado
objeto
dispositivo
general
tipos
operaciones
especifican
IRP
corresponden
llamadas
sistema
admi-
nistrador
descritas
CREATE
READ
CLOSE
figura
11-38
muestran
relaciones
nivel
pila
dispositivos
Pa-
ra
operaciones
driver
especificar
punto
entrada
IoCallDriver
obtiene
tipo
operación
IRP
utiliza
objeto
dispositivo
nivel
actual
pila
dispositivos
buscar
objeto
driver
indexa
tabla
despacho
drivers
ti-
po
operación
encontrar
punto
entrada
correspondiente
driver
llama
driver
recibe
objeto
dispositivo
IRP
902
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Objeto
dispositivo
Datos
instancia
objeto
dispositivo
Objeto
driver
Objeto
driver
Tabla
despacho
CREATE
READ
WRITE
FLUSH
IOCTL
CLEANUP
CLOSE
Driver
dispositivo
cargado
Código
driver
Figura
11-38
nivel
individual
pila
dispositivos
driver
termina
procesar
petición
representada
IRP
opcio-
nes
llamar
IoCallDriverotra
pasarle
IRP
objeto
dispositivo
pila
dispositivos
declarar
petición
completa
regresar
proceso
llamó
cola
IRP
interna
regresar
proceso
llamó
ha-
biendo
declarado
petición
pendiente
caso
produce
operación
asíncrona
drivers
pila
regre-
san
procesos
llamaron
Paquetes
peticiones
figura
11-39
muestra
principales
campos
IRP
inferior
IRP
arreglo
tamaño
dinámico
contiene
campos
utilizar
driver
pila
dispo-
sitivos
maneja
petición
campos
pila
permiten
driver
especificar
ru-
www
FreeLibros.meSECCIÓN
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
903
tina
llamar
completar
petición
S.
compleción
nivel
pila
dis-
positivos
visita
orden
inverso
llamada
rutina
compleción
asignada
ca-
driver
turno
nivel
driver
seguir
completando
petición
decidir
trabajo
dejar
pendiente
petición
suspende
comple-
ción
momento
Dirección
búfer
kernel
MDL
Hilo
Datos
pila
drivers
IRP
Información
compleción
cancelación
Vínculos
cadena
hilos
IRP
Encabezado
lista
descripción
memoria
Dirección
búfer
usuario
Apuntadores
búfer
Banderas
MDL
IRP
Bloque
APC
compleción
Puesta
co-
drivers
comunica-
ciones
Código
operación
Figura
11-39
principales
campos
Paquete
Peticiones
S.
asignar
IRP
administrador
profunda
pila
dis-
positivos
específica
asignarle
IRP
registro
profun-
didad
pila
campo
objeto
dispositivo
medida
forma
pila
dispositivos
Observe
definición
formal
objeto
dispo-
sitivo
pila
información
mantiene
estructuras
datos
privadas
pertene-
cen
driver
pila
pila
realidad
siquiera
pila
nivel
driver
libre
asignar
IRPs
seguir
utilizando
IRP
original
enviar
operación
pila
dispositivos
distinta
cambiar
hilo
tra-
bajador
sistema
continuar
ejecución
IRP
contiene
banderas
código
operación
indexarlo
tabla
despacho
drivers
apuntadores
búfer
búferes
kernel
usuario
lista
MDLs
Memory
Descriptors
Lists
Listas
descriptores
memoria
utilizan
des-
cribir
páginas
físicas
representadas
búferes
operaciones
DMA
campos
utilizan
operaciones
cancelación
compleción
campos
IRP
utilizan
cola
IRP
dispositivos
procesando
vuel-
ven
utilizar
completa
operación
proporcionar
memoria
obje-
to
control
APC
utiliza
llamar
rutina
compleción
administrador
contexto
hilo
original
campo
vínculo
utiliza
vincular
IRPs
pendientes
hilo
inició
www
FreeLibros.mePilas
dispositivos
driver
Windows
Vista
trabajo
driver
impresora
figura
11-40
drivers
apilar
significa
pe-
tición
pasar
secuencia
drivers
trabajo
figura
11-40
ilustran
drivers
apilados
904
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Proceso
usuario
Programa
usuario
Win32
Resto
Windows
Nivel
abstracción
hardware
Controlador
Controlador
Controlador
Filtro
Función
Bus
Función
BusMonolítico
Pila
drivers
Figura
11-40
Windows
permite
apilar
drivers
trabajar
instancia
espe-
cífica
dispositivo
apilamiento
representa
objetos
dispositivo
común
drivers
apilados
separar
administración
bus
trabajo
funcional
controlar
dispositivo
administración
bus
PCI
complicada
debi-
do
diversos
tipos
modos
transacciones
bus
separar
trabajo
especí-
fica
dispositivo
escritores
drivers
aprender
controlar
bus
driver
bus
estándar
pila
similar
drivers
USB
SCSI
tie-
nen
específica
dispositivo
genérica
Windows
suministra
dri-
vers
comunes
genérica
drivers
apilados
insertar
drivers
filtro
pila
visto
drivers
filtro
sistema
archivos
insertan
sis-
www
FreeLibros.meSECCIÓN
11.7
ENTRADA
SALIDA
WINDOWS
VISTA
905
tema
drivers
filtro
utilizan
administrar
hardware
físico
driver
fil-
tro
realiza
transformación
operaciones
medida
IRP
fluye
abajo
pi-
dispositivos
operación
compleción
IRP
fluye
abajo
rutinas
compleción
especificadas
driver
ejemplo
driver
filtro
com-
primir
datos
camino
disco
cifrarlos
camino
red
acción
colo-
car
filtro
significa
programa
aplicación
driver
dispositivo
conscientes
funciona
automática
datos
provienen
dispositivo
drivers
dispositivos
kernel
problema
grave
confiabilidad
estabilidad
Windows
mayoría
fallas
kernel
Windows
errores
drivers
dispositivos
drivers
dispositivos
kernel
comparten
espacio
direcciones
niveles
kernel
ejecutivo
errores
drivers
corromper
estructuras
datos
sistema
errores
asombroso
número
drivers
dispositivos
Windows
drivers
desarrollan
programadores
sistemas
experimentados
errores
cantidad
detalle
implicado
escritura
driver
correcto
Windows
modelo
poderoso
flexible
esencia
operaciones
asín-
cronas
abundar
condiciones
competencia
Windows
2000
herra-
mientas
plug-and-play
administración
energía
sistemas
Win9x
sistemas
Windows
basados
NT
impuso
número
requerimientos
drivers
lidiar
correcta
dispositivos
conectan
desconectan
paquetes
mitad
proceso
usuarios
PCs
acoplan
desacoplan
disposi-
tivos
frecuencia
cierran
tapa
meten
portátiles
maletines
general
preocupan
luz
verde
actividad
esté
encendida
desafiante
es-
cribir
drivers
dispositivos
funcionen
correcta
entorno
razón
desarrolló
Fundación
drivers
Windows
simplificar
Modelo
drivers
Windows
administrador
energía
encarga
manejar
energía
sistema
Anteriormente
administración
consumo
energía
consistía
desactivar
monitor
dete-
ner
giro
unidades
disco
cuestión
complicando
requerimientos
extender
tiempo
operar
portátiles
baterías
cues-
tiones
conservación
energía
relacionadas
computadoras
escritorio
dejen
encendidas
tiempo
alto
costo
suministrar
energía
enormes
granjas
servidores
actualidad
empresas
Microsoft
Google
construyendo
granjas
servidores
instalaciones
hidroeléctricas
obtener
tarifas
bajas
herramientas
administración
energía
recientes
incluyen
reducción
consu-
mo
energía
componentes
sistema
pasar
dispositivos
indi-
viduales
espera
apagarlos
completo
interruptores
energía
suaves
multiprocesadores
desactivan
CPUs
individuales
necesitan
velocidades
reloj
CPUs
ejecución
ajustar
valor
menor
reducir
consumo
energía
procesador
inactivo
reduce
consumo
energía
necesita
esperar
ocurra
interrupción
Windows
proporciona
especial
apagado
conocido
hibernación
copia
memoria
física
disco
reduce
consumo
energía
pequeño
www.FreeLibros.megoteo
portátiles
semanas
hibernación
consumo
batería
memoria
escribe
disco
reemplazar
batería
portátil
hibernación
sistema
reinicia
hi-
bernación
restaura
memoria
guardado
reinicializa
dispositivos
regresa
computadora
vuelta
encontraba
hibernación
te-
ner
volver
iniciar
sesión
iniciar
aplicaciones
servicios
ejecutando
Windows
optimizar
proceso
incluyendo
ignorar
pági-
nas
modificadas
respaldadas
disco
comprimir
páginas
memoria
reducir
cantidad
requerida
formas
requerir
segundos
pa-
ra
hibernar
portátil
sistema
escritorio
gigabytes
memoria
conocido
suspendido
alternativa
hibernación
administrador
energía
reduce
energía
sistema
menor
energía
utilizando
suficiente
actualizar
RAM
dinámica
memoria
nece-
sita
copiar
disco
rápido
hibernación
suspendido
confiable
perder
trabajo
sistema
escritorio
pierde
energía
intercambia
batería
portátil
errores
drivers
dispositi-
vos
reducen
energía
dispositivos
baja
energía
volver
inicializarlos
desarrollar
Windows
Vista
Microsoft
invirtió
esfuerzo
mejo-
rar
operación
suspendido
cooperación
personas
comunidad
dispositivos
hardware
Microsoft
detuvo
práctica
permitir
aplicaciones
ve-
taran
sistema
pasar
suspendido
ocasionaba
portátiles
calentaran
usuarios
descuidados
metían
maletines
esperar
luz
parpadeara
libros
disponibles
Modelo
Drivers
Windows
reciente
Fundación
Drivers
Windows
Cant
2005
Oney
2002
Orwick
Smith
2007
Viscarola
colaboradores
2007
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
Windows
Vista
admite
sistemas
archivos
importantes
FAT-16
FAT-32y
NTFS
NT
File
System
Sistema
archivos
NT
FAT-16
antiguo
sistema
ar-
chivos
MS-DOS
Utiliza
direcciones
disco
16
bits
limita
particiones
disco
GB
utiliza
acceder
discos
flexibles
clien-
tes
FAT-32
utiliza
direcciones
disco
32
bits
admite
particiones
dis-
co
TB
seguridad
sistema
FAT-32
actualidad
utiliza
medios
transportables
unidades
flash
NTFS
sistema
archivos
desa-
rrolló
específicamente
versión
NT
Windows
Windows
XP
convirtió
sis-
tema
archivos
predeterminado
instalado
mayoría
fabricantes
computadoras
mejoró
considerable
seguridad
funcionalidad
Windows
NTFS
uti-
liza
direcciones
disco
64
bits
acepta
particiones
disco
64
bytes
consideraciones
limitan
tamaños
pequeños
capítulo
examinaremos
sistema
archivos
NTFS
sistema
ar-
chivos
moderno
características
interesantes
innovaciones
diseño
906
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
907
sistema
archivos
complejo
limitaciones
espacio
impiden
cubrir
características
material
presentaremos
continuación
mostrar
impresión
ra-
zonable
sistema
11.8.1
Conceptos
fundamentales
NTFS
nombres
archivos
individuales
limitados
255
caracteres
rutas
comple-
tas
32,767
caracteres
nombres
archivos
Unicode
personas
paí-
ses
utilizan
alfabeto
latín
ejemplo
Grecia
Japón
India
Rusia
Israel
escribir
nombres
archivos
lenguaje
nativo
ejemplo
φιλε
nombre
archivo
perfectamente
legal
NTFS
admite
completo
nombres
sensibles
mayúsculas
minúsculas
foo
distinto
Fooy
FOO
API
Win32
admite
completo
sensibilidad
mayúsculas
minúsculas
nombres
archivos
ofrece
tipo
soporte
nombres
directorios
soporte
sensibilidad
mayúsculas
minúsculas
ejecuta
subsistema
POSIX
mantener
compatibilidad
UNIX
Win32
sensi-
ble
mayúsculas
minúsculas
preserva
nombres
archivos
con-
letras
mayúsculas
minúsculas
sensibilidad
mayúsculas
minúsculas
característica
conocida
usuarios
UNIX
inconveniente
usuarios
or-
dinarios
general
tipo
distinción
ejemplo
Internet
par-
insensible
mayúsculas
minúsculas
actualidad
archivo
NTFS
secuencia
lineal
bytes
archivos
FAT-32
UNIX
archivo
consiste
atributos
representa
flujo
bytes
mayoría
archivos
flujos
cortos
nombre
archivo
ID
objeto
64
bits
flujo
nombre
datos
archivo
flujos
datos
largos
flujo
nombre
consiste
nombre
archivo
signo
puntos
nombre
flujo
foo
flujo1
flujo
tamaño
bloquear
forma
independiente
flujos
idea
flujos
archivo
NTFS
sistema
archivos
Ap-
ple
Macintosh
utiliza
flujos
archivo
bifurcación
datos
recursos
flujos
NTFS
permitir
servidor
archivos
NT
atendiera
clientes
Macintosh
utilizan
flujos
datos
representar
metadatos
archivos
imá-
genes
miniatura
imágenes
JPEG
disponibles
GUI
Windows
des-
gracia
flujos
datos
múltiples
frágiles
frecuencia
separan
archivos
transportan
sistemas
archivos
red
respaldan
res-
tauran
posteriormente
herramientas
ignoran
NTFS
sistema
archivos
jerárquico
similar
sistema
archivos
UNIX
em-
bargo
separador
nombres
componentes
fósil
heredado
requerimientos
compatibilidad
CP
creó
MS-DOS
diferencia
UNIX
concepto
directorio
actual
trabajo
vínculos
duros
directorio
actual
directorio
padre
implementan
convenciones
fundamental
diseño
sistema
archivos
soporte
vínculos
duros
utilizan
subsistema
POSIX
soporte
NTFS
comprobación
recorrido
directorios
permiso
UNIX
www
FreeLibros.meLos
vínculos
simbólicos
tuvieron
soporte
NTFS
Windows
Vista
gene-
ral
creación
vínculos
simbólicos
restringida
administradores
evitar
ries-
gos
seguridad
suplantación
identidad
experimentó
UNIX
introdujeron
vínculos
simbólicos
4.2BSD
implementación
víncu-
simbólicos
Vista
utiliza
característica
NTFS
conocida
puntos
reanálisis
analizaremos
sección
soporte
compresión
cifrado
tolerancia
fallas
registro
transacciones
archivos
dispersos
analizaremos
es-
tas
características
implementaciones
11.8.2
Implementación
sistema
archivos
NT
NTFS
sistema
archivos
complejo
sofisticado
desarrolló
específi-
ca
NT
alternativa
sistema
archivos
HPFS
desarrollado
OS/2
NT
diseñó
tierra
firme
NTFS
único
componen-
tes
sistema
operativo
diseño
original
bordo
velero
Puget
Sound
siguiendo
estricto
protocolo
trabajo
mañana
cerveza
tar-
continuación
examinaremos
características
NTFS
empezaremos
estructura
veremos
búsqueda
nombres
archivos
compresión
archivos
registro
transacciones
cifrado
archivos
Estructura
sistema
archivos
volumen
partición
disco
NTFS
contiene
archivos
directorios
mapas
bits
es-
tructuras
datos
volumen
organiza
secuencia
lineal
bloques
clústeres
terminología
Microsoft
tamaño
bloque
fijo
volumen
varía
512
bytes
64
KB
dependiendo
tamaño
volumen
mayoría
discos
NTFS
utilizan
bloques
KB
compromiso
bloques
transferencias
eficientes
bloques
pequeños
nivel
fragmentación
interna
referencia
blo-
ques
utiliza
desplazamiento
inicio
volumen
números
64
bits
principal
estructura
datos
volumen
MFT
Master
File
Table
Tabla
archivos
maestra
secuencia
lineal
registros
tamaño
fijo
KB
re-
gistro
MFT
describe
archivo
directorio
Contiene
atributos
archivo
nombre
etiquetas
hora
lista
direcciones
disco
encuentran
bloques
archivo
necesario
utilizar
registros
MFT
contener
lista
bloques
cuyo
caso
registro
MFT
conocido
registro
base
apunta
registros
MFT
esquema
desborda-
miento
remonta
época
CP
entrada
directorio
conocía
co-
mo
extensión
mapa
bits
registro
entradas
libres
MFT
MFT
archivo
colocar
volu-
men
elimina
problema
sectores
defectuosos
pista
archivo
crecer
necesario
tamaño
máximo
48
registros
MFT
muestra
figura
11-41
registro
MFT
consiste
secuencia
pares
encabezado
atributo
valor
atributo
empieza
encabezado
indica
908
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
909
atributo
valor
valores
atributos
longitud
variable
nombre
archivo
datos
valor
atributo
corto
caber
registro
MFT
coloca
conoce
archivo
inmediato
Mullender
Ta-
nenbaum
1984
coloca
disco
coloca
apuntador
registro
MFT
NTFS
eficiente
pequeños
campos
caber
registro
MFT
16
registros
MFT
reservan
archivos
metadatos
NTFS
co-
mo
ilustra
figura
11-41
registros
describe
archivo
normal
atri-
butos
bloques
datos
forma
archivo
archivos
nombre
empieza
signo
dólar
indicar
archivo
metadatos
pri-
mer
registro
describe
archivo
MFT
especial
indica
encuentran
bloques
archivo
MFT
sistema
encontrarlo
duda
Windows
necesita
forma
buscar
bloque
archivo
MFT
encontrar
resto
informa-
ción
sistema
archivos
forma
encontrar
bloque
archivo
MFT
bus-
car
bloque
inicio
instala
dirección
formato
volumen
sistema
archivos
16
15
14
13
12
11
10
Archivos
metadatos
KB
archivo
usuario
Reservado
futuro
Reservado
futuro
Reservado
futuro
Reservado
futuro
Extensiones
cuotas
etc.
Tabla
conversión
mayúsculas
minúsculas
Descriptores
seguridad
archivos
BadClus
Lista
bloques
defectuosos
Boot
Cargador
bootstrap
Bitmap
Mapa
bits
bloques
usados
Directorio
raíz
AttrDef
Definiciones
atributos
Volume
Archivo
volumen
LogFile
Archivo
registro
recuperación
MftMirr
Copia
espejo
MFT
Mft
Tabla
Archivos
Maestra
Figura
11-41
tabla
archivos
maestra
NTFS
registro
duplicado
archivo
MFT
información
valiosa
imprescindible
copia
caso
bloques
MFT
vuelva
defectuoso
registro
archivo
registro
realizan
cambios
estructurales
sistema
archivos
agregar
directorio
eliminar
existente
acción
registra
archivo
realice
incrementar
pro-
babilidad
recuperarse
forma
correcta
caso
falla
operación
falla
sistema
cambios
atributos
archivos
registran
www.FreeLibros.meúnicos
cambios
registran
archivo
realizan
datos
usuario
registro
contiene
información
volumen
tamaño
etiqueta
versión
dijimos
registro
MFT
contiene
secuencia
pares
encabezado
atributo
valor
archivo
AttrDef
definen
atributos
información
es-
archivo
registro
MFT
continuación
viene
directorio
raíz
archivo
crecer
longitud
arbitraria
describe
registro
MFT
mapa
bits
registro
espacio
libre
volumen
mapa
bits
archivo
atributos
direcciones
disco
proporcionan
registro
MFT
registro
MFT
apunta
archivo
cargador
bootstrap
registro
utiliza
pa-
ra
vincular
bloques
defectuosos
asegurar
ocurran
archivo
regis-
tro
contiene
información
seguridad
registro
10
utiliza
asignación
mayúsculas
minúsculas
letras
latín
asignación
mayúsculas
obvia
me-
personas
latín
asignación
mayúsculas
minúsculas
len-
guajes
griego
armenio
georgiano
país
Unidos
obvia
latín
archivo
indica
registro
11
directorio
contiene
archivos
cosas
cuotas
disco
identificadores
obje-
tos
puntos
reanálisis
etcétera
registros
MFT
reservados
futuro
registro
MFT
consiste
encabezado
registro
seguido
pares
encabe-
zado
atributo
valor
encabezado
registro
contiene
número
mágico
utiliza
comprobar
validez
número
secuencia
actualiza
reutiliza
registro
archivo
conteo
referencias
archivo
número
actual
bytes
registro
utilizado
identificador
índice
número
secuencia
registro
base
utiliza
re-
gistros
extensión
campos
NTFS
define
13
atributos
aparecer
registros
MFT
listan
figura
11-42
encabezado
atributo
identifica
atributo
proporciona
longitud
ubica-
ción
campo
valor
variedad
banderas
información
general
valores
atributos
siguen
justo
encabezados
valor
cabe
registro
MFT
colocar
bloques
disco
separados
atributo
atributo
residente
atributo
datos
candidato
obvio
Algu-
atributos
repetir
nombre
atributos
aparecer
or-
den
fijo
registro
MFT
encabezados
atributos
residentes
longitud
24
bytes
encabezados
atributos
residentes
largos
contie-
nen
información
indica
atributo
disco
campo
información
estándar
contiene
propietario
archivo
información
seguri-
dad
etiquetas
hora
necesita
POSIX
conteo
vínculos
duros
bits
lectura
archivo
etc.
campo
longitud
fija
presente
nombre
archivo
cadena
Unicode
longitud
variable
archivos
nombres
MS-DOS
accesibles
programas
16
bits
archivos
nombre
corto
MS-DOS
nombre
actual
archivo
conforma
regla
nomenclatura
MS-DOS
necesita
nombre
MS-DOS
secundario
NT
4.0
información
seguridad
colocó
atributo
Windows
2000
ver-
siones
posteriores
información
seguridad
archivo
archi-
910
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
911
vos
puedan
compartir
descripciones
seguridad
produce
ahorros
considerables
espacio
mayoría
registros
MFT
sistema
archivos
general
información
seguridad
archivos
posee
usuario
idéntica
lista
atributos
necesita
caso
atributos
quepan
registro
MFT
atributo
indica
encontrar
registros
extensión
entrada
lista
contiene
índice
48
bits
MFT
indica
registro
exten-
sión
número
secuencia
16
bits
permitir
verificación
coincidan
registro
extensión
registros
base
archivos
NTFS
asociado
ID
número
nodo-i
UNIX
archivos
abrir
ID
ID
asigna
NTFS
útil
de-
be
persistir
basa
registro
MFT
cambiar
mueve
registro
archivo
ejemplo
archivo
restaura
respaldo
NTFS
permite
atri-
buto
ID
objeto
separado
establecer
archivo
necesita
cambiar
nun-
ca
ejemplo
mantener
archivo
copia
volumen
punto
reanálisis
indica
procedimiento
analiza
nombre
archivo
ha-
cer
especial
mecanismo
utiliza
montar
sistemas
archivos
explícita
vínculos
simbólicos
atributos
volumen
utilizan
identificarlo
siguientes
atributos
relacionan
forma
implementan
directorios
pe-
queños
listas
archivos
implementan
árboles
B+
atributo
flujo
utilitario
registro
utiliza
sistema
archivos
cifrado
llegamos
atributo
importante
flujo
datos
casos
flujos
archivo
NTFS
flujos
datos
asociados
carga
útil
flujo
datos
predeterminadono
nombre
ejemplo
rutadir\nombrearch::$DATA
flujo
datos
alternativo
flujos
nombre
ejemplo
rutadir\nombrearch-
nombreflujo:$DATA
Atributo
Descripción
Información
estándar
Bits
bandera
etiquetas
hora
etc.
Nombre
archivo
Nombre
archivo
Unicode
repetir
nombre
MS-DOS
Descriptor
seguridad
Obsoleto
información
seguridad
Extend$Secure
Lista
atributos
Ubicación
registros
adicionales
MFT
necesitan
ID
objeto
Identificador
archivo
64
bits
único
volumen
Punto
reanálisis
utiliza
montaje
vínculos
simbólicos
Nombre
volumen
Nombre
volumen
utiliza
Volume
Información
volumen
Versión
volumen
utiliza
Volume
Raíz
índice
utiliza
directorios
Asignación
índice
utiliza
directorios
Mapa
bits
utiliza
directorios
Flujo
utilería
registro
Controla
registro
actividades
LogFile
Datos
Datos
flujo
repetir
Figura
11-42
atributos
utilizados
registros
MFT
www
FreeLibros.mePara
flujo
coloca
nombre
presente
encabezado
atributo
encabezado
lista
direcciones
disco
indican
bloques
contiene
flujo
flujos
cientos
bytes
flujo
colocan
datos
flujo
actuales
registro
MFT
denomina
archivo
inmediato
Mu-
llender
Tanenbaum
1984
tiempo
datos
caben
registro
MFT
atributo
residente
veamos
forma
NTFS
regis-
tro
ubicación
atributos
residentes
datos
específicos
Asignación
almacenamiento
modelo
bloques
disco
asignan
tiradas
bloques
con-
secutivos
cuestiones
eficiencia
ejemplo
bloque
ló-
gico
flujo
coloca
bloque
20
disco
sistema
esforzará
colocar
bloque
lógico
bloque
21
tercer
bloque
lógico
bloque
22
suce-
sivo
forma
lograr
tiradas
asignar
almacenamiento
disco
bloques
bloques
flujo
describen
secuencia
registros
cua-
describe
secuencia
bloques
lógicamente
contiguos
flujo
hoyos
registros
flujos
escriben
orden
principio
pertene-
cen
categoría
flujo
hoyo
ejemplo
definidos
bloques
49
60
79
registros
flujo
producir
escribir
prime-
ros
50
bloques
buscar
bloque
lógico
60
escribir
20
blo-
ques
vuelve
leer
hoyo
bytes
faltantes
ceros
archivos
hoyos
conocen
archivos
dispersos
registro
empieza
encabezado
proporciona
desplazamiento
blo-
flujo
desplazamiento
bloque
cubierto
registro
ejemplo
registro
tendría
encabezado
50
proporcio-
naría
direcciones
disco
50
bloques
tendría
encabezado
60
80
proporcionaría
direcciones
disco
20
bloques
encabezado
registro
seguido
pares
propor-
ciona
dirección
disco
longitud
tirada
dirección
disco
desplazamiento
bloque
disco
inicio
partición
longitud
tirada
número
bloques
pares
necesiten
registro
tirada
figura
11-43
muestra
esquema
flujo
tiradas
bloques
figura
registro
MFT
flujo
corto
bloques
encabeza-
do
8)
Consiste
tiradas
bloques
consecutivos
disco
tirada
com-
puesta
bloques
20
23
bloques
64
65
bloques
80
82
tiradas
registrada
registro
MFT
par
dirección
dis-
co
conteo
bloques
número
tiradas
depende
trabajo
asignador
bloques
disco
encontrar
tiradas
bloques
consecutivos
creó
flujo
flujo
bloques
número
tiradas
n.
912
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
913
vale
pena
comentarios
lugar
límite
superior
cuan-
to
tamaño
flujos
representar
forma
falta
compresión
di-
recciones
par
requiere
números
64
bits
par
totalizar
16
bits
par
representar
millón
bloques
disco
consecutivos
flujo
20
MB
consiste
20
ejecuciones
separadas
millón
bloques
KB
cabe
problemas
registro
MFT
flujo
60
KB
esparcido
60
bloques
ais-
lados
cabe
lugar
forma
directa
representar
par
requiere
/H110038
bytes
método
compresión
disponible
reducir
tamaño
pares
valor
menor
16
direcciones
disco
bytes
cero
orden
superior
omitir
encabezado
datos
indica
bytes
omiten
bytes
utilizan
realidad
dirección
utilizan
tipos
compresión
práctica
pares
bytes
ejemplo
sencillo
información
archivo
cupo
registro
MFT
ocurre
archivo
fragmentado
información
blo-
ques
cabe
registro
MFT
respuesta
simple
utilizan
registros
MFT
figura
11-44
archivo
cuyo
registro
base
registro
102
MFT
demasiadas
ejecuciones
registro
MFT
calcula
re-
gistros
extensión
necesita
caso
necesita
coloca
índices
registro
base
resto
registro
utiliza
primeras
ejecuciones
datos
Observe
figura
11-44
contiene
redundancia
teoría
debería
necesario
es-
pecificar
secuencia
ejecuciones
información
calcular
pares
ejecuciones
especifica
información
búsqueda
eficiente
encontrar
bloque
desplazamiento
archivo
necesario
examinar
encabezados
registro
pares
ejecuciones
Encabezado
información
estándar
Encabezado
nombre
archivo
Encabe-
zado
datos
Información
bloques
datos
Ejecu-
ción
Ejecu-
ción
Ejecu-
ción
Información
estándar
Nombre
archivo
09
428
03
utilizar
Bloques
disco
Números
bloques
20-23
64-65
80-82
Registro
MFT
Encabezado
registro
Encabe-
zado
Figura
11-43
registro
MFT
flujo
ejecuciones
bloques
www
FreeLibros.meCuando
utilizado
espacio
registro
102
almacenamiento
ejecucio-
nes
continúa
registro
105
MFT
registro
empaquetan
ejecuciones
quepan
registro
lleno
resto
ejecuciones
coloca
re-
gistro
108
MFT
forma
utilizar
registros
MFT
manejar
archivos
fragmentados
extensos
problema
produce
necesitan
tantos
registros
MFT
espacio
MFT
base
listar
índices
solución
problema
lista
registros
extensión
MFT
residente
almacena
blo-
ques
disco
registro
base
MFT
crecer
tamaño
desee
figura
11-45
muestra
entrada
MFT
directorio
pequeño
registro
contiene
entradas
directorios
describe
archivo
directorio
entrada
estructura
longitud
fija
seguida
nombre
archivo
longitud
va-
riable
fija
contiene
índice
entrada
MFT
archivo
longitud
nom-
bre
archivo
variedad
campos
banderas
adicionales
buscar
entrada
directorio
examinar
nombres
archivos
turno
914
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
109
108
106
105
103
102
100
Run
m+1
Run
Run
k+1
Run
MFT
105
Run
1MFT
108
Run
registro
extensión
registro
extensión
Registro
base
101
104
107
Figura
11-44
archivo
requiere
registros
MFT
almacenar
ejecuciones
Encabezado
información
estándar
Encabezado
raíz
índice
Información
estándar
utilizar
Encabezado
registro
entrada
directorio
contiene
índice
MFT
archivo
longitud
nombre
archivo
nombre
archivo
campos
banderas
Figura
11-45
registro
MFT
directorio
pequeño
directorios
utilizan
formato
distinto
listar
archivos
forma
li-
neal
utiliza
árbol
B+
búsqueda
alfabética
facilitar
inserción
nombres
directorio
lugar
apropiado
suficiente
información
terminar
describir
forma
rea-
liza
búsqueda
nombre
archivo
\??\C:\foo\bar
figura
11-22
vimos
cooperaban
www
FreeLibros.meSECCIÓN
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
915
Win32
llamadas
sistema
nativas
NT
administradores
objetos
abrir
archivo
enviar
petición
pila
dispositivos
NTFS
volumen
pe-
tición
pide
NTFS
llene
objeto
archivo
nombre
ruta
restante
\foo\bar
análisis
realiza
NTFS
ruta
\foo\bar
empieza
directorio
raíz
cuyos
bloques
encontrar
entrada
MFT
vea
figura
11-41
cadena
foo
busca
directorio
raíz
devuelve
índice
MFT
directorio
foo
busca
directorio
cadena
bar
refiere
registro
MFT
archivo
NTFS
realiza
comprobaciones
acceso
llamada
retorno
monitor
referencia
seguridad
busca
registro
MFT
atributo
DATA
flu-
jo
datos
predeterminado
encontrar
archivo
bar
NTFS
establecerá
apuntadores
metadatos
obje-
to
archivo
pasó
administrador
S.
metadatos
incluyen
apuntador
re-
gistro
MFT
información
compresión
bloqueos
rangos
detalles
compartición
etcétera
metadatos
estructuras
datos
compar-
tidas
objetos
archivo
referencia
archivo
cam-
pos
específicos
archivo
actual
abierto
ejemplo
eliminar
archivo
cerrarlo
éxito
operación
apertura
NTFS
llama
IoCompleteRe-
questpara
pasar
IRP
vuelta
pila
administradores
objetos
úl-
timo
coloca
manejador
objeto
archivo
tabla
manejadores
proceso
actual
control
pasa
vuelta
usuario
próximas
llamadas
ReadFile
aplicación
proporcionar
manejador
especificar
objeto
archivo
C:\foo-
\bar
incluir
petición
lectura
pasa
pila
dispositivo
NTFS
archivos
directorios
regulares
NTFS
admite
vínculos
duros
sentido
UNIX
vínculos
simbólicos
mecanismo
conocido
puntos
reanálisis
NTFS
admite
proceso
marcar
archivo
directorio
punto
reanálisis
asociarle
bloque
datos
archivo
directorio
análisis
nombre
ar-
chivo
operación
falla
bloque
datos
devuelve
administrador
objetos
adminis-
trador
interpretar
datos
representaran
nombre
ruta
alternativo
actualizar
cadena
analizar
reintentar
operación
S.
mecanismo
utiliza
soporte
vínculos
simbólicos
sistemas
archivos
montados
redirige
bús-
queda
distinta
jerarquía
directorios
partición
distinta
puntos
reanálisis
utilizan
marcar
archivos
individuales
drivers
filtros
sistema
archivos
figura
11-22
mostramos
instalar
filtros
sistema
archivos
administrador
sistema
archivos
peticiones
completan
llamada
IoCompleteRequest
pasa
control
rutinas
compre-
sión
representaba
driver
pila
dispositivos
insertada
IRP
momento
petición
driver
desea
marcar
archivo
asocia
etiqueta
reanálisis
observa
peticiones
compleción
operaciones
abrir
archivos
fallaron
toparon
punto
reanálisis
bloque
datos
pasa
vuel-
ta
IRP
driver
bloque
datos
driver
asoció
archivo
driver
dejara
procesar
compleción
continuará
procesando
petición
original
general
requerirá
proceder
petición
abrir
archivo
bandera
indica
NTFS
ignorar
punto
reanálisis
abrir
archivo
www
FreeLibros.meCompresión
archivos
NTFS
proporciona
compresión
transparente
archivos
crear
archivo
com-
primido
significa
NTFS
automáticamente
comprimir
bloques
medida
escriben
disco
descomprime
automática
vuelven
leer
pro-
cesos
leen
escriben
archivos
comprimidos
idea
llevando
cabo
compresión
descompresión
compresión
funciona
NTFS
escribe
archivo
marcado
pa-
ra
compresión
disco
examina
16
bloques
lógicos
archivo
importar
ejecuciones
ocupen
ejecuta
algoritmo
compresión
datos
resultantes
almacenar
15
bloques
datos
comprimidos
escriben
disco
preferencia
ejecución
datos
comprimidos
ocupan
16
blo-
ques
16
bloques
escriben
formato
descomprimido
examinan
bloques
16
31
comprimir
15
bloques
sucesivo
figura
11-46(a
muestra
archivo
16
bloques
comprimieron
éxito
bloques
16
bloques
pudieron
comprimir
siguientes
16
bloques
comprimieron
50%
partes
escrito
ejecuciones
almacena-
do
registro
MFT
bloques
faltantes
almacenan
entrada
MF
di-
rección
disco
muestra
figura
11-46(b
encabezado
48
seguido
pares
ejecución
comprimida
ejecución
descomprimida
ejecución
comprimida
916
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Comprimido
01
70
30
37
24
31
85
40
92
23
55Dirección
disco
Archivo
original
descomprimido
ComprimidoDescomprimido
Información
estándar
Nombre
archivo
04
40
16
85
utilizar8
08
Encabezado
ejecuciones
vacías
Figura
11-46
ejemplo
comprime
archivo
48
bloques
32
bloques
registro
MFT
archivo
comprimirlo
archivo
vuelve
leer
NTFS
ejecuciones
comprimi-
das
basa
direcciones
disco
dirección
disco
indica
www
FreeLibros.meSECCIÓN
11.8
SISTEMA
ARCHIVOS
NT
WINDOWS
917
16
bloques
comprimidos
bloque
disco
utilizar
al-
macenar
datos
evitar
ambigüedad
bloque
volumen
contiene
sector
inicio
formas
imposible
utilizarlo
datos
acceso
aleatorio
archivos
comprimidos
complicado
Suponga
proceso
realiza
búsqueda
bloque
35
figura
11-46
localiza
NTFS
bloque
35
archivo
comprimido
respuesta
leer
descomprimir
eje-
cución
bloque
35
pasar
proceso
lea
elección
16
bloques
unidad
compresión
compromiso
hubiera
elegido
tamaño
menor
compresión
hubiera
efectiva
hubiera
elegido
tamaño
ma-
yor
acceso
aleatorio
hubiera
requerido
esfuerzo
Registro
transacciones
NTFS
proporciona
mecanismos
programas
detecten
cambios
archivos
di-
rectorios
volumen
mecanismo
operación
conocida
NtNotify-
ChangeDirectoryFile
pasa
búfer
sistema
regresa
detecta
cambio
directorio
subárbol
directorios
resultado
búfer
lleno
lista
registros
cambios
suerte
búfer
tamaño
suficiente
caso
con-
trario
registros
quepan
búfer
perderán
mecanismo
diario
cambios
NTFS
sistema
archivos
mantiene
lista
registros
cambios
directorios
archivos
volumen
ar-
chivo
especial
programas
leer
operaciones
control
especia-
sistema
archivos
opción
FSCTL_QUERY_USN_JOURNAL
API
NtFsControlFile
archivo
transacciones
general
extenso
probabi-
lidad
vuelvan
utilizar
entradas
examinarlas
Cifrado
archivos
computadoras
utilizan
actualidad
almacenar
tipo
información
delicada
co-
mo
planes
tomar
control
empresas
información
fiscal
cartas
amor
propietarios
desean
revelar
pérdida
información
ocurrir
compu-
tadora
portátil
pierde
alguien
roba
sistema
escritorio
reinicia
utilizando
disco
flexible
evadir
seguridad
Windows
disco
duro
quita
compu-
tadora
instala
sistema
operativo
inseguro
lidiar
problemas
Windows
opción
cifrar
archivos
caso
alguien
robe
computadora
reinicie
MS-DOS
archivos
puedan
leer
forma
normal
cifrado
Windows
marcar
directorios
cifrados
archivos
cifran
archivos
muevan
directorios
creen
cifran
proceso
actual
cifrado
descifrado
maneja
NTFS
driver
conocido
EFS
Encryption
File
System
Sistema
cifra-
do
archivos
registra
llamadas
retorno
NTFS
www
FreeLibros.meEFS
proporciona
cifrado
directorios
archivos
específicos
herramien-
ta
cifrado
Windows
Vista
conocida
BitLocker
cifra
datos
volumen
ayudar
proteger
datos
importar
usuario
apro-
veche
mecanismos
disponibles
claves
sólidas
número
sistemas
pier-
den
roban
tiempo
sensibilidad
cuestión
robo
identidad
importante
asegurar
secretos
estén
protegidos
diario
pierde
cantidad
sorprenden-
portátiles
principales
empresas
Wall
Street
supuestamente
pierden
promedio
portátil
semana
taxis
ciudad
York
11.9
SEGURIDAD
WINDOWS
VISTA
acabamos
analizar
cifrado
momento
examinar
seguridad
gene-
ral
NT
diseñó
principio
cumplir
requerimientos
seguridad
C2
Depar-
tamento
Defensa
Unidos
DoD
5200.28-STD
Libro
naranja
sistemas
seguros
prueba
ataques
DoD
cumplir
estándar
requiere
sistemas
operativos
tengan
propiedades
clasificarlos
seguros
tipos
trabajo
militar
Windows
Vista
diseñó
específica
cumplir
re-
querimientos
C2
hereda
propiedades
seguridad
diseño
original
NT
Inicio
sesión
seguro
medidas
anti-suplantación
identidad
Controles
acceso
discrecionales
Controles
acceso
privilegiados
Protección
espacio
direcciones
proceso
páginas
ponerse
ceros
asignarlas
Auditoría
seguridad
repasemos
brevemente
puntos
inicio
sesión
seguro
significa
administrador
sistema
requerir
usuarios
tengan
contraseña
iniciar
sesión
suplantación
identidad
cuan-
do
usuario
malicioso
escribe
programa
muestra
indicador
inicio
sesión
pan-
talla
aleja
computadora
esperando
usuario
inocente
siente
escriba
nombre
contraseña
nombre
contraseña
escriben
disco
indica
usua-
rio
falló
inicio
sesión
evitar
ataque
Windows
Vista
instruye
usuarios
opriman
CTRL-ALT-SUPR
iniciar
sesión
driver
teclado
captura
se-
cuencia
clave
invoca
programa
sistema
coloca
pantalla
inicio
sesión
genuina
procedimiento
funciona
procesos
usuario
deshabiliten
procesamiento
CTRL-ALT-SUPR
driver
teclado
NT
918
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.9
SEGURIDAD
WINDOWS
VISTA
919
deshabilitar
secuencia
atención
seguro
CTR-ALT-SUPR
ca-
sos
idea
provino
Windows
XP
Windows
2000
solían
compatibilidad
orden
usuarios
cambiaban
Windows
98
controles
acceso
discrecionales
permiten
propietario
archivo
objeto
de-
cir
usarlo
forma
controles
acceso
privilegiados
permiten
adminis-
trador
sistema
superusuario
redefinirlos
necesario
protección
espacio
direcciones
simplemente
significa
proceso
espacio
direcciones
virtua-
accesible
proceso
autorización
punto
significa
crece
montículo
proceso
páginas
asignadas
inicializan
cero
pro-
cesos
puedan
encontrar
información
colocó
propietario
utilice
lista
páginas
ceros
figura
11-36
provee
lista
páginas
ceros
es-
auditoría
seguridad
permite
administrador
producir
registro
cier-
tos
eventos
relacionados
seguridad
Libro
naranja
especifica
ocurrir
alguien
roba
computado-
ra
portátil
organizaciones
común
robo
semana
consecuencia
Windows
Vista
ofrece
herramientas
usuario
concienzudo
utilizar
minimizar
daño
roba
pierde
portátil
ejemplo
inicio
sesión
seguro
cifrado
archivos
usuarios
concienzudos
precisamente
pierden
portátiles
usuarios
ocasionan
problema
sección
analizaremos
conceptos
básicos
seguridad
Windows
Vista
analizaremos
llamadas
sistema
seguridad
veremos
forma
implementa
seguridad
11.9.1
Conceptos
fundamentales
usuario
grupo
Windows
Vista
identifica
SID
Security
ID
ID
seguri-
dad
SIDs
números
binarios
encabezado
corto
seguido
componente
aleatorio
SID
diseñado
único
mundo
usuario
inicia
proceso
proceso
hilos
ejecutan
SID
usuario
sistema
seguridad
es-
tá
diseñada
asegurar
hilos
SIDs
autorizados
tengan
acceso
objetos
proceso
token
acceso
especifica
SID
propiedades
ge-
neral
token
crea
winlogon
veremos
continuación
formato
token
muestra
figura
11-47
procesos
llamar
GetTokenInformationpara
adquirir
información
encabezado
contiene
información
administrativa
campo
hora
ex-
piración
indicar
token
deja
válido
actualidad
utiliza
campo
Grupos
especifica
grupos
pertenece
proceso
información
necesaria
subsistema
POSIX
DACL
Discrecional
ACL
ACL
discrecional
lista
control
ac-
ceso
asigna
objetos
creados
proceso
especifica
ACL
SID
usuario
indica
propietario
proceso
SIDs
restringidas
permitir
procesos
confianza
participen
tareas
procesos
confianza
me-
daño
privilegios
listados
otorgan
proceso
poderes
especiales
nie-
gan
usuarios
ordinarios
derecho
apagar
equipo
acceso
archivos
www.FreeLibros.meque
negaría
acceso
forma
efecto
privilegios
dividen
su-
perusuario
permisos
asignar
procesos
forma
individual
forma
usuario
recibir
superusuario
resumen
to-
ken
acceso
indica
propietario
proceso
valores
predeterminados
poderes
asociados
920
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Encabe-
zado
Hora
expiración
Grupos
CACL
predeter-
minada
SID
usua
-rio
SID
grupo
SIDs
restringi-
Privilegios
Nivel
imitación
identidad
Nivel
integridad
Figura
11-47
Estructura
token
acceso
usuario
inicia
sesión
winlogon
otorga
proceso
inicial
token
acceso
pro-
cesos
subsiguientes
general
heredan
token
principio
token
acceso
proceso
aplica
hilos
hilo
adquirir
token
acceso
dis-
tinto
ejecución
cuyo
caso
token
acceso
hilo
invalida
token
acceso
proceso
especial
hilo
cliente
pasar
permisos
acceso
hilo
servidor
per-
mitir
acceda
archivos
protegidos
objetos
cliente
mecanismo
conoce
imitación
identidad
implementa
niveles
transporte
ejem-
plo
ALPC
tuberías
nombre
TCP
IP
utiliza
RPC
comunicación
clientes
servidores
transportes
utilizan
interfaces
internas
componente
monitor
referencia
seguridad
kernel
extraer
contexto
seguridad
token
acceso
hilo
actual
enviarlo
servidor
utiliza
construir
token
servidor
utilizar
hacerse
pasar
cliente
descriptor
seguridad
concepto
básico
objeto
asociado
descriptor
seguridad
indica
operaciones
descriptores
seguri-
dad
especifican
momento
crear
objetos
sistema
archivos
NTFS
registro
man-
forma
persistente
descriptor
seguridad
utiliza
crear
descriptor
seguridad
objetos
Archivo
Clave
objetos
administrador
objetos
representan
instancias
abiertas
archivos
claves
descriptor
seguridad
consiste
encabezado
seguido
DACL
ACEs
Access
Control
Entries
Entradas
control
acceso
tipos
principales
ele-
mentos
Permitir
Denegar
elemento
Permitir
especifica
SID
mapa
bits
especifica
procesos
operaciones
SID
objeto
elemento
Denegar
funciona
coincidencia
indica
proceso
ha-
ce
llamada
operación
ejemplo
Ida
archivo
cuyo
descriptor
seguridad
especifica
acceso
lectura
Elvis
acceso
Cathy
ac-
ceso
lectura
escritura
Ida
acceso
completo
ejemplo
simple
ilustra
figura
11-48
SID
refiere
conjunto
usuarios
invalida
ACE
siga
DACL
descriptor
seguridad
SACL
System
Access
Control
List
lista
Control
Acceso
Sistema
DACL
especi-
fica
objeto
operaciones
objeto
registran
registro
even-
www
FreeLibros.meSECCIÓN
11.9
SEGURIDAD
WINDOWS
VISTA
921
tos
seguridad
sistema
figura
11-48
operación
Marilyn
realice
ar-
chivo
quedará
registrada
SACL
contiene
nivel
integridad
analizaremos
11.9.2
Llamadas
API
seguridad
mecanismo
control
acceso
Windows
Vista
basa
descriptores
seguridad
patrón
usual
proceso
crea
objeto
proporciona
descriptor
seguridad
parámetros
CreateProcess
CreateFileu
llamada
creación
objetos
descriptor
seguridad
convierte
descriptor
seguridad
unido
ob-
jeto
vimos
figura
11-48
proporciona
descriptor
seguridad
llamada
creación
objeto
utiliza
seguridad
predeterminada
token
acceso
proceso
llamada
vea
figura
11-47
llamadas
seguridad
API
Win32
relacionan
administración
descriptores
seguridad
enfocaremos
llamadas
impor-
tantes
listan
figura
11-49
crear
descriptor
seguridad
asigna
almace-
namiento
inicializa
InitializeSecurityDescriptor
llamada
llena
encabezado
conoce
SID
propietario
buscar
nombre
LookupAccountSid
insertar
descriptor
seguridad
aplica
pa-
ra
SID
grupo
general
SID
llamada
grupos
administrador
sistema
llenar
SID
Descriptor
seguridad
Encabezado
SID
propietario
SID
grupo
DACL
SACL
Encabezado
Auditar
Marilyn
111111
Descriptor
seguridad
Encabezado
Permitir
Denegar
Elvis
111111
Permitir
Cathy
110000
Permitir
Ida
ACE
ACE
Archivo
100000
111111
Figura
11-48
ejemplo
descriptor
seguridad
archivo
www
FreeLibros.meEn
punto
DACL
SACL
descriptor
seguridad
inicializar
Ini-
tializeAcl
agregar
entradas
ACL
AddAccessAllowedAcey
Ad-
dAccessDeniedAce
llamadas
repetir
agregar
entradas
ACE
necesiten
DeleteAcese
utilizar
eliminar
entrada
cuan-
do
modifica
ACL
existente
construir
ACL
lista
pue-
utilizar
SetSecurityDescriptorDaclpara
unirla
descriptor
seguridad
crea
objeto
descriptor
seguridad
pasar
parámetro
unirlo
objeto
11.9.3
Implementación
seguridad
seguridad
sistema
Windows
Vista
independiente
implementa
compo-
nentes
mayoría
visto
redes
historia
allá
alcance
libro
inicio
sesión
maneja
winlogon
autenticación
me-
diante
lsass
resultado
inicio
sesión
exitoso
shell
GUI
explorer.execon
token
acceso
asociado
proceso
utiliza
grupos
masivos
archivos
SECURITY
SAM
registro
grupo
masivo
archivos
establece
directiva
seguridad
gene-
ral
contiene
información
seguridad
usuarios
individuales
vimos
sección
11.2.3
usuario
inicia
sesión
realizan
operaciones
seguridad
abre
ob-
jeto
utilizarlo
llamada
Openxxxrequiere
abra
nombre
objeto
conjunto
permisos
procesamiento
apertura
monitor
referencia
seguridad
vea
figura
11-13
comprueba
proceso
llamada
permisos
requeridos
Pa-
ra
comprobación
analiza
token
acceso
proceso
llamada
DACL
asociada
objeto
Recorre
lista
ACEs
ACL
orden
momento
encontrar
entrada
coincida
SID
proceso
llamada
grupos
acce-
so
toma
definitivo
permisos
necesita
proceso
llamada
disponibles
operación
apertura
éxito
caso
contrario
fracasa
DACLs
entradas
Denegar
entradas
Permitir
visto
razón
común
colocar
entradas
denegar
acceso
frente
entradas
otorgan
acceso
922
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
Función
API
Win32
Descripción
InitializeSecurityDescriptor
Preparar
descriptor
LookupAccountSid
Buscar
SID
nombre
usuario
SetSecurityDescriptorOwner
Introducir
SID
propietario
descriptor
seguridad
SetSecurityDescriptorGroup
Introducir
SID
grupo
descriptor
seguridad
InitializeAcl
Inicializar
DACL
SACL
AddAccessAllowedAce
Agregar
ACE
DACL
SACL
permitir
acceso
AddAccessDeniedAce
Agregar
ACE
DACL
SACL
negar
acceso
DeleteAce
Eliminar
ACE
DACL
SACL
SetSecurityDescriptorDacl
Adjuntar
DACL
descriptor
seguridad
Figura
11-49
principales
funciones
seguridad
API
Win32
www
FreeLibros.meSECCIÓN
11.9
SEGURIDAD
WINDOWS
VISTA
923
ACL
usuario
niegue
acceso
específica
entrar
puerta
trasera
miembro
grupo
acceso
legítimo
abierto
objeto
devuelve
manejador
proceso
lla-
mada
siguientes
llamadas
comprueba
operación
intentada
conjunto
operaciones
solicitadas
momento
abrir
objeto
evitar
proceso
abra
archivo
lectura
trate
escribir
llamadas
manejadores
pro-
ducir
entradas
registros
auditoría
requiere
SACL
Windows
Vista
herramienta
seguridad
lidiar
problemas
comunes
asegurar
sistema
ACLs
SIDs
nivel
integridad
obligatorios
to-
ken
proceso
objetos
especifican
ACE
nivel
integridad
SACL
nivel
integridad
evita
acceso
escritura
objetos
importar
ACEs
DACL
especial
esquema
nivel
integridad
utiliza
protegerse
proceso
Internet
Explorer
comprometido
atacante
usuario
aconsejado
des-
cargado
código
sitio
Web
desconocido
IE
nivel
permisos
lla-
ma
ejecuta
nivel
integridad
predeterminada
archivos
claves
registro
sistema
nivel
integridad
IE
ejecu-
ta
nivel
integridad
modificarlos
años
agregado
características
seguridad
Win-
dows
Service
Pack
Windows
XP
sistema
compilaba
bandera
/GS
realizaba
validación
tipos
desbordamientos
búfer
pila
utilizaba
herramienta
arquitectura
AMD64
conocida
NX
limitar
ejecución
código
pilas
bit
NX
procesador
disponible
inclu-
so
ejecutarse
x86
NX
significa
ejecutar
permite
marcar
páginas
ejecutar
código
atacante
utiliza
vulnerabilidad
desbordamien-
to
búfer
insertar
código
proceso
fácil
saltar
código
empezar
ejecu-
tarlo
Windows
Vista
introdujo
características
seguridad
frustrar
atacantes
código
carga
kernel
comprueba
predeterminada
sistemas
x64
carga
firmado
apropiada
direcciones
cargan
DLLs
EXEs
asignaciones
pila
revuelven
sistema
probable
atacante
utilizar
éxito
desbordamientos
búfer
bi-
furcar
dirección
conocida
empezar
ejecutar
secuencias
código
provo-
car
eleven
privilegios
atacar
fracción
menor
sistemas
base
método
confiar
binarios
estén
direcciones
estándar
pro-
bable
sistemas
fallen
potencial
ataque
elevación
convierte
ataque
negación
servicio
peligroso
cambios
introducción
Microsoft
denomina
UAC
User
Account
Control
Control
cuentas
usuario
lidiar
problema
crónico
Windows
mayoría
usuarios
utilizan
equipo
administradores
diseño
Windows
requiere
usuarios
operen
administradores
negligencia
ver-
siones
provocado
imposible
utilizar
Windows
usuario
administrador
peligroso
administrador
tiempo
errores
usuario
dañar
sis-
tema
usuario
engañado
atacado
forma
ejecuta
código
trate
www.FreeLibros.mecomprometer
sistema
código
acceso
administrativo
enterrar
nivel
profundo
sistema
UAC
intenta
operación
requiera
acceso
administrador
sis-
tema
superpone
escritorio
especial
toma
control
entrada
usuario
autorizar
acceso
parecido
forma
funciona
CTRL-ALT-SUPR
se-
guridad
C2
convertirse
administrador
atacante
destru-
realmente
importa
usuario
archivos
personales
obstante
UAC
ayuda
frustrar
tipos
existentes
ataques
fácil
recuperar
sistema
comprometido
atacante
modificar
archivos
datos
sistema
característica
seguridad
Windows
Vista
mencionado
soporte
crear
procesos
protegidos
proveen
límite
seguridad
general
usuario
representación
objeto
token
define
límite
privilegios
sistema
crea
proceso
usuario
acceso
proceso
cantidad
herramientas
kernel
crear
procesos
depurar
nombres
rutas
inyección
hilos
etcétera
procesos
protegidos
desconectan
acceso
usuario
único
es-
ta
herramienta
Vista
permitir
software
Administración
derechos
digita-
proteja
contenido
procesos
protegidos
expandirá
versiones
futuras
fines
amigables
usuario
proteger
sistema
atacantes
proteger
contenido
ataques
propietario
sistema
esfuerzos
Microsoft
mejorar
seguridad
Windows
acelerado
años
re-
cientes
medida
lanzan
ataques
sistemas
mundo
Algu-
ataques
éxito
desconectar
países
empresas
importantes
Internet
incurrir
costos
miles
millones
dólares
mayoría
ataques
explotan
pe-
queños
errores
código
producen
desbordamientos
búfer
atacante
in-
sertar
código
sobrescribir
direcciones
retorno
apuntadores
excepciones
datos
controlan
ejecución
programas
problemas
evitar
uti-
lizaran
lenguajes
seguridad
tipos
C++
lenguajes
insegu-
ros
evitar
vulnerabilidades
estudiantes
estuvieran
capacitados
comprender
riesgos
validación
parámetros
datos
ingenieros
software
escriben
código
Microsoft
estudiantes
años
justo
leen
caso
estudio
libros
disponibles
tipos
pequeños
errores
codificación
explotarse
lenguajes
basados
apuntadores
evitarlos
ejemplo
Howard
LeBlank
2007
11.10
RESUMEN
kernel
Windows
Vista
estructurado
HAL
niveles
kernel
ejecutivo
NTOS
número
drivers
dispositivos
implementan
servicios
dispositivos
sistemas
archivos
redes
gráficos
HAL
ocul-
ta
diferencias
hardware
componentes
nivel
kernel
administra
CPUs
posibilitar
operación
multihilo
sincronización
ejecutivo
implementa
ma-
yoría
servicios
kernel
924
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meSECCIÓN
11.10
RESUMEN
925
ejecutivo
basa
objetos
kernel
representan
estructuras
datos
clave
ejecutivo
incluyendo
procesos
hilos
secciones
memoria
drivers
dispositivos
objetos
sincronización
mencionar
crear
objetos
procesos
usuario
llaman
servicios
sistema
obtienen
referencias
manejadores
utilizar
siguientes
llamadas
sistema
componentes
ejecutivo
sistema
operativo
crea
objetos
interna
administrador
objetos
mantiene
espacio
nombre
objetos
insertar
buscarlos
objetos
importantes
Windows
procesos
hilos
secciones
pro-
cesos
espacios
direcciones
virtuales
contenedores
recursos
hilos
uni-
dad
ejecución
programan
nivel
kernel
algoritmo
prioridad
hilo
listo
prioridad
ejecuta
reemplazando
hilos
menor
prio-
ridad
necesario
secciones
representan
objetos
memoria
archivos
asignar
espacios
direcciones
procesos
imágenes
programas
EXE
DLL
representan
secciones
memoria
compartida
Windows
proporciona
memoria
virtual
paginación
demanda
algoritmo
pagina-
ción
basa
concepto
conjunto
trabajo
sistema
mantiene
tipos
listas
pá-
ginas
optimizar
memoria
alimentar
diversas
listas
páginas
recortan
conjuntos
trabajo
fórmulas
complejas
tratan
reutilizar
páginas
físicas
referencia
tiempo
administrador
caché
mane-
ja
direcciones
virtuales
kernel
utilizar
asignar
archivos
memoria
mejora
forma
dramática
rendimiento
operaciones
aplicaciones
operaciones
lectura
satisfacer
necesidad
acceder
disco
operaciones
realizan
drivers
dispositivos
siguen
Modelo
drivers
Windows
driver
empieza
inicializar
objeto
driver
contie-
ne
direcciones
procedimientos
sistema
llamar
manipular
dispositi-
vos
dispositivos
reales
representan
objetos
dispositivo
crean
descripción
configuración
sistema
administrador
plug-and-play
medi-
descubriendo
dispositivos
enumerar
buses
sistema
dispositivos
apilan
paquetes
peticiones
pasan
abajo
pila
drivers
atien-
peticiones
dispositivo
pila
dispositivos
asíncrona
forma
inherente
drivers
común
ponen
cola
peticiones
seguir
trabajando
regresar
proceso
llamó
volúmenes
sistema
archivos
implementan
dispositi-
vos
sistema
S.
sistema
archivos
NTFS
basa
tabla
archivos
maestra
re-
gistro
archivo
directorio
metadatos
sistema
archivos
NTFS
archivo
NTFS
archivo
atributos
re-
gistro
MFT
residentes
almacenan
bloques
MFT
NTFS
acepta
Unicode
compresión
registros
transacciones
cifrado
caracterís-
ticas
Windows
Vista
sofisticado
sistema
seguridad
basado
listas
con-
trol
acceso
niveles
integridad
proceso
token
autenticación
indica
identidad
usuario
privilegios
especiales
proceso
acaso
www
FreeLibros.meCada
objeto
asociado
descriptor
seguridad
descriptor
apunta
lista
control
acceso
discrecional
contiene
entradas
control
acceso
permi-
tir
denegar
acceso
individuos
grupos
Windows
numerosas
características
segu-
ridad
versiones
recientes
incluyendo
BitLockerpara
cifrar
volúmenes
enteros
espacios
direcciones
aleatorios
pilas
ejecutables
medidas
dificultar
ata-
ques
desbordamiento
búfer
PROBLEMAS
HAL
registro
tiempo
comienza
1601
Muestre
ejemplo
aplica-
ción
característica
útil
sección
11.3.2
analizamos
problemas
ocasionan
aplicaciones
multihilo
ce-
rrar
manejadores
hilo
siguen
utilizando
posibilidad
corregir
insertar
campo
secuencia
ayuda
cambios
reque-
rirían
sistema
Win32
señales
introdujeran
proceso
hilo
tipos
Haga
proposición
explique
idea
alternativa
DLLs
vincular
estática
programa
procedi-
mientos
biblioteca
precisos
llamar
introdujera
sistema
tendría
sentido
máquinas
clientes
máquinas
servidores
razones
hilo
pilas
separadas
usuario
kernel
Windows
Windows
utiliza
páginas
MB
mejora
efectividad
TLB
profundo
impacto
rendimiento
Explique
límite
número
operaciones
distintas
definir
ob-
jeto
ejecutivo
proviene
límite
caso
contrario
llamada
WaitForMultipleObjectsde
API
Win32
permite
bloquear
hilo
conjun-
to
objetos
sincronización
cuyos
manejadores
pasan
parámetros
señala
libera
hilo
llamada
conjunto
obje-
tos
sincronización
incluya
semáforos
mutex
sección
crítica
Sugerencia
pregunta
engañosa
analizarla
cuidado
Nombre
razones
terminar
proceso
10
vimos
sección
11.4
tabla
manejadores
especiales
utiliza
asignar
IDs
procesos
hilos
algoritmos
manejar
tablas
general
asig-
nan
manejador
disponible
mantienen
lista
libre
orden
LIFO
versiones
re-
cientes
Windows
cambió
tabla
IDs
mantenga
lista
libre
orden
FIFO
problema
llegar
ocasionar
orden
FIFO
asignar
IDs
procesos
UNIX
problema
11
Suponga
quantum
establece
20
mseg
hilo
actual
prioridad
24
aca-
ba
empezar
quantum
completa
operación
hilo
priori-
926
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.meCAPÍTULO
11
PROBLEMAS
927
dad
28
pasa
listo
tiempo
aproximado
esperar
ejecu-
tarse
CPU
12
Windows
Vista
prioridad
actual
prioridad
base
al-
guna
circunstancia
tendría
sentido
prioridad
actual
menor
priori-
dad
base
muestre
ejemplo
caso
contrario
13
Windows
fácil
implementar
herramienta
hilos
ejecutan
ker-
nel
puedan
unirse
temporal
espacio
direcciones
proceso
distinto
difícil
implementar
usuario
interesante
14
memoria
libre
disponible
administrador
memoria
necesite
recortar
conjuntos
trabajo
sistema
paginación
escribiendo
frecuen-
cia
disco
15
autoasignación
utiliza
acceder
páginas
físicas
directorio
pá-
ginas
tablas
páginas
proceso
ocupa
MB
direcciones
virtuales
kernel
x86
16
región
espacio
direcciones
virtuales
reservada
confirmada
cree
us-
ted
crea
AD
Argumente
respuesta
17
transiciones
mostradas
figura
11-36
decisiones
directivas
contras-
movimientos
requeridos
forzados
eventos
sistema
ejemplo
proceso
termina
libera
páginas
18
Suponga
comparte
página
conjuntos
trabajo
desaloja
conjuntos
trabajo
figura
11-36
ocurre
desaloja
conjunto
trabajo
19
proceso
desasigna
página
pila
páginas
limpias
realiza
transición
figura
11-36
página
pila
páginas
sucias
desasigna
transición
lista
páginas
modificadas
desasigna
página
pila
páginas
sucias
20
Suponga
objeto
despachador
representa
tipo
bloqueo
exclusivo
mutex
marca
utilizar
evento
notificación
evento
sincronización
anunciar
liberado
bloqueo
malo
dependería
respuesta
tiempos
retención
bloqueo
longitud
quantum
sistema
multiprocesador
21
archivo
asignación
Muestre
entradas
ejecuciones
MFT
Desplazamiento
0123456789
Dirección
disco
50
51
52
22
24
25
26
53
54
60
22
Considere
registro
MFT
figura
11-43
Suponga
creció
archivo
asignó
décimo
bloque
número
bloque
66
vería
registro
MFT
23
figura
11-46(b
primeras
ejecuciones
longitud
bloques
accidente
iguales
forma
funciona
compresión
Explique
respuesta
www
FreeLibros.me24
Suponga
desea
crear
Windows
Vista
Lite
campos
figura
11-47
eli-
minar
debilitar
seguridad
sistema
25
modelo
extensión
utilizan
programas
navegadores
Web
Office
servidores
COM
implica
hospedaje
DLLs
enganchar
extender
funcionalidad
subyacente
modelo
razonable
servicio
basado
RPC
cui-
hacerse
pasar
clientes
cargar
DLL
26
ejecutarse
máquina
NUMA
administrador
memoria
Windows
necesita
asignar
página
física
manejar
fallo
página
página
nodo
NUMA
procesador
ideal
hilo
actual
pasa
hilo
ejecuta
actualmente
procesador
distinto
27
Muestre
par
ejemplos
aplicación
recuperar
facilidad
res-
paldo
basado
copia
sombra
volumen
disco
fallo
sistema
28
sección
11.9
provisión
memoria
montículo
proceso
casos
requieren
suministro
páginas
ceros
satisfacer
re-
querimientos
seguridad
Muestre
ejemplos
operaciones
memoria
virtual
requieran
páginas
ceros
29
comando
regedit
utilizar
exportar
registro
archivo
texto
versiones
actuales
Windows
Guarde
registro
sesión
trabajo
vea
cambia
acceso
computadora
Windows
instalar
software
hardware
descubra
cambia
agrega
elimina
programa
dispositivo
30
Escriba
programa
UNIX
simule
escritura
archivo
NTFS
flujos
Debería
aceptar
lista
archivos
argumentos
escribir
archivo
sa-
lida
contenga
flujo
atributos
argumentos
flujos
adicionales
contenido
argumentos
escriba
programa
reportar
atributos
flujos
extraer
componentes
928
CASO
ESTUDIO
WINDOWS
VISTA
CAPÍTULO
11
www
FreeLibros.me12
CASO
ESTUDIO
SYMBIAN
929
capítulos
anteriores
examinamos
sistemas
operativos
populares
equipos
escri-
torio
portátiles
Linux
Windows
Vista
90%
CPUs
mundo
equipos
escritorio
portátiles
encuentran
sistemas
embebidos
incrustados
teléfonos
celulares
PDAs
cámaras
digitales
cámaras
video
máquinas
juegos
iPods
reproductores
MP3
reproductores
CD
grabadoras
DVD
enrutadores
ina-
lámbricos
televisiones
receptores
GPS
impresoras
láser
autos
productos
consumidor
mayoría
utilizan
chips
modernos
32
64
bits
ejecutan
sistema
operativo
completo
capítulo
analizaremos
detalle
sistema
operativo
po-
pular
mundo
sistemas
incrustados
Symbian
sistema
operativo
ejecuta
plataformas
móviles
teléfonos
inteligentes
fabricantes
distintos
teléfonos
inteligentes
nombre
ejecutan
sistemas
operativos
completos
utilizan
características
computadoras
escritorio
Symbian
diseñado
forma
base
amplia
variedad
teléfonos
inteligentes
fabricantes
diseñó
cuidado
ejecutarlo
específica
plataformas
te-
léfonos
inteligentes
computadoras
propósito
general
CPU
memoria
capacidad
al-
macenamiento
limitados
enfoque
comunicación
análisis
Symbian
empezará
historia
proporcionaremos
ge-
neralidades
sistema
lector
dé
idea
diseñado
usos
tenían
destinado
diseñadores
continuación
examinaremos
diversos
aspectos
di-
seño
Symbian
hicimos
Linux
Windows
analizaremos
proce-
sos
administración
memoria
operaciones
sistema
archivos
seguridad
www
FreeLibros.meConcluiremos
análisis
forma
Symbian
maneja
comunicación
teléfonos
celulares
12.1
HISTORIA
SYMBIAN
términos
desarrollo
computadoras
general
UNIX
historia
antigua
Win-
dows
historia
moderadamente
larga
Symbian
historia
corta
raíces
sistemas
desarrollaron
década
1990
debut
2001
debería
sorprender
plataforma
teléfonos
inteligentes
ejecuta
Symbian
evolucionó
Symbian
raíces
dispositivos
bolsillo
desarrollado
rapidez
versiones
12.1.1
Raíces
Symbian
Psion
EPOC
herencia
Symbian
empieza
dispositivos
bolsillo
evolucionaron
finales
década
1980
comprimir
utilidad
dis-
positivo
escritorio
pequeño
paquete
portátil
intentos
computadoras
bolsillo
recibidos
entusiasmo
Apple
Newton
dispositivo
dise-
ñado
usuarios
lento
inicio
computadoras
bol-
sillo
desarrolladas
mediados
1990
adaptadas
usuario
forma
personas
utilizaban
dispositivos
móviles
tipo
computadoras
diseñaron
principio
PDAs
asistentes
digitales
personales
esencia
planificadores
electrónicos
evo-
lucionaron
abarcar
tipos
funcionalidad
medida
desarrollaron
empezaron
funcionar
computadoras
escritorio
tenían
necesidades
multitarea
incorporaron
capacidades
almacenamiento
formas
tenían
flexibles
áreas
entrada
salida
datos
dispositivos
bolsillo
crecieron
abarcar
comunicación
medida
iban
creciendo
dispositivos
personales
desarrollaba
comunicación
personal
teléfonos
móviles
tuvieron
notable
incremento
finales
década
1990
en-
natural
fusionar
dispositivos
bolsillo
teléfonos
móviles
formar
teléfo-
inteligentes
tuvieron
desarrollar
sistemas
operativos
operaban
dispositivos
inteligentes
medida
fusión
década
1990
Psion
Computers
fabricaba
dispositivos
PDAs
1991
Psion
produjo
Serie
pequeña
computadora
pantalla
monocromática
reso-
lución
equivalente
mitad
VGA
cabía
bolsillo
Serie
salió
Serie
3c
1996
capacidad
infrarroja
adicional
Serie
3mx
1998
procesador
veloz
memoria
dispositivos
éxito
administración
energía
interoperabilidad
computadoras
incluyendo
PCs
dispositivos
bolsillo
programación
basaba
lenguaje
diseño
orientado
objetos
empleaba
motores
aplicaciones
distintiva
desarrollo
Symbian
metodología
motores
poderosa
característica
basaba
diseño
micro-
930
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.meSECCIÓN
12.1
HISTORIA
SYMBIAN
931
kernel
enfocar
funcionalidad
motores
funcionaban
servidores
administra-
ban
funciones
respuesta
peticiones
aplicaciones
metodología
estandarización
API
abstracción
objetos
programador
apli-
caciones
dejara
preocuparse
detalles
tediosos
formatos
datos
1996
Psion
empezó
diseñar
sistema
operativo
32
bits
aceptaba
dispositi-
vos
señaladores
pantalla
táctil
utilizaba
multimedia
capacidades
completas
co-
municación
sistema
orientado
objetos
podía
portarse
distintas
arquitecturas
diseños
dispositivos
resultado
esfuerzo
Psion
introducción
sis-
tema
EPOC
Release
sistema
programó
H11001
H11001y
diseñado
orienta-
do
objetos
cimientos
utilizó
metodología
motores
expandió
idea
diseño
serie
servidores
coordinaban
acceso
servicios
sistema
dis-
positivos
periféricos
EPOC
expandió
posibilidades
comunicación
abrió
sistema
operativo
tecnología
multimedia
introdujo
plataformas
interconectar
elementos
pan-
tallas
táctiles
generalizó
interfaz
hardware
EPOC
desarrolló
versiones
posteriores
EPOC
Release
ER3
EPOC
Re-
lease
ER5
versiones
ejecutaban
plataformas
computadoras
Psion
Serie
Serie
Psion
buscaba
enfatizar
formas
podía
adaptar
sistema
operativo
plataformas
hardware
Cerca
2000
mayoría
oportunidades
desarrollo
equipos
bolsillo
negocio
teléfonos
móviles
fabricantes
bus-
cando
sistema
operativo
avanzado
próxima
generación
dispositivos
apro-
vechar
oportunidades
Psion
líderes
industria
teléfonos
móviles
Nokia
Ericsson
Motorola
Matshushita
Panasonic
formaron
empresa
conjunta
llamada
Sym-
bian
asumiera
propiedad
sistema
operativo
EPOC
encargara
futuro
desarrollo
núcleo
diseño
núcleo
conoce
Symbian
12.1.2
Symbian
versión
versión
EPOC
ER5
Symbian
debut
versión
2001
sistema
operativo
aprovechaba
propiedades
flexibles
EPOC
orientado
plataformas
distintas
generalizadas
diseñó
suficiente
flexibilidad
desarrollar
am-
plia
variedad
dispositivos
móviles
teléfonos
avanzados
tiempo
daba
fabri-
cantes
oportunidad
diferenciar
productos
decidió
Symbian
adoptara
forma
activa
tecnologías
actuales
pun-
ta
medida
hicieran
disponibles
decisión
reforzaba
opciones
diseño
orienta-
ción
objetos
arquitectura
cliente-servidor
tecnologías
volviendo
populares
mundos
computadoras
escritorio
Internet
diseñadores
Symbian
versión
consideraban
sistema
abierto
dis-
tinto
propiedades
código
fuente
abierto
atribuían
UNIX
Linux
término
abierto
diseñadores
Symbian
querían
estructura
sistema
operativo
publicaba
disponible
publicaron
interfaces
sistema
fomentar
diseño
software
terceras
partes
www
FreeLibros.me12.1.3
Symbian
versión
versión
Symbian
parecida
predecesores
EPOC
versión
diseño
función
enfoque
diseño
abarcar
telefonía
móvil
medida
fabricantes
diseñaban
teléfonos
móviles
obvio
flexibilidad
EPOC
sistema
operativo
dispositivos
bolsillo
lidiar
plétora
teléfonos
necesitaban
Symbian
versión
Symbian
mantenía
funcionalidad
escritorio
EPOC
ma-
yoría
aspectos
internos
sistema
rediseñaron
abarcar
tipos
funciona-
lidad
teléfonos
inteligentes
kernel
servicios
sistema
operativo
separaron
interfaz
usuario
versión
podía
ejecutar
sistema
operativo
mu-
chas
plataformas
distintas
teléfonos
inteligentes
utilizaba
sistema
distinto
interfaz
usuario
Symbian
podía
extender
lidiar
ejemplo
formatos
pronosticados
mensajería
podía
utilizar
distintos
teléfonos
in-
teligentes
utilizaran
distintas
tecnologías
telefónicas
versión
Symbian
liberó
2003
12.1.4
Symbian
actualidad
versión
Symbian
importante
incorporaron
abstrac-
ción
flexibilidad
sistema
operativo
abstracción
desventajas
tiempo
rendimiento
sistema
operativo
volvió
problema
resolver
emprendió
proyecto
reescribir
completo
sistema
operativo
énfasis
rendimiento
diseño
sistema
operativo
debía
retener
flexibilidad
versión
Symbian
tiempo
mejorar
rendimiento
aumentar
seguridad
sistema
versión
Symbian
liberó
2004
mejoró
rendimiento
Sym-
bian
especial
funciones
tiempo
real
versión
Symbian
liberó
2005
versión
conceptos
seguridad
basada
capacidad
instalación
guardián
versión
Symbian
flexibilidad
hardware
versión
agre-
gó
software
desarrolló
modelo
binario
permitía
desarrolladores
hardware
utilizar
Symbian
rediseñar
hardware
adaptarlo
modelo
arquitectura
específico
12.2
GENERALIDADES
SYMBIAN
vimos
sección
Symbian
pasó
sistema
operativo
bolsillo
con-
vertirse
sistema
operativo
orientado
específica
rendimiento
tiempo
real
plataforma
teléfonos
móviles
sección
veremos
generalidades
concep-
tos
plasmados
diseño
Symbian
conceptos
corresponden
directa
forma
utiliza
sistema
932
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.meSECCIÓN
12.2
GENERALIDADES
SYMBIAN
933
Symbian
único
sistemas
operativos
diseñó
teléfonos
inte-
ligentes
plataforma
destino
sistema
operativo
genérico
adaptó
te-
léfono
inteligente
fuerza
adaptación
sistema
operativo
plataforma
pequeña
características
sistemas
operativos
multitarea
administración
memoria
cuestio-
nes
seguridad
antecesores
Symbian
otorgaron
mejores
características
sistema
operati-
vo
orientado
objetos
heredó
EPOC
Utiliza
diseño
microkernel
minimi-
za
sobrecarga
kernel
pone
funcionalidad
esencial
procesos
nivel
usuario
introdujo
versión
Utiliza
arquitectura
cliente
servidor
imita
modelo
motores
integrado
EPOC
Admite
características
escritorio
incluyendo
multitarea
multihilo
sistema
almacenamiento
extensible
heredó
énfasis
mul-
timedia
comunicaciones
EPOC
cambio
Symbian
12.2.1
Orientación
objetos
orientación
objetos
término
implica
abstracción
diseño
orientado
objetos
crea
entidad
abstracta
conocida
objeto
datos
funcionalidad
componente
software
objeto
provee
funcionalidad
datos
especificados
oculta
detalles
implementación
objeto
implementado
forma
apropiada
eliminar
reemplazar
objeto
distinto
forma
piezas
sistema
utilicen
ob-
jeto
interfaz
aplica
diseño
sistema
operativo
orientación
objetos
significa
llamadas
sistema
características
kernel
interfa-
ces
tipo
acceso
datos
actuales
depender
tipo
implementación
kernel
orientado
objetos
proporciona
servicios
objetos
Utilizar
objetos
kernel
general
significa
aplicación
obtener
manejador
re-
ferencia
objeto
acceder
interfaz
objeto
manejador
diseño
Symbian
orientado
objetos
implementaciones
herramientas
sistema
ocultas
datos
sistema
utilizan
interfaces
definidas
objetos
sistema
sistema
operativo
Linux
crear
descriptor
archivos
utilizarlo
parámetro
llamada
open
Symbian
crearía
objeto
archivo
llamaría
método
openconectado
objeto
ejemplo
sabido
Linux
descriptores
archivos
enteros
indexan
tabla
memoria
sistema
operati-
vo
Symbian
desconoce
implementación
tablas
sistema
archivos
manipulación
sistema
archivos
realiza
objetos
clase
archivo
espe-
cífica
considerarse
Symbian
difiere
sistemas
operativos
utilizan
conceptos
orientados
objetos
diseño
ejemplo
diseños
sistemas
operativos
uti-
lizan
tipos
datos
abstractos
podríamos
argumentar
idea
llamada
sistema
implementa
abstracción
ocultar
detalles
implementación
programas
usuario
Symbian
orientación
objetos
diseñada
marco
trabajo
sistema
ope-
www.FreeLibros.merativo
funcionalidad
llamadas
sistema
asocian
objetos
sistema
asignación
protección
recursos
concentra
asignación
objetos
imple-
mentación
llamadas
sistema
12.2.2
Diseño
microkernel
estructura
kernel
Symbian
diseño
microkernel
basado
naturaleza
orientada
objetos
sistema
operativo
funciones
mínimas
sistema
datos
es-
tán
kernel
funciones
sistema
metido
servidores
espacio
usuario
servidores
trabajo
obtener
manejadores
objetos
sistema
llamadas
sistema
objetos
kernel
necesario
apli-
caciones
espacio
usuario
interactúan
servidores
llamadas
sistema
general
sistemas
operativos
basados
microkernel
ocupan
memoria
momento
iniciar
sistema
estructura
dinámica
servidores
iniciar
necesario
requieren
momento
inicio
general
microkernels
im-
plementan
arquitectura
conectable
soporte
módulos
sistema
car-
gar
conectar
kernel
requiera
forma
microkernels
flexibles
código
soporte
funcionalidad
ejemplo
drivers
hardware
cargar
conectar
momento
Symbian
diseñó
sistema
operativo
basado
microkernel
acceder
recursos
sistema
abren
conexiones
servidores
recursos
coordinan
ac-
ceso
recursos
Symbian
luce
arquitectura
conectable
imple-
mentaciones
implementaciones
funciones
sistema
diseñar
objetos
sistema
insertar
kernel
dinámica
ejemplo
pue-
den
implementar
sistemas
archivos
agregarlos
kernel
sistema
operativo
es-
té
ejecución
diseño
microkernel
conlleva
cuestiones
llamada
sistema
suficiente
sistema
operativo
convencional
microkernel
utiliza
paso
mensajes
rendimiento
verse
afectado
sobrecarga
adicional
comunicación
ob-
jetos
eficiencia
funciones
permanecen
espacio
kernel
sistemas
opera-
tivos
convencionales
disminuye
funciones
pasan
espacio
usuario
ejemplo
sobrecarga
llamadas
funciones
programar
procesos
reducir
rendimien-
to
compara
programación
procesos
kernel
Windows
acceso
di-
recto
estructuras
datos
kernel
mensajes
pasan
objetos
espacio
usuario
objetos
espacio
kernel
probable
ocurran
cambios
niveles
pri-
vilegios
reduce
rendimiento
llamadas
sis-
tema
funcionan
espacio
direcciones
diseños
convencionales
paso
mensajes
cambio
privilegios
implica
espacios
direcciones
implemen-
tar
petición
servicio
microkernel
cuestiones
rendimiento
obligaron
diseñadores
Symbian
sistemas
basados
microkernel
atención
detalles
diseño
imple-
mentación
énfasis
diseño
servidores
mínimos
enfocados
934
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.meSECCIÓN
12.2
GENERALIDADES
SYMBIAN
935
12.2.3
nanokernel
Symbian
lidiar
cuestiones
microkernel
diseñadores
Symbian
implementaron
estructura
nanokernel
núcleo
diseño
sistema
operativo
microker-
nels
meten
funciones
sistema
servidores
espacio
usuario
diseño
Symbian
separa
funciones
requieren
implementación
complicada
kernel
Symbian
mantiene
funciones
básicas
nanokernel
núcleo
sistema
operativo
nanokernel
proporciona
funciones
básicas
Symbian
na-
nokernel
hilos
simples
operan
privilegiado
implementan
servicios
primi-
tivos
implementaciones
nivel
incluyen
operaciones
programación
sincronización
manejo
interrupciones
objetos
sincronización
mutexes
semáforos
funciones
implementan
nivel
reemplazar
funciones
nivel
primitivas
puedan
rápidas
ejemplo
asignación
dinámica
memoria
función
complicada
operación
nanokernel
diseño
nanokernel
requiere
nivel
implementar
funciones
compli-
cadas
kernel
nivel
kernel
Symbian
proporciona
funciones
complicadas
kernel
necesita
resto
sistema
operativo
operación
nivel
kernel
Sym-
bian
operación
privilegiada
combina
operaciones
primitivas
nanokernel
implementar
tareas
complejas
kernel
servicios
objetos
complejos
hilos
usuario
planificación
procesos
cambio
contexto
memoria
dinámica
bibliotecas
cargan
forma
dinámica
sincronización
compleja
objetos
comuni-
cación
procesos
operaciones
implementan
nivel
reemplazar
completo
interrupciones
nivel
reprograme
ejecución
cambio
contexto
figura
12-1
muestra
diagrama
estructura
completa
kernel
Symbian
12.2.4
Acceso
recursos
cliente
servidor
dijimos
Symbian
explota
diseño
microkernel
incluye
modelo
clien-
servidor
acceder
recursos
sistema
aplicaciones
necesitan
acceder
re-
cursos
sistema
clientes
servidores
programas
sistema
operativo
ejecuta
coordinar
acceso
recursos
Linux
podríamos
llamar
openpara
abrir
archivo
Windows
API
Microsoft
crear
ventana
Symbian
am-
bas
secuencias
iguales
conexión
servidor
recono-
cer
conexión
hacerle
peticiones
funciones
abrir
archivo
significa
buscar
servidor
archivos
llamar
connectpara
establecer
conexión
servidor
enviarle
petición
opencon
nombre
archivo
espe-
cífico
ventajas
forma
proteger
recursos
lugar
adapta
diseño
sistema
operativo
sistema
orientado
objetos
sistema
basado
www.FreeLibros.memicrokernel
lugar
tipo
arquitectura
efectivo
administrar
múl-
tiples
accesos
recursos
sistema
requeriría
sistema
operativo
multitareas
multihi-
servidor
enfocar
recursos
administrar
actualizar
facilidad
intercambiar
diseños
12.2.5
Características
sistema
operativo
tamaño
computadoras
destino
Symbian
característi-
cas
parientes
esperar
tipo
soporte
vemos
sistemas
operativos
Linux
Windows
seguro
encontremos
es-
tas
características
forma
distinta
Symbian
características
común
sistemas
operativos
Procesos
hilos
Symbian
sistema
operativo
multitareas
multihilo
procesos
ejecutar
forma
concurrente
comunicar
utilizar
hilos
ejecutan
forma
interna
proceso
Soporte
común
sistemas
archivos
Symbian
organiza
acceso
alma-
cenamiento
sistema
modelo
sistema
archivos
for-
ma
sistemas
operativos
sistema
archivos
compatible
Windows
utiliza
predeterminada
sistema
archivos
FAT-32
admite
implementaciones
sistemas
archivos
interfaz
estilo
comple-
mento
Symbian
acepta
tipos
distintos
sistemas
archivos
incluyendo
FAT-
16
FAT-32
NTFS
formatos
tarjetas
almacenamiento
ejemplo
JFFS
936
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
Aplicaciones
usuario
Servidores
microkernel
Kernel
Symbian
nanokernelsockets
teléfono
pantalla
multi-
media
Figura
12-1
estructura
kernel
Symbian
niveles
www
FreeLibros.meSECCIÓN
12.3
PROCESOS
HILOS
SYMBIAN
937
Redes
Symbian
acepta
redes
TCP
IP
interfaces
comunicación
serial
infrarroja
Bluetooth
Administración
memoria
Symbian
utiliza
memoria
virtual
asigna-
herramientas
organiza
acceso
memoria
páginas
per-
mite
reemplazarlas
traer
páginas
memoria
intercambiarlas
12.2.6
Comunicaciones
multimedia
Symbian
creó
facilitar
comunicación
formas
difícil
generali-
dades
mencionar
características
comunicación
modelado
comunicación
cumple
orientación
objetos
arquitectura
cliente
servidor
microkernel
estructuras
comunicación
Symbian
basan
módulos
injertar
mecanismos
co-
municación
sistema
operativo
facilidad
escribir
módulos
implementar
cosa
interfaces
nivel
usuario
implementaciones
protocolos
drivers
dispositivos
diseño
microkernel
introducir
cargar
módulos
operación
sistema
forma
dinámica
Symbian
características
únicas
provienen
enfoque
platafor-
ma
teléfonos
inteligentes
arquitectura
mensajería
conectable
in-
ventar
implementar
tipos
mensajes
desarrollo
módulos
servidor
mensajería
carga
forma
dinámica
sistema
mensajería
diseñado
niveles
tipos
específicos
objetos
implementan
diversos
niveles
ejemplo
objetos
transporte
mensajes
separados
objetos
tipo
mensaje
ejemplo
forma
transporte
mensajes
CDMA
transportar
tipos
distintos
mensajes
ti-
pos
mensajes
texto
estándar
tipos
SMS
comandos
sistema
mensajes
BIO
introducir
métodos
transporte
implementar
objeto
cargarlo
kernel
núcleo
Symbian
diseñado
APIs
especializadas
multimedia
dispo-
sitivos
contenido
multimedia
manejan
servidores
especiales
marco
traba-
jo
permite
usuario
implementar
módulos
describen
contenido
existente
soporte
multimedia
formas
objetos
parecido
forma
implementa
mensajería
diseñados
interactuar
forma
reproduce
sonido
diseña
objeto
interactúa
forma
implementa
formato
sonido
12.3
PROCESOS
HILOS
SYMBIAN
Symbian
sistema
operativo
multitareas
utiliza
conceptos
procesos
hilos
forma
parecida
sistemas
operativos
estructura
kernel
Sym-
bian
forma
escasez
recursos
influyen
ve
es-
tos
objetos
multitareas
www
FreeLibros.me938
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
12.3.1
Hilos
nanohilos
procesos
base
multitarea
Symbian
prefiere
hilos
basa
concepto
hilos
forman
unidad
central
multitarea
sistema
operativo
sim-
plemente
ve
proceso
colección
hilos
bloque
control
proceso
espacio
memoria
soporte
hilos
Symbian
basa
nanokernel
nanohilos
nanokernel
pro-
porciona
soporte
simple
hilos
hilo
sostiene
nanohilo
basado
nanokernel
nanokernel
proporciona
programación
nanohilos
sincronización
comu-
nicación
hilos
servicios
temporización
nanohilos
ejecutan
privile-
giado
necesitan
pila
almacenar
datos
entorno
tiempo
ejecución
nanohilos
ejecutar
usuario
significa
sistema
operativo
mantener
estrecho
control
nanohilo
necesita
conjunto
mínimo
datos
ejecutarse
esencia
ubicación
pila
sistema
operativo
control
código
utiliza
hilo
almacena
con-
texto
hilo
pila
tiempo
ejecución
nanohilos
hilos
procesos
modelo
utiliza-
do
nanokernel
Symbian
agrega
modelo
básico
básicos
nanohilos
siguientes
Suspendido
hilo
suspende
hilo
distinto
espera
hilo
bloque
objeto
nivel
superior
ejemplo
hilo
Symbian
Espera
semáforo
rápido
hilo
espera
señale
semáforo
rá-
pido
tipo
variable
centinela
semáforos
rápidos
semáforos
nivel
na-
nokernel
Espera
DFC
hilo
esperando
agregue
llamada
fun-
ción
retrasada
DFC
cola
DFCs
DFCs
utilizan
implementación
dri-
vers
dispositivos
Representan
llamadas
kernel
cola
programar
ejecutarse
nivel
kernel
Symbian
Inactivo
hilos
inactivos
esperan
transcurra
cantidad
específica
tiempo
genérico
utiliza
desarrolladores
implementan
esta-
adicionales
nanohilos
desarrolladores
extienden
funcionalidad
nanokernel
plataformas
teléfonos
conoce
co-
mo
niveles
personalidad
desarrolladores
implemen-
tar
forma
cambia
implementaciones
extendidas
Compare
idea
nanohilo
idea
convencional
proceso
nanohilo
esencia
proceso
ultraligero
minicontexto
cambia
medida
nanohilos
cambian
www
FreeLibros.meSECCIÓN
12.3
PROCESOS
HILOS
SYMBIAN
939
procesador
nanohilo
procesos
claves
pa-
ra
nanohilos
estrecho
control
nanokernel
datos
mínimos
conforman
contexto
hilos
Symbian
basan
nanohilos
kernel
agrega
soporte
allá
proporciona
nanokernel
hilos
usuario
utilizan
aplicaciones
es-
tándar
implementan
hilos
Symbian
hilo
Symbian
contiene
nanohilo
agrega
pila
tiempo
ejecución
pila
utiliza
nanohilo
hilos
Symbian
operar
kernel
llamadas
sistema
Symbian
agrega
implementación
manejo
excepciones
señalización
terminar
hilos
Symbian
implementan
conjunto
implemen-
tación
nanohilo
hilos
Symbian
agregan
funcionalidad
implementa-
ción
mínima
nanohilo
reflejan
ideas
integradas
hilos
Symbian
sistema
operativo
agrega
encontrar
hilos
énfasis
condiciones
bloqueo
especiales
ocurrir
hilo
Sym-
bian
especiales
incluyen
espera
suspensión
semáforos
normales
va-
riables
mutex
variables
condición
Recuerde
implementación
hilos
Symbian
nanohilos
implementan
términos
nanohilos
nanohilo
suspendido
formas
12.3.2
Procesos
Symbian
procesos
hilos
Symbian
agrupados
estructura
blo-
control
proceso
espacio
memoria
hilo
ejecución
hilos
bloque
control
proceso
conceptos
proceso
progra-
mación
proceso
definido
hilos
nanohilos
Symbian
programación
proceso
implementa
realidad
planificación
hilo
ini-
cialización
bloque
control
proceso
correcto
hilo
utilice
ne-
cesidades
datos
hilos
Symbian
organizados
proceso
trabajan
juntos
formas
lugar
hilo
individual
marca
punto
inicial
proceso
lugar
hilos
comparten
parámetros
planificación
cambian
parámetros
método
planificación
proceso
cambian
parámetros
hi-
tercer
lugar
hilos
comparten
objetos
espacio
memoria
incluyendo
descripto-
res
dispositivos
descriptores
objetos
termina
proceso
kernel
termina
hilos
proceso
12.3.3
Objetos
activos
objetos
activos
formas
especializadas
hilos
implementan
forma
aligere
carga
imponen
entorno
operativo
diseñadores
Symbian
recono-
cieron
situaciones
bloquearía
hilo
aplicación
Symbian
enfoca
comunicación
aplicaciones
patrón
similar
www
FreeLibros.me940
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
implementación
escriben
datos
socket
comunicación
envían
información
tubería
bloquean
esperar
respuesta
receptor
objetos
activos
dise-
ñados
regresan
bloqueado
llamada
pun-
to
entrada
código
simplifica
implementación
ejecutan
espacio
usuario
objetos
activos
propiedades
hilos
Symbian
tales
nanohilo
unirse
hilos
Symbian
formar
proceso
sistema
operativo
objetos
activos
hilos
Symbian
lector
pregunte
ventaja
obtiene
sistema
operativo
modelo
hilos
simplificado
clave
objetos
acti-
vos
planificación
esperan
eventos
objetos
activos
residen
proceso
actuar
hilo
sistema
kernel
necesita
compro-
bar
continua
objeto
activo
desbloquear
obje-
tos
activos
proceso
coordinar
planificador
implementa
hilo
combinar
código
implementaría
hilos
hilo
crear
puntos
entrada
fijos
código
planifica-
dor
coordinar
ejecución
objetos
activos
forman
versión
eficiente
ligera
hi-
estándar
importante
adaptan
objetos
activos
estructura
pro-
cesos
Symbian
hilo
convencional
realiza
llamada
sistema
bloquea
ejecución
espera
sistema
operativo
formas
necesita
com-
probar
hilo
cambios
contexto
sistema
operativo
invertirá
tiempo
compro-
bar
procesos
bloqueados
espera
determinar
necesita
pasar
listo
objetos
activos
colocan
espera
esperan
ocu-
rra
evento
específico
sistema
operativo
necesita
comprobarlos
despla-
za
activa
evento
específico
resultado
requieren
comprobaciones
hilos
aumenta
rendimiento
12.3.4
Comunicación
procesos
entorno
multihilo
Symbian
comunicación
procesos
crucial
ren-
dimiento
sistema
hilos
especial
forma
servidores
sistema
comunican
constante
socket
modelo
básico
comunicación
utilizado
Symbian
línea
tu-
bería
comunicación
abstracta
extremos
abstracción
utiliza
ocultar
mé-
transporte
administración
datos
extremos
Symbian
utiliza
concepto
socket
comunicarse
clientes
servidores
hilos
dispositivos
en-
tre
hilos
modelo
socket
forma
base
dispositivos
abstracción
clave
modelo
útil
mecánica
intercambio
datos
dis-
positivo
administra
sistema
operativo
haga
aplicación
ejem-
plo
sockets
funcionan
TCP
IP
entorno
red
adaptar
www
FreeLibros.meSECCIÓN
12.4
ADMINISTRACIÓN
MEMORIA
941
facilidad
trabajar
entorno
Bluetooth
cambiar
parámetros
tipo
socket
uti-
lizado
sistema
operativo
encarga
trabajo
intercambio
datos
cambio
tipo
Symbian
implementa
primitivas
sincronización
estándar
encuentran
sis-
tema
operativo
propósito
general
utilizan
formas
semáforos
mutexes
sistema
operativo
proporcionan
sincronización
procesos
hilos
12.4
ADMINISTRACIÓN
MEMORIA
administración
memoria
sistemas
Linux
Windows
emplea
con-
ceptos
visto
implementar
administración
recursos
memoria
conceptos
páginas
memoria
virtual
crean
marcos
memoria
fí-
sica
memoria
virtual
paginación
demanda
reemplazo
dinámico
páginas
com-
binan
ilusión
recursos
memoria
ilimitados
memoria
física
soporta
extiende
almacenamiento
espacio
disco
duro
sistema
operativo
propósito
general
efectivo
Symbian
propor-
cionar
modelo
administración
memoria
almacenamiento
teléfonos
inteligentes
general
limitado
modelo
memoria
restringido
utiliza
modelo
espacio
memoria
virtual
intercambio
administración
memo-
ria
utiliza
mayoría
mecanismos
visto
administrar
memoria
incluyendo
MMUs
hardware
12.4.1
Sistemas
memoria
virtual
sistemas
cómputo
herramientas
proporcionar
memoria
virtual
com-
pleta
paginación
demanda
único
almacenamiento
disponible
sistema
operativo
plataformas
memoria
incluyen
disco
duro
mayoría
sis-
temas
pequeños
PDAs
teléfonos
inteligentes
dispositivos
bolsillo
nivel
proporcionan
memoria
virtual
paginación
demanda
Considere
espacio
memoria
utilizado
mayoría
dispositivos
plataformas
pe-
queñas
general
sistemas
tipos
almacenamiento
RAM
memoria
flash
RAM
almacena
código
sistema
operativo
utilizar
iniciar
sistema
memoria
flash
utiliza
memoria
operativa
almacenamiento
permanente
archivos
agregar
memoria
flash
adicional
dispositivo
tarjeta
Digital
Segura
SD
memoria
utiliza
exclusiva
almacenamiento
indefinido
ausencia
memoria
virtual
paginación
demanda
indica
ausencia
administración
memoria
mayoría
plataformas
pequeñas
basan
hardware
incluye
características
administración
sistemas
gran-
des
incluye
características
paginación
traducción
direcciones
abstracción
direcciones
virtuales
físicas
ausencia
memoria
virtual
indica
páginas
intercambiar
memoria
guardarse
almacenamiento
externo
utiliza
abstracción
páginas
memoria
páginas
reemplazan
página
www
FreeLibros.me942
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
reemplazar
descarta
significa
reemplazar
páginas
código
respaldan
memoria
flash
administración
memoria
consiste
siguientes
tareas
Administración
tamaño
aplicación
tamaño
aplicación
código
da-
tos
efecto
contundente
forma
utiliza
memoria
re-
habilidad
disciplina
crear
software
pequeño
presión
utilizar
diseño
orientado
objetos
obstáculo
objetos
significan
asignación
memoria
dinámica
implica
mayores
tamaños
montículo
mayoría
sistemas
operativos
plataformas
pequeñas
recomiendan
vinculación
estáti-
ca
módulos
Administración
montículo
montículo
espacio
asignación
dinámica
memoria
administrar
forma
estricta
plataforma
pequeña
general
espacio
montículo
limita
plataformas
pequeñas
obli-
gar
programadores
reclamar
reutilizar
espacio
montículo
pue-
aventuran
allá
límites
producen
errores
asignación
memoria
Ejecución
lugar
plataformas
unidades
disco
general
admiten
eje-
cución
lugar
significa
memoria
flash
asigna
espacio
direcciones
virtuales
programas
ejecutar
directamente
memoria
flash
necesidad
copiarlos
RAM
reduce
cero
tiempo
carga
aplicaciones
iniciar
forma
instantánea
ocupar
RAM
escasa
Carga
DLLs
decisión
cargar
DLLs
afectar
per-
cepción
rendimiento
sistema
ejemplo
aceptable
cargar
DLLs
carga
aplicación
memoria
cargarlas
tiempos
esporádicos
ejecución
usuarios
aceptarán
disposición
tiempo
retraso
carga
aplicación
retrasos
ejecución
DLLs
necesiten
cargar
caso
encuentran
memoria
contenidas
almacenamiento
flash
externo
cuyo
caso
pue-
den
ejecutar
lugar
Transferencia
administración
memoria
hardware
MMU
dis-
ponible
utiliza
extensión
funcionalidad
MMU
rendimiento
sistema
regla
ejecución
lugar
pequeñas
plataformas
formas
necesitan
memoria
reservada
operación
sistema
operativo
memoria
comparte
almacenamiento
permanente
general
administra
formas
lu-
gar
sistemas
operativos
optan
metodología
simple
paginan
memoria
tipos
sistemas
cambio
contexto
significa
asignar
espacio
operación
espacio
montón
ejemplo
compartir
espacio
operación
procesos
mé-
utiliza
protección
áreas
memoria
procesos
confía
www
FreeLibros.meSECCIÓN
12.4
ADMINISTRACIÓN
MEMORIA
943
trabajarán
conjunto
Palm
aplica
metodología
simple
administrar
me-
moria
método
utiliza
metodología
disciplinada
método
memoria
secciona
páginas
asignan
necesidades
operación
páginas
mantienen
lista
páginas
libres
administrada
sistema
operativo
asignan
necesario
sistema
operativo
procesos
usuario
metodología
memoria
virtual
agota
lista
páginas
libres
sistema
queda
memoria
asignaciones
Symbian
ejemplo
método
12.4.2
direcciona
Symbian
memoria
Symbian
sistema
operativo
32
bits
direcciones
variar
GB
Emplea
abstracciones
sistemas
programas
utilizar
direc-
ciones
virtuales
sistema
operativo
asigna
direcciones
físicas
mayoría
sistemas
Symbian
divide
memoria
páginas
virtuales
marcos
físicos
tamaño
marcos
general
KB
variable
GB
memoria
tamaño
marco
KB
representa
ta-
bla
páginas
millón
entradas
tamaños
limitados
memoria
Symbian
dedicar
MB
tabla
páginas
tiempos
búsqueda
acceso
tabla
serían
carga
sistema
resolver
Symbian
adopta
estra-
tegia
tabla
páginas
niveles
muestra
figura
12-2
nivel
cono-
cido
directorio
páginas
proporciona
vínculo
nivel
indexa
porción
dirección
virtual
12
bits
directorio
mantiene
memo-
ria
TTBR
translation
table
base
register
registro
base
tabla
traducción
apunta
entrada
directorio
páginas
apunta
nivel
colección
tablas
páginas
tablas
proporcionan
vínculo
página
específica
memoria
indexan
me-
diante
porción
dirección
virtual
bits
palabra
pá-
gina
referenciada
indexa
12
bits
menor
orden
dirección
virtual
hardware
ayuda
cálculo
asignación
dirección
virtual
física
Symbian
asu-
mir
existencia
tipo
asistencia
hardware
arquitecturas
implementa
MMUs
ejemplo
procesador
ARM
MMU
extensa
búfer
traducción
adelantada
ayudar
cálculo
direcciones
página
memoria
produce
condición
error
to-
das
páginas
memoria
aplicación
cargar
momento
iniciar
aplicación
paginación
demanda
bibliotecas
cargan
forma
dinámica
llevan
explícita
memoria
pequeños
trozos
auxiliares
código
vinculado
eje-
cutable
aplicación
fallos
página
falta
intercambio
memoria
sorprendentemente
dinámica
Symbian
contexto
aplicaciones
cambia
memoria
cargan
requerimientos
memoria
empiezan
ejecución
páginas
memoria
re-
aplicación
solicitar
estática
sistema
operativo
momento
cargar
aplicación
memoria
espacio
dinámico
montículo
limitado
peticiones
estáticas
espacio
dinámico
marcos
www
FreeLibros.me944
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
memoria
asignan
páginas
lista
marcos
libres
marcos
libres
disponi-
bles
genera
condición
error
marcos
memoria
utilizados
reemplazar
páginas
aplicación
entrante
marcos
aplicación
esté
ejecutando
momento
intercambio
Symbian
lugar
puedan
copiar
páginas
desalojadas
memoria
flash
li-
mitada
archivos
usuario
realidad
versiones
distintas
modelo
implementación
memoria
uti-
liza
Symbian
modelo
diseñó
tipos
configuración
hardware
conti-
nuación
muestra
listado
modelo
movimiento
modelo
diseñó
primeras
arquitecturas
ARM
directorio
páginas
modelo
movimiento
KB
entrada
contiene
bytes
tamaño
directorio
16
KB
páginas
memo-
ria
protegen
bits
acceso
asociados
marcos
memoria
etiquetado
acceso
memoria
dominio
dominios
registran
di-
rectorio
páginas
MMU
implementa
permisos
acceso
dominio
utiliza
segmentación
forma
explícita
organización
dis-
directorio
páginas
dirección
virtual
índice
directorio
páginas
índice
tabla
páginas
índice
directorio
páginas
memoria
física
página
memoria
tablas
páginas
11
11
11
11000
00
0000000
00000
00
Figura
12-2
Symbian
utiliza
tabla
páginas
niveles
reducir
tiempo
acceso
tablas
almacenamiento
www
FreeLibros.meSECCIÓN
12.5
ENTRADA
SALIDA
945
tribución
memoria
sección
datos
datos
asignados
usuario
sección
kernel
datos
asignados
kernel
modelo
múltiple
modelo
desarrolló
versiones
posteriores
ar-
quitectura
ARM
MMU
versiones
difiere
utilizada
versiones
ante-
riores
ejemplo
directorio
página
requiere
manejo
distinto
seccionar
piezas
referencia
conjuntos
distintos
tablas
páginas
conjuntos
utilizan
tablas
páginas
usuario
tablas
página
kernel
versión
arquitectura
ARM
revisó
mejo-
ró
bits
acceso
marco
página
abandonó
concepto
principal
modelo
directo
modelo
directo
memoria
asume
MMU
modelo
utiliza
permitido
teléfonos
inteligentes
falta
MMU
ocasionaría
severos
problemas
rendimiento
modelo
útil
entornos
de-
sarrollo
MMU
deshabilitar
razón
modelo
emulador
modelo
desarrolló
proveer
emulador
Symbian
Windows
emulador
restricciones
comparación
CPU
destino
emulador
ejecuta
proceso
Windows
espacio
direcciones
restringido
GB
GB
memoria
proporciona
emulador
accesible
proceso
Symbian
protección
memoria
disponible
bibliotecas
Symbian
propor-
cionan
DLLs
formato
Windows
Windows
maneja
asignación
administración
memoria
12.5
ENTRADA
SALIDA
estructura
entrada
salida
Symbian
refleja
diseños
sistemas
operativos
sección
resaltaremos
características
únicas
Symbian
utiliza
en-
focarse
plataforma
destino
12.5.1
Drivers
dispositivos
Symbian
drivers
dispositivos
ejecutan
código
privilegiado
kernel
proporcionar
acceso
código
nivel
usuario
recursos
protegidos
sistema
casos
Linux
Windows
drivers
dispositivos
representan
acceso
hardwa-
re
software
Symbian
driver
dispositivos
divide
niveles
driver
dispositivo
ló-
gico
LDD
driver
dispositivo
físico
PDD
LDD
presenta
interfaz
niveles
su-
periores
software
PDD
interactúa
directa
hardware
modelo
LDD
utilizar
implementación
clase
específica
dispositivos
PDD
cambia
dispositivo
Symbian
suministra
LDDs
estándar
hardware
estándar
común
Symbian
proporciona
PDD
www
FreeLibros.meConsidere
ejemplo
dispositivo
serial
Symbian
define
LDD
serial
genérico
define
interfaces
programa
acceder
dispositivo
serial
LDD
proporciona
inter-
faz
PDD
proporciona
interfaz
dispositivos
seriales
PDD
implementa
mecanismos
búfer
control
flujo
necesarios
ayudar
regular
diferencias
ve-
locidad
CPU
dispositivos
seriales
LDD
usuario
conec-
tar
cualquiera
PDDs
pudieran
utilizar
operar
dispositivos
seriales
teléfono
inteligente
específico
incluir
puerto
infrarrojo
puerto
RS-232
ejemplos
utilizan
LDD
serial
distintos
PDDs
LDDs
PDDs
cargar
forma
dinámica
programas
usua-
rio
memoria
proporcionan
herramientas
programación
compro-
bar
necesario
cargarlos
12.5.2
Extensiones
kernel
extensiones
kernel
drivers
dispositivos
Symbian
carga
tiempo
inicio
cargan
tiempo
inicio
casos
especiales
necesitan
tratar
distin-
ta
drivers
dispositivos
normales
extensiones
kernel
distintas
drivers
dispositivos
normales
mayoría
drivers
dispositivos
implementan
LDDs
forman
parejas
PDDs
cargan
necesario
aplicaciones
espacio
usuario
extensiones
kernel
cargan
tiempo
inicio
orientadas
específica
dispositivos
general
forman
pares
PDDs
extensiones
kernel
integradas
procedimiento
inicio
drivers
dis-
positivos
especiales
cargan
inician
justo
inicia
programador
Implementan
funciones
cruciales
sistemas
operativos
servicios
DMA
administración
pantalla
control
buses
dispositivos
periféricos
ejemplo
bus
USB
drivers
pro-
porcionan
razones
lugar
coinciden
abstracciones
diseño
orientado
objetos
visto
característica
diseño
microkernels
lugar
permi-
plataformas
separadas
ejecuta
Symbian
ejecuten
drivers
dispositivos
especializados
habilitan
hardware
plataforma
volver
compi-
lar
kernel
12.5.3
Acceso
directo
memoria
frecuencia
drivers
dispositivos
DMA
Symbian
acepta
hardware
DMA
hardware
consiste
controlador
conjunto
canales
DMA
canal
proporciona
dirección
comunicación
memoria
disposi-
tivo
transmisión
bidireccional
datos
requiere
canales
DMA
par
canales
DMA
dedicados
controlador
LCD
pantalla
ma-
yoría
plataformas
ofrecen
número
canales
DMA
generales
dispositivo
transmite
datos
memoria
activa
interrupción
sistema
PDD
utiliza
servicio
DMA
proporciona
hardware
DMA
dispositivo
transmi-
946
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.meSECCIÓN
12.5
ENTRADA
SALIDA
947
sor
dispositivo
interconecta
hardware
Symbian
implementa
ni-
veles
software
PDD
controlador
DMA
nivel
DMA
software
ex-
tensión
kernel
interconecta
hardware
DMA
nivel
DMA
divide
nivel
independiente
plataforma
dependiente
extensión
kernel
ni-
vel
DMA
drivers
dispositivos
kernel
inicia
procedi-
miento
inicio
soporte
DMA
complicado
razón
especial
Symbian
soporta
mu-
chas
configuraciones
hardware
distintas
suponer
configuración
DMA
interfaz
hardware
DMA
estandariza
plataforma
sumi-
nistra
nivel
independiente
plataforma
fabricante
proporciona
nivel
dependiente
plataforma
extensión
kernel
hardware
DMA
forma
Symbian
dispositivo
driver
dispositivos
compo-
nentes
LDD
PDD
hardware
DMA
ve
dispositivo
derecho
forma
implementar
soporte
sentido
paralela
forma
Sym-
bian
admite
dispositivos
12.5.4
Caso
especial
medios
almacenamiento
drivers
medios
forma
especial
PDD
Symbian
servidor
ar-
chivos
utiliza
exclusiva
implementar
acceso
dispositivos
medios
almacenamiento
teléfonos
inteligentes
contener
medios
fijos
removibles
drivers
medios
reconocer
soportar
variedad
formas
almacenamiento
so-
porte
Symbian
medios
incluye
LDD
estándar
API
interfaz
usuarios
servidor
archivos
Symbian
aceptar
26
unidades
distintas
tiempo
unidades
locales
distinguen
letra
unidad
Windows
12.5.5
Bloqueo
Symbian
bloqueo
objetos
activos
diseñadores
peso
hilos
esperan
evento
afecta
hilos
sistema
objetos
activos
permiten
sistema
operativo
maneje
llamadas
bloqueo
haga
proceso
objetos
activos
coordinan
planificador
implementan
hilo
objeto
activo
utiliza
llamada
bloqueo
señala
sistema
operativo
suspende
completa
llamada
bloqueo
sistema
operativo
des-
pierta
proceso
suspendido
continúa
ejecución
función
hubiera
regresado
datos
diferencia
perspectiva
objeto
activo
llamar
fun-
ción
esperar
valor
retorno
llamar
función
especial
dejar
establezca
bloqueo
regresar
inmediato
sistema
operativo
cargo
espera
www
FreeLibros.me12.5.6
Medios
removibles
medios
removibles
representan
dilema
interesante
diseñadores
sistemas
operativos
inserta
tarjeta
SD
Digital
segura
ranura
lector
dispositivo
justo
Necesita
controlador
driver
estructura
bus
comunique
CPU
DMA
quitar
problema
grave
modelo
dispositivo
detecta
sistema
operativo
inserción
remoción
modelo
ausencia
tarjeta
medios
complicar
cosas
ranu-
ras
dispositivos
alojar
tipo
dispositivo
ejemplo
tarjeta
SD
tarje-
ta
miniSD
adaptador
tarjeta
MultimediaCard
utilizan
tipo
ranura
Symbian
empieza
implementación
medios
removibles
similitudes
tipo
removible
características
comunes
dispositivos
insertar
remover
medios
removibles
remover
caliente
reportar
capacidades
tarjetas
incompatibles
rechazar
tarjeta
necesita
energía
aceptar
medios
removibles
Symbian
proporciona
controladores
software
con-
trolan
tarjeta
admitida
controladores
funcionan
drivers
dispositivos
tarjeta
software
inserta
tarjeta
crea
objeto
socket
forma
canal
fluyen
datos
adaptar
cambios
tarjeta
Symbian
proporciona
serie
eventos
ocurren
cambian
drivers
dis-
positivos
configuran
objetos
activos
escuchar
responder
eventos
12.6
SISTEMAS
ALMACENAMIENTO
sistemas
operativos
orientados
usuario
Symbian
sistema
archivos
veremos
continuación
12.6.1
Sistemas
archivos
dispositivos
móviles
términos
sistemas
archivos
almacenamiento
sistemas
operativos
teléfonos
móviles
requerimientos
sistemas
operativos
equipos
escrito-
rio
mayoría
implementa
entornos
32
bits
permite
usuarios
nombres
arbitra-
rios
archivos
almacena
archivos
requieren
tipo
estructura
organizada
significa
conveniente
sistema
archivos
jerárquico
basado
directorios
aun-
948
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.meSECCIÓN
12.6
SISTEMAS
ALMACENAMIENTO
949
diseñadores
sistemas
operativos
móviles
opciones
sistemas
archivos
característica
influye
elección
mayoría
teléfonos
mó-
viles
medios
almacenamiento
compartir
entorno
Windows
sistemas
teléfonos
móviles
tuvieran
medios
removibles
utili-
zar
sistema
archivos
sistemas
utilizan
memoria
flash
circunstancias
tamaños
bloque
general
512
bytes
2048
bytes
memoria
flash
simplemente
sobrescribir
memoria
borrar
escribir
unidad
eliminación
ordinaria
borrar
bytes
blo-
ques
enteros
tiempos
borrado
memoria
flash
relativamente
largos
características
memoria
flash
funciona
sistemas
archivos
diseñados
específica
esparcen
escrituras
medios
lidian
tiempos
largos
borrado
concepto
básico
actualizar
almacenamien-
to
flash
sistema
archivos
escribe
copia
datos
modificados
bloque
reasigna
apuntadores
archivos
borra
bloque
tiempo
sistemas
archivos
flash
FFS2
Microsoft
usarlo
MS-
principios
década
1990
grupo
industria
PCMCIA
aprobó
espe-
cificación
Nivel
traducción
flash
memoria
flash
1994
dispositivos
flash
tenían
apariencia
sistema
archivos
FAT
Linux
sistemas
archivos
diseñados
forma
especial
JFFS
YAFFS
Journaling
Flash
File
System
Sistema
ar-
chivos
flash
transaccional
Yet
Another
Flash
Filing
System
sistema
archivos
flash
plataformas
móviles
compartir
medios
computadoras
pa-
ra
necesario
contar
forma
compatibilidad
sistemas
FAT
utilizan
frecuencia
especial
FAT-16
tabla
asignación
corta
FAT-32
reducido
archivos
extensos
12.6.2
Sistemas
archivos
Symbian
Symbian
sistema
operativo
teléfonos
inteligentes
móviles
necesita
im-
plementar
sistema
archivos
FAT-16
duda
provee
soporte
FAT-16
uti-
liza
sistema
operativo
medios
almacenamiento
implementación
servidor
archivos
Symbian
basa
abs-
tracción
forma
parecida
sistema
archivos
virtual
Linux
orientación
objetos
permite
conectar
objetos
implementan
sistemas
operativos
servidor
archivos
Symbian
utilizar
implementaciones
distintas
sistemas
ar-
chivos
distintas
implementaciones
coexistir
servidor
archivos
creado
implementaciones
sistemas
archivos
NFS
SMB
Sym-
bian
12.6.3
Seguridad
protección
sistema
archivos
seguridad
teléfonos
inteligentes
interesante
variación
seguridad
computacio-
nal
general
aspectos
teléfonos
inteligentes
convierten
seguridad
www
FreeLibros.me950
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
reto
Symbian
elecciones
diseño
diferencian
sistemas
escritorio
propósito
general
plataformas
teléfonos
inteligentes
sección
concentraremos
aspectos
pertenecen
seguridad
sistema
archi-
vos
trataremos
cuestiones
Considere
entorno
teléfonos
inteligentes
dispositivos
usuario
requieren
identificación
usarlos
usuario
teléfono
ejecutar
aplicaciones
marcar
número
telefónico
acceder
redes
identificación
entorno
seguridad
basada
permisos
desafiante
falta
identificación
significa
conjunto
permisos
permisos
usuario
seguridad
frecuencia
aprovecha
tipos
informa-
ción
versión
posteriores
Symbian
aplicaciones
reciben
conjunto
capaci-
dades
instalarse
sección
analizaremos
proceso
decide
capacidades
otorgar
aplicación
conjunto
capacidades
aplicación
compara
ac-
ceso
solicita
acceso
conjunto
capacidades
otorga
acceso
caso
contrario
rechaza
comparar
capacidades
requiere
sobrecarga
comparación
realiza
llamada
sistema
implique
acceso
recurso
so-
brecarga
comparar
propiedad
archivos
propietario
archivo
sacrificio
funciona
Symbian
Symbian
formas
seguridad
archivos
áreas
me-
almacenamiento
Symbian
aplicaciones
utilizar
capacidad
especial
proporciona
aplicación
instala
software
sistema
efecto
instalar
aplicaciones
quedan
protegidas
acceso
sistema
significa
programas
maliciosos
sistema
virus
infectar
aplicaciones
instaladas
áreas
sistema
ar-
chivos
reservadas
específica
tipos
manipulación
datos
aplicación
conoce
jaulas
datos
consulte
sección
Symbian
capacidades
funcionado
propiedad
ar-
chivos
proteger
acceso
2.7
SEGURIDAD
SYMBIAN
teléfonos
inteligentes
proveen
entorno
difícil
seguro
vimos
dispositivos
usuario
requieren
autenticación
funciones
básicas
funciones
complicadas
instalar
aplicaciones
requieren
autorización
autenticación
ejecutan
sistemas
operativos
complejos
formas
enviar
recibir
datos
incluyendo
ejecución
programas
complicado
salvaguardar
es-
tos
entornos
Symbian
ejemplo
dificultad
usuarios
esperan
teléfonos
in-
teligentes
Symbian
permitan
tipo
necesidad
autenticación
ne-
cesidad
iniciar
sesión
verificar
identidad
duda
experimentado
lector
sistema
operativo
complicado
Symbian
capaz
www
FreeLibros.meSECCIÓN
12.7
SEGURIDAD
SYMBIAN
951
susceptible
virus
gusanos
programas
maliciosos
versiones
Symbian
anteriores
versión
ofrecían
seguridad
tipo
guardián
sistema
pedía
usuario
permiso
instalar
aplicaciones
pensamiento
diseño
aplicacio-
nes
instaladas
usuario
causar
daños
sistema
usuario
informado
sabría
programas
podía
instalar
maliciosos
confiaba
usuario
usara
prudencia
diseño
guardián
mérito
ejemplo
teléfono
inteligente
aplicaciones
instaladas
usuario
sistema
ejecutarse
errores
instalar
aplicaciones
usuario
sabía
maliciosas
mantener
seguridad
sistema
problema
diseño
usuarios
conocen
ramificaciones
completas
software
instalar
virus
enmascaran
programas
útiles
realizan
funciones
utilidad
instalan
silencio
código
malicioso
usuarios
norma-
verificar
confianza
completa
software
disponible
verificación
confianza
provocó
rediseño
completo
seguridad
plataforma
versión
Symbian
versión
sistema
operativo
mantiene
mo-
delo
guardián
asume
responsabilidad
verificar
software
haga
usuario
desarrollador
software
responsable
verificar
aplica-
ciones
proceso
conocido
firmado
sistema
verifica
afirmación
desarrollador
software
requiere
verificación
accede
fun-
ciones
sistema
aplicación
requiere
firmado
cabo
serie
pasos
desarrollador
software
obtener
ID
distribuidor
confía
terceros
confianza
certificados
Symbian
desarrollador
produce
paquete
software
desea
distribuirlo
en-
viarlo
valide
desarrollador
envía
ID
distribuidor
software
lista
formas
software
accede
sistema
confianza
verifica
lista
tipos
acceso
software
es-
té
completa
ocurra
tipo
acceso
es-
ta
verificación
firma
software
significa
paquete
instalación
cantidad
especial
información
explica
detalle
hará
sistema
Symbian
llegar
paquete
instalación
envía
vuelta
desarrollador
software
distribuya
usuarios
Observe
método
depende
forma
soft-
ware
accede
recursos
sistema
Symbian
acceder
recurso
sistema
programa
capacidad
acceder
recurso
Es-
ta
idea
capacidades
integrada
kernel
Symbian
crea
proceso
bloque
control
registra
capacidades
otorgan
caso
proceso
trate
acceso
liste
capacidades
kernel
denegará
acceso
www
FreeLibros.meEl
resultado
proceso
aparentemente
elaborado
distribuir
aplicaciones
firmadas
sistema
confianza
guardián
automatizado
integrado
Symbian
ve-
rificar
software
instalar
proceso
instalación
comprueba
señalización
pa-
quete
instalación
firma
paquete
válida
kernel
otorga
capacidades
aplicación
ejecuta
diagrama
figura
12-3
describe
relaciones
confianza
Symbian
versión
observar
niveles
confianza
integrados
sistema
aplicaciones
acceden
recursos
sistema
requieren
firma
ejemplo
aplicación
simple
muestre
pantalla
apli-
caciones
confianza
necesitan
serlo
nivel
compuesto
aplicaciones
firmadas
nivel
usuario
aplicaciones
firmadas
reciben
capaci-
dades
necesitan
tercer
nivel
confianza
compuesto
servidores
sistema
aplicaciones
nivel
usuario
servidores
necesiten
capaci-
dades
labores
arquitectura
microkernel
Symbian
servi-
dores
ejecutan
nivel
usuario
confianza
aplicaciones
nivel
usuario
clase
programas
requieren
confianza
completa
sistema
conjunto
programas
habilidad
modificar
sistema
compuesto
códi-
go
kernel
952
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
etel
mensajería
MMF
esock
Wserv
kernel
F32
SWlnstall
Entorno
computación
confianza
servidores
sistema
ejecutan
distintos
privilegios
Base
cómputo
confianza
habilidad
completa
modificar
sistema
contiene
kernel
F32
SWInstall
SWInstall
guardián
Aplicaciones
firmadas
Software
confianza
firma
propósitos
establecidos
Software
firma
Aplicaciones
confianza
afectan
sistemas
archivos
entorno
sistema
Figura
12-3
Symbian
utiliza
relaciones
confianza
implementar
seguridad
aspectos
sistema
parecer
cuestionables
ejemplo
nece-
sario
proceso
elaborado
especial
requiere
dinero
respuesta
sistema
firmas
Symbian
reemplaza
usuarios
verificador
integri-
www
FreeLibros.meSECCIÓN
12.8
COMUNICACIÓN
SYMBIAN
953
dad
software
realizarse
verificación
real
ende
parecer
procesos
dificultan
desarrollo
prueba
hardware
real
requiere
paquete
instalación
firmado
responder
Symbian
reconoce
firmado
especial
desarrollado-
res
desarrollador
obtener
certificado
digital
firmado
especial
límite
tiempo
general
meses
específico
teléfono
digital
particular
desa-
rrollador
crear
paquetes
instalación
certificado
digital
función
guardián
versión
Symbian
emplea
conocido
jaulas
datos
datos
organizan
directorios
código
ejecutable
só-
directorio
ejemplo
aplicación
instalación
software
es-
cribir
datos
escritos
aplicaciones
escribir
directorio
privado
inaccesible
programas
12.8
COMUNICACIÓN
SYMBIAN
Symbian
diseñado
criterios
específicos
mente
caracterizar
comu-
nicaciones
controladas
eventos
relaciones
cliente
servidor
configura-
ciones
basadas
pila
12.8.1
Infraestructura
básica
infraestructura
comunicación
Symbian
basa
componentes
básicos
figura
12-4
muestra
forma
genérica
infraestructura
Considere
diagrama
pun-
to
inicial
modelo
organizacional
inferior
pila
dispositivo
físico
co-
nectado
forma
computadora
dispositivo
módem
teléfono
móvil
transmisor
radio
Bluetooth
embebido
incrustado
comunicador
in-
teresados
detalles
hardware
consideraremos
dispositivo
físico
unidad
abstracta
responde
comandos
software
forma
apropiada
nivel
interesa
driver
dispositivo
recal-
cado
estructura
drivers
dispositivos
software
nivel
preocupa
trabajar
directa
hardware
estructuras
LDD
PDD
software
ni-
vel
específico
hardware
pieza
hardware
requiere
driver
dis-
positivo
interfaz
requieren
distintos
drivers
diiferentes
unidades
hardware
implementar
interfaz
niveles
superiores
nivel
implementación
protocolos
esperará
interfaz
importar
hardware
utilice
nivel
implementación
protocolos
contiene
implementacio-
nes
protocolos
admite
Symbian
implementaciones
asumen
interfaz
dri-
dispositivo
nivel
inferior
proveen
interfaz
unificada
nivel
aplicación
superior
ejemplo
nivel
implementa
suites
protocolos
Bluetooth
TCP
IP
protocolos
www
FreeLibros.me954
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
nivel
aplicación
superior
nivel
contiene
aplicación
de-
be
utilizar
infraestructura
comunicación
aplicación
forma
implementan
comunicaciones
realiza
trabajo
necesario
informar
sis-
tema
operativo
dispositivos
utilizará
drivers
instalados
apli-
cación
utiliza
forma
directa
basa
APIs
nivel
implementación
protocolos
controlar
verdaderos
dispositivos
12.8.2
análisis
detallado
infraestructura
figura
12-5
muestra
análisis
detallado
niveles
infraestructura
co-
municación
Symbian
diagrama
basa
modelo
genérico
figura
12-4
cuyos
bloques
subdividieron
unidades
operacionales
representan
utiliza
Symbian
dispositivo
físico
dispositivo
cambiado
dijimos
Sym-
bian
control
hardware
aloja
hardware
diseño
API
niveles
especifica
diseña
construye
hardware
realidad
ventaja
Symbian
desarrolladores
hardware
unidad
abstracta
diseñar
comunicación
abstracción
diseñadores
Symbian
aseguran
sistema
operativo
manejar
amplia
variedad
dispositivos
disponibles
actualidad
alojar
hardware
futuro
Aplicación
Implementación
protocolos
Driver
dispositivo
Dispositivo
físico
HARD-
WARE
Figura
12-4
comunicación
Symbian
estructura
orientada
bloques
www
FreeLibros.meSECCIÓN
12.8
COMUNICACIÓN
SYMBIAN
955
capa
driver
dispositivo
capa
dividido
niveles
figura
12-5
nivel
PDD
interconecta
directa
dispositivo
físico
vimos
puerto
hardware
específico
nivel
LDD
interconecta
nivel
implementación
protocolos
implementa
direc-
tivas
Symbian
relacionadas
dispositivo
directivas
incluyen
búferes
entrada
salida
mecanismos
interrupciones
control
flujo
capa
implementación
protocolos
figura
12-5
agregado
subcapas
nivel
implementación
protocolos
uti-
lizan
tipos
módulos
implementación
protocolos
Módulos
CSY
nivel
capas
implementación
protocolos
ser-
vidor
comunicación
módulo
CSY
módulo
comunica
directa
hardware
porción
driver
dispositivo
correspondiente
PDD
im-
plementa
diversos
aspectos
nivel
protocolos
ejemplo
pro-
tocolo
requiera
transferencia
datos
puros
dispositivo
hardware
especifique
transferencia
búfer
bits
módulo
CSY
maneja
modos
Aplicación
Código
usuario
Módulo
comunicación
CSY
aplicación
Implementación
protocolos
Módulo
MTM
Módulo
protocolo
PRT
Módulo
comunicación
TSY
Módulo
comunicación
CSY
Driver
dispositivos
Driver
dispositivo
lógico
Driver
dispositivo
físico
Dispositivo
físico
HARD-
WARE
Figura
12-5
estructura
comunicación
Symbian
conjunto
exten-
so
características
www
FreeLibros.meMódulos
TSY
telefonía
abarca
infraestructura
comunicaciones
utilizan
módulos
especiales
implementarla
módulos
servidor
telefo-
nía
TSY
implementan
funcionalidad
telefonía
TSYs
básicos
soportar
funciones
telefónicas
estándar
ejemplo
terminar
llamadas
amplia
va-
riedad
hardware
TSYs
avanzados
soportar
hardware
telefónico
avan-
zado
soportan
funcionalidad
GSM
Módulos
PRT
módulos
centrales
utilizan
implementar
protocolos
módulos
protocolos
módulos
PRT
servidores
utilizan
dichos
módulos
im-
plementar
protocolos
servidor
crea
instancia
módulo
PRT
intenta
protocolo
ejemplo
suite
TCP
IP
protocolos
implementa
módulo
TCPIP.PRT
protocolos
Bluetooth
implementan
módulo
BT.PRT
MTMs
Symbian
diseñado
específica
mensajería
ar-
quitectos
construyeron
mecanismo
manejar
mensajes
tipo
maneja-
dores
mensajes
conocen
módulos
tipos
mensajes
MTMs
manejo
mensajes
aspectos
distintos
MTMs
implementar
aspectos
MTMs
interfaz
usuario
implementar
diversas
formas
usuarios
verán
manipularán
mensajes
forma
usuario
lee
mensaje
notifica
progreso
envío
men-
saje
MTMs
cliente
manejan
procesos
dirigir
crear
responder
mensajes
MTMs
servidor
implementar
manipulación
orientada
objetos
mensajes
incluyendo
manipulación
carpetas
manipulación
espe-
cífica
mensajes
módulos
basan
módulos
formas
dependiendo
tipo
comunicación
utilice
ejemplo
implementaciones
protocolos
uti-
lizan
Bluetooth
utilizan
módulos
PRT
drivers
dispositivo
protocolos
IrDA
implementaciones
TCP
IP
utilizan
PPP
basan
módu-
PRT
módulo
TSY
módulo
CSY
implementaciones
TCP
IP
PPP
general
utilizan
módulo
TSY
módulo
CSY
vinculan
módulo
PRT
driver
dispositivo
red
Modularidad
infraestructura
modularidad
modelo
basado
pilas
útil
implementadores
calidad
abs-
tracta
diseño
niveles
evidente
ejemplos
acabamos
mostrar
Considere
implementación
pila
TCP
IP
conexión
PPP
directamente
mó-
dulo
CSY
elegir
implementación
GSM
TSY
módem
regular
pasa
módulo
CSY
futuro
traiga
tecnología
telefonía
estructura
existente
se-
guirá
funcionamiento
requerirá
agregar
módulo
TSY
implementación
telefonía
ajustar
detalle
pila
protocolo
TCP
IP
requiere
alterar
956
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.meSECCIÓN
12.9
RESUMEN
957
módulos
depende
simplemente
ajusta
módulo
PRT
TCP
IP
deja
resto
modularidad
extensiva
significa
código
adhiere
facili-
dad
infraestructura
código
antiguo
descarta
facilidad
código
existente
modificar
trastornar
sistema
requerir
reinstalaciones
extensivas
figura
12-5
agregado
subcapas
nivel
aplicación
módulos
CSY
aplicaciones
utilizan
interfaces
módulos
protocolos
implemen-
taciones
considerar
módulos
partes
implementaciones
pro-
tocolos
conveniente
considerarlas
aplicaciones
asistentes
ejemplo
aplicación
utiliza
enviar
mensajes
SMS
teléfono
móvil
aplicación
utilizaría
módulo
CSY
IRCOMM
aplicación
utiliza
im-
plementación
SMS
envuelta
nivel
implementación
protocolos
modu-
laridad
proceso
ventaja
aplicaciones
necesitan
enfocar
proceso
comunicaciones
12.9
RESUMEN
Symbian
diseñó
sistema
operativo
orientado
objetos
plataformas
telé-
fonos
inteligentes
diseño
microkernel
utiliza
núcleo
nanokernel
peque-
ño
implementa
funciones
kernel
rápidas
primitivas
Symbian
emplea
arquitectura
cliente
servidor
coordina
acceso
recursos
sistema
servidores
es-
pacio
usuario
diseñado
teléfonos
inteligentes
Symbian
ca-
racterísticas
sistema
operativo
propósito
general
procesos
hilos
administración
memoria
soporte
sistema
archivos
infraestructura
comunicaciones
extensa
Symbian
implementa
características
únicas
ejemplo
objetos
activos
mu-
cho
eficiente
espera
eventos
externos
falta
memoria
virtual
desafian-
administración
memoria
soporte
orientación
objetos
drivers
dispositivos
utiliza
diseño
abstracto
capas
PROBLEMAS
siguientes
ejemplos
servicios
describa
considerar
ope-
ración
espacio
kernel
espacio
usuario
ejemplo
servidor
sistema
sistema
operativo
microkernel
Symbian
Programar
hilo
ejecutarlo
Imprimir
documento
Responder
consulta
descubrimiento
Bluetooth
Administrar
acceso
hilo
pantalla
Reproducir
sonido
llegue
mensaje
texto
Interrumpir
ejecución
responder
llamada
telefónica
www
FreeLibros.me2
Haga
lista
mejoras
eficiencia
diseño
microkernel
Haga
lista
problemas
eficiencia
diseño
microkernel
Symbian
dividió
diseño
kernel
niveles
nanokernel
kernel
Symbian
servicios
administración
dinámica
memoria
consideraban
complicados
nanokernel
Describa
componentes
complicados
administración
di-
námica
memoria
funcionar
nanokernel
Analizamos
objetos
activos
forma
mejorar
eficiencia
procesamiento
S.
Cree
aplicación
utilizar
objetos
activos
tiempo
reaccionaría
sistema
eventos
requirieran
acción
seguridad
Symbian
enfoca
instalación
Symbian
firme
aplica-
ciones
caso
aplicación
colocara
almacenamiento
eje-
cutarla
instalada
Sugerencia
Piense
posibles
puntos
entrada
datos
teléfono
móvil
Symbian
protección
recursos
compartidos
basada
servidor
utiliza
for-
ma
extensa
Liste
ventajas
tipo
coordinación
recurso
entorno
microkernel
Haga
conjeturas
forma
ventajas
po-
dría
afectar
arquitectura
kernel
distinta
958
CASO
ESTUDIO
SYMBIAN
CAPÍTULO
12
www
FreeLibros.me13
DISEÑO
SISTEMAS
OPERATIVOS
959
12
capítulos
anteriores
tratamos
temas
analizamos
cantidad
conceptos
ejemplos
relacionados
sistemas
operativos
diseño
presenta
características
espe-
cíficas
capítulo
daremos
vistazo
rápido
cuestiones
sacrificios
diseñadores
sistemas
operativos
considerar
diseñar
implementar
sistema
cantidad
folclore
malo
comunidades
sistemas
operativos
sorprendente
escrito
libro
importante
The
Mythical
Man
Month
mítico
hombre-mes
obra
clásica
Fred
Brooks
relata
experiencias
diseño
implementación
OS/360
IBM
edición
20
aniversario
revisa
material
agrega
capítulos
Brooks
1995
documentos
clásicos
diseño
sistemas
operativos
Hints
for
Computer
Sys-
tem
Design
Lampson
1984
On
Building
Sistems
That
Hill
Fail
Corbató
1991
End-to-
End
Arguments
in
System
Design
Saltzer
colaboradores
1984
libro
Brooks
documentos
sobrevivido
paso
años
extremadamente
mayoría
ideas
siguen
válidas
publicaron
capítulo
basa
fuentes
experiencia
personal
autor
diseñador
co-diseñador
sistemas
Amoeba
Tanenbaum
colaboradores
1990
MINIX
Tanenbaum
Woodhull
1997
Globe
Steel
colaboradores
1999a
consenso
en-
tre
diseñadores
sistemas
operativos
forma
diseñar
sistema
operativo
capítulo
personal
especulativo
duda
controversial
an-
teriores
www
FreeLibros.me13.1
NATURALEZA
PROBLEMA
DISEÑO
diseño
sistemas
operativos
proyecto
ingeniería
ciencia
exacta
difícil
establecer
objetivos
claros
cumplirlos
empezar
puntos
13.1.1
Objetivos
diseñar
sistema
operativo
exitoso
diseñadores
clara
idea
quieren
falta
objetivo
dificulta
considerable
proceso
tomar
decisiones
subsiguientes
aclarar
punto
instructivo
vistazo
lenguajes
progra-
mación
PL
C.
IBM
diseñó
PL
década
1960
molestia
sopor-
FORTRAN
COBOL
vergonzoso
académicos
empezaran
parlotear
trasfondo
Algol
estableció
comité
producir
lenguaje
cumpliera
necesidades
personas
PL
I.
FOR-
TRAN
COBOL
Algol
Fracasó
carecía
visión
unifica-
dora
colección
características
guerra
voluminoso
compilarse
eficiencia
iniciarse
consideremos
C.
lenguaje
diseñado
Dennis
Ritchie
propósito
pro-
gramación
sistemas
enorme
éxito
Ritchie
sabía
que-
ría
resultado
utilizando
extensa
décadas
aparición
visión
clara
imprescindible
desean
diseñadores
sistemas
operativos
duda
varía
sistema
sistemas
embebidos
incrustados
sistemas
servidor
sistemas
operativos
propósito
general
puntos
principales
Definir
abstracciones
Proveer
operaciones
primitivas
Asegurar
aislamiento
Administrar
hardware
continuación
analizaremos
puntos
tarea
importante
difícil
sistema
operativo
definir
abstrac-
ciones
correctas
procesos
espacios
direcciones
archivos
presentes
tiempo
parecer
obvias
hilos
re-
cientes
consecuencia
maduras
ejemplo
proceso
multihilo
hilo
bloqueado
espera
entrada
teclado
realiza
bifurcación
hilo
pro-
ceso
espera
entrada
teclado
abstracciones
relacionan
sincro-
nización
señales
modelo
memoria
modelado
áreas
960
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.1
NATURALEZA
PROBLEMA
DISEÑO
961
abstracciones
instanciar
forma
estructuras
datos
concretas
usuarios
crear
procesos
archivos
semáforos
etc.
operaciones
primitivas
manipu-
lan
estructuras
datos
ejemplo
usuarios
leer
escribir
archivos
opera-
ciones
primitivas
implementan
forma
llamadas
sistema
punto
vista
usuario
corazón
sistema
operativo
forma
abstracciones
operaciones
dis-
ponibles
llamadas
sistema
usuarios
sesión
abierta
computadora
tiempo
sistema
operativo
necesita
proveer
mecanismos
mantenerlos
separados
usuario
pue-
interferir
concepto
proceso
utiliza
ampliamente
agrupar
recursos
fines
protección
general
protegen
archivos
estructuras
datos
Asegurar
usuario
operaciones
autorizadas
datos
autorizados
objetivo
clave
diseño
sistemas
usuarios
desean
compartir
da-
tos
recursos
aislamiento
selectivo
controlado
usuario
difícil
programa
correo
electrónico
capaz
fa-
lle
navegador
Web
usuario
distintos
procesos
necesitan
aislados
necesidad
aislar
fallas
relacionada
punto
sis-
tema
falla
frecuente
proceso
usuario
permitir
falle
resto
sistema
diseño
asegurarse
diversas
partes
estén
aisladas
teo-
ría
partes
sistema
operativo
aislar
permitir
fallas
in-
dependientes
sistema
operativo
administrar
hardware
especial
cui-
chips
nivel
controladores
interrupciones
bus
proporcionar
marco
trabajo
permitir
drivers
dispositivos
administren
dispositivos
discos
impresoras
pantalla
13.1.2
difícil
diseñar
sistema
operativo
Ley
Moore
enuncia
hardware
computadora
mejora
factor
100
déca-
ley
declare
mejoramiento
sistemas
operativos
factor
100
años
siquiera
mejoren
considerar
peores
sentidos
clave
confiabilidad
versión
UNIX
dé-
1970
inercia
deseo
obtener
compatibilidad
inver-
sa
culpa
adherirse
principios
diseño
sistemas
operativos
esencialmente
distintos
formas
pequeños
programas
aplicación
venden
tiendas
49
dólares
cuestiones
difícil
diseñar
sistema
operativo
programa
aplicación
lugar
sistemas
operativos
convertido
programas
extremadamente
extensos
persona
sentar
PC
escribir
sistema
operativo
serio
meses
versiones
actuales
UNIX
sobrepasan
millones
líneas
www.FreeLibros.mecódigo
Windows
Vista
millones
líneas
código
kernel
70
millo-
nes
líneas
código
entender
millones
líneas
código
mu-
cho
70
millones
producto
diseñadores
esperar
comprender
completo
sorprender
resultados
estén
frecuencia
aleja-
óptimo
sistemas
operativos
complejos
ejemplo
empresas
transporte
aéreo
complicadas
particionar
subsistemas
aislados
comprenderlos
personas
diseñan
inodoros
aeronave
tie-
nen
preocuparse
sistema
radar
subsistemas
interacción
sistema
operativo
sistema
archivos
interactúa
memoria
formas
inesperadas
imprevistas
lugar
sistemas
operativos
lidiar
concurrencia
usuarios
dispositivos
activos
tiempo
esencia
difícil
adminis-
trar
concurrencia
actividad
secuencial
condiciones
carrera
interblo-
queos
problemas
surgen
tercer
lugar
sistemas
operativos
lidiar
usuarios
potencialmente
hostiles
desean
interferir
operación
sistema
cosas
prohibidas
robar
archi-
vos
usuario
sistema
operativo
necesita
tomar
medidas
necesarias
evitar
es-
tos
usuarios
comporten
inapropiada
programas
procesamiento
palabras
editores
fotografías
problema
cuarto
lugar
usuarios
desconfían
desean
compartir
información
recursos
usuarios
seleccionados
sistema
operativo
forma
usuarios
maliciosos
pue-
interferir
programas
aplicaciones
enfrentan
reto
similar
quinto
lugar
sistemas
operativos
viven
tiempo
UNIX
operación
cuarto
siglo
Windows
décadas
muestra
signos
desapari-
ción
consecuencia
diseñadores
pensar
forma
cambiar
hardware
aplicaciones
futuro
distante
prepararse
general
sistemas
encerrados
visión
específica
mundo
desaparecen
sexto
lugar
diseñadores
sistemas
operativos
realidad
idea
so-
bre
forma
utilizarán
sistemas
necesitan
proveer
generalidad
consi-
derable
UNIX
Windows
diseñaron
correo
electrónico
navegadores
Web
mente
computadoras
utilizan
sistemas
operativos
tiempo
utilizan
aplicaciones
diseñador
barcos
crear
especificarle
desean
bote
pesca
crucero
buque
guerra
cam-
bian
opinión
llega
producto
séptimo
lugar
general
sistemas
operativos
modernos
diseñados
porta-
bles
significa
ejecutarse
plataformas
hardware
ad-
mitir
miles
dispositivos
diseñados
independiente
tipo
relación
ejemplo
diversidad
ocasiona
problemas
necesidad
sistema
operativo
ejecute
máquinas
utilizan
notaciones
little-endian
big-en-
dian
ejemplo
podía
constante
MS-DOS
usuarios
trataban
instalar
ejemplo
tarjeta
sonido
módem
utilizaban
puertos
962
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.2
DISEÑO
INTERFACES
963
líneas
petición
interrupción
programas
sistemas
operativos
lidiar
problemas
ocasionan
piezas
hardware
conflicto
octavo
lugar
frecuente
necesidad
compatibilidad
inversa
cier-
to
sistema
operativo
sistema
restricciones
longitudes
palabras
nombres
archivos
aspectos
diseñadores
consideran
obsoletos
pe-
ro
seguir
utilizando
convertir
fábrica
producir
autos
año
año
seguir
produciendo
autos
año
capacidad
13.2
DISEÑO
INTERFACES
momentos
lector
fácil
escribir
sistema
operativo
moder-
empezar
lugar
iniciar
pensar
interfa-
ces
proporcionar
sistema
operativo
proporciona
conjunto
abstracciones
implementan
tipos
datos
ejemplo
archivos
operaciones
realizan
ejemplo
read
conjunto
elementos
forman
interfaz
usuarios
considerar
contexto
usuarios
sistema
operativo
programadores
escriben
código
utiliza
llamadas
sistema
personas
ejecutan
pro-
gramas
aplicación
interfaz
principal
llamadas
sistema
mayoría
sistemas
operativos
interfaces
adicionales
ejemplo
programadores
necesitan
escribir
drivers
dis-
positivos
insertarlos
sistema
operativo
drivers
ven
características
llamadas
procedimientos
características
llamadas
definen
in-
terfaz
distinta
ven
programadores
aplicaciones
interfaces
diseñar
cuidado
sistema
éxito
13.2.1
Principios
guía
Acaso
principios
puedan
guiar
diseño
interfaces
creemos
resumen
simplicidad
integridad
habilidad
implementarse
eficiente
Principio
Simplicidad
interfaz
simple
fácil
comprender
implementar
errores
di-
señadores
sistemas
memorizar
famosa
cita
pionero
francés
aviador
escritor
An-
toine
St
Exupéry
llega
perfección
agregar
quitar
principio
sistema
operativo
forma
principio
KISS
Keep
It
Simple
Stupid
Manténganlo
bre-
ve
simple
www
FreeLibros.mePrincipio
Integridad
interfaz
permitir
usuario
necesita
completa
famosa
cita
Albert
Einstein
simple
simple
palabras
sistema
operativo
exactamente
necesita
usuarios
necesitan
almacenar
datos
proveer
mecanismo
almacenar-
usuarios
necesitan
comunicarse
sistema
operativo
propor-
cionar
mecanismo
comunicación
conferencia
Premio
Turing
1991
Francisco
Corbató
diseñadores
CTSS
MULTICS
combinó
conceptos
simplicidad
integridad
lugar
importante
enfatizar
valor
simplicidad
elegancia
complejidad
tiende
agravar
dificultades
visto
crear
errores
de-
finición
elegancia
obtención
funcionalidad
dada
mínimo
meca-
nismo
máximo
claridad
idea
clave
mínimo
mecanismo
palabras
característica
función
lla-
mada
sistema
peso
cosa
hacerla
miembro
equipo
diseño
propone
extender
llamada
sistema
agregar
carac-
terística
preguntar
ocurriría
terrible
caso
incluyera
res-
puesta
alguien
encontrar
característica
útil
ponerla
biblioteca
nivel
usuario
sistema
operativo
lenta
for-
ma
características
rápidas
bala
objetivo
preservar
Corbató
denominó
mínimo
mecanismo
consideremos
forma
ejemplos
experiencia
MINIX
Tanen-
baum
Woodhull
2006
Amoeba
Tanenbaum
colaboradores
1990
fines
pro-
pósitos
MINIX
llamadas
sistema
send
receivey
sendrec
sistema
estructurado
colección
procesos
administrador
memoria
sistema
archivos
driver
dispositivo
proceso
programa
separado
instancia
kernel
programar
procesos
manejar
paso
mensajes
consecuen-
cia
necesitan
llamadas
sistema
sendpara
enviar
mensaje
receivepara
recibir-
llamada
sendrec
optimización
razones
eficiencia
permitir
enviar
mensaje
devolver
respuesta
trampa
kernel
pide
proceso
ejemplo
proceso
sistema
archivos
driver
disco
realice
trabajo
Amoeba
simple
llamada
sistema
llamada
procedi-
miento
remoto
llamada
envía
mensaje
espera
solicitud
esencia
sen-
drecde
MINIX
integrado
llamada
964
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.2
DISEÑO
INTERFACES
965
Principo
Eficiencia
tercer
lineamiento
eficiencia
implementación
característica
llamada
siste-
ma
implementar
eficiencia
valga
pena
tenerla
in-
tuitivamente
obvia
programador
relación
costo
llamada
sistema
ejemplo
programadores
UNIX
esperan
llamada
sistema
lseeksea
costosa
llamada
sistema
read
cambia
apuntador
memoria
realiza
operaciones
disco
costos
intuitivos
incorrec-
tos
programadores
escribirán
programas
ineficientes
13.2.2
Paradigmas
establecido
objetivos
empezar
diseño
lugar
iniciar
pensar
forma
clientes
verán
sistema
cuestiones
importan-
tes
características
sistema
funcionen
presenten
co-
noce
comúnmente
coherencia
arquitectónica
aspecto
importante
distinguir
tipos
clientes
sistemas
operativos
usuarios
interactúan
programas
aplicaciones
programadores
escriben
siste-
operativos
clientes
tratan
GUI
segundos
tratan
interfaz
llamadas
sistema
intención
GUI
do-
mine
sistema
completo
Macintosh
diseño
empezar
intención
proporcionar
GUIs
UNIX
interfaz
llamadas
sistema
diseñar
esencia
GUI
diseño
ha-
cia
abajo
cuestiones
características
forma
usuario
interactuará
diseñar
sistema
producirla
ejemplo
mayoría
programas
muestran
iconos
pantalla
esperan
usuario
haga
clic
sugiere
modelo
controlado
eventos
GUI
probablemente
sistema
operati-
vo
pantalla
llena
ventanas
texto
modelo
procesos
lean
teclado
interfaz
llamadas
sistema
diseño
abajo
cuestiones
tipo
características
necesitan
programadores
general
realidad
necesitan
características
especiales
proporcionar
GUI
ejemplo
sistema
ventanas
UNIX
programa
realiza
llamadas
ready
writeen
te-
clado
ratón
pantalla
desarrolló
UNIX
requirieron
cam-
bios
sistema
operativo
funcionara
experiencia
validó
UNIX
completo
Paradigmas
interfaz
usuario
interfaz
nivel
GUI
interfaz
llamadas
sistema
aspecto
importante
te-
ner
paradigma
conoce
metáfora
proveer
for-
www.FreeLibros.mema
interfaz
GUIs
equipos
escritorio
utilizan
paradigma
WIMP
vimos
capítulo
paradigma
utiliza
apuntar
clic
apuntar
doble
clic
arras-
trar
modismos
interfaz
ofrecer
coherencia
arquitectónica
to-
do
sistema
requerimientos
adicionales
programas
barra
menús
ARCHIVO
EDICIÓN
entradas
ele-
mentos
menú
reconocidos
forma
usuarios
conocen
programa
apren-
der
rapidez
interfaz
usuario
WIMP
única
computadoras
bolsillo
utilizan
interfaz
escritura
manual
estilizada
dispositivos
multimedia
dedi-
cados
utilizar
interfaz
tipo
VCR
entrada
voz
paradig-
ma
completamente
distinto
importante
paradigma
seleccione
paradigma
invalida
unifica
interfaz
usuario
importar
paradigma
seleccionado
importante
programas
aplica-
ción
utilicen
consecuencia
diseñadores
sistemas
necesitan
proveer
bibliotecas
kits
herramientas
desarrolladores
aplicaciones
tengan
acceso
procedimientos
producen
apariencia
visual
uniforme
diseño
interfaz
usuario
importan-
tema
libro
regresaremos
tema
interfaz
sis-
tema
operativo
Paradigmas
ejecución
coherencia
arquitectónica
importante
nivel
usuario
importancia
ni-
vel
interfaz
llamadas
sistema
frecuencia
útil
diferenciar
paradig-
ma
ejecución
datos
analizaremos
empezando
paradigmas
ejecución
extenso
algorítmicos
controlados
eventos
paradigma
algorítmico
basa
idea
inicia
programa
función
conoce
antemano
obtiene
parámetros
función
compilar
pro-
grama
nómina
volar
avión
San
Francisco
lógica
básica
fija
código
programa
realiza
llamadas
sistema
obtener
datos
entrada
usua-
rio
servicios
sistema
operativo
etc.
método
describe
figura
13-1(a
paradigma
ejecución
paradigma
controlado
eventos
figura
13-1(b
programa
realiza
tipo
inicialización
ejemplo
mostrar
pantalla
des-
pués
esperar
sistema
operativo
indique
evento
evento
pulsación
tecla
movimiento
ratón
diseño
útil
programas
in-
teractivos
formas
cosas
engendra
estilo
programación
paradigma
algorítmico
algoritmos
centrales
sistema
operativo
pro-
veedor
servicios
paradigma
controlado
eventos
sistema
operativo
propor-
ciona
servicios
papel
ve
eclipsado
papel
coordinador
actividades
usuario
generador
eventos
consumidos
procesos
966
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.2
DISEÑO
INTERFACES
967
main
main
int
mess_t
msj
init
init
hacer_algo
while
obtener_mensaje(&msj
read
switch
msj.type
hacer_algo_mas
case
write
case
seguir_funcionando
case
exit(0
Figura
13-1
Código
algorítmico
Código
controlado
eventos
Paradigmas
datos
paradigma
ejecución
único
exporta
sistema
operativo
paradigma
datos
importante
pregunta
clave
forma
presentan
estructuras
dispositivos
sistema
programador
sistemas
procesamiento
lotes
FORTRAN
modelaba
cinta
magnética
secuencial
pilas
tarjetas
introducían
consideraban
cintas
entrada
pilas
tarjetas
iban
perforar
consideraban
cintas
salida
salida
impresora
consideraba
cin-
ta
salida
archivos
disco
consideraban
cintas
acceso
alea-
torio
archivo
rebobinar
cinta
correspondiente
leerla
asignación
utilizaban
tarjetas
control
trabajos
MONTAR(CINTA08
CARRETE781
EJECUTAR(ENTRADA
MISDATOS
SALIDA
PERFORADORA
CINTA08
tarjeta
indicaba
operador
obtuviera
carrete
781
estante
cintas
mon-
tara
unidad
cinta
indicaba
sistema
operativo
ejecutara
programa
FORTRAN
acababa
compilar
asignara
ENTRADA
lector
tarjetas
cinta
lógica
archivo
disco
MISDATOSa
cinta
lógica
impresora
llamada
SALIDA
cin-
ta
lógica
perforadora
tarjetas
llamada
PERFORADORA
cinta
lógica
unidad
cinta
física
cinta
lógica
FORTRAN
sintaxis
leer
escribir
cintas
lógicas
leer
cinta
lógica
programa
obtenía
entrada
tarjeta
escribir
cinta
lógica
salida
aparecería
pos-
teriormente
impresora
leer
cinta
lógica
podía
leer
carrete
781
forma
sucesiva
idea
cinta
paradigma
integrar
lec-
tor
tarjetas
impresora
perforadora
archivos
disco
cintas
ejemplo
só-
cinta
lógica
cinta
física
resto
archivos
disco
ordinarios
cola
paradigma
primitivo
inicio
dirección
correcta
www
FreeLibros.me968
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
UNIX
utiliza
forma
avanzada
modelo
archivo
paradigma
dispositivos
consideran
archivos
abrir
manipular
archivos
ordinarios
instrucciones
fd1
open(“archivo1
O_RDWR
fd2
open(“/dev
tty
O_RDWR
abren
archivo
disco
terminal
usuario
teclado
pantalla
instruccio-
nes
subsecuentes
utilizar
fd1
fd2
leer
escribir
respectivamente
diferencia
acceder
archivo
terminal
permite
búsquedas
UNIX
unifica
archivos
dispositivos
permite
acceder
procesos
archivos
tuberías
admiten
archivos
asigna-
proceso
obtener
memoria
virtual
archivo
versiones
UNIX
aceptan
sistema
archivos
/proc
instrucción
fd3
open(“/proc/501
O_RDWR
permite
proceso
tratar
acceder
memoria
proceso
501
lectura
escritura
descriptor
archivo
fd3
útil
depurador
ejemplo
Windows
Vista
allá
parezca
objeto
proce-
so
adquiere
manejador
válido
archivo
proceso
semáforo
bandeja
correo
ob-
jeto
kernel
operaciones
paradigma
general
UNIX
general
FORTRAN
paradigmas
unificadores
ocurren
contextos
vale
pena
mencionar
Web
paradigma
Web
ciberespacio
lleno
documen-
tos
URL
escribir
URL
clic
entrada
respalda-
URL
usuario
recibe
documento
realidad
documentos
documentos
genera
programa
secuencia
comandos
shell
llega
petición
ejemplo
usuario
pide
tienda
línea
lista
CDs
artista
específico
programa
genera
documento
instante
existía
petición
visto
casos
cinta
archivo
objeto
documento
casos
intención
unificar
datos
dispositivos
recursos
facilitar
manejo
sistema
operativo
paradigma
datos
unificador
tipo
13.2.3
interfaz
llamadas
sistema
cree
Corbató
mecanismo
mínimo
sistema
operativo
pro-
porcionar
menor
cantidad
llamadas
sistema
funcionar
simple
simple
paradigma
datos
unificador
desempe-
ñar
papel
importante
ayudar
ejemplo
archivos
procesos
dispositivos
ven
archivos
objetos
leer
www
FreeLibros.meSECCIÓN
13.2
DISEÑO
INTERFACES
969
llamada
sistema
read
caso
contrario
necesario
llamadas
separadas
pa-
ra
read_file
read_procy
read_tty
casos
parecer
llamadas
sistema
necesitan
variantes
menu-
do
llamada
sistema
maneje
caso
general
distintos
procedi-
mientos
biblioteca
ocultar
programadores
ejemplo
UNIX
llamada
sistema
superponer
espacio
direcciones
virtuales
proceso
exec
lla-
mada
general
exec(nombre
argp
envp
carga
archivo
ejecutable
nombre
proporciona
argumentos
apunta
argp
varia-
bles
entorno
apunta
envp
conveniente
listar
argumentos
forma
explícita
biblioteca
contenga
procedimientos
llamen
exec(nombre
arg0
arg1
argn
execle(nombre
arg0
arg1
argn
envp
procedimientos
argumentos
arreglo
llamar
execpara
haga
trabajo
arreglo
conjunta
mundos
llamada
sistema
directa
mantiene
sistema
operativo
simple
programador
obtiene
con-
veniencia
formas
llamar
exec
llamada
manejar
casos
posibles
salirse
con-
trol
fácilmente
UNIX
crear
proceso
requieren
llamadas
forkseguida
exec
parámetros
contraste
llamada
API
Win32
crear
proceso
CreateProcess
10
parámetros
apuntador
es-
tructura
18
parámetros
adicionales
tiempo
alguien
debió
preguntado
ocurriría
terrible
omitir
parámetros
respuesta
sincera
hubiera
casos
programadores
tendrían
trabajo
lograr
efecto
específico
resultado
neto
hubie-
ra
sistema
operativo
simple
pequeño
confiable
persona
proposición
10
18
parámetros
respondido
usuarios
gustan
características
réplica
gustan
sistemas
utilizan
me-
moria
fallas
sacrificios
obtener
funcionalidad
costa
memo-
ria
visibles
asignar
precio
conoce
precio
memoria
difícil
estimar
fallas
adicionales
año
agregará
carac-
terística
usuarios
realizarían
decisión
conocieran
precio
oculto
efecto
resumir
ley
software
Tanenbaum
agregar
código
agregan
errores
agregar
características
agrega
código
consecuentemente
errores
progra-
madores
creen
agregar
características
agregan
errores
computadoras
creen
hada
dientes
anda
cuidándolos
www
FreeLibros.me970
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
simplicidad
única
cuestión
considerar
diseñar
llamadas
siste-
ma
consideración
importante
eslogan
Lampson
1984
ocultes
hardware
forma
extremo
eficiente
exponerse
progra-
madores
simple
enterrarse
abstracción
propósito
abstracciones
ocultar
propiedades
indeseables
deseables
ejemplo
suponga
hardware
forma
especial
desplazar
mapas
bits
extensos
pantalla
RAM
video
alta
velocidad
justificar
llamada
sistema
pa-
ra
acceder
mecanismo
proporcionar
formas
leer
RAM
video
colo-
carla
memoria
principal
volver
escribir
llamada
desplazaría
bits
llamada
sistema
rápida
usuarios
crear
interfaces
convenientes
lenta
utilizará
cuestión
diseño
comparación
llamadas
orientadas
conexión
orientadas
conexión
llamadas
sistema
estándar
UNIX
Win32
leer
archivo
orientadas
conexión
utilizar
teléfono
abrir
archivo
leer-
cerrarlo
protocolos
acceso
archivos
orientados
cone-
xión
ejemplo
utilizar
FTP
usuario
iniciar
sesión
máquina
remota
leer
archivos
cerrar
sesión
protocolos
acceso
archivos
remotos
orientados
conexión
ejemplo
protocolo
Web
HTTP
conexión
leer
página
Web
pedirla
requiere
configurar
antemano
requiere
conexión
TCP
nivel
protocolo
protocolo
HTTP
acceder
Web
orientada
conexión
sacrificio
mecanismo
orientado
conexión
orientado
conexión
trabajo
adicional
requiere
establecer
mecanismo
ejemplo
abrir
archivo
ventaja
llamadas
subsiguientes
archivos
máquina
costo
configuración
forma
estándar
abrir
sistemas
archivos
remotos
pue-
ambas
formas
cuestión
relacionada
interfaz
llamadas
sistema
visibilidad
lista
llamadas
sistema
requeridas
POSIX
fácil
encontrar
sistemas
UNIX
ad-
miten
pequeño
número
llamadas
adicionales
lista
completa
pú-
blica
contrario
Microsoft
pública
lista
llamadas
sistema
Windows
Vista
públicas
API
Win32
APIs
contienen
gran-
des
cantidades
llamadas
bibliotecas
10,000
pequeño
número
verdaderas
llamadas
sistema
argumento
públicas
llamadas
sistema
permite
programadores
económico
funciones
ejecutan
espa-
cio
usuario
costoso
llamadas
kernel
argumento
hacerlas
públicas
proporcionan
implementadores
flexibilidad
cambiar
llamadas
sistema
subya-
centes
actuales
mejorarlas
quebrantar
programas
usuario
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
971
13.3
IMPLEMENTACIÓN
dejar
interfaces
usuario
llamadas
sistema
analizar
for-
ma
implementar
sistema
operativo
siguientes
secciones
examinaremos
cuestiones
conceptuales
generales
relacionadas
estrategias
implementación
analizaremos
técnicas
nivel
utilidad
13.3.1
Estructura
sistema
decisión
tomar
implementadores
estructura
siste-
ma
sección
1.7
examinamos
principales
posibilidades
repasaremos
reali-
dad
diseño
monolítico
estructura
idea
pequeño
sistema
operativo
ejemplo
refrigerador
caso
discutible
Sistemas
capas
método
razonable
establecido
años
sistema
capas
sistema
THE
Dijkstra
figura
1-25
sistema
operativo
capas
UNIX
Win-
dows
Vista
estructura
capas
forma
describir
sis-
tema
principio
real
lineamiento
utilizado
construir
sistema
sistema
diseñadores
optan
ruta
cui-
elegir
capas
definir
funcionalidad
capa
inferior
tra-
tar
ocultar
peores
idiosincrasias
hardware
HAL
figura
11-7
capa
deba
manejar
interrupciones
cambio
contexto
MMU
enci-
ma
capa
código
independiente
máquina
ca-
pa
distintos
diseñadores
gustos
orientaciones
posibilidad
capa
administre
hilos
incluyendo
planificación
sincronización
muestra
figura
13-2
idea
capa
debemos
hilos
apropiados
planifiquen
forma
normal
sincronicen
mecanismo
estándar
ejem-
plo
mutexes
capa
podríamos
encontrar
drivers
dispositivos
ejecu-
ta
hilo
separado
contador
programa
registros
etc.
posiblemen-
necesariamente
espacio
direcciones
kernel
diseño
simplificar
considerable
estructura
ocurre
interrup-
ción
convertir
llamada
unlocken
mutex
llamada
planificador
programar
potencialmente
hilo
recién
listo
bloquea-
do
mutex
MINIX
utiliza
método
UNIX
Linux
Windows
Vista
manejado-
res
interrupciones
ejecutan
área
control
ejecutarse
hilos
apropiados
planificar
suspender
etc.
complejidad
sistema
operativo
vale
pena
considerar
técnica
tratar
encapsular
www
FreeLibros.me972
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
capa
podríamos
esperar
encontrar
memoria
virtual
sistemas
ar-
chivos
manejadores
llamadas
sistema
memoria
virtual
nivel
ba-
jo
sistemas
archivos
caché
bloques
paginar
memoria
administrador
memoria
virtual
determinar
dinámica
forma
dividir
memoria
real
páginas
usuario
kernel
incluyendo
ca-
ché
Windows
Vista
funciona
Exokernels
sistema
niveles
partidarios
diseñadores
sistemas
campo
precisamente
visión
opuesta
Engler
colaboradores
1995
visión
basa
argumento
punta
cabo
end-to-end
Saltzer
colaboradores
1984
concep-
to
programa
usuario
desperdicio
realizar-
nivel
inferior
Considere
aplicación
principio
acceso
archivos
remotos
sistema
preocupa
datos
corrompan
trayecto
arreglos
realice
suma
comprobación
archivo
momento
escribirlo
suma
comprobación
almacenar
archivo
transferir
archivo
red
disco
origen
proceso
destino
transfiere
suma
comprobación
vuelve
calcular
extremo
receptor
valores
coinciden
descarta
archivo
vuelve
transferir
comprobación
precisa
utilizar
protocolo
red
confiable
atrapa
errores
disco
memoria
software
enrutadores
errores
transmisión
bits
argumento
punta
cabo
necesario
utilizar
protocolo
red
confiable
punto
proceso
receptor
suficiente
informa-
ción
verificar
archivo
correcto
única
razón
utilizar
protocolo
red
confiable
método
eficiencia
atrapar
reparar
errores
trans-
misión
anticipada
Manejo
interrupciones
cambio
contexto
MMU
Ocultar
hardware
nivel
Memoria
virtual
Hilos
planificación
hilos
sincronización
hilos
Driver
Driver
Sistema
archivos
Sistema
archivos
m6
Manejador
llamadas
sistema7
Nivel
Driver
Figura
13-2
diseño
sistema
operativo
niveles
moderno
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
973
argumento
punta
cabo
extender
sistema
operativo
Sostiene
sistema
operativo
programa
usuario
ejemplo
sistema
archivos
dejar
usuario
lea
escriba
porción
disco
puro
forma
protegida
mayoría
usuarios
gusta
archivos
argumento
punta
cabo
sistema
archivos
procedimiento
biblioteca
vinculado
programa
necesite
utilizar
archivos
Es-
método
permite
distintos
programas
tengan
sistemas
archivos
línea
ra-
zonamiento
indica
sistema
operativo
asignar
recursos
forma
segura
ejemplo
CPU
discos
usuarios
compiten
Exokernel
sistema
operativo
construido
argumento
punta
cabo
Engler
colaborado-
res
1995
Sistemas
cliente-servidor
basados
microkernel
compromiso
sistema
operativo
haga
haga
haga
diseño
conlleva
microkernel
sistema
operativo
ejecuta
forma
procesos
servidor
nivel
usuario
ilustra
figura
13-3
diseño
modular
flexible
flexibilidad
driver
dispositivo
tam-
bién
ejecute
proceso
usuario
completamente
protegido
kernel
drivers
drivers
dispositivos
ejecuten
kernel
aumenta
modularidad
Proceso
cliente
Proceso
cliente
Proceso
cliente
Servidor
procesos
Servidor
archivos
Servidor
memoria
Microkernel
usuario
kernel
cliente
obtiene
servicio
enviar
mensajes
procesos
servidor
Figura
13-3
Computación
cliente-servidor
basada
microkernel
drivers
dispositivos
kernel
acceder
directamente
regis-
tros
dispositivos
hardware
necesita
mecanismo
pro-
veer
funcionalidad
hardware
permite
proceso
driver
recibir
acceso
dispositivos
necesita
ejemplo
asignación
memoria
proceso
driver
asignara
memoria
página
dispositivo
nin-
guna
página
dispositivo
espacio
puertos
proteger
forma
parcial
disponible
porción
correcta
driver
disponible
asistencia
hardware
idea
formas
funcionar
necesita
llamada
sistema
disponible
procesos
dri-
dispositivo
suministre
lista
pares
puerto
valor
kernel
prime-
ro
comprobar
proceso
posee
puertos
lista
copia
valores
www
FreeLibros.me974
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
correspondientes
puertos
iniciar
dispositivo
utilizar
llamada
si-
milar
leer
puertos
forma
protegida
método
evita
drivers
dispositivos
examinen
dañen
estructuras
datos
kernel
disponible
conjunto
análogo
llamadas
permitir
procesos
driver
leyeran
escribieran
tablas
kernel
pe-
ro
controlada
aprobación
kernel
principal
problema
método
microkernels
general
disminución
rendimiento
provocan
cambios
adicionales
contexto
tra-
microkernels
años
CPUs
lentas
aplicaciones
utilizan
CPU
tolerar
pequeña
pérdida
rendimiento
ejecuta
procesador
palabras
navegador
Web
CPU
esté
inactiva
95%
tiempo
sistema
ope-
rativo
basado
microkernel
convirtiera
sistema
confiable
GHz
sistema
confia-
ble
2.5
GHz
probablemente
usuarios
quejarían
mayoría
felices
años
obtuvieron
computadora
estupenda
velocidad
GHz
Vale
pena
observar
microkernels
populares
escritorio
utili-
zan
teléfonos
celulares
PDAs
sistemas
industriales
sistemas
embebidos
sistemas
militares
alta
confiabilidad
absoluto
esencial
Sistemas
extensibles
sistemas
cliente-servidor
descritos
idea
eliminar
kernel
método
opuesto
colocar
módulos
kernel
forma
prote-
gida
palabra
clave
protegida
sección
9.5.6
estudiamos
me-
canismos
protección
principio
importar
applets
Internet
aplicar
forma
insertar
código
externo
kernel
importantes
cajas
arena
firma
código
interpretación
realidad
práctica
código
kernel
sistema
extensible
forma
estructurar
sistema
opera-
tivo
empezar
sistema
mínimo
consista
meca-
nismo
protección
agregar
módulos
protegidos
kernel
obtenga
funcionalidad
deseada
crear
sistema
mínimo
aplicación
tie-
ne
mano
caso
sistema
operativo
optimizar
aplicación
incluir
partes
requiere
Paramecium
ejemplo
sistema
Doorn
2001
Hilos
kernel
cuestión
relevante
importar
modelo
estructuración
seleccionado
hi-
sistema
conveniente
permitir
existan
hilos
kernel
separados
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
975
proceso
usuario
hilos
ejecutar
plano
escribir
páginas
sucias
disco
intercambiar
procesos
memoria
principal
disco
etc.
mis-
mo
kernel
estructurar
completo
dichos
hilos
usua-
rio
realice
llamada
sistema
hilo
usuario
ejecute
kernel
bloquee
pase
control
hilo
kernel
encargará
trabajo
hilos
kernel
ejecutan
plano
mayoría
sistemas
operativos
inician
procesos
tipo
demonios
plano
forman
par-
sistema
operativo
realzan
actividades
tipo
sistema
obtener
enviar
correo
electrónico
servicio
tipos
peticiones
usuarios
remotos
FTP
páginas
Web
13.3.2
Comparación
mecanismo
directiva
principio
ayuda
coherencia
arquitectónica
mantener
pequeño
estructurado
separar
mecanismo
directiva
colocar
mecanismo
sistema
operativo
dejar
directiva
procesos
usuario
sistema
quedar
modifica-
ción
necesidad
cambiar
directiva
módulo
directiva
tie-
ne
mantener
kernel
aislado
mecanismo
cambios
módulo
directiva
afecten
módulo
mecanismo
división
directiva
mecanismo
clara
considerar
ejem-
plos
reales
ejemplo
empresa
departamento
nóminas
cargo
pagar
salarios
empleados
computadoras
softwa-
re
cheques
bancarios
acuerdos
bancos
mecanismo
pagos
sa-
larios
directiva
determinar
paga
completamente
separada
administración
decide
departamento
nóminas
indica
ejemplo
consideremos
restaurante
mecanismo
servir
comidas
incluyendo
mesas
platos
meseros
cocina
llena
equipo
acuerdos
compa-
ñías
tarjetas
crédito
etc.
chef
establece
directiva
menú
chef
decide
servir
filetes
tofú
mecanismo
existente
manejar
directiva
consideremos
ejemplos
sistema
operativo
veremos
programa-
ción
hilos
kernel
planificador
prioridades
niveles
prioridad
mecanismo
arreglo
indexado
nivel
prioridad
caso
UNIX
Windows
Vista
entrada
inicial
lista
hilos
listos
nivel
prioridad
plani-
ficador
busca
arreglo
prioridad
alta
prioridad
baja
selecciona
hilo
directiva
establecer
prioridades
ejemplo
sistema
distintas
clases
usuarios
prioridad
distinta
permitir
procesos
usuario
establezcan
prioridad
relativa
hilos
prioridades
incre-
mentar
completar
operación
reducir
utilizar
quantum
directivas
seguir
idea
separación
en-
tre
establecer
directiva
llevarla
cabo
www
FreeLibros.meUn
ejemplo
paginación
mecanismo
implica
administración
MMU
listas
páginas
ocupadas
páginas
libres
código
transportar
páginas
disco
directiva
decidir
ocurre
fallo
página
lo-
cal
global
basado
LRU
PEPS
cosa
algoritmo
separado
completo
mecánica
administrar
realmente
páginas
tercer
ejemplo
permitir
cargar
módulos
kernel
mecanismo
forma
insertan
vinculan
llamadas
llamadas
directiva
determinar
cargar
módulo
kernel
módulos
cargar
superusuario
cargar
módulos
usuario
car-
gar
módulo
autoridad
apropiada
firmado
forma
digital
13.3.3
Ortogonalidad
diseño
sistemas
consiste
conceptos
separados
combinar
independiente
ejemplo
tipos
datos
primitivos
incluyen
enteros
caracteres
números
punto
flotante
mecanismos
combinar
tipos
datos
incluyen-
do
arreglos
estructuras
uniones
ideas
combinan
independiente
permi-
tir
arreglos
enteros
arreglos
caracteres
estructuras
miembros
uniones
números
puntos
flotantes
etc.
definido
tipo
datos
arreglo
enteros
utilizar
tipo
datos
primitivo
ejem-
plo
miembro
estructura
unión
habilidad
combinar
conceptos
sepa-
rados
independiente
conoce
ortogonalidad
consecuencia
directa
principios
simplicidad
integridad
concepto
ortogonalidad
ocurre
formas
sistemas
operativos
ejemplo
llamada
sistema
clonede
Linux
crea
hilo
llamada
mapa
bits
parámetro
permite
compartir
copiar
individual
espacio
di-
recciones
directorio
trabajo
descriptores
archivos
señales
copia
tene-
mos
proceso
fork
copia
crea
hilo
proceso
actual
crear
formas
intermedias
compartir
posibles
sis-
temas
UNIX
tradicionales
separar
diversas
características
hacerlas
ortogonales
grado
control
detallado
ortogonalidad
separación
concepto
proceso
concepto
hilo
Windows
Vista
proceso
contenedor
recursos
hilo
entidad
planificable
proceso
recibe
manejador
proceso
importa
cuán-
tos
hilos
hilo
planifica
importa
proceso
pertenece
conceptos
ortogonales
ejemplo
ortogonalidad
proviene
UNIX
sistema
creación
procesos
realiza
pasos
forky
exec
acciones
crear
espacio
direcciones
car-
garlo
imagen
memoria
separadas
cosas
ambas
manipulación
descriptores
archivos
Windows
Vista
pasos
pue-
den
separar
conceptos
crear
espacio
direcciones
llenarlo
ortogona-
secuencia
Linux
cloney
execes
ortogonal
disponibles
976
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
977
bloques
construcción
detallados
regla
general
pequeño
número
elementos
ortogonales
combinar
formas
obtiene
sistema
pequeño
simple
elegante
13.3.4
Nomenclatura
mayoría
estructuras
datos
utiliza
sistema
operativo
tipo
nom-
bre
identificador
referencia
ejemplos
obvios
nombres
inicio
sesión
nombres
archivos
nombres
dispositivos
IDs
procesos
etc.
forma
construyen
administran
nombres
cuestión
importante
dise-
ño
implementación
sistemas
nombres
diseñaron
seres
humanos
cadenas
caracteres
ASCII
Unicode
general
jerárquicos
rutas
directorio
/usr
ast
libros
mos2
cap-
12
duda
jerárquicas
indica
serie
directorios
búsqueda
empezando
directorio
raíz
URLs
jerárquicos
ejemplo
www.cs.vu.nl/~ast/
indica
máquina
específica
www
departamento
específico
cs
universidad
específica
vu
país
específico
nl
barra
diagonal
indica
archivo
específico
máquina
designada
caso
convención
www
in-
dex.html
directorio
inicio
ast
Observe
URLs
direcciones
DNS
gene-
ral
incluyendo
direcciones
correo
electrónico
inversos
empiezan
inferior
árbol
diferencia
nombres
archivos
empiezan
superior
árbol
abajo
forma
árbol
escribe
superior
empieza
izquierdo
derecha
empieza
derecho
izquierda
nomenclatura
cabo
niveles
externo
interno
ejemplo
archivos
nombre
cadena
caracteres
personas
utilicen
Ade-
nombre
interno
sistema
utiliza
UNIX
nombre
archivo
número
nodo-i
nombre
ASCII
utiliza
forma
interna
siquiera
único
archivo
vínculos
nombre
interno
análogo
Win-
dows
Vista
índice
archivo
MFT
trabajo
directorio
proveer
asignación
en-
tre
nombre
externo
nombre
interno
muestra
figura
13-4
casos
ejemplo
nombre
archivo
mostrado
nombre
interno
entero
signo
sirve
índice
tabla
kernel
ejemplos
nombres
índice
tabla
descriptores
archivos
UNIX
manejadores
objetos
Windows
Vista
Observe
representación
externa
exclusivo
siste-
ma
procesos
ejecución
general
conveniente
utilizar
índices
tablas
nom-
bres
transitorios
pierden
reinicia
sistema
sistemas
operativos
aceptan
espacios
nombres
externos
in-
ternos
ejemplo
capítulo
11
analizamos
espacios
nombres
externos
Windows
Vista
admite
nombres
archivos
nombres
objetos
nombres
registro
espacio
nombres
Active
Directory
analizamos
innumerables
espacios
nombres
internos
utilizan
enteros
signo
ejemplo
manejadores
objetos
www.FreeLibros.meentradas
MFT
nombres
espacios
nombres
externos
cadenas
Uni-
code
busca
nombre
archivo
registro
forma
utilizar
índice
MFT
tabla
objetos
diseño
espacios
nombres
necesitan
sintaxis
nombres
distinguir
nombres
absolutos
relativos
etcétera
13.3.5
Tiempo
vinculación
visto
sistemas
operativos
utilizan
tipos
nombres
referirse
ob-
jetos
asignación
nombre
objeto
fija
últi-
mo
caso
importante
momento
vincula
nombre
objeto
general
vinculación
anticipada
simple
flexible
vinculación
postergadaes
complicada
flexible
aclarar
concepto
tiempo
vinculación
veamos
ejemplos
reales
ejem-
plo
vinculación
anticipada
práctica
colegas
permitir
padres
inscriban
bebé
nacer
paguen
antemano
colegiatura
actual
estudiante
apa-
rece
18
años
colegiatura
pagada
completo
importar
alto
pre-
cio
momento
manufactura
pedir
piezas
adelantado
mantener
inventario
vincula-
ción
anticipada
contrario
manufactura
justo
tiempo
requiere
proveedores
pue-
suministrar
piezas
momento
requerir
aviso
adelantado
vinculación
postergada
lenguajes
programación
admiten
tiempos
vinculación
va-
riables
variables
globales
vinculan
dirección
virtual
específica
compila-
dor
ejemplifica
vinculación
anticipada
variables
locales
procedimiento
978
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
Cap-12
Cap-11
Cap-10
Nombre
externo
/usr
ast
libros
mos2
Cap-12
Directorio
/usr
ast
libros
mos2
Tabla
nodos-i
38
114
Nombre
interno
Figura
13-4
directorios
utilizan
asignar
nombres
externos
nombres
internos
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
979
asigna
dirección
virtual
pila
invoca
procedimiento
vinculación
in-
termedia
variables
almacenan
montículo
asignan
malloc
new
Java
asignan
direcciones
virtuales
realmente
utilizan
tene-
mos
vinculación
postergada
frecuencia
sistemas
operativos
utilizan
vinculación
anticipada
mayoría
estructuras
datos
ocasiones
utilizan
vinculación
postergada
flexibilidad
asignación
memoria
ejemplo
sistemas
multiprogramación
máquinas
contaban
hardware
reasignación
direcciones
tenían
cargar
pro-
grama
dirección
memoria
reubicarlo
ejecutara
inter-
cambiaba
traer
vuelta
dirección
memoria
fallaría
contrario
memoria
virtual
paginada
forma
vinculación
postergada
dirección
física
actual
corresponde
dirección
virtual
dada
conoce
contacto
pági-
na
regresa
memoria
ejemplo
vinculación
postergada
colocación
ventanas
GUI
contrario
sistemas
gráficos
programador
especificar
coordenadas
absolutas
pantalla
imágenes
GUIs
modernas
software
utiliza
coordena-
das
relativas
origen
ventana
determina
ventana
coloca
pantalla
cambiar
13.3.6
Comparación
estructuras
estáticas
dinámicas
diseñadores
sistemas
operativos
ven
forzados
constantemente
elegir
estructu-
ras
datos
estáticas
dinámicas
estáticas
fáciles
entender
pro-
gramar
rápido
dinámicas
flexibles
ejemplo
obvio
tabla
procesos
sistemas
simplemente
asignaban
arreglo
fijo
estructuras
proceso
tabla
procesos
contenía
256
entradas
256
procesos
podían
existir
cual-
quier
instante
intento
crear
proceso
257
fracasaría
falta
espacio
tabla
tabla
archivos
abiertos
usuario
sistema
tablas
kernel
aplicaban
consideraciones
similares
estrategia
alternativa
crear
tabla
procesos
lista
vinculada
minitablas
principio
tabla
llena
asigna
reserva
almace-
namiento
global
vincula
forma
tabla
procesos
llenar
agote
memoria
kernel
código
buscar
tabla
vuelve
complicado
ejemplo
có-
digo
buscar
tabla
procesos
estática
PID
específico
pid
muestra
figura
13-5
simple
eficiente
lista
minitablas
vinculadas
requiere
trabajo
tablas
estáticas
mejores
memoria
tablas
pronosticar
suficiente
precisión
ejemplo
sistema
usuario
im-
probable
inicie
64
procesos
desastre
fracasa
intento
iniciar
proceso
65
alternativa
utilizar
tabla
tamaño
fijo
momento
llenarse
asigne
tabla
tamaño
fijo
ejemplo
doble
tamaño
entradas
actuales
copian
www
FreeLibros.me980
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
tabla
antigua
regresa
reserva
almacenamiento
libre
forma
ta-
bla
contigua
vinculada
desventaja
requiere
ad-
ministración
almacenamiento
dirección
tabla
variable
constante
pilas
kernel
aplica
cuestión
similar
hilo
cambia
kernel
ejecuta
hilo
kernel
necesita
pila
espacio
kernel
hilos
usuario
pila
inicialziar
avance
abajo
superior
espacio
direcciones
virtuales
especificar
tamaño
adelantado
hilos
kernel
tamaño
especificar
adelantado
pila
ocupa
es-
pacio
direcciones
virtuales
kernel
pilas
pregunta
espa-
cio
obtener
sacrificios
similares
tabla
procesos
sacrificio
estático-dinámico
programación
procesos
sistemas
es-
pecial
tiempo
real
programación
manea
estática
adelantado
ejemplo
aerolínea
hora
saldrán
vuelos
semanas
partida
similar
sistemas
multimedia
planificar
procesos
audio
video
adelantado
propósito
general
consideraciones
aplican
planificación
dinámica
cuestión
estática-dinámica
estructura
kernel
simple
kernel
crea
programa
binario
carga
memoria
ejecutarse
conse-
cuencia
diseño
agregar
dispositivo
requiere
volver
vincu-
lar
kernel
controlador
dispositivo
primeras
versiones
UNIX
funcionaban
satisfactorio
entorno
minicomputadoras
agregar
dispositi-
vos
ocurría
raras
actualidad
mayoría
sistemas
ope-
rativos
permiten
agregar
código
kernel
forma
dinámica
complejidad
adicional
implica
13.3.7
Comparación
implementación
arriba-abajo
implementación
abajo-arriba
diseñar
sistema
abajo
teoría
implementar
abajo
abajo
implementación
arriba-abajo
implementadores
empiezan
manejadores
llamadas
sistema
averiguan
mecanismos
estructuras
datos
necesitan
darles
soporte
procedimientos
escriben
proceso
continúa
has-
ta
llega
hardware
encontro
for
tabla_proc[0
tabla_proc[TAMANIO_TABLA_PROC
p++
if
p->pid_proc
pid
encontro
break
Figura
13-5
Código
buscar
tabla
procesos
PID
específico
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
981
problema
método
difícil
probar
disponibles
procedimientos
nivel
superior
razón
desarrolladores
encuentran
práctico
construir
sistema
abajo
método
escribir
có-
digo
oculte
hardware
nivel
esencia
HAL
figura
11-6
manejo
inte-
rrupciones
driver
reloj
requieren
anticipada
tratar
multiprogramación
planificador
simple
ejemplo
planificación
turno
rotatorio
punto
evaluar
sistema
ejecutar
procesos
forma
correcta
funciona
tiempo
empezar
cuidadosa
definición
diversas
tablas
estructuras
datos
necesarias
sistema
especial
requieren
administración
procesos
hilos
administra-
ción
memoria
sistema
archivos
esperar
principio
for-
ma
primitiva
leer
teclado
escribir
pantalla
evaluación
depuración
casos
estructuras
datos
nivel
proteger
permitir
acceso
me-
diante
procedimientos
acceso
específicos
efecto
programación
orientada
objetos
im-
portar
lenguaje
programación
medida
completan
niveles
inferiores
evaluar
detalle
forma
sistema
avanza
abajo
simi-
lar
forma
contratistas
construyen
edificios
oficina
altos
equipo
disponible
método
alternativo
diseño
deta-
llado
sistema
asignar
grupos
distintos
escribir
módulos
prueba
trabajo
aislamiento
piezas
listas
integran
eva-
lúan
problema
línea
ataque
funciona
principio
difícil
de-
terminar
aislada
fallando
módulos
grupo
malentendió
suponía
debía
módulo
equipos
método
utiliza
frecuencia
maximizar
cantidad
paralelismo
esfuerzo
programación
13.3.8
Técnicas
útiles
Acabamos
analizar
ideas
abstractas
diseño
implementación
sistemas
examinaremos
técnicas
concretas
útiles
implementación
sistemas
limitaciones
espacio
restringen
Ocultar
hardware
hardware
desagradable
ocultar
exponga
mayoría
hardware
diversos
detalles
ni-
vel
ocupar
nivel
tipo
HAL
tipo
muestra
figura
13-2
detalles
hardware
ocultar
merece
atención
anticipada
forma
lidiar
interrupciones
programación
desagradable
sistemas
operativos
lidiar
méto-
do
convertirlas
inmediato
ejemplo
interrupción
con-
www.FreeLibros.mevertir
hilo
emergente
instante
momento
tratando
hilos
inte-
rrupciones
método
convertir
interrupción
operación
unlocken
mutex
espera
driver
correspondiente
único
efecto
interrupción
hi-
cambie
listo
tercer
método
convertir
interrupción
mensaje
hilo
código
nivel
crea
mensaje
indica
provino
interrupción
pone
cola
lla-
ma
planificador
ejecutar
potencialmente
manejador
bloqueado
espera
mensaje
técnicas
tratar
convertir
interrupciones
operaciones
sincronización
hilos
fácil
administrar
interrupción
maneje
hilo
apropiado
contexto
apropiado
ejecu-
tar
manejador
contexto
arbitrario
ocurrió
eficiencia
nivel
profundo
sistema
operativo
efi-
ciencia
mayoría
sistemas
operativos
diseñados
ejecutarse
plataformas
hardware
plataformas
diferir
términos
chip
CPU
MMU
longitud
palabras
tamaño
RAM
características
enmascarar
fa-
cilidad
HAL
equivalente
conveniente
conjun-
to
archivos
código
fuente
utilicen
generar
versiones
caso
contrario
error
aparezca
deberá
corregir
códigos
fuente
pe-
ligro
distancien
resolver
diferencias
hardware
tamaño
RAM
sistema
ope-
rativo
determinar
valor
tiempo
inicio
mantenerlo
variable
ejemplo
asignadores
memoria
utilizar
variable
tamaño
RAM
determinar
tama-
ño
caché
bloques
tablas
páginas
etc.
definir
tamaño
ta-
blas
estáticas
tabla
procesos
base
memoria
disponible
diferencias
distintos
chips
CPU
resolver
binario
determine
tiempo
ejecución
CPU
ejecutando
tratar
problema
código
fuente
destinos
utilizar
compilación
condicional
archivos
código
fuente
definen
banderas
tiempo
compilación
dis-
tintas
configuraciones
utilizan
agrupar
código
dependiente
CPU
longitud
palabras
MMU
etc.
ejemplo
imagine
sistema
operativo
ejecutar
chips
Pentium
UltraSPARC
necesitan
distinto
código
inicialización
procedimien-
to
init
escribir
ilustra
figura
13-6(a
Dependiendo
valor
CPU
define
archivo
encabezado
config.h
realiza
tipo
inicialización
binario
actual
contiene
código
necesario
máquina
destino
pérdida
efi-
ciencia
forma
ejemplo
suponga
requiere
tipo
datos
Registro
32
bits
Pentium
64
bits
UltraSPARC
manejar
código
condicional
figura
13-6(b
suponiendo
compilador
produzca
enteros
32
bits
ente-
ros
largos
64
bits
realiza
definición
probablemente
archivo
en-
cabezado
incluirá
partes
programador
declarar
variables
tipo
Registro
longitud
correcta
982
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
983
include
config.h
include
config.h
init
if
LONG_PALABRA
32
typedef
int
Registro
if
CPU
PENTIUM
endif
inicialización
Pentium
endif
if
LONG_PALABRA
64
typedef
long
Registro
if
CPU
ULTRASPARC
endif
inicialización
UltraSPARC
endif
Registro
R0
R1
R2
R3
Figura
13-6
Compilación
condicional
dependiente
CPU
Compilación
condicional
dependiente
longitud
palabras
archivo
encabezado
config.h
definir
correcta
Pa-
ra
Pentium
define
CPU
PENTIUM
define
LONG_PALABRA
32
compilar
sistema
UltraSPARC
utilizaría
archivo
config.h
distinto
va-
lores
correctos
procesador
ejemplo
define
CPU
ULTRASPARC
define
LONG_PALABRA
64
lectores
pregunten
CPU
LONG_PALABRAse
manejan
distin-
tas
macros
Podríamos
agrupado
fácilmente
definición
Registro
prueba
CPU
establecer
valor
32
bits
Pentium
64
bits
UltraSPARC
embar-
go
conveniente
Considere
ocurre
portamos
sistema
procesador
In-
tel
Itanium
64
bits
Tendríamos
agregar
instrucción
condicional
figura
13-6(b
Itanium
incluir
línea
define
LONG_PALABRA
64
archivo
config.h
Itanium
ejemplo
ilustra
principio
ortogonalidad
vimos
elementos
de-
pendientes
CPU
compilar
condicional
base
macro
CPU
dependientes
longitud
palabras
utilizar
macro
LONG_PALABRA
Pa-
ra
parámetros
aplican
consideraciones
similares
www
FreeLibros.me984
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
Indirección
problema
ciencias
computacionales
re-
solver
nivel
indirección
exageración
duda
ver-
dad
considerar
ejemplos
sistemas
basados
Pentium
oprime
tecla
hardware
genera
interrupción
coloca
número
tecla
códi-
go
carácter
ASCII
registro
dispositivo
tecla
libera
genera
interrupción
número
clave
indirección
permite
sistema
operati-
vo
posibilidad
utilizar
número
tecla
indexar
tabla
obtener
carácter
AS-
CII
fácil
manejar
diversos
teclados
utilizan
mundo
distintos
países
obtener
información
oprime
libera
tecla
utilizar
te-
cla
tecla
mayúsculas
sistema
operativo
conoce
secuencia
exacta
oprimieron
liberaron
teclas
indirección
utiliza
salida
programas
escribir
caracteres
ASCII
pantalla
interpretan
índices
tabla
tipo
letra
salida
ac-
tual
entrada
tabla
contiene
mapa
bits
carácter
indirección
separar
caracteres
tipos
letras
ejemplo
indirección
números
dispositivo
mayores
UNIX
kernel
tabla
indexada
número
dispositivo
dispositivos
bloque
dispositivos
carácter
proceso
abre
archivo
especial
/dev
hd0
sistema
extrae
tipo
bloque
carácter
números
dispositivo
menor
nodo-
indexa
tabla
drivers
apropiada
encontrar
driver
indirección
facilita
reconfiguración
sistema
programas
tratan
nombres
dispositivos
simbólicos
nombres
reales
drivers
ejemplo
indirección
ocurre
sistemas
paso
mensajes
nombran
bandeja
correo
proceso
destino
mensaje
indirección
bandejas
correo
diferencia
nombrar
proceso
destino
obte-
ner
flexibilidad
considerable
ejemplo
secretaria
encargue
mensa-
jes
jefe
sentido
macros
tales
define
TAM_TABLA_PROC
256
forma
indirección
programador
escribir
código
sa-
ber
realmente
tabla
práctica
otorgar
nombres
simbólicos
constantes
/H110021
colocarlos
encabezados
comentarios
expliquen
función
Reutilización
frecuencia
reutilizar
código
contextos
ligeramente
distintos
idea
reduce
tamaño
archivo
binario
significa
código
depurar
ejemplo
suponga
utilizan
mapas
bits
blo-
www
FreeLibros.meSECCIÓN
13.3
IMPLEMENTACIÓN
985
ques
libres
disco
manejar
administración
bloques
disco
utilizar
procedimientos
alloc
free
administran
mapas
bits
mínimo
procedimientos
funcionar
disco
allá
procedimientos
funcionar
administrar
blo-
ques
memoria
bloques
caché
bloques
sistema
archivo
nodos-i
he-
cho
utilizar
asignar
desasignar
recursos
puedan
enumerar
forma
lineal
Reentrancia
reentrancia
refiere
habilidad
ejecutar
código
tiempo
multiprocesador
peligro
CPU
ejecuta
procedimiento
CPU
empiece
ejecutarlo
terminado
caso
hilos
distintas
CPUs
ejecutar
código
tiempo
proteger-
situación
mutexes
proteger
regiones
críticas
problema
uniprocesador
especial
mayoría
sistemas
operativos
ejecutan
interrupciones
habilitadas
contrario
perderían
mu-
chas
interrupciones
sistema
confiable
sistema
operativo
ocupado
eje-
cutando
procedimiento
completamente
ocurra
interrupción
manejador
interrupciones
llame
P.
estructuras
datos
estuvieran
inconsistente
momento
interrupción
manejador
verá
inconsisten-
fallará
ejemplo
obvio
ocurrir
planificador
Suponga
proceso
utilizó
quantum
sistema
operativo
desplazando
cola
mitad
manipulación
lista
ocurre
interrupción
proceso
cambie
listo
ejecuta
planificador
colas
inconsistente
probable
sistema
falle
consecuencia
uniprocesador
sistema
ope-
rativo
reentrante
estructuras
datos
críticas
estén
protegidas
mutexes
in-
terrupciones
deshabiliten
puedan
tolerar
Fuerza
bruta
fuerza
bruta
resolver
problema
acumulado
mala
reputación
años
frecuencia
método
conveniente
simplicidad
sistema
ope-
rativo
procedimientos
reciben
llamadas
operan
datos
vale
pena
optimizarlos
ejemplo
frecuencia
necesario
buscar
tablas
arreglos
sistema
algoritmo
fuerza
bruta
dejar
tabla
orden
realizan
entradas
buscar
forma
lineal
búsqueda
número
entradas
pequeño
ejemplo
menor
1000
ganancia
ordenar
tabla
generar
valores
hash
código
complicado
probable
contenga
errores
www
FreeLibros.meDesde
funciones
ruta
crítica
cambio
contexto
esfuerzo
rápidas
escribirlas
len-
guaje
ensamblador
recurso
partes
extensas
sistema
ruta
crítica
ejemplo
llamadas
sistema
invocan
raras
llamada
fork
requiere
mseg
llevarse
cabo
optimice
gana
0.1%
código
optimizado
errores
conveniente
cabo
optimización
Comprobar
errores
llamadas
sistema
llegar
fallas
variedad
razones
archivo
abrir
pertenece
alguien
creación
proceso
falla
tabla
procesos
llena
señal
enviar
proceso
destino
sistema
operativo
comprobar
detalle
errores
posibles
cabo
llamada
llamadas
sistema
requieren
adquisición
recursos
ranuras
tabla
procesos
ranuras
tabla
nodos-i
descriptores
archivos
consejo
general
ahorrar
problemas
comprobar
llamada
sistema
cabo
adquirir
recursos
significa
colocar
pruebas
principio
procedi-
miento
ejecuta
llamada
sistema
prueba
forma
if
condicion_error
return
CODIGO_ERROR
llamada
pasa
gama
pruebas
seguro
éxito
punto
adquirir
recursos
Intercalar
pruebas
adquisición
recursos
significa
falla
prueba
camino
recursos
adquiridos
punto
regresar
comete
error
devuelve
recurso
daños
reflejan
inmediato
ejemplo
entrada
tabla
procesos
esté
disponible
forma
permanente
du-
rante
periodo
error
activar
momento
mayoría
entradas
tabla
procesos
estén
disponibles
produ-
cirá
fallo
sistema
forma
extremo
impredecible
difícil
depurar
sistemas
sufren
problema
forma
fugas
memoria
general
programa
llama
malloc
asignar
espacio
olvida
llamar
free
liberar-
forma
memoria
desapareciendo
forma
gradual
agota
reinicia
sistema
Engler
colaboradores
2000
propuesto
forma
interesante
comprobar
errores
tiempo
compilación
observaron
programador
conoce
in-
variantes
compilador
conoce
ejemplo
bloquea
mutex
rutas
inician
bloqueo
contener
desbloqueo
bloqueos
mis-
mo
mutex
ideado
forma
programador
indique
compilador
instruya
compruebe
rutas
tiempo
compilación
caso
viola-
ciones
invariante
programador
especificar
memoria
asignada
de-
be
liberar
rutas
condiciones
986
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.4
RENDIMIENTO
987
13.4
RENDIMIENTO
igualdad
condiciones
sistema
operativo
rápido
lento
sistema
operativo
rápido
confiable
lento
confiable
optimizaciones
complejas
producen
errores
importante
utilizarlas
moderación
lugares
rendimiento
crítico
optimizaciones
valen
esfuerzo
siguientes
secciones
analizaremos
técnicas
generales
utili-
zar
mejorar
rendimiento
lugares
requiere
13.4.1
lentos
sistemas
operativos
hablar
técnicas
optimización
vale
pena
recalcar
lentitud
sis-
temas
operativos
auto-infligida
ejemplo
sistemas
operativos
antiguos
co-
mo
MS-DOS
UNIX
versión
iniciaban
segundos
sistemas
UNIX
Windows
Vista
modernos
requerir
minutos
iniciarse
ejecutan
hardware
1000
rápido
razón
cosas
de-
seen
caso
cuestión
tecnología
plug
and
play
facilita
instalación
dispositivo
hardware
precio
pagar
inicio
sistema
ope-
rativo
inspeccionar
hardware
exploración
bus
requiere
tiempo
método
alternativo
opinión
autor
desechar
completo
tec-
nología
plug-and-play
pantalla
icono
llamado
Instalar
hardware
insta-
lar
dispositivo
hardware
usuario
haría
clic
icono
empezar
exploración
bus
inicio
sistema
diseñadores
siste-
actuales
opción
rechazaron
básicamente
supo-
nían
usuarios
estúpidos
forma
correcta
definieron
amable
ejemplo
deseo
sistema
amigable
usuario
prueba
idiotas
depen-
diendo
punto
vista
lector
reduce
velocidad
tiempo
diseñadores
mejorar
sistema
selectivos
agregar
características
pregunta
usua-
rios
gusta
Vale
pena
inevitable
sacrificio
tamaño
código
veloci-
dad
complejidad
confiabilidad
ventajas
superan
concisa
desventajas
incluir
programadores
tendencia
suponer
tamaño
códi-
go
conteo
errores
velocidad
infinita
experiencia
muestra
idea
optimista
factor
participa
rendimiento
marketing
productos
versión
llega
mercado
hayan
incluido
características
actual-
mente
útiles
mayoría
personas
necesitan
producto
pa-
ra
continuar
ventas
fabricantes
continúan
produciendo
flujo
continuo
versiones
características
puedan
vender
actualizaciones
clientes
exis-
www.FreeLibros.metentes
Agregar
características
ayudar
ventas
raras
ayu-
rendimiento
13.4.2
optimizar
regla
general
versión
sistema
simple
únicas
opti-
mizaciones
cosas
duda
indiquen
problema
inevitable
caché
blo-
ques
sistema
archivos
ejemplo
sistema
esté
funcionamiento
mediciones
cuidadosas
realmente
tiempo
base
es-
tas
cifras
optimizaciones
útiles
historia
optimización
daño
beneficio
estudiantes
autor
cuyo
nombre
divulgaremos
escribió
programa
mkfs
MINIX
Es-
programa
establece
sistema
archivos
disco
recién
formateado
estudiante
invirtió
meses
optimizarlo
incluyendo
integración
caché
dis-
co
entregó
funcionó
requirieron
meses
adicionales
depuración
general
programa
ejecuta
disco
duro
vida
computadora
cuan-
do
instala
sistema
ejecuta
disco
flexible
formatea
ejecución
tarda
segundos
versión
optimizar
hubiera
tardado
minuto
recursos
invertir
tiempo
optimizar
programa
utiliza
frecuencia
eslogan
aplicación
considerable
optimización
rendimiento
suficiente
rendimiento
logrado
nivel
razonable
valga
pena
esfuerzo
complejidad
requeridos
exprimir
porcentaje
algoritmo
planificación
razonablemente
justo
mantiene
ocupada
CPU
90%
tiempo
trabajo
probable
idear
algoritmo
complejo
5%
rendimiento
mala
idea
similar
tasa
paginación
baja
pa-
ra
convierta
cuello
botella
general
vale
pena
esforzarse
obtener
rendimiento
óptimo
importante
evitar
desastre
obtener
ren-
dimiento
óptimo
especial
óptimo
carga
óptimo
13.4.3
Concesiones
espacio
tiempo
método
general
mejorar
rendimiento
sacrificar
tiempo
obtener
espacio
ciencias
computacionales
frecuencia
elegir
algoritmo
utiliza
memoria
lento
algoritmo
utiliza
memoria
rápido
rea-
lizar
optimización
importante
vale
pena
buscar
algoritmos
obtengan
velocidad
utilizar
memoria
contrario
ahorren
memoria
cálculos
988
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.4
RENDIMIENTO
989
técnica
útil
casos
reemplazar
procedimientos
pequeños
macros
utilizar
macro
elimina
sobrecarga
general
asocia
llamada
pro-
cedimiento
ganancia
especial
considerable
llamada
ocurre
ciclo
ejemplo
suponga
utilizamos
mapas
bits
recursos
fre-
cuencia
necesitamos
unidades
libres
mapa
bits
propósito
necesitamos
procedimiento
llamado
cuenta_bits
número
bits
byte
procedimiento
simple
muestra
figura
13-7(a
Recorre
bits
byte
contándolos
define
TAM_BYTES
byte
contiene
bits
int
cuenta_bits(int
byte
bits
byte
int
for
i=0
TAM_BYTES
i++
itera
bits
byte
if
byte>>i)&1
cuenta++
bit
suma
return(cuenta
devuelve
suma
Macro
sumar
bits
byte
devolver
suma
define
cuenta_bits(b
b&1)+((b>>1)&1)+((b>>2)&1)+((b>>3)&1)+\
b>>4)&1)+((b>>5)&1)+((b>>6)&1)+((b>>7)&1
Macro
buscar
bits
tabla
char
bits[256]={0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3
define
cuenta_bits(b
int
bits[b
Figura
13-7
procedimiento
contar
bits
byte
macro
contar
bits
macro
bits
búsqueda
tabla
procedimiento
fuentes
ineficiencia
lugar
llamar
asignar
espacio
pila
regresar
llamada
procedimiento
sobre-
carga
lugar
contiene
ciclo
sobrecarga
asociada
ciclo
macro
figura
13-7(b
método
completamente
distinto
expresión
línea
calcula
suma
bits
desplazar
sucesiva
argumento
enmascarar
excep-
to
bit
menor
orden
sumar
términos
macro
difícilmente
obra
arte
aparece
código
ejemplo
llamada
macro
suma
cuenta_bits(tabla[i
llamada
macro
ve
idéntica
procedimiento
aparte
definición
com-
plicada
código
caso
macro
ve
caso
procedimiento
www.FreeLibros.memucho
eficiente
elimina
sobrecarga
llamada
procedimiento
so-
brecarga
ciclo
profundizar
ejemplo
calcular
bits
buscarla
tabla
256
bytes
distintos
valor
declarar
tabla
256
entradas
llamada
bits
entrada
iniciali-
za
tiempo
compilación
bits
correspondiente
valor
byte
método
requiere
cálculo
tiempo
ejecución
operación
indexamiento
figura
13-7(c
muestra
macro
trabajo
ejemplo
concesión
tiempo
cálculo
obtener
memoria
podríamos
profundizar
necesitan
cuentas
bits
palabras
completas
32
bits
macro
cuenta_bits
necesitamos
bús-
quedas
palabra
expandimos
tabla
65,536
entradas
requerirán
búsquedas
palabra
cambio
tabla
búsqueda
respuestas
tablas
utilizar
formas
ejemplo
capítulo
vimos
funciona
compresión
imágenes
JPEG
transformaciones
coseno
discretas
complejas
técnica
compresión
alternativa
conocida
GIF
utiliza
búsqueda
tablas
codificar
píxeles
RGB
24
bits
GIF
funcio-
na
imágenes
256
colores
comprimir
imagen
construye
paleta
256
colores
entrada
contiene
valor
RGB
24
bits
imagen
comprimida
consiste
índice
bits
píxel
valor
color
24
bits
obtiene
ganancia
factor
idea
ilustra
sección
/H110034
imagen
figura
13-8
figura
13-8(a
muestra
imagen
comprimida
original
valor
24
bits
bits
intensidad
rojo
verde
azul
respectivamente
imagen
GIF
mues-
tra
figura
13.8(b
valor
índice
bits
paleta
colores
paleta
al-
macena
archivo
imagen
muestra
figura
13-8(c
realidad
detalles
GIF
idea
básica
búsqueda
tabla
forma
reducir
tamaño
imagen
muestra
concesión
dife-
rente
PostScript
lenguaje
programación
utilizar
describir
imágenes
realidad
lenguaje
programación
describir
imágenes
PostScript
opti-
mizado
impresoras
integrado
intérprete
PostScript
ejecutar
programas
PostScript
reciben
ejemplo
bloque
rectangular
píxeles
color
imagen
pro-
grama
PostScript
imagen
tendría
instrucciones
colocar
rectángulo
ubi-
cación
rellenarlo
color
requiere
bits
ejecutar
comando
impresora
recibe
imagen
intérprete
integrado
ejecutar
programa
construir
imagen
PostScript
logra
compresión
datos
cambio
cálculos
concesión
distinta
búsqueda
tabla
valiosa
memoria
ancho
banda
concesiones
involucran
estructuras
datos
listas
enlace
doble
ocupan
memoria
listas
enlace
simple
per-
miten
acceso
rápido
elementos
tablas
hash
desperdician
espacio
formas
rápidas
resumen
principales
puntos
considerar
optimizar
pieza
código
distintas
estructuras
datos
concesión
tiempo
espacio
990
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.4
RENDIMIENTO
991
13.4.4
caché
caché
técnica
reconocida
mejorar
rendimiento
aplicar
exis-
ta
probabilidad
requerir
resultado
método
general
trabajo
guardar
resultado
caché
intentos
subsiguientes
pri-
mero
comprueba
caché
resultado
utiliza
caso
contrario
vuelve
ha-
cer
trabajo
visto
caché
sistema
archivos
guardar
número
bloques
disco
reciente
obtiene
ahorro
lectura
disco
ca-
ocurrencia
caché
utilizar
fines
ejem-
plo
parezca
análisis
nombres
rutas
proceso
exige
recursos
Considere
ejemplo
UNIX
figura
4-35
buscar
/usr
ast
mbox
requieren
siguientes
accesos
disco
Leer
nodo-i
directorio
raíz
nodo-i
Leer
directorio
raíz
bloque
Leer
nodo-i
/usr
nodo-i
Leer
directorio
/usr
bloque
132
Leer
nodo-i
/usr
ast
nodo-i
26
Leer
directorio
/usr
ast
bloque
406
requieren
accesos
disco
descubrir
número
nodo-i
archivo
leer
nodo-i
descubrir
números
bloques
disco
archivo
pequeño
tamaño
bloque
ejemplo
1024
bytes
requieren
accesos
disco
leer
datos
3,8,13
3,8,13
3,8,13
3,8,13
26,4,9
90,2,6
4,19,20
4,6,9
4,6,9
10,30,8
5,8,1
22,2,0
10,11,5
4,2,17
88,4,3
66,4,43
77
26
34
451
892
11
10
Bits24
Bits
24
Bits
22,2,0
26,4,9
5,8,1
10,30,8
4,6,9
4,19,20
90,2,6
66,4,43
88,4,3
4,2,17
10,11,5
3,8,13
Figura
13-8
imagen
descomprimida
24
bits
pixel
mis-
ma
comprimida
GIF
bits
pixel
paleta
colores
www
FreeLibros.meFigura
13-9
caché
nodos-i
figura
4-35
992
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
sistemas
optimizan
análisis
nombres
rutas
caché
combina-
ciones
ruta
nodo-i
ejemplo
figura
4-35
evidente
caché
contendrá
pri-
meras
entradas
figura
13-9
analizar
/usr
ast
mbox
entradas
provienen
análisis
rutas
Ruta
Número
nodo-i
/usr
/usr
ast
26
/usr
ast
mbox
60
/usr
ast
libros
92
/usr
bal
45
/usr
bal
articulo.ps
85
buscar
ruta
analizador
nombres
consulta
caché
bus-
ca
subcadena
larga
esté
presente
ejemplo
presenta
ruta
/usr
ast
concesio-
nes
stw
caché
devuelve
/usr
ast
nodo-i
26
búsqueda
empezar
eliminan
accesos
disco
problema
surge
colocar
rutas
caché
asignación
nombre
archivo
número
nodo-i
fija
tiempo
Suponga
archivo
/usr
ast
mbox
elimina
sistema
nodo-i
reutiliza
distinto
archivo
pertenece
usuario
di-
ferente
vuelve
crear
archivo
/usr
ast
mbox
obtiene
nodo-i
106
evitarlo
entrada
caché
incorrecta
búsquedas
posteriores
de-
volverán
número
nodo-i
incorrecto
razón
elimina
archivo
directorio
purgar
entrada
caché
directorio
entradas
niveles
infe-
riores
bloques
disco
nombres
ruta
únicos
elementos
colo-
car
caché
nodos-i
caché
utilizan
hilos
emergentes
manejar
interrupciones
requiere
pila
maquinaria
adicional
hi-
utilizado
caché
fácil
refabricar
hilo
usado
crear
cero
evitar
asignar
memoria
cual-
quier
cosa
difícil
producir
caché
13.4.5
Sugerencias
entradas
caché
correctas
búsqueda
caché
fracasar
entrada
garantiza
correcta
utilizar
siste-
conveniente
tabla
sugerencias
sugerencias
solución
pe-
ro
garantiza
correctas
llamada
verificar
resultado
www
FreeLibros.meSECCIÓN
13.4
RENDIMIENTO
993
ejemplo
conocido
sugerencias
URLs
incrustados
páginas
Web
ha-
cer
clic
vínculo
garantiza
página
Web
apunta
esté
pá-
gina
apunta
eliminado
10
años
atrás
ende
información
página
apunta
realidad
sugerencia
sugerencias
utilizan
conexión
archivos
remotos
información
sugerencia
indica
acerca
archivo
remoto
ubicación
ejemplo
archivo
movido
eliminado
registró
ocurrencia
siem-
pre
necesario
comprobación
correcta
13.4.6
Explotar
localidad
procesos
programas
actúan
azar
Exhiben
cantidad
considerable
localidad
tiempo
espacio
información
explotar
formas
mejorar
rendimien-
to
ejemplo
conocido
localidad
espacial
procesos
saltan
azar
espacios
direcciones
Tienden
utilizar
número
relativamente
pequeño
pá-
ginas
intervalo
páginas
proceso
utiliza
activa
con-
siderar
conjunto
trabajo
sistema
operativo
asegurar
permita
ejecución
proceso
conjunto
trabajo
esté
memoria
reducir
número
fallos
página
principio
localidad
aplica
archivos
proceso
selecciona
di-
rectorio
trabajo
específico
probable
futuras
referencias
archivos
directorio
colocar
nodos-i
archivos
directorio
cerca
disco
obtener
mejoras
rendimiento
Sistema
archivos
rápidos
Berke-
ley
basa
principio
McKusick
colaboradores
1984
área
localidad
importante
planificación
hilos
multiproce-
sadores
vimos
capítulo
forma
planificar
hilos
multiprocesador
tra-
tar
ejecutar
hilo
CPU
utilizó
esperanza
bloques
memoria
encuentren
caché
memoria
13.4.7
Optimizar
caso
común
frecuencia
conveniente
distinguir
caso
común
caso
tratarlos
distinta
código
importante
caso
común
rápido
caso
ocurre
frecuencia
suficiente
correcto
ejemplo
considere
caso
proceso
entra
región
crítica
ma-
yor
tiempo
entrada
éxito
especial
procesos
pasan
tiempo
den-
tro
regiones
críticas
Windows
Vita
aprovecha
expectativa
proveer
llamada
EnterCriticalSectionen
API
Win32
realiza
evaluación
atómica
bandera
usuario
TSLo
equivalente
evaluación
éxito
proceso
entra
región
crítica
requiere
llamada
kernel
evaluación
fracasa
proceso
biblioteca
realiza
llamada
downen
semáforo
bloquear
proceso
caso
nor-
requiere
llamada
kernel
www
FreeLibros.meComo
ejemplo
considere
establecimiento
alarma
seña-
UNIX
alarma
pendiente
momento
basta
crear
entrada
ponerla
cola
temporizador
obstante
alarma
pendiente
encontrar
eliminar
cola
temporizador
llamada
alarmno
especifica
conjunto
alarmas
sistema
asumir
caso
tiempo
alarma
pendiente
requieren
recursos
eliminar
alarma
existente
conveniente
diferenciar
casos
forma
mantener
bit
tabla
procesos
indique
alarma
pendiente
bit
desactivado
ruta
fácil
agregar
entrada
cola
temporizador
comprobar
bit
activado
comprobar
cola
temporizador
13.5
ADMINISTRACIÓN
PROYECTOS
programadores
optimistas
perpetuos
mayoría
piensan
forma
escribir
programa
correr
teclado
empezar
escribir
termina
programa
com-
pletamente
depurado
programas
extensos
funciona
siguientes
secciones
hablaremos
administración
proyectos
extensos
hardware
especial
proyectos
sistemas
operativos
extensos
13.5.1
mítico
hombre-mes
clásico
libro
Fred
Brooks
diseñadores
OS/360
dedicó
vida
académica
aborda
pregunta
difícil
construir
sistemas
operativos
gran-
des
Brooks
1975
1995
mayoría
programadores
ven
afirmación
programador
producir
1000
líneas
código
depurado
año
proyectos
extensos
preguntan
profesor
Brooks
vive
espacio
exterior
Planeta
Error
mayoría
recordar
ocasión
trabajaron
madrugada
pro-
dujeron
programa
1000
líneas
noche
producción
anual
persona
IQ
50
Brooks
proyectos
cientos
programadores
completo
distintos
proyectos
pequeños
resultados
obtienen
proyectos
pe-
queños
extrapolar
escala
extensos
proyecto
extenso
consume
cantidad
tiempo
planear
dividir
trabajo
módulos
especificando
cuidado
módulos
interfaces
tratando
imaginar
interactuarán
módulos
empezar
codificación
módulos
codificar
depurar
forma
aisla-
integrarlos
sistema
probar
caso
normal
módulo
funciona
problemas
evalúa
sistema
falla
instante
reúnen
piezas
Brooks
estimó
trabajo
compone
1/3
Planificación
1/6
Codificación
1/4
Prueba
módulos
1/4
Prueba
sistema
994
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.5
ADMINISTRACIÓN
PROYECTOS
995
palabras
escritura
código
sencilla
difícil
averiguar
de-
ben
módulos
lograr
módulo
comunique
forma
correcta
módulo
B.
pequeño
programa
escrito
programador
queda
sencilla
título
libro
Brooks
proviene
aseveración
personas
tiempo
intercambiables
unidad
hombre-mes
persona-mes
15
personas
tardan
años
crear
proyecto
inconcebible
360
personas
puedan
mes
60
personas
hagan
meses
razones
relacionadas
efecto
lugar
trabajo
paraleli-
zar
completo
codificación
empezar
planeación
determinado
módulos
necesitan
interfaces
proyecto
años
planificación
requerir
meses
lugar
aprovechar
completo
número
programadores
trabajo
particionar
número
módulos
tengan
Co-
mo
posibilidad
módulo
interactúe
módulos
número
interacciones
módulo
módulo
necesario
considerar
aumenta
base
cuadrado
número
módulos
base
cuadrado
número
programadores
comple-
jidad
sale
rápidamente
control
mediciones
cuidadosas
63
proyectos
software
confirmado
balance
personas
meses
dista
lineal
proyectos
exten-
sos
Boehm
1981
tercer
lugar
depuración
secuencial
Utilizar
10
depuradores
problema
significa
error
encontrar
10
rápido
probable
depu-
radores
lentos
desperdiciarán
tiempo
hablando
Brooks
resume
experiencia
balance
personas
tiempo
Ley
Brooks
agrega
personal
proyecto
software
retrasado
atrasará
problema
agregar
personas
capacitar
proyecto
módulos
tie-
nen
volver
dividir
coincidir
número
programadores
disponibles
re-
querirán
reuniones
coordinar
esfuerzos
etc.
Abdel-Hamid
Madnick
1991
confirmaron
ley
forma
experimental
forma
irreverente
reformular
ley
Brooks
necesitan
meses
hijo
importar
mujeres
asignen
tarea
13.5.2
Estructura
equipos
sistemas
operativos
comerciales
proyectos
software
extensos
requieren
gran-
des
equipos
personas
capacidad
personas
inmensamente
importante
dé-
cadas
mejores
programadores
10
productivos
malos
programadores
Sackman
colaboradores
1968
problema
necesitan
200
pro-
gramadores
difícil
encontrar
200
programadores
conformarse
amplio
es-
pectro
cualidades
www
FreeLibros.meLo
importante
proyecto
diseño
extenso
software
índole
necesidad
coherencia
arquitectónica
mente
controle
di-
seño
Brooks
cita
catedral
Rheims
Francia
ejemplo
proyecto
extenso
tardó
décadas
construirse
arquitectos
llegaron
subordinaron
de-
seo
sello
proyecto
cabo
planes
arquitecto
inicial
resulta-
do
coherencia
arquitectónica
precedentes
catedrales
europeas
década
1970
Harlan
Mills
combinó
observación
programadores
mejores
necesidad
coherencia
arquitectónica
proponer
paradig-
ma
equipo
programador
jefe
Baker
1972
idea
organizar
equipo
progra-
mación
equipo
cirujanos
carniceros
tiren
machetazos
diestra
siniestra
persona
esgrime
bisturí
ofrecer
ayuda
proyecto
10
personas
Mills
sugirió
estructura
equipo
figura
13-10
996
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
Figura
13-10
Proposición
Mill
llenar
equipo
10
personas
programador
jefe
Título
Deberes
Programador
jefe
Realiza
diseño
arquitectónico
escribe
código
Copiloto
Ayuda
programador
jefe
sirve
caja
resonancia
Administrador
Administra
personas
presupuesto
espacio
equipo
informes
etcétera
Editor
Edita
documentación
programador
jefe
escribir
Secretarias
administrador
editor
necesitan
secretaria
Empleado
programas
Mantiene
archivos
código
documentación
Jefe
herramientas
Provee
herramientas
necesita
programador
jefe
Evaluador
Evalúa
código
programador
jefe
Abogado
lenguaje
Empleado
tiempo
aconsejar
programador
jefe
relación
lenguaje
transcurrido
décadas
propuso
equipo
puso
producción
Al-
gunas
cosas
cambiado
necesidad
abogado
lenguaje
simple
PL
necesidad
mente
controle
diseño
pie
men-
capaz
trabajar
100%
diseño
programación
necesite
per-
sonal
soporte
ayuda
computadora
suficiente
personal
pequeño
esencia
idea
válida
proyecto
extenso
necesita
organizarse
jerarquía
nivel
inferior
equipos
pequeños
encabezado
programador
jefe
nivel
grupos
equipos
coordinar
administrador
expe-
riencia
muestra
persona
administramos
cuesta
10%
tiempo
requiere
administrador
tiempo
completo
grupo
10
equipos
administrar
administradores
sucesivo
Brooks
observó
malas
noticias
suben
árbol
Jerry
Saltzer
M.I.T.
llamó
efecto
diodo
malas
noticias
programador
jefe
adminis-
www
FreeLibros.meSECCIÓN
13.5
ADMINISTRACIÓN
PROYECTOS
997
trador
desea
jefe
proyecto
retrasado
meses
probabili-
dad
cumplir
tiempo
entrega
tradición
2000
años
antigüedad
decapitar
mensajero
malas
noticias
consecuencia
administración
superior
general
oscuras
relación
proyecto
vuelve
obvio
cumplir
tiempo
entrega
administración
superior
responde
agregando
perso-
nal
momento
entra
acción
Ley
Brooks
práctica
empresas
experiencia
producción
software
ocurre
produce
azar
tendencia
tratar
contraste
empresas
pequeñas
recientes
prisa
entrar
mercado
cuidado
producir
software
cuidado
apuro
me-
nudo
produce
resultados
alejados
óptimo
Brooks
Mills
pronosticaron
crecimiento
movimiento
código
fuente
abierto
éxitos
modelo
viable
producir
gran-
des
cantidades
software
calidad
pase
novedad
recordar
radio
dominada
radio-aficionados
apareció
radio
comercial
televisión
comercial
perceptible
proyectos
software
có-
digo
fuente
abierto
éxito
utilizado
claramente
modelo
programador
jefe
mente
controla
diseño
arquitectónico
ejemplo
Li-
nus
Torvalds
kernel
Linux
Richard
Stallman
compilador
GNU
13.5.3
función
experiencia
imprescindible
diseñadores
experimentados
proyecto
sistemas
operativos
Brooks
señala
mayoría
errores
código
diseño
programadores
hi-
cieron
correcta
erróneo
hicieran
cantidad
software
prueba
atrapar
especificaciones
defectuosas
solución
Brooks
abandonar
modelo
desarrollo
clásico
figura
13-11(a
uti-
lizar
modelo
figura
13-11(b
idea
escribir
programa
principal
simplemente
llame
procedimientos
nivel
superior
principio
señuelos
Des-
proyecto
sistema
compilar
ejecutar
hará
me-
dida
transcurra
tiempo
insertarán
módulos
sistema
completo
resultado
método
prueba
integración
sistema
realiza
forma
continua
erro-
res
diseño
aparecen
efecto
proceso
aprendizaje
producido
ma-
decisiones
diseño
empieza
ciclo
conocimiento
peligroso
Brooks
observó
denominó
efecto
se-
gundo
sistema
producto
producido
equipo
diseño
mínimo
de-
bido
diseñadores
miedo
funcionar
resultado
rehúsan
características
proyecto
éxito
crean
sistema
Impresionados
éxito
diseñadores
incluyen
adornos
omitieron
ma-
nera
intencional
resultado
sistema
atestado
características
rendimiento
pobre
percatan
fracaso
sistema
vuelven
precavidos
www
FreeLibros.me998
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
par
CTSS-MULTICS
caso
cuestión
CTSS
sistema
tiempo
compartido
propósito
general
enorme
éxito
funcionalidad
mí-
nima
sucesor
MULTICS
ambicioso
sufrió
considerable
ideas
demasiadas
novedades
sistema
desempeño
po-
bre
años
éxito
comercial
tercer
sistema
línea
desarrollo
UNIX
precavido
exitoso
13.5.4
bala
plata
obra
mítico
hombre-mes
Brooks
escribió
artículo
influyente
llamado
bala
plata
Brooks
1987
afirmaba
remedios
pregonaban
personas
tiempo
iba
generar
mejora
considerable
productivi-
dad
software
década
experiencia
demuestra
razón
balas
plata
propusieron
lenguajes
alto
nivel
mejorados
programación
orientada
objetos
inteligencia
artificial
sistemas
expertos
programación
automática
programación
gráfica
verificación
programas
entornos
programa-
ción
década
veremos
bala
plata
tengamos
confor-
marnos
mejoras
graduales
incrementales
13.6
TENDENCIAS
DISEÑO
SISTEMAS
OPERATIVOS
predicciones
difícil
especial
futuro
ejemplo
1899
jefe
Oficina
Patentes
EE.UU.
Charles
H.
Duell
pidió
presidente
McKinley
aboliera
Oficina
Patentes
trabajo
palabras
Módulos
prueba
Código
Sistema
prueba
Desplie-
gue
Procedimiento
señuelo
Plan
Procedimiento
señuelo
Procedimiento
señuelo
Programa
principal
Figura
13-11
diseño
software
tradicional
progresa
etapas
diseño
alternativo
produce
sistema
funcional
www
FreeLibros.meSECCIÓN
13.6
TENDENCIAS
DISEÑO
SISTEMAS
OPERATIVOS
999
inventar
inventado
Cerf
Navasky
1984
Thomas
Edison
apareció
pie
puerta
años
par
inventos
luz
eléctrica
fonógrafo
proyector
películas
baterías
bola
cristal
aventurarnos
adivinar
sistemas
operativos
futuro
cercano
13.6.1
Virtualización
virtualización
idea
cuyo
tiempo
llegado
surgió
1967
sis-
tema
IBM
CP
CMS
vuelta
fuerza
plataforma
Pentium
futuro
cercano
computadoras
ejecutarán
hipervisores
hardware
directo
muestra
figura
13-12
hipervisor
creará
máquinas
virtuales
sistema
operativo
computadoras
ejecutarán
Windows
máquina
virtual
apli-
caciones
heredadas
máquinas
virtuales
Linux
aplicaciones
actuales
sistemas
operativos
experimentales
máquinas
virtuales
fenómeno
des-
cribió
capítulo
duda
ola
futuro
Hardware
Hipervisor
Windows
Linux
Linux
SO
Máquina
virtual
Figura
13-12
hipervisor
ejecuta
máquinas
virtuales
13.6.2
Chips
multinúcleo
chips
multinúcleo
sistemas
operativos
aprovechan
siquiera
núcleos
64
tardan
llegar
harán
to-
núcleos
tipo
software
necesitará
realidad
principio
personas
tratarán
parchar
sistemas
operativos
actuales
trabajar
pe-
ro
probable
éxito
números
núcleos
pro-
blema
bloquear
tablas
recursos
software
duda
espacio
ideas
radicalmente
combinación
virtualización
chips
multinúcleo
crea
entorno
es-
mundo
número
CPUs
disponibles
programable
chip
núcleos
softwa-
re
cosa
utilizar
CPU
ignorar
utilizar
CPUs
reales
virtualización
vías
obtienen
16
CPUs
virtuales
virtualización
vías
32
CPUs
virtuales
combinación
progra-
ma
empezar
anunciar
CPUs
desea
sistema
operativo
decide
otorga
www
FreeLibros.me13.6.3
Sistemas
operativos
espacios
direcciones
extensos
medida
máquinas
pasan
espacios
direcciones
32
bits
64
bits
genera
posibilidad
cambios
importantes
diseño
sistemas
operativos
espacio
direcciones
32
bits
realidad
tratara
dividir
32
bytes
pa-
ra
habitante
Tierra
byte
habría
suficientes
bytes
contrario
64
equivale
/H110031019
obtener
tro-
zo
GB
podríamos
espacio
direcciones
/H110031010
bytes
empezar
podríamos
eliminar
concepto
sistema
archivos
archivos
po-
drían
contenerse
conceptual
memoria
virtual
tiempo
suficiente
espacio
mil
millones
películas
completas
compri-
mida
GB
posibles
usos
almacén
objetos
persistente
crear
objetos
espacio
direcciones
mantenerlos
desparecieran
referencias
eliminarlos
posteriormente
Dichos
objetos
serían
persistentes
espacio
direcciones
computadora
apague
reinicie
espacio
direcciones
64
bits
crear
objetos
razón
100
MB
seg
5000
años
agotara
espacio
direccio-
nes
almacenar
realmente
cantidad
datos
requeriría
cantidad
almacenamiento
disco
tráfico
paginación
his-
toria
factor
limitante
almacenamiento
disco
espacio
direcciones
cantidades
objetos
espacio
direcciones
interesante
permitir
va-
rios
procesos
ejecuten
espacio
direcciones
tiempo
compartir
objetos
forma
general
diseño
duda
conllevaría
sistemas
operativos
distin-
tos
obra
Chase
colaboradores
1994
contiene
ideas
concepto
cuestión
sistemas
operativos
volver
considerar
direc-
ciones
64
bits
memoria
virtual
64
bytes
espacio
direcciones
virtuales
páginas
KB
251
páginas
tablas
páginas
convencionales
escalan
tamaño
requiere
tablas
páginas
invertidas
posibilidad
propuesto
ideas
Talluri
colaboradores
1995
caso
espacio
investigaciones
sistemas
operativos
64
bits
13.6.4
Redes
sistemas
operativos
actuales
diseñaron
computadoras
independientes
redes
surgie-
ron
general
acceso
programas
especiales
navegadores
Web
FTP
telnet
futuro
probable
redes
base
sistemas
ope-
rativos
computadora
independiente
conexión
red
raro
telé-
fono
conexión
red
telefónica
probable
conexiones
multimegabits
norma
1000
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.6
TENDENCIAS
DISEÑO
SISTEMAS
OPERATIVOS
1001
sistemas
operativos
cambiar
adaptarse
cambio
paradigma
diferencia
datos
locales
datos
remotos
difuminarse
punto
preocupe
almacenan
datos
computadoras
cual-
quier
tratar
datos
fueran
datos
locales
gra-
do
NFS
probablemente
vuelva
dominante
integrado
acceso
Web
actualidad
requiere
programas
especiales
navegadores
integre
completo
sistema
operativo
uniforme
páginas
Web
lleguen
forma
estándar
almacenar
información
páginas
contener
amplia
variedad
elementos
texto
audio
video
programas
de-
administrará
datos
fundamentales
sistema
operativo
13.6.5
Sistemas
paralelos
distribuidos
área
prometedora
sistemas
paralelos
distribuidos
sistemas
operativos
actua-
multiprocesadores
multicomputadoras
sistemas
operativos
uniproce-
sador
estándar
pequeños
ajustes
planificador
manejar
paralelismo
futuro
veamos
sistemas
operativos
paralelismo
central
efecto
estimulará
considerable
máquinas
escritorio
lle-
gan
CPUs
configuración
multiprocesador
ocasionar
diseñen
programas
aplicaciones
multiprocesadores
con-
currente
demanda
soporte
sistema
operativo
probable
multicomputadoras
dominen
área
supercomputadoras
científi-
cas
ingeniería
escala
años
sistemas
operativos
primitivos
colocación
procesos
balanceo
cargas
comunicación
nece-
sitan
trabajo
sistemas
distribuidos
actuales
crean
middleware
siste-
operativos
existentes
proveen
herramientas
correctas
aplicaciones
distribuidas
sistemas
operativos
futuros
diseñen
sistemas
distribuidos
mente
características
necesarias
estén
presentes
sistema
operativo
principio
13.6.6
Multimedia
duda
sistemas
multimedia
futuro
mundo
computadoras
sorpresa
computadoras
estéreos
televisiones
teléfonos
fusionaran
dispositivo
capaz
producir
admitir
imágenes
fijas
alta
calidad
audio
video
conecta-
ran
redes
alta
velocidad
descargar
intercambiar
acceder
forma
remota
archivos
facilidad
sistemas
operativos
dispositivos
disposi-
tivos
independientes
audio
video
distintos
actuales
especial
requerirán
garantías
tiempo
real
controlarán
diseño
sistema
consumidores
tolerarán
fallas
semanales
televisores
digitales
requerirá
software
calidad
tolerancia
fallas
archivos
multi-
media
tienden
extensos
modificar
sistemas
archivos
po-
der
manejarlos
eficiencia
www
FreeLibros.me13.6.7
Computadoras
operadas
baterías
duda
poderosas
PCs
escritorio
probablemente
espacios
direcciones
64
bits
redes
alto
ancho
banda
múltiples
procesadores
video
audio
alta
calidad
comunes
sistemas
operativos
distintos
actuales
manejar
es-
tas
demandas
segmento
mercado
crece
rapidez
computadoras
operadas
baterías
notebooks
palmtops
webpads
laptops
100
teléfonos
inteligentes
computadoras
conexiones
inalámbricas
mundo
exterior
ejecutarán
desconectado
estén
acopladas
hogar
Ne-
cesitarán
distintos
sistemas
operativos
pequeños
rápidos
flexibles
confiables
actuales
tipos
microkernels
sistemas
extensibles
formar
base
sistemas
operativos
manejar
operaciones
conexión
completa
ejemplo
alámbrica
conexión
débil
inalámbrica
desconectada
incluyendo
aca-
paramiento
datos
desconectarse
resolución
consistencia
volver
conectarse
sistemas
actuales
manejar
problemas
mo-
vilidad
sistemas
actuales
ejemplo
buscar
impresora
láser
conectarse
enviarle
archivo
radio
administración
energía
incluyendo
diálogos
extensos
en-
tre
sistema
operativo
aplicaciones
energía
queda
batería
pue-
utilizar
esencial
adaptación
dinámica
aplicaciones
manejar
limitaciones
pequeñas
pantallas
llegar
importante
modos
entrada
salida
incluyendo
escritura
manual
voz
requerir
técnicas
sistema
operativo
mejorar
calidad
improbable
sistema
operativo
computadora
inalámbrica
bolsillo
operada
voz
energizada
baterías
común
sistema
operativo
multiprocesador
escritorio
64
bits
CPUs
conexión
red
fibraóptica
gigabits
innumerables
máquinas
híbridas
requerimientos
13.6.8
Sistemas
embebidos
sistemas
embebidos
área
proliferarán
sistema
operati-
vos
sistemas
operativos
lavadoras
hornos
microondas
muñecas
radios
transistores
Internet
reproductores
MP3
cámaras
video
elevadores
pacificadores
distintos
visto
probable
distintos
esté
ajustado
aplicación
específica
improbable
alguien
inserte
tarjeta
PCI
pacificador
convertirlo
controlador
elevador
sistemas
embebidos
incrustados
ejecutan
número
limitado
programas
conocen
tiempo
compilación
optimizaciones
posibles
sistemas
propósito
general
idea
prometedora
sistemas
embebidos
sistema
operativo
extensible
ejemplo
Paramecium
Exokernel
sistemas
crear
ligeros
pesados
demande
aplicación
cuestión
consistente
aplicaciones
Co-
mo
sistemas
embebidos
producirán
cientos
millones
importante
mercado
sistemas
operativos
1002
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meSECCIÓN
13.7
RESUMEN
1003
13.6.9
Nodos
monitoreo
mercado
nicho
redes
monitoreo
desplegando
contex-
tos
monitoreo
edificios
fronteras
nacionales
detección
incendios
foresta-
monitores
utilizados
costo
baja
energía
requieren
sistemas
operativos
extremo
simplificados
perfeccionados
bibliotecas
tiempo
ejecución
medida
nodos
poderosos
disminuyan
precio
empeza-
remos
sistemas
operativos
reales
estarán
optimizados
tareas
consumirán
menor
cantidad
energía
tiempos
vida
ba-
terías
miden
meses
transmisores
receptores
inalámbricos
consumen
energía
es-
tos
sistemas
organizarán
eficientes
energía
cosa
13.7
RESUMEN
empezar
diseño
sistema
operativo
determinar
interfaz
simple
completa
eficiente
paradigmas
interfaz
usuario
ejecución
da-
tos
claros
sistema
estructurado
utilizar
técnicas
conocidas
téc-
nica
niveles
cliente-servidor
componentes
internos
ortogonales
separar
claridad
directiva
mecanismo
considerar
detalle
cuestio-
nes
tales
comparación
estructuras
datos
estáticas
dinámicas
nomenclatu-
ra
tiempo
vinculación
orden
implementación
nodos
rendimiento
importante
optimizaciones
elegir
cuidado
arruinar
estructura
sistema
concesiones
espacio
tiempo
caché
su-
gerencias
explotación
localidad
optimización
caso
común
optimizaciones
vale
pena
frecuencia
distinto
escribir
sistema
par
personas
producir
sistema
300
caso
estructura
equipo
administración
proyectos
desempeñan
pa-
pel
crucial
éxito
fracaso
proyecto
sistemas
operativos
cambiar
años
seguir
nue-
vas
tendencias
cumplir
retos
sistemas
basados
hipervisor
sistemas
multinúcleo
espacios
direcciones
64
bits
conectividad
masiva
multipro-
cesadores
multicomputadoras
escala
multimedia
computadoras
inalámbricas
bolsillo
sistemas
embebidos
nodos
monitoreo
años
momentos
emocionantes
diseñadores
sistemas
operativos
PROBLEMAS
Ley
Moore
describe
fenómeno
crecimiento
exponencial
similar
crecimiento
población
especie
animal
introduce
entorno
comida
abundan-
enemigos
naturales
naturaleza
probable
curva
crecimiento
expo-
www.FreeLibros.menencial
convierta
momento
curva
sigmoide
límite
asintótico
cuan-
do
provisiones
alimentos
empiecen
agotar
depredadores
aprovechen
presas
Analice
factores
limitar
momento
proporción
me-
jora
hardware
computadora
figura
13-1
muestran
paradigmas
algorítmico
controlado
eventos
siguientes
tipos
programas
indique
paradigma
fácil
compilador
programa
edición
fotografías
programa
nómina
primeras
computadoras
Macintosh
Apple
código
GUI
ROM
dictamen
Corbató
sistema
proporcionar
mecanismo
mínimo
lista
llamadas
POSIX
presentes
UNIX
versión
redundantes
eliminar
perder
funcionalidad
combinaciones
simples
llamadas
tarea
rendimiento
Access
alarm
chdir
chmod
chown
chroot
close
creat
dup
exec
exit
fcntl
fork
fstat
ioctl
kill
link
lseek
mkdir
mknod
open
pause
pipe
read
stat
time
ti-
mes
umask
unlink
utime
waity
write
sistema
cliente-servidor
basado
microkernel
realiza
paso
mensajes
procesos
usuario
formas
puedan
crear
utilizar
se-
máforos
optimización
cuidadosa
mejorar
rendimiento
llamadas
sistema
Considere
caso
realiza
llamada
sistema
10
mseg
tiempo
promedio
llamada
mseg
llamadas
sistema
agilizar
factor
tiempo
tardaría
proceso
tardaba
10
segundos
ejecutarse
Muestre
análisis
comparación
mecanismo
directiva
contexto
tiendas
ventas
detalle
sistemas
operativos
realizan
asignación
nombres
niveles
distintos
externo
interno
Indique
diferencias
nombres
Longitud
Unicidad
Jerarquías
manejar
tablas
cuyo
tamaño
conoce
antemano
hacerlas
fijas
llene
reemplazarla
copiar
entradas
anteriores
tabla
liberar
tabla
ventajas
desventajas
ha-
cer
tabla
original
comparación
hacerla
1.5
ve-
ces
10
figura
13-5
utilizó
bandera
llamada
encontro
indicar
localizado
PID
Hubiera
olvidarse
encontro
evaluar
ciclo
1004
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.meCAPÍTULO
13
PROBLEMAS
1005
11
figura
13-6
diferencias
Pentium
UltraSPARC
ocultan
com-
pilación
condicional
utilizar
método
ocultar
diferencia
Pentium
disco
IDE
único
disco
Pentium
disco
SCSI
últi-
mo
disco
idea
12
indirección
forma
algoritmo
flexible
Acaso
desventajas
13
procedimientos
reentrantes
variables
globales
estáticas
privadas
Analice
respuesta
14
macro
figura
13-7(b
duda
eficiente
procedimiento
figu-
ra
13-7(a
desventaja
dificultad
leerlo
desventajas
15
Suponga
necesitamos
forma
calcular
número
bits
palabra
32
bits
par
impar
Idee
algoritmo
cálculo
rápido
Pue-
256
KB
RAM
tablas
necesario
Escriba
macro
cabo
algoritmo
Crédito
adicional
escriba
procedimiento
cálculo
iterar
32
bits
Mida
rápida
macro
procedimiento
16
figura
13-8
vimos
archivos
GIF
utilizan
valores
bits
indexar
paleta
colores
idea
utilizar
paleta
colores
16
bits
an-
cho
circunstancias
paleta
colores
24
bits
idea
17
desventaja
GIF
imagen
incluir
paleta
colores
incrementa
tamaño
archivo
tamaño
imagen
mínimo
punto
equili-
brio
paleta
colores
bits
ancho
repita
pregunta
paleta
colores
16
bits
ancho
18
texto
mostramos
nombres
rutas
caché
producir
agilización
considerable
buscar
nombres
rutas
técnica
utiliza
programa
demonio
abra
archivos
directorio
raíz
mantenga
abiertos
permanente
obligar
nodos-i
memoria
tiempo
Me-
jora
búsqueda
ruta
inmovilizan
nodos-i
forma
19
archivo
remoto
eliminado
registró
ocurrencia
ha-
ber
cambiado
referenció
información
podía
útil
registrar
20
Considere
sistema
acumula
referencias
archivos
remotos
sugerencias
ejemplo
nombre
host-remoto
nombre-remoto
archivo
remoto
elimine
forma
silenciosa
reemplace
sugerencia
obtener
archivo
equivo-
cado
problema
ocurra
frecuencia
21
texto
afirma
localidad
explotar
mejorar
rendimien-
to
considere
caso
programa
lee
entrada
origen
envía
salida
forma
continua
archivos
intento
aprovechar
localidad
sis-
tema
archivos
producir
disminución
eficiencia
caso
forma
re-
solver
www
FreeLibros.me22
Fred
Brooks
afirma
programador
escribir
1000
líneas
código
depurado
año
versión
MINIX
13,000
líneas
código
producida
per-
sona
años
explicar
discrepancia
23
Utilice
cifra
Brooks
1000
líneas
código
programador
año
es-
timación
cantidad
dinero
requirió
producir
Windows
Vista
Suponga
programador
cuesta
100,000
dólares
año
incluyendo
costos
computadoras
espacio
oficina
soporte
secretarial
sobrecarga
administrativa
Cree
res-
puesta
24
medida
memoria
económica
podríamos
imaginar
compu-
tadora
cantidad
RAM
operada
baterías
disco
duro
precios
actuales
costaría
PC
rendimiento
utilice
RAM
Suponga
suficiente
disco
GB
RAM
máquina
rendimiento
probable
máquina
competitiva
25
Nombre
características
sistema
operativo
convencional
necesarias
sistema
embebido
utilice
aparato
electrodoméstico
26
Escriba
procedimiento
suma
doble
precisión
parámetros
dados
Escriba
procedimiento
utilizando
compilación
condicional
forma
funcio-
ne
máquinas
16
bits
máquinas
32
bits
27
Escriba
programas
introduzcan
cadenas
cortas
generadas
azar
arreglo
des-
pués
buscar
arreglo
cadena
específica
búsqueda
li-
neal
simple
fuerza
bruta
método
sofisticado
elección
Vuelva
compilar
programas
tamaños
arreglos
varíen
pequeño
manejar
sistema
Evalúe
rendimiento
métodos
pun-
to
equilibrio
28
Escriba
programa
simular
sistema
archivos
memoria
1006
DISEÑO
SISTEMAS
OPERATIVOS
CAPÍTULO
13
www
FreeLibros.me14
LISTA
LECTURAS
BIBLIOGRAFÍA
1007
13
capítulos
anteriores
vimos
amplia
variedad
temas
capítulo
intención
servir
guía
lectores
interesados
continuar
estudio
sistemas
operativos
sección
14.1
lista
lecturas
recomendadas
14.2
bibliografía
ordenada
alfabéti-
camente
libros
artículos
citados
obra
referencias
mencionadas
Simposio
ACM
Principios
Sis-
temas
Operativos
SOSP
cabo
años
impares
Simposio
USENIX
Di-
seño
Implementación
Sistemas
Operativos
OSDI
cabo
años
pares
fuentes
trabajo
curso
sistemas
operativos
Conferencia
Eurosys
200x
cabo
año
fuente
artículos
clase
ACM
Transactions
on
Computer
Systems
ACM
SIGOPS
Operating
Systems
Review
publicaciones
me-
nudo
artículos
relevantes
conferencias
ACM
IEEE
USENIX
tra-
temas
especializados
14.1
SUGERENCIAS
CONTINUAR
LECTURA
siguientes
secciones
proporcionaremos
lector
sugerencias
continuar
lectu-
ra
diferencia
artículos
citados
secciones
tituladas
INVESTIGACIÓN
libro
tratan
investigación
actual
referencias
na-
turaleza
introductoria
tutoría
servir
presentar
material
con-
libro
perspectiva
distinta
énfasis
www
FreeLibros.me14.1.1
Introducción
obras
generales
Silberschatz
colaboradores
Operating
Systems
Concepts
with
Java
7a
edición
libro
texto
general
sistemas
operativos
procesos
administración
memoria
administración
almacenamiento
protección
seguridad
sistemas
distribuidos
algu-
sistemas
propósito
especial
muestran
casos
estudio
Linux
Windows
XP
por-
tada
presenta
dinosaurios
dinosaurios
sistemas
operativos
Stallings
Operating
Systems
5a
edición
libro
texto
sistemas
operativos
Abarca
temas
tradicionales
incluir
pequeña
cantidad
material
sistemas
distribuidos
Stevens
Rago
Advanced
Programming
in
the
UNIX
Environment
libro
indica
escribir
programas
utilicen
interfaz
llamadas
sistema
UNIX
biblioteca
estándar
C.
ejemplos
basan
versión
System
versión
4.4BSD
UNIX
relación
implementaciones
POSIX
describe
de-
talle
Tanenbaum
Woodhull
Operating
Systems
Design
and
Implementation
práctica
aprender
sistemas
operativos
libro
describe
princi-
pios
usuales
analiza
sistema
operativo
real
MINIX
detalle
Contiene
lis-
tado
sistema
apéndice
14.1.2
Procesos
hilos
Andrews
Schneider
Concepts
and
Notations
for
Concurrent
Programming
tutorial
encuesta
procesos
comunicación
procesos
incluyendo
ocupado
espera
semáforos
monitores
paso
mensajes
técnicas
artículo
muestra
incrustan
conceptos
lenguajes
programación
antiguo
soportado
prueba
tiempo
Ben-Ari
Principles
of
Concurrent
Programming
pequeño
libro
dedicado
completo
problemas
comunicación
pro-
cesos
capítulos
exclusión
mutua
semáforos
monitores
problema
cena
fi-
lósofos
Silberschatz
colaboradores
Operating
System
Concepts
with
Java
7a
edición
capítulos
tratan
procesos
comunicación
procesos
incluyen-
do
planificación
secciones
críticas
semáforos
monitores
problemas
clásicos
comunicación
procesos
1008
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.1
SUGERENCIAS
CONTINUAR
LECTURA
1009
14.1.3
Administración
memoria
Denning
Virtual
Memory
artículo
clásico
aspectos
memoria
virtual
Denning
pio-
neros
campo
inventor
concepto
conjunto
trabajo
Denning
Working
Sets
Past
and
Present
descripción
general
diversos
algoritmos
administración
memoria
pa-
ginación
incluye
bibliografía
extensa
artículos
viejos
reali-
dad
principios
cambiado
Knuth
The
Art
of
Computer
Programming
vol.
libro
analizan
comparan
algoritmos
ajuste
ajuste
algoritmos
memoria
Silberschatz
colaboradores
Operating
System
Concepts
with
Java
7a
edición
capítulos
tratan
administración
memoria
incluyendo
intercambio
pa-
ginación
segmentación
menciona
variedad
algoritmos
paginación
14.1.4
Entrada
salida
Geist
Daniel
Continuum
of
Disk
Scheduling
Algorithms
presenta
algoritmo
generalizado
planificación
brazo
disco
muestran
mu-
chos
resultados
simulaciones
experimentos
Scheible
Survey
of
Storage
Options
formas
almacenar
bits
DRAM
SRAM
SDRAM
memoria
flash
disco
duro
disco
flexible
CD-ROM
DVD
cinta
mencionar
artículo
estudian
diversas
tecnologías
resaltan
fortalezas
debilidades
Stan
Skadron
Power-Aware
Computing
alguien
logre
aplicar
Ley
Moore
baterías
energía
seguirá
principales
problemas
dispositivos
móviles
necesitemos
sistemas
operativos
conscientes
temperatura
artículo
estudian
cuestiones
sirve
introducción
artículos
edición
espe-
cial
revista
Computer
computación
consciente
energía
Walker
Cragon
Interrupt
Processing
in
Concurrent
Processors
implementación
interrupciones
precisas
computadoras
superescalares
activi-
dad
retadora
truco
serializar
rapidez
analizan
cuestiones
diseño
sacrificios
www
FreeLibros.me14.1.5
Sistemas
archivos
McKusick
colaboradores
Fast
File
System
for
UNIX
sistema
archivos
UNIX
rediseñó
completo
4.2
BSD
artículo
describe
diseño
sistema
archivos
énfasis
rendimiento
Silberschatz
colaboradores
Operating
System
Concepts
with
Java
7a
edición
capítulos
10
11
tratan
sistemas
archivos
Cubren
operaciones
archivos
métodos
acceso
directorios
implementación
temas
Stallings
Operating
Systems
5a
edición
capítulo
12
contiene
cantidad
material
entorno
seguridad
espe-
cial
hackers
virus
amenazas
14.1.6
Interbloqueos
Coffman
colaboradores
System
Deadlocks
introducción
interbloqueos
causas
evitar
detectar
Holt
Some
Deadlock
Properties
of
Computer
Systems
análisis
interbloqueos
Holt
introduce
modelo
grafos
dirigido
pue-
utilizar
analizar
situaciones
interbloqueo
Isloor
Marsland
The
Deadlock
Problem
An
Overview
tutorial
interbloqueos
énfasis
especial
sistemas
bases
datos
cubre
variedad
modelos
algoritmos
Shub
Unified
Treatment
of
Deadlock
tutorial
sintetiza
causas
soluciones
interbloqueos
sugiere
de-
be
enfatizar
enseñar
tema
estudiantes
14.1.7
Sistemas
operativos
multimedia
Lee
Parallel
Video
Servers
Tutorial
organizaciones
desean
ofrecer
video
demanda
crea
necesidad
servidores
video
paralelos
tolerantes
fallas
escalables
tratan
principales
cuestio-
nes
crearlos
incluyendo
arquitectura
servidor
bandas
disco
di-
rectivas
colocación
balanceo
cargas
redundancia
protocolos
sincronización
Leslie
colaboradores
The
Design
and
Implementation
of
an
Operating
System
to
Support
Dis-
tributed
Multimedia
Applications
intentos
implementar
multimedia
basado
agregar
características
sistema
operativo
existente
método
alternativo
empezar
describe
1010
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.1
SUGERENCIAS
CONTINUAR
LECTURA
1011
crear
sistema
operativo
multimedia
cero
necesidad
compatible
resultado
diseño
distinto
sistemas
convencionales
Sitaram
Multimedia
Servers
servidores
multimedia
diferencias
comparación
servidores
ar-
chivos
regulares
autores
analizan
diferencias
detalle
especial
áreas
pla-
nificación
subsistema
almacenamiento
caché
14.1.8
Sistemas
procesadores
Ahmad
Gigantic
Clusters
Where
Are
They
and
What
Are
They
Doing
lugar
darse
idea
multicomputadoras
avanzadas
Describe
idea
muestra
generalidades
sistemas
encuen-
tran
operación
actualidad
funcionamiento
ley
Moore
razonable
tamaños
mencionan
duplicarán
años
Dubois
colaboradores
Synchronization
Coherence
and
Event
Ordering
in
Multiprocessors
tutorial
sincronización
sistemas
multiprocesadores
memoria
compartida
ideas
aplican
forma
sistemas
procesador
memoria
dis-
tribuida
Geer
For
Programmers
Multicore
Chips
Mean
Multiple
Challenges
chips
multicore
estén
listos
programadores
software
re-
sultado
listos
consecuencia
programación
chips
presenta
de-
safíos
obtener
herramientas
adecuadas
dividir
trabajo
pequeñas
piezas
probar
resultados
Kant
Mohapatra
Internet
Data
Centers
centros
datos
Internet
multicomputadoras
masivas
esteroides
contienen
decenas
cientos
miles
computadoras
trabajan
aplicación
escalabilidad
mantenimiento
energía
cuestiones
importantes
ar-
tículo
forma
introducción
tema
presenta
artículos
adicionales
Kumar
colaboradores
Heterogeneous
Chip
Multiprocessors
chips
multinúcleo
utilizan
computadoras
escritorio
simétricos
núcleos
idénticos
aplicaciones
CMPs
heterogéneos
utilizan
núcleos
cálculos
decodificación
video
audio
etcétera
artículo
analizan
cuestiones
relacionadas
CMPs
heterogéneos
Kwok
Ahmad
Static
Scheduling
Algorithms
for
Allocating
Directed
Task
Graphs
to
Multipro-
cessors
planificación
tareas
óptima
multicomputadora
multiprocesador
cuan-
do
conocen
características
trabajos
antemano
problema
planifi-
cación
óptima
requiere
tiempo
calcularse
artículo
autores
analizan
comparan
27
algoritmos
conocidos
atacar
problema
distintas
formas
www
FreeLibros.meRosenblum
Garfinkel
Virtual
Machine
Monitors
Current
Technology
and
Future
Trends
artículo
empieza
historia
monitores
máquinas
virtuales
ana-
liza
actual
CPU
memoria
virtualización
S.
especial
áreas
pro-
blemáticas
relacionadas
elementos
forma
hardware
futuro
aliviar
problemas
Whitaker
colaboradores
Rethinking
the
Design
of
Virtual
Machine
Monitors
mayoría
computadoras
aspectos
estrambóticos
difíciles
virtuali-
zar
artículo
autores
sistema
Denali
paravirtualización
cam-
biar
sistemas
operativos
huéspedes
evitar
utilizar
características
extrañas
necesidad
emularlas
14.1.9
Seguridad
Bratus
What
Hackers
Learn
That
the
Rest
of
Us
Don’t
hackers
preocupa
programadores
regulares
distintas
posturas
APIs
importantes
casos
angula-
res
curiosidad
lector
Léalo
Computer
febrero
2000
tema
edición
Computer
biométrica
artículos
tema
Varían
introducción
tema
pasando
tecnologías
específicas
artículo
cuestiones
legales
privacidad
Denning
Information
Warfare
and
Security
información
convertido
arma
militar
corporativa
participantes
tratan
atacar
sistemas
información
enemigo
proteger
pro-
pios
fascinante
libro
autor
cubre
tema
concebible
relación
estrategia
ofensiva
defensiva
estafa
datos
husmeadores
paquetes
lectura
defi-
nitiva
cualquiera
esté
realmente
interesado
seguridad
computadoras
Ford
Allen
How
Not
to
Be
Seen
virus
spyware
rootkits
sistemas
administración
derechos
digitales
tie-
nen
interés
ocultar
cosas
artículo
presenta
introducción
sigilo
diversas
formas
Hafner
Markoff
Cyberpunk
reportero
New
York
Times
pública
historia
gusano
Internet
Markoff
relata
historias
absorbentes
jóvenes
hackers
irrumpen
computadoras
mundo
Johnson
Jajodia
Exploring
Steganography
Seeing
the
Unseen
1012
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.1
SUGERENCIAS
CONTINUAR
LECTURA
1013
esteganografía
larga
historia
remonta
escritor
debía
rapar
cabeza
mensajero
tatuar
mensaje
cabeza
rasurada
enviarlo
creciera
cabello
frecuencia
técnicas
actuales
espeluznantes
tam-
bién
digitales
introducción
detallada
tema
practica
actualidad
artículo
lugar
adecuado
empezar
Ludwig
The
Little
Black
Book
of
Email
Viruses
desea
escribir
software
antivirus
necesita
comprender
forma
funcionan
virus
nivel
bits
libro
tipos
virus
analiza
ma-
nera
extensiva
proporciona
código
requisito
profundo
conocimiento
programación
lenguaje
ensamblador
Pentium
Mead
Who
is
Liable
for
Insecure
Systems
trabajo
seguridad
computadoras
maneja
perspectiva
técnica
única
Suponga
distribuidores
software
fueran
legalmente
responsables
daños
ocasionados
software
fallido
Cabe
probabilidad
distribuidores
pusieran
atención
seguridad
ponen
actualidad
intriga
idea
Lea
artículo
Milojicic
Security
and
Privacy
seguridad
facetas
incluyendo
sistemas
operativos
redes
implica-
ciones
privacidad
artículo
entrevista
expertos
seguridad
piensan
tema
Nachenberg
Computer
Virus-Antivirus
Coevolution
desarrolladores
antivirus
descubren
forma
detectar
neutrali-
zar
clase
virus
computadora
desarrolladores
adelantan
mejo-
ran
analiza
juego
gato
ratón
partes
virus-antivirus
autor
optimista
escritores
antivirus
ganarán
guerra
malas
noticias
usuarios
computadoras
Pfleeger
Security
in
Computing
4a
edición
publicado
variedad
libros
seguridad
computadoras
mayoría
tratan
seguridad
redes
libro
incluye
capítulos
so-
bre
seguridad
sistemas
operativos
bases
datos
sistemas
distribuidos
Sasse
Red-Eye
Blink
Bendy
Shuffle
and
the
Yuck
Factor
User
Experience
of
Biometric
Air-
port
Systems
autor
experiencias
sistema
reconocimiento
iris
utiliza
aeropuertos
resultados
positivos
Thibadeau
Trusted
Computing
for
Disk
Drives
and
Other
Peripherals
creía
disco
duro
lugar
almacenaban
bits
equi-
vocado
unidad
disco
duro
moderna
poderosa
CPU
megabytes
RAM
ca-
www.FreeLibros.menales
comunicación
ROM
inicio
resumen
sistema
computacio-
nal
completo
punto
sufrir
ataques
necesita
sistema
protección
artículo
analiza
proceso
proteger
disco
duro
14.1.10
Linux
Bovet
Cesati
Understanding
the
Linux
Kernel
libro
análisis
general
kernel
Linux
procesos
ad-
ministración
memoria
sistemas
archivos
señales
IEEE
Information
Technology—Portable
Operating
System
Interface
POSIX
Part
System
Ap-
plication
Program
Interface
API
Language
estándar
partes
legibles
especial
anexo
Rationale
and
Notes
explica
cosas
ventaja
re-
ferencia
documento
estándares
definición
errores
escabulle
error
tipográfico
nombre
macro
proceso
edición
error
oficial
Fusco
The
Linux
Programmers
Toolbox
libro
describe
Linux
usuario
intermedio
alguien
conozca
fun-
damentos
desee
empezar
explorar
funcionan
diversos
programas
Linux
diri-
gido
programadores
C.
Maxwell
Linux
Core
Kernel
Commentary
primeras
400
páginas
libro
contienen
subconjunto
código
kernel
Li-
nux
150
páginas
consisten
comentarios
código
parecido
esti-
libro
clásico
John
Lions
1996
desea
comprender
kernel
Linux
gloriosos
detalles
lugar
apropiado
empezar
cuidado
leer
40,000
líneas
recomendable
persona
14.1.11
Windows
Vista
Cusumano
Selby
How
Microsoft
Builds
Software
preguntado
alguien
escribir
programa
29
millones
líneas
Windows
2000
lograr
funcione
averiguar
utiliza
ciclo
crea-
ción
prueba
Microsoft
administrar
proyectos
software
dé
vistazo
es-
artículo
procedimiento
instructivo
Rector
Newcomer
Win32
Programming
busca
libros
1500
páginas
ofrecen
resumen
escribir
pro-
gramas
Windows
principio
ventanas
dispositivos
sali-
gráfica
entrada
teclado
ratón
impresoras
administración
memoria
bibliotecas
sincronización
temas
Requiere
conocimien-
to
/H11001
H11001
1014
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.1
SUGERENCIAS
CONTINUAR
LECTURA
1015
Russinovich
Solomon
Microsoft
Windows
Internals
4a
edición
desea
aprender
utilizar
Windows
cientos
libros
publicados
desea
funcionamiento
interno
Windows
libro
opción
Cubre
algoritmos
in-
ternos
estructuras
datos
detalle
técnico
considerable
libro
ase-
meja
14.1.12
sistema
operativo
Symbian
Cinque
colaboradores
How
Do
Mobile
Phones
Fail
Failure
Data
Analysis
of
Symbian
Smart
Phones
solía
caso
computadoras
fallaban
diestra
siniestra
teléfonos
funcionaban
teléfonos
simplemente
computadoras
pe-
queñas
pantallas
fallan
software
defectuoso
artículo
analiza
errores
software
provocado
fallas
teléfonos
dispositivos
bolsillo
utilizan
Sym-
bian
Morris
The
Symbian
Architecture
Sourcebook
busca
información
detallada
sistema
operativo
Symbian
lugar
empezar
arquitectura
Symbian
niveles
can-
tidad
detalles
casos
estudio
Stichbury
Jacobs
The
Accredited
Symbian
Developer
interesado
necesita
desarrollar
aplicaciones
teléfonos
PDAs
Symbian
libro
empieza
introducción
lenguaje
necesario
C++
pasa
estructura
sistema
sistema
archivos
redes
cadenas
herramientas
compatibilidad
14.1.13
Principios
diseño
Brooks
The
Mythical
Man
Month
Essays
on
Software
Engineering
Fred
Brooks
diseñadores
sistema
operativo
OS/360
IBM
Aprendió
difícil
funciona
consejos
ofrece
libro
ingenioso
divertido
informativo
válidos
cuarto
siglo
escribió
Cooke
colaboradores
UNIX
and
Beyond
An
Interview
with
Ken
Thompson
Diseñar
sistema
operativo
arte
ciencia
consecuencia
escuchar
expertos
campo
aprender
tema
expertos
experiencia
Ken
Thompson
co-diseñador
UNIX
Inferno
Plan
amplia
en-
trevista
Thompson
muestra
pensamientos
acerca
provenimos
campo
www
FreeLibros.me1016
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
Corbató
On
Building
Systems
That
Will
Fail
conferencia
Premio
Turing
padre
tiempo
compartido
preocupaciones
Brooks
The
Mythical
Man-Month
conclusión
sistemas
complejos
fallarán
instancia
probabilidad
éxito
esencial
evitar
complejidad
esforzarse
simplicidad
elegancia
diseño
Crowley
Operating
Systems
Design-Oriented
Approach
mayoría
libros
texto
sistemas
operativos
describen
conceptos
bási-
cos
procesos
memoria
virtual
ejemplo
ejemplos
diseñar
sistema
operativo
libro
único
dedica
capítulos
tema
Lampson
Hints
for
Computer
System
Design
Butler
Lampson
principales
diseñadores
mundo
sistemas
operativos
inno-
vadores
recolectado
tips
sugerencias
lineamientos
años
experiencia
reunió
entretenido
informativo
artículo
libro
Brooks
lectu-
ra
obligatoria
aspirante
diseñador
sistemas
operativos
Wirth
Plea
for
Lean
Software
Niklaus
Wirth
famoso
experimentado
diseñador
sistemas
argumenta
softwa-
re
simplificado
eficiente
base
conceptos
simples
desorden
representa
mayoría
software
comercial
expresar
opinión
analiza
sistema
Obe-
ron
sistema
operativo
orientado
redes
basado
GUI
cabe
200
KB
incluyendo
compilador
Oberon
editor
texto
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
AARAJ
N.
RAGHUNATHAN
A.
RA
VI
S.
JHA
N.K.
Energy
and
Execution
Time
Analysis
of
Software-Based
Trusted
Platform
Module
Proc
Conf
On
Design
Automation
and
Test
in
Europe
IEEE
pp
1128
1133
2007
ABDEL-HAMID
T.
MADNICK
S.:Software
Project
Dynamics
An
Integrated
Approach
Upper
Sadd-
River
NJ
Prentice
Hall
1991
ABDELHAFEZ
M.
RILEY
G.
COLE
R.G.
PHAMDO
N.
Modeling
and
Simulation
of
TCP
MA-
NET
Worms
Proc
21st
Int’l
Workshop
on
Principles
of
Advanced
and
Distributed
Simulation
IEEE
pp
123
130
2007
ABRAM-PROFETA
E.L.
SHIN
K.G.
Providing
Unrestricted
VCR
Functions
in
Multicast
Video-on-
Demand
Servers
Proc
Int’l
Conf
on
Multimedia
Comp
Syst
IEEE
pp
66
75
1998
ACCETTA
M.
BARON
R.
GOLUB
D.
RASHID
R.
TEV
ANIAN
A.
YOUNG
M.:“Mach
New
Kernel
Foundation
for
UNIX
Development
Proc
Summer
1986
USENIX
Conf
USENIX
pp
93
112
1986
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1017
ADAMS
G.B.
III
AGRA
D.P.
SIEGEL
H.J.:“A
Survey
and
Comparison
of
Fault-Tolerant
Mul-
tistage
Interconnection
Networks
Computer
vol.
20
pp
14
27
junio
1987
ADAMS
K.
AGESON
Comparison
of
Software
and
Hardware
Techniques
for
X86
Virtualiza-
tion
Proc
12th
Int’l
Conf
on
Arch
Support
for
Programming
Languages
and
Operating
Systems
ACM
pp
13
2006
ADYA
A.
BOLOSKY
W.J.
CASTRO
M.
CERMAK
C.
CHAIKEN
R.
DOUCEUR
J.R.
LORCH
J.R.
THEIMER
M.
ATTENHOFER
R.P.:“FARSITE
Federated
Available
and
Re-
liable
Storage
for
an
Incompletely
Trusted
Environment
Proc
Fifth
Symp
on
Operating
System
De-
sign
and
Implementation
USENIX
pp
15
2002
AGARW
R.
STOLLER
S.D.
Run-Time
Detection
of
Potential
Deadlocks
for
Programs
with
Locks
Semaphores
and
Condition
Variables
Proc
2006
Workshop
on
Parallel
and
Distributed
Sys-
tems
ACM
pp
51
60
2006
AGRA
D.
BAKTIR
S.
KARAKOYUNLU
D.
ROHATGI
P.
SUNAR
B.:“Trojan
Detection
Using
IC
Fingerprinting
Proc
2007
IEEE
Symp
on
Security
and
Privacy
IEEE
pp
296
310
ma-
2007
AHMAD
I.
Gigantic
Clusters
Where
Are
They
and
What
Are
They
Doing
IEEE
Concurrency
vol.
pp
83
85
abril-junio
2000
AHN
B.-S.
SOHN
S.-H.
KIMM
S.-Y.
CHA
G.-I
BAEK
Y,-C.
JUNG
S.-I.
KIM
M.-J.
Imple-
mentation
and
Evaluation
of
EXT3NS
Multimedia
File
System
Proc
12th
Annual
Int´l
Conf
on
Mul-
timedia
ACM
pp
588
595
2004
ALBERS
S.
FA
VRHOLDT
L.M.
GIEL
O.:“On
Paging
with
Locality
of
Reference
Proc
34th
ACM
Symp
of
Theory
of
Computing
ACM
pp
258
267
2002
AMSDEN
Z.
ARAI
D.
HECHT
D.
HOLLER
A.
SUBRAHMANYAM
P.:“VMI
An
Interface
for
Paravirtualization
Proc
2006
Linux
Symp
2006
ANAGNOSTAKIS
K.G.
SIDIROGLOU
S.
AKRITIDIS
P.
XINIDIS
K.
MARKATOS
E.
KE-
ROMYTIS
A.D.
Deflecting
Targeted
Attacks
Using
Shadow
Honeypots
Proc
14th
USENIX
Secu-
rity
Symp
USENIX
p.
2005
ANDERSON
R.
Cryptography
and
Competition
Policy
Issues
with
Trusted
Computing
Proc
ACM
Symp
on
Principles
of
Distributed
Computing
ACM
pp
10
2003
ANDERSON
T.E.
The
Performance
of
Spin
Lock
Alternatives
for
Shared-Memory
Multiprocessors
IEEE
Trans
on
Parallel
and
Distr
Systems
vol.
pp
16
enero
1990
ANDERSON
T.E.
BERSHAD
B.N.
LAZOWSKA
E.D.
LEVY
H.M.
Scheduler
Activations
Ef-
fective
Kernel
Support
for
the
User-level
Management
of
Parallelism
ACM
Trans
on
Computer
Sys-
tems
vol.
10
pp
53
79
febrero
1992
ANDREWS
G.R.
Concurrent
Programming—Principles
and
Practice
Redwood
City
CA
Benjamin-
/Cummings
1991
ANDREWS
G.R.
SCHNEIDER
F.B.
Concepts
and
Notations
for
Concurrent
Programming
Com-
puting
Surveys
vol.
15
pp
43
marzo
1983
www
FreeLibros.me1018
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
ARNAB
A.
HUTCHISON
A.
Piracy
and
Content
Protection
in
the
Broadband
Age
Proc
S.
African
Telecomm
Netw
And
Appl
Conf
2006
ARNAN
R.
BACHMAT
E.
LAM
T.K.
MICHEL
R.
Dynamic
Data
Reallocation
in
Disk
Arrays
ACM
Trans
on
Storage
vol.
Art
marzo
2007
ARON
M.
DRUSCHEL
P.
Soft
Timers
Efficient
Microsecond
Software
Timer
Support
for
Network
Processing
Proc
17th
Symp
on
Operating
Systems
Principles
ACM
pp
223
246
1999
ASRIGO
K.
LITTY
L.
LIE
D.
Using
VMM-Based
Sensors
to
Monitor
Honeypots
Proc
ACM
U-
SENIX
Int’l
Conf
on
Virtual
Execution
Environments
CAM
pp
13
23
2006
BACHMAT
E.
BRA
VERMAN
.:“Batched
Disk
Scheduling
with
Delays
ACM
SIGMETRICS
Per-
formance
Evaluation
Rev
vol.
33
pp
36
41
2006
BAKER
F.T:“Chief
Programmer
Team
Management
of
Production
Programming
IBM
Systems
Journal
vol.
11
p.
1972
BAKER
M.
SHAH
M.
ROSENTHAL
D.S.H.
ROUSSOPOULOS
M.
MANIATIS
P.
GIULI
T.J.
BUNGALE
P.:“A
Fresh
Look
at
the
Reliability
of
Long-Term
Digital
Storage
Proc
Eurosys
2006
ACM
pp
221
234
2006
BALA
K.
KAASHOEK
M.F.
WEIHL
W.:“Software
Prefetching
and
Caching
for
Translation
Looka-
side
Buffers
Proc
First
Symp
on
Operating
System
Design
and
Implementation
USENIX
pp
243
254
1994
BALL
T.
BOUNIMOV
E.
COOK
B.
LEVIN
LICHTENBERG
J.
McGARVEY
C.
ONDRU-
SEK
B.
RAJAMANI
S.K.
USTUNER
A.
Thorough
Static
Analysis
of
Device
Drivers
Proc
Eurosys
2006
ACM
pp
73
86
2006
BARATTO
R.A.
KIM
L.N.
NIEH
J.
THINC
Virtual
Display
Architecture
for
Thin-Client
Com-
puting
Proc
20th
Symp
on
Operating
System
Principles
ACM
pp
277
290
2005
BARHAM
P.
DRAGOVIC
B.
FRASER
K.
HAND
S.
HARRIS
T.
HO
A.
NEUGEBAUER
R.
PRATT
L.
ARFIELD
A.:“Xen
and
the
Art
of
Virtualization
Proc
19th
Symp
on
Operating
Systems
Principles
ACM
pp
164
177
2003
BARNI
M.
Processing
Encrypted
Signals
New
Frontier
for
Multimedia
Security
Proc
Eighth
Works-
hop
on
Multimedia
and
Security
ACM
pp
10
2006
BARWINSKI
M.
IRVINE
C.
LEVIN
T.
Empirical
Study
of
Drive-By-Download
Spyware
Proc
Int’l
Conf
on
I-Warfare
and
Security
Academic
Confs
Int’l
2006
BASH
C.
FORMAN
G.
Cool
Job
Allocation
Measuring
the
Power
Savings
of
Placing
Jobs
at
Coo-
ling-Efficient
Locations
in
the
Data
Center
Proc
Annual
Tech
Conf
USENIX
pp
363
368
2007
BASILLI
.R.
PERRICONE
B.T.:“Software
Errors
and
Complexity
An
Empirical
Study
Commun
of
the
ACM
vol.
27
pp
42
52
enero
1984
BAYS
C.
Comparison
of
Next-Fit
First-Fit
and
Best-Fit
Commun
of
the
ACM
vol.
20
pp
191
192
marzo
1977
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1019
BELL
D.
PADULA
L.
Secure
Computer
Systems
Mathematical
Foundations
and
Model
Infor-
técnico
MTR
2547
v2
Mitre
Corp
noviembre
1973
BEN-ARI
M.
Principles
of
Concurrent
Programming
Upper
Saddle
River
NJ
Prentice
Hall
Internatio-
nal
1982
BENSALEM
S.
FERNANDEZ
J.-C.
VELUND
K.
MOUNIER
L.
Confirmation
of
Deadlock
Potentials
Detected
by
Runtime
Analysis
Proc
2006
Workshop
on
Parallel
and
Distributed
Systems
ACM
pp
41
50
2006
BERGADANO
F.
GUNETTI
D.
PICARDI
C.:“User
Authentication
Through
Keystroke
Dynamics
ACM
Trans
on
Inf
and
System
Security
vol.
pp
367
397
noviembre
2002
BHARGA
V-SPANTZEL
A.
SQUICCIARINI
A.
BERTINO
E.:“Privacy
Preserving
Multifactor
Aut-
hentication
with
Biometrics
Proc
Second
ACM
Workshop
on
Digital
Identify
Management
ACM
pp
63
72
2006
BHOEDJANG
R.A.F.:“Communication
Arch
for
Parallel-Programming
Systems
tesis
Ph
D.
Vrije
Uni-
versiteit
Amsterdam
Países
Bajos
2000
BHOEDJANG
R.A.F.
RUHL
T.
BAL
H.E.
User-Level
Network
Interface
Protocols
Computer
vol.
31
pp
53
60
noviembre
1998
BHUYAN
L.N.
YANG
Q.
AGRA
D.P.:“Performance
of
Microprocessor
Interconnection
Net-
works
Computer
vol.
22
pp
25
37
febrero
1989
BIBA
K.
Integrity
Considerations
for
Secure
Computer
Systems
Informe
técnico
76-371
División
Sistemas
Electrónicos
Fuerza
Aérea
EE.UU.
1977
BIRRELL
A.
ISARD
M.
THACKER
C.
WOBBER
T.
Design
for
High-Performance
Flash
Disks
ACM
SIGOPS
Operating
Systems
Rev
vol.
41
pp
88
93
abril
2007
BIRRELL
A.D.
NELSON
B.J.
Implementing
Remote
Procedure
Calls
CM
Trans
on
Computer
Systems
vol.
pp
39
59
febrero
1984
BISHOP
M.
FRINCKE
D.A.
Who
Owns
Your
Computer
IEEE
Security
and
Privacy
vol.
pp
61
63
2006
BOEHM
B.
Software
Engineering
Economics
Upper
Saddle
River
NJ
Prentice
Hall
1981
BORN
G.
Inside
the
Microsoft
Windows
98
Registry
Redmond
WA
Microsoft
Press
1998
BOVET
D.P.
CESATI
M.
Understanding
the
Linux
Kernel
Sebastopol
CA
O’Reilly
Associates
2005
BRADFORD
R.
KOTSOVINOS
E.
FELDMANN
A.
SCHIOBERG
H.
Live
Wide
Area
Migra-
tion
of
Virtual
Machines
Including
Local
Persistent
State
Proc
ACM
USENIX
Conf
on
Virtual
Exe-
cution
Environments
ACM
pp
169
179
2007
BRATUS
S.
What
Hackers
Learn
That
the
Rest
of
Us
Don’t
Notes
on
Hacker
Curriculum
IEEE
Secu-
rity
and
Privacy
vol.
pp
72
75
julio
agosto/2007
www
FreeLibros.me1020
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
BRINCH
HANSEN
P.
The
Programming
Language
Concurrent
Pascal
IEEE
Trans
on
Software
Engi-
neering
vol.
SE-1
pp
199
207
junio
1975
BRISOLARA
L.
S.
GUERIN
X.
CARRO
L.
REISS
R.
CHAE
S.
JERRAYA
A.:“Redu-
cing
Fine-Grain
Communication
Overhead
in
Multithread
Code
Generation
for
Heterogeneous
MP-
SoC
Proc
10th
Int’l
Workshop
on
Software
and
Compilers
for
Embedded
Systems
ACM
pp
81
89
2007
BROOKS
F.P.
Jr.:The
Mythical
Man-Month
Essays
on
Software
Engineering
Reading
MA
Addison-
Wesley
1975
BROOKS
F.P.
Jr
Silver
Bullet—Essence
and
Accident
in
Software
Engineering
Computer
vol.
20
pp
10
19
abril
1987
BROOKS
F.P.
Jr.:The
Mythical
Man-Month
Essays
on
Software
Engineering
edición
20
aniversario
Reading
MA
Addison-Wesley
1995
BRUSCHI
D.
MARTIGNONI
MONGA
M.
Code
Normalization
for
Self-Mutating
Malware
IEEE
Security
and
Privacy
vol.
pp
46
54
marzo
abril
2007
BUGNION
E.
DEVINE
S.
GOVIL
K.
ROSENBLUM
M.
Disco
Running
Commodity
Operating
Systems
on
Scalable
Multiprocessors
ACM
Trans
on
Computer
Systems
vol.
15
pp
412
447
no-
viembre
1997
BULPIN
J.R.
PRATT
I.A.:“Hyperthreading-Aware
Process
Scheduling
Heuristics
Proc
Annual
Tech
Conf
USENIX
pp
399
403
2005
BURNETT
N.C.
BENT
J.
ARPACI-DUSSEAU
A.C.
ARPACI-DUSEAU
R.H.:“Exploiting
Gray-
Box
Knowledge
of
Buffer-Cache
Management
Proc
Annual
Tech
Conf
USENIX
pp
29
44
2002
BURTON
A.N.
KELLY
P.H.J.:“Performance
Prediction
of
Paging
Workloads
Using
Lightweight
Tra-
cing
Proc
Int’l
Parallel
and
Distributed
Processing
Symp
IEEE
pp
278
285
2003
BYUNG-HYUN
Y.
HUANG
Z.
CRANEFIELD
S.
PURVIS
M.:“Homeless
and
Home-Based
Lazy
Release
Consistency
protocols
on
Distributed
Shared
Memory
Proc
27th
Australasian
Conf
on
Com-
puter
Science
Soc
Comp
Australiana
pp
117
123
2004
CANT
C.:Writing
Windows
WDM
Device
Drivers
Master
the
New
Windows
Driver
Model
Lawrence
KS
CMP
Books
2005
CARPENTER
M.
LISTON
T.
SKOUDIS
E.
Hiding
Virtualization
from
Attackers
and
Malware
IEEE
Security
and
Privacy
vol.
pp
62
65
mayo
junio
2007
CARR
R.W.
HENNESSY
J.L.
WSClock—A
Simple
and
Effective
Algorithm
for
Virtual
Memory
Management
Proc
Eighth
Symp
on
Operating
Systems
Principles
ACM
pp
87
95
1981
CARRIERO
N.
GELERNTER
D.
The
Net’s
Linda
Kernel
ACM
Trans
on
Computer
Systems
vol.
pp
110
129
mayo
1986
CARRIERO
N.
GELERNTER
D.
Linda
in
Context
Commun
of
the
ACM
vol.
32
pp
444
458
abril
1989
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1021
CASCA
C.
DUESTERW
ALD
E.
SWEENEY
P.F.
WISNIEWSKY
R.W.:“Multiple
Page
Size
Modeling
and
Optimization
Int’l
Conf
on
Parallel
Arch
and
Compilation
Techniques
IEEE
339
349
2005
CASTRO
M.
COSTA
M.
HARRIS
T.
Securing
Software
by
Enforcing
Data-flow
Integrity
Proc
Seventh
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
147
160
2006
CAUDILL
H.
GA
VRILOVSKA
A.
Tuning
File
System
Block
Addressing
for
Performance
Proc
44th
Annual
Southeast
Regional
Conf
ACM
pp
11
2006
CERF
C.
NA
ASKY
.:The
Experts
Speak
York
Random
House
1984
CHANG
L.-P.:“On
Efficient
Wear-Leveling
for
Large-Scale
Flash-Memory
Storage
Systems
Proc
ACM
Symp
on
Applied
Computing
ACM
pp
1126
1130
2007
CHAPMAN
M.
HEISER
G.
Implementing
Transparent
Shared
Memory
on
Clusters
Using
Virtual
Machines
Proc
Annual
Tech
Conf
USENIX
pp
383
386
2005
CHASE
J.S.
LEVY
H.M.
FEELEY
M.J.
LAZOWSKA
E.D.
Sharing
and
Protection
in
Single-
Address-Space
Operating
System
ACM
Trans
on
Computer
Systems
vol.
12
pp
271
307
noviem-
bre
1994
CHATTOPADHYAY
S.
LI
K.
BHANDARKAR
S.:“FGS-MR
MPEG4
Fine
Grained
Scalable
Mul-
ti-Resolution
Video
Encoding
for
Adaptive
Video
Streaming
Proc
ACM
Int’l
Workshop
on
Network
and
Operating
System
Support
for
Digital
Audio
and
Video
ACM
2006
CHEN
P.M.
NG
W.T.
CHANDRA
S.
AYCOCK
C.
RAJAMANI
G.
LOWELL
D.:“The
Rio
Fi-
Cache
Surviving
Operating
System
Crashes
Proc
Seventh
Int’l
Conf
on
Arch
Support
for
Pro-
gramming
Languages
and
Operating
Systems
ACM
pp
74
83
1996
CHEN
S.
THAPAR
M.
Novel
Video
Layout
Strategy
for
Near-Video-on-Demand
Servers
Prof.
Int’l
Conf
on
Multimedia
Computing
and
Systems
IEEE
pp
37
45
1997
CHEN
S.
TOWSLEY
D.:“A
Performance
Evaluation
of
RAID
Architectures
IEEE
Trans
on
Compu-
ters
vol.
45
pp
1116
1130
octubre
1996
CHEN
S.
GIBBONS
P.B.
KOZUCH
M.
LIASKOVITIS
AILAMAKI
A.
BLELLOCH
G.E.
FALSAFI
B.
FIX
L.
HARDA
VELLAS
N.
MOWRY
T.C.
WILKERSON
C.:“Scheduling
Th-
reads
for
Constructive
Cache
Sharing
on
CMPs
Proc
ACM
Symp
on
Parallel
Algorithms
and
Arch
ACM
pp
105
115
2007
CHENG
J.
WONG
S.H.Y.
YANG
H.
LU
S.
SmartSiren
Virus
Detection
and
Alert
for
Smartpho-
nes
Proc
Fifth
Int’l
Conf
on
Mobile
Systems
Appls
and
Services
ACM
pp
258
271
2007
CHENG
N.
JIN
H.
YUAN
Q.:“OMFS
An
Object-Oriented
Multimedia
File
System
for
Cluster
Strea-
ming
Server
Proc
Eighth
Int’l
Conf
on
High-Performance
Computing
in
Asia-Pacific
Region
IEEE
pp
532
537
2005
CHERITON
D.R.
An
Experiment
Using
Registers
for
Fast
Message-Based
Interprocess
Communica-
tion
ACM
SIGOPS
Operating
Systems
Rev
vol.
18
pp
12
20
octubre
1984
www
FreeLibros.me1022
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
CHERITON
D.R.
The
Distributed
System”,Commun
of
the
ACM
vol
31
pp
314
333
marzo
1988
CHERKASOV
L.
GARDNER
R.:“Measuring
CPU
Overhead
for
Processing
in
the
Xen
Virtual
Machine
Monitor
Proc
Annual
Tech
Conf
USENIX
pp
387
390
2005
CHERVENAK
A.
VELLANKI
KURMAS
Z.:“Protecting
File
Systems
Survey
of
Backup
Tech-
niques
Proc
15th
IEEE
Symp
on
Mass
Storage
Systems
IEEE
1998
CHIANG
M.-L.
HUANG
J.-S.
Improving
the
Performance
of
Log-Structured
File
Systems
with
Adaptive
Block
Rearrangement
Proc
2007
ACM
Symp
on
Applied
Computing
ACM
pp
1136
1140
2007
CHILDS
S.
INGRAM
D.
The
Linux-SRT
Integrated
Multimedia
Operating
System
Bringing
QoS
to
the
Desktop
Proc
Seventh
IEEE
Real-Time
Tech
and
Appl
Symp
IEEE
pp
135
141
2001
CHOU
A.
YANG
J.
CHELF
B.
HALLEM
S.
ENGLER
D.:“An
Empirical
Study
of
Operating
Sys-
tem
Errors
Proc
18th
Symp
on
Operating
Systems
Design
and
Implementation
ACM
pp
73
88
2001
CHOW
T.C.K.
ABRAHAM
J.A.
Load
Balancing
in
Distributed
Systems
IEEE
Trans
on
Software
Engineering
vol.
SE-8
pp
401
412
julio
1982
CINQUE
M.
COTRONEO
D.
KALBARCZYK
Z.
IYER
RA
VISHANKAR
K.:“How
Do
Mobile
Phones
Fail
Failure
Data
Analysis
of
the
Symbian
Smart
Phones
Proc
37th
Annual
Int’l
Conf
on
Dependable
Systems
and
Networks
IEEE
pp
585
594
2007
COFFMAN
E.G.
ELPHICK
M.J.
SHOSHANI
A.
System
Deadlocks
Computing
Surveys
vol.
pp
67
78
junio
1971
COOKE
D.
URBAN
J.
HAMILTON
S.
Unix
and
Beyond
An
Interview
with
Ken
Thompson
Computer
vol.
32
pp
58
64
mayo
1999
CORBATO
F.J.:“On
Building
Systems
That
Will
Fail
Commun
of
the
ACM
vol.
34
pp
72
81
junio
1991
CORBATO
F.J.
MERWIN-DAGGET
M.
DALEY
R.C.
An
Experimental
Time-Sharing
System
Proc
AFIPS
Fall
Joint
Computer
Conf
AFIPS
pp
335
344
1962
CORBATO
F.J.
SALTZER
J.H.
CLINGEN
C.T.:“MULTICS—The
First
Seven
Years
Proc
AFIPS
Spring
Joint
Computer
Conf
AFIPS
pp
571
583
1972
CORBATO
F.J.
VYSSOTSKY
.A.:“Introduction
and
Overview
of
the
MULTICS
System
Proc
AFIPS
Fall
Joint
Computer
Conf
AFIPS
pp
185
196
1965
CORNELL
B.
DINDA
P.A.
BUSTAMANTE
F.E.
Wayback
User-Level
Versioning
File
System
for
Linux
Proc
Annual
Tech
Conf
USENIX
pp
19
28
2004
COSTA
M.
CROWCROFT
J.
CASTRO
M.
ROWSTRON
A.
ZHOU
L.
ZHANG
L.
BARHAM
P.
Vigilante
End-to-End
Containment
of
Internet
Worms
Proc
20th
Symp
on
Operating
System
Prin
ACM
pp
133
147
2005
COURTOIS
P.J.
HEYMANS
F.
PARNAS
D.L.
Concurrent
Control
with
Readers
and
Writers
Commun
of
the
ACM
vol.
10
pp
667
668
octubre
1971
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1023
COX
L.P.
MURRAY
C.D.
NOBLE
B.D.
Pastiche
Making
Backup
Cheap
and
Easy
Proc
Fifth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
285
298
2002
CRANOR
C.D.
PARULKAR
G.M.
The
UVM
Virtual
Memory
System
Proc
Annual
Tech
Conf
USENIX
pp
117
130
1999
CROWLEY
C.
Operating
Systems
Design-Oriented
Approach
Chicago
Irwin
1997
CUSUMANO
M.A.
SELBY
R.W.
How
Microsoft
Builds
Software
Commun
of
the
ACM
vol.
40
pp
53
61
junio
1997
DABEK
F.
KAASHOEK
M.F.
KARGET
D.
MORRIS
R.
STOICA
I.
Wide-Area
Cooperative
Storage
with
CFS
Proc
18th
Symp
on
Operating
Systems
Principles
ACM
pp
202-215
2001
DALEY
R.C.
DENNIS
J.B.
Virtual
Memory
Process
and
Sharing
in
MULTICS
Commun
of
the
ACM
vol.
11
pp
306
312
mayo
1968
DALTON
A.B.
ELLIS
C.S.:“Sensing
User
Intention
and
Context
for
Energy
Management
Proc
Ninth
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
151
156
2003
DASIGENIS
M.
KROUPIS
N.
ARGYRIOU
A.
TATAS
K.
SOUDRIS
D.
THANAILAKIS
A.
ZERV
AS
N.:“A
Memory
Management
Approach
for
Efficient
Implementation
of
Multimedia
Kernels
on
Programmable
Architectures
Proc
IEEE
Computer
Society
Workshop
on
VLSI
IEEE
pp
171
177
2001
DAUGMAN
J.
How
Iris
Recognition
Works
IEEE
Trans
on
Circuits
and
Systems
for
Video
Tech
vol.
14
pp
21
30
enero
2004
DAVID
F.M.
CARLYLE
J.C.
CAMPBELL
R.H.:“Exploring
Recovery
from
Operating
System
Loc-
kups
Proc
Annual
Tech
Conf
USENIX
pp
351
356
2007
DEAN
J.
GHEMA
AT
S.:“MapReduce
Simplified
Data
Processing
on
Large
Clusters
Proc
Sixth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
137
150
2004
DENNING
D.
Lattice
Model
of
Secure
Information
Flow
Commun
of
the
ACM
vol.
19
pp
236
243
1976
DENNING
D.
Information
Warfare
and
Security
Reading
MA
Addison-Wesley
1999
DENNING
P.J.
The
Working
Set
Model
for
Program
Behavior
Commun
of
the
ACM
vol.
11
pp
323
333
1968a
DENNING
P.J.
Thrashing
Its
Causes
and
Prevention
Proc
AFIPS
National
Computer
Conf
AFIPS
pp
915
922
1968b
DENNING
P.J.
Virtual
Memory
Computing
Surveys
vol.
pp
153
189
septiembre
1970
DENNING
P.J.:“Working
Sets
Past
and
Present
IEEE
Trans
on
Software
Engineering
vol.
SE-6
pp
64
84
enero
1980
DENNIS
J.B.
AN
HORN
E.C.:“Programming
Semantics
for
Multiprogrammed
Computations
Com-
mun
of
the
ACM
vol.
pp
143
155
marzo
1966
www
FreeLibros.meDIFFIE
W.
HELLMAN
M.E.:“New
Directions
in
Cryptography
IEEE
Trans
on
Information
Theory
vol.
IT-22
pp
644
654
noviembre
1976
DIJKSTRA
E.W.
Co-operating
Sequential
Processes
Programming
Languages
Genuys
F.
Ed
Londres
Academic
Press
1965
DIJKSTRA
E.W.
The
Structure
of
THE
Multiprogramming
System
Commun
of
the
ACM
vol.
11
pp
341
346
mayo
1968
DING
X.
JIANG
S.
CHEN
F.
buffer
cache
management
scheme
exploiting
both
Temporal
and
Spatial
localities
ACM
Trans
on
Storage
vol.
Art
junio
2007
DUBOIS
M.
SCHEURICH
C.
BRIGGS
F.A.
Synchronization
Coherence
and
Event
Ordering
in
Multiprocessors
Computer
vol.
21
pp
21
febrero
1988
EAGER
D.L
LAZOWSKA
E.D.
ZAHORJAN
J.
Adaptive
Load
Sharing
in
Homogeneous
Distri-
buted
Systems
IEEE
Trans
on
Software
Engineering
vol.
SE-12
pp
662
675
mayo
1986
EDLER
J.
LIPKIS
J.
SCHONBERG
E.
Process
Management
for
Highly
Parallel
UNIX
Systems
Proc
USENIX
Workshop
on
UNIX
and
Supercomputers
USENIX
pp
17
septiembre
1988
EFSTATHOPOULOS
P.
KROHN
M.
ANDEBOGART
S.
FREY
C.
ZIEGLER
D.
KOHLER
E.
MAZIERES
D.
KAASHOEK
F.
MORRIS
R.
Labels
and
Event
Processes
in
the
Asbes-
tos
Operating
System
Proc
20th
Symp
on
Operating
Systems
Principles
ACM
pp
17
30
2005
EGAN
J.L.
TEIXEIRA
T.J.
Writing
UNIX
Device
Driver
2a
edición
York
John
Wiley
1992
EGELE
M.
KRUEGEL
C.
KIRDA
E.
YIN
H.
SONG
D.:“Dynamic
Spyware
Analysis
Proc
An-
nual
Tech
Conf
USENIX
pp
233
246
2007
EGGERT
L.
TOUCH
J.D.:“Idletime
Scheduling
with
Preemption
Intervals
Proc
20th
Symp
on
Ope-
rating
Systems
Principles
ACM
pp
249
262
2005
GAMAL
A.
Public
Key
Cryptosystem
and
Signature
Scheme
Based
on
Discrete
Logarithms
IEEE
Trans
on
Information
Theory
vol.
IT-31
pp
469
472
julio
1985
ELPHINSTONE
K.
KLEIN
G.
DERRIN
P.
ROSCOE
T.
HEISER
G.
Towards
Practical
Ve-
rified
Kernel
Proc
11th
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
117
122
2007
ENGLER
D.R.
CHELF
B.
CHOU
A.
HALLEM
S.
Checking
System
Rules
Using
System-Speci-
fic
Programmer-Written
Compiler
Extensions
Proc
Fourth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
16
2000
ENGLER
D.R.
GUPTA
S.K.
KAASHOEK
M.F.:“A
VM
Application-Level
Virtual
Memory
Proc
Fifth
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
72
77
1995
ENGLER
D.R.
KAASHOEK
M.F.
Exterminate
All
Operating
System
Abstractions
Proc
Fifth
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
78
83
1995
1024
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1025
ENGLER
D.R.
KAASHOEK
M.F.
O’TOOLE
J.
Jr
Exokernel
An
Operating
System
Architectu-
re
for
Application-Level
Resource
Management
Proc
15th
Symp
on
Operating
Systems
Principles
ACM
pp
251
266
1995
ERICKSON
J.S.
Fair
Use
DRM
and
Trusted
Computing
Commun
of
the
ACM
vol.
46
pp
34
39
2003
ETSION
Y.
TSAFIR
D.
FEITELSON
D.G.:“Effects
of
Clock
Resolution
on
the
Scheduling
od
Inte-
ractive
and
Soft
Real-Time
Processes
Proc
Int’l
Conf
on
Measurement
and
Modeling
of
Computer
Systems
ACM
pp
172
183
2003
ETSION
Y.
TSAFIR
D.
FEITELSON
D.G.:“Desktop
Scheduling
How
Can
We
Know
What
the
User
Wants
Proc
ACM
Int’l
Workshop
on
Network
and
Operating
System
Support
for
Digital
Audio
and
Video
ACM
pp
110
115
2004
ETSION
Y.
TSAFIR
D.
FEITELSON
D.G.
Process
Prioritization
Using
Output
Production
Sche-
duling
for
Multimedia
CM
Trans
on
Multimedia
Computing
and
Applications
vol.
pp
318
342
noviembre
2006
EVEN
S.
Graph
Algorithms
Potomac
MD
Computer
Science
Press
1979
FABRY
R.S.
Capability-Based
Addressing
Commun
of
the
ACM
vol.
17
pp
403
412
julio
1974
FAN
X.
WEBER
W.-D.
BARROSO
L.-A.
Power
Provisioning
for
Warehouse-Sized
Computer
Proc
34th
Annual
Int’l
Symp
on
Computer
Arch
ACM
pp
13
23
2007
FANDRICH
M.
AIKEN
M.
WBLITZEL
C.
HODSON
O.
HUNT
G.
LARUS
J.R.
LEVI
S.
Language
Support
for
Fast
and
Reliable
Message-Based
Communication
in
Singularity
Proc
Eurosys
2006
ACM
pp
177
190
2006
FASSINO
J.-P.
STEFANI
J.-B.
ALL
J.J.
MULLER
G.:“Think
Software
Framework
for
Component-Based
Operating
System
Kernels
Proc
Annual
Tech
Conf
USENIX
pp
73
86
2002
FEDOROV
A.
SELTZER
M.
SMALL
C.
NUSSBAUM
D.:“Performance
of
Multithreaded
Chip
Multiprocessors
and
Implications
for
Operating
System
Design
Proc
Annual
Tech
Conf
USENIX
pp
395
398
2005
FEELEY
M.J.
MORGAN
W.E.
PIGHIN
F.H.
KARLIN
A.R.
LEVY
H.M.
THEK-KATH
C.A.
Implementing
Global
Memory
Management
in
Workstation
Cluster
Proc
15th
Symp
on
Operating
Systems
Principles
ACM
pp
201
212
1995
FELTEN
E.W.
HALDERMAN
J.A.
Digital
Rights
Management
Spyware
and
Security
IEEE
Se-
curity
and
Privacy
vol.
pp
18
23
enero
febrero
2006
FEUSTAL
E.A.:“The
Rice
Research
Computer—A
Tagged
Architecture
Proc
AFIPS
Conf
AFIPS
1972
FLINN
J.
SATYANARAYANAN
M.
Managing
Battery
Lifetime
with
Energy-Aware
Adaptation
ACM
Trans
on
Computer
Systems
vol.
22
pp
137
179
mayo
2004
FLORENCIO
D.
HERLEY
C.
Large-Scale
Study
of
Web
Password
Habits
Proc
16th
Int’l
Conf
on
the
World
Wide
Web
ACM
pp
657
666
2007
www
FreeLibros.meFLUCKIGER
F.
Understanding
Networked
Multimedia
Upper
Saddle
River
NJ
Prentice
Hall
1995
FORD
B.
BACK
G.
BENSON
G.
LEPREAU
J.
LIN
A.
SHIVERS
O.:“The
Flux
OSkit
Subs-
trate
for
Kernel
and
Language
Research
Proc
17th
Symp
on
Operating
Systems
Principles
ACM
pp
38
51
1997
FORD
B.
HIBLER
M.
LEPREAU
J.
TULLMAN
P.
BACK
G.
CLA
WSON
S.
Microkernels
Meet
Recursive
Virtual
Machines
Proc
Second
Symp
on
Operating
Systems
Design
and
Implemen-
tation
USENIX
pp
137
151
1996
FORD
B.
SUSARLA
S.
CPU
Inheritance
Scheduling
Proc
Second
Symp
on
Operating
Systems
De-
sign
and
Implementation
USENIX
pp
91
105
1996
FORD
R.
ALLEN
W.H.
How
Not
To
Be
Seen
IEEE
Security
and
Privacy
vol.
pp
67
69
ene-
ro
febrero
2007
FOSTER
Globus
Toolkit
Version
Software
for
Service-Oriented
Systems
Int’l
Conf
on
Network
and
Parallel
Computing
IFIP
pp
13
2005
FOTHERINGHAM
J.
Dynamic
Storage
Allocation
in
the
Atlas
Including
an
Automatic
Use
of
Bac-
king
Store
Commun
of
the
ACM
vol.
pp
435
436
octubre
1961
FRANZ
M.
Containing
the
Ultimate
Trojan
Horse
IEEE
Security
and
Privacy
vol.
pp
52
56
ju-
lio-agosto
2007
FRASER
K.
HARRIS
T.
Concurrent
Programming
without
Locks
ACM
Trans
on
Computer
Sys-
tems
vol.
25
pp
61
mayo
2007
FRIEDRICH
R.
ROLIA
J.
Next
Generation
Data
Centers
Trends
and
Implications
Proc
6th
Int’l
Workshop
on
Software
and
Performance
ACM
pp
2007
FUSCO
J.
The
Linux
Programmer’s
Toolbox
Upper
Saddle
River
NJ
Prentice
Hall
2007
GAL
E.
TOLEDO
S.
Transactional
Flash
File
System
for
Microcontrollers
Proc
Annual
Tech
Conf
USENIX
pp
89
104
2005
GANAPATHY
BALAKRISHNAN
A.
SWIFT
M.M.
JHA
S.:“Microdrivers
New
Architectu-
re
for
Device
Drivers
Proc
11th
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
85
90
2007
GANESH
L.
WEATHERSPOON
H.
BALAKRISHNAN
M.
BIRMAN
K.
Optimizing
Power
Consumption
in
Large-Scale
Storage
Systems
Proc
11th
Workshop
on
Hot
Topics
in
Operating
Sys-
tems
USENIX
pp
49
54
2007
GARFINKEL
T.
ADAMS
K.
ARFIELD
A.
FRANKLIN
J.:“Compatibility
is
Not
Transparency
VMM
Detection
Myths
and
Realities
Proc
11th
Workshop
on
Hot
Topics
in
Operating
Systems
USE-
NIX
pp
31
36
2007
GARFINKEL
T.
PFAFF
B.
CHOW
J.
ROSENBLUM
M.
BONEH
D.:“Terra
Virtual
Machine-
Based
Platform
for
Trusted
Computing
Proc
19th
Symp
on
Operating
Systems
Principles
ACM
pp
193
206
2003
1026
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1027
GA
S.
FELTEN
E.W.:“Password
Management
Strategies
for
Online
Accounts
Proc
Second
Symp
on
Usable
Privacy
ACM
pp
44
55
2006
GEER
D.
For
Programmers
Multicore
Chips
Mean
Multiple
Challenges
IEEE
Computer
vol.
40
pp
17
19
septiembre
2007
GEIST
R.
DANIEL
S.
Continuum
of
Disk
Scheduling
Algorithms
ACM
Trans
on
Computer
Sys-
tems
vol.
pp
77
92
febrero
1987
GELERNTER
D.
Generative
Communication
in
Linda
ACM
Trans
on
Programming
Languages
and
Systems
vol.
pp
80
112
enero
1985
GHEMA
AT
S.
GOBIOFF
H.
LEUNG
S.-T.:“The
Google
File
System
Proc
19th
Symp
on
Ope-
rating
Systems
Principles
ACM
pp
29
43
2003
GLEESON
B.
PICOVICI
D.
SKEHILL
R.
NELSON
J.
Exploring
Power
Saving
in
802.11
oIP
Wireless
Links
Proc
2006
Int’l
Conf
on
Commun
and
Mobile
Computing
ACM
pp
779
784
2006
GNAIDY
C.
BUTT
A.R.
HU
Y.C.:“Program-Counter
Based
Pattern
Classification
in
Buffer
Caching
Proc
Sixth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
395
408
2004
GONG
L.
Inside
Java
Platform
Security
Reading
MA
Addison-Wesley
1999
GRAHAM
R.
Use
of
High-Level
Languages
for
System
Programming
Informe
proyecto
MAC
TM-13
M.I.T.
septiembre
1970
GREENAN
K.M.
MILLER
E.L.
Reliability
Mechanisms
for
File
Systems
using
Non-V
olatile
Me-
mory
as
Metadata
Store
Proc
Int’l
Conf
on
Embedded
Software
ACM
pp
178
187
2006
GROPP
W.
LUSK
E.
SKJELLUM
A.:Using
MPI
Portable
Parallel
Programming
with
the
Message
Passing
Interface
Cambridge
MA
M.I.T.
Press
1994
GROSSMAN
D.
SILVERMAN
H.
Placement
of
Records
on
Secondary
Storage
Device
to
Minimi-
ze
Access
Time
Journal
of
the
ACM
vol.
20
pp
429
438
1973
GUMMADI
K.P.
DUNN
R.J.
SARIOU
S.
GRIBBLE
S.
LEVY
H.M.
ZAHORJAN
J.
Measu-
rement
Modeling
and
Analysis
of
Peer-to-Peer
File-Sharing
Workload
Proc
19th
Symp
on
Ope-
rating
Systems
Principles
2003
GURUMURTHI
S.
Should
Disks
Be
Speed
Demons
or
Brainiacs
ACM
SIGOPS
Operating
Systems
Rev
vol.
41
pp
33
36
enero
2007
GURUMURTHI
S.
SIV
ASUBRAMANIAN
A.
KANDEMIR
M.
FRANKE
H.:“Reducing
Disk
Po-
wer
Consumption
in
Servers
with
DRPM
Computer
vol.
36
pp
59
66
diciembre
2003
HACKETT
B.
DAS
M.
ANG
D.
YANG
Z.:“Modular
Checking
for
Buffer
Overflows
in
the
Lar-
ge
Proc
28th
Int’l
Conf
on
Software
Engineering
ACM
pp
232
241
2006
HAND
S.M.
Self-Paging
in
the
Nemesis
Operating
System
Proc
Third
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
73
86
1999
www
FreeLibros.me1028
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
HAND
S.M.
ARFIELD
A.
FRASER
K.
KOTTSOVINOS
E.
MAGENHEIMER
D.:“Are
Vir-
tual
Machine
Monitors
Microkernels
Done
Right
Proc
10th
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
2005
HAERTIG
H.
HOHMUTH
M.
LIEDTKE
J.
SHONBERG
S.
The
Performance
of
Kernel-Based
Systems
Proc
16th
Symp
on
Operating
Systems
Principles
ACM
pp
66
77
1997
HAFNER
K.
MARKOFF
J.
Cyberpunk
York
Simon
and
Schuster
1991
HALDERMAN
J.A.
FELTEN
E.W.:“Lessons
from
the
Sony
CD
DRM
Episode
Proc
15th
USENIX
Security
Symp
USENIX
pp
77
92
2006
HARI
K.
MAYRON
L.
CRISTODOULOU
L.
MARQUES
O.
FURHT
B.
Design
and
Evalua-
tion
of
3D
Video
System
Based
on
H.264
View
Coding
Proc
ACM
Int’l
Workshop
on
Network
and
Operating
System
Support
for
Digital
Audio
and
Video
ACM
2006
HARMSEN
J.J.
PEARLMAN
W.A.
Capacity
of
Steganographic
Channels
Proc
7th
Workshop
on
Multimedia
and
Security
ACM
pp
11
24
2005
HARRISON
M.A.
RUZZO
W.L.
ULLMAN
J.D.
Protection
in
Operating
Systems
Commun
of
the
ACM
vol.
19
pp
461
471
agosto
1976
HART
J.M.
Win32
System
Programming
Reading
MA
Addison-Wesley
1997
HAUSER
C.
JACOBI
C.
THEIMER
M.
WELCH
B.
WEISER
M.
Using
Threads
in
Interacti-
ve
Systems
Case
Study
Proc
14th
Symp
on
Operating
Systems
Principles
ACM
pp
94
105
1993
VENDER
J.W.:“Avoiding
Deadlock
in
Multitasking
Systems
IBM
Systems
Journal
vol.
pp
74
84
1968
HEISER
G.
UHLIG
LEV
ASSEUR
J.:“Are
Virtual
Machine
Monitors
Microkernels
Done
Right
ACM
SIGOPS
Operating
Systems
Rev
vol.
40
pp
95
99
2006
HENCHIRI
O.
JAPKOWICZ
N.
Feature
Selection
and
Evaluation
Scheme
for
Computer
Virus
Detection
Proc
Sixth
Int’l
Conf
on
Data
Mining
IEEE
pp
891
895
2006
HERDER
J.N.
BOS
H.
GRAS
B.
HOMBURG
P.
TANENBAUM
A.S.
Construction
of
Highly
Dependable
Operating
System
Proc
Sixth
European
Dependable
Computing
Conf
pp
12
2006
HICKS
B.
RUEDA
S.
JAEGER
T.
McDANIEL
P.:“From
Trusted
to
Secure
Building
and
Executing
Applications
That
Enforce
System
Security
Proc
Annual
Tech
Conf
USENIX
pp
205
218
2007
HIGHAM
L.
JACKSON
L.
KA
ASH
J:“Specifying
Memory
Consistency
of
Write
Buffer
Multi-
processors
ACM
Trans
on
Computer
Systems
vol.
25
Art
febrero
2007
HILDEBRAND
D.
An
Architectural
Overview
of
QNX
Proc
Workshop
on
Microkernels
and
Other
Kernel
Arch
ACM
pp
113
136
1992
HIPSON
P.D.
Mastering
Windows
2000
Registry
Alameda
CA
Sybex
2000
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1029
HOARE
C.A.R.
Monitors
An
Operating
System
Structuring
Concept
Commun
of
the
ACM
vol.
17
pp
549
557
octubre
1974
Erratum
in
Commun
of
the
ACM
vol.
18
p.
95
febrero
1975
HOHMUTH
M.
HAERTIG
H.
Pragmatic
Nonblocking
Synchronization
in
Real-Time
Systems
Proc
Annual
Tech
Conf
USENIX
pp
217
230
2001
HOHMUTH
M.
PETER
M.
HAERTIG
H.
SHAPIRO
J.
Reducing
TCB
Size
by
Using
Untrus-
ted
Components
Small
Kernels
Versus
Virtual-Machine
Monitors
Proc
11th
ACM
SIGOPS
Euro-
pean
Workshop
ACM
Art
22
2004
HOLT
R.C.:“Some
Deadlock
Properties
of
Computer
Systems
Computing
Surveys
vol.
pp
179
196
septiembre
1972
HOM
J.
KREMER
U.
Energy
Management
of
Virtual
Memory
on
Diskless
Devices
Compilers
and
Operating
Systems
for
Low
Power
Norwell
MA
Kluwer
pp
95
113
2003
HOW
ARD
J.H.
KAZAR
M.J.
MENEES
S.G.
NICHOLS
D.A.
SATYANARAYANAN
M.
SIDE-
BOTHAM
R.N.
WEST
M.J.
Scale
and
Performance
in
Distributed
File
System
ACM
Trans
on
Computer
Systems
vol.
pp
55
81
febrero
1988
HOW
ARD
M.
LEBLANK
D.:Writing
Secure
Code
for
Windows
Vista
Redmond
WA
Microsoft
Press
2006
HUANG
W.
LIU
J.
KOOP
M.
ABALL
B.
PANDA
D.:QNomand
Migrating
OS-Bypass
Networks
in
Virtual
Machines
Proc
ACM
USENIX
Int’l
Conf
on
Virtual
Execution
Environments
ACM
pp
158
168
2007
HUANG
Z.
SUN
C.
PURVIS
M.
CRANEFIELD
S.
View-Based
Consistency
and
False
Sharing
Effect
in
Distributed
Shared
Memory
CM
SIGOPS
Operating
System
Rev
vol.
35
pp
51
60
abril
2001
HUTCHINSON
N.C.
MANLEY
S.
FEDERWISCH
M.
HARRIS
G.
HITZ
D.
KLEIMAN
S.
O’MALLEY
S.:“Logical
vs
Physical
File
System
Backup
Proc
Third
Symp
on
Oper
Systems
De-
sign
and
Impl
USENIX
pp
239
249
1999
IEEE
Information
Technology—Portable
Operating
System
Interface
POSIX
Part
System
Application
Program
Interface
API
Language
York
Instituto
Ingenieros
Eléctricos
Electrónicos
1990
IN
J.
SHIN
I.
KIM
H.
Memory
Systems
SWL
Search-While-Load
Demand
Paging
Scheme
with
NAND
Flash
Memory
Proc
2007
ACM
SIGPLAN
SIGBED
Conf
on
Languages
Compilers
and
Tools
ACM
pp
217
226
2007
ISLOOR
S.S.
MARSLAND
T.A.
The
Deadlock
Problem
An
Overview
Computer
vol.
13
pp
58
78
septiembre
1980
IVENS
K.
Optimizing
the
Windows
Registry
Foster
City
CA
IDG
Books
Worldwide
1998
JAEGER
T.
SAILER
R.
SREENIV
ASAN
Y.
Managing
the
Risk
of
Covert
Information
Flows
in
Virtual
Machine
Systems
Proc
12th
ACM
Symp
on
Access
Control
Models
and
Technologies
ACM
pp
81
90
2007
www
FreeLibros.meJAYASIMHA
D.N.
SCHWIEBERT
L.
MANIV
ANNAN
MAY
J.A.
Foundation
for
Designing
Deadlock-Free
Routing
Algorithms
in
Wormhole
Networks
J.
of
the
ACM
vol.
50
pp
250
275
2003
JIANG
X.
XU
D.
Profiling
Self-Propagating
Worms
via
Behavioral
Footprinting
Proc
4th
ACM
Workshop
in
Recurring
Malcode
ACM
pp
17
24
2006
JOHNSON
N.F.
JAJODIA
S.
Exploring
Steganography
Seeing
the
Unseen
Computer
vol.
31
pp
26
34
febrero
1998
JONES
J.R.
Estimating
Software
Vulnerabilities
IEEE
Security
and
Privacy
vol.
pp
28
32
ju-
lio
agosto
2007
JOO
Y.
CHOI
Y.
PARK
C.
CHUNG
S.
CHUNG
E.
System-level
optimization
Demand
paging
for
OneNAND
Flash
eXecute-in-place
Proc
Int’l
Conf
on
Hardware
Software
Codesign
ACM
pp
229
234
2006
KABAY
M.:“Flashes
from
the
Past
Information
Security
p.
17
1997
KAMINSKY
D.
Explorations
in
Namespace
White-Hat
Hacking
across
the
Domain
Name
System
Commun
of
the
ACM
vol.
49
pp
62
69
junio
2006
KAMINSKY
M.
VVIDES
G.
MAZIERES
D.
KAAZHOEK
M.F.:“Decentralized
User
Authen-
tication
in
Global
File
System
Proc
19th
Symp
on
Operating
Systems
Principles
ACM
pp
60
73
2003
KANG
S.
WON
Y.
ROH
S.
Harmonic
Interleaving
File
System
Support
for
Scalable
Streaming
of
Layer
Encoded
Objects
Proc
ACM
Int’l
Workshop
on
Network
and
Operating
System
Support
for
Di-
gital
Audio
and
Video
ACM
2006
KANT
K.
MPHAPATRA
P.:“Internet
Data
Centers
Computer
vol.
27
pp
35
37
noviembre
2004
KARLIN
A.R.
LI
K.
MANASSE
M.S.
OWICKI
S.:“Empirical
Studies
of
Competitive
Spinning
for
Shared-Memory
Multiprocessor
Proc
13th
Symp
on
Operating
Systems
Principles
ACM
pp
41
54
1991
KARLIN
A.R.
MANASSE
M.S.
McGEOCH
L.
OWICKI
S.
Competitive
Randomized
Algo-
rithms
for
Non-Uniform
Problems
Proc
First
Annual
ACM
Symp
on
Discrete
Algorithms
ACM
pp
301
309
1989
KAROL
M.
GOLESTANI
S.J.
LEE
D.
Prevention
of
Deadlocks
and
Livelocks
in
Lossless
Back-
pressured
Packet
Networks
IEEE
ACM
Trans
on
Networking
vol.
11
pp
923
934
2003
KAUFMAN
C.
PERLMAN
R.
SPECINER
M.
Network
Security
2a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2002
KEETON
K.
BEYER
D.
BRAU
E.
MERCHANT
A.
SANTOS
C.
ZHANG
A.
On
the
Road
to
Recovery
Restoring
Data
After
Disasters
Proc
Eurosys
2006
ACM
pp
235
238
2006
KELEHER
P.
COX
A.
DW
ARKADAS
S.
ZW
AENEPOEL
W.:“TreadMarks
Distributed
Shared
Memory
on
Standard
Workstations
and
Operating
Systems
Proc
USENIX
Winter
1994
Conf
USE-
NIX
pp
115
132
1994
1030
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1031
KERNIGHAN
B.W.
PIKE
R.
The
UNIX
Programming
Environment
Upper
Saddle
River
NJ
Prenti-
ce
Hall
1984
KIENZLE
D.M.
ELDER
M.C.
Recent
Worms
Survey
and
Trends
Proc
2003
ACM
Workshop
on
Rapid
Malcode
ACM
pp
10
2003
KIM
J.
BARATTO
R.A.
NIEH
J.
pTHINC
Thin-Client
Architecture
for
Mobile
Wireless
Web
Proc
15th
Int’l
Conf
on
the
World
Wide
Web
ACM
pp
143
152
2006
KING
S.T.
CHEN
P.M.
Backtracking
Intrusions
ACM
Trans
on
Computer
Systems
vol.
23
pp
51
76
febrero
2005
KING
S.T.
DUNLAP
G.W.
CHEN
P.M.:“Operating
System
Support
for
Virtual
Machines
Proc
An-
nual
Tech
Conf
USENIX
pp
71
84
2003
KING
S.T.
DUNLAP
G.W.
CHEN
P.M.:“Debugging
Operating
Systems
with
Time-Traveling
Virtual
Machines
Proc
Annual
Tech
Conf
USENIX
pp
15
2005
KIRSCH
C.M.
SANVIDO
M.A.A.
HENZINGER
T.A.
Programmable
Microkernel
for
Real-Ti-
Systems
Proc
1st
Int’l
Conf
on
Virtual
Execution
Environments
ACM
pp
35
45
2005
KISSLER
S.
HOYT
O.
Using
Thin
Client
Technology
to
Reduce
Complexity
and
Cost
Proc
33rd
Annual
Conf
on
User
Services
ACM
pp
138
140
2005
KLEIMAN
S.R.
Vnodes
An
Architecture
for
Multiple
File
System
Types
in
Sun
UNIX
Proc
USENIX
Summer
1986
Conf
USENIX
pp
238
247
1986
KLEIN
D.V
.:“Foiling
the
Cracker
Survey
of
and
Improvements
to
Password
Security
Proc
UNIX
Security
Workshop
II
USENIX
verano
1990
KNUTH
D.E.
The
Art
of
Computer
Programming
Vol
Fundamental
Algorithms
3a
edición
Reading
MA
Addison-Wesley
1997
KOCHAN
S.G.
WOOD
P.H.
UNIX
Shell
Programming
Indianapolis
IN
2003
KONTOTHANASSIS
L.
STETS
R.
HUNT
H.
RENCUZOGULLARI
U.
ALTEKAR
G.
DW
AR-
KADAS
S.
SCOTT
M.L.:“Shared
Memory
Computing
on
Clusters
with
Symmetric
Multiprocessors
and
System
Area
Networks
ACM
Trans
on
Computer
Systems
vol.
23
pp
301
335
agosto
2005
KOTLA
R.
ALVISI
L.
DAHLIN
M.:“SafeStore
Durable
and
Practical
Storage
System
Proc
An-
nual
Tech
Conf
USENIX
pp
129
142
2007
KRATZER
C.
DITTMAN
J.
LANG
A.
KUHNE
T.:“WLAN
Steganography
First
Practical
Re-
view
Proc
Eighth
Workshop
on
Multimedia
and
Security
ACM
pp
17
22
2006
KRA
VETS
R.
KRISHNAN
P.
Power
Management
Techniques
for
Mobile
Communication
Proc
Fourth
ACM
IEEE
Int’l
Conf
on
Mobile
Computing
and
Networking
ACM
IEEE
pp
157
168
1998
KRIEGER
O.
AUSLANDER
M.
ROSENBURG
B.
WISNIEWSKI
R.W.
XENIDIS
J.
SILV
D.
OSTROWSKI
M.
APPA
VOO
J.
BUTRICO
M.
MERGEN
M.
ATERLAND
A.
UHLIG
V.
K42
Building
Complete
Operating
System
Proc
Eurosys
2006
ACM
pp
133
145
2006
www
FreeLibros.me1032
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
KRISHNAN
R.
Timeshared
Video-on-Demand
Workable
Solution
IEEE
Multimedia
vol.
enero-
marzo
1999
pp
77
79
KROEGER
T.M.
LONG
D.D.E.
Design
and
Implementation
of
Predictive
File
Prefetching
Algo-
rithm
Proc
Annual
Tech
Conf
USENIX
pp
105
118
2001
KRUEGEL
C.
ROBERTSON
E.
VIGNA
G.
Detecting
Kernel-Level
Rootkits
Through
Binary
Analysis
Proc
First
IEEE
Int’l
Workshop
on
Critical
Infrastructure
Protection
IEEE
pp
13
21
2004
KRUEGER
P.
LAI
T.-H.
DIXIT-RADIYA
.A.:“Job
Scheduling
is
More
Important
Than
Processor
Allocation
for
Hypercube
Computers
IEEE
Trans
on
Parallel
and
Distr
Systems
vol.
pp
488
497
mayo
1994
KUM
S.-U.
MAYER-PATEL
K.:“Intra-Stream
Encoding
for
Multiple
Depth
Streams
Proc
ACM
Int’l
Workshop
on
Network
and
Operating
System
Support
for
Digital
Audio
and
Video
ACM
2006
KUMAR
R.
TULLSEN
D.M.
JOUPPI
N.P.
RANGANATHAN
P.:“Heterogeneous
Chip
Multipro-
cessors
Computer
vol.
38
pp
32
38
noviembre
2005
KUMAR
.P.
REDDY
S.M.
Augmented
Shuffle-Exchange
Multistage
Interconnection
Networks
Computer
vol.
20
pp
30
40
junio
1987
KUPERMAN
B.A.
BRODLEY
C.E.
OZDOGANOLU
H.
VIJAYKUMAR
T.N.
JALOTE
A.
Detection
and
Prevention
of
Stack
Buffer
Overflow
Attacks
Commun
of
the
ACM
vol.
48
pp
50
56
noviembre
2005
KWOK
Y.-K.
AHMAD
L.
Static
Scheduling
Algorithms
for
Allocating
Directed
Task
Graphs
to
Mul-
tiprocessors
Computing
Surveys
vol.
31
pp
406
471
diciembre
1999
LAI
A.M.
NIEH
J.
On
the
Performance
of
Wide-Area
Thin-Client
Computing
ACM
Trans
on
Com-
puter
Systems
vol.
24
pp
175
209
mayo
2006
LAMPORT
L.
Password
Authentication
with
Insecure
Communication
Commun
of
the
ACM
vol.
24
pp
770
772
noviembre
1981
LAMPSON
B.W.:“A
Scheduling
Philosophy
for
Multiprogramming
Systems
Commun
of
the
ACM
vol.
11
pp
347
360
mayo
1968
LAMPSON
B.W.
Note
on
the
Confinement
Problem
Commun
of
the
ACM
vol.
10
pp
613
615
octubre
1973
LAMPSON
B.W.
Hints
for
Computer
System
Design
IEEE
Software
vol.
pp
11
28
enero
1984
LAMPSON
B.W.
STRUGIS
H.E.:“Crash
Recovery
in
Distributed
Data
Storage
System
Xerox
Pa-
Alto
Research
Center
Technical
Report
junio
1979
LANDWEHR
C.E.
Formal
Models
of
Computer
Security
Computing
Surveys
vol.
13
pp
247
278
septiembre
1981
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1033
W.
SOFFA
M.L.
Refining
Buffer
Overflow
Detection
via
Demand-Driven
Path-Sensitive
Analy-
sis
Proc
7th
ACM
SIGPLAN-SOGSOFT
Workshop
on
Program
Analysis
for
Software
Tools
and
En-
gineering
ACM
pp
63
68
2007
LEE
B.
Parallel
Video
Servers
Tutorial
IEEE
Multimedia
vol.
pp
20-28
abril-junio
1998
LESLIE
I.
McAULEY
D.
BLACK
R.
ROSCOE
T.
BARHAM
P.
EVERS
D.
FAIRBAIRNS
R.
HYDEN
E.
The
Design
and
Implementation
of
an
Operating
System
to
Support
Distributed
Multimedia
Applications
IEEE
J.
on
Selected
Areas
in
Commun
vol.
14
pp
1280
1297
julio
1996
LEV
ASSEUR
J.
UHLIG
STOESS
J.
GOTZ
S.
Unmodified
Device
Driver
Reuse
and
Impro-
ved
System
Dependability
via
Virtual
Machines
Proc
Sixth
Symp
on
Operating
System
Design
and
Implementation
USENIX
pp
17
30
2004
LEVIN
R.
COHEN
E.S.
CORWIN
W.M.
POLLACK
F.J.
WULF
W.A.:“Policy
Mechanism
Se-
paration
in
Hydra
Proc
Fifth
Symp
on
Operating
Systems
Principles
ACM
pp
132
140
1975
LEVINE
G.N.
Defining
Deadlock
ACM
SIGOPS
Operating
Systems
Rev
vol.
37
pp
54
64
enero
2003a
LEVINE
G.N.
Defining
Deadlock
with
Fungible
Resources
ACM
SIGOPS
Operating
Systems
Rev
vol.
37
pp
11
julio
2003b
LEVINE
G.N.
The
Classification
of
Deadlock
Prevention
and
Avoidance
Is
Erroneous
ACM
SIGOPS
Operating
Systems
Rev
vol.
39
pp
47
50
abril
2005
LEVINE
J.G.
GRIZZARD
J.B.
OWEN
H.L.
Detecting
and
Categorizing
Kernel-level
Rootkits
to
Aid
Future
Detection
IEEE
Security
and
Privacy
vol.
pp
24
32
enero
febrero
2006
LI
K.
Shared
Virtual
Memory
on
Loosely
Coupled
Multiprocessors
tesis
Ph
D.
Universidad
Ya-
1986
LI
K.
HUDAK
P.
Memory
Coherence
in
Shared
Virtual
Memory
Systems
ACM
Trans
on
Compu-
ter
Systems
vol.
pp
321
359
noviembre
1989
LI
K.
KUMPF
R.
HORTON
P.
ANDERSON
T.:“A
Quantitative
Analysis
of
Disk
Drive
Power
Ma-
nagement
in
Portable
Computers
Proc
1994
Winter
Conf
USENIX
pp
279
291
1994
LI
T.
ELLIS
C.S.
LEBECK
A.R.
SORIN
D.J.
Pulse
Dynamic
Deadlock
Detection
Mechanism
Using
Speculative
Execution
Proc
Annual
Tech
Conf
USENIX
pp
31
44
2005
LIE
D.
THEKKATH
C.A.
HOROWITZ
M.
Implementing
an
Untrusted
Operating
System
on
Trus-
ted
Hardware
Proc
19th
Symp
on
Operating
Systems
Principles
ACM
pp
178
192
2003
LIEDTKE
J.
Improving
IPC
by
Kernel
Design
Proc
14th
Symp
on
Operating
Systems
Principles
ACM
pp
175
188
1993
LIEDTKE
J.
On
Micro-Kernel
Construction
Proc
15th
Symp
on
Operating
Systems
Principles
ACM
pp
237
250
1995
www
FreeLibros.meLIEDTKE
J.
Toward
Real
Microkernels
Commun
of
the
ACM
vol.
39
pp
70
77
septiembre
1996
LIN
G.
RAJARAMAN
R.
Approximation
Algorithms
for
Multiprocessor
Scheduling
under
Uncer-
tainty
Proc
19th
Symp
on
Parallel
Algorithms
and
Arch
ACM
pp
25
34
2007
LIONS
J.
Lions
Commentary
on
Unix
6th
Edition
with
Source
Code
San
José
CA
Peer-to-Peer
Com-
munications
1996
LIU
C.L.
LAYLAND
J.W.:“Scheduling
Algorithms
for
Multiprogramming
in
Hard
Real-Time
Envi-
ronment
J.
of
the
ACM
vol.
20
pp
46
61
enero
1973
LIU
J.
HUANG
W.
ABALL
B.
PANDA
B.K.:“High
Performance
VMM-Bypass
in
Virtual
Ma-
chines
Proc
Annual
Tech
Conf
USENIX
pp
29
42
2006
.M.:“Heuristic
Algorithms
for
Task
Assignment
in
Distributed
Systems
Proc
Fourth
Int’l
Conf
on
Distributed
Computing
Systems
IEEE
pp
30
39
1984
LORCH
J.R.
SMITH
A.J.
Reducing
Processor
Power
Consumption
by
Improving
Processor
Time
Management
In
Single-User
Operating
System
Proc
Second
Int’l
Conf
on
Mobile
Computing
and
Networking
ACM
pp
143
154
1996
LORCH
J.R.
SMITH
A.J.
Apple
Macintosh’s
Energy
Consumption
IEEE
Micro
vol.
18
pp
54
63
noviembre
diciembre
1998
LU
P.
SHEN
K.
Virtual
Machine
Memory
Access
Tracing
with
Hypervisor
Exclusive
Cache
Proc
Annual
Tech
Conf
USENIX
pp
29
43
2007
LUDWIG
M.A.
The
Giant
Black
Book
of
Email
Viruses
Show
Low
AZ
American
Eagle
Publications
1998
LUDWIG
M.A.
The
Little
Black
Book
of
Email
Viruses
Show
Low
AZ
American
Eagle
Publications
2002
LUND
K.
GOEBEL
Adaptive
Disk
Scheduling
in
Multimedia
DBMS
Proc
11th
ACM
Int’l
Conf
on
Multimedia
ACM
pp
65
74
2003
LYDA
R.
HAMROCK
J.
Using
Entropy
Analysis
to
Find
Encrypted
and
Packed
Malware
IEEE
Se-
curity
and
Privacy
vol.
pp
17
25
marzo
abril
2007
MANIATIS
P.
ROUSSOPOULOS
M.
GIULI
T.J.
ROSENTHAL
D.S.H.
BAKER
M.
The
LOCSS
Peer-to-Peer
Digital
Preservation
System
ACM
Trans
on
Computer
Systems
vol.
23
pp
50
febrero
2005
MARKOWITZ
J.A.
oice
Biometrics
Commun
of
the
ACM
vol.
43
pp
66
73
septiembre
2000
MARSH
B.D.
SCOTT
M.L.
LEBLANC
T.J.
MARKATOS
E.P.:“First-Class
User-Level
Threads
Proc
13th
Symp
on
Operating
Systems
Principles
ACM
pp
110
121
1991
MATTHUR
A.
MUNDUR
P.
Dynamic
Load
Balancing
Across
Mirrored
Multimedia
Servers
Proc
2003
Int’l
Conf
on
Multimedia
IEEE
pp
53
56
2003
1034
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1035
MAXWELL
S.E.
Linux
Core
Kernel
Commentary
2a
edición
Scottsdale
AZ
Coriolis
2001
McDANIEL
T.
Magneto-Optical
Data
Storage
Commun
of
the
ACM
vol.
43
pp
57
63
noviembre
2000
McKUSICK
M.J.
JOY
W.N.
LEFFLER
S.J.
FABRY
R.S.
Fast
File
System
for
UNIX
ACM
Trans
on
Computer
Systems
vol.
pp
181
197
agosto
1984
McKUSICK
M.K.
NEVILLE-NEIL
G.V
.:The
Design
and
Implementation
of
the
FreeBSD
Operating
System
Reading
M.A.
Addison-Wesley
2004
MEAD
N.R.
Who
Is
Liable
for
Insecure
Systems
Computer
vol.
37
pp
27
34
julio
2004
MEDINETS
D.
UNIX
Shell
Programming
Tools
York
McGraw-Hill
1999
MELLOR-CRUMMEY
J.M.
SCOTT
M.L.:“Algorithms
for
Scalable
Synchronization
on
Shared-Me-
mory
Multiprocessors
ACM
Trans
on
Computer
Systems
vol.9
pp
21
65
febrero
1991
MENON
A.
COX
A.
ZW
AENEPOEL
W.:“Optimizing
Network
Virtualization
in
Xen
Proc
Annual
Tech
Conf
USENIX
pp
15
28
2006
MILOJICIC
D.
Operating
Systems
Now
and
in
the
Future
IEEE
Concurrency
vol.
pp
12
21
ene-
ro-marzo
1999
MILOJICIC
D.
Security
and
Privacy
IEEE
Concurrency
vol.
pp
70
79
abril-junio
2000
MIN
H.
YI
S.
CHO
Y.
HONG
J.
An
Efficient
Dynamic
Memory
Allocator
for
Sensor
Operating
Systems
Proc
2007
ACM
Symposium
on
Applied
Computing
ACM
pp
1159
1164
2007
MOFFIE
M.
CHENG
W.
KAELI
D.
ZHAO
Q.
Hunting
Trojan
Horses
Proc
First
Workshop
on
Arch
and
System
Support
for
Improving
Software
Dependability
ACM
pp
12
17
2006
MOODY
G.
Rebel
Code
Cambridge
MA
Perseus
Publishing
2001
MOORE
J.
CHASE
J.
RANGANATHAN
P.
SHARMA
R.:“Making
Scheduling
Cool
Temperatu-
re-Aware
Workload
Placement
in
Data
Centers
Proc
Annual
Tech
Conf
USENIX
pp
61
75
2005
MORRIS
B.
The
Symbian
Architecture
Sourcebook
Chichester
UK
John
Wiley
2007
MORRIS
J.H.
SATYANARAYANAN
M.
CONNER
M.H.
HOW
ARD
J.H.
ROSENTHAL
D.S.
SMITH
F.D.:“Andrew
Distributed
Personal
Computing
Environment
Commun
of
the
ACM
vol.
29
pp
184
201
marzo
1986
MORRIS
R.
THOMPSON
K.
Password
Security
Case
History
Commun
of
the
ACM
vol.
22
pp
594
597
noviembre
1979
MOSHCHUK
A.
BRAGIN
T.
GRIBBLE
S.D.
LEVY
H.M.
Crawler-Based
Study
of
Spyware
on
the
Web
Proc
Network
and
Distributed
System
Security
Symp
Internet
Society
pp
17
2006
MULLENDER
S.J.
TANENBAUM
A.S.
Immediate
Files
Software
Practice
and
Experience
vol.
14
pp
365
368
1984
www
FreeLibros.meMUNISW
ARMY-REDDY
K.-K.
HOLLAND
D.A.
BRAUN
U.
SELTZER
M.:“Provenance-Awa-
re
Storage
Systems
Proc
Annual
Tech
Conf
USENIX
pp
43
56
2006
MUTHITACHAROEN
A.
CHEN
B.
MAZIERES
D.
Low-Bandwidth
Network
File
System
Proc
18th
Symp
on
Operating
Systems
Principles
ACM
pp
174
187
2001
MUTHITACHAROEN
A.
MORRIS
R.
GIL
T.M.
CHEN
B.
Ivy
Read
Write
Peer-to-Peer
File
System
Proc
Fifth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
31
44
2002
NACHENBERG
C.
Computer
Virus-Antivirus
Coevolution
Commun
of
the
ACM
vol.
40
pp
46
51
enero
1997
NEMETH
E.
SNYDER
G.
SEEBASS
S.
HEIN
T.R.
UNIX
System
Administration
Handbook
2a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2000
NEWHAM
C.
ROSENBLATT
Learning
the
Bash
Shell
Sebastopol
CA
O’Reilly
Associates
1998
NEWTON
G.
Deadlock
Prevention
Detection
and
Resolution
An
Annotated
Bibliography
ACM
SI-
GOPS
Operating
Systems
Rev
vol.
13
pp
33
44
abril
1979
NIEH
J.
LAM
M.S.
SMART
Scheduler
for
Multimedia
Applications
ACM
Trans
on
Computer
Systems
vol.
21
pp
117
163
mayo
2003
NIEH
J.
AILL
C.
ZHONG
H.:“Virtual-Time
Round
Robin
An
O(1
Proportional
Share
Scheduler
Proc
Annual
Tech
Conf
USENIX
pp
245
259
2001
NIGHTINGALE
E.B.
FLINN
J.
Energy
Efficiency
and
Storage
Flexibility
in
the
Blue
File
System
Proc
Sixth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
363
378
2004
NIKOLOPOULOS
D.S.
AYGUADE
E.
PAPATHEODOROU
T.S.
POLYCHRONOPOULOS
C.D.
LABARTA
J.
The
Trade-Off
between
Implicit
and
Explicit
Data
Distribution
in
Shared-Memory
Programming
Paradigms
Proc
Int’l
Conf
on
Supercomputing
ACM
pp
23
37
2001
NIST
National
Institute
of
Standards
and
Technology
FIPS
Pub
180-1
1995
OKI
B.
PFLUEGL
M.
SIEGEL
A.
SKEEN
D.
The
Information
Bus—An
Architecture
for
Exten-
sible
Distributed
Systems
Proc
14th
Symp
on
Operating
Systems
Principles
ACM
pp
58
68
1993
ONEY
W.
Programming
the
Microsoft
Windows
Driver
Model
2a
edición
Redmond
WA
Microsoft
Press
2002
ORGANICK
E.I.
The
Multics
System
Cambridge
MA
M.I.T.
Press
1972
ORWICK
P.
SMITH
G.:Developing
Drivers
with
the
Windows
Driver
Foundation
Redmond
WA
Mi-
crosoft
Press
2007
OSTRAND
T.J.
WEYUKER
E.J.
The
Distribution
of
Faults
in
Large
Industrial
Software
Sys-
tem
Proc
2002
ACM
SIGSOFT
Int’l
Symp
on
Software
Testing
and
Analysis
ACM
pp
55
64
2002
1036
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1037
OUSTERHOUT
J.K.
Scheduling
Techniques
for
Concurrent
Systems
Proc
Third
Int’l
Conf
on
Dis-
trib
Computing
Systems
IEEE
pp
22
30
1982
PADIOLEAU
Y.
ALL
J.L.
MULLER
G.:“Understanding
Collateral
Evolution
in
Linux
Device
Drivers
Proc
Eurosys
2006
ACM
pp
59
72
2006
PADIOLEAU
Y.
RIDOUX
O.
Logic
File
System
Proc
Annual
Tech
Conf
USENIX
pp
99
112
2003
PAI
.S.
DRUSCHEL
P.
ZW
AENEPOEL
W.:“IO-Lite
Unified
Buffering
and
Caching
Sys-
tem
ACM
Trans
on
Computer
Systems
vol.
18
pp
37
66
febrero
2000
PANAGIOTOU
K.
SOUZA
A.
On
Adequate
Performance
Measures
for
Paging
Proc
38th
ACM
Symp
on
Theory
of
Computing
ACM
pp
487
496
2006
PANKANTI
S.
BOLLE
R.M.
JAIN
A.:“Biometrics
The
Future
of
Identification
Computer
vol.
33
pp
46
49
febrero
2000
PARK
C.
KANG
J.-U.
PARK
S.-Y.
KIM
J.-S.
Energy
Efficient
Architectural
Techniques
Energy-Aware
Demand
Paging
on
NAND
Flash-Based
Embedded
Storages
ACM
pp
338
343
2004b
PARK
C.
LIM
J.
KWON
K.
LEE
J.
MIN
S.
Compiler-Assisted
Demand
Paging
for
Embedded
Systems
with
Flash
Memory
Proc
4th
ACM
Int’l
Cong
On
Embedded
Software
September
ACM
pp
114
124
2004a
PARK
S.
JIANG
W.
ZHOU
Y.
ADVE
S.:“Managing
Energy-Performance
Tradeoffs
for
Multithrea-
ded
Applications
on
Multiprocessor
Architectures
Proc
2007
Int’l
Conf
on
Measurement
and
Mo-
deling
of
Computer
Systems
ACM
pp
169
180
2007
PARK
S.
OHM
S.-Y.
Real-Time
FAT
File
System
for
Mobile
Multimedia
Devices
Proc
Int’l
Conf
on
Consumer
Electronics
IEEE
pp
245
346
2006
PATE
S.D.
UNIX
Filesystems
Evolution
Design
and
Implementation
York
Wiley
2003
PATTERSON
D.
HENNESSY
J.:Computer
Organization
and
Design
3a
edición
San
Francisco
Mor-
gan
Kaufman
2004
PATTERSON
D.A.
GIBSON
G.
KATZ
R.
Case
for
Redundant
Arrays
of
Inexpensive
Disks
RAID
Proc
ACM
SIGMOD
Int’l
Conf
on
Management
of
Data
ACM
pp
109
166
1988
PAUL
N.
GURUMURTHI
S.
EV
ANS
D.
Towards
Disk-Level
Malware
Detection
Proc
First
Workshop
on
Code-based
Software
Security
Assessments
2005
PEEK
D.
NIGHTINGALES
E.B.
HIGGINS
B.D.
KUMAR
P.
FLINN
J.:“Sprockets
Safe
Exten-
sions
for
Distributed
File
Systems
Proc
Annual
Tech
Conf
USENIX
pp
115
128
2007
PERMANDIA
P.
ROBERTSON
M.
BOYAPATI
C.:“A
Type
System
for
Preventing
Data
Races
and
Deadlocks
in
the
Java
Virtual
Machine
Language
Proc
2007
Conf
on
Languages
Compilers
and
Tools
ACM
pp
10
19
2007
www
FreeLibros.mePESERICO
E.
Online
Paging
with
Arbitrary
Associativity
Proc
14th
ACM-SIAM
Symp
on
Discrete
Algorithms
ACM
pp
555
564
2003
PETERSON
G.L.
Myths
about
the
Mutual
Exclusion
Problem
Information
Processing
Letters
vol.
12
pp
115
116
junio
1981
PETZOLD
C.
Programming
Windows
5a
edición
Redmond
WA
Microsoft
Press
1999
PFLEEGER
C.P.
PFLEEGER
S.L.:Security
in
Computing
4a
edición
Upper
Saddle
River
NJ
Pren-
tice
Hall
2006
PIKE
R.
PRESOTTO
D.
THOMPSON
K.
TRICKEY
H.
WINTERBOTTOM
P.
The
Use
of
Name
Spaces
in
Plan
Proc
5th
ACM
SIGOPS
European
Workshop
ACM
pp
1992
PIZLO
F.
VITEK
J.
An
Emprical
Evaluation
of
Memory
Management
Alternatives
for
Real-Time
Java
Proc
27th
IEEE
Int’l
Real-Time
Systems
Symp
IEEE
pp
25-46
2006
POPEK
G.J.
GOLDBERG
R.P.
Formal
Requirements
for
Virtualizable
Third
Generation
Architectures
Commun
of
the
ACM
vol.
17
pp
412-421
July
1974
POPESCU
B.C.
CRISPO
B.
TANENBAUM
A.S.
Secure
Data
Replication
over
Untrusted
Hosts
Proc
Ninth
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
121-127
2003
PORTOKALIDIS
G.
BOS
H.
SweetBait
Zero-Hour
Worm
Detection
and
Containment
Using
Low-
and
High-Interaction
Honeypots
PORTOKALIDIS
G.
SLOWINSKA
A.
BOS
H.:“ARGOS
An
Emulator
of
Fingerprinting
Zero-Day
Attacks
Proc
Eurosys
2006
ACM
pp
15
27
2006
PRABHAKARAN
ARPACI-DUSSEAU
A.C.
ARPACI-DUSSEAU
R.H.:“Analysis
and
Evolution
of
Journaling
File
Systems
Proc
Annual
Tech
Conf
USENIX
pp
105
120
2005
PRASAD
M.
CHIUEH
T.:“A
Binary
Rewriting
Defense
against
Stack-based
Buffer
Overflow
Attacks
Proc
Annual
Tech
Conf
USENIX
pp
211
224
2003
PRECHELT
L.
An
Empirical
Comparison
of
Seven
Programming
Languages
Computer
vol.
33
pp
23
29
octubre
2000
PUSARA
M.
BRODLEY
C.E.:“DMSEC
session
User
Re-Authentication
via
Mouse
Movements
Proc
2004
ACM
Workshop
on
Visualization
and
Data
Mining
for
Computer
Security
ACM
pp
2004
QUYNH
N.A.
TAKEFUJI
Y.:“Towards
Tamper-Resistant
Kernel
Rootkit
Detector
Proc
Symp
on
Applied
Computing
ACM
pp
276
283
2007
RAJAGOLAPAN
M.
LEWIS
B.T.
ANDERSON
T.A.:“Thread
Scheduling
for
Multicore
Platforms
Proc
11th
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
12
2007
RANGASW
AMI
R.
DIMITRIJEVIC
Z.
CHANG
E.
SCHAUSER
K.
Building
MEMS-Storage
Systems
for
Streaming
Media
ACM
Trans
on
Storage
vol.
Art
junio
2007
RECTOR
B.E.
NEWCOMER
J.M.
Win32
Programming
Reading
MA
Addison-Wesley
1997
1038
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1039
REDDY
A.L.N.
WYLLIE
J.C.
Disk
Scheduling
in
Multimedia
System
Proc
ACM
Multime-
Conf
ACM
pp
225
233
1992
REDDY
A.L.N.
WILLIE
J.C.
Issues
in
Multimedia
System
Computer
vol.
27
pp
69
74
marzo
1994
REDDY
A.L.N.
WYLLIE
J.C.
WIJAYARATNE
K.B.R.:“Disk
Scheduling
in
multimedia
sys-
tem
ACM
Trans
on
Multimedia
Computing
Communications
and
Applications
vol.
pp
37
59
febrero
2005
REID
J.F.
CAELLI
W.J.:“DRM
Trusted
Computing
and
Operating
System
Architecture
Proc
2005
Australasian
Workshop
on
Grid
Computing
and
E-Research
pp
127
136
2005
RIEBACK
M.R.
CRISPO
B.
TANENBAUM
A.S.
Is
Your
Cat
Infected
with
Computer
Virus
proc
Fourth
IEEE
Int’l
Conf
On
Pervasive
Computing
and
Commun
IEEE
pp
169
179
2006
RISKA
A.
LARKBY-LAHET
J.
RIEDEL
E.
Evaluating
Block-level
Optimization
Through
the
IO
Path
Proc
Annual
Tech
Conf
USENIX
pp
247
260
2007
RISKA
A.
RIEDEL
E.:“Disk
Drive
Level
Workload
Characterization
Proc
Annual
Tech
Conf
USE-
NIX
pp
97
102
2006
RITCHIE
D.M.
Reflections
on
Software
Research
Commun
of
the
ACM
vol.
27
pp
758
760
agos-
to
1984
RITCHIE
D.M.
THOMPSON
K.
The
UNIX
Timesharing
System
Commun
Of
the
ACM
vol.
17
pp
365
375
julio
1974
RITSCHARD
M.R.
Thin
Clients
The
Key
to
Our
Success
Proc
34th
Annual
Conf
On
User
Services
ACM
pp
343
346
2006
RIVEST
R.L.
The
MD5
Message-Digest
Algorithm
RFC
1320
abril
1992
RIVEST
R.L.
SHAMIR
A.
ADLEMAN
L.
On
Method
for
Obtaining
Digital
Signatures
and
Pu-
blic
Key
Criptosystems
Commun
of
the
ACM
vol.
21
pp
120
126
febrero
1978
ROBBINS
A.
UNIX
in
Nutshell
Desktop
Quick
Reference
for
SVR4
and
Solaris
Sebastopol
CA
O’Reilly
Associates
1999
ROSCOE
T.
ELPHINSTONE
K.
HEISER
G.
Hype
and
Virtue
Proc
11th
Workshop
on
Hot
To-
pics
in
Operating
Systems
USENIX
pp
19
24
2007
ROSENBLUM
M.
GARFINKEL
T.
Virtual
Machine
Monitors
Current
Technology
and
Future
Trends
Computer
vol.
38
pp
39
47
mayo
2005
ROSENBLUM
M.
OUSTERHOUT
J.K.
The
Design
and
Implementation
of
Log-Structured
File
System
Proc
13th
Symp
on
Oper
Sys
Prin
ACM
pp
15
1991
ROWSTRON
A.
DRUSCHEL
P.
Storage
Management
and
Caching
in
PAST
Large-Scale
Persis-
tent
Peer-to-Peer
Storage
Utility
Proc
18th
Symp
on
Operating
Systems
Principles
ACM
pp
174
187
2001
www
FreeLibros.me1040
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
ROZIER
M.
ABBROSSIMOV
ARMAND
F.
BOULE
I.
GIEN
M.
GUILLEMONT
M.
HERRMANN
F.
KAISER
C.
LEONARD
P.
LANGLOIS
S.
NEUHAUSER
W.
Chorus
Distributed
Operating
Systems
Computing
Systems
vol.
pp
305
379
octubre
1988
RUBINI
A.
KROAH-HARTMAN
G.
CORBET
J.
Linux
Device
Drivers
Sebastopol
CA
O’Reilly
Associates
2005
RUSSINOVICH
M.
SOLOMON
D.
Microsoft
Windows
Internals
4a
edición
Redmond
WA
Micro-
soft
Press
2005
RYCROFT
M.E.
One
Needs
It
Until
They
Need
It
Implementing
New
Desktop
Backup
Solu-
tions
Proc
34th
Annual
SIGUCCS
Conf
on
User
Services
ACM
pp
347
352
2006
SACKMAN
H.
ERIKSON
W.J.
GRANT
E.E.
Exploratory
Experimental
Studies
Comparing
Onli-
ne
and
Offline
Programming
Performance
Commun
of
the
ACM
vol.
11
pp
11
enero
1968
SAIDI
H.
Guarded
Models
for
Intrusion
Detection
Proc
2007
Workshop
on
Programming
Languages
and
Analysis
for
Security
ACM
pp
85
94
2007
SAITO
Y.
KARAMANOLIS
C.
KARLSSON
M.
MAHALINGAM
M.
Taming
Aggressive
Re-
plication
in
the
Pangea
Wide-Area
File
System
Proc
Fifth
Symp
On
Operating
System
Design
and
Implementation
USENIX
pp
15
30
2002
SALTZER
J.H.
Protection
and
Control
of
Information
Sharing
in
MULTICS
Commun
of
the
ACM
vol.
17
pp
388
402
julio
1974
SALTZER
J.H.
REED
D.P.
CLARK
D.D.
End-to-End
Arguments
in
System
Design
ACM
Trans
on
Computer
Systems
vol.
pp
277
noviembre
1984
SALTZER
J.H.
SCHROEDER
M.D.
The
Protection
of
Information
in
Computer
Systems
Proc
IEEE
vol.
63
pp
1278
1308
septiembre
1975
SALUS
P.H.
UNIX
At
25
Byte
vol.
19
pp
75
82
octubre
1994
SANOK
D.J.
An
Analysis
of
how
Antivirus
Methodologies
Are
Utilized
in
Protecting
Computers
from
Malicious
Code
Proc
Second
Annual
Conf
on
Information
Security
Curriculum
Development
ACM
pp
142
144
2005
SARHAN
N.J.
DAS
C.R.
Caching
and
Scheduling
in
NAD-Based
Multimedia
Servers
IEEE
Trans
on
Parallel
and
Distributed
Systems
vol.
15
pp
921
933
octubre
2004
SASSE
M.A.
Red-Eye
Blink
Bendy
Shuffle
and
the
Yuck
Factor
User
Experience
of
Biometric
Air-
port
Systems
IEEE
Security
and
Privacy
vol.
pp
78
81
mayo
junio
2007
SCHAFER
M.K.F.
HOLLSTEIN
T.
ZIMMER
H.
GLESNER
M.
Deadlock-Free
Routing
and
Component
Placement
for
Irregular
Mesh-Based
Networks-on-Chip
Proc
2005
Int’l
Conf
on
Com-
puter-Aided
Design
IEEE
pp
238
245
2005
SCHEIBLE
J.P.
Survey
of
Storage
Options
Computer
vol.
35
pp
42
46
diciembre
2002
SCHW
ARTZ
A.
GUERRAZZI
C.:“You
Can
Never
Be
Too
Thin
Skinny-Client
Technology
Proc
33d
Annual
Conf
on
User
Services
ACM
pp
336
337
2005
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1041
SCOTT
M.
LeBLANC
T.
MARSH
B.:“Multi-model
Parallel
Programming
in
Psyche
Proc
Second
ACM
Symp
On
Principles
and
Practice
of
Parallel
Programming
ACM
pp
70
78
1990
WRIGHT
L.H.
MACKINNON
R.A.
VM/370—A
Study
of
Multiplicity
and
Usefulness
IBM
Systems
J.
vol.
18
pp
17
1979
SHAH
M.
BAKER
M.
MOGUL
J.C.
SW
AMINATHAN
R.:“Auditing
to
Keep
Online
Storage
Ser-
vices
Honest
Proc
11th
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
61
66
2007
SHAH
S.
SOULES
C.A.N.
GANGER
G.R.
NOBLE
B.N.
Using
Provenance
to
Aid
in
Personal
File
Search
Proc
Annual
Tech
Conf
USENIX
pp
171
184
2007
SHENOY
P.J.
VIN
H.M.
Efficient
Striping
Techniques
for
Variable
Bit
Rate
Continuous
Media
File
Servers
Perf
Eval
J.
vol.
38
pp
175
199
1999
SHUB
C.M.
Unified
Treatment
of
Deadlock
J.
of
Computing
Sciences
in
Colleges
vol.
19
pp
194
204
octubre
2003
SILBERSCHATZ
A.
GALVIN
P.B.
GAGNE
G.:Operating
System
Concepts
with
Java
7a
edición
York
Wiley
2007
SIMON
R.J.
Windows
NT
Win32
API
SuperBible
Corte
Madera
CA
Sams
Publishing
1997
SITARAM
D.
A.
Multimedia
Servers
San
Francisco
Morgan
Kauffman
2000
SMITH
D.K.
ALEXANDER
R.C.
Fumbling
the
Future
How
Xerox
Invented
Then
Ignored
the
First
Personal
Computer
York
William
Morrow
1988
SNIR
M.
OTTO
S.W.
HUSS-LEDERMAN
S.
ALKER
D.W.
DONGARRA
J.:MPI
The
Com-
plete
Reference
Manual
Cambridge
MA
M.I.T.
Press
1996
S.W.
CHEN
G.
KANDEMIR
M.:“A
Compiler-Guided
Approach
for
Reducing
Disk
Power
Con-
sumption
by
Exploiting
Disk
Access
Locality
proc
Int’l
Symp
on
Code
Generation
and
Optimiza-
tion
IEEE
pp
256
268
2006
SPAFFORD
E.
HEAPHY
K.
FERBRACHE
D.
Computer
Viruses
Arlington
ADAPSO
1989
STALLINGS
W.:Operating
Systems
5a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2005
STAN
M.R.
SKADRON
Power-Aware
Computing
Computer
vol.
36
pp
35
38
diciembre
2003
STEIN
C.A.
HOW
ARD
J.H.
SELTZER
M.I.:“Unifying
File
System
Protection
Proc
Annual
Tech
Conf
USENIX
pp
79
90
2001
STEIN
L.
Stupid
File
Systems
Are
Better
Proc
10th
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
p.
2005
STEINMETZ
R.
NAHRSTEDT
K.
Multimedia
Computing
Communications
and
Applications
Up-
per
Saddle
River
NJ
Prentice
Hall
1995
www
FreeLibros.meSTEVENS
R.W.
RAGO
S.A.:“Advanced
Programming
in
the
UNIX
Environment
Reading
MA
Ad-
dison-Wesley
2008
STICHBURY
J.
JACOBS
M.:The
Accredited
Symbian
Developer
Chichester
UK
John
Wiley
2006
STIEGLER
M.
KARP
A.H.
YEE
K.-P.
CLOSE
T.
MILLER
M.S.
Polaris
Virus-Safe
Compu-
ting
for
Windows
XP
Commun
of
the
ACM
col
49
pp
83
88
septiembre
2006
STOESS
J.
LANG
C.
BELLOSA
F.
Energy
Management
for
Hypervisor-Based
Virtual
Machines
Proc
Annual
Tech
Conf
USENIX
pp
14
2007
STOLL
C.
The
Cuckoo’s
Egg
Tracking
Spy
through
the
Maze
of
Computer
Espionage
York
Doubleday
1989
STONE
H.S.
BOKHARI
S.H.
Control
of
Distributed
Processes
Computer
vol.
11
pp
97
106
ju-
lio
1978
STORER
M.W.
GREENAN
K.M.
MILLER
E.L.
VORUGANTI
K.:“POTSHARDS
Secure
Long-
Term
Storage
without
Encryption
Proc
Annual
Tech
Conf
USENIX
pp
143
156
2007
SWIFT
M.M.
ANNAMALAI
M.
BERSHAD
B.N.
LEVY
H.M.
Recovering
Device
Drivers
ACM
Trans
On
Computer
Systems
vol.
24
pp
333
360
noviembre
2006
TALLURI
M.
HILL
M.D.
KHALIDI
Y.A.
New
Page
Table
for
64-Bit
Address
Spaces
Proc
15th
Symp
on
Operating
Systems
Prin
ACM
pp
184
200
1995
TAM
D.
AZIMI
R.
STUMM
M.
Thread
Clustering
Sharing-Aware
Scheduling
Proc
Eurosys
2007
ACM
pp
47
58
2007
TAMAI
M.
SUN
T.
YASUMOTO
K.
SHIBATA
N.
ITO
M.:“Energy-Aware
Video
Streaming
with
QoS
Control
for
Portable
Computing
Devices
Proc
ACM
Int’l
Workshop
on
Network
and
Operating
System
Support
for
Digital
Audio
and
Video
ACM
2004
G.
SUN
N.
GAO
G.R.
Parallel
Dynamic
Programming
Algorithm
on
Multi-Core
Architec-
ture
Proc
19th
ACM
Symp
on
Parallel
Algorithms
and
Arch
ACM
pp
135
144
2007
TANENBAUM
A.S.
Computer
Networks
4a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2003
TANENBAUM
A.S.
Structured
Computer
Organization
5a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2006
TANENBAUM
A.S.
HERDER
J.N.
BOS
H.
File
Size
Distribution
on
UNIX
Systems
Then
and
Now
ACM
SIGOPS
Operating
Systems
Rev
vol.
40
pp
100-104
enero
2006
TANENBAUM
A.S.
AN
RENESSE
R.
AN
STA
VEREN
H.
SHARP
G.J.
MULLENDER
S.J.
JANSEN
J.
AN
ROSSUM
G.
Experiences
with
the
Amoeba
Distributed
Operating
System
Commun
of
the
ACM
vol.
33
pp
46
43
diciembre
1990
TANENBAUM
A.S.
AN
STEEN
M.R.
Distributed
Systems
2a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2006
1042
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1043
TANENBAUM
A.S.
WOODHULL
A.S.:Operating
Systems
Design
and
Implementation
3a
edición
Upper
Saddle
River
NJ
Prentice
Hall
2006
TANG
Y.
CHEN
S.
Automated
Signature-Based
Approach
against
Polymorphic
Internet
Worms
IEEE
Trans
On
Parallel
and
Distributed
Systems
vol.
18
pp
879
892
julio
2007
TEORY
T.J.
Properties
of
Disk
Scheduling
Policies
in
Multiprogrammed
Computer
Systems
Proc
AFIPS
Fall
Joint
Computer
Conf
AFIPS
pp
11
1972
THIBADEAU
R.
Trusted
Computing
for
Disk
Drives
and
Other
Peripherals
IEEE
Security
and
Pri-
vacy
vol.
pp
26
33
septiembre
octubre
2006
THOMPSON
K.
Reflections
on
Trusting
Trust
Commun
of
the
ACM
vol.
27
pp
761
763
agosto
1984
TOLENTINO
M.E.
TURNER
J.
CAMERON
K.W.
Memory-Miser
Performance-Constrained
Runtime
System
for
Power
Scalable
Clusters
Proc
Fourth
Int’l
Conf
on
Computing
Frontiers
ACN
pp
237
246
2007
TSAFIR
D.
ETSION
Y.
FEITELSON
D.G.
KIRKPATRICK
S.
System
Noise
Clock
Ticks
and
Fine-Grained
Parallel
Applications
Proc
19th
Annual
Int’l
Conf
on
Supercomputing
ACM
pp
303
312
2005
TUCEK
J.
NEWSOME
J.
LU
S.
HUANG
C.
XANTHOS
S.
BRUMLEY
D.
ZHOU
Y.
SONG
D.
Sweeper
Lightweight
End-to-End
System
for
Defending
Against
Fast
Worms
Proc
Eurosys
2007
ACM
pp
115
128
2007
TUCKER
A.
GUPTA
A.
Process
Control
and
Scheduling
Issues
for
Multiprogrammed
Shared-Me-
mory
Multiprocessors
Proc
12th
Symp
on
Operating
Systems
Principles
ACM
pp
159
166
1989
UHLIG
R.
NAGLE
D.
STANLEY
T.
MUDGE
T.
SECREST
S.
BROWN
R.:“Design
Tradeoffs
for
Software-Managed
TLBs
ACM
Trans
on
Computer
Systems
vol.
12
pp
175
205
agosto
1994
ULUSKI
D.
MOFFIE
M.
KAELI
D.
Characterizing
Antivirus
Workload
Execution
ACM
SI-
GARCH
Computer
Arch
News
vol.
33
pp
90
98
marzo
2005
VAHALIA
U.
UNIX
Internals—The
New
Frontiers
Upper
Saddle
River
NJ
Prentice
Hall
2007
DOORN
L.
HOMBURG
P.
TANENBAUM
A.S.
Paramecium
An
Extensible
Object-Based
Kernel
Proc
Fifth
Workshop
on
Hot
Topics
in
Operating
Systems
USENIX
pp
86
89
1995
NOORDENDE
G.
BALOGH
A.
HOFMAN
R.
BRAZIER
F.M.T.
TANENBAUM
A.S.
Secure
Jailing
System
for
Confining
Untrusted
Applications
Proc
Second
Int’l
Conf
on
Security
and
Cryptography
INSTICC
pp
414
423
2007
VASW
ANI
R.
ZAHORJAN
J.:“The
Implications
of
Cache
Affinity
on
Processor
Scheduling
for
Mul-
tiprogrammed
Shared-Memory
Multiprocessors
proc
13th
Symp
on
Operating
Systems
Principles
ACM
pp
26
40
1991
VENKATACHALAM
FRANZ
M.
Power
Reduction
Techniques
for
Microprocessor
Systems
Computing
Surveys
vol.
37
pp
195
237
septiembre
2005
www
FreeLibros.meVILLA
H.
Liquid
Cooling
Next
Generation
Data
Center
Strategy
Proc
2006
ACM
IEEE
Conf
on
Su-
percomputing
ACM
Art
287
2006
VINOSKI
S.
CORBA
Integrating
Diverse
Applications
within
Distributed
Heterogeneous
Environ-
ments
IEEE
Communications
Magazine
vol.
35
pp
46
56
febrero
1997
VISCAROLA
P.G.
MASON
T.
CARIDDI
M.
RYAN
B.
NOONE
S.:Introduction
to
the
Windows
Driver
Foundation
Kernel-Mode
Framework
Amherst
NH
OSR
Press
2007
VOGELS
W.
File
System
Usage
in
Windows
NT
4.0
Proc
17th
Symp
on
Operating
Systems
Princi-
ples
ACM
pp
93
109
1999
VON
BEHREN
R.
CONDIT
J.
ZHOU
F.
NECULA
G.C.
BREWER
E.:“Capriccio
Scalable
Th-
reads
for
Internet
Services
Proc
19th
Symp
on
Operating
Systems
Principles
ACM
pp
268
281
2003
VON
EICIKEN
T.
CULLER
D.
GOLDSTEIN
S.C.
SCHAUSER
K.E.
Active
Messages
Me-
chanism
for
Integrated
Communication
and
Computation
Proc
19th
Int’l
Symp
on
Computer
Arch
ACM
pp
256
266
1992
VRABLE
M.
MA
J.
CHEN
J.
MOORE
D.
ANDEKIEFT
E.
SNOEREN
A.C.
VOELKER
G.M.
SA
AGE
S.:“Scalability
Fidelity
and
Containment
in
the
Potemkin
Virtual
Honeyfarm
Proc
20th
Symp
on
Operating
Systems
Principles
ACM
pp
148
162
2005
WAGNER
D.
DEAN
D.:“Intrusion
Detection
via
Static
Analysis
IEEE
Symp
on
Security
and
Privacy
IEEE
pp
156
165
2001
WAGNER
D.
SOTO
P.
Mimicry
Attacks
on
Host-Based
Intrusion
Detection
Systems
Proc
Ninth
ACM
Conf
on
Computer
and
Commun
Security
ACM
pp
255
264
2002
WAHBE
R.
LUCCO
S.
ANDERSON
T.
GRAHAM
S.
Efficient
Software-Based
Fault
Isolation
Proc
14th
Symp
on
Operating
Systems
Principles
ACM
pp
203
216
1993
WALDO
J.
The
Jini
Architecture
for
Network-Centric
Computing
Commun
of
the
ACM
vol.
42
pp
76
82
julio
1999
WALDO
J.
Alive
and
Well
Jini
Technology
Today
Computer
vol.
33
pp
107
109
junio
2000
WALDSPURGER
C.A.
Memory
Resource
Management
in
VMware
ESX
server
ACM
SIGOPS
Ope-
rating
System
Rev
vol.
36
pp
181
194
enero
2002
WALDSPURGER
C.A.
WEIHL
W.E.
Lottery
Scheduling
Flexible
Proportional-Share
Resource
Management
Proc
First
Symp
on
Operating
System
Design
and
Implementation
USENIX
pp
12
1994
WALKER
W.
CRAGON
H.G.:“Interrupt
Processing
in
Concurrent
Processors
Computer
vol.
28
pp
36
46
junio
1995
WANG
A.
KUENNING
G.
REIHER
P.
POPEK
G.:“The
Conquest
File
System
Better
Performan-
ce
through
Disk
Persistent-RAM
Hybrid
Design
ACM
Trans
On
Storage
vol.
pp
309
348
agosto
2006
1044
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1045
WANG
L.
DASGUPTA
P.:“Kernel
and
Application
Integrity
Assurance
Ensuring
Freedom
from
Root-
kits
and
Malware
in
Computer
System
Proc
21st
Int’l
Conf
on
Advanced
Information
Networking
and
Applications
Workshops
IEEE
pp
583
589
2007
WANG
L.
XIAO
Survey
of
Energy-Efficient
Scheduling
Mechanisms
in
Sensor
Networks
Mo-
bile
Networks
and
Applications
vol.
11
pp
723
740
octubre
2006a
WANG
R.Y.
ANDERSON
T.E.
PATTERSON
D.A.:“Virtual
Log
Based
File
Systems
for
Program-
mable
Disk
Proc
Third
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
29
43
1999
WANG
X.
LI
Z.
XU
J.
REITER
M.K.
KIL
C.
CHOI
J.Y.
Packet
vaccine
Black-Box
Exploit
Detection
and
Signature
Generation
Proc
13th
ACM
Conf
on
Computer
and
Commun
Security
ACM
pp
37
46
2006b
WEIL
S.A.
BRANDT
S.A.
MILLER
E.L.
LONG
D.D.E.
MALTZAHN
C.
Ceph
Scalable
High-Performance
Distributed
File
System
Proc
Seventh
Symp
on
Operating
System
Design
and
Im-
plementation
USENIX
pp
307
320
2006
WEISER
M.
WELCH
B.
DEMERS
A.
SHENKER
S.
Scheduling
for
Reduced
CPU
Energy
Proc
First
Symp
on
Operating
System
Design
and
Implementation
USENIX
pp
13
23
1994
WHEELER
P.
FULP
E.
Taxonomy
of
Parallel
Techniques
of
Intrusion
Detection
Proc
45th
An-
nual
Southeast
Regional
Conf
ACM
pp
278
282
2007
WHITAKER
A.
COX
R.S.
SHA
M.
GRIBBLE
S.D.:“Rethinking
the
Design
of
Virtual
Machine
Monitors
Computer
vol.
38
pp
57
62
mayo
2005
WHITAKER
A.
SHA
M.
GRIBBLE
S.D.:“Scale
and
Performance
in
the
Denali
Isolation
Kernel
ACM
SIGOPS
Operating
Systems
Rev
vol.
36
pp
195
209
enero
2002
WILLIAMS
A.
THIES
W.
ERNST
M.D.
Static
Deadlock
Detection
for
Java
Libraries
Proc
Eu-
ropean
Conf
on
Object-Oriented
Programming
Springer
pp
602
629
2005
WIRES
J.
FEELEY
M.
Secure
File
System
Versioning
at
the
Block
Level
Proc
Eurosys
2007
ACM
pp
203
215
2007
WIRTH
N.
Plea
for
Lean
Software
Computer
vol.
28
pp
64
68
febrero
1995
Wolf
W.
The
Future
of
Multiprocessor
Systems-on-Chip
Proc
41st
Annual
Conf
on
Design
Automa-
tion
ACM
pp
681
685
2004
WONG
C.K.
Algorithmic
Studies
in
Mass
Storage
Systems
York
Computer
Science
Press
1983
WRIGHT
C.P.
SPILLANE
R.
SIV
ATHANU
G.
ZADOK
E.:“Extending
ACID
Semantics
to
the
Fi-
System
ACM
Trans
on
Storage
vol.
Art
junio
2007
WU
M.-W.
HUANG
Y.
ANG
Y.-M.
KUO
S.Y.:“A
Stateful
Approach
to
Spyware
Detection
and
Removal
Proc
12th
Pacific
Rim
Int’l
Symp
on
Dependable
Computing
IEEE
pp
173
182
2006
www
FreeLibros.me1046
LISTA
LECTURAS
BIBLIOGRAFÍA
CAPÍTULO
14
WULF
W.A.
COHEN
E.S.
CORWIN
W.M.
JONES
A.K.
LEVIN
R.
PIERSON
C.
POLLACK
F.J.:“HYDRA
The
Kernel
of
Multiprocessor
Operating
System
Commun
of
the
ACM
vol.
17
pp
337
345
junio
1974
YAHA
I.
RASCHID
L.
ANDRADE
H.:“Bid
Based
Scheduler
with
Backfilling
for
Multiprocessor
System
Proc
Ninth
Int’l
Conf
on
Electronic
Commerce
ACM
pp
459
468
2007
YANG
J.
TWOHEY
P.
ENGLER
D.
MUSUV
ATHI
M.:“Using
Model
Checking
to
Find
Serious
Fi-
System
Errors
ACM
Trans
on
Computer
Systems
vol.
24
pp
393
423
2006
YANG
L.
PENG
L.
SecCMP
Secure
Chip-Multiprocessor
Architecture
Proc
1st
Workshop
on
Ar-
chitectural
and
System
Support
for
Improving
Software
Dependability
ACM
pp
72
76
2006
YOON
E.J.
RYU
E.-K.
YOO
K.-Y.
Secure
User
Authentication
Scheme
Using
Hash
Functions
ACM
SIGOPS
Operating
Systems
Rev
vol.
38
pp
62
68
abril
2004
YOUNG
M.
TEV
ANIAN
A.
Jr
RASHID
R.
GOLUB
D.
EPPINGER
J.
CHEW
J.
BOLOSKY
W.
BLACK
D.
BARON
R.
The
Duality
of
Memory
and
Communication
in
the
Implementation
of
Multiprocessor
Operating
System
Proc
11th
Symp
on
Operating
Systems
Principles
ACM
pp
63
76
1987
YU
H.
AGRA
D.
ABBADI
A.:“MEMS-Based
Storage
Architecture
for
Relational
Databa-
ses
VLDB
J.
vol.
16
pp
251
268
abril
2007
YUAN
W.
NAHRSTEDT
K.:“Energy-Efficient
CPU
Scheduling
for
Multimedia
Systems
ACM
Trans
on
Computer
Systems
ACM
vol.
24
pp
292
331
agosto
2006
ZACHARY
G.P.:Showstopper
York
Maxwell
Macmillan
1994
ZAHORJAN
J.
LAZOWSKA
E.D.
EAGER
D.L.
The
Effect
of
Scheduling
Discipline
on
Spin
Overhead
in
Shared
Memory
Parallel
Systems
IEEE
Trans
on
Parallel
and
Distr
Systems
vol.
pp
180
198
abril
1991
ZAIA
A.
BRUNEO
D.
PULIAFITO
A.:“A
Scalable
Grid-Based
Multimedia
Server
Proc
13th
IEEE
Int’l
Workshop
on
Enabling
Technologies
Infrastructure
for
Collaborative
Enterprises
IEEE
pp
337
342
2004
ZARANDIOON
S.
THOMASIAN
A.
Optimization
of
Online
Disk
Scheduling
Algorithms
ACM
SIGMETRICS
Performance
Evaluation
Rev
vol.
33
pp
42
46
2006
ZEKAUSKAS
M.J.
SA
WDON
W.A.
BERSHAD
B.N.:“Software
Write
Detection
for
Distributed
Shared
Memory
Proc
First
Symp
on
Operating
System
Design
and
Implementation
USENIX
pp
87
100
1994
ZELDOVICH
N.
BOYD-WICKIZER
KOHLER
E.
MAZIERES
D.
Making
Information
Flow
Explicit
in
HiStar
Proc
Sixth
Symp
on
Operating
Systems
Design
and
Implementation
USENIX
pp
263
278
2006
ZHANG
L.
PARKER
M.
CARTER
J.:“Efficient
Address
Remapping
in
Distributed
Shared-Memory
Systems
ACM
Trans
on
Arch
and
Code
Optimization
vol.
pp
209
229
junio
2006
www
FreeLibros.meSECCIÓN
14.2
BIBLIOGRAFÍA
ORDEN
ALFABÉTICO
1047
ZHANG
Z.
GHOSE
K.
HFS
Hybrid
File
System
Prototype
for
Improving
Small
File
and
Metada-
ta
Performance
Proc
Eurosys
2007
ACM
pp
175
187
2007
ZHOU
Y.
LEE
E.A.
Causality
Interface
for
Deadlock
Analysis
in
Dataflow
Proc
6th
Int’l
Conf
on
Embedded
Software
ACM
IEEE
pp
44
52
2006
ZHOU
Y.
PHILBIN
J.F.:“The
Multi-Queue
Replacement
Algorithm
for
Second
Level
Buffer
Caches
Proc
Annual
Tech
Conf
USENIX
pp
91
104
2001
ZOBEL
D.
The
Deadlock
Problem
Classifying
Bibliography
ACM
SIGOPS
Operating
Systems
Rev
vol.
17
pp
16
octubre
1983
ZUBERI
K.M.
PILLAI
P.
SHIN
K.G.
EMERALDS
Small-Memory
Real-Time
Microkernel
Proc
17th
Symp
on
Operating
Systems
Principles
ACM
pp
277
299
1999
ZWICKY
E.D.:“Torture-Testing
Backup
and
Archive
Programs
Things
You
Ought
to
Know
But
Probably
Would
Rather
Not
Proc
Fifth
Conf
on
Large
Installation
Systems
Admin
USENIX
pp
181
190
1991
www.FreeLibros.me
www.FreeLibros.metoken
Vista
919
violación
Vista
888
Accidental
pérdida
datos
616
Acción
atómica
128
ACE
vea
Acceso
entrada
control
acceso
ACL
vea
Acceso
lista
control
acierto
caché
24
ACPI
vea
Interfaz
avanzada
configuración
energía
Activaciones
programación
111-112
ActiveX
control
686
859
Activo
mensaje
558
objeto
symbian
939-940
Ada
Adaptador
331
gráficos
406
objeto
597
Administración
energía
417-425
batería
423-424
comunicación
inalámbrica
422-423
ÍNDICE
1049
Abajo-arriba
implementación
980-981
Absoluta
nombre
ruta
269
ruta
781
Acceso
archivos
262
control
discrecional
634
discrecional
ACL
Vista
919
directo
memoria
29-30
336-339
347
Symbian
946-947
entrada
control
acceso
ACE
920
lista
control
ACL
624-627
Vista
828
uniforme
memoria
876
uniforme
memoria
multiprocesador
531-533
secuencial
262
uniforme
memoria
multiprocesador
526-531
www
FreeLibros.meCPU
421-422
cuestiones
hardware
418-419
cuestiones
aplicaciones
424-425
cuestiones
sistema
operativo
419
disco
420-421
memoria
422
pantalla
419-420
térmica
423
Administración
memoria
175-248
Linux
758-771
mapas
bits
185
listas
memoria
libre
185-187
overlays
188
symbian
937
941-945
Vista
844
879-894
memoria
física
Linux
762-766
derechos
digitales
833
procesos
Linux
741-745
proyectos
994-998
diodo
malas
noticias
996
efecto
sistema
997
equipo
programador
jefe
996
estructura
equipos
995-997
función
experiencia
997
hombre-mes
mítico
994
bala
plata
998
espacio
disco
292-298
térmica
423
Administrador
caché
Vista
844
configuración
Vista
844
energía
Vista
905
entrada
salida
Vista
842
memoria
175
objetos
824
Vista
842
procesos
Vista
843
ventanas
403
conjunto
balance
Vista
891
Adquisición
recursos
435-437
ADSL
vea
Línea
suscriptor
digital
asimétrica
Adversario
615
Adware
687
1050
ÍNDICE
Afinidad
hilos
Vista
862
programación
545
Agente
705
Aiken
Howard
Ajuste
rápido
algoritmo
187
Alarma
señal
39
Algorítmico
paradigma
966
Algoritmo
asignación
procesos
566
envejecimiento
208
frecuencia
fallo
página
217-218
gráfico-teórico
566-567
iniciado
receptor
568
iniciado
emisor
567-568
firma
mensajes
620
hash
seguro
620
paginación
global
216-217
paginación
local
216-217
programación
145-163
categorías
149
niveles
545
hilos
162-163
multicomputadoras
565
tiempo
real
150
152
160-163
488-493
garantizado
158-159
inteligente
544
introducción
145-152
Linux
752-755
menor
tiempo
respuesta
491-493
menor
tiempo
restante
continuación
154
monotónica
frecuencia
490-491
multimedia
487-493
múltiples
colas
156-158
multiprocesador
542-548
preferente
149
objetivos
150-152
afinidad
545
pandilla
546-548
partes
iguales
160
prioridades
155-156
sorteo
159
turno
rotatorio
154-155
www
FreeLibros.meÍNDICE
1051
preferente
149
llegar
atendido
152-153
proceso
corto
continuación
158
sistema
procesamiento
lotes
149-150
152-154
sistema
interactivo
150-151
154-160
trabajo
corto
153-154
Vista
874-879
programación
discos
379-382
búsqueda
corta
380
elevador
381
reclamación
marcos
página
768-771
oportunidad
204-205
sustitución
página
201-216
769
conjunto
trabajo
209-213
reciente
206-207
global
216-217
Linux
768-771
local
216-217
usó
recientemente
203-204
utilizada
frecuencia
207-208
óptimo
202-203
entrar
salir
204
reloj
205-206
resumen
215-216
oportunidad
204-205
Vista
890-891
WSclock
213-214
óptimo
sustitución
páginas
202-203
Almacenamiento
respaldo
231-233
estable
385-388
local
hilo
Vista
862
ALPC
vea
LPC
avanzada
Alternancia
estricta
121-122
Alternativo
flujo
datos
Vista
912
Amenaza
613-614
Anillo
protección
246
Aparato
superior
TV
470
APC
vea
Llamada
procedimiento
asíncrona
Aperiódico
sistema
tiempo
real
161
API
vea
Interfaz
programación
aplicaciones
Applet
705
Apuntador
pila
20
72-73
referenciado
850
Archivo
40-43
asignado
225
bloque
crudo
778
compartido
283-285
asignación
memoria
760
acceso
secuencial
262
aleatorio
262
bloque
crudo
Linux
778
código
objeto
74
encabezado
73-74
736
encabezado
73-74
735
paginación
Vista
881-883
disperso
Vista
912
especial
772
caracteres
43
260
772
bloques
43
260
772
Linux
772
implementación
274-280
implementado
lista
277-278
inmediato
Windows
Vista
912
objeto
74
persistente
256
regular
260
señuelo
695
Área
intercambio
769
Área
lisa
CD-ROM
367
368
Argumento
punta
cabo
972
Arquitectura
común
intermediarios
peticiones
objetos
596-597
estándar
industria
31
etiquetada
628
Arreglo
redundante
discos
económicos
363-367
Arriba-Abajo
implementación
980-981
Asignación
contigua
274
almacenamiento
Vista
912-915
direcciones
virtuales
Vista
881
listas
enlazadas
277-278
Asignador
páginas
766
www
FreeLibros.meAsistente
digital
personal
35
Asociativa
memoria
196
Atanasoff
John
7-8
Ataque
mímica
705
retorno
libc
664-665
usuarios
internos
656-659
cadenas
formato
662-664
desbordamiento
búfer
660-662
enteros
665
escalada
privilegios
667
inyección
código
666
Atributo
archivo
263
archivo
263-264
residente
NTFS
910
Audio
MPEG
nivel
484-487
Autenticación
142
641-656
biométrica
653
objeto
físico
651
contraseña
642-643
Autoasignación
Vista
872
889
Automontaje
799
NFS
798
Autoridad
certificación
621
Avestruz
algoritmo
441
AWE
vea
Extensiones
ventana
dirección
lenguaje
programación
721
Babbage
Charles
Backoff
exponencial
binario
584
Balance
cargas
565-568
Bandas
amplias
510
estrechas
510
Bandeja
correo
143
Bandera
comando
732
Banquero
algoritmo
451-454
recurso
451-452
recursos
452-454
Barajado
perfecto
529
Barrera
144-145
1052
ÍNDICE
Base
cómputo
confianza
631-632
Base
datos
números
marco
página
Vista
891
Batería
administración
423-424
Bell-La
Padula
modelo
634-636
Berkeley
UNIX
723-724
Berry
Clifford
7-8
Biba
modelo
636
Biblioteca
compartida
223-225
vínculos
dinámicos
223
Binaria
traducción
573
Binario
semáforo
129
Biométrica
653
BIOS
vea
Sistema
básico
entrada
salida
Bit
espera
despertar
128
presente
ausente
191
sucio
194
BitLocker
918
Bloque
básico
573
control
procesos
91
entorno
hilo
Vista
862
entorno
proceso
Vista
862
firma
620
faltante
305
indirecto
individual
322
795
indirecto
triple
322
795
iniciado
símbolo
758
libre
295
tamaño
292
Bloqueo
compartido
784
archivo
783
fases
545
giro
122
539
páginas
230-231
exclusivo
784
Bloques
archivo
especial
43
260
Linux
772
Blue
pill
688
Bluetooth
399
Blu-ray
375-376
468
Bomba
tiempo
657
lógica
656-657
www
FreeLibros.meÍNDICE
1053
Brinch
Hansen
Per
136
Brooks
Fred
11
BSD
14
BSOD
vea
Pantalla
azul
muerte
BSS
vea
Bloque
iniciado
símbolo
Búfer
circular
356
traducción
adelantada
195-197
196
197-198
885
fallo
duro
198
fallo
suave
198
limitado
126
Bus
30-32
serial
universal
32
Búsqueda
corta
algoritmo
380
traslapada
361
Byron
Lord
lenguaje
programación
721
preprocesador
74
programación
72-75
Caballo
Troya
670-672
Caché
777
844
894
895
acierto
24
archivos
307-310
multimedia
512-513
bloques
307
multimedia
511-512
búfer
307
escritura
inmediata
309
objetos
Linux
767
L1
25
L2
25
servidor
Web
998
línea
24
527
memoria
23-24
Cadena
hash
vía
649
Cajas
arena
706-708
Calidad
servicio
471
586
Cambio
bancos
Vista
883
contexto
27
154
proceso
154
Campo
475
Canal
encubierto
637-641
Canal
lateral
653
Canalización
20-21
43
734
741
Cañón
órgano
algoritmo
507
Capacidad
627-630
intercambio
770
Carácter
escape
398
Carga
útil
virus
673
Carpeta
vea
Directorio
video
demanda
496-499
CC-NUMA
vea
multiprocesador
NUMA
cachés
coherentes
CD
grabable
371-373
regrabable
373
ROM
367-373
multisesión
372
XA
372
pista
372
sector
369
sistema
archivos
312-313
Cena
filósofos
problema
164-167
CERT
vea
Equipo
Respuesta
Emergencias
Computacionales
Certificado
621
Cifrado
617
618
696
917
918
archivos
Vista
917-918
sustitución
monoalfabética
618
Cilindro
26
Cinta
27
Circuito
integrado
11
Clase
driver
Vista
847
Clave
criptográfica
617
archivo
260
Vista
848
Cliente
67
delgado
415-417
Cliente-servidor
diseño
935-936
modelo
67
sistema
973-974
Clúster
estaciones
trabajo
548
computadoras
548
tamaño
319
www
FreeLibros.meCMP
vea
Multiprocesador
nivel
chip
CMS
vea
Sistema
monitor
conversacional
Codificación
pérdidas
478
audio
476-478
formas
onda
484
video
473-476
478-484
perceptual
484
Código
byte
710
corrección
errores
332
exploración
395
independiente
posición
225
móvil
705-706
multihilo
114-117
Coherencia
arquitectónica
965
Colegas
algoritmo
766
Colossus
COM
vea
Modelo
objetos
componentes
Comando
protección
633
Comodín
626
732
Compactación
archivos
semántica
594-596
memoria
183
Compartición
espacio
545
tiempo
12-14
multiprocesador
543-545
falsa
563-564
Compilador
portable
722
Compresión
archivos
Vista
916-917
audio
484-487
video
478-484
Comprobación
errores
986
Comprobador
integridad
699
comportamiento
699-700
Compuerta
llamadas
246
Computadora
cuarta
generación
15-18
generación
7-8
generación
generación
10-15
operada
batería
1002
Comunicación
937
953-957
1054
ÍNDICE
procesos
39
117-145
940
941
Vista
868
869
inalámbrica
422
Concesiones
601
espacio
tiempo
988-991
tiempo
espacio
988-991
Condición
carrera
117-119
127
Confidencialidad
datos
613
Conjunto
trabajo
algoritmo
209-213
trabajo
modelo
210
Conmutación
circuitos
551
paquetes
almacenamiento
retransmisión
550
Consistencia
secuencial
564-565
594
Consola
recuperación
Vista
848
Contador
programa
20
CONTEXT
estructura
datos
Vista
865
Contexto
dispositivo
410
Contraseña
263
626
642-653
657
658
649-650
Control
acceso
discrecional
634
acceso
obligatorio
634
admisión
algoritmo
472
carga
218-219
cuentas
usuario
923
Controlador
dispositivo
331
Convertidor
análogo
digital
476
Copia
oculta
volumen
Vista
897
Copiar
escritura
223
748
883
Co-programación
547
CORBA
vea
Arquitectura
común
intermediarios
peticiones
objetos
COW
vea
Clúster
estaciones
trabajo
CP
vea
Programa
control
microcomputadoras
CPU
vea
Unidad
central
proceso
CPU
superescalar
20-21
Cracker(s
642
métodos
intrusión
643-647
Creación
bandas
disco
364
CreateProcessA
826
CreateProcessW
826
www
FreeLibros.meÍNDICE
1055
Criptografía
616-622
clave
pública
618-619
clave
secreta
617-618
clave
simétrica
612-618
Criterios
comunes
844
Crominancia
475
Csrss.exe
821
CSY
módulo
955
CTSS
vea
Sistema
compatible
tiempo
compartido
Cuadro
474
CD-ROM
369
programar
148-149
Cuantización
479
ruido
477
Cubo
549
Cuestiones
programas
aplicación
424
Cuota
297
298
850
disco
297-298
Cutler
David
17
DACL
vea
Acceso
discrecional
ACL
Vista
DAG
vea
Gráfico
acíclico
dirigido
Datos
compartidos
usuario
Vista
862
DB
vea
Decibel
Decibel
476
Decodificación
video
478
Defensa
profundidad
692
Defensa
malware
692-712
Dekker
algoritmo
123
Demonio
87
359
740
impresión
118
paginación
226
769
Denominación
archivos
257-259
uniforme
343
Dentry
estructura
datos
Linux
789
Desajuste
cabezas
377
cilindros
376
Descarga
paso
685
Descriptor
archivo
42
267
785
direcciones
virtuales
885
páginas
Linux
763
seguridad
Vista
823
920
volumen
primario
313
Desfragmentación
311
Deshabilitación
interrupciones
120-121
Detección
intrusos
basada
modelos
703-705
Diámetro
549
DIB
vea
Mapa
bits
independiente
dispositivo
Dijkstra
E.W.
128
Diodo
malas
noticias
996
Dirección
IP
588
644
lineal
244
virtual
189-19
Direccionamiento
memorias
extensas
Vista
883-884
bloques
lógicos
363
Directiva
limpieza
226
programación
161
mecanismo
comparación
67
161-162
233-234
975-976
Directorio
actual
270
cola
impresión
359
páginas
245
trabajo
42
270-271
781
nivel
268
implementación
280-282
jerárquico
268-269
raíz
42
268
Disciplina
línea
778
Disco
48-49
70
CD-ROM
367-372
entrelazado
doble
378
simple
378
dinámico
Vista
897
DVD
373-376
entrelazado
378
531
IDE
361
magnético
361
RAID
363-367
www
FreeLibros.meSATA
361
versátil
digital
373-376
468
virtual
573
visual
audio
385
Disponibilidad
sistema
614
Dispositivo(s
bloque
330
bloque
transaccional
796
caracteres
330
350
entrada
salida
27-30
330-331
dedicados
358
red
778
354
772
menor
58
354
772
virtual
579
DLL
vea
Biblioteca
vínculos
dinámicos
DMA
vea
Acceso
directo
memoria
DNS
vea
Sistema
nombres
dominio
Doble
anillo
549
Doble
búfer
322
795
Dominio
622
578
protección
622-624
vea
Sistema
operativo
disco
DPC
vea
Llamada
procedimiento
diferida
Driver
dispositivo
28
349-353
cargado
forma
dinámica
28
945-946
Vista
845-847
901-902
dispositivo
reentrante
352
dispositivo
virus
678-679
filtro
Vista
904
DRM
vea
Administración
derechos
digitales
DSM
vea
Memoria
compartida
distribuida
Duplicación
563
DV
vea
Video
Digital
DVD
vea
Disco
DVD
alta
definición
375-376
468
Eckert
J.
Presper
Eco
echo
396
1056
ÍNDICE
E-cos
179
EEPROM
vea
PROM
eléctricamente
borrable
Efecto
tablero
ajedrez
238
sistema
997
EFS
vea
Sistema
cifrado
archivos
Ejecutivo
Vista
836
Electrónica
unidades
integradas
28
361
Elevador
algoritmo
381
Linux
778-779
Encuentro
144
ENIAC
Enlazador
74
Enmascaramiento
frecuencia
484
temporal
486
Enrutador
459
585
Enrutamiento
segmentado
551
Entrada
43-44
329-427
tabla
páginas
193-194
estándar
733
Entrada
salida
asíncrona
344
búfer
344
355-357
Linux
771-779
Vista
896-906
niveles
software
348-360
945-948
asignación
memoria
332-3367
interrupciones
346
347
proceso
ligado
147
programada
344-346
búfer
Vista
895
síncrona
344
DMA
347
EPOC
931
Equipo
respuesta
emergencias
computacionales
684
programador
jefe
996
Errno
variable
114
Error(es
código
explotación
659-667
estándar
733
Escritor
www
FreeLibros.meÍNDICE
1057
páginas
asignadas
Vista
893
modificadas
Vista
893
Espacio(s
221
direcciones
38
40
179-187
direcciones
extensas
1000
direcciones
virtuales
189-192
Linux
767-768
nombres
objetos
Vista
852-858
puertos
entrada
salida
28
tuplas
598-599
221
separado
instrucciones
datos
221
Esqueleto
596
activo
inactivo
125-126
128
proceso
90-91
inseguro
450-451
seguro
450-451
Esteganografía
639-641
Estructura(s
archivo
259-260
datos
archivo
Linux
789
equipo
995-997
sistema
operativo
971-975
estáticas
dinámicas
comparación
979-980
Ethernet
583-584
Evento
notificación
870
sincronización
870
Evento
870
Exclusión
mutua
119
alternancia
estricta
121-122
bloqueo
giro
122
ocupado
espera
120-125
deshabilitación
interrupciones
120-121
inactividad
wakeup
125-126
inversión
prioridades
126
ocupado
espera
22
solución
Peterson
123-124
variable
bloqueo
121
Exokernel
71
972-973
Exploración
errores
código
659-667
localidad
993
puertos
646
Ext2
sistema
archivos
Linux
788-795
Ext3
sistema
archivos
Linux
795-796
Extensión
extensiones
archivo
258-259
276
dirección
física
767
888
ventana
dirección
884
Fair-share
programación
160
Fallo
página
191
algoritmo
frecuencia
217-218
duro
Vista
889
manejo
228-229
Linux
768-771
Vista
886-890
suave
Vista
881
889
FAT
vea
Tabla
asignación
archivos
FAT
-16
sistema
archivos
257
906
-32
sistema
archivos
257
906
FCFS
vea
algoritmo
llegar
atendido
Fibra
470
585
864
871
FIFO
vea
Algoritmo
sustitución
página
entrar
salir
Filtro
733
905
Vista
845
Finger
demonio
683
Firewall
693-695
695
personal
695
694
Firma
código
701-702
digital
619-621
Flash
dispositivo
863
memoria
25
Flashing
847
Fluctuación
471
Flujo
datos
predeterminado
Vista
912
www
FreeLibros.meFormato
alto
nivel
379
nivel
376
disco
376-379
disco
universal
276
FORTRAN
8-10
Monitor
System
10-11
Fragmentación
220
312
externa
238
interna
219-220
FreeBSD
18
Fuerza
bruta
985-986
Función
hash
criptográfica
619
experiencia
997
vía
619
Fundación
drivers
Windows
901
Gabor
ondículas
655
Gates
Bill
15-16
GDI
vea
Interfaz
dispositivo
gráfico
GDT
vea
Tabla
descriptores
globales
Generalidades
Linux
728-739
GID
vea
Linux
ID
grupo
Giro
conmutación
comparación
541-542
Globus
kit
herramientas
603
Gnome
18
Gooey
vea
Interfaz
gráfica
usuario
Grado
multiprogramación
94
Gráfico
acílico
dirigido
283
bloqueo
kernel
755
cargador
inicio
unificado
755
Granja
discos
508
GRUB
vea
cargador
inicio
unificado
Grupo
626
Grupo
expertos
películas
481
Grupo
expertos
unidos
fotografía
478
GUI
vea
Interfaz
gráfica
usuario
Gusano
682-684
1058
ÍNDICE
Hacker
642
sombrero
blanco
642
sombrero
negro
642
HAL
vea
Nivel
abstracción
hardware
Hardware
disco
361-375
entrada
salida
329-343
protección
47-48
heredado
33
HD
DVD
vea
DVD
alta
definición
Herramienta
computadora
13
Hibernación
Vista
905
High
Sierra
CD-ROM
370
Hijo
proceso
39
740
Hilo(s
95-117
despachador
98
emergente
112-114
558
implementación
brida
110-111
espacio
kernel
109-110
espacio
usuario
106-109
Linux
748-752
POSIX
104-106
938-939
Vista
864-879
Hipercubo
550
Hipervínculo
590
Hipervisor
70
llamada
574
tipo
570
571-572
tipo
572
573
Historia
Linux
726-728
sistemas
operativos
7-18
MS-DOS
814
UNIX
Linux
720-728
Windows
813-819
Hive
Vista
829
830
844
Hoare
C.A.R.
136
Host
459
585
Hosting
compartido
69
Hoyo
CD-ROM
367-368
Husmeador
paquetes
646
Hyperthreading
22
www
FreeLibros.meÍNDICE
1059
IAT
vea
Tabla
direcciones
importación
vista
IBM
1401
7094
9-10
zSeries
11
IBSYS
10
IC
vea
Circuito
integrado
ID
grupo
39
Linux
803
proceso
54
usuario
39
Linux
803
IDE
disco
vea
Electrónica
unidades
integradas
Identificador
proceso
740
seguridad
919
IDL
vea
Lenguaje
definición
interfaz
IDS
vea
Sistema
detección
intrusos
IIOP
597
Impersonation
Vista
920
Implementación
hilos
Linux
745-752
Vista
871-873
administración
memoria
Linux
762-771
Vista
885-894
Linux
775
paginación
227-234
segmentación
237-238
seguridad
Linux
806
Vista
922
administrador
objetos
Vista
848-858
sistemas
operativos
971-986
procesos
Linux
745-752
Vista
871-873
sistema
archivos
Linux
788-796
Vista
908-918
Inanición
165
461
Independencia
dispositivo
343
358
ubicación
594
Indicador
45
shell
732
Indirección
984
Infierno
DLLs
859
Infraestructura
clave
pública
621
Inicio
755
bloque
273
computadora
33
Linux
755-757
Vista
847-848
driver
Vista
847
seguro
Vista
847
virus
sector
677-678
Instrucción
privilegiada
571
sensible
871
Integridad
datos
614
Intel
núcleo
17
Interbloqueo
433-463
comunicaciones
458-459
recursos
437-438
detección
recuperación
442-448
revisión
447-448
eliminación
procesos
447-448
preferencia
447
condiciones
437-438
evitar
448-454
investigación
461
modelado
438-441
prevención
454-457
ataque
condición
preferente
455
ataque
contención
espera
455
ataque
espera
circular
456-457
ataque
exclusión
mutua
454-455
trayectorias
449-450
Intercambio
181-184
Interconexión
componentes
periféricos
31
Interfaces
Linux
730-731
Interfaz
avanzada
configuración
energía
424
controlador
dispositivo
353-355
www.FreeLibros.mede
dispositivo
gráfico
410
driver
424
kernel
driver
776
llamadas
sistema
968-970
máquina
virtual
575
memoria
virtual
226-227
paso
mensajes
140-144
programación
aplicaciones
60
574
gráfica
usuario
1-2
404-411
725
sistemas
cómputo
pequeños
32
Intermediario
peticiones
objetos
596
Internet
548-586
Interpretación
708-709
Intérprete
comandos
38
Interrupción
29
339-343
imprecisa
342-343
precisa
341-342
Interruptor
barras
cruzadas
527
Intrinsics
402
Intruso
615-616
Inversión
prioridad
126
878
Investigación
administración
memoria
247
digital
15-16
entrada
salida
425-426
interbloqueo
461
procesos
hilos
168-169
seguridad
711-712
sistema
archivos
324
procesadores
604-605
operativo
multimedia
516-517
operativos
general
76-77
seguridad
711-712
IP
vea
Protocolo
Internet
IPC
vea
Comunicación
procesos
IRP
vea
Paquete
peticiones
entrada
salida
ISA
vea
Arquitectura
estándar
industria
ISO
9660
sistema
archivos
313-316
ISR
vea
Rutina
servicio
interrupción
Jaulas
datos
953
Java
seguridad
709-711
1060
ÍNDICE
JavaSpace
602-603
JBD
vea
Dispositivo
bloque
transaccional
jerarquía
directorios
592-593
memoria
23
715
Jiffy
752
Jini
601-603
JKD
vea
Kit
desarrollo
Java
Jobs
Steve
16
Joliet
extensiones
317-318
JPEG
vea
Grupo
expertos
unidos
fotografías
JPEG
estándar
478-481
JVM
vea
Máquina
virtual
Java
KDE
18
Kerckhoffs
principio
617
Kernel
estructura
Linux
736-739
extensión
946
hilos
974
nivel
Vista
836-838
Vista
832
836
Keylogger
668
Kildall
Gary
15
Kit
desarrollo
Java
710
KMDF
vea
Marco
trabajo
driver
kernel
ontogenia
recapitula
filogenia
46-49
LAN
vea
Red
área
local
Laptop
771
LDT
vea
Tabla
descriptores
locales
LPC
avanzada
845
Lectores
escritores
problema
167-168
Lectura
adelantada
310
NFS
802
Lenguaje
definición
interfaz
596
Ley
Moore
533
www
FreeLibros.meÍNDICE
1061
Murphy
118
Zipf
506
Libro
amarillo
CD-ROM
368-369
naranja
371
rojo
CD-ROM
367
verde
CD-ROM
370
Limpiador
286
Linda
598-599
Línea
suscriptor
digital
asimétrica
468
775
Linus
programador
elevador
778-789
Linux
15
719-806
Administración
memoria
758-771
procesos
741-745
algoritmo
reclamación
página
768-771
elevador
778-779
archivo
bloques
crudo
778
especial
bloques
772
especial
caracteres
772
caché
objetos
767
descriptor
página
763
entrada
salida
771-779
espacio
direcciones
virtuales
767-768
estructura
datos
archivos
789
datos
nodo-i
789
datos
dentry
789
kernel
736-739
hilo
748-752
historia
15
726-728
ID
grupo
803
ID
usuario
803
identificador
proceso
740
implementación
procesos
745-752
inicio
755-757
interfaces
730-731
llamadas
sistema
acceso
114
639
679
805
806
alarma
116
390
745
994
administración
memoria
761-762
administración
procesos
741-745
archivos
785
785-788
entrada
salida
775-779
llamadas
sistema
código
brk
55
759
761
chdir
58
675
751
787
chmod
59
672
805
chown
672
clone
750
752
946
977
close
56
264
290
493
704
774
785
799
800
closedir
272
creat
785
788
create
264
272
633
785
exec
54
55
81
110
623
661
677
742
743
744
748
762
821
867
969
976
977
execve
54
60
87
88
exit
55
88
704
744
fcntl
787
fork
52
54
60
81
87
88
104
105
222
223
460
537
740
741
742
747
748
749
750
751
768
808
809
821
862
863
867
969
976
986
fstat
56
786
fsuid
811
fsync
771
getpid
740
ioctl
775
898
900
kill
59
89
745
link
57
272
787
788
lseek
81
289
749
751
786
810
965
mkdir
57
787
mmap
761
809
827
mount
42
58
800
801
munmap
761
nice
753
open
56
114
264
270
289
318
325
358
435
411
493
627
703
772
785
789
791
799
800
802
898
933
935
opendir
272
pause
91
745
pipe
786
www.FreeLibros.meread
21
38
49
50
56
59
66
98
99
104
108
109
170
262
264
267
272
289
290
291
344
355
493
494
594
595
622
703
704
730
754
760
771
772
785
786
789
792
794
799
800
801
806
898
963
965
969
readdir
272
287
rename
265
272
325
request
435
rewinddir
788
rmdir
57
787
select
108
109
171
841
setgid
806
setuid
806
811
sigaction
745
signal
137
348
stat
56
786
790
792
sync
309
771
900
umount
58
unlink
58
81
273
787
788
wait
137
138
139
348
waitpid
54
55
742
744
write
56
265
267
289
290
309
356
359
594
622
703
704
760
771
772
774
785
786
789
796
802
806
898
mecanismo
asignación
memoria
766-767
módulo
cargable
779
objetivos
729-730
paginación
768-771
proceso
739-757
programa
utilitario
734-736
programación
procesos
752-755
programación
752-755
programador
disco
778-779
redes
773-775
runqueue
753
seguridad
803-806
superbloque
790
sistema
archivos
779-801
779-802
ext2
788-795
789
ext3
795-796
transaccional
795
virtual
788-789
1062
ÍNDICE
descripción
archivos
abiertos
794
nodos-i
792
tarea
746
waitqueue
755
Lista
capacidades
627
628
control
acceso
sistema
920
descriptores
memoria
903
espera
Vista
882
-C
627
628
Livelock
459-460
Localidad
referencia
209
Localizador
uniforme
recursos
590-591
LPC
vea
Llamada
procedimiento
local
LPC
avanzada
845
LRU
vea
reciente
algoritmo
Luminancia
475
Llamada
procedimiento
asíncrona
833
839-841
diferida
838-839
local
821
remoto
558-560
sistema
21
administración
archivos
56
administración
directorios
57-59
administración
memoria
Linux
761-762
administración
memoria
Vista
884-885
administración
procesos
52-56
administración
procesos
Linux
741-745
administración
procesos
Vista
869-871
entrada
salida
Linux
775-779
entrada
salida
Vista
898-900
seguridad
Linux
805-806
seguridad
Vista
921-922
sistema
archivos
Linux
785-788
diversas
58-59
ascendente
112
asíncrona
556-558
bloqueo
555-558
síncrona
555-558
www
FreeLibros.meÍNDICE
1063
sistema
entrada
salida
Linux
775
sistema
seguridad
Linux
805
Vista
921-922
sistema
49-61
Macintosh
16
18
Macro
73
virus
679
Macrobloque
482
Maestro-esclavo
multiprocesador
536
Mainframe
sistema
operativo
34
Malware
667-692
Malla
549
Manejador
89
822
archivo
NFS
798
interrupciones
348-349
933
Vista
850-852
Manejo
errores
343
disco
382-385
Mapa
bits
411-413
412
independiente
dispositivo
413
Máquina
analítica
finito
99
virtual
570
67-71
redescubrimiento
69-71
segura
571
Máquina
Virtual
Java
71
708-770
Marco
página
190
trabajo
driver
kernel
901
usuario
901
Marshaling
parámetros
559
Máscara
audio
484
Matriz
asignación
actual
444
peticiones
444
Mauchley
John
MBR
vea
Registro
maestro
inicio
MD5
vea
Algoritmo
firma
mensajes
MDL
vea
Lista
descriptores
memoria
Mecanismo
asignación
memoria
protección
613
622-641
Linux
766-767
programación
161
directiva
comparación
67
161-162
233-234
975-976
removible
948
ajuste
algoritmo
186
Memoria
23-26
422
compartida
distribuida
227
560
560-565
acceso
aleatorio
25
disco
26-27
lectura
25
extensa
47
investigación
administración
247
libre
administración
184-187
llamadas
sistema
administración
Linux
761
Vista
884
paginada
188-234
segmentada
234-247
virtual
188-247
unidad
administración
27
189-192
transaccional
863
virtual
26-27
49
182
188-247
algoritmos
sustitución
página
201-216
cuestiones
diseño
216-227
MULTICS
238-242
paginación
189-192
Pentium
242-247
virtualización
576-577
Menor
tiempo
respuesta
programación
491-493
restante
continuación
programación
154
Mes-hombre
mítico
994
Metarchivo
412
Metadatos
263
Método
409
596
Método
sincronizado
java
139
MFT
vea
Vista
tabla
archivos
maestra
Mickey
399
Microcomputadora
15
www
FreeLibros.meMicrokernel
64-67
574-575
934-937
973-974
MINIX
65-67
Microkernel
diseño
934
Microprograma
243
Microsoft
sistema
operativo
disco
16
17
256
318-321
326
814
815
910
Middleware
582
basado
coordinación
598
basado
documentos
590-591
basado
objetos
596-597
basado
sistemas
archivos
591-596
Millenium
edition
17
Minipuerto
Vista
847
MINIX
725-726
65-67
historia
14
MMU
entrada
salida
578
Modelado
multiprogramación
93-95
Modelo
acceso
remoto
591-592
carga
descarga
591-592
drivers
Windows
901
hilos
clásico
100-104
objetos
componentes
830
transferencia
591-592
acceso
remoto
591-592
carga
descarga
591
proceso
84-86
canónico
396
cocido
396
crudo
396
kernel
virtual
571
onda
cuadrada
389
ráfaga
338
supervisor
disparo
389
fly-by
338
suspendido
Vista
906
Modulación
código
pulso
477
Módulo(s
cargable
Linux
779
plataforma
confianza
621
tipos
mensaje
956
Linux
779
1064
ÍNDICE
Monitor
134-140
máquina
virtual
68-70
570
referencia
seguridad
Vista
844
referencia
708
Montaje
58
Montón
759
Motif
402
Motor
mutación
698
MP3
vea
audio
MPEG
nivel
MPEG
estándar
481-484
MPI
vea
Interfaz
paso
mensajes
MS-DOS
1.0
814
sistema
archivos
318-321
Multicomputadora
548-568
hardware
549-553
programación
565
MULTICS
vea
Servicio
Información
Cómputo
MULTiplexado
Multihilo
22
101
Multimedia
467-518
1001
archivos
472-478
colocación
archivos
499-510
programación
487-493
discos
513-516
servidor
494
sistema
archivos
493-516
video
demanda
504-506
organización
499-504
caché
510-513
Multinivel
seguridad
634-636
Multinúcleo
chip
22-23
533
579-580
999-1000
Multiplexeo
6-7
Multiprocesador(es
84
526-548
nivel
chip
533
basado
directorio
531
memoria
compartida
526-548
hardware
526-534
programación
542-548
NUMA
cachés
coherentes
531
NUMA
caché
531
simétrico
536-538
sincronización
538-541
Multiprogramación
12
84-86
modelado
93-95
www
FreeLibros.meÍNDICE
1065
Mutex
130-134
Phtreads
132
Nanohilo
938-939
Nanokernel
935
Navegador
Web
590
NC-NUMA
vea
Multiprocesador
NUMA
caché
Negación
servicio
614
NFS
vea
Sistema
archivos
red
NFU
vea
utilizada
frecuencia
algoritmo
Niño
script
script
kiddies
647
Nivel
abstracción
hardware
833-836
834
integridad
921
Vista
841-845
canónico
396
utilizada
frecuencia
algoritmo
207-208
Nodo
sensor
1003
-I
57
279-280
estructura
datos
Linux
789
-R
801
NFS
801
-V
290
801
NFS
800
Nombre
corto
Vista
910
ruta
42
269-272
absoluta
269
relativa
270
Nomenclatura
977
transparencia
593-594
Notación
decimal
puntos
644
Notación
húngara
409
NRU
vea
reciente
algoritmo
NT
vea
Windows
NT
NT
espacio
nombres
824
NTFS
vea
Sistema
archivos
tecnología
NTOS
vea
Sistema
operativo
tecnología
Núcleo
17
22
533
imagen
38
memoria
25
NUMA
multiprocesador
vea
Acceso
uniforme
memoria
multiprocesador
Número
puerto
694
mágico
261
Objeto
596
625
824
842
848
852
853
854
855
856
857
control
837
dispositivo
824
Vista
845
driver
824
Vista
897
notificación
841
sincronización
841
despachador
838
840
Ocupado
espera
29
122
346
Omega
red
529
Operación
archivos
264-265
directorios
272-273
línea
128
Optimización
caso
común
993
metas
988
ORB
vea
Intermediario
peticiones
objetos
Organización
longitud
datos
constante
504
tiempo
constante
504
Orientación
objetos
933-934
Ortogonalidad
976-977
OS/2
815
OS/360
11-12
operación
128
P1003.1
724
www
FreeLibros.mePadre
proceso
740
PAE
vea
Extensión
dirección
física
Página
188-192
compartida
221-223
confirmada
Vista
881
fijada
230-231
763
inválida
Vista
881
reservada
Vista
881
Web
590
Paginación
189-192
demanda
209
bloqueo
páginas
230-231
copia
escribir
223
Linux
768-771
implementación
227-234
local
global
comparación
216-218
optimización
194-198
páginas
compartidas
221-223
respaldo
instrucciones
229-230
separación
directiva
mecanismo
233-234
Palabra
programa
20
Pantalla
azul
muerte
843
Papelera
reciclaje
299
Paquete
peticiones
entrada
salida
855
902-903
Paradigma
controlado
eventos
966
datos
967
ejecución
966-967
interfaz
usuario
965
Paravirtualización
71
574-576
opciones
575
Partición
12
33
58
231
288
312
319
320
379
677
769
790
Paso
mensajes
140-144
cuestiones
diseño
140
142
interfaz
144
Pastilla
533
Paterson
Tim
16
PCI
bus
31
PCI
Express
31
PDA
vea
Asistente
digital
Ppersonal
PDP
-1
14
-11
721
722
1066
ÍNDICE
Pentium
17
segmentación
242-237
ajuste
algoritmo
187
Permiso
622
genérico
629
Peterson
G.L.
123
PFF
vea
Fallo
página
algoritmo
frecuencia
PFRA
vea
Algoritmo
reclamación
mar-
cos
página
PID
vea
Identificador
proceso
Pidgin
Pascal
136-138
Pila
dispositivos
Vista
845
904-906
protocolos
588
Píxel
475
PKI
vea
Infraestructura
clave
pública
Plantilla
Linda
599
Plug
and
play
32
843
897
POLA
vea
Principio
menor
autoridad
pandilla
programación
546-548
POSIX
14
50-57
724
hilos
104-106
PowerShell
830
Preámbulo
332
Prepaginación
210
886
889
Presión
memoria
891
ajuste
algoritmo
186
llegar
salir
algoritmo
204
atendido
algoritmo
379
programación
152-153
Primitivas
envío
recepción
555
Principio
menor
autoridad
623
Prioridad
actual
Vista
875
base
Vista
875
Privacidad
614
Problema
confinamiento
637
clásicos
IPC
163-169
Procesador
19-23
compartición
172
ideal
Vista
876
www
FreeLibros.meÍNDICE
1067
Productor-consumidor
problema
126
Java
139-141
paso
mensajes
142-144
monitores
137-139
Pthreads
135
semáforos
129-130
Proceso(s
38-40
83-170
91-93
comportamiento
147-148
creación
86-88
sistema
Vista
866
grupo
741
implementación
Linux
745-752
intercambiador
768
jerarquía
89
IPC
936
937-941
Linux
739-757
Vista
861-879
862-863
ligado
entrada
salida
174
ligado
cálculos
147
ligero
101
corto
continuación
158
secuencial
84
terminación
88-89
Programa
control
microcomputadoras
15-16
814
ejecutable
virus
674-676
Programación
realizarla
148-149
discos
multimedia
513-516
niveles
545
hilos
162
procesos
Linux
752-755
colas
156-158
Vista
819-831
dinámica
discos
multimedia
515-516
garantizada
158-159
inteligente
544
lotes
150-151
monotónica
frecuencia
490-491
multimedia
487-493
prioridad
155-156
sorteo
159
turno
rotatorio
154-155
preferente
148
149
tiempo
real
160-163
488-493
Programador
disco
Linux
778-779
entrada
salida
777
PROM
eléctricamente
borrable
25
Propiedad
635
seguridad
simple
635
Proporcionalidad
151
Protagonista
78
625
Protección
44
Protocolo
BFS
798
coherencia
caché
527
comunicación
458
control
transmisión
588
774
datagramas
usuario
774
descubrimiento
Jini
601
Internet
558
574
InterOrb
Internet
597
Proyecto
programación
extenso
74-75
PRT
módulo
956
Pseudoparalelismo
84
Psicoacústica
484
Psion
930-931
PSW
20
Pthreads
104-106
132-134
Publicar
suscribir
600
601
Puente
584
Puerta
trasera
668
Puerto
646
compleción
entrada
salida
Vista
900
entrada
salida
332
Punto
comprobación
447
cruce
528
reproducción
498
reanálisis
Vista
908
911
915
Quantum
154
RAID
vea
Arreglo
redundante
discos
económicos
www
FreeLibros.meRAM
vea
Memoria
acceso
aleatorio
video
406
volátil
387
Ranura
correo
868
Ratón
software
399
Readyboost
Vista
896
Readyboot
Vista
896
Reconocimiento
142
paquete
586
Reconocimiento
iris
655
Recuperación
interbloqueo
447-448
revisión
447-448
eliminación
procesos
448
preferencia
447
Recurso
404
434-437
preferente
434-435
preferente
434-435
Red(es
1000-1001
área
amplia
583
bloqueo
530
área
local
583
bots
668
conmutación
multietapa
529-531
hardware
583-586
interfaz
551-553
procesador
553
protocolo
587
587-589
Linux
773-775
servicio
553
Reed-Soomon
código
370
Reentrancia
985
Regedit
830
Región
crítica
119-120
Registro
base
180-181
Vista
908
base
tabla
traducción
943
transacciones
828
Vista
917
Windows
829
límite
180-181
maestro
inicio
273
379
755
Rejilla
549
603
Reloj
388-394
algoritmo
205-206
hardware
388-390
pulso
389
1068
ÍNDICE
software
390-394
Rendimiento
151
987-994
Reporte
errores
357
Reservación
ancho
banda
Vista
883
Respaldo
instrucción
229-230
sistema
archivos
298-304
Reto-respuesta
autenticación
650
Reubicación
dinámica
180
estática
179
Reutilización
984-985
Revestimiento
188
Revisión
código
657
hardware
computadora
19-33
Robo
ciclo
338
Robo
identidad
669
Rock
Ridge
extensiones
316-317
Rol
626
Ronda
513
Root
804
Rootkit
688-692
detección
689-691
Sony
691-692
tipos
688-689
RSA
Rivest-Shamir-Adelman
algoritmo
619
runqueue
Linux
753
Ruta
relativa
781
Rutina
servicio
interrupción
838
RWX
bits
44
SACL
vea
Lista
control
acceso
sistema
Salida
estándar
733
Salt
648
SATA
disco
vea
Serial
ATA
disco
Scan-EDF
algoritmo
515
SCSI
vea
Interfaz
sistema
cómputo
pequeños
Sección
823
crítica
119-120
870
Secuencia
escape
400
Secuestro
navegador
687
www
FreeLibros.meÍNDICE
1069
Segmentación
234-246
paginación
238-247
MULTICS
238-242
Pentium
242-247
implementación
237-238
Segmento
234
datos
55-56
758
pila
55-56
texto
55-56
compartido
760
Seguridad
611-713
contraseñas
UNIX
647-648
symbian
950-953
Vista
918-924
oscuridad
617
Linux
803-806
949-953
Vista
918-924
Semáforo
128-130
binario
129
Semántica
compartición
archivos
594-596
sesión
595
Señal(es
741
compuesta
475
código
multihilo
116
Señuelo
archivo
695
Separación
directiva
mecanismo
233-234
Serial
ATA
disco
361
Servicio
búsqueda
Jini
601
datagramas
587
reconocimiento
587
Información
Cómputo
MULTiplexado
13-15
49
238-242
720
petición-respuesta
587
orientado
conexión
586
conexión
586
Servidor
67
799
reencarnación
66
video
469
pull
multimedia
494
push
multimedia
494
799
Web
multihilo
97-99
Sesión
CD-ROM
372
SETUID
bit
804
SHA-1
vea
Algoritmo
hash
seguro
SHA-256
vea
Algoritmo
hash
seguro
SHA-512
vea
Algoritmo
hash
seguro
Shell
38
44-46
731-734
secuencia
comandos
734
Shellcode
664
SID
vea
Identificador
seguridad
ajuste
algoritmo
186
Símbolo
canalización
733
bala
plata
998
bloqueo
llamada
555-558
red
528
Sincronización
130
barrera
144-145
Vista
869-871
Sistema(s
amigable
usuario
16
básico
entrada
salida
33
176
codificación
audio
484-487
codificación
video
473-476
compatible
tiempo
compartido
13
acoplamiento
débil
525
acoplamiento
fuerte
525
procesadores
investigación
604-605
archivos
administración
292-312
administración
bloques
libres
295-297
arquitectura
797
CD-ROM
312-313
consistencia
304-307
Linux
788-789
tecnología
906-918
red
290
796-802
distribución
273-274
driver
filtro
846
estructura
Vista
908-912
estructurados
registro
285-287
FAT-16
906
FAT-32
906
implementación
273-291
investigación
324
ISO
9660
313-316
Linux
779-801
www.FreeLibros.memiddleware
basado
591-596
montado
42
343
multimedia
493-516
operativos
multimedia
467-518
protocolos
797-800
raíz
42
rendimiento
307-311
respaldo
298-304
seguridad
936
948-953
tamaño
bloque
292
transaccional
287-288
transaccional
Linux
795
UNIX
V7
321-323
versión
802
virtual
288-291
Vista
906-918
cifrado
archivos
917
confianza
630-631
detección
intrusos
695
703
directorios
nivel
268
directorios
jerárquico
268
niveles
63-64
971-972
nombres
dominio
589
paginación
cuestiones
diseño
216-227
procesamiento
lotes
9-10
tiempo
real
periódico
161
tiempo
real
programable
161
distribuido
525
580-603
chip
534
extensible
974
introducción
468-472
investigación
516-517
monitor
conversacional
68-69
monolítico
62-63
operativo
anfitrión
70
570
Berkeley
UNIX
723-724
BSD
13
cliente-servidor
67
máquina
extendida
4-5
administrador
recursos
6-7
comprobación
errores
986
concesiones
espacio
tiempo
998-991
computadora
bolsillo
35
computadora
personal
35
1070
ÍNDICE
nodos
sensores
36
tecnología
820
red
18
servidor
34
tarjeta
inteligente
37
tiempo
real
duro
36
tiempo
real
suave
36-37
distribuido
18
disco
16
niveles
63-64
explotación
localidad
993
FreeBSD
18
fuerza
bruta
958-986
historia
7-18
implementación
971-986
incrustado
35-36
1002
interfaces
963-970
invitado
71-570
Linux
15
719-806
máquina
virtual
67-71
microkernel
64-67
MINIX
14
65-67
725
726
monolítico
62-63
multiprocesador
34-35
534-548
objetivos
960-961
ocultar
hardware
981-984
operativos
conceptos
37-49
optimización
rendimiento
987-994
paradigmas
965-968
difícil
diseñarlos
961-963
principios
963-965
reentrancia
985
sugerencias
992-993
tendencias
998-1003
caché
991-992
programación
procesos
487-493
seguro
modelo
formal
632-634
UNIX
18
PDP-11
721-722
estándar
724-725
portable
722-723
Windows
2000
17
817
2003
818
3.0
816
95
815
98
815
www
FreeLibros.meÍNDICE
1071
17
815
NT
17
NT
4.0
817
Server
2008
813
Vista
813-926
XP
17
817
SLED
vea
disco
costoso
SMP
vea
Multiprocesador
simétrico
Snooping
533
Socket
773
868
Sobrepaginados
thrashing
209
940-941
Software
comunicación
multicomputadora
553-558
entrada
394-399
independiente
dispositivo
353-358
objetivos
343-344
principios
343-347
salida
399-414
Solución
Peterson
123
Sondeo
346
Spooler
directorio
117-118
Spooling
12
359
Spyware
684-688
acciones
realizadas
687-688
Sugerencias
992-993
Sujeto
625
Superbloque
274
789
Linux
790
SuperFetch
Vista
886
Superusuario
39
804
Suplantación
identidad
inicio
sesión
658
Svchost.exe
861
SVID
vea
System
definición
interfaz
SVM
vea
Máquina
virtual
segura
Symbian
929-1003
administración
memoria
937
941-945
características
936-937
comunicación
937
953-957
DMA
946-947
driver
dispositivo
945-946
entrada
salida
945-948
generalidades
932-937
hilo
938-939
historia
930-932
manejador
933
microkernel
934
módulos
955-956
motor
aplicación
930
multimedia
937
nanohilo
938-939
nanokernel
935
nivel
kernel
935
objeto
activo
939-940
orientación
objetos
933-934
proceso
936
937-941
redes
936
seguridad
950-953
sistema
archivos
936
948-953
System
14
definición
interfaz
724
Tabla
archivos
maestra
Vista
908
asignación
archivos
278
contenido
volumen
372
descripción
archivos
abiertos
Linux
794
descriptores
globales
242
descriptores
locales
242
direcciones
importación
Vista
859
nodos-I
Linux
792
páginas
invertida
200-201
oculta
577
multinivel
198-200
memorias
extensas
198
procesos
38
91
Talón
559
560
596
cliente
559
servidor
559
Tamaño
página
219-220
Tarea
Linux
746
ligada
CPU
12
fibras
Vista
863-864
Tarjeta
valor
almacenado
651
inteligente
651-653
www
FreeLibros.meTarro
miel
705
TCB
vea
Base
cómputo
confianza
TCP
IP
724
TEB
vea
Bloque
entorno
hilo
vista
Teclado
software
395-398
Técnicas
antivirus
695-701
diseño
comprobación
errores
986
concesiones
espacio
tiempo
998-991
explotación
localidad
993
fuerza
bruta
985-986
indirección
984
ocultar
hardware
981-984
optimización
caso
común
993
optimización
rendimiento
987-994
reentrancia
985
reutilización
984-985
sugerencias
992-993
caché
991-992
Tecnología
interconexión
549-551
virtualización
571
Temporizador
388-394
software
393-394
guardián
392
Tendencias
diseño
sistemas
operativos
998-1003
chips
multinúcleo
999-1000
dispositivos
móviles
1002
espacios
direcciones
extensos
1000
multimedia
1001
redes
1000-1001
sensores
1003
sistemas
distribuidos
1001
incrustados
1002
paralelos
1001
virtualización
999
Teorema
Nyquist
477
Termcap
400
Terminal
394
Texto
cifrado
617
simple
617
THINC
vea
Cliente
delgado
1072
ÍNDICE
Thompson
Ken
14
Tiempo
coordenado
universal
389
ejecución
programas
75
respuesta
151
vinculación
978-979
real
390
duro
160
suave
160
virtual
actual
211
Tipo
archivo
260-262
letra
413
Token
828
restringido
Vista
863
Trabajador
hilo
98
Trabajo
corto
programación
153-154
Trampa
21-22
657
Transacción
atómica
288
Transparencia
localidad
593-594
nomenclatura
593-594
ubicación
593-594
TRAP
instrucción
51-52
Trayectorias
recursos
449-450
TSL
instrucción
124-125
TSY
módulo
956
Tupla
598-599
UID
efectivo
804
UMA
multiprocesador
basado
bus
526-527
interruptor
barras
cruzadas
527-529
conmutación
multietapa
529
531
disco
costoso
363
Unicode
824
UNICS
720-721
Unidad
central
proceso
19-23
421-422
Unidades
métricas
78-79
UNIX
18
Berkeley
723-724
PDP-11
721-722
estándar
724-725
www
FreeLibros.meÍNDICE
1073
historia
721-725
PDP-11
721-722
portable
722-723
seguridad
contraseñas
647-648
sistema
archivos
V7
321
caché
991-992
multimedia
510-513
Vista
849-896
hilos
95-100
reciente
algoritmo
203-207
888
simulación
207-209
UTC
vea
Tiempo
coordenado
universal
Vaciado
físico
300
incremental
300
lógico
301
Vampiro
punción
583
Variable
bloqueo
121
condición
133
137
global
114-115
VCR
funciones
control
494
Vector
interrupciones
29
92
340
recursos
disponibles
444
recursos
existentes
444
Ventana
406
texto
400
Verificador
aplicaciones
Vista
852
driver
Vista
776
Versiones
Vista
860
VFS
vea
Sistema
archivos
virtual
Video
demanda
468
digital
482
entrelazado
475
progresivo
475
Vinculación
anticipada
978
postergada
978
Vínculo
283
781
duro
273
simbólico
273
283
Virtualización
568-580
999
entrada
salida
578-579
cuestiones
licencia
580
memoria
576-577
requerimientos
570-571
Virus
672
carga
útil
673
cavidad
676
evitarlos
700-701
cavidad
676
código
fuente
679-680
compañía
673
driver
dispositivo
678-679
macro
679
programa
ejecutable
674-676
sobrescritura
674
dropper
673
explorador
695-699
operación
673
parasítico
675
polimórfico
698
residente
memoria
676-677
sector
inicio
677-678
Vista
813-926
acl
discrecional
919
administración
memoria
física
891-894
administrador
configuración
844
energía
905
entrada
salida
842
caché
844
memoria
844
objetos
842
procesos
843
conjunto
balance
891
algoritmo
reemplazo
páginas
890-891
almacenamiento
local
hilo
862
archivo
paginación
881-883
inmediato
912
disperso
912
asignación
almacenamiento
912-915
www.FreeLibros.mede
direcciones
virtuales
881
atributo
residente
910
autoasignación
872
889
base
datos
números
marco
página
891
bloque
entorno
hilo
862
proceso
862
cambio
bancos
883
cifrado
archivos
917-918
clave
848
compresión
archivos
916-917
comunicación
procesos
868-869
consola
recuperación
848
copia
oculta
volumen
897
datos
compartidos
usuario
862
descriptor
seguridad
920
disco
dinámico
897
driver
clase
847
dispositivo
901-902
dispositivos
845-847
filtro
904
inicio
847
ejecutivo
836
entrada
salida
búfer
895
escritor
páginas
asignadas
893
modificadas
893
espacio
nombres
objetos
852-858
estructura
datos
contexto
865
sistema
archivos
908-912
estructura
831-861
falla
dura
889
suave
881
889
filtro
845
flujo
datos
alternativo
912
predeterminado
912
hibernación
905
hilo
afinidad
862
864-879
ZeroPage
893
1074
ÍNDICE
historia
818-819
hive
829
imitación
identidad
920
inicio
seguro
847
kernel
832
836-838
lista
control
acceso
828
espera
882
llamada
API
AddAccessAllowedAce
921
AddAccessDeniedAce
922
CreateDirectory
61
CreateFile
827
857
921
CreateFileMapping
885
CreateProcess
60
88
821
866
871
872
873
921
969
CreateSemaphore
851
869
DeleteAce
922
DuplicateHandle
869
EnterCriticalSection
870
993
ExceptPortHandle
823
ExitProcess
60
88
FlushFileBuffers
309
GetFileAttributesEx
61
GetLocalTime
61
GetTokenInformation
919
InitializeAcl
921
InitializeSecurityDescriptor
921
IoCallDriver
901
902
IoCompleteRequest
901
915
IopParseDevice
855
856
LeaveCriticalSection
870
LookupAccountSid
921
NtAllocateVirtualMemory
824
NtCancelIoFile
900
NtClose
853
854
NtCreateFile
824
853
855
899
900
NtCreateProcess
821
823
853
867
NtCreateThread
824
867
NtCreateUserProcess
872
873
NtDeviceIoControlFile
900
NtDuplicateObject
824
NtFlushBuffersFile
900
NtFsControlFile
900
917
NtLockFile
900
NtMapViewOfSection
824
www
FreeLibros.meÍNDICE
1075
NtNotifyChangeDirectoryFile
900
917
NtQueryDirectoryFile
899
NtQueryInformationFile
900
NtQueryV
olumeInformationFile
899
NtReadFile
899
NtReadVirtualMemory
824
NtResumeThread
873
NtSetInformationFile
900
NtSetV
olumeInformationFile
899
NtUnlockFile
900
NtWriteFile
899
NtWriteVirtualMemory
824
ObCreateObjectType
857
ObOpenObjectByName
855
OpenSemaphore
851
ProcHandle
824
PulseEvent
870
QueueUserAPC
840
ReadFile
915
ReleaseMutex
870
ReleaseSemaphore
869
RemoveDirectory
61
ResetEvent
870
SectionHandle
823
SetCurrentDirectory
61
SetEvent
870
SetFilePointer
61
SetPriorityClass
875
SetSecurityDescriptorDacl
922
SetThreadPriority
875
SwitchToFiber
864
TerminateProcess
89
ValidDataLength
895
WaitForMultipleObjects
841
848
869
926
WaitForSingleObject
60
869
870
llamadas
API
entrada
salida
898
procesos
866-871
seguridad
921-922
manejador
850-852
manejo
fallos
página
886-890
mini-puerto
847
espera
906
monitor
referencia
seguridad
844
nivel
ejecutivo
841-845
nombre
corto
910
objeto
dispositivo
845
objeto
driver
897
página
confirmada
881
inválida
881
pila
dispositivos
845
904-906
presión
memoria
891
prioridad
actual
875
base
875
procesador
ideal
876
proceso
861-879
862-863
sistema
866
programación
874-879
puerto
compleción
entrada
salida
900
puntos
reanálisis
908-915
readyboost
896
readyboot
896
registro
base
908
registro
transacciones
917
reservación
ancho
banda
898
sincronización
869-871
sistema
archivos
906-918
superfetch
886
tabla
archivos
maestra
908
direcciones
importación
859
tareas
fibras
863-864
token
acceso
919
restringido
863
verificador
aplicaciones
852
driver
901
versiones
860
violación
acceso
888
memorias
extensas
883-884
VM/370
68-69
VMI
vea
Interfaz
máquina
virtual
VMS
17
VMware
70
572
VT
vea
Tecnología
virtualización
VTOC
vea
Tabla
contenido
volumen
www
FreeLibros.meW
WaitForMultipleObject
841
Waitqueue
Linux
755
WAN
vea
Red
área
amplia
War
dialer
644
WDF
vea
Fundación
drivers
Windows
WDM
vea
Modelo
drivers
Windows
Widgets
402
Win32
API
59-61
816
825-831
Windows
2000
17
817
2003
818
3.0
816
95
815
98
815
basado
MS-DOS
815
basado
NT
815-818
17
815
NT
17
NT
API
822-825
NT
4.0
817
registro
829
subsistema
820
Server
2008
813
Windows
825-826
Vista
vea
Vista
XP
17
817
WndProc
409
WOW
vea
Windows
Windows
1076
ÍNDICE
Wsclock
213
WSclock
215
WSClock
algoritmo
213
Window
sistema
18
400-404
726
administrador
ventanas
403
cliente
401
intrinsics
402
recurso
404
servidor
401
widget
402
11
vea
Window
sistema
86
17
Xenix
16
Xlib
402
VM
68
ZeroPage
hilo
Vista
893
Zipf
George
506
Zombie
614
668
744
ZSeries
IBM
11
www.FreeLibros.me
