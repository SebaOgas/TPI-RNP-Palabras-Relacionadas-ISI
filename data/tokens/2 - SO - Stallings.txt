Sistemas
operativos
Aspectos
internos
principios
diseño
Quinta
Edición
WILLIAM
STALLINGS
Traducción
revisión
técnica
José
María
Peña
Sánchez
Fernando
Pérez
Costoya
María
Santos
Pérez
Hernández
Víctor
Robles
Forcada
Francisco
Javier
Rosales
García
Departamento
Arquitectura
Tecnología
Sistemas
Informáticos
Facultad
Informática
Universidad
Politécnica
Madrid
Madrid
México
Santafé
Bogotá
Aires
Caracas
Lima
Montevideo
San
Juan
San
José
Santiago
Sâo
Paulo
White
Plains
0-Primeras
12/5/05
17:09
Página
iiiSISTEMAS
OPERATIVOS
William
Stallings
Pearson
Educación
S.A.
Madrid
2005
Materia
Informática
681.3
Formato
195
250
mm
Páginas
872
derechos
reservados
Queda
prohibida
excepción
prevista
Ley
forma
reproducción
distribución
comunicación
pública
transformación
obra
contar
autorización
titulares
propiedad
intelectual
infracción
derechos
mencionados
constitutiva
delito
propiedad
intelectual
arts
270
sgts
Código
Penal
DERECHOS
RESER
ADOS
2005
edición
castellano
PEARSON
EDUCACIÓN
S.A.
C/
Ribera
Loira
28
28042
Madrid
España
SISTEMAS
OPERATIVOS
William
Stallings
ISBN
84-205-4462-0
Depósito
Legal
PEARSON
PRENTICE
HALL
sello
editorial
autorizado
PEARSON
EDUCACIÓN
S.A.
Authorized
translation
from
the
English
language
edition
entitled
OPERATING
SYSTEMS
th
Edition
by
STALLINGS
WILLIAM
published
by
Peason
Education
Inc
publishing
as
Prentice
Hall
Copyright
2005
ISBN
0-13-147954-7
All
rights
reserved
part
of
this
book
may
be
reproduced
or
transmitted
in
any
from
or
by
any
means
elecronic
or
mechanical
including
photocopying
recording
or
by
any
information
storage
retrieval
system
without
permission
from
Pearson
Education
Inc
Equipo
editorial
Editor
Miguel
Martín-Romo
Técnico
editorial
Marta
Caicoya
Equipo
producción
Director
José
A.
Clares
Técnico
Isabel
Muñoz
Diseño
cubierta
Equipo
diseño
Pearson
Educación
S.A.
Impreso
IMPRESO
ESP
AÑA
PRINTED
IN
SP
AIN
libro
impreso
papel
tintas
ecológicos
Datos
catalogación
bibliográfica
0-Primeras
12/5/05
17:09
Página
iv
ISBN
978-84-205-5796-0PÁGINA
WEB
SISTEMAS
OPERATIVOS
ASPECTOS
INTERNOS
PRINCIPIOS
DISEÑO
QUINTA
EDICIÓN
página
web
WilliamStallings.com/OS/OS5e.html
proporciona
apoyo
profesores
estudiantes
utilicen
libro
Incluye
siguientes
elementos
MATERIAL
APOYO
CURSOS
material
apoyo
cursos
incluye
Copia
figuras
libro
formato
PDF
Copia
tablas
libro
formato
PDF
conjunto
transparencias
PowerPoint
utilizarlas
ayuda
clase
Notas
clase
HTML
servir
material
ayuda
estudio
Página
Recursos
Estudiante
Informática
Computer
Science
Student
Resource
Site
contienen
número
enlaces
documentos
estudiantes
encontrar
úti-
formación
informática
página
incluye
revisión
matemáticas
bási-
cas
relacionadas
consejos
búsqueda
información
redacción
realización
proble-
casa
enlaces
repositorios
información
informática
tales
informes
bibliografías
enlaces
interés
hoja
erratas
libro
actualizada
mensualmente
DOCUMENTOS
COMPLEMENTARIOS
documentos
complementarios
incluyen
copia
PDF
algoritmos
libro
pseudo-código
tipo
Pascal
fácil
lectura
Material
libro
relativo
Windows
UNIX
Linux
reproducido
documentos
PDF
fácil
referencia
documentos
amplían
tratado
libro
Incluye
aspectos
relativos
compleji-
dad
algoritmos
estándares
Internet
Sockets
CURSOS
SISTEMAS
OPERATIVOS
página
web
OS5e
incluye
enlaces
páginas
cursos
impartidos
usando
libro
páginas
proporcionar
guías
útiles
planificar
ordenar
temas
tratados
número
anotaciones
material
diverso
vi
Contenido
0-Primeras
12/5/05
17:09
Página
viPÁGINAS
WEB
ÚTILES
página
web
OS5e
incluye
enlaces
páginas
interés
enlaces
cubren
am-
plio
espectro
temas
permitirán
estudiantes
explorar
aspectos
concretos
profundidad
LISTA
CORREO
ELECTRÓNICO
mantiene
lista
correo
profesores
utilicen
libro
puedan
intercambiar
in-
formación
sugerencias
preguntas
autor
información
suscripción
proporciona
página
web
libro
PROYECTOS
SISTEMAS
OPERATIVOS
página
web
incluye
enlaces
páginas
Nachos
BACI
paquetes
software
sir-
ven
entornos
implementación
proyectos
página
incluye
software
descargar
información
apoyo
Véase
Apéndice
información
Contenido
vii
0-Primeras
12/5/05
17:09
Página
viiContenido
Prólogo
xvii
Capítulo
Guía
lector
0.1
Organización
libro
0.2
Orden
presentación
temas
0.3
Recursos
Internet
Web
ANTECECENTES
Capítulo
Introducción
computadores
1.1
Elementos
básicos
10
1.2
Registros
procesador
11
1.3
Ejecución
instrucciones
14
1.4
Interrupciones
17
1.5
jerarquía
memoria
27
1.6
Memoria
cache
30
1.7
Técnicas
comunicación
34
1.8
Lecturas
sitios
web
recomendados
37
1.9
Términos
clave
cuestiones
repaso
problemas
38
Apéndice
1A
Características
rendimiento
memorias
niveles
41
Apéndice
1B
Control
procedimientos
48
Capítulo
Introducción
sistemas
operativos
53
2.1
Objetivos
funciones
sistemas
operativos
54
2.2
evolución
sistemas
operativos
58
2.3
Principales
logros
67
2.4
Desarrollos
llevado
sistemas
operativos
modernos
79
2.5
Descripción
global
Microsoft
Windows
82
2.6
Sistemas
UNIX
tradicionales
91
2.7
Sistemas
UNIX
modernos
94
2.8
Linux
95
2.9
Lecturas
sitios
web
recomendados
101
2.10
Términos
clave
cuestiones
repaso
problemas
103
Contenido
ix
0-Primeras
12/5/05
17:09
Página
ixSEGUNDA
PROCESOS
105
Capítulo
Descripción
control
procesos
107
3.1
proceso
108
3.2
procesos
110
3.3
Descripción
procesos
126
3.4
Control
procesos
135
3.5
Gestión
procesos
UNIX
SVR4
143
3.6
Resumen
149
3.7
Lecturas
recomendadas
149
3.8
Términos
clave
cuestiones
repaso
problemas
150
Proyecto
programación
Desarrollo
intérprete
mandatos
154
Capítulo
Hilos
SMP
micronúcleos
157
4.1
Procesos
hilos
158
4.2
Multiprocesamiento
simétrico
172
4.3
Micronúcleos
176
4.4
Gestión
hilos
SMP
Windows
181
4.5
Gestión
hilos
SMP
Solaris
187
4.6
Gestión
procesos
hilos
Linux
193
4.7
Resumen
196
4.8
Lecturas
recomendadas
196
4.9
Términos
clave
cuestiones
repaso
problemas
197
Capítulo
Concurrencia
Exclusión
mutua
sincronización
201
5.1
Principios
concurrencia
203
5.2
Exclusión
mutua
soporte
hardware
212
5.3
Semáforos
215
5.4
Monitores
229
5.5
Paso
mensajes
235
5.6
problema
Lectores
Escritores
241
5.7
Resumen
245
5.8
Lecturas
recomendadas
247
5.9
Términos
clave
cuestiones
repaso
problemas
248
Capítulo
Concurrencia
Interbloqueo
inanición
257
6.1
Fundamentos
interbloqueo
258
6.2
Prevención
interbloqueo
267
Contenido
0-Primeras
12/5/05
17:09
Página
x6.3
Predicción
interbloqueo
269
6.4
Detección
interbloqueo
273
6.5
estrategia
integrada
tratamiento
interbloqueo
277
6.6
problema
filósofos
comensales
277
6.7
Mecanismos
concurrencia
UNIX
280
6.8
Mecanismos
concurrencia
núcleo
Linux
284
6.9
Funciones
sincronización
hilos
Solaris
291
6.10
Mecanismos
concurrencia
Windows
294
6.11
Resumen
296
6.12
Lecturas
recomendadas
297
6.13
Términos
clave
cuestiones
repaso
problemas
297
MEMORIA
305
Capítulo
Gestión
memoria
307
7.1
Requisitos
gestión
memoria
308
7.2
Particionamiento
memoria
311
7.3
Paginación
321
7.4
Segmentación
325
7.5
Resumen
327
7.6
Lecturas
recomendadas
327
7.7
Términos
clave
cuestiones
repaso
problemas
328
Apéndice
7A
Carga
enlace
331
Capítulo
Memoria
virtual
339
8.1
Hardware
estructuras
control
340
8.2
Software
sistema
operativo
358
8.3
Gestión
memoria
UNIX
Solaris
378
8.4
Gestión
memoria
Linux
384
8.5
Gestión
memoria
Windows
386
8.6
Resumen
388
8.7
Lectura
recomendada
páginas
web
389
8.8
Términos
clave
cuestiones
repaso
problemas
390
Apéndice
8A
Tablas
Hash
395
CUARTA
PLANIFICACIÓN
399
Capítulo
Planificación
uniprocesador
401
9.1
Tipos
planificación
procesador
402
9.2
Algoritmos
planificación
406
Contenido
xi
0-Primeras
12/5/05
17:09
Página
xi9.3
Planificación
UNIX
tradicional
427
9.4
Resumen
429
9.5
Lecturas
recomendadas
431
9.6
Términos
clave
cuestiones
repaso
problemas
431
Apéndice
9A
Tiempo
respuesta
436
Apéndice
9B
Sistemas
colas
438
Proyecto
programación
planificador
HOST
444
Capítulo
10
Planificación
multiprocesador
tiempo
real
451
10.1
Planificación
multiprocesador
452
10.2
Planificación
tiempo
real
463
10.3
Planificación
Linux
477
10.4
Planificación
UNIX
SVR4
480
10.5
Planificación
Windows
482
10.6
Resumen
484
10.7
Lecturas
recomendadas
485
10.8
Términos
clave
cuestiones
repaso
problemas
485
QUINTA
ENTRADA
SALIDA
FICHEROS
489
Capítulo
11
Gestión
planificación
disco
491
11.1
Dispositivos
492
11.2
Organización
sistema
493
11.3
Aspectos
diseño
sistema
operativo
496
11.4
Utilización
buffers
500
11.5
Planificación
disco
503
11.6
RAID
511
11.7
Cache
disco
520
11.8
UNIX
SVR4
522
11.9
Linux
527
11.10
Windows
530
11.11
Resumen
532
11.12
Lecturas
sitios
web
recomendados
532
11.13
Términos
clave
cuestiones
repaso
problemas
534
Apéndice
11A
Dispositivos
almacenamiento
disco
537
Capítulo
12
Gestión
ficheros
547
12.1
Descripción
básica
548
12.2
Organización
acceso
ficheros
553
xii
Contenido
0-Primeras
12/5/05
17:09
Página
xii12.3
Directorios
559
12.4
Compartición
ficheros
563
12.5
Bloques
registros
564
12.6
Gestión
almacenamiento
secundario
566
12.7
Gestión
ficheros
UNIX
574
12.8
Sistema
ficheros
virtual
Linux
578
12.9
Sistema
ficheros
Windows
582
12.10
Resumen
587
12.11
Lecturas
recomendadas
588
12.12
Términos
clave
cuestiones
repaso
problemas
589
SEXTA
SISTEMAS
DISTRIBUIDOS
SECURIDAD
591
Capítulo
13
Redes
595
13.1
necesidad
arquitectura
protocolos
597
13.2
arquitectura
protocolos
TCP
IP
599
13.3
Sockets
605
13.4
Redes
Linux
609
13.5
Resumen
611
13.6
Lecturas
sitios
web
recomendados
611
13.7
Términos
clave
cuestiones
repaso
problemas
612
Apéndice
13A
Protocolo
simple
transferencia
ficheros
614
Capítulo
14
Procesamiento
distribuido
cliente
servidor
clusters
619
14.1
Computación
cliente
servidor
620
14.2
Paso
mensajes
distribuido
630
14.3
Llamadas
procedimiento
remoto
633
14.4
Clusters
636
14.5
Servidor
Cluster
Windows
642
14.6
Sun
Cluster
643
14.7
Clusters
Beowulf
Linux
646
14.8
Resumen
648
14.9
Lecturas
recomendadas
sitios
web
648
14.10
Términos
clave
cuestiones
repaso
problemas
650
Capítulo
15
Gestión
procesos
distribuidos
653
15.1
Migración
procesos
654
15.2
globales
distribuidos
660
15.3
Exclusión
mutua
distribuida
665
Contenido
xiii
0-Primeras
12/5/05
17:09
Página
xiii15.4
Interbloqueo
distribuido
675
15.5
Resumen
685
15.6
Lecturas
recomendadas
685
15.7
Términos
clave
cuestiones
repaso
problemas
686
Capítulo
16
Seguridad
689
16.1
Amenazas
seguridad
690
16.2
Protección
695
16.3
Intrusos
701
16.4
Software
malicioso
713
16.5
Sistemas
confiables
722
16.6
Seguridad
Windows
725
16.7
Resumen
731
16.8
Lecturas
recomendadas
sitios
web
732
16.9
Términos
clave
cuestiones
repaso
problemas
733
Apéndice
16A
Cifrado
736
APÉNDICES
743
Apéndice
Temas
concurrencia
743
A.1
Exclusión
mutua
Técnicas
software
744
A.2
Condiciones
carrera
semáforos
748
A.3
problema
barbería
758
A.4
Problemas
763
Apéndice
Diseño
orientado
objetos
765
B.1
Motivación
766
B.2
Conceptos
orientación
objetos
767
B.3
Beneficios
diseño
orientado
objetos
771
B.4
CORBA
772
B.5
Lecturas
sitios
web
recomendados
775
Apéndice
Proyectos
programación
sistemas
operativos
777
C.1
Proyectos
enseñanza
sistemas
operativos
778
C.2
NACHOS
779
C.3
Proyectos
investigación
780
C.4
Proyectos
programación
780
C.5
Tareas
lectura
análisis
781
xiv
Contenido
0-Primeras
12/5/05
17:09
Página
xivApéndice
OSP
entorno
proyectos
sistemas
operativos
783
D.1
Introducción
784
D.2
Aspectos
innovadores
OSP
785
D.3
Comparación
herramientas
docentes
sistemas
operativos
786
Apéndice
BACI
Sistema
programación
concurrente
Ben-Ari
789
E.1
Introducción
790
E.2
BACI
790
E.3
Ejemplos
programas
BACI
793
E.4
Proyectos
BACI
797
E.5
Mejoras
Sistema
BACI
800
Glosario
801
Referencias
811
Acrónimos
827
Índice
829
Contenido
xv
0-Primeras
13/5/05
17:21
Página
xv0-Primeras
12/5/05
17:09
Página
xviPrólogo
OBJETIVOS
libro
ocupa
conceptos
estructura
mecanismos
sistemas
operativos
pro-
pósito
presentar
clara
completa
naturaleza
características
sistemas
operativos
tarea
reto
motivos
lugar
computadores
diseñan
sistemas
operativos
presentan
enorme
variedad
diversidad
incluye
estaciones
trabajo
computadores
personales
único
usuario
pasando
sistemas
compartidos
tama-
ño
sistemas
mainframe
supercomputadores
máquinas
especializadas
tales
sistemas
tiempo
real
variedad
capacidad
velocidad
máquinas
requisitos
aplicaciones
sistema
lugar
rápido
ritmo
cambios
caracterizado
sistemas
informáticos
continúa
remitir
Diver-
sas
áreas
fundamentales
diseño
sistemas
operativos
reciente
aparición
estando
activa
investigación
áreas
variedad
ritmo
cambios
incesante
conceptos
fundamentales
si-
guen
aplicables
momento
Evidentemente
aplicación
depende
actual
tecnología
requisitos
particulares
aplicación
objetivo
libro
proporcionar
estudio
profundo
fundamentos
diseño
sistemas
operativos
relacionarlos
aspectos
diseño
contemporáneos
tendencias
actuales
desarrollo
sistemas
operativos
SISTEMAS
EJEMPLO
libro
destinado
lector
principios
diseño
aspectos
implemen-
tación
sistemas
operativos
contemporáneos
consiguiente
tratamiento
puramente
con-
ceptual
teórico
inadecuado
mostrar
conceptos
asociarlos
alternativas
diseño
mundo
real
seleccionado
sistemas
operativos
ejemplos
reales
Windows
XP
Windows
2003
sistema
operativo
multitarea
computadores
persona-
estaciones
trabajo
servidores
tratarse
sistema
operativo
incorpora
nítida
desarrollos
tecnología
sistemas
operativos
Windows
sistemas
operativos
comerciales
importantes
estrechamente
basado
principios
diseño
orientado
objetos
libro
ocupa
tec-
nología
utilizada
versiones
recientes
Windows
XP
estaciones
trabajo
com-
putadores
personales
2003
servidores
UNIX
sistema
operativo
multiusuario
originalmente
destinado
minicomputadores
implementado
amplio
rango
máquinas
poderosos
microcomputadores
super-
computadores
incluyen
versiones
UNIX
UNIX
SVR4
sistema
usado
incorpora
características
avanzadas
Solaris
versión
comercial
utilizada
UNIX
Incluye
procesamiento
multihilo
características
encuentran
SVR4
mayoría
versiones
UNIX
Linux
versión
UNIX
cuyo
código
fuente
disponible
libremente
utili-
zada
actualmente
Contenido
xvii
0-Primeras
12/5/05
17:09
Página
xviiEstos
sistemas
seleccionaron
relevancia
representatividad
estudio
sistemas
ejemplo
distribuye
texto
agruparlos
capítulo
apéndice
du-
rante
estudio
concurrencia
describen
mecanismos
concurrencia
sistema
ejem-
plo
explica
motivación
diversas
opciones
diseño
individuales
enfoque
conceptos
diseño
estudiados
capítulo
refuerzan
inmediatamente
ejemplos
mundo
real
AUDIENCIA
DESTINADO
libro
destinado
audiencia
carácter
académico
perfil
profesio-
nal
libro
texto
pensado
curso
sistemas
operativos
semestre
titulaciones
Informática
Ingeniería
Computadores
Ingeniería
Eléctrica
Incluye
temas
re-
comendados
Computer
Curricula
2001
programas
universitarios
informática
equipo
trabajo
conjunto
planes
estudio
informática
Joint
Task
Force
on
Compu-
ting
Curricula
sociedad
informática
Computer
Society
IEEE
ACM
libro
tra-
ta
temas
recomendados
Guidelines
for
Associate-Degree
Curricula
in
Computer
Science
2002
equipo
trabajo
conjunto
planes
estudio
informática
sociedad
informá-
tica
IEEE
ACM
libro
sirve
igualmente
volumen
referencia
básico
adecuado
estudio
personal
ORGANIZACIÓN
LIBRO
libro
divide
partes
véase
Capítulo
visión
general
Antecedentes
Procesos
Memoria
Planificación
Entrada
salida
ficheros
Sistemas
distribuidos
seguridad
libro
incluye
diversas
características
pedagógicas
numerosas
figuras
tablas
facilitar
estudio
capítulo
incluye
lista
términos
clave
preguntas
repaso
problemas
propuestas
lecturas
adicionales
direcciones
sitios
web
relevantes
disponible
profesores
batería
preguntas
test
SERVICIOS
INTERNET
PROFESORES
ESTUDIANTES
sitio
web
asociado
libro
proporciona
apoyo
estudiantes
profesores
si-
tio
incluye
enlaces
sitios
relevantes
copias
originales
transparencias
figuras
ta-
blas
libro
formato
PDF
Adobe
Acrobat
transparencias
PowerPoint
información
dar-
alta
lista
correo
Internet
libro
página
web
WilliamStallings.com/OS/OS5e.html
Véase
Sección
Sitio
web
sistemas
operativos
Aspectos
in-
ternos
principios
diseño
prólogo
información
establecido
lis-
ta
correo
profesores
libro
puedan
intercambiar
información
sugerencias
preguntas
autor
descubran
errores
tipográficos
tipo
xviii
Prólogo
0-Primeras
12/5/05
17:09
Página
xviiipublicará
lista
erratas
WilliamStallings.com
resaltar
autor
man-
sitio
estudiante
informática
WilliamStallings.com/StudentSupport.html
PROYECTOS
SISTEMAS
OPERATIVOS
instructores
elemento
importante
curso
sistemas
operativos
proyecto
conjunto
proyectos
estudiante
obtiene
experiencia
práctica
per-
mite
reforzar
conceptos
libro
libro
proporciona
incomparable
grado
apoyo
as-
pecto
incluyendo
componente
proyectos
curso
interior
libro
definen
pro-
yectos
programación
principales
sitio
web
profesor
ofrece
referencias
línea
utilizar
estudiantes
abordar
proyectos
forma
gradual
proporciona
información
paquetes
software
sirven
entornos
trabajo
implementación
proyectos
OSP
NACHOS
desarrollar
componentes
sistema
operativo
BACI
estudiar
mecanis-
mos
concurrencia
sitio
web
profesor
incluye
serie
pequeños
proyectos
programación
pensado
desarrollarse
semanas
cubre
amplio
rango
temas
implementarse
lenguaje
apropiado
plataforma
proyectos
investigación
tareas
lectura
análisis
Véase
apéndices
detalles
NOVEDADES
QUINTA
EDICIÓN
edición
autor
intentado
recoger
innovaciones
mejoras
habido
dis-
ciplina
años
transcurrido
edición
manteniendo
tratamien-
to
amplio
completo
materia
Asimismo
profesores
imparten
disciplina
profesionales
trabajan
campo
revisado
profundidad
cuarta
edición
conse-
cuencia
proceso
partes
libro
mejorado
claridad
redacción
ilustraciones
acompañan
texto
incluido
problemas
carácter
realista
mejoras
pedagógicas
presentación
cara
usuario
contenido
técnico
libro
actualizado
completamente
reflejar
cambios
actuales
excitante
disciplina
estudio
Linux
extendido
significativamente
basándose
versión
Linux
2.6
estudio
Windows
actualizado
incluir
Windows
XP
Windows
Server
2003
revisa-
do
extendido
material
dedicado
concurrencia
mejorar
claridad
moviendo
mis-
mo
apéndice
incluyendo
estudio
condiciones
carrera
tratamiento
planifi-
cación
versión
incluye
estudio
inversión
prioridades
capítulo
redes
presentándose
API
Sockets
ampliado
tratamiento
diseño
orien-
tado
objetos
AGRADECIMIENTOS
edición
beneficiado
revisión
realizada
diversas
personas
aportaron
ge-
nerosamente
tiempo
experiencia
incluyen
Stephen
Murrell
Universidad
Miami
David
Krumme
Universidad
Tufts
Duncan
Buell
Universidad
Carolina
Amit
Jain
Universi-
dad
Bosie
State
Fred
Kuhns
Universidad
Washington
St
Louis
Mark
McCullen
Universidad
Michigan
State
Jayson
Rock
Universidad
Wisconsin-Madison
David
Middleton
Universidad
Arkansas
Technological
Binhai
Zhu
Universidad
Montana
State
revisaron
par-
libro
autor
gracias
gente
revisiones
detalladas
capí-
tulos
Javier
Eraso
Helguera
Andrew
Cheese
Robert
Kaiser
Bhavin
Ghandi
Joshua
Cope
Luca
Ve-
Prólogo
xix
0-Primeras
12/5/05
17:09
Página
xixnuti
Gregory
Sharp
Marisa
Gil
Balbir
Singh
Mrugesh
Gajjar
Bruce
Janson
Mayan
Moudgill
Pete
Bixby
Sonja
Tideman
Siddharth
Choudhuri
Zhihui
Zhang
Andrew
Huo
Zhigang
Yibing
Wang
Da-
río
Álvarez
Michael
Tsai
Asimismo
autor
gustaría
agradecer
Tigran
Aivazian
autor
do-
cumento
aspectos
internos
núcleo
Linux
Linux
Kernel
Internals
pro-
yecto
documentación
Linux
Linux
Documentation
Project
revisión
material
Linux
2.6
Ching-Kuang
Shene
Universidad
Michigan
Tech
proporcionó
ejemplos
usados
sec-
ción
condiciones
carrera
revisó
dicha
sección
Asimismo
Fernando
Ariel
Gont
contribuyó
diversos
ejercicios
estudiante
llevó
cabo
revisiones
detalladas
capítulos
autor
querría
gracias
Michael
Kifer
Scott
A.
Smolka
SUNY–Stony
Brook
contribuir
Apéndice
Bill
Bynum
College
of
William
and
Mary
Tracy
Camp
Colorado
School
of
Mines
prestar
ayuda
Apéndice
Steve
Taylor
Worcester
Polytechnic
Institu-
colaborar
proyectos
programación
tareas
lectura
análisis
manual
profesor
profesor
N.
Nguyen
Universidad
George
Mason
contribuir
proyectos
investigación
manual
profesor
Ian
G.Graham
Universidad
Griffith
colaboró
proyectos
programación
libro
Oskars
Rieksts
Universidad
Kutztown
permitió
forma
ge-
nerosa
hiciera
notas
clase
ejercicios
proyectos
autor
querría
gracias
numerosas
personas
responsables
publicación
libro
realizaron
costumbre
excelente
trabajo
incluye
personal
Prenti-
ce
Hall
particularmente
editores
Alan
Apt
Toni
Holm
ayudante
Patrick
Lindner
directo-
ra
producción
Rose
Kernan
directora
suplementos
Sarah
Parker
agradecimiento
ex-
tiende
Jake
Warde
Warde
Publishers
dirigió
proceso
revisión
Patricia
M.
Daly
edición
copia
xx
Prólogo
0-Primeras
12/5/05
17:09
Página
xxCAPÍTULO
Guía
lector
0.1
Organización
libro
0.2
Orden
presentación
temas
0.3
Recursos
Internet
Web
00-Capitulo
12/5/05
16:15
Página
1N
libro
sitio
web
asociado
cubre
cantidad
material
continuación
proporciona
lector
visión
general
0.1
ORGANIZACIÓN
LIBRO
libro
organizado
partes
Antecedentes
Proporciona
introducción
arquitectura
organización
computador
énfasis
aspectos
relacionados
diseño
sistemas
operativos
presentando
asimismo
visión
general
temas
sistemas
operativos
tra-
tados
resto
libro
Procesos
Presenta
análisis
detallado
procesos
procesamiento
multihilo
multiprocesamiento
simétrico
Symmetric
Multiprocessing
SMP
micronú-
cleos
estudian
aspectos
principales
concurrencia
siste-
ma
uniprocesador
hincapié
temas
exclusión
mutua
interbloqueos
Memoria
Proporciona
extenso
estudio
técnicas
gestión
me-
moria
incluyendo
memoria
virtual
Cuarta
Planificación
Ofrece
estudio
comparativo
diversas
estrategias
plani-
ficación
procesos
examinará
planificación
hilos
SMP
tiempo
real
Quinta
Entrada
salida
ficheros
Examina
aspectos
involucrados
control
operaciones
sistema
operativo
dedica
especial
atención
disco
fundamental
rendimiento
sistema
Asimismo
proporciona
visión
general
gestión
ficheros
Sexta
Sistemas
distribuidos
seguridad
Estudia
principales
tendencias
redes
computadores
incluyendo
TCP
IP
procesamiento
cliente
servidor
clusters
Asimismo
describe
áreas
diseño
fundamentales
desarrollo
sistemas
operativos
dis-
tribuidos
Capítulo
16
proporciona
estudio
amenazas
mecanismos
pro-
porcionar
seguridad
computador
red
libro
dedicado
lectores
principios
diseño
aspectos
implementación
sistemas
operativos
contemporáneos
inadecuado
trata-
miento
puramente
teórico
conceptual
mostrar
conceptos
asociarlos
opciones
dise-
ño
tomar
vida
real
seleccionado
sistemas
operativos
ejemplos
reales
Windows
sistema
operativo
multitarea
diseñado
ejecutar
diversos
computadores
personales
estaciones
trabajo
servidores
sistemas
operativos
comer-
ciales
recientes
diseñado
esencialmente
cero
posición
incorporar
nítida
recientes
desarrollos
tecnología
sistemas
operativos
UNIX
sistema
operativo
multitarea
destinado
originalmente
minicomputadores
im-
plementado
amplio
rango
máquinas
poderosos
microprocesadores
supercom-
putadores
familia
sistemas
operativos
incluye
Linux
Sistemas
operativos
Aspectos
internos
principios
diseño
00-Capitulo
12/5/05
16:15
Página
2El
estudio
sistemas
ejemplo
distribuido
libro
agrupado
único
capítulo
apéndice
estudio
concurrencia
describe
mecanismo
concurrencia
sistema
ejemplo
discute
motivación
opciones
diseño
particu-
lares
estrategia
conceptos
diseño
estudiados
determinado
capítulo
inme-
diatamente
reforzados
ejemplos
mundo
real
0.2
ORDEN
PRESENTACIÓN
TEMAS
natural
lectores
cuestionaran
orden
particular
presentación
temas
li-
bro
ejemplo
tema
planificación
Capítulos
10
relacionado
dedicados
concurrencia
Capítulos
tema
general
procesos
Capítulo
razonable
tratarlo
inmediatamente
temas
dificultad
reside
diversos
temas
estrechamente
interrelacionados
ejem-
plo
tratar
memoria
virtual
útil
referencia
aspectos
planificación
relaciona-
fallo
página
útil
referirse
aspectos
gestión
memoria
estudian
decisiones
planificación
tipo
ejemplo
repetir
in-
definidamente
estudio
planificación
requiere
conocimientos
gestión
viceversa
Figura
0.1
sugiere
relaciones
importantes
temas
líneas
continuas
indi-
can
relaciones
estrechas
punto
vista
decisiones
diseño
implementa-
ción
Basados
diagrama
razonable
comenzar
discusión
básica
procesos
co-
rresponde
Capítulo
orden
arbitrario
tratados
sistemas
operativos
reúnen
material
procesos
principio
tratan
te-
Guía
lector
Descripción
control
procesos
Planificación
Gestión
memoria
Seguridad
Gestión
ficheros
Concurrencia
Redes
Gestión
Figura
0.1
Temas
sistemas
operativos
00-Capitulo
12/5/05
16:15
Página
3mas
ciertamente
válido
importancia
fundamental
gestión
memoria
opinión
autor
importante
gestión
procesos
llevado
decisión
presentar
tema
profundizar
planificación
solución
ideal
estudiante
completar
Capítulos
orden
lea
asimile
capítulos
siguientes
paralelo
seguido
opcionalmente
seguido
seguido
opcionalmente
10
estudiar
siguientes
capítu-
orden
11
12
seguido
13
14
15
cerebro
hu-
mano
cabo
procesamiento
paralelo
estudiante
resulta
imposible
caro
traba-
jar
éxito
simultáneamente
copias
libro
abiertas
capítulos
Dada
necesidad
orden
lineal
autor
orden
utilizado
li-
bro
efectivo
0.3
RECURSOS
INTERNET
WEB
diversos
recursos
disponibles
Internet
Web
apoyar
libro
ayudar
lector
mantenerse
avances
campo
SITIOS
WEB
LIBRO
creado
página
web
especial
libro
WilliamStallings.com/OS/OS5e.html
Consul-
diagrama
páginas
principio
libro
obtener
descripción
detallada
si-
tio
web
especial
interés
documentos
disponibles
sitio
web
estudiante
Pseudo-código
lectores
acostumbrados
lenguaje
reproducen
al-
goritmos
pseudo-código
similar
Pascal
lenguaje
pseudo-código
intuitivo
particularmente
fácil
seguir
Descripciones
Windows
UNIX
Linux
mencionado
previamente
utili-
zan
Windows
diversas
versiones
UNIX
ejemplos
casos
reales
estando
estu-
distribuido
texto
agrupado
único
capítulo
apéndice
lectores
preferirían
material
único
sitio
usarlo
referencia
material
Windows
UNIX
libro
reproduce
documentos
si-
tio
web
detecte
error
tipográfico
tipo
publicará
lista
erratas
libro
sitio
web
favor
informe
error
detecte
libro
William
Stallings.com
encuentran
hojas
erratas
libros
publicados
autor
información
descuentos
pedidos
libros
mantiene
sitio
recursos
estudiante
informática
Computer
Science
Student
Resource
Site
WilliamStallings.com/StudentSupport.html
objetivo
sitio
proporcionar
documentos
información
enlaces
estudiantes
informática
enlaces
or-
ganizan
categorías
Matemáticas
Incluye
repaso
matemáticas
básicas
introducción
análisis
colas
sistemas
númericos
enlaces
numerosos
sitios
información
matemáticas
How-to
Aconseja
guía
estudiante
resolver
ejercicios
escribir
informes
técnicos
preparar
presentaciones
técnicas
Sistemas
operativos
Aspectos
internos
principios
diseño
00-Capitulo
12/5/05
16:15
Página
4•
Recursos
investigación
Proporciona
enlaces
recopilaciones
importantes
artículos
in-
formes
técnicos
referencias
bibliográficas
Misceláneos
Incluye
diversos
documentos
enlaces
útiles
SITIOS
WEB
numerosos
sitios
web
proporcionan
información
relacionada
temas
tratados
libro
siguientes
capítulos
encontrarse
referencias
sitios
web
específicos
Sec-
ción
Lecturas
recomendadas
URL
sitio
web
particular
cambiar
libro
incluye
direcciones
URL
sitio
web
libro
encontrarse
enlace
apropiado
sitios
web
nombrados
libro
GRUPOS
NOTICIAS
USENET
Diversos
grupos
noticias
USENET
dedican
tema
relacionado
sistemas
opera-
tivos
determinado
sistema
operativo
ocurre
prácticamente
grupos
USENET
alto
porcentaje
ruido
señal
experimento
valioso
comprobar
satisface
necesidades
lector
relevantes
siguientes
comp.os.research
grupo
interesa
seguir
grupo
noticias
modera-
do
dedica
temas
investigación
comp.os.misc
foro
discusión
general
temas
sistemas
operativos
comp.unix.internals
comp.os.linux.development.system
Guía
lector
00-Capitulo
12/5/05
16:15
Página
500-Capitulo
12/5/05
16:15
Página
6PARTE
ANTECEDENTES
proporcionan
antecedentes
necesarios
establece
contexto
resto
libro
presentando
conceptos
fundamentales
arquitectura
com-
putadores
aspectos
internos
sistemas
operativos
GUÍA
CAPÍTULO
INTRODUCCIÓN
COMPUTADORES
sistema
operativo
intermediario
programas
aplicación
herra-
mientas
usuarios
hardware
computador
apreciar
funciona
siste-
ma
operativo
aspectos
diseño
involucrados
conocimiento
organiza-
ción
arquitectura
computadores
Capítulo
proporciona
estudio
procesador
memoria
elementos
computador
CAPÍTULO
INTRODUCCIÓN
SISTEMAS
OPERATIVOS
tema
diseño
sistema
operativo
S.O.
abarca
enorme
campo
resultando
fácil
enredar-
detalles
perdiendo
contexto
general
estudio
tema
particular
Capí-
tulo
proporciona
visión
general
lector
volver
punto
libro
recuperar
contexto
global
comienza
exposición
objetivos
funciones
siste-
ma
operativo
continuación
relevancia
histórica
describen
sistemas
funciones
S.O.
estudio
permite
presentar
principios
diseño
S.O.
fundamentales
entorno
sencillo
queden
claras
relaciones
funciones
S.O.
conti-
nuación
capítulo
resalta
características
importantes
sistemas
operativos
modernos
libro
presentan
diversos
temas
necesario
hablar
principios
fundamentales
consolidados
recientes
innovaciones
diseño
SS.OO
análisis
capítulo
notar
lector
abordar
mezcla
técnicas
di-
seño
consolidadas
recientes
Finalmente
presenta
introducción
Windows
UNIX
estudio
establece
arquitectura
general
sistemas
proporcionando
contexto
discusiones
detalladas
realizan
01-Capitulo
16/5/05
17:03
Página
701-Capitulo
16/5/05
17:03
Página
8CAPÍTULO
Introducción
computadores
1.1
Elementos
básicos
1.2
Registros
procesador
1.3
Ejecución
instrucciones
1.4
Interrupciones
1.5
jerarquía
memoria
1.6
Memoria
cache
1.7
écnicas
comunicación
1.8
Lecturas
sitios
web
recomendados
1.9
érminos
clave
cuestiones
repaso
problemas
Apéndice
1A
Características
rendimiento
memorias
niveles
Apéndice
1B
Control
procedimientos
01-Capitulo
16/5/05
17:03
Página
9N
sistema
operativo
explota
recursos
hardware
procesadores
proporcionar
conjunto
servicios
usuarios
sistema
sistema
operativo
gestiona
memo-
ria
secundaria
dispositivos
entrada
salida
usuarios
importante
conocimientos
hardware
computador
subyacente
iniciar
estudio
sistemas
operativos
capítulo
proporciona
visión
general
hardware
computador
mayoría
áreas
estudio
asumiendo
lector
familiarizado
tema
embar-
go
estudiarán
detalle
aspectos
repercusión
temas
tratados
libro
1.1
ELEMENTOS
BÁSICOS
alto
nivel
computador
consta
procesador
memoria
componentes
incluyendo
módulos
tipo
componentes
interconectan
lograr
función
principal
computador
ejecutar
programas
elementos
estructurales
principales
Procesador
Controla
funcionamiento
computador
realiza
funciones
procesa-
miento
datos
procesador
denomina
usualmente
unidad
central
proceso
Central
Processing
Unit
CPU
Memoria
principal
Almacena
datos
programas
memoria
habitualmente
volátil
apaga
computador
pierde
contenido
contraste
contenido
memoria
disco
mantiene
apaga
computador
memoria
princi-
pa
denomina
memoria
real
memoria
primaria
Módulos
S.
Transfieren
datos
computador
entorno
externo
entorno
externo
formado
diversos
dispositivos
incluyendo
dispositivos
memoria
secunda-
ria
ejemplo
discos
equipos
comunicaciones
terminales
Bus
sistema
Proporciona
comunicación
procesadores
memoria
principal
módulos
S.
Figura
1.1
muestra
componentes
alto
nivel
funciones
procesador
intercambio
datos
memoria
utilizan
normalmente
registros
inter-
procesador
registro
dirección
memoria
RDIM
especifica
dirección
memoria
lectura
escritura
registro
datos
memoria
RDAM
contie-
ne
datos
escribir
memoria
recibe
datos
leídos
memoria
ma-
nera
similar
registro
dirección
RDIE
especifica
determinado
dispositivo
registro
datos
RDAE
permite
intercambio
datos
módulo
procesador
módulo
memoria
consta
conjunto
posiciones
definidas
direcciones
nu-
meradas
secuencialmente
posición
contiene
patrón
bits
interpretar
instrucción
datos
módulo
transfiere
datos
dispositivos
externos
ha-
cia
procesador
memoria
viceversa
Contiene
buffers
zonas
almacenamiento
in-
ternas
mantienen
temporalmente
datos
puedan
enviar
10
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
101.2
REGISTROS
PROCESADOR
procesador
incluye
conjunto
registros
proporcionan
tipo
memoria
rá-
pida
menor
capacidad
memoria
principal
registros
procesador
sirven
funciones
Registros
visibles
usuario
Permiten
programador
lenguaje
máquina
en-
samblador
minimizar
referencias
memoria
principal
optimizando
registros
lenguajes
alto
nivel
compilador
realice
optimización
intentará
tomar
decisiones
in-
teligentes
variables
asignan
registros
posiciones
memoria
princi-
pa
l.
lenguajes
alto
nivel
tales
permiten
programador
sugerir
compi-
lador
variables
deberían
almacenarse
registros
Registros
control
Usados
procesador
controlar
operación
ru-
tinas
privilegiadas
sistema
operativo
controlar
ejecución
programas
clasificación
nítida
registros
categorías
ejemplo
algu-
nas
máquinas
contador
programa
visible
usuario
estudio
presenta
continuación
conveniente
utilizar
categorías
Introducción
computadores
11
CPU
Memoria
principal
Bus
sistema
Módulo
Buffers
Instrucción
H110022
H110021
Datos
Datos
Datos
Datos
Instrucción
Instrucción
PC
/H11005
Contador
programa
/H11005
Registro
instrucción
RDIM
/H11005
Registro
dirección
memoria
RDAM
/H11005
Registro
datos
memoria
RDI
/H11005
Registro
dirección
entrada
salida
RDA
/H11005
Registro
datos
entrada
salida
PC
RDIM
RDAM
RDI
RDA
Unidad
ejecución
Figura
1.1
Componentes
computador
visión
alto
nivel
01-Capitulo
16/5/05
17:03
Página
11REGISTROS
VISIBLES
USUARIO
registro
visible
usuario
acceder
lenguaje
máquina
ejecutado
procesador
generalmente
disponible
programas
incluyendo
pro-
gramas
aplicación
programas
sistema
tipos
registros
normalmente
dis-
ponibles
registros
datos
dirección
códigos
condición
programador
utilizar
registros
datos
diversas
funciones
ca-
sos
esencia
propósito
general
usarse
instrucción
máquina
realice
operaciones
datos
frecuentemente
restricciones
ejem-
plo
registros
dedicados
operaciones
coma
flotante
operaciones
enteros
registros
dirección
contienen
direcciones
memoria
principal
datos
instruccio-
nes
dirección
utiliza
cálculo
dirección
efectiva
completa
registros
propósito
general
dedicados
for-
ma
particular
direccionamiento
memoria
continuación
incluyen
ejemplos
Registro
índice
direccionamiento
indexado
común
direccionamiento
implica
sumar
índice
valor
base
obtener
dirección
efectiva
Puntero
segmento
direccionamiento
segmentado
memoria
divide
seg-
mentos
bloques
palabras
longitud
variable
referencia
memoria
consta
referencia
determinado
segmento
desplazamiento
seg-
mento
direccionamiento
importante
estudio
gestión
memoria
realizará
Capítulo
direccionamiento
utiliza
registro
mantener
dirección
base
posición
inicio
segmento
múltiples
registros
ejemplo
sistema
operativo
código
sistema
operativo
ejecutando
procesador
aplicación
ejecu-
tando
actualmente
Puntero
pila
direccionamiento
pila
visible
usuario
registro
dedi-
cado
apunta
cima
pila
permite
instrucciones
contienen
campo
dirección
tales
permiten
apilar
push
extraer
pop
máquinas
llamada
subrutina
procedimiento
implica
salvar
automáti-
camente
registros
visibles
usuario
restaurarán
retornar
procesador
reali-
za
operaciones
salvar
restaurar
ejecución
instrucciones
llamada
retorno
permite
procedimiento
use
registros
independientemente
máquinas
programador
responsable
guardar
contenido
registros
visibles
usuario
llamada
procedimiento
incluyendo
instrucciones
programa
funciones
salvar
restaurar
hardware
software
depen-
diendo
procesador
12
Sistemas
operativos
Aspectos
internos
principios
diseño
definición
universal
término
palabra
general
palabra
conjunto
ordenado
bytes
bits
unidad
normal
almacena
transmite
opera
información
determinado
computador
Normalmente
computador
juego
instrucciones
longitud
fija
longitud
instrucciones
palabra
pila
almacena
memoria
principal
conjunto
secuencial
posiciones
referencia
mane-
ra
similar
ocurre
pila
física
papeles
insertando
extrayendo
elementos
cima
Véase
Apéndi-
ce
1B
incluye
explicación
gestión
pila
01-Capitulo
16/5/05
17:03
Página
12REGISTROS
CONTROL
emplean
registros
procesador
controlar
funcionamiento
mayo-
ría
máquinas
visibles
usuario
ac-
ceder
instrucciones
máquina
ejecutadas
denomina
control
sis-
tema
operativo
máquinas
distintas
organizaciones
registros
utilizarán
dife-
rente
terminología
continuación
proporcionará
lista
razonablemente
completa
tipos
registros
descripción
registros
RDIRM
RDAM
RDIE
RDAE
mencionados
anteriormente
Figura
1.1
siguientes
esenciales
eje-
cución
instrucciones
Contador
programa
Program
Counter
PC
Contiene
dirección
próxima
ins-
trucción
leerá
memoria
Registro
instrucción
Instruction
Register
Contiene
instrucción
leída
diseños
procesador
incluyen
registro
conjunto
registros
conocido
usualmente
palabra
programa
Program
Status
Word
PSW
contiene
in-
formación
PSW
contiene
normalmente
códigos
condición
informa-
ción
tales
bit
habilitar
inhabilitar
interrupciones
bit
usua-
rio
supervisor
códigos
condición
llamados
indicadores
bits
cuyo
valor
asigna
nor-
malmente
hardware
procesador
teniendo
resultado
operaciones
ejem-
plo
operación
aritmética
producir
resultado
positivo
negativo
cero
desbordamien-
to
almacenarse
resultado
registro
memoria
fija
código
condición
concordancia
resultado
ejecución
instrucción
aritméti-
ca
Posteriormente
comprobar
código
condición
operación
salto
condicional
bits
código
condición
agrupan
registros
Normalmen-
forman
registro
control
Generalmente
instrucciones
máquina
permiten
bits
lean
referencia
implícita
alterados
refe-
rencia
explícita
destinados
realimentación
resultado
ejecución
instrucción
máquinas
utilizan
múltiples
tipos
interrupciones
proporcionar
conjunto
registros
interrupciones
puntero
rutina
tratamiento
interrupción
utiliza
pila
implementar
funciones
ejemplo
llamadas
procedimientos
necesita
puntero
pila
sistema
véase
Apéndice
1B
hardware
gestión
memoria
estudiado
Capítulo
requiere
registros
dedicados
Asimismo
utilizar
registros
control
operaciones
S.
diseño
organización
registro
control
influyen
factores
as-
pecto
fundamental
proporcionar
apoyo
sistema
operativo
tipos
información
con-
trol
útiles
específicamente
sistema
operativo
diseñador
procesador
co-
nocimiento
funcional
sistema
operativo
utilizar
diseñar
organización
registros
proporcione
soporte
hardware
características
particulares
sistema
operativo
aspectos
tales
protección
memoria
multiplexación
programas
usuario
decisión
diseño
fundamental
reparto
información
control
registros
memoria
habitual
dedicar
primeras
direcciones
bajas
cientos
miles
pala-
bras
memoria
propósitos
control
diseñador
decidir
información
control
Introducción
computadores
13
01-Capitulo
16/5/05
17:03
Página
13debería
registros
rápidos
caros
memoria
principal
rápida
económica
1.3
EJECUCIÓN
INSTRUCCIONES
programa
ejecutarse
procesador
consta
conjunto
instrucciones
almace-
nado
memoria
forma
simple
procesamiento
instrucción
consta
pa-
sos
procesador
lee
busca
instrucciones
memoria
ejecuta
ejecución
programa
consiste
repetir
proceso
búsqueda
ejecución
instruc-
ciones
ejecución
instrucción
involucrar
operaciones
dependiendo
natu-
raleza
denomina
ciclo
instrucción
procesamiento
requerido
única
instrucción
Fi-
gura
1.2
describe
ciclo
instrucción
utilizando
descripción
simplificada
pasos
es-
tos
pasos
denomina
fase
búsqueda
ejecución
ejecución
programa
detiene
apaga
máquina
produce
tipo
error
irrecuperable
ejecuta
instrucción
programa
procesador
BÚSQUEDA
EJECUCIÓN
INSTRUCCIÓN
principio
ciclo
instrucción
procesador
lee
instrucción
memoria
pro-
cesador
típico
contador
programa
PC
almacena
dirección
instrucción
leer
indique
cosa
procesador
incrementa
PC
instrucción
ejecutada
leerá
instrucción
orden
secuencial
de-
cir
instrucción
situada
dirección
memoria
alta
Considere
ejemplo
computador
simplificado
instrucción
ocupa
palabra
memoria
16
bits
Supon-
ga
contador
programa
situado
posición
300
procesador
leerá
ins-
trucción
posición
300
sucesivos
ciclos
instrucción
completados
satisfactoriamente
leerán
instrucciones
posiciones
301
302
303
sucesivamente
secuencia
al-
terar
explicará
posteriormente
instrucción
leída
carga
registro
procesador
conocido
registro
ins-
trucción
instrucción
contiene
bits
especifican
acción
procesador
procesador
interpreta
instrucción
cabo
acción
requerida
general
acciones
dividen
categorías
Procesador-memoria
transferir
datos
procesador
memoria
viceversa
Procesador-E
S.
enviar
datos
dispositivo
periférico
recibirlos
mis-
mo
transfiriéndolos
procesador
módulo
S.
14
Sistemas
operativos
Aspectos
internos
principios
diseño
Inicio
Parada
Busca
instrucción
Fase
búsqueda
Fase
ejecución
Ejecuta
instrucción
Figura
1.2
Ciclo
instrucción
básico
01-Capitulo
16/5/05
17:03
Página
14•
Procesamiento
datos
procesador
operaciones
aritméticas
lógi-
cas
datos
Control
instrucción
especificar
alterar
secuencia
ejecución
ejemplo
procesador
leer
instrucción
posición
149
especifica
si-
guiente
instrucción
posición
182
procesador
almacenará
contador
pro-
grama
valor
182
consecuencia
fase
búsqueda
leerá
ins-
trucción
posición
182
150
ejecución
instrucción
involucrar
combinación
acciones
Considere
ejemplo
sencillo
utilizando
máquina
hipotética
incluye
características
mostradas
Figura
1.3
procesador
contiene
único
registro
datos
llamado
acumulador
AC
instrucciones
datos
longitud
16
bits
estando
memoria
organi-
zada
secuencia
palabras
16
bits
formato
instrucción
proporciona
bits
código
operación
permitiendo
16
códigos
operación
representados
único
dígito
hexadecimal
12
bits
restantes
formato
instrucción
direccio-
nar
directamente
212
4.096
palabras
memoria
denotadas
dígitos
hexadecimales
Figura
1.4
ilustra
ejecución
parcial
programa
mostrando
partes
relevantes
memoria
registros
procesador
fragmento
programa
mostrado
suma
contenido
palabra
memoria
dirección
940
palabra
memoria
dirección
941
almace-
nando
resultado
posición
requieren
instrucciones
corresponden
fases
búsqueda
ejecución
describe
continuación
Introducción
computadores
15
encontrar
repaso
básico
sistema
numéricos
decimal
binario
hexadecimal
Computer
Science
Student
Resource
Site
WilliamStallings.com/StudentSupport.html
03
15
15
Código-de-op
Dirección
01
Magnitud
Contador
programa
PC
Dirección
instrucción
Registro
instrucción
Instrucción
ejecutando
Acumulador
AC
Almacenamiento
temporal
Formato
instrucción
Formato
entero
Registros
internos
CPU
0001
Carga
AC
memoria
0010
Almacena
AC
memoria
0101
Suma
AC
memoria
Lista
parcial
códigos-de-op
Figura
1.3
Características
máquina
hipotética
01-Capitulo
16/5/05
17:03
Página
151
PC
contiene
valor
300
dirección
instrucción
instrucción
va-
lor
1940
hexadecimal
carga
registro
instrucción
incrementa
PC
Nótese
proceso
involucra
registro
dirección
memoria
RDIM
registro
datos
memoria
RDAM
simplificar
muestran
registros
intermedios
bits
dígito
hexadecimal
indican
AC
cargar
valor
leído
memoria
restantes
12
bits
dígitos
hexadecimales
especifican
dirección
memoria
940
lee
instrucción
5941
posición
301
incrementa
PC
contenido
previo
AC
contenido
posición
941
suman
resultado
alma-
cena
AC
lee
instrucción
2941
posición
302
incrementa
PC
almacena
contenido
AC
posición
941
ejemplo
necesitan
ciclos
instrucción
forma
consta
fase
búsqueda
fase
ejecución
sumar
contenido
posición
940
contenido
941
juego
instrucciones
complejo
necesitarían
ciclos
instrucción
mayoría
procesadores
modernos
incluyen
instrucciones
contienen
dirección
fase
ejecución
determinada
instrucción
involucrar
referen-
cia
memoria
Asimismo
referencias
memoria
instrucción
especificar
operación
S.
16
Sistemas
operativos
Aspectos
internos
principios
diseño
PC300
Registros
CPUMemoria
Fase
búsqueda
Fase
ejecución
3001940
301
5941
302
2941
940
0003
941
0002
AC
IR1940
Paso
PC300
Memoria
3011940
301
5941
302
2941
940
0003
941
0002
AC
IR1940
0003
Paso
PC300
Memoria
301
0005
0005
0003
0005
1940
301
5941
302
2941
940
0003
941
0002
AC
IR5941
Paso
PC300
Memoria
3021940
301
5941
302
2941
940
0003
941
0002
AC
IR5941
Paso
PC300
Memoria
301940
301
5941
302
2941
940
0003
941
0002
AC
IR2941
Paso
PC300
Memoria
3031940
301
5941
302
2941
940
0003
941
0005
AC
IR2941
Paso
Registros
CPU
Registros
CPU
Registros
CPU
Registros
CPU
Registros
CPU
Figura
1.4
Ejemplo
ejecución
programa
contenido
memoria
registros
hexadecimal
01-Capitulo
16/5/05
17:03
Página
16SISTEMA
intercambiar
datos
directamente
módulo
ejemplo
controlador
disco
procesador
procesador
iniciar
lectura
escritura
memo-
ria
especificando
dirección
posición
memoria
leer
escribir
datos
módulo
S.
caso
procesador
identifica
dispositivo
específico
controlado
determinado
módulo
S.
producirse
secuencia
instrucciones
similar
Figura
1.4
instrucciones
instrucciones
referencia
memoria
casos
deseable
permitir
intercambios
produzcan
directamente
memoria
liberar
procesador
tarea
S.
tales
casos
procesador
concede
módulo
autorización
leer
escribir
memoria
transferencia
memoria
llevarse
cabo
implicar
procesador
dicha
transferencia
módulo
emite
mandatos
lectura
escritura
memoria
liberando
procesador
res-
ponsabilidad
intercambio
operación
conocida
acceso
directo
memoria
Direct
Me-
mory
Access
DMA
examinará
capítulo
1.4
INTERRUPCIONES
Prácticamente
computadores
proporcionan
mecanismo
módulos
me-
moria
interrumpir
secuenciamiento
normal
procesador
Tabla
1.1
detalla
tipos
comunes
interrupciones
Básicamente
interrupciones
constituyen
mejorar
utilización
procesador
ejemplo
mayoría
dispositivos
lentos
procesador
Supón-
gase
procesador
transfiriendo
datos
impresora
utilizando
esquema
ciclo
ins-
trucción
Figura
1.2
instrucción
escritura
procesador
parar
perma-
necer
inactivo
impresora
lleve
cabo
longitud
pausa
orden
miles
millones
ciclos
instrucción
Claramente
enorme
desperdicio
capacidad
procesador
abla
1.1
Clases
interrupciones
programa
Generada
condición
produce
resultado
ejecu-
ción
instrucción
tales
desbordamiento
aritmético
di-
visión
cero
intento
ejecutar
instrucción
máquina
ilegal
referencias
espacio
memoria
permitido
usuario
temporizador
Generada
temporizador
procesador
Permite
sistema
operati-
vo
funciones
forma
regular
Generada
controlador
señalar
conclusión
normal
operación
indicar
diversas
condiciones
error
fallo
hardware
Generada
fallo
fallo
suministro
energía
error
paridad
memoria
ejemplo
concreto
considere
computador
personal
operase
1GHz
permitiría
ejecutar
10
instrucciones
típico
disco
duro
Introducción
computadores
17
discussion
usos
prefijos
numéricos
tales
giga
tera
disponible
documento
apoyo
Computer
Science
Student
Resource
Site
WilliamStallings.com/StudentSupport.html
01-Capitulo
16/5/05
17:03
Página
17velocidad
rotación
7200
revoluciones
minuto
corresponde
tiempo
rotación
media
pista
ms
millones
lento
procesador
Figura
1.5a
muestra
cuestión
programa
usuario
realiza
serie
llamadas
ESCRITURA
intercaladas
procesamiento
segmentos
código
refieren
se-
cuencias
instrucciones
involucran
S.
llamadas
ESCRITURA
invocan
rutina
utilidad
sistema
realizará
operación
real
S.
programa
consta
secciones
secuencia
instrucciones
etiquetada
figura
preparar
operación
real
S.
incluir
copiar
datos
salida
buffer
especial
preparar
pará-
metros
mandato
dispositivo
mandato
real
S.
interrupciones
emite
mandato
programa
esperar
dispositivo
realice
función
solicitada
comprobar
periódicamente
muestrear
dispositivo
programa
esperar
sim-
plemente
realizando
repetidamente
operación
comprobación
determinar
operación
S.
secuencia
instrucciones
etiquetada
figura
completar
operación
incluir
establecer
valor
indique
éxito
fallo
operación
operación
tardar
tiempo
relativamente
completa
programa
queda
colgado
esperando
complete
programa
usuario
detiene
momento
llamada
ESCRITURA
periodo
tiempo
considerable
18
Sistemas
operativos
Aspectos
internos
principios
diseño
Programa
usuario
ESCRITURA
Programa
Mandato
interrupciones
Manejador
interrupción
2a
2b
3a
3b
Interrupciones
espera
Interrupciones
espera
larga
Programa
usuario
Programa
usuario
ESCRITURA
ESCRITURA
ESCRITURA
ESCRITURA
ESCRITURA
ESCRITURA
ESCRITURA
ESCRITURA
Programa
Mandato
Programa
Mandato
Manejador
interrupción
Figura
1.5
Flujo
programa
control
interrupciones
01-Capitulo
16/5/05
17:03
Página
18INTERRUPCIONES
CICLO
INSTRUCCIÓN
Gracias
interrupciones
procesador
dedicarse
ejecutar
instrucciones
operación
llevando
cabo
Considere
flujo
control
mostrado
Figura
1.5b
anteriormente
programa
usuario
alcanza
punto
llamada
sistema
consiste
llamada
ESCRITURA
programa
invoca
caso
consta
código
preparación
mandato
real
S.
ejecuten
po-
cas
instrucciones
devuelve
control
programa
usuario
dispositivo
exter-
ocupado
aceptando
datos
memoria
computador
imprimiéndolos
operación
cabo
forma
concurrente
ejecución
instrucciones
programa
usuario
dispositivo
externo
listo
atendido
preparado
aceptar
datos
procesador
módulo
dispositivo
externo
manda
señal
petición
interrupción
procesador
procesador
responde
suspendiendo
ejecución
progra-
ma
actual
saltando
rutina
servicio
específica
dispositivo
conocida
mane-
jador
interrupción
reanudando
ejecución
original
atendido
dispositivo
Figura
1.5b
indican
puntos
produce
interrupción
Téngase
producir
interrupción
punto
ejecución
programa
prin-
cipal
determinada
instrucción
cara
programa
usuario
interrupción
suspende
secuencia
normal
ejecución
completa
procesamiento
interrupción
reanuda
ejecución
Figura
1.6
programa
usuario
contener
código
especial
tratar
interrupcio-
nes
procesador
sistema
operativo
responsables
suspender
programa
usuario
posteriormente
reanudarlo
punto
tratar
interrupciones
añade
fase
interrupción
ciclo
instrucción
muestra
Figura
1.7
compárese
Figura
1.2
fase
interrupción
procesador
comprueba
producido
interrupción
indicado
presencia
señal
interrupción
interrupciones
pendientes
procesador
continúa
fase
búsqueda
lee
instrucción
programa
actual
pendiente
interrupción
procesador
sus-
pende
ejecución
programa
actual
ejecuta
rutina
manejador
interrupción
rutina
manejador
interrupción
generalmente
sistema
operativo
Normalmente
rutina
Introducción
computadores
19
/H11001
interrupción
produce
punto
Programa
usuario
Manejador
interrupción
Figura
1.6
Transferencia
control
interrupciones
01-Capitulo
16/5/05
17:03
Página
19determina
naturaleza
interrupción
realiza
acciones
requieran
ejemplo
usando
manejador
determina
módulo
generó
interrupción
paso
programa
escriba
datos
módulo
S.
completa
rutina
maneja-
dor
interrupción
procesador
reanudar
ejecución
programa
usuario
punto
interrupción
evidente
proceso
implica
sobrecarga
ejecutarse
instrucciones
adiciona-
manejador
interrupción
determinar
naturaleza
interrupción
decidir
acción
apropiada
cantidad
relativamente
elevada
tiempo
gasta-
ría
simplemente
espera
operación
procesador
emplear
efi-
cientemente
interrupciones
apreciar
ganancia
eficiencia
considere
Figura
1.8
diagrama
tiempo
ba-
sado
flujo
control
Figuras
1.5a
1.5b
Figuras
1.5b
1.8
asumen
tiempo
re-
querido
operación
relativamente
corto
inferior
tiempo
tarda
completarse
ejecución
instrucciones
operaciones
escritura
programa
usuario
caso
típi-
co
especialmente
dispositivo
lento
impresora
operación
mu-
cho
tiempo
ejecución
secuencia
instrucciones
usuario
Figura
1.5c
ilustra
tipo
situación
caso
programa
usuario
alcanza
llamada
ESCRITU-
RA
complete
operación
generada
llamada
resultado
programa
usuario
queda
colgado
punto
completa
operación
prece-
dente
procesar
llamada
ESCRITURA
empezar
operación
S.
Figura
1.9
muestra
temporización
situación
interrupciones
observar
ganancia
eficiencia
tiempo
realiza
operación
solapa
ejecución
instrucciones
usuario
PROCESAMIENTO
INTERRUPCIONES
aparición
interrupción
dispara
eventos
hardware
procesador
software
Figura
1.10
muestra
secuencia
típica
dispositivo
completa
operación
produce
secuencia
eventos
hardware
dispositivo
genera
señal
interrupción
procesador
procesador
termina
ejecución
instrucción
actual
responder
interrup-
ción
indica
Figura
1.7
20
Sistemas
operativos
Aspectos
internos
principios
diseño
Fase
búsqueda
Fase
ejecución
Fase
interrupción
Inicio
Parada
Interrupciones
inhabilitadas
Búsqueda
instrucción
Ejecuta
instrucción
Comprueba
interrupción
inicia
manejador
interrupciónInterrupciones
habilitadas
Figura
1.7
Ciclo
instrucción
interrupciones
01-Capitulo
16/5/05
17:03
Página
203
procesador
comprueba
petición
interrupción
pendiente
determina
manda
señal
reconocimiento
dispositivo
produjo
interrupción
re-
conocimiento
permite
dispositivo
elimine
señal
interrupción
momento
procesador
necesita
prepararse
transferir
control
rutina
inte-
rrupción
comenzar
necesita
salvar
información
requerida
reanudar
programa
actual
momento
interrupción
información
mínima
requerida
palabra
es-
tado
programa
PSW
posición
instrucción
ejecutar
contenida
contador
programa
información
apilar
pila
con-
trol
sistema
véase
Apéndice
1B
continuación
procesador
carga
contador
programa
posición
punto
en-
trada
rutina
manejo
interrupción
responderá
interrupción
Dependiendo
arquitectura
computador
diseño
sistema
operativo
único
programa
tipo
interrupción
dispositivo
tipo
interrupción
rutina
manejo
interrupción
procesador
determinar
invo-
car
información
incluida
señal
interrupción
original
procesador
Introducción
computadores
21
Espera
procesador
55
Tiempo
Operación
Operación
2a
2b
3a
3b
interrupciones
números
círculo
refieren
usados
Figura
1.5a
interrupciones
números
círculo
refieren
usados
Figura
1.5b
Operación
Operación
Espera
procesador
Figura
1.8
Temporización
programa
espera
S.
01-Capitulo
16/5/05
17:03
Página
21puede
petición
dispositivo
generó
interrupción
obtener
respuesta
contiene
información
requerida
cargado
contador
programa
procesador
continúa
ci-
clo
instrucción
comienza
lectura
instrucción
lectura
instrucción
determinada
contenido
contador
programa
resultado
transfiere
con-
trol
programa
manejador
interrupción
ejecución
programa
conlleva
siguientes
operaciones
momento
contador
programa
PSW
vinculados
programa
interrumpido
almacenado
pila
sistema
información
programa
ejecución
concreto
necesita
salvar
contenido
registros
procesador
puesto
registros
utilizar
manejador
interrup-
22
Sistemas
operativos
Aspectos
internos
principios
diseño
Tiempo
Espera
procesador
Operación
interrupciones
números
círculo
refieren
usados
Figura
1.5a
interrupciones
números
círculo
refieren
usados
Figura
1.5c
Espera
procesador
Operación
Espera
procesador
Operación
Operación
Espera
procesador
Figura
1.9
Temporización
programa
espera
larga
S.
01-Capitulo
16/5/05
17:03
Página
22ciones
salvar
valores
información
es-
tado
Generalmente
manejador
interrupción
comenzará
salvando
contenido
registros
pila
Capítulo
estudiará
información
salvarse
Figura
1.11a
muestra
ejemplo
sencillo
caso
programa
usuario
interrum-
pe
instrucción
posición
N.
contenido
registros
di-
rección
instrucción
palabras
apilan
pila
control
puntero
pila
actualiza
señale
cima
pila
conta-
dor
programa
quedará
apuntando
principio
rutina
servicio
interrupción
manejador
interrupción
momento
comenzar
procesar
interrupción
incluirá
examen
información
relacionada
operación
evento
distinto
causado
interrupción
Asimismo
implicar
envío
mandatos
adicionales
reconocimientos
dispositivo
S.
completa
procesamiento
interrupción
recuperan
valores
regis-
tros
salvados
pila
restituyen
registros
ejemplo
véase
Figura
1.11b
acción
consiste
restituir
pila
valores
PSW
contador
pro-
grama
resultado
instrucción
ejecutar
corresponderá
programa
previamente
interrumpido
importante
salvar
información
programa
interrumpido
posterior
reanudación
interrupción
rutina
llamada
programa
lu-
Introducción
computadores
23
controlador
dispositivo
sistema
hardware
genera
interrupción
procesador
termina
ejecución
instrucción
actual
procesador
indica
reconocimiento
interrupción
procesador
apila
PSW
PC
pila
control
procesador
carga
valor
PC
basado
interrupción
Salva
resto
información
proceso
Procesa
interrupción
Restaura
información
proceso
Restaura
antiguos
PSW
PC
Hardware
Software
Figura
1.10
Procesamiento
simple
interrupciones
01-Capitulo
16/5/05
17:03
Página
23gar
interrupción
suceder
momento
punto
ejecu-
ción
programa
usuario
aparición
imprevisible
MÚLTIPLES
INTERRUPCIONES
estudio
momento
tratado
caso
produzca
única
in-
terrupción
Supóngase
producen
múltiples
interrupciones
ejemplo
pro-
grama
recibiendo
datos
línea
comunicación
imprimiendo
resultados
tiempo
impresora
generará
interrupción
completa
operación
impresión
controlador
línea
comunicación
generará
interrupción
llega
unidad
datos
unidad
consistir
único
carácter
bloque
dependiendo
naturale-
za
protocolo
comunicaciones
caso
produzca
interrupción
comunicación
procesando
interrupción
impresora
considerar
alternativas
hora
tratar
múltiples
interrupciones
inhabilitar
interrupciones
procesando
interrupción
interrupción
inhabilitada
significa
simplemente
procesador
ignorará
señal
petición
interrupción
produce
interrupción
tiempo
generalmente
permanecerá
pendien-
procesada
procesador
comprobará
rehabiliten
interrupciones
ejecuta
programa
usuario
produce
interrupción
inhabilitan
interrupciones
inmediatamente
completa
rutina
manejo
interrupción
rehabilitan
interrupciones
reanudar
programa
usuario
procesa-
dor
comprueba
producido
interrupciones
adicionales
estrategia
válida
sencilla
puesto
interrupciones
manejan
estricto
orden
secuencial
Figura
1.12a
desventaja
estrategia
prioridad
relativa
grado
urgencia
interrupciones
ejemplo
llegan
datos
línea
comunicación
necesitar
procesen
rápidamente
deje
sitio
datos
llegar
lote
datos
procesado
llegue
datos
perderse
buffer
dispositivo
llenarse
desbordarse
estrategia
definir
prioridades
interrupciones
permitir
interrup-
ción
prioridad
cause
interrumpa
ejecución
manejador
interrupción
menor
prioridad
Figura
1.12b
ejemplo
estrategia
considere
sistema
dispositivos
impresora
disco
línea
comunicación
prioridades
cre-
cientes
respectivamente
Figura
1.13
basada
ejemplo
TANE97
muestra
secuencia
programa
usuario
comienza
10
produce
interrupción
impresora
almacena
información
usuario
pila
sistema
ejecución
continúa
rutina
servicio
interrupción
Interrupt
Service
Routine
ISR
impresora
ejecutando
rutina
15
produce
interrupción
equipo
comunicaciones
línea
comunicación
prioridad
superior
impresora
sirve
pe-
tición
interrupción
interrumpe
ISR
impresora
almacena
pila
eje-
cución
continúa
ISR
equipo
comunicaciones
ejecutando
rutina
produce
interrupción
disco
20
interrupción
menor
prioridad
simple-
mente
queda
espera
ISR
línea
comunicación
ejecuta
conclusión
completa
ISR
línea
comunicación
25
restituye
previo
proceso
corresponde
ejecución
ISR
impresora
ejecutarse
instrucción
rutina
procesador
atiende
interrupción
dis-
co
prioridad
transfiere
control
ISR
disco
completa
rutina
35
reanuda
ISR
impresora
rutina
completa
40
de-
vuelve
finalmente
control
programa
usuario
24
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
24MULTIPROGRAMACIÓN
utilizando
interrupciones
procesador
siga
utilizarse
eficientemente
ejemplo
considérese
Figura
1.9b
demuestra
utilización
procesador
tiem-
po
requerido
completar
operación
código
usuario
llamadas
situación
habitual
procesador
parado
tiempo
solución
problema
permitir
múltiples
programas
usuario
estén
activos
tiempo
Supóngase
ejemplo
procesador
ejecutar
programas
sim-
plemente
dedica
leer
datos
memoria
copiarlos
dispositivo
externo
tipo
aplicación
implica
cálculo
procesador
empezar
programa
Introducción
computadores
25
Inicio
/H11001
/H11001
Retorno
Programa
usuario
Memoria
principal
Procesador
Registros
generales
Contador
programa
Puntero
pila
/H11002
/H11002
Pila
control
Rutina
servicio
interrupción
Programa
usuario
interrupción
produce
instrucción
posición
Retorno
interrupción
/H11001
/H11001
Procesador
Registros
generales
Contador
programa
Puntero
pila
/H11001
/H11001
/H11002
/H11002
Pila
control
/H11001
Inicio
Retorno
Memoria
principal
Rutina
servicio
interrupción
Figura
1.11
Cambios
memoria
registros
interrupción
01-Capitulo
16/5/05
17:03
Página
25genera
salida
emitir
mandato
escritura
dispositivo
externo
continuación
empezar
ejecución
aplicación
procesador
programas
secuencia
ejecutan
programas
dependerá
prioridad
relativa
esperando
finalización
operación
S.
interrumpe
programa
transfiere
control
manejador
interrupción
completado
rutina
manejador
interrup-
ción
ocurrir
devuelva
inmediatamente
control
programa
usuario
es-
taba
ejecución
momento
lugar
control
pasar
programa
pen-
diente
ejecutar
prioridad
Posteriormente
reanudará
programa
usuario
interrumpido
previamente
momento
prioridad
concepto
múltiples
programas
ejecutan
turnos
denomina
multiprogramación
estudiará
Capítulo
26
Sistemas
operativos
Aspectos
internos
principios
diseño
Programa
usuario
Manejador
interrupción
Procesamiento
secuencial
interrupciones
Procesamiento
anidado
interrupciones
Manejador
interrupción
Manejador
interrupción
Manejador
interrupción
Programa
usuario
Figura
1.12
Transferencia
control
múltiples
interrupciones
01-Capitulo
16/5/05
17:03
Página
261.5
JERARQUÍA
MEMORIA
restricciones
diseño
memoria
computador
resumir
preguntas
capacidad
velocidad
coste
pregunta
capacidad
límite
dispone
determinada
capacidad
probablemente
desarrollarán
aplicaciones
usarán
cuestión
acer-
ca
velocidad
tiempo
respuesta
fácil
alcanzar
rendimiento
máximo
memoria
capaz
mantener
ritmo
procesador
procesa-
dor
ejecutando
instrucciones
debería
pausas
esperando
estén
disponibles
instruc-
ciones
operandos
considerar
pregunta
sistema
práctico
coste
memoria
razonable
relación
componentes
esperar
compromiso
características
fundamentales
me-
moria
coste
capacidad
tiempo
acceso
momento
utilizan
diversas
tecnologías
implementar
sistemas
memoria
espectro
tecnologías
cum-
plen
siguientes
relaciones
menor
tiempo
acceso
coste
bit
capacidad
menor
coste
bit
capacidad
menor
velocidad
acceso
Queda
dilema
enfrenta
diseñador
gustaría
utilizar
tecnologías
proporcionen
memoria
capacidad
necesita
capacidad
coste
bit
cumplir
requisitos
rendimiento
diseñador
necesita
utilizar
memorias
capacidad
relativamente
baja
tiempos
acceso
rápidos
Introducción
computadores
27
Programa
usuario
Rutina
servicio
interrupción
impresora
Rutina
servicio
interrupción
disco
/H1100510
/H1100540
/H1100515
/H1100525
/H1100525
/H1100535
/H11005
Rutina
servicio
interrupción
comunicación
Figura
1.13
Ejemplo
secuencia
tiempo
múltiples
interrupciones
01-Capitulo
16/5/05
17:03
Página
27La
solución
dilema
consiste
basarse
único
componente
memoria
tecnología
emplear
jerarquía
memoria
Figura
1.14
muestra
jerarquía
típica
desciende
jerarquía
ocurre
Disminución
coste
bit
Aumento
capacidad
Aumento
tiempo
acceso
Disminución
frecuencia
acceso
memoria
procesador
memorias
rápidas
caras
pequeñas
complementan
memorias
len-
tas
baratas
clave
éxito
organización
aspecto
disminución
frecuencia
acceso
concepto
examinará
detalle
mis-
mo
capítulo
estudie
cache
posteriores
capítulos
libro
presente
memoria
virtual
modos
proporcionará
explicación
momento
Supóngase
procesador
acceso
niveles
memoria
nivel
contiene
1.000
bytes
tiempo
acceso
0.1
ms
nivel
contiene
100.000
bytes
tiempo
acceso
1ms
Asuma
byte
acceder
nivel
procesador
di-
28
Sistemas
operativos
Aspectos
internos
principios
diseño
Memoria
interna
Almacenamiento
externo
Almacenamiento
línea
Memoria
principal
Disco
magnéticoCD-ROM
CD-RW
DVD-RW
DVD-RAM
Cinta
magnéticaMO
WORM
Cache
Re-
gistros
Figura
1.14
jerarquía
memoria
01-Capitulo
16/5/05
17:03
Página
28rectamente
nivel
transfiere
byte
nivel
continua-
ción
procesador
accede
simplificar
ignorará
tiempo
requerido
procesador
determinar
byte
nivel
Figura
1.15
muestra
forma
general
curva
representa
situación
figura
muestra
tiempo
acceso
memoria
ni-
veles
función
tasa
aciertos
define
fracción
ac-
cesos
memoria
encuentran
memoria
rápida
ejemplo
cache
tiempo
acceso
nivel
T2
nivel
25
observar
porcentajes
elevados
accesos
nivel
tiempo
acceso
correspondiente
nivel
nivel
ejemplo
supone
95%
accesos
memoria
encuentran
cache
A=
0,95
tiempo
acceder
byte
expresar
0,95)(0,1
ms
0,05)(0,1
ms
ms
0,095
0,055
0,15
ms
resultado
tiempo
acceso
memoria
rápida
principio
estrategia
utilizar
niveles
memoria
funciona
cumplen
condiciones
empleo
diversas
tecnologías
rango
sistemas
memoria
satisfacen
condiciones
Afortunadamente
condición
gene-
ralmente
válida
validez
condición
basada
principio
conocido
proximidad
refe-
rencias
DENN68
curso
ejecución
programa
referencias
memoria
procesador
instrucciones
datos
tienden
agruparse
programas
contienen
habi-
tualmente
diversos
bucles
iterativos
subrutinas
inicia
bucle
subrutina
referencias
repetidas
pequeño
conjunto
instrucciones
operaciones
tablas
vectores
involucran
accesos
conjuntos
agrupados
bytes
datos
periodo
tiem-
Introducción
computadores
29
palabra
accedida
memoria
rápida
define
acierto
fallo
suce-
palabra
accedida
memoria
rápida
T1
T2
T1
/H11001
T2
Fracción
accesos
involucra
nivel
tasa
aciertos
Tiempo
acceso
Figura
1.15
Rendimiento
memoria
simple
niveles
01-Capitulo
16/5/05
17:03
Página
29po
agrupaciones
usando
cambiando
periodo
corto
procesa-
dor
principalmente
trabajando
grupos
fijos
referencias
memoria
consiguiente
organizar
datos
jerarquía
porcenta-
je
accesos
nivel
sucesivamente
considerablemente
menor
nivel
inferior
Considere
ejemplo
niveles
presentado
previamente
Supóngase
memoria
nivel
contiene
datos
instrucciones
programa
agrupaciones
actuales
almacenar
temporalmente
nivel
agrupaciones
nivel
expulsada
nivel
sitio
agrupación
llega
nivel
media
embar-
go
mayoría
referencias
corresponderá
instrucciones
datos
contenidos
nivel
principio
aplicar
niveles
memoria
tipo
memoria
rápida
pe-
queña
costosa
consiste
registros
internos
procesador
Normalmente
procesador
contendrá
docenas
tipo
registros
máquinas
contienen
cientos
registros
Descendiendo
niveles
memoria
principal
sistema
memoria
interna
fundamental
computador
posición
memoria
principal
única
dirección
mayoría
ins-
trucciones
máquina
referencia
direcciones
memoria
principal
memoria
prin-
cipal
amplía
usualmente
cache
pequeña
velocidad
cache
normalmente
visible
programador
procesador
dispositivo
controla
movimiento
datos
memoria
principal
registros
procesador
objeto
mejorar
rendimiento
formas
memoria
descritas
normalmente
volátiles
emplean
tecnología
semi-
conductores
niveles
explota
memoria
semiconductores
presen-
ta
diversos
tipos
diferencian
velocidad
coste
datos
almacenan
forma
permanente
dispositivos
almacenamiento
masivo
externos
comunes
discos
duros
dispositivos
extraíbles
tales
discos
extraíbles
cintas
al-
macenamiento
óptico
memoria
volátil
externa
denomina
memoria
secundaria
memoria
auxiliar
almacenar
ficheros
programas
datos
usualmente
visi-
ble
programador
términos
ficheros
registros
contraposición
bytes
palabras
indi-
viduales
disco
utiliza
proporcionar
extensión
memoria
principal
conoci-
memoria
virtual
estudiará
Capítulo
añadir
niveles
adicionales
jerarquía
software
ejemplo
utilizar
memoria
principal
zona
almacenamiento
intermedio
guardar
temporalmente
datos
leídos
disco
técnica
denominada
cache
disco
estudia
detalle
Capítulo
11
mejora
rendimiento
maneras
escrituras
disco
agruparse
transferencias
datos
pe-
queño
tamaño
producen
transferencias
tamaño
mejora
rendi-
miento
disco
minimiza
grado
implicación
procesador
programa
acceder
datos
destinados
escritos
volca-
do
disco
caso
datos
recuperan
rápidamente
cache
software
lentamente
ocurre
accede
disco
Apéndice
1A
estudia
implicaciones
rendimiento
estructuras
memoria
múltiples
niveles
1.6
MEMORIA
CACHE
memoria
cache
invisible
sistema
operativo
interactúa
elementos
hardware
gestión
memoria
principios
usados
esquemas
me-
moria
virtual
estudiados
Capítulo
8)
aplicables
memoria
cache
30
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
30MOTIVACIÓN
ciclos
instrucción
procesador
accede
memoria
leer
ins-
trucción
frecuencia
adicionales
leer
almacenar
resultados
ve-
locidad
procesador
ejecutar
instrucciones
claramente
limitada
tiempo
ciclo
memoria
tiempo
tarda
leer
escribir
palabra
memoria
limitación
problema
significativo
persistente
discrepancia
velocidad
procesador
memoria
principal
años
velocidad
procesador
incre-
mentado
constantemente
forma
rápida
velocidad
acceso
memoria
diseñador
compromiso
velocidad
coste
tamaño
Idealmente
debería
construir
memoria
principal
tecnología
registros
procesador
consiguiendo
tiem-
pos
ciclo
memoria
comparables
tiempos
ciclo
procesador
estrategia
resultado
costosa
solución
consiste
aprovecharse
principio
proximidad
uti-
lizando
memoria
pequeña
rápida
procesador
memoria
principal
denominada
cache
FUNDAMENTOS
CACHE
propósito
memoria
cache
proporcionar
tiempo
acceso
memoria
memorias
rápidas
disponibles
tiempo
ofrecer
tamaño
memoria
precio
tipos
memorias
semiconductores
costosas
concepto
muestra
Figura
1.16
memoria
principal
relativamente
lenta
memoria
cache
pequeña
rápida
cache
contiene
copia
memoria
principal
procesador
intenta
leer
byte
memoria
comprobación
determinar
byte
cache
entrega
byte
procesador
caso
contrario
lee
in-
troduce
cache
bloque
memoria
principal
consta
número
fijo
bytes
continuación
entrega
byte
pedido
procesador
fenómeno
proxi-
midad
referencias
lee
introduce
cache
bloque
datos
satisfacer
única
referencia
memoria
probable
referencias
memoria
futuro
correspondan
bytes
bloque
Figura
1.17
representa
estructura
sistema
memoria
cache
principal
memoria
principal
consta
palabras
direccionables
teniendo
palabra
única
dirección
n-
bits
efectos
correspondencia
niveles
memoria
consta
número
bloques
longitud
fija
palabras
bloques
cache
consis-
huecos
denominados
líneas
palabras
número
huecos
considerablemente
menor
número
bloques
memoria
principal
M)6
sub-
Introducción
computadores
31
símbolo
significa
menor
similar
símbolo
significa
CPU
Cache
Memoria
principal
Transferencias
bloques
Transferencias
palabras
Figura
1.16
Cache
memoria
principal
01-Capitulo
16/5/05
17:03
Página
31conjuntos
bloques
memoria
principal
residen
huecos
cache
lee
pala-
bra
bloque
memoria
cache
transfiere
bloque
huecos
cache
bloques
huecos
dedicar
hueco
individual
forma
única
permanente
determinado
bloque
hueco
incluye
etiqueta
identifi-
ca
bloque
concreto
almacena
actualmente
etiqueta
corresponde
normalmente
bits
peso
dirección
referencia
direcciones
co-
mienzan
secuencia
bits
ejemplo
sencillo
supóngase
dirección
bits
etiqueta
bits
eti-
queta
01
refiere
bloque
posiciones
siguientes
direcciones
010000
010001
010010
010011
010100
010101
010110
010111
011000
011001
011010
011011
011100
011101
011110
011111
Figura
1.18
muestra
operación
lectura
procesador
genera
dirección
DL
pala-
bra
pretende
leer
cache
contiene
palabra
entrega
procesador
caso
contrario
carga
cache
bloque
contiene
palabra
proporcionando
procesador
dicha
palabra
DISEÑO
CACHE
estudio
detallado
diseño
cache
queda
alcance
libro
continuación
resumen
brevemente
elementos
fundamentales
comprobará
afrontar
32
Sistemas
operativos
Aspectos
internos
principios
diseño
Dirección
memoria
/H11002
2n
/H11002
Longitud
palabra
Longitud
bloque
palabras
Bloque
palabras
Bloque
Número
línea
Etiqueta
Bloque
Memoria
principal
Cache
Figura
1.17
Estructura
cache
memoria
principal
01-Capitulo
16/5/05
17:03
Página
32aspectos
diseño
similares
tratar
diseño
memoria
virtual
cache
disco
divi-
den
siguientes
categorías
Tamaño
cache
Tamaño
bloque
Función
correspondencia
Algoritmo
remplazo
Política
escritura
tratado
tema
tamaño
cache
llegándose
conclusión
cache
tamaño
razonablemente
pequeño
impacto
significativo
rendimiento
as-
pecto
relacionado
capacidad
cache
tamaño
bloque
unidad
datos
intercambia
cache
memoria
principal
tamaño
bloque
incrementa
pequeño
tamaños
mayores
principio
tasa
aciertos
aumentará
principio
proximidad
alta
probabilidad
accedan
futuro
inmediato
datos
proximidad
palabra
referencia
incrementa
tamaño
bloque
llevan
cache
datos
útiles
tasa
aciertos
comenzará
decrecer
tamaño
bloque
sigua
creciendo
probabilidad
volver
datos
recientemente
Introducción
computadores
33
Recibe
dirección
DL
CPU
cache
bloque
contiene
DL
Lee
palabra
DL
entrega
CPU
Completado
Accede
memoria
principal
buscando
bloque
contiene
DL
Reserva
hueco
cache
bloque
memoria
principal
Entrega
palabra
DL
CPU
Carga
bloque
memoria
principal
hueco
cache
Inicio
DL
dirección
lectura
Figura
1.18
Operación
lectura
cache
01-Capitulo
16/5/05
17:03
Página
33leídos
menor
utilizar
nuevamente
datos
expulsar
cache
dejar
sitio
bloque
lee
incluye
bloque
datos
cache
función
correspondencia
determina
posición
cache
ocupará
bloque
restricciones
afectan
diseño
función
correspondencia
lugar
introduce
bloque
cache
remplazar
deseable
minimizara
probabilidad
remplazase
bloque
necesitara
futuro
inmediato
flexible
función
corres-
pondencia
grado
libertad
hora
diseñar
algoritmo
remplazo
maximice
tasa
aciertos
lugar
flexible
función
correspondencia
compleja
circuitería
requerida
buscar
cache
determinar
bloque
algoritmo
remplazo
selecciona
restricciones
función
corresponden-
cia
bloque
remplazar
bloque
cargarse
cache
huecos
llenos
bloques
deseable
remplazar
bloque
probablemente
necesitar
futuro
inmediato
imposible
identificar
bloque
estrategia
razonablemente
eficiente
remplazar
bloque
cache
tiempo
ha-
berse
producido
referencia
política
denomina
algoritmo
reciente-
mente
usado
Least
Recently
Used
LRU
necesitan
mecanismos
hardware
identificar
blo-
recientemente
usado
altera
contenido
bloque
cache
necesario
volverlo
escribir
memoria
principal
remplazarlo
política
escritura
dicta
lugar
operación
es-
critura
memoria
alternativa
escritura
produzca
actualiza
blo-
opción
escritura
realice
remplaza
bloque
estrategia
minimiza
operaciones
escritura
memoria
deja
memoria
principal
temporalmente
obsoleto
interferir
operación
multiprocesador
acceso
directo
memoria
módulos
hardware
S.
1.7
TÉCNICAS
COMUNICACIÓN
técnicas
cabo
operaciones
programada
dirigida
interrupciones
Acceso
directo
memoria
Direct
Memory
Access
DMA
PROGRAMADA
procesador
ejecuta
programa
instrucción
relacionada
ejecu-
ta
instrucción
generando
mandato
módulo
apropiado
caso
programa-
módulo
realiza
acción
solicitada
fija
bits
correspondientes
registro
esta-
do
realiza
acción
avisar
procesador
concreto
interrumpe
procesador
invoca
instrucción
procesador
tomar
papel
activo
determinar
completa
instrucción
S.
motivo
procesador
comprueba
periódicamente
módulo
completado
operación
34
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
34Con
técnica
procesador
responsable
extraer
datos
memoria
principal
operación
salida
almacenarlos
operación
entrada
sotfware
es-
cribe
procesador
ejecuta
instrucciones
control
directo
operación
incluyendo
comprobar
dispositivo
enviar
mandato
lectura
escritura
transferir
datos
juego
instrucciones
incluye
instrucciones
siguientes
categorías
Control
Utilizadas
activar
dispositivo
externo
especificarle
ejemplo
indicar
unidad
cinta
magnética
rebobine
avance
registro
Utilizadas
comprobar
diversas
condiciones
asociadas
módulo
periféricos
Transferencia
Utilizadas
leer
escribir
datos
registros
procesador
dispositivos
externos
Figura
1.19a
proporciona
ejemplo
programada
leer
bloque
da-
tos
dispositivo
externo
p.
ej.
registro
cinta
almacenarlo
memoria
datos
leen
palabra
palabra
ejemplo
16
bits
palabra
lee
procesador
per-
manecer
bucle
comprobación
determina
palabra
disponible
registro
datos
módulo
S.
diagrama
flujo
subraya
desventajas
principa-
técnica
proceso
consume
tiempo
apreciable
mantiene
procesador
ocupado
innecesariamente
Introducción
computadores
35
Envía
mandato
lectura
módulo
Lee
módulo
Comprueba
Lee
palabra
módulo
Escribe
palabra
memoria
Completado
instrucción
programada
instrucción
dirigida
interrupciones
instrucción
Acceso
directo
memoriaCondición
error
Listo
Listo
listo
cosa
Lee
módulo
DMA
CPU
memoria
CPU
memoria
CPU
CPU
CPU
Interrupción
CPU
Interrupción
DMA
CPU
CPU
CPU
cosa
CPU
DMAEnvía
mandato
lectura
módulo
Lee
módulo
Comprueba
Lee
palabra
módulo
Escribe
palabra
memoria
Completado
Condición
error
Envía
mandato
lectura
bloque
módulo
Figura
1.19
técnicas
leer
bloque
datos
01-Capitulo
16/5/05
17:03
Página
35E
DIRIGIDA
INTERRUPCIONES
problema
programada
procesador
esperar
tiempo
módulo
correspondiente
esté
listo
recepción
transmisión
datos
procesa-
dor
esperando
comprobar
repetidamente
módulo
S.
re-
sultado
nivel
rendimiento
sistema
degrada
gravemente
alternativa
procesador
genere
mandato
módulo
acto
segui-
do
continúe
realizando
trabajo
útil
módulo
interrumpirá
proce-
sador
solicitar
servicio
esté
listo
intercambiar
datos
proce-
sador
ejecutará
transferencia
datos
reanudará
procesamiento
previo
Considere
funciona
alternativa
punto
vista
módulo
S.
operación
entrada
módulo
recibe
mandato
LECTURA
procesador
módulo
pasa
leer
datos
periférico
asociado
datos
registro
datos
módulo
módulo
genera
interrupción
procesador
línea
control
módulo
espera
procesador
pida
datos
petición
módulo
sitúa
datos
bus
datos
listo
operación
S.
punto
vista
procesador
acciones
correspondientes
operación
lec-
tura
describen
continuación
procesador
genera
mandato
LECTURA
Salva
contexto
ejemplo
contador
programa
registros
procesador
pro-
grama
actual
abandona
pasando
cosa
ejemplo
procesador
trabajando
programas
ciclo
instrucción
pro-
cesador
comprueba
interrupciones
Figura
1.7
produce
interrupción
mó-
dulo
procesador
salva
contexto
programa
ejecutando
actualmente
comienza
ejecutar
programa
manejo
interrupción
procesa
interrupción
caso
procesador
lee
palabra
datos
módulo
almacena
memoria
conti-
nuación
restaura
contexto
programa
mandato
programa
reanuda
ejecución
Figura
1.19b
muestra
dirigida
interrupciones
leer
bloque
datos
dirigida
interrupciones
eficiente
programada
elimina
espera
innecesaria
dirigida
interrupciones
consume
tiempo
pro-
cesador
puesto
palabra
datos
memoria
módulo
mó-
dulo
memoria
pasar
procesador
invariablemente
múltiples
módulos
computador
necesitan
mecanismos
permitir
procesador
determine
dispositivo
causó
interrupción
decidir
caso
múltiples
interrupciones
manejar
sistemas
múltiples
líneas
interrupción
módulo
línea
lí-
nea
prioridad
Alternativamente
única
línea
interrupción
utilizan
líneas
adicionales
guardar
dirección
dispositivo
asignan
prioridades
distintos
dispositivos
ACCESO
DIRECTO
MEMORIA
dirigida
interrupciones
eficiente
programada
simple
re-
intervención
activa
procesador
transferir
datos
memoria
módulo
transferencia
datos
atravesar
camino
procesador
ambas
formas
sufren
inconvenientes
inherentes
36
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
361
tasa
transferencia
limitada
velocidad
procesador
comprobar
dispositivo
ofrecerle
servicio
procesador
involucrado
gestión
transferencia
ejecutar
instrucciones
transferencia
S.
transferir
volúmenes
datos
requiere
técnica
eficiente
acceso
directo
memoria
Direct
Memory
Access
DMA
función
DMA
llevarla
cabo
módulo
separado
conectado
bus
sistema
incluida
módulo
S.
caso
técnica
funciona
describe
continuación
procesador
desea
leer
escribir
bloque
datos
genera
mandato
módulo
DMA
enviándole
información
lectura
escritura
dirección
dispositivo
involucrado
posición
inicial
memoria
desea
leer
datos
quieren
escribir
número
palabras
pretende
leer
escribir
continuación
procesador
continúa
trabajo
delegado
operación
módulo
DMA
ocupará
módulo
DMA
transferirá
bloque
com-
pleto
datos
palabra
palabra
memoria
pasar
procesador
procesador
involucrado
principio
transferencia
Fi-
gura
1.19c
módulo
DMA
necesita
tomar
control
bus
transferir
datos
memoria
competencia
bus
procesa-
dor
necesita
bus
esperar
módulo
DMA
Nótese
interrupción
procesador
salva
contexto
pasa
cosa
lugar
procesador
detiene
du-
rante
ciclo
bus
tiempo
tarda
transferir
palabra
bus
efecto
global
causar
procesador
ejecute
lentamente
transferencia
DMA
caso
procesador
requiera
acceso
bus
transferencia
múltiples
palabras
DMA
eficiente
dirigida
interrupciones
programada
1.8
LECTURAS
SITIOS
WEB
RECOMENDADOS
STAL03
cubre
detalle
temas
capítulo
libros
arqui-
tectura
organización
computadores
textos
notables
siguientes
PATT98
estudio
general
HENN02
autores
libro
avanzado
enfatiza
so-
bre
aspectos
cuantitativos
diseño
HENN02
Hennessy
J.
Patterson
D.
Computer
Architecture
Quantitative
Approach
San
Mateo
CA
Morgan
Kaufmann
2002
PATT98
Patterson
D.
Hennessy
J.
Computer
Organization
and
Design
The
Hardware
Software
In-
terface
San
Mateo
CA
Morgan
Kaufmann
1998
STAL03
Stallings
W.
Computer
Organization
and
Architecture
6th
ed
Upper
Saddle
River
NJ
Pren-
tice
Hall
2003
Introducción
computadores
37
01-Capitulo
16/5/05
17:03
Página
37SITIOS
WEB
RECOMENDADOS
WWW
Computer
Architecture
Home
Page
índice
amplio
información
relevante
investigadores
arquitectura
computadores
incluyendo
grupos
proyectos
arquitectura
organizaciones
técnicas
bibliografía
empleo
información
comercial
CPU
Info
Center
Información
procesadores
específicos
incluyendo
artículos
técni-
cos
información
productos
anuncios
1.9
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
acceso
directo
memoria
DMA
marco
pila
proximidad
temporal
bus
sistema
memoria
cache
puntero
pila
ciclo
instrucción
memoria
principal
puntero
segmento
código
condición
memoria
secundaria
registro
contador
programa
módulo
registro
datos
dirigida
interrupciones
multiprogramación
registro
dirección
programada
pila
registro
índice
entrada
salida
procedimiento
reentrante
registro
instrucción
hueco
cache
procesador
tasa
aciertos
Instrucción
proximidad
unidad
central
proceso
CPU
Interrupción
proximidad
espacial
CUESTIONES
REPASO
1.1
Enumere
defina
brevemente
elementos
principales
computador
1.2
Defina
categorías
principales
registros
procesador
1.3
términos
generales
acciones
distintas
especificar
instrucción
máquina
1.4
interrupción
1.5
tratan
múltiples
interrupciones
1.6
características
distinguen
diversos
elementos
jerarquía
memoria
1.7
memoria
cache
1.8
Enumere
defina
brevemente
técnicas
operaciones
S.
1.9
diferencia
proximidad
espacial
temporal
1.10
general
estrategias
aprovechar
proximidad
espacial
temporal
38
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
38PROBLEMAS
1.1
Suponga
máquina
hipotética
Figura
1.3
instrucciones
0011
Carga
AC
valor
leído
dispositivo
0111
Almacena
AC
dispositivo
casos
dirección
12
bits
identifica
determinado
dispositivo
externo
Mues-
tre
ejecución
programa
utilizando
formato
Figura
1.4
correspondiente
si-
guiente
fragmento
Carga
AC
valor
leído
dispositivo
Suma
AC
contenido
posición
memoria
940
Almacena
AC
dispositivo
Asuma
valor
leído
dispositivo
posición
940
contiene
valor
1.2
ejecución
programa
Figura
1.4
describe
texto
utilizando
pasos
Extienda
descripción
mostrar
RDIM
RDAM
1.3
Considere
hipotético
microprocesador
32
bits
instrucciones
32
bits
com-
puestas
campos
byte
contiene
código
operación
resto
ope-
rando
inmediato
dirección
operando
máxima
capacidad
memoria
directamente
direccionable
bytes
Estudie
impacto
velocidad
sistema
dependiendo
bus
microproce-
sador
bus
direcciones
local
32
bits
bus
datos
local
16
bits
bus
direcciones
local
16
bits
bus
datos
local
16
bits
bits
necesitan
contador
programa
registro
instruc-
ciones
1.4
Considere
microprocesador
hipotético
genera
dirección
16
bits
ejemplo
asuma
contador
programa
registros
dirección
ancho
16
bits
bus
datos
16
bits
máximo
espacio
direcciones
memoria
procesador
ac-
ceder
directamente
conecta
memoria
16
bits
máximo
espacio
direcciones
memoria
procesador
ac-
ceder
directamente
conecta
memoria
bits
características
arquitectónicas
permitirán
microprocesador
acceder
espacio
separado
instrucción
entrada
salida
especificar
número
puerto
bits
puertos
bits
manejar
microprocesador
16
bits
Razone
respuesta
1.5
Considere
microprocesador
32
bits
bus
datos
externo
16
bits
alimenta-
do
reloj
entrada
MHz
Asuma
microprocesador
ciclo
bus
cuya
duración
mínima
ciclos
reloj
entrada
tasa
transferencia
datos
máxima
bus
microprocesador
mantener
medida
bytes
incrementar
rendimiento
bus
datos
exter-
32
bits
doblar
frecuencia
reloj
externo
suministrada
microprocesador
Introducción
computadores
39
01-Capitulo
16/5/05
17:03
Página
39Detalle
suposición
realice
razonando
Sugerencia
determi-
ne
número
bytes
transferir
ciclo
bus
1.6
Considere
computador
contiene
módulo
controla
sencillo
teletipo
impresora
teclado
CPU
contiene
siguientes
registros
conectados
directamente
bus
sistema
RENT
Registro
entrada
bits
RSAL
Registro
salida
bits
INE
Indicador
entrada
bit
INS
Indicador
salida
bit
HAI
Habilitación
interrupción
bit
módulo
controla
entrada
teclado
teletipo
salida
impresora
teletipo
capaz
codificar
símbolo
alfanumérico
palabras
bits
descodificar
palabra
bits
símbolo
alfanumérico
indicador
entrada
activa
introduce
palabra
bits
registro
entrada
teletipo
indicador
sali-
activa
imprime
palabra
Describa
CPU
utilizando
registros
enumerados
problema
teletipo
Describa
eficientemente
función
empleando
HAI
1.7
prácticamente
sistemas
incluyen
módulos
DMA
otorga
prio-
ridad
accesos
módulo
DMA
memoria
principal
accesos
pro-
cesador
1.8
módulo
DMA
transfiriendo
caracteres
memoria
principal
disposi-
tivo
externo
transmitiendo
9600
bits
bps
procesador
leer
instruc-
ciones
velocidad
millón
instrucciones
ralentizará
procesador
actividad
DMA
1.9
computador
consta
CPU
dispositivo
conectado
memoria
principal
bus
compartido
anchura
bus
datos
pa-
labra
CPU
ejecutar
máximo
10
instrucciones
ins-
trucción
media
requiere
ciclos
máquina
utilizan
bus
memoria
operación
lectura
escritura
memoria
utiliza
ciclo
máqui-
na
Supóngase
CPU
ejecutando
constantemente
programas
pla-
background
requieren
95%
tasa
ejecución
instrucciones
instrucción
S.
Asuma
ciclo
procesador
ciclo
bus
suponga
transferir
bloques
datos
D.
utiliza
programada
transferencia
palabra
requiere
CPU
ejecute
instrucciones
estime
tasa
máxima
transferencia
datos
palabras
D.
Estime
tasa
utiliza
transferencia
DMA
1.10
Considere
código
for
20
i++
for
10
j++
a[i
a[i
40
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
40a
Proporcione
ejemplo
proximidad
espacial
código
Proporcione
ejemplo
proximidad
temporal
código
1.11
Generalice
ecuaciones
1.1
1.2
Apéndice
1A
jerarquías
memoria
niveles
1.12
Considere
sistema
memoria
siguientes
parámetros
Tc
100
ns
Cc
0,01
céntimos
bit
Tm
1.200
ns
Cm
0,001
céntimos
bit
coste
1MByte
memoria
principal
coste
1Mbyte
memoria
principal
utilizando
tecnología
memoria
cache
tiempo
acceso
efectivo
10%
tiempo
acceso
cache
tasa
aciertos
1.13
computador
cache
memoria
principal
disco
usado
memoria
virtual
palabra
accedida
cache
requieren
20
ns
accederla
memoria
principal
cache
necesitan
60
ns
cargarla
cache
incluye
tiempo
comprobar
inicialmente
cache
continuación
re-
ferencia
comienza
palabra
memoria
principal
requieren
12
ms
buscar
palabra
disco
seguido
60
ns
copiarla
cache
ini-
cia
nuevamente
referencia
tasa
aciertos
cache
0,9
memoria
prin-
cipal
0,6
tiempo
ns
requerido
acceder
palabra
sistema
1.4
Suponga
procesador
utiliza
pila
gestionar
llamadas
procedimiento
retornos
eliminarse
contador
programa
utilizando
cima
pila
contador
programa
APÉNDICE
1A
CARACTERÍSTICAS
RENDIMIENTO
MEMORIAS
NIVELES
capítulo
referencia
cache
actúa
buffer
memoria
principal
procesador
creando
memoria
interna
niveles
arquitectura
niveles
propor-
ciona
rendimiento
mejorado
memoria
nivel
equiparable
explotando
propiedad
conocida
proximidad
analizará
apéndice
abla
1.2.Características
memorias
niveles
Cache
memoria
Memoria
virtual
Cache
discoprincipal
Paginación
Proporción
típica
5:1
106:1
106:1
tiempos
acceso
Sistema
gestión
Implementado
Combinación
Software
sistema
memoria
hardware
especial
hardware
software
sistema
Tamaño
típico
bloque
128
bytes
64
4096
bytes
64
4096
bytes
Acceso
procesador
Acceso
directo
Acceso
indirecto
Acceso
indirecto
nivel
Introducción
computadores
41
01-Capitulo
16/5/05
17:03
Página
41El
mecanismo
cache
memoria
principal
arquitectura
computador
imple-
mentado
hardware
habitualmente
invisible
sistema
operativo
libro
tra-
ta
mecanismo
instancias
técnica
memoria
niveles
explotan
propiedad
proximidad
parcialmente
implementadas
sistema
operativo
memoria
virtual
cache
disco
Tabla
1.2
temas
analizarán
Capítulos
11
respectivamente
apéndice
revisarán
características
rendimiento
memoria
niveles
comunes
técnicas
PROXIMIDAD
base
ganancia
rendimiento
memoria
niveles
reside
principio
pro-
ximidad
comentado
Sección
1.5
principio
establece
referencias
memoria
tien-
den
agruparse
periodo
tiempo
grupos
usando
cambiando
periodo
corto
procesador
primordialmente
trabajando
grupos
fijos
referen-
cias
memoria
experiencia
real
muestra
principio
proximidad
válido
comprobarlo
consi-
dere
línea
razonamiento
interrupciones
salto
llamada
constituyen
pequeña
instrucciones
programa
ejecución
programa
secuencial
mayoría
casos
próxima
instrucción
leer
inmediatamente
instrucción
leída
frecuente
produzca
larga
secuencia
ininterrumpida
llamadas
procedi-
miento
seguida
correspondiente
secuencia
retornos
habitual
programa
permanezca
confinado
ventana
anidamiento
invocación
procedimientos
bas-
tante
estrecha
periodo
corto
tiempo
referencias
instrucciones
tienden
localizarse
procedimientos
mayoría
construcciones
iterativas
consta
número
relativamente
pequeño
instrucciones
repetidas
ejecuta
iteración
cálculo
queda
con-
finado
pequeña
contigua
programa
programas
cálculo
implica
procesar
estructuras
datos
tales
vectores
secuencias
registros
casos
sucesivas
referencias
estructu-
ras
datos
corresponderán
elementos
datos
situados
próximamente
línea
razonamiento
confirmado
estudios
punto
estudios
analizado
comportamiento
programas
escritos
lenguajes
alto
nivel
Tabla
1.3
incluye
resultados
fundamentales
midiendo
aparición
tipos
sentencias
ejecución
extraídos
estudios
detallan
continuación
antiguo
estudio
comportamiento
lenguaje
programación
Knuth
KNUT71
examinaba
colección
programas
FORTRAN
usados
ejercicios
estudiantes
Tanenbaum
TANE78
publicó
medidas
recogidas
300
procedimientos
utilizados
programas
siste-
ma
operativo
escritos
lenguaje
soporte
programación
estructurada
SAL
Patter-
Sequin
PATT82
analizaron
conjunto
medidas
obtenidas
compiladores
programas
composición
documentos
diseño
asistido
computador
Computer-Aided
Design
CAD
ordenamiento
comparación
ficheros
estudiaron
lenguajes
programación
Pas-
cal
Huck
HUCK83
analizó
programas
seleccionados
representar
mezcla
cálcu-
científicos
propósito
general
incluyendo
transformada
rápida
Fourier
integración
sistemas
ecuaciones
diferenciales
coincidencia
general
resultados
mezcla
42
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
42de
lenguajes
aplicaciones
refiere
instrucciones
salto
llamada
represen-
fracción
sentencias
ejecutadas
vida
programa
es-
tudios
confirman
afirmación
lista
precedente
abla
1.3
Frecuencia
dinámica
relativa
operaciones
lenguajes
alto
nivel
Estudio
HUCK83
KNUT71
PATT82
TANE78
Lenguaje
Pascal
FORTRAN
Pascal
SAL
Tipo
carga
Científica
Estudiantes
Sistema
Sistema
Sistema
Asignación
74
67
45
38
42
Bucle
43534
Llamada
15
12
12
IF
20
29
43
36
GOTO
9—3
7616
afirmación
estudios
presentados
PATT85
proporcionan
confirmación
ilustra
Figura
1.20
muestra
comportamiento
llamadas
retor-
llamada
representa
línea
descendente
desplaza
derecha
retorno
línea
ascendente
desplazándose
derecha
figura
define
ventana
profundidad
secuencia
llamadas
retornos
movimiento
neto
dirección
causa
ventana
mueva
observarse
programa
ejecu-
ción
permanecer
ventana
estacionaria
largos
periodos
tiempo
es-
tudio
autores
programas
Pascal
mostró
ventana
profundidad
necesitaría
desplazarse
1%
llamadas
retornos
TAMI83
principio
proximidad
referencias
continúa
validado
estudios
recientes
ejemplo
Figura
1.21
muestra
resultado
estudio
patrones
acceso
páginas
web
determinado
sitio
Introducción
computadores
43
/H11005
/H11005
33
Tiempo
números
llamadas
retornos
Nivel
anidamiento
Retorno
Llamada
Figura
1.20
Ejemplo
comportamiento
llamadas
retornos
programa
01-Capitulo
16/5/05
17:03
Página
43La
bibliografía
tema
distinción
proximidad
espacial
temporal
proximidad
espacial
refiere
tendencia
ejecución
involucrar
posiciones
memoria
agrupadas
refleja
tendencia
procesador
acceder
secuencialmente
ins-
trucciones
proximidad
espacial
refleja
tendencia
programa
acceder
forma
secuencial
posiciones
datos
procesa
tabla
datos
proximidad
temporal
referencia
tendencia
procesador
acceder
posiciones
memoria
utilizado
recientemente
ejemplo
ejecuta
bucle
procesador
ejecuta
juego
instrucciones
repetidamente
Tradicionalmente
proximidad
temporal
explota
manteniendo
memoria
cache
valo-
res
instrucciones
datos
usados
recientemente
aprovechando
jerarquía
cache
proximidad
espacial
explota
generalmente
utilizando
bloques
cache
incorporan-
do
mecanismos
lectura
anticipada
buscan
elementos
cuyo
prevé
lógica
control
cache
Recientemente
habido
investigaciones
considerables
mejora
técnicas
objeto
alcanzar
rendimiento
estrategias
básicas
siguen
OPERACIÓN
MEMORIA
NIVELES
propiedad
proximidad
explotar
creación
memoria
niveles
memoria
nivel
superior
M1
pequeña
rápida
cara
bit
memoria
nivel
inferior
M2
M1
utiliza
almacenamiento
temporal
contenido
M2
realiza
referencia
memoria
intento
acceder
elemento
M1
éxito
cabo
acceso
rápido
caso
contrario
copia
blo-
posiciones
memoria
M2
M1
continuación
acceso
lugar
M1
Gracias
proximidad
trae
bloque
M1
debería
accesos
posiciones
bloque
dando
resultado
servicio
global
rápido
expresar
tiempo
acceso
elemento
deberá
considerar
veloci-
dades
niveles
memoria
probabilidad
referencia
dada
encontrarse
M1
T1
T1
T2
T1
T2
1.1
44
Sistemas
operativos
Aspectos
internos
principios
diseño
500
1000
1500
2000
2500
3000
50
100
150
200
Número
acumulativo
documentos
250
300
350
400
Número
refrencias
Figura
1.21
Proximidad
referencias
páginas
web
BAEN97
01-Capitulo
16/5/05
17:03
Página
44donde
TS
tiempo
acceso
sistema
T1
tiempo
acceso
M1
ejemplo
cache
cache
disco
T2
tiempo
acceso
M2
ejemplo
memoria
principal
disco
tasa
aciertos
tasa
referencias
encontradas
M1
Figura
1.15
muestra
tiempo
acceso
función
tasa
aciertos
observarse
porcentaje
alto
aciertos
tiempo
acceso
cerca
M1
M2
RENDIMIENTO
continuación
examinan
parámetros
relevantes
valoración
mecanis-
mo
memoria
niveles
lugar
coste
C1D1
C2D2
CS
1.2
D1
D2
CS
coste
bit
memoria
combinada
niveles
C1
coste
bit
memoria
M1
nivel
superior
C2
coste
bit
memoria
M2
nivel
inferior
D1
tamaño
M1
D2
tamaño
M2
deseable
C2
C1
C2
requiere
M1
M2
Figura
1.22
mues-
tra
relación
Seguidamente
considere
tiempo
acceso
memoria
niveles
proporcione
mejora
significativa
rendimiento
necesita
TS
T1
T1
menor
T2
T1
T2
necesita
tasa
aciertos
próxima
consiguiente
pretende
M1
pequeña
mantener
coste
me-
jorar
tasa
acierto
rendimiento
tamaño
M1
satisface
requi-
sitos
punto
razonable
responder
cuestión
serie
preguntas
adicionales
valor
tasa
aciertos
necesita
satisfacer
requisito
rendimiento
planteado
tamaño
M1
asegurará
tasa
aciertos
requerida
Satisface
tamaño
requisito
coste
Introducción
computadores
45
Nótese
ejes
escala
logarítmica
revisión
básica
escalas
logarítmicas
docu-
mento
repaso
matemáticas
Computer
Science
Student
Support
Site
WilliamStallings.com/StudentSupport.html
01-Capitulo
16/5/05
17:03
Página
45Para
responder
preguntas
considere
cantidad
T1
TS
conoce
eficiencia
acceso
medida
refleja
punto
tiempo
acceso
TS
cerca
tiem-
po
acceso
M1
T1
ecuación
1.1
T1
1.3
TS
T2
T1
Figura
1.23
dibuja
T1
TS
función
tasa
aciertos
cantidad
T2
T1
parámetro
necesitarse
tasa
aciertos
intervalo
0,8
0,9
satisfacer
requisito
rendimiento
momento
expresar
exactamente
pregunta
tamaño
relativo
memoria
razonable
tasa
aciertos
0,8
D1
D2
dependerá
factores
incluyendo
características
software
ejecutando
detalles
di-
seño
memoria
niveles
determinante
principal
evidentemente
grado
proximi-
dad
Figura
1.24
sugiere
efecto
proximidad
tasa
aciertos
Claramente
M1
tamaño
M2
tasa
aciertos
1,0
elementos
M2
es-
tarán
almacenados
M1
continuación
supóngase
proximidad
referencias
completamente
aleatorias
caso
tasa
aciertos
función
estricta-
mente
lineal
tamaño
relativo
memoria
ejemplo
M1
mitad
tamaño
M2
momento
mitad
elementos
M2
M1
tasa
aciertos
0,5
práctica
grado
proximidad
referencias
figura
indican
efectos
proximidad
moderada
acusada
46
Sistemas
operativos
Aspectos
internos
principios
diseño
Tamaño
relativo
niveles
D1
Coste
combinado
relativo
CS
C2
C1
C2
1000
C1
C2
10
C1
C2
100
678
1000
23
100023
100956
109
678
100
678
10
Figura
1.22
Relación
coste
memoria
relación
tamaño
relativo
memoria
niveles
01-Capitulo
16/5/05
17:03
Página
46Introducción
computadores
47
Tasa
aciertos
/H11549
/H11005
/H11005
10
/H11005
100
/H11005
1000
0.0
0.2
0.4
0.6
0.8
1.0
0.1
0.01
0.001
Eficiencia
acceso
/H11549
T1
Ts
Figura
1.23
Eficiencia
acceso
función
tasa
aciertos
T2
T1
proximidad
Proximidad
moderada
Proximidad
acusada
Tasa
aciertos
Tamaño
relativo
memorias
D2
0.0
0.0
0.2
0.4
0.6
0.8
1.0
0.2
0.4
0.6
0.8
1.0
Figura
1.24
Tasa
aciertos
función
tamaño
memoria
01-Capitulo
16/5/05
17:03
Página
47En
consecuencia
proximidad
acusada
lograr
valores
elevados
tasa
aciertos
tamaño
memoria
nivel
superior
relativamente
pequeño
ejemplo
numerosos
estudios
muestran
tamaños
cache
pequeños
producirán
tasa
acier-
tos
0,75
independencia
tamaño
memoria
principal
ejemplo
AGAR98
PRZY88
STRE83
SMIT82
cache
tamaño
intervalo
128
palabras
generalmente
adecuada
actualmente
memoria
principal
presenta
normalmente
intervalo
extiende
cientos
megabytes
gigabyte
memoria
virtual
cache
disco
citar
estudios
confir-
man
fenómeno
memoria
M1
relativamente
pequeña
produce
valor
ele-
vado
tasa
aciertos
gracias
proximidad
conduce
pregunta
listada
anteriormente
satisface
tamaño
relativo
memorias
requisito
coste
respuesta
claramente
necesita
memoria
ni-
vel
superior
relativamente
pequeña
alcanzar
rendimiento
coste
bit
niveles
memoria
aproximará
memoria
nivel
inferior
APÉNDICE
1B
CONTROL
PROCEDIMIENTOS
técnica
habitual
controlar
ejecución
llamadas
procedimiento
retornos
utilizar
pila
apéndice
resume
propiedades
básicas
pilas
revisa
control
procedimientos
IMPLEMENTACIÓN
PILA
pila
conjunto
ordenado
elementos
momento
acce-
der
recientemente
añadido
punto
acceso
denomina
cima
pila
número
elementos
pila
longitud
pila
variable
razón
conoce
pila
lista
apilamiento
lista
entra
sale
Last-
In
First-Out
LIFO
implementación
pila
requiere
conjunto
posiciones
dedicado
almace-
nar
elementos
pila
Figura
1.25
muestra
técnica
habitual
reserva
memoria
principal
memoria
virtual
bloque
contiguo
posiciones
mayoría
bloque
parcialmente
lleno
elementos
pila
resto
disponible
crecimiento
pila
necesitan
direcciones
funcionamiento
adecuado
habitualmente
almacenan
registros
procesador
Puntero
pila
Contiene
dirección
cima
pila
añade
elemento
APILA
elimina
EXTRAE
puntero
decrementa
incrementa
contener
dirección
cima
pila
Base
pila
Contiene
dirección
posición
inferior
bloque
reservado
posición
utiliza
añade
elemento
pila
vacía
intento
extraer
elemento
pila
vacía
informa
error
Límite
pila
Contiene
dirección
extremo
cima
bloque
reservado
intento
apilar
elemento
pila
llena
indica
error
Tradicionalmente
mayoría
máquinas
actuales
base
pila
extremo
dirección
alta
bloque
pila
reservado
límite
extremo
dirección
baja
pila
crece
direcciones
altas
bajas
48
Sistemas
operativos
Aspectos
internos
principios
diseño
01-Capitulo
16/5/05
17:03
Página
48LLAMADAS
RETORNOS
PROCEDIMIENTOS
técnica
habitual
gestionar
llamadas
retornos
procedimientos
utilizar
pila
procesador
ejecuta
llamada
almacena
apila
dirección
retorno
pila
ejecuta
retorno
utiliza
dirección
cima
pila
elimina
extrae
di-
rección
pila
Figura
1.27
muestra
pila
procedimientos
anidados
presenta-
Figura
1.26
necesario
frecuencia
pasar
parámetros
llamada
procedimiento
pasar
registros
posibilidad
almacenar
parámetros
memoria
justo
des-
pués
instrucciones
llamada
caso
retorno
posición
parámetros
Ambas
técnicas
inconvenientes
utilizan
registros
programa
llama-
do
realiza
llamada
escribirse
asegure
registros
utilizan
apropiadamente
almacenamiento
parámetros
memoria
difícil
intercambiar
número
variable
parámetros
estrategia
flexible
paso
parámetros
pila
procesador
ejecuta
llamada
apila
dirección
retorno
parámetros
desean
pasar
procedimiento
llamado
procedimiento
invocado
acceder
parámetros
pila
re-
tornar
parámetros
retorno
almacenar
pila
dirección
retorno
conjunto
completo
parámetros
incluyendo
dirección
retorno
almacena
invocación
procedimiento
denomina
marco
pila
Figura
1.28
muestra
ejemplo
ejemplo
refiere
procedimiento
declaran
variables
locales
x1
x2
procedimiento
llamar
de-
claran
variables
y1
y2
elemento
almacenado
marco
pila
puntero
principio
marco
previo
técnica
necesita
número
longitud
parámetros
Introducción
computadores
49
Memoria
principal
Libre
pila
memoria
elementos
superiores
registros
Elemento
superior
pila
elemento
pila
Registros
CPU
Límite
pila
Puntero
pila
Base
pila
Bloque
reservado
pila
Memoria
principal
Libre
Registros
CPU
Límite
pila
Puntero
pila
Base
pila
Bloque
reservado
pila
Figura
1.25
Organización
habitual
pila
01-Capitulo
16/5/05
17:03
Página
49se
apilar
variable
continuación
almacena
punto
retorno
procedimiento
co-
rresponde
marco
pila
Finalmente
reserva
espacio
cima
marco
pila
variables
locales
variables
locales
utilizar
paso
parámetros
ejemplo
supóngase
llama
pasa
valor
parámetro
valor
almacenar
variable
y1
lenguaje
alto
nivel
habría
instrucción
rutina
similar
LLAMADA
Q(y1
ejecuta
llamada
crea
marco
pila
Figura
1.28b
inclu-
ye
puntero
marco
pila
dirección
retorno
variables
locales
50
Sistemas
operativos
Aspectos
internos
principios
diseño
LLAMADA
Proc1
Memoria
principal
Programa
principal
Procedimiento
Proc1
Direcciones
4000
4100
4101
4500
4800
4600
4601
4650
4651
RETORNO
Llamadas
retornos
Secuencia
ejecución
Procedimiento
Proc2
LLAMADA
Proc2
LLAMADA
Proc2
RETORNO
Figura
1.26
Procedimientos
anidados
Contenido
inicial
pila
4101
LLAMADA
Proc1
4101
4601
LLAMADA
inicial
Proc2
4101
RETORNO
4101
4651
LLAMADA
Proc2
4101
RETORNO
RETORNO
Figura
1.27
pila
implementar
procedimientos
anidados
Figura
1.26
01-Capitulo
16/5/05
17:03
Página
50de
inicia
valor
parámetro
P.
variable
local
y2
sim-
plemente
variable
local
utilizada
cálculos
apartado
analiza
ne-
cesidad
incluir
variables
locales
marco
pila
PROCEDIMIENTOS
REENTRANTES
concepto
útil
particularmente
sistema
soporte
múltiples
usuarios
tiempo
procedimientos
reentrantes
procedimiento
reentrante
única
co-
pia
código
programa
compartir
múltiples
usuarios
periodo
tiempo
carácter
reentrante
procedimiento
aspectos
fundamentales
código
programa
modificarse
datos
locales
usuario
almacenarse
se-
paradamente
procedimiento
reentrante
interrumpido
invocado
programa
causó
interrupción
ejecutarse
correctamente
retornar
procedimiento
sistema
compartido
carácter
reentrante
permite
eficiente
memoria
principal
mantiene
copia
código
programa
memoria
principal
aplicación
llamar
procedimiento
procedimiento
reentrante
permanente
instrucciones
constituyen
procedimiento
temporal
puntero
retorno
programa
llamada
espacio
variables
locales
usadas
programa
instancia
ejecución
llamada
activación
procedimiento
ejecutará
código
permanente
copia
parámetros
variables
locales
temporal
asociada
activación
particular
denomina
registro
activación
conveniente
soporte
procedimientos
reentrantes
pila
llama
procedimiento
reentrante
registro
activación
procedimiento
almacenar
pila
registro
activación
convierte
marco
pila
crea
llamada
procedimiento
Introducción
computadores
51
Puntero
marco
previo
Dirección
retorno
Cima
puntero
pila
x1
x2
Puntero
marco
actual
activo
llamado
y2
y1
x2
x1
Puntero
marco
previo
Dirección
retorno
Puntero
marco
previo
Dirección
retorno
Puntero
marco
actual
Cima
puntero
pila
Figura
1.28
Crecimiento
marco
pila
utilizando
procedimientos
ejemplo
Q.
01-Capitulo
16/5/05
17:03
Página
5101-Capitulo
16/5/05
17:03
Página
52CAPÍTULO
Introducción
sistemas
operativos
2.1
Objetivos
funciones
sistemas
operativos
2.2
evolución
sistemas
operativos
2.3
Principales
logros
2.4
Desarrollos
llevado
sistemas
operativos
modernos
2.5
Descripción
global
Microsoft
Windows
2.6
Sistemas
UNIX
tradicionales
2.7
Sistemas
UNIX
modernos
2.8
Linux
2.9
Lecturas
sitios
web
recomendados
2.10
érminos
clave
cuestiones
repaso
problemas
02-Capitulo
12/5/05
16:18
Página
53N
Comenzamos
estudio
sistemas
operativos
historia
historia
inte-
resante
permite
ofrecer
visión
general
principios
sistemas
operativos
sección
examina
objetivos
funciones
sistemas
operativos
continuación
muestra
evolucionado
sistemas
operativos
primitivos
sistemas
lotes
sofisticados
sistemas
multitarea
multiusuario
resto
capítulo
describe
historia
características
generales
sistemas
operativos
utilizan
ejemplos
libro
material
capítulo
cubre
profundidad
resto
capítulos
2.1
OBJETIVOS
FUNCIONES
SISTEMAS
OPERATIVOS
sistema
operativo
programa
controla
ejecución
aplicaciones
programas
actúa
interfaz
aplicaciones
hardware
computador
consi-
derar
sistema
operativo
siguientes
objetivos
Facilidad
sistema
operativo
facilita
computador
Eficiencia
sistema
operativo
permite
recursos
sistema
computación
puedan
utilizar
eficiente
Capacidad
evolucionar
sistema
operativo
construir
forma
puedan
desarrollar
probar
introducir
funciones
sistema
interferir
servicio
examinar
orden
aspectos
sistema
operativo
SISTEMA
OPERATIVO
INTERFAZ
USUARIO
COMPUTADOR
hardware
software
utilizados
proporcionar
aplicaciones
usuarios
for-
ma
jerárquica
capas
muestra
Figura
2.1
usuario
dichas
aplicaciones
usuario
normalmente
preocupa
detalles
hardware
computador
usuario
ve
sistema
computación
términos
conjunto
aplicaciones
aplicación
expresar
lenguaje
programación
normalmente
desarrollada
programador
aplicaciones
programador
tuviera
desarrollar
aplicación
con-
instrucciones
código
máquina
encargaran
controlar
completamente
hardware
computador
enfrentaría
labor
extremadamente
compleja
facilitar
tarea
pro-
porcionan
conjunto
programas
sistema
programas
conocen
utili-
dades
programas
utilizan
frecuentemente
funciones
asisten
programador
fases
creación
programas
gestión
ficheros
control
dispositivos
S.
programador
hará
utilidades
desarrolle
aplicación
aplicaciones
invocarán
utilidades
ejecución
cabo
funciones
programa
sistema
importante
sistema
operativo
sistema
operativo
oculta
detalles
hardware
programador
pro-
porciona
interfaz
apropiada
utilizar
sistema
Actúa
mediador
fácil
programador
aplicación
acceso
dichas
utilidades
servicios
forma
resumida
sistema
operativo
proporciona
normalmente
servicios
siguientes
áreas
Desarrollo
programas
sistema
operativo
proporciona
variedad
utilidades
ser-
vicios
tales
editores
depuradores
asistir
programador
creación
54
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
54programas
Normalmente
servicios
ofrecen
forma
utilidades
forman
núcleo
sistema
operativo
ofrecen
sistema
conocen
herramientas
desarrollo
programas
aplicación
Ejecución
programas
necesita
serie
pasos
ejecutar
programa
instrucciones
datos
cargar
memoria
principal
dispositivos
ficheros
inicializar
recursos
prepararse
sistemas
operativos
re-
alizan
labores
planificación
nombre
usuario
Acceso
dispositivos
S.
dispositivo
requiere
conjunto
peculiar
instrucciones
señales
control
operación
sistema
operativo
proporciona
interfaz
uniforme
esconde
detalles
forma
programadores
puedan
acceder
dichos
dispositivos
utilizando
lecturas
escrituras
sencillas
Acceso
controlado
ficheros
acceso
ficheros
sistema
operativo
re-
flejar
comprensión
detallada
naturaleza
dispositivo
disco
cinta
estructura
datos
contenidos
ficheros
sistema
almacena-
miento
Adicionalmente
caso
sistema
múltiples
usuarios
sistema
operativo
proporcionar
mecanismos
protección
controlar
acceso
ficheros
Acceso
sistema
sistemas
compartidos
públicos
sistema
operativo
controla
ac-
ceso
sistema
completo
recursos
sistema
específicos
función
acceso
pro-
porcionar
protección
recursos
datos
evitando
autorizado
usuarios
resolviendo
conflictos
caso
conflicto
recursos
Detección
respuesta
errores
variedad
errores
ejecución
sistema
computación
incluyen
errores
hardware
internos
externos
tales
error
memoria
fallo
dispositivo
errores
software
tales
división
cero
intento
acceder
posición
memoria
prohibida
in-
capacidad
sistema
operativo
conceder
solicitud
aplicación
caso
Introducción
sistemas
operativos
55
Usuario
Programador
Diseñador
sistema
operativo
Programas
aplicación
Utilidades
Sistema
operativo
Hardware
computador
Figura
2.1
Capas
vistas
sistema
computación
02-Capitulo
12/5/05
16:18
Página
55sistema
operativo
proporcionar
respuesta
elimine
condición
error
supo-
niendo
menor
impacto
aplicaciones
ejecución
respuesta
osci-
lar
finalizar
programa
causó
error
reintentar
operación
simplemente
informar
error
aplicación
Contabilidad
sistema
operativo
recogerá
estadísticas
recur-
sos
monitorizará
parámetros
rendimiento
tales
tiempo
respuesta
sistema
información
útil
anticipar
necesidades
mejoras
futuras
opti-
mizar
sistema
mejorar
rendimiento
sistema
multiusuario
información
utilizar
facturar
usuarios
SISTEMA
OPERATIVO
GESTOR
RECURSOS
computador
conjunto
recursos
utilizan
transporte
almacenamiento
pro-
cesamiento
datos
cabo
control
funciones
sistema
operati-
vo
encarga
gestionar
recursos
sistema
operativo
controla
transporte
almacenamiento
pro-
cesamiento
datos
punto
vista
respuesta
afirmativa
gestionando
recursos
computador
sistema
operativo
control
funciones
básicas
control
realiza
forma
curiosa
Normalmente
mecanismo
control
externo
dispositivo
controlado
constituye
separada
dis-
tinta
dispositivo
ejemplo
sistema
calefacción
residencia
controla
tra-
vés
termostato
separado
aparatos
generación
distribución
calor
caso
sistema
operativo
mecanismo
control
inusual
aspectos
funciones
sistema
operativo
actúan
forma
resto
software
de-
cir
programa
conjunto
programas
ejecutados
procesador
sistema
operativo
frecuentemente
cede
control
depende
procesador
volver
retomarlo
sistema
operativo
conjunto
programas
programas
proporciona
instrucciones
procesador
principal
diferencia
radica
objetivo
programa
siste-
ma
operativo
dirige
procesador
recursos
sistema
temporización
ejecución
programas
obstante
procesador
sistema
operativo
dejar
paso
ejecución
programas
sistema
operativo
deja
control
procesador
trabajo
útil
retoma
control
permitir
procesador
realice
pieza
trabajo
mecanismos
utilizan
cabo
quedarán
claros
capítulo
Figura
2.2
muestra
principales
recursos
gestionados
sistema
operativo
porción
sistema
operativo
memoria
principal
incluye
kernel
núcleo
contiene
funciones
sistema
operativo
frecuentemente
utilizadas
momento
porciones
sistema
operativo
actualmente
resto
memoria
principal
contiene
programas
datos
usuario
asignación
recurso
memoria
principal
controlada
for-
ma
conjunta
sistema
operativo
hardware
gestión
memoria
procesador
verá
sistema
operativo
decide
programa
ejecución
utilizar
dispositivo
controla
acceso
ficheros
procesador
recurso
sistema
ope-
rativo
determinar
tiempo
procesador
asignarse
ejecución
programa
usuario
particular
caso
sistema
multiprocesador
decisión
tomada
procesadores
56
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
56FACILIDAD
EVOLUCIÓN
SISTEMA
OPERATIVO
sistema
operativo
importante
evolucionar
tiempo
siguientes
razones
Actualizaciones
hardware
tipos
hardware
ejemplo
primeras
versiones
sistemas
operativos
UNIX
IBM
OS/2
empleaban
mecanismo
pagi-
nado
ejecutaban
máquinas
hardware
paginación
paginación
presenta
brevemente
capítulo
discute
detalladamente
Capítulo
Ver-
siones
recientes
sistemas
operativos
cambiado
faceta
explotar
capacidades
paginación
terminales
gráficos
página
lugar
terminales
línea
afecta
diseño
sistemas
operativos
ejemplo
ter-
minal
gráfico
normalmente
permite
usuario
aplicaciones
tiempo
tra-
vés
ventanas
pantalla
requiere
gestión
sofisticada
sistema
operativo
servicios
respuesta
demanda
usuario
respuesta
necesidades
gestores
sistema
sistema
operativo
ofrecer
servicios
ejemplo
difícil
mantener
rendimiento
herramientas
existentes
añadir
sis-
tema
operativo
herramientas
medida
control
ejemplo
mayoría
aplicaciones
requieren
ventanas
pantalla
característica
requiere
ac-
tualizaciones
importantes
sistema
operativo
soporta
ventanas
Resolución
fallos
sistema
operativo
fallos
fallos
descubren
transcurso
tiempo
resuelven
implica
introducción
fallos
Introducción
sistemas
operativos
57
Memoria
Sistema
computación
Dispositivos
Sofware
sistema
operativo
Programas
datos
Procesador
Programas
Datos
Almacenamiento
Controlador
Impresoras
teclados
cámaras
digitales
etc.
Procesador
Controlador
Controlador
Figura
2.2
sistema
operativo
gestor
recursos
02-Capitulo
12/5/05
16:18
Página
57La
necesidad
cambiar
regularmente
sistema
operativo
introduce
requisitos
di-
seño
obvio
sistema
diseño
modular
interfaces
módu-
claramente
definidas
documentado
programas
tí-
pico
sistema
operativo
contemporáneo
cabo
modularización
sencilla
adecuado
DENN80a
detallará
tema
capítulo
2.2
EVOLUCIÓN
SISTEMAS
OPERATIVOS
comprender
requisitos
claves
sistema
operativo
significado
principales
ca-
racterísticas
sistema
operativo
contemporáneo
útil
considerar
evolución
sistemas
operativos
años
PROCESAMIENTO
SERIE
computadores
finales
años
40
mediados
años
50
pro-
gramador
interaccionaba
directamente
hardware
computador
existía
sistema
operativo
máquinas
utilizadas
consola
contenía
luces
interruptores
dispositivo
entrada
impresora
programas
código
máquina
cargaban
dispositivo
entrada
ejemplo
lector
tarjetas
error
provocaba
parada
progra-
ma
luces
indicaban
condición
error
programador
podía
examinar
registros
procesador
memoria
principal
determinar
causa
error
programa
terminaba
forma
normal
salida
aparecía
impresora
sistemas
iniciales
presentaban
problemas
principales
Planificación
mayoría
instalaciones
utilizaban
plantilla
impresa
reservar
tiempo
máquina
Típicamente
usuario
podía
solicitar
bloque
tiempo
múltiplos
media
hora
usuario
podía
obtener
hora
terminar
45
minu-
tos
implicaba
malgastar
tiempo
procesamiento
computador
usua-
rio
podía
problemas
finalizaba
tiempo
asignado
forzado
terminar
an-
tes
resolver
problema
Tiempo
configuración
único
programa
denominado
trabajo
podía
implicar
carga
memoria
compilador
programa
lenguaje
alto
nivel
programa
código
fuente
continuación
carga
enlace
programa
objeto
funciones
comunes
pasos
podían
suponer
montar
desmontar
cintas
configurar
tarjetas
ocurría
error
desgraciado
usuario
normalmente
volver
comienzo
se-
cuencia
configuración
utilizaba
cantidad
considerable
tiempo
confi-
gurar
programa
iba
ejecutar
operación
denominarse
procesamiento
serie
reflejar
usuarios
acceden
computador
serie
tiempo
desarrollado
herramien-
tas
software
sistemas
procesamiento
serie
eficiente
herra-
mientas
incluyen
bibliotecas
funciones
comunes
enlazadores
cargadores
depuradores
rutinas
gestión
disponibles
software
común
usuarios
SISTEMAS
LOTES
SENCILLOS
primeras
máquinas
caras
importante
maximizar
utilización
tiem-
po
malgastado
planificación
configuración
trabajos
inaceptable
58
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
58Para
mejorar
utilización
desarrolló
concepto
sistema
operativo
lotes
sistema
operativo
lotes
sistema
operativo
clase
desa-
rrollado
mediados
años
50
General
Motors
IBM
701
WEIZ81
con-
cepto
subsecuentemente
refinado
implementado
IBM
704
número
clientes
IBM
principios
años
60
número
vendedores
desarrollado
sistemas
operativos
lote
sistemas
computación
IBSYS
sistema
operativo
IBM
computado-
res
7090/7094
particularmente
notable
influencia
sistemas
idea
central
esquema
procesamiento
lotes
sencillo
pieza
soft-
ware
denomina
monitor
tipo
sistema
operativo
usuario
acceder
directa-
mente
máquina
lugar
usuario
envía
trabajo
tarjeta
cinta
operador
computador
crea
sistema
lotes
trabajos
enviados
coloca
secuencia
trabajos
dispositivo
entrada
utilice
monitor
programa
finaliza
procesamiento
devuelve
control
monitor
punto
monitor
comienza
carga
programa
comprender
funciona
esquema
analizar
puntos
vista
monitor
procesador
Punto
vista
monitor
monitor
controla
secuencia
eventos
monitor
memoria
principal
disponible
ejecución
Fi-
gura
2.3
porción
monitor
denomina
monitor
residente
resto
monitor
formado
conjunto
utilidades
funciones
comunes
cargan
subrutinas
programa
usuario
comienzo
trabajo
requiera
monitor
lee
trabajos
dispositivo
entrada
normalmente
lector
tarjetas
dispositivo
cinta
magnética
leído
dispositivo
trabajo
actual
coloca
área
programa
usuario
pasa
control
trabajo
completado
de-
vuelve
control
monitor
inmediatamente
lee
trabajo
resultados
trabajo
envían
dispositivo
salida
ejemplo
impresora
entregár-
selo
usuario
Introducción
sistemas
operativos
59
Procesamiento
interruptores
Manejadores
dispositivos
Secuenciamientos
trabajo
Intérprete
lenguaje
control
Área
programa
usuario
Monitor
Límite
Figura
2.3
Disposición
memoria
monitor
residente
02-Capitulo
12/5/05
16:18
Página
59•
Punto
vista
procesador
punto
procesador
ejecuta
instrucciones
zona
memoria
principal
contiene
monitor
instrucciones
provocan
lea
trabajo
almacene
zona
memoria
principal
trabajo
leído
procesador
encontrará
instrucción
salto
monitor
indica
pro-
cesador
continúe
ejecución
inicio
programa
usuario
procesador
ejecutará
instrucciones
programa
usuario
encuentre
condición
finali-
zación
error
Cualquiera
condiciones
procesador
ejecute
instrucción
programa
monitor
frase
pasa
control
trabajo
simple-
mente
significa
procesador
leerá
ejecutará
instrucciones
programa
usuario
frase
devuelve
control
monitor
indica
procesador
leerá
ejecutará
instruccio-
nes
programa
monitor
monitor
realiza
función
planificación
cola
sitúa
lote
trabajos
tra-
bajos
ejecutan
rápidamente
clase
tiempo
ocioso
medias
Ade-
monitor
mejora
tiempo
configuración
trabajos
trabajos
incluye
conjunto
instrucciones
formato
primitivo
lenguaje
control
trabajos
Job
Control
Language
JCL
tipo
especial
lenguaje
programación
utilizado
dotar
instrucciones
monitor
ejemplo
sencillo
consiste
usuario
enviando
programa
escrito
lenguaje
programación
FORTRAN
datos
utilizados
pro-
grama
código
FORTRAN
líneas
datos
trabajo
incluye
instrucciones
control
trabajo
representan
líneas
comienzan
símbolo
formato
general
trabajo
aspecto
60
Sistemas
operativos
Aspectos
internos
principios
diseño
JOB
FTN
LOAD
RU
END
Datos
Instrucciones
FORTRAN
ejecutar
trabajo
monitor
lee
línea
FTN
carga
compilador
apropiado
sis-
tema
almacenamiento
normalmente
cinta
compilador
traduce
programa
usuario
código
objeto
almacena
memoria
sistema
almacenamiento
almacena
memoria
operación
denomina
compilar
cargar
ejecutar
caso
almacene
cinta
necesita
utilizar
instrucción
LOAD
monitor
lee
instrucción
recupera
control
operación
compilación
monitor
invoca
cargador
carga
progra-
ma
objeto
memoria
lugar
compilador
transfiere
control
forma
compartir
segmento
memoria
principal
subsistemas
ejecutar
momento
determinado
ejecución
programa
usuario
instrucción
entrada
implica
lectura
línea
datos
instrucción
entrada
programa
usuario
supone
invocación
rutina
entrada
forma
sistema
operativo
rutina
entrada
comprueba
pro-
02-Capitulo
12/5/05
16:18
Página
60grama
lea
accidentalmente
línea
JCL
sucede
genera
error
transfiere
con-
trol
monitor
finalizar
trabajo
usuario
monitor
analizará
líneas
entrada
instrucción
JCL
forma
sistema
queda
protegido
frente
pro-
grama
excesivas
escasas
líneas
datos
monitor
sistema
operativo
lotes
simplemente
programa
confía
habilidad
procesador
cargar
instrucciones
porciones
memoria
principal
for-
ma
alternativa
permiten
tomar
abandonar
control
características
hardware
deseables
Protección
memoria
ejecución
programa
usuario
alterar
área
memoria
contiene
monitor
ocurriera
hardware
procesador
detectar
error
transferir
control
monitor
monitor
abortará
trabajo
im-
primirá
mensaje
error
cargará
trabajo
Temporizador
utiliza
temporizador
evitar
único
trabajo
monopolice
sis-
tema
activa
temporizador
comienzo
trabajo
temporizador
expira
programa
usuario
devuelve
control
monitor
Instrucciones
privilegiadas
instrucciones
nivel
máquina
denominan
privile-
giadas
ejecutar
monitor
procesador
instrucciones
ejecuta
programa
usuario
produce
error
provocando
control
transfiera
monitor
instrucciones
privilegiadas
encuentran
instrucciones
permiten
monitor
tome
control
dispositivos
S.
evita
ejemplo
programa
usuario
forma
accidental
lea
instrucciones
control
tra-
bajos
trabajo
programa
usuario
desea
operaciones
solicitar
monitor
realice
operaciones
Interrupciones
modelos
computadores
iniciales
tenían
capacidad
carac-
terística
proporciona
sistema
operativo
flexibilidad
dejar
retomar
control
des-
programas
usuario
consideraciones
protección
memoria
instrucciones
privilegiadas
llevan
concepto
modos
operación
programa
usuario
ejecuta
usuario
usuarios
acceder
áreas
memoria
ejecutar
instrucciones
monitor
ejecuta
sistema
denomina
núcleo
ejecutar
instrucciones
privilegiadas
acceder
áreas
memoria
protegidas
construir
sistema
operativo
características
fabrican-
tes
computadores
rápidamente
resultados
construyeron
sistemas
operativos
lotes
primitivos
características
hardware
sistema
operativo
lotes
tiempo
máquina
alterna
ejecución
programas
usuario
ejecución
monitor
implica
sacrificios
monitor
utiliza
memoria
principal
consume
tiempo
máquina
Ambas
situaciones
implican
sobrecarga
pe-
sar
sobrecarga
sistema
lotes
simple
mejora
utilización
computador
SISTEMAS
LOTES
MULTIPROGRAMADOS
procesador
frecuentemente
ocioso
secuenciamiento
trabajos
au-
tomático
proporciona
sistema
operativo
lotes
simple
problema
consiste
dispositivos
lentos
comparados
procesador
Figura
2.4
detalla
cálculo
re-
presentativo
corresponde
programa
procesa
fichero
registros
Introducción
sistemas
operativos
61
02-Capitulo
12/5/05
16:18
Página
61realiza
media
100
instrucciones
máquina
registro
ejemplo
computador
malgasta
96%
tiempo
esperando
dispositivos
terminen
trans-
ferir
datos
fichero
Figura
2.5a
muestra
situación
único
pro-
grama
denomina
monoprogramación
procesador
ejecuta
tiempo
alcanza
instrucción
S.
esperar
instrucción
concluya
an-
tes
continuar
Leer
registro
fichero
15
ms
Ejecutar
100
instrucciones
ms
Escribir
registro
fichero
15
ms
31
ms
Porcentaje
utilización
CPU
0,032
3,2%
31
Figura
2.4
Ejemplo
utilización
sistema
62
Sistemas
operativos
Aspectos
internos
principios
diseño
Ejecución
Tiempo
BB
AA
BB
CC
Monoprogramación
Tiempo
Multiprogramador
programas
Tiempo
Multiprogramador
programas
Programa
Espera
Combinado
Programa
Programa
Programa
Programa
Programa
Combinado
Ejecución
Ejecución
Ejecución
Ejecución
Ejecución
Ejecución
Ejecución
EjecuciónEjecuciónEjecución
Espera
Espera
Espera
Espera
Espera
EjecuciónEjecuciónEjecución
Espera
Espera
Ejecución
Ejecución
Ejecución
Espera
Espera
Ejecución
EjecuciónEspera
EsperaEspera
Espera
Ejecución
Espera
Espera
Espera
Ejecución
EjecuciónEspera
Espera
Figura
2.5
Ejemplo
multiprogramación
02-Capitulo
12/5/05
16:18
Página
62Introducción
sistemas
operativos
63
ineficiencia
evitarse
suficiente
memoria
contener
siste-
ma
operativo
monitor
residente
programa
usuario
Supóngase
espacio
sistema
operativo
programas
usuario
trabajo
necesita
esperar
asignar
procesador
trabajo
probablemente
esté
esperando
opera-
ción
Figura
2.5b
expandir
memoria
albergue
programas
multiplexación
Figura
2.5c
enfoque
conoce
multiprogramación
multitarea
tema
central
sistemas
operativos
modernos
mostrar
beneficios
multiprogramación
describe
ejemplo
sencillo
computador
250
Mbytes
memoria
disponible
utilizar
sistema
operativo
disco
terminal
impresora
envían
simultáneamente
ejecución
programas
TRABAJO1
TRABAJO2
TRABAJO3
características
listadas
Tabla
2.1
asumen
requisitos
mí-
nimos
procesador
trabajos
TRABAJO1
TRABAJO3
continuo
impreso-
ra
disco
trabajo
TRABAJO3
entorno
lotes
sencillo
trabajos
ejecu-
tarán
secuencia
trabajo
TRABAJO1
completará
minutos
trabajo
TRABAJO2
esperará
minutos
continuación
ejecutará
terminando
15
minutos
trabajo
TRABAJO3
esperará
20
minutos
completará
30
minutos
haberse
en-
viado
media
utilización
recursos
productividad
tiempos
respuestas
muestran
columna
monoprogramación
Tabla
2.2
utilización
dispositivo
ilustra
Fi-
gura
2.6a
evidente
infrautilización
recursos
compara
res-
pecto
periodo
30
minutos
requerido
abla
2.1
Atributos
ejecución
ejemplos
programas
TRABAJO
TRABAJO
TRABAJO
Tipo
trabajo
Computación
pesada
cantidad
cantidad
Duración
minutos
15
minutos
10
minutos
Memoria
requerida
50
100
75
Necesita
disco
Necesita
terminal
Necesita
impresora
abla
2.2
Efectos
utilización
recursos
multiprogramación
Monoprogramación
Multiprogramación
procesador
20%
40%
memoria
33%
67%
disco
33%
67%
impresora
33%
67%
Tiempo
transcurrido
30
minutos
15
minutos
Productividad
trabajos
hora
12
trabajos
hora
Tiempo
respuesta
18
minutos
10
minutos
02-Capitulo
12/5/05
16:18
Página
63Ahora
supóngase
trabajos
ejecutan
concurrentemente
sistema
operativo
multiprogramado
conflicto
trabajos
ejecutar
mínimo
tiempo
coexisten
computador
asumiendo
asigne
trabajos
TRABAJO2
TRABAJO3
suficiente
tiempo
procesador
mantener
ope-
raciones
entrada
salida
activas
trabajo
TRABAJO1
requerirá
minutos
completarse
tiempo
TRABAJO2
completado
tercio
trabajo
TRABAJO3
mitad
trabajos
habrán
finalizado
15
minutos
mejora
evidente
examinar
columna
multiprogramación
Tabla
2.2
obtenido
histograma
mostrado
Figura
2.6b
sistema
lotes
simple
sistema
lotes
multiprogramado
basarse
características
hardware
computador
característica
adicional
nota-
ble
útil
multiprogramación
hardware
soporta
interrupciones
DMA
Direct
Memory
Access
acceso
directo
memoria
gestionada
interrup-
ciones
DMA
procesador
solicitar
mandato
trabajo
continuar
ejecución
trabajo
controlador
dispositivo
gestiona
dicha
operación
S.
operación
finaliza
procesador
interrumpido
pasa
control
progra-
ma
tratamiento
interrupciones
sistema
operativo
sistema
operativo
pasará
control
trabajo
sistemas
operativos
multiprogramados
sofisticados
comparados
siste-
monoprogramados
trabajos
listos
ejecutar
guardarse
me-
moria
principal
requiriendo
forma
gestión
memoria
Adicionalmente
trabajos
listos
ejecución
procesador
decidir
ejecutar
decisión
requiere
algoritmo
planificación
conceptos
discuten
capítulo
SISTEMAS
TIEMPO
COMPARTIDO
multiprogramación
procesamiento
lotes
eficiente
em-
bargo
trabajos
deseable
proporcionar
usuario
interaccione
di-
rectamente
computador
trabajos
procesamiento
tran-
sacciones
interactivo
esencial
computadores
personales
dedicados
estaciones
trabajo
cumplir
fre-
cuentemente
requisitos
necesita
utilidad
computación
interactiva
op-
ción
disponible
años
60
mayoría
computadores
costosos
lugar
desarrolló
concepto
tiempo
compartido
multiprogramación
permite
procesador
gestionar
múltiples
trabajos
lotes
determinado
tiempo
multiprogramación
utilizar
gestionar
múlti-
ples
trabajos
interactivos
caso
técnica
denomina
tiempo
compartido
comparte
tiempo
procesador
múltiples
usuarios
sistema
tiempo
compartido
múltiples
usuarios
acceden
simultáneamente
sistema
terminales
sistema
ope-
rativo
encargado
entrelazar
ejecución
programa
usuario
pequeños
intervalos
tiempo
computación
usuarios
activos
solicitando
servicio
usuario
verá
media
capacidad
computación
efectiva
contar
sobrecarga
introducida
sistema
operativo
tiempo
reacción
relativamente
lento
humanos
tiempo
respuesta
sistema
diseñado
adecuadamente
debería
similar
computador
dedicado
tipos
procesamiento
lotes
tiempo
compartido
utilizan
multiprogramación
diferencias
importantes
listan
Tabla
2.3
64
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
64Introducción
sistemas
operativos
65
0%
10
15
20
25
30
Minutos
Monoprogramación
TRABAJO1
Historia
trabajo
Impresora
erminal
Disco
Memoria
CPU
100%
0%
100%
0%
100%
0%
100%
0%
100%
0%
10
15
Minutos
Multiprogramación
100%
0%
100%
0%
100%
0%
100%
0%
100%
Tiempo
Tiempo
Historia
trabajo
Impresora
erminal
Disco
Memoria
CPU
TRABAJO2
TRABAJO3
TRABAJO1
TRABAJO2
TRABAJO3
Figura
2.6
Histogramas
utilización
02-Capitulo
12/5/05
16:18
Página
65
abla
2.3
Multiprogramación
lotes
frente
tiempo
compartido
Multiprogramación
lotes
Tiempo
compartido
Objetivo
principal
Maximizar
procesador
Minimizar
tiempo
respuesta
Fuente
directivas
Mandatos
lenguaje
Mandatos
introducidos
sistema
operativo
control
trabajos
terminal
proporcionados
trabajo
sistemas
operativos
tiempo
compartido
desarrollados
sistema
CTSS
Compatible
Time-Sharing
System
CORB62
desarrollado
MIT
grupo
conocido
Proyecto
MAC
Machine-Aided
Cognition
Multiple-Access
Computers
sistema
ini-
cialmente
desarrollado
IBM
709
1961
transferido
IBM
7094
Comparado
sistemas
posteriores
CTSS
primitivo
sistema
ejecutó
máquina
memoria
principal
32.000
palabras
36
bits
monitor
residente
ocupando
5000
palabras
control
asignaba
usuario
interactivo
programa
usuario
datos
carga-
ban
restantes
27.000
palabras
memoria
principal
arrancar
programa
cargaba
comienzo
palabra
5000
simplificaba
monitor
gestión
memo-
ria
reloj
sistema
generaba
interrupción
0,2
segundos
in-
terrupción
reloj
sistema
operativo
retomaba
control
podía
asignar
procesador
usuario
intervalos
regulares
tiempo
usuario
actual
desalojado
usuario
puesto
ejecutar
preservar
programa
usuario
antiguo
programas
usuario
datos
escriben
disco
lean
programas
usuario
datos
Posteriormente
código
datos
programa
usuario
antiguo
restauran
memoria
principal
programa
vuelve
planificado
minimizar
tráfico
disco
memoria
usuario
escrita
disco
pro-
grama
entrante
sobreescribe
principio
queda
ilustrado
Figura
2.7
usuarios
interactivos
requisitos
memoria
TRABAJO1
15.000
TRABAJO2
20.000
TRABAJO3
5000
TRABAJO4
10.000
Inicialmente
monitor
carga
trabajo
TRABAJO1
transfiere
control
mo-
nitor
decide
transferir
control
trabajo
TRABAJO2
TRABAJO2
requiere
memoria
TRABAJO1
escribir
TRABAJO1
disco
continuación
cargarse
TRABAJO2
continuación
cargar
TRABAJO3
ejecutarse
em-
bargo
TRABAJO3
pequeño
TRABAJO2
porción
queda
memoria
reduciendo
tiempo
escritura
disco
Posteriormente
monitor
decide
transferir
control
TRABAJO1
porción
adicional
TRABAJO2
escribirse
disco
carga
TRABAJO1
memoria
carga
TRABAJO4
trabajo
TRABAJO1
porción
TRABAJO2
permanecen
memoria
pun-
to
cualquiera
trabajos
TRABAJO1
TRABAJO2
activados
requiere
carga
parcial
ejemplo
TRABAJO2
ejecuta
requiere
TRA-
BAJO4
porción
residente
TRABAJO1
escriban
disco
falta
TRABAJO2
lea
66
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
66La
técnica
utilizada
CTSS
primitiva
comparada
técnicas
tiempo
compartido
ac-
tuales
funcionaba
extremadamente
sencilla
minimizaba
tamaño
monitor
De-
bido
trabajo
cargaba
dirección
memoria
necesidad
utilizar
técnicas
reubicación
tiempo
carga
discutirán
escribir
disco
necesario
minimiza
actividad
disco
Ejecutando
7094
CTSS
permitía
número
máximo
32
usuarios
compartición
tiempo
multiprogramación
implican
problemas
sistema
operativo
múltiples
trabajos
memoria
protegerse
evitar
interfieran
ejemplo
modificación
datos
múltiples
usuarios
interactivos
sistema
ficheros
protegido
forma
usuarios
autorizados
tengan
acceso
fichero
particular
gestionarse
conflictos
recursos
impresoras
dispositivos
almacenamiento
masivo
problemas
posibles
solu-
ciones
describirán
libro
2.3
PRINCIPALES
LOGROS
sistemas
operativos
encuentran
piezas
software
complejas
jamás
desarrolla-
das
refleja
reto
intentar
resolver
dificultad
alcanzar
determinados
objetivos
conflictivos
conveniencia
eficiencia
capacidad
evolución
DENN80a
propone
principales
avances
teóricos
desarrollo
sistemas
operativos
Procesos
Gestión
memoria
Protección
seguridad
información
Planificación
gestión
recursos
Estructura
sistema
Introducción
sistemas
operativos
67
Monitor
TRABAJO
32000
5000
20000
20000
Monitor
32000
5000
25000
25000
Monitor
32000
5000
25000
Monitor
32000
5000
10000
Libre
25000
Monitor
32000
5000
20000
15000
25000
Monitor
32000
5000
LibreLibre
Libre
Libre
Libre
Libre
TRABAJO
TRABAJO
TRABAJO
TRABAJO
TRABAJO
TRABAJO
TRABAJO
TRABAJO
TRABAJO
Figura
2.7
Operación
CTSS
02-Capitulo
12/5/05
16:18
Página
67Cada
avance
caracteriza
principios
abstracciones
desarrollado
resolver
problemas
prácticos
Tomadas
forma
conjunta
áreas
incluyen
mayoría
aspec-
tos
clave
diseño
implementación
sistemas
operativos
modernos
revisión
áreas
sección
sirve
visión
global
resto
libro
PROCESOS
concepto
proceso
fundamental
estructura
sistemas
operativos
término
utilizado
diseñadores
sistema
Multics
años
60
DALE68
término
general
trabajo
definiciones
término
proceso
incluyendo
programa
ejecución
instancia
programa
ejecutándose
computador
entidad
asignar
ejecutar
procesador
unidad
actividad
caracterizada
hilo
secuencial
ejecución
ac-
tual
conjunto
recursos
sistema
asociados
concepto
aclarará
texto
líneas
principales
desarrollo
sistema
computación
crearon
problemas
tempori-
zación
sincronización
contribuyeron
desarrollo
concepto
proceso
operación
lotes
multiprogramados
tiempo
compartido
sistemas
transacciones
tiempo
real
visto
multiprogramación
diseñó
permitir
simultáneo
procesador
dispositi-
vos
incluyendo
dispositivos
almacenamiento
alcanzar
máxima
eficiencia
mecanismo
clave
respuesta
señales
indican
finalización
transacciones
procesador
planificado
programas
residen
memoria
principal
línea
desarrollo
tiempo
compartido
propósito
general
caso
objetivo
clave
diseño
responder
necesidades
usuario
razones
económicas
capaz
soportar
usuarios
simultáneamente
objetivos
compatibles
tiempo
reacción
relativamente
lento
usuario
ejemplo
usuario
típico
necesita
me-
segundos
tiempo
procesamiento
minuto
cantidad
30
usuarios
compartir
sistema
interferencias
notables
so-
brecarga
sistema
tenerse
cálculos
línea
importante
desarrollo
sistemas
procesamiento
transacciones
tiempo
real
caso
número
usuarios
realizan
consultas
actualizaciones
base
datos
ejemplo
sistema
reserva
compañía
aérea
principal
diferencia
sistema
procesamiento
transacciones
sistema
tiempo
real
limitado
aplicaciones
usuarios
sistema
tiempo
real
pue-
den
comprometidos
desarrollo
programas
ejecución
trabajos
aplicaciones
casos
tiempo
respuesta
sistema
impresionante
principal
herramienta
disponible
programadores
sistema
desarrollo
inicial
multiprogramación
sistemas
interactivos
multiusuario
interrupción
trabajo
po-
suspender
actividad
ocurrencia
evento
definido
finalización
operación
S.
procesador
guardaría
forma
contexto
ejemplo
contador
programa
registros
saltaría
rutina
tratamiento
interrupciones
determinaría
naturaleza
interrupción
procesaría
interrupción
continuaría
procesamiento
usuario
trabajo
interrumpido
trabajo
68
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
68El
diseño
software
sistema
coordinar
diversas
actividades
resultó
notable-
mente
difícil
progresión
simultánea
trabajos
suponía
realización
numerosos
pasos
ejecución
secuencial
imposible
analizar
posi-
bles
combinaciones
secuencias
eventos
ausencia
método
sistemático
coor-
dinación
cooperación
actividades
programadores
acudían
métodos
ad
hoc
basados
comprensión
entorno
sistema
operativo
controlar
esfuerzos
vul-
nerables
frente
errores
programación
sutiles
cuyos
efectos
podían
observarse
extrañas
secuencias
acciones
ocurrían
errores
difíciles
diagnosticar
necesi-
taban
distinguirse
errores
software
hardware
aplicaciones
detectaba
error
difícil
determinar
causa
condiciones
precisas
error
apare-
cía
difíciles
reproducir
términos
generales
causas
principales
dichos
errores
DEBB80a
Inapropiada
sincronización
frecuente
rutina
suspenda
esperando
evento
sistema
ejemplo
programa
inicia
lectura
esperar
datos
estén
disponibles
buffer
proceder
caso
necesita
señal
procedente
rutina
diseño
inapropiado
mecanismo
señali-
zación
provocar
señales
pierdan
reciban
señales
duplicadas
Violación
exclusión
mutua
Frecuentemente
programa
usuario
intentan
recursos
compartidos
simultáneamente
ejemplo
usuarios
inten-
tar
editar
fichero
accesos
controlan
ocurrir
error
existir
tipo
mecanismo
exclusión
mutua
permita
rutina
momento
determinado
actualice
fichero
difícil
verificar
implementación
exclusión
mutua
correcta
posibles
secuencias
eventos
Operación
determinista
programa
resultados
programa
particular
nor-
malmente
dependen
entrada
programa
actividades
pro-
grama
sistema
compartido
programas
comparten
memoria
ejecu-
ciones
entrelazadas
procesador
interferir
sobreescribiendo
zonas
memoria
comunes
forma
impredecible
orden
diversos
programas
planifican
afectar
salida
programa
particular
Interbloqueos
programas
queden
bloqueados
esperándose
ejemplo
programas
requerir
dispositivos
cabo
determinada
operación
ejemplo
copia
disco
cinta
progra-
tomado
control
dispositivos
programa
control
dis-
positivo
esperando
programa
libere
recurso
po-
seen
interbloqueo
depender
temporización
asignación
liberación
recursos
necesita
enfrentarse
problemas
forma
sistemática
monitorizar
controlar
ejecución
programas
procesador
concepto
proceso
proporciona
fundamentos
considerar
proceso
formado
siguientes
componentes
programa
ejecutable
datos
asociados
necesita
programa
variables
espacio
trabajo
buffers
etc.
contexto
ejecución
programa
elemento
esencial
contexto
ejecución
proceso
conjunto
datos
interno
sistema
operativo
capaz
supervisar
controlar
proceso
información
interna
separada
proceso
sistema
operativo
información
Introducción
sistemas
operativos
69
02-Capitulo
12/5/05
16:18
Página
69el
proceso
acceder
contexto
incluye
información
sistema
operativo
necesi-
ta
gestionar
proceso
procesador
necesita
ejecutar
proceso
apropiadamente
contexto
incluye
contenido
diversos
registros
procesador
tales
contador
progra-
ma
registros
datos
incluye
información
sistema
operativo
prio-
ridad
proceso
proceso
esperando
finalización
evento
particular
Figura
2.8
indica
forma
procesos
gestionarse
procesos
encuentran
porción
memoria
principal
asignado
bloque
memoria
proceso
contiene
programa
datos
información
contexto
incluye
proceso
lista
procesos
construye
mantiene
sistema
operativo
lista
procesos
contiene
entrada
proceso
incluye
puntero
ubicación
bloque
memoria
contie-
ne
proceso
entrada
incluir
contexto
ejecución
proceso
resto
contexto
ejecución
almacenado
lugar
proceso
queda
reflejado
Figura
2.8
frecuentemente
región
memoria
separada
registro
ín-
proceso
contiene
índice
proceso
procesador
actualmente
controlando
lista
procesos
contador
programa
apunta
instrucción
proceso
ejecutar
registros
base
límite
definen
región
memoria
ocupada
proceso
registro
base
contiene
dirección
inicial
región
memoria
registro
límite
tamaño
región
bytes
palabras
contador
programa
referencias
datos
interpretan
for-
70
Sistemas
operativos
Aspectos
internos
principios
diseño
Contexto
Datos
Programa
codigo
Índice
procesos
PC
Base
Límite
registros
Proceso
Proceso
Memoria
principal
Registros
procesador
Lista
procesos
Contexto
Datos
Programa
codigo
Figura
2.8
Implementación
procesos
típica
02-Capitulo
12/5/05
16:18
Página
70ma
relativa
registro
base
exceder
valor
almacenado
registro
límite
previe-
ne
interferencia
procesos
Figura
2.8
registro
índice
proceso
indica
proceso
ejecutando
proce-
so
ejecutando
previamente
interrumpido
temporalmente
contenidos
registros
momento
interrupción
guardados
contexto
ejecución
Posteriormente
sistema
operativo
cambiar
proceso
ejecución
continuar
ejecución
contexto
A.
carga
contador
programa
valor
apunta
área
pro-
grama
proceso
continuará
ejecución
automáticamente
proceso
verse
estructura
datos
proceso
ejecu-
ción
esperando
ejecutarse
completo
proceso
instante
contiene
contexto
estructura
permite
desarrollo
técnicas
potentes
aseguran
coordinación
cooperación
procesos
diseñar
incorporar
características
sistema
operativo
ejemplo
prioridad
expandiendo
contexto
incluir
información
utilice
soporte
dicha
característica
libro
veremos
nú-
mero
ejemplos
utiliza
estructura
proceso
resolver
problemas
provocados
multiprogramación
compartición
recursos
GESTIÓN
MEMORIA
entorno
computación
permita
programación
modular
flexible
datos
ayudar
resolver
necesidades
usuarios
gestores
sistema
necesitan
control
eficiente
ordenado
asignación
recursos
satisfacer
requisitos
sistema
ope-
rativo
responsabilidades
principales
gestión
almacenamiento
Aislamiento
procesos
sistema
operativo
evitar
procesos
independientes
interfieran
memoria
proceso
datos
instrucciones
Asignación
gestión
automática
programas
asignación
dinámica
memoria
demanda
nivel
jerarquía
memoria
asignación
transparente
programador
programador
preocuparse
aspectos
rela-
cionados
limitaciones
memoria
sistema
operativo
lograr
incrementar
efi-
ciencia
asignando
memoria
trabajos
necesiten
Soporte
programación
modular
programadores
capaces
definir
módu-
programación
crear
destruir
alterar
tamaño
módulos
dinámicamente
Protección
control
acceso
compartición
memoria
nivel
jerar-
quía
memoria
permite
programa
direccione
espacio
memoria
proceso
deseable
necesita
compartición
determinadas
aplicaciones
característica
amenaza
integridad
programas
sistema
operativo
sistema
operativo
permitir
usuarios
puedan
acceder
distintas
formas
porciones
memoria
Almacenamiento
plazo
aplicaciones
requieren
formas
almacenar
infor-
mación
largos
periodos
tiempo
computador
apagado
Normalmente
sistemas
operativos
alcanzan
requisitos
memoria
virtual
utilidades
sistemas
operativos
sistema
operativo
implementa
almacenamien-
to
plazo
información
almacenada
objetos
denominados
ficheros
fichero
concepto
lógico
conveniente
programador
unidad
útil
control
acceso
protec-
ción
sistemas
operativos
Introducción
sistemas
operativos
71
02-Capitulo
12/5/05
16:18
Página
71La
memoria
virtual
utilidad
permite
programas
direccionar
memoria
punto
vista
lógico
importar
cantidad
memoria
principal
física
disponible
me-
moria
virtual
concebida
método
múltiples
trabajos
usuario
residiendo
memoria
principal
forma
concurrente
forma
exista
intervalo
tiempo
espera
ejecución
procesos
sucesivos
proceso
escribe
almacena-
miento
secundario
lee
proceso
sucesor
procesos
varían
tamaño
procesador
planifica
determinado
número
procesos
difícil
almacenarlos
compactamente
memoria
principal
introdujeron
sistemas
paginación
permiten
procesos
compriman
número
determinado
bloques
tamaño
fijo
denominados
páginas
programa
referencia
palabra
dirección
virtual
consiste
número
página
desplazamiento
página
página
proceso
localizar
sitio
memoria
principal
sistema
paginación
proporciona
proyección
di-
námica
direcciones
virtuales
utilizadas
programa
dirección
real
dirección
física
memoria
principal
hardware
proyección
dinámica
disponible
paso
eliminar
requisito
páginas
proceso
residan
memoria
principal
simultáneamente
páginas
proceso
mantienen
disco
proceso
ejecución
páginas
encuentran
memoria
principal
referencia
página
memoria
principal
hardware
gestión
memoria
detecta
permite
página
falta
cargue
esque-
ma
denomina
área
memoria
virtual
representado
Figura
2.9
hardware
procesador
sistema
operativo
dota
usuario
procesador
virtual
acceso
memoria
virtual
almacen
espacio
almacena-
miento
lineal
colección
segmentos
bloques
longitud
variable
direcciones
contiguas
casos
instrucciones
lenguaje
programación
referenciar
programa
ubicaciones
datos
área
memoria
virtual
aislamiento
proce-
sos
lograr
dando
proceso
única
área
memoria
virtual
solape
áreas
compartición
memoria
lograr
porciones
espacios
memoria
virtual
solapan
ficheros
mantienen
almacenamiento
plazo
ficheros
copiar
memoria
virtual
programas
manipulen
Figura
2.10
destaca
aspectos
direccionamiento
esquema
memoria
virtual
almacenamiento
compuesto
memoria
principal
directamente
direccionable
ins-
trucciones
máquina
memoria
auxiliar
baja
velocidad
accede
forma
indirecta
car-
gando
bloques
memoria
principal
hardware
traducción
direcciones
memory
management
unit
unidad
gestión
memoria
interpone
procesador
memoria
programas
referencia
direcciones
virtuales
proyectadas
direcciones
reales
memoria
principal
referencia
dirección
virtual
memoria
física
en-
tonces
porción
contenidos
memoria
real
llevados
memoria
auxiliar
conte-
nidos
memoria
real
buscando
llevados
memoria
principal
ta-
rea
proceso
generó
dirección
suspende
diseñador
sistema
operativo
necesita
desarrollar
mecanismo
traducción
direcciones
genere
sobrecarga
política
asignación
almacenamiento
minimice
tráfico
niveles
jerarquía
memoria
PROTECCIÓN
SEGURIDAD
INFORMACIÓN
crecimiento
sistemas
tiempo
compartido
recientemente
redes
com-
putadores
originado
incremento
preocupación
protección
información
na-
turaleza
amenazas
conciernen
organización
variarán
enormemente
dependiendo
72
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
72las
circunstancias
herramientas
propósito
general
utilizar
computadores
sistemas
operativos
soportar
variedad
mecanismos
protec-
ción
seguridad
general
principal
problema
control
acceso
sistemas
compu-
tación
información
almacenada
mayoría
trabajo
seguridad
protección
relacionado
sistemas
operativos
pue-
agrupar
forma
genérica
categorías
Disponibilidad
Relacionado
protección
sistema
frente
interrupciones
Confidencialidad
Asegura
usuarios
puedan
leer
datos
tie-
nen
autorización
acceso
Integridad
datos
Protección
datos
frente
modificaciones
autorizadas
Autenticidad
Relacionado
verificación
apropiada
identidad
usuarios
validez
mensajes
datos
Introducción
sistemas
operativos
73
Memoria
principal
Disco
Programa
usuario
A.0
B.0
B.1
B.5
B.6
B.2
B.3
A.1
A.2
A.7
A.8
A.5
A.9
10
memoria
principal
formada
marcos
tamaño
fijo
tamaño
página
ejecute
programa
páginas
encontrar
memoria
principal
memoria
secundaria
disco
contener
páginas
tamaño
fijo
programa
usuario
formado
páginas
páginas
programas
sistema
operativo
encuentran
disco
ficheros
Programa
usuario
Figura
2.9
Conceptos
memoria
virtual
02-Capitulo
12/5/05
16:18
Página
73PLANIFICACIÓN
GESTIÓN
RECURSOS
responsabilidad
clave
sistemas
operativos
gestión
recursos
disponibles
espacio
memoria
principal
dispositivos
procesadores
planificar
distintos
procesos
activos
asignación
recursos
política
planificación
factores
Equitatividad
Normalmente
desea
procesos
compiten
determi-
nado
recurso
conceda
acceso
equitativo
recurso
especialmente
trabajos
categoría
trabajos
demandas
similares
Respuesta
diferencial
sistema
operativo
necesitar
discriminar
clases
trabajos
requisitos
servicio
sistema
operativo
tomar
decisiones
asignación
planificación
objetivo
satisfacer
conjunto
to-
requisitos
tomar
decisiones
forma
dinámica
ejemplo
proceso
esperando
dispositivo
sistema
operativo
intentar
planificar
proceso
ejecución
liberar
dispo-
sitivo
posteriores
demandas
procesos
Eficiencia
sistema
operativo
intentar
maximizar
productividad
minimizar
tiem-
po
respuesta
caso
sistemas
tiempo
compartido
acomodar
tantos
usuarios
criterios
entran
conflicto
encontrar
compromiso
adecuado
si-
tuación
particular
problema
objeto
investigación
sistemas
operativos
planificación
gestión
recursos
esencialmente
problemas
investigación
pue-
den
aplicar
resultados
matemáticos
disciplina
Adicionalmente
medir
actividad
siste-
ma
importante
capaz
monitorizar
rendimiento
ajustes
correspondientes
Figura
2.11
sugiere
principales
elementos
sistema
operativo
relacionados
plani-
ficación
procesos
asignación
recursos
entorno
multiprogramación
sistema
ope-
rativo
mantiene
número
colas
simplemente
lista
procesos
es-
perando
recursos
cola
corto
plazo
compuesta
procesos
encuentran
74
Sistemas
operativos
Aspectos
internos
principios
diseño
Procesador
Dirección
virtual
Dirección
real
Dirección
disco
Unidad
gestión
memoria
Memoria
principal
Memoria
secundaria
Figura
2.10
Direccionamiento
memoria
virtual
02-Capitulo
12/5/05
16:18
Página
74en
memoria
principal
porción
mínima
esencial
memoria
principal
listos
ejecutar
procesador
esté
disponible
Cualquiera
procesos
procesador
continuación
responsabilidad
planificador
corto
plazo
dispatcher
elegir
estrategia
común
asignar
orden
proceso
cola
intervalo
tiempo
técnica
conoce
round-robin
turno
rotatorio
efecto
técnica
turno
rotatorio
emplea
cola
circular
estrategia
consiste
asignar
niveles
prio-
ridad
distintos
procesos
planificador
encargado
elegir
procesos
orden
prioridad
cola
plazo
lista
trabajos
esperando
utilizar
procesador
sistema
operativo
añade
trabajos
sistema
transfiriendo
proceso
cola
plazo
cola
corto
plazo
punto
asignar
porción
memoria
principal
proceso
entrante
sistema
operativo
seguro
sobrecarga
memoria
tiempo
procesa-
dor
admitiendo
demasiados
procesos
sistema
cola
dispositivo
S.
proceso
solicitar
dispositivo
S.
procesos
espe-
ran
utilizar
dispositivo
encuentran
alineados
cola
dispositivo
sistema
operativo
determinar
proceso
asigna
dispositivo
disponible
ocurre
interrupción
sistema
operativo
recibe
control
procesador
manejador
interrupciones
proceso
invocar
específicamente
servicio
sistema
ope-
rativo
manejador
dispositivo
llamada
sistema
caso
manejador
llamada
sistema
punto
entrada
sistema
operativo
caso
maneja
interrupción
llamada
sistema
invoca
planificador
corto
plazo
seleccione
proceso
ejecución
detallado
descripción
funcional
detalles
diseño
modular
porción
sistema
operativo
difiere
sistemas
esfuerzo
investigación
desarrollo
sistemas
operativos
dirigido
creación
algoritmos
planificación
estructuras
datos
proporcionen
equitatividad
respuesta
diferencial
eficiencia
Introducción
sistemas
operativos
75
Pasa
control
proceso
Manejador
interrupciones
código
Cola
plazo
Cola
corto
plazo
Colas
Sistema
operativo
Llamada
sistema
proceso
Interrupción
proceso
Interrupción
Planificador
corto
plazo
código
Manejador
llamadas
sistema
código
Figura
2.11
Elementos
clave
sistema
operativo
multiprogramación
02-Capitulo
12/5/05
16:18
Página
75ESTRUCTURA
SISTEMA
medida
añadido
características
sistemas
operativos
hardware
subyacente
vuelto
potente
versátil
crecido
tamaño
complejidad
sistemas
operati-
vos
CTSS
puesto
marcha
MIT
1963
compuesto
32.000
palabras
almacenamiento
36
bits
OS/360
presentado
IBM
año
millón
instrucciones
máquina
1975
sistema
Multics
desarrollado
MIT
laboratorios
Bell
superado
20
millones
instrucciones
recientemen-
introducido
sistemas
operativos
sencillos
sistemas
pequeños
inevitablemente
complejos
medida
hardware
subyacente
requisitos
usuario
incrementan
sistema
UNIX
muchísimo
complejo
sis-
tema
juguete
puesto
marcha
programadores
talento
comienzo
años
70
sencillo
sistema
MS-DOS
supuso
comienzo
ricos
complejos
sistemas
OS/2
Windows
ejemplo
Windows
NT
4.0
contiene
16
millones
líneas
código
Win-
dows
2000
duplica
número
tamaño
sistema
operativo
conjunto
completo
características
dificultad
problema
afronta
sistema
llevado
disciplina
desafortunados
de-
masiado
comunes
problemas
lugar
sistemas
operativos
entregan
forma
crónica
implica
creación
sistemas
operativos
frecuentes
actualizaciones
viejos
sistemas
lugar
sistemas
fallos
latentes
planteados
resueltos
tercer
lugar
rendimiento
frecuentemente
esperado
lugar
comprobado
imposible
construir
sistema
operativo
complejo
vulnerable
cantidad
ataques
seguridad
incluyendo
virus
gusanos
accesos
autorizados
gestionar
complejidad
sistemas
operativos
eliminar
problemas
puesto
énfasis
estructura
software
sistema
operativo
años
puntos
parecen
obvios
software
modular
ayudará
organizar
proceso
desarrollo
software
limitará
esfuerzo
diagnosticar
corregir
errores
módulos
interfaces
definidas
interfaces
sencillas
facilita
programación
facilita
evolución
sistema
mínimas
interfaces
módulos
modificar
módulo
mínimo
impacto
módulos
sistemas
operativos
ejecutan
millones
decenas
millones
líneas
código
suficiente
programación
modular
habido
incremento
conceptos
capas
jerárquicas
abstracción
información
estructura
jerárquica
sistema
operativo
moderno
separa
funciones
características
escala
tiempo
nivel
abstracción
sistema
serie
niveles
nivel
rea-
liza
subconjunto
relacionado
funciones
requeridas
sistema
operativo
nivel
confía
niveles
inmediatamente
inferiores
funciones
primitivas
ocultar
detalles
funciones
nivel
proporciona
servicios
capa
inmediatamente
superior
Idealmente
niveles
definirse
forma
cambios
nivel
requieran
cambios
niveles
forma
descompuesto
problema
número
subproblemas
manejables
general
capas
inferiores
tratan
escala
tiempo
menor
partes
siste-
ma
operativo
interaccionar
directamente
hardware
computador
eventos
escala
tiempo
ínfima
mil
millonésimas
extremo
espectro
partes
sistema
operativo
comunican
usuario
in-
voca
mandatos
escala
tiempo
larga
segundos
conjunto
niveles
adapta
adecuadamente
entorno
forma
principios
aplican
varía
enormemente
sistemas
operativos
con-
temporáneos
útil
punto
propósito
mostrar
sistemas
operativos
76
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
76Introducción
sistemas
operativos
77
presentar
modelo
sistema
operativo
jerárquico
propuesto
BROW84
DENN84
útil
corresponde
sistema
operativo
particular
modelo
define
Tabla
2.4
compuesto
siguientes
niveles
Nivel
formado
circuitos
electrónicos
objetos
tratados
registros
cel-
das
memoria
puertas
lógicas
operaciones
definidas
objetos
acciones
cero
registro
leer
posición
memoria
Nivel
conjunto
instrucciones
procesador
operaciones
nivel
permitidas
conjunto
instrucciones
lenguaje
máquina
adición
resta
carga
almacenamiento
Nivel
Añade
concepto
procedimiento
subrutina
operaciones
llamada
retorno
call
return
Nivel
Introduce
interrupciones
permiten
procesador
guardar
contexto
actual
invocar
rutina
tratamiento
interrupciones
abla
2.4
Jerarquía
diseño
sistema
operativo
Nivel
Nombre
Objetos
Ejemplos
operaciones
13
Intérprete
mandatos
Entorno
programación
Sentencias
lenguaje
usuario
intérprete
mandatos
12
Procesos
usuario
Procesos
usuario
Salir
matar
suspender
continuar
Directorios
Directorios
Crear
destruir
insertar
entrada
eliminar
entrada
buscar
listar
10
Dispositivos
Dispositivos
externos
Abrir
cerrar
leer
escribir
impresoras
pantallas
teclados
Sistema
ficheros
Ficheros
Crear
destruir
abrir
cerrar
leer
escribir
Comunicaciones
Tuberías
Crear
destruir
abrir
cerrar
leer
escribir
Memoria
virtual
Segmentos
páginas
Leer
escribir
cargar
Almacenamiento
Bloques
datos
Leer
escribir
asignar
secundario
local
canales
dispositivo
liberar
Procesos
primitivos
Procesos
primitivos
Suspender
continuar
semáforos
lista
esperar
señalizar
procesos
listos
Interrupciones
Programas
gestión
Invocar
enmascarar
interrupciones
desenmascarar
reintentar
Procedimientos
Procedimientos
pila
Marcar
pila
llamar
llamadas
registro
retornar
activación
Conjunto
instrucciones
Pila
evaluación
Cargar
almacenar
sumar
intérprete
microprogramas
restar
saltar
datos
escalares
vectoriales
Circuitos
electrónicos
Registros
puertas
transferir
buses
etc.
activar
complementar
área
sombreado
gris
representa
hardware
02-Capitulo
12/5/05
16:18
Página
77Estos
cuatros
niveles
sistema
operativo
constituyen
hard-
ware
procesador
elementos
sistema
operativo
empiezan
mostrar
niveles
ejemplo
rutinas
tratamiento
interrupciones
Nivel
corres-
ponde
sistema
operativo
propiamente
conceptos
asociados
multipro-
gramación
aparecen
Nivel
nivel
introduce
noción
proceso
programa
ejecución
requisitos
fundamentales
sistemas
operativos
soporte
múltiples
proce-
sos
incluyen
habilidad
suspender
continuar
procesos
requiere
guardar
re-
gistros
hardware
forma
interrumpir
ejecución
proceso
iniciar
Adicionalmente
procesos
necesitan
cooperar
necesitan
métodos
sincronización
técnicas
sencillas
concepto
importante
diseño
sistemas
operativos
semáforo
técnica
señalización
sencilla
analiza
Capítulo
Nivel
dispositivos
almacenamiento
secundario
computador
nivel
funciones
posicionar
cabezas
lectura
escritura
transferencia
real
bloques
Nivel
delega
Nivel
planificación
operación
notificación
pro-
ceso
solicitante
finalización
Niveles
altos
preocupan
dirección
disco
datos
requeridos
proporcionan
petición
bloque
datos
apropiado
controlador
dispositivo
Nivel
Nivel
Crea
espacio
direcciones
lógicas
procesos
nivel
organiza
espa-
cio
direcciones
virtuales
bloques
moverse
memoria
principal
memo-
ria
secundaria
esquemas
común
utilizan
páginas
tamaño
fijo
utilizan
segmentos
longitud
variable
utilizan
bloque
memoria
necesario
memoria
principal
lógica
nivel
requiere
transferencia
Nivel
punto
sistema
operativo
recursos
único
procesador
Comenzando
Nivel
sistema
operativo
objetos
externos
dispositivos
periféricos
posi-
blemente
redes
computadores
conectados
red
objetos
niveles
superiores
obje-
tos
lógicos
nombre
compartirse
procesos
computador
múlti-
ples
computadores
Nivel
comunicación
información
mensajes
procesos
Nivel
proporciona
mecanismo
señalización
primitivo
permite
sincroniza-
ción
procesos
nivel
compartición
información
rica
herramientas
potentes
propósito
tubería
pipe
canal
lógico
flujo
datos
procesos
tubería
define
salida
proceso
en-
trada
proceso
utilizar
enlazar
dispositivos
externos
ficheros
procesos
concepto
discute
Capítulo
Nivel
soporte
almacenamiento
plazo
ficheros
nombre
nivel
datos
almacenamiento
secundario
ven
términos
entidades
abstractas
longitud
variable
contrasta
visión
orientada
hardware
almacenamiento
se-
cundario
términos
pistas
sectores
bloques
tamaño
fijo
Nivel
Nivel
10
Proporciona
acceso
dispositivos
externos
utilizando
interfaces
estándar
Nivel
11
nivel
responsable
mantener
asociación
identificadores
exter-
internos
recursos
objetos
sistema
identificador
externo
nombre
utilizar
aplicación
usuario
identificador
interno
dirección
iden-
tificador
utilizarse
niveles
inferiores
sistema
operativo
lo-
78
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
78calizar
controlar
objeto
asociaciones
mantienen
directorio
entradas
incluyen
asociación
identificadores
externos
internos
caracterís-
ticas
derechos
acceso
Nivel
12
Proporciona
utilidad
completa
soporte
procesos
nivel
allá
proporcionado
Nivel
Nivel
mantienen
contenidos
registros
procesador
asociados
proceso
lógica
procesos
planifica-
ción
Nivel
12
soporte
información
necesaria
gestión
ordenada
procesos
incluye
espacio
direcciones
virtuales
procesos
lista
ob-
jetos
procesos
interactuar
restricciones
interacción
paráme-
tros
pasados
proceso
creación
incluye
característica
pu-
diera
utilizar
sistema
operativo
controlar
proceso
Nivel
13
Proporciona
interfaz
sistema
operativo
usuario
denomina
shell
capa-
razón
separa
usuario
detalles
sistemas
operativos
presenta
sistema
operativo
simplemente
colección
servicios
shell
acepta
mandatos
usuario
sentencias
control
trabajos
interpreta
crea
controla
procesos
necesita
ejecución
ejemplo
nivel
interfaz
implementarse
gráfica
proporcionando
usuario
mandatos
lista
presentada
menú
mostrando
resultados
utilizando
salida
gráfica
conectada
dispositivo
específico
pantalla
modelo
hipotético
sistema
operativo
proporciona
estructura
descriptiva
útil
sirve
guía
implementación
lector
volver
estudiar
estructura
desarro-
llo
libro
situar
aspecto
particular
diseño
discusión
contexto
apropiado
2.4
DESARROLLOS
LLEVADO
SISTEMAS
OPERATIVOS
MODERNOS
años
habido
evolución
gradual
estructura
capacidades
siste-
operativos
años
introducido
número
ele-
mentos
diseño
sistemas
operativos
versiones
sistemas
operati-
vos
existentes
creado
cambio
fundamental
naturaleza
sistemas
operativos
sistemas
operativos
modernos
responden
desarrollos
hardware
aplicacio-
nes
amenazas
seguridad
causas
hardware
principales
encuentran
má-
quinas
multiprocesador
logrado
incrementar
velocidad
máquina
medida
dispositivos
conexión
alta
velocidad
red
tamaño
creciente
variedad
dispositi-
vos
almacenamiento
memoria
campo
aplicaciones
aplicaciones
multimedia
Internet
acceso
Web
computación
cliente
servidor
influido
diseño
sistema
operativo
seguridad
acceso
Internet
computadores
incrementado
medida
amenaza
potencial
ataques
sofisticados
tales
virus
gusanos
técnicas
hacking
impacto
profundo
diseño
sistemas
operativos
velocidad
cambio
demandas
sistemas
operativos
requiere
modificacio-
nes
mejoras
arquitecturas
existentes
formas
organizar
sistema
operati-
vo
amplio
rango
técnicas
elementos
diseño
probado
sistemas
operativos
experimentales
comerciales
mayoría
trabajo
encaja
siguientes
categorías
Arquitectura
micronúcleo
microkernel
Multihilo
Multiprocesamiento
simétrico
Introducción
sistemas
operativos
79
02-Capitulo
12/5/05
16:18
Página
79•
Sistemas
operativos
distribuidos
Diseño
orientado
objetos
relativamente
tiempo
mayoría
sistemas
operativos
formados
núcleo
monolítico
núcleos
proporcionan
mayoría
funcionalida-
des
consideradas
sistema
operativo
incluyendo
planificación
sistemas
ficheros
redes
controladores
dispositivos
gestión
memoria
funciones
Normalmente
núcleo
monolítico
implementa
único
proceso
elementos
compartiendo
espacio
direcciones
arquitectura
micronúcleo
asigna
funciones
esenciales
núcleo
incluyendo
espacios
almacenamiento
comunicación
procesos
IPC
planificación
básica
procesos
proporcionan
servicios
sistema
operativo
denominados
servidores
ejecutan
usuario
tratados
apli-
cación
micronúcleo
técnica
desacopla
núcleo
desarrollo
servidor
servido-
res
configurarse
aplicaciones
específicas
determinados
requisitos
entorno
técnica
micronúcleo
simplifica
implementación
proporciona
flexibilidad
adapta
perfectamen-
entorno
distribuido
esencia
micronúcleo
interactúa
procesos
locales
remotos
servidor
forma
facilitando
construcción
sistemas
distribuidos
Multitheadinges
técnica
proceso
ejecutando
aplicación
divide
se-
rie
hilos
threadsque
ejecutar
concurrentemente
siguientes
distinciones
Thread
hilo
unidad
trabajo
Incluye
contexto
procesador
con-
contador
programa
puntero
pila
área
datos
pila
posibilitar
salto
subrutinas
hilo
ejecuta
secuencialmente
interrum-
pir
forma
procesador
paso
hilo
Proceso
colección
hilos
recursos
sistema
asociados
memoria
conteniendo
código
datos
ficheros
abiertos
dispositivos
corres-
ponde
concepto
programa
ejecución
Dividiendo
aplicación
múltiples
hi-
programador
control
modularidad
aplicaciones
temporiza-
ción
eventos
relacionados
aplicación
técnica
multithreading
útil
aplicaciones
llevan
cabo
número
tareas
esen-
cialmente
independientes
necesitan
serializadas
ejemplo
servidor
bases
datos
escucha
procesa
numerosas
peticiones
cliente
múltiples
hilos
ejecutándose
mis-
mo
proceso
intercambiar
ejecución
hilos
supone
sobrecarga
procesador
inter-
cambiar
ejecución
procesos
pesados
hilos
útiles
estructurar
pro-
cesos
núcleo
sistema
operativo
describe
capítulos
siguientes
tiempo
computadores
personales
estaciones
trabajo
virtualmente
único
usuario
contenían
único
procesador
propósito
general
medida
demanda
ren-
dimiento
incrementa
coste
microprocesadores
continúa
cayendo
fabricantes
in-
troducido
mercado
computadores
múltiples
procesadores
lograr
eficiencia
fiabilidad
técnica
consiste
emplear
multiprocesamiento
simétrico
SMP
Symmetric
Multi-
Processing
término
refiere
arquitectura
hardware
computador
com-
portamiento
sistema
operativo
explota
dicha
arquitectura
definir
multiprocesa-
dor
simétrico
sistema
computación
aislado
siguientes
características
múltiples
procesadores
procesadores
comparten
utilidades
memoria
principal
interco-
nectadas
bus
comunicación
esquema
conexión
interna
procesadores
funciones
término
simétrico
80
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
80El
sistema
operativo
SMP
planifica
procesos
hilos
procesadores
SMP
diversas
ventajas
potenciales
arquitecturas
monoprocesador
incluyen
Rendimiento
trabajo
organizar
forma
porción
trabajo
paralelo
sistema
múltiples
procesadores
alcanzará
rendimiento
procesador
tipo
muestra
Figura
2.12
multiprogramación
proceso
ejecutar
resto
procesos
esperan
procesador
multiproceso
proceso
ejecutarse
simultáneamente
procesador
Disponibilidad
multiprocesador
simétrico
procesadores
cabo
funciones
fallo
procesador
máquina
contrario
sistema
continuar
funcionando
rendimiento
reducido
Crecimiento
incremental
usuario
mejorar
rendimiento
sistema
añadiendo
procesador
adicional
Escalado
fabricantes
ofrecer
rango
productos
precio
carac-
terísticas
basadas
número
procesadores
configurado
sistema
importante
notar
características
beneficios
potenciales
garantizados
sistema
operativo
proporcionar
herramientas
funciones
explotar
paralelismo
sistema
SMP
Introducción
sistemas
operativos
81
Intercalado
multiprogramación
procesador
Proceso
Intercalado
solapamiento
multiproceso
procesadores
Bloqueado
Ejecutando
Tiempo
Proceso
Proceso
Proceso
Proceso
Proceso
Figura
2.12
Multiprogramación
multiproceso
02-Capitulo
12/5/05
16:18
Página
81La
técnica
multithreading
SMP
frecuentemente
analizados
juntos
utilidades
independientes
nodo
monoprocesador
técnica
multihreading
útil
estruc-
turar
aplicaciones
procesos
núcleo
máquina
SMP
útil
procesos
con-
hilos
procesos
ejecutar
paralelo
ambas
utilidades
complementan
utilizar
forma
conjunta
efectivamente
característica
atractiva
SMP
existencia
múltiples
procesadores
transpa-
rente
usuario
sistema
operativo
encarga
planificar
hilos
procesos
procesadores
in-
dividuales
sincronización
procesadores
libro
discute
planificación
me-
canismos
sincronización
utilizados
proporcionar
apariencia
único
sistema
usuario
problema
proporcionar
apariencia
sistema
cluster
computadores
separado-un
sistema
multicomputador
caso
colección
entidades
computa-
dores
módulos
memoria
principal
memoria
secundaria
mó-
dulos
S.
sistema
operativo
distribuido
proporciona
ilusión
espacio
memoria
princi-
pa
espacio
memoria
secundario
utilidades
acceso
unificadas
sis-
tema
ficheros
distribuido
clusters
volviendo
populares
productos
clusters
mercado
arte
sistemas
distribuidos
re-
trasado
monoprocesadores
sistemas
operativos
SMP
examinarán
dichos
siste-
innovación
diseño
sistemas
operativos
tecnologías
orientadas
ob-
jetos
diseño
orientado
objetos
introduce
disciplina
proceso
añadir
extensiones
mo-
dulares
pequeño
núcleo
nivel
sistema
operativo
estructura
basada
objetos
permite
programadores
personalizar
sistema
operativo
eliminar
integridad
sistema
orientación
objetos
facilita
desarrollo
herramientas
distribuidas
sistemas
operati-
vos
distribuidos
2.5
DESCRIPCIÓN
GLOBAL
MICROSOFT
WINDOWS
sección
descripción
global
Microsoft
Windows
describirá
UNIX
sección
HISTORIA
historia
Windows
comienza
sistema
operativo
desarrollado
Micro-
soft
computador
personal
IBM
conocido
MS-DOS
PC-DOS
versión
ini-
cial
1.0
apareció
1981
compuesto
4000
líneas
código
fuente
ensamblador
ejecutaba
Kbytes
memoria
utilizando
microprocesador
Intel
8086
IBM
desarrolló
computador
personal
basado
disco
duro
PC
XT
Microsoft
desa-
rrolló
2.0
salió
mercado
1983
sistema
daba
soporte
disco
duro
proporcionaba
jerarquía
directorios
momento
disco
podía
contener
directorio
ficheros
soportando
máximo
64
ficheros
adecuado
disquetes
limitado
discos
duros
restricción
directorio
burda
versión
permitía
directorios
contuvieran
tantos
subdirectorios
ficheros
versión
contenía
conjunto
mandatos
rico
sistema
operativo
proporcionaban
funciones
realizadas
programas
externos
versión
ca-
pacidades
añadidas
encontraban
características
sistemas
UNIX
redirección
consiste
capacidad
modificar
entrada
salida
determinada
aplicación
impresión
plano
porción
memoria
residente
creció
24
Kbytes
82
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
82Cuando
IBM
anunció
PC
AT
1984
Microsoft
introdujo
3.0
sistema
AT
contenía
procesador
Intel
80286
proporcionaba
características
direccionamiento
extendido
protección
memoria
utilizadas
compatible
versiones
anteriores
sistema
operativo
simplemente
utilizaba
80286
8086
rápido
sistema
operativo
daba
soporte
teclado
periféricos
disco
duro
requisitos
memoria
incre-
mentaron
36
Kbytes
actualizaciones
notables
versión
3.0
3.1
apareció
1984
daba
soporte
conexión
red
PC
tamaño
porción
residente
cam-
bió
logró
incrementando
cantidad
sistema
operativo
podía
intercambiado
swap-
ped
3.3
apareció
1987
daba
soporte
línea
máquinas
IBM
PS/2
nue-
vo
versión
beneficiaba
capacidades
procesador
PS/2
proporcionadas
80286
chips
32
bits
80386
punto
porción
residente
alcanzado
mínimo
46
Kbytes
incrementándose
cantidad
seleccionaban
extensiones
opcionales
momento
utilizando
entorno
posibilidades
in-
troducción
80486
chip
Intel
Pentium
proporcionaban
características
simplemente
po-
explotar
sencillo
sistema
comienzo
años
80
Microsoft
comenzó
desarrollar
interfaz
gráfica
usuario
GUI
Graphical
User
Interface
interpuesta
en-
tre
usuario
sistema
operativo
objetivo
Microsoft
competir
Macintosh
cuyo
sistema
operativo
insuperable
facilidad
1990
Microsoft
versión
GUI
conocida
Windows
3.0
incorporaba
características
amigables
Macintosh
limitada
necesidad
ejecutar
Microsoft
intentó
desarrollo
sistema
operativo
generación
IBM
explo-
tar
potencia
microprocesadores
incorporaría
características
facilidad
Windows
proyecto
finalmente
abortado
intento
fallido
Mi-
crosoft
desarrolló
sistema
operativo
cero
denominó
Windows
NT
Win-
dows
NT
explota
capacidades
microprocesadores
contemporáneos
proporciona
multitarea
entorno
mono
multiusuario
versión
Windows
NT
3.1
apareció
1993
interfaz
gráfica
Windows
3.1
sistema
operativo
Microsoft
sucesor
Windows
3.0
NT
3.1
sistema
operativo
32
bits
capacidad
soporte
aplicaciones
Win-
dows
antiguas
aplicaciones
OS/2
versiones
NT
3.x
Microsoft
produjo
NT
4.0
NT
4.0
esencialmente
arquitectura
interna
3.x
cambio
externo
notable
NT
4.0
proporciona
mis-
ma
interfaz
usuario
Windows
95
cambio
arquitectónico
importante
com-
ponentes
gráficos
ejecutaban
usuario
subsistema
Win32
3.x
mue-
ven
sistema
ejecutivo
Windows
NT
ejecuta
núcleo
beneficio
cambio
consiste
aceleración
funciones
importantes
desventaja
potencial
funcio-
nes
gráficas
acceso
servicios
nivel
sistema
impactar
fia-
bilidad
sistema
operativo
2000
Microsoft
introdujo
principal
actualización
materializó
sistema
Windows
2000
sistema
ejecutivo
subyacente
arquitectura
núcleo
funda-
mentalmente
NT
4.0
añadido
características
énfasis
Win-
dows
2000
adición
servicios
funciones
soporte
procesamiento
distribuido
elemento
central
características
Windows
2000
Active
Directory
servi-
cio
directorios
distribuido
capaz
proyección
nombres
objetos
arbitrarios
información
dichos
objetos
punto
general
Windows
2000
distinción
Windows
2000
Server
escri-
torio
Windows
2000
esencia
núcleo
arquitectura
ejecutiva
servicios
Windows
2000
Server
incluye
servicios
requeridos
servidor
red
Introducción
sistemas
operativos
83
02-Capitulo
12/5/05
16:18
Página
83En
2001
apareció
versión
escritorio
Windows
conocida
Windows
XP
ofrecieron
versiones
XP
PC
hogar
estación
trabajo
negocio
2001
apareció
versión
XP
64
bits
año
2003
Microsoft
presentó
versión
servidor
conocido
Windows
Server
2003
versiones
disponibles
32
64
bits
versiones
64
bits
XP
Server
2003
diseñadas
específicamente
hardware
Intel
Itanium
64
bits
MULTITAREA
MONOUSUARIO
Windows
Windows
2000
ejemplo
significativo
significa
ola
sistemas
operativos
microcomputadores
ejemplos
OS/2
MacOS
desa-
rrollo
Windows
dirigido
necesidad
explotar
capacidades
microprocesadores
actuales
32
bits
rivalizan
mainframes
minicomputadores
años
velocidad
sofisticaciones
hardware
capacidad
memoria
características
significativas
sistemas
operativos
pensados
soporte
único
usuario
interactivo
sistemas
operativos
multitarea
principales
desarrollos
disparado
necesidad
multitarea
computadores
personales
estaciones
trabajo
servidores
lugar
incremento
velocidad
capacidad
memoria
microprocesadores
soporte
memoria
virtual
aplicacio-
nes
vuelto
complejas
interrelacionadas
ejemplo
usuario
desear
utilizar
procesador
texto
programa
dibujo
hoja
cálculo
simultáneamente
producir
documento
multitarea
usuario
desea
crear
dibujo
copiarlo
documento
re-
quieren
siguientes
pasos
Abrir
programa
dibujo
Crear
dibujo
guardarlo
fichero
portapapeles
Cerrar
programa
dibujo
Abrir
procesador
texto
Insertar
dibujo
sitio
adecuado
desea
cambio
usuario
cerrar
procesador
texto
abrir
programa
dibujo
editar
imagen
gráfica
guardarlo
cerrar
programa
dibujo
abrir
procesador
texto
insertar
imagen
actualizada
proceso
vuelve
tedioso
rápidamente
medida
servicios
capacidades
disponibles
usuarios
vuelven
potentes
variados
entorno
monotarea
vuelve
burdo
amigable
entorno
multitarea
usuario
abre
aplicación
necesita
deja
abierta
información
mover
aplicaciones
fácilmente
aplicación
ventanas
abiertas
interfaz
gráfica
dispositi-
vo
puntero
ratón
permite
usuario
navegar
fácilmente
entorno
motivación
multitarea
aumento
computación
cliente
servidor
paradigma
computador
personal
estación
trabajo
cliente
sistema
host
servidor
utilizan
forma
conjunta
cabo
aplicación
particular
enlazados
asigna
trabajo
adapta
capacidades
paradigma
clien-
servidor
cabo
red
área
local
formada
computadores
personales
servidores
enlace
sistema
usuario
host
ejemplo
mainframe
aplicación
implicar
computadores
personales
dispo-
sitivos
servidor
proporcionar
respuesta
requerida
sistema
operativo
necesita
soporte
hardware
comunicación
tiempo
real
protocolos
comunicación
asociados
arqui-
tecturas
transferencia
datos
soporte
interacción
usuarios
84
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
84Las
características
describen
continuación
refieren
versión
Profesional
Win-
dows
versión
Server
Servidor
multitarea
permitir
múltiples
usua-
rios
soporte
múltiples
conexiones
locales
servidor
proporciona
servicios
compartidos
utilizan
múltiples
usuarios
red
servidor
Internet
Windows
permitir
miles
conexiones
web
simultáneas
ARQUITECTURA
Figura
2.13
muestra
estructura
global
Windows
2000
posteriores
versiones
Windows
tie-
nen
esencialmente
estructura
nivel
detalle
estructura
modular
Windows
considerable
flexibilidad
diseñado
ejecutar
variedad
plataformas
hardware
soporte
aplicaciones
escritas
cantidad
sistemas
operativos
momento
escritura
libro
Windows
implementado
plataformas
hardware
Intel
Pen-
tium
x86
Itanium
virtualmente
sistemas
operativos
Windows
separa
software
orientado
aplicación
software
sistema
operativo
incluye
sistema
ejecutivo
Introducción
sistemas
operativos
85
usuario
núcleo
Gestor
sesiones
Hilos
sistema
Entregador
servicios
sistema
Winlogon
Lsass
Lsass
servidor
autenticación
seguridad
local
POSIX
interfaz
sistema
operativo
portable
GDI
interfaz
dispositivo
gráfico
DLL
bibliotecas
enlace
dinámicas
Áreas
coloreadas
indican
Sistema
Ejecutivo
Procesos
soporte
sistema
Procesos
servicio
Aplicaciones
Subsistemas
servicio
Gestor
control
servicios
Spooler
Winmgmt.exe
SVChost.exe
Aplicación
usuario
DLL
subsistemas
Win32
Ntdll.dll
Explorador
Windows
Gestor
tareas
Interfaces
llamada
núcleo
Win32
USER
GDI
Controladores
gráficos
Capa
abstracción
hardware
HAL
Cache
sistema
ficheros
Gestor
objetos
Gestor
plug
and
play
Gestor
potencia
Monitor
refencia
seguridad
Memoria
virtual
Procesos
hilos
Gestor
configuración
registro
Llamada
procedimiento
local
POSIX
OS/2
Controladores
dispositivo
sistema
ficheros
Gestor
Núcleo
Services.exe
Figura
2.13
Arquitectura
Windows
2000
SOLO00
02-Capitulo
12/5/05
16:18
Página
85núcleo
kernel
capa
abstracción
hardware
ejecuta
núcleo
software
eje-
cuta
núcleo
acceso
datos
sistema
hardware
resto
software
eje-
cuta
usuario
acceso
limitado
datos
sistema
ORGANIZACIÓN
SISTEMA
OPERATIVO
Windows
arquitectura
micronúcleo
pura
Microsoft
denomina
arquitectura
micronúcleo
modificada
caso
arquitecturas
micronúcleo
puras
Windows
modular
función
sistema
gestiona
único
componente
sistema
operativo
resto
sistema
operativo
aplicaciones
acceden
dicha
función
componen-
responsable
utilizando
interfaz
estándar
acceder
datos
sistema
claves
función
apropiada
principio
borrar
actualizar
reemplazar
módu-
reescribir
sistema
completo
interfaz
programa
aplicación
API
di-
ferencia
sistema
micronúcleo
puro
Windows
configura
forma
funcio-
nes
sistema
externas
micronúcleo
ejecutan
núcleo
razón
reside
rendimiento
desarrolladores
Windows
descubrieron
utilizando
técnica
micronúcleo
pura
funciones
micronúcleo
requerían
intercambios
procesos
hilos
cambios
buffers
memoria
extra
componentes
núcleo
siguientes
Sistema
ejecutivo
Contiene
servicios
básicos
sistema
operativo
gestión
memoria
gestión
procesos
hilos
seguridad
comunicación
procesos
Núcleo
formado
componentes
fundamentales
sistema
operativo
nú-
cleo
gestiona
planificación
hilos
intercambio
procesos
excepciones
manejo
interrupciones
sincronización
multiprocesadores
diferencia
resto
sistema
ejecutivo
nivel
usuario
código
núcleo
ejecuta
hilos
úni-
ca
sistema
operativo
expulsable
paginable
Capa
abstracción
hardware
HAL
Hardware
Abstraction
Layer
Realiza
pro-
yección
mandatos
respuestas
hardware
genéricos
plataforma
específica
Aísla
sistema
operativo
diferencias
hardware
específicas
plataforma
HAL
bus
sistema
controlador
acceso
memoria
directa
DMA
controlador
interrupciones
temporizadores
sistema
módulos
me-
moria
máquina
parezcan
núcleo
entrega
soporte
necesario
multiprocesamiento
simétrico
SMP
explicado
anteriormente
Controladores
dispositivo
Incluye
sistemas
ficheros
controladores
dis-
positivos
hardware
traducen
funciones
usuario
peticiones
específicas
dis-
positivos
hardware
S.
Gestión
ventanas
sistemas
gráficos
Implementa
funciones
interfaz
gráfica
usuario
GUI
tales
gestión
ventanas
controles
interfaz
usuario
dibujo
sistema
ejecutivo
Windows
incluye
módulos
funciones
sistema
específicas
pro-
porciona
API
software
usuario
continuación
describen
mó-
dulos
sistema
ejecutivo
Gestor
S.
Proporciona
entorno
aplicaciones
acceder
dispositivos
S.
gestor
responsable
enviar
petición
controlador
dispositivo
apropiado
procesamiento
posterior
gestor
implementa
API
Windows
provee
seguridad
nombrado
dispositivos
sistemas
fiche-
ros
utilizando
gestor
objetos
Windows
discute
Capítulo
11
86
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
86•
Gestor
cache
Mejora
rendimiento
basada
ficheros
provocando
da-
tos
disco
referenciados
recientemente
residan
memoria
principal
acceso
rápido
retardando
escrituras
disco
mantenimiento
actualizaciones
me-
moria
periodo
corto
tiempo
enviarlas
disco
Gestor
objetos
Crea
gestiona
borra
objetos
sistema
ejecutivo
Windows
tipos
datos
abstractos
utilizados
representar
recursos
procesos
hilos
objetos
sincronización
Provee
reglas
uniformes
mantener
control
nombrado
configura-
ción
seguridad
objetos
gestor
objetos
crea
manejadores
objetos
formados
información
control
acceso
puntero
objeto
objetos
Windows
discuten
posteriormente
sección
Gestor
plug
and
play
Determina
controladores
necesitan
determinado
dis-
positivo
carga
dichos
controladores
Gestor
potencia
Coordina
gestión
potencia
dispositivos
con-
figurar
reducir
consumo
potencia
hibernando
procesador
Monitor
referencia
seguridad
Asegura
validación
acceso
reglas
generación
auditoría
modelo
orientado
objetos
Windows
proporciona
visión
seguridad
con-
sistente
uniforme
especificando
entidades
fundamentales
constituyen
sistema
ejecuti-
vo
Windows
utiliza
rutinas
validación
acceso
comprobaciones
auditoria
objetos
protegidos
incluyendo
ficheros
procesos
espacios
direc-
ciones
dispositivos
S.
seguridad
Windows
discute
Capítulo
15
Gestor
memoria
virtual
Proyecta
direcciones
virtuales
espacio
direcciones
proceso
páginas
físicas
memoria
computador
gestión
memoria
virtual
Windows
describe
Capítulo
Gestor
procesos
hilos
Crea
borra
objetos
traza
comportamiento
objetos
proceso
hilo
gestión
procesos
hilos
Windows
describe
Capítulo
Gestor
configuración
responsable
implementar
gestionar
registro
sistema
repositorio
configuración
parámetros
nivel
sistema
global
usuario
Utilidad
llamada
procedimiento
local
LPC
Local
Procedure
Call
Fuerza
rela-
ción
cliente
servidor
aplicaciones
subsistemas
ejecutivos
único
sis-
tema
similar
utilidad
llamada
procedimiento
remoto
RPC
Remote
Procedure
Call
utilizada
procesamiento
distribuido
PROCESOS
USUARIO
tipos
básicos
procesos
usuario
Windows
Procesos
sistema
especiales
Incluye
servicios
proporcionados
sistema
operativo
Windows
proceso
inicio
gestor
sesiones
Procesos
servicio
servicios
Windows
ejemplo
registro
eventos
Subsistemas
entorno
Expone
servicios
nativos
Windows
aplicaciones
usuario
proporciona
entorno
personalidad
sistema
operativo
subsiste-
soportados
Win32
Posix
OS/2
subsistema
entorno
incluye
bibliotecas
enlace
dinámico
Dynamic
Link
Libraries
DLL
convierten
llamadas
aplicación
usuario
llamadas
Windows
Aplicaciones
usuario
tipos
Win32
Posix
OS/2
Windows
3.1
MS-DOS
Introducción
sistemas
operativos
87
02-Capitulo
12/5/05
16:18
Página
87Windows
estructurado
soportar
aplicaciones
escritas
Windows
2000
versiones
posteriores
Windows
98
sistemas
operativos
Windows
proporcionan
soporte
utilizando
sistema
ejecutivo
compacto
subsistemas
entorno
protegidos
subsistemas
protegidos
partes
Windows
interactúan
usuario
subsistema
proceso
separado
sistema
ejecutivo
protege
espacio
direcciones
resto
subsiste-
aplicaciones
subsistema
protegido
proporciona
interfaz
usuario
gráfica
línea
mandatos
define
aspecto
sistema
operativo
usuario
Adicionalmente
sub-
sistema
protegido
proporciona
API
entorno
operativo
particular
significa
aplicaciones
creadas
entorno
operativo
particular
ejecutar-
cambio
Windows
interfaz
sistema
operativo
ven
escrito
forma
ejemplo
aplicaciones
basadas
OS/2
ejecutar
sistema
operativo
Windows
modificación
sistema
Windows
diseñado
independiente
plataforma
capa
abstracción
hardware
HAL
debería
relativamente
fácil
portar
subsistemas
protegi-
aplicaciones
soportadas
plataforma
hardware
casos
requiere
recompilar
subsistema
importante
Win32
Win32
API
implementada
Windows
2000
versiones
posteriores
Windows
98
características
Win32
dispo-
nibles
Windows
98
características
implementadas
Windows
98
idénticas
aqué-
llas
Windows
2000
posteriores
versiones
MODELO
CLIENTE
SERVIDOR
sistema
ejecutivo
subsistemas
protegidos
aplicaciones
estructuran
mode-
computación
cliente
servidor
modelo
común
computación
distribuida
discute
sexta
arquitectura
adoptar
interno
sis-
tema
caso
Windows
subsistema
entorno
subsistema
servicio
ejecutivo
implementa
procesos
proceso
espera
solicitud
cliente
servicios
ejemplo
servi-
cios
memoria
servicios
creación
procesos
servicios
planificación
procesadores
cliente
programa
módulo
sistema
operativo
solicita
servicio
envío
mensaje
mensaje
encamina
sistema
ejecutivo
servidor
apropiado
servidor
cabo
operación
requerida
devuelve
resultados
información
mensaje
encamina
vuelta
cliente
servicio
ejecutivo
ventajas
arquitectura
cliente
servidor
siguientes
Simplifica
sistema
ejecutivo
construir
diversos
API
conflictos
duplicacio-
nes
sistema
ejecutivo
añadir
fácilmente
interfaces
Mejora
fiabilidad
módulo
servicios
ejecutivos
ejecuta
proceso
se-
parado
partición
memoria
protegida
módulos
clientes
acceder
directamente
hardware
modificar
zona
memoria
al-
macena
sistema
ejecutivo
único
servidor
fallar
provocar
fallo
corromper
resto
sistema
operativo
Proporciona
aplicaciones
maneras
uniformes
comunicarse
sistema
ejecutivo
LPC
restringir
flexibilidad
aplicaciones
cliente
esconden
proceso
paso
mensajes
resguardos
funciones
contenedores
ejecutables
al-
macenados
bibliotecas
enlace
dinámicas
Dynamic
Link
Libraries
DLL
88
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
88aplicación
realiza
llamada
interfaz
subsistema
entorno
resguardo
apli-
cación
cliente
empaqueta
parámetros
llamada
envía
mensaje
sub-
sistema
servidor
implementa
llamada
Proporciona
base
adecuada
computación
distribuida
Normalmente
computa-
ción
distribuida
utiliza
modelo
cliente
servidor
llamadas
procedimientos
remotos
im-
plementadas
utilizando
módulos
distribuidos
cliente
servidor
intercambio
mensajes
clientes
servidores
Windows
servidor
local
pasar
mensaje
servi-
dor
remoto
procesamiento
nombre
aplicaciones
locales
cliente
clientes
necesitan
petición
atendida
local
remotamente
petición
atiende
forma
local
remota
cambiar
dinámicamente
condiciones
carga
actuales
cambios
dinámicos
configuración
HILOS
SMP
características
importantes
Windows
soporte
hilos
SMP
ambas
caracte-
rísticas
presentadas
Sección
2.4
CUST93
enumera
siguientes
características
Windows
soporte
hilos
SMP
rutinas
sistema
operativo
ejecutar
procesador
disponible
di-
ferentes
rutinas
ejecutar
simultáneamente
procesadores
Windows
permite
múltiple
hilos
ejecución
único
proceso
Múltiples
hilos
proceso
ejecutar
procesadores
simultáneamente
procesos
servidor
utilizar
múltiples
hilos
procesar
peticiones
cliente
simultáneamente
Windows
proporciona
mecanismos
compartir
datos
recursos
procesos
capacida-
des
flexibles
comunicación
procesos
OBJETOS
WINDOWS
Windows
apoya
enormemente
conceptos
diseño
orientado
objetos
enfoque
facili-
ta
compartición
recursos
datos
procesos
protección
recursos
frente
acceso
autorizado
conceptos
clave
diseño
orientado
objetos
utilizados
Windows
en-
cuentran
siguientes
Encapsulación
objeto
compuesto
elementos
información
denomi-
nados
atributos
procedimientos
cabo
datos
de-
nominados
servicios
única
forma
acceder
datos
objeto
invocando
servicios
objeto
datos
objeto
proteger
fácilmente
autorizado
incorrecto
ejemplo
intentando
ejecutar
pieza
datos
ejecutable
Clases
instancias
objetos
clase
objeto
plantilla
lista
atributos
servicios
objeto
define
características
objetos
sistema
operativo
crear
instancias
específicas
clase
objetos
necesite
ejemplo
única
clase
objeto
proceso
objeto
proceso
proceso
actualmente
ac-
tivo
enfoque
simplifica
creación
gestión
objetos
Herencia
característica
soportada
nivel
usuario
extensión
sistema
ejecutivo
ejemplo
objetos
directorio
ejemplos
objeto
conte-
nedor
propiedad
objeto
contenedor
objetos
contiene
heredar
Introducción
sistemas
operativos
89
02-Capitulo
12/5/05
16:18
Página
89propiedades
contenedor
ejemplo
supongamos
directorio
sistema
ficheros
comprimido
fichero
cree
contenedor
directorio
comprimido
Polimorfismo
Internamente
Windows
utiliza
conjunto
común
funciones
manipu-
lar
objetos
tipo
característica
polimorfismo
define
Apéndice
B.
Windows
completamente
polimórfico
mu-
chas
API
específicas
tipos
objetos
específicos
lector
esté
familiarizado
conceptos
orientados
objetos
revisar
Apéndi-
ce
libro
entidades
Windows
objetos
objetos
utilizan
casos
datos
usuario
acceso
datos
compartido
restringido
entida-
des
representadas
objetos
encuentran
ficheros
procesos
hilos
semáforos
temporizado-
res
ventanas
Windows
crea
gestiona
tipos
objetos
forma
uniforme
gestor
objetos
gestor
objetos
responsable
crear
destruir
objetos
nombre
aplicaciones
garantizar
acceso
servicios
datos
objetos
objeto
sistema
ejecutivo
denominado
objeto
núcleo
dis-
tinguirlo
objetos
nivel
usuario
objetos
gestionados
sistema
ejecutivo
bloque
memoria
gestionado
núcleo
accesible
nú-
cleo
elementos
estructura
datos
ejemplo
nombre
objeto
parámetros
seguridad
contabilidad
comunes
tipos
objetos
elemen-
tos
específicos
tipo
objeto
particular
ejemplo
prioridad
objeto
hilo
núcleo
acceder
estructuras
datos
objetos
núcleo
imposible
aplicación
encuentre
estructuras
datos
lea
escriba
directamente
lugar
apli-
caciones
manipulan
objetos
indirectamente
conjunto
funciones
manipulación
objetos
soportado
sistema
ejecutivo
crea
objeto
aplicación
solicita
creación
recibe
manejador
objeto
Esencialmente
manejador
puntero
objeto
refe-
renciado
hilo
utilizar
manejador
proceso
invocar
funciones
Win32
trabajan
objetos
objetos
información
seguridad
asociada
forma
descrip-
tor
seguridad
Security
Descriptor
SD
información
seguridad
utilizar
res-
tringir
acceso
objeto
ejemplo
proceso
crear
objeto
semáforo
objetivo
usuarios
capaces
abrir
utilizar
semáforo
SD
objeto
se-
máforo
compuesto
lista
usuarios
acceder
objeto
semáforo
conjunto
accesos
permitidos
lectura
escritura
cambio
etc.
Windows
objetos
nombre
proceso
crea
objeto
nom-
bre
gestor
objetos
devuelve
manejador
objeto
manejador
única
forma
referirse
objetos
nombre
referenciados
procesos
nom-
bre
ejemplo
proceso
desea
sincronizarse
proceso
crear
objeto
tipo
evento
nombre
pasar
nombre
evento
B.
proceso
abrir
utilizar
objeto
evento
simplemente
deseara
utilizar
evento
sincronizar
hilos
proceso
crearía
objeto
evento
nombre
necesita
procesos
pue-
utilizar
evento
ejemplo
objetos
gestionados
Windows
continuación
listan
catego-
rías
objetos
gestiona
núcleo
Objetos
control
Utilizados
controlar
operaciones
núcleo
áreas
corres-
ponden
planificación
sincronización
Tabla
2.5
lista
objetos
control
núcleo
90
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
90Introducción
sistemas
operativos
91
Objetos
dispatcher
Controla
activación
sincronización
operaciones
sistema
objetos
describen
Capítulo
abla
2.5
Objetos
control
micronúcleo
Windows
MS96
Llamada
procedimiento
Utilizado
romper
ejecución
hilo
específico
provocar
asíncrono
llame
procedimiento
procesador
especificado
Interrupción
Utilizado
conectar
origen
interrupción
rutina
servi-
cio
interrupciones
entrada
tabla
IDT
Inte-
rrupt
Dispatch
Table
procesador
tabla
IDT
utiliza
entregar
interrupciones
ocurren
procesador
Proceso
Representa
espacio
direcciones
virtuales
información
control
necesaria
ejecución
conjunto
objetos
hilo
proceso
contiene
puntero
mapa
direcciones
lista
hilos
listos
ejecutar
contiene
objetos
hilo
lista
hilos
pertene-
cen
proceso
tiempo
acumulado
hilos
ejecuten
proceso
prioridad
base
Perfil
Utilizado
medir
distribución
tiempo
ejecución
bloque
código
medir
perfil
código
usua-
rio
sistema
Windows
sistema
operativo
completamente
orientado
objetos
implementado
lenguaje
orientado
objetos
estructuras
datos
residen
completamente
componente
sistema
ejecutivo
representadas
objetos
Windows
muestra
potencia
tecnología
orientada
objetos
representa
tendencia
signi-
ficativa
tecnología
diseño
sistemas
operativos
2.6
SISTEMAS
UNIX
TRADICIONALES
HISTORIA
historia
UNIX
relato
narrado
frecuencia
repetirá
detalles
contrario
realizará
resumen
UNIX
desarrolló
inicialmente
laboratorios
Bell
operacional
PDP-7
1970
personas
relacionadas
laboratorios
Bell
participa-
do
trabajo
tiempo
compartido
desarrollado
proyecto
MAC
MIT
proyecto
encargó
desarrollo
CTSS
Multics
habitual
UNIX
original
versión
recortada
Multics
desarrolladores
UNIX
realmente
dije-
ron
influenciados
CTSS
RITC78
obstante
UNIX
incorporó
ideas
Multics
trabajo
UNIX
laboratorios
Bell
instituciones
produjo
con-
versiones
UNIX
hito
notable
portar
sistema
UNIX
PDP-7
PDP-11
pista
UNIX
sistema
operativo
computa-
dores
hito
importante
reescritura
UNIX
lenguaje
programación
C.
estrategia
precedentes
tiempo
pensaba
complejo
sistema
operativo
tratar
eventos
críticos
tiempo
debía
escribirse
exclusivamente
lenguaje
ensamblador
implementación
demostró
ventajas
utilizar
lenguaje
alto
ni-
vel
mayoría
código
sistema
prácticamente
implementaciones
UNIX
escritas
C.
02-Capitulo
12/5/05
16:18
Página
91Estas
primeras
versiones
UNIX
populares
laboratorios
Bell
1974
sistema
UNIX
describió
revista
técnica
RITC74
despertó
interés
sistema
proporcionaron
licencias
UNIX
instituciones
comerciales
universidades
versión
completamente
disponible
laboratorios
Bell
Ver-
sión
1976
versión
Versión
aparecida
1978
antecesora
siste-
UNIX
modernos
sistema
importante
vinculado
AT&T
desarrolló
Universidad
California
Berkeley
llamó
UNIX
BSD
Berkeley
Software
Distribution
eje-
cutándose
PDP
máquinas
AX
AT&T
continuó
desarrollando
refinando
sistema
1982
laboratorios
Bell
combinaron
diversas
variantes
AT&T
UNIX
único
sistema
denominado
comercialmente
UNIX
System
III
número
características
añadieron
posteriormente
sistema
operativo
producir
UNIX
System
DESCRIPCIÓN
Figura
2.14
proporciona
descripción
general
arquitectura
UNIX
hardware
subyacente
gestionado
software
sistema
operativo
sistema
operativo
denomina
frecuentemente
núcleo
sistema
simplemente
núcleo
destacar
aislamiento
frente
usuarios
aplicaciones
porción
UNIX
conocerá
UNIX
libro
UNIX
viene
equipado
conjunto
servicios
usuario
interfaces
consideran
sistema
agrupar
shell
software
interfaz
componentes
compilador
compilador
ensamblador
cargador
capa
externa
formada
aplicacio-
nes
usuario
interfaz
usuario
compilador
C.
Figura
2.15
muestra
vista
cercana
núcleo
programas
usuario
invo-
car
servicios
sistema
operativo
directamente
programas
biblioteca
interfaz
llamada
sistemas
frontera
usuario
permite
software
alto
nivel
obtenga
ac-
ceso
funciones
específicas
núcleo
extremo
sistema
operativo
contiene
rutinas
pri-
mitivas
interaccionan
directamente
hardware
interfaces
sistema
divi-
92
Sistemas
operativos
Aspectos
internos
principios
diseño
Hardware
Núcleo
Interfaz
llamada
sistema
Comandos
bibliotecas
UNIX
Aplicaciones
escritas
usuario
Figura
2.14
Arquitectura
general
UNIX
02-Capitulo
12/5/05
16:18
Página
92de
partes
principales
encargada
control
procesos
encargada
gestión
ficheros
S.
subsistema
control
procesos
encarga
gestión
memoria
planificación
ejecución
procesos
sincronización
comunicación
procesos
sistema
ficheros
intercambia
datos
memoria
dispositivos
externos
flujos
caracteres
bloques
lograr
utilizan
variedad
controla-
dores
dispositivos
transferencias
orientadas
bloques
utiliza
técnica
cache
discos
espacio
direccionamiento
usuario
dispositivo
externo
interpone
buf-
fer
sistema
memoria
principal
descripción
subsección
refiere
denominado
sistemas
UNIX
tradicio-
nales
AHA96
utiliza
término
referirse
System
Versión
SVR3
System
Release
4.3BSD
versiones
anteriores
siguientes
sentencias
generales
afirmarse
sis-
tema
UNIX
tradicional
diseñaron
ejecutar
único
procesador
carecen
capaci-
dad
proteger
estructuras
datos
acceso
concurrente
múltiples
procesadores
núcleo
versátil
soportando
único
tipo
sistema
ficheros
única
política
planificación
procesos
único
formato
fichero
ejecutable
núcleo
tradicional
UNIX
diseñado
extensible
utilidades
reutilización
código
resultado
iban
añadiendo
características
versiones
UNIX
aña-
dir
código
proporcionando
núcleo
tamaño
modular
Introducción
sistemas
operativos
93
Hardware
Nivel
hardware
Nivel
núcleo
Nivel
núcleo
Nivel
usuario
Programas
usuario
Trap
Control
hardware
Interfaz
llamadas
sistema
Bibliotecas
Controladores
dispositivos
Subsistema
fichero
Subsistema
control
procesos
Carácter
Bloque
Cache
Buffer
Comunicación
procesos
Planificador
Gestión
memoria
Figura
2.15
Núcleo
tradicional
UNIX
BACH86
02-Capitulo
12/5/05
16:18
Página
932.7
SISTEMAS
UNIX
MODERNOS
UNIX
evolucionó
número
implementaciones
proliferó
proporcionó
características
útiles
necesaria
producción
imple-
mentación
unificara
importantes
innovaciones
añadiera
características
di-
seño
sistemas
operativos
modernos
produjera
arquitectura
modular
arquitectura
mostrada
Figura
2.16
muestra
aspectos
típicos
núcleo
UNIX
moderno
pe-
queño
núcleo
utilidades
escritas
forma
modular
proporciona
funciones
servicios
necesa-
rios
procesos
sistema
operativo
círculos
externos
representa
funciones
interfaz
implementarse
formas
verán
ejemplos
sistemas
UNIX
modernos
SYSTEM
RELEASE
SVR4
SVR4
desarrollado
conjuntamente
AT&T
Sun
Microsistemas
combina
características
SVR3
4.3BSD
Microsoft
Xenix
System
SunOS
reescritura
completa
núcleo
94
Sistemas
operativos
Aspectos
internos
principios
diseño
Utilidades
comunes
Entorno
memoria
virtual
Intercambiador
dispositivo
bloques
Intercambiador
ejecución
a.out
Proyecciones
fichero
Controlador
disco
Controlador
cinta
Controlador
red
Controlador
terminal
Procesos
sistema
Procesos
tiempo
compartido
RFS
s5fs
FFS
NFS
Proyecciones
anónimas
coff
elf
Flujos
Interfaz
vnode
vfs
Entorno
planificación
Proyecciones
fichero
Figura
2.16
Núcleo
UNIX
moderno
VAHA96
02-Capitulo
12/5/05
16:18
Página
94System
produjo
implementación
organizada
compleja
característi-
cas
versión
incluyen
soporte
procesamiento
tiempo
real
clases
planificación
pro-
cesos
estructuras
datos
dinámicamente
asignadas
gestión
memoria
virtual
sistema
fiche-
ros
virtual
núcleo
expulsivo
SVR4
mezcló
esfuerzos
diseñadores
comerciales
académicos
desarrolló
proporcionar
plataforma
uniforme
permitiera
despegue
comercial
UNIX
Logró
ob-
jetivo
variantes
importantes
UNIX
Incorpora
mayoría
caracte-
rísticas
importantes
desarrolladas
sistema
UNIX
forma
integrada
co-
mercialmente
viable
SVR4
ejecuta
rango
máquinas
microprocesadores
32
bits
supercomputadores
ejemplos
UNIX
libro
ejemplos
SVR4
SOLARIS
Solaris
versión
UNIX
Sun
basada
SVR4
versión
proporciona
características
SVR4
conjunto
características
avanzadas
núcleo
multihilo
completamente
expulsivo
soporte
completo
SMP
interfaz
orientada
objetos
sistemas
ficheros
Solaris
implementación
UNIX
utilizada
comercialmente
exito-
sa
características
sistemas
operativos
utiliza
Solaris
ejemplo
libro
4.4BSD
series
UNIX
BSD
Berkeley
Software
Distribution
jugado
papel
importante
de-
sarrollo
teoría
diseño
sistemas
operativos
4.xBSD
utilizado
ampliamente
ins-
talaciones
académicas
servido
base
productos
comerciales
UNIX
probable
BSD
seguramente
responsable
popularidad
UNIX
mayoría
mejoras
UNIX
aparecieron
lugar
versiones
BSD
4.4BSD
versión
BSD
Berkeley
produjo
disolviéndose
posteriormente
orga-
nización
encargada
diseño
implementación
actualización
importante
4.3BSD
incluye
sistema
memoria
virtual
cambios
estructura
núcleo
larga
lista
mejoras
versión
sistema
operativo
Macintosh
Mac
basa
4.4BSD
2.8
LINUX
HISTORIA
Linux
comenzó
variante
UNIX
arquitectura
PC
IBM
Intel
80386
Linus
Tor-
valds
estudiante
finlandés
informática
escribió
versión
inicial
Torvalds
distribuyó
In-
ternet
versión
Linux
1991
personas
colaborando
In-
ternet
contribuido
desarrollo
Linux
control
Torvalds
Linux
libre
código
fuente
disponible
convirtió
alternativa
estaciones
trabajo
UNIX
ofrecidas
Sun
Microsystems
IBM
Linux
siste-
ma
UNIX
completo
ejecuta
plataformas
incluyendo
Intel
Pentium
Itanium
PowerPC
Motorota
IBM
Introducción
sistemas
operativos
95
02-Capitulo
12/5/05
16:18
Página
95La
clave
éxito
Linux
disponibilidad
paquetes
software
libre
auspicios
Fundación
Software
Libre
Free
Software
Foundation
FSF
fundación
centra
software
estable
independiente
plataforma
alta
calidad
soportado
co-
munidad
usuarios
proyecto
GNU
proporciona
herramientas
desarrolladores
soft-
ware
licencia
pública
GNU
GPL
GNU
Public
License
sello
aprobación
FSF
Tor-
vald
utilizó
herramientas
GNU
desarrollo
núcleo
posteriormente
distribuido
licencia
GPL
distribuciones
Linux
aparecen
productos
proyecto
GNU
FSF
esfuerzos
individuales
Torvalds
colaboradores
lar-
go
mundo
programadores
individuales
Linux
penetra-
ción
significativa
mundo
corporativo
software
libre
calidad
núcleo
Linux
programadores
talento
contribuido
versión
actual
dando
lugar
producto
técnicamente
impresionante
Linux
modular
fácilmente
configurable
Resulta
óptimo
incrementar
rendimiento
variedad
plataformas
hard-
ware
código
fuente
disponible
distribuidores
adaptar
aplicaciones
facilidades
cumplir
requisitos
específicos
libro
proporcionarán
deta-
lles
internos
núcleo
Linux
ESTRUCTURA
MODULAR
mayoría
núcleos
Linux
monolíticos
anteriormente
capítulo
núcleo
monolítico
incluye
prácticamente
funcionalidad
sistema
operativo
bloque
código
ejecuta
único
proceso
único
espacio
direcciona-
miento
componentes
funcionales
núcleo
acceso
estructuras
internas
datos
rutinas
cambios
porción
sistema
operativo
monolíti-
co
módulos
rutinas
volverse
enlazar
reinstalar
sistema
reiniciado
cambios
tengan
efecto
resultado
modificación
ejemplo
aña-
dir
controlador
dispositivo
función
sistema
fichero
difícil
problema
especialmente
agudo
Linux
cuyo
desarrollo
global
grupo
pro-
gramadores
independientes
asociados
forma
difusa
Linux
utiliza
técnica
micronúcleo
logra
ventajas
potenciales
técnica
arquitectura
modular
particular
Linux
estructurado
colec-
ción
módulos
cargarse
descargarse
automáticamente
deman-
bloques
relativamente
independientes
denominan
módulos
cargables
GOYE99
Esen-
cialmente
módulo
fichero
cuyo
código
enlazarse
desenlazarse
núcleo
tiempo
real
Normalmente
módulo
implementa
funciones
específicas
sistema
ficheros
controlador
dispositivo
características
capa
superior
núcleo
módulo
ejecuta
proceso
hilo
crear
hilos
núcleo
ne-
cesite
propósitos
lugar
módulo
ejecuta
núcleo
nombre
proce-
so
actual
Linux
considerar
monolítico
estructura
modular
elimina
dificultades
desarrollar
evolucionar
núcleo
módulos
cargables
Linux
características
importantes
Enlace
dinámico
módulo
núcleo
cargarse
enlazarse
núcleo
nú-
cleo
memoria
ejecutándose
módulo
desenlazarse
eliminarse
memoria
momento
96
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
96•
Módulos
apilables
módulos
gestionan
jerarquía
módulos
individuales
sirven
bibliotecas
módulos
cliente
referencian
superior
jerarquía
actúan
clientes
referencian
módulos
inferior
jerarquía
enlace
dinámico
FRAN97
facilita
configuración
reduce
memoria
núcleo
Linux
programa
usuario
usuario
cargar
descargar
explícitamente
módulos
núcleo
utilizando
mandatos
insmod
rmmod
núcleo
detecta
necesidad
funciones
particulares
cargar
descargar
módulos
necesite
módulos
apilables
pue-
den
definir
dependencias
módulos
ventajas
código
común
conjunto
módulos
similares
ejemplo
controladores
hardware
similar
mover
único
módulo
reduciendo
replicación
núcleo
asegurar
módulos
necesarios
presentes
impidiendo
descargar
módulo
módulos
ejecutan
dependen
cargando
módulos
adicio-
nalmente
requeridos
carga
módulo
Figura
2.17
ejemplo
ilustra
estructuras
utilizadas
Linux
gestionar
mó-
dulos
figura
muestra
lista
módulos
núcleo
mó-
dulos
cargados
FAT
VFAT
módulo
define
tablas
tabla
módu-
tabla
símbolos
tabla
módulos
incluye
siguientes
elementos
next
Puntero
módulo
módulos
organizan
lista
enlazada
lista
comienza
pseudomódulo
mostrado
Figura
2.17
name
Puntero
nombre
módulo
size
Tamaño
módulo
páginas
memoria
usecount
Contador
módulo
contador
incrementa
operación
rela-
cionada
funciones
módulo
comienza
decrementa
operación
finaliza
flags
Opciones
módulo
nsyms
Número
símbolos
exportados
ndeps
Número
módulos
referenciados
syms
Puntero
tabla
símbolos
módulo
deps
Puntero
lista
módulos
referenciados
módulo
refs
Puntero
lista
módulos
módulo
tabla
símbolos
define
símbolos
controlados
módulo
utilizan
sitios
Figura
2.17
muestra
módulo
VFAT
carga
módulo
FAT
módulo
VFAT
dependiente
módulo
FAT
COMPONENTES
NÚCLEO
Figura
2.18
tomada
MOSB02
muestra
principales
componentes
núcleo
Linux
implementados
arquitectura
IA-64
ejemplo
Intel
Itanium
figura
muestra
Introducción
sistemas
operativos
97
02-Capitulo
12/5/05
16:18
Página
97varios
procesos
ejecutando
núcleo
caja
indica
proceso
separado
línea
curvada
cabeza
flecha
representa
hilo
ejecución
núcleo
compuesto
colección
componentes
interaccionan
usando
flechas
indicar
principales
interacciones
muestra
hardware
subyacente
conjunto
componentes
utilizando
flechas
indicar
componentes
núcleo
utilizan
controlan
componentes
hardware
componentes
núcleo
ejecutan
CPU
simplicidad
muestran
relaciones
Brevemente
principales
componentes
núcleo
siguientes
Señales
núcleo
utiliza
señales
llamar
proceso
ejemplo
señales
uti-
lizan
notificar
fallos
proceso
ejemplo
división
cero
Ta-
bla
2.6
ejemplos
señales
Llamadas
sistema
llamada
sistema
forma
proceso
requiere
servicio
núcleo
específico
cientos
llamadas
sistema
agrupar-
básicamente
categorías
sistema
ficheros
proceso
planificación
comunicación
procesos
socket
red
misceláneos
Tabla
2.7
define
ejemplos
categoría
98
Sistemas
operativos
Aspectos
internos
principios
diseño
FAT
syms
deps
refs
ndeps
nysms
flags
usecount
size
name
next
value
name
value
tabla
símbolos
name
value
name
value
name
value
name
value
name
VFAT*syms
deps
refs
ndeps
nysms
flags
usecount
size
name
next
módulo
módulo
tabla
símbolos
Figura
2.17
Lista
ejemplo
módulos
núcleo
Linux
Linux
distinción
conceptos
proceso
hilo
múltiples
hilos
Linux
agrupar
forma
efectivamente
existir
único
proceso
compuesto
múltiples
hilos
aspectos
discuten
Capítulo
02-Capitulo
12/5/05
16:18
Página
98•
Procesos
planificador
Crea
gestiona
planifica
procesos
Memoria
virtual
Asigna
gestiona
memoria
virtual
procesos
Sistemas
ficheros
Proporciona
espacio
nombres
global
jerárquico
fiche-
ros
directorios
objetos
relacionados
ficheros
proporciona
funcio-
nes
sistema
ficheros
Protocolos
red
soporte
interfaz
Socket
usuarios
utilizando
pila
pro-
tocolos
TCP
IP
Controladores
dispositivo
tipo
carácter
Gestiona
dispositivos
requiere
núcleo
enviar
recibir
datos
byte
terminales
módems
impresoras
Controladores
dispositivo
tipo
bloque
Gestiona
dispositivos
leen
escriben
datos
bloques
formas
memoria
secundaria
discos
magnéticos
CDROM
etc.
Controladores
dispositivo
red
Gestiona
tarjetas
interfaz
red
puertos
comunicación
permiten
conexiones
red
puentes
encami-
nadores
Traps
fallos
Gestiona
traps
fallos
generados
CPU
fallos
memoria
Memoria
física
Gestiona
conjunto
marcos
páginas
memoria
real
asigna
pá-
ginas
memoria
virtual
Interrupciones
Gestiona
interrupciones
dispositivos
periféricos
Introducción
sistemas
operativos
99
Señales
Llamadas
sistema
Procesos
planificador
Memoria
virtual
Memoria
física
Memoria
sistema
Procesos
Hardware
Nivel
usuarioNúcleo
CPU
erminal
Disco
Interrupciones
fallos
Controladores
dispositivos
orientados
carácter
Controladores
dispositivos
orientados
bloque
Controladores
disposivos
red
Sistemas
ficheros
Protocolos
red
Interrupciones
Controlador
interfaz
red
Figura
2.18
Componentes
núcleo
Linux
02-Capitulo
12/5/05
16:18
Página
99100
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
2.6
señales
Linux
SIGHUP
Desconexión
terminal
SIGCONT
Continuar
SIGQUIT
Finalización
teclado
SIGTSTP
Parada
teclado
SIGTRAP
Traza
SIGTTOU
Escritura
terminal
SIGBUS
Error
bus
SIGXCPU
Límite
CPU
excedido
SIGKILL
Señal
matar
SIGVTALRM
Reloj
alarma
virtual
SIGSEGV
Violación
segmentación
SIGWINCH
Cambio
tamaño
ventana
SIGPIPE
Tubería
rota
SIGPWR
Fallo
potencia
SIGTERM
Terminación
SIGRTMIN
señal
tiempo
real
SIGCHLD
Cambio
hijo
SIGRTMAX
señal
tiempo
real
abla
2.7
.Algunas
llamadas
sistema
Linux
Relacionadas
sistema
ficheros
close
Cierra
descriptor
fichero
link
Construye
nombre
fichero
open
Abre
posiblemente
crea
fichero
dispositivo
read
Lee
descriptor
fichero
write
Escribe
descriptor
fichero
Relacionadas
procesos
execve
Ejecuta
programa
exit
Termina
proceso
invoca
getpid
Obtiene
identificación
proceso
setuid
Establece
identidad
usuario
proceso
actual
prtrace
Proporciona
forma
proceso
padre
observar
controlar
ejecución
proceso
examinar
cambiar
imagen
memoria
registros
Relacionadas
planificación
sched_getparam
Establece
parámetros
planificación
asociados
política
planificación
proceso
identificado
pid
sched_get_priority_max
Devuelve
valor
máximo
prioridad
utilizar
al-
goritmo
planificación
identificado
política
sched_setscheduler
Establece
política
planificación
ejemplo
FIFO
parámetros
asociados
pid
proceso
sched_rr_get_interval
Escribe
estructura
timespec
apuntada
parámetro
tp
cuan-
to
tiempo
round
robin
proceso
pid
sched_yield
proceso
abandonar
procesador
voluntariamente
nece-
sidad
bloquearse
llamada
sistema
proceso
en-
tonces
moverá
cola
prioridad
estática
nue-
vo
proceso
pondrá
ejecución
02-Capitulo
12/5/05
16:18
Página
100Relacionadas
comunicación
procesos
IPC
msgrcv
asigna
estructura
buffer
mensajes
recibir
mensaje
llamada
sistema
lee
mensaje
cola
mensajes
especificada
msqid
buffer
mensajes
nuevamente
creado
semctl
cabo
operación
control
especificada
cmd
conjun-
to
semáforos
semid
semop
cabo
operaciones
determinados
miembros
conjunto
semáforos
semid
shmat
Adjunta
segmento
memoria
compartido
identificado
shmid
segmento
datos
proceso
invoca
shmctl
Permite
usuario
recibir
información
segmento
memoria
compartido
establecer
propietario
grupo
permisos
segmen-
to
memoria
compartido
destruir
segmento
Relacionadas
sockets
red
bind
Asigna
dirección
IP
local
puerto
socket
Devuelve
caso
éxito
-1
caso
error
connect
Establece
conexión
socket
socket
asociado
remo-
to
sockaddr
gethostname
Devuelve
nombre
máquina
local
send
Envia
bytes
buffer
apuntado
msg
socket
setsockopt
Envia
opciones
socket
Misceláneos
create_module
Intenta
crear
entrada
módulo
cargable
reservar
memoria
núcleo
necesario
contener
módulo
fsync
Copia
partes
memoria
fichero
disco
espera
dispositivo
informa
partes
almace-
namiento
estable
query_module
Solicita
información
relacionada
módulos
cargables
núcleo
time
Devuelve
tiempo
segundos
enero
1970
vhangup
Simula
suspensión
terminal
actual
llamada
sirve
usuarios
puedan
terminal
limpio
tiempo
inicio
2.9
LECTURAS
SITIOS
WEB
RECOMENDADOS
área
arquitectura
computadores
libros
sistemas
operativos
SILB04
NUTT04
TANE01
cubren
principios
básicos
usando
diversos
sistemas
operativos
importantes
casos
estudio
BRIN01
colección
excelente
artículos
cubren
principales
avances
diseño
sistemas
operativos
años
tratamiento
excelente
aspectos
internos
UNIX
proporciona
análisis
compa-
rativo
número
variantes
AHA96
UNIX
SVR4
GOOD94
proporciona
tratamiento
definitivo
amplios
detalles
técnicos
sistema
académicamente
popular
Berke-
ley
UNIX
4.4BSD
MCKU96
altamente
recomendado
MAUR01
proporciona
trata-
Introducción
sistemas
operativos
101
02-Capitulo
12/5/05
16:18
Página
101miento
aspectos
internos
Solaris
tratamientos
aspectos
internos
Linux
recogen
BOVE03
BAR00
incontables
libros
versiones
Windows
curiosamente
mate-
rial
disponible
aspectos
internos
Windows
SOLO00
proporciona
tratamiento
exce-
lente
aspectos
internos
Windows
2000
material
válido
posterio-
res
versiones
BOSW03
cubre
aspectos
internos
Windows
2003
BAR00
Bar
M.
Linux
Internals
New
York
McGraw-Hill
2000
BOSW03
Boswell
W.
Inside
Windows
Server
2003
Reading
MA
Addison-Wesley
2003
BOVE03
Bovet
D.
Cesati
M.
Understanding
the
Linux
Kernel
Sebastopol
CA
O’Reilly
2003
BRIN01
Brinch
Hansen
Classic
Operating
Systems
From
Batch
Processing
to
Distributed
Systems
New
York
Springer-Verlag
2001
GOOD94
Goodheart
B.
Cox
J.
The
Magic
Garden
Explained
The
Internals
of
UNIX
System
Relea-
Englewood
Cliffs
NJ
Prentice
Hall
1994
MAUR01
Mauro
J.
McDougall
R.
Solaris
Internals
Core
Kernel
Architecture
Palo
Alto
CA
Sun
Mi-
crosystems
Press
2001
MCKU96
McKusick
M.
Bostic
K.
Karels
M.
Quartermain
J.
The
Design
and
Implementation
of
the
4.4BSD
UNIX
Operating
System
Reading
MA
Addison-Wesley
1996
NUTT04
Nutt
G.
Operating
System
Reading
MA
Addison-Wesley
2004
SILB04
Silberschatz
A.
Galvin
Gagne
G.
Operating
System
Concepts
with
Java
Reading
MA
Addison-Wesley
2004
SOLO00
Solomon
D.
Inside
Microsoft
Windows
2000
Redmond
WA
Microsoft
Press
2000
TANE01
Tanenbaum
A.
Modern
Operating
Systems
Upper
Saddle
River
NJ
Prentice
Hall
2001
VAHA96
Vahalia
U.
UNIX
Internals
The
New
Frontiers
Upper
Saddle
River
NJ
Prentice
Hall
1996
SITIOS
WEB
RECOMENDADOS
centro
recursos
sistema
operativo
colección
útil
documentos
artículos
amplio
rango
temas
sistemas
operativos
Revisión
sistemas
operativos
extensa
revisión
sistemas
operativos
comercia-
libres
investigación
aficionados
Comparación
técnica
sistemas
operativos
Incluye
cantidad
sustancial
infor-
mación
variedad
sistemas
operativos
Grupo
especial
interés
ACM
sistemas
operativos
Información
publica-
ciones
conferencias
SIGOPS
Comité
Técnico
IEEE
sistemas
operativos
entornos
aplicación
Incluye
boletín
línea
enlaces
sitios
FAQ
comp.os.research
FAQ
amplio
válido
cubre
aspectos
diseño
siste-
operativos
102
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
102•
Universo
Guru
UNIX
Fuente
excelente
información
UNIX
Proyecto
documentación
Linux
nombre
describe
sitio
2.10
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
Contexto
ejecución
Monitor
Procesamiento
serie
Dirección
física
Monitor
residente
Proceso
Dirección
real
Monoprogramación
Round-robin
turno
rotatorio
Dirección
virtual
Multihilo
Sistema
batch
lotes
proceso
Multiprocesamiento
simétrico
Sistema
batch
lotes
multiprogramado
Gestión
memoria
Multiprogramación
Sistema
tiempo
compartido
Hilo
Multitarea
Sistema
operativo
Interrupción
Núcleo
Trabajo
Instrucción
privilegiada
Núcleo
monolítico
Tarea
Lenguaje
control
trabajos
Planificación
Tiempo
compartido
Micronúcleo
Procesamiento
batch
lotes
CUESTIONES
REPASO
2.1
objetivos
diseño
sistema
operativo
2.2
núcleo
sistema
operativo
2.3
multiprogramación
2.4
proceso
2.5
utiliza
sistema
operativo
contexto
ejecución
proceso
2.6
Liste
explique
brevemente
responsabilidades
relacionadas
gestión
alma-
cenamiento
sistema
operativo
típico
2.7
Explique
distinción
dirección
real
dirección
virtual
2.8
Describa
técnica
planificación
round-robin
turno
rotatorio
2.9
Explique
diferencia
núcleo
monolítico
micronúcleo
2.10
consiste
multihilos
multithreading
PROBLEMAS
2.1
Supóngase
computador
multiprogramado
trabajo
ca-
racterísticas
idénticas
periodo
computación
trabajo
gasta
mitad
tiem-
po
mitad
actividad
procesador
trabajo
ejecuta
Introducción
sistemas
operativos
103
02-Capitulo
12/5/05
16:18
Página
103periodos
Asúmase
utiliza
planificación
round-robin
simple
operacio-
nes
solapar
operaciones
procesador
Defina
siguientes
cantidades
Tiempo
servicio
Tiempo
real
completar
trabajo
Productividad
Número
trabajos
completados
periodo
T.
Utilización
procesador
Porcentaje
tiempo
procesador
activo
es-
perando
Calcule
cantidades
trabajos
simultáneos
asumiendo
pe-
riodo
distribuye
siguientes
formas
mitad
mitad
procesador
cuarto
cuartos
tercer
cuartos
procesador
2.2
programa
limitado
ejecuta
gasta
tiempo
esperando
operaciones
utilizando
procesador
programa
limitado
procesador
contrario
Supóngase
algoritmo
planificación
corto
plazo
favorece
programas
utilizado
tiempo
procesador
reciente
Explique
algoritmo
favorece
programas
limitados
niega
permanente-
mente
tiempo
procesador
programas
limitados
procesador
2.3
Contraste
políticas
planificación
utilizar
intenta
optimizar
sistema
tiempo
compartido
utilizan
optimizar
sistema
lo-
tes
multiprogramado
2.4
propósito
llamadas
sistema
relacionan
llamadas
siste-
ma
sistema
operativo
concepto
dual
núcleo
usuario
2.5
sistema
operativo
IBM
OS/390
módulos
principales
núcleo
gestor
recursos
sistema
SRM
System
Resource
Manager
módulo
responsa-
ble
asignación
recursos
espacios
direcciones
procesos
SRM
OS/390
grado
sofisticación
único
sistemas
operativos
sistema
operativo
mainframe
ciertamente
tipo
sistema
operativo
funciones
llevadas
cabo
SRM
concepto
recurso
incluye
procesador
me-
moria
real
canales
S.
SRM
acumula
estadísticas
pertenecientes
utilización
procesador
canales
estructuras
datos
clave
propósito
proporcionar
ren-
dimiento
óptimo
basado
monitorización
análisis
rendimiento
instalación
pro-
porciona
objetivos
rendimiento
sirven
guía
SRM
modifica
dinámicamente
instalación
características
rendimiento
trabajos
basándose
utilización
sistema
Adicionalmente
SRM
proporciona
informes
permiten
operador
entrenado
refinar
configuraciones
establecimiento
parámetros
me-
jorar
servicio
usuario
problema
ejemplo
actividad
SRM
memoria
real
divide
bloques
tamaño
llamados
marcos
miles
marco
contener
bloque
memoria
virtual
conocido
página
SRM
recibe
control
20
inspeccionando
marco
página
página
referenciado
cambiado
contador
incrementa
tiempo
SRM
media
números
determinar
número
segundos
marco
página
sistema
queda
inalterable
propósito
acción
SRM
104
Sistemas
operativos
Aspectos
internos
principios
diseño
02-Capitulo
12/5/05
16:18
Página
104PARTE
II
PROCESOS
tarea
fundamental
sistema
operativo
moderno
gestión
procesos
siste-
ma
operativo
reservar
recursos
procesos
permitir
compartir
inter-
cambiar
información
proteger
recursos
resto
permitir
sincro-
nización
procesos
alcanzar
requisitos
sistema
operativo
mantener
estructura
determinada
proceso
describa
propiedad
recursos
permite
sistema
operativo
establecer
control
procesos
monoprocesador
multiprogramado
ejecución
procesos
intercalar
tiempo
multiprocesador
intercala
ejecución
procesos
múltiples
procesos
ejecuten
forma
simultánea
ejecución
intercalada
forma
simultánea
tipos
concurrencia
llevan
sistema
diferen-
tes
problemas
ámbito
aplicaciones
programador
sistemas
operativos
sistemas
operativos
actuales
problemática
gestión
procesos
ampliada
introducción
concepto
hilo
thread
sistema
multihilo
concepto
proceso
mantiene
atributos
propiedad
recursos
aspectos
ejecución
múltiples
flujos
instrucciones
relacionada
hilos
ejecutan
proceso
ÍNDICE
CAPÍTULO
DESCRIPCIÓN
CONTROL
PROCESOS
objetivo
sistemas
operativos
tradicionales
gestión
procesos
proceso
en-
cuentra
instante
ejecución
incluyen
Listo
Ejecu-
tando
Bloqueado
sistema
operativo
traza
ejecución
gestiona
movimiento
procesos
sistema
operativo
mantiene
estructu-
ras
datos
complejas
describen
proceso
sistema
operativo
operaciones
planificación
proporcionar
servicios
compartición
procesos
sincronización
Capítulo
repasa
estructuras
datos
técnicas
utilizadas
forma
habitual
siste-
operativos
gestión
procesos
03-Capitulo
12/5/05
16:19
Página
105CAPÍTULO
HILOS
SMP
MICRONÚCLEOS
Capítulo
cubre
áreas
características
sistemas
operativos
contemporáneos
repre-
sentan
avances
diseño
sistemas
operativos
tradicionales
sistemas
operativos
concepto
tradicional
proceso
dividido
partes
propiedad
recursos
proceso
ejecución
flujo
instrucciones
hilo
thread
único
proceso
contener
múltiples
hilos
organización
multihilo
proporciona
ventajas
estructuración
aplicaciones
rendimiento
Capítulo
examina
multiprocesadores
simétricos
SMP
sistemas
múltiples
procesadores
capaz
ejecutar
aplicación
código
sistema
organización
SMP
mejora
rendimiento
fiabilidad
SMP
conjunto
programación
multihilo
proporciona
importantes
mejoras
nivel
rendimiento
finali-
zar
Capítulo
examina
concepto
micronúcleo
estilo
diseño
sistemas
operati-
vos
minimiza
cantidad
código
sistema
ejecuta
núcleo
ventajas
estrategia
analizan
CAPÍTULO
CONCURRENCIA
EXCLUSIÓN
MUTUA
SINCRONIZACIÓN
temas
centrales
sistemas
operativos
modernos
multiprogramación
procesa-
miento
distribuido
concepto
concurrencia
fundamental
fundamental
tecnología
diseño
sistemas
operativos
Capítulo
repasa
aspectos
control
concurrencia
exclusión
mutua
sincronización
exclusión
mutua
refiere
posibi-
lidad
múltiples
procesos
hilos
compartan
código
recursos
datos
forma
acceso
objeto
compartido
momento
sincronización
re-
lacionada
exclusión
mutua
posibilidad
múltiples
procesos
coordinen
activida-
des
intercambiar
información
Capítulo
proporciona
amplio
tratamiento
aspectos
relativos
concurrencia
comenzando
repaso
consideraciones
diseño
implicadas
capítulo
proporciona
revisión
soporte
hardware
concurrencia
presentando
me-
canismos
importantes
darle
soporte
semáforos
monitores
paso
mensajes
CAPÍTULO
CONCURRENCIA
INTERBLOQUEO
INANICIÓN
Capítulo
muestra
aspectos
concurrencia
interbloqueo
situación
procesos
esperando
miembros
conjunto
completen
operación
continuar
miembros
capaz
interbloqueos
fenómeno
difícil
anticipar
soluciones
generales
fáciles
Capítulo
muestra
estrategias
principales
manejar
interbloqueo
prevenirlo
evitarlo
detectarlo
ina-
nición
refiere
situación
proceso
listo
ejecutar
deniega
acceso
procesador
forma
continuada
deferencia
procesos
inanición
cuestión
planificación
trataremos
Capítulo
centra
interbloqueos
inanición
contexto
soluciones
necesarias
evitar
problema
inanición
106
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
106CAPÍTULO
Descripción
control
procesos
3.1
proceso
3.2
procesos
3.3
Descripción
procesos
3.4
Control
procesos
3.5
Gestión
procesos
UNIX
SVR4
3.6
Resumen
3.7
Lecturas
recomendadas
3.8
érminos
clave
cuestiones
repaso
problemas
03-Capitulo
12/5/05
16:19
Página
107El
diseño
sistema
operativo
reflejar
requisitos
generales
sistemas
opera-
tivos
multiprogramados
sistemas
operativos
monousuario
Windows
98
siste-
mainframes
IBM
capaces
soporte
miles
usuarios
construyen
torno
concepto
proceso
mayoría
requisitos
sistema
operativo
cumplir
expresar
referencia
procesos
sistema
operativo
intercalar
ejecución
múltiples
procesos
maximizar
uti-
lización
procesador
proporciona
tiempo
respuesta
razonable
sistema
operativo
reservar
recursos
procesos
conforme
política
específi-
ca
ejemplo
funciones
aplicaciones
prioridad
mis-
mo
tiempo
evita
interbloqueos
sistema
operativo
requerir
soporte
comunicación
procesos
crea-
ción
procesos
ayuda
estructuración
aplicaciones
comienza
estudio
detallado
sistemas
operativos
examinando
forma
representan
controlan
procesos
introducción
concepto
proceso
capítulo
presentará
procesos
caracterizan
comportamiento
Seguida-
mente
presentarán
estructuras
datos
sistema
operativo
gestionar
proce-
sos
incluyen
estructuras
representar
proceso
registrar
características
sistema
operativo
necesita
alcanzar
objetivos
Posterior-
mente
verá
sistema
operativo
utiliza
estructuras
controlar
ejecución
procesos
discute
gestión
procesos
UNIX
SVR4
Capítulo
proporciona
ejemplos
modernos
gestión
procesos
tales
Solaris
Windows
Linux
Nota
capítulo
referencias
puntuales
memoria
virtual
mayoría
po-
demos
ignorar
concepto
relación
procesos
puntos
discusión
consideraciones
memoria
virtual
pertinentes
memoria
virtual
discutirá
de-
talle
Capítulo
proporcionado
somera
visión
general
Capítulo
3.1
PROCESO
CONCEPTOS
PREVIOS
definir
término
proceso
útil
recapitular
conceptos
presentados
Capítulos
plataforma
computación
consiste
colección
recursos
hardware
proce-
sador
memoria
módulos
relojes
unidades
disco
similares
aplicaciones
computadores
desarrollan
determinadas
tareas
Suelen
aceptar
entradas
mundo
exterior
procesamiento
generar
salidas
eficiente
aplicaciones
estén
escritas
directamente
plataforma
hardware
específica
principales
razones
siguientes
108
Sistemas
operativos
Aspectos
internos
principios
diseño
interbloqueos
examinarán
Capítulo
ejemplo
sencillo
interbloqueo
ocurre
procesos
necesitan
recursos
iguales
continuar
procesos
posesión
recursos
realice
algu-
na
acción
proceso
esperará
indefinidamente
recurso
03-Capitulo
12/5/05
16:19
Página
108a
Numerosas
aplicaciones
desarrollarse
plataforma
forma
tie-
ne
sentido
desarrollar
rutinas
comunes
acceder
recursos
computador
procesador
proporciona
únicamente
soporte
limitado
multi-
programación
necesario
disponer
software
gestionar
compartición
proce-
sador
recursos
múltiples
aplicaciones
tiempo
múltiples
aplicaciones
activas
tiempo
necesario
proteger
da-
tos
recursos
aplicación
sistema
operativo
desarrolló
proporcionar
interfaz
apropiada
aplicacio-
nes
rica
funcionalidades
segura
consistente
sistema
operativo
capa
softwa-
re
aplicaciones
hardware
computador
Figura
2.1
soporte
aplicacio-
nes
utilidades
considerar
sistema
operativo
proporciona
representación
uniforme
abs-
tracta
recursos
aplicaciones
solicitar
acceder
recursos
incluyen
memoria
principal
interfaces
red
sistemas
ficheros
etc.
sistema
operativo
creado
abstracciones
recursos
aplicaciones
usen
controlar
ejemplo
sistema
operativo
permitir
compartición
protección
recursos
conocen
conceptos
aplicaciones
software
sistema
recursos
disposición
hablar
sistema
operativo
forma
ordenada
gestionar
ejecu-
ción
aplicaciones
forma
recursos
estén
disponibles
múltiples
aplicaciones
procesador
físico
conmute
múltiples
aplicaciones
forma
lleguen
procesarse
procesador
dispositivos
puedan
forma
eficiente
enfoque
adoptado
sistemas
operativos
modernos
recae
modelo
ejecución
aplicación
corresponde
existencia
procesos
PROCESOS
BLOQUES
CONTROL
PROCESOS
recordar
Capítulo
sugirieron
diversas
definiciones
término
proceso
in-
cluyendo
programa
ejecución
instancia
programa
ejecutado
computador
entidad
asignar
ejecutar
procesador
unidad
actividad
caracteriza
ejecución
secuencia
instrucciones
actual
conjunto
recursos
sistema
asociados
pensar
proceso
entidad
consiste
número
ele-
mentos
elementos
esenciales
serían
código
programa
compartirse
procesos
estén
ejecutando
programa
conjunto
datos
asociados
Descripción
control
procesos
109
03-Capitulo
12/5/05
16:19
Página
109código
Supongamos
procesador
comienza
ejecutar
código
programa
refe-
riremos
entidad
ejecución
proceso
instante
puntual
tiempo
mien-
proceso
ejecución
proceso
caracterizar
serie
elementos
in-
cluyendo
siguientes
Identificador
identificador
único
asociado
proceso
distinguirlo
resto
procesos
proceso
actualmente
corriendo
ejecución
Prioridad
Nivel
prioridad
relativo
resto
procesos
Contador
programa
dirección
instrucción
programa
eje-
cutará
Punteros
memoria
Incluye
punteros
código
programa
datos
asociados
di-
cho
proceso
bloque
memoria
compartido
procesos
Datos
contexto
datos
presenten
registros
procesador
proceso
corriendo
Información
S.
Incluye
peticiones
pendientes
dispositivos
ejemplo
unidad
cinta
asignados
proceso
lista
ficheros
etc.
Información
auditoría
incluir
cantidad
tiempo
procesador
tiempo
reloj
utilizados
límites
tiempo
registros
contables
etc.
información
lista
almacena
estructura
datos
suele
llamar
bloque
control
proceso
process
control
block
Figura
3.1
sistema
operativo
crea
gestiona
punto
significativo
relación
bloque
control
proceso
BCP
con-
suficiente
información
forma
interrumpir
proceso
corriendo
posteriormente
restaurar
ejecución
hubiera
habido
interrupción
BCP
herramienta
clave
permite
sistema
operativo
soporte
múltiples
procesos
pro-
porcionar
multiprogramación
proceso
interrumpe
valores
actuales
contador
programa
registros
procesador
datos
contexto
guardan
campos
correspondien-
tes
BCP
proceso
cambia
valor
bloqueado
listo
descri-
tos
continuación
sistema
operativo
libre
proceso
ejecu-
ción
contador
programa
datos
contexto
recuperan
cargan
registros
procesador
proceso
comienza
correr
forma
proceso
compuesto
código
programa
datos
asociados
bloque
control
proceso
BCP
computador
monoprocesador
instante
determinado
máximo
único
proceso
corriendo
proceso
esta-
rá
ejecución
3.2
PROCESOS
acaba
comentar
programa
ejecute
crear
proceso
tarea
programa
punto
vista
procesador
ejecuta
instrucciones
repertorio
instrucciones
secuencia
dictada
cambio
valores
registro
contador
progra-
ma
tiempo
contador
programa
apuntar
código
programas
procesos
punto
vista
programa
individual
ejecución
implica
secuencia
instrucciones
programa
110
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
110Se
caracterizar
comportamiento
determinado
proceso
listando
secuencia
instruc-
ciones
ejecutan
proceso
lista
denomina
trazadel
proceso
caracte-
rizar
comportamiento
procesador
mostrando
trazas
procesos
entrelazan
Considere
ejemplo
Figura
3.2
muestra
despliegue
memoria
procesos
simplificar
exposición
asume
dichos
procesos
memoria
virtual
procesos
representados
programas
residen
memoria
principal
adicional
pequeño
programa
activador
dispatcher
intercambia
procesador
proceso
Figura
3.3
muestra
trazas
procesos
instantes
ejecu-
ción
muestran
12
primeras
instrucciones
ejecutadas
procesos
C.
proceso
eje-
cuta
instrucciones
asume
cuarta
instrucción
invoca
operación
proceso
esperar
vea
trazas
punto
vista
procesador
Figura
3.4
muestra
trazas
en-
trelazadas
resultante
52
ciclos
ejecución
conveniencia
ciclos
instruccio-
nes
numerados
ejemplo
asume
sistema
operativo
deja
proceso
continúe
ciclos
instrucción
interrumpe
previene
proceso
monopolice
tiempo
procesador
muestra
Figura
3.4
prime-
ras
instrucciones
proceso
ejecutan
seguidas
alarma
temporización
time-out
ejecución
código
activador
ejecuta
instrucciones
devolver
con-
trol
proceso
ejecuten
instrucciones
proceso
solicita
acción
Descripción
control
procesos
111
reducido
número
instrucciones
ejecutadas
procesos
planificador
irreal
utilizado
simplificar
ejemplo
clarificar
explicaciones
Identificador
Prioridad
Contador
programa
Punteros
memoria
Datos
contexto
Información
Información
auditoría
Figura
3.1
Bloque
control
programa
BCP
simplificado
03-Capitulo
12/5/05
16:19
Página
111E
esperar
procesador
deja
ejecutar
proceso
pasa
ejecutar
proceso
activador
alarma
temporización
procesador
vuelve
proceso
A.
proceso
llega
temporización
proceso
esperando
complete
operación
activador
pasa
proceso
C.
112
Sistemas
operativos
Aspectos
internos
principios
diseño
Memoria
principalDirección
Activador
Proceso
Proceso
Proceso
Contador
programa
100
5000
8000
8000
12000
Figura
3.2
Instantánea
ejemplo
ejecución
Figura
3.4
ciclo
instrucción
13
Figura
3.3
Traza
procesos
Figura
3.2
5000
8000
12000
5001
8001
12001
5002
8002
12002
5003
8003
12003
5004
12004
5005
12005
5006
12006
5007
12007
5008
12008
5009
12009
5010
12010
5011
12011
Traza
Proceso
Traza
Proceso
Traza
Proceso
5000
Dirección
comienzo
programa
Proceso
A.
8000
Dirección
comienzo
programa
Proceso
B.
12000
Dirección
comienzo
programa
Proceso
C.
03-Capitulo
12/5/05
16:19
Página
112UN
MODELO
PROCESO
responsabilidad
principal
sistema
operativo
controlar
ejecución
procesos
in-
cluye
determinar
patrón
entrelazado
ejecución
asignar
recursos
procesos
pri-
mer
paso
diseño
sistema
operativo
control
procesos
describir
comporta-
miento
desea
tengan
procesos
construir
modelo
simple
observando
instante
proce-
so
ejecutando
procesador
modelo
proceso
esta-
Ejecutando
Ejecutando
muestra
Figura
3.5a
sistema
operativo
crea
proceso
crea
bloque
control
proceso
BCP
proceso
inserta
di-
cho
proceso
sistema
Ejecutando
proceso
conocido
sistema
operativo
esperando
oportunidad
ejecutar
proceso
actualmente
ejecución
interrumpirá
sistema
operativo
activador
seleccionará
proceso
Descripción
control
procesos
113
5000
27
12004
5001
28
12005
5002
Temporización
5003
29
100
5004
30
101
5005
31
102
Temporización
32
103
100
33
104
101
34
105
102
35
5006
10
103
36
5007
11
104
37
5008
12
105
38
5009
13
8000
39
5010
14
8001
40
5011
15
8002
Temporización
16
8003
41
100
Petición
42
101
17
100
43
102
18
101
44
103
19
102
45
104
20
103
46
105
21
104
47
12006
22
105
48
12007
23
12000
49
12008
24
12001
50
12009
25
12002
51
12010
26
12003
52
12011
Temporización
100
Dirección
comienzo
programa
activador
zonas
sombreadas
indican
ejecución
proceso
activación
columna
cuentan
ciclos
instrucciones
cuarta
columna
direcciones
instrucciones
ejecutan
Figura
3.4
Traza
combinada
procesos
Figura
3.2
03-Capitulo
12/5/05
16:19
Página
113a
ejecutar
proceso
saliente
pasará
Ejecutando
Ejecutando
pasará
Ejecutando
proceso
modelo
simple
apreciar
diseño
elementos
sistema
operati-
vo
proceso
representarse
sistema
operativo
seguirle
pista
información
correspondiente
proceso
incluyendo
actual
lo-
calización
memoria
bloque
control
programa
procesos
ejecutan-
do
especie
cola
esperando
turno
ejecución
Figura
3.5b
sugiere
estructura
cola
cuyas
entradas
punteros
BCP
proceso
particular
Al-
ternativamente
cola
consistir
lista
enlazada
bloques
datos
blo-
representa
proceso
exploraremos
posteriormente
implementación
describir
comportamiento
activador
términos
diagrama
colas
proceso
interrumpe
transfiere
cola
procesos
espera
Alternativamente
proce-
so
finalizado
abortado
descarta
sale
sistema
caso
activador
se-
lecciona
proceso
cola
ejecutar
CREACIÓN
TERMINACIÓN
PROCESOS
intentar
refinar
sencillo
modelo
resultará
útil
hablar
creación
terminación
procesos
forma
independiente
modelo
comportamiento
procesos
use
vida
proceso
acotada
creación
terminación
Creación
proceso
añadir
proceso
ges-
tionando
determinado
momento
sistema
operativo
construye
estructuras
datos
manejar
proceso
describió
Sección
3.3
reserva
espacio
di-
recciones
memoria
principal
proceso
acciones
constituyen
creación
proceso
114
Sistemas
operativos
Aspectos
internos
principios
diseño
ejecutado
Ejecutado
Activación
Cola
Entrada
Salida
Activación
Detención
Diagrama
transiciones
Modelos
colas
Procesador
Entrada
Salida
Detención
Figura
3.5
Modelo
proceso
03-Capitulo
12/5/05
16:19
Página
114Existen
eventos
comunes
llevan
creación
proceso
indica
Ta-
bla
3.1
entorno
lotes
proceso
crea
respuesta
solicitud
trabajo
entorno
interactivo
proceso
crea
usuario
entra
sistema
casos
sistema
operativo
responsable
creación
procesos
sistema
operativo
petición
aplicación
crear
procesos
ejemplo
usuario
solicita
imprima
fi-
chero
sistema
operativo
crear
proceso
gestione
impresión
proceso
solicitado
operar
independientemente
tiempo
requerido
completar
tarea
impresión
TABLA
3.1
Razones
creación
proceso
proceso
lotes
sistema
operativo
dispone
flujo
control
lotes
trabajos
habitualmente
cinta
disco
sistema
operativo
listo
procesar
trabajo
leerá
si-
guiente
secuencia
mandatos
control
trabajos
Sesión
interactiva
usuario
terminal
entra
sistema
Creado
sistema
sistema
operativo
crear
proceso
fun-
operativo
proporcionar
ción
representación
programa
usuario
servicio
usuario
esperar
ejemplo
proceso
contro-
lar
impresión
Creado
proceso
existente
motivos
modularidad
explotar
paralelismo
programa
usuario
ordenar
creación
número
procesos
Tradicionalmente
sistema
operativo
creaba
procesos
forma
transpa-
rente
usuarios
programas
común
sistemas
operativos
contem-
poráneos
útil
permitir
proceso
creación
ejemplo
proceso
aplicación
generar
proceso
recibir
datos
aplicación
gene-
rando
organizar
datos
forma
apropiada
posterior
análisis
proceso
ejecuta
paralelo
proceso
original
activa
datos
disponibles
organización
útil
estructuración
aplicación
ejemplo
proceso
servi-
dor
ejemplo
servidor
impresoras
servidor
ficheros
generar
proceso
solicitud
esté
manejando
sistema
operativo
crea
proceso
petición
explícita
proceso
dicha
acción
denomina
creación
proceso
proceso
lanza
denomina
proceso
padre
proceso
creado
denomina
proceso
hijo
Habitualmente
relación
procesos
necesita
comunicación
coope-
ración
Alcanzar
cooperación
tarea
complicada
programador
as-
pecto
verá
Capítulo
erminación
procesos
Tabla
3.2
resume
razones
típicas
terminación
pro-
ceso
sistema
proporcionar
mecanismos
proceso
indica
fina-
lización
completado
tarea
trabajo
lotes
incluir
instrucción
HALT
llamada
servicio
sistema
operativo
especifica
terminación
caso
ins-
trucción
HALT
generará
interrupción
indicar
sistema
operativo
proceso
fina-
lizado
aplicación
interactiva
acciones
usuario
indicarán
proceso
termi-
nado
ejemplo
sistema
tiempo
compartido
proceso
usuario
particular
terminar
usuario
sale
sistema
apaga
terminal
ordenador
personal
esta-
ción
trabajo
usuario
salir
aplicación
ejemplo
procesador
texto
Descripción
control
procesos
115
03-Capitulo
12/5/05
16:19
Página
115hoja
cálculo
acciones
resultado
solicitud
servicio
siste-
ma
operativo
terminar
proceso
solicitante
Adicionalmente
número
error
condición
fallo
finalización
proceso
Tabla
3.2
muestra
lista
condiciones
habituales
finalización
motivos
abla
3.2
Razones
terminación
proceso
Finalización
normal
proceso
ejecuta
llamada
sistema
operativo
indicar
completado
ejecución
Límite
tiempo
excedido
proceso
ejecutado
tiempo
especificado
límite
má-
ximo
posibilidades
medir
tiempo
in-
cluyen
tiempo
utilizado
tiempo
utilizado
únicamente
eje-
cución
caso
procesos
interactivos
cantidad
tiempo
usuario
entrada
Memoria
disponible
proceso
requiere
memoria
sistema
proporcionar
Violaciones
frontera
proceso
acceder
posición
memoria
tie-
ne
acceso
permitido
Error
protección
proceso
recurso
ejemplo
fichero
permitido
acceder
utilizarlo
forma
apropia
ejemplo
escribiendo
fichero
lectura
Error
aritmético
proceso
operación
cálculo
permitida
división
almacenar
números
mayores
representación
hardware
codificar
Límite
tiempo
proceso
esperado
tiempo
especificado
valor
máximo
cumpla
determinado
evento
Fallo
producido
error
operación
entrada
salida
ejemplo
imposibilidad
encontrar
fichero
fallo
lectura
escritura
límite
máximo
intentos
ejemplo
área
defectuosa
cinta
opera-
ción
inválida
lectura
impresora
línea
Instrucción
válida
proceso
intenta
ejecutar
instrucción
inexistente
habitualmente
resultado
salto
área
datos
intento
ejecutar
di-
chos
datos
Instrucción
privilegiada
proceso
intenta
utilizar
instrucción
reservada
sistema
operativo
inapropiado
datos
porción
datos
tipo
erróneo
inicializada
Intervención
operador
razón
operador
sistema
operativo
finalizado
sistema
operativo
proceso
ejemplo
condición
interbloqueo
Terminación
proceso
proceso
padre
termina
sistema
operativo
automá-
padre
ticamente
finalizar
procesos
hijos
descendientes
padre
Solicitud
proceso
padre
proceso
padre
habitualmente
autoridad
finalizar
pro-
pios
procesos
descendientes
116
Sistemas
operativos
Aspectos
internos
principios
diseño
sistema
operativo
compasivo
casos
permitir
usuario
recuperarse
fallo
terminar
proceso
ejemplo
usuario
solicita
acceder
fichero
deniega
acceso
sistema
operativo
simplemente
informar
usuario
permitir
proceso
continúe
03-Capitulo
12/5/05
16:19
Página
116Por
sistemas
operativos
proceso
terminarse
proceso
creó
proceso
padre
terminado
MODELO
PROCESO
procesos
estuviesen
preparados
ejecutar
gestión
colas
proporcionada
Figura
3.5b
efectiva
cola
lista
tipo
FIFO
procesador
opera
siguiendo
estrategia
cíclica
round-robin
turno
rotatorio
procesos
disponibles
proceso
cola
cantidad
tiempo
turnos
ejecutar
regresar
cola
bloquee
sencillo
ejemplo
vimos
implemen-
tación
inadecuada
procesos
Ejecutando
listos
eje-
cutar
bloqueados
esperando
complete
operación
S.
utilizando
única
cola
activador
seleccionar
únicamente
procesos
lleven
tiempo
cola
lugar
debería
recorrer
lista
buscando
procesos
estén
blo-
queados
lleven
cola
tiempo
forma
natural
manejar
situación
dividir
Ejecutando
Listo
Bloqueado
muestra
Figura
3.6
gestionarlo
correctamente
añadido
adicionales
resultarán
útiles
diagrama
siguientes
Ejecutando
proceso
actualmente
ejecución
capítulo
asumimos
computador
único
procesador
forma
proceso
esta-
do
instante
determinado
Listo
proceso
prepara
ejecutar
oportunidad
Bloqueado
proceso
ejecutar
cumpla
evento
determinado
complete
operación
S.
proceso
acaba
crear
admitido
grupo
proce-
sos
ejecutables
sistema
operativo
Típicamente
proceso
cargado
memoria
principal
bloque
control
proceso
BCP
creado
Saliente
proceso
liberado
grupo
procesos
ejecutables
sistema
ope-
rativo
detenido
abortado
razón
Descripción
control
procesos
117
Activación
Temporización
Listo
Bloqueado
Ejecutando
SalienteAdmisión
Salida
Espera
evento
Sucede
evento
Figura
3.6
Modelo
proceso
03-Capitulo
12/5/05
16:19
Página
117Los
Saliente
útiles
construir
gestión
procesos
corresponde
proceso
acaba
definido
ejemplo
usuario
intenta
entrar
sistema
tiempo
compartido
solicita
trabajo
sistema
proce-
so
lotes
sistema
operativo
definir
proceso
etapas
sistema
ope-
rativo
realiza
tareas
internas
correspondan
asocia
identificador
proceso
reservan
construyen
tablas
necesiten
gestionar
proceso
punto
proceso
significa
sistema
operativo
ta-
reas
necesarias
crear
proceso
proceso
puesto
ejecución
ejem-
plo
sistema
operativo
limitar
número
procesos
sistema
razo-
nes
rendimiento
limitaciones
memoria
principal
proceso
información
relativa
proceso
necesite
sistema
operativo
mantiene
tablas
control
memoria
principal
proceso
memoria
prin-
cipal
código
programa
ejecutar
memoria
principal
reser-
vado
espacio
datos
asociados
programa
proceso
programa
permanece
almacenamiento
secundario
normalmente
disco
forma
similar
proceso
sale
sistema
fases
proceso
termina
alcanza
punto
finalización
natural
abortado
error
recuperable
proceso
autoridad
apropiada
causa
proceso
aborte
terminación
mueve
proceso
Saliente
punto
proceso
elegible
ejecución
tablas
información
asociada
trabajo
encuentran
temporalmente
preservadas
sis-
tema
operativo
proporciona
tiempo
programas
auxiliares
soporte
extraigan
información
necesaria
ejemplo
programa
auditoría
requerir
registrar
tiempo
proceso
recursos
utilizados
proceso
saliente
objeto
contabilidad
recursos
sistema
programa
utilidad
requerir
extraer
información
his-
tórico
procesos
temas
relativos
rendimiento
análisis
utilización
programas
extraído
información
necesaria
sistema
operativo
necesita
mantener
dato
relativo
proceso
proceso
borra
sistema
Figura
3.6
indica
tipos
eventos
llevan
transición
proceso
posibles
transiciones
siguientes
Null
ÆÆ
crea
proceso
ejecutar
programa
evento
ocurre
cualquiera
relaciones
indicadas
tabla
3.1
ÆÆ
Listo
sistema
operativo
mueve
proceso
listo
encuentre
preparado
ejecutar
proceso
mayoría
sistemas
fijan
límite
basado
número
procesos
existentes
cantidad
memoria
virtual
utilizar
procesos
existentes
límite
asegura
de-
masiados
procesos
activos
degrade
rendimiento
sistema
Listo
ÆÆ
Ejecutando
llega
momento
seleccionar
proceso
ejecutar
sistema
operativo
selecciona
procesos
encuentre
Listo
tarea
acabo
planificador
planificador
estudiará
Ejecutando
ÆÆ
Saliente
proceso
actual
ejecución
finaliza
sistema
ope-
rativo
proceso
indica
completado
ejecución
aborta
Véase
tabla
3.2
118
Sistemas
operativos
Aspectos
internos
principios
diseño
explicaciones
párrafo
ignorado
concepto
memoria
virtual
sistemas
soporten
memoria
virtual
proceso
mueve
Listo
código
programa
datos
cargan
memoria
virtual
memori
virtual
explicado
brevemente
Capítulo
examinará
detalle
Capítulo
03-Capitulo
12/5/05
16:19
Página
118•
Ejecutando
ÆÆ
Listo
razón
habitual
transición
proceso
eje-
cución
alcanzado
máximo
tiempo
ejecución
forma
ininterrumpida
prácticamente
sistemas
operativos
multiprogramados
imponen
tipo
restric-
ción
tiempo
posibles
causas
alternativas
transición
incluidas
sistemas
operativos
particular
importancia
caso
sistema
operativo
asigna
niveles
prioridad
procesos
Supóngase
ejemplo
proceso
ejecutando
determinado
nivel
prioridad
proceso
nivel
prioridad
bloqueado
sistema
ope-
rativo
produce
evento
proceso
esperando
move-
rá
proceso
Listo
interrumpir
proceso
ejecu-
ción
proceso
B.
Decimos
caso
sistema
operativo
expulsado
proceso
Adicionalmente
proceso
voluntariamente
dejar
utilizar
procesador
ejemplo
procesos
realiza
función
auditoría
mantenimiento
forma
periódica
Ejecutando
ÆÆ
Bloqueado
proceso
pone
Bloqueado
solicita
esperar
solicitud
sistema
operativo
realiza
habitualmente
llamada
sistema
llamada
proceso
ejecución
procedimiento
código
sistema
operativo
ejemplo
proceso
solicitado
servicio
sistema
operativo
momento
solicitar
recurso
ejemplo
fichero
sección
compartida
memoria
virtual
inmediata-
mente
disponible
proceso
iniciar
acción
operación
completarse
proceso
continúe
proceso
comunica
proceso
bloquearse
esperando
proceso
propor-
cione
datos
esperando
mensaje
proceso
Bloqueado
ÆÆ
Listo
proceso
Bloqueado
mueve
Listo
suce-
evento
esperando
Listo
ÆÆ
Saliente
claridad
transición
muestra
diagrama
sistemas
padre
terminar
ejecución
proceso
hijo
mo-
mento
padre
termina
procesos
hijos
asociados
padre
pue-
den
finalizarse
Bloqueado
ÆÆ
Saliente
aplican
comentarios
indicados
caso
regresamos
sencillo
ejemplo
Figura
3.7
muestra
transición
proceso
figura
3.8a
sugiere
forma
aplicar
esquema
colas
co-
Listos
cola
Bloqueados
proceso
admitido
sistema
coloca
cola
Listos
llega
momento
sistema
operativo
seleccione
proceso
ejecutar
se-
lecciona
cola
Listos
ausencia
esquema
prioridad
cola
lista
tipo
FIFO
first-in-first-out
proceso
ejecución
termina
utilizar
procesa-
dor
finaliza
coloca
cola
Listos
Bloqueados
dependiendo
circuns-
tancias
sucede
evento
proceso
cola
Bloqueados
única-
mente
esté
esperando
evento
mueve
cola
Listos
transición
significa
sucede
evento
sistema
operativo
recorrer
cola
entera
Bloqueados
buscando
procesos
estén
esperando
evento
Descripción
control
procesos
119
general
término
expulsión
preemption
define
reclamación
recurso
proceso
proceso
poseía
finalice
caso
recurso
procesador
proceso
ejecutando
tinuar
ejecución
expulsado
proceso
entrar
ejecutar
03-Capitulo
12/5/05
16:19
Página
119los
sistemas
operativos
procesos
significar
cientos
miles
proce-
sos
lista
eficiente
cola
evento
forma
sucede
evento
lista
entera
procesos
cola
correspondiente
movería
Listo
Figura
8b
refinamiento
activación
procesos
dictada
esquema
priorida-
des
conveniente
colas
procesos
listos
nivel
prioridad
siste-
ma
operativo
determinar
proceso
listo
prioridad
simplemente
seleccionan-
do
orden
PROCESOS
SUSPENDIDOS
necesidad
intercambio
swapping
principales
descritos
Listo
Ejecu-
tando
Bloqueado
proporcionan
forma
sistemática
modelizar
comportamiento
proce-
sos
diseñar
implementación
sistema
operativo
construido
sistemas
operativos
utilizando
únicamente
justificación
añadir
modelo
be-
neficio
suponer
sistema
utiliza
memoria
virtual
proceso
ejecuta
cargarse
completamente
memoria
principal
ejemplo
Figura
3.8b
to-
procesos
colas
residir
memoria
principal
Recuérdese
razón
compleja
maquinaria
operaciones
mu-
cho
lentas
procesos
cómputo
procesador
sistema
monoprograma-
do
estaría
ocioso
tiempo
ajustes
Figura
3.8b
resuelven
completa-
mente
problema
caso
memoria
almacena
múltiples
procesos
procesador
asignarse
proceso
queda
bloqueado
diferencia
velo-
cidad
procesador
habitual
procesos
memoria
encontrasen
esperas
dichas
operaciones
sistema
multiprogramado
procesador
ocioso
tiempo
memoria
principal
expandirse
acomodar
procesos
fallos
solución
coste
asociado
memoria
principal
120
Sistemas
operativos
Aspectos
internos
principios
diseño
Activador
/H11005
Ejecutando
/H11005
Listo
/H11005
Bloqueado
10
15
20
25
30
35
40
45
50
Proceso
Proceso
Proceso
Figura
3.7
procesos
traza
Figura
3.4
03-Capitulo
12/5/05
16:19
Página
120coste
reducido
nivel
bytes
comienza
incrementarse
acercamos
almacenamiento
gigabytes
apetito
programas
nivel
memoria
crecido
rápido
bajado
coste
memorias
forma
memorias
actuales
llevado
ejecutar
procesos
tamaño
procesos
solución
swapping
memoria
intercambio
implica
mover
proceso
memoria
principal
disco
procesos
memoria
principal
es-
tado
Listo
sistema
operativo
intercambia
procesos
bloqueados
disco
cola
Sus-
pendidos
lista
procesos
existentes
temporalmente
expulsados
memoria
principal
suspendidos
sistema
operativo
trae
proceso
cola
Suspendidos
responde
solicitud
proceso
ejecución
continúa
procesos
llegado
swapping
operación
riesgo
potencial
problema
empeore
disco
habitualmente
rápida
sistemas
ejemplo
comparado
cinta
impresora
swapping
habitualmente
me-
jora
rendimiento
sistema
swapping
escrito
añadirse
modelo
comportamiento
procesos
Figura
3.9a
Suspendido
procesos
Descripción
control
procesos
121
Activación
Temporización
Espera
evento
Espera
evento
Ocurre
evento
Cola
Listos
Cola
Bloqueados
Admisión
Salida
Procesador
Salida
Cola
evento
Cola
simple
Bloqueados
Múltiples
colas
Bloqueados
Procesador
Activación
Cola
Listos
Admisión
Temporización
Cola
evento
Espera
evento
1Ocurre
evento
Ocurre
evento
Ocurre
evento
Cola
evento
Espera
evento
Figura
3.8
Modelo
colas
Figura
3.6
03-Capitulo
12/5/05
16:19
Página
121memoria
principal
encuentran
Bloqueado
sistema
operativo
suspender
pro-
ceso
poniéndolo
Suspendido
transfiriéndolo
disco
espacio
libera
memo-
ria
principal
usarse
traer
proceso
sistema
operativo
operación
swap
transferencia
disco
proceso
opciones
seleccionar
proceso
traerlo
memoria
principal
admitir
proceso
creado
traer
proceso
anteriormente
encontrase
Suspendido
preferible
traer
proceso
anteriormente
estuviese
suspendido
proporcionar
servicio
lugar
incrementar
carga
sistema
línea
razonamiento
presenta
dificultad
procesos
suspen-
didos
encontraban
previamente
Bloqueado
momento
suspensión
Cla-
ramente
traer
proceso
bloqueado
memoria
encon-
trarse
listo
ejecución
reconocer
procesos
Suspendido
originalmente
Bloqueado
espera
evento
particu-
lar
evento
sucede
proceso
Bloqueado
potencialmente
disponible
ejecución
forma
necesitamos
replantear
aspecto
diseño
conceptos
independientes
proceso
esperando
evento
Bloqueado
proceso
transferido
memoria
disco
suspendido
describir
combinaciones
necesitamos
Listo
proceso
memoria
principal
disponible
ejecución
Bloqueado
proceso
memoria
principal
esperando
evento
Bloqueado
Suspendido
proceso
almacenamiento
secundario
esperando
evento
Listo
Suspendido
proceso
almacenamiento
secundario
disponible
ejecución
cargado
memoria
principal
diagrama
transiciones
incluya
Sus-
pendidos
mencionar
punto
explicación
asumido
utiliza
memoria
virtual
proceso
completamente
memoria
principal
completamente
esquema
memoria
virtual
ejecutar
proceso
parcialmente
memo-
ria
principal
referencia
dirección
proceso
memoria
princi-
pa
porción
correspondiente
proceso
trae
memoria
principal
pare-
cer
elimina
necesidad
swapping
explícito
dirección
necesitada
proceso
demande
traerse
transferirse
disco
memoria
hardware
gestión
memoria
procesador
veremos
Capítulo
rendimiento
sistemas
memoria
virtual
colapsarse
número
suficientemente
pro-
cesos
activos
parcialmente
memoria
principal
forma
sis-
tema
memoria
virtual
sistema
operativo
necesita
swapping
procesos
forma
ex-
plícita
completa
intención
mejorar
rendimiento
Veamos
Figura
3.9b
modelo
transición
diseñado
líneas
punteadas
figura
indican
transiciones
posibles
necesarias
transicio-
nes
importantes
siguientes
Bloqueado
ÆÆ
Bloqueado
Suspendido
procesos
listos
procesos
bloqueados
transfiere
disco
espacio
proceso
bloqueado
transición
realizarse
procesos
listos
disponi-
122
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
122bles
sistema
operativo
determina
proceso
actualmente
ejecución
proce-
sos
listos
desea
ejecutar
requieren
memoria
principal
mantener
rendimiento
adecuado
Bloqueado
Suspendido
ÆÆ
Listo
Suspendido
proceso
Bloqueado
Suspendi-
do
mueve
Listo
Suspendido
sucede
evento
esperando
Nótese
requiere
información
concerniente
proceso
suspendido
accesible
sistema
operativo
Listo
Suspendido
ÆÆ
Listo
procesos
listos
memoria
principal
sis-
tema
operativo
necesitará
traer
continuar
ejecución
Adicionalmente
darse
caso
proceso
Listo
Suspendido
prioridad
cualquiera
procesos
Listo
caso
sistema
operativo
haberse
diseñado
determinar
importante
traer
proceso
prioridad
minimizar
efecto
swapping
Descripción
control
procesos
123
Suspendido
Listo
Bloqueado
Ejecutando
Saliente
Admisión
único
Suspendido
Suspensión
Espera
evento
Sucede
eventoReactivación
Activación
Temporización
Salida
Listo/
suspendido
Listo
Bloqueado
Ejecutando
Saliente
Admisión
Admisión
Suspendido
Activación
Temporización
Reactivación
Suspensión
Suspensión
Reactivación
Salida
Bloqueado/
suspendido
Suspensión
Sucede
evento
Sucede
evento
Espera
evento
Figura
3.9
Diagrama
transición
procesos
suspendidos
03-Capitulo
12/5/05
16:19
Página
123•
Listo
ÆÆ
Listo
Suspendido
Normalmente
sistema
operativo
preferirá
suspender
procesos
bloqueados
proceso
Listo
proceso
Listo
ejecutar
momento
proceso
Bloqueado
ocupa
espacio
memoria
ejecutar
em-
bargo
necesario
suspender
proceso
Listo
liberar
blo-
suficientemente
memoria
sistema
operativo
decidir
suspen-
der
proceso
Listo
baja
prioridad
proceso
Bloqueado
alta
prioridad
cree
proceso
Bloqueado
listo
transiciones
interesantes
considerar
siguientes
ÆÆ
Listo
Suspendido
Listo
crea
proceso
aña-
dirse
cola
Listos
cola
Listos
Suspendidos
caso
sistema
ope-
rativo
crear
bloque
control
proceso
BCP
reservar
espacio
direccio-
nes
proceso
preferible
sistema
operativo
realice
tareas
internas
forma
disponer
suficiente
cantidad
procesos
bloqueados
estrategia
ocurrir
espacio
suficiente
memoria
principal
proceso
transición
ÆListo
Suspendido
deseamos
hincapié
filosofía
creación
procesos
diferida
haciéndolo
reducir
sobrecarga
sistema
operativo
permite
tareas
creación
procesos
sistema
lleno
procesos
bloqueados
Bloqueado
Suspendido
ÆÆ
Bloqueado
incursión
transición
parecer
diseño
pobre
proceso
listo
ejecu-
tar
memoria
principal
sentido
traerlo
considérese
siguien-
escenario
proceso
termina
liberando
memoria
principal
proceso
cola
Bloqueados
Suspendidos
prioridad
procesos
cola
Listos
Suspendidos
sistema
operativo
motivos
creer
evento
blo-
quea
ocurrir
circunstancias
razonable
traer
proceso
Bloquea-
do
memoria
procesos
Listos
Ejecutando
ÆÆ
Listo
Suspendido
Normalmente
proceso
ejecución
mueve
cola
Listos
tiempo
procesador
finaliza
sistema
operativo
expulsa
proceso
ejecución
proceso
prioridad
cola
Bloqueado
Suspendido
acaba
desbloquearse
sistema
operativo
mover
pro-
ceso
ejecución
directamente
cola
Listos
Suspendidos
liberar
memo-
ria
principal
ÆÆ
Saliente
Habitualmente
proceso
termina
ejecutando
completado
ejecución
condición
fallo
sistemas
operativos
proceso
terminarse
proceso
creó
proceso
padre
terminado
permite
proceso
moverse
Saliente
usos
suspensión
procesos
definido
concepto
proce-
sos
suspendidos
proceso
memoria
principal
proceso
memoria
principal
disponible
forma
inmediata
ejecución
independientemente
espera
evento
analizar
concepto
procesos
suspendidos
definiendo
proceso
suspendido
cumple
siguientes
características
proceso
inmediatamente
disponible
ejecución
124
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
1242
proceso
espera
evento
condición
bloqueo
inde-
pendiente
condición
suspendido
sucede
evento
bloquea
habi-
lita
proceso
ejecución
inmediata
proceso
puesto
suspendido
agente
proceso
proceso
padre
sistema
operativo
propósito
prevenir
ejecución
proceso
recuperado
agente
explícitamente
indique
abla
3.3
Razones
suspensión
proceso
Swapping
sistema
operativo
necesita
liberar
suficiente
memoria
princi-
pa
traer
proceso
Listo
ejecución
razones
sistema
operativo
sistema
operativo
suspender
proceso
plano
utilidad
proceso
sospecha
cau-
sar
problema
Solicitud
interactiva
usuario
usuario
desear
suspender
ejecución
progra-
ma
motivo
depuración
utilizando
recurso
Temporización
proceso
ejecutarse
periódicamente
ejemplo
proceso
monitor
estadísticas
sistema
sus-
penderse
espera
intervalo
ejecución
Solicitud
proceso
padre
proceso
padre
querer
suspender
ejecución
descendiente
examinar
modificar
proceso
sus-
pendido
coordinar
actividad
procesos
des-
cendientes
Tabla
3.3
muestra
lista
condiciones
suspensión
proceso
ra-
zones
discutido
anteriormente
proporcionar
espacio
memoria
traer
procesos
Listos
Suspendidos
incrementar
espacio
memoria
disponible
procesos
Listos
sistema
operativo
motivos
suspender
proceso
ejemplo
utilizar
proceso
traza
auditoría
monitorizar
actividad
sistema
proce-
so
recoger
datos
nivel
utilización
recursos
procesador
memoria
canales
tasa
progreso
procesos
sistema
sistema
operativo
control
opera-
dor
activar
desactivar
proceso
determinada
periodicidad
sistema
operativo
de-
tecta
sospecha
problema
suspender
procesos
ejemplo
interbloqueo
discutirá
Capítulo
ejemplo
detectan
problemas
línea
comunicación
operador
solicita
sistema
operativo
suspenda
proceso
utiliza
dicha
línea
pruebas
tipo
razones
relacionadas
interactivo
sistema
ejemplo
usuarios
sospechan
programa
tipo
bug
detener
ejecución
programa
examinando
modificando
programa
datos
reanudándolo
ha-
ber
proceso
plano
recolecta
trazas
estadísticas
activado
usuario
consideraciones
tiempo
activar
decisiones
swapping
ejemplo
proceso
activa
periódicamente
ocioso
tiempo
enviado
disco
ejecuciones
realiza
ejemplo
programa
moni-
toriza
utilización
sistema
actividad
usuario
Descripción
control
procesos
125
03-Capitulo
12/5/05
16:19
Página
125Por
proceso
padre
suspender
proceso
descendiente
ejemplo
proceso
lanza
proceso
lectura
fichero
Posteriormente
proceso
encuen-
tra
error
lectura
fichero
indica
proceso
A.
proceso
suspende
proceso
investiga
causa
casos
activación
proceso
Suspendido
solicita
agente
inicialmente
puso
proceso
suspensión
3.3
DESCRIPCIÓN
PROCESOS
sistema
operativo
controla
eventos
computador
planifica
activa
procesos
ejecución
procesador
reserva
recursos
responde
solicitudes
servi-
cios
básicos
procesos
usuario
Fundamentalmente
piensa
sistema
operativo
entidad
gestiona
recursos
sistema
procesos
concepto
ilustra
Figura
3.10
entorno
multiprogramado
numerosos
procesos
P1
Pn
creados
residentes
memoria
virtual
proceso
transcurso
ejecución
necesita
acceder
recursos
sistema
incluido
procesador
disposi-
tivos
memoria
principal
figura
proceso
P1
ejecutando
proceso
memoria
principal
controla
dispositivos
S.
proceso
P2
totalmente
memoria
principal
bloqueado
esperando
disponer
dispositivo
asignado
P1
proceso
Pn
transferido
disco
swapping
suspendido
Exploraremos
detalles
gestión
recursos
sistema
operativo
capítulos
interesa
cuestión
fundamental
información
necesita
sistema
operativo
controlar
procesos
gestionar
recursos
ESTRUCTURAS
CONTROL
SISTEMA
OPERATIVO
sistema
operativo
encarga
gestión
procesos
recursos
disponer
infor-
mación
actual
proceso
recurso
mecanismo
universal
pro-
porcionar
información
sistema
operativo
construye
mantiene
tablas
información
entidad
gestiona
indica
idea
general
alcance
tarea
Figura
3.11
muestra
tipos
tablas
mantenidas
sistema
operati-
vo
memoria
ficheros
procesos
detalles
difieren
sistema
operati-
vo
fundamentalmente
sistemas
operativos
mantienen
información
cua-
tro
categorías
126
Sistemas
operativos
Aspectos
internos
principios
diseño
Procesador
Memoria
principal
Recursos
ordenador
Memoria
virtual
P2
PnP1
Figura
3.10
Procesos
recursos
reserva
recursos
instantánea
sistema
03-Capitulo
12/5/05
16:19
Página
126Las
tablas
memoria
mantener
registro
memoria
principal
real
secundaria
virtual
memoria
principal
reservada
sistema
operativo
resto
disponible
procesos
procesos
mantienen
memoria
secundaria
utilizando
tipo
memoria
virtual
técnicas
swapping
tablas
memoria
incluir
información
reservas
memoria
principal
procesos
reservas
memoria
secundaria
procesos
atributos
protección
restringe
memoria
principal
virtual
for-
ma
procesos
puedan
acceder
áreas
memoria
compartida
información
necesaria
manejar
memoria
virtual
Veremos
detalle
estructuras
información
gestión
memoria
sistema
operativo
utilizar
tablas
gestionar
dispositivos
canales
computador
instante
determinado
dispositivo
disponi-
ble
asignado
proceso
particular
operación
realizando
sistema
ope-
rativo
necesita
operación
dirección
memoria
principal
área
usa-
fuente
destino
transferencia
S.
gestión
examina
detalle
Capítulo
11
sistema
operativo
mantener
tablas
ficheros
tablas
proporcionan
información
existencia
ficheros
posición
almacenamiento
secundario
ac-
Descripción
control
procesos
127
Memoria
Dispositivos
Ficheros
Procesos
Proceso
Tablas
memoria
Proceso
Imagen
proceso
Proceso
Tablas
Tablas
ficheros
Tabla
primaria
procesos
Proceso
Proceso
Proceso
Imagen
proceso
Figura
3.11
Estructura
general
tablas
control
sistema
operativo
03-Capitulo
12/5/05
16:19
Página
127tual
atributos
mayoría
prácticamente
información
gestionar
sistema
ficheros
cuyo
caso
sistema
operativo
conocimiento
ficheros
sistemas
operativos
mayoría
detalle
gestión
ficheros
gestiona
sistema
operativo
aspecto
explorará
Capítulo
12
lugar
sistema
operativo
mantener
tablas
procesos
gestionar
proce-
sos
restante
sección
dedicada
examinar
requisitos
tablas
procesos
proceder
explicación
puntualizaciones
im-
portantes
Figura
3.11
muestra
tipos
tablas
que-
tablas
encuentran
entrelazadas
referenciadas
Me-
moria
ficheros
gestionan
procesos
forma
referencias
recursos
directa
indirectamente
tablas
procesos
ficheros
in-
dicados
tablas
ficheros
accesibles
dispositivos
estarán
caso
residentes
memoria
virtual
principal
tablas
accesibles
sistema
operati-
vo
controladas
gestión
memoria
sistema
operativo
crear
tablas
iniciales
Ciertamente
sistema
operativo
información
entorno
básico
memoria
física
dispositivos
identificadores
ejemplo
cuestión
configuración
sistema
operativo
inicializa
acceso
al-
gunos
datos
configuración
definen
entorno
básico
datos
crear
sis-
tema
operativo
asistencia
humana
software
autoconfiguración
ESTRUCTURAS
CONTROL
PROCESO
considerará
información
sistema
operativo
manejar
controlar
pro-
cesos
localizados
procesos
atribu-
tos
procesos
gestionar
ejemplo
identificador
proceso
Localización
procesos
podamos
tratar
cuestión
encuentran
procesos
atributos
debemos
tratar
cuestión
fundamental
re-
presentación
física
proceso
mínimo
proceso
incluir
programa
conjunto
programas
ejecutar
Asociados
programas
posiciones
memoria
datos
variables
locales
globales
constante
definida
proceso
consistir
cantidad
suficiente
memoria
almacenar
programa
datos
Adicional-
mente
ejecución
típica
programa
incluye
pila
véase
Apéndice
1B
utiliza
registrar
llamadas
procedimientos
parámetros
pasados
dichos
procedimientos
úl-
timo
proceso
asociado
número
atributos
utilizados
sistema
operativo
controlar
proceso
Normalmente
conjunto
atributos
denomina
bloque
con-
trol
proceso
BCP
referir
conjunto
programa
datos
pila
atributos
imagen
proceso
Tabla
3.4
posición
imagen
proceso
dependerá
esquema
gestión
memoria
utili-
ce
caso
simple
imagen
proceso
mantiene
bloque
memoria
contiguo
continuo
bloque
mantiene
memoria
secundaria
habitualmente
disco
sistema
operativo
gestionar
proceso
pequeña
porción
imagen
mantener
128
Sistemas
operativos
Aspectos
internos
principios
diseño
nombres
habituales
usados
estructura
datos
bloque
control
tarea
descriptor
proceso
des-
criptor
tarea
03-Capitulo
12/5/05
16:19
Página
128en
memoria
principal
ejecutar
proceso
imagen
proceso
completa
cargar
me-
moria
principal
memoria
virtual
Asimismo
sistema
operativo
necesita
posición
disco
proceso
proceso
encuentre
memoria
principal
po-
sición
dicha
memoria
vio
ligera
modificación
compleja
esquema
sistema
operativo
CTSS
Capítulo
CTSS
proceso
transfiere
disco
swapping
imagen
proceso
permanece
memoria
principal
forma
siste-
ma
operativo
mantener
registro
partes
imagen
proceso
encuentran
memoria
principal
abla
3.4
Elementos
típicos
imagen
proceso
Datos
usuario
modificable
espacio
usuario
incluir
datos
programa
área
pila
usuario
programas
puedan
modificados
Programa
usuario
programa
ejecutar
Pila
sistema
proceso
pilas
sistema
LIFO
asociadas
pila
utiliza
almacenar
parámetros
direcciones
retorno
procedimientos
llamadas
sistema
Bloque
control
proceso
Datos
necesarios
sistema
operativo
controlar
procesos
véase
tabla
3.5
sistemas
operativos
modernos
suponen
existencia
hardware
paginación
per-
mite
memoria
física
contigua
soporte
procesos
parcialmente
residentes
memoria
principal
casos
imagen
proceso
encontrar
dicha
memoria
principal
restantes
memoria
secundaria
forma
tablas
mantenidas
sistema
operativo
mostrar
localización
página
imagen
proceso
Figura
3.11
muestra
estructura
información
localización
forma
tabla
primaria
procesos
entrada
proceso
entrada
contiene
puntero
imagen
proceso
imagen
proceso
contiene
múltiples
bloques
infor-
mación
mantiene
directamente
tabla
principal
proceso
disponible
referen-
cias
cruzadas
entradas
tablas
memoria
representación
ge-
nérica
sistema
operativo
particular
forma
organizar
información
localización
Atributos
proceso
sistema
operativo
multiprogramado
actualidad
requiere
cantidad
información
manejar
proceso
explicado
infor-
mación
considerar
reside
bloque
control
proceso
BCP
sistemas
organizarán
información
formas
capítulo
próxi-
mo
muestran
ejemplos
exploraremos
simplemente
tipo
información
sistema
operativo
utilizar
considerar
detalle
información
organizada
Descripción
control
procesos
129
explicación
pasa
detalles
particular
sistema
utilice
memoria
virtual
ima-
gen
proceso
activo
memoria
secundaria
imagen
carga
memoria
principal
copia
lugar
moverse
forma
memoria
secundaria
mantiene
copia
segmentos
páginas
imagen
proceso
memoria
principal
ve
modificada
copia
memoria
secundaria
desactu
ali-
zada
residente
memoria
principal
copie
disco
03-Capitulo
12/5/05
16:19
Página
129La
Tabla
3.5
muestra
lista
tipos
categorías
información
sistema
operativo
requiere
proceso
Resulta
sorprendente
cantidad
información
necesaria
ges-
tión
apreciando
exactitud
responsabilidades
sistema
operativo
lista
parecerá
razonable
agrupar
información
bloque
control
proceso
categorías
generales
Identificación
proceso
Información
procesador
Información
control
proceso
abla
3.5
Elementos
típicos
bloque
control
proceso
BCP
Identificación
proceso
Identificadores
Identificadores
numéricos
guardar
bloque
control
proceso
identificadores
proceso
identificador
proceso
creó
proceso
proceso
padre
identificador
usuario
Información
procesador
Registros
visibles
usuario
registro
visible
usuario
referencia
lenguaje
máquina
ejecuta
procesador
usuario
Normalmente
32
registros
determinadas
implementaciones
RISC
100
Registros
control
variedad
registros
procesador
utilizan
control
operaciones
Es-
tos
incluyen
Contador
programa
contiene
dirección
instrucción
ejecutar
Códigos
condición
resultan
operación
lógica
aritmética
reciente
ejemplo
sig-
cero
acarreo
desbordamiento
Información
incluyen
flags
interrupciones
habilitadas
deshabilitadas
eje-
cución
Puntero
pila
proceso
pilas
sistema
LIFO
asociadas
pila
utiliza
almace-
nar
parámetros
direcciones
retorno
procedimientos
llamadas
sistema
pun-
tero
pila
apunta
alta
pila
Información
control
proceso
Información
planificación
información
sistema
operativo
necesita
analizar
funciones
planificación
Elementos
típicos
información
130
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
130•
proceso
indica
listo
proceso
planificado
ejecución
ejemplo
Ejecutando
Listo
Esperando
Detenido
Prioridad
campos
utilizar
escribir
prioridad
planificación
proceso
sistemas
necesitan
múltiples
valores
ejemplo
por-defecto
actual
mayor-disponible
Información
relativa
planificación
dependerá
algoritmo
planificación
utilizado
ejemplo
cantidad
tiempo
proceso
esperando
cantidad
tiempo
proceso
ejecutado
corriendo
Evento
identificar
evento
proceso
esperando
continuar
ejecución
Estructuración
datos
proceso
enlazado
proceso
cola
anillo
estructura
ejemplo
procesos
espera
nivel
prioridad
particular
enlazados
cola
proceso
mostrar
relación
padre-hijo
creador-creado
proceso
bloque
control
proceso
contener
punteros
procesos
so-
porte
estructuras
Comunicación
procesos
asociar
flags
señales
mensajes
relativos
comunicación
proce-
sos
independientes
información
mantener
bloque
control
proceso
BCP
Privilegios
proceso
procesos
adquieren
privilegios
memoria
acceder
tipos
instrucciones
ejecutar
Adicionalmente
privilegios
utilizar
uti-
lidades
sistema
servicios
Gestión
memoria
sección
incluir
punteros
tablas
segmentos
páginas
describen
memoria
vir-
tual
asignada
proceso
recursos
utilización
indicar
recursos
controlados
proceso
ejemplo
ficheros
abiertos
incluir
histórico
utilización
procesador
recursos
información
necesaria
planificador
identificador
proceso
prácticamente
sistemas
operativos
proceso
asocia
identificador
numérico
único
simplemente
índice
tabla
procesos
principal
Figura
3.11
forma
existir
traducción
permita
sistema
operativo
localizar
tablas
apropiadas
basándose
identificador
proceso
identifica-
dor
útil
cuestiones
tablas
controladas
sistema
operativo
incluyen
información
referencia
proceso
identificador
proceso
ejem-
plo
puedan
organizar
tablas
memoria
proporcionar
mapa
memoria
principal
indique
proceso
asignada
región
aparecer
referencias
similares
tablas
ficheros
proceso
comunica
proceso
identificador
pro-
ceso
informa
sistema
operativo
destino
comunicación
procesos
crear
procesos
identificadores
indican
proceso
padre
descendientes
caso
identificadores
proceso
proceso
asignar
identificador
usuario
indica
usuario
responsable
trabajo
Descripción
control
procesos
131
03-Capitulo
12/5/05
16:19
Página
131La
información
proceso
indica
contenidos
registros
procesador
proceso
ejecutando
información
registros
proceso
interrumpe
información
registros
salvaguardarse
forma
pue-
restaurar
proceso
continúe
ejecución
naturaleza
número
regis-
tros
depende
diseño
procesador
Normalmente
conjunto
registros
incluye
registros
visi-
bles
usuario
registros
control
punteros
pila
describieron
Capítulo
notar
diseño
procesadores
incluye
registro
conjuntos
regis-
tros
habitualmente
conocidos
palabras
programa
program
status
word
PSW
contiene
información
PSW
típicamente
contiene
códigos
condición
información
ejemplo
palabra
procesador
procesadores
Pentium
definen
registros
EFLAFS
véase
Figura
3.12
Tabla
3.6
es-
tructura
utilizada
sistemas
operativos
incluyendo
UNIX
Windows
ejecuten
procesadores
tipo
Pentium
categoría
principal
información
bloque
control
proceso
denomina
falta
nombre
información
control
proceso
información
adicional
nece-
sita
sistema
operativo
controlar
coordinar
procesos
activos
Ta-
bla
3.5
indica
ámbito
información
examinemos
detalles
funcionamiento
sistema
operativo
sucesivos
capítulos
necesidad
elementos
lista
parecerá
clara
contenido
figura
debería
modificarse
traducción
registros
control
arquitectura
concreto
sentido
puesto
siglas
denotan
inglés
significado
dichas
siglas
traducción
término
encuentran
tabla
Figura
3.13
sugiere
estructura
imágenes
procesos
memoria
virtual
imagen
proceso
consiste
bloque
control
proceso
pila
usuario
espacio
di-
recciones
privadas
proceso
espacio
direcciones
proceso
comparta
procesos
figura
imagen
proceso
aparece
rango
direcciones
contiguo
implementación
real
caso
dependerá
esquema
gestión
memoria
forma
encuentren
organizadas
estructuras
control
sistema
operativo
132
Sistemas
operativos
Aspectos
internos
principios
diseño
IO
PL
31
21
15
16
ID
/H11005
Indicador
identificación
VIP
/H11005
Interrupción
virtual
pendiente
VIF
/H11005
Indicador
interrupción
virtual
AC
/H11005
Comprobación
alineamiento
VM
/H11005
virtual
8086
RF
/H11005
Indicación
reanudación
NT
/H11005
Indicador
tarea
anidada
IOPL
/H11005
Nivel
privilegio
OF
/H11005
Indicador
desbordamiento
DF
/H11005
Indicador
dirección
IF
/H11005
Indicador
interrupciones
habilitadas
TF
/H11005
Indicador
trap
SF
/H11005
Indicador
signo
ZF
/H11005
Indicador
cero
AF
/H11005
Indicador
auxiliar
acarreo
PF
/H11005
Indicador
paridad
CF
/H11005
Indicador
acarreo
Figura
3.12
Registro
EFLAGS
Pentium
II
03-Capitulo
12/5/05
16:19
Página
132Descripción
control
procesos
133
Bits
control
AC
Alignment
check
Fija
palabra
doble-palabra
direcciona-
frontera
palabras
dobles-palabras
ID
Identification
flag
bit
puesto
procesador
soporta
instrucción
CPUID
instrucción
proporciona
información
so-
bre
vendedor
familia
modelo
RF
Resume
flag
Permite
programador
desactivar
extensiones
depuración
forma
instrucción
volverse
ejecutar
excepción
depuración
causar
inmediatamente
excepción
depuración
IOPL
privilege
level
activado
procesador
genere
excep-
ción
accesos
dispositivo
ope-
ración
protegido
DF
Direction
flag
Determina
instrucción
procesamiento
cadenas
caracteres
incrementa
decrementa
semi-registros
16
bits
DI
operaciones
16
bits
registros
32
bits
EDI
operaciones
32
bits
IF
Interruption
enable
flag
puesto
procesador
reconocerá
interrupciones
externas
TF
Trap
flag
puesto
causa
interrupción
eje-
cución
instrucción
dirigido
depuración
código
Bits
modos
operación
NT
Nested
task
flag
Indica
tarea
actual
anidada
tarea
operación
protegido
VM
Virtual
8086
mode
Permite
programador
activar
desactivar
virtual
8086
determina
procesador
funciona
fuese
máqui-
na
8086
VIP
Virtual
interrupt
pending
Usado
virtual
8086
indicar
inte-
rrupciones
espera
servicio
VIF
Virtual
interruption
flag
Usado
virtual
8086
lugar
IF
Códigos
condición
AF
Auxiliar
carry
flag
Representa
acarreo
resto
medios
bytes
opera-
ción
aritmética
lógica
bits
usando
registro
CF
Carry
flag
Indica
acarreo
resto
bit
situado
iz-
quierda
operación
aritmética
modifi-
caron
operaciones
desplazamiento
rotación
OF
Overflow
flag
Indica
desbordamiento
overflow
aritmético
suma
resta
PF
Parity
flag
Paridad
resultado
operación
aritmética
lógica
indi-
ca
paridad
par
indica
paridad
impar
SF
Sign
flag
Indica
signo
resultado
operación
aritmética
lógica
ZF
Zero
flag
Indica
resultado
operación
aritmética
lógica
abla
3.6
Bits
registro
EFLAGS
Pentium
03-Capitulo
12/5/05
16:19
Página
133Como
indica
Tabla
3.5
bloque
control
proceso
contener
información
estructu-
ral
incluyendo
punteros
permiten
enlazar
bloques
control
proceso
forma
colas
describieron
sección
implementarse
listas
enlazadas
bloques
control
proceso
ejemplo
estructura
colas
Figura
3.8a
imple-
mentar
sugiere
Figura
3.14
papel
bloque
control
proceso
bloque
control
proceso
importan-
estructuras
datos
sistema
operativo
bloque
control
proceso
contiene
información
proceso
necesita
sistema
operativo
bloques
leen
modifi-
can
práctica
totalidad
módulos
sistema
operativo
incluyendo
relacionados
planificación
reserva
recursos
procesamiento
regiones
análisis
monitori-
zación
rendimiento
conjunto
bloques
control
proceso
definen
sistema
operativo
muestra
aspecto
importante
diseño
número
rutinas
siste-
ma
operativo
necesitarán
acceder
información
bloques
control
proceso
Proporcio-
nar
acceso
directo
tablas
difícil
proceso
asociado
único
identificador
utilizarse
indexar
tabla
punteros
bloques
control
proceso
dificultad
reside
acceso
protección
posibles
problemas
pre-
sentar
fallo
simple
rutina
manejador
interrupción
dañar
bloques
control
proceso
destruir
capacidad
sistema
manejar
procesos
afectados
cambio
estructura
semántica
bloques
control
procesos
afectar
número
módulos
sistema
operativo
134
Sistemas
operativos
Aspectos
internos
principios
diseño
Bloque
control
proceso
Identificador
proceso
Proceso
Proceso
Proceso
Información
procesador
Información
control
proceso
Pila
usuario
Espacio
privado
direcciones
usuario
programas
datos
Espacio
compartido
direcciones
Identificador
proceso
Identificador
proceso
Información
procesador
Información
procesador
Información
control
proceso
Información
control
proceso
Pila
usuario
Pila
usuario
Espacio
privado
direcciones
usuario
programas
datos
Espacio
privado
direcciones
usuario
programas
datos
Espacio
compartido
direcciones
Espacio
compartido
direcciones
Figura
3.13
Procesos
usuario
memoria
virtual
03-Capitulo
12/5/05
16:19
Página
134Estos
problemas
tratar
obligando
rutinas
sistema
operativo
pasen
rutina
manejador
cuyo
único
trabajo
proteger
bloques
control
proceso
única
realiza
arbitraje
operaciones
lectura
escritura
dichos
bloques
factores
equilibrar
rutina
aspectos
rendimiento
grado
resto
software
sistema
verificarse
determinar
corrección
3.4
CONTROL
PROCESOS
MODOS
EJECUCIÓN
continuar
explicación
sistema
operativo
gestiona
proce-
sos
necesitamos
distinguir
modos
ejecución
procesador
normalmente
asociados
sistema
operativo
asociados
programas
usuario
procesadores
proporcio-
nan
modos
ejecución
instrucciones
ejecutar
modos
privilegia-
únicamente
incluirían
lectura
modificación
registros
control
ejemplo
pa-
labra
programa
instrucciones
primitivas
instrucciones
relacionadas
gestión
memoria
Adicionalmente
regiones
memoria
acceder
mo-
privilegiados
privilegiado
denomina
usuario
programas
usuario
típicamente
ejecutan
privilegiado
denomina
sistema
control
núcleo
término
refiere
núcleo
sistema
operativo
sistema
operativo
engloba
funciones
importantes
sistema
Tabla
3.7
lista
funciones
normalmente
encuentran
núcleo
sistema
operativo
Descripción
control
procesos
135
Ejecutando
Listo
Bloqueado
Bloque
control
proceso
Figura
3.14
Estructuras
listas
procesos
03-Capitulo
12/5/05
16:19
Página
135
abla
3.7
.Funciones
típicas
núcleo
sistema
operativo
Gestión
procesos
Creación
terminación
procesos
Planificación
activación
procesos
Intercambio
procesos
Sincronización
procesos
soporte
comunicación
procesos
Gestión
bloques
control
proceso
Gestión
memoria
Reserva
espacio
direcciones
procesos
Swapping
Gestión
páginas
segmentos
Gestión
Gestión
buffers
Reserva
canales
dispositivos
procesos
Funciones
soporte
Gestión
interrupciones
Auditoría
Monitorización
motivo
modos
necesita
proteger
sistema
operativo
tablas
clave
sistema
ejemplo
bloques
control
proceso
interferencia
programas
usuario
núcleo
software
control
completo
procesador
instrucciones
registros
memoria
nivel
control
necesario
seguridad
reco-
mendable
programas
usuario
Aparecen
cuestiones
conoce
procesador
ejecutando
modificarse
referente
cuestión
típicamente
bit
palabra
programa
PSW
indica
ejecución
bit
cambia
respuesta
determinados
eventos
Habitualmente
usuario
realiza
llamada
servicio
siste-
ma
operativo
interrupción
dispara
ejecución
rutina
sistema
operativo
ejecución
cambia
núcleo
finalización
servicio
fija
usuario
ejemplo
consideramos
procesador
Intel
Itanium
implemen-
ta
arquitectura
IA-64
64
bits
procesador
registro
psr
incluye
campo
bits
llamado
cpl
current
privilege
level
Nivel
nivel
privile-
gios
Nivel
nivel
privilegios
mayoría
sistemas
operati-
vos
Linux
utilizar
Nivel
núcleo
niveles
nivel
usuario
llega
interrupción
procesador
limpia
bits
psr
incluyendo
campo
cpl
automáticamente
pone
cpl
rutina
manejo
interrupción
instrucción
ejecuta
irt
interrupt
return
instrucción
procesador
restaure
psr
programa
interrumpido
restaura
nivel
privilegios
pro-
grama
secuencia
similar
ocurre
aplicación
solicita
llamada
sistema
Itanium
aplicación
solicita
llamada
sistema
indicando
identificador
llamada
sistema
136
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
136y
argumentos
dicha
llamada
áreas
definidas
posteriormente
ejecutando
instruc-
ción
especial
invocar
usuario
objeto
transferir
control
núcleo
CREACIÓN
PROCESOS
Sección
3.1
comentado
eventos
llevará
creación
proceso
vistas
estructuras
datos
asociadas
proceso
posiciones
posición
describir
breve-
mente
pasos
llevan
creación
proceso
sistema
operativo
decide
motivo
Tabla
3.1
crear
proceso
pro-
cederá
Asignar
identificador
proceso
único
proceso
instante
añade
entrada
tabla
primaria
procesos
contiene
entrada
proceso
Reservar
espacio
proceso
incluye
elementos
imagen
proceso
sistema
operativo
memoria
requiere
espacio
di-
recciones
privado
programas
datos
pila
usuario
valores
asig-
nar
defecto
basándonos
tipo
proceso
fijarse
base
solicitud
creación
trabajo
remitido
usuario
proceso
creado
proceso
pro-
ceso
padre
pasar
parámetros
requeridos
sistema
operativo
solicitud
creación
proceso
espacio
direcciones
compartido
proceso
fijan
enlaces
apropiados
reservar
espacio
bloque
control
proceso
BCP
Inicialización
bloque
control
proceso
identificación
proceso
BCP
contiene
identificador
proceso
posibles
identificadores
indicador
proceso
padre
información
proceso
BCP
habitualmente
inicializa
mayoría
entradas
contador
programa
fijado
pun-
to
entrada
programa
punteros
pila
sistema
fijados
definir
límites
pila
proceso
información
control
procesos
inicializa
base
va-
lores
omisión
considerando
atributos
solicitados
proce-
so
ejemplo
proceso
inicializar
normalmente
Listo
Listo
Sus-
pendido
prioridad
fijar
defecto
prioridad
baja
solicitud
explicita
eleve
prioridad
Inicialmente
proceso
poseer
nin-
gún
recurso
dispositivos
ficheros
exista
indicación
explícita
heredados
padre
Establecer
enlaces
apropiados
ejemplo
sistema
operativo
mantiene
cola
planificador
lista
enlazada
proceso
situarse
cola
Listos
cola
Listos
Suspendidos
Creación
expansión
estructuras
datos
ejemplo
sistema
operativo
pue-
mantener
registro
auditoría
proceso
utilizar
posteriormente
efectos
facturación
análisis
rendimiento
sistema
CAMBIO
PROCESO
vista
operación
cambio
proceso
parecer
sencilla
casos
pro-
ceso
ejecución
interrumpe
sistema
operativo
asigne
proceso
Eje-
cutando
forma
establecer
turno
procesos
necesario
Descripción
control
procesos
137
03-Capitulo
12/5/05
16:19
Página
137cuenta
consideraciones
diseño
evento
dispara
cambios
proceso
consideración
distinción
cambio
proceso
process
switching
cambio
mode
switching
sistema
operativo
estructuras
gestiona
proporcionar
cambio
proceso
realiza
cambio
proceso
cambio
proceso
ocurrir
ins-
tante
sistema
operativo
obtiene
control
proceso
actualmente
ejecución
Tabla
3.8
indica
posibles
momentos
sistema
operativo
tomar
control
consideremos
interrupciones
sistema
Realmente
distinguir
sistemas
tipos
interrupciones
sistema
simplemente
deno-
minadas
interrupciones
denominadas
traps
primeras
producen
causa
al-
gún
tipo
evento
externo
independiente
proceso
actualmente
ejecución
ejem-
plo
finalización
operación
S.
asociadas
condición
error
excepción
generada
proceso
ejecutando
intento
acceso
permiti-
do
fichero
interrupción
ordinaria
control
transfiere
inicialmente
ma-
nejador
interrupción
realiza
determinadas
tareas
internas
posteriormente
salta
rutina
sistema
operativo
encargada
tipos
interrupciones
particular
Al-
gunos
ejemplos
Interrupción
reloj
sistema
operativo
determinar
proceso
ejecución
excedido
unidad
máxima
tiempo
ejecución
denominada
rodaja
tiempo
time
slice
rodaja
tiempo
máxima
cantidad
tiempo
proceso
ejecutar
interrumpido
caso
proceso
pasar
Listo
activar
proceso
Interrupción
S.
sistema
operativo
determina
acción
ocurrido
ac-
ción
constituye
evento
esperando
procesos
sistema
operativo
mueve
procesos
correspondientes
Listos
procesos
es-
tado
Bloqueado
Suspendido
Listo
Suspendido
sistema
operativo
decidir
reanuda
ejecución
proceso
actualmente
Ejecutando
expulsa
proce-
der
ejecución
proceso
Listo
prioridad
abla
3.8
Mecanismos
interrupción
ejecución
proceso
Mecanismo
Causa
Interrupción
Externa
ejecución
proceso
Reacción
evento
externo
actualmente
ejecución
asíncrono
Trap
Asociada
ejecución
Manejo
condición
error
instrucción
actual
excepción
Llamada
sistema
Solicitud
explícita
Llamada
función
sistema
operativo
Fallo
memoria
procesador
referencia
dirección
memoria
virtual
palabra
memoria
principal
sistema
operativo
tra-
er
bloque
página
segmento
contiene
referencia
memoria
secundaria
me-
moria
principal
solicita
operación
traer
bloque
memoria
proceso
causó
fallo
memoria
pasa
Bloqueado
sistema
operativo
realiza
cambio
proceso
pone
ejecutar
proceso
bloque
memoria
solicitado
traído
proceso
pasará
Listo
138
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
138Con
trap
sistema
operativo
conoce
condición
error
excepción
irreversible
proceso
ejecución
pone
Saliente
cambio
proceso
sistema
operativo
actuará
dependiendo
naturaleza
error
diseño
intentar
procedimiento
recuperación
simplemente
notificación
usuario
pudiendo
implicar
cambio
proceso
continuación
ejecución
proceso
actual
sistema
operativo
activar
llamada
sistema
proceden-
programa
ejecución
ejemplo
ejecutando
proceso
ejecuta
opera-
ción
implica
llamada
abrir
archivo
llamada
implica
salto
ruti-
na
código
sistema
operativo
realización
llamada
sistema
implicar
casos
proceso
realiza
pase
Bloqueado
Cambio
Capítulo
discutimos
inclusión
fase
interrupción
ciclo
instrucción
Recordando
fase
interrupción
procesador
comprueba
exista
interrupción
pendiente
indicada
presencia
señal
interrupción
interrupciones
pendientes
procesador
pasa
fase
búsqueda
instrucción
siguien-
do
programa
proceso
actual
interrupción
pendiente
proceso
actúa
si-
guiente
Coloca
contador
programa
dirección
comienzo
rutina
programa
mane-
jador
interrupción
Cambia
usuario
núcleo
forma
código
tratamiento
interrup-
ción
incluir
instrucciones
privilegiadas
procesador
acto
seguido
pasa
fase
búsqueda
instrucción
busca
instruc-
ción
programa
manejo
interrupción
dará
servicio
punto
habitual-
mente
contexto
proceso
interrumpido
salvaguarda
bloque
control
pro-
ceso
programa
interrumpido
pregunta
plantear
constituye
contexto
salvaguardar
respuesta
información
alterada
ejecución
rutina
interrupción
necesitará
continuación
proceso
interrumpido
forma
guardar
bloque
control
proceso
referencia
infor-
mación
procesador
incluye
contador
programa
registros
procesa-
dor
información
pila
necesita
depende
ocurra
manejador
interrupción
habitualmente
pequeño
programa
realiza
tareas
básicas
relativas
interrupción
ejemplo
borra
flag
indicador
señala
presencia
interrupciones
enviar
confirmación
entidad
lanzó
dicha
interrupción
ejemplo
módulo
S.
tareas
internas
variadas
relativas
efectos
evento
causó
interrupción
ejemplo
interrupción
refiere
evento
manejador
interrupción
comproba-
rá
existencia
condición
error
ocurrido
error
manejador
mandará
se-
ñal
proceso
solicitó
dicha
operación
S.
interrupción
proviene
reloj
manejador
pasar
control
activador
decidirá
pasar
proceso
rodaja
tiempo
asignada
proceso
expirado
pasa
resto
información
bloque
control
proceso
interrupción
cambio
proceso
proceso
necesita
cosas
sistemas
operativos
existencia
interrupción
implica
necesariamente
cambio
proceso
ejecución
rutina
interrupción
ejecu-
ción
reanude
proceso
casos
necesita
salvaguardar
información
procesador
produce
interrupción
restablecerlo
reanude
Descripción
control
procesos
139
03-Capitulo
12/5/05
16:19
Página
139ejecución
proceso
Habitualmente
operaciones
salvaguarda
recuperación
realizan
hardware
Cambio
proceso
cambio
concepto
di-
ferente
cambio
proceso
cambio
ocurrir
cambie
proceso
actualmente
Ejecutando
caso
salvaguarda
posterior
restauración
comportan
ligera
sobrecarga
proceso
actualmente
Ejecutando
mover
Listo
Bloqueado
etc.
sistema
opera-
tivo
cambios
sustanciales
entorno
pasos
realizan
cambio
proceso
completo
Salvar
procesador
incluyendo
contador
programa
registros
Actualizar
bloque
control
proceso
actualmente
Ejecutando
incluye
cambiar
proceso
Listo
Bloqueado
Lis-
to
Suspendido
Saliente
actualizar
campos
importantes
inclu-
yendo
razón
proceso
dejado
Ejecutando
información
auditoría
Mover
bloque
control
proceso
cola
apropiada
Listo
Bloqueado
evento
Listo
Suspendido
Selección
proceso
ejecutar
cuestión
analiza
detalle
Actualizar
bloque
control
proceso
elegido
incluye
pasarlo
Ejecutando
Actualizar
estructuras
datos
gestión
memoria
necesitar
depen-
diendo
haga
traducción
direcciones
aspectos
cubrirán
Restaurar
procesador
momento
proceso
selecciona-
do
salió
Ejecutando
leyendo
valores
anteriores
contador
programa
registros
cambio
proceso
implica
cambio
requiere
esfuerzo
cambio
EJECUCIÓN
SISTEMA
OPERATIVO
Capítulo
señalamos
aspectos
intrínsecos
sistema
operativo
sistema
operativo
funciona
forma
software
sentido
sistema
operativo
conjunto
programas
ejecutados
procesador
sistema
operativo
frecuencia
cede
control
depende
procesador
recuperar
control
140
Sistemas
operativos
Aspectos
internos
principios
diseño
término
cambio
contexto
context
switch
literatura
sistemas
operativos
libros
texto
Desafortu-
nadamente
mayoría
referencias
utilizan
término
libro
denominado
cambio
pr
oce-
so
fuentes
referirse
cambio
cambio
thread
definido
capítulo
evi-
tar
ambigüedades
término
utilizado
libro
03-Capitulo
12/5/05
16:19
Página
140Si
sistema
operativo
simplemente
colección
programas
ejecutados
procesador
programa
sistema
operativo
proceso
sistema
controla
interesantes
cuestiones
inspirado
cuentas
direcciones
dife-
rentes
diseño
Figura
3.15
ilustra
rango
visiones
encuentran
sistemas
operativos
contemporáneos
Núcleo
procesos
visión
tradicional
común
sistemas
operativos
anti-
guos
ejecución
sistema
operativo
proceso
Figura
3.15a
visión
proceso
ejecución
interrumpe
invoca
llamada
sistema
contexto
guarda
control
pasa
núcleo
sistema
operativo
región
memoria
pila
sistema
controlar
llamada
procedimientos
retornos
sistema
ope-
rativo
funciones
necesite
restaurar
contexto
proceso
interrum-
pido
retome
ejecución
proceso
usuario
afectado
forma
alternativa
sistema
operativo
salvaguarda
contexto
activación
proceso
di-
ferente
ocurre
depende
causa
interrupción
circunstancias
puntua-
momento
caso
punto
clave
caso
concepto
proceso
aplica
única-
mente
programas
usuario
código
sistema
operativo
ejecuta
entidad
inde-
pendiente
requiere
privilegiado
ejecución
Ejecución
procesos
usuario
alternativa
común
sistemas
operativos
máquinas
pequeñas
PC
estaciones
trabajo
ejecutar
virtualmente
softwa-
re
sistema
operativo
contexto
proceso
usuario
visión
sistema
ope-
rativo
percibe
conjunto
rutinas
usuario
invoca
funcio-
nes
ejecutadas
entorno
proceso
usuario
muestra
Figura
3.15b
punto
determinado
sistema
operativo
maneja
imágenes
procesos
imagen
incluye
Descripción
control
procesos
141
P1
P2
Pn
Núcleo
Núcleo
independiente
Funciones
SO
ejecutan
procesos
independiente
Fun-
ciones
SO
Funciones
conmutación
procesos
Funciones
conmutación
procesos
Funciones
SO
ejecutan
proceso
usuario
P1
P1
P2
OS1
P2
Pn
Pn
OSk
Fun-
ciones
SO
Fun-
ciones
SO
Figura
3.15
Relación
sistema
operativo
procesos
usuario
03-Capitulo
12/5/05
16:19
Página
141sólo
regiones
mostradas
Figura
3.13
incluye
áreas
programa
datos
pila
programas
núcleo
Figura
3.16
sugiere
estructura
imagen
proceso
típica
estrategia
pila
núcleo
separada
manejar
llamadas
retornos
proceso
núcleo
código
sistema
operativo
datos
espacio
direcciones
compartidas
compar-
ten
procesos
ocurre
interrupción
trap
llamada
sistema
procesador
pone
nú-
cleo
control
pasa
sistema
operativo
contexto
salva
cambia
rutina
sistema
operativo
ejecución
continúa
proceso
usuario
actual
forma
realiza
cambio
proceso
cambio
proceso
sistema
operativo
trabajo
determina
proceso
actual
continuar
ejecución
cambio
continúa
programa
interrum-
pido
proceso
principales
ventajas
alternativa
in-
terrumpido
programa
usuario
utilizar
rutina
sistema
operativo
conti-
núa
incurrir
doble
cambio
proceso
determina
cambio
proceso
lugar
continuar
proceso
control
pasa
rutina
cambio
proceso
rutina
ejecutarse
proceso
actual
dependiendo
diseño
sistema
momento
obstante
proceso
actual
ejecución
designando
porceso
142
Sistemas
operativos
Aspectos
internos
principios
diseño
Identificador
proceso
Información
procesador
Información
control
proceso
Pila
usuario
Espacio
privado
direcciones
usuario
programas
datos
Pila
núcleo
Espacio
compartido
direcciones
Bloque
control
proceso
Figura
3.16
Imagen
proceso
sistema
operativo
ejecuta
espacio
usuario
03-Capitulo
12/5/05
16:19
Página
142ejecutar
fase
conveniente
ejecución
cualquiera
procesos
forma
visión
sistema
operativo
reseñable
forma
senci-
lla
determinados
instantes
tiempo
proceso
salva
elige
proceso
ejecutar
en-
tre
listos
delega
control
proceso
razón
esquema
convierte
situación
arbitraria
caótica
instantes
críticos
código
ejecutando
código
compartido
sistema
operativo
código
usuario
con-
cepto
usuario
núcleo
usuario
interferir
rutinas
sistema
ope-
rativo
ejecutando
entorno
proceso
usuario
re-
cuerda
clara
distinción
concepto
proceso
programa
relación
proceso
ejecutarse
programas
usuario
programas
sistema
operativo
programas
sistema
operativo
ejecutan
procesos
usuario
idénticos
Sistemas
operativos
basados
procesos
alternativa
mostrada
Figura
3.15c
implementar
sistema
operativo
colección
procesos
sistema
op-
ciones
software
núcleo
ejecuta
núcleo
caso
principales
funciones
núcleo
organizan
procesos
independientes
pequeña
cantidad
código
intercambio
procesos
ejecuta
procesos
visión
ventajas
Impone
disciplina
diseño
programas
refuerza
sistemas
operativos
modulares
mínimas
claras
interfaces
módulos
Adicio-
nalmente
funciones
sistema
operativo
críticas
convenientemente
separa-
das
procesos
ejemplo
mencionado
anteriormente
programa
monitoriza-
ción
recoge
niveles
utilización
recursos
procesador
memoria
canales
ratio
progreso
procesos
sistema
programa
realiza
servicio
programa
activo
invocar
sistema
operativo
proceso
fun-
ción
ejecutarse
nivel
prioridad
determinado
intercalándose
procesos
control
activador
implementación
sistema
operativo
grupo
proce-
sos
entornos
multiprocesadores
multicomputadores
determinados
servicios
sistema
operativo
enviar
procesadores
dedicados
incrementando
rendimiento
3.5
UNIX
SVR4
PROCESS
MANAGEMENT
UNIX
System
gestión
procesos
simple
potente
fácilmente
visi-
ble
nivel
usuario
UNIX
modelo
mostrado
Figura
3.15b
mayoría
sistema
operativo
ejecuta
entorno
proceso
forma
necesitan
mo-
usuario
núcleo
UNIX
utiliza
categorías
procesos
procesos
sistema
proce-
sos
usuario
procesos
sistema
ejecutan
núcleo
ejecuta
código
sistema
opera-
tivo
tareas
administrativas
funciones
internas
reserva
memoria
swapping
procesos
procesos
usuario
operan
usuario
ejecutar
programas
utilidades
núcleo
ejecutar
instrucciones
pertenecen
núcleo
proceso
usuario
entra
núcleo
solicitud
llamada
sistema
genera
excepción
fallo
ocurre
interrupción
PROCESOS
sistemas
operativos
UNIX
utilizan
proceso
encuentran
recogidos
Tabla
3.9
diagrama
transiciones
muestra
Figura
3.17
basada
figura
Descripción
control
procesos
143
03-Capitulo
12/5/05
16:19
Página
143en
BACH86
figura
similar
Figura
3.9b
procesos
dormidos
UNIX
correspondientes
bloqueo
diferencias
resumir
UNIX
utiliza
Ejecutando
indican
proceso
ejecutando
usua-
rio
núcleo
distinción
Listo
Ejecutar
Memoria
Expulsa-
do
esencialmente
indica
línea
punteada
une
distinción
realiza
énfasis
forma
llega
Ex-
pulsado
proceso
ejecuta
núcleo
resultado
llamada
siste-
ma
interrupción
reloj
interrupción
requerirá
tiempo
sistema
ope-
rativo
complete
trabajo
esté
listo
devolver
control
proceso
usuario
punto
núcleo
decide
expulsar
proceso
actual
favor
procesos
listos
prioridad
caso
proceso
actual
mueve
Expulsado
cuestiones
activación
procesos
Expulsado
es-
tados
Listo
Ejecutar
Memoria
forman
única
cola
expulsión
ocurrir
proceso
punto
moverse
núcleo
usuario
procesos
ejecutan
núcleo
expulsados
sistemas
UNIX
apropiados
procesamiento
tiempo
real
proporcionará
explicación
requisitos
procesamiento
tiempo-real
Capítulo
10
UNIX
procesos
interés
particular
proceso
proceso
especial
crea
sistema
arranca
realidad
estructura
datos
predefinida
carga
ordenador
arranca
proceso
swapper
Adicionalmente
proceso
lanza
proceso
denomina
proceso
init
procesos
sistema
proceso
antecesor
usuario
interactivo
entrar
sistema
proceso
crea
proce-
so
usuario
Posteriormente
proceso
usuario
crear
procesos
hijos
conforman
estructura
árbol
procesos
forma
aplicación
particular
pue-
consistir
número
procesos
relacionados
abla
3.9
procesos
UNIX
Ejecutando
Usuario
Ejecutando
usuario
Ejecutando
Núcleo
Ejecutando
núcleo
Listo
Ejecutar
Memoria
Listo
ejecutar
núcleo
planifique
Dormido
Memoria
ejecutar
ocurra
evento
proceso
memoria
principal
bloqueo
Listo
Ejecutar
Swap
proceso
listo
preguntar
swapper
cargar
proceso
memoria
principal
nú-
cleo
planificarlo
ejecución
Durmiendo
Swap
proceso
esperando
evento
expulsado
almacenamiento
secundario
bloqueo
Expulsado
proceso
regresado
núcleo
usuario
núcleo
expulsado
activación
proceso
Creado
proceso
creado
recientemente
listo
ejecutar
Zombie
proceso
deja
registro
re-
coja
proceso
padre
144
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
144DESCRIPCIÓN
PROCESOS
proceso
UNIX
conjunto
estructuras
datos
complejas
proporcionan
sistema
operativo
información
necesaria
manejar
activar
procesos
Tabla
3.10
re-
coge
elementos
imagen
proceso
organizados
partes
contexto
nivel
usuario
contexto
registros
contexto
nivel
sistema
contexto
nivel
usuario
contiene
elementos
básicos
programa
usuario
generar
directamente
fichero
objeto
compilado
programa
usuario
divide
áreas
texto
datos
área
texto
sólo-lectura
crea
intención
contener
instrucciones
programa
proceso
ejecución
procesador
uti-
liza
área
pila
usuario
gestionar
llamadas
procedimientos
retornos
parámetros
pasados
área
memoria
compartida
área
datos
com-
procesos
única
copia
física
área
memoria
compartida
utilización
memoria
virtual
presenta
procesos
comparten
región
memoria
común
espacio
dirección
pro-
ceso
ejecutando
información
procesador
almacena
área
contexto
registros
contexto
nivel
sistema
contiene
información
restante
necesita
sistema
ope-
rativo
manejar
proceso
Consiste
estática
tamaño
fijo
permanece
proceso
tiempo
vida
dinámica
varía
tamaño
vida
proceso
entrada
tabla
procesos
elemento
estática
contiene
información
control
proceso
accesible
núcleo
Descripción
control
procesos
145
Fork
suficiente
memoria
sistemas
swap)Suficiente
memoria
Recuperación
swap
Expulsión
swap
Expulsión
swap
DespertarDespertarDormido
Retorno
Expulsión
Retorno
usuario
Llamada
sistema
interrupción
Salida
Replanificación
proceso
Interrupción
retorno
interrupción
Expulsado
Creado
Listo
ejecutar
swap
Listo
ejecutar
memoria
Ejecutando
núcleo
Zombie
Dormido
memoria
Dormido
swap
Ejecutando
usuario
Figura
3.17
Diagrama
transiciones
procesos
UNIX
03-Capitulo
12/5/05
16:19
Página
145en
momento
sistema
memoria
virtual
entradas
tabla
procesos
mantienen
memoria
principal
Tabla
3.11
muestra
contenidos
entrada
tabla
procesos
área
usuario
área
contiene
información
adicional
proceso
necesita
núcleo
ejecutando
contexto
proceso
utiliza
proceso
pagina
memoria
swapping
Tabla
3.12
muestra
conteni-
dicha
tabla
abla
3.10
Imagen
proceso
UNIX
Contexto
nivel
usuario
Texto
Instrucciones
máquina
ejecutables
programa
Datos
Datos
accesibles
programa
asociado
proceso
Pila
usuario
Contiene
argumentos
variables
locales
punteros
funciones
ejecutadas
usuario
Memoria
compartida
Memoria
compartida
procesos
usada
comuni-
cación
procesos
Contexto
registros
Contador
programa
Dirección
instrucción
ejecutar
tratar-
espacio
memoria
núcleo
usuario
proceso
Registro
Contiene
hardware
procesador
momento
procesador
expulsión
contenidos
formato
dependen
específi-
camente
hardware
Puntero
pila
Apunta
cima
pila
núcleo
usuario
dependiendo
operación
momento
expulsión
Registros
propósito
general
Depende
hardware
Contexto
nivel
sistema
Entrada
tabla
procesos
Define
proceso
información
ac-
cesible
sistema
operativo
Área
usuario
Información
control
proceso
necesita
acceder
contexto
proceso
Tabla
regiones
proceso
Define
traducción
direcciones
virtuales
físicas
contiene
información
permisos
indican
tipo
acceso
permitido
proceso
sólo-lectura
lec-
tura-escritura
lectura-ejecución
Pila
núcleo
Contiene
marco
pila
procedimientos
núcleo
proceso
ejecuta
núcleo
146
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
146
abla
3.11
Entrada
tabla
procesos
UNIX
proceso
actual
proceso
Punteros
área
área
memoria
proceso
texto
datos
pila
Tamaño
proceso
Permite
sistema
operativo
espacio
reservado
proceso
Identificadores
usuario
ID
usuario
real
identifica
usuario
responsable
ejecución
proceso
ID
usuario
efectivo
utilizar
proceso
gane
forma
temporal
privilegios
aso-
ciados
programa
particular
programa
eje-
cuta
proceso
proceso
opera
identificador
usuario
efectivo
Identificadores
proceso
Identificador
proceso
identificador
proceso
padre
identificadores
fijan
proceso
entra
Creado
llamaba
sistema
fork
Descriptor
evento
Válido
proceso
dormido
evento
ocurre
proceso
mueve
Listo
Ejecutar
Prioridad
Utilizado
planificación
proceso
Señal
Enumera
señales
enviadas
proceso
manejadas
Temporizadores
Incluye
tiempo
ejecución
proceso
utilización
recur-
sos
núcleo
temporizador
fijado
usuario
enviar
señal
alarma
proceso
P_link
Puntero
enlace
cola
Listos
válido
proceso
Listo
Ejecutar
memoria
Indica
imagen
proceso
memoria
principal
secundaria
memoria
campo
indica
expulsado
swap
temporalmente
fijado
memoria
principal
distinción
entrada
tabla
procesos
área
refleja
núcleo
UNIX
ejecuta
contexto
proceso
tiempo
nú-
cleo
realizando
tareas
relacionadas
proceso
tiempo
núcleo
realizando
tareas
planificación
preparatorias
activación
proceso
necesita
información
totalidad
procesos
sistema
informa-
ción
tabla
procesos
accesible
proceso
específico
actualmente
ejecución
estática
contexto
nivel
sistema
tabla
regiones
proceso
utiliza
sistema
gestión
memoria
pila
núcleo
dinámica
contexto
nivel
sistema
pila
proceso
ejecutando
núcleo
contiene
información
salvaguardarse
restaurarse
llamadas
procedimientos
ocurre
interrupción
Descripción
control
procesos
147
03-Capitulo
12/5/05
16:19
Página
147
abla
3.12
Área
UNIX
Puntero
tabla
proceso
Indica
entrada
correspondiente
área
U.
Identificador
usuario
Identificador
usuario
real
efectivo
Utilizado
deter-
minar
privilegios
Temporizadores
Registro
tiempo
proceso
descendientes
utilizado
ejecutar
usuario
núcleo
Vector
manejadores
señales
tipo
señal
definida
sistema
indica
proceso
reaccionar
hora
recibirla
salir
ignorar
ejecutar
función
específica
definida
usuario
Terminal
control
Indica
terminal
acceso
login
proceso
Campo
error
Recoge
errores
encontrados
llamada
sistema
Valor
retorno
Contiene
resultados
llamada
sistema
Parámetros
Indica
cantidad
datos
transferidos
dirección
fuente
destino
vector
datos
espacio
usuario
desplazamientos
fichero
S.
Parámetros
fichero
Directorio
actual
directorio
raíz
sistema
fi-
cheros
asociado
entorno
proceso
Tabla
descriptores
fichero
Recoge
ficheros
proceso
abierto
usuario
Campos
límite
Restringe
tamaño
proceso
tamaño
máximo
fi-
chero
crear
Campos
modos
permiso
Máscara
modos
protección
creación
fi-
cheros
proceso
CONTROL
PROCESOS
creación
procesos
UNIX
realiza
llamada
sistema
fork
proceso
solicita
llamada
fork
sistema
operativo
realiza
siguientes
funciones
BACH86
Solicita
entrada
tabla
procesos
proceso
Asigna
identificador
proceso
único
proceso
hijo
copia
imagen
proceso
padre
excepción
regiones
memoria
compartidas
Incrementa
contador
fichero
posesión
padre
reflejar
proceso
adi-
cional
posee
dichos
ficheros
Asigna
proceso
hijo
Listo
Ejecutar
Devuelve
identificador
proceso
hijo
proceso
padre
valor
proceso
hijo
trabajo
realiza
núcleo
proceso
padre
núcleo
com-
pletado
funciones
cualquiera
siguientes
acciones
rutina
activador
148
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
1481
Continuar
proceso
padre
control
vuelve
usuario
punto
rea-
lizó
llamada
fork
padre
Transferir
control
proceso
hijo
proceso
hijo
comienza
ejecutar
punto
código
padre
punto
retorno
llamada
fork
Transferir
control
proceso
procesos
padre
hijo
permanecen
Listos
Ejecutar
resultar
difícil
visualizar
creación
procesos
procesos
padre
hijo
ejecutando
segmento
código
diferencia
reside
retorna
función
fork
parámetro
retorno
comprueba
valor
en-
tonces
proceso
hijo
bifurcación
ejecución
programa
continuar
ejecución
programa
hijo
valor
proceso
padre
continuar
línea
principal
ejecución
3.6
RESUMEN
concepto
fundamental
sistemas
operativos
modernos
concepto
proceso
función
principal
sistema
operativo
crear
gestionar
finalizar
procesos
pro-
ceso
activo
sistema
operativo
reservar
tiempo
ejecución
procesador
coordinar
actividades
gestionar
demandas
planteen
conflictos
reservar
re-
cursos
sistema
procesos
funciones
gestión
procesos
sistema
operativo
mantiene
descrip-
ción
proceso
imagen
proceso
incluye
espacio
direcciones
proceso
ejecutando
bloque
control
proceso
contiene
información
sistema
operativo
necesita
gestionar
proceso
incluyendo
actual
reserva
recursos
prioridad
datos
relevancia
tiempo
vida
proceso
mueve
im-
portantes
Listo
Ejecutando
Bloqueado
proceso
Listo
proceso
actualmente
ejecución
listo
ejecutado
sistema
operativo
active
proceso
Ejecutando
actualmente
ejecución
procesador
sistemas
multiprocesador
procesos
proceso
Bloqueado
esperando
complete
determinado
evento
opera-
ción
S.
proceso
ejecución
interrumpe
interrupción
evento
ocu-
rre
proceso
recogido
procesador
ejecución
llamada
sistema
caso
procesador
realiza
cambio
transferencia
control
rutinas
sistema
operativo
sistema
operativo
realiza-
do
trabajo
necesario
continuar
proceso
interrumpido
cambiar
procesos
3.7
LECTURAS
RECOMENDADAS
libros
texto
listados
Sección
2.9
cubren
material
capítulo
en-
contrar
GOOD94
GRAY97
descripciones
gestión
procesos
UNIX
NEHM75
descripción
interesante
proceso
sistema
operativo
fun-
ciones
necesarias
activación
procesos
Descripción
control
procesos
149
03-Capitulo
12/5/05
16:19
Página
149GOOD94
Goodheart
B.
Cox
J.
The
magic
Garden
Explained
The
Internals
of
UNIX
System
Rele-
ase
Englewood
Cliffs
NJ
Prentice
Hall
1994
GRAY97
Gray
J.
Interprocess
Communication
in
Unix
The
Nooks
and
Crannies
Upper
Saddler
Ri-
NJ
Prentice
Hall
1997
NEHM75
Nehmer
J.
Dispatcher
Primitives
for
the
Construction
of
Operating
System
Kernels
Acta
Informática
vol
1975
3.8
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
bloque
control
proceso
imagen
proceso
proceso
hijo
cambio
interrupción
proceso
padre
cambio
proceso
núcleo
round-robin
bloqueado
privilegiado
swapping
ejecutando
sistema
tarea
listo
usuario
traza
saliente
trap
suspendido
palabra
programa
expulsión
proceso
CUESTIONES
REPASO
3.1
traza
instrucciones
3.2
eventos
comunes
llevan
creación
proceso
3.3
modelo
procesamiento
Figura
3.6
defina
brevemente
3.4
significa
expulsión
proceso
3.5
swapping
objetivo
3.6
Figura
3.9
bloqueados
3.7
Indique
características
proceso
suspendido
3.8
tipo
entidades
sistema
operativo
mantiene
tablas
información
moti-
vos
gestión
3.9
Indique
categorías
generales
información
bloque
control
proceso
3.10
necesitan
modos
usuario
núcleo
3.11
pasos
realiza
sistema
operativo
creación
proceso
3.12
diferencia
interrupción
trap
3.13
Dé
ejemplos
interrupción
3.14
diferencia
cambio
cambio
proceso
150
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
150PROBLEMAS
3.1
Nombre
actividades
principales
sistema
operativo
gestión
proce-
sos
forma
describa
necesaria
3.2
PINK89
definen
procesos
siguientes
ejecuta
ejecutando
ac-
tivo
listo
bloqueado
suspendido
proceso
bloqueado
esperando
per-
miso
acceder
recurso
bloqueado
esperando
realice
operación
recurso
adquirido
sistemas
operativos
agrupados
bloqueado
suspendido
sen-
tido
usado
capítulo
Compare
ventajas
ambas
definiciones
3.3
modelo
Figura
3.9b
dibuje
diagrama
colas
similar
Figura
3.8b
3.4
Considerando
diagrama
transiciones
Figura
3.9b
Suponga
toca
siste-
ma
operativo
activar
proceso
procesos
Listo
Listo
Suspendi-
do
procesos
Listo
Suspendido
prioridad
procesos
Listos
políticas
extremas
activar
pro-
ceso
Listo
minimizar
efecto
swapping
preferencia
procesos
prioridad
implique
swapping
swapping
fuese
necesario
Sugiera
política
encuentre
punto
prioridad
rendimiento
3.5
Tabla
3.13
muestra
proceso
sistema
operativo
AX
VMS
proporcionar
justificación
existencia
tantos
distintos
espera
siguientes
versión
residente
swap
espera
fallo
página
espera
colisión
página
espera
evento
común
espera
libe-
ración
página
espera
recurso
Dibuje
diagrama
transiciones
indique
acción
suceso
causa
dicha
transición
3.6
sistema
operativo
AX
VMS
utiliza
modos
acceso
procesador
facilitar
protección
compartición
recursos
sistema
procesos
acceso
determina
Privilegios
ejecución
instrucciones
instrucciones
ejecutar
procesador
Privilegios
acceso
memoria
posiciones
memoria
acceder
ins-
trucciones
actuales
cuatros
modos
acceso
Núcleo
Ejecuta
núcleo
sistema
operativo
VMS
incluye
gestión
memoria
manejo
interrupciones
operaciones
S.
Ejecutivo
Ejecuta
llamadas
sistema
incluyendo
rutinas
gestión
ficheros
registros
disco
cinta
Supervisor
Ejecuta
servicios
sistema
operativo
tales
respuestas
mandatos
usuario
Usuario
Ejecuta
programas
usuario
utilidades
compilado-
res
editores
enlazadores
depuradores
Descripción
control
procesos
151
03-Capitulo
12/5/05
16:19
Página
151
abla
3.13
VAX
VMS
Proceso
Proceso
Condición
Proceso
Actualmente
ejecución
Proceso
ejecución
Computable
residente
Listo
residente
memoria
principal
Computable
swap
Listo
expulsado
memoria
principal
Espera
fallo
página
proceso
referencia
página
memoria
principal
esperar
dicha
página
lea
Espera
colisión
página
proceso
referencia
página
compartida
causa
espera
fallo
página
proce-
so
página
privada
fase
leída
me-
moria
escrita
disco
Espera
evento
común
Esperando
flag
evento
compartido
flags
evento
mecanismos
comunicación
procesos
señales
bit
Espera
liberación
página
Esperando
libere
página
memoria
prin-
cipal
asignada
conjunto
páginas
asignadas
proceso
conjunto
trabajo
proceso
Espera
hibernada
residente
proceso
puesto
espera
Espera
hibernada
swap
Proceso
hibernado
expulsado
memoria
principal
Espera
evento
local
residente
proceso
memoria
principal
espera
flag
evento
local
habitualmente
espera
finalización
operación
Espera
evento
local
swap
Proceso
espera
evento
local
expulsado
memoria
principal
Espera
suspendida
residente
proceso
puesto
espera
proceso
Espera
suspendida
swap
Proceso
espera
suspendida
expulsado
me-
moria
principal
Espera
recurso
proceso
esperando
disponer
recurso
tipo
ge-
neral
sistema
proceso
ejecuta
privilegios
necesita
llamar
procedimiento
ejecuta
nivel
privilegio
ejemplo
programa
usuario
requiere
llamada
sistema
llamada
realiza
instruc-
ción
cambio
CHM
causa
interrupción
transfiere
control
rutina
acceso
retorno
realiza
instrucción
REI
retorno
excepción
interrupción
número
sistemas
operativos
modos
núcleo
usuario
Cuá-
ventajas
inconvenientes
modos
lugar
incluir
caso
modos
3.7
esquema
VMS
comentado
problema
denomina
habitualmente
estruc-
tura
protección
anillo
ilustra
Figura
3.18
realidad
modelo
sencillo
núcleo
usuario
describe
Sección
3.3
estructura
anillos
SILB04
aborda
problema
enfoque
principal
desventaja
modelo
estructura
anillo
jerárquico
per-
mite
forzar
principio
necesidad-de-conocimiento
particular
objeto
152
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
152accesible
dominio
Dj
accesible
dominio
Di
debemos
i.
implica
segmento
accesible
Di
accesible
j.
Explique
claramente
problema
indicado
cita
Sugiera
forma
sistema
operativo
estructura
anillo
resolver
problema
3.8
Figura
3.7b
sugiere
proceso
encontrar
cola
espera
evento
instante
proceso
esté
esperando
evento
Proporcione
ejemplo
caso
modificaría
estructura
colas
figura
soporte
funcionalidad
3.9
número
ordenadores
interrupción
hacía
automáticamente
registros
procesador
guardasen
posiciones
determinadas
asociadas
señal
interrupción
particular
circunstancias
técnica
Explique
general
3.10
Sección
3.4
indica
UNIX
apropiado
aplicaciones
tiempo
real
proceso
ejecutando
núcleo
expulsado
Elabore
ra-
zonamiento
Descripción
control
procesos
153
Núcleo
Ejecutivo
Supervisor
Usuario
REI
CHMx
Figura
3.18
Modos
acceso
VAX
VMS
03-Capitulo
12/5/05
16:19
Página
153PROYECTO
PROGRAMACIÓN
DESARROLLO
INTÉRPRETE
MANDATOS
shell
intérprete
mandatos
interfaz
usuario
fundamental
sistemas
operativos
proyecto
escribir
intérprete
mandatos
sencillo
myshell
siguientes
pro-
piedades
intérprete
mandatos
soporte
siguientes
mandatos
internos
i.
cd
directorio
cambia
directorio
actual
directorio
argumento
directorio
aparece
devuelve
directorio
actual
directorio
proporcionar
mensaje
error
apropiado
mandato
modificar
variable
entorno
PWD
ii
clr
limpia
pantalla
iii
dir
directory
lista
contenido
directorio
iv
environ
muestra
variables
entorno
v.
echo
comentario
muestra
comentario
pantalla
seguido
línea
espa-
cios
múltiples
tabuladores
reducen
especio
sencillo
vi
help
muestra
manual
usuario
usando
filtro
more
vii
pause
detiene
ejecución
intérprete
mandatos
pulse
Intro
viii
quit
sale
intérprete
mandatos
ix
entorno
intérprete
mandatos
contener
shell=<ruta>/myshell
ruta>/myshell
ruta
completa
ejecutable
intérprete
mandatos
ruta
fija-
directorio
inicial
ruta
real
ejecutado
resto
entradas
teclado
interpretan
invocación
programa
de-
ben
realizarse
fork
ejecución
programa
proce-
so
hijo
intérprete
mandatos
programa
ejecutarse
entorno
incluya
entrada
parent=<ruta>/myshell
ruta>/myshell
ruta
descrita
apartado
1.ix
intérprete
mandatos
capaz
leer
entrada
mandatos
fichero
ejem-
plo
invoca
intérprete
mandatos
línea
myshell
fichero-lotes
fichero-lotesse
supone
contiene
líneas
mandatos
intérprete
llegue
fichero
intérprete
mandatos
terminar
Obviamente
intérprete
invoca
argumentos
entrada
solicitará
mandatos
usuario
vía
consola
intérprete
mandatos
soportar
redirección
stdin
stdout
ejemplo
línea
mandatos
nombreprograma
arg1
arg2
entrada
salida
ejecutará
programa
nombreprograma
argumentos
arg1
arg2
flujo
entra
stdin
alimentará
fichero
entrada
flujo
salida
stdout
volcará
fichero
salida
redirección
stdout
mandatos
internos
dir
environ
echo
help
redirección
salida
carácter
redirección
creará
fichero
salida
exis-
truncará
contenido
indicador
redirección
creará
fichero
sa-
lida
añadirá
salida
contenido
intérprete
mandatos
soportar
ejecución
mandatos
plano
back-
ground
signo
línea
mandatos
indica
intérprete
devolver
prompt
usuario
inmediatamente
lanzado
programa
prompt
indicar
ruta
directorio
actual
154
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
154Nota
asumir
argumentos
línea
mandatos
incluyendo
símbolos
redirección
background
estarán
separados
argumentos
línea
mandatos
espacios
blanco
espacios
tabuladores
obsérvese
línea
man-
datos
Requisitos
proyecto
Diseñe
intérprete
mandatos
sencillo
satisfaga
criterios
mencionados
imple-
méntelo
plataforma
UNIX
seleccionada
Escriba
manual
sencillo
describa
intérprete
manual
contener
sufi-
ciente
información
usuario
principiante
UNIX
usarlo
ejemplo
explicar
conceptos
redirección
entorno
programa
ejecución
plano
background
manual
llamarse
readme
documento
texto
plano
leerse
editor
texto
estándar
ejemplo
tipo
profundidad
pide
deberá
inspeccionar
manuales
línea
csh
tcsh.(man
csh
man
tcsh).Estos
intérpretes
funcionalidad
pide
forma
manual
requiere
deberá
incluir
concepto
consideraciones
implementación
ficheros
fuente
código
incluirá
fi-
cheros
proyecto
manual
Manual
Usuario
Manual
Desarrollo
código
fuente
extensamente
comentado
apropiadamente
estructurado
permitien-
do
colegas
comprenderlo
darle
mantenimiento
código
código
comentado
pro-
piedad
alineado
fácil
interpretar
interesa
persona
eva-
luar
código
entenderlo
facilidad
necesidad
gimnasia
mental
detalles
envío
proyecto
proporcionarán
antelación
fecha
límite
envío
proyecto
contener
ficheros
fuente
incluyendo
ficheros
cabecera
makefi-
letras
minúsculas
favor
fichero
readme
letras
minúsculas
favor
incluir
fichero
ejecutable
evaluador
recompilará
automáticamente
intérprete
man-
datos
código
fuente
código
fuente
compila
calificado
makefile
letras
minúsculas
favor
generar
fichero
binario
llamado
myshell
letras
minúsculas
favor
ejemplo
makefile
Pepe
Potamo
s1234567
Proyecto
SO
CompLab1/01
tutor
Chema
Peña
myshell
myshell.c
utility.c
myshell.h
gcc
Wall
myshell.c
utility.c
myshell
programa
myshell
generará
simplemente
tecleando
make
línea
mandatos
Nota
cuarta
línea
makefile
ejemplo
comenzar
tabulador
ejemplo
mostrado
ficheros
incluidos
directorio
envío
makefile
myshell.c
utility.c
myshell.h
readme
Envío
necesario
makefile
ficheros
incluidos
envío
copiarán
directorio
incluya
rutas
makefile
makefile
incluir
dependencias
com-
pilar
programa
incluye
biblioteca
makefile
construir
dicha
biblioteca
Descripción
control
procesos
155
03-Capitulo
12/5/05
16:19
Página
155Para
dejar
construya
mano
binario
fichero
objeto
re-
querirá
ficheros
fuente
makefile
fichero
readme
Verifique
proyecto
copiando
dichos
ficheros
directorio
vacío
compilándolo
completamente
mandato
make
Usaremos
script
copia
ficheros
directorio
prueba
borre
fichero
myshell
previo
ficheros
.a
.o
ejecute
make
copie
serie
ficheros
prue-
bas
directorio
compruebe
intérprete
mandatos
serie
ficheros
lotes
pasados
entrada
estándar
stdin
línea
mandatos
batería
pruebas
falla
debi-
do
nombres
erróneos
diferencias
mayúsculas
minúsculas
versiones
erróneas
código
fallen
compilar
falta
ficheros
etc.
secuencia
evaluación
detendrá
caso
calificación
obtenida
pruebas
pasadas
completamente
puntuación
código
fuente
manual
Documentación
solicitada
lugar
código
fuente
comprobará
evaluará
manual
readme
comen-
tarios
completamente
necesarios
código
fuente
manual
usuario
presentar
formato
desee
visualizar
editor
texto
están-
manual
contener
suficiente
información
usuario
principiante
UNIX
intérprete
ejemplo
explicar
conceptos
redirección
entorno
programa
ejecución
plano
background
manual
llamarse
re-
adme
minúsculas
favor
extensión
.txt
156
Sistemas
operativos
Aspectos
internos
principios
diseño
03-Capitulo
12/5/05
16:19
Página
156CAPÍTULO
Hilos
SMP
micronúcleos
4.1
Procesos
hilos
4.2
Multiprocesamiento
simétrico
4.3
Micronúcleos
4.4
Gestión
hilos
SMP
Windows
4.5
Gestión
hilos
SMP
Solaris
4.6
Gestión
procesos
hilos
Linux
4.7
Resumen
4.8
Lecturas
recomendadas
4.9
érminos
clave
cuestiones
repaso
problemas
04-Capitulo
12/5/05
16:20
Página
157Este
capítulo
analiza
conceptos
avanzados
relativos
gestión
procesos
pue-
den
encontrar
sistemas
operativos
modernos
lugar
muestra
concepto
proceso
complejo
sutil
visto
momento
contiene
conceptos
potencialmente
independientes
relativo
propiedad
recursos
relativo
ejecución
sistemas
operativos
distinción
llevado
desarrollo
es-
tructuras
conocidas
hilos
threads
analizar
hilos
pasa
multiprocesa-
miento
simétrico
Symmetric
Multiprocessing
SMP
SMP
sistema
operativo
capaz
planificar
simultáneamente
procesos
múltiples
procesadores
introduce
concepto
micronúcleo
forma
útil
estructurar
sistema
operativo
soporte
ma-
nejo
procesos
restantes
tareas
4.1
PROCESOS
HILOS
momento
presentado
concepto
proceso
poseedor
caracte-
rísticas
Propiedad
recursos
proceso
incluye
espacio
direcciones
virtuales
mane-
jo
imagen
proceso
Capítulo
imagen
proceso
colección
programa
datos
pila
atributos
definidos
bloque
control
proceso
proceso
asignar
control
propiedad
recursos
tales
memoria
principal
canales
dispositivos
archivos
sistema
operativo
realiza
función
protección
evitar
interferencias
deseadas
procesos
relación
recursos
Planificación
ejecución
ejecución
proceso
ruta
ejecución
traza
tra-
vés
programas
ejecución
intercalada
procesos
proceso
ejecución
Ejecutando
Listo
etc.
priori-
dad
activación
entidad
planifica
activa
sistema
operativo
sistemas
operativos
tradicionales
características
realmen-
esencia
proceso
quedar
características
in-
dependientes
tratadas
tales
sistema
operativo
diversos
siste-
operativos
desarrollados
recientemente
distinguir
características
unidad
activa
suele
denominar
hilo
thread
proceso
ligero
unidad
propiedad
recursos
suele
denominar
proceso
tarea
MULTIHILO
Multihilo
refiere
capacidad
sistema
operativo
soporte
múltiples
hilos
ejecu-
ción
proceso
enfoque
tradicional
hilo
ejecución
proceso
identifica
concepto
hilo
conoce
estrategia
monohilo
configuraciones
muestran
izquierda
Figura
4.1
estrategia
monohilo
ejemplo
siste-
158
Sistemas
operativos
Aspectos
internos
principios
diseño
siquiera
mantener
grado
consistencia
sistemas
operativos
mainframe
IBM
conceptos
espacio
direcciones
tarea
respectivamente
corresponden
conceptos
proceso
hilo
descri
ben
sección
literatura
término
proceso
ligero
utiliza
equivalente
término
hilo
tipo
particu-
lar
hilo
conocido
hilo
nivel
núcleo
caso
Solaris
entidad
asocia
hilos
nivel
usuario
hi-
nivel
núcleo
04-Capitulo
12/5/05
16:20
Página
158ma
operativo
soporta
único
proceso
usuario
único
hilo
MS-DOS
sistemas
operativos
variedades
UNIX
soportan
múltiples
procesos
usuario
hilo
proceso
derecha
Figura
4.1
representa
estrategias
multihilo
entorno
ejecución
Java
ejemplo
sistema
único
proceso
múltiples
hilos
interesante
sección
múltiples
procesos
soporta
múltiples
hilos
en-
foque
Windows
Solaris
Mach
OS/2
sección
ofrece
descripción
general
mecanismo
multihilo
capítulo
discuten
detalles
enfo-
ques
Windows
Solaris
Linux
entorno
multihilo
proceso
define
unidad
asignación
recursos
unidad
protección
asocian
procesos
siguientes
espacio
direcciones
virtuales
soporta
imagen
proceso
Acceso
protegido
procesadores
procesos
comunicación
procesos
archivos
recursos
dispositivos
canales
proceso
hilos
ejecución
hilo
Ejecutando
Listo
etc.
contexto
hilo
almacena
ejecución
forma
hilo
contador
programa
independiente
proceso
pila
ejecución
hilo
espacio
almacenamiento
variables
locales
Hilos
SMP
micronúcleos
159
proceso
hilo
proceso
Múltiples
hilos
Múltiples
procesos
hilo
proceso
Traza
instrucción
Múltiples
procesos
Múltiples
hilos
proceso
Figura
4.1
Hilos
procesos
ANDE97
04-Capitulo
12/5/05
16:20
Página
159•
Acceso
memoria
recursos
proceso
compartido
hilos
proceso
Figura
4.2
muestra
diferencia
hilos
procesos
punto
vista
gestión
procesos
modelo
proceso
monohilo
concepto
hilo
representa-
ción
proceso
incluye
bloque
control
proceso
espacio
direcciones
usuario
pilas
usuario
núcleo
gestionar
comportamiento
llamadas
retornos
ejecución
procesos
proceso
ejecutando
registros
procesador
con-
trolan
proceso
proceso
ejecutando
almacena
contenido
registros
entorno
multihilo
habiendo
único
bloque
control
proceso
espa-
cio
direcciones
usuario
asociado
proceso
pilas
separadas
hilo
bloque
control
hilo
contiene
valores
registros
priori-
dad
información
relativa
hilo
forma
hilos
proceso
comparten
recursos
proceso
resi-
den
espacio
direcciones
acceso
datos
hilo
cambia
de-
terminados
datos
memoria
hilos
ven
resultados
acceden
datos
hilo
abre
archivo
permisos
lectura
hilos
proceso
leer
archivo
mayores
beneficios
hilos
provienen
consecuencias
rendimiento
tiempo
crear
hilo
proceso
existente
crear
proceso
totalmente
estudios
realizados
desarrollaron
sistema
operativo
Mach
muestran
creación
hilo
rápida
creación
proceso
UNIX
TEV
A87
tiempo
finalizar
hilo
proceso
tiempo
cambiar
hilos
proceso
hilos
mejoran
eficiencia
comunicación
programas
eje-
cutando
sistemas
operativos
comunicación
procesos
inde-
160
Sistemas
operativos
Aspectos
internos
principios
diseño
Modelo
proceso
único
hilo
Bloque
control
proceso
Espacio
direcciones
usuario
Pila
usuario
Pila
núcleo
Modelo
proceso
multihilo
Bloque
control
hilo
Hilo
Hilo
Hilo
Bloque
control
proceso
Espacio
direcciones
usuario
Pila
usuario
Pila
usuario
Pila
usuario
Pila
núcleo
Pila
núcleo
Pila
núcleo
Bloque
control
hilo
Bloque
control
hilo
Figura
4.2
Modelos
proceso
único
hilo
multihilo
04-Capitulo
12/5/05
16:20
Página
160pendientes
requiere
intervención
núcleo
proporcionar
protección
mecanis-
mos
necesarios
comunicación
hilos
proceso
comparten
memoria
archivos
comunicar
necesidad
invocar
núcleo
forma
desea
implementar
aplicación
función
conjunto
unidades
ejecución
relacionadas
eficiente
conjunto
hilos
con-
procesos
independientes
ejemplo
aplicación
hilos
servidor
archivos
llega
petición
archivo
programa
gestión
archivos
ejecutar
hilo
servidor
manejará
peticiones
crearán
finalizarán
hilos
cor-
to
periodo
tiempo
servidor
ejecuta
máquina
multiprocesador
ejecutando
simultáneamente
múltiples
hilos
proceso
procesadores
procesos
hilos
servidor
archivos
compartir
archivos
datos
coor-
dinar
acciones
rápido
hilos
memoria
compartida
procesos
paso
men-
sajes
coordinación
hilos
útiles
procesador
ayudan
simplificar
estruc-
tura
programas
realizan
funciones
LETW88
ofrece
ejemplos
hilos
sistema
multiprocesamiento
usuario
Trabajo
plano
plano
ejemplo
programa
hoja
cál-
culo
hilo
mostrar
menús
leer
entrada
usuario
hilo
ejecuta
mandatos
usuario
actualiza
hoja
cálculo
forma
trabajo
incremen-
ta
velocidad
percibe
aplicación
permitiendo
programa
solicitar
mandato
mandato
esté
completado
Procesamiento
asíncrono
elementos
asíncronos
programa
imple-
mentar
hilos
ejemplo
diseñar
procesador
textos
protección
fallo
corriente
escriba
buffer
memoria
RAM
disco
minuto
crear
hilo
cuyo
único
trabajo
crear
copia
seguridad
perió-
dicamente
planifique
directamente
sistema
operativo
necesita
código
adicional
programa
principal
proporcione
control
tiempo
coordi-
ne
entrada
salida
Velocidad
ejecución
proceso
multihilo
computar
serie
datos
lee
siguientes
dispositivo
sistema
multiprocesador
ejecu-
tando
simultáneamente
múltiples
hilos
proceso
forma
hilo
bloqueado
operación
lee
datos
hilo
ejecutando
Estructura
modular
programas
programas
realizan
diversas
tareas
fuentes
destinos
entrada
salida
diseñar
implementar
fácilmente
usando
hilos
sistema
operativo
soporte
hilos
planificación
activación
realizan
nivel
hilo
información
relativa
ejecución
mantenga
estructuras
datos
nivel
hilo
diversas
acciones
afectan
hilos
proceso
sistema
operativo
gestionar
nivel
proceso
Suspender
proce-
so
implica
expulsar
espacio
direcciones
proceso
memoria
principal
dejar
hueco
espacio
direcciones
proceso
hilos
proceso
comparten
Hilos
SMP
micronúcleos
161
04-Capitulo
12/5/05
16:20
Página
161espacio
direcciones
hilos
suspenden
tiempo
forma
similar
finaliza-
ción
proceso
finaliza
hilos
proceso
FUNCIONALIDADES
HILOS
hilos
procesos
ejecución
sincronizar
continuación
analizan
aspectos
funcionalidades
hilos
hilos
procesos
principales
hilos
Ejecu-
tando
Listo
Bloqueado
Generalmente
sentido
aplicar
suspensión
hilo
dichos
conceptos
nivel
proceso
particular
expulsa
proceso
hilos
expulsar
comparten
espacio
direcciones
proceso
operaciones
básicas
relacionadas
hilos
asociadas
cambio
hilo
ANDE97
Creación
crea
proceso
crea
hilo
proceso
Pos-
teriormente
hilo
proceso
crear
hilo
proceso
proporcio-
nando
puntero
instrucciones
argumentos
hilo
hilo
proporciona
registro
contexto
espacio
pila
coloca
cola
Listos
Bloqueo
hilo
necesita
esperar
evento
bloquea
almacenando
registros
usuario
contador
programa
punteros
pila
procesador
pasar
ejecutar
hilo
Listo
proceso
Desbloqueo
sucede
evento
hilo
bloqueado
hilo
pasa
cola
Listos
Finalización
completa
hilo
liberan
registro
contexto
pilas
aspecto
importante
bloqueo
hilo
implica
bloqueo
proceso
completo
palabras
bloquea
hilo
proceso
impide
ejecución
hilo
proceso
hilo
Listo
lugar
dudas
pierde
potencia
flexibilidad
hilos
hilo
bloqueado
bloquea
proceso
entero
olveremos
tema
continuación
veamos
hilos
nivel
usuario
nivel
nú-
cleo
momento
consideraremos
beneficios
rendimiento
hilos
bloquean
proceso
completo
Figura
4.3
basada
KLEI96
muestra
programa
realiza
llamadas
procedimiento
remoto
RPC
máquinas
combinar
resulta-
programa
hilo
resultados
obtienen
secuencia
programa
esperar
respuesta
servidor
turnos
Reescribir
programa
utilizar
hilo
RPC
mejora
sustancialmente
velocidad
Observar
programa
ejecu-
ta
uniprocesador
peticiones
generar
secuencia
resultados
procesar
secuencia
programa
espera
concurrentemente
respuestas
uniprocesador
multiprogramación
permite
intercalado
múltiples
hilos
múlti-
ples
procesos
ejemplo
Figura
4.4
intercalan
hilos
procesos
procesa-
162
Sistemas
operativos
Aspectos
internos
principios
diseño
RPC
técnica
programas
ejecutar
máquinas
interactúan
utilizando
sintaxis
semántica
llamadas
procedimiento
programa
llamante
llamado
comportan
progra-
ma
estuviera
ejecutando
máquina
RPC
suelen
utilizar
aplicaciones
cliente
servidor
analizan
Capítulo
13
04-Capitulo
12/5/05
16:20
Página
162dor
ejecución
pasa
hilo
bloquea
hilo
actualmente
ejecución
por-
ción
tiempo
agota
Hilos
SMP
micronúcleos
163
ejemplo
hilo
comienza
ejecutar
hilo
finaliza
rodaja
tiempo
hilo
esté
listo
ejecutar
elección
decisión
planificación
tema
aborda
RPC
utilizando
único
hilo
RPC
utilizando
hilo
servidor
uniprocesador
Tiempo
Proceso
Bloqueado
esperando
respuesta
RPC
Bloqueado
esperando
procesador
Hilo
Ejecutando
Hilo
Proceso
Hilo
Proceso
Servidor
Petición
RPC
Petición
RPC
Servidor
ServidorPetición
RPC
Petición
RPC
Servidor
Figura
4.3
Llamadas
Procedimiento
Remoto
RPC
utilizando
hilos
Tiempo
Bloqueado
Petición
Hilo
Proceso
Hilo
Proceso
Hilo
Proceso
Listo
Ejecutando
Petición
completa
Finalizada
rodaja
tiempo
Proceso
creado
Finalizada
rodaja
tiempo
Figura
4.4
Ejemplo
multihilo
uniprocesador
04-Capitulo
12/5/05
16:20
Página
163Sincronización
hilos
hilos
proceso
comparten
espacio
direccio-
nes
recursos
ejemplo
archivos
abiertos
alteración
recurso
cualquiera
hilos
afecta
entorno
resto
hilos
proceso
nece-
sario
sincronizar
actividades
hilos
interfieran
corrompan
estructu-
ras
datos
ejemplo
hilos
simultáneo
intentan
añadir
elemento
lista
do-
blemente
enlazada
perder
elemento
lista
acabar
malformada
asuntos
surgen
técnicas
utilizan
sincronización
hilos
ge-
neral
sincronización
procesos
aspectos
técnicas
tratan
Capítulos
EJEMPLO—ADOBE
PAGEMAKER
ejemplo
hilos
aplicación
Adobe
PageMaker
ejecuta
sistema
compartido
PageMaker
herramienta
escritura
diseño
producción
entornos
escri-
torio
estructura
hilos
PageMaker
utilizada
OS/2
muestran
Figura
4.5
KRON90
eligió
optimizar
respuesta
aplicación
encontrar
estructuras
hilos
similares
sistemas
operativos
hilos
activos
hilo
manejar
eventos
hilo
repintar
pantalla
hilo
servicio
Generalmente
OS/2
sensible
gestión
ventanas
mensaje
entrada
requiere
proceso
OS/2
recomienda
mensaje
requiera
0,1
se-
gundos
tiempo
procesamiento
ejemplo
llamar
subrutina
imprimir
página
procesa
mandato
impresión
impedir
sistema
envío
mensajes
164
Sistemas
operativos
Aspectos
internos
principios
diseño
Hilo
servicio
Hilo
repintado
pantalla
Event-handling
thread
Impresión
Flujo
automático
texto
Importar
Inicialización
Hilo
manejador
eventos
Figura
4.5
Estructura
hilos
Adobe
PageMaker
04-Capitulo
12/5/05
16:20
Página
164otras
aplicaciones
degradando
rendimiento
cumplir
criterio
operaciones
usuario
requieren
tiempo
imprimir
importar
datos
descargar
texto
realizadas
hilo
servicio
inicialización
programa
cabo
hilo
servicio
utiliza
tiempo
inactivo
usuario
invoca
diálogo
creación
documento
abre
documento
existente
hilo
independiente
espera
mensajes
evento
sincronización
hilo
servicio
hilo
gestiona
eventos
complicada
usuario
continuar
escribiendo
moviendo
ratón
activa
hilo
manejo
even-
tos
hilo
servicio
ocupado
sucede
conflicto
PageMaker
filtra
es-
tos
mensajes
acepta
básicos
tales
redimensionamiento
ventana
hilo
servicio
manda
mensaje
hilo
manejo
eventos
indicar
finalizado
tarea
ocurre
restringe
actividad
usuario
PageMaker
programa
indica
situación
deshabilitando
elementos
menús
mostrando
cursor
ocupado
usuario
libertad
cambiar
aplicación
cursor
mueve
ventana
cambiará
cursor
apropiado
aplicación
función
repintado
pantalla
maneja
hilo
realiza
razones
PageMaker
limita
número
objetos
aparecen
página
forma
proce-
sar
petición
repintado
exceder
fácilmente
recomendación
0,1
segundos
Utilizar
hilo
independiente
permite
usuario
cancelar
repintado
caso
usuario
reescala
página
repintado
forma
inmediata
programa
sensible
completa
visualización
antigua
comenzar
visualización
escala
desplazamiento
dinámico
línea
línea
repintar
pantalla
medida
usuario
mueve
indicador
desplazamiento
hilo
manejo
eventos
monitoriza
barra
desplazamiento
repinta
reglas
márgenes
haciéndolo
forma
rápida
usua-
rio
posición
actual
forma
inmediata
hilo
repintado
pantalla
cons-
tantemente
intentando
repintar
página
implementación
repintado
dinámico
múltiples
hilos
genera
sobre-
carga
aplicación
Múltiples
hilos
permiten
separar
actividades
concurrentes
forma
natu-
ral
código
HILOS
NIVEL
USUARIO
NIVEL
NÚCLEO
amplias
categorías
implementación
hilos
hilos
nivel
usuario
user-level
thre-
ads
ULT
hilos
nivel
núcleo
kernel-level
threads
KLT)4
conocidos
literatura
hilos
soportados
núcleo
kernel-supported
threads
procesos
ligeros
lightweight
processes
Hilos
nivel
usuario
entorno
ULT
puro
aplicación
gestiona
trabajo
hilos
núcleo
consciente
existencia
Figura
4.6a
muestra
enfoque
Hilos
SMP
micronúcleos
165
acrónimos
ULT
KLT
exclusivos
libro
introducen
concisión
04-Capitulo
12/5/05
16:20
Página
165ULT
aplicación
programarse
multihilo
biblioteca
hilos
paquete
rutinas
gestión
ULT
biblioteca
hilos
contiene
código
creación
destrucción
hilos
paso
mensajes
datos
hilos
planificar
eje-
cución
hilos
guardar
restaurar
contexto
hilos
defecto
aplicación
comienza
hilo
ejecutando
hilo
aplicación
hilo
localizan
proceso
gestionado
núcleo
momento
aplica-
ción
esté
ejecutando
proceso
Ejecutando
aplicación
crear
hilo
ejecutar
proceso
creación
realiza
llamando
utilidad
creación
bi-
blioteca
hilos
pasa
control
utilidad
llamada
procedimiento
biblio-
teca
hilos
crea
estructura
datos
hilo
pasa
control
hilos
proceso
esté
listo
utilizando
algoritmo
planificación
pasa
control
biblioteca
almacena
contexto
hilo
actual
pasa
control
bi-
blioteca
hilo
recupera
contexto
hilo
contexto
esencialmente
contenido
registros
usuario
contador
programa
punteros
pila
actividad
descrita
párrafo
lugar
espacio
usuario
proceso
núcleo
consciente
actividad
núcleo
continúa
planificando
proceso
unidad
asigna
proceso
único
Listo
Ejecutando
Bloqueado
etc.
siguientes
ejemplos
deberían
aclarar
relación
planificación
hilos
planificación
procesos
Suponer
proceso
ejecutando
hilo
Figura
4.7a
muestran
proceso
ULT
proceso
siguientes
posi-
ble
situación
aplicación
ejecutando
hilo
llamada
sistema
bloquea
B.
ejem-
plo
realiza
llamada
S.
pase
control
núcleo
núcleo
llama
acción
sitúa
proceso
Bloqueado
cambia
proceso
Mien-
estructura
datos
conservada
biblioteca
hilos
hilo
proceso
Ejecutando
importante
darse
hilo
ejecutando
realmente
sentido
corriendo
procesador
percibe
Ejecutando
biblioteca
hilos
diagramas
correspondien-
tes
muestran
Figura
4.7b
166
Sistemas
operativos
Aspectos
internos
principios
diseño
PP
Espacio
usuario
Biblioteca
hilos
Espacio
núcleo
Combinado
d(b
Nivel
núcleo
puro(a
Nivel
usuario
puro
Hilo
nivel
usuario
Hilo
nivel
núcleo
Proceso
Espacio
usuario
Espacio
núcleo
Espacio
usuario
Espacio
núcleo
Biblioteca
hilos
Figura
4.6
Hilos
nivel
usuario
nivel
núcleo
04-Capitulo
12/5/05
16:20
Página
166Hilos
SMP
micronúcleos
167
Listo
Ejecutando
Bloqueado
Hilo
Listo
Hilo
Proceso
Listo
Hilo
Listo
Hilo
Listo
Proceso
Listo
Hilo
Listo
Hilo
Listo
Proceso
Listo
Hilo
Listo
Hilo
Listo
Proceso
Listo
Bloqueado
Bloqueado
Bloqueado
Bloqueado
Bloqueado
BloqueadoBloqueadoBloqueado
Bloqueado
Bloqueado
Bloqueado
Ejecutando
Ejecutando
Ejecutando
Ejecutando
Ejecutando
Ejecutando
Ejecutando
EjecutandoEjecutando
Ejecutando
Ejecutando
Figura
4.7
Ejemplos
relaciones
hilos
nivel
usuario
proceso
04-Capitulo
12/5/05
16:20
Página
1672
interrupción
reloj
pasa
control
núcleo
decide
proceso
actual
ejecución
finalizado
porción
tiempo
núcleo
pasa
proceso
Listo
cambia
proceso
estructura
datos
conservada
biblioteca
hilos
hilo
proceso
Ejecución
diagramas
es-
tado
correspondientes
muestran
Figura
4.7c
hilo
llega
punto
necesita
acción
hilo
proceso
B.
hilo
entra
Bloqueado
hilo
pasa
Listo
Ejecutando
proceso
continúa
es-
tado
Ejecutando
diagramas
correspondientes
muestran
Figura
4.7d
casos
Figuras
4.7b
4.7c
núcleo
devuelve
control
proceso
ejecución
reanuda
hilo
advertir
proceso
interrumpirse
finalizar
porción
tiempo
expulsado
proceso
prioridad
mien-
ejecutando
código
biblioteca
hilos
forma
proceso
me-
transición
hilo
hilo
interrumpe
reanuda
proceso
ejecución
continúa
biblioteca
hilos
completa
cambio
hilo
pasa
control
hilo
proceso
ULT
lugar
KLT
presenta
siguientes
ventajas
cambio
hilo
requiere
privilegios
núcleo
estructuras
datos
gestión
hilos
espacio
direcciones
usuario
proceso
consi-
guiente
proceso
cambia
núcleo
gestión
hilos
ahorra
sobrecarga
cambios
usuario
núcleo
núcleo
usuario
planificación
especificarse
aplicación
aplicación
bene-
ficiar
simple
algoritmo
planificación
cíclico
beneficiar
algoritmo
planificación
basado
prioridades
algoritmo
planificación
medida
tocar
planificador
sistema
operativo
ULT
ejecutar
sistema
operativo
necesita
cambio
núcleo
soporte
ULT
biblioteca
hilos
conjunto
utilida-
des
nivel
aplicación
comparten
aplicaciones
desventajas
ULT
comparación
KLT
sistema
operativo
típico
llamadas
sistema
bloqueantes
resultado
ULT
realiza
llamada
sistema
bloquea
hilo
blo-
quean
hilos
proceso
estrategia
pura
ULT
aplicación
multihilo
sacar
ventaja
multiproceso
núcleo
asigna
proceso
procesador
tiempo
consiguiente
de-
terminado
momento
ejecutar
hilo
proceso
efecto
multiprogra-
mación
nivel
aplicación
proceso
multiprogramación
lugar
mejora
significativa
velocidad
aplicación
aplicaciones
po-
drían
beneficiar
habilidad
ejecutar
porciones
código
forma
concurrente
formas
afrontar
problemas
ejemplo
problemas
superarse
es-
cribiendo
aplicación
múltiples
procesos
lugar
múltiples
hilos
enfoque
elimina
principal
ventaja
hilos
cambio
cambio
proceso
lugar
cambio
hilo
genera
sobrecarga
forma
solucionar
problema
hilos
bloquean
técnica
denominada
jacke-
ting
revestimiento
objetivo
técnica
convertir
llamada
sistema
bloqueante
168
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
168llamada
sistema
bloqueante
ejemplo
lugar
llamar
directamente
rutina
siste-
ma
hilo
llamar
rutina
jacket
nivel
aplicación
rutina
jac-
ket
código
verifica
dispositivo
ocupado
hilo
entra
Bloque-
ado
pasa
control
biblioteca
hilos
hilo
hilo
recupera
control
chequea
dispositivo
S.
Hilos
nivel
núcleo
entorno
KLT
puro
núcleo
gestiona
trabajo
gestión
hilos
código
gestión
hilos
aplicación
interfaz
programación
aplicación
API
acceder
utilidades
hilos
núcleo
Windows
ejemplo
enfoque
Figura
4.6b
representa
entorno
KLT
puro
aplicación
programarse
multihilo
hilos
aplicación
mantienen
proceso
núcleo
mantiene
in-
formación
contexto
proceso
entidad
hilos
individuales
proceso
pla-
nificación
realizada
núcleo
realiza
nivel
hilo
enfoque
resuelve
principales
inconvenientes
enfoque
ULT
núcleo
planificar
simultáneamente
múltiples
hilos
proceso
múltiples
procesadores
bloquea
hilo
proceso
nú-
cleo
planificar
hilo
proceso
ventaja
enfoque
KLT
rutinas
núcleo
multihilo
principal
desventaja
enfoque
KLT
comparación
enfoque
ULT
transfe-
rencia
control
hilo
proceso
requiere
cambio
núcleo
mostrar
diferencias
Tabla
4.1
muestra
resultados
medidas
tomadas
uniproce-
sador
AX
ejecutando
sistema
operativo
tipo
UNIX
medidas
siguientes
Crear
Proceso
Nulo
tiempo
crear
planificar
ejecutar
completar
proceso
hilo
llama
pro-
cedimiento
nulo
sobrecarga
crear
proceso
hilo
Señalizar-Esperar
tiempo
proceso
hilo
señalizar
proceso
hilo
esperando
continuación
esperar
condición
sobrecarga
sincronizar
procesos
hilos
abla
4.1
Latencia
Operaciones
Hilos
Procesos
mS
ANDE92
Operación
Hilos
nivel
usuario
Hilos
nivel
núcleo
Procesos
Crear
Proceso
Nulo
34
948
1.300
Señalizar-Esperar
37
441
1.840
apreciar
orden
diferencia
ULT
KLT
forma
similar
KLT
procesos
forma
ganancia
significativa
multihilos
KLT
com-
paración
procesos
hilo
ganancia
significativa
adicional
ULT
depende
naturaleza
aplicación
involucrada
podamos
beneficiar
ganancia
adicional
cambios
hilo
aplicación
requieren
acceso
núcleo
esquema
basado
ULT
superior
esquema
basado
KLT
Enfoques
combinados
sistemas
operativos
proporcionan
utilidades
combinadas
ULT
KLT
Figura
4.6c
Solaris
principal
ejemplo
sistema
combinado
creación
hilos
realiza
completo
espacio
usuario
planificación
sincronización
hilos
aplicación
múltiples
ULT
aplicación
asocian
número
menor
KLT
programador
ajustar
número
KLT
máquina
aplicación
particular
lograr
mejores
resultados
posibles
Hilos
SMP
micronúcleos
169
04-Capitulo
12/5/05
16:20
Página
169En
enfoques
combinados
múltiples
hilos
aplicación
ejecutar
paralelo
múltiples
procesadores
llamada
sistema
bloqueante
necesita
bloquear
proceso
com-
pleto
sistema
diseñado
enfoque
debería
combinar
ventajas
enfoques
puros
ULT
KLT
minimizando
desventajas
CONFIGURACIONES
comentado
conceptos
asignación
recursos
unidades
activación
tradicionalmente
relacionados
concepto
proceso
relación
1:1
hilos
procesos
Recientemente
habido
interés
proporcionar
múltiples
hilos
proceso
relación
muchos-a-uno
muestra
Tabla
4.2
combinaciones
investigadas
denominan
relación
muchos-a-muchos
rela-
ción
uno-a-muchos
abla
4.2
Relación
Hilos
Procesos
Hilos
Procesos
Descripción
Sistemas
Ejemplo
1:1
hilo
ejecución
Implementaciones
UNIX
único
proceso
tradicionales
espacio
direcciones
recursos
M:1
proceso
define
Windows
NT
Solaris
Linux
espacio
direcciones
OS/2
OS/390
MACH
pertenencia
dinámica
recursos
crear
ejecutar
múltiples
hilos
proceso
hilo
migrar
Ra
Clouds
Emerald
entorno
proceso
permite
hilos
moverse
fácilmente
distintos
sistemas
Combina
atributos
TRIX
M:1
casos
M.
Relación
muchos-a-muchos
idea
relación
muchos-a-muchos
hilos
pro-
cesos
explorada
sistema
operativo
experimental
TRIX
SIEB83,WARD80
TRIX
conceptos
dominio
hilo
dominio
entidad
estática
consiste
espacio
direcciones
puertos
enviar
recibir
mensajes
hilo
ruta
ejecución
pila
ejecución
procesador
información
planificación
enfoque
multihilo
visto
momento
múltiples
hilos
ejecutar
dominio
proporcionando
ventajas
discutidas
anteriormente
po-
sible
actividad
usuario
ejecutar
aplicaciones
múltiples
dominios
caso
hilo
mover
dominios
hilo
múltiples
dominios
motivado
deseo
proporcionar
herra-
mientas
estructuración
programador
ejemplo
considere
programa
170
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
170subprograma
S.
entorno
multiprogramado
permite
procesos
creados
usuarios
programa
principal
generar
proceso
manejo
continuar
ejecutan-
do
futuro
progreso
programa
principal
depende
funcionamiento
programa
principal
esperar
finalización
programa
S.
va-
rias
formas
implementar
aplicación
programa
completo
implementarse
proceso
solución
razonable
directa
desventajas
relativas
gestión
memoria
proceso
com-
pleto
requerir
cantidad
memoria
ejecutar
forma
eficiente
subprograma
requiere
relativamente
espacio
direccionamiento
al-
macenar
manejar
cantidad
código
fuente
programa
ejecuta
espacio
direcciones
programa
suceder
proceso
com-
pleto
deba
permanecer
memoria
principal
funcionamiento
operación
esté
sujeta
intercambio
efecto
gestión
memoria
existiría
programa
principal
subprograma
hubieran
implementados
hi-
espacio
direcciones
programa
principal
subprograma
implementarse
procesos
in-
dependientes
enfoque
presenta
sobrecarga
creación
proceso
subordinado
actividad
frecuente
deberá
dejar
vivo
proceso
subordinado
consi-
guiente
consumo
recursos
deberá
crear
destruir
frecuentemente
subprograma
consiguiente
pérdida
eficiencia
Tratar
programa
principal
subprograma
actividad
implementar
hilo
crear
espacio
direcciones
dominio
programa
principal
subprograma
S.
forma
hilo
mover
espacios
direcciones
ejecución
sistema
operativo
gestionar
espacios
direcciones
forma
independiente
genera
sobrecarga
creación
procesos
Adicionalmente
espacio
direcciones
utilizado
subprograma
compartido
programas
S.
experiencias
desarrolladores
TRIX
indican
opción
mérito
eficiente
aplicaciones
Relación
uno-a-muchos
campo
sistemas
operativos
distribuidos
diseñados
controlar
sistemas
computadores
distribuidos
habido
interés
concepto
hilo
entidad
mover
espacios
direcciones
ejemplo
importante
inves-
tigación
sistema
operativo
Clouds
especialmente
núcleo
conocido
Ra
DASG92
ejemplo
sistema
Emerald
STEE95
punto
vista
usuario
hilo
Clouds
unidad
actividad
proceso
espacio
direcciones
virtual
bloque
control
proceso
asociado
creado
hilo
comienza
ejecutando
proceso
invocación
punto
entrada
pro-
grama
proceso
hilos
mover
espacio
direcciones
límites
máquina
moverse
computador
mueve
hilo
llevarse
determinada
información
controlador
terminal
parámetros
globales
guías
planificación
ejemplo
prioridad
Hilos
SMP
micronúcleos
171
movimiento
procesos
hilos
espacios
direcciones
migración
hilos
máquinas
con-
vertido
tema
interés
años
tema
analiza
Capítulo
14
04-Capitulo
12/5/05
16:20
Página
171El
enfoque
Clouds
proporciona
forma
eficiente
aislar
usuarios
programadores
detalles
entorno
distribuido
actividad
usuario
representada
hilo
movimiento
hilo
máquinas
gestionado
sistema
operativo
gra-
cias
información
relativa
sistema
necesidad
acceder
recurso
remoto
equi-
librado
carga
4.2
MULTIPROCESAMIENTO
SIMÉTRICO
Tradicionalmente
computador
visto
máquina
secuencial
lenguajes
programación
requieren
programador
especifique
algoritmos
secuencia
instrucciones
procesador
ejecuta
programas
ejecución
instrucciones
máquina
secuencia
instrucción
ejecuta
secuencia
operaciones
buscar
instrucción
buscar
operandos
operación
almacenar
resultados
visión
computador
totalmente
nivel
micro-operación
gene-
ran
múltiples
señales
control
tiempo
pipeline
instrucciones
relati-
vo
búsqueda
ejecución
operaciones
presente
tiempo
ejemplos
realización
funciones
paralelo
medida
evolucionado
tecnología
computadores
coste
hardware
des-
cendido
diseñadores
visto
oportunidades
paralelismo
normalmente
mejorar
rendimiento
casos
mejorar
fiabilidad
libro
examina-
mos
enfoques
populares
proporcionar
paralelismo
réplica
procesa-
dores
multiprocesamiento
simétricos
SMP
clusters
SMP
abordan
sección
clusters
examinan
ARQUITECTURA
SMP
útil
encaja
arquitectura
SMP
categorías
procesamiento
paralelo
forma
común
categorizar
sistemas
taxonomía
sistemas
procesamiento
pa-
ralelo
introducida
Flynn
FLYN72
Flynn
propone
siguientes
categorías
sistemas
computadores
Única
instrucción
único
flujo
datos
Single
instruction
single
data
SISD
stream
procesador
ejecuta
única
instrucción
opera
datos
almacenados
memoria
Única
instrucción
múltiples
flujos
datos
Single
instruction
multiple
data
SIMD
stream
única
instrucción
máquina
controla
ejecución
simultánea
número
elementos
proceso
elemento
proceso
memoria
datos
asociada
forma
instrucción
ejecuta
conjunto
datos
procesadores
procesadores
vectoriales
matriciales
entran
categoría
Múltiples
instrucciones
único
flujo
datos
Multiple
instruction
single
data
MISD
stream
transmite
secuencia
datos
conjunto
procesadores
ejecuta
secuencia
instrucciones
estructura
im-
plementado
Múltiples
instrucciones
múltiples
flujos
datos
Multiple
instruction
multiple
data
MIMD
stream
conjunto
procesadores
ejecuta
simultáneamente
secuencias
instrucciones
conjuntos
datos
172
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
172Con
organización
MIMD
procesadores
propósito
general
capaces
procesar
instrucciones
necesarias
transformaciones
datos
apropiadas
MIMD
subdividir
forma
comunican
procesadores
Figura
4.8
procesador
memoria
dedicada
elemento
proceso
computador
comu-
nicación
computadores
rutas
prefijadas
redes
sistema
conocido
cluster
multicomputador
procesadores
comparten
memoria
común
procesador
accede
programas
datos
almacenados
memo-
ria
compartida
procesadores
comunican
dicha
memoria
sistema
conoce
multiprocesador
memoria
compartida
clasificación
general
multiprocesadores
memoria
compartida
basa
forma
asignar
procesos
procesadores
enfoques
fundamentales
maestro
esclavo
simé-
trico
arquitectura
maestro
esclavo
núcleo
sistema
operativo
ejecuta
de-
terminado
procesador
resto
procesadores
ejecutar
programas
usuario
utilidades
sistema
operativo
maestro
responsable
planificación
procesos
hilos
proceso
hilo
activado
esclavo
necesita
servicios
ejemplo
llamada
enviar
petición
maestro
esperar
realice
servicio
enfo-
sencillo
requiere
mejoras
sistema
operativo
multiprogramado
uniprocesador
resolución
conflictos
simplifica
procesador
control
memoria
recursos
S.
desventajas
enfoque
siguientes
fallo
maestro
echa
abajo
sistema
maestro
convertirse
cuello
botella
punto
vista
rendimiento
único
responsable
planificación
gestión
procesos
multiprocesador
simétrico
Symmetric
Multiprocessor
SMP
núcleo
ejecutar
procesador
normalmente
procesador
realiza
planificación
conjunto
disponible
procesos
hilos
núcleo
construirse
múltiples
procesos
múltiples
hi-
permitiéndose
ejecución
partes
núcleo
paralelo
enfoque
SMP
complica
sistema
operativo
asegurar
procesadores
seleccionan
proceso
pierde
proceso
cola
emplear
técnicas
resolver
sincronizar
recursos
Hilos
SMP
micronúcleos
173
Procesadores
paralelos
SIMD
única
instrucción
múltiples
flujos
datos
Maestro
esclavo
ClustersMultiprocesadores
simétricos
SMP
Memoria
compartida
fuertemente
acoplados
Memoria
distribuida
débilmente
acoplados
MIMD
múltiples
instrucciones
múltiples
flujos
datos
Figura
4.8
Arquitectura
procesadores
paralelos
04-Capitulo
12/5/05
16:20
Página
173El
diseño
SMP
clusters
complejo
involucra
temas
relativos
organización
física
es-
tructuras
interconexión
comunicación
procesadores
diseño
sistema
operativo
técnicas
aplicaciones
software
preocupación
hablemos
clúste-
res
Capítulo
13
centra
aspectos
diseño
sistema
operativo
casos
veremos
brevemente
temas
organización
ORGANIZACIÓN
SMP
Figura
4.9
muestra
organización
general
SMP
múltiples
procesadores
contiene
unidad
control
unidad
aritmético-lógica
registros
proce-
sador
acceso
memoria
principal
compartida
dispositivos
meca-
nismo
interconexión
bus
compartido
común
procesadores
procesadores
comunicar
memoria
mensajes
información
dejados
espa-
cios
memoria
compartidos
procesadores
intercambiarse
señales
directamente
memoria
organizada
múltiples
accesos
simul-
táneos
bloques
separados
máquinas
modernas
procesadores
suelen
nivel
memoria
cache
privada
procesador
cache
introduce
consideraciones
diseño
Debi-
do
cache
local
contiene
imagen
porción
memoria
principal
altera
pala-
bra
cache
invalidar
palabra
resto
caches
prevenir
resto
procesadores
alertados
llevado
cabo
actualización
problema
conoce
problema
coherencia
caches
suele
solucionar
técnicas
hardware
sistema
operativo
CONSIDERACIONES
DISEÑO
SISTEMAS
OPERATIVOS
MULTIPROCESADOR
sistema
operativo
SMP
gestiona
procesadores
recursos
computador
usuario
sistema
forma
sistema
uniprocesador
multiprogra-
mado
usuario
desarrollar
aplicaciones
utilicen
múltiples
procesos
múltiples
hilos
procesos
preocuparse
disponible
único
procesador
múltiples
procesa-
dores
forma
sistema
operativo
multiprocesador
proporcionar
funcionalidad
sistema
multiprogramado
características
adicionales
adecuarse
múltiples
pro-
cesadores
principales
claves
diseño
incluyen
siguientes
características
Procesos
hilos
simultáneos
concurrentes
rutinas
núcleo
necesitan
reentrantes
permitir
procesadores
ejecuten
código
núcleo
simultáneamente
múltiples
procesadores
ejecutar
partes
código
núcleo
tablas
gestión
estructuras
núcleo
gestionas
apropiada-
mente
impedir
interbloqueos
operaciones
inválidas
Planificación
planificación
procesador
de-
ben
evitar
conflictos
utiliza
multihilo
nivel
núcleo
posibilidad
pla-
nificar
múltiples
hilos
proceso
simultáneamente
múltiples
procesadores
Capítulo
10
examina
planificación
multiprocesador
STAL03
proporciona
descripción
esquemas
coherencia
cache
basados
hardware
174
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
174•
Sincronización
múltiples
procesos
activos
acceder
espacios
direccio-
nes
compartidas
recursos
compartidos
cuidado
proporcionar
sincronización
eficaz
sincronización
servicio
fuerza
exclusión
mutua
or-
den
eventos
mecanismo
común
sincronización
utiliza
sistemas
ope-
rativos
multiprocesador
cerrojos
descritos
Capítulo
Gestión
memoria
gestión
memoria
multiprocesador
tratar
aspectos
encontrados
máquinas
uniprocesador
verán
Ade-
sistema
operativo
necesita
explotar
paralelismo
hardware
existente
me-
morias
multipuerto
lograr
rendimiento
mecanismos
paginación
procesadores
coordinados
asegurar
consistencia
procesadores
comparten
página
segmento
decidir
reemplazo
página
Fiabilidad
tolerancia
fallos
sistema
operativo
degradar
caso
fallo
procesador
planificador
partes
sistema
operativo
darse
pérdida
procesador
reestructurar
tablas
gestión
apropiadamente
aspectos
diseño
sistema
operativo
multiprocesador
suelen
extensio-
nes
soluciones
problemas
diseño
uniprocesadores
multiprogramados
trataremos
separado
lugar
aspectos
específicos
temas
multiprocesador
tratarán
contexto
apropiado
libro
Hilos
SMP
micronúcleos
175
Subsistema
Bus
sistema
Memoria
principal
Adaptador
L1
cache
Procesador
L2
cache
L1
cache
L2
cache
Procesador
L2
cache
L1
cache
Procesador
Adaptador
Adaptador
Figura
4.9
Organización
multiprocesadores
simétricos
04-Capitulo
12/5/05
16:20
Página
1754.3
MICRONÚCLEOS
concepto
últimamente
recibiendo
atención
micronúcleo
micronúcleo
pequeña
central
sistema
operativo
proporciona
bases
extensiones
modu-
lares
término
confuso
cuestiones
relacionadas
micronú-
cleos
respuestas
distintas
equipos
diseño
sistemas
operativos
cuestiones
incluyen
pequeño
núcleo
denominarse
micronúcleo
dise-
ñar
manejadores
dispositivos
obtener
rendimiento
abstraen
fun-
ciones
hardware
ejecutar
operaciones
pertenecen
núcleo
espa-
cio
usuario
mantener
código
subsistemas
existentes
ejemplo
versión
UNIX
empezar
cero
enfoque
micronúcleo
popularizó
sistema
operativo
Mach
teoría
enfoque
proporciona
alto
grado
flexibilidad
modularidad
Determinados
productos
implementaciones
micronúcleo
enfoque
general
diseño
verá
computadores
personales
estaciones
trabajo
sistemas
operativos
servidor
desarrollen
futuro
cercano
ARQUITECTURA
MICRONÚCLEO
sistemas
operativos
desarrollados
mediados
finales
años
50
diseñados
preocuparse
arquitectura
experiencia
necesaria
construcción
sistemas
software
realmente
problemas
causados
dependencia
mutua
interacción
tenían
sistemas
operativos
monolíticos
prácticamente
procedi-
miento
podía
llamar
falta
estructura
insostenible
medida
sistemas
operativos
crecieron
proporciones
desmesuradas
ejemplo
versión
OS/360
contenía
millón
líneas
código
Multics
desarrollado
creció
20
millones
líneas
código
DENN84
vimos
Sección
2.3
necesitaron
técnicas
programación
modular
manejar
escala
desarrollo
software
Específicamente
desa-
rrollaron
sistemas
operativos
capas
Figura
4.10a
funciones
organizan
jerárquicamente
interacción
capas
adyacentes
enfoque
capas
ma-
yor
capas
ejecutan
núcleo
problemas
permanecen
enfoque
capas
capa
posee
demasiada
fun-
cionalidad
cambios
capa
numerosos
efectos
difíciles
seguir
código
capas
adyacentes
resultado
difícil
imple-
mentar
versiones
medida
sistema
operativo
básico
funciones
añadidas
eli-
minadas
difícil
construir
seguridad
interacciones
capas
adyacentes
filosofía
existente
micronúcleo
funciones
absolutamente
esencia-
sistema
operativo
estén
núcleo
servicios
aplicaciones
esenciales
cons-
truyen
micronúcleo
ejecutan
usuario
filosofía
micronúcleo
varía
diseño
característica
general
ser-
vicios
tradicionalmente
formado
sistema
operativo
subsistemas
ex-
176
Sistemas
operativos
Aspectos
internos
principios
diseño
costumbre
terminología
área
aplica
forma
consistente
literatura
término
sistema
operati-
vo
monolítico
utiliza
frecuentemente
referirse
tipos
sistemas
operativos
denominado
monolíti-
cos
capas
04-Capitulo
12/5/05
16:20
Página
176ternos
interactúan
núcleo
ejemplos
manejadores
dispositivos
servidores
archivos
gestores
memoria
virtual
sistemas
ventana
servicios
seguridad
arquitectura
micronúcleo
reemplaza
tradicional
estructura
vertical
estratificada
ca-
pas
horizontal
Figura
4.10b
componentes
sistema
operativo
externos
micronú-
cleo
implementan
servidores
procesos
interactúan
normalmente
paso
mensajes
micronúcleo
forma
micronúcleo
funciona
inter-
cambiador
mensajes
válida
mensajes
pasa
componentes
concede
acceso
hardware
micronúcleo
realiza
función
protección
previene
paso
mensajes
intercambio
esté
permitido
ejemplo
aplicación
abrir
archivo
manda
mensaje
servidor
sistema
archivos
crear
proceso
hilo
manda
mensaje
servidor
procesos
servidores
mandar
mensajes
resto
servidores
invocar
funciones
primiti-
vas
micronúcleo
arquitectura
cliente
servidor
computador
BENEFICIOS
ORGANIZACIÓN
MICRONÚCLEO
literatura
encontrar
serie
ventajas
micronúcleos
ejemplo
FINK97
LIED96a
WAYN94a
incluyen
Interfaces
uniformes
Extensibilidad
Flexibilidad
Portabilidad
Fiabilidad
Soporte
sistemas
distribuidos
Soporte
sistemas
operativos
orientados
objetos
OOOS
Hilos
SMP
micronúcleos
177
HARDW
AREHARDW
ARE
Gestión
primitivas
procesos
Micronúcleo
Memoria
virtual
Gestión
dispositivos
Comunicación
procesos
Sistema
ficheros
Usuarios
Núcleo
capas
Micro
núcleo
usuario
núcleo
Proceso
cliente
Manejador
dispositivos
Servidor
ficheros
Servidor
procesos
Memoria
virtual
usuario
núcleo
Figura
4.10
Arquitectura
núcleo
04-Capitulo
12/5/05
16:20
Página
177El
micronúcleo
impone
interfaz
uniforme
peticiones
realizadas
proceso
procesos
necesitan
diferenciar
servicios
nivel
núcleo
nivel
usuario
servicios
proporcionan
paso
mensajes
forma
inevitable
sistema
operativo
adquirir
características
diseño
actual
medida
desarrollen
dispositivos
hardware
técnicas
soft-
ware
arquitectura
micronúcleo
facilita
extensibilidad
permitiendo
agregar
servicios
realización
múltiples
servicios
área
funcional
ejemplo
múltiples
organizaciones
archivos
disquetes
organización
implementar
proceso
nivel
usuario
múltiples
servicios
archivos
disponibles
núcleo
forma
usuarios
elegir
variedad
servicios
adapte
necesidades
arquitectura
micronúcleo
añade
característica
servi-
dor
relacionado
necesita
modificarse
añadirse
impacto
servidor
modificado
restringe
subconjunto
sistema
modificaciones
requieren
construcción
núcleo
Relacionado
extensibilidad
arquitectura
micronúcleo
flexibilidad
añadir
características
sistema
operativo
características
existentes
eliminar
implementación
pequeña
eficiente
sistema
operati-
vo
micronúcleo
necesariamente
sistema
pequeño
estructura
permite
añadir
amplio
rango
características
mundo
necesita
ejemplo
alto
nivel
seguridad
necesidad
computación
distribuida
características
sustanciales
términos
requisitos
memoria
opcionales
producto
atractivo
núme-
ro
usuarios
monopolio
Intel
segmentos
mercado
computación
impro-
bable
dure
indefinidamente
forma
portabilidad
convierte
característica
in-
teresante
sistemas
operativos
arquitectura
micronúcleo
código
es-
pecífico
procesador
micronúcleo
cambios
necesarios
transferir
sistema
procesador
menores
tienden
unidos
grupos
lógicos
tamaño
producto
software
dificultad
asegurar
fiabilidad
diseño
modular
ayuda
mejorar
fiabilidad
arquitectura
micronúcleo
lograr
mayores
ganancias
micronúcleo
pequeño
verificar
forma
rigurosa
utilice
pequeño
número
interfaces
programación
aplicaciones
API
sencillo
producir
código
calidad
servicios
sistema
operativo
nú-
cleo
programador
sistema
número
limitado
API
dominar
métodos
limita-
interacción
consiguiente
difícil
afectar
negativamente
componentes
sistema
micronúcleo
soporte
sistemas
distribuidos
incluyendo
clusters
controlados
sistemas
operativos
distribuidos
envía
mensaje
cliente
proceso
servidor
mensaje
incluir
identificador
servicio
pedido
configura
sistema
distribuido
ejemplo
cluster
forma
procesos
servicios
tengan
identificadores
únicos
imagen
sistema
nivel
micronúcleo
proce-
so
enviar
mensaje
máquina
reside
servicio
pedido
olveremos
punto
discusión
sistemas
distribuidos
arquitectura
micronúcleo
funciona
contexto
sistema
operativo
orientado
objetos
enfoque
orientado
objetos
servir
diseñar
micronúcleo
desarrollar
extensiones
modulares
sistema
operativo
resultado
diseños
micronúcleos
dirección
orientación
objetos
WAYN94b
enfoque
prometedor
casar
arqui-
tectura
micronúcleo
principios
OOOS
componentes
MESS96
compo-
nentes
objetos
interfaces
claramente
definidas
interconectadas
realiza-
178
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
178ción
software
bloques
construcción
interacción
componentes
utiliza
interfaz
componente
sistemas
tales
Windows
basan
exclusivamente
completo
métodos
orientados
objetos
incorporado
principios
orientación
ob-
jetos
diseño
micronúcleo
RENDIMIENTO
MICRONÚCLEO
potencial
desventaja
cita
micronúcleos
rendimiento
tiempo
construir
enviar
mensaje
micronúcleo
aceptar
decodificar
respuesta
simple
llamada
servicio
importantes
factores
forma
difícil
generalizar
desventaja
rendimiento
depende
tamaño
funcionalidad
micronúcleo
LIED96a
resume
número
estudios
revelan
pérdida
sustancial
rendimiento
denominados
micronúcleos
generación
pérdidas
continúan
esfuer-
zos
realizados
optimizar
código
micronúcleo
respuesta
problema
mayores
micronúcleos
volviendo
introducir
servicios
críticos
manejadores
sistema
operativo
ejemplos
enfoque
Mach
Chorus
Incrementando
forma
se-
lectiva
funcionalidad
micronúcleo
reduce
número
cambios
usuario-núcleo
número
cambios
espacio
direcciones
proceso
solución
reduce
problemas
rendimiento
sacrificando
fortaleza
diseño
micronúcleo
mínimas
inter-
faces
flexibilidad
etc.
enfoque
consiste
micronúcleo
pequeño
LIED96b
argumenta
apropiadamente
diseñado
micronúcleo
pequeño
elimina
pérdidas
rendimiento
mejora
flexibilidad
fiabilidad
idea
tamaños
típico
mi-
cronúcleo
generación
300
Kbytes
código
140
interfaces
llamadas
siste-
ma
ejemplo
micronúcleo
pequeño
generación
L4
HART97
LIED95
consiste
12
Kbytes
código
llamadas
sistema
experimentaciones
realizadas
sistemas
indican
funcionar
sistemas
operativos
capas
ejemplo
UNIX
DISEÑO
MICRONÚCLEO
micronúcleos
presentan
variedad
tamaños
funcionalidades
facilitar
reglas
concernientes
funcionalidades
darse
micronú-
cleo
estructura
implementarse
sección
presentamos
conjunto
mínimo
fun-
ciones
servicios
micronúcleo
perspectiva
diseño
micronúcleo
incluir
funciones
dependen
directamente
hardware
aque-
llas
funciones
necesarias
mantener
servidores
aplicaciones
operando
usuario
funciones
entran
categorías
generales
gestión
memoria
nivel
interco-
municación
procesos
IPC
manejo
interrupciones
Gestión
memoria
nivel
micronúcleo
controlar
concepto
hardware
espacio
direcciones
implementación
protección
nivel
proceso
micronúcleo
responsabilice
asignación
página
virtual
marco
físico
principal
gestión
memoria
incluyendo
protección
espacio
memoria
proce-
sos
algoritmo
reemplazo
páginas
lógica
paginación
implementarse
núcleo
ejemplo
módulo
memoria
virtual
micronúcleo
decide
traer
Hilos
SMP
micronúcleos
179
04-Capitulo
12/5/05
16:20
Página
179una
página
memoria
página
presente
memoria
reemplazarse
micronúcleo
proyecta
referencias
página
direcciones
físicas
memoria
principal
paginador
externo
Mach
YOUN87
introdujo
concepto
paginación
gestión
memoria
virtual
forma
externa
núcleo
Figura
4.11
muestra
fun-
cionamiento
paginador
externo
hilo
aplicación
referencia
página
memoria
principal
fallo
página
ejecución
pasa
núcleo
núcleo
manda
mensaje
proceso
paginador
indicando
página
referenciada
paginador
decidir
cargar
página
localizar
marco
página
propósito
paginador
núcleo
interactuar
operaciones
lógicas
paginador
memoria
física
página
disponible
paginador
manda
mensaje
aplicación
micro-
núcleo
técnica
permite
proceso
núcleo
proyectar
archivos
bases
datos
espa-
cios
direcciones
usuario
llamar
núcleo
políticas
compartición
memoria
especí-
ficas
aplicación
implementar
núcleo
LIED95
recomienda
conjunto
operaciones
micronúcleo
soporte
paginación
externa
gestión
memoria
virtual
Conceder
Grant
propietario
espacio
direcciones
proceso
conceder
páginas
proceso
núcleo
borra
páginas
espacio
memoria
otorgante
asigna
proceso
especificado
Proyectar
Map
proceso
proyectar
cualquiera
páginas
espacio
di-
recciones
proceso
forma
procesos
acceso
páginas
ge-
nera
memoria
compartida
procesos
núcleo
mantiene
asignación
pági-
nas
propietario
inicial
proporciona
asociación
permite
acceso
procesos
Limpiar
Flush
proceso
reclamar
página
concedida
asociada
proceso
comenzar
núcleo
asigna
memoria
física
disponible
recursos
proceso
base
sistema
medida
crean
procesos
conceder
asociar
páginas
espacio
direcciones
original
procesos
esquema
soporte
múltiples
esquemas
memoria
virtual
simultáneamente
Comunicación
procesos
Interprocess
Communication
forma
básica
comuni-
cación
procesos
hilos
sistema
operativo
micronúcleo
mensajes
180
Sistemas
operativos
Aspectos
internos
principios
diseño
Aplicación
Paginador
Micronúcleo
Llamada
función
espacio-
direcciones
Reanudar
Fallo
página
Figura
4.11
Procesamiento
fallo
página
04-Capitulo
12/5/05
16:20
Página
180mensaje
incluye
cabecera
identifica
procesos
remitente
receptor
cuerpo
con-
directamente
datos
puntero
bloque
datos
información
control
proceso
Normalmente
pensar
IPC
fundamentan
puertos
asociados
pro-
ceso
puerto
esencia
cola
mensajes
destinada
proceso
particular
proceso
múltiples
puertos
Asociada
puerto
lista
indica
procesos
pue-
den
comunicar
identidades
funcionalidades
puerto
mantienen
núcleo
proceso
concederse
funcionalidades
mandando
mensaje
núcleo
funcionalidades
puerto
Llegado
punto
conveniente
comentario
paso
mensajes
paso
mensajes
procesos
tengan
solapado
espacio
direcciones
implica
rea-
lizar
copia
memoria
memoria
forma
limitado
velocidad
memo-
ria
incrementa
velocidad
procesador
forma
investigación
actual
sistemas
operativos
muestra
interés
IPC
basado
hilos
esquemas
memoria
compartida
re-proyección
páginas
page
remapping
página
compartida
múltiples
procesos
Gestión
interrupciones
arquitectura
micronúcleo
manejar
inte-
rrupciones
hardware
mensajes
incluir
puertos
espacios
direcciones
micronúcleo
reconocer
interrupciones
manejar
genera
men-
saje
proceso
nivel
usuario
actualmente
asociado
interrupción
forma
habilita
interrupción
asigna
proceso
nivel
usuario
interrup-
ción
núcleo
mantiene
asociaciones
transformación
interrupciones
mensajes
micronúcleo
micronúcleo
relacionado
manejo
interrupcio-
nes
específico
dispositivos
LIED96a
sugiere
hardware
conjunto
hilos
identificadores
hilo
único
mandan
mensajes
únicamente
identificador
hilo
hilos
asociados
espacio
usuario
hilo
receptor
determina
mensaje
proviene
interrupción
determina
interrupción
específica
estructura
general
código
nivel
usuario
hilo
dispositivo
do
waitFor(msg
remitente
if
remitente
mi_interrupcion_hardware
leer
escribir
puertos
reanudar
interrupción
hardware
else
while(true
4.4
GESTIÓN
HILOS
SMP
WINDOWS
diseño
proceso
Windows
limitado
necesidad
proporcionar
soporte
diversos
entornos
sistemas
operativos
procesos
soportados
entornos
sistemas
operati-
vos
diferencian
cosas
incluyendo
siguientes
Hilos
SMP
micronúcleos
181
04-Capitulo
12/5/05
16:20
Página
181•
denominación
procesos
proporcionan
hilos
procesos
representa
procesos
protege
recursos
procesos
mecanismos
utilizan
comunicación
sincronización
procesos
relacionan
procesos
consecuencia
estructuras
procesos
servicios
proporcionados
núcleo
Windows
relativamente
sencillos
propósito
general
permitiendo
subsistema
sistema
operativo
emule
estructura
funcionalidad
particular
proceso
caracte-
rísticas
importantes
procesos
Windows
siguientes
procesos
Windows
implementados
objetos
proceso
ejecutable
contener
hilos
objeto
proceso
objeto
hilo
funcionalidades
sincronización
precons-
truidas
Figura
4.12
basada
SOLO00
muestra
forma
proceso
asocia
recursos
controla
utiliza
proceso
asigna
testigo
token
seguridad
ac-
ceso
denominada
ficha
principal
proceso
usuario
inicia
sesión
Windows
crea
ficha
acceso
incluye
ID
seguridad
usuario
proceso
crea
ejecu-
ta
representación
usuario
copia
testigo
acceso
Windows
utiliza
comprobar
usuario
acceder
objetos
seguridad
funciones
restrin-
gidas
sistema
objeto
seguridad
testigo
acceso
controla
proceso
mo-
dificar
atributos
caso
proceso
manejador
abierto
testigo
acceso
proceso
intenta
abrir
manejador
sistema
seguridad
determinará
per-
mitido
proceso
modificar
atributos
relacionado
proceso
serie
bloques
definen
espacio
direccio-
nes
virtuales
actualmente
asignado
proceso
proceso
modificar
directamente
es-
tructuras
dependen
gestor
memoria
virtual
proporciona
servicios
asignación
memoria
procesos
Finalmente
proceso
incluye
tabla
objetos
objetos
conocidos
proceso
manejador
hilo
contenido
objeto
Figura
4.12
muestra
único
hilo
proceso
acceso
objeto
archivo
objeto
segmento
define
seg-
mento
memoria
compartido
OBJETO
PROCESO
OBJETO
HILO
estructura
orientada
objetos
Windows
facilita
desarrollo
proceso
propósito
gene-
ral
Windows
tipos
objetos
relacionados
procesos
procesos
hilos
proceso
entidad
corresponde
trabajo
usuario
aplicación
posee
recursos
memoria
archivos
abiertos
hilo
unidad
trabajo
activar
eje-
cuta
secuencialmente
interrumpible
forma
procesador
cambiar
hilo
proceso
Windows
representa
objeto
Figura
4.23a
estructura
objeto
proceso
define
serie
atributos
encapsula
serie
acciones
servicios
proceso
realizará
servicio
reciba
mensaje
apropiado
182
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
182única
forma
invocar
servicio
mensajes
objeto
proceso
proporciona
servicio
Windows
crea
proceso
utiliza
objeto
definido
proceso
Win-
dows
plantilla
generar
instancia
proceso
momento
creación
asignan
valores
atributos
Tabla
4.3
definición
atributo
objeto
contenido
objeto
proceso
proceso
Windows
contener
hilo
ejecutar
hilo
crear
hilos
sistema
multiprocesador
múltiples
hilos
proceso
eje-
cutar
paralelo
Figura
4.13b
representa
estructura
objeto
hilo
Tabla
4.4
define
atributos
objeto
hilo
importante
darse
atributos
hilos
asemeja
procesos
casos
valor
atributo
hilo
deriva
valor
atributo
proceso
ejemplo
afinidad
procesador
asociada
hilo
thread
processor
af-
finity
conjunto
procesadores
sistema
multiprocesador
ejecutar
hilo
conjunto
subconjunto
afinidad
procesador
asociada
proceso
Adviértase
atributos
proceso
hilo
contexto
información
permite
hilo
suspenda
reanude
cambiar
comportamiento
hilo
alterando
contenido
hilo
suspendido
MULTIHILO
Windows
soporta
concurrencia
procesos
hilos
procesos
ejecutar
paralelo
múltiples
hilos
proceso
asignados
distintos
procesadores
ejecutar
concurrente
proceso
multihilo
lograr
concurrencia
sobre-
carga
múltiples
procesos
hilos
proceso
intercambiar
información
espacio
direcciones
común
acceso
recursos
compartidos
proceso
hilos
procesos
intercambiar
información
memoria
compartida
Hilos
SMP
micronúcleos
183
Objeto
proceso
Ficha
acceso
Descriptores
direcciones
virtuales
Hilo
Archivo
Sección
Manejador
Manejador
Manejador
Objetos
disponibles
Tabla
manejadores
Figura
4.12
proceso
Windows
recursos
04-Capitulo
12/5/05
16:20
Página
183
abla
4.3
Atributos
objeto
proceso
Windows
ID
proceso
valor
único
identifica
proceso
sistema
operativo
Descriptor
seguridad
Describe
creador
objeto
acceder
utilizar
obje-
to
deniega
acceso
objeto
Prioridad
base
Prioridad
ejecución
base
hilos
proceso
Afinidad
procesador
Conjunto
procesadores
defecto
ejecutar
defecto
hilos
proceso
Límite
cuota
Máxima
cantidad
memoria
sistema
paginada
paginada
espacio
archivo
páginas
tiempo
procesador
utilizar
procesos
usuario
Tiempo
ejecución
cantidad
tiempo
ejecutado
hilos
proceso
Contadores
Variables
almacenan
número
tipo
operaciones
hilos
proceso
Contadores
operaciones
Variables
almacenan
número
tipo
operaciones
MV
memoria
virtual
hilos
proceso
Puertos
excepciones
Canales
comunicación
procesos
gestor
proce-
depurado
sos
manda
mensaje
hilos
proceso
causa
excepción
salida
razón
terminación
proceso
184
Sistemas
operativos
Aspectos
internos
principios
diseño
ID
proceso
Descriptor
seguridad
Prioridad
base
Afinidad
procesador
defecto
Límite
cuota
Tiempo
ejecución
Contadores
Contadores
operaciones
MV
Puertos
excepciones
depurado
salida
Crear
proceso
Abrir
proceso
Solicitar
información
proceso
Establecer
información
proceso
Proceso
actual
Terminar
proceso
ProcesoTipo
objeto
Atributos
cuerpo
objeto
Servicios
ID
hilo
Contexto
hilo
Prioridad
dinámica
Prioridad
base
Afinidad
procesador
hilo
Tiempo
ejecución
hilo
alerta
Contador
suspensiones
Testigo
personificación
Puerto
finalización
salida
hilo
Crear
hilo
Abrir
hilo
Solicitar
información
hilo
Establecer
información
hilo
Hilo
actual
Terminar
hilo
Obtener
contexto
Establecer
contexto
Suspender
Reanudar
Alertar
hilo
Chequear
alerta
Registrar
puerto
finalización
Hilo
Servicios
Objeto
proceso
Objeto
hilo
Atributos
cuerpo
objeto
Tipo
objeto
Figura
4.13
Objetos
Windows
proceso
hilo
04-Capitulo
12/5/05
16:20
Página
184
abla
4.4
Atributos
objeto
hilo
Windows
ID
hilo
Valor
único
identifica
hilo
llama
servidor
Contexto
hilo
conjunto
valores
registros
información
volátil
define
ejecución
hilo
Prioridad
dinámica
prioridad
ejecución
hilo
determinado
momento
Prioridad
base
límite
inferior
prioridad
dinámica
hilo
Afinidad
procesador
conjunto
procesadores
ejecutar
hilo
asociada
hilo
subconjunto
valor
definido
objeto
proceso
Tiempo
ejecución
hilo
cantidad
tiempo
acumulado
ejecutado
hilo
usuario
núcleo
alerta
flag
indica
hilo
ejecutar
llamada
procedimien-
to
asíncrona
Contador
suspensión
número
suspendida
ejecución
hilo
reanudado
Testigo
personificación
señal
acceso
temporal
permite
hilo
operaciones
lugar
proceso
utilizado
subsistemas
Puerto
finalización
Canal
comunicación
procesos
gestor
procesos
manda
mensaje
termina
hilo
utilizado
subsis-
temas
salida
hilo
razón
terminación
hilo
proceso
multihilo
orientado
objetos
forma
efectiva
implementar
aplicación
servidora
ejemplo
proceso
servidor
atender
clientes
petición
cliente
desencadena
creación
hilo
servidor
HILOS
hilo
Windows
Figura
4.14
Listo
ready
planificarse
ejecución
activador
micronúcleo
conoce
hilos
listos
planifica
orden
prioridad
Substituto
standby
hilo
substituto
seleccionado
ejecutar
lugar
determinado
procesador
prioridad
hilo
substituto
suficientemente
alta
hilo
actualmente
ejecución
procesador
expulsado
favor
forma
hilo
substituto
espera
hilo
ejecución
bloquea
finaliza
porción
tiempo
Ejecutando
running
micronúcleo
realiza
intercambio
hilo
proce-
so
hilo
susbtituto
pasa
ejecución
ejecuta
expulsado
finaliza
porción
tiempo
bloquea
termina
casos
vuelve
cola
listos
Esperando
waiting
hilo
pasa
esperando
bloquea
evento
ejemplo
espera
voluntariamente
temas
sincronización
subsiste-
ma
manda
hilo
suspendido
satisface
condición
espera
hilo
pasa
Listo
recursos
disponibles
Hilos
SMP
micronúcleos
185
04-Capitulo
12/5/05
16:20
Página
185•
Transición
transition
hilo
entra
esperar
listo
eje-
cutar
recursos
disponibles
ejemplo
pila
hilo
memoria
recursos
disponibles
hilo
pasa
Listo
Terminado
terminated
hilo
finalizar
hilo
proceso
padre
finaliza
completan
tareas
internas
hilo
borra
sistema
retenerse
ejecutivo
futuras
reinicializaciones
SOPORTE
SUBSISTEMAS
SISTEMAS
OPERATIVOS
servicios
procesos
hilos
propósito
general
soporte
estructuras
procesos
hilos
SO
cliente
subsistema
SO
responsable
sacar
provecho
procesos
hilos
Windows
sistema
operativo
área
gestión
procesos
hilos
com-
plicada
damos
pequeña
visión
general
creación
proceso
comienza
petición
aplicación
proceso
aplicación
manda
solicitud
creación
proceso
correspondiente
subsistema
pasa
solicitud
ejecutivo
Windows
ejecutivo
crea
objeto
proceso
devuelve
subsistema
manejador
objeto
Windows
crea
proceso
crea
automáticamente
hilo
caso
Win32
OS/2
crea
proceso
hilo
consiguiente
sistemas
operativos
subsistema
llama
gestor
procesos
Windows
crear
hilo
proceso
recibiendo
manejador
hilo
respuesta
continuación
de-
vuelven
aplicación
información
hilo
proceso
caso
Windows
16-bit
POSIX
186
Sistemas
operativos
Aspectos
internos
principios
diseño
ejecutivo
Windows
describe
Capítulo
Contiene
servicios
base
sistema
operativo
gestión
me-
moria
gestión
procesos
hilos
seguridad
comunicación
procesos
Ejecutable
Escogido
ejecutar
Cambiar
Expulsado
Bloquear/
suspender
Desbloquear/
reanudar
Recurso
disponible
Recurso
disponible
Desbloquear
Recurso
disponible
Finalizar
Sustituto
Listo
Ejecutando
Transición
Esperando
Finalizado
Ejecutable
Figura
4.14
hilo
Windows
04-Capitulo
12/5/05
16:20
Página
186no
soportan
hilos
sistemas
operativos
subsistema
obtiene
hilo
proceso
Windows
proceso
activarse
devuelve
informa-
ción
proceso
aplicación
proceso
aplicación
esté
implementado
hilo
visible
aplicación
crea
proceso
Win32
OS/2
proceso
hereda
atri-
butos
proceso
creado
entorno
Windows
procedimiento
crea-
ción
realiza
indirectamente
proceso
cliente
aplicación
manda
solicitud
creación
proceso
subsistema
SO
proceso
subsistema
manda
solicitud
proceso
ejecutivo
Windows
efecto
deseado
proceso
herede
características
proceso
cliente
proceso
servidor
Windows
permite
subsistema
especificar
padre
proceso
proceso
hereda
testigo
acceso
límite
cuota
prioridad
base
afini-
dad
procesador
defecto
padre
SOPORTE
MULTIPROCESAMIENTO
SIMÉTRICO
Windows
soporta
configuración
hardware
SMP
hilos
proceso
incluyendo
ejecutivo
ejecutar
procesador
ausencia
restricciones
afinidad
ex-
plicadas
párrafo
micronúcleo
asigna
hilo
listo
procesador
disponi-
ble
asegura
procesador
ocioso
ejecutando
hilo
menor
prioridad
hilo
prioridad
listo
Múltiples
hilos
proceso
ejecutar
múltiples
procesadores
defecto
micronúcleo
utiliza
política
afinidad
débil
soft
affinity
asignar
procesa-
dores
hilos
planificador
intenta
asignar
proceso
listo
procesador
ejecutó
ayuda
reutilizar
datos
estén
memoria
cache
procesador
ejecución
previa
hilo
aplicación
restringir
ejecución
hilos
deter-
minados
procesadores
afinidad
fuerte
hard
affinity
4.5
GESTIÓN
HILOS
SMP
SOLARIS
Solaris
implementa
soporte
hilo
multinivel
habitual
diseñado
proporcionar
conside-
rable
flexibilidad
sacar
provecho
recursos
procesador
ARQUITECTURA
MULTIHILO
Solaris
utiliza
conceptos
relacionados
hilos
Procesos
proceso
normal
UNIX
incluye
espacio
direcciones
usuario
pila
bloque
control
proceso
Hilos
nivel
usuario
Implementados
biblioteca
hilos
espacio
direcciones
proceso
invisibles
sistema
operativo
hilos
nivel
usuario
user-level
threads
ULT
interfaz
aplicaciones
paralelas
Hilos
SMP
micronúcleos
187
acrónimo
ULT
exclusivo
libro
literatura
Solaris
04-Capitulo
12/5/05
16:20
Página
187•
Procesos
ligeros
proceso
ligero
lightweight
process
LWP
visto
asociación
ULT
hilos
núcleo
LWP
soporta
ULT
asocia
hilo
núcleo
LWP
planifican
forma
independiente
núcleo
ejecutar
paralelo
múltiples
procesadores
Hilos
núcleo
entidades
fundamentales
planificar
ejecutar
cual-
quier
procesador
sistema
Figura
4.15
muestra
relación
entidades
Nótese
hilo
núcleo
LWP
LWP
visible
proceso
aplicación
forma
estructuras
datos
LWP
espacio
direcciones
proceso
respectivo
tiempo
LWP
vinculado
único
hilo
núcleo
activable
estructura
datos
hilo
núcleo
mantiene
espacio
direcciones
núcleo
ejemplo
proceso
consiste
único
ULT
vinculado
único
LWP
forma
único
hilo
ejecución
correspondiente
proceso
UNIX
tradicional
requiere
concurrencia
proceso
aplicación
utiliza
estructura
proceso
proceso
corresponde
estrategia
ULT
pura
ULT
soportados
único
hilo
nú-
cleo
ejecutar
ULT
tiempo
estructura
útil
apli-
cación
programar
forma
exprese
concurrencia
necesario
ejecu-
tar
paralelo
múltiples
hilos
proceso
muestra
múltiples
hilos
multiplexados
menor
número
LWP
general
Solaris
permite
aplicaciones
multiplexar
ULT
número
menor
LWP
permite
aplicación
especificar
grado
paralelismo
nivel
núcleo
proceso
proceso
hilos
permanentemente
vinculados
LWP
estructura
paralelismo
nivel
núcleo
totalmente
visible
aplicación
útil
188
Sistemas
operativos
Aspectos
internos
principios
diseño
PPPPP
Usuario
Núcleo
Hardware
Biblioteca
hilos
Proceso
5Proceso
4Proceso
3Proceso
2Proceso
Hilo
nivel
usuario
Hilo
núcleo
Proceso
ligero
Procesador
LLL
LLL
Figura
4.15
Ejemplo
arquitectura
multihilo
Solaris
04-Capitulo
12/5/05
16:20
Página
188hilos
suspenderse
frecuentemente
quedar
bloqueados
proceso
muestra
asocia-
ción
múltiples
ULT
múltiples
LWP
enlace
ULT
LWP
LWP
asociado
procesador
particular
muestra
figura
presencia
hilos
núcleo
asociados
LWP
núcleo
crea
ejecuta
destruye
hilos
núcleo
ejecutar
funciones
específicas
sistema
hilos
núcleo
lugar
procesos
núcleo
implementar
funciones
sis-
tema
reduce
sobrecarga
intercambios
núcleo
cambios
procesos
cambios
hilos
MOTIVACIÓN
combinación
hilos
nivel
usuario
nivel
núcleo
oportunidad
progra-
mador
aplicación
explotar
concurrencia
forma
efectiva
apropiada
aplicación
programas
paralelismo
lógico
sacar
provecho
simplifi-
car
estructurar
código
necesitan
paralelismo
hardware
ejemplo
aplicación
emplee
múltiples
ventanas
activa
determinado
momento
po-
dría
beneficiarse
implementación
conjunto
ULT
único
LWP
ventaja
restringir
aplicaciones
ULT
eficiencia
ULT
crear
destruir
bloquear
acti-
var
etc.
involucrar
núcleo
núcleo
conociera
ULT
tendría
asignar
estructuras
datos
núcleo
intercambio
hilos
visto
Tabla
4.1
intercambio
hilos
nivel
núcleo
costoso
intercambio
hilos
nivel
usuario
aplicación
hilos
bloquear
ejemplo
realiza
resultará
interesante
múltiples
LWP
soportar
número
ULT
aplicación
biblioteca
hilos
necesitan
contorsiones
permitir
ejecutar
hilos
proce-
so
lugar
hilo
proceso
bloquea
hilos
proceso
ejecutar
restantes
LWP
Asociar
ULT
LWP
efectivo
aplicaciones
ejemplo
computa-
ción
paralela
matrices
dividir
filas
matrices
hilos
exacta-
mente
ULT
LWP
requiere
intercambio
hilos
proceso
computación
mezcla
hilos
permanentemente
asociados
LWP
hilos
asociados
múlti-
ples
hilos
compartiendo
múltiples
LWP
apropiada
aplicaciones
ejemplo
apli-
cación
tiempo
real
querer
hilos
tuvieran
prioridad
sistema
pla-
nificación
tiempo
real
hilos
realizan
funciones
secundarias
compartir
pequeño
conjunto
LWP
ESTRUCTURA
PROCESOS
Figura
4.16
compara
términos
generales
estructura
proceso
sistema
UNIX
tra-
dicional
Solaris
implementación
UNIX
típica
estructura
proceso
incluye
ID
proceso
ID
usuario
tabla
tratamiento
señales
núcleo
decidir
llega
señal
proceso
descriptores
archivos
describen
archivos
proceso
mapa
memoria
define
espacio
direcciones
proceso
estructura
procesador
incluye
pila
núcleo
proceso
Solaris
contiene
estructura
básica
reemplaza
bloque
procesador
lis-
ta
estructuras
contienen
bloque
datos
LWP
Hilos
SMP
micronúcleos
189
04-Capitulo
12/5/05
16:20
Página
189La
estructura
datos
LWP
incluye
siguientes
elementos
identificador
LWP
prioridad
LWP
hilo
núcleo
soporte
máscara
señales
núcleo
señales
aceptarán
Valores
almacenados
registros
nivel
usuario
LWP
ejecutando
pila
núcleo
LWP
incluye
argumentos
llamadas
sistema
resultados
códigos
error
nivel
llamada
recursos
datos
perfiles
Puntero
correspondiente
hilo
núcleo
Puntero
estructura
proceso
EJECUCIÓN
HILOS
Figura
4.17
muestra
visión
simplificada
ejecución
ULT
LWP
ejecu-
ción
hilos
nivel
usuario
gestiona
biblioteca
hilos
Consideremos
190
Sistemas
operativos
Aspectos
internos
principios
diseño
ID
proceso
Estructura
proceso
UNIX
ID
usuario
Tabla
activación
señales
Descriptores
archivos
Mapa
memoria
Prioridad
Máscara
señales
Registros
PILA
procesador
Estructura
proceso
Solaris
LW
ID
LWP
LWP
Prioridad
Máscara
señales
Registros
PILA
ID
proceso
ID
usuario
Tabla
activación
señales
Mapa
memoria
Descriptores
archivos
ID
LWP
Prioridad
Máscara
señales
Registros
PILA
Figura
4.16
Estructura
procesos
UNIX
tradicional
Solaris
04-Capitulo
12/5/05
16:20
Página
190los
hilos
vinculados
hilos
comparten
serie
LWP
hilo
vinculado
siguientes
ejecutable
activo
durmiendo
detenido
ULT
activo
asigna
LWP
ejecuta
hilo
núcleo
subyacente
ejecuta
serie
eventos
causar
ULT
deje
activo
Consideremos
ULT
acti-
vo
denominado
T1
ocurrir
siguientes
sucesos
Sincronización
T1
invoca
primitivas
concurrentes
discutidas
Capítulo
coordinar
actividad
hilos
forzar
exclusión
mutua
T1
pasa
dur-
miendo
cumple
condición
sincronización
T1
pasa
ejecutable
Suspensión
hilo
incluyendo
T1
causar
suspenda
T1
pase
detenido
T1
permanece
hilo
manda
petición
conti-
nuación
pasa
ejecutable
Expulsión
hilo
activo
T1
hilo
causa
hilo
T2
prioridad
pase
ejecutable
T1
hilo
menor
prioridad
expulsa
pasa
ejecutable
T2
asigna
LWP
disponible
Ceder
paso
T1
ejecuta
mandato
biblioteca
thr_yield
planificador
hilos
biblioteca
mirará
proceso
ejecutable
T2
prioridad
T1
pasa
ejecutable
T2
asigna
LWP
liberado
T1
continúa
ejecutando
casos
precedentes
T1
sale
activo
biblioteca
hilos
selec-
ciona
hilo
vinculado
ejecutable
ejecuta
LWP
nuevamente
disponible
Figura
4.17
muestra
diagrama
LWP
diagrama
descripción
detallada
activo
ULT
hilo
vinculado
LWP
asignado
Activo
diagrama
LWP
explica
hilo
activo
ejecutando
LWP
Ejecutando
Cuan-
do
hilo
activo
ejecuta
llamada
sistema
bloqueante
LWP
pasa
Bloqueado
ULT
permanece
vinculado
LWP
concierne
biblioteca
hilos
ULT
permanece
activo
hilos
vinculados
relación
ULT
LWP
ligeramente
ejemplo
ULT
vinculado
pasa
Durmiendo
espera
evento
sincronización
LWP
parar
ejecutar
logra
manteniendo
bloqueo
LWP
variable
sin-
cronización
nivel
núcleo
INTERRUPCIONES
HILOS
sistemas
operativos
contienen
formas
actividad
concurrente
procesos
interrupciones
procesos
hilos
cooperan
gestionan
estructuras
datos
compartidas
diversas
primitivas
fuerzan
exclusión
mutua
proceso
mis-
mo
tiempo
ejecutar
determinado
código
acceder
determinados
datos
sincronizan
ejecución
interrupciones
sincronizan
impidiendo
manejo
periodo
tiempo
Solaris
unifica
conceptos
modelo
interrupciones
convierten
hi-
núcleo
motivación
convertir
interrupciones
hilos
reducir
sobrecarga
proceso
tratamiento
interrupciones
maneja
datos
compartidos
resto
núcleo
consiguiente
ejecuta
rutina
núcleo
accede
datos
interrupciones
Hilos
SMP
micronúcleos
191
04-Capitulo
12/5/05
16:20
Página
191se
bloquear
interrupciones
vayan
afectar
da-
tos
Normalmente
forma
rutina
suba
nivel
prioridad
interrupciones
bloquear
interrupciones
baje
nivel
prioridad
acceso
completado
operaciones
llevan
tiempo
problema
sistema
multiprocesador
núcleo
pro-
teger
objetos
necesitar
bloquear
interrupciones
procesadores
solución
Solaris
resumir
Solaris
emplea
conjunto
hilos
núcleo
manejar
interrupciones
cual-
quier
hilo
núcleo
hilo
interrupción
identificador
prioridad
contexto
pila
núcleo
controla
acceso
estructuras
datos
sincroniza
hilos
interrupción
utilizando
primitivas
exclusión
mutua
tipo
discutido
Capítulo
utili-
zan
técnicas
habituales
sincronización
hilos
manejo
interrupciones
192
Sistemas
operativos
Aspectos
internos
principios
diseño
Hilos
nivel
usuario
Ejecutable
Continuar
Dormir
Parar
Despertar
Parar
Parar
Activar
Expulsar
Ejecutable
Procesos
ligeros
Ejecutando
Bloqueado
Activar
Parar
Continuar
Rodaja
tiempo
expulsado
Despertar
Bloqueando
sistema
llamada
Parado
Parado
Activo
Durmiendo
Despertar
Parar
Figura
4.17
hilos
nivel
usuarios
LWP
Solaris
04-Capitulo
12/5/05
16:20
Página
1923
asigna
prioridad
hilos
interrupción
tipo
hilo
núcleo
sucede
interrupción
envía
determinado
procesador
hilo
estuviera
ejecutando
procesador
inmovilizado
pinned
hilo
inmovilizado
mover
procesador
contexto
preserva
simplemente
suspende
procesa
interrup-
ción
procesador
comienza
ejecutar
hilo
interrupción
conjunto
hilos
interrupción
desactivados
disponibles
necesario
crear
hilo
continua-
ción
ejecuta
hilo
interrupción
manejar
interrupción
rutina
interrupción
necesita
acceso
estructura
memoria
bloqueada
hilo
ejecución
hilo
inte-
rrupción
deberá
esperar
acceder
dicha
estructura
hilo
interrupción
expul-
sado
hilo
interrupción
prioridad
experimentación
interrupciones
Solaris
indican
enfoque
proporciona
rendimiento
superior
estrategias
manejo
interrupciones
tradicionales
KLEI95
4.6
GESTIÓN
PROCESOS
HILOS
LINUX
TAREAS
LINUX
proceso
tarea
Linux
representa
estructura
datos
ttaasskk__ssttrruucctt
contiene
información
diversas
categorías
ejecución
proceso
ejecutando
listo
suspendido
detenido
zombie
Pasaremos
describirlo
posteriormente
Información
planificación
Información
necesitada
Linux
planificar
procesos
proceso
normal
tiempo
real
prioridad
procesos
tiempo
real
planifican
procesos
normales
categoría
prio-
ridades
relativas
contador
cantidad
tiempo
proceso
ejecutando
Identificadores
proceso
identificador
único
proceso
identi-
ficadores
usuario
grupo
identificador
usuario
utiliza
asignar
privilegios
acceso
recursos
grupo
procesos
Comunicación
procesos
Linux
soporta
mecanismo
IPC
encontrado
UNIX
SVR4
descrito
Capítulo
Enlaces
proceso
incluye
enlace
padres
enlaces
hermanos
procesos
padre
enlaces
hijos
Tiempos
temporizadores
Incluye
tiempo
creación
proceso
cantidad
tiem-
po
procesador
consumido
proceso
momento
proceso
te-
ner
asociado
temporizadores
proceso
define
temporizador
llamada
sistema
resultado
manda
señal
proceso
finaliza
tempori-
zador
temporizador
periódico
Sistema
archivos
Incluye
punteros
archivo
abierto
proceso
punteros
directorios
actual
raíz
proceso
Espacio
direcciones
Define
espacio
direcciones
virtual
asignado
proceso
Hilos
SMP
micronúcleos
193
04-Capitulo
12/5/05
16:20
Página
193•
Contexto
específico
procesador
información
registros
pila
constitu-
yen
contexto
proceso
Ejecutando
valor
corresponde
proceso
Ejecutando
ejecutando
listo
ejecutar
Interrumpible
bloqueado
proceso
esperando
evento
finalización
operación
disponibilidad
recurso
señal
proceso
Ininterrumpible
bloqueado
diferencia
In-
terrumpible
Ininterrumpible
proceso
esperando
directamente
hardware
manejará
señal
Detenido
proceso
parado
reanudado
acción
positiva
proceso
ejemplo
proceso
depurado
Parado
Zombie
proceso
terminado
razón
estructura
tarea
tabla
procesos
HILOS
LINUX
sistemas
UNIX
tradicionales
soportan
hilo
ejecución
proceso
sistemas
UNIX
modernos
suelen
proporcionar
soporte
múltiples
hilos
nivel
núcleo
proceso
sistemas
UNIX
tradicionales
versiones
antiguas
núcleo
Linux
ofrecían
soporte
multihilo
lugar
aplicaciones
debían
escribirse
conjunto
fun-
194
Sistemas
operativos
Aspectos
internos
principios
diseño
ejecutando
Creación
Planificando
Finalización
SeñalSeñal
Evento
Señal
evento
Parado
Listo
Ejecutando
Zombie
Ininterrumpible
Interrumpible
Figura
4.18
Modelo
procesos
hilos
Linux
04-Capitulo
12/5/05
16:20
Página
194ciones
biblioteca
nivel
usuario
popular
bibliotecas
conoce
bi-
blioteca
pthread
POSIX
thread
asociaban
hilos
único
proceso
nivel
núcleo
visto
versiones
modernas
UNIX
ofrecen
hilos
nivel
núcleo
Li-
nux
proporciona
solución
única
diferencia
hilos
procesos
Utilizando
mecanismo
similar
procesos
ligeros
Solaris
hilos
nivel
usuario
asocian
procesos
nivel
núcleo
Múltiples
hilos
nivel
usuario
constituyen
único
pro-
ceso
nivel
usuario
asocian
procesos
Linux
nivel
núcleo
comparten
ID
grupo
permite
procesos
compartir
recursos
tales
archivos
memorias
evi-
tar
necesidad
cambio
contexto
planificador
cambia
procesos
grupo
Linux
crea
proceso
copiando
atributos
proceso
actual
proceso
clonar
forma
comparte
recursos
tales
archivos
manejadores
señales
memoria
virtual
procesos
comparten
memoria
virtual
funcionan
hi-
proceso
define
tipo
estructura
datos
independiente
hilo
lugar
mandato
normal
fork
procesos
crean
Linux
usando
manda-
to
clone
mandato
incluye
conjunto
flags
argumentos
definidos
Tabla
4.5
llamada
sistema
tradicional
fork
implementa
Linux
llamada
sistema
clo-
ne()sin
flag
núcleo
Linux
realiza
cambio
proceso
verifica
dirección
di-
rectorio
páginas
proceso
actual
proceso
planificado
compartiendo
espacio
direcciones
cambio
contexto
consiste
básicamen-
saltar
posición
código
procesos
clonados
grupo
procesos
compartir
espacio
memoria
compartir
pila
usuario
llamada
clone()crea
espacios
pila
separados
proceso
abla
4.5
Flags
llamada
clone
Linux
CLONE_CLEARID
Borrar
ID
tarea
CLONE_DETACHED
padre
envío
señal
SIGCHLD
finalización
CLONE_FILES
Compartir
tabla
identifica
archivos
abiertos
CLONE_FS
Compartir
tabla
identifica
directorio
raíz
directorio
actual
trabajo
valor
máscara
bits
utilizada
enmascarar
permisos
iniciales
archivo
CLONE_IDLETASK
Establecer
PID
cero
refiere
tarea
idle
tarea
idle
utiliza
tareas
disponibles
bloqueadas
esperando
re-
cursos
CLONE_NEWNS
Crear
espacio
nombres
hijo
CLONE_PARENT
llamante
tarea
comparten
proceso
padre
CLONE_PTRACE
proceso
padre
trazado
proceso
hijo
hará
CLONE_SETTID
Escribir
TID
espacio
usuario
CLONE_SETTLS
Crear
TLS
hijo
CLONE_SIGHAND
Compartir
tabla
identifica
manejadores
señales
Hilos
SMP
micronúcleos
195
04-Capitulo
12/5/05
16:20
Página
195CLONE_SYSVSEM
Compartir
semántica
SEM_UNDO
System
V.
CLONE_THREAD
Insertar
proceso
grupo
hilos
padre
flag
activado
fuerza
forma
implícita
CLONE_PARENT
CLONE_VFORK
activado
padre
planifica
ejecución
hijo
invoque
llamada
sistema
execve
CLONE_VM
Compartir
espacio
direcciones
descriptor
memoria
ta-
blas
páginas
4.7
RESUMEN
sistemas
operativos
distinguen
conceptos
proceso
hilo
relacionado
propiedad
recursos
relacionado
ejecución
programas
enfo-
mejorar
eficiencia
conveniencia
código
sistema
multihilo
definir
múltiples
hilos
concurrentes
proceso
utilizando
hilos
nivel
usuario
hilos
nivel
núcleo
sistema
operativo
desconce
existencia
hilos
nivel
usuario
crean
gestionan
biblioteca
hilos
ejecuta
espacio
usuario
proceso
hilos
nivel
usuario
eficientes
requiere
cambio
contexto
cambiar
hilo
ejecutando
tiempo
único
hilo
nivel
usuario
hilo
bloquea
proceso
entero
hará
hilos
nivel
núcleo
hilos
pro-
ceso
mantienen
núcleo
reconocidos
núcleo
múltiples
hilos
mis-
mo
proceso
ejecutar
paralelo
multiprocesador
bloqueo
hilo
bloquea
proceso
completo
requiere
cambio
contexto
cambiar
hilo
multiprocesamiento
simétrico
método
organizar
sistema
multiprocesador
forma
proceso
hilo
ejecutar
procesador
incluye
código
núcleo
procesos
arquitecturas
SMP
generan
conceptos
diseño
siste-
operativos
proporcionan
rendimiento
sistema
uniprocesador
condiciones
años
habido
interés
diseño
sistemas
operativos
basados
micronúcleo
forma
pura
sistema
operativo
micronúcleo
consiste
micronúcleo
pequeño
ejecuta
núcleo
contiene
funciones
esenciales
críticas
sistema
operativo
resto
funciones
sistema
operativo
implementa
ejecutar
usuario
utilizar
micronúcleo
servicios
críticos
diseño
tipo
micronúcleo
implementaciones
flexibles
altamente
modulares
persisten
preguntas
rendimiento
arquitecturas
4.8
LECTURAS
RECOMENDADAS
LEWI96
KLEI96
proporcionan
visión
general
concepto
hilos
discu-
sión
estrategias
programación
centra
conceptos
cen-
tra
programación
proporcionan
cobertura
temas
PHAM96
hilos
Windows
NT
profundidad
ROBB04
cobertura
concep-
to
hilos
UNIX
196
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
196[MUKH96
proporciona
discusión
aspectos
diseño
sistemas
opera-
tivos
SMP
CHAP97
contiene
artículos
direcciones
diseño
actual
sis-
temas
operativos
multiprocesador
LIED95
LIED96
contienen
discusiones
interesantes
principios
diseño
micronúcleos
centra
aspectos
rendimiento
CHAP97
Chapin
S.
Maccabe
A.
eds
Multiprocessor
Operating
Systems
Harnessing
the
Power
Special
issue
of
IEEE
Concurrency
Abril-Junio
1997
KLEI96
Kleiman
S.
Shah
D.
Smallders
B.
Programming
with
Threads
Upper
Saddle
River
NJ
Prentice
Hall
1996
LEWI96
Lewis
B.
Berg
D.
Threads
Upper
Saddle
River
NJ
Prentice
Hall
1996
LIED95
Liedtke
J.
On
m-Kernel
Construction
Proceedings
of
the
Fifteenth
ACM
Symposium
on
Operating
Systems
Principles
Diciembre
1995
LIED96
Liedtke
J.
Toward
Real
Microkernels
Communications
of
the
ACM
Septiembre
1996
MUKH96
Mukherjee
B.
Karsten
S.
Operating
Systems
for
Parallel
Machines
in
Parallel
Compu-
ters
Theory
Practice
Edited
by
Casavant
Tvrkik
Plasil
Alamitos
CA
IEEE
Compu-
ter
Society
Press
1996
PHAM96
Pham
Garg
Multithreaded
Programming
with
Windows
NT
Upper
Saddle
River
NJ
Prentice
Hall
1996
ROBB04
Robbins
K.
Robbins
S.
UNIX
Systems
Programming
Communication
Concurrency
Th-
reads
Upper
Saddle
River
NJ
Prentice
Hall
2004
4.9
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
hilo
micronúcleo
procesos
ligeros
hilos
nivel
núcleo
KLT
multihilo
puerto
hilo
nivel
usuario
ULT
multiprocesador
simétrico
SMP
sistema
operativo
monolítico
mensaje
proceso
tarea
PREGUNTAS
REVISIÓN
4.1
Tabla
3.5
enumera
elementos
típicos
encuentran
bloque
control
proceso
sistema
operativo
monohilo
pertenecer
blo-
control
hilo
pertenecer
bloque
control
proceso
sistema
multihilo
4.2
Enumere
razones
cambio
contexto
hilos
barato
cambio
contexto
procesos
4.3
características
potencialmente
independientes
con-
cepto
proceso
4.4
Dé
ejemplos
generales
hilos
sistema
multiprocesador
monousuario
4.5
recursos
compartidos
normalmente
hilos
proceso
4.6
Enumere
ventajas
ULT
KLT
Hilos
SMP
micronúcleos
197
04-Capitulo
12/5/05
16:20
Página
1974.7
Enumere
desventajas
ULT
comparación
KLT
4.8
Defina
jacketing
revestimiento
4.9
Defina
brevemente
diversas
arquitecturas
nombran
Figura
4.8
4.10
Enumere
aspectos
principales
diseño
sistema
operativo
SMP
4.11
Dé
ejemplos
servicios
funciones
encuentran
sistema
operativo
monolíti-
co
típico
subsistemas
externos
sistema
operativo
micronúcleo
4.12
Enumere
explique
brevemente
ventajas
potenciales
diseño
micronúcleo
comparación
diseño
monolítico
4.13
Explique
desventaja
potencial
rendimiento
sistema
operativo
micronúcleo
4.14
Enumere
funciones
gustaría
encontrar
sistema
operativo
micro-
núcleo
mínimo
4.15
forma
básica
comunicación
procesos
hilos
sistema
operativo
micronúcleo
PROBLEMAS
4.1
ventajas
utilizar
múltiples
hilos
proceso
necesita
trabajo
creación
hilo
proceso
existente
creación
proceso
simplifica
comunicación
hilos
proceso
cambio
contexto
hilos
proceso
conlleva
trabajo
cambio
contexto
hilos
procesos
4.2
discusión
ULT
frente
KLT
desventaja
ULT
ejecutan
llamada
sistema
bloquea
hilo
hilos
proceso
sucede
4.3
OS/2
normalmente
abarca
concepto
proceso
sistemas
operati-
vos
divide
tipos
entidad
sesión
procesos
hilos
sesión
colec-
ción
hilos
asociados
interfaz
usuario
teclado
pantalla
ratón
sesión
representa
aplicación
usuario
interactiva
procesador
textos
hoja
cálculo
concepto
permite
usuario
abrir
aplica-
ción
ventanas
pantalla
sistema
operativo
sa-
ber
ventana
sesión
activa
forma
entradas
teclado
ratón
manden
sesión
apropiada
momento
sesión
plano
resto
sesiones
plano
entradas
teclado
ratón
redirigen
procesos
sesión
plano
indi-
aplicación
sesión
plano
proceso
realiza
salida
gráfica
manda
señal
directamente
buffer
hardware
gráfico
pan-
talla
pasa
sesión
plano
almacena
buffer
hardware
grá-
fico
buffer
lógico
vídeo
sesión
sesión
segun-
do
plano
cualquiera
hilos
cualquiera
procesos
sesión
ejecuta
produce
salida
pantalla
salida
redirige
buffer
lógico
vídeo
Cuan-
do
sesión
vuelve
plano
actualiza
pantalla
reflejar
contenido
buffer
lógico
vídeo
forma
reducir
número
conceptos
relacionados
procesos
OS/2
eliminar
sesiones
asociar
interfaz
usuario
teclado
pantalla
ra-
198
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
198tón
procesos
forma
proceso
plano
estruc-
turación
procesos
formados
hilos
beneficios
pierden
enfoque
utiliza
modificaciones
asigna
recursos
memoria
archivos
etc.
ni-
vel
proceso
hilo
4.4
Considérese
entorno
asociación
hilos
nivel
usuario
hilos
nivel
núcleo
permite
hilos
proceso
ejecutar
lla-
madas
sistema
bloqueantes
hilos
continúan
ejecutando
Explique
modelo
ejecuten
rápido
programas
multihilo
corres-
pondientes
versiones
monohilo
máquina
monoprocesador
4.5
proceso
termina
ejecutando
hilos
proceso
continuarán
eje-
cutando
4.6
sistema
operativo
OS/390
mainframe
estructura
conceptos
espacio
direcciones
tarea
Hablando
forma
aproximada
espacio
direcciones
único
corresponde
única
aplicación
corresponde
proceso
sis-
temas
operativos
espacio
direcciones
tareas
generar
ejecutar
forma
concurrente
corresponde
concepto
multihilo
estructuras
datos
claves
gestionar
estructura
tareas
bloque
control
espacio
direcciones
ASCB
contiene
información
espacio
di-
recciones
requerido
OS/390
esté
ejecutando
espacio
direcciones
información
ASBC
incluye
prioridad
planificación
memoria
real
virtual
asignada
espacio
direcciones
número
tareas
listas
espacio
direc-
ciones
zona
intercambio
bloque
control
tare-
as
TCB
representa
programa
usuario
ejecución
Contiene
información
necesa-
ria
gestionar
tarea
espacio
direcciones
incluye
información
procesador
punteros
programas
tarea
eje-
cución
tarea
ASCB
estructuras
globales
mantenidas
memoria
siste-
ma
TCB
estructuras
locales
mantienen
espacio
direc-
ciones
ventaja
dividir
información
control
porciones
globales
locales
4.7
multiprocesador
procesadores
20
unidades
cinta
nú-
mero
trabajos
enviados
sistema
requiere
máximo
cua-
tro
cintas
completar
ejecución
Suponga
trabajo
comienza
ejecutando
unidades
cinta
tiempo
requerir
cuarta
cinta
periodo
cerca
finalización
Suponga
número
infinito
trabajos
Suponga
planificador
sistema
operativo
comenzará
trabajo
cintas
disponibles
comienza
trabajo
asignan
cin-
tas
forma
inmediata
liberan
trabajo
finaliza
número
máximo
trabajos
progreso
determinado
momento
número
máximo
mínimo
unidades
cinta
paradas
re-
sultado
política
Sugiera
política
alternativa
mejorar
utilización
unidades
cinta
tiempo
evitar
interbloqueo
sistema
número
máximo
tra-
bajos
progreso
determinado
momento
lími-
tes
número
unidades
cinta
paradas
Hilos
SMP
micronúcleos
199
04-Capitulo
12/5/05
16:20
Página
1994.8
descripción
ULT
Solaris
ULT
ceder
paso
ULT
prioridad
hubiera
hilo
ejecutable
prioridad
función
cesión
diera
resultado
cesión
hilo
prioridad
200
Sistemas
operativos
Aspectos
internos
principios
diseño
04-Capitulo
12/5/05
16:20
Página
200CAPÍTULO
Concurrencia
Exclusión
mutua
sincronización
5.1
Principios
concurrencia
5.2
Exclusión
mutua
soporte
hardware
5.3
Semáforos
5.4
Monitores
5.5
Paso
mensajes
5.6
problema
Lectores
Escritores
5.7
Resumen
5.8
Lecturas
recomendadas
5.9
érminos
clave
cuestiones
repaso
problemas
05-Capitulo
12/5/05
16:21
Página
201Los
temas
centrales
diseño
sistemas
operativos
relacionados
gestión
procesos
hilos
Multiprogramación
Gestión
múltiples
procesos
sistema
monoprocesador
Multiprocesamiento
Gestión
múltiples
procesos
multiprocesador
Procesamiento
distribuido
Gestión
múltiples
procesos
ejecutan
múltiples
siste-
cómputo
distribuidos
concurrencia
fundamental
áreas
diseño
sistema
operativo
con-
currencia
abarca
aspectos
comunicación
procesos
comparti-
ción
competencia
recursos
sincronización
actividades
múltiples
procesos
re-
serva
tiempo
procesador
procesos
Debemos
entender
asuntos
suceden
entorno
multiprocesamiento
procesamiento
distribuido
siste-
monoprocesador
multiprogramados
concurrencia
aparece
contextos
Múltiples
aplicaciones
multiprogramación
ideada
permitir
compartir
dinámica-
mente
tiempo
procesamiento
aplicaciones
activas
Aplicaciones
estructuradas
extensión
principios
diseño
modular
programación
estructurada
aplicaciones
programadas
eficazmente
conjunto
procesos
concurrentes
Estructura
sistema
operativo
ventajas
constructivas
aplicables
pro-
gramación
sistemas
sistemas
operativos
implementados
conjunto
procesos
hilos
Dada
importancia
tema
capítulos
libro
tratan
aspectos
relaciona-
concurrencia
capítulo
tratan
concurrencia
sistemas
multipro-
gramados
multiproceso
Capítulos
13
14
examinan
aspectos
concurrencia
rela-
ción
procesamiento
distribuido
resto
libro
cubre
número
temas
importantes
diseño
sistema
operativo
opinión
concurrencia
juega
papel
principal
frente
temas
capítulo
comienza
introducción
concepto
concurrencia
implicaciones
ejecución
múltiples
procesos
concurrentes
descubre
requisito
básico
conse-
guir
ofrecer
procesos
concurrentes
capacidad
imperar
exclusión
mutua
capacidad
impedir
proceso
acción
permitido
examinan
mecanismos
hardware
permitir
exclusión
mu-
tua
verán
soluciones
requieren
espera
activa
ofrecidas
sistema
operativo
impuestas
compilador
lenguaje
examinan
propues-
tas
semáforos
monitores
paso
mensajes
utilizan
problemas
clásicos
concurrencia
ilustrar
conceptos
comparar
pro-
puestas
presentadas
capítulo
problema
productor
consumidor
introduce
uti-
lizarse
ejemplo
capítulo
cierra
problema
lectores
escritores
202
Sistemas
operativos
Aspectos
internos
principios
diseño
simplicidad
generalmente
referiremos
ejecución
concurrente
procesos
visto
capí-
tulo
sistemas
unidad
fundamental
concurrencia
hilo
proceso
05-Capitulo
12/5/05
16:21
Página
202
abla
5.1
términos
clave
relacionados
concurrencia
sección
crítica
Sección
código
proceso
requiere
acceso
recursos
critical
section
compartidos
ejecutada
proceso
esté
sección
código
correspondiente
interbloqueo
Situación
procesos
incapaces
actuar
deadlock
esperando
haga
círculo
vicioso
Situación
procesos
cambian
continuamente
livelock
respuesta
cambios
procesos
trabajo
útil
exclusión
mutua
Requisito
proceso
esté
sección
crítica
acce-
mutual
exclusion
recursos
compartidos
proceso
sec-
ción
crítica
acceda
recursos
compartidos
condición
carrera
Situación
múltiples
hilos
procesos
leen
escriben
dato
race
condition
compartido
resultado
depende
coordinación
relativa
ejecuciones
inanición
Situación
proceso
preparado
avanzar
soslayado
inde-
starvation
finidamente
planificador
capaz
avanzar
escoge
exposición
concurrencia
continúa
Capítulo
discusión
mecanismos
concurrencia
sistemas
ejemplo
pospone
capítulo
Tabla
5.1
muestra
términos
clave
relacionados
concurrencia
5.1
PRINCIPIOS
CONCURRENCIA
sistema
multiprogramado
procesador
único
procesos
entrelazan
tiempo
ofrecer
apariencia
ejecución
simultánea
Figura
2.12a
procesamiento
paralelo
real
cambiando
proceso
supone
sobrecarga
ejecución
entrelazada
proporciona
importantes
beneficios
eficiencia
procesamiento
estructuración
programas
sistema
múltiples
procesadores
entrelazar
ejecución
múltiples
procesos
solaparlas
Figura
2.12b
instancia
parecer
entrelazado
solapamiento
representan
modos
ejecución
fundamentalmente
presentan
problemas
ambas
téc-
nicas
verse
ejemplos
procesamiento
concurrente
ambas
presentan
problemas
caso
monoprocesador
problemas
surgen
característica
básica
sistemas
multiprogramados
predecirse
velocidad
relativa
ejecución
proce-
sos
depende
actividad
procesos
forma
sistema
operativo
ma-
neja
interrupciones
políticas
planificación
sistema
operativo
plantean
si-
guientes
dificultades
compartición
recursos
globales
cargada
peligros
ejemplo
procesos
utilizan
variable
global
realizan
lecturas
escrituras
varia-
ble
orden
ejecuten
lecturas
escrituras
crítico
subsección
muestra
ejemplo
problema
sistema
operativo
complicado
gestionar
asignación
recursos
ópti-
ma
ejemplo
proceso
solicitar
canal
concreto
serle
con-
cedido
control
suspendido
justo
utilizar
canal
desea-
Concurrencia
Exclusión
mutua
sincronización
203
05-Capitulo
12/5/05
16:21
Página
203ble
sistema
operativo
simplemente
bloquee
canal
impida
utilización
procesos
conducir
condición
interbloqueo
descri-
be
Capítulo
Llega
complicado
localizar
errores
programación
resultados
típi-
camente
deterministas
reproducibles
ejemplo
véase
LEBL87
CARR89
SHEN02
discusiones
asunto
dificultades
precedentes
presentan
sistema
multiprocesador
predecible
velocidad
relativa
ejecución
procesos
sistema
multipro-
cesador
bregar
problemas
derivados
ejecución
simultánea
múltiples
proce-
sos
fundamentalmente
problemas
sistema
mo-
noprocesador
quedará
medida
exposición
avance
EJEMPLO
SENCILLO
Considere
procedimiento
void
eco
cent
getchar
csal
cent
putchar(csal
procedimiento
muestra
elementos
esenciales
programa
proporcionará
pro-
cedimiento
eco
carácter
entrada
obtiene
teclado
tecla
carácter
introducido
almacena
variable
cent
transfiere
variable
csal
envía
pantalla
programa
llamar
repetidamente
procedimiento
aceptar
entra-
usuario
mostrarla
pantalla
Considere
sistema
multiprogramado
único
procesador
úni-
co
usuario
usuario
saltar
aplicación
aplicación
utiliza
tecla-
do
entrada
pantalla
salida
aplicación
necesita
proce-
dimiento
eco
sentido
procedimiento
compartido
esté
cargado
porción
memoria
global
aplicaciones
utiliza
única
copia
procedimiento
eco
economizándose
espacio
compartición
memoria
principal
procesos
útil
permitir
interacción
efi-
ciente
próxima
procesos
obstante
interacción
acarrear
problemas
Consi-
dere
secuencia
proceso
P1
invoca
procedimiento
eco
interrumpido
inmediatamente
getchar
devuelva
valor
almacenado
cent
punto
carácter
introducido
recientemente
almacenado
cent
proceso
P2
activa
invoca
procedimiento
eco
ejecuta
concluir
habiendo
leído
mostrado
pantalla
único
carácter
y.
retoma
proceso
P1
instante
valor
sobrescrito
centy
perdido
lugar
centcontiene
transferido
csaly
mostrado
204
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
204Así
carácter
pierde
muestra
esencia
problema
variable
compartida
global
cent
Múltiples
procesos
acceso
variable
pro-
ceso
actualiza
variable
global
justo
interrumpido
proceso
alterar
varia-
ble
proceso
utilizar
valor
Suponga
decidimos
proceso
tiempo
procedimiento
secuencia
resultaría
proceso
P1
invoca
procedimiento
eco
interrumpido
inmediatamente
concluya
función
entrada
punto
carácter
introducido
recientemente
almacenado
cent
proceso
P2
activa
invoca
procedimiento
eco
P1
toda-
vía
procedimiento
eco
actualmente
suspendido
P2
impide
entrar
procedimiento
P2
suspende
esperando
disponibilidad
procedimiento
eco
momento
posterior
proceso
P1
retoma
completa
ejecución
eco
muestra
carácter
correcto
x.
P1
sale
eco
elimina
bloqueo
P2
P2
retomado
invocará
satisfactoriamente
procedimiento
eco
lección
aprender
ejemplo
necesario
proteger
variables
globales
compar-
tidas
recursos
globales
compartidos
única
controlar
código
accede
variable
imponemos
disciplina
proceso
tiempo
entrar
eco
eco
procedimiento
ejecutar
completarse
disponible
proceso
tipo
error
acaba
describir
ocurrirá
imponer
disciplina
temas
capitales
capítulo
problema
enunciado
suposición
trataba
sistema
operativo
multi-
programado
monoprocesador
ejemplo
demuestra
problemas
concurrencia
su-
ceden
único
procesador
sistema
multiprocesador
aparecen
problemas
recursos
compartidos
protegidos
funcionan
soluciones
supón-
gase
mecanismo
controlar
accesos
variable
global
compartida
procesos
P1
P2
ejecutando
procesador
distinto
procesos
invocan
procedimiento
eco
Ocurren
siguientes
eventos
eventos
línea
suceden
paralelo
Proceso
P1
Proceso
P2
cent
getchar
cent
getchar
csal
cent
csal
cent
putchar(csal
putchar(csal
resultado
carácter
introducido
P1
pierde
mostrado
carácter
introducido
P2
mostrado
P1
P2
añádase
capacidad
cumplir
Concurrencia
Exclusión
mutua
sincronización
205
05-Capitulo
12/5/05
16:21
Página
205disciplina
proceso
tiempo
eco
sucede
secuencia
procesos
P1
P2
ejecutando
procesador
distinto
procesos
invocan
procedimiento
eco
P1
procedimiento
eco
P2
invoca
eco
P1
procedimiento
eco
esté
P1
suspendido
ejecutando
P2
bloqueará
entrada
procedimiento
P2
suspende
espera
disponibilidad
procedi-
miento
eco
momento
posterior
proceso
P1
completa
ejecución
eco
sale
procedi-
miento
continúa
ejecutando
Inmediatamente
P1
salga
eco
retoma
P2
comienza
ejecución
eco
caso
sistema
monoprocesador
motivo
problema
interrupción
parar
ejecución
instrucciones
punto
proceso
caso
sistema
multiprocesador
motivo
suceder
proce-
sos
ejecutando
simultáneamente
intentando
acceder
variable
global
solución
tipos
problema
controlar
accesos
recursos
compartidos
CONDICIÓN
CARRERA
condición
carrera
sucede
múltiples
procesos
hilos
leen
escriben
datos
resultado
depende
orden
ejecución
instrucciones
múltiples
procesos
Consideremos
casos
sencillos
ejemplo
suponga
procesos
P1
P2
comparten
variable
global
a.
punto
ejecución
P1
actualiza
valor
punto
ejecución
P2
actualiza
valor
tareas
compiten
carrera
escribir
variable
a.
ejemplo
perdedor
carrera
proceso
actualiza
determina
va-
lor
a.
ejemplo
considere
procesos
P3
P4
comparten
variables
glo-
bales
by
valores
iniciales
b=
c=
punto
ejecución
P3
ejecuta
asigna-
ción
punto
ejecución
P4
ejecuta
asignación
c.
Note
procesos
actualizan
variables
valores
finales
variables
dependen
orden
procesos
ejecuten
asignaciones
P3
ejecuta
senten-
cia
asignación
valores
finales
b=
c=
P4
ejecuta
sentencia
asignación
valores
finales
b=
c=
Apéndice
condiciones
carrera
utilizando
semáforos
ejemplo
PREOCUPACIONES
SISTEMA
OPERATIVO
aspectos
diseño
gestión
surgen
existencia
concurrencia
enumerarse
siguientes
necesidades
sistema
operativo
capaz
seguir
pista
procesos
bloques
control
proceso
descrito
Capítulo
206
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
2062
sistema
operativo
ubicar
desubicar
recursos
proceso
activo
recursos
incluyen
Tiempo
procesador
misión
planificación
tratada
Memoria
mayoría
sistemas
operativos
esquema
memoria
virtual
tema
abordado
Ficheros
Tratados
Capítulo
12
Dispositivos
S.
Tratados
Capítulo
11
sistema
operativo
proteger
datos
recursos
físicos
proceso
frente
inter-
ferencias
involuntarias
procesos
involucra
técnicas
relacionan
memoria
fi-
cheros
dispositivos
S.
Capítulo
15
tratado
general
tema
protección
funcionamiento
proceso
resultado
produzca
independiente
ve-
locidad
suceda
ejecución
relación
velocidad
procesos
concurren-
tes
tema
capítulo
entender
abordarse
cuestión
independencia
velocidad
necesita-
mos
formas
procesos
interaccionar
INTERACCIÓN
PROCESOS
clasificar
formas
procesos
interaccionan
base
grado
perciben
existencia
Tabla
5.2
enumera
posibles
grados
percepción
consecuencias
Procesos
perciben
procesos
independientes
pretende
trabajen
juntos
ejemplo
situación
multiprogramación
múltiples
pro-
cesos
independientes
trabajos
lotes
sesiones
interactivas
mezcla
procesos
estén
trabajando
juntos
sistema
operativo
necesita
pre-
ocuparse
competencia
recursos
ejemplo
aplicaciones
independientes
pue-
den
querer
ambas
acceder
disco
fichero
impresora
sistema
operativo
re-
gular
accesos
Procesos
perciben
indirectamente
procesos
necesariamen-
presencia
respectivos
ID
proceso
com-
parten
accesos
objeto
buffer
S.
Tales
procesos
exhiben
cooperación
compartición
objeto
común
Procesos
perciben
directamente
procesos
capaces
comunicarse
vía
ID
proceso
diseñados
trabajar
conjuntamente
actividad
tales
procesos
exhiben
cooperación
condiciones
claras
sugiere
Tabla
5.2
algu-
procesos
exhibir
aspectos
competición
cooperación
obstante
constructivo
examinar
casos
lista
precedente
determinar
implicacio-
nes
sistema
operativo
Concurrencia
Exclusión
mutua
sincronización
207
05-Capitulo
12/5/05
16:21
Página
207
abla
5.2
Interacción
procesos
Influencia
Potenciales
Grado
percepción
Relación
proceso
problemas
control
Procesos
Competencia
resultados
Exclusión
mutua
perciben
proceso
Interbloqueo
independientes
recurso
renovable
acción
Inanición
temporización
proceso
verse
afectada
Procesos
Cooperación
resultados
Exclusión
mutua
perciben
compartición
proceso
Interbloqueo
indirectamente
depender
recurso
renovable
información
obtenida
Inanición
ejemplo
Coherencia
datos
objeto
compartido
temporización
proceso
verse
afectada
Procesos
Cooperación
resultados
Interbloqueo
perciben
directamente
comunicación
proceso
recurso
consumible
depender
Inanición
primitivas
información
obtenida
comunicación
disposición
temporización
proceso
verse
afectada
Competencia
procesos
recursos
procesos
concurrentes
entran
conflicto
en-
tre
compiten
recurso
forma
pura
describirse
situa-
ción
procesos
necesitan
acceso
recurso
curso
ejecución
proceso
percata
existencia
procesos
verse
afectado
ejecución
procesos
conlleva
proceso
dejar
inalterado
recurso
utilice
Ejemplos
recursos
dispositivos
memoria
tiempo
procesador
reloj
intercambio
información
procesos
competencia
obstante
ejecución
proceso
afectar
comportamiento
procesos
competencia
concreto
procesos
desean
acceder
recurso
único
sistema
operativo
reservará
recurso
esperar
proceso
deniega
ac-
ceso
ralentizado
caso
extremo
proceso
bloqueado
recurso
terminar
satisfactoriamente
caso
procesos
competencia
afrontarse
problemas
control
necesidad
exclusión
mutua
Supóngase
procesos
requieren
acceso
recurso
único
compartible
impresora
curso
ejecución
proceso
enviando
mandatos
dispositivo
recibiendo
información
enviando
datos
reci-
biendo
datos
referiremos
recurso
recurso
crítico
porción
programa
utiliza
sección
crítica
programa
importante
permita
programa
tiempo
sección
crítica
simplemente
delegar
sistema
operativo
entienda
aplique
restricción
detalles
requisitos
obvios
caso
impresora
ejemplo
proceso
individual
control
208
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
208la
impresora
imprime
fichero
completo
líneas
procesos
competencia
intercalarían
aplicación
exclusión
mutua
crea
problemas
control
adicionales
in-
terbloqueo
ejemplo
considere
procesos
P1
P2
recursos
R1
R2
Suponga
proceso
necesita
acceder
recursos
función
encontrarse
situación
sistema
operativo
asigna
R1
P2
R2
P1
proceso
esperando
recursos
liberará
recurso
posee
conse-
guido
recurso
función
requiere
recursos
procesos
in-
terbloqueados
problema
control
inanición
Suponga
procesos
P1
P2
P3
requieren
accesos
periódicos
recurso
R.
Considere
situación
P1
posesión
recur-
so
P2
P3
retenidos
esperando
recurso
P1
termine
sección
crítica
debería
permitírsele
acceso
P2
P3
Asúmase
sistema
operativo
concede
acceso
P3
P1
solicita
acceso
completar
sección
crítica
sistema
operativo
conce-
acceso
P1
P3
terminado
posteriormente
concede
alternativamente
acceso
P1
P3
P2
denegársele
indefinidamente
acceso
recurso
suceda
interbloqueo
control
competencia
involucra
inevitablemente
sistema
operativo
ubi-
ca
recursos
procesos
necesitarán
capaces
expresar
requisito
exclusión
mutua
bloqueando
recurso
usarlo
solu-
ción
involucrará
apoyo
sistema
operativo
proporcionar
servicio
bloqueo
Figura
5.1
ilustra
mecanismo
exclusión
mutua
términos
abstractos
procesos
ejecutados
concurrentemente
proceso
incluye
sección
crítica
opera
re-
curso
Ra
código
adicional
precede
sucede
sección
crítica
involucra
acceso
Ra
procesos
acceden
recurso
Ra
desea
proceso
esté
sección
crítica
tiempo
aplicar
exclusión
mutua
proporcionan
funciones
en-
trarcriticay
salircritica
función
toma
argumento
nombre
recurso
su-
jeto
competencia
proceso
intente
entrar
sección
crítica
pro-
ceso
sección
crítica
recurso
esperar
Concurrencia
Exclusión
mutua
sincronización
209
Figura
5.1
Ilustración
exclusión
mutua
PROCESO
void
P1
while
true
código
entrarcritica
Ra
sección
crítica
salircritica
Ra
código
posterior
PROCESO
void
P2
while
true
código
entrarcritica
Ra
sección
crítica
salircritica
Ra
código
posterior
PROCESO
void
Pn
while
true
código
entrarcritica
Ra
sección
crítica
salircritica
Ra
código
posterior
05-Capitulo
12/5/05
16:21
Página
209Falta
examinar
mecanismos
específicos
proporcionar
funciones
entrarcritica
sa-
lircritica
momento
postergamos
asunto
consideramos
casos
interacción
procesos
Cooperación
procesos
vía
compartición
caso
cooperación
vía
compartición
cubre
procesos
interaccionan
procesos
conocimiento
explícito
ejemplo
múltiples
procesos
acceso
variables
compartidas
ficheros
bases
datos
compar-
tidas
procesos
actualizar
datos
compartidos
referenciar
procesos
procesos
acceso
datos
procesos
cooperar
asegurar
datos
comparten
manipulados
adecuadamente
mecanismos
control
asegurar
integridad
datos
compartidos
datos
contenidos
recursos
dispositivos
memoria
problemas
con-
trol
exclusión
mutua
interbloqueo
inanición
presentes
única
diferencia
datos
individuales
accedidos
maneras
lectura
escritura
operaciones
escritura
mutuamente
exclusivas
problemas
surge
requisito
coherencia
da-
tos
ejemplo
sencillo
considérese
aplicación
contabilidad
actuali-
zados
datos
individuales
Supóngase
datos
individuales
mantenidos
relación
b.
programa
actualice
valor
actualizar
mantener
relación
Considérense
siguientes
procesos
P1
P2
inicialmente
consistente
proceso
tomado
separado
dejará
datos
com-
partidos
consistente
considere
ejecución
concurrente
procesos
respetan
exclusión
mutua
dato
individual
ejecución
secuencia
condición
mantiene
ejemplo
comienza
ejecución
secuencia
tendremos
problema
evitado
declarando
proceso
secuencia
completa
sección
crítica
ve
concepto
sección
crítica
importante
caso
cooperación
compar-
tición
funciones
abstractas
entrarcritica
salircritica
tratadas
anteriormente
Figura
5.1
usarse
caso
argumento
funciones
variable
fichero
objeto
compartido
secciones
críticas
utilizan
conse-
210
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
210guir
integridad
datos
recurso
variable
concreta
identifi-
argumento
caso
pensarse
argumento
identificador
compar-
tido
procesos
concurrentes
identifica
secciones
críticas
mutuamente
exclusivas
Cooperación
procesos
vía
comunicación
casos
tratado
proceso
entorno
aislado
incluye
procesos
interacciones
procesos
indirectas
casos
compartición
caso
competencia
recursos
compartidos
conscientes
procesos
caso
compar-
tición
valores
proceso
explícitamente
consciente
procesos
consciente
necesidad
mantener
integridad
datos
procesos
cooperan
vía
comu-
nicación
cambio
diversos
procesos
involucrados
participan
esfuerzo
común
vin-
cula
comunicación
proporciona
sincronizar
coordinar
actividades
Típicamente
comunicación
fundamenta
mensajes
tipo
primitivas
envío
recepción
mensajes
proporcionadas
lenguaje
programación
núcleo
sistema
operativo
acto
pasar
mensajes
procesos
comparten
exclusión
mutua
requisito
control
tipo
cooperación
problemas
interbloqueo
inanición
presentes
ejemplo
interbloqueo
procesos
bloqueados
esperando
comunicación
ejemplo
inanición
considérense
procesos
P1
P2
P3
muestran
comportamiento
P1
intentando
repetidamente
comunicar
P2
P3
P2
P3
intentando
comunicar
P1
suceder
secuencia
P1
P2
intercambiasen
información
repetidamente
P3
blo-
queado
esperando
comunicación
P1
interbloqueo
P1
permanece
activo
P3
pasa
hambre
REQUISITOS
EXCLUSIÓN
MUTUA
mecanismo
técnica
proporcionar
exclusión
mutua
debería
cumplimentar
siguientes
requisitos
exclusión
mutua
hacerse
cumplir
permite
proceso
tiempo
sección
crítica
procesos
secciones
críticas
recurso
objeto
compartido
proceso
pare
sección
crítica
interferir
procesos
proceso
solicite
acceso
sección
crítica
postergado
in-
definidamente
interbloqueo
inanición
proceso
esté
sección
crítica
proceso
solicite
entrar
sección
crítica
permitírsele
entrar
demora
suposiciones
velocidades
relativas
procesos
número
procesadores
proceso
permanece
sección
crítica
tiempo
finito
maneras
satisfacer
requisitos
exclusión
mutua
delegar
responsabilidad
procesos
desean
ejecutar
concurrentemente
procesos
Concurrencia
Exclusión
mutua
sincronización
211
05-Capitulo
12/5/05
16:21
Página
211programas
sistema
programas
aplicación
estarían
obligados
coordinarse
cumplir
exclusión
mutua
apoyo
lenguaje
programación
sistema
operativo
Pode-
mos
referirnos
soluciones
software
enfoque
propenso
alta
sobre-
carga
procesamiento
errores
duda
útil
examinar
propuestas
obtener
me-
jor
comprensión
complejidad
programación
concurrente
tema
cubre
Apéndice
A.
enfoque
proporcionar
nivel
soporte
sistema
operati-
vo
lenguaje
programación
importantes
enfoques
examinan
Secciones
5.3
5.5
5.2
EXCLUSIÓN
MUTUA
SOPORTE
HARDWARE
desarrollado
número
algoritmos
software
exclusión
mutua
conocido
algoritmo
Dekker
solución
software
fácil
alta
so-
brecarga
procesamiento
significativo
riesgo
errores
lógicos
obstante
estudio
algoritmos
ilustra
conceptos
básicos
potenciales
problemas
desarro-
llo
programas
concurrentes
lector
interesado
Apéndice
incluye
análisis
so-
luciones
software
sección
consideran
interesantes
soluciones
hardware
exclu-
sión
mutua
DESHABILITAR
INTERRUPCIONES
máquina
monoprocesador
procesos
concurrentes
solaparse
entre-
lazarse
proceso
continuará
ejecutando
invoque
servicio
sistema
operati-
vo
interrumpido
garantizar
exclusión
mutua
basta
impedir
proceso
interrumpido
técnica
proporcionarse
forma
primitivas
definidas
núcleo
sistema
deshabilitar
habilitar
interrupciones
proceso
cumplir
ex-
clusión
mutua
compárese
Figura
5.1
while
true
deshabilitar
interrupciones
sección
crítica
habilitar
interrupciones
resto
sección
crítica
interrumpida
garantiza
exclusión
mutua
precio
solución
obstante
alto
eficiencia
ejecución
degradarse
notablemente
por-
limita
capacidad
procesador
entrelazar
programas
problema
solución
funcionará
arquitectura
multiprocesador
sistema
cómputo
inclu-
ye
procesador
típico
estén
ejecutando
tiempo
proceso
caso
deshabilitar
interrupciones
garantiza
exclusión
mutua
INSTRUCCIONES
MÁQUINA
ESPECIALES
configuración
multiprocesador
procesadores
comparten
acceso
memoria
princi-
pa
común
caso
relación
maestro
esclavo
cambio
procesadores
compor-
212
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
212tan
independientemente
relación
igualdad
mecanismo
interrupción
proce-
sadores
basarse
exclusión
mutua
nivel
hardware
acceso
posición
memoria
excluye
acceso
posición
fundamento
diseñadores
procesadores
propues-
to
instrucciones
máquina
llevan
cabo
acciones
atómicamente
leer
escribir
leer
comprobar
única
posición
memoria
único
ciclo
búsqueda
instruc-
ción
ejecución
instrucción
acceso
posición
memoria
bloquea
instrucción
referencie
posición
Típicamente
acciones
realizan
único
ciclo
instrucción
sección
consideran
instrucciones
implementadas
comúnmente
descritas
RAYN86
STON93
Instrucción
est
and
Set
instrucción
test
and
set
comprueba
establece
definirse
boolean
testset
int
if
return
true
else
return
false
instrucción
comprueba
valor
argumento
i.
valor
instrucción
re-
emplaza
valor
devuelve
caso
contrario
valor
cambia
devuelve
falso
función
testsetcompleta
realiza
atómicamente
sujeta
interrupción
Figura
5.2a
muestra
protocolo
exclusión
mutua
basado
instrucción
construcción
paralelos(P1
P2
Pn
significa
suspender
ejecución
programa
principal
iniciar
ejecución
concurrente
procedimientos
P1
P2
P1
P2
Pn
hayan
terminado
retomar
programa
principal
variable
compartida
cerrojose
ini-
cializa
único
proceso
entrar
sección
crítica
variable
cerrojo
procesos
intenten
entrar
sección
crítica
caen
espera
activa
término
espera
activa
busy
waiting
espera
cíclica
spin
waiting
re-
fiere
técnica
proceso
obtener
permiso
entrar
sección
crítica
continúa
ejecutando
instrucción
conjunto
instrucciones
comprue-
ban
variable
apropiada
entrar
proceso
abandona
sección
crítica
res-
tablece
cerrojo
punto
procesos
espera
concederá
ac-
Concurrencia
Exclusión
mutua
sincronización
213
término
atómico
significa
instrucción
realiza
único
paso
interrumpida
05-Capitulo
12/5/05
16:21
Página
213ceso
sección
crítica
elección
proceso
depende
procesos
ejecuta
instrucción
testset
Instrucción
Exchange
instrucción
exchange
intercambio
definirse
void
exchange
int
registro
int
memoria
int
temp
temp
memoria
memoria
registro
registro
temp
instrucción
intercambia
contenidos
registro
posición
memoria
arquitectura
Intel
IA-32
Pentium
IA-64
Itanium
contienen
instrucción
XCHG
Figura
5.2b
muestra
protocolo
exclusión
mutua
basado
instrucción
ex-
change
variable
compartida
cerrojo
inicializa
proceso
utiliza
variable
local
llavei
inicializa
único
proceso
entrar
sección
crítica
en-
214
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
exclusión
mutua
programa
exclusión
mutua
const
int
número
procesos
const
int
número
procesos
int
cerrojo
int
cerrojo
void
P(int
void
P(int
while
true
int
llavei
while
true
while
testset
cerrojo
do
exchange
llavei
cerrojo
sección
crítica
while
llavei
cerrojo
sección
crítica
resto
exchange
llavei
cerrojo
resto
void
main
void
main
cerrojo
paralelos
P(1
P(2
P(n
cerrojo
paralelos
P(1
P(2
P(n
Figura
5.2
Soporte
hardware
exclusión
mutua
Instrucción
test
and
set
Instrucción
exchange
05-Capitulo
12/5/05
16:21
Página
214cuentra
cerrojoigual
cambiar
cerrojoa
excluye
procesos
sec-
ción
crítica
proceso
abandona
sección
crítica
restaura
cerrojo
valor
permi-
tiéndose
proceso
gane
acceso
sección
crítica
Nótese
expresión
cumple
variables
ini-
cializadas
dada
naturaleza
algoritmo
exchange
cerrojo
proceso
sección
crítica
cerrojo
exactamente
proceso
sección
crítica
cuya
variable
llavei
Propiedades
solución
instrucción
máquina
instrucción
máquina
especial
exclusión
mutua
ventajas
aplicable
número
procesos
procesador
único
multiprocesador
memoria
principal
compartida
simple
fácil
verificar
utilizado
soporte
múltiples
secciones
críticas
sección
crítica
definida
variable
desventajas
serias
emplea
espera
activa
proceso
esperando
acceder
sección
crítica
continúa
consumiendo
tiempo
procesador
inanición
proceso
abandona
sección
crítica
pro-
ceso
esperando
selección
proceso
espera
arbitraria
proceso
denegársele
indefinidamente
acceso
interbloqueo
Considérese
escenario
sistema
procesa-
dor
único
proceso
P1
ejecuta
instrucción
especial
ejemplo
testset
exchange
entra
sección
crítica
P1
interrumpido
darle
procesador
P2
alta
prioridad
P2
intenta
utilizar
recurso
P1
denega-
rá
acceso
mecanismo
exclusión
mutua
caerá
bucle
espera
acti-
P1
escogido
ejecutar
menor
prioridad
proceso
listo
P2
Dados
inconvenientes
ambas
soluciones
software
hardware
acaban
esbozar
necesario
buscar
mecanismos
5.3
SEMÁFOROS
Pasamos
mecanismos
sistema
operativo
lenguaje
programación
utilizan
proporcionar
concurrencia
Comenzando
sección
semáforos
siguientes
secciones
tratarán
monitores
paso
mensajes
avance
fundamental
tratamiento
problemas
programación
concurrente
ocurre
1965
tratado
Dijkstra
DIJK65
Dijkstra
involucrado
diseño
sistema
operativo
colección
procesos
secuenciales
cooperantes
desarrollo
cerrojo
llave
Concurrencia
Exclusión
mutua
sincronización
215
05-Capitulo
12/5/05
16:21
Página
215mecanismos
eficientes
fiables
soporte
cooperación
mecanismos
usa-
fácilmente
procesos
usuario
procesador
sistema
operativo
colaborasen
ha-
cerlos
disponibles
principio
fundamental
procesos
cooperar
simples
se-
ñales
tales
proceso
obligado
parar
lugar
específico
recibido
señal
específica
requisito
complejo
coordinación
satisfecho
estruc-
tura
señales
apropiada
señalización
utilizan
variables
especiales
llamadas
semáfo-
ros
transmitir
señal
vía
semáforo
proceso
ejecutará
primitiva
semSignal(s
recibir
señal
vía
semáforo
proceso
ejecutará
primitiva
semWait(s
corres-
pondiente
señal
transmitido
proceso
suspenderá
transmisión
lugar
efecto
deseado
semáforo
visto
variable
contiene
valor
entero
definidas
operaciones
semáforo
inicializado
valor
negativo
operación
semWait
decrementa
valor
semáforo
valor
pasa
negativo
en-
tonces
proceso
ejecutando
semWait
bloquea
caso
proceso
continúa
ejecución
operación
semSignal
incrementa
valor
semáforo
valor
menor
cero
desbloquea
procesos
bloqueados
operación
semWait
Aparte
operaciones
inspeccionar
manipular
semáforo
Figura
5.3
sugiere
definición
formal
primitivas
semáforo
primitivas
semWait
semSignal
asumen
atómicas
versión
restringida
conocida
semáforo
binario
mutex
define
Figura
5.4
semáforo
binario
tomar
valores
definir
siguientes
operaciones
semáforo
binario
inicializado
operación
semWaitBcomprueba
valor
semáforo
valor
cero
pro-
ceso
ejecutando
semWaitBse
bloquea
valor
cambia
valor
cero
proceso
continúa
ejecución
operación
semSignalB
comprueba
proceso
bloqueado
semáforo
desbloquea
procesos
bloqueados
operación
semWaitB.
procesos
bloqueados
valor
semáforo
pone
principio
debería
fácil
implementar
semáforo
binario
demostrarse
tie-
ne
potencia
expresiva
semáforo
general
véase
Problema
5.9
contrastar
tipos
semáforos
semáforo
no-binario
referido
semáforo
contador
semáforo
general
semáforos
contador
semáforos
binarios
utiliza
cola
mantener
procesos
esperando
semáforo
Surge
cuestión
orden
procesos
216
Sistemas
operativos
Aspectos
internos
principios
diseño
artículo
original
Dijkstra
literatura
utiliza
letra
semWait
letra
semSignal
iniciales
palabras
holandesas
prueba
probaren
incremento
verhogen
literatura
utilizan
tér-
minos
wait
signal
libro
utiliza
semWait
semSignal
claridad
evitar
confusión
operaciones
similares
wait
signal
monitores
tratadas
posteriormente
05-Capitulo
12/5/05
16:21
Página
216Concurrencia
Exclusión
mutua
sincronización
217
struct
semaphore
int
queueType
cola
void
semWait(semaphore
s.cuenta
if
s.cuenta
proceso
s.cola
bloquear
proceso
void
semSignal(semaphore
s.cuenta++
if
s.cuenta
extraer
proceso
s.cola
proceso
lista
listos
Figura
5.3
definición
primitivas
semáforo
struct
binary_semaphore
enum
cero
valor
queueType
cola
void
semWaitB(binary_semaphore
if
s.valor
s.valor
else
proceso
s.cola
bloquear
proceso
void
semSignalB(binary_semaphore
if
esta_vacia(s.cola
s.valor
else
extraer
proceso
s.cola
proceso
lista
listos
Figura
5.4
definición
primitivas
semáforo
binario
05-Capitulo
12/5/05
16:21
Página
217extraídos
cola
política
favorable
FIFO
primero-en-entrar-primero-en-salir
pro-
ceso
lleve
tiempo
bloqueado
extraído
cola
semáforo
cuya
defi-
nición
incluye
política
denomina
semáforo
fuerte
semáforo
especifica
orden
procesos
extraídos
cola
semáforo
débil
Figura
5.5
basada
DENN84
ejemplo
operación
semáforo
fuerte
procesos
depen-
den
resultado
proceso
D.
Inicialmente
ejecutando
listos
contador
semáforo
indicando
resultados
disponible
rea-
liza
instrucción
semWaitsobre
semáforo
semáforo
decrementa
continuar
ejecutando
posteriormente
adjunta
lista
listos
ejecuta
finalmente
realiza
instrucción
semWaity
bloqueado
permitiendo
ejecute
completa
nue-
vo
resultado
realiza
instrucción
semSignal
permite
moverse
lista
listos
adjunta
lista
listos
comienza
ejecutar
bloquea
realiza
instruc-
ción
semWait
similar
ejecutan
bloquean
semáforo
permitiendo
re-
tomar
ejecución
resultado
realiza
semSignal
transfiere
lista
listos
Posteriores
ciclos
liberarán
Bloqueado
algoritmo
exclusión
mutua
tratado
subsección
ilustrado
Figura
5.6
semáforos
fuertes
garantizan
libres
inanición
semáforos
débiles
asumirán
semáforos
fuertes
convenientes
forma
típica
se-
máforo
proporcionado
sistemas
operativos
EXCLUSIÓN
MUTUA
Figura
5.6
muestra
solución
directa
problema
exclusión
mutua
usando
semáforo
compárese
Figura
5.1
Considere
procesos
identificados
P(i
necesitan
to-
acceder
recurso
proceso
sección
crítica
accede
recurso
proceso
ejecuta
semWait(s
justo
entrar
sección
crítica
valor
spasa
negativo
proceso
bloquea
valor
decrementa
proceso
entra
sección
crítica
inmediatamente
positivo
proceso
capaz
en-
trar
sección
crítica
semáforo
inicializa
proceso
ejecute
semWaitserá
capaz
entrar
sección
crítica
inmediatamente
poniendo
valor
proceso
intente
entrar
sección
crítica
encontrará
ocupada
bloqueará
poniendo
valor
-1
Cual-
quier
número
procesos
intentar
entrar
forma
intento
insatisfactorio
conllevará
decremento
valor
s.
proceso
inicialmente
entró
sección
crítica
salga
sse
incrementa
procesos
bloqueados
extrae
lista
pro-
cesos
bloqueados
asociada
semáforo
pone
Listo
planificado
sistema
operativo
entrar
sección
crítica
Figura
5.7
basada
BACO03
muestra
secuencia
procesos
usando
disciplina
exclusión
mutua
Figura
5.6
ejemplo
procesos
ac-
ceden
recurso
compartido
protegido
semáforo
s.
proceso
ejecuta
semWait(s),y
semáforo
valor
momento
operación
semWait
entrar
inme-
diatamente
sección
crítica
semáforo
toma
valor
sección
crítica
realizan
operación
semWait
bloqueados
pendientes
disponibilidad
semáforo
salga
sección
crítica
realice
semSignal(s),B
proce-
so
cola
entrar
sección
crítica
programa
Figura
5.6
servir
igualmente
requisito
permita
proceso
sección
crítica
requisito
cumple
simplemente
inicializando
semáforo
valor
especificado
momento
valor
s.cuenta
interpretado
218
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
218Concurrencia
Exclusión
mutua
sincronización
219
Procesador
SemáforoCola
bloqueados
Cola
listos
/H11005
/H11005
/H11005
/H110021
AB
/H11005
/H11005
/H11005
/H110023C
/H11005
/H110022
CA
Procesador
SemáforoCola
bloqueados
Cola
listos
Procesador
SemáforoCola
bloqueados
Cola
listos
Procesador
SemáforoCola
bloqueados
Cola
listos
Procesador
SemáforoCola
bloqueados
Cola
listos
Semáforo
Procesador
Cola
bloqueados
Cola
listos
Procesador
SemáforoCola
bloqueados
Cola
listos
Figura
5.5
Ejemplo
mecanismo
semáforo
05-Capitulo
12/5/05
16:21
Página
219220
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
exclusión
mutua
const
int
número
procesos
semafore
void
P(int
while
true
semWait(s
sección
crítica
semSignal(s
resto
void
main
paralelos
P(1
P(2
P(n
Figura
5.6
Exclusión
mutua
usando
semáforos
/H110021
/H110021
/H110022
semWait(s
Valor
semáfor
Cola
semáforo
BC
semSignal(s
semSignal(s
semSignal(s
semWait(s
semWait(s
Región
crítica
Ejecución
normal
Bloqueado
semáforo
Nota
ejecución
normal
sucede
paralelo
regiones
críticas
serializan
Figura
5.7
Procesos
accediendo
datos
compartidos
protegidos
semáforo
05-Capitulo
12/5/05
16:21
Página
220•
s.cuenta
s.cuenta
número
procesos
ejecutar
semWait(s
sus-
pensión
ejecuta
semSignal(s
medias
situación
permitirá
semáfo-
ros
admitir
sincronización
exclusión
mutua
s.cuenta
magnitud
s.cuenta
número
procesos
suspendidos
s.cola
PROBLEMA
PRODUCTOR
CONSUMIDOR
Examinemos
problemas
comunes
afrontados
programación
concurrente
problema
productor
consumidor
enunciado
general
procesos
generando
al-
gún
tipo
datos
registros
caracteres
poniéndolos
buffer
único
consumidor
extrayendo
datos
buffer
sistema
obligado
impedir
superposi-
ción
operaciones
datos
agente
productor
consumidor
acce-
der
buffer
momento
Analizaremos
soluciones
problema
ilustrar
potencia
dificultades
semáforos
empezar
asúmase
buffer
infinito
consiste
vector
datos
términos
abs-
tractos
funciones
productory
consumidorse
definen
productor
consumidor
while
true
while
true
producir
dato
while
entra
sale
b[entra
entra++
b[sale
sale++
consumir
dato
Figura
5.8
ilustra
estructura
buffer
b.
productor
generar
datos
almacenarlos
vector
ritmo
incrementa
índice
entra
vector
consumi-
dor
procede
similar
asegurarse
intenta
leer
entrada
vacía
vector
consumidor
asegura
productor
avanzado
allá
entra
sale
seguir
Intentemos
implementar
sistema
utilizando
semáforos
binarios
Figura
5.9
intento
tratar
índices
entra
sale
simplemente
guardamos
constancia
número
Concurrencia
Exclusión
mutua
sincronización
221
b[1
b[2
sale
b[3
b[4
b[5
01234
entra
Nota
área
sombreada
indica
porción
buffer
ocupada
Figura
5.8
Buffer
infinito
problema
productor
consumidor
05-Capitulo
12/5/05
16:21
Página
221de
datos
buffer
usando
variable
entera
(=
entra
sale
semáforo
utiliza
cumplir
exclusión
mutua
semáforo
retardo
forzar
consumidor
esperar
semWait
buffer
vacío
222
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
productor
consumidor
int
binary_semaphore
binary_semaphore
retardo
void
productor
while
true
producir
semWaitB(s
anyadir
n++
if
n==1
semSignalB(retardo
semSignalB(s
void
consumidor
semWaitB(retardo
while
true
semWaitB(s
extraer
semSignalB(s
consumir
if
n==0
semWaitB(retardo
void
main
paralelos
productor
consumidor
Figura
5.9
solución
incorrecta
problema
productor
consumidor
buffer
infinito
usando
semáforos
binarios
05-Capitulo
12/5/05
16:21
Página
222Esta
solución
directa
productor
libre
añadir
buffer
momento
Realiza
semWaitB(s
añadir
semSignalB(s
haberlo
im-
pedir
consumidor
productor
acceda
buffer
operación
aña-
dir
dato
sección
crítica
productor
incrementa
valor
buffer
vacío
justo
añadido
productor
realiza
semSignalB(retardo
alertar
consumidor
consumidor
comienza
esperando
produzca
dato
usando
semWaitB(retardo
toma
dato
decrementa
sección
crítica
productor
capaz
permanecer
consu-
midor
situación
usual
consumidor
raramente
bloqueará
semáforo
re-
tardo
normalmente
positivo
productor
consumidor
avanzarán
problemas
defecto
programa
consumidor
agotado
datos
buffer
necesita
restablecer
semáforo
retardopara
obligarse
esperar
productor
introducido
datos
buffer
propósito
sentencia
if
semWaitB(re-
tardo
Considere
escenario
esbozado
Tabla
5.3
línea
14
consumidor
ejecuta
operación
semWaitB.El
consumidor
efectivamente
vaciado
buffer
puesto
línea
8)
productor
incrementado
consumidor
comprobar
valor
línea
14
resultado
semSignalB
casa
semWaitB
valor
-1
línea
20
significa
consumidor
consumido
buffer
dato
inexistente
cabe
simple-
mente
mover
sentencia
condicional
sección
crítica
consumidor
lugar
interbloqueo
ejemplo
línea
tabla
solución
problema
introducir
variable
auxiliar
establecerse
sección
crítica
consumidor
posterior
muestra
Figura
5.10
análi-
sis
cuidadoso
lógica
código
debería
convencer
interbloqueo
suceder
utilizan
semáforos
generales
denominados
semáforos
contador
obte-
nerse
solución
clara
muestra
Figura
5.11
variable
se-
máforo
valor
número
datos
buffer
Supóngase
transcrip-
ción
programa
comete
error
intercambian
operaciones
semSignal(s
semSignal(n
requeriría
operación
semSignal(n
realizase
sección
crítica
productor
interrupción
consumidor
productor
Afectaría
pro-
grama
consumidor
caso
esperar
semáforos
seguir
Supóngase
operaciones
semWait(n
semWait(s
intercambian
accidental-
mente
produce
serio
error
fatal
consumidor
entrase
sección
crítica
buffer
vacío
n.cuenta
productor
añadir
buffer
sistema
interbloqueado
ejemplo
sutileza
semáforos
dificultad
producir
diseños
correctos
Finalmente
añadamos
restricción
realista
problema
productor
consumidor
buffer
finito
buffer
buffer
circular
Figura
5.12
valo-
res
indexan
expresados
módulo
tamaño
buffer
mantiene
relación
Bloquearse
Desbloquear
Productor
insertar
buffer
lleno
Consumidor
dato
insertado
Consumidor
extraer
buffer
vacío
Productor
dato
extraído
Concurrencia
Exclusión
mutua
sincronización
223
05-Capitulo
12/5/05
16:21
Página
223Las
funciones
productor
consumidor
expresarse
variables
entra
sale
inicializadas
productor
consumidor
while
true
while
true
producir
dato
while
entra
sale
while
entra
sale
b[sale
b[entra
sale
sale
entra
entra
consumir
dato
224
Sistemas
operativos
Aspectos
internos
principios
diseño
Productor
Consumidor
Retardo
100
semWaitB(s
010
011
semSignalB(s
semWaitB(retardo
semWaitB(s
000
semSignalB(s
10
semWaitB(s
11
010
12
011
13
semSignalB(s
14
if
n==0
semWaitB(retardo
15
semWaitB(s
16
001
17
semSignalB(s
18
if
n==0
semWaitB(retardo
19
semWaitB(s
20
-1
21
semSignalB(s
-1
abla
5.3
Escenario
Programa
Figura
5.9
áreas
blanco
representan
sección
crítica
controlada
semáforos
n++
if
n==1
semSignalB(retardo
n++
n--
n--
n--
if
n==1
semSignalB(retardo
05-Capitulo
12/5/05
16:21
Página
224Concurrencia
Exclusión
mutua
sincronización
225
programa
productor
consumidor
int
binary_semaphore
binary_semaphore
retardo
void
productor
while
true
producir
semWaitB(s
anyadir
n++
if
n==1
semSignalB(retardo
semSignalB(s
void
consumidor
int
variable
local
semWaitB(retardo
while
true
semWaitB(s
extraer
semSignalB(s
consumir
if
m==0
semWaitB(retardo
void
main
paralelos
productor
consumidor
Figura
5.10
solución
correcta
problema
productor
consumidor
buffer
infinito
usando
semáforos
binarios
05-Capitulo
12/5/05
16:21
Página
225La
Figura
5.13
muestra
solución
usando
semáforos
generales
semáforo
añadido
número
espacios
vacíos
instructivo
ejemplo
semáforos
problema
barbería
descrito
Apéndice
A.
Apéndice
incluye
ejemplos
adicionales
problema
condiciones
carrera
semáforos
IMPLEMENTACIÓN
SEMÁFOROS
anteriormente
imperativo
funciones
semWait
semSignal
implementadas
primitivas
atómicas
obvia
implementarlas
hardware
firmware
falta
propuesto
variedad
esquemas
esencia
problema
226
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
productor
consumidor
semaphore
semaphore
void
productor
while
true
producir
semWait(s
anyadir
semSignal(s
semSignal(n
void
consumidor
while
true
semWait(n
semWait(s
extraer
semSignal(s
consumir
void
main
paralelos
productor
consumidor
Figura
5.11
solución
problema
productor
consumidor
buffer
infinito
usando
semáforos
05-Capitulo
12/5/05
16:21
Página
226Concurrencia
Exclusión
mutua
sincronización
227
b[1
b[2
sale
b[3
b[4
b[5
b[n
entra
b[1
b[2
b[3
b[4
b[5
b[n
entra
sale
Figura
5.12
Buffer
finito
circular
problema
productor
consumidor
programa
productor
consumidor
semaphore
semaphore
semaphore
tamaño
buffer
void
productor
while
true
producir
semWait(e
semWait(s
anyadir
semSignal(s
semSignal(n
void
consumidor
while
true
semWait(n
semWait(s
extraer
semSignal(s
semSignal(e
consumir
void
main
paralelos
productor
consumidor
Figura
5.13
solución
problema
productor
consumidor
buffer
acotado
usando
semáforos
05-Capitulo
12/5/05
16:21
Página
227de
exclusión
mutua
proceso
tiempo
manipular
semáforo
ope-
ración
semWait
semSignal
cualquiera
esquemas
software
tales
algoritmo
Dekker
Peterson
Apéndice
usarse
supondría
substancial
sobrecarga
procesamiento
alternativa
utilizar
esquemas
soportados
hardware
exclusión
mutua
ejemplo
Figura
5.14a
muestra
utili-
zación
instrucción
test
and
set
implementación
semáforo
nuevamente
estructura
Figura
5.3
incluye
componente
entero
s.ocupado
involucra
forma
espera
activa
operaciones
semWait
semSignal
relativamente
cortas
cantidad
espera
activa
implicada
debería
relevante
sistema
procesador
único
inhibir
interrupciones
operaciones
semWait
semSignal
sugiere
Figura
5.14b
relativamente
corta
duración
operaciones
significa
solución
razonable
228
Sistemas
operativos
Aspectos
internos
principios
diseño
semWait(s
semWait(s
while
testset(s.ocupado
inhibir
interrupciones
s.cuenta
s.cuenta
if
s.cuenta
if
s.cuenta
proceso
s.cola
proceso
s.cola
bloquear
proceso
bloquear
proceso
habilitar
interrupciones
s.ocupado
else
else
habilitar
interrupciones
s.ocupado
semSignal(s
semSignal(s
inhibir
interrupciones
while
testset(s.ocupado
s.cuenta++
if
s.cuenta
s.cuenta++
if
s.cuenta
extraer
proceso
s.cola
proceso
lista
listos
extraer
proceso
s.cola
proceso
lista
listos
habilitar
interrupciones
s.ocupado
Figura
5.14
posibles
implementaciones
semáforos
Instrucción
TTeessttsseett
Interrupciones
05-Capitulo
12/5/05
16:21
Página
2285.4
MONITORES
semáforos
proporcionan
herramienta
potente
flexible
exclusión
mutua
coordinación
procesos
Figura
5.9
sugiere
difícil
producir
programa
correcto
utilizando
semáforos
dificultad
operaciones
semWait
sem-
Signalpueden
dispersas
programa
resulta
fácil
efecto
global
operaciones
semáforos
afectan
monitor
construcción
lenguaje
programación
proporciona
funcionalidad
equivalente
semáforos
fácil
controlar
concepto
definió
formalmente
HOAR74
construcción
monitor
implementada
número
lenguajes
programación
incluyendo
Pascal
Concurrente
Pascal-Plus
Modula-2
Modula-3
Java
implementada
biblioteca
programa
permite
programadores
cerrojos
monitor
objeto
concreto
lista
encadenada
pue-
quererse
único
cerrojo
listas
lista
elemento
lista
Comencemos
viendo
versión
Hoare
examinar
refinada
MONITOR
SEÑAL
monitor
módulo
software
consistente
procedimientos
secuencia
inicia-
lización
datos
locales
principales
características
monitor
siguientes
variables
locales
datos
accesibles
procedimientos
monitor
procedimiento
externo
proceso
entra
monitor
invocando
procedimientos
proceso
ejecutando
monitor
tiempo
proceso
invocado
monitor
bloquea
espera
monitor
quede
disponible
primeras
características
guardan
semejanza
objetos
software
orienta-
do
objetos
sistema
operativo
lenguaje
programación
orientado
objetos
pue-
implementarse
inmediatamente
monitor
objeto
características
especiales
cumplir
disciplina
proceso
tiempo
monitor
capaz
proporcionar
exclusión
mutua
fácilmente
variables
datos
monitor
accedidas
proceso
estructura
datos
compartida
protegida
colocándola
monitor
datos
monitor
representan
recurso
monitor
proporciona
función
exclusión
mutua
acceso
recurso
útil
programación
concurrente
monitor
incluir
herramientas
sincroni-
zación
ejemplo
suponga
proceso
invoca
monitor
deba
bloque-
arse
satisfaga
condición
precisa
funcionalidad
proceso
bloquee
libere
monitor
proceso
entrar
condición
satisfecho
monitor
esté
disponible
nuevamente
proceso
retomado
permitida
entrada
monitor
punto
suspendió
monitor
soporta
sincronización
variables
condición
conteni-
das
monitor
accesibles
monitor
variables
condición
tipo
datos
especial
monitores
manipula
funciones
cwait(c):Suspende
ejecución
proceso
llamante
condición
c.
monitor
queda
disponible
usado
proceso
Concurrencia
Exclusión
mutua
sincronización
229
05-Capitulo
12/5/05
16:21
Página
229•
csignal(c):Retoma
ejecución
proceso
bloqueado
cwait
condición
procesos
elige
Nótese
operaciones
wait
signal
monitores
semáforos
proceso
monitor
señala
proceso
esperando
variable
condición
señal
pierde
Figura
5.15
ilustra
estructura
monitor
proceso
entrar
monitor
invocando
cualquiera
procedimientos
entenderse
monitor
único
punto
entrada
protegido
proceso
monitor
procesos
intenten
entrar
monitor
unirán
cola
procesos
bloqueados
esperando
disponibilidad
monitor
proceso
monitor
temporalmente
blo-
quearse
condición
realizando
cwait(x);en
caso
proceso
añadido
cola
procesos
esperando
reentrar
monitor
cambie
condición
retomar
eje-
cución
punto
programa
llamada
cwait(x
230
Sistemas
operativos
Aspectos
internos
principios
diseño
Entrada
Cola
entrada
procesos
Salida
Condición
c1
cwait(c1
Cola
urgente
csignal
Condición
cn
cwait(cn
Datos
locales
Variables
condición
Procedimiento
Procedimiento
Código
inicialización
Área
espera
monitor
MONITOR
Figura
5.15
Estructura
monitor
05-Capitulo
12/5/05
16:21
Página
230Si
proceso
ejecutando
monitor
detecta
cambio
variable
condición
realiza
csignal(x),que
avisa
cambio
correspondiente
cola
condición
ejemplo
monitor
retornemos
problema
productor
consumidor
buf-
fer
acotado
Figura
5.16
muestra
solución
utilizando
monitores
módulo
monitor
buffer-
acotado
controla
buffer
utilizado
almacenar
extraer
caracteres
monitor
incluye
va-
riables
condición
declaradas
construcción
cond
nolleno
espacio
añadir
carácter
buffer
novacio
carácter
buffer
productor
añadir
caracteres
buffer
procedimiento
anyadir
den-
tro
monitor
productor
acceso
directo
buffer
procedimiento
comprueba
condición
nolleno
determinar
espacio
disponible
buffer
proceso
ejecu-
ta
monitor
bloquea
condición
proceso
productor
consumidor
entrar
monitor
buffer
esté
lleno
proceso
bloqueado
ex-
traído
cola
reactivado
retomará
labor
colocar
carácter
buffer
proceso
seña-
condición
novacio
descripción
similar
realizarse
función
consumidor
ejemplo
marca
división
responsabilidad
monitores
comparación
se-
máforos
caso
monitores
construcción
monitor
impone
exclusión
mutua
productor
consumidor
accedan
simultáneamente
buffer
programador
disponer
primitivas
cwaity
csignalapropiadas
código
monitor
impedir
depositen
datos
buffer
lleno
extraigan
vacío
caso
semáforos
exclusión
mutua
sincronización
respon-
sabilidad
programador
Nótese
Figura
5.16
proceso
sale
monitor
inmediatamente
ejecutar
función
csignal
csignal
sucede
procedimiento
propuesta
Hoare
proceso
emite
señal
bloquea
monitor
pase
disponible
sitúa
cola
monitor
liberado
punto
posibilidad
colocar
proceso
bloqueado
cola
entrada
tendría
competir
acceso
procesos
entrado
monitor
obstante
proceso
bloqueado
fun-
ción
csignalha
parcialmente
tarea
monitor
sentido
preferencia
proceso
procesos
entraron
recientemente
disponiéndolo
cola
urgente
separada
Figura
5.15
lenguajes
utiliza
monitores
Pascal
Concurrente
exige
csignal
aparezca
operación
ejecutada
procedimiento
monitor
procesos
esperando
condición
ejecución
csignal(x
efecto
semáforos
cometer
errores
función
sincronización
moni-
tores
ejemplo
omite
funciones
csignalen
monitor
bufferacotado
en-
tonces
procesos
entren
cola
correspondiente
condición
estarán
permanentemente
colgados
ventaja
monitores
semáforos
funciones
sin-
cronización
confinadas
monitor
fácil
comprobar
sincronización
correctamente
detectar
errores
monitor
programado
correctamente
acceso
recurso
protegido
correcto
acceso
proceso
cambio
semáforos
acceso
recurso
correcto
procesos
acce-
den
recurso
programados
correctamente
MODELO
ALTERNATIVO
MONITORES
NOTIFICACIÓN
DIFUSIÓN
definición
monitor
Hoare
HOAR74
requiere
proceso
cola
condición
proceso
dicha
cola
ejecuta
inmediatamente
proceso
realice
Concurrencia
Exclusión
mutua
sincronización
231
05-Capitulo
12/5/05
16:21
Página
231232
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
productor
consumidor
monitor
bufferacotado
char
buffer[N
espacio
datos
int
punteros
buffer
int
número
datos
buffer
cond
nolleno
novacio
variables
condición
sincronizar
void
anyadir
char
if
cwait(nolleno
buffer
lleno
evitar
desbordar
buffer[dentro
cuenta++
dato
buffer
csignal(novacio
retoma
consumidor
espera
void
extraer
char
if
cwait(novacio
buffer
vacío
evitar
consumo
buffer[fuera
dato
buffer
csignal(nolleno
retoma
productor
espera
cuerpo
monitor
buffer
inicialmente
vacío
Figura
5.16
solución
problema
productor
consumidor
buffer
acotado
usando
monitor
void
productor
char
while
true
producir(x
anyadir(x
void
consumidor
char
while
true
extraer(x
consumir(x
void
main
paralelos
productor
consumidor
05-Capitulo
12/5/05
16:21
Página
232csignal
dicha
condición
proceso
realiza
csignal
salir
inmediata-
mente
monitor
bloquearse
monitor
desventajas
solución
proceso
realiza
csignal
terminado
monitor
necesitarán
cambios
proceso
adicionales
bloquear
proceso
retomarlo
monitor
quede
disponible
planificación
procesos
asociada
señal
perfectamente
fiable
realiza
csignal
proceso
cola
correspondiente
condición
activado
inmediatamente
planificador
asegurar
proceso
entra
monitor
activación
condición
proceso
activado
cambiar
ejemplo
Figura
5.16
realiza
csignal(novacio
activado
proceso
cola
novacio
consumidor
moni-
tor
ejemplo
proceso
productor
añadir
carácter
buffer
vacío
fallar
justo
señalización
procesos
cola
novacioestarían
permanentemen-
colgados
Lampson
Redell
desarrollaron
definición
monitor
lenguaje
Mesa
LAMP80
solución
resuelve
problemas
acaban
enunciar
aporta
extensio-
nes
útiles
estructura
monitor
Mesa
utiliza
lenguaje
programación
sistemas
Modula-3
NELS91
Mesa
primitiva
csignal
sustituye
cnotify
interpretación
proceso
ejecutando
monitor
ejecuta
cnotify(x
provoca
cola
condición
notificada
proceso
continúa
ejecutando
resul-
tado
notificación
proceso
cabeza
cola
condición
retomado
momento
futuro
conveniente
monitor
esté
disponible
garantía
proceso
monitor
proceso
notificado
proceso
notificado
deberá
volver
comprobar
condición
ejemplo
procedimientos
monitor
bufferaco-
tadotendrían
código
Figura
5.17
Concurrencia
Exclusión
mutua
sincronización
233
Figura
5.17
Monitor
buffer
acotado
monitor
Mesa
void
anyadir
char
while
cwait(nolleno
buffer
lleno
evitar
desbordar
buffer[dentro
cuenta++
dato
buffer
cnofify(novacio
notifica
consumidor
espera
void
extraer
char
while
cwait(novacio
buffer
vacío
evitar
consumo
buffer[fuera
dato
buffer
cnotify(nolleno
notifica
productor
espera
05-Capitulo
12/5/05
16:21
Página
233Las
sentencias
if
remplazan
bucles
while
convenio
requiere
evalua-
ción
extra
variable
condición
cambio
cambios
proceso
extra
tam-
restricciones
cnotify
ejecutar
proceso
notificado
mejora
útil
asociarse
primitiva
cnotify
temporizador
asociado
primitiva
condición
proceso
esperando
máximo
intervalo
tiem-
po
indicado
situado
Listo
independencia
condición
notificada
activado
proceso
comprobará
condición
continuará
condición
satisfizo
temporización
evita
inanición
indefinida
proceso
caso
proceso
falle
señalar
condición
norma
proceso
notifica
reactiva
fuerza
añadir
primitiva
cbroadcast
repertorio
difusión
broadcast
provoca
proce-
sos
esperando
condición
pasen
Listo
conveniente
situaciones
proceso
procesos
reactivados
ejemplo
programa
produc-
tor
consumidor
suponga
ambas
funciones
anyadir
extraer
puedan
aplicarse
bloques
caracteres
longitud
variable
caso
productor
añade
bloque
caracteres
buffer
necesita
caracteres
dispuesto
consumir
consumidor
espera
Simple-
mente
emite
cbroadcast
procesos
espera
avisados
intenten
suma
usarse
cbroadcastcuando
proceso
dificultad
mane-
ra
precisa
procesos
reactivar
ejemplo
gestor
memoria
gestor
bytes
libres
proceso
libera
bytes
adicionales
proceso
espera
seguir
bytes
utiliza
difusión
procesos
verifican
suficiente
memoria
libre
ventaja
monitores
Lampson
Redell
monitores
Hoare
solu-
ción
Lampson
Redell
propensa
error
solución
Lampson
Redell
usarse
construcción
while
procedimiento
comprueba
variable
condición
señalado
proceso
señalar
difundir
incorrectamente
causar
error
programa
señalado
programa
señalado
comprobará
variable
relevante
condición
cumple
volverá
esperar
ventaja
monitor
Lampson
Redell
presta
enfoque
modular
cons-
trucción
programas
ejemplo
considere
implementación
reserva
buffer
S.
niveles
condiciones
satisfechas
procesos
secuenciales
cooperantes
Estructuras
datos
concordantes
monitor
cumple
exclusión
mutua
completa
operación
entrada
salida
permitir
operación
buffer
Nivel
suficiente
memoria
proceso
completar
solicitud
reserva
monitor
Hoare
señal
transporta
condición
nivel
men-
saje
implícito
liberado
suficientes
bytes
llamada
solicitud
reserva
funcionar
señal
implícita
condición
nivel
programador
cambia
definición
condición
nivel
necesario
reprogramar
procesos
señalizan
programador
cambia
suposiciones
realizadas
proceso
espera
concreto
esperar
invariante
ligeramente
nivel
necesario
reprogramar
procesos
señalizan
modular
propenso
causar
errores
sincronización
ejemplo
despertar
error
modifica
código
programador
acordarse
modi-
ficar
procedimientos
monitor
realiza
pequeño
cambio
condi-
ción
nivel
monitor
Lampson
Redell
difusión
asegura
condición
nivel
insi-
núa
cumpla
nivel
proceso
comprobar
condición
nivel
234
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
234Sincronización
Formato
Send
Contenido
Bloqueante
Longitud
bloqueante
Fija
Receive
Variable
Bloqueante
bloqueante
Comprobación
llegada
Direccionamiento
Disciplina
cola
Directo
FIFO
Send
Prioridad
Receive
Explícito
Implícito
Indirecto
Estático
Dinámico
Propiedad
realiza
cambio
condición
nivel
espera
seña-
posibilidad
despertar
erróneo
procedimiento
verifica
condi-
ción
nivel
condición
nivel
quedar
oculta
procedimiento
monitor
Hoare
condición
nivel
trasladarse
código
proceso
es-
pera
código
procesos
señalizan
viola
abstracción
datos
principios
modularidad
interprocedural
5.5
PASO
MENSAJES
procesos
interaccionan
satisfacerse
requisitos
fundamentales
sincroni-
zación
comunicación
procesos
necesitan
sincronizados
exclusión
mutua
procesos
cooperantes
necesitar
intercambiar
información
enfoque
proporciona
ambas
funciones
paso
mensajes
paso
mensajes
ventaja
añadida
presta
implementado
sistemas
distribuidos
multiprocesadores
memoria
compartida
sistemas
monoprocesador
sistemas
paso
mensajes
presentan
modalidades
sección
presenta-
mos
introducción
general
características
típicas
encontradas
tales
sistemas
fun-
cionalidad
real
paso
mensajes
proporciona
normalmente
forma
par
primitivas
send(destino
mensaje
receive(origen
mensaje
conjunto
mínimo
operaciones
necesarias
procesos
puedan
entablar
paso
mensajes
proceso
envía
información
forma
mensaje
proceso
designado
destino
proceso
recibe
información
ejecutando
primitiva
receive
indicando
fuente
mensaje
Concurrencia
Exclusión
mutua
sincronización
235
abla
5.4
Características
diseño
sistemas
mensajes
comunicación
sincronización
interprocesador
05-Capitulo
12/5/05
16:21
Página
235En
Tabla
5.4
muestran
número
decisiones
diseño
relativas
sistemas
paso
mensaje
examinadas
resto
sección
SINCRONIZACIÓN
comunicación
mensaje
procesos
implica
nivel
sincronización
receptor
recibir
mensaje
enviado
proceso
suma
especificar
sucede
proceso
primitiva
sendo
receive
Considérese
primitiva
send
primitiva
send
ejecuta
proceso
posibilidades
proceso
envía
bloquea
mensaje
recibe
blo-
quea
proceso
realiza
primitiva
receive
posibilidades
mensaje
enviado
previamente
mensaje
recibido
ejecución
continúa
mensajes
esperando
proceso
bloquea
mensaje
llega
proceso
continúa
ejecutando
abandonando
intento
recepción
emisor
receptor
bloqueantes
bloqueantes
combinacio-
nes
típicas
sistema
concreto
normalmente
implementar
combinaciones
Envío
bloqueante
recepción
bloqueante
emisor
receptor
bloquean
mensaje
entrega
conoce
normalmente
rendezvous
Envío
bloqueante
recepción
bloqueante
emisor
continuar
receptor
bloqueará
mensaje
solicitado
llegue
probablemente
combinación
útil
Envío
bloqueante
recepción
bloqueante
partes
esperar
tareas
programación
concurrente
natural
send
bloqueante
ejemplo
utiliza
operación
salida
imprimir
permite
proceso
so-
licitante
emita
petición
forma
mensaje
continúe
peligro
potencial
sendno
bloqueante
error
provocar
situación
procesos
generan
mensajes
re-
petidamente
bloqueo
castigue
proceso
mensajes
consumir
recur-
sos
sistema
incluyendo
tiempo
procesador
espacio
almacenamiento
detrimento
procesos
sistema
operativo
envío
bloqueante
pone
programador
carga
determinar
mensaje
recibido
procesos
emplear
mensajes
respues-
ta
reconocer
recepción
mensaje
primitiva
receive
versión
bloqueante
natural
tareas
programación
concurrente
Generalmente
proceso
mensaje
necesita
esperar
información
continuar
obstante
mensaje
pierde
suceder
sis-
tema
distribuido
proceso
falla
enviar
mensaje
espera
proceso
receptor
quedar
bloqueado
indefinidamente
problema
resolverse
utilizando
receive
bloqueante
peligro
enfoque
mensaje
envía
proceso
correspondiente
receive
mensaje
perderse
posibles
solu-
ciones
permitir
proceso
receptor
compruebe
mensaje
espera
receivey
permitirle
proceso
especificar
origen
primitiva
receive
segun-
solución
útil
proceso
espera
mensajes
origen
continuar
llega
cualquiera
mensajes
236
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
236DIRECCIONAMIENTO
Claramente
necesario
especificar
primitiva
envío
procesos
recibir
mensaje
implementaciones
permiten
proceso
re-
ceptor
indicar
origen
mensaje
recibir
esquemas
especificar
procesos
primitivas
send
receive
caben
den-
tro
categorías
direccionamiento
directo
direccionamiento
indirecto
direccionamien-
to
directo
primitiva
send
incluye
identificador
específico
proceso
destinatario
primiti-
receive
manipulada
maneras
posibilidad
proceso
deba
designar
explícitamente
proceso
emisor
proceso
anticipación
proceso
es-
pera
mensaje
suele
eficaz
procesos
concurrentes
cooperantes
casos
imposible
especificar
anticipación
proceso
origen
ejemplo
proce-
so
servidor
impresión
deberá
aceptar
mensaje
solicitud
impresión
proceso
tales
aplicaciones
solución
efectiva
direccionamiento
implícito
caso
parámetro
origen
primitiva
receive
toma
valor
devuelto
operación
recepción
completa
esquema
general
direccionamiento
indirecto
caso
mensajes
enví-
an
directamente
emisor
receptor
enviados
estructura
datos
compar-
tida
consiste
colas
contener
mensajes
temporalmente
Tales
colas
conocen
ge-
neralmente
buzones
mailboxes
procesos
comuniquen
proceso
envía
mensaje
buzón
apropiado
proceso
toma
mensaje
buzón
virtud
direccionamiento
indirecto
desacoplando
emisor
receptor
per-
mite
flexibilidad
mensajes
relación
emisores
receptores
uno-a-uno
muchos-a-uno
uno-a-muchos
muchos-a-muchos
Figura
5.18
relación
uno-a-uno
permite
establecer
enlace
comunicaciones
privadas
procesos
aísla
interacción
interferencias
erróneas
procesos
relación
muchos-a-uno
útil
interacciones
cliente
servidor
proceso
proporciona
servicio
procesos
caso
buzón
conoce
normalmente
puerto
relación
uno-a-muchos
permite
emisor
múltiples
recep-
tores
útil
aplicaciones
mensaje
información
difundido
conjunto
procesos
relación
muchos-a-muchos
permite
múltiples
procesos
servidores
pro-
porcionar
servicio
concurrente
múltiples
clientes
asociación
procesos
buzones
estática
dinámica
Normalmente
puertos
asocian
estáticamente
proceso
particular
puerto
crea
asigna
proceso
permanentemente
normalmente
relación
uno-a-uno
define
estática
perma-
nentemente
emisores
asociación
emisor
buzón
ocurrir
diná-
micamente
propósito
utilizarse
primitivas
connecty
disconnect
aspecto
relacionado
propiedad
buzón
caso
puerto
típica-
mente
creado
propiedad
proceso
receptor
destruye
proceso
puer-
to
caso
general
buzón
sistema
operativo
ofrecer
servicio
crear-
Tales
buzones
verse
propiedad
proceso
crea
cuyo
caso
destruye
proceso
propiedad
sistema
operativo
cuyo
caso
precisa
mandato
explícito
destruir
buzón
FORMATO
MENSAJE
formato
mensaje
depende
objetivos
facilidad
mensajería
facili-
dad
ejecuta
computador
único
sistema
distribuido
sistemas
operativos
Concurrencia
Exclusión
mutua
sincronización
237
05-Capitulo
12/5/05
16:21
Página
237diseñadores
preferido
mensajes
cortos
longitud
fija
minimizar
sobrecarga
procesa-
miento
almacenamiento
transferir
cantidad
datos
datos
dis-
puestos
archivo
mensaje
simplemente
indicar
archivo
solución
sencilla
permitir
mensajes
longitud
variable
Figura
5.19
muestra
formato
típico
mensaje
sistema
operativo
propor-
ciona
mensajes
longitud
variable
mensaje
dividido
partes
cabecera
contiene
información
acerca
mensaje
cuerpo
contiene
contenido
real
men-
saje
cabecera
contener
identificación
origen
destinatario
previsto
mensaje
campo
longitud
campo
tipo
discriminar
tipos
mensajes
información
adicional
control
campo
puntero
crear
lista
encadenada
mensajes
número
secuencia
número
orden
mensajes
intercambiados
origen
destino
campo
prioridad
DISCIPLINA
COLA
disciplina
cola
simple
FIFO
suficiente
mensajes
urgentes
alternativa
permitir
especificar
prioridad
mensaje
base
tipo
mensaje
indicación
emisor
alternativa
permitir
receptor
inspeccionar
cola
mensajes
seleccionar
mensaje
recibir
238
Sistemas
operativos
Aspectos
internos
principios
diseño
S1
Sn
R1
Rn
Buzón
S1
Sn
R1
S1
R1Puerto
S1
R1
Buzón
Puerto
Figura
5.18
Comunicación
indirecta
procesos
05-Capitulo
12/5/05
16:21
Página
238EXCLUSIÓN
MUTUA
Figura
5.20
muestra
paso
mensajes
exclusión
mutua
com-
párense
Figuras
5.1
5.2
5.6
asume
primitiva
receive
bloqueante
pri-
mitiva
send
bloqueante
conjunto
procesos
concurrentes
comparten
buzón
procesos
enviar
recibir
buzón
inicializa
conteniendo
único
mensaje
contenido
nulo
proceso
desea
entrar
sección
crítica
intentar
recibir
mensaje
buzón
vacío
proceso
bloquea
proceso
conseguido
mensaje
realiza
Concurrencia
Exclusión
mutua
sincronización
239
Tipo
mensaje
ID
destino
ID
origenCabecera
Cuerpo
Longitud
mensaje
Información
control
Contenido
mensajes
Figura
5.19
Formato
general
mensaje
Figura
5.20
Exclusión
mutua
usando
mensajes
programa
exclusión
mutua
const
int
número
procesos
void
P(int
message
carta
while
true
receive
buzon
carta
sección
crítica
send
buzon
carta
resto
void
main
create_mailbox
buzon
send
buzon
null
paralelos
P(1
P(2
P(n
05-Capitulo
12/5/05
16:21
Página
239sección
crítica
devuelve
mensaje
buzón
mensaje
comporta
testigo
pasando
proceso
solución
precedente
asume
proceso
realiza
operación
recepción
concu-
rrentemente
mensaje
entregará
procesos
bloquearán
cola
mensajes
vacía
procesos
bloquearán
mensaje
disponible
procesos
activará
tomará
mensaje
supuestos
prácticamente
facilidades
paso
mensajes
ejemplo
paso
mensajes
Figura
5.21
presenta
solución
problema
productor
consumidor
buffer
acotado
Utilizando
exclusión
mutua
básica
proporciona
240
Sistemas
operativos
Aspectos
internos
principios
diseño
Figura
5.21
solución
problema
productor
consumidor
buffer
acotado
usando
mensajes
programa
productor
consumidor
const
int
capacidad
capacidad
almacenamiento
null
mensaje
vacío
int
void
productor
message
pmsg
while
true
receive
puedeproducir
pmsg
producir
receive
puedeconsumir
pmsg
void
consumidor
message
cmsg
while
true
receive
puedeconsumir
cmsg
consumir
receive
puedeproducir
cmsg
void
main
create_mailbox(puedeproducir
create_mailbox(puedeconsumir
for
int
capacidad
i++
send(puedeproducir
null
paralelos
productor
consumidor
05-Capitulo
12/5/05
16:21
Página
240paso
mensajes
problema
resuelto
algoritmo
similar
Figura
5.13
cambio
programa
Figura
5.21
aprovecha
ventaja
paso
mensajes
transferir
datos
señales
utilizan
buzones
medida
productor
genera
datos
envían
mensajes
buzón
puedeconsumir
mensaje
buzón
consumidor
consumirlo
puedeconsumir
sirve
buffer
datos
buffer
or-
ganizan
cola
mensajes
tamaño
buffer
viene
determinado
variable
global
ca-
pacidad
Inicialmente
buzón
puedeproducir
rellena
número
mensajes
nulos
capacidad
buffer
número
mensajes
puedeproducir
reduce
producción
cre-
ce
consumo
solución
flexible
múltiples
productores
consumidores
tengan
acceso
buzones
sistema
distribuido
procesos
pro-
ductores
buzón
puedeproducir
procesos
productores
buzón
puedecon-
sumir
5.6
PROBLEMA
LECTORES
ESCRITORES
diseño
mecanismos
sincronización
concurrencia
útil
capaz
relacionar
problema
concreto
problemas
conocidos
capaz
probar
solución
capacidad
resolver
problemas
conocidos
literatura
problemas
tomado
importancia
aparecen
frecuentemente
ejemplos
problemas
dise-
ño
comunes
valor
educativo
problemas
productor
consumidor
explorado
sección
veremos
problema
clásico
problema
lecto-
res
escritores
problema
lectores
escritores
define
área
datos
compartida
número
procesos
área
datos
fichero
bloque
memoria
principal
banco
registros
procesador
número
procesos
leen
área
datos
lectores
número
escriben
área
datos
escritores
siguientes
condiciones
satisfacerse
número
lectores
leer
fichero
simultáneamente
escritor
tiempo
escribir
fichero
escritor
escribiendo
fichero
lector
leerlo
continuar
distingamos
problema
problema
general
exclu-
sión
mutua
problema
productor
consumidor
problema
lectores
escritores
lectores
escriben
área
datos
escritores
leen
área
datos
caso
general
incluye
caso
permitir
proceso
leer
escribir
área
datos
caso
declarar
proceso
accede
área
datos
sección
críti-
ca
imponer
solución
general
exclusión
mutua
razón
preocuparnos
caso
restrictivo
solución
eficiente
caso
solución
me-
eficiente
problema
general
inaceptablemente
lenta
ejemplo
supóngase
área
compartida
catálogo
biblioteca
usuarios
ordinarios
biblioteca
leen
catálogo
localizar
libro
bibliotecarios
actualizar
catálogo
solu-
ción
general
acceso
catálogo
tratado
sección
crítica
usuarios
ve-
rían
forzados
leer
catálogo
claramente
impondría
retardos
intolerables
tiempo
importante
impedir
escritores
interferirse
necesa-
rio
impedir
lectura
escritura
curso
impedir
acceda
informa-
ción
inconsistente
Concurrencia
Exclusión
mutua
sincronización
241
05-Capitulo
12/5/05
16:21
Página
241¿Puede
considerarse
problema
productor
consumidor
simplemente
caso
especial
proble-
ma
lectores
escritores
único
escritor
productor
único
lector
consumidor
res-
puesta
productor
simplemente
escritor
leer
posiciones
cola
determinar
escribir
dato
determinar
buffer
lleno
consumidor
lector
ajustar
punteros
cola
mostrar
eliminado
unidad
buffer
Examinemos
soluciones
problema
LECTORES
PRIORIDAD
Figura
5.22
solución
utilizando
semáforos
muestra
instancia
lector
escritor
proceso
escritor
sencillo
semáforo
sescr
utiliza
cumplir
exclusión
mutua
escritor
esté
accediendo
área
datos
compartidos
escritor
nin-
gún
lector
acceder
proceso
lector
utiliza
sescr
cumplir
exclusión
mutua
obstante
permitir
múltiples
lectores
necesitamos
lectores
leyendo
lector
intenta
leer
esperar
sescr
lector
leyendo
siguientes
lectores
necesitan
esperar
entrar
variable
global
cuentalect
utiliza
número
lectores
semáforo
asegurar
cuentalect
actualiza
adecuadamente
ESCRITORES
PRIORIDAD
sección
previa
lectores
prioridad
único
lector
comenzado
acceder
área
datos
lectores
retengan
control
área
datos
quede
lec-
tor
realizando
lectura
escritores
sujetos
inanición
Figura
5.23
muestra
solución
garantiza
permitirá
lector
acce-
so
área
escritor
declarado
intención
escribir
escrito-
res
siguientes
semáforos
variables
añaden
definidas
semáforo
slect
inhibe
lectores
único
escritor
deseando
acceder
área
datos
variable
cuentaescr
controla
cambio
slect
semáforo
controla
actualización
cuentaescr
lectores
necesita
semáforo
adicional
permitir
ocurra
cola
slect
escritores
capaces
saltar
cola
permite
lector
encolarse
slect
lector
adicional
encolará
semáforo
inmediatamente
esperar
slect
Tabla
5.5
resume
posibilidades
Figura
5.24
muestra
solución
alternativa
prioridad
escritores
im-
plementada
paso
mensajes
caso
proceso
controlador
acceso
área
datos
compartidos
procesos
desean
acceder
área
datos
envían
mensaje
solicitud
controlador
concede
acceso
respondiendo
mensaje
OK
indican
acceso
completado
mensaje
terminado
controlador
equipado
buzones
tipos
mensaje
pue-
recibir
242
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
242El
proceso
controlador
prioridad
escritores
sirve
mensajes
solicitan
escribir
mensajes
solicitan
leer
cumplirse
exclusión
mutua
variable
inicializa
número
máximo
número
posi-
ble
lectores
ejemplo
valor
100
acción
controlador
resumirse
escritor
esperando
lectores
activos
Servir
mensajes
terminado
limpiar
lectores
activos
única
solicitud
pendiente
solicitud
escritura
Permitir
con-
tinuar
escritor
esperar
mensaje
terminado
Concurrencia
Exclusión
mutua
sincronización
243
Figura
5.22
solución
problema
lectores
escritores
usando
semáforos
lectores
prioridad
programa
lectores
escritores
int
cuentalect
semaphore
sescr
void
lector
while
true
semWait
cuentalect++
if
cuentalect
semWait
sescr
semSignal
LEERDATO
semWait
cuentalect
if
cuentalect
semSignal
sescr
semSignal
void
escritor
while
true
semWait
sescr
ESCRIBIRDATO
semSignal
sescr
void
main
cuentalect
paralelos
lector
escritor
05-Capitulo
12/5/05
16:21
Página
243244
Sistemas
operativos
Aspectos
internos
principios
diseño
Figura
5.23
solución
problema
lectores
escritores
usando
semáforos
escritores
prioridad
programa
lectores
escritores
int
cuentalect
cuentaescr
semaphore
sescr
slect
void
lector
while
true
semWait
semWait
slect
semWait
cuentalect++
if
cuentalect
semWait
sescr
semSignal
semSignal
slect
semSignal
LEERDATO
semWait
cuentalect
if
cuentalect
semSignal
sescr
semSignal
void
escritor
while
true
semWait
cuentaescr++
if
cuentaescr
semWait
slect
semSignal
semWait
sescr
ESCRIBIRDATO
semSignal
sescr
semWait
cuentaescr
if
cuentaescr
semSignal
slect
semSignal
void
main
cuentalect
cuentaescr
paralelos
lector
escritor
05-Capitulo
12/5/05
16:21
Página
244•
escritor
solicitud
esperar
limpian
lectores
activos
recibirse
mensajes
terminado
5.7
RESUMEN
temas
centrales
sistemas
operativos
modernos
multiprogramación
multiprocesamiento
procesamiento
distribuido
concurrencia
fundamental
temas
fundamental
tec-
nología
diseño
sistemas
operativos
múltiples
procesos
ejecutando
concurrente-
mente
realmente
caso
sistema
multiprocesador
virtualmente
caso
sistema
multiprogramado
procesador
único
surgen
cuestiones
resolución
conflictos
cooperación
procesos
concurrentes
interactuar
maneras
procesos
percatan
competir
recursos
tiempo
procesador
accesos
dispositivos
entrada
salida
procesos
percatarse
indirectamente
compartan
acceso
objeto
común
bloque
memoria
principal
fichero
Finalmen-
procesos
directamente
conscientes
cooperar
intercambiando
infor-
mación
aspectos
clave
surgen
interacciones
exclusión
mutua
interbloqueo
exclusión
mutua
condición
conjunto
procesos
concurrentes
capaz
acceder
recurso
función
dada
momento
determinado
técnicas
exclusión
mutua
usarse
resolver
conflictos
compe-
tencia
recursos
sincronizar
procesos
puedan
cooperar
ejemplo
modelo
productor
consumidor
proceso
pone
datos
buffer
proce-
sos
extraen
datos
buffer
forma
exclusión
mutua
involucra
instrucciones
máquina
propó-
sito
específico
solución
reduce
sobrecarga
ineficiente
utiliza
espera
activa
Concurrencia
Exclusión
mutua
sincronización
245
lectores
sistema
sescr
establecido
colas
escritores
sistema
sescr
slect
establecidos
escritores
encolan
sescr
lectores
escritores
lectura
sescr
establecido
lector
slect
establecido
escritor
escritores
encolan
sescr
lector
encola
slect
lectores
encolan
lectores
escritores
escritura
sescr
establecido
escritor
slect
establecido
escritor
escritores
encolan
sescr
lector
encola
slect
lectores
encolan
abla
5.5
colas
proceso
programa
Figura
5.23
05-Capitulo
12/5/05
16:21
Página
245246
Sistemas
operativos
Aspectos
internos
principios
diseño
Figura
5.24
solución
problema
lectores
escritores
usando
paso
mensajes
void
lector(int
void
controlador
message
msj
while
true
while
true
if
msj
send
quiereleer
msj
if
vacio
terminado
receive
buzon[i
msj
LEERDATO
receive
terminado
msj
msj
cuenta++
send
terminado
msj
else
if
vacio
quiereescribir
void
escritor(int
receive
quiereescribir
msj
escritor_id
msj.id
message
msj
100
while(true
else
if
vacio
quiereleer
msj
send
quiereescribir
msj
receive
quiereleer
msj
receive
buzon[j
msj
ESCRIBIRDATO
send
msj.id
OK
msj
send
terminado
msj
if
send
escritor_id
OK
receive
terminado
msj
100
while
receive
terminado
msj
cuenta++
05-Capitulo
12/5/05
16:21
Página
246Otro
enfoque
exclusión
mutua
proporcionar
servicios
sistema
opera-
tivo
técnicas
comunes
semáforos
facilidades
mensajes
semáfo-
ros
utilizan
señalización
procesos
fácilmente
aplicar
disciplina
exclusión
mutua
mensajes
útiles
cumplir
exclusión
mutua
proporcionan
mecanismo
eficiente
comunicación
procesos
5.8
LECTURAS
RECOMENDADAS
BEN82
proporciona
explicación
clara
entretenida
concurrencia
exclu-
sión
mutua
semáforos
temas
relacionados
tratamiento
formal
incluye
sistemas
distribuidos
encontrar
BEN90
AXFO88
tratado
legible
útil
tam-
bién
contiene
problemas
soluciones
desarrolladas
RAYN86
exhaustiva
lúcida
colección
algoritmos
exclusión
mutua
cubriendo
software
ejemplo
Dekker
solu-
ciones
hardware
semáforos
mensajes
HOAR85
clásico
fácil
leer
presenta
enfoque
formal
definición
procesos
secuenciales
concurrencia
LAMP86
extenso
tratado
formal
exclusión
mutua
RUDO90
útil
ayuda
entender
concurrencia
BACO03
tratado
organizado
concurrencia
BIRR89
proporciona
in-
troducción
práctica
programación
concurrente
BUHR95
exhaustiva
investigación
monitores
KANG98
instructivo
análisis
12
políticas
planificación
problema
lectores
escritores
AXFO88
Axford
Concurrent
Programming
Fundamental
Techniques
for
Real-Time
and
Parallel
Soft-
ware
Design
New
York
Wiley
1988
BACO03
Bacon
J.
Harris
Operating
Systems
Concurrent
and
Distributed
Software
Design
Rea-
ding
MA
Addison-Wesley
1998
BEN82
Ben-Ari
M.
Principles
of
Concurrent
Programming
Englewood
Cliffs
NJ
Prentice
Hall
1982
BEN90
Ben-Ari
M.Principles
of
Concurrent
and
Distributed
Programming
Englewood
Cliffs
NJ
Pren-
tice
Hall
1990
BIRR89
Birrell
A.
An
Introduction
to
Programming
with
Threads
SRC
Research
Report
35
Compaq
Systems
Research
Center
Palo
Alto
CA
Enero
1989
Disponible
http://www.research.com-
paq.com/SRC
BUHR95
Buhr
Fortier
M.
Monitor
Classification
ACM
Computing
Surveys
Marzo
1995
HOAR85
Hoare
C.
Communicating
Sequential
Processes
Englewood
Cliffs
NJ
Prentice
Hall
1985
KANG98
Kang
S.
Lee
J.
Analysis
and
Solution
of
Non-Preemptive
Policies
for
Scheduling
Readers
and
Writers
Operating
Systems
Review
Julio
1998
LAMP86
Lamport
L.
The
Mutual
Exclusion
Problem
Journal
of
the
ACM
Abril
1986
RA
YN86Raynal
M.
Algorithms
for
Mutual
Exclusion
Cambridge
MA
MIT
Press
1986
RUDO90
Rudolph
B.
Self-Assessment
Procedure
XXI
Concurrency
Communications
of
the
ACM
Mayo
1990
Concurrencia
Exclusión
mutua
sincronización
247
05-Capitulo
12/5/05
16:21
Página
2475.9
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
bloqueante
interbloqueo
sección
crítica
concurrencia
monitor
semáforo
condición
carrera
mutex
semáforo
binario
corrutina
bloqueante
semáforo
contador
espera
activa
paso
mensajes
semáforo
débil
exclusión
mutua
proceso
concurrente
semáforo
fuerte
inanición
recurso
crítico
semáforo
general
CUESTIONES
REPASO
5.1
Enumere
aspectos
diseño
concepto
concurrencia
relevante
5.2
contextos
aparece
concurrencia
5.3
requisito
básico
ejecución
procesos
concurrentes
5.4
Enumere
grados
percepción
procesos
defina
brevemente
5.5
diferencia
procesos
competencia
procesos
cooperantes
5.6
Enumere
problemas
control
asociados
procesos
competencia
defina
brevemente
5.7
Enumere
condiciones
necesarias
exclusión
mutua
5.8
operaciones
realizadas
semáforo
5.9
diferencia
semáforos
binarios
semáforos
generales
5.10
diferencia
semáforos
fuertes
semáforos
débiles
5.11
monitor
5.12
diferencia
bloqueante
bloqueante
mensajes
5.13
condiciones
asociadas
generalmente
problema
lectores
escritores
PROBLEMAS
5.1
procesos
hilos
proporcionan
herramienta
potente
estructuración
implementación
programas
serían
complejos
simples
programas
secuenciales
corrutina
construcción
concurrente
instructivo
examinar
propósito
problema
introducir
corrutinas
compararlas
procesos
Considere
sencillo
problema
CONW63
Lea
tarjetas
80
columnas
imprímalas
líneas
125
caracteres
siguientes
cambios
Inserte
blanco
extra
imagen
tarjeta
reemplace
pa-
reja
asteriscos
adyacentes
aparezca
carácter
≠.
248
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
248a
Desarrolle
solución
problema
programa
secuencial
ordinario
Verá
programa
difícil
escribir
interacciones
diversos
elementos
programa
dispares
conversión
longitud
80
125
longitud
imagen
tarjeta
conversión
variará
dependiendo
número
dobles
asteriscos
aparezcan
forma
mejorar
claridad
minimi-
zar
posibles
errores
escribir
aplicación
procedimientos
separados
procedimiento
lee
imagen
tarjetas
añade
imagen
blanco
es-
cribe
conjunto
caracteres
fichero
temporal
leer
tarjetas
procedimiento
lee
fichero
temporal
sustitución
caracteres
es-
cribe
fichero
temporal
tercer
procedimiento
lee
contenido
fichero
temporal
imprime
líneas
125
caracteres
solución
secuencial
atractiva
sobrecarga
ficheros
tempora-
Conway
propuso
forma
estructura
programa
corrutina
per-
mite
escribir
aplicación
programas
conectados
buffers
carácter
Figura
5.25
procedimiento
tradicional
relación
maestro
esclavo
procedimiento
llamante
procedimiento
llamado
procedimiento
llamante
pue-
ejecutar
llamada
punto
procedimiento
procedimiento
llamado
comienza
punto
entrada
retorna
procedimiento
llamante
punto
llamada
corrutina
exhibe
relación
simétrica
medida
realiza
llamada
ejecución
punto
activo
procedimiento
lla-
mado
sentido
procedimiento
llamante
superior
llamado
retornos
cambio
corrutina
pasar
control
corrutina
sentencia
resume
retomar
invoca
corrutina
retoma
punto
entrada
Posteriormente
corrutina
reactiva
punto
sentencia
resume
Nótese
corrutina
programa
ejecución
momento
puntos
transición
definidos
explícitamente
código
ejemplo
procesamiento
concu-
rrente
Explique
operación
programa
Figura
5.25
programa
contempla
condición
terminación
Asuma
rutina
LEERTARJETA
devuelve
valor
puesto
imagen
80
caracteres
entrada
devuelve
falso
caso
Modifique
programa
in-
cluir
contingencia
Nótese
línea
impresa
contener
125
caracteres
Reescriba
solución
conjunto
procesos
usando
semáforos
5.2
Considere
programa
concurrente
procesos
definidos
sentencias
atómicas
indivisibles
arbitrarias
Asuma
programa
princi-
pa
muestra
realiza
paralelos
procesos
void
void
Muestre
posibles
entrelazados
ejecución
procesos
precedentes
muéstrelo
dando
trazas
ejecución
términos
sentencias
atómicas
Concurrencia
Exclusión
mutua
sincronización
249
05-Capitulo
12/5/05
16:21
Página
2495.3
Considere
programa
const
int
50
int
void
int
for
i++
250
Sistemas
operativos
Aspectos
internos
principios
diseño
Figura
5.25
aplicación
corrutinas
char
ca
cp
void
filtrar
char
entrada[80
char
salida[125
while
true
void
leer
if
ca
while
true
cp
ca
LEERTARJETA
entrada
RESUME
imprimir
for
int
i=0
80
i++
else
ca
entrada
RESUME
filtrar
RESUME
leer
if
ca
ca
RESUME
filtrar
cp
RESUME
imprimir
void
imprimir
else
while
true
cp
RESUME
imprimir
for
int
125
j++
cp
ca
RESUME
imprimir
salida
cp
RESUME
filtrar
RESUME
leer
IMPRIMIRLINEA
salida
05-Capitulo
12/5/05
16:21
Página
250void
main
paralelos
write
Determine
límites
inferior
superior
correctos
valor
variable
compar-
tida
producida
programa
concurrente
Asuma
procesos
ejecutar
velocidad
relativa
valor
incrementado
des-
pués
cargado
registro
instrucción
máquina
separada
Suponga
permite
ejecución
paralelo
número
arbitrario
pro-
cesos
supuestos
Apartado
a.
efecto
modificación
ran-
go
valores
finales
5.4
eficiente
términos
tiempo
procesador
espera
activa
espera
bloqueante
Explíquelo
5.5
Considere
programa
boolean
bloqueado[2
int
turno
void
int
id
while
true
bloqueado[id
true
while
turno
id
while
bloqueado[1-id
turno
id
sección
crítica
bloqueado[id
false
resto
void
main
bloqueado[0
false
bloqueado[1
false
turno
paralelos
P(0
P(1
Concurrencia
Exclusión
mutua
sincronización
251
05-Capitulo
12/5/05
16:21
Página
251Esta
solución
problema
exclusión
mutua
procesos
propone
HYMA66
Encuentre
contraejemplo
demuestre
solución
incorrecta
interesante
notar
código
engañó
Communications
of
the
ACM
5.6
solución
software
exclusión
mutua
algoritmo
panadería
Lamport
LAMP74
llamado
basado
práctica
panaderías
tiendas
cliente
recibe
tique
numerado
llega
permite
servido
turno
algoritmo
boolean
eligiendo[n
int
numero[n
while
true
eligiendo[i
true
numero[i
maximo(numero
eligiendo[i
false
for
int
j++
while
eligiendo[j
continue
while
numero[j
numero[j],j
numero[i],i
continue
sección
crítica
numero[i
resto
vectores
eligiendo
numero
inicializados
falso
respectivamente
elemento
i-ésimo
vector
leído
escrito
proceso
leído
procesos
notación
define
OR
AND
Describa
algoritmo
palabras
Muestre
algoritmo
evita
interbloqueo
Muestre
cumple
exclusión
mutua
5.7
utiliza
instrucción
máquina
especial
proporcionar
exclusión
mutua
Figura
5.2
control
tiempo
deberá
esperar
proceso
an-
tes
acceso
región
crítica
Idee
algoritmo
utilice
instrucción
test-
set
garantizar
proceso
esperando
entrar
sección
crítica
hará
turnos
número
procesos
solicitar
acceso
región
crítica
turno
evento
consistente
proceso
sale
sec-
ción
crítica
proceso
concede
acceso
5.8
Considere
definición
semáforos
void
semWait(s
252
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
252if
s.cuenta
s.cuenta
else
proceso
s.cola
bloquear
proceso
void
semSignal
if
proceso
bloqueado
semáforo
extraer
proceso
s.cola
proceso
lista
listos
else
s.cuenta++
Compare
conjunto
definiciones
Figura
5.3
Nótese
diferencia
definición
precedente
semáforo
tomar
valor
negativo
diferencia
conjuntos
definiciones
utilizan
programas
sustituirse
conjunto
alterar
significado
programa
5.9
implementar
semáforos
generales
usando
semáforos
binarios
operaciones
semWaitBy
semSignalBy
semáforos
binarios
pausay
mutex
Considere
void
semWait(semaphore
semWaitB(mutex
if
semSignalB(mutex
semWaitB(pausa
else
SemsignalB(mutex
void
semSignal(semaphore
semWaitB(mutex
Concurrencia
Exclusión
mutua
sincronización
253
05-Capitulo
12/5/05
16:21
Página
253s++
if
semSignalB(pausa
semSignalB(mutex
Inicialmente
pone
valor
deseado
semáforo
operación
semWait
decre-
menta
operación
semSignal
incrementa
s.
semáforo
binario
mutex
inicializa
asegura
exclusión
mutua
actualización
s.
semáforo
bina-
rio
pausa
inicializa
bloquear
procesos
defecto
programa
precedente
Demuestre
defecto
proponga
cambio
subsane
Pista
suponga
procesos
llaman
semWait(s
ini-
cialmente
justo
semSignalB(mutex
semWaitB(pausa),la
llamada
semWait(s
avanza
punto
mover
única
línea
programa
5.10
1978
Dijkstra
propuso
conjetura
solución
problema
exclusión
mutua
evite
inanición
aplicable
número
desconocido
finito
procesos
usando
número
finito
semáforos
débiles
1979
J.M.
Morris
refutó
conjetura
publicar
algoritmo
utiliza
semáforos
débiles
comportamiento
algorit-
mo
descrito
procesos
esperando
operación
semWait(S
proceso
ejecutando
semSignal(S),el
valor
semáforo
modifica
procesos
espera
desbloquea
independientemente
sem-
Wait(S).Aparte
semáforos
algoritmo
utiliza
variables
enteras
nega-
tivas
contadores
número
procesos
secciones
algoritmo
semáforos
inicializan
semáforo
contadores
NA
NM
inicializan
semáforo
exclusión
mutua
protege
accesos
va-
riable
compartida
NA
proceso
intente
entrar
sección
crítica
cruzar
barreras
representadas
semáforos
M.
contadores
NA
NM
respectivamen-
contienen
número
procesos
listos
cruzar
barrera
cruzado
barrera
barrera
M.
protocolo
NM
procesos
bloqueados
entrarán
secciones
críticas
usando
técnica
cascada
similar
utilizada
Defina
algoritmo
conforme
descripción
5.11
problema
planteó
examen
Parque
Jurásico
consiste
museo
parque
rutas
safari
pasa-
jeros
coches
monoplaza
pasajeros
deambulan
museo
rato
cola
paseo
coche
safari
coche
dispo-
nible
monta
pasajero
pasea
parque
cantidad
tiempo
aleatoria
vehículos
paseo
parque
pasajero
abordo
pasajero
coche
espera
coche
listo
cargar
pasajeros
esperando
coche
espera
Use
semáforos
sincronizar
procesos
pasajero
procesos
coche
esqueleto
código
encontrado
garabateado
papel
suelo
sala
examen
Evalúe
corrección
Ignore
sintaxis
variables
declaradas
Re-
cuerde
corresponden
semWaity
semSignal
resource
Parque_Jurasico
sem
coche_libre
coche_tomado
coche_ocupado
pasajero_pendiente
254
Sistemas
operativos
Aspectos
internos
principios
diseño
05-Capitulo
12/5/05
16:21
Página
254process
pasajero(i
to
num_pasajeros
do
true
dormir(int(random(1000*tiempo_visita
P(coche_libre
V(coche_tomado
P(coche_ocupado
P(pasajero_pendiente
od
end
pasajero
process
coche(j
to
num_coches
do
true
V(coche_libre
P(coche_tomado
V(coche_ocupado
dormir(int(random(1000*tiempo_paseo
V(pasajero_pendiente
od
end
coche
end
Parque_Jurasico
5.12
comentario
Figura
5.9
Tabla
5.3
cabe
simplemente
mover
sentencia
condicional
sección
crítica
controlada
consumi-
dor
lugar
interbloqueo
Demuestre
tabla
similar
Tabla
5.3
5.13
Considere
solución
problema
productor
consumidor
buffer
infinito
definido
Figura
5.10
Suponga
caso
usual
productor
consumidor
ejecutando
velocidad
escenario
Productor
añadir
semSignal;producir
añadir
semSignal;producir
Consumidor
consumir
extraer
semWait;consumir
extraer
semWait
productor
añadir
elemento
buffer
señalar
consumidor
consume
elemento
previo
productor
añadiendo
buf-
fer
vacío
consumidor
extrayendo
único
dato
buffer
consumidor
bloquea
semáforo
realizando
número
lla-
madas
mecanismo
semáforo
creando
considerable
sobrecarga
Construya
programa
eficiente
circunstancias
Pista
Permita
tomar
valor
-1
significará
buffer
vacío
consumidor
detectado
bloquear
productor
propor-
cione
datos
solución
necesita
variable
local
encuen-
tra
Figura
5.10
5.14
Considere
Figura
5.13
Cambiaría
significado
programa
intercambiase
si-
guiente
semWait(e
semWait(s
semSignal(s
semSignal(n
semWait(n
semWait(s
semSignal(s
semSignal(e
5.15
Nótese
exposición
problema
productor
consumidor
buffer
finito
Figura
5.12
definición
permite
entradas
buffer
Modifique
algoritmo
corregir
deficiencia
Concurrencia
Exclusión
mutua
sincronización
255
05-Capitulo
12/5/05
16:21
Página
2555.16
problema
demuestra
semáforos
coordinar
tipos
procesos
Santa
Claus
duerme
tienda
Polo
Norte
despertado
nue-
ve
renos
vuelto
vacaciones
Pacífico
Sur
elfos
dificultades
fabricando
juguetes
Santa
dormir
elfos
despertarle
tengan
problemas
elfos
solucio-
nando
problemas
elfo
desee
visitar
Santa
Claus
esperar
elfos
vuelvan
Santa
Claus
despierta
elfos
esperando
puerta
tienda
reno
acaba
volver
trópico
Santa
Claus
decidido
elfos
esperar
Navidad
im-
portante
listo
trineo
asume
renos
desean
abandonar
trópicos
momento
reno
volver
buscar
Santa
Claus
esperan
establo
calentito
engan-
chados
trineo
Resuelva
problema
usando
semáforos
5.17
Muestre
paso
mensajes
semáforos
funcionalidad
equivalente
Implemente
paso
mensajes
usando
semáforos
Pista
haga
área
alma-
cenamiento
compartida
mantener
buzones
consistiendo
vector
capacidad
determinado
número
mensajes
Implemente
semáforo
usando
paso
mensajes
Pista
introduzca
proceso
sincronización
separado
256
Sistemas
operativos
Aspectos
internos
principios
diseño
gratitud
John
Trono
St
Michael’s
College
Vermont
proporcionar
problema
05-Capitulo
12/5/05
16:21
Página
256CAPÍTULO
Concurrencia
Interbloqueo
inanición
6.1
Fundamentos
interbloqueo
6.2
Prevención
interbloqueo
6.3
Predicción
interbloqueo
6.4
Detección
interbloqueo
6.5
estrategia
integrada
tratamiento
interbloqueo
6.6
problema
filósofos
comensales
6.7
Mecanismos
concurrencia
UNIX
6.8
Mecanismos
concurrencia
núcleo
Linux
6.9
Funciones
sincronización
hilos
Solaris
6.10
Mecanismos
concurrencia
Windows
6.11
Resumen
6.12
Lecturas
recomendadas
6.13
érminos
clave
cuestiones
repaso
problemas
06-Capitulo
16/5/05
17:04
Página
257N
capítulo
continúa
estudio
concurrencia
examinando
problemas
dificultan
iniciativas
proporcionar
procesamiento
concurrente
interbloqueo
inanición
capí-
tulo
comienza
estudio
principios
fundamentales
interbloqueos
problemas
relacionados
inanición
continuación
examinarán
estrategias
básicas
tratar
interbloqueo
prevención
detección
predicción
Acto
seguido
revisará
problemas
clásicos
utilizados
ilustrar
sincronización
interbloqueo
problema
filósofos
comensales
Capítulo
estudio
capítulo
limita
considerar
concurrencia
interblo-
queo
único
sistema
estrategias
tratar
problemas
interbloqueo
distri-
buido
abordarán
Capítulo
14
6.1
FUNDAMENTOS
INTERBLOQUEO
definir
interbloqueo
bloqueo
permanente
conjunto
procesos
compiten
recursos
sistema
comunican
conjunto
procesos
interbloqueado
proceso
conjunto
bloqueado
esperando
evento
normal-
mente
liberación
recurso
requerido
generar
proceso
bloqueado
conjunto
interbloqueo
permanente
producirse
eventos
dife-
rencia
problemas
aparecen
gestión
procesos
concurrentes
solución
eficiente
caso
general
interbloqueos
involucran
necesidades
conflictivas
afectan
recursos
procesos
ejemplo
habitual
interbloqueo
tráfico
Figura
6.1a
muestra
situa-
ción
coches
llegado
tiempo
intersección
confluyen
caminos
cuadrantes
intersección
recursos
con-
trolar
particular
coches
desean
cruzar
intersección
requisitos
recursos
siguientes
coche
viaja
norte
necesita
cuadrantes
b.
coche
necesita
cuadrantes
c.
coche
necesita
cuadrantes
d.
coche
necesita
cuadrantes
a.
norma
circulación
habitual
coche
cruce
caminos
debería
pre-
ferencia
coche
justo
derecha
regla
funciona
coches
intersección
ejemplo
llegan
intersección
coches
vienen
norte
oes-
norte
esperará
oeste
proseguirá
coches
llegan
aproxima-
damente
tiempo
abstendrá
cruzar
intersección
produciéndose
inter-
bloqueo
coches
olvidan
normas
entran
cuidadosamente
intersección
posee
recurso
cuadrante
continuar
recurso
requerido
apoderado
coche
producido
interbloqueo
Nótese
coche
justo
coche
marcha
atrás
eliminar
interbloqueo
continuación
examina
diagrama
interbloqueo
involucrando
procesos
recursos
computador
Figura
6.2
basada
incluida
BACO03
denominada
diagrama
pro-
greso
conjunto
muestra
progreso
procesos
compitiendo
recursos
proceso
ne-
258
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
258Concurrencia
Interbloqueo
inanición
259
cb
interbloqueo
Interbloqueo
Figura
6.1
Ilustración
interbloqueo
Progreso
Progreso
PSolicita
Solicita
Solicita
Solicita
requiere
requiere
Libera
Libera
Libera
Libera
Interbloqueo
inevitable
quieren
trayectoria
progreso
Tramo
horizontal
trayectoria
indica
ejecutando
esperando
Tramo
vertical
trayectoria
indica
ejecutando
esperando
quieren
recurso
Región
interbloqueo
inevitable
requiere
quieren
requiere
quieren
recurso
Figura
6.2
Ejemplo
interbloqueo
06-Capitulo
16/5/05
17:04
Página
259cesita
exclusivo
recursos
periodo
tiempo
Suponga
procesos
estructura
general
Proceso
Proceso
Solicita
Solicita
Solicita
Solicita
Libera
Libera
Libera
Libera
Figura
6.2
eje
representa
progreso
ejecución
eje
repre-
senta
Q.
progreso
conjunto
procesos
representa
trayectoria
avanza
origen
dirección
nordeste
caso
sistema
uniprocesador
ejecutar
proceso
trayectoria
consiste
segmentos
horizontales
verticales
alterna-
segmento
horizontal
representa
periodo
ejecuta
espera
segmento
vertical
representa
periodo
ejecuta
espera
figura
muestra
áre-
as
requieren
recurso
líneas
ascendentes
áreas
pro-
cesos
requieren
recurso
líneas
descendentes
áreas
requieren
recur-
sos
asume
proceso
requiere
control
exclusivo
recurso
regiones
prohibidas
imposible
trayectoria
represente
progreso
ejecución
conjunta
regiones
figura
muestra
trayectorias
ejecución
resumir
adquiere
continuación
libera
A.
continúe
ejecución
capaz
adquirir
recursos
adquiere
continuación
A.
ejecuta
bloquea
solicitar
A.
libera
A.
Cuan-
do
continúe
ejecución
capaz
adquirir
recursos
adquiere
continuación
adquiere
A.
interbloqueo
inevitable
puesto
ejecución
continúe
bloqueará
espera
B.
adquiere
continuación
adquiere
B.
interbloqueo
inevitable
puesto
ejecución
continúe
bloqueará
espera
B.
adquiere
continuación
B.
ejecuta
bloquea
solicitar
B.
libera
B.
continúe
ejecución
capaz
adquirir
recursos
adquiere
continuación
libera
B.
continúe
ejecución
capaz
adquirir
recursos
área
sombreada
gris
Figura
6.2
denominarse
región
fatal
relacionada
comentario
trayectorias
trayectoria
ejecución
entra
región
fatal
interbloqueo
inevitable
Nótese
existencia
región
fatal
depende
lógica
procesos
interbloqueo
inevitable
progreso
conjunto
procesos
crea
trayectoria
entra
región
fatal
260
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
260La
aparición
interbloqueo
depende
dinámica
ejecución
deta-
lles
aplicación
ejemplo
supóngase
necesitase
recursos
tiempo
procesos
tuvieran
estructura
Proceso
Proceso
Solicita
Solicita
Libera
Solicita
Solicita
Libera
Libera
Libera
situación
refleja
Figura
6.3
analiza
figura
lector
convencerá
independencia
temporización
relativa
procesos
ocurrir
inter-
bloqueo
Concurrencia
Interbloqueo
inanición
261
/H11005
quieren
recurso
/H11005
quieren
recurso
23
/H11005
trayectoria
progreso
Tramo
horizontal
trayectoria
indica
ejecutando
esperando
Tramo
vertical
trayectoria
indica
ejecutando
esperando
Progreso
Progreso
PSolicita
Solicita
Solicita
Solicita
requiere
Libera
Libera
Libera
Libera
quieren
requiere
quieren
requiere
BSe
requiere
Figura
6.3
Ejemplo
interbloqueo
BACO03
06-Capitulo
16/5/05
17:04
Página
261Como
mostrado
utilizar
diagrama
progreso
conjunto
registrar
histo-
ria
ejecución
procesos
comparten
recursos
casos
procesos
competir
recurso
requeriría
diagrama
dimensiones
cual-
quier
caso
principios
concernientes
regiones
fatales
interbloqueos
permanecerían
RECURSOS
REUTILIZABLES
distinguirse
categorías
recursos
reutilizables
consumibles
recurso
reutilizable
utilizar
forma
segura
proceso
momento
destruye
procesos
obtienen
unidades
recurso
liberarán
pue-
volver
usarlas
procesos
ejemplos
recursos
reutilizables
incluyen
procesado-
res
canales
memoria
principal
secundaria
dispositivos
estructuras
datos
fiche-
ros
bases
datos
semáforos
ejemplo
recursos
reutilizables
involucrados
interbloqueo
considere
procesos
compiten
acceso
exclusivo
fichero
disco
unidad
cinta
C.
Figura
6.4
muestran
operaciones
realizadas
programas
implicados
interblo-
queo
produce
proceso
mantiene
recurso
solicita
ejemplo
ocurrirá
interbloqueo
sistema
multiprogramación
intercala
ejecución
procesos
si-
guiente
p1
q0
q1
p2
q2
parecer
error
programación
problema
diseñador
sistema
operativo
observado
previamente
diseño
programas
con-
currentes
complejo
interbloqueos
producir
estando
causa
frecuentemente
em-
potrada
compleja
lógica
programa
difícil
detección
estrategia
tratar
interbloqueo
imponer
restricciones
diseño
sistema
orden
solicitar
recursos
ejemplo
interbloqueo
recurso
reutilizable
relacionado
peticiones
reserva
memoria
principal
Supóngase
espacio
disponible
reservar
200
Kbytes
produce
secuencia
peticiones
262
Sistemas
operativos
Aspectos
internos
principios
diseño
Proceso
Paso
Acción
p0
Solicita
p1
Bloquea
p2
Solicita
p3
Bloquea
p4
Realiza
función
p5
Desbloquea
p6
Desbloquea
Proceso
Paso
Acción
q0
Solicita
q1
Bloquea
q2
Solicita
q3
Bloquea
q4
Realiza
función
q5
Desbloquea
q6
Desbloquea
Figura
6.4
Ejemplo
procesos
compitiendo
recursos
reutilizables
06-Capitulo
16/5/05
17:04
Página
262P1
P2
Solicita
80
Kbytes
Solicita
70
Kbytes
Solicita
60
Kbytes
Solicita
80
Kbytes
interbloqueo
sucede
procesos
progresan
petición
conoce
anticipadamente
cantidad
memoria
solicitarse
difícil
tratar
tipo
interblo-
queos
restricciones
diseño
sistema
tratar
problema
realidad
eliminar
posibilidad
produzca
utilización
memoria
virtual
estudiará
Capítulo
RECURSOS
CONSUMIBLES
recurso
consumible
crearse
producirse
destruirse
consumirse
Normal-
mente
límite
número
recursos
consumibles
determinado
tipo
proceso
pro-
ductor
desbloqueado
crear
número
ilimitado
recursos
proceso
consu-
midor
adquiere
recurso
recurso
deja
existir
ejemplos
recursos
consumibles
interrupciones
señales
mensajes
información
buffers
S.
ejemplo
interbloqueo
involucra
recursos
consumibles
considere
par
procesos
forma
proceso
intenta
recibir
mensaje
continuación
en-
vía
mensaje
P1
P2
Recibe
P2
Recibe
P1
Envía
P2
M1
Envía
P1
M2
produce
interbloqueo
función
recepción
Recibe
bloqueante
proce-
so
receptor
bloquea
recibe
mensaje
Nuevamente
causa
interbloqueo
error
diseño
errores
sutiles
difíciles
detectar
dar-
rara
combinación
eventos
cause
interbloqueo
programa
usándo-
periodo
considerable
tiempo
años
realmente
ocurra
inter-
bloqueo
única
estrategia
efectiva
tratar
tipos
interbloqueo
Ta-
bla
6.1
resume
elementos
fundamentales
estrategias
importantes
desa-
rrollado
prevención
predicción
detección
estudiará
presenten
grafos
asignación
recursos
continuación
condiciones
inter-
bloqueo
Concurrencia
Interbloqueo
inanición
263
06-Capitulo
16/5/05
17:04
Página
263264
Sistemas
operativos
Aspectos
internos
principios
diseño
Estrategia
Política
reserva
Esquemas
alternativos
Principales
ventajas
Principales
desventajasde
recursos
abla
6.1
Resumen
estrategias
detección
prevención
predicción
interbloqueos
sistemas
operativos
ISLO80
Prevención
Predicción
Detección
Conservadora
infrautiliza
recursos
camino
detección
prevención
liberal
recursos
solicitados
conceden
caso
Solicitud
simultánea
recursos
Expropiación
Ordenamiento
recursos
Asegura
camino
seguro
invoca
periódicamente
comprobar
interbloqueo
Adecuada
procesos
realizan
ráfaga
actividad
necesaria
expropiación
Conveniente
aplica
recursos
cuyo
guardar
restaurar
fácilmente
asegurarlo
comprobaciones
tiempo
compilación
necesita
cálculos
tiempo
ejecución
problema
resuelve
diseño
sistema
necesaria
expropiación
retrasa
iniciación
proceso
Facilita
gestión
línea
Ineficiente
Retrasa
iniciación
proceso
procesos
futuros
requisitos
recursos
Expropia
frecuencia
necesario
Impide
solicitudes
graduales
recursos
SO
futuros
requisitos
recursos
procesos
procesos
bloquear
largos
periodos
Pérdidas
inherentes
expropiación
06-Capitulo
16/5/05
17:04
Página
264GRAFOS
ASIGNACIÓN
RECURSOS
herramienta
útil
caracterización
asignación
recursos
procesos
grafo
asignación
recursos
introducido
Holt
HOLT72
grafo
asignación
recursos
grafo
dirigido
representa
sistema
refiere
recursos
procesos
forma
proceso
recurso
representa
nodo
arista
grafo
dirigida
proceso
recurso
indica
proceso
solicitado
recurso
concedi-
do
Figura
6.5a
interior
nodo
recurso
muestra
punto
instancia
recurso
ejemplo
tipo
recurso
múltiples
instancias
conjunto
dispositivos
controlados
módulo
gestión
recursos
sistema
operativo
arista
grafo
dirigida
punto
nodo
recurso
reutilizable
proceso
indica
concedido
petición
Figura
6.5b
proceso
asignado
unidad
recurso
arista
grafo
dirigida
punto
nodo
recurso
consumible
proceso
indica
proceso
productor
recurso
Figura
6.5c
muestra
ejemplo
interbloqueo
unidad
recurso
Ra
Rb
proceso
P1
mantiene
Rb
solicita
Ra
P2
mantiene
Ra
pide
Rb
Figura
6.5d
topología
Figura
6.5c
interbloqueo
disponibles
múltiples
unidades
recurso
grafo
asignación
recursos
Figura
6.6
corresponde
situación
interbloqueo
Figura
6.1b
Nótese
caso
situación
sencilla
proce-
Concurrencia
Interbloqueo
inanición
265
Rb
Ra
Ra
Espera
circular
Recurso
solicitado
Rb
Ra
interbloqueo
Ra
Recurso
asignado
Solicita
Asignado
Solicita
Asignado
Solicita
Asignado
Solicita
Asignado
Solicita
Asignado
P1
P1
P1
P2
P1
P2
Figura
6.5
Ejemplos
grafos
asignación
recursos
06-Capitulo
16/5/05
17:04
Página
265sos
forma
recurso
necesita
caso
cadena
circular
procesos
recursos
resultado
interbloqueo
CONDICIONES
INTERBLOQUEO
presentarse
condiciones
gestión
interbloqueo
Exclusión
mutua
proceso
utilizar
recurso
momento
proce-
so
acceder
unidad
recurso
asignado
proceso
Retención
espera
proceso
mantener
recursos
asignados
espera
asignación
recursos
expropiación
forzar
expropiación
recurso
proceso
posee
diversos
motivos
condiciones
realmente
deseables
ejemplo
necesita
ex-
clusión
mutua
asegurar
coherencia
resultados
integridad
base
datos
expropiación
debería
forma
arbitraria
ejemplo
involucrados
recursos
datos
expropiación
implementarse
mecanismo
recu-
peración
retroceso
restaura
proceso
recursos
previo
adecuado
des-
proceso
finalmente
repetir
acciones
cumplen
condiciones
producir
interbloqueo
cum-
plan
realmente
produzca
interbloqueo
requiere
cuarta
condición
Espera
circular
lista
cerrada
procesos
proceso
posee
recurso
necesitado
proceso
lista
ejemplo
véase
Fi-
guras
6.5c
6.6
primeras
condiciones
necesarias
suficientes
exista
interbloqueo
cuarta
condición
realmente
consecuencia
potencial
primeras
cumplen
primeras
condiciones
producir
secuencia
eventos
conduzca
espera
circular
irresoluble
espera
circular
irresoluble
definición
interblo-
queo
espera
circular
enumerada
cuarta
condición
irresoluble
cumplen
266
Sistemas
operativos
Aspectos
internos
principios
diseño
Ra
Rb
Rc
Rd
P1
P2
P3
P4
Figura
6.6
Grafo
asignación
recursos
correspondiente
Figura
6.1b
06-Capitulo
16/5/05
17:04
Página
266tres
primeras
condiciones
condiciones
forma
conjunta
constituyen
condicio-
nes
necesarias
suficientes
interbloqueo1
clarificar
discusión
útil
volver
concepto
diagrama
progreso
conjunto
mostró
Figura
6.2
Recuerde
definió
región
fatal
procesos
entrado
región
verán
involucrados
interbloqueo
región
fatal
cumplen
conjuntamente
primeras
condiciones
anteriormente
ex-
puestas
satisface
condiciones
región
fatal
ocurrir
interbloqueo
condiciones
necesarias
interbloqueo
pro-
duzca
interbloqueo
región
fatal
secuencia
peti-
ciones
recursos
conduzca
región
fatal
cumple
condición
espera
circular
entrado
región
fatal
condiciones
expuestas
anteriormente
suficientes
interbloqueo
Resumiendo
Posibilidad
interbloqueo
Existencia
interbloqueo
Exclusión
mutua
Exclusión
mutua
expropiación
expropiación
Retención
espera
Retención
espera
Espera
circular
estrategias
tratamiento
interbloqueo
lugar
prevenir
interbloqueo
adoptando
política
elimine
condiciones
condiciones
enu-
meradas
previamente
lugar
predecir
interbloqueo
tomando
apropiadas
decisiones
dinámicas
basadas
actual
asignación
recursos
tercer
lugar
pue-
intentar
detectar
presencia
interbloqueo
cumplen
condiciones
ac-
ciones
pertinentes
recuperarse
continuación
estudiarán
sucesivamente
estrategias
6.2
PREVENCIÓN
INTERBLOQUEO
estrategia
prevención
interbloqueo
consiste
forma
simplificada
diseñar
siste-
ma
excluya
posibilidad
interbloqueo
clasificar
métodos
prevención
interbloqueo
categorías
método
indirecto
prevención
interblo-
queo
impedir
aparición
condiciones
necesarias
listadas
previamente
primeras
método
directo
prevención
interbloqueo
impide
produzca
es-
pera
circular
cuarta
condición
continuación
examinan
técnicas
relacionadas
condiciones
Concurrencia
Interbloqueo
inanición
267
Prácticamente
libros
texto
simplemente
enumeran
condiciones
condiciones
necesarias
interbloqueo
presentación
obscurece
aspectos
sutiles
cuarta
condición
espera
circular
fun-
damentalmente
condiciones
primeras
condiciones
decisiones
diseño
cuarta
circunstancia
ocurrir
dependiendo
secuencia
peticiones
liberaciones
realizada
procesos
inv
olucra-
asociación
espera
circular
condiciones
necesarias
conduce
inadecuada
distinción
prevención
predicción
Véase
SHUB90
SHUB03
discusión
tema
06-Capitulo
16/5/05
17:04
Página
267EXCLUSIÓN
MUTUA
general
condiciones
eliminarse
acceso
recurso
re-
exclusión
mutua
sistema
operativo
proporcionarlo
recursos
fi-
cheros
permitir
múltiples
accesos
lectura
acceso
exclusivo
escritu-
ras
caso
ocurrir
interbloqueo
proceso
requiere
permiso
escritura
RETENCIÓN
ESPERA
condición
retención
espera
eliminarse
estableciendo
proceso
solicitar
tiempo
recursos
requeridos
bloqueándolo
puedan
conceder
simultáneamente
peticiones
estrategia
insuficiente
maneras
lugar
proceso
quedarse
esperando
tiempo
solicitudes
re-
cursos
puedan
satisfacerse
continuado
recursos
lugar
recursos
asignados
proceso
permanecer
inutiliza-
periodo
tiempo
considerable
impide
pro-
cesos
problema
proceso
anticipado
recursos
requerirá
problema
práctico
creado
programación
modular
estruc-
tura
multihilo
aplicación
aplicación
necesitaría
consciente
recursos
solicitarán
niveles
módulos
solicitud
simultánea
EXPROPIACIÓN
condición
impedir
maneras
lugar
proceso
mantiene
recursos
deniega
petición
posterior
proceso
deberá
liberar
recursos
originales
necesario
solicitará
recurso
adicional
Alternativamente
pro-
ceso
solicita
recurso
proceso
mantiene
actualmente
sistema
operativo
expropiar
proceso
obligarle
liberar
recursos
esquema
impediría
interbloqueo
procesos
posean
prioridad
estrategia
práctica
aplica
recursos
cuyo
salvar
restau-
rar
caso
procesador
ESPERA
CIRCULAR
condición
espera
circular
impedir
definiendo
orden
lineal
distintos
tipos
recursos
proceso
asignado
recursos
tipo
posteriormente
pedir
recursos
cuyo
tipo
orden
posterior
R.
comprobar
estrategia
funciona
correctamente
asociar
índice
tipo
recurso
recurso
precede
Rj
ordenación
j.
continuación
su-
póngase
procesos
involucrados
interbloqueo
adquirido
solicitado
Rj
adquirido
Rj
solicitado
Ri
condición
imposible
puesto
implica
i.
ocurría
caso
retención
espera
prevención
espera
circular
ineficiente
ralentizando
procesos
denegando
innecesariamente
acceso
recurso
268
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
2686.3
PREDICCIÓN
INTERBLOQUEO
estrategia
resolver
problema
interbloqueo
difiere
sutilmente
prevención
interbloqueo
predicción
interbloqueo
prevención
interbloqueo
restringen
solicitudes
recurso
impedir
condiciones
interbloqueo
realiza
indirectamente
impidiendo
condiciones
gestión
necesarias
exclusión
mutua
retención
espera
expropiación
directamente
evitando
espera
circular
con-
ineficiente
recursos
ejecución
ineficiente
procesos
predicción
interbloqueo
permite
condiciones
necesarias
toma
decisiones
razonables
asegurarse
alcanza
punto
interbloqueo
predicción
per-
mite
concurrencia
prevención
predicción
interbloqueo
decide
dinámica-
mente
petición
actual
reserva
recurso
concede
potencialmente
causar
in-
terbloqueo
predicción
interbloqueo
requiere
conocimiento
futuras
solicitudes
recursos
proceso
sección
describen
técnicas
predecir
interbloqueo
iniciar
proceso
demandas
interbloqueo
conceder
petición
adicional
recurso
proceso
asignación
provocar
interbloqueo
DENEGACIÓN
INICIACIÓN
PROCESO
Considere
sistema
procesos
tipos
recursos
definen
si-
guientes
vectores
matrices
Recursos
R1
R2
Rm
cantidad
recurso
sistema
Disponibles
D1
D2
Dm
cantidad
recurso
asignada
proceso
N11
N12
N1
N21
N22
N2
Necesidad
Nij
necesidades
proceso
recurso
Nn1
Nn2
Nnm
A11
A12
A1
A21
A22
A2
Asignación
Aij
asignación
actual
proceso
recurso
An1
An2
Anm
Concurrencia
Interbloqueo
inanición
269
término
predicción
confuso
considerar
estrategias
estudiadas
sección
ejemplos
prevención
interbloqueo
impiden
efectivamente
aparición
interbloqueo
06-Capitulo
16/5/05
17:04
Página
269La
matriz
Necesidad
proporciona
requisitos
máximos
proceso
recurso
estando
fila
dedicada
proceso
información
declararse
antelación
proceso
predicción
interbloqueo
funcione
similar
matriz
Asig-
nación
proporciona
asignación
actual
proceso
cumplen
siguientes
relaciones
Rj
Dj
Aij
recursos
disponibles
asignados
i=1
Nij
Rj
proceso
necesitar
cantidad
recursos
existentes
sistema
Aij
Nij
proceso
asignados
recursos
cual-
quier
tipo
necesidades
originales
recurso
cantidades
definidas
establecer
política
predicción
interbloqueo
rechace
iniciar
proceso
requisitos
recursos
pudiesen
conducir
interbloqueo
inicia
proceso
Rj
N(n+1)j
Nij
i=1
iniciarse
proceso
satisfacer
necesidades
máximas
to-
procesos
actuales
proceso
estrategia
lejos
óptima
asume
caso
procesos
solicitarán
necesidades
máximas
simultáneamente
DENEGACIÓN
ASIGNACIÓN
RECURSOS
estrategia
denegación
asignación
recursos
denominada
algoritmo
banquero
propuso
DIJK65
comenzará
definiendo
conceptos
seguro
Considere
sistema
número
fijo
procesos
recursos
determinado
mo-
mento
proceso
cero
recursos
asignados
sistema
refleja
asigna-
ción
actual
recursos
procesos
consiste
vectores
Recursos
Dis-
ponibles
matrices
Necesidad
Asignación
definidas
anteriormente
seguro
secuencia
asignación
recursos
procesos
implica
interbloqueo
procesos
ejecutarse
completo
inseguro
evidentemente
seguro
ejemplo
muestra
conceptos
Figura
6.7a
muestra
sistema
consta
procesos
recursos
cantidad
recursos
R1
R2
R3
unidades
respectivamente
actual
asignaciones
pro-
cesos
dejando
disponibles
unidad
R2
unidad
R3
pregunta
seguro
responder
cuestión
plantea
pregunta
intermedia
procesos
270
Sistemas
operativos
Aspectos
internos
principios
diseño
Dijkstra
usó
nombre
analogía
problema
banca
clientes
desean
préstamo
dinero
corresponden
procesos
dinero
prestar
corresponde
recursos
Enunciado
problema
bancario
problema
especifica
continuación
banco
reserva
limitada
dinero
prestar
lista
clientes
línea
crédito
momento
cliente
optar
solicitar
préstamo
cantidad
corresponda
línea
crédito
garantía
haga
reembolso
habe
obtenido
cantidad
máxima
préstamo
banquero
rechazar
préstamo
cliente
riesgo
banco
quede
fondos
suficientes
satisfacer
solicitudes
préstamo
posteriores
permitirán
clientes
realicen
finalmente
reembolso
06-Capitulo
16/5/05
17:04
Página
270puede
ejecutarse
completo
recursos
disponibles
satisfacerse
recursos
disponibles
diferencia
requisitos
máximos
asignación
actual
pro-
ceso
términos
matrices
vectores
presentados
previamente
condición
cumplirse
proceso
ij
Aij
Dj
Claramente
caso
P1
unidad
R1
requiere
unidades
adicionales
R2
unidades
R3
asignando
uni-
dad
R3
proceso
P2
logra
asignados
recursos
máximos
requeridos
eje-
cutarse
completo
Asuma
cabo
complete
P2
retornar
recursos
conjunto
recursos
disponibles
resultante
muestra
Figura
6.7b
momento
repetiría
pregunta
cualquiera
procesos
restantes
completarse
caso
procesos
restantes
completarse
Supóngase
elige
P1
asig-
nándole
recursos
requeridos
completa
P1
devuelve
recursos
conjunto
dis-
ponibles
resultante
muestra
Figura
6.7c
continuación
completar
P3
alcanzándose
Figura
6.7d
Finalmente
completar
P4
instante
to-
procesos
ejecutado
completo
definido
Figura
6.7a
seguro
conceptos
sugieren
estrategia
predicción
interbloqueo
asegura
sistema
procesos
recursos
seguro
proceso
solicite
conjunto
recursos
supóngase
concede
petición
actualice
sistema
conse-
cuencia
determine
resultado
seguro
caso
afirmativo
concede
petición
caso
contrario
bloquea
proceso
seguro
conceder
petición
Considérese
definido
Figura
6.8a
Supóngase
P2
solicita
unidad
adicional
R1
R3
asume
concede
petición
resultante
Figura
6.7a
comprobado
previamente
seguro
seguro
conceder
petición
Retornando
Figura
6.8a
suponiendo
P1
solicita
unidad
R1
R3
asume
concede
petición
resultante
representado
Figura
6.8b
seguro
respuesta
proceso
necesitará
unidad
adicional
R1
disponible
basándose
predicción
interbloqueo
solicitud
P1
denegaría
P1
debería
bloquear
importante
resaltar
Figura
6.8b
interbloqueo
indica
posibili-
dad
interbloqueo
ejemplo
P1
ejecutara
liberaría
posteriormente
unidad
R1
R3
volver
necesitar
recursos
sucediera
sistema
retornaría
seguro
estrategia
predicción
inter-
bloqueo
predice
interbloqueo
certeza
anticipa
posibilidad
interbloqueo
asegu-
ra
posibilidad
Figura
6.9
versión
abstracta
lógica
predicción
interbloqueo
algoritmo
principal
muestra
estructura
datos
define
sistema
peticion
vector
define
recursos
solicitados
proceso
i.
lugar
prueba
asegurarse
petición
excede
necesidades
ori-
ginales
proceso
petición
válida
paso
determinar
satisfacer-
suficientes
recursos
disponibles
suspende
ejecución
proceso
caso
paso
determinar
seguro
satisfacer
petición
asignan
provisionalmente
recursos
proceso
formar
nuevo_estado
continuación
realiza
comprobación
seguro
utilizando
algoritmo
Figura
6.9c
Concurrencia
Interbloqueo
inanición
271
06-Capitulo
16/5/05
17:04
Página
271272
Sistemas
operativos
Aspectos
internos
principios
diseño
R1
R2
R3
P1
P2
P3
P4
Matriz
necesidad
R1
R2
R3
P1
P2
P3
P4
Matriz
asignación
R1
R2
R3
P1
P2
P3
P4
Vector
recursos
R1
R2
R3
Vector
disponibles
R1
R2
R3
inicial
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
R1
R2
R3
P2
ejecuta
completarse
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
R1
R2
R3
P1
ejecuta
completarse
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
R1
R2
R3
P3
ejecuta
completarse
Matriz
necesidad
Matriz
asignación
Vector
disponibles
Matriz
asignación
AMatriz
necesidad
Vector
recursos
Vector
recursos
Vector
disponibles
Vector
disponibles
Matriz
asignación
AMatriz
necesidad
Vector
recursos
Figura
6.7
Determinación
seguro
06-Capitulo
16/5/05
17:04
Página
272La
predicción
interbloqueo
ventaja
necesario
expropiar
procesos
retroceder
ejecución
ocurre
detección
interbloqueo
restrictivo
prevención
interbloqueo
restricciones
establecerse
anticipado
requisitos
máximos
recursos
proceso
procesos
involucrados
independientes
orden
ejecutan
restringido
requisito
sincronización
número
fijo
recursos
asignar
proceso
terminar
mantenga
recursos
6.4
DETECCIÓN
INTERBLOQUEO
estrategias
prevención
interbloqueo
conservadoras
resuelven
problema
in-
terbloqueo
limitando
acceso
recursos
imponiendo
restricciones
procesos
extre-
mo
contrario
estrategia
detección
interbloqueo
limita
acceso
recursos
restringe
acciones
procesos
detección
interbloqueo
recursos
pedidos
conceden
procesos
Periódicamente
sistema
operativo
realiza
algoritmo
permite
detectar
condición
espera
circular
descrita
anteriormente
condición
ilustra-
Figura
6.6
Concurrencia
Interbloqueo
inanición
273
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
R1
R2
R3
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
P1
P2
P3
P4
R1
R2
R3
R1
R2
R3
P1
solicita
unidad
R1
R3
Matriz
necesidad
Matriz
asignación
inicial
Vector
disponibles
DVector
recursos
Matriz
necesidad
Matriz
asignación
Vector
recursos
Vector
disponibles
Figura
6.8
Determinación
inseguro
06-Capitulo
16/5/05
17:04
Página
273274
Sistemas
operativos
Aspectos
internos
principios
diseño
struct
int
recursos[m
int
disponibles[m
int
necesidad[n][m
int
asignacion[n][m
if
asignacion
peticion
necesidad
error
petición
necesidad
else
if
peticion
disponibles
suspender
proceso
else
simular
asignación
definir
nuevo_estado
asignacion
asignacion
peticion
disponibles
disponibles
peticion
if
seguro(nuevo_estado
cabo
asignación
else
restaurar
original
suspender
proceso
boolean
seguro
int
disponibles_actual[m
proceso
resto[<número
procesos
disponibles_actual
disponibles
resto
procesos
while
encontrar
proceso
resto
necesidad
asignacion
disponibles_actual
if
encontrado
simular
ejecución
disponibles_actual
disponibles_actual
asignacion
resto
resto
else
falso
return
resto
null
estructuras
datos
globales
algoritmo
asignación
recursos
algoritmo
comprobar
seguro
algoritmo
banquero
Figura
6.9
Lógica
predicción
interbloqueo
06-Capitulo
16/5/05
17:04
Página
274ALGORITMO
DETECCIÓN
INTERBLOQUEO
comprobación
interbloqueo
tanta
frecuencia
petición
recurso
frecuencia
dependiendo
probabilidad
ocurra
inter-
bloqueo
comprobación
petición
recurso
ventajas
conlleva
de-
tección
temprana
algoritmo
relativamente
sencillo
basado
cambios
gra-
duales
sistema
comprobaciones
frecuentes
consumen
considerable
tiempo
procesador
algoritmo
usual
detección
interbloqueo
describe
COFF71
utilizan
matriz
Asignación
vector
Disponibles
descritos
sección
previa
define
matriz
solicitud
ij
representa
cantidad
recursos
tipoj
solici-
tados
proceso
i.
algoritmo
actúa
marcando
procesos
interbloqueo
Ini-
cialmente
procesos
marcar
continuación
llevan
cabo
siguientes
pasos
marca
proceso
fila
matriz
Asignación
completamente
cero
inicia
vector
temporal
asignándole
vector
Disponibles
busca
índice
proceso
esté
marcado
actualmente
fila
i-ésima
menor
T.
Sik
Tk
m.
fila
algo-
ritmo
termina
fila
cumpla
marca
proceso
suma
fila
correspondiente
matriz
asignación
T.
ejecuta
Tk
Aik
m.
continua-
ción
vuelve
tercer
paso
interbloqueo
procesos
marcar
algoritmo
proceso
marcar
interbloqueo
estrategia
algoritmo
encontrar
proceso
cuyas
pe-
ticiones
recursos
puedan
satisfacerse
recursos
disponibles
continuación
asumir
conceden
recursos
proceso
ejecuta
terminar
libera
recursos
algorit-
mo
continuación
busca
satisfacer
peticiones
proceso
Nótese
algoritmo
ga-
rantiza
prevención
interbloqueo
dependerá
orden
concedan
peticiones
fu-
turas
labor
determinar
actualmente
interbloqueo
utilizar
Figura
6.10
mostrar
algoritmo
detección
interbloqueo
algo-
ritmo
actúa
Marca
P4
recursos
asignados
Fija
petición
proceso
P3
menor
marca
P3
ejecuta
proceso
marcar
fila
menor
T.
al-
goritmo
termina
algoritmo
concluye
marcar
P1
P2
indicando
procesos
interbloqueo
RECUPERACIÓN
detectado
interbloqueo
necesita
estrategia
recuperarlo
si-
guientes
estrategias
listadas
orden
sofisticación
creciente
posibles
Concurrencia
Interbloqueo
inanición
275
06-Capitulo
16/5/05
17:04
Página
2751
Abortar
procesos
involucrados
interbloqueo
crea
usuales
solución
adoptada
sistemas
operativos
Retroceder
proceso
interbloqueo
punto
control
checkpoint
previamente
definido
rearrancar
procesos
requiere
implementen
sistema
me-
canismos
retroceso
rearranque
riesgo
técnica
repetirse
inter-
bloqueo
original
indeterminismo
procesamiento
concurrente
asegu-
rar
probablemente
suceda
Abortar
sucesivamente
procesos
interbloqueo
deje
existir
orden
seleccionan
procesos
abortarlos
debería
basado
criterios
impliquen
coste
mínimo
aborto
invocar
algoritmo
detección
comprobar
interbloqueo
Expropiar
sucesivamente
recursos
interbloqueo
deje
existir
tercer
punto
debería
utilizar
selección
basada
coste
requiere
nue-
invocación
algoritmo
detección
expropiación
proceso
expropiado
recurso
retroceder
punto
adquisición
recurso
Puntos
criterio
selección
siguientes
elige
pro-
ceso
menor
cantidad
tiempo
procesador
consumida
menor
cantidad
salida
producida
tiempo
restante
estimado
menor
número
recursos
asignados
menor
prioridad
cantidades
fáciles
medir
tiempo
restante
estimado
particularmente
difícil
aplicación
excepción
criterio
basado
prioridad
indicación
coste
usuario
contraposición
coste
siste-
ma
276
Sistemas
operativos
Aspectos
internos
principios
diseño
R1
R2
R3
R4
R5
P1
P2
P3
P4
Matriz
solicitud
R1
R2
R3
R4
R5
P1
P2
P3
P4
R1
R2
R3
R4
R5
Vector
recursos
R1
R2
R3
R4
R5
Vector
disponibles
Matriz
asignación
Figura
6.10
Ejemplo
detección
interbloqueo
06-Capitulo
16/5/05
17:04
Página
2766.5
ESTRATEGIA
INTEGRADA
TRATAMIENTO
INTERBLOQUEO
sugiere
Tabla
6.1
ventajas
desventajas
estrategias
tratamiento
interbloqueo
intentar
diseñar
solución
sistema
operativo
utilice
estrategias
eficiente
estrategias
distintas
situaciones
HOWA73
sugiere
técnica
Agrupar
recursos
diversas
clases
recursos
Utilizar
estrategia
orden
lineal
definida
previamente
prevenir
espera
circular
im-
pidiendo
interbloqueos
clases
recursos
clase
recursos
algoritmo
apropiado
clase
ejemplo
técnica
considere
siguientes
clases
recursos
Espacio
intercambio
Bloques
memoria
almacenamiento
secundario
utilizados
expulsar
procesos
Recursos
proceso
Dispositivos
asignables
dispositivos
cinta
ficheros
Memoria
principal
Asignable
procesos
páginas
segmentos
Recursos
internos
canales
S.
orden
lista
representa
orden
asignan
recursos
orden
ra-
zonable
considerando
secuencia
pasos
seguir
proceso
tiempo
vida
clase
utilizar
siguientes
estrategias
Espacio
intercambio
prevención
interbloqueos
obligando
asignen
tiempo
recursos
necesitados
vayan
usarse
estrategia
pre-
vención
retención
espera
estrategia
razonable
conocen
requisitos
má-
ximos
almacenamiento
frecuentemente
predicción
po-
sibilidad
factible
Recursos
proceso
predicción
usualmente
efectiva
categoría
razonable
esperar
procesos
declaren
anticipadamente
recursos
clase
requerirán
prevención
ordenamiento
recursos
clase
Memoria
principal
prevención
expropiación
estrategia
apropiada
memoria
principal
expropia
proceso
simplemente
expulsado
memoria
secundaria
liberando
espacio
resolver
interbloqueo
Recursos
internos
utilizarse
prevención
ordenamiento
recursos
6.6
PROBLEMA
FILÓSOFOS
COMENSALES
sección
problema
filósofos
comensales
presentado
Dijkstra
DIJK71
filósofos
viven
casa
mesa
preparada
Básicamente
vida
filósofo
consiste
pensar
comer
años
pensando
filósofos
única
comida
contribuye
fuerza
mental
espa-
guetis
falta
habilidad
manual
filósofo
necesita
tenedores
comer
espaguetis
Concurrencia
Interbloqueo
inanición
277
06-Capitulo
16/5/05
17:04
Página
277La
disposición
comida
simple
Figura
6.11
mesa
redonda
colocado
cuenco
servir
espaguetis
platos
filósofo
tenedores
fi-
lósofo
comer
dirige
sitio
asignado
mesa
utilizando
tenedores
situa-
plato
toma
come
espaguetis
problema
diseñar
ritual
algoritmo
permita
filósofos
comer
algoritmo
satisfacer
exclusión
mutua
filósofos
puedan
utilizar
tenedor
evitando
interbloqueo
inanición
caso
término
sentido
literal
algorítmico
problema
parezca
importante
relevante
muestra
problemas
básicos
interbloqueo
inanición
intenta
desarrollar
soluciones
re-
velan
dificultades
programación
concurrente
ejemplo
véase
GING90
Asimismo
problema
filósofos
comensales
considerarse
representativo
problemas
tratan
coordinación
recursos
compartidos
ocurrir
aplica-
ción
incluye
hilos
concurrentes
ejecución
consiguiente
problema
caso
prueba
estándar
evaluar
estrategias
sincronización
SOLUCIÓN
UTILIZANDO
SEMÁFOROS
Figura
6.12
muestra
solución
utilizando
semáforos
filósofo
toma
tenedor
izquierda
derecha
filósofo
terminado
comer
vuelve
colo-
car
tenedores
mesa
solución
desgraciadamente
conduce
interbloqueo
filósofos
hambrientos
tiempo
sentarán
asirán
tenedor
iz-
quierda
tenderán
mano
tomar
tenedor
indecorosa
posición
filósofos
pasarán
hambre
278
Sistemas
operativos
Aspectos
internos
principios
diseño
P3
P0
P2
P4
P1
Figura
6.11
Disposición
filósofos
comensales
06-Capitulo
16/5/05
17:04
Página
278Para
superar
riesgo
interbloqueo
comprar
tenedores
adicionales
solu-
ción
higiénica
enseñar
filósofos
comer
espaguetis
tenedor
alternati-
incorporar
asistente
permitiera
filósofos
tiempo
comedor
máximo
filósofos
sentados
filósofo
acceso
tenedores
Figura
6.13
muestra
solución
utilizando
semáforos
solución
libre
interbloqueos
inanición
SOLUCIÓN
UTILIZANDO
MONITOR
Figura
6.14
muestra
solución
problema
filósofos
comensales
utilizando
monitor
define
vector
variables
condición
variable
condición
tenedor
Es-
tas
variables
condición
utilizan
permitir
filósofo
espere
esté
disponible
tenedor
vector
tipo
booleano
registra
disponibilidad
tenedor
ver-
daderosignifica
tenedor
disponible
monitor
consta
procedimientos
proce-
dimiento
obtiene_tenedores
utiliza
filósofo
obtener
tenedores
situado
iz-
quierda
derecha
tenedores
disponibles
proceso
corresponde
filósofo
encola
variable
condición
correspondiente
permite
proceso
filósofo
monitor
utiliza
procedimiento
libera_tenedorespara
queden
disponi-
bles
tenedores
Nótese
estructura
solución
similar
solución
semáforo
propuesta
Figura
6.12
casos
filósofo
toma
tenedor
izquierda
derecha
diferencia
solución
semáforo
solución
monitor
sufre
interbloqueos
proceso
momento
monitor
ejemplo
Concurrencia
Interbloqueo
inanición
279
programa
filosofos_comensales
semaforo
tenedor
int
void
filosofo
int
while
piensa
wait
tenedor[i
wait
tenedor[(i+1
mod
come
signal
tenedor[(i+1
mod
signal
tenedor[i
void
main
paralelos
filosofo
filosofo
filosofo
filosofo
filosofo
Figura
6.12
solución
problema
filósofos
comensales
06-Capitulo
16/5/05
17:04
Página
279garantiza
proceso
filósofo
monitor
asir
tenedor
derecha
tome
izquierda
filósofo
derecha
oportunidad
asir
tenedor
izquierda
derecha
filósofo
6.7
MECANISMOS
CONCURRENCIA
UNIX
UNIX
proporciona
diversos
mecanismos
comunicación
sincronización
procesos
sección
revisarán
importantes
Tuberías
pipes
Mensajes
Memoria
compartida
Semáforos
Señales
tuberías
mensajes
memoria
compartida
utilizarse
comunicar
datos
procesos
semáforos
señales
utilizan
disparar
acciones
procesos
280
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
filosofos_comensales
semaforo
tenedor
semaforo
comedor
int
void
filosofo
int
while
piensa
wait
comedor
wait
tenedor[i
wait
tenedor[(i+1
mod
come
signal
tenedor[(i+1
mod
signal
tenedor[i
signal
comedor
void
main
paralelos
filosofo
filosofo
filosofo
filosofo
filosofo
Figura
6.13
solución
problema
filósofos
comensales
06-Capitulo
16/5/05
17:04
Página
280Concurrencia
Interbloqueo
inanición
281
Figura
6.14
solución
problema
filósofos
comensales
usando
monitor
monitor
controlador_de_comensales
cond
TenedorListo[5
variable
condición
sincronizar
boolean
tenedor
disponibilidad
tenedor
void
obtiene_tenedores
int
id_pr
id_pr
número
ident
filósofo
int
izquierdo
id_pr
int
derecho
id_pr++
concede
tenedor
izquierdo
if
tenedor(izquierdo
cwait(TenedorListo[izquierdo
encola
variable
condición
tenedor(izquierdo
falso
concede
tenedor
derecho
if
tenedor(derecho
cwait(TenedorListo[derecho
encola
variable
condición
tenedor(derecho
falso
void
libera_tenedores
int
id_pr
int
izquierdo
id_pr
int
derecho
id_pr++
libera
tenedor
izquierdo
if
empty(TenedorListo[izquierdo
espera
tenedor
tenedor(izquierdo
else
despierta
proceso
espera
tenedor
csignal(TenedorListo[izquierdo
/*libera
tenedor
derecho*/
if
empty(TenedorListo[derecho
espera
tenedor
tenedor(derecho
else
despierta
proceso
espera
tenedor
csignal(TenedorListo[derecho
void
filosofo[k=0
clientes
filósofos
while
piensa
obtiene_tenedores(k
cliente
solicita
tenedores
vía
monitor
come
espaguetis
libera_tenedores(k
cliente
libera
tenedores
vía
monitor
06-Capitulo
16/5/05
17:04
Página
281TUBERÍAS
contribuciones
significativas
UNIX
desarrollo
sistemas
operativos
tubería
Inspirado
concepto
corrutina
RITC84
tubería
buffer
circular
permite
procesos
comuniquen
siguiendo
modelo
productor-consumidor
cola
tipo
entrar
salir
escribe
proceso
lee
crea
tubería
establece
tamaño
fijo
bytes
proceso
intenta
escribir
tubería
petición
escritura
ejecuta
inmediatamente
suficiente
espacio
caso
contrario
proceso
bloquea
similar
proceso
lee
bloquea
intenta
leer
bytes
actualmente
tubería
caso
contrario
petición
lectura
eje-
cuta
inmediatamente
sistema
operativo
asegura
exclusión
mutua
momento
acceder
tubería
único
proceso
tipos
tuberías
nombre
nombre
procesos
relacionados
com-
tuberías
nombre
procesos
compartir
tuberías
nombre
relacionados
MENSAJES
mensaje
conjunto
bytes
tipo
asociado
UNIX
proporciona
llamadas
sistema
msgsnd
msgrcv
procesos
puedan
transferencia
mensajes
Asociada
proceso
cola
mensajes
funciona
buzón
emisor
mensaje
especifica
tipo
mensaje
mensaje
envía
tipo
utilizarse
criterio
selección
receptor
receptor
recuperar
mensajes
orden
llegada
tipo
proceso
bloqueará
intente
enviar
mensaje
cola
llena
proceso
bloqueará
intente
leer
mensaje
cola
vacía
proceso
intenta
leer
mensaje
tipo
presente
mensaje
tipo
proceso
bloquea
MEMORIA
COMPARTIDA
forma
rápida
comunicación
procesos
proporcionada
UNIX
memoria
compar-
tida
bloque
memoria
virtual
compartido
múltiples
procesos
procesos
leen
escriben
memoria
compartida
utilizando
instrucciones
máquina
utilizan
leer
escribir
partes
espacio
memoria
virtual
permiso
determinado
proceso
lectura
lectura
escritura
estableciéndose
forma
individual
proceso
restricciones
exclusión
mutua
mecanismo
memoria
com-
partida
proporcionar
procesos
utilizan
memoria
compartida
SEMÁFOROS
llamadas
sistema
semáforos
UNIX
System
generalización
funciones
semWaity
semSignaldefinidas
Capítulo
operaciones
simultánea-
mente
operaciones
incremento
decremento
corresponder
valores
mayores
núcleo
realiza
operaciones
solicitadas
atómicamente
proceso
acce-
der
semáforo
hayan
completado
operaciones
282
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
282Un
semáforo
consta
siguientes
elementos
valor
actual
semáforo
identificador
proceso
operó
semáforo
número
procesos
espera
valor
semáforo
valor
actual
número
procesos
espera
valor
semáforo
cero
Asociado
semáforo
colas
procesos
bloqueados
semáforo
semáforos
crean
realmente
conjuntos
constando
conjunto
semáforos
semáforos
llamada
sistema
semct1que
permite
valores
semá-
foros
conjunto
fijen
tiempo
llamada
sistema
semop
toma
argumento
lista
operaciones
semáforo
definida
semáforos
conjunto
realiza
llamada
núcleo
cabo
sucesivamente
operaciones
indicadas
operación
función
real
especifica
valor
sem_op
existiendo
siguientes
posibilidades
sem_op
positivo
núcleo
incrementa
valor
semáforo
despierta
pro-
cesos
espera
valor
semáforo
incremente
sem_opes
núcleo
comprueba
valor
semáforo
valor
semáforo
núcleo
continúa
operaciones
lista
caso
contrario
núcleo
incre-
menta
número
procesos
espera
semáforo
valor
suspende
proceso
espere
evento
valor
semáforo
haga
sem_op
negativo
valor
absoluto
menor
valor
sel
semáforo
núcleo
añade
sem_op(un
número
negativo
valor
semáforo
resultado
núcleo
des-
pierta
procesos
espera
semáforo
tome
valor
sem_op
negativo
valor
absoluto
valor
semáforo
núcleo
sus-
pende
proceso
espera
evento
valor
semáforo
incremente
generalización
semáforos
proporciona
considerable
flexibilidad
sincronización
coordinación
procesos
SEÑALES
señal
mecanismo
software
informa
proceso
existencia
eventos
asíncro-
señal
similar
interrupciones
hardware
emplea
prioridades
señales
tratan
señales
ocurren
tiempo
presentan
proceso
orden
particular
procesos
enviar
señales
núcleo
envíe
señales
interna-
mente
entregar
señal
actualiza
campo
tabla
procesos
correspondiente
pro-
ceso
enviando
señal
señal
mantiene
único
bit
señales
determinado
tipo
encolarse
señal
procesa
proceso
despierte
ejecutar
proceso
retornando
llamada
sistema
proceso
responder
señal
realizando
acción
defecto
ejemplo
terminación
eje-
cutando
función
manejo
señal
ignorando
señal
Tabla
6.2
enumera
señales
definidas
UNIX
SVR4
Concurrencia
Interbloqueo
inanición
283
06-Capitulo
16/5/05
17:04
Página
283
abla
6.2
Señales
UNIX
Valor
Nombre
Descripción
01
SIGHUP
Desconexión
enviada
proceso
núcleo
asume
usuario
proceso
trabajo
útil
02
SIGINT
Interrupción
03
SIGQUIT
Abandonar
enviada
usuario
provocar
parada
proceso
generación
volcado
memoria
core
dump
04
SIGILL
Instrucción
ilegal
05
SIGTRAP
Trap
traza
activa
ejecución
código
seguimiento
ejecución
proceso
06
SIGIOT
Instrucción
IOT
07
SIGEMT
Instrucción
EMT
08
SIGFPE
Excepción
coma
flotante
09
SIGKILL
Matar
terminar
proceso
10
SIGBUS
Error
bus
SIGSEGV
Violación
segmento
proceso
intenta
acceder
posición
espacio
direcciones
12
SIGSYS
Argumento
erróneo
llamada
sistema
13
SIGPIPE
Escritura
tubería
lectores
asociados
14
SIGALRM
Alarma
emitida
proceso
desea
recibir
señal
transcurra
determinado
periodo
tiempo
15
SIGTERM
Terminación
software
16
SIGUSR1
Señal
definida
usuario
17
SIGUSR2
Señal
definida
usuario
18
SIGCHLD
Muerte
proceso
hijo
19
SIGPWR
Interrupción
suministro
energía
6.8
MECANISMOS
CONCURRENCIA
NÚCLEO
LINUX
Linux
incluye
mecanismos
concurrencia
presentes
sistemas
UNIX
SVR4
incluyendo
tuberías
mensajes
memoria
compartida
señales
Linux
2.6
incluye
abun-
dante
conjunto
mecanismos
concurrencia
especialmente
destinados
ejecutando
hilo
núcleo
mecanismos
utilizados
núcleo
proporcionar
concurrencia
ejecución
código
núcleo
sección
estudiará
me-
canismos
concurrencia
núcleo
Linux
OPERACIONES
ATÓMICAS
Linux
proporciona
conjunto
funciones
garantiza
operaciones
variable
atómicas
operaciones
utilizarse
evitar
condiciones
carrera
sencillas
operación
atómica
ejecuta
interrupción
interferencia
sistema
uniprocesador
hilo
realiza
operación
atómica
verse
interrumpido
comenzado
opera-
284
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
284ción
termina
sistema
multiprocesador
establece
cerrojo
variable
operando
impedir
acceso
hilos
complete
operación
Linux
definen
tipos
operaciones
atómicas
operaciones
enteros
operan
variable
tipo
entero
operaciones
mapas
bits
operan
bit
mapa
bits
Tabla
6.3
operaciones
implementarse
arquitectura
pre-
tenda
ejecute
Linux
arquitecturas
instrucciones
lenguaje
ensamblador
corresponden
directamente
operaciones
atómicas
arquitecturas
utiliza
ope-
ración
establece
cerrojo
bus
memoria
garantizar
operación
atómica
abla
6.3
Operaciones
atómicas
Linux
Operaciones
atómicas
enteros
ATOMIC_INT
int
declaración
inicia
atomic_t
valor
int
atomic_read(atomic_t
Lee
valor
entero
void
atomic_set(atomic_t
int
Asigna
valor
entero
void
atomic_add(int
atomic_t
Suma
void
atomic_sub(int
atomic_t
Resta
void
atomic_inc(atomic_t
Suma
void
atomic_dec(atomic_t
Resta
int
atomic_sub_and_test(int
atomic_t
Resta
devuelve
resultado
cero
caso
contrario
int
atomic_dec_and_test(atomic_t
Resta
devuelve
resultado
cero
caso
contrario
Operaciones
atómicas
mapas
bits
void
set_bit(int
void
dir
Pone
bit
mapa
bits
apuntado
dir
void
clear_bit(int
void
dir
Pone
bit
mapa
bits
apuntado
dir
void
change_bit(int
void
dir
Invierte
valor
bit
mapa
bits
apuntado
dir
int
test_and_set_bit(int
void
dir
Pone
bit
mapa
bits
apuntado
dir
devuelve
valor
previo
int
test_and_clear_bit(int
void
dir
Pone
bit
mapa
bits
apuntado
dir
devuelve
valor
previo
int
test_and_change_bit(int
void
dir
Invierte
valor
bit
mapa
bits
apuntado
dir
devuelve
valor
previo
int
test_bit(int
void
dir
Devuelve
valor
bit
mapa
bits
apuntado
dir
operaciones
atómicas
enteros
utiliza
tipo
datos
especial
atomic_t
operaciones
atómicas
enteros
utilizar
tipo
datos
permitién-
dose
operación
LOVE04
enumera
siguientes
ventajas
restricciones
Concurrencia
Interbloqueo
inanición
285
06-Capitulo
16/5/05
17:04
Página
2851
operaciones
atómicas
utilizan
variables
circunstan-
cias
desprotegidas
condiciones
carrera
variables
tipo
datos
protegidas
inapropiado
operaciones
atómicas
compilador
optimizar
erróneamente
acceso
valor
ejemplo
utilizando
alias
dirección
memoria
correcta
tipo
datos
sirve
esconder
diferencias
específicas
arquitectura
implementación
habitual
tipos
datos
enteros
atómicos
implementación
contadores
operaciones
atómicas
mapas
bits
operan
secuencia
bits
almacenada
posición
memoria
indicada
variable
tipo
puntero
equivalente
tipo
datos
atomic_trequerido
operaciones
atómicas
enteros
operaciones
atómicas
mecanismo
simple
sincronización
núcleo
construir
mecanismos
cerrojo
complejos
CERROJOS
CÍCLICOS
técnica
frecuentemente
utilizada
proteger
sección
crítica
Linux
cerrojo
cíclico
spinlock
determinado
momento
único
hilo
adquirir
cerrojo
cí-
clico
hilo
intente
adquirir
cerrojo
seguirá
intentándolo
forma
cí-
clica
adquirirlo
Esencialmente
cerrojo
cíclico
construye
usando
posi-
ción
memoria
contiene
valor
entero
hilo
comprueba
entrar
sección
crítica
valor
hilo
asigna
valor
entra
sección
crítica
valor
cero
hilo
comprueba
continuamente
valor
cero
cerro-
jo
cíclico
fácil
implementar
desventaja
hilos
quedado
sección
crítica
continúan
ejecutando
espera
activa
ce-
rrojos
cíclicos
efectivos
situaciones
tiempo
espera
adquirir
cerro-
jo
prevé
orden
magnitud
inferior
correspondiente
cambios
contexto
forma
básica
cerrojo
cíclico
spin_lock(&cerrojo
sección
crítica
spin_unlock(&cerrojo
CERROJOS
CÍCLICOS
BÁSICOS
cerrojo
cíclico
básico
contraposición
cerrojo
cíclico
escritura
lectura
explicado
poste-
riormente
presenta
modalidades
Tabla
6.4
Sencillo
código
sección
crítica
ejecuta
manejadores
interrupciones
interrupciones
inhabilitadas
ejecución
sección
crítica
uti-
lizar
cerrojo
cíclico
simple
afecta
interrupciones
procesador
ejecuta
286
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
286•
irq
interrupciones
inhabilitadas
debería
utilizar
tipo
cerrojo
cíclico
irqsave
conoce
interrupciones
estarán
habilitadas
inhabilitadas
mo-
mento
ejecución
debería
utilizar
versión
adquiere
cerrojo
salva
actual
interrupciones
procesador
local
restaurará
libere
cerrojo
bh
ocurre
interrupción
manejador
interrupciones
correspondiente
realiza
cantidad
mínima
trabajo
necesaria
fragmento
código
llamado
mitad
inferior
bot-
tom
half
realiza
resto
trabajo
asociado
interrupción
permitiendo
interrup-
ción
actual
habilite
cerrojo
cíclico
bhse
inhabilitar
habilitar
ejecución
rutinas
tipo
mitad
inferior
evitar
conflictos
sección
crí-
tica
protegida
abla
6.4
Cerrojos
cíclicos
Linux
void
spin_lock(spinlock_t
cerrojo
Adquiere
cerrojo
especificado
comprobando
cíclicamente
valor
esté
disponible
void
spin_lock_irq(spinlock_t
cerrojo
spin_lock
prohibiendo
interrupciones
procesador
local
void
spin_lock_irqsave(spinlock_t
cerrojo
spin_lock_irq
guardando
unsigned
long
indicadores
actual
interrupciones
indicadores
void
spin_lock_bh(spinlock_t
cerrojo
spin_lock
prohibiendo
ejecución
mitades
inferiores
void
spin_unlock(spinlock_t
cerrojo
Libera
cerrojo
especificado
void
spin_unlock_irq(spinlock_t
cerrojo
Libera
cerrojo
especificado
habilita
interrupciones
locales
void
spin_unlock_irqrestore(spinlock_t
Libera
cerrojo
especificado
restaura
cerrojo
unsigned
long
indicadores
interrupciones
locales
void
spin_unlock_bh(spinlock_t
cerrojo
Libera
cerrojo
especificado
habilita
ejecución
mitades
inferiores
void
spin_lock_init(spinlock_t
cerrojo
Inicia
cerrojo
especificado
int
spin_trylock(spinlock_t
cerrojo
Intenta
adquirir
cerrojo
especificado
devolviendo
valor
distinto
cero
posee
proceso
cero
caso
contrario
int
spin_is_locked(spinlock_t
cerrojo
Devuelve
valor
distinto
cero
cerrojo
posee
proceso
cero
caso
contrario
cerrojo
cíclico
simple
utiliza
programador
datos
protegidos
acce-
derse
manejador
interrupción
rutina
tipo
mitad
inferior
caso
contrario
tipo
cerrojo
cíclico
apropiado
cerrojos
cíclicos
implementan
sistema
uniprocesador
frente
máquina
multiprocesadora
uniprocesador
siguientes
considera-
ciones
inhabilita
opción
expulsión
núcleo
hilo
núcleo
verse
interrumpido
eliminan
cerrojos
cíclicos
tiempo
compilación
necesarios
activa
expulsión
núcleo
permite
interrupciones
elimi-
nan
cerrojos
cíclicos
realiza
comprobación
posición
memoria
Concurrencia
Interbloqueo
inanición
287
06-Capitulo
16/5/05
17:04
Página
287asociada
cerrojo
cíclico
implementa
simplemente
código
habilita
des-
habilita
interrupciones
sistema
multiprocesador
cerrojo
cíclico
compila
código
realiza
realmente
comprobación
posición
memoria
asociada
cerrojo
cíclico
utili-
zación
mecanismo
cerrojo
cíclico
programa
permite
independiente
eje-
cuta
sistema
uniprocesador
multiprocesador
CERROJO
CÍCLICO
LECTURA-ESCRITURA
cerrojo
cíclico
lectura-escritura
mecanismo
permite
grado
concurrencia
núcleo
cerrojo
cíclico
básico
cerrojo
cíclico
lectura-escritura
permite
múltiples
hilos
tengan
acceso
simultáneo
estructura
datos
pretenden
acceso
lectura
acceso
exclusivo
cerrojo
cíclico
hilo
desea
actualizar
estructura
da-
tos
cerrojo
cíclico
lectura-escritura
consta
contador
lectores
24
bits
indica-
dor
desbloqueo
interpretación
Contador
Indicador
Interpretación
cerrojo
cíclico
disponible
cerrojo
cíclico
adquirido
escritura
hilo
cerrojo
cíclico
adquirido
lectura
hilos
Inválido
ocurre
cerrojo
cíclico
básico
cerrojo
cíclico
lectura-escritura
versiones
simples
tipo
irqy
tipo
irqsave
Nótese
cerrojo
cíclico
lectura-escritura
favorece
lectores
frente
escritores
lectores
mantienen
cerrojo
cíclico
lector
escritor
obtener
cerrojo
cíclico
incorporar
lectores
cerrojo
cíclico
escritor
esperando
SEMÁFOROS
nivel
usuario
Linux
proporciona
interfaz
semáforos
corresponde
UNIX
SVR4
Internamente
proporciona
implementación
semáforos
código
forma
núcleo
invocar
semáforos
núcleo
accederse
directamente
programa
usuario
llamadas
sistema
implemen-
funciones
núcleo
eficientes
semáforos
visibles
usuario
Linux
proporciona
tipos
mecanismos
semáforos
núcleo
semáforos
binarios
se-
máforos
contador
semáforos
lectura-escritura
SEMÁFOROS
BINARIOS
CONTADOR
semáforos
binarios
contador
definidos
Linux
2.6
Tabla
6.5
funcionali-
dad
descrita
tipos
semáforos
Capítulo
utilizan
nombres
fun-
288
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
288ción
down
up
funciones
denominó
semWait
semSignal
Capítulo
respectivamente
semáforo
contador
inicia
utilizando
función
sema_init
semáforo
nombre
asigna
valor
inicial
semáforos
binarios
llamados
MUTEX
Linux
inician
funciones
init_MUTEX
init_MUTEX_LOCKED
inician
semáforo
res-
pectivamente
Linux
proporciona
versiones
operación
down
semWait
función
down
corresponde
operación
tradicional
semWait
hilo
comprue-
ba
valor
semáforo
bloquea
disponible
hilo
despertará
produzca
correspondiente
operación
up
semáforo
Obsérvese
nombre
función
semáforos
contador
binarios
función
down_interruptible
permite
hilo
reciba
responda
señal
nú-
cleo
bloqueado
operación
down
señal
despierta
hilo
función
down_interruptible
incrementa
valor
contador
semáforo
devuelve
código
error
conocido
Linux
-EINTR
valor
indica
hilo
función
se-
máforo
abortado
efecto
hilo
visto
forzado
abandonar
semáforo
característica
útil
manejadores
dispositivos
servicios
conve-
niente
abortar
operación
semáforo
función
down_trylock
permite
intentar
adquirir
semáforo
bloqueado
se-
máforo
disponible
adquiere
caso
contrario
función
devuelve
valor
distinto
cero
bloquear
hilo
SEMÁFOROS
LECTURA-ESCRITURA
semáforo
lectura-escritura
clasifica
usuarios
lectores
escritores
permitiendo
múltiples
lectores
concurrentes
escritores
único
escritor
lectores
realidad
semáfo-
ro
funciona
semáforo
contador
lectores
semáforo
binario
MU-
TEX
escritores
Tabla
6.5
muestra
operaciones
básicas
semáforos
lectura-
escritura
semáforos
lectura-escritura
utilizan
bloqueo
ininterrumpible
versión
operaciones
down
BARRERAS
arquitecturas
compiladores
hardware
procesador
cambiar
orden
accesos
memoria
código
fuente
optimizar
rendimiento
cambios
orden
llevan
cabo
optimizar
pipeline
instrucciones
procesador
algoritmos
realizan
contienen
comprobaciones
aseguran
violan
dependencias
datos
ejemplo
código
modificar
orden
posición
memoria
actualice
haga
posición
memoria
a.
código
Concurrencia
Interbloqueo
inanición
289
06-Capitulo
16/5/05
17:04
Página
289no
cambiar
orden
accesos
memoria
ocasiones
im-
portante
lecturas
escrituras
ejecuten
orden
especificado
información
hilo
dispositivo
hardware
fijar
orden
ejecuta
instrucción
Linux
proporciona
mecanismo
barrera
memoria
Tabla
6.6
enumera
funciones
importantes
definen
mecanismo
operación
rmb
asegura
produce
lectura
barrera
definida
lugar
ocupa
rmb
código
Igualmente
operación
wmb
asegura
produce
escritura
barrera
definida
lugar
ocupa
wmb
código
operación
mb
proporciona
barrera
lectura
escritura
290
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
6.5
Semáforos
Linux
Semáforos
tradicionales
void
sema_init(struct
semaphore
sem
int
cont
Inicia
semáforo
creado
dinámicamente
valor
cont
void
init_MUTEX(struct
semaphore
sem
Inicia
semáforo
creado
dinámicamente
valor
inicialmente
abierto
void
init_MUTEX_LOCKED(struct
semaphore
sem
Inicia
semáforo
creado
dinámicamente
valor
inicialmente
cerrado
void
down(struct
semaphore
sem
Intenta
adquirir
semáforo
especificado
entrando
bloqueo
ininterrumpible
semáforo
disponible
int
down_interruptible(struct
semaphore
sem
Intenta
adquirir
semáforo
especificado
entrando
bloqueo
interrumpible
semáforo
disponible
devuelve
valor
EINTR
recibe
señal
int
down_trylock(struct
semaphore
sem
Intenta
adquirir
semáforo
especificado
devuelve
valor
distinto
cero
semáforo
disponible
void
up(struct
semaphore
sem
Libera
semáforo
especificado
Semáforos
lectura-escritura
void
init_rwsem(struct
rw_semaphore
sem_le
Inicia
semáforo
creado
dinámicamente
valor
void
down_read(struct
rw_semaphore
sem_le
Operación
down
lectores
void
up_read(struct
rw_semaphore
sem_le
Operación
up
lectores
void
down_write(struct
rw_semaphore
sem_le
Operación
down
escritores
void
up_write(struct
rw_semaphore
sem_le
Operación
up
escritores
06-Capitulo
16/5/05
17:04
Página
290
abla
6.6
Operaciones
barrera
memoria
Linux
rmb
Impide
cambie
orden
lecturas
evitando
realicen
barrera
wmb
Impide
cambie
orden
escrituras
evitando
realicen
barrera
mb
Impide
cambie
orden
lecturas
escrituras
evitando
realicen
barrera
barrier
Impide
compilador
cambiar
orden
lecturas
escrituras
evitando
realicen
barrera
smp_rmb
SMP
proporciona
rmb
UP
proporciona
barrier
smp_wmb
SMP
proporciona
wmb
UP
proporciona
barrier
smp_mb
SMP
proporciona
mb
UP
proporciona
barrier
SMP
multiprocesador
simétrico
UP
uniprocesador
aspectos
importantes
operaciones
barrera
conviene
resaltar
barreras
relacionadas
instrucciones
máquina
concretamente
ins-
trucciones
carga
almacenamiento
instrucción
lenguaje
alto
nivel
implica
carga
lectura
posición
almacenamiento
escritura
posición
a.
operaciones
rmb
wmby
mbdictan
comportamiento
compilador
pro-
cesador
caso
compilador
operación
barrera
dicta
compilador
cambie
orden
instrucciones
proceso
compilación
caso
procesador
operación
barrera
dicta
instrucción
pendiente
ejecución
esté
incluida
pipeline
barrera
completarse
ejecutar
instrucción
encuentre
barrera
operación
barrier
operación
ligera
operación
mb(),puesto
controla
comportamiento
compilador
útil
conoce
procesador
reali-
zará
cambios
orden
indeseables
ejemplo
procesadores
x86
modifican
orden
escrituras
operaciones
smp_rmb
smp_wmby
smp_mb
proporcionan
optimización
código
compilarse
uniprocesador
UP
multiprocesador
simétrico
SMP
ins-
trucciones
definen
barreras
memoria
usuales
caso
SMP
UP
interpretan
barreras
compilador
operaciones
smp
útiles
situa-
ciones
dependencias
datos
interés
surgirán
contexto
SMP
6.9
FUNCIONES
SINCRONIZACIÓN
HILOS
SOLARIS
mecanismos
concurrencia
UNIX
SVR4
Solaris
proporciona
funciones
sincronización
hilos
Cerrojos
exclusión
mutua
mutex
Semáforos
Concurrencia
Interbloqueo
inanición
291
06-Capitulo
16/5/05
17:04
Página
291•
Cerrojos
múltiples
lectores
único
escritor
lectores
escritor
Variables
condición
Solaris
implementa
funciones
núcleo
hilos
núcleo
proporcionan
biblioteca
hilos
hilos
nivel
usuario
Figura
6.15
muestra
estructuras
datos
asociadas
funciones
funciones
iniciación
mecanismos
re-
llenan
campos
datos
crea
objeto
sincronización
básicamente
operaciones
entrar
adquirir
cerrojo
liberar
desbloquearlo
mecanismos
núcleo
biblioteca
hilos
aseguren
exclusión
mutua
impidan
in-
terbloqueo
hilo
intenta
acceder
fragmento
datos
código
debería
protegido
utiliza
función
sincronización
apropiada
acceso
produce
hilo
establece
cerrojo
objeto
desbloquea
núcleo
toma
ac-
ción
correctiva
primitivas
sincronización
requieren
existencia
instrucción
hardware
permita
objeto
consultado
modificado
operación
atómica
vio
Sección
5.3
CERROJO
EXCLUSIÓN
MUTUA
mutex
utiliza
asegurarse
hilo
momento
acceder
recurso
pro-
tegido
mutex
hilo
obtiene
mutex
libera
hilo
intenta
ad-
292
Sistemas
operativos
Aspectos
internos
principios
diseño
Cerrojo
MUTEX
Semáforo
Cerrojo
lectura
escritura
Variable
condición
propietario
octetos
cerrojo
octeto
hilo
propietario
octetos
unión
octetos
puntero
estadísticas
número
peticiones
escritura
Tipo
octeto
cerrojo
escritura
octeto
espera
octetos
contador
octetos
espera
octetos
información
específica
tipo
octetos
posiblemente
ident
turnstile
tipo
relleno
cerrojo
puntero
estadística
Tipo
octeto
cerrojo
escritura
octeto
espera
octetos
espera
octetos
Figura
6.15
Estructura
datos
sincronización
Solaris
06-Capitulo
16/5/05
17:04
Página
292quirir
cerrojo
mutex
ejecutando
función
mutex_enter
mutex_enter
establecer
cerrojo
hilo
acción
bloqueante
depende
información
específi-
ca
tipo
almacenada
objeto
mutex
política
bloqueante
defecto
cerrojo
cícli-
co
hilo
bloqueado
comprueba
cerrojo
ejecuta
bucle
espera
activa
forma
opcional
mecanismo
espera
bloqueante
basado
interrupciones
caso
mutex
incluye
identificador
turnstile
identifica
cola
hilos
bloqueados
cerrojo
operaciones
cerrojo
mutex
siguientes
mutex_enter
Adquiere
cerrojo
bloqueando
potencialmente
posee
hilo
mutex_exit
Libera
cerrojo
desbloqueando
potencialmente
hilo
espera
mutex_tryenter
Adquiere
cerrojo
posee
hilo
primitiva
mutex_tryenter
proporciona
bloqueante
fun-
ción
exclusión
mutua
permite
programador
utilizar
estrategia
espera
activa
hi-
nivel
usuario
evitando
bloquear
proceso
hilo
bloquea
SEMÁFOROS
Solaris
proporciona
clásicos
semáforos
contador
ofreciendo
siguientes
funciones
sema_p
Decrementa
semáforo
bloqueando
potencialmente
hilo
sema_v
Incrementa
semáforo
desbloqueando
potencialmente
hilo
espera
sema_tryp
Decrementa
semáforo
requiere
bloqueo
función
sema_tryp()permite
espera
activa
CERROJO
LECTURA
ESCRITURA
cerrojo
lectura
escritura
permite
múltiples
hilos
tengan
acceso
simultáneo
lectura
obje-
tos
protegidos
cerrojo
permite
momento
único
hilo
acceda
objeto
modificarlo
excluye
acceso
lectores
adquiere
cerrojo
escritura
toma
cerrojo
escritura
hilos
in-
tentan
acceder
leer
escribir
esperar
lectores
adquirido
cerrojo
cerrojo
lectura
funciones
siguientes
rw_enter
Intenta
adquirir
cerrojo
lector
escritor
rw_exit
Libera
cerrojo
lector
escritor
rw_tryenter
Decrementa
semáforo
requiere
bloqueo
rw_downgrade
hilo
adquirido
cerrojo
escritura
convierte
lectura
escritor
espera
permanece
esperando
hilo
libere
cerrojo
escritores
espera
función
despierta
lectores
pendientes
rw_tryupgrade
Intenta
convertir
cerrojo
lectura
escritura
Concurrencia
Interbloqueo
inanición
293
06-Capitulo
16/5/05
17:04
Página
293VARIABLES
CONDICIÓN
variable
condición
utiliza
esperar
cumpla
determinada
condición
mecanismo
utilizarse
conjunción
cerrojo
mutex
implementa
mo-
nitor
tipo
mostrado
Figura
6.14
primitivas
siguientes
cv_wait
Bloquea
activa
condición
cv_signal
Despierta
hilos
bloqueados
cv_wait
cv_broadcast
Despierta
hilos
bloqueados
cv_wait
función
cv_wait
libera
mutex
asociado
bloquearse
vuelve
adquirir
an-
tes
retornar
intentar
volverlo
adquirir
bloquearse
hilos
com-
piten
mutex
condición
causó
espera
volverse
comprobar
típico
mutex_enter(&m
while
condicion
cv_wait(&vc
mutex_exit(&m
permite
condición
expresión
compleja
puesto
protegida
mutex
6.10
MECANISMOS
CONCURRENCIA
WINDOWS
Windows
XP
2003
proporcionan
sincronización
hilos
arquitectura
objetos
métodos
sincronización
importantes
objetos
sincronización
sección
crítica
objetos
sincronización
utilizan
funciones
espera
lugar
describirán
funciones
espera
continuación
examinarán
ti-
pos
objetos
FUNCIONES
ESPERA
funciones
espera
permiten
hilo
bloquee
ejecución
funciones
espera
retornan
cumplen
criterios
especificados
tipo
función
espera
determina
conjunto
criterios
utilizado
llama
función
espera
comprueba
sa-
tisface
criterio
espera
caso
negativo
hilo
llamada
transita
espe-
ra
usando
tiempo
procesador
cumplan
criterios
tipo
sencillo
función
espera
espera
objeto
función
WaitForSingleObject
requiere
manejador
corresponda
objeto
sincronización
función
retorna
produce
siguientes
circunstancias
294
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
294•
objeto
especificado
señalado
transcurrido
plazo
máximo
espera
plazo
máximo
fijarse
INFINITE
especificar
espera
ilimitada
OBJETOS
SINCRONIZACIÓN
mecanismo
utilizado
ejecutivo
Windows
implementar
funciones
sincroniza-
ción
basa
familia
objetos
sincronización
muestran
breves
descripciones
Tabla
6.7
abla
6.7
.Objetos
sincronización
Windows
Tipo
objeto
Definición
Pasa
Efecto
hilos
señalado
espera
Evento
aviso
hilo
genera
Desbloquea
ocurrido
evento
evento
sistema
Mutex
mecanismo
hilo
propietario
desbloquea
hilo
proporciona
exclusión
hilo
libera
mutex
mutua
equivalente
semáforo
binario
Semáforo
contador
regula
contador
Desbloquea
número
hilos
semáforo
llega
cero
recurso
Temporizador
contador
cumple
tiempo
Desbloquea
espera
registra
paso
especificado
expira
tiempo
intervalo
tiempo
Notificación
cambio
notificación
Ocurre
cambio
desbloquea
hilo
fichero
cambios
sistema
sistema
ficheros
ficheros
encaja
criterios
filtro
objeto
Entrada
consola
ventana
texto
entrada
disponible
desbloquea
hilo
pantalla
ejemplo
procesar
usada
manejar
pantalla
aplicación
MS-DOS
Trabajo
instancia
completa
Desbloquea
fichero
abierto
operación
dispositivo
Notificación
notificación
produce
tipo
Desbloquea
recurso
memoria
cambio
recurso
cambio
especificado
memoria
memoria
física
Proceso
invocación
hilo
termina
Desbloquea
programa
incluyendo
espacio
direcciones
recursos
requeridos
ejecutar
programa
Hilo
entidad
ejecutable
hilo
termina
Desbloquea
proceso
Nota
filas
coloreadas
corresponden
objetos
sincronización
Concurrencia
Interbloqueo
inanición
295
06-Capitulo
16/5/05
17:04
Página
295Los
tipos
objetos
tabla
diseñados
específicamente
soporte
sincronización
tipos
objetos
restantes
usos
adicionales
utilizarse
sincronización
instancia
objeto
sincronización
señalado
seña-
hilo
bloquear
objeto
señalado
desbloqueándose
objeto
transite
señalado
mecanismo
sencillo
hilo
realiza
petición
espera
ejecutivo
Windows
utilizando
manejador
objeto
sincronización
objeto
transita
señalado
ejecutivo
Windows
desbloquea
objetos
tipo
hilo
esperando
objeto
sincronización
objeto
evento
útil
enviar
señal
hilo
indicarle
ocurrido
determi-
nado
evento
ejemplo
entrada
salida
asíncrona
sistema
establece
objeto
evento
es-
pecífico
objeto
transitará
señalado
completado
operación
asíncrona
objeto
mutex
garantizar
acceso
mutuamente
exclusivo
re-
curso
permitiendo
momento
hilo
acceso
tipo
objeto
funciona
semáforo
binario
objeto
mutex
pasa
señalado
desbloquea
hilos
esperando
mutex
mutex
pue-
den
utilizar
sincronizar
hilos
ejecutan
procesos
mutex
obje-
tos
semáforo
compartir
hilos
pertenecientes
distintos
procesos
semáforo
Win-
dows
semáforo
contador
Básicamente
objeto
temporizador
espera
avisa
transcurrido
tiempo
intervalos
regulares
OBJETOS
SECCIÓN
CRÍTICA
objetos
sección
crítica
proporcionan
mecanismo
sincronización
similar
proporciona-
do
objetos
mutex
objetos
sección
crítica
utilizar
hilos
proceso
objetos
mutex
eventos
semáforos
utilizar
aplicación
único
proceso
objetos
sección
crítica
proporcionan
mecanismo
sin-
cronización
exclusión
mutua
ligeramente
rápido
eficiente
proceso
responsable
asignar
memoria
utilizada
sección
crítica
Normalmen-
simplemente
declarando
variable
tipo
CRITICAL_SECTION.Antes
hilos
proceso
puedan
utilizarla
sección
crítica
inicia
utilizando
funciones
Initialize-
CriticalSectiono
InitializeCriticalSectionAndSpinCount
hilo
funciones
EnterCriticalSection
TryEnterCriticalSection
soli-
citar
posesión
sección
crítica
utilizando
función
LeaveCriticalSection
liberar
posesión
objeto
sección
crítica
posee
actualmente
hilo
EnterCriti-
calSectionespera
indefinidamente
obtener
posesión
contraste
utiliza
objeto
mutex
lograr
exclusión
mutua
funciones
espera
aceptan
especifique
plazo
tiempo
espera
máximo
función
TryEnterCriticalSection
intenta
entrar
sección
crítica
bloquear
hilo
llamada
6.11
RESUMEN
interbloqueo
bloqueo
conjunto
procesos
compiten
recursos
siste-
ma
comunican
bloqueo
permanente
sistema
operativo
tome
accio-
nes
correctivas
abortar
procesos
forzar
ejecución
procesos
retroceda
interbloqueo
involucrar
recursos
reutilizables
consumibles
recurso
reutili-
zable
destruye
canal
región
memoria
296
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
296recurso
consumible
destruye
adquiere
proceso
ejemplos
mensajes
información
almacenada
buffers
S.
estrategias
generales
tratar
interbloqueos
prevención
detección
predic-
ción
prevención
interbloqueo
garantiza
produce
interbloqueo
asegurándose
cumple
condiciones
necesarias
interbloqueo
detección
interbloqueo
necesaria
sistema
operativo
dispuesto
conceder
peticiones
recursos
periódica-
mente
sistema
operativo
comprobar
interbloqueo
tomar
acciones
pertinentes
romperlo
predicción
interbloqueo
implica
análisis
petición
recurso
determinar
conducir
interbloqueo
concediéndola
interbloqueo
6.12
LECTURAS
RECOMENDADAS
artículo
clásico
interbloqueos
HOLT72
lectura
valiosa
tam-
bién
COFF71
estudio
interesante
ISLO80
CORB96
tratado
general
de-
tección
interbloqueos
DIMI98
ameno
estudio
general
interbloqueos
artículos
recientes
Levine
LEVI03a
LEVI03b
clarifican
conceptos
utilizados
estudio
in-
terbloqueo
SHUB03
estudio
útil
interbloqueo
mecanismos
concurrencia
UNIX
SVR4
Linux
Solaris
detalladamente
estu-
diados
GRAY97
LOVE04
MAUR01
respectivamente
COFF71
Coffman
E.
Elphick
M.
Shoshani
A.
System
Deadlocks
Computing
Surveys
Junio
1971
CORB96
Corbett
J.
Evaluating
Deadlock
Detection
Methods
for
Concurrent
Software
IEEE
Transac-
tions
on
Software
Engineering
Marzo
1996
DIMI98
Dimitoglou
G.
Deadlocks
and
Methods
for
Their
Detection
Prevention
and
Recovery
in
Mo-
dern
Operating
Systems
Operating
Systems
Review
Julio
1998
GRAY97
Gray
J.
Interprocess
Communications
in
UNIX
The
Nooks
and
Crannies
Upper
Saddle
Ri-
NJ
Prentice
Hall
1997
HOLT72
Holt
R.
Some
Deadlock
Properties
of
Computer
Systems
Computing
Surveys
Septiembre
1972
ISLO80
Isloor
S.
Marsland
The
Deadlock
Problem
An
Overview
Computer
Septiembre
1980
LEVI03a
Levine
G.
Defining
Deadlock
Operating
Systems
Review
Enero
2003
LEVI03bLevine
G.
Defining
Deadlock
with
Fungible
Resources
Operating
Systems
Review
Julio
2003
LOVE04
Love
R.
Linux
Kernel
Development
Indianapolis
IN
Sams
Publishing
2004
MAUR01
Mauro
J.
McDougall
R.
Solaris
Internals
Upper
Saddle
River
NJ
Prentice
Hall
PTR
2001
SHUB03
Shub
C.
Unified
Treatment
of
Deadlock
Journal
of
Computing
in
Small
Colleges
Octu-
bre
2003
Disponible
biblioteca
digital
ACM
6.13
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
algoritmo
banquero
exclusión
mutua
predicción
interbloqueo
barrera
memoria
expropiación
prevención
interbloqueo
cerrojo
cíclico
grafo
asignación
recursos
recurso
consumible
detección
interbloqueo
inanición
recurso
reutilizable
diagrama
progreso
conjunto
interbloqueo
retención
espera
espera
circular
mensaje
tubería
Concurrencia
Interbloqueo
inanición
297
06-Capitulo
16/5/05
17:04
Página
297CUESTIONES
REPASO
6.1
Cite
ejemplos
recursos
reutilizables
consumibles
6.2
condiciones
cumplirse
interbloqueo
6.3
condiciones
producen
interbloqueo
6.4
prever
condición
retención
espera
6.5
Enumere
maneras
prever
condición
expropiación
6.6
prever
condición
espera
circular
6.7
diferencia
predicción
detección
prevención
interbloqueo
PROBLEMAS
6.1
Muestre
condiciones
interbloqueo
aplicadas
Figura
6.1a
6.2
Figura
6.3
proporcione
descripción
narrativa
trayecto-
rias
representadas
similar
descripción
Figura
6.2
realizada
Sección
6.1
6.3
ocurrir
interbloqueo
situación
reflejada
Figura
6.3
Justifique
afirmación
6.4
Considere
instantánea
sistema
Suponga
peticiones
recursos
pendientes
satisfacerse
disponibles
r1
r2
r3
r4
2100
asignación
actual
necesidades
máximas
necesidades
pendientes
proceso
r1
r2
r3
r4
r1
r2
r3
r4
r1
r2
r3
r4
00120012
20002750
00346656
23544356
03320652
Calcule
pedir
proceso
escríbalo
columnas
eti-
quetadas
necesidades
pendientes
sistema
actualmente
seguro
inseguro
sistema
actualmente
interbloqueo
procesos
caso
llegar
inter-
bloqueo
298
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
298e
llega
solicitud
p3
concederse
solicitud
inmediata-
mente
forma
segura
interbloqueo
seguro
inseguro
quedaría
sistema
justo
concesión
petición
completa
procesos
caso
estarían
interbloqueo
concede
inmediatamente
petición
completa
6.5
Aplique
algoritmo
detección
interbloqueo
Sección
6.4
siguientes
datos
muestre
resultado
Disponibles
2100
2001
0010
Solicitud
1010
Asignación
2001
2100
0120
6.6
sistema
spooling
Figura
6.16
consta
proceso
entrada
proceso
usua-
rio
proceso
salida
conectados
buffers
residentes
disco
pro-
cesos
intercambian
datos
bloques
tamaño
bloques
almacenan
disco
utilizando
límite
flotante
buffers
entrada
salida
dependiendo
velocidad
procesos
funciones
comunicación
utilizadas
aseguran
cumple
restricción
recursos
máx
máx
máximo
número
bloques
disco
número
bloques
entrada
disco
número
bloques
salida
disco
procesos
conocen
siguientes
aspectos
entorno
proporcione
datos
proceso
momento
es-
cribirá
disco
espacio
disponible
entrada
disponible
disco
proceso
momento
consumirá
escribirá
disco
cantidad
finita
datos
salida
bloque
leído
espacio
disponible
datos
salida
disponibles
disco
proceso
momento
consumirá
Demuestre
sistema
producirse
interbloqueo
6.7
Sugiera
restricción
adicional
recursos
impida
interbloqueo
Problema
6.6
siga
permitiendo
límite
buffers
entrada
sali-
variar
necesidades
presentes
procesos
Concurrencia
Interbloqueo
inanición
299
EP
Almacenamiento
intermedio
entrada
Almacenamiento
intermedio
salida
Figura
6.16
sistema
spooling
06-Capitulo
16/5/05
17:04
Página
2996.8
sistema
operativo
THE
DIJK68
tambor
precursor
disco
almacena-
miento
secundario
divide
buffers
entrada
áreas
procesamiento
buffers
sa-
lida
límites
flotantes
dependiendo
velocidad
procesos
involucrados
actual
tambor
caracterizar
siguientes
parámetros
máx
máximo
número
páginas
tambor
número
páginas
entrada
tambor
número
páginas
procesamiento
tambor
número
páginas
salida
tambor
ress
número
páginas
reservadas
salida
resp
número
páginas
reservadas
procesamiento
Formule
restricciones
necesarias
recursos
garantice
excede
capacidad
tambor
reserva
número
mínimo
páginas
permanentemente
salida
procesamiento
6.9
sistema
operativo
THE
página
siguientes
transiciones
vacío
buffer
entrada
producción
entrada
buffer
entrada
área
procesamiento
consumo
entrada
área
procesamiento
buffer
salida
producción
salida
buffer
salida
vacío
consumo
salida
vacío
área
procesamiento
llamada
procedimiento
área
procesamiento
vacío
retorno
procedimiento
Defina
efecto
transiciones
términos
cantidades
p.
interbloqueo
mantienen
suposiciones
hechas
Problema
6.6
procesos
entrada
usuario
salida
6.10
Considere
sistema
150
unidades
memoria
asignadas
procesos
muestra
continuación
Proceso
Máx
Asignadas
17
26
36
Aplique
algoritmo
banquero
determinar
seguro
conceder
siguientes
peticiones
caso
afirmativo
indique
secuencia
terminaciones
garantizar
factible
caso
negativo
muestre
reducción
tabla
asig-
nación
resultante
Aparece
cuarto
proceso
necesidad
memoria
máxima
60
necesi-
dad
inicial
25
unidades
Aparece
cuarto
proceso
necesidad
memoria
máxima
60
necesi-
dad
inicial
35
unidades
300
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
3006.11
Evalúe
grado
utilidad
algoritmo
banquero
sistema
operativo
6.12
implementa
algoritmo
estructura
serie
pipeline
flujo
elementos
datos
tipo
producido
proceso
pasa
secuen-
cia
procesos
P1
P2
Pn-1
operan
elementos
orden
Defina
buffer
general
mensajes
contenga
elementos
datos
par-
cialmente
consumidos
escriba
algoritmo
proceso
-1
estructura
repetir
indefinidamente
recibe
predecesor
consume
elemento
envía
sucesor
Suponga
recibe
elementos
enviados
n-1
algoritmo
debería
permitir
procesos
trabajen
directamente
mensajes
guardados
buffer
ma-
nera
necesario
copias
Muestre
procesos
quedarse
interbloqueo
buffer
común
6.13
procesos
comparten
unidades
recurso
reservarse
libe-
rarse
momento
necesidad
máxima
proceso
uni-
dades
Demuestre
ocurrir
interbloqueo
procesos
comparten
unidades
recurso
reservarse
liberarse
momento
necesidad
máxima
proceso
excede
suma
necesidades
máximas
menor
N.
Demuestre
ocurrir
interbloqueo
6.14
Considere
sistema
formado
procesos
recurso
actual
matrices
asignación
necesidad
31
93
72
número
mínimo
unidades
recurso
necesitan
disponibles
seguro
6.15
Considere
siguientes
modos
manejo
interbloqueo
algoritmo
banquero
detección
interbloqueo
aborto
hilo
liberando
recursos
reserva
recursos
anticipado
reinicio
hilo
liberación
recursos
hilo
necesita
esperar
ordenamiento
recursos
detección
interbloqueo
re-
troceso
ejecución
hilo
criterio
utilizado
evaluación
estrategias
tratamiento
inter-
bloqueo
analizar
permite
concurrencia
palabras
estrate-
gia
permite
ejecutar
esperas
mayoría
hilos
interbloqueo
Asigne
orden
estrategias
tratamiento
interbloqueo
permite
grado
concurrencia
Explique
ordenación
Concurrencia
Interbloqueo
inanición
301
06-Capitulo
16/5/05
17:04
Página
301b
criterio
eficiencia
palabras
estrategia
sobrecarga
procesador
Ordene
estrategias
eficiente
asumiendo
interbloqueo
evento
raramente
produce
Explique
ordenación
Cambia
respuesta
interbloqueo
frecuente
6.16
Comente
solución
problema
filósofos
comensales
filósofo
ham-
briento
toma
tenedor
izquierda
disponible
dere-
cha
tomará
empezará
comer
caso
contrario
devolverá
tenedor
izquierda
repetirá
ciclo
6.17
Supóngase
tipos
filósofos
toma
tenedor
izquierda
zurdo
tipo
toma
derecha
dies-
tro
comportamiento
zurdo
define
Figura
6.12
diestro
inicio
repetir
indefinidamente
piensa
wait
tenedor[(i+1
mod
wait
tenedor[i
come
signal
tenedor[i
signal
tenedor[(i+1
mod
porsiempre
Demuestre
combinación
zurdos
diestros
evita
inter-
bloqueo
combinación
zurdos
diestros
impide
inani-
ción
6.18
Figura
6.17
muestra
solución
problema
filósofos
comensales
usando
mo-
nitores
Compare
solución
presentada
Figura
6.14
escriba
conclusio-
nes
6.19
Tabla
6.3
operaciones
atómicas
Linux
involucran
accesos
variable
atomic_read(atomic_t
simple
operación
lectura
obviamente
atómica
arquitectura
añade
operación
repertorio
operaciones
atómicas
6.20
Considere
fragmento
código
sistema
Linux
read_lock
cerrojo_le
write_lock
cerrojo_le
cerrojo_le
cerrojo
lectura_escritura
efecto
código
6.21
variables
valores
iniciales
respectivamente
código
ejecuta
sistema
Linux
302
Sistemas
operativos
Aspectos
internos
principios
diseño
06-Capitulo
16/5/05
17:04
Página
302Hilo
Hilo
mb
rmb
errores
evitar
utilización
barreras
memoria
Concurrencia
Interbloqueo
inanición
303
Figura
6.17
solución
problema
filósofos
comensales
usando
monitor
monitor
controlador
de_comensales
enum
pensando
hambriento
comiendo
estado[5
cond
requiereTenedor
variable
condición
void
obtiene_tenedores
int
id_pr
id_pr
número
ident
filósofo
estado[id_pr
hambriento
anuncia
hambre
if
estado[(id_pr+1
comiendo
||
estado[(id_pr-1
comiendo
cwait(requiereTenedor
id_pr
espera
vecino
come
estado[id_pr
comiendo
continúa
vecino
come
void
libera_tenedores
int
id_pr
estado[id_pr
pensando
oportunidad
comer
vecino
número
if
estado[(id_pr+1
hambriento
estado[(id_pr+2
comiendo
csignal(requiereTenedor
id_pr+1
oportunidad
comer
vecino
número
menor
else
if
estado[(id_pr-1
hambriento
estado[(id_pr-2
comiendo
csignal(requiereTenedor
id_pr-1
void
filosofo[k=0
clientes
filósofos
while
piensa
obtiene_tenedores(k
cliente
solicita
tenedores
vía
monitor
come
espaguetis
libera_tenedores
cliente
libera
tenedores
vía
monitor
06-Capitulo
16/5/05
17:04
Página
30306-Capitulo
16/5/05
17:04
Página
304PARTE
III
MEMORIA
aspectos
complejos
diseño
sistemas
operativos
gestión
me-
moria
coste
memoria
caído
dramáticamente
resultado
tamaño
memoria
principal
máquinas
modernas
crecido
alcanzando
rangos
torno
gigabytes
suficientemente
memoria
principal
contener
programas
es-
tructuras
datos
necesarias
procesos
activos
sistema
operativo
Análogamente
ta-
rea
central
sistema
operativo
gestionar
memoria
implica
traer
bloques
da-
tos
memoria
secundaria
operación
lenta
velocidad
relativa
tiempo
ciclo
instrucción
procesador
aumenta
año
pasa
mantener
ocupado
procesador
procesadores
mantener
eficiencia
sistema
opera-
tivo
gestionar
forma
inteligente
transferencia
memoria
principal
secundaria
minimizar
efecto
rendimiento
ÍNDICE
CAPÍTULO
GESTIÓN
MEMORIA
Capítulo
proporciona
descripción
básica
mecanismos
fundamentales
utilizados
gestión
memoria
resumen
requisitos
básicos
esquema
gestión
memoria
continuación
introduce
particionamiento
memoria
técnica
utilizada
casos
especiales
tales
gestión
memoria
núcleo
em-
bargo
revisión
particionamiento
memoria
ilumina
aspectos
diseño
re-
lacionados
gestión
memoria
resto
capítulo
técnicas
forman
elementos
básicos
prácticamente
sistemas
gestión
memoria
paginación
segmentación
CAPÍTULO
MEMORIA
VIRTUAL
memoria
virtual
basada
paginación
combinación
paginación
segmentación
técnica
universal
gestión
memoria
máquinas
contemporáneas
me-
moria
virtual
esquema
transparente
procesos
permite
proceso
comporte
07-Capitulo
16/5/05
17:04
Página
305como
tuviera
memoria
ilimitada
disposición
lograr
sistema
operativo
crea
proceso
espacio
direcciones
virtual
memoria
virtual
disco
memoria
vir-
tual
trae
memoria
principal
real
necesita
forma
procesos
compartir
cantidad
relativamente
pequeña
memoria
principal
memoria
virtual
tra-
baje
forma
efectiva
necesita
mecanismos
hardware
lleven
cabo
funciones
pagi-
nación
segmentación
básicas
tales
traducción
direcciones
virtuales
reales
Capítulo
comienza
descripción
mecanismos
hardware
resto
capítulo
dedica
aspec-
tos
diseño
sistema
operativo
relacionados
memoria
virtual
306
Sistemas
operativos
Aspectos
internos
principios
diseño
07-Capitulo
16/5/05
17:04
Página
306CAPÍTULO
Gestión
memoria
.1
Requisitos
gestión
memoria
.2
Particionamiento
memoria
.3
Paginación
.4
Segmentación
.5
Resumen
.6
Lecturas
recomendadas
.7
érminos
clave
cuestiones
revisión
problemas
Apéndice
7A
Carga
enlace
07-Capitulo
16/5/05
17:04
Página
307N
sistema
monoprogramado
memoria
divide
partes
sistema
operativo
monitor
residente
núcleo
programa
actualmente
ejecución
sistema
multiprogramado
usuario
memoria
subdividir
posteriormente
acomodar
múltiples
procesos
sistema
operativo
encargado
tarea
subdivisión
tarea
denomina
gestión
memoria
gestión
memoria
efectiva
vital
sistema
multiprogramado
procesos
encuentran
memoria
tiempo
proce-
sos
esperarían
operaciones
procesador
estaría
ocioso
necesario
asig-
nar
memoria
asegurar
cantidad
procesos
listos
consuman
tiempo
procesa-
dor
disponible
Comenzaremos
capítulo
descripción
requisitos
gestión
memoria
pretende
satisfacer
continuación
mostrará
tecnología
gestión
memoria
analizan-
do
variedad
esquemas
simples
utilizado
capítulo
enfoca
requisito
programa
cargar
memoria
principal
ejecutarse
discusión
introduce
al-
gunos
principios
fundamentales
gestión
memoria
.1
REQUISITOS
GESTIÓN
MEMORIA
ientras
analizan
mecanismos
políticas
asociados
gestión
memoria
útil
mantener
mente
requisitos
gestión
memoria
satisfacer
LIST93
sugiere
requisitos
Reubicación
Protección
Compartición
Organización
lógica
Organización
física
REUBICACIÓN
sistema
multiprogramado
memoria
principal
disponible
comparte
generalmente
va-
rios
procesos
Normalmente
programador
sepa
anticipadamente
programas
residirán
memoria
principal
tiempo
ejecución
programa
Adicionalmente
intercambiar
procesos
memoria
principal
maximizar
utilización
procesador
proporcionando
número
procesos
ejecución
programa
lleva-
do
disco
limitante
colocarlo
región
memoria
principal
don-
hallaba
anteriormente
trae
memoria
contrario
necesario
reubicar
proceso
área
memoria
forma
anticipada
colocar
programa
permitir
programas
puedan
mover
memoria
principal
intercambio
swap
hechos
ponen
manifiesto
aspectos
técnicos
relacionados
direccionamiento
muestra
Figura
7.1
figura
representa
imagen
proceso
razones
sim-
plicidad
asumirá
imagen
proceso
ocupa
región
contigua
memoria
princi-
pa
l.
Claramente
sistema
operativo
necesitará
ubicación
información
control
308
Sistemas
operativos
Aspectos
internos
principios
diseño
07-Capitulo
16/5/05
17:04
Página
308del
proceso
pila
ejecución
punto
entrada
utilizará
proceso
ini-
ciar
ejecución
sistema
operativo
encarga
gestionar
memoria
respon-
sable
traer
proceso
memoria
principal
direcciones
fáciles
adquirir
Adicional-
mente
procesador
tratar
referencias
memoria
programa
instrucciones
salto
contienen
dirección
referenciar
instrucción
ejecutar
continuación
instrucciones
referencia
datos
contienen
dirección
byte
palabra
datos
referenciados
forma
hardware
procesador
software
sistema
operativo
traducir
referencias
memoria
encontradas
código
pro-
grama
direcciones
memoria
físicas
reflejan
ubicación
actual
programa
memo-
ria
principal
PROTECCIÓN
proceso
protegerse
interferencias
deseadas
procesos
ac-
cidentales
intencionadas
programas
procesos
capaces
refe-
renciar
permiso
posiciones
memoria
proceso
lectura
escritura
lograr
requisitos
reubicación
incrementa
dificultad
satisfacer
requisitos
protección
mayoría
lenguajes
programación
permite
cálculo
dinámico
di-
recciones
tiempo
ejecución
ejemplo
calculando
índice
posición
vector
puntero
estructura
datos
referencias
memoria
generadas
pro-
ceso
comprobarse
tiempo
ejecución
asegurar
refieren
espacio
memoria
asignado
proceso
Afortunadamente
verá
mecanismos
soporte
reasignación
soporte
requisito
protección
Normalmente
proceso
usuario
acceder
porción
sistema
operativo
código
datos
programa
proceso
saltar
instrucción
proceso
trato
especial
programa
proceso
acceder
área
datos
proceso
procesador
capaz
abortar
tales
instrucciones
punto
ejecución
Gestión
memoria
309
Bloque
control
proceso
Programa
Datos
Pila
Extremo
actual
pila
Punto
entrada
programa
Información
control
proceso
Valores
direcciones
crecientes
Instrucciones
salto
Referencia
datos
Figura
.1
Requisitos
direccionamiento
proceso
07-Capitulo
16/5/05
17:04
Página
309Obsérvese
requisitos
protección
memoria
satisfechos
procesador
hardware
lugar
sistema
operativo
software
sistema
operativo
anticipar
referencias
memoria
programa
hará
anticipación
llevaría
tiempo
calcularlo
programa
comprobar
viola-
ción
referencias
memoria
evaluar
permisibilidad
referen-
cia
acceso
datos
salto
tiempo
ejecución
instrucción
realiza
dicha
referencia
cabo
hardware
procesador
capacidad
COMPARTICIÓN
mecanismo
protección
flexibilidad
permitir
procesos
acceder
porción
memoria
principal
ejemplo
programas
ejecutando
programa
ventajoso
permitir
proceso
acceder
copia
programa
lugar
copia
separada
Procesos
estén
cooperando
tarea
ne-
cesitar
compartir
acceso
estructura
datos
sistema
gestión
me-
moria
permitir
acceso
controlado
áreas
memoria
compartidas
comprometer
protec-
ción
esencial
verá
mecanismos
utilizados
soporte
reubicación
soportan
capacidades
compartición
ORGANIZACIÓN
LÓGICA
invariablemente
memoria
principal
computador
organiza
espacio
alma-
cenamiento
lineal
unidimensional
compuesto
secuencia
bytes
palabras
nivel
físico
memoria
secundaria
organizada
forma
similar
organización
similar
hardware
real
máquina
corresponde
forma
programas
construyen
normalmente
mayoría
programas
organizan
módulos
modificar
lectura
ejecución
contienen
datos
modificar
sistema
operativo
hardware
computador
tratar
forma
efectiva
programas
usuarios
datos
forma
módulos
tipo
lograr
ventajas
módulos
escribir
compilar
independientemente
referencias
módulo
resueltas
sistema
tiempo
ejecución
sobrecarga
adicional
modesta
proporcionar
grados
protección
módulos
lectura
ejecución
introducir
mecanismos
módulos
compartir
procesos
ventaja
proporcionar
compartición
nivel
módulo
corresponde
forma
usuario
ve
problema
fácil
especificar
compartición
deseada
herramienta
adecuadamente
satisface
requisitos
segmentación
técnicas
gestión
memoria
exploradas
capítulo
ORGANIZACIÓN
FÍSICA
discute
Sección
1.5
memoria
computador
organiza
niveles
conocidos
memoria
principal
memoria
secundaria
memoria
principal
proporciona
acceso
310
Sistemas
operativos
Aspectos
internos
principios
diseño
07-Capitulo
16/5/05
17:04
Página
310rápido
coste
relativamente
alto
Adicionalmente
memoria
principal
volátil
proporciona
almacenamiento
permanente
memoria
secundaria
lenta
barata
memoria
principal
normalmente
volátil
memoria
secundaria
larga
capacidad
proporcionar
almacenamiento
programas
datos
plazo
memoria
principal
pequeña
contiene
programas
datos
actualmente
esquema
niveles
organización
flujo
información
memoria
princi-
pa
secundaria
supone
preocupaciones
principales
sistema
responsabilidad
flujo
asignarse
programador
particular
practicable
deseable
motivos
memoria
principal
disponible
programa
datos
insuficiente
caso
programador
debería
utilizar
técnica
conocida
superposición
overlaying
programas
datos
organizan
forma
asignar
región
memoria
módulos
programa
principal
respon-
sable
intercambiar
módulos
disco
memoria
necesidades
ayuda
herramientas
compilación
programación
overlays
malgasta
tiem-
po
programador
entorno
multiprogramado
programador
conoce
tiempo
codificación
espacio
disponible
localizará
espacio
tarea
mover
información
niveles
memoria
de-
bería
responsabilidad
sistema
tarea
esencia
gestión
memoria
.2
PARTICIONAMIENTO
MEMORIA
operación
principal
gestión
memoria
traer
procesos
memoria
principal
procesador
ejecutar
sistemas
multiprogramados
modernos
implica
esquema
sofisticado
denominado
memoria
virtual
memoria
vir-
tual
basa
ambas
siguientes
técnicas
básicas
segmentación
paginación
fijarse
técnicas
memoria
virtual
preparar
camino
analizando
técnicas
sen-
cillas
utilizan
memoria
virtual
Tabla
7.1
técnicas
particionamiento
utilizado
variantes
sistemas
operativos
obsoletos
técnicas
paginación
sencilla
segmentación
sencilla
utilizadas
forma
aislada
queda-
rá
clara
discusión
memoria
virtual
analizan
técnicas
consideraciones
memoria
virtual
PARTICIONAMIENTO
FIJO
mayoría
esquemas
gestión
memoria
asumir
sistema
operativo
ocupa
porción
fija
memoria
principal
resto
memoria
principal
disponi-
ble
múltiples
procesos
esquema
simple
gestionar
memoria
disponible
repartir-
regiones
límites
fijos
amaños
partición
Figura
7.2
muestra
ejemplos
alternativas
particionamiento
fijo
posibilidad
consiste
particiones
tamaño
caso
proceso
cuyo
tamaño
Gestión
memoria
311
07-Capitulo
16/5/05
17:04
Página
311312
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
.1.Técnicas
gestión
memoria
écnica
Descripción
Virtudes
Defectos
Particionamiento
fijo
memoria
principal
Sencilla
implementar
ineficiente
divide
particiones
sobrecarga
memoria
estáticas
tiempo
sistema
operativo
fragmentación
interna
generación
fijarse
número
sistema
proceso
máximo
procesos
cargar
activos
partición
superior
tamaño
Particionamiento
particiones
crean
fragmentación
ineficiente
dinámico
forma
dinámica
interna
procesador
forma
eficiente
memoria
necesidad
proceso
carga
principal
compactación
partición
evitar
fragmentación
tamaño
externa
proceso
Paginación
sencilla
memoria
principal
fragmentación
pequeña
cantidad
divide
marcos
externa
fragmentación
tamaño
interna
proceso
divide
páginas
tamaño
marcos
proceso
carga
carga
páginas
marcos
disponibles
necesariamente
contiguos
Segmentación
sencilla
proceso
divide
fragmentación
Fragmentación
externa
segmentos
interna
mejora
proceso
carga
utilización
cargando
memoria
reduce
segmentos
sobrecargada
particiones
dinámicas
particionamiento
necesariamente
dinámico
contiguas
Paginación
Exactamente
fragmentación
Sobrecarga
memoria
virtual
paginación
sencilla
externa
grado
gestión
compleja
multiprogramación
memoria
necesario
cargar
espacio
páginas
direcciones
virtuales
proceso
páginas
residentes
traen
demanda
forma
automática
Segmentación
Exactamente
fragmentación
Sobrecarga
memoria
virtual
segmentación
interna
grado
gestión
compleja
multiprogramación
memoria
necesario
cargar
espacio
segmentos
direcciones
virtuales
proceso
segmentos
soporte
protección
residentes
traen
compartición
demanda
forma
automática
07-Capitulo
16/5/05
17:04
Página
312es
menor
tamaño
partición
cargarse
partición
disponible
to-
das
particiones
llenas
proceso
Listo
Ejecutando
sistema
ope-
rativo
mandar
swap
proceso
cualquiera
particiones
cargar
proceso
forma
procesador
trabajo
dificultades
particiones
fijas
tamaño
programa
caber
partición
caso
pro-
gramador
diseñar
programa
overlays
forma
necesite
porción
programa
memoria
principal
momento
determinado
ne-
cesita
módulo
presente
programa
usuario
cargar
módulo
partición
programa
superponiéndolo
overlaying
programa
datos
utilización
memoria
principal
extremadamente
ineficiente
programa
importar
pequeño
ocupa
partición
entera
ejemplo
pro-
grama
cuya
longitud
menor
Mbytes
ocuparía
partición
Mbytes
memoria
fenómeno
espacio
interno
malgastado
Gestión
memoria
313
Sistema
operativo
12
16
Participaciones
tamaño
Sistema
operativo
Participaciones
distinto
tamaño
Figura
.2
Ejemplo
particionamiento
fijo
memoria
64
Mbytes
07-Capitulo
16/5/05
17:04
Página
313de
bloque
datos
cargado
menor
partición
conoce
nombre
frag-
mentación
interna
problemas
mejorar
resolver
utilizando
particiones
tamaño
dife-
rente
Figura
7.2b
ejemplo
programas
16
Mbytes
acomodar
overlays
particiones
pequeñas
Mbytes
permiten
programas
pequeños
puedan
aco-
modar
menor
fragmentación
interna
Algoritmo
ubicación
particiones
tamaño
ubicación
procesos
memoria
trivial
partición
disponible
proceso
carga
dicha
partición
particio-
nes
tamaño
importa
partición
utiliza
particiones
encuentran
ocupadas
procesos
listos
ejecutar
dichos
procesos
llevar-
disco
dejar
espacio
proceso
procesos
disco
deci-
sión
planificación
tema
describe
particiones
tamaño
formas
posibles
asignar
procesos
parti-
ciones
forma
sencilla
consiste
asignar
proceso
partición
pequeña
cabe
caso
necesita
cola
planificación
partición
mantenga
procesos
disco
destinados
dicha
partición
Figura
7.3a
ventaja
técnica
procesos
asignan
forma
minimiza
memoria
malgastada
par-
tición
fragmentación
interna
técnica
óptima
punto
vista
partición
individual
ópti-
ma
punto
vista
sistema
completo
Figura
7.2b
ejemplo
caso
procesos
tamaño
12
16
determinado
instante
tiempo
caso
partición
16
quedará
utilizarse
asignar
dicha
partición
procesos
pequeños
técnica
óptima
emplear
única
cola
to-
procesos
Figura
7.3b
momento
cargar
proceso
memoria
principal
se-
lecciona
partición
pequeña
disponible
albergar
proceso
particio-
nes
ocupadas
cabo
decisión
enviar
swap
proceso
preferencia
hora
expulsado
disco
proceso
ocupe
partición
pequeña
pue-
albergar
proceso
entrante
considerar
factores
prioridad
preferencia
expulsar
disco
procesos
bloqueados
frente
procesos
listos
particiones
distinto
tamaño
proporciona
grado
flexibilidad
frente
parti-
ciones
fijas
Adicionalmente
esquemas
particiones
fijas
relativamente
sencillos
requieren
soporte
mínimo
sistema
operativo
sobrecarga
procesa-
miento
mínimo
serie
desventajas
número
particiones
especificadas
tiempo
generación
sistema
limita
número
proceso
activos
suspendidos
sistema
tamaños
particiones
preestablecidos
tiempo
generación
sistema
trabajos
pequeños
utilizan
espacio
particiones
eficientemente
entorno
requisito
almacenamiento
principal
trabajos
conoce
an-
314
Sistemas
operativos
Aspectos
internos
principios
diseño
asume
conoce
tamaño
máximo
memoria
proceso
requerirá
caso
proceso
ocupar
única
alternativa
esquema
overlays
memoria
virtual
07-Capitulo
16/5/05
17:04
Página
314temano
técnica
razonable
mayoría
casos
téc-
nica
ineficiente
particionamiento
fijo
desconocido
ejemplo
sistema
opera-
tivo
exitoso
utilizó
técnica
sistema
operativo
mainframes
IBM
sistema
operativo
MFT
Multiprogramming
with
Fixed
Number
of
Tasks
Multiprogramado
número
fijo
tareas
PARTICIONAMIENTO
DINÁMICO
vencer
dificultades
particionamiento
fijo
desarrolló
técnica
conocida
particionamiento
dinámico
técnica
sustituido
técnicas
gestión
memoria
sofisticadas
sistema
operativo
importante
utilizó
técnica
sistema
operativo
mainframes
IBM
sistema
operativo
MVT
Multiprogramming
with
Variable
Number
of
Tasks
Multiprogramado
número
variable
tareas
particionamiento
dinámico
particiones
longitud
número
variable
lle-
proceso
memoria
principal
asigna
exactamente
tanta
memoria
requiera
ejemplo
utiliza
64
Mbytes
memoria
principal
muestra
Figura
7.4
Inicial-
mente
memoria
principal
vacía
sistema
operativo
proce-
sos
cargan
justo
sistema
operativo
finaliza
ocupando
espacio
justo
proceso
deja
hueco
memoria
pequeño
cuarto
pro-
ceso
momento
procesos
encuentran
memoria
disponible
sistema
operativo
proceso
disco
deja
suficiente
espacio
cargar
proceso
proceso
proceso
pequeño
proceso
crea
pe-
queño
hueco
Posteriormente
alcanza
punto
procesos
memoria
principal
listo
proceso
Listo-Suspendido
disponible
es-
Gestión
memoria
315
Sistema
operativo
procesos
cola
procesos
participación
única
cola
Sistema
operativo
procesos
Figura
.3
Asignación
memoria
particionamiento
fijo
07-Capitulo
16/5/05
17:04
Página
315pacio
suficiente
memoria
proceso
sistema
operativo
disco
proceso
memoria
proceso
muestra
ejemplo
método
comienza
correctamente
finalmente
si-
tuación
huecos
pequeños
memoria
medida
pasa
tiempo
memoria
fragmenta
utilización
memoria
decrementa
fenómeno
conoce
fragmentación
externa
indicando
memoria
externa
particio-
nes
fragmenta
forma
incremental
contraposición
ocurre
fragmentación
in-
terna
descrita
anteriormente
técnica
eliminar
fragmentación
externa
compactación
sis-
tema
operativo
desplaza
procesos
memoria
forma
encuentren
contiguos
memoria
libre
encontrará
unida
bloque
ejemplo
Figura
7.4R
compactación
permite
obtener
bloque
memoria
libre
longitud
16M.
suficiente
cargar
proceso
adicional
desventaja
compactación
procedimiento
consume
tiempo
malgasta
tiempo
procesador
Obsérvese
compacta-
ción
requiere
capacidad
reubicación
dinámica
mover
programa
región
memoria
principal
invalidar
referencias
memoria
programa
véase
Apéndice
7A
316
Sistemas
operativos
Aspectos
internos
principios
diseño
Sistema
operativo
20
36
56
Sistema
operativo
Proceso
20
14
22
Sistema
operativo
Proceso
Proceso
20
14
18
Sistema
operativo
Proceso
Proceso
14MProceso
Proceso
Sistema
operativo
Proceso
Proceso
20
18
Sistema
operativo
Proceso
Proceso
Proceso
Sistema
operativo
Proceso
Proceso
18
Sistema
operativo
Proceso
Proceso
20
14
18
20
18
Figura
.4
efecto
particionamiento
dinámico
07-Capitulo
16/5/05
17:04
Página
316Algoritmo
ubicación
compactación
memoria
consume
cantidad
tiempo
diseñador
sistema
operativo
inteligente
hora
decidir
asignar
memoria
procesos
eliminar
huecos
hora
cargar
intercambiar
proceso
memoria
principal
bloque
memoria
libre
suficiente
tamaño
sistema
operativo
decidir
bloque
libre
asignar
algoritmos
colocación
considerarse
mejor-ajuste
best-fit
primer-ajus-
te(first-fit
siguiente-ajuste
next-fit
limitados
escoger
blo-
ques
libres
memoria
principal
iguales
proceso
llevarse
memoria
Mejor-ajuste
escoge
bloque
cercano
tamaño
petición
Primer-ajuste
co-
mienza
analizar
memoria
principio
escoge
bloque
disponible
sufi-
cientemente
Siguiente-ajuste
comienza
analizar
memoria
colocación
elige
bloque
disponible
suficientemente
Figura
7.5a
muestra
ejemplo
configuración
memoria
número
colo-
caciones
intercambios
disco
bloque
utilizó
bloque
22
Mbytes
crea
partición
14
Mbytes
Figura
7.5b
muestra
diferencia
algoritmos
me-
jor-
primer-
siguiente-
ajuste
hora
satisfacer
petición
asignación
16
Mbytes
Me-
Gestión
memoria
317
12
22
18
14
36
bloque
asignado
12
14
20
Próximo-ajuste
Bloque
asignado
Mejor-ajuste
Primer-ajuste
Bloque
libre
asignación
Figura
.5
Ejemplo
configuración
memoria
asignación
bloque
16
Mbytes
07-Capitulo
16/5/05
17:04
Página
317jor-ajuste
busca
lista
completa
bloques
disponibles
bloque
18
Mbytes
dejando
fragmento
Mbytes
Primer-ajuste
provoca
fragmento
Mbytes
siguiente-ajuste
pro-
voca
fragmento
20
Mbytes
técnicas
depende
secuencia
exacta
intercambio
procesos
ta-
maño
dichos
procesos
comentarios
véase
BREN89
SHOR75
BAYS77
algoritmo
primer-ajuste
sencillo
normalmente
rápido
algoritmo
siguiente-ajuste
tiende
producir
resulta-
ligeramente
peores
primer-ajuste
algoritmo
siguiente-ajuste
llevará
frecuentemente
asignación
bloque
libre
memoria
resultado
bloque
memoria
libre
normalmente
aparece
espacio
memoria
divide
rápidamente
pequeños
fragmentos
caso
algoritmo
siguiente-ajuste
requerir
fre-
cuentemente
compactación
algoritmo
primer-ajuste
dejar
espacio
almacenamiento
pequeñas
particiones
libres
necesitan
buscarse
paso
primer-
ajuste
algoritmo
mejor-ajuste
nombre
comportamiento
normalmente
algoritmo
busca
bloque
pequeño
satisfaga
petición
garantiza
fragmento
quede
pequeño
petición
memoria
malgasta
cantidad
pequeña
memoria
resultado
memoria
principal
queda
rápidamente
bloques
pequeños
satisfacer
peticiones
asignación
memoria
compactación
memoria
frecuentemente
resto
algoritmos
Algoritmo
reemplazamiento
sistema
multiprogramado
utiliza
particionamiento
dinámico
momento
procesos
memoria
principal
estén
bloqueado
suficiente
me-
moria
proceso
adicional
cabo
compactación
evitar
mal-
gastar
tiempo
procesador
esperando
proceso
desbloquee
sistema
operativo
inter-
cambiará
procesos
memoria
principal
disco
sitio
proceso
proceso
encuentre
Listo-Suspendido
sistema
operati-
vo
escoger
proceso
reemplazar
tema
algoritmos
reemplazo
contemplará
detalle
esquemas
memoria
virtual
pospone
discusión
SISTEMA
BUDDY
esquemas
particionamiento
fijo
dinámico
desventajas
esquema
particio-
namiento
fijo
limita
número
procesos
activos
utilizar
espacio
ineficientemente
ajuste
tamaños
partición
disponibles
tamaños
procesos
es-
quema
particionamiento
dinámico
complejo
mantener
incluye
sobrecarga
compactación
compromiso
interesante
sistema
buddy
KNUT97
PETE77
sistema
buddy
bloques
memoria
disponibles
tamaño
2L
bloque
tamaño
pequeño
asignado
2U
bloque
tamaño
asignado
normalmente
tamaño
memoria
completa
disponible
comenzar
espacio
completo
disponible
único
bloque
tamaño
U.
realiza
petición
tamaño
2U-1
2U
asigna
bloque
entero
caso
blo-
318
Sistemas
operativos
Aspectos
internos
principios
diseño
07-Capitulo
16/5/05
17:04
Página
318que
divide
bloques
buddy
iguales
tamaño
U-1
2U-2
2U-1
asigna
pe-
tición
bloques
caso
divide
mitad
proceso
continúa
bloque
pequeño
genera
asigna
peti-
ción
momento
sistema
buddy
mantiene
lista
huecos
bloques
asignar
tamaño
i.
hueco
eliminarse
lista
i+1
dividiéndolo
mitad
crear
bloques
tamaño
lista
i.
par
bloques
lista
encuentren
asigna-
eliminados
dicha
lista
unidos
único
bloque
lista
i+1
cabo
petición
asignación
tamaño
2i-1
2i
utiliza
algoritmo
recursivo
LIST93
encontrar
hueco
tamaño
void
obtener_hueco
int
if
i==(U+1
fallo
if
lista_i
vacía
obtener_hueco(i+1
dividir
hueco
buddies
colocar
buddies
lista_i
tomar
hueco
lista_i
Figura
7.6
muestra
ejemplo
utiliza
bloque
inicial
Mbyte
petición
100
Kbytes
forma
necesita
bloque
128K.
bloque
inicial
divide
512K.
divide
bloques
256
divide
128
asigna
A.
petición
solicita
bloque
256K.
bloque
disponible
asignado
proceso
continúa
provocando
divisiones
fusiones
bloques
requiere
Obsérvese
libera
unen
bloques
128
bloque
256
inmediatamente
unido
bloque
compañero
buddy
Figura
7.7
muestra
representación
forma
árbol
binario
asignación
bloques
inmediatamente
petición
Liberar
nodos
hoja
representan
particionamiento
memoria
actual
bloques
nodos
hoja
asig-
nado
caso
unen
bloque
sistema
buddy
compromiso
razonable
eliminar
desventajas
esquemas
particionamiento
fijo
variable
sistemas
operativos
contemporáneos
memoria
vir-
tual
basada
paginación
segmentación
superior
sistema
buddy
utilizado
sistemas
paralelos
forma
eficiente
asignar
liberar
programas
paralelos
ejem-
plo
véase
JOHN92
forma
modificada
sistema
buddy
utiliza
asignación
memo-
ria
núcleo
UNIX
descrito
Capítulo
8)
REUBICACIÓN
considerar
formas
tratar
problemas
particionamiento
aclarar
aspecto
relacionado
colocación
procesos
memoria
utiliza
esquema
parti-
cionamiento
fijo
Figura
7.3a
espera
proceso
asigne
partición
Gestión
memoria
319
07-Capitulo
16/5/05
17:04
Página
319Es
partición
seleccionada
carga
proceso
utiliza-
intercambio
proceso
memoria
área
swap
disco
caso
utili-
za
cargador
sencillo
describe
Apéndice
7A
proceso
carga
320
Sistemas
operativos
Aspectos
internos
principios
diseño
bloque
Mbyte
Solicitar
100
Solicitar
240
Solicitar
64
Solicitar
256
Liberar
Liberar
Solicitar
75
Liberar
Liberar
Liberar
512K256KA
/H11005
128K128
512
KB
/H11005
256KA
/H11005
128K128
512
KB
/H11005
256KA
/H11005
128KC
/H11005
64K64
256
KB
/H11005
256
/H11005
256KA
/H11005
128KC
/H11005
64K64
256
256KD
/H11005
256KA
/H11005
128KC
/H11005
64K64
256
256KD
/H11005
256KE
/H11005
128KC
/H11005
64K64
256
256KD
/H11005
256KE
/H11005
128K128
512
256KD
/H11005
256
256
256KD
/H11005
256K128
/H11005
64K64
Figura
.6
Ejemplo
sistema
Buddy
256
256KD
/H11005
256KA
/H11005
128KC
/H11005
64K64
512
256
128
64
Figura
.7
.Representación
forma
árbol
sistema
Buddy
07-Capitulo
16/5/05
17:04
Página
320primera
referencias
memoria
relativas
código
reemplazan
direcciones
memoria
principal
absolutas
determinadas
dirección
base
proceso
cargado
caso
particiones
tamaño
Figura
7.2
caso
única
cola
proce-
sos
particiones
distinto
tamaño
Figura
7.3b
proceso
ocupar
particio-
nes
transcurso
ciclo
vida
imagen
proceso
crea
carga
partición
memoria
principal
proceso
llevarse
disco
trae
memoria
principal
posteriormente
asignarse
partición
dis-
tinta
ocurre
caso
particionamiento
dinámico
Obsérvese
Figuras
7.4c
proceso
ocupa
regiones
memoria
ocasiones
trae
memoria
utiliza
compactación
procesos
desplazan
memoria
principal
ubicaciones
instrucciones
datos
referenciadas
proceso
fijas
Cambiarán
proceso
intercambia
desplaza
resolver
problema
realiza
distinción
tipos
direcciones
dirección
lógica
referencia
ubicación
memoria
independiente
asignación
actual
datos
memoria
cabo
traducción
dirección
física
alcance
acceso
memoria
dirección
relativa
ejemplo
particular
dirección
lógica
dirección
expresa
ubicación
relativa
punto
conocido
nor-
malmente
valor
registro
procesador
dirección
física
dirección
absoluta
ubicación
real
memoria
principal
programas
emplean
direcciones
relativas
memoria
cargan
utilizando
carga
dinámi-
ca
tiempo
ejecución
véase
Apéndice
7A
recoge
discusión
Normalmente
referencias
memoria
procesos
cargados
relativas
origen
programa
necesita
mecanismo
hardware
traducir
direcciones
relativas
direcciones
físicas
memoria
principal
tiempo
ejecución
instrucción
contiene
dicha
referencia
Figura
7.8
muestra
forma
realiza
normalmente
traducción
direcciones
proceso
asigna
Ejecutando
registro
especial
procesador
llamado
registro
base
carga
dirección
inicial
programa
memoria
principal
registro
valla
indica
ubicación
programa
valores
establecen
cuan-
do
programa
carga
memoria
imagen
proceso
memoria
ejecución
proceso
encuentran
direcciones
relativas
incluyen
contenidos
registro
instrucciones
direcciones
instrucciones
ocurren
saltos
instruc-
ciones
call
direcciones
datos
existentes
instrucciones
carga
almacenamiento
procesa-
dor
manipula
dirección
relativa
pasos
valor
registro
base
suma
dirección
relativa
producir
dirección
absoluta
dirección
resultante
compara
valor
registro
valla
dirección
límites
cabo
ejecución
instrucción
caso
genera
interrupción
manejar
sistema
operativo
esquema
Figura
7.8
permite
traigan
memoria
programas
lleven
disco
ejecución
proporciona
medida
protección
imagen
proceso
aislada
contenidos
registros
base
valla
evita
accesos
autorizados
procesos
.3
PAGINACIÓN
particiones
tamaño
fijo
variable
ineficientes
memoria
pri-
meros
provocan
fragmentación
interna
fragmentación
externa
Supóngase
memoria
principal
divide
porciones
tamaño
fijo
relativamente
pequeños
proceso
divide
porciones
pequeñas
tamaño
fijo
dichas
porciones
pro-
Gestión
memoria
321
07-Capitulo
16/5/05
17:04
Página
321ceso
conocidas
páginas
asigna
porciones
disponibles
memoria
conocidas
marcos
marcos
páginas
sección
muestra
espacio
memoria
malgastado
proceso
fragmentación
interna
corresponde
fracción
página
proceso
fragmentación
externa
Figura
7.9
ilustra
páginas
marcos
momento
marcos
memoria
libres
sistema
operativo
mantiene
lista
mar-
cos
libres
proceso
almacenado
disco
formado
páginas
momento
cargar
proceso
sistema
operativo
marcos
libres
carga
pá-
ginas
proceso
dichos
marcos
Figura
7.9b
proceso
formado
páginas
proceso
formado
páginas
cargan
continuación
momento
proceso
suspende
deja
memoria
principal
Posteriormente
procesos
memoria
princi-
pa
bloquean
sistema
operativo
necesita
traer
proceso
proceso
formado
páginas
supóngase
ejemplo
suficientes
marcos
contiguos
utilizar
ubicar
proceso
evitaría
sistema
operativo
cargara
proceso
respuesta
utilizar
concepto
dirección
lógica
registro
base
senci-
llo
direcciones
basta
ocasión
lugar
sistema
operativo
mantiene
tabla
páginas
proceso
tabla
páginas
muestra
ubicación
marco
página
proceso
programa
dirección
lógica
formada
número
página
desplazamiento
página
importante
recordar
caso
partición
simple
dirección
lógica
ubicación
palabra
relativa
comienzo
programa
procesador
traduce
dirección
física
paginación
traducción
direcciones
lógicas
físicas
realiza
hardware
procesador
procesador
acceder
ta-
322
Sistemas
operativos
Aspectos
internos
principios
diseño
Bloque
control
proceso
Programa
Datos
Pila
Comparador
Interrupción
sistema
operativo
Dirección
absoluta
Imagen
proceso
memoria
principal
Dirección
relativa
Registro
base
Registro
valla
Sumador
Figura
.8
Soporte
hardware
reubicación
07-Capitulo
16/5/05
17:04
Página
322bla
páginas
proceso
actual
Presentado
dirección
lógica
número
página
despla-
zamiento
procesador
utiliza
tabla
páginas
producir
dirección
física
número
marco
desplazamiento
Continuando
ejemplo
páginas
proceso
cargan
marcos
11
12
Figura
7.10
muestra
tablas
páginas
momento
tabla
páginas
contiene
entrada
página
proceso
forma
tabla
inde-
xe
fácilmente
número
página
iniciando
página
entrada
tabla
pá-
ginas
contiene
número
marco
memoria
principal
contiene
página
co-
rrespondiente
Adicionalmente
sistema
operativo
mantiene
única
lista
marcos
libres
marcos
memoria
encuentran
actualmente
ocupados
disponibles
páginas
Gestión
memoria
323
Marco
número
Memoria
principal
10
11
12
13
14
Quince
marcos
disponibles
10
11
12
13
14
Cargar
proceso
10
11
12
13
14
Intercambiar
10
11
12
13
14
Cargar
proceso
10
11
12
13
14
Cargar
proceso
10
11
12
13
14
Cargar
proceso
A.0
A.1
A.2
A.3
A.0
A.1
A.2
A.3
A.0
A.1
A.2
A.3
A.0
A.1
A.2
A.3
A.0
A.1
A.2
A.3
C.0
C.1
C.2
C.3
C.1
C.2
C.3
C.1
C.2
C.3
C.0
C.0
D.0
D.1
D.2
B.0
B.1
B.2
D.3
D.4
B.0
B.1
B.2
Memoria
principal
Memoria
principal
Memoria
principal
Memoria
principal
Memoria
principal
Figura
.9
Asignación
páginas
proceso
marcos
libres
07-Capitulo
16/5/05
17:04
Página
323Por
vemos
paginación
simple
describe
similar
particiona-
miento
fijo
diferencias
paginación
particiones
pequeñas
pro-
grama
ocupar
partición
dichas
particiones
necesitan
contiguas
esquema
paginación
conveniente
tamaño
página
tamaño
marco
potencia
tamaño
página
potencia
fácil
de-
mostrar
dirección
relativa
define
referencia
origen
programa
dirección
lógica
expresada
número
página
desplazamiento
muestra
ejem-
plo
Figura
7.11
ejemplo
utilizan
direcciones
16
bits
tamaño
página
1024
bytes
dirección
relativa
1502
formato
binario
00000101110
11110
pá-
gina
tamaño
necesita
campo
desplazamiento
10
bits
dejando
bits
número
página
programa
compuesto
máximo
6=64
páginas
byte
muestra
Figura
7.11
dirección
relativa
1502
corresponde
desplaza-
miento
478
0111011110
página
000001
forma
número
16
bits
0000010111011110
consecuencias
utilizar
tamaño
página
potencia
dobles
esquema
direccionamiento
lógico
transparente
programador
ensamblador
montador
dirección
lógica
número
página
desplazamiento
programa
idéntica
dirección
relativa
relativamente
sencillo
implementar
función
ejecute
hardware
cabo
dinámicamente
traducción
direcciones
tiempo
ejecución
Considérese
dirección
n+m
bits
bits
izquierda
corresponden
número
página
bits
derecha
corresponden
desplazamiento
ejemplo
Figura
7.11b
10
nece-
sita
cabo
siguientes
pasos
traducción
direcciones
Extraer
número
página
bits
izquierda
dirección
lógica
Utilizar
número
página
índice
tabla
páginas
proceso
encontrar
número
marco
k.
dirección
física
inicial
marco
dirección
física
byte
referenciado
di-
cho
número
desplazamiento
dirección
física
necesita
calcularse
fácilmente
construida
concatenando
número
marco
desplazamiento
ejemplo
dirección
lógica
0000010111011110
corresponde
página
número
desplazamiento
478
Supóngase
página
reside
marco
memoria
principal
número
binario
000110
dirección
física
corresponde
marco
número
desplaza-
miento
478
0001100111011110
Figura
7.12a
Resumiendo
paginación
simple
memoria
principal
divide
marcos
peque-
ños
tamaño
proceso
divide
páginas
tamaño
procesos
pequeños
requieren
páginas
procesos
mayores
requieren
proceso
trae
memo-
324
Sistemas
operativos
Aspectos
internos
principios
diseño
Tabla
páginas
proceso
13
14
Lista
marcos
libre
10
113
12
Tabla
páginas
proceso
Tabla
páginas
proceso
Tabla
páginas
proceso
Figura
.10
Estructuras
datos
ejemplo
Figura
.9
instante
07-Capitulo
16/5/05
17:04
Página
324ria
páginas
cargan
marcos
disponibles
establece
tabla
páginas
técnica
resuelve
problemas
inherentes
particionamiento
.4
SEGMENTACIÓN
programa
usuario
subdividir
utilizando
segmentación
programa
datos
asociados
dividen
número
segmentos
requiere
programas
longitud
longitud
máxima
segmento
caso
pagina-
ción
dirección
lógica
utilizando
segmentación
compuesta
partes
caso
nú-
mero
segmento
desplazamiento
segmentos
distinto
tamaño
segmentación
similar
particionamiento
dinámico
ausencia
esquema
overlays
memoria
virtual
necesitaría
segmentos
programa
cargaran
memoria
ejecución
diferencia
comparada
particionamiento
dinámico
segmentación
programa
ocupar
partición
particiones
necesitan
contiguas
segmentación
elimina
frag-
mentación
interna
particionamiento
dinámico
sufre
fragmentación
externa
proceso
divide
piezas
pequeñas
fragmentación
ex-
terna
debería
menor
paginación
invisible
programador
segmentación
normalmente
visible
proporciona
utilidad
organizar
programas
datos
Normalmente
programador
compilador
asignará
programas
datos
segmentos
propósitos
programa-
ción
modular
programas
datos
dividir
posteriormente
múltiples
segmentos
in-
Gestión
memoria
325
Dirección
lógica
Segmento
desplazamiento
752
Fragmentación
interna
Segmentación(a
Particionado
Paginación
tamaño
página
752
Segmento
1950
bytes
0000010111011110
0001001011110000
Dirección
lógica
Página
Desplazamiento
478Dirección
relativa
1502
0000010111011110
478
Proceso
usuario
2700
bytes
Segmento
750
bytes
Página
Página
Página
Figura
.11
Direcciones
lógicas
07-Capitulo
16/5/05
17:04
Página
325conveniente
principal
servicio
programador
consciente
limitación
tamaño
segmento
máximo
consecuencia
utilizar
segmentos
distinto
tamaño
relación
simple
en-
tre
direcciones
lógicas
direcciones
físicas
forma
análoga
paginación
esquema
seg-
mentación
sencillo
haría
tabla
segmentos
proceso
lista
bloques
libre
memoria
principal
entrada
tabla
segmentos
tendría
proporcionar
dirección
inicial
memoria
principal
correspondiente
segmento
entrada
debería
proporcio-
nar
longitud
segmento
asegurar
utilizan
direcciones
válidas
pro-
ceso
entra
Ejecutando
dirección
tabla
segmentos
carga
registro
espe-
cial
utilizado
hardware
gestión
memoria
Considérese
dirección
n+m
bits
bits
izquierda
corresponden
número
segmento
bits
derecha
corresponden
desplazamiento
ejemplo
Figura
7.11c
12
tamaño
segmento
máximo
12
4096
necesita
cabo
siguientes
pasos
traducción
direcciones
Extraer
número
segmento
bits
izquierda
dirección
lógica
Utilizar
número
segmento
índice
tabla
segmentos
proceso
en-
contrar
dirección
física
inicial
segmento
326
Sistemas
operativos
Aspectos
internos
principios
diseño
000010111011110
Página
bits
Desplazamiento
10
bits
Tabla
páginas
proceso
Dirección
lógica
16
bits
0001100111011110
Dirección
física
16
bits
Paginación
000101
0001001011110000
Segmento
bits
Desplazamiento
12
bits
Tabla
segmentos
proceso
Longitud
Base
Dirección
lógica
16
bits
0010001100010000
Dirección
física
16
bits
Segmentación
0010111011100
0000010000000000
0111100111100010000000100000
000110
011001
Figura
.12
Ejemplos
traducción
direcciones
lógicas
físicas
07-Capitulo
16/5/05
17:04
Página
326•
Comparar
desplazamiento
expresado
bits
derecha
longitud
seg-
mento
desplazamiento
longitud
dirección
válida
dirección
física
deseada
suma
dirección
física
inicial
desplazamiento
ejemplo
dirección
lógica
0001001011110000
corresponde
segmento
número
desplazamiento
752
Supóngase
segmento
reside
memoria
principal
comen-
zando
dirección
física
inicial
0010000000100000
dirección
física
0010000000100000
001011110000
0010001100010000
Figura
7.12b
Resumiendo
segmentación
simple
proceso
divide
conjunto
segmentos
tamaño
proceso
trae
memoria
segmentos
cargan
regiones
memoria
disponibles
crea
tabla
segmentos
.5
RESUMEN
tareas
importantes
complejas
sistema
operativo
gestión
memoria
gestión
memoria
implica
tratar
memoria
principal
recurso
asignarse
com-
partirse
procesos
activos
utilizar
procesador
utilidades
eficientemen-
deseable
mantener
tantos
procesos
memoria
principal
desea-
ble
liberar
programadores
restricciones
tamaño
desarrollo
programas
herramientas
básicas
gestión
memoria
paginación
segmentación
pa-
ginación
proceso
divide
conjunto
páginas
tamaño
fijo
tamaño
relativa-
mente
pequeño
segmentación
permite
piezas
tamaño
variable
combinar
segmentación
paginación
único
esquema
gestión
memoria
.6
LECTURAS
RECOMENDADAS
libros
sistema
operativos
recomendados
Sección
2.9
proporcionan
cobertura
ges-
tión
memoria
sistema
particionamiento
suplantado
técnicas
memoria
virtual
mayoría
libros
cubren
superficialmente
tema
tratamientos
completos
interesantes
MILE92
discusión
profunda
estrategias
particiona-
miento
KNUT97
temas
enlace
carga
cubren
libros
desarrollo
programas
arquitectura
computadores
sistemas
operativos
tratamiento
particularmente
detallado
BECK90
CLAR98
contiene
discusión
discusión
práctica
detalle
tema
numerosos
ejemplos
sistemas
operativos
LEVI99
BECK90
Beck
L.
System
Software
Reading
MA
Addison-Wesley
1990
CLAR98
Clarke
D.
and
Merusi
D.
System
Software
Programming
The
Way
Things
Work
Upper
Sadd-
River
NJ
Prentice
Hall
1998
KNUT97
Knuth
D.
The
Art
of
Computer
Programming
Volume
Fundamental
Algorithms
Reading
MA
Addison-Wesley
1997
LEVI99
Levine
J.
Linkers
and
Loaders
New
York
Elsevier
Science
and
Technology
1999
MILE92
Milenkovic
M.
Operating
Systems
Concepts
and
Design
New
York
McGraw-Hill
1992
Gestión
memoria
327
07-Capitulo
16/5/05
17:04
Página
3277
.7
TÉRMINOS
CLAVE
CUESTIONES
REVISIÓN
PROBLEMAS
TÉRMINOS
CLAVE
Carga
Enlace
dinámico
Particionamiento
Carga
absoluta
Enlazado
Particionamiento
dinámico
Carga
tiempo
real
dinámica
Fragmentación
externa
Particionamiento
fijo
Carga
reubicable
Fragmentación
interna
Protección
Compactación
Gestión
memoria
Reubicación
Compartición
Marca
Segmentación
Dirección
física
Organización
lógica
Sistema
XXXX
Dirección
lógica
Organización
física
Tabla
páginas
Dirección
relativa
Página
Editor
enlaces
Paginación
CUESTIONES
REVISIÓN
7.1
requisitos
intenta
satisfacer
gestión
memoria
7.2
deseable
capacidad
reubicar
procesos
7.3
forzar
protección
memoria
tiempo
compilación
7.4
razones
permitir
procesos
accedan
región
memoria
7.5
esquema
particionamiento
fijo
ventajas
utilizar
particiones
distinto
tamaño
7.6
diferencia
fragmentación
interna
externa
7.7
distinciones
direcciones
lógicas
relativas
físicas
7.8
diferencia
página
marco
7.9
diferencia
página
segmento
PROBLEMAS
7.1
Sección
2.3
listaron
objetivos
gestión
memoria
Sección
7.1
requisitos
Discutir
lista
incluye
aspectos
tratados
lista
7.2
Considérese
esquema
particionamiento
fijo
particiones
tamaño
16
bytes
memoria
principal
tamaño
24
bytes
proceso
residente
mantiene
tabla
procesos
incluye
puntero
partición
bits
nece-
sita
puntero
7.3
Considérese
esquema
particionamiento
dinámico
Demostrar
media
me-
moria
contiene
mitad
huecos
segmentos
7.4
implementar
algoritmos
colocación
discutidos
particiona-
miento
dinámico
Sección
7.2
guardar
lista
bloques
libres
memoria
328
Sistemas
operativos
Aspectos
internos
principios
diseño
07-Capitulo
16/5/05
17:04
Página
328Para
métodos
discutidos
ajuste
best-fit
ajuste
first-fit
ajuste
next-fit
longitud
media
búsqueda
7.5
algoritmo
colocación
particionamiento
dinámico
ajuste
worst-fit
caso
utiliza
bloque
memoria
libre
proceso
Dis-
cutir
ventajas
inconvenientes
método
comparado
me-
jor
ajuste
longitud
media
búsqueda
ajuste
7.6
utiliza
esquema
particionamiento
dinámico
determinado
momento
configuración
memoria
áreas
sombreadas
bloques
asignados
áreas
blancas
bloques
libres
si-
guientes
peticiones
memoria
40
20
10M.
Indíquese
dirección
ini-
cial
bloques
utilizando
siguientes
algoritmos
colocación
ajuste
ajuste
ajuste
Asúmase
bloque
añadido
recientemente
co-
mienzo
memoria
ajuste
7.7
bloque
memoria
Mbyte
asigna
utilizando
sistema
buddy
Mostrar
resultados
secuencia
figura
similar
Figura
7.6
Petición
70
Petición
35
Petición
80
Respuesta
Petición
60
Respuesta
Respues-
ta
Respuesta
C.
Mostrar
representación
árbol
binario
Respuesta
B.
7.8
Considérese
sistema
buddy
determinado
bloque
asignación
actual
tie-
ne
dirección
0110
11110000
bloque
tamaño
dirección
binaria
bloque
compañero
buddy
bloque
tamaño
16
dirección
binaria
bloque
compañero
buddy
7.9
buddy
k(x
dirección
bloque
tamaño
cuya
dirección
x.
Escribir
expre-
sión
general
bloque
compañero
buddy
buddyk(x
7.10
secuencia
Fibonacci
define
Fo=0
F1=1
Fn+2=
Fn+1
Fn
utilizarse
secuencia
establecer
sistema
buddy
ventaja
sistema
sistema
buddy
binario
descrito
capítulo
Gestión
memoria
329
20
20
20
20
10
40
30
40
40M40
60
60
07-Capitulo
16/5/05
17:04
Página
3297.11
curso
ejecución
programa
procesador
incrementará
palabra
contenidos
registro
instrucciones
contador
programa
car-
gue
instrucción
alterará
contenidos
registro
salto
instrucción
llamada
provoque
ejecución
programa
consi-
dérese
Figura
7.8
alternativas
direcciones
instrucción
Mantener
dirección
relativa
registro
instrucciones
traducción
direcciones
dinámica
utilizando
registro
instrucciones
entrada
salto
llamada
dirección
relativa
generada
salto
llama-
carga
registro
instrucciones
Mantener
dirección
absoluta
registro
instrucciones
salto
llamada
emplea
traducción
direcciones
dinámica
almacenando
resultados
registro
instrucciones
opción
preferible
7.12
Considérese
sistema
paginación
sencillo
siguientes
parámetros
32
bytes
memoria
física
tamaño
página
10
bytes
216
páginas
espacio
direccionamiento
lógico
bits
dirección
lógica
bytes
marco
bits
dirección
física
especifica
marco
entradas
tabla
páginas
bits
entrada
tabla
páginas
Asúmase
entrada
tabla
páginas
incluye
bit
válido
inválido
7.13
dirección
virtual
sistema
paginación
equivalente
par
número
pagina
número
bytes
página
nú-
mero
bytes
página
Encontrar
ecuaciones
algebraicas
muestren
funciones
a.
7.14
Considérese
sistema
segmentación
sencillo
tabla
segmentos
Dirección
inicial
Longitud
bytes
660
248
1752
422
222
198
996
604
siguientes
direcciones
lógicas
determina
dirección
física
indica
produce
fallo
segmento
0,198
2,156
1,530
3,444
0,222
330
Sistemas
operativos
Aspectos
internos
principios
diseño
07-Capitulo
16/5/05
17:04
Página
3307.15
Considérese
memoria
colocan
segmentos
contiguos
S2
or-
den
creación
extremo
dispositivo
sugiere
figura
crea
segmento
contiguos
n+1,se
coloca
inmediatamente
inclu-
so
segmentos
S1
S2
hubieran
borrado
límite
segmentos
borrados
hueco
alcanzan
extremo
memoria
seg-
mentos
compactan
Mostrar
fracción
tiempo
utilizada
compactación
cumple
inigualdad
longitud
media
segmento
palabras
tiempo
vida
segmento
referencias
memoria
fracción
memoria
utiliza
condiciones
equilibrio
Sugerencia
Encontrar
velocidad
media
límites
cruzan
memoria
Encontrar
f=0,2
t=1000
s=50
APÉNDICE
7A
CARGA
ENLACE
paso
creación
proceso
activo
cargar
programa
memoria
principal
cre-
ar
imagen
proceso
Figura
7.13
Figura
7.14
muestra
escenario
típico
mayoría
sistemas
aplicación
formada
módulos
compilados
ensamblados
formato
código
objeto
enlazados
resolver
referencias
módulos
tiempo
resuelven
referencias
rutinas
biblioteca
rutinas
biblioteca
incorpo-
rarse
programa
hacerle
referencia
código
compartido
sistema
operativo
proporciona
tiempo
ejecución
apéndice
resumen
características
clave
enlazadores
cargadores
motivos
claridad
presentación
comienza
descripción
tarea
carga
módulo
programa
caso
requiere
enlace
CARGA
Figura
7.14
cargador
coloca
módulo
carga
memoria
principal
comenzando
ubicación
x.
carga
programa
satisfacer
requisito
direccionamiento
mostrado
Figura
7.1
general
seguir
técnicas
Carga
absoluta
Carga
reubicable
Carga
dinámica
tiempo
real
kf
s≥
-1
12
Gestión
memoria
331
HuecoS2
SnS1
07-Capitulo
16/5/05
17:04
Página
331332
Sistemas
operativos
Aspectos
internos
principios
diseño
Bloque
control
proceso
Pila
Imagen
proceso
memoria
principal
Programa
Datos
Código
objeto
Programa
Datos
Figura
.13
función
carga
Memoria
principal
Cargador
Módulo
cargaMontadorMódulo
Módulo
Módulo
Biblioteca
Figura
.14
escenario
carga
07-Capitulo
16/5/05
17:04
Página
332Carga
absoluta
cargador
absoluto
requiere
módulo
carga
cargarse
ubi-
cación
memoria
principal
módulo
carga
presentado
cargador
re-
ferencias
direcciones
direcciones
memoria
principal
específicas
absolutas
ejem-
plo
Figura
7.14
ubicación
1024
palabra
módulo
carga
destinado
dicha
región
memoria
dirección
1024
asignación
valores
direcciones
específicas
referencias
programa
pro-
grama
programador
tiempo
compilación
ensamblado
Tabla
7.2a
opción
desventajas
programador
estra-
tegia
asignación
colocar
módulos
memoria
principal
modificación
programa
implique
inserciones
borrados
cuerpo
módulo
to-
das
direcciones
alterarse
preferible
permitir
referencias
memoria
programas
expresen
simbólicamente
resolver
dichas
referencias
simbóli-
cas
tiempo
compilación
ensamblado
queda
reflejado
Figura
7.15
referencia
instrucción
elemento
datos
representa
inicialmente
símbolo
hora
pre-
parar
módulo
entrada
cargador
absoluto
ensamblador
compilador
convertirá
referencias
direcciones
específicas
ejemplo
módulo
carga
dirección
inicial
1024
muestra
Figura
7.15b
abla
.2.Asociación
direcciones
Cargador
Tiempo
asociación
Función
Tiempo
programación
programador
especifica
directamente
programa
direcciones
físicas
reales
Tiempo
compilación
programa
contiene
referencias
direcciones
simbólicas
compila-
ensamblado
dor
ensamblador
convierte
direcciones
físicas
reales
Tiempo
carga
compilador
ensamblador
produce
direcciones
relativas
cargador
traduce
direcciones
absolutas
carga
programa
Tiempo
ejecución
programa
cargador
retiene
direcciones
relativas
hardware
pro-
cesador
convierte
dinámicamente
direcciones
absolutas
Montador
Tiempo
montaje
Función
Tiempo
programación
permiten
referencias
programas
datos
externos
programa-
dor
colocar
programa
código
fuente
subpro-
gramas
invoque
Tiempo
compilación
ensamblador
traer
código
fuente
subrutina
re-
ensamblado
ferencia
ensamblarlo
unidad
Creación
módulo
módulos
objeto
ensamblado
utilizando
direcciones
rela-
carga
tivas
módulos
enlazan
juntos
referencias
restable-
cen
relación
origen
módulo
carga
Tiempo
carga
referencias
externas
resuelven
módulo
carga
carga
memoria
principal
momento
módulos
enlace
di-
námico
referenciados
adjuntan
módulo
carga
paquete
com-
pleto
carga
memoria
principal
virtual
Tiempo
ejecución
referencias
externas
resuelven
procesador
ejecuta
llamada
externa
momento
proceso
interrumpe
mó-
dulo
deseado
enlaza
programa
invoca
Gestión
memoria
333
07-Capitulo
16/5/05
17:04
Página
333Carga
reubicable
desventaja
enlazar
referencias
memoria
direcciones
específicas
carga
módulo
carga
resultante
colocar
región
específica
memoria
principal
programas
comparten
memoria
principal
deseable
decidir
principio
región
memoria
cargar
módulo
particular
tomar
deci-
sión
tiempo
carga
necesitamos
módulo
carga
ubicarse
lugar
memoria
principal
satisfacer
requisito
ensamblador
compilador
produce
direcciones
me-
moria
reales
direcciones
absolutas
direcciones
relativas
punto
conocido
inicio
programa
técnica
muestra
Figura
7.15c
comienzo
módulo
carga
asigna
dirección
relativa
resto
referencias
memoria
módulo
expre-
san
relativas
comienzo
módulo
referencias
memoria
expresadas
formato
relativo
colocar
módulo
lugar
adecuado
convierte
tarea
simple
cargador
módulo
carga
comienzo
ubicación
cargador
simplemente
añadir
referencia
memoria
carga
módulo
memoria
asistir
tarea
módulo
cargado
incluir
infor-
mación
cargador
referencias
memoria
interpretar
nor-
malmente
relativo
origen
programa
relativo
punto
programa
ubicación
actual
compilador
ensamblador
prepara
conjunto
infor-
mación
denomina
normalmente
diccionario
reubicación
Carga
dinámica
tiempo
real
cargadores
reubicables
comunes
proporcionan
beneficios
obvios
comparan
cargadores
absolutos
entorno
multiprogramación
de-
334
Sistemas
operativos
Aspectos
internos
principios
diseño
Direcciones
simbólicas
JUMP
PROGRAMA
Módulo
objeto
LOAD
Direcciones
absolutas
JUMP
1424
1424
1024
2224
Módulo
carga
absoluto
LOAD
2224
Direcciones
relativas
JUMP
400
400
1200
DATOS
Módulo
carga
relativo
LOAD
1200
PROGRAMA
PROGRAMA
DATOSDATOS
Figura
.15
Módulos
carga
absolutos
reubicables
07-Capitulo
16/5/05
17:04
Página
334penda
memoria
virtual
esquema
carga
reubicable
adecuado
libro
referido
necesidad
traer
quitar
imágenes
procesos
memoria
principal
maximizar
utilización
procesador
maximizar
utilización
memoria
principal
importante
intercambiar
imágenes
procesos
localizaciones
momentos
programa
cargado
intercambiarse
disco
memoria
di-
ferentes
ubicaciones
imposible
referencias
memoria
limitan
direcciones
absolutas
tiempo
carga
inicial
alternativa
posponer
cálculo
dirección
absoluta
necesite
realmente
tiempo
ejecución
propósito
módulo
carga
carga
memoria
principal
to-
das
referencias
memoria
formato
relativo
Figura
7.15c
instrucción
ejecuta
realmente
calcula
dirección
absoluta
asegurar
función
degrada
rendimiento
realiza
hardware
procesador
especial
lugar
llevarse
cabo
software
hardware
describe
Sección
7.2
cálculo
dinámico
direcciones
proporciona
flexibilidad
programa
carga
región
memoria
principal
continuación
ejecución
programa
inte-
rrumpir
programa
intercambiar
disco
memoria
posteriormente
intercam-
biarse
localización
ENLACE
función
montador
tomar
entrada
colección
módulos
objeto
producir
módulo
carga
formado
conjunto
integrado
programa
módulos
datos
pasará
cargador
módulo
objeto
referencias
direcciones
módulos
referencias
expresar
simbólicamente
módulo
objeto
enlazado
montador
crea
único
módulo
carga
une
forma
contigua
módulos
objeto
referencia
módulos
cambiarse
dirección
simbólica
convertirse
refe-
rencia
ubicación
módulo
carga
ejemplo
módulo
Figura
7.16a
con-
invocación
procedimiento
módulo
B.
módulos
combinan
módulo
carga
referencia
simbólica
módulo
cambia
referencia
específica
localización
punto
entrada
módulo
carga
Editor
enlace
naturaleza
enlace
direcciones
dependerá
tipo
módulo
carga
cree
lleve
cabo
proceso
enlace
Tabla
7.2b
desea
módulo
carga
reubicable
suele
habitual
enlace
normalmente
forma
módulo
objeto
compilado
ensamblado
crea
referencias
relativas
comienzo
módulo
objeto
módulos
colocan
juntos
único
módulo
carga
reubicable
referencias
relativas
origen
módulo
carga
módulo
utilizar
entrada
carga
reubicable
carga
dinámica
tiempo
ejecución
montador
produce
módulo
carga
reubicable
denomina
frecuentemente
editor
enlace
Figura
7.16
ilustra
función
editor
enlace
Montador
dinámico
carga
posponer
funciones
relativas
enlace
tér-
mino
enlace
dinámico
utiliza
denominar
práctica
posponer
enlace
módulos
Gestión
memoria
335
07-Capitulo
16/5/05
17:04
Página
335externos
módulo
carga
cree
módulo
carga
contiene
re-
ferencias
resolver
programas
referencias
resolver
tiempo
carga
tiempo
ejecución
enlace
dinámico
tiempo
carga
seguir
siguientes
pasos
módulo
carga
módulo
aplicación
llevarse
memoria
cargarlo
referencia
módu-
externo
módulo
destino
provoca
cargador
encuentre
módulo
destino
cargue
altere
referencia
dirección
relativa
memoria
comienzo
módulo
aplicación
ventajas
técnica
frente
enlace
estático
facilita
incorporar
versiones
modificadas
actualizadas
módulo
destino
utilidad
sistema
operativo
rutinas
propósito
general
enla-
ce
estático
cambio
módulo
requeriría
reenlace
módulo
aplicación
completo
ineficiente
imposible
circunstancias
ejemplo
campo
ordenadores
personales
mayoría
software
comercial
entregado
formato
módulo
carga
entregan
versiones
fuente
objeto
código
destino
fichero
enlace
dinámico
facilita
camino
compartir
código
forma
automática
sistema
operativo
reconocer
aplicación
utiliza
código
destino
carga
enlaza
código
utilizar
infor-
mación
cargar
única
copia
código
destino
enlazarlo
ambas
aplicaciones
lu-
gar
cargar
copia
aplicación
336
Sistemas
operativos
Aspectos
internos
principios
diseño
Direcciones
relativas
JSR
Return
Return
Return
/H11002
/H11001
/H11002
/H11001
/H11001
/H11001
/H11002
JSR
/H11001
CALL
B;Referencia
externa
módulo
Return
Módulo
Módulos
objeto
CALL
Módulo
Return
Módulo
cargaReturn
Módulo
Longitud
Longitud
Longitud
Módulo
Módulo
Módulo
Figura
.16
función
montaje
07-Capitulo
16/5/05
17:04
Página
336•
Facilita
desarrolladores
software
independientes
extender
funcionalidad
siste-
ma
operativo
ampliamente
utilizado
Linux
desarrollador
implementar
función
útil
variedad
aplicaciones
empaquetarla
mó-
dulo
enlace
dinámico
enlace
dinámico
tiempo
ejecución
enlaces
pospuestos
tiempo
ejecución
referencias
externas
módulos
destino
quedan
programa
cargado
realiza
llamada
módulo
ausente
sistema
operativo
localiza
módulo
carga
enlaza
módulo
llamante
visto
carga
dinámica
permite
mover
módulo
carga
entero
estructura
módulo
estática
permaneciendo
cambios
ejecución
proceso
ejecución
casos
determinar
ejecución
módulos
objeto
necesitarán
situación
tipificada
aplicaciones
procesamiento
transacciones
sistema
reserva
vuelos
aplicación
banca-
ria
naturaleza
transacción
especifica
módulos
programa
requieren
car-
gados
enlazados
programa
principal
ventaja
montador
dinámico
necesario
asignar
memoria
unidades
programa
dichas
unidades
referencien
capacidad
utiliza
soporte
sistemas
segmentación
mejora
adicional
aplicación
necesita
nombres
módulos
puntos
entrada
llamarse
ejemplo
escribirse
programa
di-
bujo
trabajar
variedad
trazadores
gestiona
con-
trolador
aplicación
aprender
nombre
trazador
actualmente
instala-
do
sistema
proceso
buscando
fichero
configuración
permite
usuario
aplicación
instalar
trazador
exista
tiempo
aplicación
escribió
Gestión
memoria
337
07-Capitulo
16/5/05
17:04
Página
33707-Capitulo
16/5/05
17:04
Página
338CAPÍTULO
Memoria
virtual
8.1
Hardware
estructuras
control
8.2
Software
sistema
operativo
8.3
Gestión
memoria
UNIX
Solaris
8.4
Gestión
memoria
Linux
8.5
Gestión
memoria
Windows
8.6
Resumen
8.7
Lectura
recomendada
páginas
web
8.8
érminos
clave
cuestiones
repaso
problemas
Apéndice
8A
ablas
Hash
08-Capitulo
12/5/05
16:23
Página
339N
Capítulo
vieron
conceptos
paginación
segmentación
analizaron
limitacio-
nes
entrar
discutir
concepto
memoria
virtual
análisis
concepto
complicado
gestión
memoria
interacción
compleja
hard-
ware
procesador
sistema
operativo
centraremos
aspectos
hardware
memoria
virtual
observando
paginación
segmentación
combinación
pagina-
ción
segmentación
veremos
aspectos
relacionados
diseño
servicios
memoria
virtual
sistema
operativo
8.1
HARDWARE
ESTRUCTURAS
CONTROL
omparando
paginación
sencilla
segmentación
sencilla
distin-
ción
particionamiento
estático
dinámico
fundamentos
co-
mienzo
gestión
memoria
características
paginación
segmenta-
ción
clave
comienzo
referencias
memoria
proceso
realizan
direcciones
lógicas
traducen
dinámicamente
direcciones
físicas
ejecución
significa
pro-
ceso
llevado
traído
memoria
forma
ocupe
regiones
me-
moria
principal
distintos
instantes
tiempo
ejecución
proceso
dividirse
porciones
páginas
segmentos
porciones
localizadas
memoria
forma
contigua
ejecución
combi-
nación
traducción
direcciones
dinámicas
ejecución
tabla
páginas
segmentos
permite
veamos
comenzar
memoria
dinámica
características
anteriores
necesario
páginas
segmentos
proceso
encuen-
tren
memoria
principal
ejecución
porción
segmento
página
instrucción
buscar
porción
direc-
ción
datos
acceder
instrucción
ejecutar
Consideremos
momento
hablar
términos
ge-
nerales
usaremos
término
porción
referirnos
página
segmento
dependien-
do
empleando
paginación
segmentación
Supongamos
traer
proceso
memoria
sistema
operativo
comienza
trayendo
únicamente
porciones
incluye
porción
inicial
programa
porción
inicial
datos
acceden
primeras
instrucciones
acceden
proceso
realmente
memoria
principal
instante
tiempo
denomina
conjunto
residente
proceso
proceso
ejecutándose
cosas
ocurren
forma
suave
referencias
memoria
encuentren
conjunto
residente
Usando
tabla
segmentos
páginas
procesador
capaz
determinar
procesador
dirección
lógica
memoria
principal
generará
interrupción
indicando
fallo
acceso
memoria
sistema
operativo
coloca
proceso
interrumpido
bloqueado
toma
control
ejecución
proceso
reanudarse
sistema
operativo
necesita
traer
memoria
principal
porción
proceso
contiene
dirección
lógica
causado
fallo
acceso
sistema
operativo
realiza
petición
lectura
disco
petición
sistema
operativo
activar
proceso
ejecute
disco
realiza
operación
S.
porción
solicitada
traído
340
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
340la
memoria
principal
interrupción
lanza
dando
control
sistema
ope-
rativo
coloca
proceso
afectado
Listo
lector
ocurrir
cuestionar
eficiencia
maniobra
proceso
ejecutando
resulta
necesario
interrumpirlo
motivo
llegado
cargar
porciones
necesarias
proceso
momento
posponer
cuestión
garantía
eficiencia
verdaderamente
lugar
ponderar
implicaciones
estrategia
implicaciones
sorprendente
ambas
dirigidas
mejorar
utilización
sistema
mantenerse
número
procesos
memoria
principal
cargar
porciones
procesos
ejecutar
espacio
procesos
utilización
eficiente
procesador
pro-
bable
numerosos
procesos
encuentre
Listo
instante
tiempo
concreto
proceso
memoria
principal
superar
restricciones
fundamentales
programación
esquema
discutien-
do
programador
realmente
atento
memoria
disponible
pro-
grama
escribiendo
programador
buscar
es-
tructurar
programa
fragmentos
cargarse
forma
separada
tipo
estrategia
superposición
overlay
memoria
virtual
basada
paginación
segmen-
tación
trabajo
delega
sistema
operativo
hardware
concierne
pro-
gramador
trabajando
memoria
enorme
tamaño
asociado
almacena-
miento
disco
sistema
operativo
automáticamente
carga
porciones
proceso
memoria
principal
necesitan
proceso
ejecuta
memoria
principal
memoria
denomina
memo-
ria
real
programador
usuario
perciben
memoria
potencialmente
localizada
disco
denomina
memoria
virtual
memoria
virtual
permite
multiprogramación
efectiva
libera
usuario
restricciones
excesi-
vamente
fuertes
memoria
principal
Tabla
8.1
recoge
características
paginación
segmentación
memoria
virtual
PROXIMIDAD
MEMORIA
VIRTUAL
beneficios
memoria
virtual
atractivos
esquema
verdaderamente
práctico
momento
importante
debate
punto
experiencia
numerosos
siste-
operativos
demostrado
allá
duda
memoria
virtual
realmente
funciona
memoria
virtual
basada
paginación
paginación
segmentación
convertido
actua-
lidad
componente
esencial
sistemas
operativos
contemporáneos
entender
aspecto
clave
memoria
virtual
causa
debate
examinemos
tareas
sistema
operativo
relacionadas
memoria
virtual
considerar
proceso
tamaño
consistente
programa
número
vec-
tores
datos
corto
periodo
tiempo
ejecución
acotar
pequeña
sección
programa
ejemplo
subrutina
acceso
vectores
datos
única-
mente
verdaderamente
desperdicio
cargar
docenas
porciones
proceso
porciones
usarán
programa
suspenda
mande
zona
intercambio
swap
memoria
cargando
únicamente
porciones
programa
salta
destrucción
referencia
dato
en-
Memoria
virtual
341
08-Capitulo
12/5/05
16:23
Página
341342
Sistemas
operativos
Aspectos
internos
principios
diseño
Paginación
sencilla
Paginación
memoria
virtual
Segmentación
sencilla
Segmentación
memoria
virtual
abla
8.1
Características
paginación
segmentación
Memoria
principal
particionada
fragmentos
pequeños
tamaño
fijo
llamados
marcos
Programa
dividido
páginas
compilador
sistema
gestión
memoria
Fragmentación
interna
marcos
fragmentación
externa
sistema
operativo
mantener
tabla
páginas
proceso
mostrando
marco
página
ocupada
sistema
operativo
mantener
lista
marcos
libres
procesador
utiliza
número
página
desplazamiento
calcular
direcciones
absolutas
páginas
proceso
encontrarse
memoria
principal
proceso
ejecutar
utilicen
solapamientos
overlays
Memoria
principal
particionada
fragmentos
pequeños
tamaño
fijo
llamados
marcos
Programa
dividido
páginas
compilador
sistema
gestión
memoria
Fragmentación
interna
marcos
fragmentación
externa
sistema
operativo
mantener
tabla
páginas
proceso
mostrando
marco
página
ocupada
sistema
operativo
mantener
lista
marcos
libres
procesador
utiliza
número
página
desplazamiento
calcular
direcciones
absolutas
necesita
mantener
páginas
proceso
marcos
memoria
principal
proceso
ejecute
páginas
leer
demanda
lectura
página
memoria
principal
requerir
escritura
página
disco
Memoria
principal
particionada
segmentos
programa
especifican
programador
compilador
ejemplo
decisión
toma
programador
fragmentación
interna
Fragmentación
externa
sistema
operativo
mantener
tabla
segmentos
proceso
mostrando
dirección
carga
longitud
segmento
sistema
operativo
mantener
lista
huecos
memoria
principal
procesador
utiliza
número
segmento
desplazamiento
calcular
direcciones
absolutas
segmentos
proceso
encontrarse
memoria
principal
proceso
ejecutar
utilicen
solapamientos
overlays
Memoria
principal
particionada
segmentos
programa
especifican
programador
compilador
ejemplo
decisión
toma
programador
fragmentación
interna
Fragmentación
externa
sistema
operativo
mantener
tabla
segmentos
proceso
mostrando
dirección
carga
longitud
segmento
sistema
operativo
mantener
lista
huecos
memoria
principal
procesador
utiliza
número
segmento
desplazamiento
calcular
direcciones
absolutas
necesitan
mantener
segmentos
proceso
memoria
principal
proceso
ejecute
segmentos
leer
demanda
lectura
segmento
memoria
principal
requerir
escritura
segmentos
disco
08-Capitulo
12/5/05
16:23
Página
342cuentra
porción
memoria
memoria
principal
dispara
fallo
indica
sistema
operativo
porción
deseada
momento
porciones
proceso
encuentran
memo-
ria
mantener
procesos
alojados
ahorra
tiempo
porciones
proceso
usadas
expulsarán
memoria
swap
swap
memoria
sistema
operativo
inteligente
hora
manejar
esquema
estable
prácticamente
memoria
principal
encontrará
ocupada
porciones
procesos
forma
procesador
sistema
operativo
tengan
acceso
directo
número
procesos
sistema
operativo
traiga
porción
memoria
expulsar
elimina
porción
justo
utilizada
deberá
recuperar
dicha
porción
forma
inmediata
abuso
condición
denominada
trasiego
thras-
hing
sistema
consume
tiempo
enviando
trayendo
porciones
swap
lugar
ejecutar
instrucciones
Evitar
trasiego
áreas
investigación
principales
época
años
70
condujo
variedad
algoritmos
complejos
efectivos
esencia
sistema
operativo
adivinar
base
historia
reciente
porciones
probables
utilizadas
futuro
cercano
razonamiento
basa
creencia
principio
proximidad
presentó
Ca-
pítulo
véase
especialmente
Apéndice
1A
resumir
principio
proximidad
indica
referencias
programa
datos
proceso
tienden
agruparse
resu-
porciones
proceso
necesitarán
periodo
tiempo
cor-
to
suposiciones
inteligentes
porciones
proceso
necesitarán
futuro
evitar
trasiego
forma
confirmar
principio
proximidad
observar
rendimiento
procesos
entorno
memoria
virtual
Figura
8.1
muestra
famoso
diagrama
ilustra
forma
clara
principios
proximidad
HATF
72
Nótese
tiempo
vida
proceso
referencias
encuentran
acotadas
subconjunto
páginas
vemos
principio
proximidad
sugiere
esquema
memoria
virtual
funcionar
memoria
virtual
resulte
práctica
efectiva
necesitan
ingredientes
Pri-
mero
existir
soporte
hardware
esquema
paginación
segmentación
sistema
operativo
incluir
código
gestionar
movimiento
páginas
segmentos
memoria
secundaria
memoria
principal
sección
examinaremos
aspectos
hardware
veremos
estructuras
control
necesarias
crearán
mantendrán
sistema
operativo
usadas
hardware
gestión
memoria
examinarán
aspectos
correspondientes
sistema
operativo
sección
PAGINACIÓN
término
memoria
virtual
asocia
habitualmente
sistemas
emplean
paginación
memoria
virtual
basada
segmentación
utiliza
tratada
paginación
memoria
virtual
utilizado
computador
Atlas
KILB62
convirtió
estrategia
usada
general
forma
comercial
presentación
paginación
sencilla
indicamos
proceso
dispone
ta-
bla
páginas
páginas
encuentran
localizadas
memoria
principal
entra-
tabla
páginas
consiste
número
marco
correspondiente
página
memoria
principal
memoria
virtual
basada
esquema
paginación
necesita
tabla
páginas
normalmente
asocia
única
tabla
páginas
proceso
caso
entradas
tabla
páginas
complejas
Figura
8.2a
Memoria
virtual
343
08-Capitulo
12/5/05
16:23
Página
343sólo
páginas
proceso
encuentran
memoria
principal
necesita
entrada
tabla
páginas
indique
correspondiente
página
presente
memoria
prin-
cipal
bit
indica
página
memoria
entrada
indicar
número
marco
dicha
página
entrada
tabla
páginas
incluye
bit
modificado
indica
contenidos
correspondiente
página
alterados
página
cargó
me-
moria
principal
cambio
necesario
escribir
página
llegue
mo-
mento
reemplazarla
página
marco
página
actualmente
ocupa
existir
bits
control
entradas
ejemplo
protección
compartición
gestio-
na
nivel
página
necesitarán
bits
propósito
Estructura
tabla
páginas
mecanismo
básico
lectura
palabra
memoria
implica
traducción
dirección
virtual
lógica
consistente
número
página
des-
344
Sistemas
operativos
Aspectos
internos
principios
diseño
Tiempo
ejecución
18
Números
página
20
22
24
26
28
30
32
34
Figura
8.1
Comportamiento
paginación
08-Capitulo
12/5/05
16:23
Página
344plazamiento
dirección
física
consistente
número
marco
desplazamiento
usando
tabla
páginas
tabla
páginas
longitud
variable
dependiendo
tamaño
proceso
suponer
almacenada
registros
lugar
encontrarse
memoria
principal
accedida
Figura
8.3
sugiere
implementación
hardware
proceso
particular
ejecutando
registro
con-
dirección
comienzo
tabla
áginas
proceso
úmero
página
dirección
virtual
utiliza
indexar
tabla
buscar
correspondiente
marco
ágina
combinado
desplazamiento
direcci
ón
virtual
genera
dirección
real
deseada
Normalmente
campo
correspondiente
número
página
campo
correspondiente
número
marco
página
mayorí
sistemas
nica
tabla
pá
gina
proceso
proceso
ocupar
cantidad
memoria
virtual
ejemplo
arquitectura
AX
proceso
31
Gbytes
memoria
virtual
Usando
pá
ginas
512
bytes
representa
22
entradas
tabla
pá
gina
proceso
Evidentemente
can-
tidad
memoria
demandada
tablas
gina
únicamente
inaceptablemente
resolver
problema
esquemas
memoria
virtual
almacena
ta-
Memoria
virtual
345
Dirección
virtual
Número
página
Desplazamiento
Únicamente
paginación
Entrada
tabla
páginas
Número
marcoPM
bits
control
Dirección
virtual
Segmento
página
Únicamente
segmentación
Longitud
Comienzo
segmentoPM
Número
página
Combinación
segmentación
paginación
Número
marcoPM
Bits
control
/H11005
bit
presente
/H11005
bit
modificado
Desplazamiento
Entrada
tabla
segmentos
bits
control
Dirección
virtual
Segmento
página
Desplazamiento
Entrada
tabla
segmentos
Longitud
Comienzo
segmento
Entrada
tabla
páginas
bits
control
Figura
8.2
Formatos
típicos
gestión
memoria
08-Capitulo
12/5/05
16:23
Página
345blas
pá
ginas
tambié
memoria
virtual
lugar
memoria
real
representa
tablas
pá
ginas
sujetas
paginació
pá
gina
proceso
ejecució
tabla
pá
ginas
encontrarse
memoria
incluyendo
entrada
tabla
pá
ginas
pá
gina
actualmente
ejecució
n.
procesadores
utili-
zan
esquema
niveles
organizar
tablas
pá
ginas
tamañ
o.
esque-
ma
directorio
pá
ginas
entrada
apuntaba
tabla
pá
ginas
forma
extensió
directorio
pá
ginas
longitud
má
xima
tabla
pá
ginas
proceso
consistirá
pá
ginas
Normalmente
longitud
má
xima
tabla
pá
ginas
restringe
pá
gina
ejemplo
procesador
Pentium
utiliza
estrategia
Figura
8.4
muestra
ejemplo
esquema
ípico
niveles
32
bits
di-
rección
Asumimos
direccionamiento
nivel
byte
áginas
Kbytes
12
es-
pacio
direcciones
virtuales
Gbytes
232
compone
220
páginas
pági-
nas
referencia
entrada
tabla
páginas
ETP
4-bytes
crear
tabla
página
usuario
20
ETP
requiere
Mbytes
222
bytes
enorme
tabla
pá-
ginas
usuario
ocupa
10
páginas
mantenerse
memoria
virtual
hacerse
referencia
tabla
páginas
raíz
10
PTE
ocuparía
Kbytes
12
memoria
principal
Fi-
gura
muestra
pasos
relacionados
traducción
direcciones
esquema
pági-
na
raíz
mantiene
memoria
principal
10
bits
direcci
ón
virtual
indexar
tabla
páginas
raíz
encontrar
ETP
página
tabla
páginas
usuario
página
memoria
principal
produce
fallo
página
página
memoria
principal
siguientes
10
bits
direcci
ón
virtual
indexar
tabla
áginas
usuario
encontrar
ETP
ágina
referencia
dirección
virtual
original
346
Sistemas
operativos
Aspectos
internos
principios
diseño
Dirección
virtual
Dirección
física
Programa
Mecanismo
paginación
Memoria
principal
Nro
Página
Puntero
tabla
páginasn
bits
bits
Registro
Tabla
páginas
Nro
Marco
/H11001
Marco
página
Nro
Página
Desplazamiento
Nro
Marco
Desplazamiento
Desplazamiento
Figura
8.3
Traducción
direcciones
sistema
paginación
08-Capitulo
12/5/05
16:23
Página
346
abla
páginas
invertida
desventaja
tipo
tablas
áginas
visto
tamaño
proporcional
espacio
direcciones
virtuales
estrategia
alternativa
tablas
áginas
niveles
es-
tructura
tabla
páginas
invertida
Variaciones
estrategia
usado
arquitecturas
PowerPC
UltraSPARC
IA-64
implementación
sistema
operativo
Mach
RT-PC
Memoria
virtual
347
4-kbyte
tabla
páginas
raíz
4-Mbyte
tabla
páginas
usuario
4-Gbyte
espacio
direcciones
usuario
Figura
8.4
tabla
páginas
jerárquica
niveles
10
bits10
bits
12
bits
Puntero
tabla
páginas
raíz
Nro
Marco
Desplazamiento
Dirección
virtual
Tabla
páginas
Kbytes
contiene
1024
ETP
Tabla
páginas
raíz
contiene
1024
PTE
/H11001
/H11001
Programa
Mecanismo
paginación
Memoria
principal
Marco
página
Figura
8.5
Traducción
direcciones
sistema
paginación
niveles
08-Capitulo
12/5/05
16:23
Página
347En
estrategia
correspondiente
nú
mero
pá
gina
direcció
virtual
refe-
rencia
valor
hash
usando
funció
hash
sencilla1
valor
hash
puntero
tabla
pá
ginas
invertida
contiene
entradas
tablas
pá
gina
entrada
tabla
pá
ginas
invertida
marco
pá
gina
real
lugar
pá
gina
vir-
tual
forma
único
requiere
tablas
pá
gina
proporció
fija
memoria
real
independientemente
nú
mero
procesos
pá
ginas
virtuales
so-
portadas
má
direcció
virtual
traducirse
entrada
ta-
bla
hash
té
cnica
encadenamiento
utiliza
gestionar
desbordamiento
té
cnicas
hashing
proporcionan
habitualmente
cadenas
excesivamente
largas
entradas
estructura
tabla
pá
ginas
denomina
invertida
indexan
entradas
tabla
pá
ginas
nú
mero
marco
lugar
nú
mero
pá
gina
virtual
Figura
8.6
muestra
implementación
típica
técnica
tabla
páginas
invertida
tamaño
memoria
física
marcos
tabla
páginas
invertida
contiene
entradas
for-
ma
entrada
posición
i-esima
refiere
marco
i.
entrada
tabla
páginas
inclu-
ye
información
Número
página
correspondiente
úmero
pá
gina
direcció
virtual
348
Sistemas
operativos
Aspectos
internos
principios
diseño
Véase
Apéndice
8A
explicaciones
hashing
bits
bits
bits
bits
Dirección
virtual
Función
hasd
ID
proceso
Bits
control
Cadena
Tabla
páginas
invertida
entrada
marco
memoria
física
Dirección
real
/H11002
Nro
Página
Desplazamiento
Nro
Segmento
Desplazamiento
Nro
Página
Figura
8.6
Estructura
tabla
páginas
invertida
08-Capitulo
12/5/05
16:23
Página
348•
Identificador
proceso
proceso
propietario
ágina
combinación
número
página
identificador
proceso
identifica
página
espacio
di-
recciones
virtuales
proceso
particular
Bits
control
campo
incluye
flags
ejemplo
válido
referenciado
mo-
dificado
información
protección
cerrojos
Puntero
cadena
campo
nulo
indicado
posiblemente
bit
adicional
entradas
encadenadas
entrada
caso
campo
contiene
valor
índice
número
m-1
entrada
cadena
ejemplo
dirección
virtual
incluye
número
página
bits
m.
fun-
ción
hash
traduce
número
página
bits
cantidad
bits
utiliza
indexar
tabla
páginas
invertida
Buffer
traducción
anticipada
principio
referencia
memoria
virtual
causar
accesos
memoria
física
buscar
entrada
tabla
áginas
apropiada
buscar
datos
solicitados
forma
esquema
memoria
virtual
ásico
causaría
efecto
duplicar
tiempo
acceso
memoria
solventar
problema
mayoría
esquemas
memoria
virtual
utilizan
cache
especial
alta
velocidad
entradas
tabla
pá-
gina
habitualmente
denominada
buffer
traducción
anticipada
translation
lookaside
buffer
TLB
cache
funciona
forma
similar
memoria
cache
general
véase
Capítulo
con-
entradas
tabla
páginas
usadas
forma
reciente
organi-
zación
hardware
paginaci
ón
resultante
ilustra
Figura
8.7
Dada
direcci
ón
virtual
procesador
examina
TLB
entrada
tabla
áginas
solicitada
presente
acierto
TLB
recupera
número
marco
construye
dirección
real
en-
trada
tabla
páginas
solicitada
fallo
TLB
procesador
utiliza
núme-
ro
página
indexar
tabla
páginas
proceso
examinar
correspondiente
entrada
tabla
páginas
bit
presente
puesto
página
memoria
principal
procesador
recuperar
número
marco
entrada
tabla
páginas
construir
dirección
real
procesador
autorizará
TLB
incluir
en-
trada
tabla
páginas
Finalmente
bit
presente
est
puesto
página
solicita-
memoria
principal
produce
fallo
acceso
memoria
llamado
fallo
página
punto
abandonamos
dominio
hardware
invocar
sistema
operativo
cargará
página
necesaria
actualizada
tabla
páginas
Figura
8.8
muestra
diagrama
flujo
TLB
diagrama
flujo
muestra
página
solicitada
memoria
principal
interrupci
ón
fallo
página
invoque
rutina
tratamiento
fallo
ágina
mantener
sim-
plicidad
diagrama
mostrado
sistema
operativo
activar
proceso
operación
disco
realizando
principio
proximi-
dad
mayoría
referencias
memoria
virtual
encontrar
án
situadas
página
reciente-
mente
utiliza
mayoría
referencias
invocarán
entrada
tabla
páginas
cache
estudios
TLB
sistemas
AX
demostrado
esquema
significa
importante
mejora
rendimiento
CLAR85
SATY81
numerosos
detalles
adicionales
relativos
organizaci
ón
real
TLB
TLB
contiene
entradas
tabla
áginas
indexar
simple-
Memoria
virtual
349
N.
T.
traducción
apropiada
translation
lookaside
buffer
buffer
traducción
anticipada
literatura
castellano
utilizan
siglas
TLB
forma
generalizada
describir
dicha
memoria
causar
confusión
textos
presente
libro
utilizaremos
dichas
siglas
referirnos
08-Capitulo
12/5/05
16:23
Página
349mente
TLB
número
página
lugar
entrada
TLB
incluir
número
página
entrada
tabla
áginas
completa
procesador
proporciona
hardware
permite
consultar
simultáneamente
entradas
determinar
concien-
cia
número
página
técnica
denomina
resolución
asociativa
asociative
mapping
contrasta
resolución
directa
indexación
utilizada
buscar
tabla
áginas
Figura
8.9
dise
ño
TLB
considerar
forma
entradas
organizan
entrada
reemplazar
necesite
traer
entrada
aspectos
considerarse
diseño
cache
hardware
punto
contempla
li-
bro
lector
consultar
funcionamiento
diseño
cache
detalle
ejemplo
STAL03
concluir
mecanismo
memoria
virtual
interactuar
sistema
cache
cache
TLB
cache
memoria
principal
ilustra
Figura
8.10
dirección
virtual
generalmente
formato
úmero
página
desplazamiento
sistema
me-
moria
consulta
TLB
presente
entrada
tabla
ágina
coincide
dirección
real
física
genera
combinando
número
marco
desplazamiento
entrada
busca
tabla
áginas
generado
dirección
real
man-
formato
etiqueta
tag
resto
remainder
consulta
cache
bloque
contiene
palabra
devuelve
CPU
palabra
busca
memoria
principal
350
Sistemas
operativos
Aspectos
internos
principios
diseño
Véase
Figura
1.17
Normalmente
etiqueta
bits
situados
ás
izquierda
direcci
ón
real
estudio
detallado
caches
refiere
lector
STAL03
Dirección
virtual
Desplazamiento
Cargar
páginaTabla
páginas
Memoria
principal
Memoria
secundaria
Dirección
real
TLB
Acierto
TLB
Fallo
TLB
Fallo
página
Nro
Página
Desplazamiento
Nro
Marco
Desplazamiento
Figura
8.7
TLB
08-Capitulo
12/5/05
16:23
Página
350El
lector
apreciar
complejidad
hardware
CPU
participa
referencia
memoria
sencilla
dirección
virtual
traduce
dirección
real
implica
referencia
entrada
tabla
áginas
TLB
memoria
principal
disco
palabra
referenciada
cache
memoria
principal
disco
dicha
palabra
re-
ferenciada
únicamente
disco
página
contiene
dicha
palabra
cargarse
memoria
principal
bloque
cache
Adicionalmente
entrada
tabla
áginas
di-
cha
página
actualizarse
amaño
página
decisió
diseñ
hardware
importante
tamañ
pá
gina
factores
considerar
fragmentació
interna
Evidentemente
tamañ
pá
gina
menor
cantidad
fragmentació
interna
optimizar
memoria
principal
serí
beneficioso
reducir
fragmentació
interna
menor
gina
número
pá
ginas
necesarias
proceso
número
pá
ginas
proceso
significa
tambié
mayores
tablas
pá
ginas
programas
entorno
altamente
multipro-
Memoria
virtual
351
Comienzo
CPU
verifica
TLB
Entrada
tabla
páginas
TLB
Éxodo
adaptable
depósito
Actualizar
TLB
CPU
genera
dirección
física
SO
solicita
CPU
lectura
páginas
dico
CPU
activa
hardware
Subrutina
tratamiento
fallo
página
Retorno
instrucción
fallo
Actualizar
tablas
páginas
reemplazo
página
Página
transferida
disco
memoria
Página
memoria
principal
Memoria
llena
Figura
8.8
Operación
paginación
TLB
FURH87
08-Capitulo
12/5/05
16:23
Página
351gramado
significa
determinadas
partes
tablas
gina
procesos
activos
encontrarse
memoria
virtual
memoria
principal
fallo
pá
gina
doble
referencia
sencilla
memoria
atraer
tabla
pá
gina
solici-
tada
atraer
pá
gina
proceso
factor
importante
caracterí
sticas
fí
sicas
mayoría
dispositivos
memoria
secundaria
tipo
giratorio
favorecien-
do
tamañ
pá
gina
mejorar
eficiencia
transferencia
bloques
datos
Aumentando
complejidad
aspectos
efecto
tama
ño
página
tie-
ne
relación
posibilidad
ocurra
fallo
ágina
comportamiento
érminos
ge-
nerales
recogido
Figura
8.11a
basa
principio
proximidad
ta-
maño
página
pequeño
forma
habitual
número
relativamente
alto
áginas
disponibles
memoria
principal
proceso
Despu
és
tiempo
páginas
memo-
ria
contendrán
partes
procesos
referencia
forma
reciente
forma
tasa
fallos
página
debería
baja
medida
tamaño
páginas
incrementa
página
particular
contendrá
información
lejos
referencia
realizada
efecto
principio
proximidad
debilita
tasa
fallos
página
comienza
crecer
al-
gún
momento
tasa
fallos
ágina
comenzará
caer
medida
tamaño
página
aproxima
tamaño
proceso
completo
punto
diagrama
única
página
contiene
proceso
completo
fallos
página
complicació
adicional
tasa
fallos
pá
gina
tambié
viene
determinada
nú-
mero
marcos
asociados
proceso
Figura
8.11b
muestra
tamañ
pá
gina
fijo
tasa
fallos
cae
medida
número
pá
ginas
mantenidas
memoria
principal
crece
352
Sistemas
operativos
Aspectos
internos
principios
diseño
parámetro
representa
conjunto
trabajo
concepto
analizará
Sección
8.2
Traducción
asociativa(a
Traducción
directa
Tabla
páginas
502
Dirección
virtual
37
37
19
511
37
27
14
211
90
Entradas
PT
TLB
502
37
502
Dirección
real
37
502
Dirección
real
Nro
Página
Desplazamiento
Dirección
virtual
Nro
Página
Desplazamiento
Nro
Página
Nro
Segmento
DesplazamientoNro
Segmento
Desplazamiento
Figura
8.9
Resolución
directa
vs
asociativa
entradas
tabla
páginas
08-Capitulo
12/5/05
16:23
Página
352Memoria
virtual
353
Dirección
virtual
Operaciones
TBL
Tabla
páginas
Memoria
principal
Fallo
TLB
Fallo
Acierto
Valor
Acierto
TLB
TLB
Etiqueta
Resto
Direción
real
Operaciones
cache
Cache
H11001
Valor
Nro
Página
Desplazamiento
Figura
8.10
Operaciones
TLB
cache
NW
Tamaño
página
Tasa
fallos
página
Número
marcos
página
reservados
/H11005
tamaño
proceso
entero
/H11005
conjunto
trabajo
/H11005
número
páginas
proceso
Tasa
fallos
página
Figura
8.11
Comportamiento
típico
paginación
programa
08-Capitulo
12/5/05
16:23
Página
353tanto
política
software
cantidad
memoria
reservada
proceso
interactúa
deci-
siones
diseño
hardware
tama
ño
página
Tabla
.2
contiene
listado
tamañ
pá
ginas
determinadas
arquitecturas
concluir
aspecto
diseño
tamaño
página
relacionado
tamaño
memoria
física
tamaño
programa
tiempo
memoria
principal
est
espacio
direcciones
utilizado
aplicaciones
crece
ten-
dencia
resulta
evidente
ordenadores
personales
estaciones
trabajo
aplicaciones
complejidad
creciente
diversas
técnicas
programación
actuales
usadas
programas
tamaño
tienden
reducir
efecto
proximidad
referencias
pro-
ceso
HUCK93
ejemplo
técnicas
programación
orientada
objetos
motivan
ódulos
datos
programas
pequeño
tamaño
referencias
repartidas
número
relativamente
alto
objetos
periodo
tiempo
corto
aplicaciones
multihilo
multithreaded
presentar
cambios
abruptos
flujo
instrucciones
referencias
memoria
fraccionadas
abla
8.2
Ejemplo
tamaños
página
Computer
amaño
página
Atlas
512
palabras
48-bits
Honeywell-Multics
1024
palabras
36-bits
IBM
370
XA
370
Kbytes
Familia
VAX
512
bytes
IBM
AS/400
512
bytes
DEC
Alpha
Kbytes
MIPS
Kbytes
16
Mbytes
UltraSPARC
Kbytes
Mbytes
Pentium
Kbytes
Mbytes
PowerPc
Kbytes
Itanium
Kbytes
256
Mbytes
tamañ
determinado
TLB
medida
tama
proceso
crece
pro-
ximidad
referencias
decrece
ndice
aciertos
TLB
reduciendo
circuns-
tancias
TLB
convertir
cuello
botella
rendimiento
ejemplo
véase
CHEN92
forma
incrementar
rendimiento
TLB
utilizar
TLB
tamañ
má
entradas
tamañ
TLB
interactú
aspectos
diseñ
hardware
ejemplo
cache
memoria
principal
nú
mero
accesos
memoria
ciclo
instruc-
ció
TALL92
principales
pegas
tamañ
TLB
tenden-
cia
crecimiento
tamañ
memoria
principal
velocidad
crecimiento
al-
ternativa
tamañ
pá
gina
mayores
forma
entrada
tabla
pá
ginas
referenciada
TLB
apunte
bloque
memoria
relativamente
aca-
bamos
tamañ
pá
gina
significar
degradació
rendimiento
354
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
354Sobre
consideraciones
nú
mero
diseñ
adores
investigado
posibilidad
utilizar
mú
ltiples
tamañ
pá
gina
TALL92
KHAL93
arquitecturas
micropro-
cesadores
soporte
diversos
tama
pá
gina
incluyendo
MIPS
R4000
Alpha
UltraS-
PARC
Pentium
IA-64
tamañ
pá
gina
mú
ltiples
proporcionan
flexibilidad
necesaria
TLB
forma
eficiente
ejemplo
regiones
contiguas
memoria
ta-
mañ
espacio
direcciones
proceso
instrucciones
programa
proyectar
reducido
nú
mero
pá
ginas
tamañ
lugar
nú
mero
pá
ginas
tamañ
má
pequeñ
pilas
hilos
alojar
utili-
zando
tamañ
pá
gina
relativamente
pequeñ
mayorí
sistemas
operativos
comerciales
aú
soportan
nicamente
tamañ
pá
gina
independientemente
capacidades
hardware
ejecutando
motivo
tama
pá
gina
afecta
aspectos
sistema
operativo
cambio
modelo
tamañ
pá
ginas
representa
tarea
significativamente
compleja
véase
GANA98
má
detalle
SEGMENTACIÓN
implicaciones
memoria
virtual
segmentación
permite
programador
me-
moria
tratase
espacios
direcciones
segmentos
segmentos
tamaños
realidad
tamaño
dinámico
referencia
memoria
consiste
formato
dirección
tipo
número
segmento
desplazamiento
organización
número
ventajas
programador
espacios
di-
recciones
segmentados
Simplifica
tratamiento
estructuras
datos
crecer
programador
conoce
priori
tama
estructura
datos
particular
alcanzar
ne-
cesario
estimaci
utilicen
tama
segmento
diná
micos
memoria
virtual
segmentada
estructura
datos
asignar
seg-
mento
sistema
operativo
expandir
reducirá
segmento
demanda
seg-
mento
necesita
expandirse
encuentre
memoria
principal
suficiente
tamañ
sistema
operativo
mover
segmento
rea
memoria
principal
disponible
enviarlo
swap
caso
segmento
incrementado
tama
volverá
memoria
principal
oportuni-
dad
Permite
programas
modifican
recopilan
forma
independiente
requerir
conjunto
completo
programas
re-enlacen
vuelvan
cargar
posibili-
dad
articular
utilización
múltiples
segmentos
soporte
compartición
procesos
programador
situar
programa
uti-
lidad
tabla
datos
resulte
útil
segmento
hacerse
referencia
des-
procesos
Soporta
mecanismos
protecci
ón
segmento
definirse
contener
conjunto
programas
datos
descritos
programador
administrador
sistemas
asignar
privilegios
acceso
forma
apropiada
Organización
exposición
segmentación
sencilla
indicamos
proceso
tabla
segmentos
segmentos
cargado
memoria
princi-
pa
tabla
segmentos
proceso
crea
carga
memoria
principal
entra-
tabla
segmentos
contiene
dirección
comienzo
correspondiente
segmento
Memoria
virtual
355
08-Capitulo
12/5/05
16:23
Página
355memoria
principal
longitud
mecanismo
tabla
segmentos
necesita
tratando
esquemas
memoria
virtual
basados
segmentaci
ón
habitual
única
tabla
segmentos
procesos
caso
entradas
tabla
segmentos
ás
complejas
Figura
8.2b
segmentos
proceso
encontrarse
memoria
principal
nece-
sita
bit
entrada
tabla
segmentos
indicar
correspondiente
segmento
en-
cuentra
presente
memoria
principal
indica
segmento
memoria
entrada
incluir
dirección
comienzo
longitud
bit
control
entrada
tabla
segmentos
bit
modificado
indica
contenidos
segmento
correspondiente
modificado
carg
memoria
principal
cambio
necesario
escribir
segmento
reem-
place
memoria
principal
darse
bits
control
ejemplo
gesti
ón
protección
compartición
gestiona
nivel
segmento
necesitar
án
bits
correspondien-
tes
fines
mecanismo
bá
sico
lectura
palabra
memoria
implica
traducció
di-
recció
virtual
ló
gica
consistente
nú
mero
segmento
desplazamiento
direc-
ció
fí
sica
usando
tabla
segmentos
tabla
segmentos
tama
variable
dependiendo
tamañ
proceso
suponer
almacenada
regis-
tro
lugar
encontrarse
memoria
principal
accederse
Figura
8.12
su-
giere
implementacione
hardware
esquema
tese
similitud
Figura
8.3
Cuan-
do
proceso
particular
ejecució
registro
mantiene
direcció
comienzo
tabla
segmentos
proceso
úmero
segmento
direcció
virtual
utiliza
indexar
tabla
buscar
direcció
memoria
principal
comienza
segmen-
to
sta
añ
adida
desplazamiento
direcció
virtual
producir
direcció
real
solicitada
356
Sistemas
operativos
Aspectos
internos
principios
diseño
desplazamiento
Puntero
tabla
segmento
Dirección
virtual
Registro
Tabla
segmentos
Dirección
física
Longitud
Base
Segmento
Base
Programa
Mecanismo
segmentación
Memoria
principal
Nro
seg
Nro
seg
Figura
8.12
Traducción
direcciones
sistema
segmentación
08-Capitulo
12/5/05
16:23
Página
356PAGINACIÓN
SEGMENTACIÓN
COMBINADAS
Paginació
segmentació
ventajas
paginació
transparente
programador
elimina
fragmentació
externa
proporciona
eficiente
me-
moria
principal
Adicionalmente
fragmentos
mueven
memoria
disco
tamañ
prefijado
desarrollar
algoritmos
gesti
memo-
ria
má
sofisticados
exploten
comportamiento
programas
veremos
má
adelan-
segmentaci
visible
programador
beneficios
visto
anterior-
mente
incluyendo
posibilidad
manejar
estructuras
datos
crecen
modularidad
soporte
compartició
protecció
n.
combinar
ventajas
sistemas
hardware
procesador
soporte
sistema
operativo
capaces
propor-
cionar
sistema
combinado
paginación
segmentación
espacio
direcciones
usuario
divide
número
segmentos
discreción
programador
segmento
di-
vidido
número
páginas
tamaño
fijo
tamaño
marcos
memoria
principal
segmento
longitud
inferior
ágina
segmento
ocupará
únicamente
página
punto
vista
programador
direcci
ón
lógica
conteniendo
número
segmento
desplazamiento
segmento
punto
vista
sistema
desplazamiento
segmento
visto
úmero
página
desplazamiento
página
incluida
segmento
Figura
8.13
sugiere
estructura
proporcionar
soporte
combinació
paginació
segmentació
nó
tese
similitud
Figura
8.5
Asociada
proceso
tabla
segmentos
tablas
pá
ginas
segmentos
proceso
est
ejecució
registro
mantiene
direcció
comienzo
tabla
segmentos
pro-
ceso
direcció
virtual
procesador
utiliza
correspondiente
úmero
segmento
indexar
tabla
segmentos
proceso
encontrar
tabla
pá
gi-
Memoria
virtual
357
Nro
seg
Puntero
tabla
segmentos
Dirección
virtual
Dirección
física
Tabla
página
Programa
Mecanismo
segmentación
Mecanismo
páginación
Memoria
principal
Página
segmentos
Nro
seg
Nro
Página
Desplazamiento
Nro
seg
DesplazamientoNro
seg
Desplazamiento
Figura
8.13
Traducción
direcciones
sistema
segmentación
paginación
08-Capitulo
12/5/05
16:23
Página
357nas
segmento
Despué
correspondiente
nú
mero
pá
gina
direcció
vir-
tual
original
utiliza
indexar
tabla
ginas
buscar
correspondiente
nú
mero
mar-
co
ste
combina
desplazamiento
correspondiente
direcci
virtual
generar
direcció
real
requerida
Figura
8.2c
muestran
formatos
entrada
tabla
segmentos
entrada
tabla
páginas
entrada
tabla
segmentos
contiene
longitud
seg-
mento
contiene
campo
base
referencia
tabla
áginas
bits
presente
modificado
necesitan
aspectos
gestionan
nivel
ágina
bits
control
utilizarse
efectos
compartición
protección
entrada
ta-
bla
páginas
esencialmente
sistema
paginaci
ón
puro
número
pági-
na
proyecta
número
marco
correspondiente
página
presente
me-
moria
bit
modificado
indica
ágina
necesita
escribirse
expulse
marco
página
actual
bits
control
relacionados
protecci
ón
aspectos
gestión
memoria
PROTECCIÓN
COMPARTICIÓN
segmentación
proporciona
vía
implementación
políticas
protección
com-
partición
entrada
tabla
segmentos
incluye
longitud
as
direc-
ción
base
programa
forma
descontrolada
acceder
posici
ón
memoria
princi-
pa
allá
límites
segmento
compartici
ón
segmento
encuentre
referenciado
tablas
segmentos
ás
proceso
mecanismos
disponibles
sistemas
paginaci
ón
caso
estructura
páginas
programa
datos
visible
programador
especifica-
ción
protección
requisitos
compartición
cómodos
Figura
8.14
ilustra
tipos
relaciones
protección
definir
sistema
proporcionar
mecanismos
ás
sofisticados
esquema
habitual
utilizar
estructura
protección
anillo
tipo
indicamos
Cap
ítulo
Problema
3.7
esquema
anillos
números
bajos
interiores
disfrutan
mayores
privilegios
anillos
numeraciones
altas
exteriores
Normalmente
anillo
reserva
funciones
nú-
cleo
sistema
operativo
aplicaciones
niveles
superiores
utilidades
servicios
sistema
operativo
ocupar
anillo
intermedio
principios
ásicos
sistemas
anillo
siguientes
programa
acceder
datos
residentes
anillo
anillos
me-
privilegios
programa
invocar
servicios
residentes
anillo
anillos
má
privi-
legios
8.2
SOFTWARE
SISTEMA
OPERATIVO
diseño
gesti
ón
memoria
sistema
operativo
depende
opciones
fun-
damentales
elegir
sistema
técnicas
memoria
virtual
paginación
segmentación
ambas
algoritmos
utilizados
aspectos
gestión
memoria
358
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
358Las
elecciones
posibles
primeras
opciones
dependen
plataforma
hardware
dis-
ponible
primeras
implantaciones
UNIX
proporcionaban
memoria
virtual
procesadores
ejecutaban
daban
soporte
paginaci
ón
segmentación
técnicas
abordable
plataforma
hardware
traducción
direcciones
funciones
básicas
tambié
comentarios
adicionales
primeras
opciones
ex-
cepció
sistemas
operativos
plataformas
ordenadores
personales
antiguos
MS-DOS
sistemas
cará
cter
especializado
sistemas
operativos
importan-
tes
proporcionan
memoria
virtual
sistemas
segmentació
pura
actualidad
re-
almente
escasos
segmentació
combina
paginació
mayorí
aspectos
gestió
memoria
relativos
diseñ
sistema
operativo
encuadran
rea
paginació
forma
secció
concentraremos
aspectos
asociados
paginació
n.
elecciones
relativas
opción
entran
dominio
software
sistema
operativo
objeto
secci
ón
Tabla
8.3
muestra
elementos
dise
ño
clave
Memoria
virtual
359
protección
compartición
sistema
combinado
segmentación
paginación
suelen
delegar
habitualmente
ni-
vel
segmento
Abordaremos
cuestiones
capítulos
posteriores
Memoria
principalDirección
Activador
Proceso
Proceso
Proceso
20
Acceso
permitido
Instrucción
salto
permitido
Referencia
dato
permitido
35
50
80
90
140
190
Referencia
dato
permitido
Figura
8.14
Relaciones
protección
segmentos
08-Capitulo
12/5/05
16:23
Página
359van
examinar
caso
aspecto
central
rendimiento
tratará
minimizar
tasa
ocurrencia
fallos
ágina
fallos
página
causan
considerable
sobrecarga
software
mínimo
sobrecarga
incluye
decisi
ón
ágina
páginas
residentes
reemplazar
intercambio
swap
dichas
páginas
sistema
operativo
planificar
ejecuci
ón
proceso
operación
página
causando
cambio
contexto
forma
intentaremos
organizar
determinados
aspectos
forma
tiempo
ejecuci
ón
proceso
probabilidad
referencia
palabra
página
encuentre
presente
mínima
áreas
indicadas
Tabla
8.3
política
dem
ás
verá
tarea
gestión
me-
moria
entorno
paginación
endiabladamente
compleja
Adicionalmente
rendimiento
conjunto
políticas
particular
depende
tamaño
memoria
velocidad
relativa
memoria
principal
secundaria
tama
ño
número
procesos
est
án
compitiendo
recursos
comportamiento
ejecuci
ón
programas
forma
individual
característica
depende
naturaleza
aplicación
lenguaje
programación
compilador
utilizado
estilo
programador
escribi
programa
interactivo
comportamiento
dinámico
usuario
lector
esperar
ning
ún
res-
puesta
definitiva
sistemas
pequeños
diseño
sistema
operativo
intentar
elegir
conjunto
políticas
parezcan
funcionar
amplia
gama
condiciones
bas
ándo-
conocimiento
actual
sistema
sistemas
particularmente
mainframes
sistema
operativo
incluir
herramientas
monitorización
control
permitan
administrador
instalación
ajustar
obtener
resultados
base
condi-
ciones
instalación
POLÍTICA
RECUPERACIÓN
política
recuperación
determina
página
trae
memoria
principal
al-
ternativas
habituales
demanda
paginaci
ón
adelantada
prepaging
paginación
demanda
página
trae
memoria
ólo
referencia
posici
ón
dicha
pági-
na
resto
elementos
política
gestión
memoria
funcionan
correctamente
ocurriría
360
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
8.3
Políticas
sistema
operativo
memoria
virtual
Política
recuperación
Gestión
conjunto
residente
demanda
Tamaño
conjunto
residente
Paginación
adelantada
Fijo
Variable
Política
ubicación
Ámbito
reemplazo
Global
Política
reemplazo
Local
Algoritmos
básicos
Óptimo
Política
limpieza
FIFO
demanda
Usada
recientemente
LRU
Limpieza
adelantada
reloj
Control
carga
Buffers
página
Grado
multiprogramación
08-Capitulo
12/5/05
16:23
Página
360lo
proceso
arranca
inicialmente
áfaga
fallos
página
trayendo
páginas
memoria
principio
proximidad
sugiere
futuras
referencias
encontrarán
páginas
recientemente
traídas
tiempo
situación
estabilizará
número
fallos
página
caerá
nivel
paginación
adelantada
prepaging
traen
memoria
páginas
causado
fallo
página
paginación
adelantada
características
mayoría
dispositivos
memoria
secundaria
tales
discos
tiem-
pos
búsqueda
latencia
rotación
páginas
proceso
encuentran
almacenadas
memoria
secundaria
forma
contigua
eficiente
traer
memoria
número
pá-
ginas
contiguas
lugar
traerlas
periodo
tiempo
ás
am-
plio
política
ineficiente
mayoría
páginas
traído
re-
ferencian
posteriori
política
paginación
adelantada
emplearse
proceso
arranca
cuyo
caso
programador
designar
forma
páginas
necesarias
ocurra
fallo
página
caso
apropiado
resulta
completamente
invisible
programador
completa
utilidad
paginaci
ón
adelantada
recono-
cida
MAEK87
paginación
adelantada
confundir
swapping
proceso
saca
memoria
coloca
suspendido
páginas
residentes
expulsan
memoria
proceso
recupera
páginas
previamente
memoria
principal
re-
tornan
POLÍTICA
UBICACIÓN
política
ubicación
determina
memoria
real
residir
porciones
memoria
proceso
sistema
segmentaci
ón
puros
política
ubicación
aspecto
diseño
importante
políticas
estilo
ajuste
ajuste
similares
discutie-
ron
Capítulo
alternativas
sistemas
pagi-
nación
pura
paginación
combinada
segmentación
ubicación
habitualmente
irrelevante
de-
bido
hardware
traducción
direcciones
hardware
acceso
memoria
principal
funciones
combinación
página-marco
eficiencia
entorno
ubicación
implicación
importante
tema
investi-
gación
desarrollo
sistemas
llamados
multiprocesadores
acceso
memoria
uni-
forme
nonuniform
memory
access
multiprocessors-NUMA
memoria
distribuida
compartida
máquina
referenciarse
procesador
áquina
tiempo
acceso
dependiente
localización
física
varía
distancia
procesador
módulo
memoria
forma
rendimiento
depende
significativamente
distancia
reside
dato
relación
procesador
utilizar
LARO92
BOLO89
COX89
sistemas
NUMA
estrategia
ubicación
automática
aceptable
asigna
páginas
módulo
memoria
finalmente
proporcionará
rendimiento
POLÍTICA
REEMPLAZO
mayoría
libros
sistemas
operativos
tratamiento
gestión
memoria
in-
cluye
sección
titulada
política
reemplazo
selección
página
me-
moria
principal
candidata
reemplazarse
traer
página
tema
difícil
explicar
conceptos
interrelacionados
Memoria
virtual
361
08-Capitulo
12/5/05
16:23
Página
361•
marcos
página
reservar
procesos
activos
conjunto
páginas
considerar
reemplazo
limita
aque-
llas
proceso
causado
fallo
ágina
contrario
consideran
marcos
página
memoria
principal
conjunto
páginas
considerar
ágina
concreto
reemplazar
referimos
conceptos
gestión
conjunto
residente
subsección
reservado
término
política
reemplazo
tercer
concepto
discutirá
subsección
rea
polí
ticas
reemplazo
probablemente
aspecto
gestió
memoria
má
estudiado
marcos
memoria
principal
est
ocupados
nece-
sario
traer
pá
gina
resolver
fallo
pá
gina
polí
tica
reemplazo
determina
pá
gina
actualmente
memoria
reemplazarse
polí
ticas
objetivo
pá
gina
eliminarse
posibilidades
volver
te-
ner
referencia
futuro
pró
ximo
principio
proximidad
referencia
alta
correlació
histó
rico
referencias
recientes
patrones
referencia
futuro
pró
ximo
mayorí
polí
ticas
tratan
predecir
comportamiento
futuro
base
comportamiento
contraprestaci
considerar
má
elaborada
sofisticada
polí
tica
reemplazo
sobrecarga
nivel
software
hardware
implementarla
Bloqueo
marcos
necesario
mencionar
restricción
aplica
políticas
reem-
plazo
indagar
algoritmos
marcos
memoria
principal
encontrarse
bloqueados
marco
est
bloqueado
página
actualmente
almacenada
di-
cho
marco
reemplazarse
núcleo
sistema
operativo
almacena
mar-
cos
bloqueados
estructuras
control
claves
Adicionalmente
buffers
áreas
tipo
critico
ponen
marcos
bloqueados
memoria
principal
bloqueo
asociando
bit
bloqueo
marcos
bit
al-
macenar
tabla
marcos
incluirse
tabla
páginas
actual
Algoritmos
básicos
Independientemente
estrategia
gesti
ón
conjunto
residente
discutirá
subsección
algoritmos
básicos
utilizan
selec-
ción
página
reemplazar
algoritmos
reemplazo
desarrollando
literatura
•Ó
ptimo
Usado
recientemente
least
recently
used-LRU
FIFO
first-in-first-out
Reloj
política
óptima
selección
tomará
reemplazo
página
instante
referencia
lejos
política
resultados
menor
número
posibles
fallos
ágina
BELA66
Evidentemente
pol
ítica
imposible
implementar
requiere
sistema
operativo
perfecto
conocimiento
eventos
futuros
utiliza
estándar
apartir
contrastar
algoritmos
reales
Figura
8.15
proporciona
ejemplo
pol
ítica
óptima
ejemplo
asume
reserva
marcos
fija
tamaño
conjunto
residente
fijo
proceso
marcos
eje-
362
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
362cución
proceso
requiere
referencia
páginas
flujo
páginas
referenciadas
programa
citado
232152453252
representa
página
referencia
ágina
política
óptima
produce
fallos
ágina
reserva
marcos
ocupado
completamente
política
reemplazo
página
usada
recientemente
LRU
seleccionará
candidata
página
memoria
referenciado
ás
tiempo
prin-
cipio
proximidad
referenciada
página
probabilidad
volverá
referencias
futuro
pol
ítica
LRU
proporciona
resultados
política
óptima
problema
alternativa
dificultad
implementa-
ción
opción
etiquetar
página
instante
tiempo
referencia
referencias
memoria
instrucciones
datos
caso
hardware
diera
soporte
esquema
sobrecarga
tremenda
forma
alternativa
mantener
pila
referencias
páginas
igualmente
opci
ón
costosa
Figura
8.15
muestra
ejemplo
comportamiento
LRU
utilizando
flujo
re-
ferencias
páginas
ejemplo
política
óptima
ejemplo
producen
fa-
llos
página
política
FIFO
marcos
página
ocupados
tratase
buffer
circular
páginas
remplazan
estrategia
cíclica
tipo
round-robin
necesita
Memoria
virtual
363
232152453252
FF
FF
FF
FF
fallo
página
reserva
marcos
llenado
inicialmente
FF
OPT
Flujo
páginas
referenciales
LRU
FIFO
RELOJ
Figura
8.15
Comportamiento
algoritmos
reemplazo
páginas
08-Capitulo
12/5/05
16:23
Página
363es
puntero
recorra
forma
circular
marcos
ágina
proceso
políticas
reemplazo
sencilla
implementar
razonamiento
modelo
simplicidad
reemplazo
página
memoria
tiempo
página
traída
memoria
tiempo
dejado
utilizarse
razonamiento
menu-
do
erróneo
habitual
programas
zona
regiones
datos
utilizados
forma
intensiva
tiempo
vida
proceso
áginas
expulsadas
memoria
tra
ídas
forma
repetida
algoritmo
tipo
FIFO
Continuando
ejemplo
Figura
8.15
pol
ítica
FIFO
genera
fa-
llos
página
Nótese
algoritmo
LRU
reconoce
áginas
referencia
frecuencia
página
FIFO
política
LRU
alcanza
resultados
similares
política
óptima
difícil
implementar
impone
sobrecarga
significativa
política
FIFO
sencilla
implementar
rendimiento
relativamente
pobre
ños
diseñadores
sistemas
operativos
intentado
número
algoritmos
aproximarse
re-
sultados
obtenidos
LRU
intentando
imponer
sobrecarga
ás
reducida
al-
goritmos
variantes
esquema
denominado
política
reloj
forma
sencilla
política
reloj
requiere
inclusi
ón
bit
adicional
marcos
página
denominado
bit
usado
ágina
trae
memoria
bit
usado
marco
pone
momento
ágina
vuelva
utilizarse
referencia
generada
fallo
ágina
inicial
bit
usado
pone
algoritmo
reemplazo
áginas
conjunto
áginas
candidatas
reemplazo
proceso
ámbito
local
memoria
principal
ámbito
global
dispo-
nen
tratase
buffer
circular
asocia
puntero
reemplaza
página
puntero
indica
marco
buffer
justo
marco
acaba
actuali-
zarse
llega
momento
reemplazar
página
sistema
operativo
recorre
buffer
encontrar
marco
bit
usado
marco
bit
usado
reinicia
bit
continúa
marcos
buffer
bit
usado
co-
mienzo
proceso
marcos
encuentre
seleccionar
reemplazo
marcos
bit
puntero
completar
ciclo
completo
buffer
poniendo
bits
usado
parándose
posición
original
reemplazando
ágina
di-
cho
marco
Véase
política
similar
FIFO
pol
ítica
reloj
algorit-
mo
saltará
marco
bit
usado
pol
ítica
domina
política
reloj
visualizar
marcos
página
estuviesen
distribuidos
írculo
número
sistemas
operativos
empleado
variante
política
sencilla
reloj
ejemplo
Multics
CORB68
Figura
8.16
plantea
ejemplo
mecanismo
política
reloj
buffer
circular
marcos
memoria
principal
encuentran
disponibles
reemplazo
ágina
comienzo
reemplazo
ágina
buffer
página
entrante
727
puntero
marco
apunta
marco
número
contiene
página
45
momento
política
reloj
co-
mienza
ejecutarse
bit
usado
ágina
45
marco
ágina
reemplaza
bit
usado
pone
puntero
avanza
forma
similar
página
191
marco
remplazar
bit
usado
pondrá
avanzando
nue-
vo
puntero
marco
marco
úmero
bit
usado
est
ágina
556
reemplazará
ágina
727
bit
usado
pone
marco
puntero
avanza
marco
completando
procedimiento
reemplazo
página
364
Sistemas
operativos
Aspectos
internos
principios
diseño
concepto
ámbito
discute
subsecci
ón
Ámbito
reemplazo
08-Capitulo
12/5/05
16:23
Página
364El
comportamiento
política
reloj
ilustrado
Figura
8.15
presencia
asterisco
indica
correspondiente
bit
usado
flecha
indica
po-
sición
actual
puntero
Nótese
política
reloj
intenta
proteger
marcos
posi-
ble
reemplazo
Figura
8.17
muestra
resultados
experimento
BAER80
compara
algoritmos
comentado
asume
úmero
marcos
página
asignados
proceso
fijo
resultado
basa
ejecuci
ón
0,25
10
referencias
programa
FORTRAN
utilizando
tama
ño
página
256
palabras
Baer
ejecutó
experimento
reservas
10
12
14
marcos
diferencias
pol
íticas
palpables
Memoria
virtual
365
/H11002
/H11002
Pág
19
Pág
puntero
marco
Pág
45
Pág
191
Pág
556
Pág
13Pág
67
Pág
33
Pág
222
Pág
Usado
/H11005
buffer
justo
reemplazo
página
Pág
19
Pág
Pág
45
Pág
191
Pág
727
Pág
13Pág
67
Pág
33
Pág
222
Pág
buffer
justo
reemplazo
página
marco
buffer
circular
candidato
reemplazo
Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
0Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
1Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
Usado
/H11005
0Usado
/H11005
Usado
/H11005
Usado
/H11005
Figura
8.16
Ejemplo
operación
política
reemplazo
reloj
08-Capitulo
12/5/05
16:23
Página
365cuando
número
marcos
reservados
peque
ño
estando
FIFO
factor
ve-
ces
óptimo
curvas
mantienen
forma
comportamiento
ideal
mostrado
Figura
8.11b
intención
ejecutar
forma
eficiente
deseable
encontrarse
derecho
curva
tasa
fallos
ágina
pequeña
tiempo
mantiene
necesidad
reservar
relativamente
marcos
izquierdo
curva
restricciones
indican
deseable
operaci
ón
estaría
aproximadamen-
mitad
curva
FINK88
tanbié
reporta
resultados
prá
cticamente
idé
nticos
mostrando
des-
viació
má
xima
torno
factor
estrategia
Finkel
consistí
simular
efecto
va-
rias
polí
ticas
cadena
referencias
pá
ginas
generada
sinté
ticamente
10.000
re-
ferencias
seleccionadas
espacio
virtual
100
pá
ginas
aproximarse
efectos
principio
pró
ximidad
referencia
impuso
distribució
exponencial
probabili-
dad
referencia
pá
gina
concreto
Finkel
indica
podr
concluir
sentido
elaborar
algoritmos
reemplazo
pá
ginas
só
factor
juego
remarca
diferencia
efecto
considerable
requisitos
memoria
prin-
cipal
evitar
rendimiento
sistema
operativo
degrade
rendi-
miento
sistema
operativo
evitar
requisito
memoria
principal
algoritmo
reloj
comparado
algoritmos
reserva
marcos
variable
aplican
ámbitos
reemplazamiento
global
local
véase
si-
guiente
explicación
relativa
políticas
reemplazo
CARR81
CARR
84
algoritmo
re-
loj
rendimiento
LRU
algoritmo
reloj
hacerse
potente
incrementando
número
bits
utiliza
procesadores
soportan
paginaci
ón
asocia
bit
modificado
páginas
memoria
principal
marco
memoria
principal
bit
nece-
sario
página
modificado
reemplazar
escrito
memoria
secundaria
sacar
provecho
bit
algoritmo
re-
loj
bits
usado
modificado
marco
ági-
na
cae
categorías
siguientes
366
Sistemas
operativos
Aspectos
internos
principios
diseño
reduce
número
bits
utilizados
algoritmo
reloj
degenera
tipo
FIFO
68
Número
marcos
reservados
Fallos
página
1000
referencias
10
12
14
10
15
20
25
30
35
FIFO
RELOJ
LRU
OPT
40
Figura
8.17
Comparativa
algoritmos
reemplazo
local
reserva
marcos
fija
08-Capitulo
12/5/05
16:23
Página
366•
accedido
recientemente
modificada
Accedida
recientemente
modificada
accedido
recientemente
modificada
Accedida
recientemente
modificada
clasificación
algoritmo
reloj
actuar
Comenzando
posici
ón
actual
puntero
recorremos
buffer
marcos
re-
corrido
cambio
bit
usado
marco
encuentre
selecciona
reemplazo
paso
falla
recorre
buffer
buscando
marco
pri-
mer
marco
encuentre
seleccionará
reemplazo
recorrido
pondrá
bit
usado
marcos
vayan
saltando
paso
falla
puntero
vuelto
posici
ón
original
mar-
cos
conjunto
bit
usado
repite
paso
resulta
necesario
paso
encontrará
marco
reemplazo
resumen
algoritmo
reemplazo
ginas
vueltas
travé
pá
ginas
buffer
buscando
modificado
tra
do
accedida
recientemente
pá
gina
opció
reemplazo
ventaja
modificado
necesita
escribirse
memoria
secundaria
pá
gina
candidata
vuelta
algoritmo
vuelta
buffer
buscando
pá
gina
modificada
accedido
recientemente
gina
escribirse
remplazada
principio
proximidad
referencia
necesitarse
futuro
pr
ximo
falla
marcos
buf-
fer
encuentran
marcados
hubiesen
accedidos
recientemente
realiza
ter-
cera
estrategia
utilizado
esquema
memoria
virtual
versiones
antiguas
Macintosh
GOLD89
mostrados
Figura
8.18
ventaja
algoritmo
algoritmo
reloj
básico
otorga
preferencia
reemplazo
áginas
modifi-
cado
página
modificado
escribirse
reemplazo
aho-
rro
tiempo
inmediato
Buffering
páginas
políticas
LRU
reloj
superiores
FIFO
ambas
in-
cluyen
complejidad
sobrecarga
FIFO
sufre
Adicionalmente
aspecto
relati-
vo
coste
reemplazo
página
modificado
superior
escribirse
memoria
secundaria
estrategia
interesante
mejorar
rendimiento
paginación
permite
política
reemplazo
áginas
sencilla
buffering
páginas
estrategia
re-
presentativa
tipo
usaba
AX
VMS
algoritmo
reemplazo
páginas
FIFO
sencillo
mejorar
rendimiento
página
remplazada
pierde
asigna
siguientes
listas
lista
páginas
libres
página
modificado
lista
pági-
nas
modificadas
Véase
página
mueve
físicamente
memoria
contra-
rio
entrada
tabla
páginas
página
elimina
coloca
lista
áginas
libres
lista
páginas
modificadas
lista
páginas
libres
lista
marcos
páginas
disponibles
lectura
pá-
ginas
VMS
intenta
mantener
peque
ño
número
marcos
libres
momento
Memoria
virtual
367
08-Capitulo
12/5/05
16:23
Página
367página
leer
utiliza
marco
página
cabeza
lista
eliminando
ágina
reemplazar
ágina
modificado
mantiene
memoria
marco
página
añade
lista
áginas
libres
forma
similar
á-
gina
modificada
escribir
reemplazar
marco
página
añade
lista
pági-
nas
modificadas
aspecto
importante
maniobras
página
reemplazar
mantie-
ne
memoria
forma
proceso
referencia
ágina
devuelve
conjunto
residente
proceso
coste
efecto
lista
áginas
modificadas
libres
actúa
cache
páginas
lista
páginas
modificadas
función
útil
pági-
nas
modificadas
escriben
grupos
lugar
reduce
forma
significativa
número
operaciones
tiempo
acceso
disco
versión
simple
estrategia
buffering
páginas
implementa
sistema
operativo
Mach
RASH88
caso
realiza
distinción
páginas
modificadas
modificadas
Política
reemplazo
tamaño
cache
comentado
anteriormente
tamaño
memoria
principal
crece
proximidad
referencia
aplicaciones
decrecer
compensación
tamaños
caches
aumentando
Actualmente
tama
ños
caches
megabytes
alternativas
dise
ño
abordables
BORG90
368
Sistemas
operativos
Aspectos
internos
principios
diseño
marco
buffer
circular
proceso
reemplazo
reemplazo
Página
accedida
recientemente
modificada
56
/H11002
Página
accedida
recientemente
modificada
Página
94
accedida
recientemente
modificada
Página
95
accedida
recientemente
modificada
Página
96
accedida
recientemente
modificada
Página
97
accedida
recientemente
modificadaPágina
45
accedida
recientemente
modificada
Página
121
accedida
recientemente
modificada
Página
46
accedida
recientemente
modificada
Página
47
accedida
recientemente
modificada
Página
13
accedida
recientemente
modificada
Figura
8.18
algoritmo
reemplazo
páginas
reloj
GOLD89
08-Capitulo
12/5/05
16:23
Página
368cache
tamaño
reemplazo
páginas
memoria
virtual
impacto
impor-
tante
rendimiento
marco
página
destinado
reemplazo
cache
blo-
cache
pierde
tiempo
página
contiene
sistemas
utilizan
algú
tipo
buffering
pá
ginas
mejorar
rendimiento
cache
añ
adiendo
polí
tica
reemplazo
pá
ginas
polí
tica
ubicació
pá
ginas
buffer
pá
ginas
mayorí
sistemas
operativos
ubican
ginas
seleccionando
marco
procedente
buffer
pá
ginas
forma
arbitraria
utilizando
habitualmente
disciplina
tipo
FIFO
estudio
reportado
KESS92
muestra
estrategia
reemplazo
ginas
cuidadosa
significar
10
20%
fallos
cache
compara
re-
emplazo
simple
KESS92
examinan
algoritmos
reemplazo
áginas
detalles
allá
ámbito
libro
dependen
detalles
estructura
caches
políticas
esencia
estrategias
consiste
traer
páginas
consecutivas
memoria
prin-
cipal
forma
minimice
número
marcos
página
encuentran
proyectados
ranuras
cache
GESTIÓN
CONJUNTO
RESIDENTE
amaño
conjunto
residente
memoria
virtual
paginada
necesario
casos
siquiera
traer
páginas
proceso
memoria
principal
pre-
parar
ejecución
sistema
operativo
debería
páginas
traerse
memoria
principal
debería
reservar
proceso
particular
factores
entran
juego
menor
cantidad
memoria
reservada
proceso
úmero
procesos
residir
memoria
principal
aumenta
probabilidad
sistema
operativo
encontrar
proceso
listo
ejecutar
instan-
reduce
tiempo
perdido
swapping
conjunto
páginas
proceso
est
án
memoria
relativamente
peque
ño
en-
tonces
virtud
principio
proximidad
referencia
posibilidad
fallo
ági-
na
véase
Figura
8.11.b
allá
determinado
tamaño
reserva
memoria
principal
determinado
proceso
efecto
apreciable
tasa
fallos
ágina
proceso
de-
bido
principio
proximidad
referencia
Teniendo
factores
encontrar
tipos
políticas
existentes
sis-
temas
operativos
contemporáneos
política
asignación
fija
proporciona
número
fijo
mar-
cos
memoria
principal
disponibles
ejecución
número
decide
momento
car-
ga
inicial
proceso
instante
creaci
ón
proceso
determinar
base
tipo
proceso
interactivo
lotes
tipo
aplicación
basar
guías
proporcionadas
programador
administrador
sistema
pol
ítica
asignación
fija
pro-
duzca
fallo
página
proceso
ejecución
página
necesite
reemplazará
páginas
proceso
política
asignación
variable
permite
reserven
número
marcos
proceso
variar
tiempo
vida
forma
ideal
proceso
est
cau-
sando
tasa
fallos
página
relativamente
alta
forma
continua
indicativo
principio
proximidad
referencia
aplica
forma
relativamente
débil
proceso
otorgarán
marcos
página
adicionales
reducir
tasa
fallos
proceso
Memoria
virtual
369
08-Capitulo
12/5/05
16:23
Página
369con
tasa
fallos
páginas
excepcionalmente
baja
indicativo
proceso
com-
portamiento
ajustado
principio
proximidad
referencia
reducir
án
marcos
reserva-
esperanza
incremente
forma
apreciable
tasa
fallos
políticas
asignación
variable
basa
concepto
ámbito
reemplazo
explicar
si-
guiente
subsección
política
asignación
variable
parecer
potente
dificultades
estrategia
sistema
operativo
cu
ál
comportamiento
proceso
activo
requiere
forma
inevitable
sobrecarga
software
sistema
operativo
depende
mecanismos
hardware
proporcionados
plataforma
procesador
Ámbito
reemplazo
estrategia
ámbito
reemplazo
clasificar
global
local
tipos
políticas
activan
fallo
ágina
marcos
á-
gina
libres
política
reemplazo
local
selecciona
únicamente
páginas
residentes
proceso
generado
fallo
ágina
identificación
página
reemplazar
política
reemplazo
global
consideran
páginas
memoria
principal
en-
cuentren
bloqueadas
candidatos
reemplazo
independientemente
proceso
perte-
nezca
página
particular
políticas
locales
fáciles
analizar
evidencia
convincente
proporcionen
rendimiento
pol
íticas
globales
atractivas
simplicidad
implementaci
ón
sobrecarga
mínima
CARR84
MAEK87
correlación
ámbito
reemplazo
tamaño
conjunto
residente
Tabla
8.4
conjunto
residente
fijo
implica
automáticamente
política
reemplazo
local
man-
tamaño
conjunto
residente
reemplazar
ágina
eliminar
memoria
prin-
cipal
proceso
política
asignación
variable
emplear
claramente
políti-
ca
reemplazo
global
reemplazo
ágina
proceso
memoria
principal
causa
asignación
memoria
proceso
crezca
página
disminu-
ye
verá
asignación
variable
reemplazo
local
combinaci
ón
válida
examinan
combinaciones
Asignación
fija
ámbito
local
caso
proceso
ejecuci
ón
memoria
principal
número
marcos
fijo
fallo
ágina
sistema
operativo
elegir
página
residentes
proceso
actual
reemplazo
utilizarían
algoritmos
reemplazo
visto
secci
ón
precedente
política
asignación
fija
necesario
decidir
adelantado
cantidad
espacio
re-
servado
proceso
determinado
base
tipo
aplicaci
ón
tamaño
programa
desventajas
estrategia
tipos
reservas
resultan
demasia-
do
pequeñas
alta
tasa
fallos
página
sistema
multiprogramado
completo
ralentice
reservas
resultan
habr
pro-
gramas
memoria
principal
tiempo
procesador
ocioso
tiempo
perdi-
do
swapping
Asignación
variable
ámbito
global
combinación
probablemente
sencilla
im-
plementar
adoptada
número
sistemas
operativos
momento
determina-
do
número
procesos
determinado
memoria
principal
serie
marcos
asignados
Normalmente
sistema
operativo
mantiene
lista
marcos
libres
sucede
fallo
ágina
añade
marco
libre
conjunto
residente
proceso
trae
página
marco
forma
proceso
sufra
diversos
fallos
á-
gina
crecerá
gradualmente
tamaño
debería
reducir
tasa
fallos
página
global
sistema
370
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
370La
dificultad
estrategia
elecció
reemplazos
marcos
libres
disponibles
sistema
operativo
elegir
pá
gina
actualmente
memoria
reemplazarla
selecció
cabo
marcos
en-
cuentran
memoria
principal
excepci
marcos
bloqueados
usados
núcleo
Utilizando
cualquiera
polí
ticas
vistas
secció
pá
gina
se-
leccionada
reemplazo
pertenecer
cualquiera
procesos
residentes
nin-
guna
disciplina
predeterminada
indique
qu
proceso
perder
pá
gina
conjunto
resi-
dente
proceso
sufre
reducció
tamañ
conjunto
residente
porqué
ptimo
forma
encontrar
contraprestació
problemas
rendimiento
potenciales
asignació
variable
reemplazo
mbito
global
centran
buffering
pá
ginas
forma
selecció
pá
gina
reemplace
significativa
pá
gina
reclamar
referencia
bloque
páginas
sobrescriba
Asignación
variable
ámbito
local
asignación
variable
reemplazo
ámbito
local
intenta
resolver
problemas
estrategia
ámbito
global
resumir
carga
proceso
memoria
principal
asignan
úmero
marcos
página
conjunto
residente
basando
tipo
aplicaci
ón
solicitudes
pro-
grama
criterios
cubrir
reserva
utilizará
paginaci
ón
adelantada
pagi-
nación
demanda
ocurra
fallo
página
página
seleccionará
reemplazar
pertenecerá
conjunto
residente
proceso
causó
fallo
reevaluará
asignación
proporcionada
proceso
increment
ándose
reduciéndose
mejorar
rendimiento
estrategia
decisiones
relativas
aumentar
disminuir
tamaño
conjunto
resi-
dente
toman
forma
meditada
harán
contando
indicios
posibles
demandas
futuras
procesos
encuentran
activos
forma
realiza
valora-
ción
estrategia
compleja
política
reemplazo
global
simple
rendimiento
elementos
clave
estrategia
asignación
variable
ámbito
local
criterios
utilizan
determinar
tamaño
conjunto
residente
periodicidad
cambios
Memoria
virtual
371
able
8.4
Gestión
conjunto
residente
Reemplazo
Local
Reemplazo
Global
Asignación
Fija
número
marcos
asignados
proceso
fijo
páginas
reemplazar
eligen
marcos
asignados
proceso
Asignación
Variable
número
marcos
asignados
páginas
proceso
variarse
reemplazar
eligen
marcos
memoria
páginas
principal
reemplazar
eligen
tamaño
conjunto
residente
marcos
asignados
proceso
procesos
varíe
08-Capitulo
12/5/05
16:23
Página
371estrategia
específica
atraído
atención
literatura
denominada
estrategia
conjunto
trabajo
estrategia
conjunto
trabajo
pura
difícil
implemen-
tar
útil
examinarla
referencia
comparativas
conjunto
trabajo
concepto
acuñado
popularizado
Denning
DENN68
DENN70
DENN80b
profundo
impacto
diseño
gestión
memoria
virtual
conjunto
trabajo
parámetro
proceso
tiempo
virtual
W(t
conjunto
páginas
proceso
referenciado
unidades
tiempo
virtual
tiempo
virtual
define
Considérese
secuencia
referencias
me-
moria
r(1
r(2
r(i
página
contiene
i-esima
dirección
virtual
generada
proceso
tiempo
mide
referencias
memoria
t=1,2,3
mide
tiempo
virtual
interno
proceso
variables
W.
variable
ventana
tiempo
vir-
tual
observa
proceso
tamaño
conjunto
trabajo
función
decreciente
tamaño
ventana
resultado
muestra
Figura
8.19
base
BACH86
demuestra
secuencia
referencias
páginas
proceso
puntos
indican
unidades
tiempo
conjunto
trabajo
cambia
Nótese
tamaño
ventana
tamaño
conjunto
trabajo
expresar
re-
lación
W(t
D+1
W(t
conjunto
trabajo
función
tiempo
proceso
ejecuta
unidades
tiempo
terminando
tiempo
utiliza
única
página
|W(t
D)|=1
conjunto
traba-
jo
crecer
llegar
páginas
proceso
accede
rápidamente
páginas
tamaño
ventana
permite
forma
|W(t
D)|
min(D
Figura
8.20
indica
variar
tamaño
conjunto
trabajo
tiem-
po
valor
determinado
D.
programas
periodos
relativamente
estables
tamaño
conjunto
trabajo
alternan
periodos
cambio
rápido
pro-
ceso
comienza
ejecutar
forma
gradual
construye
conjunto
trabajo
medida
referencias
páginas
Esporádicamente
principio
proximidad
referencia
proceso
deberá
estabilizarse
conjunto
determinado
páginas
periodos
transito-
rios
posteriores
reflejan
cambio
programa
región
referencia
fase
transición
páginas
antiguo
conjunto
referencia
permanecerán
venta-
na
causando
rápido
incremento
tamaño
conjunto
trabajo
medida
re-
ferenciando
páginas
medida
ventana
desplaza
referencias
tamaño
conjunto
trabajo
reduce
contiene
únicamente
páginas
re-
gión
referencia
concepto
conjunto
trabajo
crear
estrategia
tamaño
conjunto
residente
Monitorizando
conjunto
trabajo
proceso
Eliminando
periódicamente
conjunto
residente
páginas
encuentran
conjunto
trabajo
esencia
política
LRU
proceso
ejecutar
conjunto
trabajo
memoria
principal
ejemplo
conjunto
residente
incluye
conjunto
trabajo
372
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
13/5/05
19:01
Página
372Esta
estrategia
funciona
principio
aceptado
principio
proximidad
referencia
explota
estrategia
gestión
memoria
minimice
fallos
página
Desgraciadamente
persisten
problemas
estrategia
conjunto
trabajo
predice
futuro
tama
ño
pertenencia
conjunto
trabajo
cambian
tiempo
ejemplo
véase
Figura
8.20
medición
conjunto
trabajo
proceso
practicable
ía
ne-
cesario
proceso
asignar
sello
tiempo
referencia
página
asigne
tiempo
virtual
proceso
mantenga
lista
ordenada
tiempo
áginas
valor
óptimo
desconocido
caso
variar
espí
ritu
estrategia
vá
lido
número
sistemas
operativos
inten-
aproximarse
estrategia
conjunto
trabajo
forma
centrarse
re-
ferencias
exactas
pá
ginas
tasa
fallos
pá
gina
ilustra
Figura
8.11b
tasa
fallos
pá
ginas
cae
medida
incrementa
tamañ
conjunto
residente
proceso
tamañ
conjunto
trabajo
caer
punto
curva
indicado
figura
lugar
monitorizar
tamañ
conjunto
trabajo
forma
directa
alcanzar
resul-
tados
comparables
monitorizando
tasa
fallos
pá
gina
razonamiento
tasa
Memoria
virtual
373
24
15
18
23
24
17
18
24
18
17
17
15
24
17
24
18
Secuencia
referencias
páginas
23
Tamaño
ventana
DD
45
24
24
15
15
18
18
23
23
24
24
17
17
18
18
24
18
17
17
17
15
15
24
24
17
24
18
24
24
15
24
15
18
15
18
23
18
23
24
23
24
17
24
17
18
18
24
24
18
17
18
17
17
15
17
15
24
24
17
17
24
18
24
24
15
24
15
18
15
18
23
18
23
24
17
24
17
18
18
17
15
17
15
24
17
24
18
24
24
15
24
15
18
15
18
23
15
18
23
24
17
18
23
24
17
24
17
18
24
18
17
15
17
15
24
15
17
24
18
Figura
8.19
Conjunto
trabajo
proceso
definido
tamaño
ventana
08-Capitulo
12/5/05
16:23
Página
373de
fallos
pá
ginas
proceso
determinado
límite
sistema
forma
global
beneficiar
asignar
tamañ
conjunto
residente
menor
proceso
dispone
número
marcos
pá
ginas
libres
procesos
dañ
ar
proceso
cuestió
causando
incremento
fallos
pá
gina
tasa
fallos
pá
gina
umbral
má
ximo
proceso
beneficiarse
incremento
tamañ
conjunto
residente
produzca
menor
número
fallos
degradar
sistema
algoritmo
estrategia
algoritmo
frecuencia
fallos
página
page
fault
frequency
PFF
CHU72
GUPT78
algoritmo
necesita
bit
usado
encuentre
asociado
página
memoria
bit
pondr
accedido
ágina
produce
fallo
página
sistema
operativo
anotar
tiempo
virtual
fallo
página
proceso
manteniendo
contador
referencias
páginas
fija
umbral
F.
diferencia
tiempo
fallo
página
menor
añade
página
conjunto
residente
proceso
caso
descartan
páginas
bit
usado
reduce
tamaño
conjunto
residente
forma
acorde
pone
bit
usado
resto
áginas
estrategia
refinar
usando
umbrales
umbral
máximo
utiliza
disparar
crecimiento
conjunto
resi-
dente
límite
inferior
utiliza
disparar
reducción
tamaño
conjunto
residente
tiempo
fallos
página
recíproco
tasa
fallos
página
parece-
ría
mantener
medida
ejecución
tasa
fallos
ágina
utilización
medida
tiempo
sencilla
compromiso
razonable
permite
de-
cisiones
relativas
tamaño
conjunto
residente
basen
tasa
fallos
ágina
es-
trategia
estilo
complementa
buffering
páginas
resultado
rendimiento
fallo
grave
estrategia
adoptada
PFF
comporta-
miento
periodos
transitorios
produce
desplazamiento
374
Sistemas
operativos
Aspectos
internos
principios
diseño
Transitorio
Estable
Tamaño
conjunto
trabajo
Tiempo
Transitorio
Transitorio
Transitorio
Estable
Estable
Estable
Figura
8.20
Gráfico
típico
tamaño
conjunto
trabajo
MAEK87
08-Capitulo
12/5/05
16:23
Página
374una
región
referencia
PFF
ágina
sale
conjunto
residente
ha-
yan
unidades
tiempo
virtual
referencia
periodos
regiones
referencia
rápida
sucesión
fallos
página
conjunto
residente
pro-
ceso
crezca
áginas
antigua
regi
ón
referencia
expulsen
súbitos
picos
solicitudes
memoria
producir
desactivaciones
reactivaciones
procesos
innece-
sarias
corresponden
cambios
proceso
sobrecargas
swapping
deseables
estrategia
intenta
manejar
fenómeno
transición
regiones
referencia
sobrecarga
relativamente
baja
comparado
PFF
política
conjunto
trabajo
muestreo
intervalos
variables
variable-interval
sampled
working
set
VSWS
FERR83
política
VSWS
evalúa
conjunto
trabajo
proceso
instantes
muestreo
basados
tiempo
virtual
transcurrido
comienzo
intervalo
muestreo
bits
usado
áginas
residentes
procesos
ponen
ólo
páginas
referencia
intervalo
mantendrán
bit
páginas
mantienen
conjunto
residente
proceso
intervalo
descartan
forma
tama-
ño
conjunto
residente
decrecerá
intervalo
intervalo
páginas
causado
fallo
añaden
conjunto
residente
forma
conjunto
residente
mantiene
tamaño
fijo
crece
intervalo
política
VSWS
toma
parámetros
duración
mínima
intervalo
muestreo
duración
máxima
intervalo
muestreo
número
fallos
página
permite
ocurran
instantes
muestreo
política
VSWS
tiempo
virtual
muestreo
alcanza
suspende
proceso
analizan
bits
usado
tiempo
virtual
transcurrido
llegue
ocurren
fallos
página
tiempo
virtual
muestreo
menor
espera
tiem-
po
virtual
transcurrido
alcance
valor
suspender
proceso
analizar
bits
usado
tiempo
virtual
muestreo
suspende
proceso
analizan
bits
usado
valores
parámetros
toman
forma
muestreo
dispare
habitualmente
cuan-
do
ocurre
fallo
página
muestreo
caso
2b
par
ámetros
proporcionan
fronteras
protección
condiciones
excepcionales
política
VSWS
intenta
reducir
pico
solicitudes
memoria
causadas
transici
ón
abrupta
áreas
refe-
rencia
incrementando
frecuencia
muestreo
tasa
áginas
utilizadas
descartan
conjunto
residente
tasa
fallos
página
incrementa
experiencia
técnica
sistema
operativo
mainframe
Bull
GCOS
indica
mecanismo
sencillo
implementar
PFF
efectivo
PIZZ89
POLÍTICA
LIMPIEZA
política
limpieza
opuesta
política
recuperación
encarga
determinar
página
modificada
escribir
memoria
secundaria
alternativas
ás
co-
Memoria
virtual
375
08-Capitulo
12/5/05
16:23
Página
375munes
limpieza
demanda
limpieza
adelantada
limpieza
demanda
página
escribe
memoria
secundaria
ólo
seleccionado
reemplazo
po-
lítica
limpieza
adelantada
escribe
páginas
modificadas
marcos
pági-
nas
necesiten
forma
páginas
puedan
escribir
lotes
peligro
perseguir
cualquiera
políticas
extremo
limpieza
adelantada
página
escribe
contin
úe
memoria
principal
algoritmo
re-
emplazo
páginas
indique
eliminarse
limpieza
adelantada
permite
áginas
es-
criban
lotes
sentido
escribir
cientos
miles
áginas
darnos
mayoría
modificarse
reemplazadas
capacidad
transferencia
memoria
secundaria
limitada
malgastar
operaciones
limpie-
za
innecesarias
limpieza
demanda
escritura
ágina
modificada
colisiona
precede
lectura
página
técnica
minimizar
escrituras
páginas
implica
proceso
sufrido
fallo
página
esperar
completen
trans-
ferencias
páginas
desbloquearse
implica
reducci
ón
utilización
procesador
estrategia
apropiada
incorpora
buffering
páginas
permite
adoptar
polí-
tica
limpiar
páginas
reemplazables
desacoplar
operaciones
limpieza
reemplazo
buffering
páginas
páginas
reemplazadas
ubicarse
listas
modifi-
cadas
modificadas
páginas
lista
modificadas
escribirse
periódicamente
lotes
moverse
lista
modificadas
ágina
lista
modificadas
reclamaba
referencia
perderse
marco
asigna
ágina
CONTROL
CARGA
control
carga
determina
número
procesos
residirán
memoria
principal
de-
nomina
grado
multiprogramación
política
control
carga
crítica
gestión
memoria
efectiva
procesos
residentes
ocasiones
cua-
procesos
encuentren
bloqueados
tiempo
gastarán
realizando
swap-
ping
demasiados
procesos
residentes
media
tamaño
conjunto
residente
proceso
adecuado
producirán
frecuentes
fallos
página
resulta-
do
trasiego
thrashing
Grado
multiprogramación
trasiego
muestra
Figura
8.21
medida
nivel
multiprogramación
aumenta
valores
peque
ños
cabría
esperar
utilización
proce-
sador
aumente
posibilidades
procesos
residentes
encuentren
bloqueados
alcanza
punto
tama
ño
conjunto
residente
promedio
adecuado
punto
número
fallos
páginas
incrementa
forma
dram
ática
utilización
procesador
colapsa
numerosas
formas
abordar
problema
algoritmo
conjunto
trabajo
frecuencia
fallos
página
incorporan
forma
implícita
control
carga
proce-
sos
cuyo
conjunto
residente
suficientemente
permite
ejecutar
forma
propor-
cionar
tamaño
conjunto
residente
necesario
proceso
activo
pol
ítica
automática
dinámicamente
determina
número
programas
activos
estrategia
sugerida
Denning
DENN80b
conoce
criterio
ajus-
ta
nivel
multiprogramación
forma
tiempo
fallos
ágina
iguala
tiempo
necesario
procesar
fallo
ágina
estudios
rendimiento
indican
376
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
376que
punto
utilización
procesador
máxima
política
presenta
efecto
similar
propuesta
LERO76
criterio
50%
intenta
mantener
utilización
dispositivo
paginación
50%
estudios
rendimiento
in-
dican
punto
utilización
procesador
máxima
alternativa
adaptar
algoritmo
reemplazo
páginas
reloj
descrito
anteriormente
Figura
8.16
CARR84
describe
técnica
usando
ámbito
global
implica
monitorizar
tasa
puntero
recorre
buffer
circular
marcos
tasa
nivel
umbral
determinado
indica
circunstancias
siguientes
ocurriendo
fallos
página
implican
peticiones
avanzar
puntero
solicitud
número
marcos
promedio
recorren
puntero
peque
ño
indica
páginas
residentes
referencia
real-
mente
reemplazables
casos
grado
multiprogramaci
ón
incrementarse
seguridad
tasa
recorrido
circular
puntero
supera
umbral
máximo
indica
tasa
fallos
página
alta
dificultad
encontrar
páginas
reemplazables
implica
grado
multiprogramación
alto
Suspensión
procesos
reducir
grado
multiprogramació
má
procesos
actualmente
residentes
suspenderse
enviarlos
swap
CARR84
proporciona
posibilidades
Procesos
baja
prioridad
implementa
decisión
política
activación
relacionada
cuestiones
rendimiento
Procesos
provoca
fallos
razón
probabilidad
ta-
rea
causa
fallos
conjunto
trabajo
residente
rendimiento
sufrir
me-
dicha
tarea
suspende
Adicionalmente
elecci
ón
trae
ventaja
asociada
bloquea
proceso
ía
punto
bloquearse
elimina
evita
sobrecarga
reemplazo
páginas
operación
S.
Memoria
virtual
377
Grado
multiprogramación
Utilización
procesador
Figura
8.21
Efectos
multiprogramación
08-Capitulo
12/5/05
16:23
Página
377•
Proceso
activado
tiempo
proceso
menor
probabilidad
conjunto
trabajo
residente
Proceso
conjunto
residente
menor
tamaño
requerirá
menor
esfuerzo
cargarse
penaliza
programas
proximidad
refe-
rencias
fuerte
Proceso
proporciona
número
marcos
libres
memoria
sobrecarga
futuras
desactivaciones
probables
corto
plazo
Proceso
ventana
ejecución
restante
mayoría
esquemas
activa-
ción
procesos
proceso
ólo
ejecutarse
determinada
rodaja
tiempo
recibir
interrupción
situarse
lista
Listos
estrategia
aproxi-
ma
disciplina
activación
proceso
menor
tiempo
ejecuci
ón
áreas
diseño
sistemas
operativos
selección
política
apropiada
cuesti
ón
considerar
depende
factores
dise
ño
sistema
operativo
características
programas
ejecutarán
8.3
GESTIÓN
MEMORIA
UNIX
SOLARIS
UNIX
pretende
sistema
independiente
áquina
esquema
gestión
memoria
variará
sistema
primeras
versiones
UNIX
utilizaba
particionamiento
variable
esquema
memoria
virtual
implantaciones
actuales
UNIX
Solaris
uti-
lizan
memoria
virtual
paginada
SVR4
Solaris
esquemas
gesti
ón
memoria
separados
sistema
pagi-
nación
proporciona
funcionalidades
memoria
virtual
asignar
marcos
ágina
memoria
principal
procesos
tambi
én
asignar
marcos
página
buffers
bloques
disco
esquema
gestión
memoria
efectivo
procesos
usuario
disco
esquema
memoria
virtual
paginada
apropiado
ges-
tionar
asignación
memoria
núcleo
cuestiones
utiliza
asignador
memoria
núcleo
examinar
mecanismos
orden
SISTEMA
PAGINACIÓN
Estructuras
datos
memoria
virtual
paginada
UNIX
utiliza
estructuras
datos
pequeñas
diferencias
independientes
áquina
Figura
8.22
Tabla
8.5
Tabla
páginas
Habitualmente
tabla
páginas
proceso
entrada
página
memoria
virtual
proceso
Descriptor
bloques
disco
Asociado
página
proceso
entrada
tabla
indica
copia
disco
página
virtual
Tabla
datos
marcos
página
Describe
marco
memoria
real
indexa
número
marco
algoritmo
reemplazo
tabla
Tabla
utilización
swap
tabla
swap
dispositivo
inter-
cambio
entrada
página
dispositivo
mayoría
campos
definidos
Tabla
8.5
proporcionan
descripci
ón
requieren
explicaci
ón
adicional
campo
Edad
entrada
tabla
ági-
378
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
378nas
indicador
tiempo
programa
referencia
marco
número
bits
frecuencia
actualización
campo
dependientes
im-
plementación
universal
campo
UNIX
pol
íticas
reemplazo
páginas
campo
Tipo
Almacenamiento
descriptor
bloques
disco
necesita
si-
guiente
razón
fichero
ejecutable
crear
proceso
ólo
programa
datos
fichero
cargan
memoria
real
ás
dando
fallos
página
partes
programa
datos
án
cargando
momento
carga
inicial
crean
páginas
memoria
virtual
asocia
posi-
ciones
dispositivos
utiliza
momento
sistema
operativo
indica
necesario
limpiar
posiciones
marco
página
carga
bloque
programa
datos
Reemplazo
páginas
tabla
marcos
página
utiliza
reemplazo
páginas
punteros
crear
listas
tabla
marcos
disponibles
enla-
zan
lista
marcos
libres
disponibles
traer
áginas
número
marcos
dispo-
nibles
cae
determinado
nivel
núcleo
quitará
marcos
compensar
algoritmo
reemplazo
páginas
usado
SVR4
refinamiento
algoritmo
reloj
Fi-
gura
8.16
conocido
algoritmo
reloj
manecillas
Figura
8.23
algoritmo
utiliza
bit
referencia
entrada
tabla
áginas
página
memoria
suscepti-
ble
selección
bloqueada
reemplazo
bit
pone
ágina
trae
pone
referencia
ágina
lectura
escritura
manecillas
algoritmo
reloj
manecilla
delantera
recorre
páginas
lista
páginas
seleccionables
pone
bit
referencia
instante
manecilla
Memoria
virtual
379
Entrada
tabla
páginas
Descriptor
bloques
disco
Entrada
tabla
marcos
página
Entrada
tabla
swap
Contador
referencias
Número
unidad
almacenamiento
página
página
Contador
referencias
Dispositivo
lógico
Número
bloque
Puntero
datos
MP
Número
dispositivo
swap
Número
bloque
dispositivo
Tipo
almacenamiento
Número
marco
página
Edad
Prote-
gidaValidaReferen-
ciada
Modi-
ficada
Copy
on
write
Figura
8.22
Formatos
gestión
memoria
UNIX
SVR4
08-Capitulo
12/5/05
16:23
Página
379trasera
recorre
lista
verifica
bit
referencia
bit
est
puesto
referencia
página
momento
pasó
manecilla
delantera
mar-
cos
saltan
bit
referencia
dicha
ágina
intervalo
tiempo
visita
manecillas
áginas
colocan
lista
páginas
expulsables
parámetros
determinan
operación
algoritmo
tasa
recorrido
tasa
manecillas
recorren
lista
páginas
pági-
nas
separación
manecillas
espacio
manecillas
delantera
trasera
pará
metros
vienen
fijados
valores
omisi
momento
arranque
de-
pendiendo
cantidad
memoria
fí
sica
pará
metro
tasa
recorrido
modificarse
responder
cambios
condiciones
sistema
pará
metro
variar
linealmen-
valores
recorrido
lento
slowscan
recorrido
rá
pido
fastscan
fijados
momen-
to
configuració
dependiendo
cantidad
memoria
libre
variando
valores
lotsfree
minfree
palabras
medida
memoria
libre
reduce
manecillas
re-
loj
mueven
má
rá
pidamente
liberar
má
pá
ginas
pará
metro
separació
maneci-
llas
indicado
espacio
manecilla
delantera
trasera
tasa
recorrido
indica
ventana
oportunidad
gina
descartable
falta
Asignador
memoria
núcleo
núcleo
ejecuci
ón
genera
destruye
pe-
queñas
tablas
buffers
frecuencia
requiere
reserva
memoria
dinámica
AHA96
muestra
ejemplos
encaminamiento
traducción
ruta
reservar
buffer
copiar
ruta
espacio
usuario
380
Sistemas
operativos
Aspectos
internos
principios
diseño
Comienzo
lista
páginas
lista
páginas
Separaciónentrem
anecillas
Manecilla
delantera
Manecilla
trasera
Figura
8.23
Algoritmo
reemplazo
paginas
reloj
manecillas
08-Capitulo
12/5/05
16:23
Página
380Memoria
virtual
381
N.
T.
término
copy
on
write
dejado
inglés
puesto
forma
ás
habitual
denotarlo
lite-
ratura
castellano
abla
8.5
Parámetros
gestión
memoria
UNIX
SVR4
Entrada
tabla
páginas
Número
marco
página
Indica
marco
memoria
real
Edad
Indica
tiempo
página
memoria
haberse
referenciado
longitud
contenidos
campo
dependen
procesador
Copy
on
write8
Puesto
proceso
comparte
página
procesos
escribe
página
copia
aparte
procesos
comparten
página
original
funcionalidad
permite
demorar
operación
copia
has-
ta
completamente
necesaria
evitar
casos
llega
serlo
Modificada
Indica
página
modificado
Referenciada
Indica
referencia
página
bit
pone
página
carga
reiniciar
periódicamente
algoritmo
reemplazo
páginas
Válida
Indica
página
memoria
principal
Protegida
Indica
permite
operación
escritura
Descriptor
bloques
disco
Número
dispositivo
swap
Número
dispositivo
lógico
almacenamiento
secundario
almacena
página
correspon-
diente
permite
existan
dispositivo
utilizados
swap
Número
bloque
dispositivo
Posición
bloque
página
dispositivo
swap
Tipo
almacenamiento
dispositivo
almacenamiento
unidad
swap
fichero
ejecutable
úl-
timo
caso
indicación
denota
memoria
virtual
asignada
borrarse
Entrada
tabla
marcos
página
página
Indica
marco
disponible
asociado
página
caso
especifica
página
dispositivo
swap
fichero
ejecutable
opera-
ción
S.
Contador
referencias
Número
procesos
referencia
página
Dispositivo
lógico
Dispositivo
lógico
contiene
copia
página
Número
bloque
Posición
bloque
copia
página
dispositivo
lógico
Punteros
datos
MP
Puntero
datos
apuntan
entradas
tabla
marcos
página
puntero
construir
lista
páginas
libres
lista
hash
páginas
Entrada
tabla
swap
Contador
referencias
Número
entradas
tabla
página
apunta
página
dispositivo
swap
Número
unidad
almacenamiento
página
Identificador
página
unidad
almacenamiento
08-Capitulo
12/5/05
16:23
Página
381•
rutina
allocb
reserva
buffer
flujos
tamaño
arbitrario
implementaciones
UNIX
reservan
estructuras
zombie
recoger
sa-
lida
información
utilización
recursos
procesos
finalizados
SVR4
Solaris
núcleo
reserva
objetos
estructuras
proc
v-nodos
bloques
descripción
fichero
forma
din
ámica
demanda
mayoría
bloques
significativamente
pequeños
tamaño
típico
pá-
gina
máquina
mecanismo
paginaci
ón
deficiente
hora
reserva
memoria
dinámica
núcleo
caso
SVR4
utiliza
modificación
sistema
buddy
descrito
Sección
7.2
sistemas
buddy
coste
reservar
liberar
bloque
memoria
compara-
do
polí
ticas
ajuste
ajuste
KNUT97
forma
caso
ges-
tió
memoria
nú
cleo
operaciones
reserva
liberació
má
rá
pi-
do
desventaja
sistemas
buddy
tiempo
necesario
fragmentar
reagrupar
bloques
Barkley
Lee
AT&T
propusieron
variación
conocida
sistema
buddy
perezoso
BARK89
técnica
adoptada
SVR4
autores
observaron
UNIX
muestra
comportamiento
estable
solicitudes
memoria
úcleo
cantidad
peticiones
bloques
determinado
tamaño
varía
ligeramente
tiempo
bloque
tamaño
libera
inmediatamente
reagrupa
vecino
bloque
ta-
maño
2i+1
próxima
úcleo
solicite
bloque
tamaño
2i
implicará
necesidad
di-
vidir
bloque
tamaño
evitar
agrupaci
ón
innecesaria
posterior
di-
visión
sistema
buddy
perezoso
pospone
reagrupación
momento
parezca
resulta
necesaria
momento
intenta
reagrupar
número
bloques
posibles
sistema
buddy
perezoso
siguientes
parámetros
número
actual
bloques
tamaño
2i
Ai
número
actual
bloques
tamaño
2i
encuentran
reservados
ocupados
Gi
número
actual
bloques
tamaño
2i
libres
globalmente
bloques
seleccionar
reagrupados
vecino
bloques
libre
bloques
agrupar
bloque
libre
global
tamaño
i+1
bloques
libres
huecos
sistema
buddy
estándar
considerar-
libres
globales
Li
número
actual
bloques
tamaño
2i
encuentran
libres
localmente
bloques
encuentran
seleccionables
grabaci
ón
vecino
bloque
libre
bloques
reagrupan
lugar
bloques
libres
locales
mantienen
espera
petici
ón
futura
bloque
tamaño
relación
mantiene
Gi
Li
general
sistema
buddy
perezoso
intenta
mantener
caudal
bloques
libres
locales
úni-
camente
solicita
reagrupación
número
bloques
libres
locales
supera
determinado
ímite
bloques
libres
locales
posibilidad
falten
bloques
libres
nivel
mayoría
tiempo
libera
bloque
reagrupaci
ón
realiza
382
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
382forma
minimizan
costes
gesti
ón
operaciones
reservar
bloque
distinción
bloques
libres
locales
globales
forma
minimi-
za
gestión
criterio
utiliza
reagrupación
número
bloques
libres
locales
tama-
ño
determinado
exceder
número
bloques
reservados
tama
ño
ejemplo
Li
Ai
guía
razonable
evitar
crecimiento
bloques
libres
locales
experimentos
llevados
cabo
BARK89
confirman
resultados
esquema
proporciona
mejoras
considerables
implementar
esquema
autores
definen
variable
demora
forma
Ai
Li
2Li
Gi
Figura
8.24
muestra
algoritmo
Memoria
virtual
383
Figura
8.24
Algoritmo
sistema
buddy
perezoso
Valor
inicial
Di
operación
valor
actualiza
operación
solicitud
reservar
bloque
bloques
libres
selecciona
reserva
bloque
seleccionado
libre
forma
local
Di
Di
Di
Di
caso
toman
bloques
dividiendo
bloque
operaci
ón
recursiva
reserva
marca
libre
forma
local
Di
permanece
cambios
cambiar
tamaños
bloque
debi-
do
llamada
recursiva
II
operación
liberación
bloque
Caso
Di
marca
libre
forma
local
libera
localmente
Di
Di
Caso
Di
marca
libre
forma
global
libera
globalmente
reagrupación
Caso
Di
marca
libre
forma
global
libera
globalmente
reagrupación
selecciona
bloque
libre
local
tamaño
2i
libera
forma
global
reagrupa-
ción
Di
08-Capitulo
12/5/05
16:23
Página
3838.4
GESTIÓN
MEMORIA
LINUX
Linux
comparte
características
esquemas
gestión
memoria
im-
plementaciones
UNIX
incorpora
caracter
ísticas
esquema
gestión
memoria
Linux
complejo
DUBE98
secció
ligera
visió
general
principales
aspectos
gestió
memoria
Linux
memoria
virtual
procesos
asignació
memoria
núcleo
MEMORIA
VIRTUAL
LINUX
Direccionamiento
memoria
virtual
Linux
estructura
tablas
áginas
niveles
consistente
siguientes
tipos
tablas
tabla
particular
tama
ño
página
Directorio
páginas
proceso
activo
directorio
áginas
único
ta-
maño
página
entrada
directorio
áginas
apunta
página
direc-
torio
intermedio
páginas
directorio
páginas
residir
memoria
principal
proceso
activo
Directorio
intermedio
páginas
directorio
intermedio
páginas
expande
múlti-
ples
páginas
entrada
directorio
intermedio
áginas
apunta
página
contie-
ne
tabla
páginas
Tabla
páginas
tabla
páginas
expandirse
múltiples
páginas
entrada
tabla
páginas
referencia
página
virtual
proceso
utilizar
estructura
tabla
ginas
niveles
direcció
virtual
Linux
có
mo
consistente
campos
Figura
8.25
campo
má
izquierda
má
significativo
utiliza
ndice
directorio
pá
ginas
campo
sirve
n-
directorio
intermedio
pá
ginas
tercer
campo
utiliza
indexar
tabla
pá
ginas
cuarto
campo
proporciona
desplazamiento
pá
gina
memo-
ria
seleccionada
estructura
tabla
páginas
Linux
independiente
plataforma
dise
ñó
acomodarse
procesador
Alpha
64
bits
proporciona
soporte
hardware
niveles
páginas
direcciones
64
bits
utilización
únicamente
niveles
áginas
arqui-
tectura
Alpha
resultaría
tablas
páginas
directorios
tamaño
arquitectura
Pentium
x86
32
bits
sistema
hardware
paginación
niveles
software
Linux
acomoda
esquema
niveles
definiendo
tama
ño
directorio
intermedio
páginas
resaltar
referencias
nivel
extra
indirecci
ón
eliminan
optimización
realizada
momento
compilaci
ón
ejecución
sobrecarga
rendimiento
utilizaci
ón
diseño
genérico
niveles
plata-
formas
soportan
niveles
Reserva
páginas
mejorar
eficiencia
lectura
escritura
páginas
memoria
principal
Linux
define
mecanismo
manejar
bloques
áginas
contiguas
proyectarán
bloques
marcos
página
contiguos
utiliza
sistema
buddy
núcleo
mantiene
lista
marcos
página
contiguos
grupos
tama
ño
fijo
grupo
consistir
16
32
marcos
páginas
áginas
asig-
nan
liberan
memoria
principal
grupos
disponibles
dividen
juntan
utilizando
al-
goritmo
sistema
buddy
384
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
384Algoritmo
reemplazo
páginas
algoritmo
reemplazo
áginas
Linux
basaba
algoritmo
reloj
descrito
Secci
ón
8.2
véase
Figura
8.16
algoritmo
reloj
sen-
cillo
asocia
bit
usado
bit
modificado
páginas
memoria
prin-
cipal
esquema
Linux
usado
reemplaza
variable
bits
accede
página
variable
incrementa
plano
Linux
recorre
peri
ódicamente
lista
completa
páginas
decrementa
variable
edad
ágina
medida
rotando
memoria
principal
ágina
edad
ágina
vieja
referencia
alg
ún
tiempo
candidato
reemplazo
Cuan-
do
valor
edad
alto
frecuencia
accedido
ágina
recientemente
menor
posibilidad
elegirse
reemplazo
forma
algoritmo
Linux
variante
política
LRU
RESERVA
MEMORIA
NÚCLEO
gestión
memoria
núcleo
realiza
base
marcos
ágina
memoria
princi-
pa
l.
función
básica
asignar
liberar
marcos
usos
posibles
propietarios
marco
incluyen
procesos
espacio
usuario
ejemplo
marco
memoria
virtual
proceso
actualmente
residiendo
memoria
real
datos
úcleo
reservados
dinámicamente
código
estático
núcleo
cache
páginas
fundamentos
reserva
memoria
úcleo
Linux
mecanismos
re-
serva
pá
ginas
usados
gesti
memoria
virtual
usuario
caso
esquema
memoria
virtual
utiliza
algoritmo
buddy
forma
memoria
nú
cleo
Memoria
virtual
385
cache
páginas
propiedades
similares
buffer
disco
descrito
cap
ítulo
cache
disco
verá
Capítulo
11
pospone
discusi
ón
cache
páginas
Linux
Cap
ítulo
11
Directorio
global
Registro
cr3
Directorio
páginas
Directorio
intermedio
páginas
Tabla
páginas
Marco
página
memoria
física
Dirección
virtual
Directorio
intermedio
Tabla
páginas
Desplazamiento
/H11001
/H11001
/H11001
/H11001
Figura
8.25
Traducción
direcciones
esquema
memoria
virtual
Linux
08-Capitulo
12/5/05
16:23
Página
385se
reservar
liberar
unidades
pá
ginas
tamañ
nimo
memoria
reservar
forma
gina
reserva
pá
ginas
únicamente
se-
rí
insuficiente
nú
cleo
requiere
pequeñ
fragmentos
utilizará
corto
periodo
tiempo
tama
ajustarse
pequeñ
tama-
Linux
utiliza
esquema
conocido
asignación
láminas
slab
allocation
BONW94
gina
reservada
quina
Pentium
x86
tama
pá
gina
Kbytes
fragmentos
gina
asignar
tama
32
64
128
252
508
2040
4080
bytes
asignación
láminas
relativamente
compleja
examinar
detalle
aqu
descripción
encontrar
AHA96
esencia
Linux
mantiene
conjunto
lis-
tas
enlazadas
tamaño
fragmento
fragmentos
dividir
agregar
similar
indicada
algoritmo
buddy
mover
di-
ferentes
listas
forma
correspondiente
8.5
GESTIÓN
MEMORIA
WINDOWS
gestor
memoria
virtual
Windows
controla
forma
reserva
memoria
realiza
paginación
gestor
memoria
diseñado
funcionar
variada
gama
plataformas
utilizar
tama
ños
páginas
Kbytes
64
Kbytes
plataformas
Intel
PowerPC
MIPS
4096
bytes
ágina
plataformas
DEC
Alpha
8192
bytes
página
MAPA
DIRECCIONES
VIRTUALES
WINDOWS
proceso
usuario
Windows
espacio
direcciones
independiente
32
bits
permitiendo
Gbytes
memoria
proceso
omisi
ón
memoria
reservada
sistema
operativo
forma
realidad
usuario
dispone
Gbytes
es-
pacio
virtual
direcciones
disponibles
procesos
comparten
Gbytes
es-
pacio
sistema
opción
permite
espacio
direcciones
crezca
Gby-
tes
dejando
espacio
sistema
únicamente
Gbytes
documentaci
ón
Windows
indica
característica
incluyó
soporte
aplicaciones
requieren
intensi-
vo
cantidades
memoria
servidores
memorias
gigabytes
espacio
direcciones
mejorar
drásticamente
rendimiento
aplicaciones
so-
porte
decisión
data
mining
Figura
8.26
muestra
espacio
direcciones
virtuales
efecto
ve
usuario
Consis-
regiones
0x00000000
0x0000FFFF
Reservada
ayudar
programadores
capturar
asignacio-
nes
punteros
nulos
0x00010000
0x7FFEFFFF
Espacio
direcciones
disponible
usuario
espacio
dividido
páginas
cargar
memoria
principal
0x7FFF0000
0x7FFFFFFF
gina
guarda
accesible
usuario
gina
sistema
operativo
resulte
má
fá
cil
verificar
referencias
punteros
rango
0x80000000
0xFFFFFFFF
Espacio
direcciones
sistema
área
Gbytes
utili-
za
Ejecutivo
Windows
micronúcleo
manejadores
dispositivos
386
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
386PAGINACIÓN
WINDOWS
crea
proceso
principio
utilizar
espacio
usuario
Gbytes
me-
128
Kbytes
espacio
dividido
páginas
tamaño
fijo
cualquiera
cua-
cargar
memoria
principal
pr
áctica
página
encontrar
efectos
gestión
presentes
Disponible
Páginas
actualmente
usadas
proceso
Reservada
Conjunto
páginas
contiguas
gestor
memoria
virtual
separa
proceso
cuentan
cuota
memoria
usada
proceso
proceso
necesite
escribir
memoria
memoria
reservada
asigna
proceso
Asignada
páginas
gestor
memoria
virtual
reservado
espacio
fichero
paginación
ejemplo
fichero
disco
escribirían
páginas
eliminen
memoria
principal
distinción
memoria
reservada
asignada
útil
minimiza
cantidad
espacio
disco
guardarse
proceso
particular
manteniendo
espacio
libre
disco
procesos
permite
hilo
proceso
declare
petici
ón
cantidad
memoria
proporcionarse
rápidamente
necesita
Memoria
virtual
387
0Región
64
Kbytes
asignaciones
punteros
nulos
accesible
Región
64
Kbytes
asignaciones
punteros
erróneos
accesible
Región
sistema
operativo
Gbytes
espacio
direcciones
usuario
Gbytes
reservado
utilizable
0xFFFFFFFF
Figura
8.26
Espacio
direcciones
virtuales
habitual
Windows
08-Capitulo
12/5/05
16:23
Página
387El
esquema
gestión
conjunto
residente
utiliza
Windows
asignaci
ón
variable
ámbito
local
véase
Tabla
8.4
activa
proceso
asigna
número
marcos
página
memoria
principal
conjunto
trabajo
proceso
referencia
página
memoria
áginas
residentes
proce-
so
expulsa
trayéndose
página
conjuntos
trabajo
procesos
activos
ajustan
usando
siguientes
condiciones
generales
memoria
principal
disponible
gestor
memoria
virtual
permite
con-
juntos
residentes
procesos
activos
crezcan
ocurre
fallo
ágina
trae
página
memoria
expulsar
ágina
antigua
incremente
conjunto
residente
proceso
página
memoria
empieza
escasear
gestor
memoria
virtual
recupera
memoria
sis-
tema
moviendo
áginas
utilizado
ás
tiempo
procesos
swap
reduciendo
tamaño
conjuntos
residentes
8.6
RESUMEN
forma
eficiente
procesador
funciones
aconsejable
mantener
número
procesos
posibles
memoria
principal
deseable
liberar
progra-
mador
restricciones
tamaño
desarrollo
programas
vía
cabo
ambas
recomendaciones
memoria
virtual
me-
moria
virtual
referencias
direcciones
ógicas
traducen
tiempo
ejecuci
ón
direcciones
reales
permite
proceso
ubicar
memoria
principal
dicha
ubicaci
ón
cambie
tiempo
memoria
virtual
tambi
én
permite
proceso
dividida
fragmentos
fragmentos
porqu
ubicados
forma
contigua
memoria
principal
ejecuci
ón
realidad
necesita
fragmentos
proceso
encuentren
memoria
principal
dicha
ejecuci
ón
estrategias
básicas
proporcionar
memoria
virtual
paginaci
ón
segmentación
paginación
proceso
divide
áginas
tamaño
fijo
relativamente
peque-
ñas
segmentación
proporciona
posibilidad
definir
fragmentos
tama
ño
variable
combinar
segmentación
paginación
único
esquema
gesti
ón
memoria
esquema
gestión
memoria
virtual
requiere
soporte
hardware
software
soporte
hardware
proporciona
procesador
soporte
incluye
traducci
ón
dinámica
direcciones
virtuales
direcciones
físicas
generación
interrupciones
referencia
á-
gina
segmento
memoria
principal
Dichas
interrupciones
disparan
soft-
ware
gestión
memoria
sistema
operativo
capítulo
tratado
diversas
consideraciones
diseño
relativas
soporte
sistema
operativo
Política
recuperación
páginas
traer
demanda
pol
ítica
paginación
adelantada
agrupa
carga
áginas
Política
ubicación
sistema
segmentación
pura
segmento
trae
memoria
ajustarse
espacio
memoria
disponible
Política
reemplazo
memoria
llena
decidir
qu
ágina
páginas
reemplazarse
traer
Gestión
conjunto
reciente
sistema
operativo
decidir
cuá
nta
memoria
asigna
proceso
particular
proceso
trae
memoria
me-
388
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
388diante
asignació
tica
realizada
momento
crear
proceso
cambiar
diná
micamente
Política
limpieza
páginas
proceso
modificado
escribir
momento
reemplazo
articular
política
limpieza
adelantada
agru-
pa
actividad
escritura
páginas
Control
carga
control
carga
responsable
determinar
número
procesos
residir
memoria
principal
instante
determinado
8.7
LECTURA
RECOMENDADA
PÁGINAS
WEB
previsible
memoria
virtual
tratada
mayorí
libros
sistemas
operativos
MILE92
proporciona
resumen
reas
investigació
n.
CARR84
proporciona
excelente
examen
profundidad
cuestiones
rendimiento
art
culo
clá
si-
co
DENN70
aú
lectura
recomendada
DOWD93
proporciona
an
lisis
rendi-
miento
profundo
organismos
reemplazo
ginas
JACO98a
revisi
aspectos
diseñ
memoria
virtual
incluye
explicaci
tablas
ginas
invertidas
JACO98b
examina
organizació
hardware
memoria
virtual
mi-
croprocesadores
lectura
sobria
IBM86
forma
detallada
herramientas
opciones
dis-
ponibles
administración
optimización
políticas
memoria
virtual
siste-
MVS
documento
ilustra
perfectamente
complejidad
problema
AHA96
mejores
tratamientos
esquemas
gestión
memoria
utili-
zados
tipos
sistemas
UNIX
GORM04
tratamiento
profundo
gesti
ón
memoria
Linux
CARR84
Carr
R.
Virtual
Memory
Management
Ann
Arbor
UMI
Research
Press
1984
DENN70
Denning
Virtual
Memory
Computing
Surveys
Septiembre
1970
DOWD93
Dowdy
L.
Lowery
C.
.S.
to
Operating
Systems
Upper
Saddle
River
NJ
Prentice
Hall
1993
GORM04
Gorman
M.
Understanding
the
Linux
Virtual
Memory
Management
Upper
Saddle
River
NJ
Prentice
Hall
2004
IBM86
IBM
Nacional
Technical
Support
Large
Systems
Multiple
Virtual
Storage
MVS
Virtual
Storage
Tuning
Cookbook
Dallas
Systems
CenterTechnical
Bulletin
G320-0597
Junio
1986
JACO98a
Jaboc
B.
Mudge
Virtual
Memory
Issues
of
Implementation
Computer
Junio
1998
JACO98b
Jaboc
B.
Mudge
Virtual
Memory
in
Contemprany
Microprocessors
IEEE
Micro
Agos-
to
1998
MILE92
Milenkovic
M.
Operating
Systems
Concepts
and
Design
New
Cork
McGraw-Hill
1992
VAHA96Vahalia
U.
UNIX
Internals
The
New
Frontiers
Upper
Saddle
River
NJ
Prentice
Hall
1996
Páginas
Web
recomendadas
The
Memory
Management
Reference
fuente
documentos
enlaces
aspectos
gestión
memoria
Memoria
virtual
389
08-Capitulo
12/5/05
16:23
Página
3898.8
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
asignación
láminas
memoria
real
proximidad
referencia
conjunto
trabajo
memoria
virtual
segmentación
conjunto
reciente
página
segmento
fallo
página
paginación
tabla
páginas
fragmentación
externa
paginación
adelantada
tabla
segmentos
fragmentación
interna
paginación
demanda
tabla
hash
gestión
conjunto
residente
política
recuperación
TLB
hashing
política
reemplazo
traducción
asociativa
marco
política
ubicación
trasiego
CUESTIONES
REPASO
8.1
diferencia
paginación
sencilla
paginación
memoria
virtual
8.2
Explique
trasiego
thrashing
8.3
principio
proximidad
referencia
crucial
memoria
virtual
8.4
elementos
encuentran
típicamente
entrada
tabla
páginas
Defina
breve-
mente
elemento
8.5
propósito
TLB
8.6
Defina
brevemente
alternativas
política
recuperación
8.7
diferencia
gestión
conjunto
residente
política
reemplazo
páginas
8.8
relación
algoritmos
reemplazo
páginas
FIFO
reloj
8.9
cometido
buffering
páginas
8.10
combinar
política
reemplazo
global
política
asigna-
ción
fija
8.11
diferencia
conjunto
reciente
conjunto
trabajo
8.12
diferencia
limpieza
demanda
limpieza
adelantada
PROBLEMAS
8.1
Suponga
tabla
áginas
proceso
actualmente
ejecuci
ón
To-
números
formato
decimal
encuentran
numerados
comenzando
cero
direcciones
direcciones
memoria
nivel
byte
tama
ño
página
1024
bytes
390
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
390Número
Bit
Bit
Bit
Número
página
virtual
valida
referenciada
modificada
marco
página
01104
11117
2000
31002
4000
51010
Describa
exactamente
mo
té
rminos
reales
generarí
direcció
virtual
direcció
memoria
fí
sica
traducció
realizada
CPU
dirección
física
corresponderá
siguientes
direcciones
virtuales
falta
trate
fallo
página
produce
1052
ii
2221
iii
5499
8.2
Considere
sistema
memoria
virtual
paginada
direcciones
virtuales
32
bits
páginas
Kbyte
entrada
tabla
áginas
requiere
32
bits
desea
limitar
tamaño
tablas
páginas
única
página
niveles
tablas
áginas
necesitan
tamaño
tabla
páginas
nivel
Sugerencia
tama-
ños
tabla
página
menor
tabla
pá
ginas
menor
alta
má
baja
jerarquí
tablas
pá
ginas
Cuá
estrategias
implican
menor
consumo
pá
ginas
8.3
Cuá
nto
espacio
memoria
necesita
tablas
pá
ginas
usuario
Figura
8.4
Asumiendo
implementar
tabla
páginas
invertida
tipo
hash
esquema
direccionamiento
mostrado
Figura
8.4
función
hash
proyecta
número
página
20
bits
valor
hash
bits
entrada
tabla
contiene
úmero
página
número
marco
puntero
cadena
tabla
páginas
dispone
entradas
adicionales
coli-
siones
entrada
hash
espacio
memoria
estaría
ocupando
tabla
páginas
invertida
8.4
proceso
marcos
reservados
siguientes
úmeros
formato
decimal
numeraciones
comienzan
tabla
muestra
instante
tiempo
cargó
página
marco
instante
tiem-
po
acceso
página
número
página
virtual
bits
referenciada
modificada
marcos
página
instantes
tiempo
expresados
ticks
reloj
comienzo
proceso
Memoria
virtual
391
08-Capitulo
12/5/05
16:23
Página
391Número
Marco
Instante
Instante
Bit
Bit
Mpágina
virtual
página
carga
referencia
60
161
130
160
26
162
20
163
produce
fallo
ágina
página
virtual
instante
164
marco
página
reemplazará
contenido
siguientes
políticas
gestión
memoria
Explique
casos
FIFO
LRU
Reloj
Óptimo
usando
cadena
referencias
Tomando
memoria
mencionado
justo
instante
produce
fallo
página
teniendo
cadena
referencias
páginas
virtuales
fallos
página
ocurrirían
usase
política
conjunto
trabajo
LRU
tomando
ventana
tamaño
lugar
asignación
fija
Indique
claramen-
produce
fallo
ágina
8.5
proceso
referencia
páginas
orden
Asuma
algoritmo
reemplazo
FIFO
encuentre
número
transferencias
páginas
secuencia
referencias
comienza
memoria
princi-
pa
vacía
limitación
marcos
página
Repita
caso
marcos
página
8.6
proceso
contiene
áginas
virtuales
disco
asigna
forma
fija
mar-
cos
página
memoria
principal
traza
áginas
5,1
Muestre
sucesivas
páginas
residentes
marcos
utilizando
política
reemplazo
LRU
Calcule
índice
acierto
memoria
principal
Asúmase
marcos
inicialmente
vacíos
Repita
apartado
política
reemplazo
FIFO
Compare
índices
acierto
comente
efectividad
utilizar
FIFO
aproximación
LRU
referente
traza
particular
8.7
sistemas
AX
tablas
ágina
usuarios
colocan
direcciones
virtua-
espacio
sistema
ventaja
tablas
página
usuarios
memoria
virtual
lugar
memoria
principal
desventajas
392
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
3928.8
Supóngase
instrucciones
programa
for(i=1;i<=n;i++
a[i]=b[i]+c[i
ejecutan
memoria
tama
pá
gina
1000
palabras
1000
Usando
má
quina
conjunto
completo
instrucciones
registro-registro
utiliza
registros
ndice
escriba
programa
hipoté
tico
implemente
siguientes
instrucciones
Posteriormente
muestre
secuencia
referencias
pá
ginas
ejecució
n.
8.9
sistemas
IBM/370
utilizan
estructura
memoria
niveles
denominan
niveles
segmentos
áginas
segmentaci
ón
carece
características
descritas
anteriormente
capítulo
arqui-
tectura
básica
370
tamaño
página
Kbytes
Kbytes
tama
ño
segmento
fija
64
Kbytes
Mbyte
arquitecturas
370
XA
370
tamaño
página
Kbytes
tamaño
segmentos
Mbyte
beneficios
segmentación
encuentran
disponibles
esquema
beneficio
modelo
segmentación
370
8.10
Asumiendo
tama
ño
página
Kbytes
entrada
tabla
áginas
requiere
bytes
niveles
tablas
páginas
necesitarán
proyectar
espacio
di-
recciones
64
bits
tabla
páginas
principal
entra
única
página
8.11
Considere
sistema
gesti
memoria
basada
ginas
utiliza
nico
nivel
pá
ginas
Asumiendo
tabla
pá
ginas
necesaria
memoria
referencia
memoria
consume
200
ns
tardar
referencia
página
memoria
añadimos
MMU
añade
sobrecarga
20
ns
acierto
asume
85%
referencias
memoria
aciertos
TLB
MMU
tiempo
efectivo
acceso
memoria
Explíquese
tasa
aciertos
TLB
afecta
tiempo
acceso
memoria
efectivo
8.12
Considere
cadena
referencias
áginas
proceso
conjunto
trabajo
marcos
inicialmente
vacíos
cadena
referencias
páginas
longitud
números
páginas
algoritmo
reemplazo
páginas
límite
inferior
número
fallos
página
límite
superior
número
fallos
página
8.13
explicaciones
algoritmos
reemplazo
áginas
autor
realiza
analogía
quita-nieves
movi
éndose
pista
circular
nieve
cae
forma
uniforme
pista
único
quita-nieves
mueve
velocidad
constante
recorrido
nieve
quita-nieves
pista
desaparece
sistema
Ac
ál
algoritmo
reemplazo
páginas
presentados
Secci
ón
8.2
asociar
analogía
sugiere
analogía
comportamiento
algoritmo
reemplazo
pá-
ginas
cuestión
Memoria
virtual
393
08-Capitulo
12/5/05
16:23
Página
3938.14
arquitectura
S/370
clave
almacenamiento
campo
control
asociado
marco
página
memoria
real
bits
clave
importantes
reemplazo
páginas
bit
referencia
bit
cambio
bit
referencia
pone
accedido
direcci
ón
marco
lectura
escri-
tura
pone
carga
ágina
marco
bit
cambio
pone
realiza
operación
escritura
posición
marco
Sugiera
estrategia
determinar
marcos
página
utilizado
tiempo
usando
únicamente
bit
referencia
8.15
Considere
secuencia
referencias
áginas
elemento
secuencia
representa
número
página
refiere
tamaño
conjunto
trabajo
referencia
k-ésima
define
probabilidad
página
ausente
F(t
D)=1
ocurre
fallo
página
tiempo
virtual
caso
Dibuje
diagrama
similar
mostrado
Figura
8.19
secuencia
referencias
res-
tringiéndose
valores
Dibuje
20
function
D.
Dibuje
m20
function
D.
8.16
clave
rendimiento
pol
ítica
gestión
conjunto
reciente
VSWS
valor
Q.
experiencia
demostrado
valor
fijo
determinado
proceso
diferencias
considerables
secuencia
fallos
ágina
distintas
etapas
ejecución
toma
único
valor
procesos
frecuencias
fallos
ágina
considerablemente
dife-
rencias
indican
claramente
mecanismo
ajuste
dinámicamente
valor
du-
rante
tiempo
vida
proceso
incrementaría
considerablemente
rendimiento
algoritmo
Sugiera
mecanismo
sencillo
propósito
8.17
Considere
tarea
dividida
segmentos
tama
ño
sistema
construye
tabla
descriptores
áginas
entradas
seg-
mento
forma
sistema
implementa
combinaci
ón
segmentación
pagina-
ción
asume
tama
ño
página
Kbytes
tamaño
máximo
segmentos
tamaño
máximo
espacio
direcciones
lógicas
tarea
Supongamos
elemento
ubicaci
ón
física
00021ABC
accedido
tarea
formato
dirección
lógica
tarea
generaría
espacio
direcciones
físicas
máximo
sistema
8.18
Considere
espacio
direcciones
ógicas
paginadas
compuesto
32
áginas
Kbytes
proyecta
espacio
memoria
ísica
Mbyte
formato
direcciones
lógicas
procesador
longitud
anchura
tabla
áginas
bits
derechos
acceso
Ftk
DD=
sW
tk
DD=
394
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
394c
efecto
tabla
páginas
espacio
memoria
física
fuese
mitad
8.19
núcleo
UNIX
proporciona
crecimiento
dinámico
pila
proceso
memoria
virtual
intentará
reducirla
Considere
caso
programa
llama
subrutina
escrita
pide
reserve
vector
local
pila
consume
10
Kbytes
núcleo
expandirá
segmento
pila
ubicarlo
regresa
subrutina
puntero
pila
ajusta
espacio
podr
ía
liberarse
ú-
cleo
Explique
qu
reducir
pila
instante
núcleo
UNIX
APÉNDICE
8A
TABLAS
HASH
Consideremos
problema
conjunto
objetos
almacenar
tabla
objeto
consiste
etiqueta
informaci
ón
adicional
referiremos
valor
objeto
Adicionalmente
deseable
disponer
serie
operaciones
ordinarias
tabla
inserción
borrado
búsqueda
valor
determinada
clave
etiquetas
objetos
num
éricas
rango
solución
sencilla
utilizar
tabla
longitud
M.
objeto
etiqueta
insertaría
tabla
posición
siem-
pre
objetos
tamaño
fijo
búsqueda
tabla
trivial
implica
indexaci
ón
base
etiqueta
numérica
objeto
necesario
almacenar
dicha
etiqueta
tabla
posici
ón
objeto
implica
valor
tablas
deno-
minan
tablas
acceso
directo
etiquetas
numéricas
posibilidad
utilizar
estrategia
acceso
directo
referimos
objetos
A[1
A[N
objeto
A[i
consiste
etiqueta
clave
vi
define
función
proyección
I(k
forma
I(k
tome
valores
claves
I(ki)π(kj
par
valores
caso
utilizar
tablas
acceso
directo
tabla
longitud
M.
principal
dificultad
esquemas
ocurre
má
caso
proporció
entradas
tabla
implica
eficiente
memoria
alternativa
utilizació
tabla
longitud
almace-
nar
objetos
etiqueta
valor
entradas
esquema
cantidad
me-
moria
minimiza
much
simo
má
pesado
proceso
consulta
tabla
dife-
rentes
posibilidades
Búsqueda
secuencial
estrategia
fuerza
bruta
consume
tiempo
tablas
tamaño
Búsqueda
asociativa
soporte
apropiado
hardware
elementos
tabla
buscar
forma
simultánea
estrategia
propósito
general
aplicar
tipos
tablas
Búsqueda
binaria
etiquetas
proyecciones
numérica
etiquetas
ordenan
forma
ascendente
tabla
búsqueda
binaria
rápida
secuencia
Tabla
8.6
requiere
hardware
especial
búsqueda
binaria
prometedora
consulta
tablas
principal
desventaja
método
inserción
objeto
proceso
simple
habitualmente
requerir
re-
ordenación
entradas
úsqueda
binaria
habitualmente
tablas
razonablemente
estáticas
sufren
cambios
Memoria
virtual
395
08-Capitulo
12/5/05
16:23
Página
395Queremos
evitar
penalizaciones
memoria
estrategia
acceso
directo
sencillo
penalizaciones
proceso
alternativas
vistas
anteriormente
étodo
utilizado
habitual-
mente
denomina
hashing
hashing
desarrollado
ños
50
sencillo
implementar
ventajas
lugar
consultar
mayoría
ob-
jetos
acceso
directo
caso
visto
lugar
inserciones
borrados
manejar
complejidad
adicional
función
hashing
definir
asumimos
obje-
tos
almacenados
tabla
hash
longitud
insertar
objeto
tabla
I1
convierte
etiqueta
objeto
valor
pseudo-aleatorio
ejemplo
función
proyección
habitual
dividir
etiqueta
que-
darse
resto
valor
n.
I2
índice
tabla
hash
entrada
correspondiente
tabla
vacía
almacenar
objeto
etiqueta
valor
dicha
entrada
entrada
ocupada
almacenamiento
objeto
causado
colisi
ón
almacenará
objeto
área
desbordamiento
veremos
ás
operación
consulta
objeto
conocemos
etiqueta
C1
convierte
etiqueta
objeto
valor
pseudo-aleatorio
usando
función
proyección
caso
inserci
ón
C2
índice
tabla
hash
entrada
correspondiente
tabla
vacía
objeto
en-
contraba
almacenado
previamente
tabla
entrada
ocupada
etiquetas
coinciden
recupe-
rar
valor
entrada
ocupada
etiquetas
coinciden
continuar
consulta
área
desbordamiento
396
Sistemas
operativos
Aspectos
internos
principios
diseño
TABLA
8.6
Tiempo
búsqueda
objetos
tabla
tamaño
M.
écnica
Longitud
búsqueda
Directa
Secuencial
Binaria
log2(M
Hashing
lineal
Hash
desbordamiento
encadenado
-N
08-Capitulo
12/5/05
16:23
Página
396Los
esquemas
hashing
difieren
forma
manejan
colisiones
desborda-
mientos
técnica
habitual
denomina
hashing
lineal
habitualmente
compiladores
técnica
regla
I2.b
convierte
I2.b
entrada
ocupada
n+1
mod
vuelve
paso
I2.a
regla
C2.c
modifica
consecuentemente
Figura
8.27a
ejemplo
caso
etiquetas
objetos
almacenan
numéricas
tabla
hash
posiciones
M=8
función
proyección
consiste
que-
darse
resto
división
figura
asume
objetos
insertados
orden
ascendente
necesario
forma
objetos
50
51
proyectan
posicio-
nes
respectivamente
est
án
vacías
insertan
objeto
74
tambi
én
proyecta
posición
vacía
intentará
posición
tam-
bién
ocupada
intentará
posición
libre
fácil
determinar
longitud
media
operación
consulta
determinado
objeto
tabla
efecto
agrupamiento
órmula
aproximada
obtenida
Schay
Spruth
SCHA62
Longitud
media
búsqueda
M.
Nótese
resultado
independiente
tama
ño
tabla
depende
encuentre
llena
resultado
sorprendente
tabla
80%
ocupación
longitud
media
úsqueda
torno
bú
squeda
longitud
considerar
larga
tablas
hashing
line-
desventaja
adicional
resulta
cil
borrar
elementos
estrategia
alter-
22
Memoria
virtual
397
95
valor
95
94
valor
94
51
valor
51
50
valor
50
83
valor
83
119
valor
119
139
valor
139
74
valor
74
Tabla
hash
Overflow
table
139
119
119
95
94
83
74
51
50
Desbordamiento
encadenado
95
119
valor
95
valor
83
51
valor
51
50
valor
50
valor
119
95
83
Hashing
lineal
74
51
50
83
74
valor
74
Figura
8.27
Hashing
08-Capitulo
12/5/05
16:23
Página
397nativa
proporciona
longitud
bú
squeda
má
corta
Tabla
8.6
permite
borrados
mis-
ma
forma
inserciones
desbordamiento
encadenado
té
cnica
muestra
Fi-
gura
8.27b
caso
tabla
separada
redirigen
operaciones
colisió
n.
tabla
incluye
punteros
entradas
asociá
ndolas
cadena
posició
tabla
hash
caso
longitud
media
bú
squeda
asumiendo
datos
distribuidos
forma
aleatoria
Longitud
media
búsqueda
valores
valor
aproxima
1,5
caso
N.
forma
técnica
proporciona
almacenamiento
compacto
operaci
ón
consulta
rápida
-1
398
Sistemas
operativos
Aspectos
internos
principios
diseño
08-Capitulo
12/5/05
16:23
Página
398PARTE
IV
PLANIFICACIÓN
sistema
operativo
asignar
recursos
computador
necesidades
potencial-
mente
competitivas
múltiples
procesos
caso
procesador
recurso
asignar
tiempo
ejecución
procesador
forma
asignarlo
planificación
función
planificación
diseñada
satisfacer
objetivos
incluyen
equidad
ausencia
inanición
proceso
eficiente
tiempo
procesador
sobrecar-
ga
función
planificación
necesitar
niveles
priori-
dad
plazos
tiempo
real
inicio
finalización
procesos
años
planifi-
cación
objeto
profundas
investigaciones
implementado
múltiples
algoritmos
investigación
planificación
centra
explotación
sistemas
multiproce-
sador
particularmente
aplicaciones
multihilo
planificación
tiempo
real
GUÍA
LECTURA
CAPÍTULO
PLANIFICACIÓN
UNIPROCESADOR
Capítulo
centra
planificación
procesador
contexto
limitado
pue-
den
definir
clarificar
múltiples
aspectos
diseño
relacionados
planificación
Capítulo
comienza
examen
tipos
planificación
procesador
plazo
pla-
zo
corto
plazo
grueso
capítulo
dedicado
temas
planificación
corto
plazo
examinan
comparan
algoritmos
propuestos
CAPÍTULO
10
PLANIFICACIÓN
MULTIPROCESADOR
TIEMPO
REAL
Capítulo
10
examina
áreas
centrales
investigación
actual
planificación
presen-
cia
múltiples
procesadores
complica
decisiones
planificación
abre
posibilida-
des
particular
múltiples
procesadores
planificar
ejecución
simultánea
múltiples
hilos
proceso
Capítulo
10
pasa
revista
planificación
multiprocesa-
dor
multihilo
resto
capítulo
planificación
tiempo
real
requisitos
tiempo
real
exigen
planificador
allá
imparcialidad
priori-
dad
especificar
límites
temporales
comienzo
finalización
diversas
tareas
procesos
09-Capitulo
12/5/05
16:24
Página
39909-Capitulo
12/5/05
16:24
Página
400CAPÍTULO
Planificación
uniprocesador
9.1
Tipos
planificación
procesador
9.2
Algoritmos
planificación
9.3
Planificación
UNIX
tradicional
9.4
Resumen
9.5
Lecturas
recomendadas
9.6
érminos
clave
cuestiones
repaso
problemas
Apéndice
9A
Tiempo
respuesta
Apéndice
9B
Sistemas
colas
09-Capitulo
12/5/05
16:24
Página
401N
sistema
multiprogramado
múltiples
procesos
concurrente
memoria
prin-
cipal
procesos
usando
procesador
esperando
suceso
al-
gún
evento
finalización
operación
S.
procesador
procesadores
mantienen
ocupados
ejecutando
proceso
resto
espera
clave
multiprogramación
planificación
diferencian
tipos
planifi-
cación
Tabla
9.1
planificación
fondo
Capítulo
S.
tipos
restantes
planificación
pertenecientes
planificación
procesador
tratan
capítulo
capítulo
comienza
examinando
tipos
planificación
procesador
mostrando
relacionan
verá
planificación
plazo
planificación
plazo
preocu-
pan
aspectos
rendimiento
relacionados
grado
multiprogramación
temas
tratan
Capítulo
detalle
Capítulos
forma
restante
capítulo
centra
planificación
corto
plazo
limita
planificación
sistema
uniprocesador
múltiples
procesadores
añade
complejidad
adicional
cen-
trarse
caso
uniprocesadores
forma
diferencias
algoritmos
planificación
claridad
Sección
9.2
analiza
algoritmos
utilizar
tomar
decisiones
plani-
ficación
corto
plazo
9.1
TIPOS
PLANIFICACIÓN
PROCESADOR
objetivo
planificación
procesos
asignar
procesos
ejecutados
procesador
procesadores
tiempo
forma
cumplan
objetivos
sistema
tales
tiempo
respuesta
rendimiento
eficiencia
procesador
siste-
actividad
planificación
divide
funciones
independientes
planificación
largo-
medio-
corto-plazo
nombres
sugieren
escalas
tiempo
relativas
ejecutan
funciones
abla
9.1
Tipos
planificación
Planificación
plazo
decisión
añadir
proceso
conjunto
procesos
ejecutados
Planificación
plazo
decisión
añadir
proceso
número
procesos
parcialmente
totalmente
memoria
principal
Planificación
corto
plazo
decisión
proceso
disponible
ejecutado
procesador
Planificación
decisión
proceso
pendiente
petición
atendido
dispositivo
disponible
Figura
9.1
relaciona
funciones
planificación
diagrama
transición
procesos
anteriormente
visto
Figura
3.9b
planificación
plazo
realiza
crea
proceso
decidir
añade
proceso
conjunto
activos
actualmente
planificación
plazo
función
intercambio
swapping
function
decidir
añade
proceso
parcialmente
memoria
disponibles
ejecución
planificación
corto
plazo
conlleva
decidir
procesos
listos
ejecutar
ejecutado
Figura
9.2
reorganiza
402
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
402diagrama
transición
Figura
3.9b
apreciar
anidamiento
funciones
planificación
planificación
afecta
rendimiento
sistema
determina
proceso
esperará
proceso
progresará
punto
vista
presenta
Figura
9.3
muestran
colas
in-
volucradas
transición
procesos
Fundamentalmente
planificación
problema
manejo
colas
minimizar
retardo
cola
optimizar
rendimiento
entorno
colas
PLANIFICACIÓN
PLAZO
planificador
plazo
determina
programas
admiten
sistema
procesamien-
to
forma
controla
grado
multiprogramación
admitido
trabajo
progra-
ma
usuario
convierte
proceso
añade
cola
planificador
corto
plazo
algu-
sistemas
proceso
reciente
creación
comienza
zona
intercambio
cuyo
caso
añaden
cola
planificador
plazo
sistema
lotes
lotes
sistema
operativo
propósito
general
trabajos
enviados
mandan
disco
mantienen
cola
lotes
planificador
plazo
creará
procesos
cola
caso
tomar
decisio-
nes
planificador
decidir
sistema
operativo
coger
pro-
cesos
adicionales
planificador
decidir
trabajo
trabajos
aceptan
convertidos
procesos
Consideremos
brevemente
decisiones
decisión
crear
proceso
toma
dependiendo
grado
multiprograma-
ción
deseado
número
procesos
creados
menor
porcentaje
tiempo
Planificación
uniprocesador
403
simplicidad
Figura
9.3
muestra
procesos
yendo
directamente
Listo
Figuras
9.1
9.2
muestran
opciones
Listo
Listo
Suspendido
Listo/
suspendido
Listo
Ejecutando
Salida
Planificación
plazo
Planificación
plazo
Bloqueado/
suspendido
Bloqueado
Planificación
corto
plazo
Planificación
plazo
Planificación
plazo
Figura
9.1
Planificación
transiciones
procesos
09-Capitulo
12/5/05
16:24
Página
403en
proceso
ejecutar
procesos
compiten
cantidad
tiempo
procesador
forma
planificador
plazo
limitar
grado
multi-
programación
proporcionar
servicio
satisfactorio
actual
conjunto
procesos
termine
trabajo
planificador
decidir
añadir
trabajos
fracción
tiempo
procesador
ocioso
excede
determinado
valor
invocar
planificador
plazo
decisión
trabajo
admitir
basarse
sencillo
llegar
servirse
herramienta
gestionar
rendimiento
sistema
crite-
rio
utilizado
incluir
prioridad
tiempo
estimado
ejecución
requisitos
S.
ejemplo
información
disponible
planificador
intentar
encontrar
compromiso
procesos
limitados
procesador
procesos
limitados
decisión
pue-
404
Sistemas
operativos
Aspectos
internos
principios
diseño
proceso
limitado
procesador
realiza
trabajo
computacional
ocasionalmente
disposi-
tivos
S.
proceso
limitado
pasa
tiempo
utilizando
dispositivos
rocesador
Ejecutando
Listo
Bloqueado
Bloqueado/
suspendido
Listo/
suspendido
Corto
plazo
plazo
plazo
Salida
Figura
9.2
Niveles
planificación
09-Capitulo
12/5/05
16:24
Página
404de
tomada
dependiendo
recursos
vayan
utilizados
forma
intente
equilibrar
S.
programas
interactivos
sistema
tiempo
compartido
petición
creación
proceso
generada
usuario
intentando
conectarse
sistema
usuarios
tiempo
compartido
sitúan
simplemente
cola
sistema
aceptar
exactamente
sistema
operativo
aceptará
usuarios
autorizados
sistema
sa-
ture
saturación
estima
utilizando
medidas
prefijadas
sistema
Llegado
punto
petición
conexión
encontrará
mensaje
indicando
sistema
completo
usuario
debería
reintentarlo
PLANIFICACIÓN
PLAZO
planificación
plazo
función
intercambio
aspectos
relacionados
discuten
Capítulos
frecuencia
decisión
intercambio
basa
necesidad
gestionar
grado
multiprogramación
sistema
utiliza
memoria
virtual
ges-
tión
memoria
aspecto
forma
decisión
meter
proceso
memoria
necesidades
memoria
procesos
PLANIFICACIÓN
CORTO
PLAZO
términos
frecuencia
ejecución
planificador
plazo
ejecuta
relativamente
frecuencia
toma
decisión
grano
grueso
admitir
proceso
proceso
admi-
Planificación
uniprocesador
405
Espera
evento
Tiempo
finalizado
FinalizadoCola
listos
Planificación
corto
plazo
Planificación
plazo
Planificación
plazo
Usuarios
interactivos
Trabajos
lotes
Procesador
Cola
listos
suspendidos
Suceso
evento
Cola
bloqueados
suspendidos
Cola
bloqueados
Planificación
plazo
Figura
9.3
Diagrama
encolamiento
planificación
09-Capitulo
12/5/05
16:24
Página
405tir
planificador
plazo
ejecuta
frecuentemente
tomar
decisiones
intercam-
bio
planificador
corto
plazo
conocido
activador
ejecuta
frecuente-
mente
toma
decisiones
grano
fino
proceso
ejecutar
planificador
corto
plazo
invoca
ocurre
evento
conllevar
blo-
queo
proceso
actual
proporcionar
oportunidad
expulsar
proceso
actualmente
ejecución
favor
ejemplos
eventos
Interrupciones
reloj
Interrupciones
S.
Llamadas
sistema
Señales
ejemplo
semáforos
9.2
ALGORITMOS
PLANIFICACIÓN
CRITERIOS
PLANIFICACIÓN
CORTO
PLAZO
objetivo
principal
planificación
corto
plazo
asignar
tiempo
procesador
forma
optimicen
aspectos
comportamiento
sistema
Generalmente
establece
conjunto
criterios
evaluar
políticas
planificación
criterios
utilizados
habitualmente
categorizar
dimensiones
distinción
criterios
orientados
usuario
criterios
orientados
sistema
criterios
orientados
usuario
relacionados
comportamiento
sistema
percibe
usuario
individual
proceso
ejemplo
tiempo
respuesta
sistema
inte-
ractivo
tiempo
respuesta
tiempo
transcurre
envío
petición
apari-
ción
respuesta
cantidad
visible
usuario
lógicamente
interés
gustaría
política
planificación
proporcione
servicio
usuarios
caso
tiempo
respuesta
definir
límite
ejemplo
segundos
forma
objetivo
mecanismo
planificación
maximizar
número
usuarios
tiempo
respuesta
menor
segundos
criterios
relacionados
sistema
atención
centra
efecti-
vo
eficiente
procesador
ejemplo
rendimiento
throughput
tasa
procesos
finalizan
medida
valiosa
relación
sistema
gustaría
maxi-
mizar
centra
servicios
proporcionados
usuario
forma
rendi-
miento
incumbe
administrador
sistema
usuarios
criterios
orientados
usuario
importantes
prácticamente
siste-
criterios
orientados
sistema
generalmente
importantes
sistemas
usuario
sistemas
usuario
probablemente
importante
lograr
alta
utiliza-
ción
procesador
alto
rendimiento
respuesta
sistema
aplicaciones
usuario
aceptable
clasificar
criterios
dependiendo
relacionados
prestaciones
criterios
relacionados
prestaciones
cuantitativos
generalmente
pue-
den
medidos
ejemplos
tiempo
respuesta
rendimiento
criterios
relacionados
prestaciones
cualitativos
naturaleza
medi-
analizados
ejemplo
tales
criterios
previsibilidad
gustaría
servicio
proporcionado
usuarios
tuviera
características
tiempo
independien-
temente
trabajos
estén
realizando
sistema
punto
criterio
pue-
406
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
406de
medido
calculando
discrepancias
función
carga
trabajo
medida
directa
medir
rendimiento
tiempo
respuesta
función
carga
trabajo
Tabla
9.2
resume
criterios
clave
planificación
independientes
imposible
optimizar
forma
simultánea
ejemplo
proporcionar
tiempo
respuesta
requerir
algoritmo
planificación
cambie
procesos
frecuentemente
incre-
menta
sobrecarga
sistema
reduciendo
prestaciones
forma
diseño
políticas
planificador
implica
compromiso
requisitos
competitivos
pesos
relativos
dados
distintos
requisitos
dependerán
naturaleza
sistema
abla
9.2
Criterios
planificación
Orientados
usuario
relacionados
prestaciones
Tiempo
estancia
turnaround
time
Tiempo
transcurrido
lanza
proceso
finaliza
Incluye
tiempo
ejecución
sumado
tiempo
espera
recursos
incluyendo
procesador
medida
apropiada
trabajos
lotes
Tiempo
respuesta
response
time
proceso
interactivo
tiempo
trascurre
lanza
petición
comienza
recibir
respuesta
proceso
producir
salida
usuario
continúa
proceso
petición
forma
punto
vista
usuario
medida
tiempo
estancia
planificación
in-
tentar
lograr
bajos
tiempos
respuesta
maximizar
número
usuarios
interactivos
tiempos
respuesta
aceptables
Fecha
tope
deadlines
especificar
fecha
tope
proceso
planificador
subordinar
objetivos
maximizar
porcentaje
fechas
tope
conseguidas
Orientados
usuario
Previsibilidad
trabajo
debería
ejecutarse
tiempo
coste
carga
sistema
variación
tiempo
respuesta
tiempo
estancia
malo
punto
vista
usuarios
significar
osci-
lación
sobrecarga
sistema
necesidad
punto
sistema
eliminar
inestabilidades
Orientados
sistema
relacionados
prestaciones
Rendimiento
política
planificación
debería
intentar
maximizar
número
procesos
comple-
tados
unidad
tiempo
medida
trabajo
medida
de-
pende
claramente
longitud
media
procesos
influenciada
política
plani-
ficación
afectar
utilización
Utilización
procesador
porcentaje
tiempo
procesador
ocupado
sis-
tema
compartido
costoso
criterio
significativo
sistema
usuario
sistemas
tales
sistemas
tiempo
real
criterio
importante
Orientados
sistema
Equidad
ausencia
orientación
usuarios
orientación
proporcionada
siste-
ma
procesos
tratados
proceso
sufrir
inanición
Imposición
prioridades
asignan
prioridades
procesos
política
planificador
debería
favorecer
procesos
prioridades
altas
Equilibrado
recursos
política
planificador
debería
mantener
ocupados
recursos
sis-
tema
procesos
utilicen
recursos
determinado
momento
sobreutili-
zados
deberían
favorecidos
criterio
implica
planificación
plazo
plazo
Planificación
uniprocesador
407
09-Capitulo
12/5/05
16:24
Página
407En
sistemas
operativos
interactivos
usuario
tiempo
compartido
adecuado
tiempo
respuesta
requisito
crítico
importancia
requisito
definición
adecuación
varía
aplicaciones
tema
explora
profundidad
apéndice
libro
PRIORIDADES
sistemas
proceso
asigna
prioridad
planificador
elegirá
proceso
prioridad
proceso
prioridad
menor
Figura
9.4
muestra
prioridades
claridad
diagrama
colas
simplificado
ignorando
existencia
múltiples
colas
bloqueadas
suspendidos
comparar
Figura
3.8a
lugar
cola
procesos
listos
ejecutar
proporcionan
conjunto
colas
orden
descendente
priori-
dad
CL0
CL1
CL
prioridad[CLi]>prioridad[CLj
selección
planificación
planificador
comenzará
cola
listos
prioridad
alta
CL0
procesos
cola
selecciona
proceso
utilizando
política
planificación
CL0
vacía
examina
CL1
sucesivamente
problema
esquemas
planificación
prioridades
procesos
prioridad
baja
sufrir
inanición
sucederá
conjunto
procesos
prioridad
listos
ejecutar
comportamiento
deseable
prioridad
proceso
pue-
408
Sistemas
operativos
Aspectos
internos
principios
diseño
UNIX
sistemas
valores
mayores
prioridad
representan
procesos
prioridad
baja
esfecifique
seguiremos
convención
sistemas
tales
Windows
utilizan
convención
opuesta
número
ma-
yor
significa
prioridad
Espera
evento
Suceso
evento
Expulsión
Envío
FinalizadoCL0
CL1
CLn
Admitido
Procesador
Cola
bloqueados
Figura
9.4
Encolamiento
prioridades
09-Capitulo
12/5/05
16:24
Página
408de
cambiar
antigüedad
histórico
ejecución
Posteriormente
daremos
ejemplo
situación
POLÍTICAS
PLANIFICACIÓN
ALTERNATIVAS
Tabla
9.3
presenta
información
resumida
políticas
planificación
examinadas
subsección
función
selección
determina
proceso
procesos
listos
selecciona
ejecución
función
basada
prioridades
requisitos
recursos
características
ejecución
proceso
caso
medidas
cuantitativas
tiempo
usado
sistema
momento
esperando
ejecutando
tiempo
usado
ejecución
momento
tiempo
servicio
requerido
proceso
incluyendo
generalmente
canti-
dad
estimada
proporcionada
usuario
ejemplo
función
selección
max[w
implica
planificación
tipo
llegar
servirse
first-come-first-served
FCFS
decisión
especifica
instantes
tiempo
ejecuta
función
selección
categorías
generales
expulsion
nonpreemptive
caso
proceso
Ejecu-
tando
continúa
ejecutando
termina
bloquea
esperar
soli-
citar
servicio
sistema
operativo
expulsión
preemptive
proceso
ejecutando
determinado
momento
interrumpido
listo
sistema
operativo
decisión
expulsar
tomada
llega
proceso
llega
interrupción
pasa
proceso
bloqueado
listo
periódicamente
basándose
interrupciones
reloj
políticas
expulsivas
sobrecarga
expulsivas
proporcio-
nar
servicio
población
procesos
previenen
proceso
monopolizar
procesador
tiempo
coste
expulsión
resultar
re-
lativamente
utilización
mecanismos
eficientes
cambios
proceso
tanta
ayuda
hardware
proporcionando
cantidad
memoria
principal
dejar
alto
porcentaje
programas
memoria
principal
medida
describan
políticas
planificación
utilizará
conjunto
procesos
Tabla
9.4
ejemplo
ejecución
pensar
procesos
trabajos
lotes
tiempo
servicio
tiempo
ejecución
requerido
considerar
procesos
curso
requieren
alternativo
procesador
forma
repetitiva
caso
tiempos
servicio
representan
tiempo
procesador
requerido
ciclo
caso
términos
modelo
colas
cantidad
corresponde
tiempo
servicio
Planificación
uniprocesador
409
Apéndice
9B
contiene
resumen
terminología
modelo
colas
09-Capitulo
12/5/05
16:24
Página
409410
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
9.3
Características
políticas
planificación
Función
Rendimiento
Tiempo
Rendimiento
Efecto
InaniciónSelección
Decisión
Respuesta
Procesos
FCFS
max[w
expulsiva
especificado
alto
Mínima
Penaliza
especialmente
procesos
cortos
penaliza
diferencia
procesos
tiempos
ejecución
procesos
rn
constante
Expulsiva
Proporciona
Mínima
Tratamiento
Rotatorio
rodajas
tiempo
justo
round
robin
tiempo
rodaja
respuesta
procesos
pequeña
cortos
SPN
min[s
expulsiva
Alto
Proporciona
alta
Penaliza
tiempo
procesos
largos
respuesta
procesos
cortos
SRT
min[s-e
Expulsiva
Alto
Proporciona
Penaliza
llegada
tiempo
alta
procesos
largos
respuesta
HRRN
max(w+s
expulsiva
Alto
Proporciona
alta
equilibrio
tiempo
respuesta
Feedback
texto
Expulsiva
especificado
especificado
rodajas
alta
favorecer
tiempo
procesos
tiempo
espera
tiempo
ejecución
momento
tiempo
servicio
requerido
proceso
incluyendo
09-Capitulo
12/5/05
16:24
Página
410Para
ejemplo
Tabla
9.4
Figura
9.5
muestra
patrones
ejecución
directi-
ciclo
Tabla
9.5
resume
principales
resultados
determina
tiempo
finalización
proceso
forma
determinar
tiempo
estancia
términos
modelo
colas
tiempo
estancia
turnaround
time
TAT
tiempo
residencia
tiempo
elemento
sistema
tiempo
espera
tiempo
servicio
útil
tiempo
estancia
normalizado
tasa
tiempo
estancia
tiempo
servicio
valor
indica
retardo
relativo
experimentado
proceso
tiempo
ejecu-
ción
valor
absoluto
retardo
tolerar
menor
valor
tasa
1,0
valores
mayores
corresponden
servicio
nivel
menor
abla
9.4
Ejemplo
planificación
procesos
Proceso
Tiempo
llegada
Tiempo
servicio
A03
B26
C44
D65
E8
llegar
servirse
first-come-first-served
directiva
planifica-
ción
sencilla
llegar
servirse
FCFS
conocida
primero-
entra-primero-sale
FIFO
sistema
colas
estricto
momento
proceso
pasa
listo
une
cola
listos
proceso
actualmente
ejecución
deja
ejecutar
selecciona
ejecutar
proceso
tiempo
cola
listos
FCFS
funciona
procesos
largos
procesos
cortos
Considérese
si-
guiente
ejemplo
basado
FINK88
Proceso
Tiempo
Tiempo
Tiempo
Tiempo
Tiempo
TsLlegada
Servicio
Comienzo
Finalización
Estancia
010111
100
101
100
101
102
100
100
100
102
202
199
1,99
Media
100
26
tiempo
estancia
normalizado
proceso
excesivamente
comparación
procesos
tiempo
sistema
100
tiempo
requerido
proceso
sucederá
llegue
proceso
corto
continuación
proceso
ejemplo
extremo
procesos
largos
proceso
tiempo
estancia
doble
tiempo
residencia
normalizado
de-
2,0
Planificación
uniprocesador
411
09-Capitulo
12/5/05
16:24
Página
411Otro
problema
FCFS
tiende
favorecer
procesos
limitados
procesador
procesos
limitados
S.
Considere
colección
procesos
li-
mitado
procesador
número
procesos
limitados
S.
proceso
limitado
procesador
ejecutando
resto
procesos
esperar
estarán
colas
bloqueado
mover
cola
listos
proceso
limitado
procesador
ejecutando
punto
dispositivos
ociosos
exista
trabajo
potencial
proceso
412
Sistemas
operativos
Aspectos
internos
principios
diseño
llegar
servirse
FCFS
10
15
20
10
15
20
Turno
rotatorio
RR
/H11005
Turno
rotatorio
RR
/H11005
proceso
corto
SPN
Menor
tiempo
restante
SRT
tasa
respuesta
HRRN
Retroalimentación
/H11005
Retroalimentación
/H11005
Figura
9.5
Comparación
políticas
planificación
09-Capitulo
12/5/05
16:24
Página
412actual
ejecución
deja
Ejecutando
procesos
listos
pasarán
Ejecutando
volverán
bloquear
evento
S.
proceso
limitado
procesador
blo-
queado
procesador
quedará
ocioso
FCFS
conllevar
usos
ineficientes
procesador
dispositivos
S.
FCFS
alternativa
atractiva
sistema
uniprocesador
combina
esquemas
prioridades
proporcionar
planificación
eficaz
forma
planificador
mantener
colas
nivel
prioridad
despachar
den-
tro
cola
usando
llegar
servirse
Veremos
ejemplo
sistema
hablemos
planificación
retroalimentada
feedback
urno
rotatorio
round
robin)Una
forma
directa
reducir
castigo
trabajos
cor-
tos
FCFS
utilización
expulsión
basándose
reloj
política
sencilla
turno
rotatorio
denominada
planificación
cíclica
genera
interrupción
reloj
intervalo
tiempo
sucede
interrupción
proceso
actual
ejecución
sitúa
cola
listos
selecciona
trabajo
política
FCFS
técnica
conocida
cortar
tiempo
time
slicing
proceso
rodaja
tiempo
expulsado
planificación
turno
rotatorio
tema
clave
diseño
longitud
quantum
tiempo
rodaja
utilizada
quantum
pequeño
proceso
moverá
sistema
relativamente
rápido
sobrecarga
procesamiento
manejo
interrupción
reloj
funciones
planificación
activación
forma
evitar
quantums
tiempo
pequeños
idea
quantum
tiempo
ligera-
mente
tiempo
requerido
interacción
función
típica
proceso
me-
nor
procesos
necesitarán
quantums
tiempo
Figura
9.6
muestra
efecto
tiempo
respuesta
Nótese
caso
extremo
quantum
tiempo
proceso
eje-
cución
planificación
turno
rotatorio
degenera
FCFS
Figura
9.5
Tabla
9.5
muestran
resultados
ejemplo
utilizando
quantums
tiempo
unidades
tiempo
Nótese
proceso
trabajo
corto
obtiene
mejoras
significativas
quantum
tiempo
planificación
turno
rotatorio
particularmente
efectiva
sistemas
tiempo
compartido
propósito
general
sistemas
procesamiento
transaccional
desventaja
planifica-
ción
turno
rotatorio
forma
desigual
procesos
limitados
procesador
procesos
limitados
S.
Generalmente
proceso
limitado
ráfagas
pro-
cesador
cortas
cantidad
tiempo
ejecución
utilizada
operaciones
pro-
cesos
limitados
procesador
mezcla
tipos
procesos
sucederá
si-
guiente
proceso
limitado
utiliza
procesador
periodo
corto
bloquea
espera
complete
operación
continuación
une
cola
listos
proceso
limitado
procesador
generalmente
utiliza
rodaja
tiempo
completa
ejecuta
inmediatamente
vuelve
cola
listos
forma
procesos
limitados
procesador
tienden
recibir
rodaja
equitativa
tiempo
procesador
conlleva
rendimiento
procesos
limitados
ineficiente
recursos
incremento
varianza
tiempo
respuesta
HALD91
sugiere
refinamiento
planificación
turno
rotatorio
denomina
turno
ro-
tatorio
virtual
virtual
round
robin
VRR
evita
injusticia
Figura
9.7
muestra
es-
quema
procesos
llegan
unen
cola
listos
gestionada
FCFS
expira
tiempo
ejecución
proceso
vuelve
cola
listos
bloquea
proceso
une
cola
S.
característica
Planificación
uniprocesador
413
09-Capitulo
12/5/05
16:24
Página
413414
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
9.5
Comparación
políticas
planificación
Proceso
Tiempo
llegada
02468
Tiempo
servicio
Ts
36452
Media
FCFS
Tiempo
finalización
13
18
20
Tiempo
estancia
Tr
12
12
8.60
Tr
Ts
1.00
1.17
2.25
2.40
6.00
2.56
RR
Tiempo
finalización
18
17
20
15
Tiempo
estancia
Tr
16
13
14
10.80
Tr
Ts
1.33
2.67
3.25
2.80
3.50
2.71
RR
Tiempo
finalización
17
20
19
Tiempo
estancia
Tr
15
14
10.00
Tr
Ts
1.00
2.5
1.75
2.80
5.50
2.71
SPN
Tiempo
finalización
15
20
Tiempo
estancia
Tr
37
437
.60
Tr
Ts
1.00
1.17
2.75
2.80
1.50
1.84
SRT
Tiempo
finalización
15
20
10
Tiempo
estancia
Tr
34
427
.20
Tr
Ts
1.00
2.17
1.00
2.80
1.00
1.59
HRRN
Tiempo
finalización
13
20
15
Tiempo
estancia
Tr
379
478
.00
Tr
Ts
1.00
1.17
2.25
2.80
3.5
2.14
FB
Tiempo
finalización
20
16
19
Tiempo
estancia
Tr
18
12
13
10.00
Tr
Ts
1.33
3.00
3.00
2.60
1.5
2.29
FB
2i
Tiempo
finalización
17
18
20
14
Tiempo
estancia
Tr
15
14
14
10.60
Tr
Ts
1.33
2.50
3.50
2.80
3.00
2.63
09-Capitulo
12/5/05
16:24
Página
414una
cola
auxiliar
FCFS
mueven
procesos
bloqueados
S.
tomar
decisión
activación
procesos
cola
auxiliar
preferencia
cola
listos
activa
proceso
cola
auxiliar
ejecuta
tiempo
superior
rodaja
tiempo
tiempo
ejecutando
cola
principal
listos
estudios
rendimiento
realizados
autores
indican
enfoque
realmente
superior
turno
rotatorio
términos
equidad
proceso
corto
shortest
process
next
enfoque
reducir
sesgo
favor
procesos
largos
inherente
FCFS
política
proceso
corto
SPN
política
expulsiva
selecciona
proceso
tiempo
procesamiento
cor-
to
esperado
forma
proceso
corto
situará
cabeza
cola
proce-
sos
largos
Figura
9.5
Tabla
9.5
muestran
resultado
ejemplo
Observe
proceso
recibe
servicio
FCFS
rendimiento
global
mejora
significativa-
mente
términos
tiempo
respuesta
incrementa
variabilidad
tiempos
respuesta
especialmente
procesos
largos
forma
reduce
predecibilidad
Planificación
uniprocesador
415
Asignación
tiempo
proceso
Tiempo
Tiempo
respuesta
quantum
Interacción
finalizada
tiempo
interacción
típica
Proceso
expulsado
Ejecutan
procesos
tiempo
menor
interacción
típica
Asignación
tiempo
proceso
Asignación
tiempo
proceso
Interacción
finalizada
Figura
9.6
Efecto
tamaño
quantum
tiempo
expulsión
09-Capitulo
12/5/05
16:24
Página
415Un
problema
política
SPN
necesidad
estimar
tiempo
pro-
cesamiento
requerido
proceso
trabajos
lotes
sistema
requerir
pro-
gramador
estime
valor
proporcione
sistema
operativo
estimación
programador
menor
tiempo
actual
ejecución
sistema
abortar
trabajo
entorno
producción
ejecutan
frecuentemente
trabajos
recoger
estadísti-
cas
procesos
interactivos
sistema
operativo
guardar
media
tiempo
ejecu-
ción
ráfaga
proceso
forma
sencilla
cálculo
9.1
tiempo
ejecución
procesador
instancia
i-ésima
proceso
tiempo
ejecución
trabajos
lotes
tiempo
ráfaga
procesador
trabajos
interactivos
valor
predicho
instancia
i-ésima
S1
valor
predicho
instancia
calculado
evitar
volver
calcular
suma
completa
reescribir
ecuación
9.2)S
Snn
n+
11
Tni
Â1
416
Sistemas
operativos
Aspectos
internos
principios
diseño
Espera
Enviar
Tiempo
finalizado
Finalizado
Cola
listos
Admitido
Procesador
Cola
Cola
auxiliar
produce
Cola
Cola
produce
produce
Espera
Espera
Figura
9.7
Diagrama
encolamiento
planificador
turno
rotatorio
virtual
09-Capitulo
12/5/05
16:24
Página
416Observe
fórmula
otorga
peso
instancia
gustaría
otorgar
peso
instancias
recientes
probabilidades
reflejen
comportamientos
futuros
promedio
exponencial
técnica
común
predecir
valores
futuros
basándose
serie
tiempos
pasados
n+1
Tn
a)Sn
9.3
factor
multiplicación
constante
determina
peso
relativo
observaciones
recientes
relación
antiguas
observaciones
Comparar
Ecuación
9.2
valor
constante
independientemente
número
observaciones
pasadas
valores
pasados
consideran
distantes
menor
peso
claridad
considere
desarrollo
Ecuación
9.3
n+1
aTn
aTn–1
a)iaTn–1
a)nS1
9.4
menores
término
sucesivo
ecuación
pequeño
ejemplo
0,8
Ecuación
9.4
queda
Sn+1
0,8Tn
0,16Tn–1
0,032Tn–2
0,0064Tn–3
antigua
observación
promedio
Figura
9.8
muestra
tamaño
coeficiente
función
posición
desarrollo
valor
peso
observaciones
recientes
0,8
prácticamente
peso
observaciones
recientes
0,2
promedio
extiende
observaciones
ventaja
utilizar
valor
cercano
promedio
reflejará
cambio
rápido
cantidades
observadas
desventaja
cambio
brusco
valores
observados
vuelven
valor
valor
alto
lugar
oscilaciones
promedio
Figura
9.9
compara
promedio
simple
exponencial
valores
Figura
9.9a
valor
observado
comienza
crece
gradualmente
valor
10
mantiene
Figura
9.9b
valor
observado
comienza
20
baja
gradualmente
10
Planificación
uniprocesador
417
0,0
0,1
0,2
0,3
0,4
0,5
0,6
0,7
0,8
/H11005
0,2
/H11005
0,5
/H11005
0,8
10
Momento
observación
Valor
coeficiente
Figura
9.8
Coeficientes
exponenciales
suaves
09-Capitulo
12/5/05
16:24
Página
417luego
mantiene
casos
comenzamos
valor
estimado
S1
prioridad
procesos
Observar
promedio
exponencial
reacciona
cambios
comportamiento
procesos
rápido
promedio
simple
valores
mayores
generan
reacciones
rápidas
cambios
valores
observados
riesgo
SPN
posibilidad
inanición
procesos
largos
llegada
constante
procesos
cortos
SPN
reduce
predisposición
favor
trabajos
largos
deseable
entorno
tiempo
compartido
procesamiento
tran-
saccional
carencia
expulsión
olviendo
caso
descrito
FCFS
procesos
seguirán
ejecutando
orden
penalizando
fuertemente
proceso
corto
418
Sistemas
operativos
Aspectos
internos
principios
diseño
10
/H11005
0,8
/H11005
0,5
Promedio
simple
Valor
observado
20
19
18
17
16
15
14
13
121110
10
15
20
/H11005
0,8
/H11005
0,5
20
19
18
17
16
15
14
13
121110
Función
creciente
Función
decreciente
Tiempo
Tiempo
Valor
observado
promediadoValor
observado
promediado
Promedio
simple
Valor
observado
Figura
9.9
promedio
exponencial
09-Capitulo
12/5/05
16:24
Página
418Menor
tiempo
restante
shortest
remaining
time
política
menor
tiempo
restante
SRT
versión
expulsiva
SPN
caso
planificador
escoge
proceso
menor
tiempo
proceso
restante
esperado
proceso
une
cola
lis-
tos
tiempo
restante
menor
proceso
actualmente
ejecución
pla-
nificador
expulsar
proceso
actual
llega
proceso
SPN
planificador
estimación
tiempo
proceso
función
seleccionada
riesgo
inanición
procesos
largos
SRT
sesgo
favor
procesos
largos
encontrar
FCFS
diferen-
cia
turno
rotatorio
generan
interrupciones
adicionales
reduciéndose
sobrecarga
almacenar
tiempos
servicio
transcurridos
generando
sobrecarga
SRT
debería
mejorar
tiempos
estancia
SPN
trabajo
corto
preferencia
traba-
jo
ejecución
Obsérvese
ejemplo
Tabla
9.5
procesos
cortos
reciben
servicio
forma
inmediata
dando
tiempo
estancia
normalizado
1,0
tasa
respuesta
highest
response
ratio
next
Tabla
9.5
he-
mos
utilizado
tiempo
estancia
normalizado
tasa
tiempo
estancia
tiem-
po
actual
servicio
valor
importante
proceso
individual
gustaría
minimi-
zar
tasa
gustaría
minimizar
valor
procesos
general
adelantado
tiempo
servicio
procesos
aproximar
ba-
sándonos
historia
entrada
usuario
gestor
configuración
Consi-
derar
tasa
tasa
respuesta
tiempo
invertido
esperando
procesador
tiempo
servicio
esperado
despacha
inmediatamente
proceso
valor
tiempo
estancia
norma-
lizado
Observar
valor
mínimo
1,0
sucede
proceso
acaba
entrar
sistema
forma
regla
planificación
completa
bloquea
proceso
actual
elegir
proceso
listo
valor
R.
enfoque
atractivo
edad
proceso
favorece
procesos
cortos
menor
denomi-
nador
tasa
envejecimiento
servicio
incrementa
tasa
proce-
so
competir
trabajos
cortos
SRT
SPN
tiempo
servicio
estimar
política
tasa
respuesta
HRRN
Retroalimentación
feedback
averiguar
tiempo
servicio
proce-
sos
SPN
SRT
HRRN
utilizar
forma
establecer
preferencia
tra-
bajos
cortos
penalizar
trabajos
ejecutando
tiempo
palabras
basarnos
tiempo
ejecución
restante
basar
tiempo
ejecu-
ción
utilizado
momento
ws
s=
Planificación
uniprocesador
419
09-Capitulo
12/5/05
16:24
Página
419La
forma
planificación
realiza
expulsión
rodajas
tiempo
utiliza
mecanismo
prioridades
dinámico
proceso
entra
sis-
tema
sitúa
CL0
véase
Figura
9.4
expulsión
vuelve
es-
tado
Listo
sitúa
CL1
expulsado
sitúa
cola
menor
prioridad
proceso
corto
completará
forma
rápida
llegar
migrar
lejos
jerarquía
colas
listos
proceso
irá
degradándose
gradualmente
for-
ma
favorece
procesos
cortos
viejos
largos
cola
cola
menor
prioridad
utiliza
mecanismo
FCFS
cola
menor
prioridad
proceso
descender
devuelto
cola
repe-
tidas
completar
forma
cola
política
turno
rotatorio
Figura
9.10
ilustra
mecanismo
planificación
retroalimentación
mostrando
camino
seguirá
proceso
colas
enfoque
conocido
retroalimentación
multinivel
sistema
operativo
adjudica
procesador
proceso
proceso
bloquea
expulsado
vuelve
situar
colas
prioridad
serie
variaciones
esquema
versión
sencilla
consiste
expul-
sión
política
rotatoria
intervalos
periódicos
ejemplo
muestra
situación
Figura
9.5
Tabla
9.5
rodaja
unidad
tiempo
Observar
caso
comportamiento
similar
turno
rotatorio
rodaja
tiempo
420
Sistemas
operativos
Aspectos
internos
principios
diseño
utilizan
líneas
tiempo
enfatizar
diagrama
secuencias
tiempo
representación
es-
tática
posibles
transacciones
Figura
9.4
FinalizadoCL0
Admitido
Procesador
CL1
CLn
Finalizado
Finalizado
Procesador
Procesador
Figura
9.10
Planificación
retroalimentada
09-Capitulo
12/5/05
16:24
Página
420Un
problema
presenta
esquema
simple
contado
tiempo
estancia
procesos
largos
alargar
forma
alarmante
ocurrir
inanición
entrando
trabajos
frecuentemente
sistema
compensar
problema
va-
riar
tiempos
expulsión
cola
proceso
cola
CL0
rodaja
unidad
tiempo
proceso
cola
CL1
rodaja
unidades
tiempo
sucesivamen-
general
proceso
cola
CL
permite
ejecutar
unidades
tiempo
expulsado
esquema
muestra
ejemplo
Figura
9.5
Tabla
9.5
asignando
rodajas
tiempo
mayores
colas
menor
prioridad
proceso
sufrir
inanición
solución
promover
procesos
colas
prioridad
pasen
determinado
tiempo
esperando
servicio
cola
actual
COMPARACIÓN
RENDIMIENTO
Claramente
rendimiento
políticas
planificación
factor
crítico
elección
imposible
comparación
definitiva
rendimiento
relativo
dependerá
multitud
factores
incluyen
distribución
probabilidad
tiempos
servicio
va-
rios
procesos
eficiencia
planificación
mecanismo
cambio
contexto
naturaleza
demandas
rendimiento
subsistemas
S.
continuación
intentamos
extraer
conclusiones
generales
Análisis
colas
sección
haremos
fórmulas
básicas
colas
supondremos
llegadas
siguen
Procesos
Poisson
tiempos
servicio
exponenciales
observación
disciplina
planificación
elija
siguien-
elemento
servido
forma
independiente
tiempo
servicio
cumple
relación
Tr
Tiempo
estancia
residencia
tiempo
sistema
esperando
ejecutando
Ts
Tiempo
servicio
tiempo
gastado
Ejecutando
Utilización
procesador
particular
planificador
basado
prioridad
prioridad
proceso
asigna
forma
independiente
tiempo
esperado
servicio
proporciona
tiempo
es-
tancia
tiempo
estancia
normalizado
enfoque
FCFS
presencia
ausen-
cia
expulsión
genera
diferencia
medias
excepción
planificación
cíclica
FCFS
diversas
políticas
planificación
consi-
deradas
selecciones
basándose
tiempos
esperados
servicio
des-
gracia
resulta
complicado
desarrollar
modelos
analíticos
cercanos
disciplinas
hacernos
idea
rendimiento
relativo
algoritmos
comparación
Tp
Planificación
uniprocesador
421
encontrar
resumida
terminología
colas
utilizada
capítulo
Apéndice
9B.
Sitio
Computer
Science
Student
Support
WilliamStallings.com/StudentSupport.html
encontrar
introducción
básica
análisis
colas
09-Capitulo
12/5/05
16:24
Página
421con
FCFS
considerando
planificación
prioridades
prioridad
basada
tiempo
servicio
planificación
realiza
basándose
prioridad
procesos
asigna
priori-
dad
basándose
tiempo
servicio
surgen
diferencias
Tabla
9.6
muestra
fór-
mulas
resultantes
asumen
clases
prioridad
tiempos
servicio
clase
tabla
indica
tasa
llegada
resultados
generalizar
cual-
quier
número
clases
prioridad
Observar
fórmulas
planificación
expulsión
caso
asume
interrumpe
proceso
menor
prioridad
cuan-
do
proceso
prioridad
pasa
listo
ejemplo
consideremos
caso
clases
prioridad
número
llega-
das
procesos
clase
tiempo
servicio
clase
menor
prioridad
tiempo
clase
prioridad
forma
preferencia
proce-
sos
cortos
Figura
9.11
muestra
resultado
Dando
preferencia
trabajos
cor-
tos
mejora
tiempo
estancia
normalizado
niveles
utilización
superiores
esperar
mejora
expulsión
Observar
rendimiento
global
ve
afectado
surgen
diferencias
significativas
consideran
clases
prioridad
separado
Figura
9.12
muestra
resultado
procesos
prioridad
menor
tamaño
comparar
línea
superior
gráfico
asume
prioridades
esta-
mos
observando
rendimiento
relativo
mitad
procesos
menor
tiempo
pro-
cesamiento
líneas
asumen
asigna
procesos
prioridad
me-
422
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
9.6
Fórmulas
colas
único
servidor
categorías
prioridades
Suposiciones
Tasa
llegada
Poisson
elementos
prioridad
sirven
elementos
prioridad
llegar
servirse
elementos
prioridad
interrumpe
elemento
atendido
elemento
abandona
cola
pierde
llamadas
retrasadas
Fórmulas
Generales
interrupciones
tiempos
servicio
Disciplina
colas
expulsiva
reanudación
exponencial
tiempos
servicio
exponencial
ll
rl
rl
rr
12
11
22
12
TT
TT
TT
ss
ss
rr
TT
TT
TT
TT
rs
ss
rs
rs
11
11
22
22
11
rr
TT
TT
rs
rs
11
11
22
12
11
ËÁ
¯˜
09-Capitulo
12/5/05
16:24
Página
422Planificación
uniprocesador
423
0,1
10
0,2
0,3
0,4
0,5
clases
prioridad
/H9261
/H11005
/H92612
ts2
/H11005
/H11003
ts1
Tiempo
respuesta
normalizado
Tr
Ts
0,6
0,7
0,8
0,9
1,0
prioridad
Prioridad
Prioridad
expulsión
Utilización
/H9267
Figura
9.11
Tiempo
respuesta
normalizado
0,1
10
0,2
0,3
0,4
0,5
Utilización
clases
prioridad
l2
ts2
ts1
Tiempo
respuesta
normalizado
Tr1
Ts1
0,6
0,7
0,8
0,9
1,0
prioridad
Prioridad
Prioridad
expulsión
Figura
9.12
Tiempo
respuesta
normalizado
procesos
cortos
09-Capitulo
12/5/05
16:24
Página
423joras
significativas
ejecuta
sistema
utilizando
planificación
prioridades
expulsión
mejoras
significativas
utiliza
expulsión
Figura
9.13
muestra
análisis
procesos
menor
prioridad
tamaño
cabe
esperar
procesos
sufren
degradación
rendimiento
planificaciones
prioridad
Modelos
simulación
dificultades
modelo
analítico
superar
simulación
discreta
casos
permite
modelar
amplio
rango
políticas
desventaja
simulación
resultados
determinada
ejecución
aplicar
particular
colección
procesos
conjunto
particular
suposiciones
pue-
den
obtener
resultados
útiles
FINK88
encontrar
resultados
estudios
simulación
consta
50.000
procesos
tasa
llegada
0,8
tiempo
servicio
forma
supone
utilización
procesador
lTs
0,8
midiendo
so-
lamente
punto
utilización
presentar
resultados
agrupan
procesos
percentiles
tiempo
servicio
500
procesos
forma
500
procesos
menor
tiempo
servicio
percentil
eliminados
restantes
500
pro-
cesos
menor
tiempo
servicio
incluyen
percentil
sucesivamente
permite
efecto
diversas
políticas
función
longitud
proceso
Figura
9.14
muestra
tiempo
estancia
normalizado
Figura
9.15
muestra
tiempo
espera
Mirando
tiempo
estancia
observar
rendimiento
FCFS
desfavorable
procesos
tiempo
estancia
10
tiempo
servicio
procesos
cortos
tiempo
espera
ab-
soluto
uniforme
esperar
planificación
independiente
tiempo
ser-
424
Sistemas
operativos
Aspectos
internos
principios
diseño
0,1
10
0,2
0,3
0,4
0,5
Utilización
/H9267
clases
prioridad
/H9261
/H11005
/H92612
ts2
/H11005
/H11003
ts1
Tiempo
respuesta
normalizado
Tr2
Ts2
0,6
0,7
0,8
0,9
1,0
Prioridad
Prioridad
expulsión
prioridad
Figura
9.13
Tiempo
respuesta
normalizado
procesos
largos
09-Capitulo
12/5/05
16:24
Página
424Planificación
uniprocesador
425
Percentil
tiempo
requerido
Tiempo
estancia
normalizado
FCFS
FCFS
HRRN
HRRN
SPN
RR
RR
FB
FB
SRT
SRT
SPN
10
100
10
20
30
40
50
60
70
80
90
100
Figura
9.14
Resultados
simulación
tiempo
estancia
normalizado
Percentil
tiempo
requerido
Tiempo
espera
FCFSFCFS
HRRN
HRRN
RR
RR
FB
FB
SRT
SPN
SPN
10
20
30
40
50
60
70
80
90
100
10
Figura
9.15
Resultados
simulación
tiempo
espera
09-Capitulo
12/5/05
16:24
Página
425vicio
figuras
muestran
planificación
rotatoria
rodaja
unidad
tiempo
procesos
cortos
ejecutan
rodaja
planificación
rota-
toria
tiempo
estancia
normalizado
procesos
tratando
forma
justa
proceso
corto
funciona
planificación
turno
rotatorio
procesos
cortos
menor
tiempo
restante
versión
expulsiva
SPN
funciona
me-
jor
SPN
7%
procesos
largos
visto
políticas
expulsivas
FCFS
favorece
procesos
largos
SPN
favorece
cortos
tasa
respuesta
intenta
compromiso
efectos
realmente
con-
firma
figuras
figura
muestra
planificación
retroalimentación
rodajas
fijas
uniformes
cola
prioridad
esperar
FB
funciona
procesos
cortos
PLANIFICACIÓN
CONTRIBUCIÓN
JUSTA
FAIR-SHARE
SCHEDULING
algoritmos
planificación
discutidos
momento
tratan
colección
procesos
listos
simple
conjunto
procesos
seleccionar
ejecutar
con-
procesos
romper
prioridades
homogéneo
sistema
multiusuario
aplicaciones
trabajos
usuario
or-
ganizar
múltiples
procesos
hilos
estructura
colección
procesos
reconoce
planificadores
tradicionales
punto
vista
usuario
preocupación
ejecuta
simple
proceso
ejecutan
conjunto
procesos
forman
aplicación
forma
deseable
tomar
decisiones
planificación
basándose
con-
juntos
procesos
enfoque
conoce
normalmente
planificación
contribución
justa
concepto
extender
grupo
usuarios
usuario
representa
proceso
ejemplo
sistema
tiempo
compartido
podríamos
querer
considerar
usuarios
determinado
departamento
miembros
grupo
tomar
decisiones
planificación
intentando
grupo
servicio
similar
forma
usuarios
departamento
meten
sistema
gustaría
tiempo
respuesta
degrada
miembros
departamento
usuarios
departamentos
término
contribución
justa
indica
filosofía
planificador
usua-
rio
asigna
prima
tipo
define
participación
usuario
recursos
sis-
tema
fracción
dichos
recursos
particular
usuario
asigna
rodaja
procesador
esquema
debería
operar
forma
lineal
usuario
doble
prima
usuario
ejecución
larga
usuario
debería
capaz
doble
trabajo
usuario
B.
objetivo
planificador
contribución
justa
controlar
menores
recursos
usuarios
excedido
contribución
justa
mayores
recursos
llegado
serie
propuestas
planificadores
contribución
justa
HENR84
KAY88
WOOD86
sección
describe
esquema
propuesto
HENR84
implementado
diversos
sistemas
UNIX
sistema
denomina
FSS
Fair
Share
Schedu-
ler
FSS
histórico
ejecución
grupo
procesos
relacionados
histó-
rico
ejecución
procesos
tomar
decisiones
planificación
sistema
di-
vide
comunidad
usuarios
conjunto
grupos
destina
fracción
procesador
grupo
forma
grupos
25%
procesador
grupo
proporciona
sistema
virtual
ejecuta
lento
sistema
completo
planificación
realiza
base
prioridad
prioridad
proceso
reciente
procesador
reciente
procesador
grupo
pertenece
proceso
426
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
426sea
valor
numérico
prioridad
menor
prioridad
fórmula
aplica
pro-
ceso
grupo
CPUj(i
Medida
utilización
procesador
proceso
intervalo
GCPUk(i
Medida
utilización
procesador
grupo
intervalo
Pj(i
Prioridad
proceso
comienzo
intervalo
valores
pequeños
equivalen
prioridades
altas
Basej
Prioridad
base
proceso
Wk
Prima
asignada
grupo
restricción
proceso
asigna
prioridad
base
prioridad
proceso
disminuye
medida
proceso
utiliza
procesador
medida
grupo
pertenece
proceso
utiliza
pro-
cesador
caso
utilización
grupo
normaliza
media
dividiendo
peso
grupo
peso
asignado
grupo
utilización
afectará
prioridad
Figura
9.16
ejemplo
proceso
grupo
procesos
grupo
grupo
prima
0,5
asume
procesos
limi-
tados
procesador
normalmente
listos
ejecutar
procesos
prio-
ridad
base
60
utilización
procesador
mide
procesador
inte-
rrumpe
60
interrupción
incrementa
campo
procesador
proceso
actualmente
ejecución
campo
grupo
correspondiente
prioridades
recalculan
figura
planifica
proceso
A.
expulsa
pro-
cesos
prioridad
planifica
proceso
B.
uni-
dad
tiempo
proceso
prioridad
Fijarse
repite
patrón
núcleo
pla-
nifica
procesos
orden
sucesivamente
forma
50%
procesador
destina
proceso
constituye
grupo
50%
procesos
constituyen
grupo
9.3
PLANIFICACIÓN
UNIX
TRADICIONAL
sección
examinamos
planificación
tradicional
UNIX
utiliza
UNIX
SVR3
4.3
BSD
UNIX
sistemas
orientados
entornos
interactivos
tiempo
comparti-
do
algoritmo
planificación
diseñado
proporcionar
tiempos
respuesta
usuarios
interactivos
asegura
trabajos
fondo
background
baja
prioridad
sufran
inanición
sistema
reemplazado
sistemas
UNIX
modernos
me-
rece
pena
examinarlo
representativo
algoritmos
prácticos
planificación
tiem-
01
1<£
ÂWy
Wkk
CPU
CPU
GCPU
GCPU
Pi
CPU
GCPU
jj
24Base
Planificación
uniprocesador
427
09-Capitulo
12/5/05
16:24
Página
427po
compartido
esquema
planificación
SVR4
incluye
adaptación
requisitos
tiem-
po
real
verá
Capítulo
10
planificador
UNIX
tradicional
emplea
retroalimentación
multinivel
utiliza
planificación
turno
rotatorio
colas
prioridad
sistema
expulsión
segun-
428
Sistemas
operativos
Aspectos
internos
principios
diseño
Prioridad
rectángulo
coloreado
representa
proceso
ejecución
60
60
60
74
15
16
17
75
15
16
17
75
78
18
19
20
78
18
19
20
78
67
60
15
16
17
75
74
15
15
16
17
75
60
60
60
60
90
30
30
96
37
37
98
39
39
70
18
76
15
18
90
30
30
79
33
03
75
30
60
Contador
CPU
proceso
Proceso
Grupo
Grupo
Tiempo
60
60
Contador
CPU
grupo
Proceso
Proceso
Prioridad
Prioridad
Contador
CPU
proceso
Contador
CPU
grupo
Contador
CPU
proceso
Contador
CPU
grupo
Figura
9.16
Ejemplo
planificación
contribución
justa
procesos
grupos
09-Capitulo
12/5/05
16:24
Página
428do
proceso
bloquea
completa
expulsado
prioridad
basada
tipo
proceso
histórico
ejecución
aplican
siguientes
fórmulas
CPUj(i
Medida
utilización
procesador
proceso
intervalo
Pj(i
Prioridad
proceso
comienzo
intervalo
valores
pequeños
equivalen
prioridades
altas
Basej
Prioridad
base
proceso
ajustej
Factor
ajuste
controlable
usuario
prioridad
proceso
recalcula
momento
realiza
decisión
planificación
propósito
prioridad
base
dividir
procesos
bandas
fijas
niveles
prioridad
componentes
CPU
ajuste
limitan
impedir
procesos
migren
banda
asignada
asignada
nivel
prioridad
base
bandas
utili-
zan
optimizar
acceso
dispositivos
bloques
ejemplo
disco
permitir
sistema
operativo
responder
rápidamente
llamadas
sistema
orden
decreciente
prioridad
bandas
Intercambiador
swapper
Control
dispositivos
bloque
Manipulación
ficheros
Control
dispositivos
orientados
carácter
Procesos
usuario
jerarquía
debería
proporcionar
eficiente
dispositivos
S.
banda
procesos
usuario
histórico
ejecución
tiende
penalizar
procesos
limita-
procesador
costa
procesos
limitados
S.
debería
mejorar
eficiencia
esquema
expulsivo
cíclico
estrategia
planificación
diseñada
satisfacer
requerimientos
tiempo
compartido
propósito
general
Figura
9.17
muestra
ejemplo
planificación
procesos
procesos
crean
tiempo
prioridad
base
60
ignoraremos
valor
ajuste
reloj
interrum-
pe
sistema
60
incrementa
contador
proceso
ejecución
ejem-
plo
supone
procesos
bloquea
proceso
listo
ejecutar
Compárese
Figura
9.16
9.4
RESUMEN
sistema
operativo
tipos
decisiones
planificación
ejecución
procesos
planificación
plazo
determina
admiten
procesos
sistema
planificación
plazo
función
intercambio
determina
programa
CPU
CPU
Pi
CPU
juste
jj
2Base
Planificación
uniprocesador
429
09-Capitulo
12/5/05
16:24
Página
429trae
parcial
totalmente
memoria
principal
ejecutado
planificación
corto
plazo
determina
proceso
listo
ejecutado
procesador
capítulo
centra
as-
pectos
relativos
planificación
corto
plazo
diseño
planificador
corto
plazo
serie
criterios
Al-
gunos
criterios
relacionados
comportamiento
sistema
percibe
usuario
orientados
usuario
miran
efectividad
sistema
satis-
facer
necesidades
usuarios
orientados
sistema
criterios
relacionan
es-
pecíficamente
medidas
cuantitativas
rendimiento
naturaleza
cualitativa
punto
vista
usuario
tiempo
respuesta
generalmente
caracterís-
tica
importante
sistema
punto
vista
sistema
importantes
rendimiento
utilización
procesador
430
Sistemas
operativos
Aspectos
internos
principios
diseño
Prioridad
60
60
60
075
30
67
15
75
30
67
15
68
16
76
33
76
33
67
15
75
30
060
Contador
CPU
Proceso
Tiempo
60
60
60
60
60
63
67
63
63
67
Prioridad
Contador
CPU
Prioridad
Contador
CPU
Proceso
Proceso
rectángulo
coloreado
representa
proceso
ejecución
Figura
9.17
Ejemplo
planificación
tradicional
procesos
UNIX
09-Capitulo
12/5/05
16:24
Página
430Se
desarrollado
algoritmos
tomar
decisiones
planificación
corto
plazo
procesos
listos
ejecutar
llegar
servirse
Selecciona
proceso
tiempo
es-
perando
servicio
Turno
rotatorio
Utiliza
rodajas
tiempo
limitar
procesos
ejecución
pe-
queña
ráfaga
tiempo
ejecución
rota
procesos
listos
proceso
corto
Selecciona
proceso
menor
tiempo
procesamiento
esperado
expulsa
procesos
Menor
tiempo
restante
Selecciona
proceso
menor
tiempo
procesamiento
restan-
esperado
proceso
expulsado
proceso
pasa
listo
tasa
respuesta
Basa
decisión
planificación
estimación
tiempo
estancia
normalizado
Retoalimentación
Establece
conjunto
colas
planificación
sitúa
procesos
colas
basándose
historia
ejecución
criterios
elección
algoritmo
planificación
dependerá
rendimiento
esperado
compleji-
dad
implementación
9.5
LECTURAS
RECOMENDADAS
Prácticamente
libros
texto
sistemas
operativos
cubren
planificación
KLEI04
CONW67
presentan
rigurosos
análisis
colas
políticas
planificación
DOWD93
proporciona
análisis
rendimiento
instructivo
algoritmos
planificación
CONW67
Conway
R.
Maxwell
W.
Miller
L.
Theory
of
Scheduling
Reading
MA
Addison-Wesley
1967
Reprinted
by
Dover
Publications
2003
DOWD93
Dowdy
L.
Lowery
C.
.S.
to
Operating
Systems
Upper
Saddle
River
NJ
Prentice
Hall
1993
KLEI04
Kleinrock
L.
Queuing
Systems
Volume
Three
Computer
Applications
New
York
Wiley
2004
9.6
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
Activador
llegar
Tiempo
estancia
Equidad
servirse
FCFS
Tiempo
respuesta
Planificación
corto
plazo
Previsibilidad
Tiempo
residencia
Planificación
plazo
Promedio
exponencial
Tiempo
servicio
Planificación
plazo
Rendimiento
Turno
rotatorio
Planificación
prioridades
Retroalimentación
multinivel
Utilización
Planificación
contribución
justa
Rodajas
tiempo
entrar
Tasa
llegada
salir
FIFO
Tiempo
espera
Planificación
uniprocesador
431
09-Capitulo
12/5/05
16:24
Página
431CUESTIONES
REPASO
9.1
Describa
brevemente
tipos
planificación
procesos
9.2
normalmente
requisito
rendimiento
crítico
sistema
operativo
inte-
ractivo
9.3
diferencia
tiempo
estancia
tiempo
respuesta
9.4
planificación
procesos
valor
prioridad
representa
prioridad
baja
prioridad
alta
9.5
diferencia
planificación
expulsiva
expulsiva
9.6
Defina
brevemente
planificación
FCFS
9.7
Defina
brevemente
planificación
turno
rotatorio
9.8
Defina
brevemente
planificación
proceso
corto
9.9
Defina
brevemente
planificación
menor
tiempo
restante
9.10
Defina
brevemente
planificación
tasa
respuesta
9.11
Defina
brevemente
planificación
retroalimentación
PROBLEMAS
9.1
Considere
conjunto
procesos
Nombre
proceso
Tiempo
llegada
Tiempo
proceso
A03
B15
C32
D95
E1
25
Realice
análisis
Tabla
9.5
Figura
9.5
conjunto
9.2
Repita
Problema
9.1
conjunto
datos
Nombre
proceso
Tiempo
llegada
Tiempo
proceso
A01
B19
C21
D39
9.3
Demuestre
algoritmos
planificación
expulsivos
SPN
proporciona
mínimo
tiempo
espera
conjunto
trabajos
llega
tiempo
Asuma
planificador
ejecutar
tarea
disponible
432
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
4329.4
Suponga
patrón
ráfagas
proceso
13
13
13
asuma
conjetura
inicial
10
Realice
dibujo
similar
Figura
9.9
9.5
Considere
par
fórmulas
alternativa
Ecuación
9.3
Sn+1
aTn
a)Sn
Xn+1
min[Ubound
max[Lbound
bSn+1
Ubound
Lbound
límites
superior
inferior
preelegidos
valor
estima-
do
T.
utiliza
valor
n+1
lugar
valor
Sn+1
algoritmo
pro-
ceso
corto
función
realizan
efecto
mayores
menores
va-
lores
9.6
ejemplo
Figura
9.5
proceso
ejecuta
unidades
tiempo
pase
control
proceso
B.
escenario
ejecutara
unida-
des
tiempo
pase
control
proceso
B.
variaciones
política
algoritmo
planificación
retroalimentación
tendrían
posibles
escenarios
9.7
sistema
uniprocesador
expulsivo
cola
listos
contiene
trabajos
instan-
inmediatamente
finalización
trabajo
trabajos
llegaron
tiempos
t2
t3
tiempos
estimados
ejecución
r1
r2
r3
respectivamente
Figura
9.18
muestra
incremento
lineal
tasas
respuesta
tiempo
Utilice
ejemplo
encontrar
variante
planificación
tasa
respuesta
conocida
planificación
tasa
respuesta
minimax
minimice
máxima
tasa
respuesta
conjunto
trabajos
ignorando
futuras
llegadas
Sugerencia
decida
trabajo
planificar
9.8
Demuestre
algoritmo
tasa
respuesta
minimax
problema
minimiza
máxima
tasa
respuesta
lote
trabajos
Sugerencia
centre
atención
trabajo
tasa
respuesta
trabajos
ejecutados
Considere
subconjunto
trabajos
planificados
orden
observe
tasa
respuesta
trabajo
ejecuta
lugar
Observe
subconjun-
to
debería
mezclado
trabajos
conjunto
Planificación
uniprocesador
433
t1
t2
r1
t3
t4
Tiempo
Tasa
respuesta
r2
r3
Figura
9.18
Tasa
respuesta
función
tiempo
09-Capitulo
12/5/05
16:24
Página
4339.9
Defina
tiempo
residencia
tiempo
proceso
pasa
esperan-
do
atendido
Muestre
FIFO
tiempo
servicio
Ts
Tr
Ts
/(1-
utilización
9.10
multiplexa
sobrecarga
procesador
velocidad
infinita
procesos
presentes
cola
listos
modelo
idealizado
planificación
cí-
clica
procesos
listos
utilizando
rodajas
tiempo
pequeñas
compara-
ción
tiempo
servicio
Muestre
entradas
Poisson
fuente
infinita
tiempos
servicio
exponenciales
tiempo
respuesta
pro-
ceso
tiempo
servicio
viene
Rx
x/(1-
Sugerencia
revise
ecuacio-
nes
básicas
colas
documento
Análisis
Colas
WilliamsStallings.com/Stu-
dentSupport.html
continuación
considere
número
elementos
esperando
sistema
llega
proceso
9.11
planificaciones
turno
rotatorio
utilizan
rodaja
tiempo
fija
argumento
favor
rodajas
pequeñas
argumento
favor
ro-
dajas
Compare
contraste
tipos
sistema
trabajos
aplican
argumentos
sistemas
trabajos
tamaños
razonables
9.12
sistema
colas
trabajos
esperar
atendidos
trabajo
espera
prioridad
incrementa
forma
lineal
tiempo
empezando
cero
tasa
a.
trabajo
espera
prioridad
alcanza
prioridad
trabajos
atendidos
continuación
comienza
compartir
procesador
resto
trabajos
forma
cíclica
prioridad
continúa
incrementando
tasa
menor
algoritmo
denomina
turno
rotatorio
egoísta
trabajos
inten-
vano
monopolizar
procesador
incrementando
forma
constante
prioridad
Utilice
figura
9.19
demostrar
tiempo
respuesta
trabajo
tiempo
servicio
viene
asumiendo
tiempos
llegada
servicio
distribuciones
exponenciales
me-
respectivamente
Sugerencia
considere
sistema
global
subsiste-
forma
separada
9.13
sistema
interactivo
planificación
rotatoria
intercambio
intenta
respuesta
pe-
ticiones
sencillas
completar
turno
rotatorio
to-
procesos
listos
sistema
determina
rodaja
tiempo
asignar
proceso
listo
turno
dividiendo
tiempo
máximo
respuesta
número
proceso
requieren
atendidos
política
razonable
9.14
tipo
proceso
favorece
normalmente
planificación
colas
retroalimenta-
das
multinivel
procesos
limitados
procesador
procesos
limitados
Explique
brevemente
9.15
proceso
planificación
basado
prioridades
planificador
pasa
control
proceso
determinado
proceso
prioridad
lis-
to
Asuma
utiliza
información
adicional
proceso
decisión
Asu-
rl
ba=
ËÁ
¯˜
10
sx
¢11
rr
434
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
434ma
prioridades
procesos
establecen
momento
creación
proceso
cambian
sistema
funcione
supuestos
peligroso
Solución
Dekker
véase
Sección
A.1
problema
exclusión
mutua
Explíquelo
justificando
evento
deseable
suceder
suceder
9.16
trabajos
lotes
llegan
centro
computación
tiem-
po
tiempos
estimados
ejecución
15
12
minutos
respectivamente
prioridades
definidas
externamente
respectivamente
va-
lores
menores
correspondiendo
prioridades
mayores
siguientes
algoritmos
planificación
determine
tiempo
estancia
proceso
tiem-
po
estancia
trabajos
Ignore
tiempo
intercambio
proce-
sos
Explique
llega
respuestas
casos
asuma
eje-
cuta
trabajo
termina
trabajos
totalmente
limitados
procesador
Planificación
turno
rotatorio
rodaja
minuto
Planificación
prioridades
FCFS
ejecutan
orden
15
12
proceso
corto
APÉNDICE
9A
TIEMPO
RESPUESTA
tiempo
respuesta
tiempo
sistema
reaccionar
frente
determinada
entra-
transacción
interactiva
definir
tiempo
pulsación
tecla
usuario
comienzo
visualización
resultados
computa-
dor
tipos
aplicaciones
definiciones
general
tiempo
sistema
responder
petición
determinada
tarea
Planificación
uniprocesador
435
Trabajos
esperando
H11032
H11032
aa
Trabajos
servidos
Tiempo
Prioridad
Salidas
Figura
9.19
Planificación
turno
rotatorio
egoísta
09-Capitulo
12/5/05
16:24
Página
435De
forma
ideal
gustaría
tiempo
respuesta
aplicación
corto
em-
bargo
forma
fija
menores
tiempos
respuesta
implican
mayores
costes
costes
vienen
partes
Potencia
computación
rápido
procesador
menor
tiempo
respuesta
incrementar
potencia
computación
significa
incrementar
costes
Requisitos
competencia
Proporcionar
tiempo
respuesta
rápida
procesos
penalizar
procesos
forma
llegar
compromiso
nivel
tiempo
respuesta
coste
conlleva
Tabla
9.7
basada
MART88
enumera
rangos
tiempos
respuesta
enfrentar
dificultades
diseño
requiere
tiempo
respuesta
menor
sistemas
controlan
interactúan
actividad
externa
cadena
montaje
requisito
tiempos
respuesta
consideramos
inte-
racción
hombre-máquina
aplicación
entrada
datos
dominio
tiempos
respuesta
conversacionales
caso
existiendo
requisito
tiempos
cortos
respuesta
difícil
evaluar
longitud
tiempo
aceptable
abla
9.7
.Rangos
tiempos
respuesta
Mayores
15
segundos
descarta
interacciones
conversacionales
determinado
tipo
aplicaciones
tipo
usuarios
importaría
esperar
15
segundos
respuesta
per-
sona
ocupada
cifra
intolerable
tiempos
diseñar
sistema
for-
ma
usuario
cambiar
actividades
mire
respuesta
Mayores
segundos
normalmente
largos
conversación
operador
mantener
memoria
información
retardos
dificultan
solución
problemas
frustran-
tes
actividades
entrada
datos
conclusión
actividad
principal
finalizar
transacción
retardos
tolerables
segundos
retrasos
dificultar
operaciones
terminal
requieren
alta
concentra-
ción
Esperar
segundos
terminal
resultar
sorprendentemente
usuario
absorto
tarea
realizando
aceptar
retardo
rango
conclusión
actividad
menor
segundos
usuario
terminal
recordar
información
respuestas
tiem-
po
respuesta
corto
detalle
información
recordar
necesi-
dad
tiempos
respuesta
menores
segundos
actividades
elaboradas
terminal
se-
gundos
representan
límite
tiempo
importante
Tiempos
respuesta
tipos
trabajos
requieren
concentración
especialmente
aplicaciones
grá-
ficas
requieren
tiempos
respuesta
cortos
mantener
interés
atención
usuario
largos
periodos
tiempo
Tiempos
respuesta
décima
Actividades
presionar
tecla
carácter
pantalla
seleccionar
elemento
pantalla
instantáneas
0,1
segundos
acción
interacción
ratón
requiere
interacciones
extremadamente
rápidas
436
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
436La
clave
productividad
aplicaciones
interactivas
tiempo
respuesta
rápido
confirmado
diversos
estudios
SHNE84
THAD81
GUYN88
estudios
muestran
ordenador
usuario
interactúan
forma
asegure
esperar
productividad
incrementa
significativamente
coste
trabajos
realizados
computador
reduce
calidad
tiende
mejorar
Solía
ampliamente
aceptado
tiempos
respuesta
relativamente
lentos
segundos
aceptables
aplicacio-
nes
interactivas
persona
pensando
tarea
aho-
ra
productividad
incrementa
logran
tiempos
respuesta
rápidos
resultados
obtenidos
tiempos
respuesta
basados
análisis
transac-
ciones
on-line
transacción
consiste
mandato
usuario
terminal
incluyendo
respuesta
sistema
dividir
secuencias
tiempo
Tiempo
respuesta
usuario
tiempo
transcurre
usuario
recibe
res-
puesta
completa
mandato
introduce
mandato
gente
suele
refe-
rirse
tiempo
tiempo
pensar
Tiempo
respuesta
sistema
tiempo
transcurre
usuario
introduce
mandato
respuesta
completa
presenta
terminal
ejemplo
efecto
reducir
tiempo
respuesta
sistema
Figura
9.20
muestra
resultados
estudio
llevado
cabo
ingenieros
utilizan
programa
diseño
asistido
computador
diseño
circuitos
integrados
tarjetas
SMIT83
transacción
consiste
mandato
altera
forma
gráfico
mostrado
pantalla
resultado
muestra
número
transacciones
incrementa
medida
tiempo
respuesta
sistema
disminuye
aumenta
drásticamente
tiempo
respuesta
sistema
cae
sucede
medida
reduce
tiempo
respuesta
sistema
tiempo
respuesta
usuario
relacionado
efecto
memoria
corto
plazo
atención
humana
Planificación
uniprocesador
437
Transacciones
usuario-hora
4000
3500
3000
2500
2000
1500
1000
500
1,50
Experto
Novato
Tiempo
respuesta
sistema
segundos
0,25
0,50
0,75
1,00
1,25
Figura
9.20
Resultados
tiempo
respuesta
funciones
gráficas
complejas
09-Capitulo
12/5/05
16:24
Página
437Otra
área
tiempo
respuesta
volviendo
crítico
Web
Internet
intranet
tiempo
página
web
aparezca
pantalla
usuario
variar
tiempos
respuesta
medir
función
nivel
participación
usuario
sesión
particular
sistemas
tiempos
respuesta
rápidos
tienden
cen-
trar
atención
usuario
muestra
Figura
9.21
SEVC96
sistemas
web
tiempo
respuesta
menor
segundos
mantienen
alto
nivel
atención
usua-
rio
Figura
9.21
indica
SEVC96
sistemas
web
tiempos
respuesta
segundos
mantienen
alto
nivel
atención
usuario
tiempo
respuesta
10
se-
gundos
pierde
concentración
tiempo
respuesta
10
segundos
desmoraliza
usuario
cancela
sesión
APÉNDICE
9B
SISTEMAS
COLAS
capítulo
capítulos
posteriores
utiliza
teoría
colas
apéndice
presenta
definición
sistemas
colas
definen
conceptos
clave
lectores
estén
familiarizados
sistemas
colas
introducción
básica
Sitio
Computer
Science
Student
Resource
WilliamStallings.com/StudentSupport.html
ANÁLISIS
COLAS
necesario
pronósticos
rendimiento
función
carga
existente
fun-
ción
carga
esperada
entorno
posibles
enfoques
análisis
posterior
basándose
valores
actuales
pronóstico
sencillo
extrapolando
valores
conocidos
entorno
esperado
futuro
438
Sistemas
operativos
Aspectos
internos
principios
diseño
01
303
Tiempo
segundos
Rápido
interacción
Cambiar
canal
TV
servicio
cable
Tiempo
conexión
llamadas
Unidos
Verificación
tarjetas
crédito
puntos
venta
Establecer
conexión
modem
28,8
Kbps
Ejecutar
operación
bolsa
York
Lento
Concentración
usuario
web
tiempos
respuesta
Figura
9.21
Requisitos
tiempos
respuesta
09-Capitulo
12/5/05
16:24
Página
4383
Desarrollar
modelo
analítico
basado
sistema
colas
Programar
ejecutar
modelo
simulación
opción
opción
absoluto
esperar
sucede
genera
usuarios
infelices
compras
imprudentes
opción
prometedora
analista
tomar
posición
imposible
predecir
demanda
futura
grado
certeza
merece
pena
intentar
modelado
exacto
contrario
pronóstico
preliminar
propor-
cionará
estimación
rango
problema
enfoque
compor-
tamiento
sistemas
carga
cambiante
intuitivamente
ca-
bría
esperar
entorno
recurso
compartido
ejemplo
red
línea
transmisión
sistema
tiempo
compartido
rendimiento
sistema
nor-
malmente
responde
forma
exponencial
incrementos
demanda
Figura
9.22
ejemplo
representativo
línea
superior
muestra
suele
suceder
tiempos
respuesta
usuarios
recurso
compartido
medida
incrementa
car-
ga
carga
expresa
fracción
capacidad
forma
trabajando
encaminador
capaz
procesar
remitir
1000
paquetes
carga
0,5
representa
tasa
llegada
500
paquetes
tiempo
respuesta
canti-
dad
tiempo
retransmitir
paquete
entrante
línea
inferior
pronóstico
simple
basado
conocimiento
comportamiento
sistema
carga
0,5
impor-
Planificación
uniprocesador
439
línea
inferior
basada
ajuste
polinomio
orden
datos
disponibles
carga
0,5
12
10
Tiempo
respuesta
0,80,60,40,20,0
Carga
sistema
fracción
capacidad
Límite
experiencia
Tiempo
real
respuesta
Tiempo
pronosticado
respuesta
Figura
9.22
Tiempo
respuesta
pronosticado
frente
tiempo
respuesta
real
09-Capitulo
12/5/05
16:24
Página
439tante
pronóstico
parecía
prometedor
realidad
sistema
viene
abajo
carga
0,8
0,9
forma
necesita
herramienta
predicción
exacta
opción
consiste
ha-
cer
modelo
analítico
expresado
conjunto
ecuaciones
pue-
den
resolver
obtener
parámetros
deseados
tiempo
respuesta
rendimiento
etc.
pro-
blemas
computadores
sistemas
operativos
redes
problemas
prácticos
vida
real
modelos
analíticos
basados
teoría
colas
proporcionan
ajuste
rea-
lidad
desventaja
teoría
colas
simplificaciones
derivar
ecua-
ciones
parámetros
interés
enfoque
modelo
simulación
lenguaje
programación
simu-
lación
suficientemente
flexible
potente
analista
modelar
realidad
detalle
evitar
simplificaciones
teoría
colas
casos
necesita
modelo
simulación
aconsejable
paso
análisis
razón
medidas
existentes
pronósticos
carga
futura
conllevan
deter-
minado
margen
error
forma
importar
modelo
simulación
va-
lor
resultados
limitado
calidad
entradas
suposi-
ciones
requeridas
teoría
colas
resultados
obtenidos
cerca
obtendrían
análisis
simulación
cuidadoso
análisis
colas
reali-
zar
minutos
problemas
definidos
programar
ejecutar
ejercicio
si-
mulación
semanas
tiempo
consiguiente
necesario
analista
domine
fundamentos
teoría
colas
COLAS
SERVIDOR
Figura
9.23
representa
sistema
colas
sencillo
central
sistema
servi-
dor
proporciona
servicio
elementos
elementos
población
elementos
llegan
sistema
atendidos
servidor
ocioso
atiende
elemento
inmediata-
mente
contrario
elemento
entrante
une
línea
espera
servidor
com-
pleta
servicio
elemento
elemento
sale
elementos
esperando
cola
manda
inmediatamente
servidor
servidor
modelo
representar
cosa
realice
función
servicio
colección
elementos
Ejemplos
procesador
servi-
cio
procesos
línea
transmisión
proporciona
servicio
transmisión
paquetes
estructuras
datos
dispositivo
proporciona
servicio
lectura
escritura
pe-
ticiones
S.
Tabla
9.8
resume
parámetros
importantes
asociados
modelo
colas
elementos
llegan
determinada
tasa
media
elementos
llegan
l.
mo-
mento
determinado
número
elementos
esperando
cola
cero
nú-
mero
esperando
tiempo
elemento
esperar
w.
Tw
pondera
elementos
entrantes
incluyendo
esperar
servidor
ma-
nipula
elementos
entrantes
tiempo
servicio
intervalo
tiempo
en-
tre
envío
elemento
servidor
salida
elemento
servidor
utilización
fracción
tiempo
servidor
ocupado
medida
intervalo
tiempo
Final-
mente
parámetros
sistema
global
número
elementos
residentes
siste-
440
Sistemas
operativos
Aspectos
internos
principios
diseño
literatura
línea
espera
denomina
normalmente
cola
usual
referirse
sistema
entero
cola
indique
cosa
usaremos
término
cola
referirnos
línea
espera
09-Capitulo
12/5/05
16:24
Página
440ma
incluyendo
elemento
atendido
tiempo
ele-
mento
sistema
esperando
atendido
Tr
referiremos
tiempo
residencia9
asumimos
capacidad
cola
infinita
pierde
elemento
sistema
simplemente
retrasan
atendidos
circunstancias
tasa
salida
iguala
tasa
entrada
medida
incrementa
tasa
entrada
utilización
incrementa
congestión
cola
vuelve
incrementándose
tiempo
espera
servidor
satura
trabajando
100%
tiempo
forma
tasa
máxima
entrada
teórica
gestionada
sistema
lmax
Ts
Planificación
uniprocesador
441
literatura
palabra
denomina
tiempo
cola
entiende
tiempo
cola
tiempo
gastado
esperando
cola
atendido
Llegadas
Línea
espera
cola
Disciplina
envío
Servidor
Salidas
/H11005
elementos
esperando
Tw
/H11005
tiempo
espera
Ts
/H11005
tiempo
servicio
/H11005
utilización
/H11005
Tasa
llegada
/H11005
elementos
residentes
sistema
colas
Tr
/H11005
tiempo
residencia
Figura
9.23
Estructura
sistema
colas
parámetros
cola
servidor
tasa
llegada
número
llegadas
Ts
tiempo
servicio
llegada
tiempo
servicio
atendido
contar
tiempo
espera
cola
utilización
fracción
tiempo
instalaciones
servidor
servidores
ocupados
número
elementos
esperando
atendidos
Tw
tiempo
espera
incluye
elementos
esperar
elementos
tiempo
espera
número
elementos
residentes
sistema
esperando
atendidos
Tr
tiempo
residencia
tiempo
elemento
pasa
sistema
esperando
sien-
do
atendido
abla
9.8
Notación
sistemas
colas
09-Capitulo
12/5/05
16:24
Página
441Sin
colas
largas
saturando
sistema
creciendo
lí-
mites
Consideraciones
prácticas
tales
requisitos
tiempo
respuesta
tamaño
buffers
normalmente
limitan
tasa
entrada
servidor
70
90%
máximo
teórico
suelen
siguientes
suposiciones
Tamaño
población
forma
característica
asume
tamaño
infinito
pobla-
ción
significa
tasa
llegada
altera
pérdida
población
pobla-
ción
finita
población
disponible
llegada
reduce
número
elemen-
tos
actualmente
sistema
normalmente
reduce
tasa
llegada
proporcionalmente
Tamaño
cola
Normalmente
asume
tamaño
cola
infinito
forma
lí-
nea
espera
crecer
límites
cola
finita
pierdan
elemen-
tos
sistema
práctica
cola
finita
casos
cambia
sustancialmente
análisis
442
Sistemas
operativos
Aspectos
internos
principios
diseño
Cola
multiservidor
Servidor
Llegadas
Cola
Tasa
llegada
Salidas
Disciplina
envío
Múltiples
colas
servidor
Salidas
Servidor
Servidor
Servidor
Servidor
Servidor
Llegadas
Tasa
llegada
Figura
9.24
Cola
multiservidor
frente
múltiples
colas
servidor
09-Capitulo
12/5/05
16:24
Página
442•
Disciplina
envío
servidor
queda
libre
elemento
esperan-
do
decidir
elemento
enviar
enfoque
sencillo
primero-entra-
primero-sale
disciplina
normalmente
utiliza
término
cola
posibilidad
último-entrar-primero-salir
cosa
encontrar
práctica
disciplina
envío
basada
tiempo
servicio
ejemplo
nodo
intercam-
bio
paquetes
decidir
enviar
paquetes
base
corto
generar
cantidad
paquetes
salientes
minimizar
tiempo
proceso
relativo
tiempo
transmisión
desgracia
disciplinas
basadas
tiempo
servicio
difíciles
modelar
analíticamente
COLA
MULTISERVIDOR
Figura
9.24
muestra
generalización
modelo
simple
múltiples
servidores
compartiendo
cola
común
llega
elemento
servidor
disponible
envía
elemento
directamente
servidor
supone
servidores
idénticos
servidor
disponible
diferencia
servidor
eli-
ja
elemento
servidores
ocupados
empieza
formar
cola
servidor
quede
libre
envía
elemento
cola
utilizando
disciplina
envío
existente
excepción
utilización
parámetros
mostrados
Figura
9.23
utilizar
caso
multiservidor
interpretación
servidores
idénticos
en-
tonces
utilización
servidor
considerar
Nr
utilización
sistema
completo
término
normalmente
conocido
intensidad
tráfico
u.
for-
ma
utilización
máxima
teórica
100%
máxima
tasa
entrada
teórica
características
clave
escogidas
normalmente
cola
multiservidor
cola
servidor
supone
población
infinita
tamaño
infinito
cola
cola
infinita
compartida
servidores
indique
contrario
disciplina
envío
FIFO
caso
multiservidor
suponen
idénticos
servido-
res
elección
servidor
particular
elemento
esperando
efecto
tiempo
servicio
contraste
Figura
9.24b
muestra
estructura
múltiples
colas
servidor
lmax
Ts
Planificación
uniprocesador
443
09-Capitulo
12/5/05
16:24
Página
443PROYECTO
PROGRAMACIÓN
PLANIFICADOR
HOST
Sistema
Operativo
Hipotético
Pruebas
Hypothetical
Operating
System
Testbed
HOST
sistema
multiprogramado
planificador
procesos
niveles
prioridad
restricción
recursos
disponibles
finitos
Planificador
niveles
prioridad
planificador
opera
niveles
prioridad
Procesos
tiempo
real
ejecutar
inmediatamente
política
lle-
gar
servirse
FCFS
expulsando
proceso
esté
ejecución
menor
prioridad
procesos
ejecutan
completen
Procesos
normales
usuario
ejecutan
planificador
retroalimentado
ni-
veles
Figura
P2.1
quantum
tiempo
planificador
valor
quantum
tiempo
planificadores
retroalimentados
planificador
necesita
mantener
colas
envío
prioridad
tiempo
real
usuario
alimentan
lista
trabajos
planificar
lista
examina
tick
planificador
trabajos
llegado
transfieren
cola
adecuada
continuación
examinan
colas
trabajo
tiempo
real
ejecuta
finalización
expulsando
trabajo
esté
ejecutando
cola
trabajos
prioridad
tiempo
real
vacía
reactive
plani-
ficador
retroalimentado
menor
prioridad
trabajo
prioridad
usuario
cola
trabajos
usuario
ejecutar
recursos
disponibles
memoria
dispositivos
transfiere
cola
prioridad
adecuada
funcionamiento
normal
cola
retroalimentada
acepta
trabajos
nivel
máximo
prioridad
degrada
prioridad
complete
rodaja
tiempo
planificador
aceptar
trabajos
menor
prio-
ridad
cuyo
caso
inserta
cola
adecuada
política
permite
planificador
emular
444
Sistemas
operativos
Aspectos
internos
principios
diseño
LiberarCL0
Admitir
Procesador
CL1
CL2
Procesador
Procesador
Liberar
Liberar
Figura
P2.1
Planificación
retroalimentada
Niveles
09-Capitulo
12/5/05
16:24
Página
444planificador
tipo
turno
rotatorio
Figura
P2.2
aceptan
trabajos
menor
priori-
dad
finalizado
trabajos
listos
prioridad
planificador
retroali-
mentado
reanuda
comenzando
continuando
proceso
encuentre
principio
cola
prioridad
esté
vacía
tick
suspende
trabajo
actual
finaliza
liberan
recursos
trabajo
listo
prioridad
flujo
lógico
deber
mostrado
Figura
P2.3
tratado
ejercicios
Restricciones
recursos
HOST
siguientes
recursos
Impresoras
Escáner
Módem
Unidades
CD
1024
Mbytes
memoria
disponible
procesos
procesos
menor
prioridad
utilizar
recursos
mo-
mento
envío
proceso
notificar
planificador
HOST
recursos
utilizará
proceso
planificador
asegura
recurso
solicitado
disponible
pro-
ceso
ciclo
vida
colas
transferencia
inicial
cola
traba-
jos
colas
prioridad
1-3
finalización
proceso
incluyendo
rodajas
tiempo
esté
ejecutando
Planificación
uniprocesador
445
Admitir
LiberarCLQ
Procesador
Figura
P2.2
Planificador
turno
rotatorio
Prioridad
Cola
tiempo
real
Cola
trabajos
usuario
Tiempo
llegada2
Tiempo
planificación
Recursos
disponibles
Lista
planificador
trabajos
Prioridad
Prioridad
Figura
P2.3
Flujo
lógico
planificador
09-Capitulo
12/5/05
16:24
Página
445Los
procesos
tiempo
real
necesitan
recurso
impresora
escáner
módem
CD
lógicamente
necesitan
asignación
memoria
trabajos
tiempo
real
requisito
memoria
menor
64Mbytes
Asignación
memoria
asignación
memoria
realizarse
bloque
contiguo
memoria
proceso
asignación
permanece
asociada
proceso
tiempo
vida
dejar
suficiente
memoria
contigua
libre
procesos
tiempo
real
que-
den
bloqueados
puedan
ejecutar
64
Mbytes
trabajo
tiempo
real
ejecución
dejan-
do
960
Mbytes
compartidos
trabajos
usuario
activos
MMU
hardware
HOST
soporta
memoria
virtual
in-
tercambio
memoria
disco
sistema
paginado
restricciones
utilizar
esquema
apropiado
asignación
memo-
ria
particiones
variables
Encaje
Encaje
Encaje
Encaje
etc.
Procesos
procesos
HOST
simulados
planificador
creando
proceso
proce-
so
planificar
proceso
genérico
suministrado
proceso
código
fuente
sig-
trap.c
ejecutar
prioridad
ejecuta
baja
prioridad
dur-
miendo
periodos
mostrando
mensaje
ID
proceso
comienza
proceso
mensaje
proceso
ejecución
mensaje
Suspende
Continúa
Finaliza
proceso
proceso
finalizará
20
segundos
finaliza
planificador
sali-
pantalla
proceso
realiza
color
seleccionado
azar
rodajas
procesos
distinguir
fácilmente
Utilice
proceso
ciclo
vida
proceso
envía
proceso
cola
entrada
planificador
lista
procesos
ini-
cial
define
tiempo
llegada
prioridad
tiempo
procesador
requerido
se-
gundos
tamaño
bloque
memoria
recursos
solicitados
proceso
listo
ejecutar
llegado
recursos
solicitados
disponibles
trabajos
tiempo
real
pendientes
envían
ejecución
política
llegar
servirse
FCFS
recursos
disponibles
suficientes
memoria
proceso
usuario
menor
prioridad
transfiere
proceso
cola
prioridad
adecuada
actualizan
indica-
dores
recursos
restantes
lista
memoria
dispositivos
comienza
trabajo
fork
exec(“proceso
planificador
mostrará
parámetros
trabajo
ID
proceso
prioridad
tiempo
restante
procesador
segundos
posición
memoria
tamaño
bloque
recursos
solicitados
exec
permite
ejecutar
proceso
tiempo
real
finalice
momento
planificador
mata
mandándole
señal
SIGINT
permite
ejecutar
trabajo
usuario
baja
prioridad
tick
planificador
momento
suspende
SIGTSTP
finaliza
SIGINT
tiempo
446
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
446
finalizado
suspende
baja
prioridad
sitúa
cola
adecua-
prioridad
muestra
Figuras
P2.1
P2.3
mantener
sincroniza-
ción
salida
planificador
proceso
hijo
planificador
esperar
proceso
responda
señal
SIGTSTP
SIGINT
continuar
waitpid(p->pid
sta-
WUNTRACED
rendimiento
mostrado
políticas
planificación
Figura
9.5
trabajo
usuario
suspender
mover
menor
prioridad
proceso
esperando
re)iniciado
estén
pendientes
trabajos
tiempo
real
prioridad
inicia
rei-
nicia
proceso
pendiente
prioridad
colas
retroalimentadas
SIGCONT
finaliza
proceso
recursos
utilizó
devuelven
planificador
asignación
recursos
10
procesos
lista
entrada
cola
entrada
colas
retroali-
mentadas
finaliza
planificador
Lista
planificación
Lista
planificación
lista
procesos
procesar
planificador
lista
reside
fichero
texto
especifica
línea
mandatos
ejemplo
hostd
listaplanif
línea
lista
describe
proceso
siguientes
datos
separados
comas
tiempo
llegada
prioridad
tiempo
procesador
Mbytes
impresoras
escáneres
módems
CDs
forma
12
64
12
128
13
128
indicaría
trabajo
Tiempo
llegada
12
prioridad
tiempo
real
requiere
tiempo
procesador
64
Mbytes
memoria
requiere
recursos
S.
trabajo
Tiempo
llegada
12
prioridad
máxima
prioridad
trabajo
usuario
re-
segundos
tiempo
procesador
128
Mbytes
memoria
impresora
unidad
CD
ercer
trabajo
Tiempo
llegada
13
prioridad
mínima
prioridad
trabajo
usuario
requie-
re
segundos
tiempo
procesador
128
Mbytes
memoria
impresora
módem
unidades
CD
fichero
texto
longitud
contenido
máximo
1000
trabajos
Finalizará
marca
end-of-line
final-de-línea
seguida
end-of-file
final-de-fichero
ejercicios
describen
listas
entrada
planificador
comprobar
funciona-
miento
características
listas
similares
pruebas
pasar
planificador
evaluación
espera
funcionamiento
exactamente
descrito
ejercicios
Obviamente
planificador
verificado
combinaciones
complejas
Planificación
uniprocesador
447
09-Capitulo
12/5/05
16:24
Página
447Durante
curso
dispondrá
planificador
totalmente
funcional
caso
duda
forma
funcionar
planificador
formato
salida
utilizar
programa
verificar
espera
funcione
planificador
Requisitos
proyecto
Diseñe
planificador
satisfaga
criterios
mencionados
documento
formal
diseño
Describa
justifique
algoritmos
asignación
memoria
utilizado
justifique
decisión
Describa
justifique
estructuras
utilizadas
planificador
colas
planifica-
ción
asignación
memoria
recursos
Describa
justifique
estructura
general
programa
comentando
módulos
principales
funciones
espera
descripción
interfaces
funciones
Justifique
utilizar
esquema
planificación
multinivel
comparán-
dolo
esquemas
utilizados
sistemas
operativos
reales
Resuma
desventajas
esquema
sugiera
posibles
soluciones
Incluya
justificación
esquemas
asignación
memoria
recursos
espera
documento
formal
justificaciones
descripciones
argumentaciones
exhaustivas
documento
diseño
entregar
impreso
documento
diseño
incluir
código
fuente
Implemente
planificador
utilizando
lenguaje
C.
código
fuente
extensamente
comentado
apropiadamente
estructurado
permi-
tiendo
colegas
comprenderlo
darle
mantenimiento
código
comentado
propie-
dad
alineado
fácil
interpretar
interesa
persona
evaluar
código
entenderlo
facilidad
necesidad
gimnasia
mental
detalles
envío
proyecto
proporcionarán
antelación
fecha
límite
envío
proyecto
contener
ficheros
fuente
incluyendo
ficheros
cabecera
makefile
incluir
fichero
ejecutable
evaluador
recompilará
automática-
mente
intérprete
mandatos
código
fuente
código
fuente
compila
calificado
makefile
letras
minúsculas
favor
generar
fichero
binario
llamado
hostd
letras
minúsculas
favor
ejemplo
makefile
José
Pérez
s1234567
Sistemas
Operativos
Proyecto
LabComp
1/01
tutor
Antonio
López
hostd
hostd.c
utility.c
hostd.h
gcc
hostd.c
utility.c
-o
hostd
programa
hostd
generará
simplemente
tecleando
make
línea
mandatos
Nota
cuarta
línea
makefile
ejemplo
comenzar
tabulador
Documentación
solicitada
Fichero(s
código
fuente
fichero(s
cabecera
makefile
documento
diseño
descrito
anteriormente
448
Sistemas
operativos
Aspectos
internos
principios
diseño
09-Capitulo
12/5/05
16:24
Página
448Envío
código
necesario
makefile
ficheros
incluidos
envío
copiarán
directorio
incluya
rutas
makefile
makefile
incluir
dependencias
com-
pilar
programa
incluye
biblioteca
makefile
construir
dicha
biblioteca
dejar
construya
mano
binario
fichero
objeto
requerirá
ficheros
fuente
makefile
fichero
readme
Verifique
proyecto
copiando
dichos
ficheros
directorio
vacío
compilándolo
completamente
mandato
make
corrector
usará
script
copia
ficheros
directorio
prueba
borra
fichero
hostd
previo
ficheros
.a
.o
ejecuta
make
copia
serie
ficheros
pruebas
directorio
comprueba
planificador
serie
ficheros
prueba
batería
pruebas
falla
nombres
erróneos
diferencias
mayúsculas
minúsculas
versiones
erróneas
código
fallen
compilar
falta
ficheros
etc.
secuencia
evalua-
ción
detendrá
caso
calificación
obtenida
pruebas
pasadas
completamente
puntuación
código
fuente
manual
Planificación
uniprocesador
449
09-Capitulo
12/5/05
16:24
Página
44909-Capitulo
12/5/05
16:24
Página
450CAPÍTULO
10
Planificación
multiprocesador
tiempo
real
10.1
Planificación
multiprocesador
10.2
Planificación
tiempo
real
10.3
Planificación
Linux
10.4
Planificación
UNIX
SVR4
10.5
Planificación
Windows
10.6
Resumen
10.7
Lecturas
recomendadas
10.8
érminos
clave
cuestiones
repaso
problemas
10-Capitulo
10
16/5/05
17:05
Página
451N
capítulo
continúa
pasando
revista
planificación
procesos
hilos
Comenzamos
exami-
nando
aspectos
surgen
disponibilidad
procesador
exploran
nú-
mero
decisiones
diseño
continuación
verá
planificación
procesos
sistema
multiprocesador
examinan
consideraciones
diseño
plani-
ficación
hilos
multiprocesador
sección
capítulo
cubre
planificación
tiempo
real
sección
comienza
exponiendo
características
procesos
tiempo
real
analiza
naturaleza
proceso
planificación
examinan
propuestas
plani-
ficación
tiempo
real
planificación
basada
plazos
planificación
tasa
monótona
10.1
PLANIFICACIÓN
MULTIPROCESADOR
uando
sistema
computador
contiene
procesador
diseño
función
plani-
ficación
plantea
cuestiones
comienza
resumen
multipro-
cesadores
ve
consideraciones
planifica-
ción
nivel
proceso
nivel
hilo
clasificar
sistemas
multiprocesador
Débilmente
acoplado
multiprocesador
distribuido
cluster
Consiste
colección
sistemas
relativamente
autónomos
procesador
memoria
principal
ca-
nales
S.
Tratamos
tipo
configuración
Capítulo
14
Procesadores
funcionalidad
especializada
ejemplo
procesador
S.
caso
procesador
propósito
general
maestro
procesadores
especializados
controlados
procesador
maestro
proporcionan
servicios
Capítulo
11
tratan
aspectos
relacionados
procesadores
S.
Procesamiento
fuertemente
acoplado
Consiste
conjunto
procesadores
compar-
ten
memoria
principal
control
integrado
único
sistema
operativo
concierne
sección
categoría
específicamente
aspectos
rela-
cionados
planificación
GRANULARIDAD
caracterizar
multiprocesadores
situarlos
contexto
arquitecturas
considerar
granularidad
sincronización
frecuencia
sincronización
procesos
sistema
distinguir
categorías
paralelismo
difieren
grado
granularidad
resumen
Tabla
10.1
adaptada
GEHR87
WOOD89
Paralelismo
Independiente
paralelismo
independiente
sincronización
explícita
procesos
representa
trabajo
aplicación
independiente
separada
típico
tipo
paralelismo
sistemas
tiempo
compartido
usuario
desarrolla
pro-
pio
trabajo
aplicación
particular
tratamiento
textos
hoja
cálculo
multi-
procesador
proporciona
servicio
monoprocesador
multiprogramado
procesador
disponible
tiempo
respuesta
usuarios
menor
mejora
prestaciones
similar
proporcionando
usuario
com-
putador
personal
estación
trabajo
compartir
información
archivo
siste-
452
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
452mas
individuales
conectados
red
formando
sistema
distri-
buido
enfoque
examina
Capítulo
14
único
sistema
multiprocesador
compartido
casos
eficaz
coste
sistema
distribuido
consideramos
economía
escala
discos
periféricos
abla
10.1
Granularidad
sincronización
procesos
Intervalo
amaño
Grano
Descripción
sincronización
Instrucciones
Fino
Paralelismo
inherente
único
flujo
instrucciones
20
Procesamiento
paralelo
multitarea
única
aplicación
20-200
Grueso
Multiprocesamiento
procesos
concurrentes
entorno
multiprogramado
200-2000
grueso
Procesamiento
distribuido
nodos
red
conformar
único
entorno
computación
2000-1
Independiente
Múltiples
procesos
relacionados
Paralelismo
grano
grueso
grueso
paralelismo
grano
grueso
grue-
so
sincronización
procesos
nivel
burdo
tipo
situación
sen-
cillamente
conjunto
procesos
concurrentes
ejecutando
monoprocesador
multipro-
gramado
proporcionarse
multiprocesador
cambio
software
usuario
WOOD89
ejemplo
sencillo
aplicación
explotar
existencia
multiprocesador
autores
desarrollado
programa
dada
especificación
archi-
vos
necesitan
recompilados
reconstruir
fragmento
software
determina
es-
tas
compilaciones
normalmente
ejecutadas
simultáneamente
programa
lanza
proceso
compilación
paralela
autores
informan
aumento
velocidad
multiprocesador
realmente
excede
cabría
esperar
simplemente
sumamos
número
procesadores
sinergias
caches
disco
tema
analiza
Capí-
tulo
11
compartición
código
compilador
cargado
memoria
única
general
colección
procesos
concurrentes
necesitan
comunicarse
sincroni-
zarse
beneficiarse
arquitectura
multiprocesador
caso
interac-
ción
procesos
frecuente
sistema
distribuido
proporcionar
so-
porte
interacción
frecuente
sobrecarga
comunicaciones
red
mermar
potencial
mejora
velocidad
caso
organización
mul-
tiprocesador
proporciona
soporte
eficaz
Paralelismo
grano
Vimos
Capítulo
aplicación
individual
im-
plementada
eficazmente
colección
hilos
único
proceso
caso
paralelismo
potencial
aplicación
especificado
explícitamente
programa-
dor
deberá
grado
alto
coordinación
interacción
hilos
aplicación
dando
lugar
nivel
sincronización
grano
paralelismos
independiente
grueso
grueso
proporcionarse
monoprocesador
multiprogramado
multiprocesador
impacto
función
Planificación
multiprocesador
tiempo
real
453
10-Capitulo
10
16/5/05
17:05
Página
453de
planificación
planificación
hilos
necesario
reexaminar
planificación
hilos
aplicación
interactúan
frecuentemente
decisiones
planifica-
ción
concernientes
hilo
afectar
prestaciones
aplicación
completa
olveremos
tema
sección
Paralelismo
grano
fino
paralelismo
grano
fino
representa
complejo
paralelismo
hilos
trabajo
aplicaciones
altamente
paralelas
área
especializada
fragmentada
mu-
chas
propuestas
ASPECTOS
DISEÑO
multiprocesador
planificación
involucra
aspectos
interrelacionados
asignación
procesos
procesadores
multiprogramación
procesador
individual
activación
proceso
propiamente
dicha
considerar
aspectos
importante
mente
propuesta
elegida
depende-
rá
general
grado
granularidad
aplicación
número
procesadores
disponibles
Asignación
procesos
procesadores
asume
arquitectura
multiprocesador
uniforme
sentido
procesador
ventaja
física
particular
acceso
memoria
principal
dispositivos
enfoque
simple
planifica-
ción
consiste
tratar
proceso
recurso
colectivo
asignar
procesos
procesadores
demanda
Surge
cuestión
asignación
debería
estática
dinámica
proceso
vincula
permanentemente
procesador
activación
con-
cluye
mantiene
cola
corto
plazo
dedicada
procesador
ventaja
estrategia
sobrecarga
función
planificación
asignación
procesador
realiza
Asimismo
procesadores
de-
dicados
permite
estrategia
conocida
planificación
grupo
pandilla
verá
desventaja
asignación
estática
procesador
ocioso
cola
vacía
procesador
trabajo
acumulado
evitar
situación
utilizarse
cola
común
procesos
cola
global
planificados
pro-
cesador
disponible
vida
proceso
ejecutado
pro-
cesadores
momentos
arquitectura
memoria
compartida
fuertemente
aco-
plada
información
contexto
procesos
disponible
procesadores
coste
planificación
proceso
independiente
identi-
dad
procesador
planifica
opción
balance
dinámico
carga
hilos
mueven
cola
procesador
cola
procesador
Linux
utiliza
enfoque
Independientemente
procesos
vinculan
procesadores
necesita
ma-
nera
asignar
procesos
procesadores
venido
usando
enfoques
maestro
esclavo
ca-
maradas
arquitectura
maestro
esclavo
funciones
clave
núcleo
sistema
operati-
vo
ejecutan
procesador
concreto
procesadores
ejecutar
programas
usuario
maestro
responsable
planificación
trabajos
pro-
454
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
454ceso
activo
esclavo
necesita
servicio
ejemplo
llamada
enviar
solicitud
maestro
esperar
servicio
realice
enfoque
simple
re-
mejorar
sistema
operativo
monoprocesador
multiprogramado
resolución
conflictos
simplifica
procesador
control
memoria
recursos
S.
desventajas
enfoque
fallo
maestro
falle
sistema
comple-
to
maestro
llegar
cuello
botella
rendimiento
sistema
arquitectura
camaradas
núcleo
ejecutado
procesador
pro-
cesador
auto-planifica
colección
procesos
disponibles
enfoque
complica
siste-
ma
operativo
sistema
operativo
asegurar
procesadores
escogen
proceso
procesos
extravían
razón
emplearse
técnicas
resolver
sin-
cronizar
competencia
demanda
recursos
gama
opciones
extremos
enfoque
sub-
conjunto
procesadores
dedicado
procesar
núcleo
enfoque
sim-
plemente
gestionar
necesidades
procesos
núcleo
procesos
base
prioridad
historia
ejecución
multiprogramación
procesadores
individuales
proceso
aso-
cia
estáticamente
procesador
tiempo
vida
surge
pregunta
debería
procesador
multiprogramado
reacción
lector
preguntarse
porqué
cuestión
particularmente
ineficiente
vincular
procesador
único
proceso
proceso
quedar
frecuentemente
bloqueado
esperando
conside-
raciones
concurrencia
sincronización
multiprocesadores
tradicionales
tratan
sincronizaciones
grano
grueso
inde-
pendientes
véase
Tabla
10.1
procesador
individual
capaz
cambiar
procesos
alta
utilización
rendimiento
obs-
tante
aplicaciones
grano
ejecutando
multiprocesador
procesadores
situación
clara
procesadores
disponibles
pro-
cesador
esté
ocupado
tiempo
deja
importante
cambio
preocupación
proporcionar
rendimiento
aplicaciones
aplicación
consista
hilos
ejecutar
dificultad
hilos
estén
dispuestos
ejecutar
simultáneamente
Activación
procesos
aspecto
diseño
relacionado
planificación
multiproce-
sador
elección
real
proceso
ejecutar
visto
monoprocesador
multiprogra-
mado
prioridades
sofisticados
algoritmos
planificación
basados
mejorar
rendimiento
frente
ingenua
estrategia
FCFS
llegar
ser-
servido
consideramos
multiprocesadores
complejidades
innecesarias
in-
cluso
contraproducentes
enfoque
simple
eficaz
sobrecarga
caso
planificación
hilos
entran
juego
aspectos
importantes
prioridades
historias
ejecución
Tratemos
temas
turno
PLANIFICACIÓN
PROCESOS
sistemas
multiprocesador
tradicionales
procesos
vinculan
procesadores
cambio
única
cola
procesadores
utiliza
tipo
esquema
basado
prioridades
múltiples
colas
basadas
prioridad
alimentando
único
colectivo
proce-
sadores
caso
sistema
verse
arquitectura
colas
multiservidor
Considérese
caso
sistema
biprocesador
procesador
mitad
velo-
cidad
procesamiento
procesador
sistema
monoprocesador
SAUE81
informa
Planificación
multiprocesador
tiempo
real
455
10-Capitulo
10
16/5/05
17:05
Página
455un
análisis
colas
compara
planificaciones
FCFS
turno
circular
tiempo
restante
estudio
ocupa
tiempo
servicio
procesos
mide
cantidad
tiempo
procesador
necesita
proceso
trabajo
completo
proceso
listo
utilizar
procesador
caso
turno
circular
asume
tiempo
comparado
sobrecarga
cambio
contexto
pequeño
comparado
tiempo
servicio
resultados
dependen
variabilidad
observa
tiempos
servicio
medida
común
variabilidad
coeficiente
variación
valor
Cs
corresponde
caso
variabilidad
tiempos
servicio
procesos
iguales
Valores
mayores
corresponden
variabilidad
tiempos
servicio
valor
Cs
medida
varían
valores
tiempos
servicio
Valores
Cs
inusuales
distribuciones
tiempo
servicio
procesador
Figura
10.1a
compara
productividad
turno
circular
FCFS
función
Cs
Nóte-
diferencia
algoritmos
planificación
menor
caso
biprocesador
procesadores
proceso
único
tiempo
servicio
disruptivo
caso
FCFS
procesos
utilizar
procesador
Resultados
similares
muestran
Figura
10.1b
estudio
SAUE81
repite
análisis
número
supuestos
acerca
grado
multiprogramación
mezcla
procesos
limitados
CPU
prioridades
conclu-
sión
general
disciplina
planificación
específica
importante
pro-
cesadores
Debería
evidente
conclusión
fuerte
medida
número
procesadores
crece
disciplina
básica
FCFS
FCFS
esquema
estático
prioridades
suficiente
sistema
multiprocesador
PLANIFICACIÓN
HILOS
visto
hilos
concepto
ejecución
separa
resto
definición
proceso
aplicación
implementada
conjunto
hilos
cooperan
ejecutan
forma
concurrente
espacio
direcciones
monoprocesador
hilos
usarse
ayuda
estructuración
programas
solapar
procesamiento
Dada
mínima
penalización
cambio
hilo
comparado
cambio
proceso
beneficios
obtienen
coste
completo
hilos
vuelve
evidente
sistema
multiprocesador
entorno
hilos
explotar
paralelismo
real
aplicación
hilos
aplicación
ejecutando
simultáneamente
procesadores
separados
mejora
drásti-
ca
prestaciones
demostrarse
aplicaciones
necesitan
inte-
racción
significativa
hilos
paralelismo
grano
pequeñas
diferencias
gestión
planificación
hilos
lugar
impacto
significativo
prestaciones
ANDE89
propuestas
planificación
multiprocesador
hilos
asignación
pro-
cesadores
destacan
enfoques
generales
Compartición
carga
procesos
asignan
procesador
particular
mantiene
cola
global
hilos
listos
procesador
ocioso
selecciona
hilo
456
Sistemas
operativos
Aspectos
internos
principios
diseño
valor
Cs
calcula
ss
Ts
ss
desviación
estándar
tiempo
servicio
Ts
tiempo
servi-
cio
documento
análisis
colas
WilliamStallings.com/StudentSupport.html
encontrará
explicaciones
s.
10-Capitulo
10
16/5/05
17:05
Página
456cola
término
compartición
carga
utiliza
distinguir
estrategia
esque-
balanceo
carga
trabajos
asignan
permanente
ejemplo
véase
FEIT90a])2
Planificación
multiprocesador
tiempo
real
457
00.98
1.00
Razón
productividad
RR
FCFS
1.03
1.05
1.08
1.10
1.13
1.15
123
Coeficiente
variación
Procesador
dual
Procesador
único
45
01.00
Razón
productividad
SRT
FCFS
1.05
1.10
1.15
1.20
1.25
12345
Procesador
dual
Procesador
único
Coeficiente
variación
Figura
10.1
Comparación
rendimiento
planificación
procesadores
literatura
tema
refiere
enfoque
auto-planificación
procesador
planifica
considerar
procesadores
término
utiliza
literatura
referirse
rogramas
escritos
lenguajes
permiten
programador
especifique
planificación
ejemplo
véase
FOST91
10-Capitulo
10
16/5/05
17:05
Página
457•
Planificación
pandilla
conjunto
hilos
relacionados
planifica
ejecutar
conjunto
procesadores
tiempo
relación
uno-a-uno
Asignación
procesador
dedicado
opuesto
enfoque
compartición
carga
proporciona
planificación
implícita
definida
asignación
hilos
procesadores
proceso
ocupa
número
procesadores
número
hilos
programa
du-
rante
ejecución
programa
programa
termina
procesadores
regresan
parque
general
asignación
programa
Planificación
dinámica
número
hilos
proceso
cambiar
curso
ejecución
Compartición
carga
compartición
carga
posiblemente
enfoque
simple
surge
directamente
entorno
monoprocesador
ventajas
carga
distribuye
uniformemente
procesadores
asegurando
procesador
queda
ocioso
trabajo
pendiente
precisa
planificador
centralizado
procesador
queda
disponible
rutina
planificación
sistema
operativo
ejecuta
procesador
seleccionar
si-
guiente
hilo
cola
global
organizarse
accesible
usando
cualquiera
esquemas
expuestos
Capítulo
incluyendo
esquemas
basados
prioridad
esquemas
consideran
his-
toria
ejecución
anticipan
demandas
procesamiento
LEUT90
analiza
versiones
compartición
carga
llegar
servido
FCFS
llega
trabajo
hilos
disponen
consecutivamente
cola
compartida
procesador
pasa
ocioso
coge
hilo
listo
ejecuta
completa
bloquea
Menor
número
hilos
cola
compartida
listos
organiza
cola
prioridad
prioridad
hilos
trabajos
menor
número
hilos
planificados
trabajos
prioridad
ordenan
trabajo
llega
FCFS
hilo
planificado
ejecuta
completa
blo-
quea
Menor
número
hilos
expulsión
prioridad
trabajos
menor
número
hilos
planificados
llega
trabajo
menor
número
hilos
trabajo
ejecución
expulsarán
hilos
pertenecientes
trabajo
planificado
Usando
modelos
simulación
autores
informan
amplio
rango
característi-
cas
trabajo
FCFS
superior
políticas
lista
precedente
autores
muestran
forma
planificación
pandilla
expuesta
subsección
gene-
ralmente
superior
compartición
carga
compartición
carga
desventajas
cola
central
ocupa
región
memoria
accederse
cum-
pla
exclusión
mutua
convertirse
cuello
botella
procesadores
buscan
trabajo
tiempo
pequeño
número
proce-
sadores
difícil
convierta
problema
apreciable
multiprocesador
consiste
docenas
cientos
procesadores
posibilidad
cuello
botella
real
458
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
458•
probable
hilos
expulsados
retomen
ejecución
procesador
procesador
equipado
cache
local
volverá
eficaz
hilos
tratan
conjunto
común
hilos
probable
hilos
programa
ganen
acceso
procesadores
necesita
alto
grado
co-
ordinación
hilos
programa
cambios
proceso
necesarios
compro-
meter
seriamente
rendimiento
potenciales
desventajas
esquemas
utilizados
multi-
procesadores
actuales
sistema
operativo
Mach
BLAC90
WEND98
utiliza
técnica
mejorada
compartición
carga
sistema
operativo
mantiene
cola
local
procesador
cola
global
compar-
tida
cola
local
utiliza
hilos
temporalmente
vinculados
procesador
con-
creto
procesador
examina
cola
local
preferencia
absoluta
hilos
vin-
culados
vinculados
ejemplo
hilos
vinculados
procesadores
dedicados
ejecutar
procesos
forman
sistema
operativo
ejemplo
hilos
aplicación
particular
distribuidos
pro-
cesadores
software
adicional
adecuado
proporciona
soporte
planificación
pan-
dilla
expuesta
continuación
Planificación
pandilla
concepto
planificar
conjunto
procesos
simultáneamente
so-
bre
conjunto
procesadores
hilos
JONE80
refiere
concepto
plani-
ficación
grupo
cita
siguientes
beneficios
ejecutan
paralelo
procesos
estrechamente
relacionados
reducirse
bloqueo
sincronización
necesitarse
cambios
proceso
prestaciones
aumenta-
rán
sobrecarga
planificación
reducirse
decisión
única
afecta
procesadores
procesos
multiprocesador
Cm
utiliza
término
coplanificación
GEHR87
coplanificación
basa
concepto
planificar
conjunto
tareas
relacionadas
denominadas
carga
traba-
jo
elementos
individuales
carga
trabajo
tienden
pequeños
pró-
ximos
idea
hilo
término
planificación
pandilla
aplicado
planificación
simultánea
hilos
componen
proceso
individual
FEIT90b
planificación
pandilla
aplicaciones
parale-
grano
fino
cuyo
rendimiento
ve
degradado
forma
importante
aplicación
ejecutando
partes
listas
ejecutar
beneficiosa
aplicación
paralela
rendimiento
sensible
necesidad
planificación
pandilla
ampliamente
reconocida
implementaciones
variedad
sistemas
operativos
multiprocesador
obvia
planificación
pandilla
mejora
prestaciones
aplicación
individual
minimizan
cambios
proceso
Suponga
hilo
proceso
ejecutando
alcanza
punto
sincronizarse
hilo
proceso
hilo
ejecutando
listo
ejecutar
hilo
quedará
colgado
su-
ceda
cambio
proceso
procesador
tome
hilo
necesario
aplicación
co-
ordinación
estrecha
hilos
cambios
reducirán
dramáticamente
rendimiento
plani-
ficación
simultánea
hilos
cooperantes
reducir
tiempo
ubicación
recursos
ejemplo
múltiples
hilos
planificados
pandilla
acceder
fichero
sobrecarga
adicional
bloquearse
operación
posicionamiento
lectura
escritura
Planificación
multiprocesador
tiempo
real
459
10-Capitulo
10
16/5/05
17:05
Página
459El
planificación
pandilla
crea
requisito
ubicación
procesador
posi-
bilidad
suponga
procesadores
aplicaciones
hilos
aplicación
dársele
1/
tiempo
disponible
procesadores
usando
porciones
tiempo
FEIT90a
notar
estrategia
inefi-
ciente
Considere
ejemplo
aplicaciones
hilos
hilo
Utilizando
asignación
tiempo
uniforme
desperdicia
37,5%
recurso
procesamiento
ejecuta
aplicación
único
hilo
procesadores
quedan
ociosos
véa-
Figura
10.2
aplicaciones
único
hilo
encajadas
juntas
mejorar
utilización
procesadores
opción
disponible
alternativa
planificación
uniforme
planificación
ponderada
número
hilos
aplicación
hilos
dársele
4/5
tiempo
aplicación
hilo
dársele
quinto
tiempo
reduciéndose
desperdicio
procesador
15%
Asignación
procesador
dedicado
forma
extrema
planificación
pandilla
sugeri-
TUCK89
dedicar
grupo
procesadores
aplicación
duración
aplicación
planifica
aplicación
dada
hilos
asigna
pro-
cesador
permanece
dedicado
hilo
aplicación
concluye
enfoque
parecer
desperdicio
extremo
tiempo
procesador
hilo
aplicación
bloquea
esperando
sincronización
hilo
procesador
hilo
queda
ocioso
multiprogramación
procesadores
realizarse
ob-
servaciones
defensa
estrategia
sistema
altamente
paralelo
decenas
cientos
procesadores
cua-
representa
pequeña
fracción
coste
sistema
utilización
procesador
deja
importante
medida
eficacia
rendimiento
Evitar
totalmente
cambio
proceso
vida
programa
sus-
tancial
mejora
velocidad
programa
TUCK89
ZAHO90
informan
análisis
sustentan
afirmación
Figura
10.3
muestra
resultados
experimento
TUCK89
autores
ejecutaron
apli-
caciones
multiplicación
matrices
cálculo
transformada
rápida
Fourier
FFT
sistema
16
procesadores
aplicación
descompone
problema
tareas
proyectan
hilos
dicha
aplicación
ejecuta
programas
escritos
variar
número
hilos
esencia
aplicación
define
introduce
cola
número
tareas
aplicación
extrae
tareas
cola
proyecta
hilos
disponibles
hilos
tareas
tareas
restantes
permanecen
enconadas
460
Sistemas
operativos
Aspectos
internos
principios
diseño
1/21/2Tiempo
Grupo
Grupo
División
uniforme
PE1
PE2
PE3
PE4
15%
Desperdicio37,5%
Desperdicio
4/5
Grupo
División
pesos
PE1
PE2
PE3
PE4
Ocioso
1/5
Grupo
Ocioso
Ocioso
Ocioso
Ocioso
Ocioso
Figura
10.2
Ejemplo
planificación
grupos
hilos
FEIT90b
10-Capitulo
10
16/5/05
17:05
Página
460extraídas
hilos
completan
tarea
asignada
Claramente
aplicaciones
estructuradas
problemas
numéricos
aplicaciones
tratarse
forma
Figura
10.3
muestra
incremento
velocidad
aplicaciones
número
hi-
ejecutan
tareas
aplicación
varía
24
ejemplo
observa
ambas
aplicaciones
arrancan
simultáneamente
24
hilos
aceleración
obtenida
com-
parada
único
hilo
aplicación
2,8
multiplicación
matrices
2,4
FFT
figura
muestra
rendimiento
ambas
aplicaciones
empeora
considerable-
mente
número
hilos
aplicación
excede
número
proce-
sos
sistema
excede
número
procesadores
número
hilos
rendi-
miento
obtiene
frecuencia
expulsión
hilos
re-planificación
excesiva
expulsión
provoca
ineficiencia
sentidos
tiempo
gastado
esperando
hilo
suspendido
abandone
sección
crítica
tiempo
gastado
cambios
proceso
ineficiente
com-
portamiento
cache
autores
concluyen
estrategia
eficaz
limitar
número
hilos
activos
número
procesadores
sistema
mayoría
aplicaciones
hilo
único
es-
tructuradas
cola
tareas
conseguirá
eficaz
razonablemente
eficiente
re-
cursos
procesador
asignación
procesador
dedicado
planificación
pandilla
atacan
proble-
ma
planificación
tratando
aspecto
ubicación
procesador
observarse
problema
ubicación
procesador
multiprocesador
problema
ubi-
cación
memoria
monoprocesador
problema
planificación
monoproce-
sador
pregunta
procesadores
asignar
programa
momento
análoga
marcos
página
asignar
proceso
momento
GEHR87
define
término
conjunto
residente
actividad
análogo
conjunto
residente
memoria
virtual
Planificación
multiprocesador
tiempo
real
461
400
81
Número
procesos
Aceleración
FFT
Multiplicación
matrices
16
20
24
Figura
10.3
Aceleración
aplicación
función
número
procesos
TUCK89
10-Capitulo
10
16/5/05
17:05
Página
461como
mínimo
número
actividades
hilos
planificados
simultáneamente
procesadores
aplicación
progreso
aceptable
esquemas
gestión
memoria
planificar
elementos
conjunto
residente
actividad
provocar
trasiego
procesador
sucede
planificación
hilos
cuyos
servicios
necesitan
provoca
expulsión
hilos
cuyos
servicios
necesitados
fragmentación
procesador
refiere
situación
quedan
procesa-
dores
sobrantes
ubicados
procesadores
sobrantes
insuficientes
número
organizados
adecuadamente
soporte
requisitos
apli-
caciones
pendientes
planificación
pandilla
ubicación
procesador
dedicado
objetivo
evitar
problemas
Planificación
dinámica
aplicaciones
proporcionar
lenguaje
sistema
herramientas
permitan
número
hilos
proceso
alterado
dinámica-
mente
permitiría
sistema
operativo
ajustase
carga
mejorar
utilización
ZAHO90
propone
enfoque
sistema
operativo
aplicación
es-
tán
involucrados
tomar
decisiones
planificación
sistema
operativo
responsable
particionar
procesadores
trabajos
trabajo
utiliza
procesadores
actual-
mente
partición
ejecutar
subconjunto
tareas
ejecutables
proyectando
es-
tas
tareas
hilos
decisión
apropiada
acerca
subconjunto
ejecutar
hi-
suspender
proceso
expulsado
deja
aplicaciones
individuales
conjunto
rutinas
biblioteca
enfoque
adecuado
aplicaciones
aplicaciones
consideradas
único
hilo
programadas
sacar
ventaja
particular
característica
sis-
tema
operativo
enfoque
responsabilidad
planificación
sistema
operativo
limitada
funda-
mentalmente
ubicación
procesador
realiza
política
trabajo
solicita
procesadores
trabajo
llega
re-
quisitos
cambian
procesadores
ociosos
utilizarlos
satisfacer
solicitud
caso
trabajo
realiza
solicitud
acaba
llegar
ubicarlo
único
proce-
sador
quitándoselo
trabajo
actualmente
procesador
satisfacerse
solicitud
mantenerla
pendiente
pro-
cesador
pase
disponible
trabajo
rescinda
solicitud
ejemplo
dejan
necesarios
procesadores
extra
libere
procesadores
incluyendo
terminación
trabajo
Examinar
cola
actual
solicitudes
procesador
satisfechas
Asignar
único
procesa-
dor
trabajo
lista
actualmente
procesadores
ejemplo
recién
llegados
espera
volver
examinar
lista
volviendo
asignar
resto
procesadores
siguiendo
estrategia
FCFS
ZAHO90
MAJU88
informan
análisis
sugieren
aplicaciones
aprovechar
ventajas
planificación
dinámica
enfoque
superior
planifica-
ción
pandilla
asignación
procesador
dedicado
obstante
sobrecarga
enfoque
invalidar
aparente
ventaja
rendimiento
necesario
experimentar
sistema
real
probar
ventaja
planificación
dinámica
462
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
46210.2
PLANIFICACIÓN
TIEMPO
REAL
ANTECEDENTES
computación
tiempo
real
convirtiendo
disciplina
importancia
sistema
operativo
particular
planificador
componente
importante
sistema
tiempo
real
Ejemplos
aplicaciones
actuales
sistemas
tiempo
real
control
experimentos
laboratorio
control
procesos
plantas
industriales
robótica
control
tráfico
aéreo
telecomunicaciones
sistemas
militares
mando
control
generación
siste-
incluirá
vehículos
terreno
autónomos
controladores
robots
articulaciones
elásticas
sistemas
fundamentados
manufactura
inteligente
estación
espacial
exploración
fondo
marino
computación
tiempo
real
definirse
corrección
sistema
depende
resultado
lógico
computación
momento
pro-
ducen
resultados
definir
sistema
tiempo
real
definiendo
entiende
proceso
tiempo
real
tarea
general
sistema
tiempo
real
tareas
tareas
tiempo
real
grado
urgencia
Tales
tareas
intentan
controlar
reac-
cionar
eventos
lugar
mundo
exterior
eventos
ocurren
tiempo
real
tarea
tiempo
real
capaz
mantener
ritmo
eventos
con-
ciernen
normalmente
asociar
plazo
tiempo
límite
tarea
concreta
plazo
especifica
instante
comienzo
finalización
tarea
clasificada
dura
blanda
tarea
tiempo
real
duro
cumplir
plazo
límite
producirá
daño
inaceptable
error
fatal
sistema
tarea
tiempo
real
suave
asociado
plazo
límite
deseable
obligatorio
teniendo
sentido
planificar
com-
pletar
tarea
plazo
límite
vencido
característica
tareas
tiempo
real
periódicas
aperiódicas
tarea
ape-
riódica
plazo
finalizar
comenzar
restricción
instante
comienzo
finalización
caso
tarea
periódica
requisito
enunciado
periodo
exactamente
unidades
CARACTERÍSTICAS
SISTEMAS
OPERATIVOS
TIEMPO
REAL
sistemas
operativos
tiempo
real
caracterizados
requisitos
únicos
áreas
generales
MORG92
Determinismo
Reactividad
Control
usuario
Fiabilidad
Operación
fallo
suave
Planificación
multiprocesador
tiempo
real
463
suele
pasar
terminología
presenta
problema
literatura
utilizan
palabras
signifi-
cados
común
proceso
particular
opere
restricciones
tiempo
real
naturaleza
repetitiva
proceso
dura
tiempo
tiempo
realiza
función
repetitiva
respuesta
eventos
tiempo-real
sección
referir
función
individual
tarea
entenderse
proceso
avanza
secuen
cia
tareas
momento
proceso
dedicando
única
tarea
proceso
tarea
planific
ado
10-Capitulo
10
16/5/05
17:05
Página
463Un
sistema
operativo
determinista
sentido
realiza
operaciones
instantes
tiempo
fijos
predeterminados
intervalos
tiempo
predeterminados
múltiples
procesos
compiten
recursos
tiempo
procesador
sistema
totalmente
deter-
minista
sistema
operativo
tiempo
real
solicitudes
servicio
procesos
dirigi-
das
eventos
externos
temporizaciones
grado
sistema
operativo
satisfacer
determinista
solicitudes
depende
velocidad
capaz
respon-
der
interrupciones
sistema
capacidad
suficiente
manejar
solicitudes
tiempo
requerido
medida
útil
capacidad
sistema
operativo
funcionar
determinista
retardo
máximo
llegada
interrupción
dispositivo
alta
prioridad
comienza
servicio
sistemas
operativos
tiempo
real
retardo
rango
decenas
cientos
milisegundos
sistema
operativo
tiempo
real
retar-
do
límite
superior
punto
microsegundos
milisegundo
característica
distinta
relacionada
reactividad
determinismo
preocupa
tiempo
tarda
sistema
operativo
reconocimiento
interrupción
reactividad
preocupa
tiempo
tarda
sistema
operativo
reconocimiento
servir
in-
terrupción
reactividad
incluye
siguientes
aspectos
cantidad
tiempo
necesario
manejar
inicialmente
interrupción
comenzar
eje-
cutar
rutina
servicio
interrupción
RSI
ejecución
RSI
necesita
cam-
bio
proceso
retardo
RSI
ejecutada
contexto
proceso
actual
cantidad
tiempo
necesario
RSI
depende
generalmente
plata-
forma
hardware
efecto
anidamiento
interrupciones
RSI
interrumpida
llegada
interrupción
servicio
retrasará
determinismo
reactividad
juntos
conforman
tiempo
respuesta
eventos
externos
requisitos
tiempo
respuesta
críticos
sistemas
tiempo
real
siste-
cumplir
requisitos
tiempo
impuestos
individuos
dispositivos
flujos
datos
ex-
ternos
sistema
control
usuario
generalmente
sistema
operativo
tiempo
real
sistemas
operativos
ordinarios
típico
sistema
operativo
tiempo
real
usuario
control
función
planificación
sistema
operativo
proporcionar
guía
burda
agrupación
usuarios
clase
prioridad
sistema
tiempo
real
esencial
permitirle
usuario
control
grano
fino
prioridad
tarea
usuario
capaz
distinguir
tareas
duras
suaves
especificar
priori-
dades
relativas
clase
sistema
tiempo
real
permitirle
usuario
especificar
características
paginación
procesos
procesos
residir
memoria
principal
algoritmos
transferencia
disco
utilizarse
derechos
procesos
bandas
prioridad
etcétera
fiabilidad
normalmente
importante
sistemas
tiempo
real
fallo
transitorio
sistema
tiempo
real
solventarse
simplemente
rearrancando
sistema
fallo
procesador
sistema
multiprocesador
tiempo
real
lugar
nivel
servicio
degradado
procesador
falla
reparado
sus-
tituido
sistema
tiempo
real
responder
controlar
eventos
tiempo
real
pérdida
degradación
prestaciones
consecuencias
catastróficas
pérdidas
económicas
da-
ños
equipos
importantes
pérdida
vidas
464
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
464Como
áreas
diferencia
sistema
operativo
tiempo
real
tiempo
real
cuestión
grado
sistema
tiempo
real
diseñado
responder
va-
rios
modos
fallo
operación
fallo
suave
característica
refiere
habilidad
sistema
fallar
preserve
tanta
capacidad
datos
ejemplo
típico
sistema
UNIX
tradicional
detecta
corrupción
datos
núcleo
emite
mensaje
fallo
consola
sistema
vuelca
contenidos
memoria
disco
análisis
posterior
fallo
termina
ejecución
sistema
cambio
sistema
tiempo
real
intentará
corregir
problema
minimizar
efectos
continuando
caso
ejecución
Normalmente
sistema
notifica
usuario
proceso
usuario
intentar
acción
correctiva
continúa
operando
nivel
servicio
redu-
cido
caso
necesario
apagar
máquina
intentará
mantener
consistencia
fi-
cheros
datos
aspecto
importante
operación
fallo
suave
conoce
estabilidad
sistema
tiempo
real
estable
casos
imposible
cumplir
plazos
tareas
sistema
cumplirá
plazos
tareas
críticas
alta
prioridad
plazos
tareas
críticas
satisfagan
cumplir
requisitos
precedentes
sistemas
operativos
tiempo
real
incluyen
forma
representativa
siguientes
características
STAN89
Cambio
proceso
hilo
rápido
Pequeño
tamaño
asociado
funcionalidades
mínimas
Capacidad
responder
rápidamente
interrupciones
externas
Multitarea
herramientas
comunicación
procesos
semáforos
señales
eventos
Utilización
ficheros
secuenciales
especiales
acumular
datos
alta
velocidad
Planificación
expulsiva
basada
prioridades
Minimización
intervalos
deshabilitan
interrupciones
Primitivas
retardar
tareas
cantidad
dada
tiempo
parar
retomar
tareas
Alarmas
temporizaciones
especiales
corazón
sistema
tiempo
real
planificador
tareas
corto
plazo
diseño
planificador
equidad
minimización
tiempo
respuesta
importan-
importante
tareas
tiempo
real
duro
completen
comiencen
plazo
tantas
tareas
tiempo
real
suave
completen
comiencen
plazo
mayoría
sistemas
operativos
tiempo
real
contemporáneos
incapaces
tratar
directamente
plazos
límite
cambio
diseñan
sensibles
tareas
tiempo
real
aproxime
plazo
tiempo
tarea
planificada
rápidamente
punto
vista
aplicaciones
tiempo
real
requieren
típi-
camente
tiempos
respuesta
deterministas
rango
milisegundos
submilisegundo
amplio
conjunto
condiciones
aplicaciones
avanzadas
simuladores
aviones
militares
ejemplo
suelen
restricciones
rango
10
100
ms
ATLA80
Figura
10.4
ilustra
abanico
posibilidades
planificador
expulsivo
utiliza
simple
planificación
turno
circular
tarea
tiempo
real
añadida
cola
listos
Planificación
multiprocesador
tiempo
real
465
10-Capitulo
10
16/5/05
17:05
Página
465esperar
próxima
rodaja
tiempo
ve
Figura
10.4a
caso
tiempo
plani-
ficación
generalmente
inaceptable
aplicaciones
tiempo
real
alternativo
planificador
expulsivo
utilizarse
mecanismo
planificación
prioridad
dándole
tareas
tiempo
real
prioridad
caso
tarea
tiempo
real
esté
lista
planificada
proceso
actual
bloquee
concluya
Figura
10.4b
lugar
retardo
segundos
tarea
lenta
baja
prioridad
estuviera
ejecutando
momen-
to
crítico
enfoque
aceptable
enfoque
prometedor
combinar
prio-
ridades
interrupciones
basadas
reloj
puntos
expulsión
ocurrirán
intervalos
regula-
res
suceda
punto
expulsión
tarea
actualmente
ejecución
expulsada
esperando
tarea
prioridad
incluir
expulsión
tareas
núcleo
sistema
operativo
retardo
orden
milisegundos
Figura
10.4c
enfoque
adecuado
aplicaciones
tiempo
real
suficiente
aplicaciones
exigentes
casos
opción
tomado
denomi-
na
expulsión
inmediata
caso
sistema
operativo
responde
interrupción
inmediatamente
sistema
esté
sección
bloqueada
código
crítico
re-
tardos
planificación
tareas
tiempo
real
reducirse
100
ms
PLANIFICACIÓN
TIEMPO
REAL
planificación
tiempo
real
áreas
activas
investigación
informática
subsección
ofrece
visión
general
enfoques
planificación
tiempo
real
muestran
clases
algoritmos
planificación
populares
compendio
algoritmos
planificación
tiempo
real
RAMA94
observa
distintos
enfoques
planificación
dependen
sistema
realiza
análisis
planifica-
bilidad
realiza
estática
dinámicamente
resultado
análisis
produce
plan
planificación
desarrollarán
tareas
tiempo
ejecu-
ción
base
consideraciones
autores
identifican
siguientes
clases
algoritmos
Enfoques
estáticos
dirigidos
tabla
realiza
análisis
estático
factibili-
dad
planificación
resultado
análisis
planificación
determina
tiempo
ejecución
comenzar
ejecutarse
tarea
Enfoques
estáticos
expulsivos
dirigidos
prioridad
realiza
análisis
está-
tico
obtiene
planificación
cambio
análisis
utiliza
asignar
prio-
ridades
tareas
utilizarse
planificador
expulsivo
tradicional
basado
prioridades
Enfoques
dinámicos
basados
plan
factibilidad
determina
tiempo
ejecu-
ción
dinámicamente
comenzar
ejecución
estáticamente
ta-
rea
aceptada
ejecutable
satisfacer
restricciones
tiempo
resultados
análisis
factibilidad
plan
usará
decidir
marcha
tarea
Enfoques
dinámicos
esfuerzo
realiza
análisis
factibilidad
sistema
intenta
cumplir
plazos
aborta
ejecución
proceso
cuyo
plazo
fallado
planificación
estática
dirigida
tabla
aplicable
tareas
periódicas
datos
entrada
análisis
tiempo
periódico
llegada
tiempo
ejecución
plazo
periódico
finalización
prioridad
relativa
tarea
planificador
intenta
encontrar
plan
permi-
ta
cumplir
requisitos
tareas
periódicas
enfoque
predecible
466
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
466Planificación
multiprocesador
tiempo
real
467
Proceso
Solicitud
proceso
tiempo
real
Planificador
expulsivo
turno
circular
Tictac
reloj
Proceso
Proceso
tiempo
real
Tiempo
planificación
Proceso
tiempo
real
añadido
cola
ejecución
esperar
rodaja
Proceso
actual
Current
process
blocked
or
completed
Planificador
expulsivo
dirigido
prioridad
Proceso
tiempo
real
Tiempo
planificación
Proceso
tiempo
real
añadido
comienzo
cola
ejecución
Punto
expulsión
Planificador
expulsivo
dirigido
prioridad
puntos
expulsión
Tiempo
planificación
Esperar
punto
expulsión
Planificador
expulsivo
inmediato
proceso
tiempo
real
expulsa
proceso
actual
ejecuta
inmediatemente
Proceso
Solicitud
proceso
tiempo
real
Solicitud
proceso
tiempo
real
Proceso
actual
Proceso
tiempo
real
Solicitud
proceso
tiempo
real
Proceso
actual
Proceso
tiempo
real
Tiempo
planificación
Figura
10.4
Planificación
procesos
tiempo
real
10-Capitulo
10
16/5/05
17:05
Página
467flexible
cambio
cualquiera
requisitos
tareas
requiere
rehacer
pla-
nificación
plazo
cercano
técnicas
plazos
periódicos
expuestas
posterior-
mente
típicas
categoría
algoritmos
planificación
planificación
estática
expulsión
dirigida
prioridad
mecanismo
pla-
nificación
expulsivo
dirigido
prioridades
común
mayoría
sistemas
multiprogramados
tiempo
real
sistema
tiempo
real
utilizarse
múltiples
fac-
tores
determinar
prioridad
ejemplo
sistema
tiempo
compartido
prioridad
proceso
cambiar
dependiendo
consume
CPU
S.
sistema
tiempo
real
asignación
prioridades
relacionada
restricciones
tiempo
asociadas
ta-
rea
ejemplo
enfoque
algoritmo
tasa
monótona
expuesto
posteriormente
asigna
prioridades
estáticas
tareas
basándose
longitudes
periodos
planificación
dinámica
basada
plan
llega
tarea
comience
ejecución
intentará
crear
plan
contenga
tareas
previamente
planifica-
das
tarea
recién
llegada
planificada
cumplan
plazos
tarea
planificada
anteriormente
pierda
plazo
tarea
acep-
tada
poniéndose
marcha
plan
planificación
planificación
dinámica
esfuerzo
enfoque
utilizado
sistemas
ope-
rativos
tiempo
real
disponibles
comercialmente
llega
tarea
sistema
asigna
prioridad
basada
características
forma
característica
utiliza
al-
gún
tipo
planificación
basada
plazos
planificación
plazo
cercano
tare-
as
periódicas
análisis
estático
planificabilidad
tipo
planificación
sabremos
determinada
restricción
tiempo
satisfecha
venza
plazo
tarea
complete
principal
desventaja
forma
planifica-
ción
ventaja
fácil
implementar
PLANIFICACIÓN
PLAZOS
sistemas
operativos
tiempo
real
actuales
diseñados
objetivo
arrancar
tareas
tiempo
real
rápidamente
enfatizan
manipu-
lación
rápida
interrupciones
activación
rápida
tareas
medi-
útil
evaluación
sistemas
operativos
tiempo
real
Generalmente
aplicaciones
tiempo-real
preocupan
velocidad
ejecución
completar
comenzar
tareas
momentos
adecuados
demanda
diná-
mica
recursos
conflictos
sobrecarga
procesamiento
fallos
hardware
software
de-
duce
prioridades
proporcionan
herramienta
burda
contempla
requisito
com-
pletar
iniciar
tarea
momento
adecuado
habido
propuestas
enfoques
potentes
apropiados
planificación
ta-
reas
tiempo
real
basan
información
adicional
acerca
tarea
forma
general
utilizarse
información
tarea
Tiempo
activación
Momento
tarea
pasa
lista
ejecutar
caso
tarea
repetitiva
periódica
tratará
secuencia
tiempos
conocida
antema-
caso
tarea
aperiódica
tiempo
conocido
previamente
siste-
ma
operativo
consciente
tarea
pase
lista
Plazo
comienzo
Momento
tarea
comenzar
Plazo
conclusión
Momento
tarea
completada
aplicaciones
tiempo
real
típicas
plazos
comienzo
plazos
conclusión
468
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
468•
Tiempo
proceso
Tiempo
necesario
ejecutar
tarea
conclusión
casos
disponible
sistema
operativo
estimará
media
exponen-
cial
definida
Capítulo
sistemas
planificación
información
utiliza
Recursos
requeridos
Conjunto
recursos
distintos
procesador
tarea
necesita
ejecución
Prioridad
Mide
importancia
relativa
tarea
tareas
tiempo
real
duro
te-
ner
prioridad
absoluta
provocando
sistema
falle
plazo
cumple
sistema
continuar
ejecutando
importar
suceda
asignarse
prioridades
relativas
tareas
tiempo
real
duro
suave
planificador
utilizará
guía
Estructura
subtareas
tarea
descompuesta
subtarea
obligatoria
subtarea
opcional
subtarea
obligatoria
posee
plazo
duro
dimensiones
función
planificación
tiempo
real
con-
sideración
plazos
tarea
ejecutar
continuación
tipo
expulsión
permite
de-
mostrarse
estrategia
expulsión
dada
utilizando
plazos
comienzo
conclusión
política
planificar
tarea
plazo
cercano
minimiza
cantidad
tareas
fallan
plazos
BUTT99
HONG89
PANW88
resultado
cumple
configu-
raciones
procesador
único
multiprocesador
expulsión
factor
crítico
diseño
especifican
plazos
comienzo
sentido
planificación
expulsiva
caso
responsabilidad
tarea
tiempo
real
bloquearse
completar
porción
crítica
obligatoria
eje-
cución
permitir
satisfagan
plazos
comienzo
tiempo
real
encaja
patrón
Figura
10.4b
sistema
plazos
conclusión
apropiada
estrategia
expulsiva
Figura
10.4c
ejemplo
tarea
ejecutando
tarea
lista
circunstancias
única
cumplan
pla-
zos
conclusión
expulsar
ejecutar
finalizar
retomar
finalizar
abla
10.2
Perfil
ejecución
tareas
periódicas
Proceso
Tiempo
llegada
Tiempo
ejecución
Plazo
conclusión
A(1
10
20
A(2
20
10
40
A(3
40
10
60
A(4
60
10
80
A(5
80
10
100
B(1
25
50
B(2
50
25
100
Planificación
multiprocesador
tiempo
real
469
10-Capitulo
10
16/5/05
17:05
Página
469Como
ejemplo
planificación
tareas
periódicas
plazos
conclusión
considere
sistema
recolecta
procesa
datos
sensores
B.
plazo
recolección
da-
tos
sensor
20
ms
sensor
50
ms
10
ms
incluyendo
sobre-
carga
sistema
operativo
procesar
muestra
datos
25
ms
procesar
muestra
datos
B.
Tabla
10.2
resume
perfil
ejecución
tareas
Figura
10.5
com-
técnicas
planificación
utilizando
perfil
ejecución
Tabla
10.2
fila
Figura
10.5
repite
información
Tabla
10.2
restantes
filas
ilustran
técnicas
planificación
computador
capaz
decisión
planificación
10
ms
Suponga
circunstancias
intentamos
esquema
planificación
prioridad
diagramas
tiempo
Figura
10.5
muestran
resultado
prioridad
prime-
ra
instancia
tarea
20
ms
tiempo
proceso
trozos
10
ms
momento
plazo
vence
falla
prioridad
fallará
plazo
diagrama
tiempo
muestra
planificación
plazo
cercano
instante
llegan
A1
B1
A1
plazo
cercano
planifica-
A1
completa
procesador
entrega
B1
20
llega
A2
A2
plazo
cercano
B1
B1
interrumpida
A1
ejecutar
concluir
En-
tonces
30
retoma
B1
40
llega
A3
B1
plazo
cercano
permite
continuar
ejecutando
concluir
45
A3
toma
procesador
finali-
za
55
470
Sistemas
operativos
Aspectos
internos
principios
diseño
90704020
10
30
50
60
80
1000
Tiempo
ms
B1
B2
A1
A2
A3
A4
A5Tiempos
llegada
ejecución
plazos
A1
plazo
A2
plazo
A3
plazo
A4
plazo
A5
plazo
B2
plazo
B1
plazo
A3
A4
A5A1
B1
A2
B1
B2
B2
B2
A1
A2
A3
A4
A5
B2B1
fallo
A1
fallo
A2
A3
A4
fallo
A5
B2
B1
B2A2
A3
A5
A1
A2
A3
A4
A5
B2B1
A1
B1
A2
B1
A3
B2
A4
B2
A5
Planificación
prioridades
fijas
prioridad
Planificación
plazo
cercano
usando
plazos
conclusión
B1
Planificación
prioridades
fijas
prioridad
Figura
10.5
Planificación
tareas
periódicas
tiempo
real
plazos
conclusión
basado
Tabla
10.2
10-Capitulo
10
16/5/05
17:05
Página
470En
ejemplo
planificando
punto
expulsión
dando
prioridad
tarea
plazo
satisfacerse
requisitos
sistema
tareas
pe-
riódicas
predecibles
utiliza
enfoque
planificación
estática
dirigida
tabla
Considere
esquema
tratar
tareas
aperiódicas
plazos
comienzo
superior
Figura
10.6
muestra
tiempos
llegada
plazos
comienzo
ejemplo
con-
sistente
tareas
tiempo
ejecución
20
ms
Tabla
10.3
resume
perfil
ejecución
tareas
abla
10.3
Perfil
ejecución
tareas
aperiódicas
Proceso
Tiempo
llegada
Tiempo
ejecución
Plazo
comienzo
A1
10
02
02
02
05
02
09
02
07
esquema
directo
planificar
tarea
lista
plazo
cercano
permitir
tarea
ejecute
concluir
utiliza
enfoque
ejemplo
Figura
10.6
obser-
ve
tarea
precisa
servicio
inmediato
deniega
servicio
riesgo
Planificación
multiprocesador
tiempo
real
471
90704020
10
30
50
60
80
100
1100
120
ADE
ADE
fallo
ADE
fallo
ADE
fallo
AB
CDE
AB
AB
CDE
AB
CDE
CED
AC
Requisitos
Tiempos
llegada
Plazo
comienzo
Plazo
cercano
Servicio
Plazo
cercano
tiempos
ociosos
forzados
llegar
servirse
FCFS
Tiempos
llegada
Plazo
comienzo
Tiempos
llegada
Plazo
comienzo
Tiempos
llegada
Plazo
comienzo
Servicio
Servicio
Figura
10.6
Planificación
tareas
aperiódicas
tiempo
real
plazos
comienzo
10-Capitulo
10
16/5/05
17:05
Página
471manejar
tareas
aperiódicas
especialmente
plazos
comienzo
mejora
política
me-
jorará
rendimiento
conocerse
anticipación
plazos
tarea
esté
lista
política
conocida
plazo
cercano
tiempos
ociosos
forzados
funcio-
na
planificar
tarea
elegible
plazo
cercano
permitir
tarea
ejecute
concluir
tarea
elegible
lista
resultado
procesador
permanezca
ocioso
tareas
listas
Observe
ejemplo
sistema
evita
planificación
tarea
única
tarea
lista
resultado
procesador
utiliza
máxima
eficiencia
satisfacen
requisitos
planificación
Finalmente
comparar
muestra
política
FCFS
caso
tareas
cumplen
plazos
PLANIFICACIÓN
TASA
MONÓTONA
métodos
prometedores
resolver
conflictos
planificación
multitarea
tareas
periódicas
planificación
tasa
monótona
RMS
esquema
propuesto
LIU73
recientemente
ganado
popularidad
BRIA99
SHA94
RMS
asigna
prio-
ridades
tareas
base
periodos
Figura
10.7
ilustra
parámetros
relevantes
tareas
periódicas
periodo
tarea
cantidad
tiempo
llegada
instancia
tarea
llegada
ins-
tancia
tarea
tasa
tarea
Hercios
simplemente
inverso
periodo
se-
gundos
ejemplo
tarea
periodo
50
ms
ocurre
tasa
20
Hz
Típicamente
periodo
tarea
plazo
crítico
tarea
tareas
te-
ner
plazos
cercanos
tiempo
ejecución
cómputo
cantidad
tiempo
pro-
ceso
requerido
ocurrencia
tarea
quedar
sistema
monoprocesador
tiempo
ejecución
periodo
obligado
tarea
periódica
ejecuta
concluye
instancia
tarea
deniega
ser-
vicio
recursos
insuficientes
utilización
procesador
tarea
T.
ejemplo
tarea
periodo
80
ms
tiempo
cómputo
55
ms
utilización
procesador
55/80
0,6875
RMS
tarea
prioridad
periodo
tarea
prioridad
periodo
sucesivamente
tarea
disponible
ejecución
periodo
sirve
dibu-
jamos
prioridad
tareas
función
tasa
resultado
función
monótona-
mente
creciente
Figura
10.8
nombre
planificación
tasa
monótona
medida
efectividad
algoritmo
planificación
periódica
garantiza
cumplen
plazos
duros
Suponga
tareas
periodo
tiempo
cómputo
fijos
cumplir
plazos
cumplirse
relación
472
Sistemas
operativos
Aspectos
internos
principios
diseño
Proceso
ProcesoOciososP
Tiempo
ejecución
tarea
Ciclo
Perido
tarea
Ciclo
Tiempo
Figura
10.7
Diagrama
tiempos
tarea
periódica
10-Capitulo
10
16/5/05
17:05
Página
472(10.1
suma
utilización
procesador
tareas
exceder
valor
co-
rresponde
utilización
procesador
Ecuación
10.1
proporciona
límite
número
tareas
algoritmo
planificación
perfecto
planificar
satisfactoriamente
al-
goritmo
particular
límite
menor
RMS
mostrarse
cumple
si-
guiente
relación
10.2
abla
10.4
Valor
límite
superior
RMS
nn
21
1,0
0,828
0,779
0,756
0,743
0,734
ln
0,693
nn
n1
21
1++
Planificación
multiprocesador
tiempo
real
473
Prioridad
Alta
Baja
Tasa
Hz
Tarea
frecuente
prioridad
Tarea
frecuente
menor
prioridad
Figura
10.8
conjunto
tareas
RMS
WARR91
10-Capitulo
10
16/5/05
17:05
Página
473La
Tabla
10.4
muestra
valores
límite
superior
medida
número
ta-
reas
aumenta
límite
planificabilidad
converge
ln
0,693
ejemplo
considere
caso
tareas
periódicas
Ui
Ci
Tarea
C1
20
T1
100
U1
0,2
Tarea
C2
40
T2
150
U2
0,267
Tarea
C3
100
T3
350
U3
0,286
utilización
tareas
0,2
0,267
0,286
0,753
límite
superior
planificabilidad
tareas
usando
RMS
utilización
necesaria
tareas
menor
límite
superior
RMS
0,753
0,779
utiliza
RMS
tareas
planificadas
satis-
factoriamente
demostrarse
límite
superior
Ecuación
10.1
cumple
plani-
ficación
plazo
cercano
utilización
procesador
acomodar
tareas
periódicas
planificación
plazo
cercano
obstante
RMS
ampliamente
adoptado
aplicaciones
industriales
SHA91
ofrece
explicación
práctica
diferencia
prestaciones
pequeña
límite
superior
Ecuación
10.2
conservador
práctica
utilizaciones
altas
90%
mayoría
sistemas
tiempo
real
duro
componentes
tiempo
real
suave
mensajes
críticos
auto
comprobaciones
ejecutadas
niveles
prioridad
menores
absorber
tiempo
procesador
utiliza
planificación
RMS
tareas
tiempo
real
duro
fácil
estabilidad
RMS
sistema
cumplir
plazos
sobrecarga
errores
transitorios
plazos
tareas
esenciales
ga-
rantizados
subconjunto
tareas
planificable
enfoque
asignación
estática
prioridades
necesita
asegurar
tareas
esenciales
prioridades
relativa-
mente
altas
planificación
plazo
cercano
prioridad
tarea
periódica
cambia
periodo
difícil
asegurar
tareas
esenciales
cumplen
plazos
INVERSIÓN
PRIORIDAD
inversión
prioridad
fenómeno
suceder
esquema
planificación
expulsivo
basado
prioridades
particularmente
relevante
contexto
planificación
tiempo
real
caso
conocido
inversión
prioridad
sucedió
misión
Mars
Pathfinder
vehículo
robot
alcanzó
Marte
julio
1997
comenzó
recolectar
transmitir
volumi-
nosas
cantidades
datos
Tierra
misión
software
abordo
co-
menzó
experimentar
reinicializaciones
totales
sistema
consiguientes
pérdidas
datos
esfuerzo
equipo
Jet
Propulsion
Laboratory
construyó
Pathfinder
descubrió
problema
inversión
prioridad
JONE97
779
13++£
474
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
474En
esquema
planificación
prioridad
sistema
ejecutando
tarea
prioridad
inversión
prioridad
sucede
circunstancias
sis-
tema
fuerzan
tarea
prioridad
esperar
tarea
menor
prioridad
ejemplo
sencillo
inversión
prioridad
sucede
tarea
menor
prioridad
bloqueado
recurso
dispositivo
semáforo
binario
tarea
prioridad
intenta
bloquear
recurso
tarea
prioridad
pasará
bloqueado
recurso
esté
disponible
tarea
menor
prioridad
termina
recurso
libera
tarea
prioridad
re-
tomada
rápidamente
violen
restricciones
tiempo
real
situación
seria
conocida
inversión
prioridad
ilimitada
du-
ración
inversión
prioridad
depende
tiempo
necesario
recurso
compartido
acciones
impredecibles
tareas
relacionadas
inversión
prioridad
sucedió
software
Pathfinder
ilimitada
sirve
ejemplo
fenómeno
exposición
basa
TIME02
software
Pathfinder
incluye
siguientes
tareas
orden
prioridad
decreciente
Comprueba
periódicamente
salud
software
sistemas
nave
espacial
T2
Procesa
datos
imágenes
T3
Realiza
ocasionalmente
comprobación
equipos
ejecutarse
reinicializa
temporizador
valor
máximo
temporizador
vence
asume
integridad
software
vehículo
visto
comprometida
al-
gún
procesador
reinicializan
dispositivos
recarga
completamente
software
verifican
sistemas
nave
espacial
sistema
arranca
secuencia
recuperación
completa
T3
comparten
estructura
datos
protegida
semáforo
binario
s.
Figura
10.9a
muestra
secuencia
causa
inversión
prioridad
t1
T3
comienza
ejecutar
t2
T3
bloquea
semáforo
entra
sección
crítica
t3
T1
prioridad
T3
expulsa
T3
comienza
ejecutar
t4
T1
intenta
entrar
sección
crítica
bloquea
semáforo
propiedad
T3
T3
retoma
ejecución
sección
crítica
t5
T2
prioridad
T3
expulsa
T3
comienza
ejecutar
t6
T2
suspende
causa
relacionada
T1
T2
retoma
T3
t7
T3
abandona
sección
crítica
desbloquea
semáforo
expulsa
T3
bloquea
semáforo
entra
sección
crítica
secuencia
circunstancias
esperar
T2
concluyan
alcanza
rei-
nicializar
temporizador
expire
sistemas
prácticos
utilizan
enfoques
alternativos
evitar
inversión
prioridad
ilimitada
protocolo
herencia
prioridad
protocolo
techo
prioridad
idea
básica
herencia
prioridad
tarea
menor
prioridad
heredará
prio-
ridad
tarea
prioridad
pendiente
recurso
compartan
cambio
prioridad
sucede
tarea
prioridad
bloquea
recurso
finalizar
tarea
menor
prioridad
libera
recurso
Figura
10.9b
muestra
herencia
prioridad
resuelve
problema
inversión
prioridad
ilimitada
ilustrado
Figura
10.9a
secuencia
eventos
relevantes
Planificación
multiprocesador
tiempo
real
475
10-Capitulo
10
16/5/05
17:05
Página
475t1
T3
comienza
ejecutar
t2
T3
bloquea
semáforo
entra
sección
crítica
t3
T1
prioridad
T3
expulsa
T3
comienza
ejecutar
t4
T1
intenta
entrar
sección
crítica
bloquea
semáforo
propiedad
T3
T3
asigna
inmediatamente
temporal
prioridad
T1
T3
reto-
ma
ejecución
sección
crítica
t5
T2
listo
ejecutar
T3
prioridad
T2
expulsar
T3
476
Sistemas
operativos
Aspectos
internos
principios
diseño
T1
T2
T3
Inversión
prioridad
ilimitada
Expulsado
T1
Expulsado
T2
desbloqueado
Tiempo
Ejecución
normal
Ejecución
sección
crítica
bloqueadoBloqueado
T3
intenta
bloquear
t1
t2
t3
t4
t5
t6
t7
t8
T1
T2
T3
bloqueado
T3
herencia
prioridad
Expulsado
T1
desbloqueado
bloqueado
T1
t1
t2
t3
t4
t5
t6
t7
bloqueado
Bloqueado
T3
intenta
bloquear
desbloqueado
Figura
10.9
Inversión
prioridad
10-Capitulo
10
16/5/05
17:05
Página
476t6
T3
abandona
sección
crítica
desbloquea
semáforo
prioridad
reduce
anteriormente
T1
expulsa
T3
bloquea
semáforo
entra
sección
crítica
t7
T1
suspende
causa
relacionada
T2
T2
comienza
ejecutar
enfoque
techo
prioridad
asocia
prioridad
recurso
prioridad
aso-
ciada
recurso
nivel
alta
prioridad
usuario
prioritario
planificador
asigna
prioridad
tarea
acceda
recurso
tarea
termina
recurso
prioridad
restablece
valor
normal
10.3
PLANIFICACIÓN
LINUX
Linux
2.4
anteriores
Linux
capacidad
planificación
tiempo
real
planificador
procesos
tiempo
real
algoritmo
planificación
tradicional
UNIX
descrito
Sección
9.3
Linux
2.6
incluye
esencialmente
capacidad
planifi-
cación
tiempo
real
ediciones
previas
planificador
sustancialmente
modificado
procesos
tiempo
real
Examinemos
áreas
turno
PLANIFICACIÓN
TIEMPO
REAL
clases
planificación
Linux
siguientes
SCHED_FIFO
Hilos
tiempo
real
planificados
FIFO
SCHED_RR
Hilos
tiempo
real
planificados
turno
circular
SCHED_OTHER
hilos
tiempo
real
clase
utilizarse
múltiples
prioridades
prioridades
clases
tiempo
real
mayores
prioridades
clase
SCHED_OTHER
valores
omisión
siguientes
prioridad
clases
tiempo
real
99
inclusive
clase
SCHED_OTHER
100
139
número
menor
significa
prioridad
hilos
FIFO
aplican
siguientes
reglas
sistema
interrumpirá
hilo
FIFO
ejecución
siguientes
casos
hilo
FIFO
prioridad
pasa
listo
hilo
FIFO
ejecución
pasa
bloqueado
espera
evento
S.
hilo
FIFO
ejecución
cede
voluntariamente
procesador
realizando
llamada
primitiva
sched_yield
hilo
FIFO
ejecución
interrumpido
sitúa
cola
asociada
prioridad
hilo
FIFO
pasa
listo
hilo
prioridad
hilo
actualmen-
ejecución
hilo
actualmente
ejecución
expulsado
hilo
FIFO
listo
prioridad
ejecutado
hilo
prioridad
escoge-
rá
hilo
lleve
tiempo
esperando
Planificación
multiprocesador
tiempo
real
477
10-Capitulo
10
16/5/05
17:05
Página
4774
término
O(1
ejemplo
notación
gran-O
usada
caracterizar
complejidad
algoritmos
sitio
web
libro
encontrarse
documento
explica
notación
política
SCHED_RR
similar
política
SCHED_FIFO
añadido
ro-
daja
tiempo
asociada
hilo
hilo
SCHED_RR
ejecutando
rodaja
tiempo
suspende
selecciona
ejecución
hilo
tiempo
real
prioridad
Figura
10.10
ejemplo
ilustra
diferencia
planificaciones
FIFO
RR
Asú-
mase
proceso
hilos
prioridades
relativas
asignadas
muestra
Figura
10.10a
Asúmase
hilos
espera
listos
ejecutar
hilo
actual
pasa
es-
perar
termina
hilo
prioridad
despertado
hilo
ejecutando
Figura
10.10b
muestra
secuencia
hilos
pertenecen
clase
SCHED_FIFO
hilo
ejecuta
espera
termina
hilos
prioridad
arranca
hilo
esperando
tiempo
hilo
C.
hilo
ejecuta
espera
termina
hilo
ejecuta
espera
termina
Finalmente
ejecuta
hilo
A.
Figura
10.10c
muestra
ejemplo
secuencia
hilos
perteneciesen
clase
SCHED_RR
hilo
ejecuta
espera
termina
hilos
entrelazan
tiempo
prioridad
Finalmente
ejecuta
hilo
A.
clase
planificación
SCHED_OTHER
hilo
clase
ejecutar
hilos
tiempo
real
listos
ejecutar
PLANIFICACIÓN
TIEMPO
REAL
planificador
Linux
2.4
clase
SCHED_OTHER
escalaba
número
crecien-
procesadores
número
creciente
procesos
atacar
problema
Linux
2.6
planificador
completamente
conocido
planificador
O(1
planificador
dise-
ñado
tiempo
seleccionar
proceso
adecuado
asignarlo
procesador
constan-
importar
carga
sistema
número
procesadores
núcleo
mantiene
estructuras
datos
planificación
procesador
siste-
ma
forma
Figura
10.11
478
Sistemas
operativos
Aspectos
internos
principios
diseño
Máxima
Prioridades
relativas
hilos
Secuencia
planificación
FIFO
DBCA
Media
Media
MínimaA
Secuencia
planificación
RR
DBCB
Figura
10.10
Ejemplo
planificación
tiempo
real
Linux
10-Capitulo
10
16/5/05
17:05
Página
478struct
prio_array
int
nr_active
número
tareas
array
unsigned
long
bitmap[BITMAP_SIZE
bitmap
prioridades
struct
list_head
queue[MAX_PRIO
colas
prioridad
mantiene
cola
separada
nivel
prioridad
número
colas
estruc-
tura
MAX_PRIO
cuyo
valor
normalmente
140
estructura
incluye
array
bits
tamaño
suficiente
proporcionar
bit
nivel
prioridad
140
niveles
prioridad
palabras
32-bit
BITMAP_SIZE
valor
crea
vector
160
bits
20
ignoran
vector
indica
colas
vacías
Finalmente
nr_active
indica
número
tareas
presente
colas
mantienen
estructuras
estructura
colas
acti-
vas
estructura
colas
vencidas
Inicialmente
vectores
ponen
cero
colas
vacías
proceso
pasa
listo
asigna
cola
prioridad
apropiada
estructura
colas
activas
asigna
rodaja
tiempo
apropiada
tarea
expulsada
completar
rodaja
tiem-
po
devuelve
cola
activa
tarea
completa
rodaja
tiempo
cola
apropiada
estructura
colas
vencidas
asigna
rodaja
tiempo
plani-
ficación
realiza
tareas
estructura
colas
activas
estructura
colas
acti-
vas
vacía
simple
asignación
puntero
resulta
cambio
colas
activas
vencidas
continúa
planificación
Planificación
multiprocesador
tiempo
real
479
Array
prioridad
140
bits
colas
activas
Array
prioridad
140
bits
colas
Bit
prioridad
Cola
activa
vacía
prioridad
Bit
139
prioridad
139
Colas
activas
140
colas
prioridad
cola
contiene
tareas
listas
dicha
prioridad
Colas
vencidas
140
colas
prioridad
cola
contiene
tareas
listas
cuya
rodaja
tiempo
venció
dicha
prioridad
Figura
10.11
Estructuras
datos
planificación
Linux
procesador
10-Capitulo
10
16/5/05
17:05
Página
479La
planificación
simple
eficiente
procesador
planificador
toma
cola
va-
cía
prioridad
múltiples
tareas
cola
tareas
planifican
turno
circular
Linux
incluye
mecanismo
mover
tareas
lista
colas
procesador
Periódicamente
planificador
comprueba
desbalanceo
sustancial
número
tareas
asignadas
procesador
balancear
carga
planificador
transferir
algu-
nas
tareas
tareas
activas
prioridad
seleccionan
transferidas
importante
distribuir
uniformemente
tareas
prioridad
Cálculo
prioridades
rodajas
tiempo
tarea
tiempo
real
asigna
prioridad
inicial
rango
100
139
valor
comisión
120
prioridad
está-
tica
tarea
especificada
usuario
medida
tarea
ejecuta
calcula
priori-
dad
dinámica
función
prioridad
estática
tarea
comportamiento
ejecución
planificador
Linux
diseñado
favorecer
tareas
limitadas
limitadas
procesador
preferencia
tiende
proporcionar
respuesta
interactiva
técnica
utilizada
Linux
determinar
prioridad
dinámica
guardar
información
tiempo
duermen
procesos
esperando
evento
versus
tiempo
ejecutan
esencia
tarea
pierde
tiempo
durmiendo
prioridad
rodajas
tiempo
asignan
rango
10
ms
200
ms
general
tareas
prioridad
asignan
rodajas
tiempo
largas
Relación
tareas
tiempo
real
tareas
tiempo-real
manipulan
distinta
tareas
tiempo
real
colas
prioridad
aplican
siguientes
consideraciones
tareas
tiempo
real
prioridad
estática
realizaron
cálculos
prioridad
dinámica
tareas
SCHED_FIFO
asignadas
rodajas
tiempo
tareas
planifican
si-
guiendo
disciplina
FIFO
tareas
bloquea
desbloquee
volverá
cola
prioridad
lista
colas
activas
tareas
SCHED_RR
asignadas
rodajas
tiempo
traslada
lista
colas
vencidas
tareas
consume
rodaja
tiem-
po
devuelve
cola
prioridad
valor
rodaja
tiempo
valores
rodaja
tiempo
cambian
efecto
reglas
cambio
lista
colas
activas
lista
colas
vencidas
sucede
tareas
tiempo
real
listas
esperando
ejecutar
10.4
PLANIFICACIÓN
UNIX
SVR4
algoritmo
planificación
utilizado
UNIX
SVR4
revisión
completa
algoritmo
planificación
utilizado
sistemas
UNIX
anteriores
descrito
Sección
9.3
algorit-
mo
diseñado
preferencia
procesos
tiempo
real
pre-
ferencia
procesos
núcleo
menor
preferencia
procesos
modo-usuario
co-
nocidos
procesos
tiempo
compartido
principales
modificaciones
implementadas
SVR4
siguientes
añadido
planificador
prioridad
estática
expulsivo
introducción
conjunto
160
niveles
prioridad
divididos
clases
prioridad
480
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
4802
inserción
puntos
expulsión
núcleo
básico
expulsivo
dividido
pasos
proceso
ejecutar
conclusión
interrupción
En-
tre
pasos
proceso
identificado
puntos
expulsión
núcleo
interrumpido
segura
planificar
proceso
punto
seguro
define
región
código
estructuras
datos
núcleo
ac-
tualizadas
consistentes
bloqueadas
semáforo
Figura
10.12
ilustra
160
niveles
prioridad
definidos
SVR4
proceso
define
perteneciente
clases
prioridad
asigna
nivel
prioridad
clase
clases
siguientes
Tiempo-real
159-100
procesos
niveles
prioridad
garantiza
ele-
gidos
ejecutar
proceso
núcleo
tiempo
compartido
procesos
tiempo
real
puntos
expulsión
expulsar
proce-
sos
núcleo
procesos
usuario
Núcleo
99-60
procesos
niveles
prioridad
garantiza
elegidos
ejecutar
proceso
tiempo
compartido
retrasados
procesos
tiempo
real
Tiempo-compartido
59-0
procesos
baja
prioridad
pensados
aplica-
ciones
usuario
tiempo
real
Planificación
multiprocesador
tiempo
real
481
Clase
prioridad
Tiempo
real
Núcleo
Tiempo
compartido
Valor
global
Secuencia
planificación
159
100
99
60
59
Figura
10.12
Clases
prioridad
SVR4
0111
159
012n
dqactmap
dispq
PP
Figura
10.13
Colas
activación
SVR4
10-Capitulo
10
16/5/05
17:05
Página
481La
Figura
10.13
indica
implementada
planificación
SVR4
Asociada
ni-
vel
prioridad
cola
activación
procesos
nivel
prioridad
ejecutan
turno
circular
vector
bits
dqactmap
contiene
bit
nivel
prioridad
bit
pone
nivel
prioridad
cola
vacía
proceso
activo
abando-
na
Ejecución
bloqueo
vencimiento
rodaja
tiempo
expulsión
activador
comprueba
dqactmap
activa
proceso
listo
cola
vacía
prioridad
alcanza
puntos
expulsión
definidos
núcleo
comprueba
varia-
ble
llamada
kprunrun
significa
proceso
tiempo
real
Listo
núcleo
expulsa
proceso
actual
menor
prioridad
proceso
listo
tiempo
real
prioridad
clase
tiempo
compartido
prioridad
procesos
variable
planificador
reduce
prioridad
proceso
utiliza
totalmente
tiempo
eleva
prioridad
bloquea
evento
recurso
tiempo
ubicado
proceso
tiempo
compartido
depende
prioridad
yendo
100
ms
prioridad
10
ms
prioridad
59
proceso
tiempo
real
prioridad
fija
tiempo
fijo
10.5
PLANIFICACIÓN
WINDOWS
Windows
diseñado
sensible
necesidades
único
usuario
entorno
altamente
interactivo
papel
servidor
Windows
implementa
planifica-
dor
expulsivo
sistema
flexible
niveles
prioridad
incluye
planificación
turno
circular
nivel
niveles
variación
dinámica
prioridad
base
ac-
tividad
hilo
actual
PRIORIDAD
PROCESOS
HILOS
prioridades
Windows
organizan
bandas
clases
tiempo
real
variable
bandas
consiste
16
niveles
prioridad
hilos
precisan
atención
inmediata
clase
tiempo
real
incluye
funciones
comunicaciones
tareas
tiempo
real
general
Windows
planificador
expulsivo
basado
prioridades
hilos
prioridades
tiempo
real
preferencia
hilos
monoprocesador
hilo
cuya
prioridad
hilo
actualmente
ejecución
pasa
listo
hilo
prioritario
expulsado
entrega
procesador
hilo
prioridad
prioridades
manejan
clases
Figura
10.14
clase
prioridad
tiempo
real
hilos
prioridad
fija
cambia
clase
prioridad
variable
prioridad
hilo
comienza
valor
asignado
inicialmente
cambiar
abajo
vida
hilo
cola
FIFO
nivel
prioridad
proceso
migrar
colas
clase
prioridad
varia-
ble
obstante
hilo
nivel
prioridad
15
pasar
nivel
16
nivel
clase
tiempo
real
prioridad
inicial
hilo
clase
prioridad
variable
determina
base
canti-
dades
prioridad
base
proceso
prioridad
base
hilo
atributos
objeto
pro-
ceso
prioridad
base
proceso
tomar
valor
15
objeto
hilo
asociado
objeto
proceso
atributo
prioridad
base
hilo
indica
prioridad
base
hilo
relativa
proceso
prioridad
base
hilo
proceso
den-
tro
niveles
proceso
ejemplo
proceso
482
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
482prioridad
base
hilos
prioridad
base
-1
prioridad
inicial
hilo
hilo
clase
prioridad
variable
activado
prioridad
real
conocida
prioridad
dinámica
hilo
fluctuar
límites
dados
prioridad
dinámica
caer
rango
inferior
prioridad
base
hilo
exceder
15
Figura
10.15
ofrece
ejemplo
objeto
proceso
atributo
prioridad
base
objeto
hilo
asociado
objeto
proceso
prioridad
inicial
prioridad
dinámica
hilo
fluctuar
rango
15
hilo
interrumpido
por-
usado
completamente
tiempo
actual
ejecutivo
Windows
baja
prioridad
hilo
interrumpe
esperar
evento
ejecutivo
Windows
sube
priori-
dad
hilos
limitados
procesador
tienden
prioridades
menores
hilos
limitados
tienden
prioridades
mayores
caso
hilos
limitados
ejecutivo
sube
prio-
ridad
esperas
interactivas
ejemplo
espera
teclado
pantalla
tipo
ejemplo
disco
hilos
interactivos
tienden
mayores
prioridades
clase
prioridad
variable
Planificación
multiprocesador
tiempo
real
483
31
Menor
16
15
Menor
Clases
prioridad
tiempo
real
Clases
prioridad
variable
Figura
10.14
Prioridades
activación
hilos
Windows
10-Capitulo
10
16/5/05
17:05
Página
483PLANIFICACIÓN
MULTIPROCESADOR
Windows
ejecuta
procesador
único
hilo
prioridad
activo
esperando
evento
hilo
prioridad
enton-
ces
comparte
procesador
turno
circular
hilos
nivel
prioridad
sistema
multiprocesador
procesadores
hilos
prioridad
acti-
vos
ejecutando
exclusiva
procesadores
extra
resto
hilos
menor
prio-
ridad
comparten
único
procesador
restante
ejemplo
procesadores
hilos
prioridad
ejecutan
procesadores
restantes
hilos
ejecutan
procesa-
dor
restante
disciplina
ve
afectada
atributo
hilo
denominado
afinidad
procesa-
dor
hilo
listo
ejecutar
únicos
procesadores
disponibles
con-
procesadores
afines
hilo
forzado
esperar
ejecutivo
planificará
hilo
disponible
10.6
RESUMEN
multiprocesador
fuertemente
acoplado
múltiples
procesadores
acceso
me-
moria
principal
configuración
estructura
planificación
compleja
ejemplo
proceso
asignado
procesador
vida
activado
procesador
entra
Ejecutable
estudios
prestaciones
sugieren
diferencias
algoritmos
planificación
signifi-
cantes
sistemas
multiprocesador
proceso
tarea
tiempo
real
ejecuta
conexión
procesos
fun-
ciones
conjunto
eventos
externos
sistema
computador
cumplir
plazos
interactuar
efectiva
correctamente
entorno
externo
sistema
operativo
tiempo
real
capaz
manejar
procesos
tiempo
real
contexto
criterios
tradicionales
algoritmos
planificación
cabida
cambio
factor
clave
cumplir
plazos
484
Sistemas
operativos
Aspectos
internos
principios
diseño
Prioridad
base
Normal
normal
Menor
normal
15
14
13
12
11
10
Prioridad
proceso
Prioridad
base
hilo
Prioridad
dinámica
hilo
Figura
10.15
Ejemplo
relación
prioridades
Windows
10-Capitulo
10
16/5/05
17:05
Página
484tiempo
algoritmos
apropiados
contexto
basan
fundamentalmente
expulsión
reaccionar
plazos
tiempo
relativos
10.7
LECTURAS
RECOMENDADAS
WEND89
expone
interesante
enfoques
planificación
multiprocesador
tratamiento
planificación
tiempo
real
contenido
LIU00
siguientes
colec-
ciones
contienen
artículos
importantes
sistemas
operativos
tiempo
real
planificación
KRIS94
STAN93
LEE93
TILB91
SHA90
proporciona
explicación
in-
versión
prioridad
herencia
prioridad
techo
prioridad
ZEAD97
analiza
prestacio-
nes
planificador
tiempo
real
SVR4
LIND04
proporciona
resumen
planificador
Linux
2.6
LOVE04
contiene
exposición
detallada
KRIS94
Krishna
C.
Lee
eds
Special
Issue
on
Real-Time
Systems
Proceedings
of
the
IEEE
Ene-
ro
1994
LEE93
Lee
Krishna
C.
eds
Readings
in
Real-Time
Systems
Alamitos
CA
IEEE
Computer
So-
ciety
Press
1993
LIND04
Lindsley
R.
What’s
New
in
the
2.6
Scheduler
Linux
Journal
Marzo
2004
LIU00
Liu
J.
Real-Time
Systems
Upper
Saddle
River
NJ
Prentice
Hall
2000
LOVE04
Love
R.
Linux
Kernel
Development
Indianapolis
IN
Sams
Publishing
2004
SHA90
Sha
L.
Rajkumar
R.
Lehoczky
J.
Priority
Inheritance
Protocols
An
Approach
to
Real-Time
Synchronization
IEEE
Transactions
on
Computers
Septiembre
1990
STAN93
Stankovic
J.
Ramamritham
K.
eds
Advances
in
Real-Time
Systems
Alamitos
CA
IEEE
Computer
Society
Press
1993
TILB91
Tilborg
A.
Koob
eds
Foundations
of
Real-Time
Computing
Scheduling
and
Resource
Management
Boston
Kluwer
Academic
Publishers
1991
WEND89
Wendorf
J.
Wendorf
R.
Tokuda
H.
Scheduling
Operating
System
Processing
on
Small-
Scale
Microprocessors
Proceedings
22nd
Annual
Hawaii
International
Conference
on
System
Science
Enero
1989
ZEAD97
Zeadally
S.
An
Evaluation
of
the
Real-Time
Performance
of
SVR4.0
and
SVR4.2
Operating
Systems
Review
Enero
1977
10.8
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
compartición
carga
planificación
pandilla
sistema
operativo
tiempo-real
granularidad
planificación
tasa
monótona
tarea
aperiódica
inversión
prioridad
planificación
tiempo
real
tarea
tiempo
real
duro
inversión
prioridad
ilimitada
planificación
plazo
tarea
tiempo
real
suave
operación
fallo
suave
sensibilidad
tarea
periódica
planificación
hilos
sistema
operativo
determinista
Planificación
multiprocesador
tiempo
real
485
10-Capitulo
10
16/5/05
17:05
Página
485CUESTIONES
REPASO
10.1
Enumere
defina
brevemente
categorías
granularidad
sincronización
10.2
Enumere
defina
brevemente
técnicas
planificación
hilos
10.3
Enumere
defina
brevemente
versiones
compartición
carga
10.4
diferencia
tareas
tiempo
real
duro
suave
10.5
diferencia
tareas
tiempo
real
periódicas
aperiódicas
10.6
Enumere
defina
brevemente
áreas
generales
requisitos
sistema
operati-
vo
tiempo
real
10.7
Enumere
defina
brevemente
clases
algoritmos
planificación
tiempo
real
10.8
elementos
información
tarea
útiles
planificación
tiempo
real
PROBLEMAS
10.1
Considere
conjunto
tareas
periódicas
perfiles
ejecución
Tabla
10.5
Desarrolle
diagramas
planificación
similares
Figura
10.5
con-
tareas
10.2
Considere
conjunto
tareas
aperiódicas
perfiles
ejecución
Tabla
10.6
Desarrolle
diagramas
planificación
similares
Figura
10.6
con-
tareas
10.3
problema
demuestra
Ecuación
10.2
planificación
tasa
mo-
nótona
condición
suficiente
planificación
satisfactoria
condición
necesaria
planificación
satisfactoria
Ecuación
10.2
satisfaga
Considere
conjunto
tareas
periódicas
independientes
Tarea
C1
20
T1
100
Tarea
P2
C2
30
T2
145
planificarse
satisfactoriamente
tareas
usando
planificador
tasa
monótona
Añada
tarea
conjunto
Tarea
P3
C3
68
T3
150
satisface
Ecuación
10.2
Suponga
instancia
tareas
precedentes
llega
instante
Asuma
plazo
tiempo
tarea
D1
100
D2
145
D3
150
Usando
planificación
tasa
monótona
cumplirán
plazos
plazos
futuras
repeticiones
tarea
10.4
Dibuje
diagrama
similar
Figura
10.9b
muestre
secuencia
eventos
ejemplo
usando
techo
prioridad
486
Sistemas
operativos
Aspectos
internos
principios
diseño
10-Capitulo
10
16/5/05
17:05
Página
486
abla
10.5
Perfil
ejecución
problema
10.1
Proceso
Tiempo
llegada
Tiempo
ejecución
Plazo
conclusión
A(1
10
20
A(2
20
10
40
B(1
10
50
B(2
50
10
100
C(1
15
50
C(2
50
15
100
abla
10.6
Perfil
ejecución
problema
10.2
Proceso
Tiempo
llegada
Tiempo
ejecución
Plazo
comienzo
A1
00
02
03
02
06
02
08
02
07
Planificación
multiprocesador
tiempo
real
487
10-Capitulo
10
16/5/05
17:05
Página
48710-Capitulo
10
16/5/05
17:05
Página
488PARTE
ENTRADA
SALIDA
FICHEROS
robablemente
sistema
sistema
gestión
ficheros
partes
intrin-
cadas
diseño
sistema
operativo
aspecto
fundamental
rendimiento
sistema
realmente
factor
clave
obtener
rendi-
miento
sistema
Observando
operación
interno
computador
apre-
ciar
velocidad
computador
continúa
incrementándose
caso
único
proce-
sador
suficientemente
rápido
configuraciones
SMP
proporcionan
múltiples
procesadores
acelerar
trabajo
velocidades
acceso
memoria
interna
incrementándose
rápidamente
velocidad
procesador
obstante
inteligente
niveles
cache
interna
logrando
mantener
tiempo
acceso
memoria
principal
acorde
velocidad
procesador
supone
reto
significativo
rendimiento
particularmente
caso
almacenamiento
disco
sistema
ficheros
rendimiento
aspecto
Asi-
entran
juego
requisitos
diseño
fiabilidad
seguridad
punto
vista
usuario
sistema
ficheros
aspecto
importante
sistema
ope-
rativo
usuario
desea
acceso
rápido
ficheros
garantice
fiche-
ros
corrompen
seguros
frente
accesos
autorizados
GUÍA
QUINTA
CAPÍTULO
11
GESTIÓN
PLANIFICACIÓN
DISCO
Capítulo
11
comienza
introducción
dispositivos
almacenamiento
or-
ganización
sistema
sistema
operativo
capítulo
continúa
estudio
di-
versas
estrategias
gestión
buffers
mejorar
rendimiento
resto
capítulo
dedica-
do
disco
analizará
planificar
múltiples
peticiones
disco
aprovechen
características
físicas
acceso
disco
mejorar
tiempo
res-
puesta
continuación
examinará
vectores
discos
mejorar
rendimiento
fiabilidad
estudiará
cache
disco
11-Capitulo
11
16/5/05
17:06
Página
489CAPÍTULO
12
GESTIÓN
FICHEROS
Capítulo
12
ofrece
estudio
diversos
tipos
organizaciones
ficheros
examina
aspec-
tos
sistema
operativo
relacionados
gestión
acceso
ficheros
estudia
organización
física
lógica
datos
examinan
servicios
relacionados
gestión
ficheros
proporciona
sistema
operativo
convencional
usuarios
continuación
pre-
sentan
mecanismos
específicos
estructuras
datos
forman
sistema
gestión
ficheros
11-Capitulo
11
16/5/05
17:06
Página
490CAPÍTULO
Gestión
planificación
disco
11.1
Dispositivos
11.2
Organización
sistema
11.3
Aspectos
diseño
sistema
operativo
11.4
Utilización
buffers
11.5
Planificación
disco
11.6
RAID
11.7
Cache
disco
11.8
UNIX
SVR4
11.9
Linux
11.10
Windows
11.11
Resumen
11.12
Lecturas
sitios
web
recomendados
11.13
érminos
clave
cuestiones
repaso
problemas
Apéndice
11A
Dispositivos
almacenamiento
disco
11-Capitulo
11
16/5/05
17:06
Página
491N
Probablemente
aspecto
intrincado
diseño
sistema
operativo
variedad
dispositivos
aplicaciones
difícil
desarrollar
solución
general
uniforme
capítulo
comienza
estudio
dispositivos
organización
sistema
S.
temas
generalmente
pertenecen
ámbito
arquitectura
computadores
establecen
base
estudio
punto
vista
sistema
operativo
sección
estudian
aspectos
diseño
sistema
operativo
incluyendo
obje-
tivos
diseño
organizar
sistema
S.
continuación
exami-
nará
buffers
operaciones
servicios
básicos
proporciona-
sistema
operativo
sistema
gestión
buffers
mejora
rendimiento
general
siguientes
secciones
capítulo
estarán
dedicadas
disco
magnético
siste-
contemporáneos
forma
importante
resultando
fundamental
ren-
dimiento
percibe
usuario
comienza
desarrollando
modelo
rendimiento
disco
continuación
estudian
diversas
técnicas
utilizarse
mejorar
rendimiento
apéndice
capítulo
resume
características
dispositivos
almacena-
miento
secundario
incluyendo
disco
magnético
memoria
óptica
11.1
DISPOSITIVOS
Capítulo
dispositivos
externos
dedicados
computador
agrupar
rasgos
categorías
Legibles
usuario
Adecuados
comunicación
usuario
computador
ejemplos
impresoras
terminales
visualización
gráfica
constan
pantalla
teclado
posiblemente
dispositivos
ratón
Legibles
máquina
Adecuados
comunicación
equipamiento
electrónico
ejemplos
unidades
discos
cintas
sensores
controladores
activadores
Comunicación
Adecuados
comunicación
dispositivo
remotos
ejemplos
controladores
línea
digital
módems
diferencias
distintas
categorías
dife-
rencias
fundamentales
encuentran
siguientes
Velocidad
transferencia
datos
diferencias
órdenes
magnitud
velocidades
transferencia
datos
Figura
11.1
muestra
ejemplos
Aplicación
destinado
dispositivo
influencia
software
políticas
sistema
operativo
herramientas
soporte
ejemplo
disco
utilizado
almacenar
ficheros
requiere
soporte
software
gestión
ficheros
disco
utilizado
almacenamiento
respaldo
páginas
esque-
ma
memoria
virtual
depende
hardware
software
memoria
virtual
Ade-
distintas
aplicaciones
disco
impacto
algoritmos
plani-
ficación
disco
estudiarán
capítulo
ejemplo
adicional
considere
terminal
utilizar
usuario
normal
administrador
492
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
492sistema
usos
implican
niveles
privilegios
posiblemente
prioridades
dife-
rentes
sistema
operativo
Complejidad
control
impresora
requiere
interfaz
control
sencilla
disco
complejo
efecto
diferencias
sistema
operativo
filtra
cier-
to
punto
módulo
controla
dispositivo
estudiará
próxima
sección
Unidad
transferencia
datos
transferirse
flujo
bytes
caracteres
ejemplo
terminal
bloques
tamaño
ejemplo
disco
Representación
datos
dispositivos
utilizan
esquemas
codificación
datos
incluyendo
diferencias
código
carácter
convenciones
paridad
Condiciones
error
naturaleza
errores
notifican
consecuen-
cias
rango
disponible
respuestas
difieren
considerablemente
dispositivo
diversidad
difícil
lograr
enfoque
coherente
uniforme
punto
vista
sistema
operativo
procesos
usuario
11.2
ORGANIZACIÓN
SISTEMA
Sección
1.7
presentó
técnicas
cabo
programada
procesador
envía
mandato
petición
proceso
mó-
dulo
continuación
proceso
realiza
espera
activa
complete
operación
continuar
Gestión
planificación
disco
493
Teclado
101
102
103
104
105
Velocidad
transferencia
datos
bps
106
107
108
109
Ratón
Módem
Ethernet
Disco
duro
Pantalla
gráfica
Ethernet
Gigabit
Disquete
Impresión
láser
Escáner
Disco
óptico
Figura
11.1
Velocidad
típica
transferencia
datos
S.
11-Capitulo
11
16/5/05
17:06
Página
493•
dirigida
interrupciones
procesador
emite
mandato
petición
proceso
continúa
ejecutando
instrucciones
siguientes
interrumpido
módulo
completado
trabajo
siguientes
instrucciones
mis-
mo
proceso
caso
proceso
necesite
esperar
complete
S.
caso
contrario
suspende
proceso
espera
interrupción
realiza
trabajo
Acceso
directo
memoria
Direct
Memory
Access
DMA
módulo
DMA
controla
intercambio
datos
memoria
principal
módulo
S.
procesador
manda
petición
transferencia
bloque
datos
módulo
DMA
resulta
interrumpido
transferido
bloque
completo
Tabla
11.1
indica
relación
técnicas
mayoría
computadores
DMA
forma
transferencia
predominante
sistema
operativo
soporte
abla
11.1
Técnicas
S.
interrupciones
interrupciones
ransferencia
memoria
procesador
programada
dirigida
interrupciones
ransferencia
directa
memoria
Acceso
directo
memoria
DMA
EVOLUCIÓN
SISTEMA
computadores
ido
evolucionando
habido
tendencia
creciente
compleji-
dad
sofisticación
componentes
individuales
tendencia
evidente
funciones
S.
etapas
evolución
resumir
si-
guiente
procesador
controla
directamente
dispositivo
periférico
situación
presenta
dispositivos
simples
controlados
microprocesador
añade
controlador
módulo
S.
procesador
programada
interrupcio-
nes
paso
procesador
independiza
detalles
específicos
interfaces
dispositivos
externos
utiliza
configuración
etapa
empleando
interrupciones
procesador
necesita
gastar
tiempo
esperando
realice
operación
incre-
mentando
eficiencia
módulo
control
directo
memoria
DMA
mover
bloque
datos
memoria
involucrar
procesador
principio
transferencia
mejora
módulo
convertirse
procesador
independiente
juego
instrucciones
especializadas
adaptadas
S.
unidad
central
procesamiento
CPU
procesador
ejecute
programa
residente
memoria
principal
procesador
lee
ejecuta
instrucciones
intervención
procesador
permite
procesador
especifique
secuencia
actividades
interrum-
pido
termine
secuencia
completa
494
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
4946
módulo
memoria
local
computador
derecho
arquitectura
controlar
conjunto
dispositivos
intervención
mínima
procesador
común
arquitectura
controlar
comunicación
terminales
interactivos
procesador
encarga
mayoría
tareas
involucradas
control
terminales
avanza
proceso
evolución
ta-
reas
realizan
intervención
procesador
procesador
quedando
relevado
gradualmente
tareas
relacionadas
mejorando
rendimiento
etapas
produce
cambio
principal
introducción
concepto
módulo
capaz
ejecutar
programa
nota
terminología
módulos
descritos
etapas
cuarta
sexta
término
acceso
directo
memoria
Direct
Access
Memory
DMA
apropiado
de-
bido
tipos
módulos
implican
control
directo
memoria
principal
módulo
S.
Asimismo
módulo
quinta
etapa
denomina
usualmente
canal
sexta
etapa
procesador
término
ocasiones
aplicado
ambas
situaciones
sección
utilizará
término
canal
referir-
tipos
módulos
S.
ACCESO
DIRECTO
MEMORIA
Figura
1.12
indica
términos
generales
lógica
DMA
unidad
DMA
capaz
imitar
procesador
tomando
control
bus
sistema
procesador
uni-
dad
DMA
necesita
transferir
datos
memoria
usando
bus
sistema
Gestión
planificación
disco
495
Registros
direcciones
Lógica
control
Registros
datos
Contador
datos
Líneas
datos
Líneas
direcciones
Solicitud
DMA
Reconocimiento
DMA
Interrupción
Lectura
Escritura
Figura
11.2
Típico
diagrama
bloques
DMA
11-Capitulo
11
16/5/05
17:06
Página
495La
técnica
DMA
funciona
describe
continuación
procesador
leer
escribir
bloque
datos
envía
mandato
módulo
DMA
especificándole
si-
guiente
información
operación
lectura
escritura
utilizando
línea
control
lectura
escritura
procesador
módulo
DMA
dirección
dispositivo
involucrado
comunicándoselo
líneas
datos
dirección
inicial
memoria
pretende
leer
escribir
comunicándoselo
líneas
datos
almacenándose
registro
dirección
módulo
DMA
número
palabras
leer
escribir
comunicándoselo
lí-
neas
datos
almacenándose
registro
contador
datos
continuación
computador
continúa
trabajo
delegado
operación
módulo
DMA
módulo
DMA
transfiere
bloque
completo
datos
palabra
palabra
di-
rectamente
memoria
pasar
procesador
completa
trans-
ferencia
módulo
DMA
envía
señal
interrupción
procesador
procesador
involucrado
principio
transferencia
Figura
1.19c
mecanismo
DMA
configurar
maneras
Figura
11.3
muestran
al-
gunas
alternativas
ejemplo
módulos
comparten
bus
sistema
módulo
DMA
actuando
procesador
subordinado
programada
intercambiar
datos
memoria
módulo
módulo
DMA
configuración
económica
claramente
ineficiente
ocurre
programada
controlada
procesador
transferencia
palabra
consume
ciclos
bus
petición
transfe-
rencia
seguida
transferencia
número
ciclos
bus
requeridos
recortarse
sustancialmente
integrando
DMA
funciones
S.
indica
Figura
11.3b
significa
camino
módulo
DMA
módulos
incluye
bus
sistema
lógica
DMA
realmente
módulo
módulo
separado
controla
módulos
S.
concepto
paso
allá
conectando
módulos
módulo
DMA
utilizando
bus
Figura
11.3c
reduce
número
interfa-
ces
módulo
DMA
proporciona
configuración
fácilmente
expansible
casos
Figuras
11.3
módulo
DMA
utiliza
bus
sistema
comparte
procesador
memoria
principal
intercambiar
datos
memoria
señales
control
procesador
intercambio
datos
módulos
DMA
lugar
bus
sistema
11.3
ASPECTOS
DISEÑO
SISTEMA
OPERATIVO
OBJETIVOS
DISEÑO
objetivos
suma
importancia
diseño
sistema
eficiencia
generalidad
eficiencia
importante
operaciones
usualmente
significan
cuello
bo-
tella
computador
Examinando
Figura
11.1
observará
mayoría
dispositivos
extremadamente
lentos
comparados
memoria
principal
procesa-
dor
afrontar
problema
multiprogramación
estudió
previa-
mente
permite
procesos
esperen
finalización
operaciones
496
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
496está
ejecutando
proceso
enorme
tamaño
memoria
principal
máquinas
dará
frecuencia
situación
se-
guir
ritmo
procesador
utilizar
intercambio
procesos
listos
mantener
ocupado
procesador
operación
S.
dedicado
considerable
esfuerzo
diseño
plantear
esque-
mejoren
eficiencia
S.
área
recibido
atención
importancia
disco
capítulo
dedicado
estudio
eficiencia
disco
objetivo
principal
generalidad
aras
simplicidad
eliminación
erro-
res
deseable
manejar
dispositivos
uniforme
afirmación
aplica
procesos
ven
dispositivos
sistema
operativo
gestiona
dispositivos
operaciones
S.
diversidad
caracterís-
ticas
dispositivos
difícil
práctica
alcanzar
generalidad
utilizar
estrategia
modular
jerárquica
diseñar
funciones
S.
estrategia
escon-
mayoría
detalles
dispositivo
rutinas
nivel
inferior
procesos
usuario
niveles
altos
sistema
operativo
contemplan
dispositivos
tér-
minos
funciones
generales
tales
lectura
escritura
abrir
cerrar
establecer
cerrojo
libe-
rarlo
continuación
estudia
estrategia
Gestión
planificación
disco
497
Procesador
DMA
Único
bus
DMA
independiente
Único
bus
DMA-E
integrado
Bus
Bus
Bus
sistema
Memoria
DMA
DMA
DMA
Procesador
Memoria
MemoriaProcesador
Figura
11.3
Configuraciones
DMA
alternativas
11-Capitulo
11
16/5/05
17:06
Página
497ESTRUCTURA
LÓGICA
SISTEMA
Capítulo
estudio
estructura
sistema
enfatizó
naturaleza
jerárquica
sistemas
operativos
modernos
filosofía
jerárquica
basa
funciones
sistema
operativo
deberían
separadas
dependiendo
complejidad
escala
tiempo
caracte-
rística
nivel
abstracción
estrategia
conduce
organización
sistema
operativo
serie
niveles
nivel
realiza
subconjunto
relacionado
funciones
requeridas
sistema
operativo
apoya
nivel
inferior
subyacente
funciones
bási-
cas
ocultar
detalles
funciones
proporcionando
servicios
nivel
superior
Idealmente
niveles
deberían
definir
cambios
nivel
requieran
cambios
niveles
descompuesto
problema
subproblemas
manejables
general
niveles
inferiores
tratan
escala
tiempo
corta
par-
tes
sistema
operativo
interaccionar
directamente
hardware
computador
eventos
escala
tiempo
nanosegundos
extremo
espectro
situán
partes
sistema
operativo
comunican
usuario
emite
mandatos
ritmo
sosegado
segundos
con-
niveles
ajusta
perfectamente
entorno
Aplicando
filosofía
específicamente
sistema
llega
tipo
organización
sugeri-
Figura
11.4
compárese
Tabla
2.4
detalles
organización
dependerán
tipo
dispositivo
aplicación
estructuras
lógicas
importantes
representadas
figura
sistema
operativo
ajuste
exactamente
estructuras
principios
generales
válidos
esquema
mayoría
sis-
temas
operativos
encaja
descrito
Considérese
lugar
caso
simple
dispositivo
periférico
local
co-
munica
sencilla
flujo
bytes
registros
Figura
11.4a
niveles
in-
volucrados
siguientes
lógica
módulo
lógica
dispositivos
recurso
lógico
ocupa
detalles
control
real
dispositivo
módulo
lógica
ocupa
gestión
tareas
generales
procesos
usuario
permitiéndolos
tratar
dispositivo
términos
identificador
dispositivo
mandatos
sencillos
abrir
cerrar
leer
escribir
dispositivo
operaciones
requeridas
datos
caracteres
buffers
regis-
tros
etc.
convierten
secuencias
apropiadas
instrucciones
mandatos
canal
órdenes
controlador
utilizar
técnicas
buffers
mejorar
utilización
Planificación
control
gestión
real
cola
planificación
operaciones
producen
nivel
control
operaciones
nivel
manejan
interrupciones
recoge
informa
nivel
software
realmente
interactúa
módulo
hardware
dispositivo
dispositivo
comunicación
estructura
Figura
11.4b
an-
teriormente
descrita
diferencia
fundamental
módulo
lógica
reemplaza
arquitectura
comunicación
consistir
niveles
ejemplo
TCP
IP
estudiará
Capítulo
13
498
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
498La
Figura
11.4c
muestra
estructura
representativa
gestión
dispositivo
almacenamiento
secundario
proporciona
soporte
sistema
ficheros
niveles
presentado
previamente
Gestión
directorios
nivel
nombres
simbólicos
ficheros
convierten
identificadores
referencia
directamente
fichero
indirectamente
descriptor
fichero
tabla
índices
nivel
ocupa
operacio-
nes
usuario
afectan
directorio
ficheros
tales
añadir
borrar
reorganizar
Sistema
ficheros
nivel
estructura
lógica
ficheros
opera-
ciones
especificar
usuarios
abrir
cerrar
leer
escribir
derechos
acceso
gestionan
nivel
Organización
física
direcciones
memoria
virtual
con-
vertirse
direcciones
físicas
memoria
principal
teniendo
estructura
seg-
mentación
paginación
referencias
lógicas
ficheros
registros
convertir
direcciones
físicas
almacenamiento
secundario
teniendo
estructura
pistas
Gestión
planificación
disco
499
Puerto
comunicación
Hardware
Procesos
usuario
lógica
Planificación
control
Dispositivo
periférico
local
Hardware
Gestión
directorios
Sistema
ficheros
Organización
física
dispositivo
Sistema
fichero
Hardware
Arquitectura
comunicaciones
Procesos
usuario
Procesos
usuario
dispositivo
dispositivo
Planificación
control
Planificación
control
Figura
11.4
modelo
organización
S.
11-Capitulo
11
16/5/05
17:06
Página
499y
sectores
dispositivo
almacenamiento
secundario
asignación
espacio
alma-
cenamiento
secundario
buffers
almacenamiento
principal
tratan
nivel
Dada
importancia
sistema
ficheros
dedicará
tiempo
capítulo
estudiar
diversos
componentes
estudio
capítulo
centra
niveles
inferiores
Capítulo
12
presentarán
niveles
superiores
11.4
UTILIZACIÓN
BUFFERS
Supóngase
proceso
usuario
desea
leer
bloques
datos
cinta
tenien-
do
bloque
longitud
512
bytes
datos
leerse
zona
datos
espa-
cio
direcciones
proceso
usuario
corresponde
direcciones
virtuales
1000
1511
sencilla
enviar
mandato
similar
Leer_Blo-
que[1000
cinta
unidad
cinta
continuación
esperar
datos
estén
disponibles
espera
activa
comprobando
continuamente
dispositivo
práctica
suspendiendo
proceso
produzca
interrupción
estrategia
conlleva
problemas
programa
queda
esperando
com-
plete
relativamente
lenta
operación
S.
problema
estrategia
in-
terfiere
decisiones
intercambio
sistema
operativo
posiciones
virtuales
1000
1511
permanecer
memoria
principal
curso
transferencia
blo-
caso
contrario
perder
datos
utiliza
paginación
página
contiene
posiciones
memoria
requeridas
fijarse
residente
memoria
princi-
pa
l.
páginas
proceso
expulsarse
disco
imposible
expulsar
completamente
proceso
precise
sistema
operativo
Nótese
riesgo
produzca
interbloqueo
único
proceso
proceso
emite
mandato
suspende
esperando
resultado
continuación
expulsa
inicio
operación
proceso
bloquea
esperando
evento
operación
bloquea
esperando
proceso
traiga
memoria
evitar
interbloqueo
memoria
usuario
involu-
crada
operación
quedarse
residente
memoria
principal
inmediatamente
emita
petición
operación
encole
ejecutar-
tiempo
consideraciones
aplican
operación
salida
transfiriendo
blo-
área
proceso
usuario
directamente
módulo
proceso
bloquea
du-
rante
transferencia
proceso
expulsarse
evitar
sobrecargas
ineficiencias
conveniente
transferencias
entrada
hagan
peticiones
correspondientes
cabo
transferencias
sa-
lida
tiempo
petición
técnica
conoce
buffers
sección
analizarán
esquemas
gestión
buffers
proporcionan
sistemas
operativos
mejorar
rendimiento
sistema
hora
analizar
distintas
estrategias
gestión
buffers
importante
distinción
tipos
dispositivos
orientados
bloques
orientados
flujo
caracteres
dispositivo
orientado
bloques
almacena
información
bloques
usual-
mente
tamaño
fijo
realizándose
transferencias
bloque
bloque
Generalmente
referencia
datos
número
bloque
discos
cintas
ejemplos
dispositivos
orientados
bloques
dispositivo
orientado
flujo
caracteres
transfiere
datos
entrada
salida
flujo
bytes
estructura
bloques
ter-
minales
impresoras
puertos
comunicación
ratón
dispositivos
apuntadores
500
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
500la
mayoría
dispositivos
almacenamiento
secundario
orientados
flujos
caracteres
BUFFER
ÚNICO
tipo
sencillo
esquema
proporcionar
sistema
operativo
buffer
único
Figu-
ra
11.5b
proceso
usuario
emite
petición
sistema
operativo
asigna
buffer
operación
sistema
memoria
principal
dispositivos
orientados
bloques
esquema
buffer
único
describir
transferencias
entrada
buffer
sistema
completa
transferencia
proceso
mueve
bloque
espacio
usuario
inmediatamente
pide
bloque
denomina
lectura
adelantada
entrada
anticipada
operación
realiza
esperan-
za
acabará
necesitando
bloque
tipos
cómputos
suposi-
ción
razonable
tiempo
normalmente
accede
datos
forma
secuencial
secuencia
procesamiento
leerá
innecesariamente
bloque
estrategia
proporcionará
generalmente
mejora
rendimiento
comparada
alternativa
buffers
sistema
proceso
usuario
procesando
blo-
datos
leyendo
bloque
sistema
operativo
capaz
expulsar
Gestión
planificación
disco
501
Sistema
operativo
Dispositivo
buffer
Proceso
usuario
Sistema
operativo
Transferencia
Buffer
único
Buffer
doble
Entrada
Buffer
circular
Proceso
usuario
Proceso
usuario
Proceso
usuario
Sistema
operativo
Sistema
operativo
Transferencia
Transferencia
Entrada
Entrada
Entrada
Dispositivo
Dispositivo
Dispositivo
Figura
11.5
Esquemas
buffers
entrada
salida
11-Capitulo
11
16/5/05
17:06
Página
501al
proceso
puesto
llevando
cabo
operación
entrada
memoria
sistema
memoria
proceso
usuario
técnica
complica
lógica
sis-
tema
operativo
sistema
operativo
seguimiento
asignación
buffers
sis-
tema
procesos
usuario
afecta
lógica
intercambio
operación
afecta
disco
usando
intercambio
prácticamente
sentido
encolar
escrituras
disco
requeridas
expulsar
proceso
dispositivo
intento
expulsar
proceso
liberar
memoria
principal
comenzará
termine
operación
previa
cuyo
momento
expulsión
proceso
disco
dejado
apropiada
aplicar
consideraciones
similares
salida
orientada
bloques
transfieren
datos
dispositivo
lugar
copian
espacio
usuario
buffer
sistema
escribirán
definitivamente
proceso
solicitante
momento
continuar
expulsado
necesario
KNUT97
sugiere
comparación
rendimiento
tosca
informativa
buffer
único
Supóngase
tiempo
requerido
leer
bloque
tiempo
proceso
transcurre
sucesivas
peticiones
lectura
buf-
fer
tiempo
ejecución
bloque
básicamente
T+
P.
buffer
único
tiempo
má-
ximo
T]+M
tiempo
requerido
mover
datos
buffer
sistema
memoria
usuario
mayoría
casos
tiempo
ejecución
bloque
sustancial-
mente
menor
usando
buffer
único
usando
caso
orientada
flujo
caracteres
esquema
buffer
único
utili-
zar
operación
línea
línea
byte
byte
operación
línea
línea
apropiado
terminales
texto
texto
desplazando
verticalmen-
denominados
terminales
inteligentes
tipo
terminal
entrada
usua-
rio
terminal
línea
línea
usando
retorno
carro
indicar
línea
similar
salida
línea
línea
impresora
líneas
ejemplo
tipo
dispositivos
operación
byte
byte
utiliza
terminales
formulario
tecla
pulsada
significativa
periféricos
sensores
controladores
caso
línea
línea
utilizar
buffer
almacenar
única
línea
pro-
ceso
usuario
suspende
entrada
datos
esperando
llegada
línea
completa
salida
proceso
usuario
copiar
línea
salida
buffer
conti-
nuar
procesamiento
necesita
suspender
proceso
línea
salida
enviar
buffer
vacíe
terminar
operación
salida
caso
byte
byte
interacción
sistema
operativo
proceso
usuario
modelo
productor-consumidor
estudiado
Capítulo
BUFFER
DOBLE
mejora
técnica
buffer
único
asignando
operación
buffers
sistema
Figura
11.5c
esquema
proceso
transfiere
datos
buffer
sistema
operativo
vacía
llena
técnica
conoce
buffer
doble
in-
tercambio
buffers
transferencia
orientada
bloques
estimar
tiempo
ejecución
máximo
mantener
dispositivo
orientado
bloques
trabajando
velocidad
T.
buffer
doble
asegura
proceso
esperar
finalización
S.
caso
alcanza
mejora
buffer
único
mejora
conlleva
incremento
complejidad
502
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
502Con
entrada
orientada
flujo
caracteres
plantean
modos
operación
alternativos
caso
línea
línea
proceso
usuario
necesita
sus-
penderse
operación
entrada
salida
proceso
buffer
doble
caso
operación
byte
byte
buffer
doble
ofrece
ventaja
adi-
cional
buffer
único
doble
longitud
casos
utiliza
modelo
productor-
consumidor
BUFFER
CIRCULAR
esquema
buffer
doble
debería
suavizar
flujo
datos
dispositivo
proce-
so
interés
centrado
rendimiento
determinado
proceso
desearía
opera-
ción
capaz
mantener
ritmo
proceso
buffer
doble
inadecuado
proceso
realiza
ráfagas
rápidas
S.
caso
problema
aliviarse
frecuentemente
utili-
zando
buffers
utilizan
buffers
conjunto
buffers
denomina
buffer
circular
Fi-
gura
11.5d
buffer
individual
unidad
buffer
circular
simplemente
modelo
productor-consumidor
buffer
acotado
estudió
Capítulo
UTILIDAD
BUFFERS
buffers
técnica
amortigua
picos
demanda
S.
mu-
chos
buffers
utilicen
permitirán
dispositivo
mantener
ritmo
pro-
ceso
indefinidamente
demanda
media
proceso
servir
dis-
positivo
S.
múltiples
buffers
buffers
acabarán
llenándose
proceso
esperar
procesar
fragmento
datos
entorno
mul-
tiprogramación
diversas
actividades
distintos
procesos
atender
buffers
técnica
incrementar
eficiencia
sistema
operativo
rendi-
miento
procesos
individuales
11.5
PLANIFICACIÓN
DISCO
cuarenta
años
incremento
velocidad
procesadores
memoria
principal
sobrepasado
creces
velocidad
acceso
disco
incrementándose
aproxi-
madamente
órdenes
magnitud
velocidad
disco
orden
magnitud
resultado
discos
actualmente
órdenes
magnitud
lentos
memoria
principal
espera
diferencia
aumente
futuro
inmedia-
to
rendimiento
subsistema
almacenamiento
disco
vital
importancia
investigaciones
esquemas
mejorar
rendimiento
sección
resaltan
aspectos
fundamentales
revisan
técnicas
importantes
rendimiento
sistema
discos
estrechamente
asociado
aspectos
diseño
sistema
ficheros
estudio
continuará
Capítulo
12
PARÁMETROS
RENDIMIENTO
DISCO
detalles
reales
operación
disco
dependen
computador
sistema
operativo
naturaleza
hardware
canal
controlador
disco
Figura
11.6
muestra
diagrama
general
tiempos
transferencia
disco
Gestión
planificación
disco
503
11-Capitulo
11
16/5/05
17:06
Página
503Cuando
funcionamiento
unidad
disco
disco
rota
velocidad
constante
leer
escribir
cabeza
posicionar
pista
deseada
principio
sector
requerido
dicha
pista
selección
pista
implica
movimiento
cabeza
sistema
cabeza
móvil
selección
electrónica
cabeza
sistema
cabeza
fija
sistema
cabeza
móvil
tiempo
tarda
situar
cabeza
pista
denomina
tiempo
bús-
queda
caso
selecciona
pista
controlador
disco
espera
sector
apropiado
rote
cabeza
tiempo
tarda
llegar
comienzo
sector
cabeza
conoce
retardo
rotacional
latencia
rotacional
suma
tiempo
búsqueda
caso
retardo
rotacional
lugar
tiempo
acceso
tiempo
tarda
llegar
posición
lectura
escritura
cabeza
posición
operación
lectura
escritura
realiza
sector
mue-
ve
cabeza
transferencia
datos
operación
tiempo
requeri-
do
transferencia
tiempo
transferencia
tiempo
acceso
transferencia
retardos
esperas
colas
normal-
mente
asociadas
operación
disco
proceso
emite
petición
esperar
lugar
cola
dispositivo
esté
disponible
momento
asigna
dispositivo
proceso
dispositivo
comparte
único
canal
conjunto
canales
unidades
disco
espera
adicional
canal
esté
disponible
punto
realiza
búsqueda
comenzar
acceso
disco
sistemas
tipo
mainframe
utiliza
técnica
conocida
detección
posi-
ción
rotacional
Rotational
Position
Sensing
RPS
mecanismo
funciona
forma
generado
mandato
búsqueda
libera
canal
manejar
operaciones
S.
completa
búsqueda
dispositivo
determina
datos
rotan
cabeza
sector
aproxima
cabeza
dispositivo
intenta
restablecer
camino
comunicación
vuelta
máquina
unidad
control
canal
ocupados
operación
intento
volver
conectarse
falla
dispositivo
rotar
revolución
completa
intentar
volverse
conectar
denomina
fallo
RPS
situación
representa
elemento
retardo
adicional
añadirse
línea
tiempo
Figura
11.6
Tiempo
búsqueda
tiempo
búsqueda
tiempo
requerido
mover
brazo
disco
pista
requerida
tiempo
búsqueda
consta
componentes
fundamentales
tiempo
arranque
inicial
tiempo
tarda
atravesar
pistas
cruzarse
brazo
acceso
504
Sistemas
operativos
Aspectos
internos
principios
diseño
Véase
Apéndice
11A
estudio
organización
formato
disco
Espera
dispositivo
Espera
canal
Búsqueda
Retardo
rotacional
Transferencia
datos
Dispositivo
ocupado
Figura
11.6
Diagrama
tiempos
transferencia
disco
11-Capitulo
11
16/5/05
17:06
Página
504empieza
moverse
desgracia
tiempo
atravesar
pistas
función
lineal
nú-
mero
pistas
incluye
tiempo
establecimiento
tiempo
transcurre
posiciona
cabeza
pista
prevista
confirma
identificación
producido
mejoras
gracias
desarrollo
componentes
disco
pequeños
ligeros
años
disco
normal
diámetro
14
pulgadas
36
cm
tamaño
común
actualmente
3,5
pulgadas
8,9
cm
reduciendo
distancia
moverse
brazo
tiempo
normal
búsqueda
discos
duros
actuales
10
ms
Retardo
rotacional
discos
flexibles
rotan
velocidades
3600
rpm
dispositivos
portátiles
cámaras
digitales
15.000
rpm
momento
escribió
libro
velocidad
produce
revolución
ms
promedio
retardo
rota-
cional
ms
discos
flexibles
normalmente
giran
velocidad
300
600
rpm
retardo
100
50
ms
Tiempo
transferencia
tiempo
transferencia
disco
depende
velocidad
rotación
siguien-
expresión
tiempo
transferencia
número
bytes
transferir
número
bytes
pista
velocidad
rotación
revoluciones
tiempo
acceso
expresar
tiempo
búsqueda
comparación
tiempos
parámetros
previamente
definidos
examinarán
operaciones
mostrar
peligro
confiar
valores
medios
Considere
disco
tiempo
bús-
queda
4ms
fabricante
velocidad
rotación
7.500
rpm
sectores
512
bytes
500
sectores
pista
Supóngase
leer
fichero
consta
2.500
sectores
significa
1,28
Mbytes
pretende
estimar
tiempo
transferencia
TT
rN
ab
rN=
Gestión
planificación
disco
505
11-Capitulo
11
16/5/05
17:06
Página
505En
lugar
supóngase
fichero
almacena
forma
compacta
disco
fichero
ocupa
sectores
pistas
adyacentes
pistas
500
sectores
pis-
ta
2.500
sectores
conoce
organización
secuencial
tiempo
leer
pista
Búsqueda
media
ms
Retardo
rotacional
ms
Lectura
500
sectores
ms
16
ms
Supóngase
restantes
pistas
leer
básicamente
tiempo
búsqueda
operación
seguir
flujo
disco
necesita
retardo
rotacional
pista
sucesiva
lee
pista
sucesiva
12
ms
leer
fichero
entero
necesario
Tiempo
16
12
64
ms
0,064
segundos
continuación
calculará
tiempo
requerido
leer
datos
utilizando
acceso
aleatorio
lugar
acceso
secuencial
accesos
sectores
distribuyen
mane-
ra
aleatoria
disco
sector
Búsqueda
media
ms
Retardo
rotacional
ms
Lectura
sector
0,016
ms
8,016
ms
Tiempo
2500
8,016
20.040
ms
20,04
segundos
evidente
orden
leen
sectores
disco
efecto
tremendo
rendimiento
S.
caso
acceso
fichero
leen
escriben
múltiples
sectores
control
distribuyen
sectores
datos
dis-
co
estudiará
capítulo
caso
acceso
fichero
entorno
multiprogramación
diversas
peticiones
compitiendo
dis-
co
importante
examinar
maneras
mejorar
rendimiento
disco
logrado
acceso
disco
puramente
aleatorio
POLÍTICAS
PLANIFICACIÓN
DISCO
ejemplo
acaba
describir
diferencia
rendimiento
tiempo
búsque-
peticiones
acceso
sectores
involucran
selección
aleatoria
pistas
rendi-
miento
sistema
disco
mejorar
asunto
necesita
reducir
tiempo
gastado
búsquedas
Considere
situación
normal
entorno
multiprogramación
sistema
operati-
vo
mantiene
cola
peticiones
dispositivo
S.
caso
único
disco
ha-
brá
peticiones
lecturas
escrituras
diversos
procesos
cola
seleccionan
elementos
cola
orden
aleatorio
predecir
pistas
visitar
aleatoria-
mente
proporcionando
rendimiento
deficiente
planificación
aleatoria
útil
punto
referencia
evaluar
técnicas
506
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
506La
Figura
11.7
compara
rendimiento
algoritmos
planificación
usando
ejemplo
secuencia
peticiones
S.
eje
vertical
corresponde
pistas
disco
eje
horizontal
corresponde
tiempo
equivalente
número
pistas
atravesadas
figura
asume
cabeza
disco
situada
inicialmente
pista
100
ejemplo
supone
disco
200
pistas
cola
peticiones
disco
in-
cluye
peticiones
aleatorias
pistas
solicitadas
orden
recibido
planificador
disco
55
58
39
18
90
160
150
38
184
Tabla
11.2a
muestra
resultados
forma
tabla
abla
11.2
Comparación
algoritmos
planificación
disco
SCAN
C-SCAN
FIFO
SSTF
comenzando
pista
comenzando
pista
comenzando
comenzando
100
dirección
100
dirección
pista
100
pista
100
números
pista
números
pista
crecientes
crecientes
Próxima
Número
Próxima
Número
Próxima
Número
Próxima
Número
pista
pistas
pista
pistas
pista
pistas
pista
pistas
accedida
atravesadas
accedida
atravesadas
accedida
atravesadas
accedida
atravesadas
55
45
90
10
150
50
150
50
58
58
32
160
10
160
10
39
19
55
184
24
184
24
18
21
39
16
90
94
18
166
90
72
38
58
32
38
20
160
70
18
20
55
39
150
10
150
132
39
16
55
16
38
12
160
10
38
58
184
146
184
24
18
20
90
32
longitud
55,3
longitud
27
longitud
27
longitud
35,8
media
media
media
media
búsqueda
búsqueda
búsqueda
búsqueda
entrar
salir
forma
sencilla
planificación
corresponde
algoritmo
entrar
salir
First
In-First
Out
FIFO
procesa
elementos
cola
orden
secuencial
es-
trategia
ventaja
equitativa
petición
acaba
sirviendo
peti-
ciones
sirven
orden
recibido
Figura
11.7a
muestra
movimiento
brazo
disco
algoritmo
FIFO
planificación
procesos
requieren
acceso
disco
peticiones
corresponden
sectores
agrupados
ficheros
prever
rendimiento
técnica
frecuencia
resultados
similares
pla-
nificación
aleatoria
rendimiento
caso
procesos
compi-
tiendo
disco
beneficioso
considerar
política
planificación
sofisticada
Tabla
11.3
enumeran
políticas
planificación
analizarán
continuación
Gestión
planificación
disco
507
11-Capitulo
11
16/5/05
17:06
Página
507508
Sistemas
operativos
Aspectos
internos
principios
diseño
199
175
150
125
100
75
Númro
pista
50
25
FIFO
Tiempo
199
175
150
125
100
75
50
25
SSTF
199
175
150
125
100
75
50
25
SCAN
199
175
150
125
100
75
50
25
C-SCAN
Tiempo
Tiempo
Tiempo
Númro
pistaNúmro
pistaNúmro
pista
Figura
11.7
Comparación
algoritmos
planificación
disco
véase
Tabla
1.3
11-Capitulo
11
16/5/05
17:06
Página
508
abla
11.3
Algoritmos
planificación
disco
Nombre
Descripción
Comentarios
Selección
solicitante
PA
Planificación
aleatoria
análisis
simulación
FIFO
entrar
salir
equitativo
PRI
Prioridad
proceso
Control
externo
gestión
cola
disco
LIFO
entrar
salir
Maximiza
proximidad
recursos
Selección
elemento
solicitado
SSTF
tiempo
servicio
utilización
colas
pequeñas
corto
SCAN
Recorrido
disco
bidireccional
distribución
servicio
C-SCAN
Recorrido
unidireccional
Menor
variabilidad
servicio
retorno
rápido
SCAN-de-N-pasos
SCAN
registros
Garantía
servicio
FSCAN
SCAN-de-N-pasos
tamaño
Sensible
carga
cola
principio
ciclo
SCAN
Prioridad
sistema
basado
prioridad
PRI
planificación
control
software
gestión
disco
estrategia
diseñada
optimizar
utilización
disco
sa-
tisfacer
objetivos
sistema
operativo
frecuencia
prioridad
trabajos
lotes
corta
duración
trabajos
interactivos
trabajos
largos
re-
quieren
procesamiento
prolongado
permite
trabajos
cortos
salgan
siste-
ma
rápidamente
pudiendo
proporcionar
tiempo
respuesta
interactiva
adecuado
trabajos
largos
esperar
tiempo
excesivamente
políti-
ca
tipo
usuarios
tomaran
medidas
dividiendo
trabajos
partes
pequeñas
engañar
sistema
tipo
política
tiende
inadecuada
sistemas
base
datos
entrar
salir
Sorprendentemente
política
seleccionar
petición
reciente
mérito
sistemas
procesamiento
transacciones
asignar
dispositivo
usuario
reciente
debería
producir
movimiento
brazo
desplazamiento
fichero
se-
cuencial
Aprovechar
proximidad
mejora
rendimiento
reduce
longitud
cola
trabajo
utilice
activamente
sistema
ficheros
procesará
rápido
disco
mantiene
ocupado
carga
trabajo
evidente
posi-
bilidad
inanición
proceso
insertado
petición
cola
pierde
posición
delantera
proceso
recuperar
dicha
posición
terminen
peticiones
cola
Gestión
planificación
disco
509
11-Capitulo
11
16/5/05
17:06
Página
509Las
planificaciones
FIFO
prioridad
LIFO
entrar
salir
basadas
atributos
cola
demandante
planificador
conoce
posición
pista
ac-
tual
emplear
planificación
basada
elemento
solicitado
continuación
exami-
nan
políticas
tiempo
servicio
corto
política
SSTF
Shortest
Service
Time
First
tiempo
servicio
corto
con-
siste
seleccionar
petición
disco
requiera
menor
movimiento
brazo
posición
actual
realiza
selección
pro-
duzca
tiempo
búsqueda
mínimo
Evidentemente
seleccionar
tiempo
búsque-
mínimo
garantiza
mínimo
tiempo
búsqueda
correspondiente
movimientos
brazo
esquema
debería
proporcionar
rendimiento
algoritmo
FIFO
brazo
moverse
direcciones
utilizar
algoritmo
aleatorio
resolver
casos
empate
existencia
distancias
iguales
Figura
11.7b
Tabla
11.2b
muestran
rendimiento
SSFT
ejemplo
usó
planificación
FIFO
Scan
excepción
planificación
FIFO
políticas
descritas
dejar
petición
servir
vacíe
completamente
cola
peticiones
po-
drían
llegar
continuamente
peticiones
seleccionarían
petición
exis-
tente
alternativa
sencilla
impide
tipo
inanición
algoritmo
SCAN
conocido
algoritmo
ascensor
funciona
similar
ascensor
algoritmo
SCAN
brazo
moverse
dirección
satisfaciendo
pe-
ticiones
pendientes
encuentre
camino
alcanza
pista
dirección
peticiones
dirección
mejora
denomina
política
LOOK
momento
dirección
servicio
invierte
búsqueda
continúa
dirección
opuesta
sirviendo
peticiones
orden
Figura
11.7c
Tabla
11.2c
muestran
política
SCAN
observar
política
SCAN
comporta
prácticamente
política
SSTF
hubiera
brazo
moviendo
dirección
pistas
números
bajos
comienzo
ejem-
plo
patrón
planificación
habría
SSTF
SCAN
ejemplo
estático
añade
elemento
cola
caso
cola
cambiando
dinámicamente
SCAN
similar
SSTF
patrón
peticio-
nes
inusual
Nótese
política
SCAN
favorece
tratamiento
área
disco
atravesado
recientemente
aprovecha
proximidad
SSTF
LIFO
difícil
observar
política
SCAN
favorece
trabajos
cuyas
peticiones
correspon-
den
pistas
cercanas
pistas
interiores
exteriores
tra-
bajos
llegado
recientemente
problema
evitar
política
C-
SCAN
problema
soluciona
política
SCAN-de-
N-pasos
510
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
510C-Scan
política
C-SCAN
SCAN
circular
restringe
búsqueda
dirección
visitar
pista
dirección
brazo
vuelve
extremo
opuesto
disco
búsqueda
comienza
reduce
retardo
máximo
experimentar
peticiones
SCAN
tiempo
previsto
búsqueda
pista
interna
externa
intervalo
servicio
previsto
sectores
periferia
t.
C-SCAN
intervalo
orden
máx
smáx
tiempo
búsqueda
máximo
Figura
11.7d
Tabla
11.2d
muestran
comportamiento
C-SCAN
SCAN-de-N-pasos
FSCAN
SSFT
SCAN
C-SCAN
brazo
moverse
periodo
tiem-
po
considerable
ejemplo
procesos
elevadas
tasas
acceso
determina-
pista
monopolizar
dispositivo
entero
sucesivas
peticiones
pista
dis-
cos
alta
densidad
múltiples
superficies
probablemente
afectados
característica
discos
densidad
baja
discos
superficies
evitar
estancamiento
brazo
cola
peticiones
disco
dividirse
segmentos
momento
procesando
segmento
complete
algoritmos
SCAN-de-N-pasos
FSCAN
ejemplos
estrategia
política
SCAN-de-N-pasos
divide
cola
peticiones
disco
colas
longitud
N.
momento
procesa
cola
utilizando
SCAN
procesando
cola
peticiones
añadir
cola
peticiones
disponibles
fi-
nal
búsqueda
procesan
próxima
búsqueda
valores
rendimiento
SCAN-de-N-pasos
aproxima
SCAN
valor
convierte
política
FIFO
FSCAN
política
utiliza
colas
comienza
búsqueda
peticio-
nes
incluidas
colas
estando
vacía
búsqueda
peticiones
incluyen
cola
difiere
servicio
peticiones
procesado
peticiones
antiguas
11.6
RAID
estudió
anteriormente
ritmo
mejora
rendimiento
almacenamiento
secundario
considerablemente
menor
caso
procesadores
memoria
principal
di-
ferencia
sistema
almacenamiento
disco
probablemente
centro
principal
inte-
rés
mejorar
rendimiento
general
computador
ocurre
áreas
vinculadas
rendimiento
computador
diseñadores
almacenamiento
disco
determinado
componente
mejorarse
lograr
mejoras
adicionales
rendimiento
utilizar
múltiples
componentes
paralelo
caso
almacenamiento
disco
desarrollo
vectores
discos
funcionan
independiente
paralelo
Usando
múltiples
discos
manejar
paralelo
peticiones
independientes
datos
solicitados
residan
distintos
discos
única
petición
ejecutar
paralelo
bloque
datos
pretende
acceder
distribuido
múltiples
discos
múltiples
discos
maneras
organizar
datos
redundancia
añadir
mejorar
fiabilidad
dificultar
desarrollo
esquemas
ba-
Gestión
planificación
disco
511
11-Capitulo
11
16/5/05
17:06
Página
511ses
datos
puedan
utilizar
diversas
plataformas
sistemas
operativos
Afortunadamente
industria
definido
esquema
estándar
diseño
bases
datos
múltiples
discos
co-
nocido
RAID
Redundant
Array
of
Independent
Disks
Vector
redundante
discos
indepen-
dientes
esquema
RAID
consta
niveles
cero
niveles
implican
re-
lación
jerárquica
designan
diversas
arquitecturas
diseño
comparten
características
comunes
RAID
corresponde
conjunto
unidades
físicas
disco
tratado
sistema
operati-
vo
único
dispositivo
lógico
datos
distribuidos
unidades
físicas
vector
capacidad
redundancia
disco
utiliza
almacenar
información
paridad
garantiza
datos
recuperar
caso
falle
disco
detalles
características
enumeradas
tercer
lugar
difieren
distintos
niveles
RAID
RAID
RAID
incluyen
característica
término
RAID
originalmente
acuñado
artículo
grupo
investigadores
universidad
California
Berkeley
PATT88
artículo
definió
configuraciones
aplica-
ciones
discos
RAID
introdujo
definiciones
niveles
RAID
estrategia
remplazó
dispositivos
disco
capacidad
múltiples
dis-
positivos
menor
capacidad
distribuyendo
datos
permitan
accesos
simultá-
neos
datos
múltiples
dispositivos
mejora
rendimiento
facilita
crecimiento
gradual
capacidad
contribución
original
propuesta
RAID
abordar
efectivamente
necesidad
redun-
dancia
permitir
múltiples
cabezas
activadores
trabajen
simultáneamente
logra
ma-
yor
tasa
transferencia
múltiples
dispositivos
incrementa
probabilidad
fa-
llo
compensar
pérdida
fiabilidad
RAID
utiliza
información
paridad
almacenada
posibilita
recuperación
datos
perdidos
fallo
disco
continuación
examinará
niveles
RAID
Tabla
11.4
MASS97
pro-
porciona
pequeño
resumen
niveles
tabla
rendimiento
muestra
términos
capacidad
transferencia
datos
posibilidad
mover
datos
tasa
peticiones
capacidad
satisfacer
peticiones
niveles
RAID
presentan
diferencias
relativas
inherentes
parámetros
punto
fuerte
nivel
RAID
resaltado
color
Figura
11.8
ejemplo
muestra
esquemas
RAID
proporcionar
capacidad
datos
equivalente
discos
redundancia
figura
resalta
distribución
datos
usuario
redundancia
indica
re-
quisitos
almacenamiento
relativos
distintos
niveles
hará
referencia
figura
lar-
go
estudio
512
Sistemas
operativos
Aspectos
internos
principios
diseño
investigadores
compañías
definido
niveles
adicionales
niveles
definidos
sección
conocidos
universalmente
artículo
siglas
RAID
significaban
vector
redundante
discos
económicos
Redundant
Array
of
Inexpensive
Disks
término
económico
utilizaba
contrastar
discos
pequeños
relativamente
baratos
usados
vector
RAID
alternativa
consistente
único
disco
caro
SLED
Single
Large
Expensive
Disk
opción
SLED
simplemente
cosa
puesto
actualmente
tecnología
disco
similar
configuraciones
RAID
par
consiguiente
industria
adoptado
término
independiente
enfatizar
vector
RAID
significa
mejoras
rendimiento
fiabilidad
significativas
11-Capitulo
11
16/5/05
17:06
Página
512Gestión
planificación
disco
513
abla
11.4
Niveles
RAID
Capacidad
asa
Categoría
Nivel
Descripción
Discos
Disponibilidad
transferencia
peticiones
deimplicados
datos
datos
pequeñasE
bandas
redundancia
Inferior
alta
alta
único
disco
lecturas
escrituras
Espejo
Discos
duplicados
2N
3N
etc.
RAID
doble
menor
único
disco
único
disco
RAID
lecturas
similar
lecturas
único
disco
similar
único
escrituras
disco
escrituras
Redundancia
Código
único
disco
alternativas
doble
Hamming
RAID
mostradas
único
disco
5Acceso
paralelo
Paridad
intercalada
nivel
bit
único
disco
alternativas
doble
comparable
mostradas
único
disco
RAID
Paridad
intercalada
Similar
RAID
Similar
RAID
nivel
bloque
único
disco
lecturas
lecturas
comparable
significativamente
significativamente
RAID
inferior
único
inferior
único
disco
disco
escrituras
escrituras
Paridad
distribuida
Similar
RAID
Similar
RAID
intercalada
único
disco
lecturas
lecturas;Acceso
nivel
bloque
comparable
inferior
único
generalmenteindependiente
RAID
disco
inferior
único
escrituras
disco
escrituras
Paridad
dual
Similar
RAID
Similar
RAID
distribuida
lecturas
lecturas
intercalada
alternativas
inferior
RAID
significativamente
nivel
bloque
mostradas
escrituras
inferior
RAID
escrituras
11-Capitulo
11
16/5/05
17:06
Página
513514
Sistemas
operativos
Aspectos
internos
principios
diseño
RAID
NIVEL
RAID
nivel
miembro
familia
RAID
puesto
incluye
redundancia
mejorar
fiabilidad
aplicaciones
tales
supercomputadores
rendimiento
capacidad
primordiales
impor-
tante
coste
fiabilidad
RAID
datos
usuarios
sistema
distribuidos
dis-
cos
vector
importante
ventaja
único
disco
pen-
dientes
peticiones
solicitan
bloques
datos
distintos
probabilidad
bloques
pedidos
estén
discos
cabo
peticiones
paralelo
reduciendo
tiempo
espera
cola
S.
ocurre
niveles
RAID
simplemente
distribuir
datos
vector
discos
datos
distribuidos
bandas
inglés
strips
discos
disponibles
comprenderá
considerando
Figura
11.8
efectos
datos
usuarios
sistema
estuvieran
almacenados
único
disco
lógico
disco
lógico
dividido
bandas
bandas
bloques
físi-
cos
sectores
unidad
bandas
asignan
forma
rotatoria
discos
físicos
conse-
cutivos
vector
RAID
conjunto
bandas
lógicamente
consecutivas
RAID
redundancia
banda
RAID
discos
espejo
RAID
redundancia
código
Hamming
b0
b1
b2
b3
f0(b
f1(b
f2(b
banda
banda
banda
12
banda
banda
banda
banda
13
banda
banda
banda
10
banda
14
banda
banda
banda
11
banda
15
banda
banda
banda
banda
12
banda
banda
banda
banda
13
banda
banda
banda
10
banda
14
banda
banda
banda
11
banda
15
banda
banda
banda
banda
12
banda
banda
banda
banda
13
banda
banda
banda
10
banda
14
banda
banda
banda
11
banda
15
Figura
11.8
Niveles
RAID
página
11-Capitulo
11
16/5/05
17:06
Página
514miembro
vector
discos
asigna
exactamente
banda
llama
lista
inglés
stri-
pe
vector
discos
primeras
bandas
lógicas
almacenan
físicamente
pri-
mera
banda
discos
segundas
bandas
lógicas
distribuyen
constituyen-
do
banda
disco
sucesivamente
ventaja
distribución
única
petición
consiste
múltiples
bandas
contiguas
lógicamente
manejar
paralelo
bandas
petición
reduciendo
considerablemente
tiempo
transferen-
cia
S.
Gestión
planificación
disco
515
RAID
paridad
distribuida
nivel
bloque
bloque
P(12-15
P(8-11
P(4-7
P(0-3
P(16-19
P(12-15
P(8-11
P(4-7
RAID
paridad
distribuida
nivel
bloque
RAID
paridad
nivel
bit
b0
b1
b2
b3
P(b
P(0-3
RAID
redundancia
dual
P(12-15
Q(12-15
P(8-11
P(4-7
Q(4-7
P(0-3
Q(8-11
Q(0-3
bloque
bloque
bloque
12
bloque
13
bloque
bloque
bloque
bloque
bloque
bloque
10
bloque
14
bloque
bloque
bloque
11
bloque
15
bloque
bloque
bloque
bloque
12
bloque
bloque
bloque
bloque
bloque
bloque
bloque
bloque
11
bloque
15
bloque
16
bloque
13
bloque
17
bloque
10
bloque
14
bloque
18
bloque
19
bloque
bloque
bloque
bloque
12
bloque
bloque
bloque
bloque
bloque
bloque
bloque
13
bloque
10
bloque
14
bloque
bloque
11
bloque
15
Figura
11.8
Niveles
RAID
página
11-Capitulo
11
16/5/05
17:06
Página
515RAID
elevada
capacidad
transferencia
datos
rendimiento
cualquiera
niveles
RAID
depende
forma
crítica
patrones
peticiones
sistema
distribución
datos
aspectos
tratar
claramente
nivel
RAID
impacto
redundancia
interfiere
análisis
lugar
considérese
RAID
lograr
tasa
transferencia
datos
elevada
aplicaciones
experimen-
ten
alta
tasa
transferencia
cumplir
requisitos
existir
elevada
capacidad
transferencia
camino
memoria
máquina
unida-
des
disco
individuales
incluyendo
buses
internos
controlador
buses
sistema
adaptadores
buses
memoria
máquina
requisito
aplicación
peticiones
accedan
eficientemen-
vector
discos
requisito
cumple
mayoría
peticiones
corresponde
cantidad
datos
contiguos
lógicamente
comparado
tamaño
banda
caso
única
petición
involucra
transferencia
datos
paralelo
múltiples
discos
in-
crementando
tasa
transferencia
efectiva
comparada
transferencia
único
disco
RAID
elevada
tasa
peticiones
entorno
orientado
transacciones
usuario
normalmente
preocupado
tiempo
respuesta
velocidad
transferencia
caso
petición
individual
cantidad
pequeña
datos
tiem-
po
dominado
movimiento
cabezas
disco
tiempo
búsqueda
movi-
miento
disco
latencia
rotacional
entorno
transacciones
cientos
peticiones
vector
discos
proporcionar
tasas
elevadas
ejecución
repartiendo
carga
múltiples
discos
reparto
carga
efectivo
alcanza
normalmente
múltiples
peticiones
pendientes
implica
múltiples
aplicaciones
independientes
aplicación
basada
transacciones
capaz
múltiples
peticiones
asíncronas
rendimiento
influido
tamaño
banda
tamaño
banda
relativa-
mente
única
petición
involucre
único
acceso
disco
manejar
paralelo
múltiples
peticiones
pendientes
reduciendo
tiempo
espera
cola
petición
RAID
NIVEL
nivel
RAID
diferencia
niveles
logra
redundancia
esquemas
RAID
utiliza
tipo
cálculo
paridad
incluir
redundancia
RAID
redundancia
simple
estrategia
duplicar
datos
Figura
11.8b
muestra
distribución
datos
utilizada
esquema
RAID
caso
banda
lógica
asigna
discos
físicos
separados
disco
vector
disco
duplicado
contenga
datos
es-
quema
RAID
implementar
distribución
datos
común
aspectos
positivos
organización
RAID
petición
lectura
servirse
cualquiera
discos
contienen
datos
pedidos
implique
valor
mínimo
tiempo
búsqueda
latencia
rotacional
petición
escritura
requiere
actualizar
ambas
bandas
paralelo
rendimiento
escritura
establece
escritura
lenta
implica
valor
tiempo
búsqueda
latencia
rotacional
516
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
516una
penalización
escritura
RAID
niveles
RAID
implican
bits
paridad
actualiza
única
banda
software
gestión
vector
calcular
actualizar
bits
paridad
banda
real
involucrada
recuperación
fallo
sencilla
dispositivo
falla
acceder
datos
dispositivo
principal
desventaja
RAID
coste
requiere
doble
espacio
disco
corres-
pondiente
disco
lógico
proporcionado
configuración
RAID
probablemen-
limitada
dispositivos
almacenan
software
datos
sistema
ficheros
altamente
críti-
cos
casos
RAID
proporciona
copia
respaldo
tiempo
real
datos
caso
fallo
disco
datos
críticos
inmediatamente
disponibles
entorno
transacciones
RAID
alcanzar
tasas
elevadas
peticiones
peticiones
lectura
situación
rendimiento
RAID
acer-
carse
doble
proporcionado
esquema
RAID
sustancial
peticiones
escritura
ganancia
rendimiento
RAID
RAID
proporcionar
rendimiento
RAID
aplicaciones
transferencias
intensivas
datos
elevado
porcentaje
lecturas
mejora
produ-
ce
aplicación
dividir
petición
lectura
participen
grupos
discos
RAID
NIVEL
niveles
RAID
utilizan
técnica
acceso
paralelo
vector
acceso
paralelo
to-
miembros
disco
participan
ejecución
petición
S.
Normalmente
ejes
distintas
unidades
sincronizan
momento
cabeza
disco
esté
posición
discos
ocurre
esquemas
RAID
utiliza
distribución
datos
bandas
caso
esquemas
RAID
bandas
pequeñas
único
byte
palabra
RAID
calcula
código
corrección
error
bits
correspondientes
disco
datos
almacenándose
bits
código
resultante
correspondientes
posiciones
bit
múltiples
discos
paridad
Normalmente
utiliza
Código
Hamming
capaz
corregir
errores
único
bit
detectar
errores
RAID
requiere
discos
RAID
costoso
número
discos
redundantes
proporcional
logaritmo
número
discos
datos
única
lectura
acceden
discos
simultánea
controlador
vector
recibe
datos
pedidos
código
corrección
error
asociado
error
único
bit
controlador
de-
tectar
corregir
error
instantáneamente
tiempo
acceso
lectura
ralentiza
única
escritura
operación
escritura
acceder
discos
datos
paridad
llevarse
cabo
esquema
RAID
opción
efectiva
entorno
produjeran
errores
disco
Dada
alta
fiabilidad
unidades
disco
discos
propiamente
dichos
esquema
RAID
excesivo
implementa
práctica
RAID
NIVEL
esquema
RAID
organiza
similar
usado
RAID
diferencia
estriba
RAID
requiere
disco
redundante
independencia
tamaño
vector
discos
Gestión
planificación
disco
517
11-Capitulo
11
16/5/05
17:06
Página
517RAID
emplea
acceso
paralelo
teniendo
datos
distribuidos
pequeñas
bandas
lugar
código
corrección
errores
calcula
bit
paridad
simple
conjunto
bits
almace-
nados
posición
discos
datos
Redundancia
caso
ocurra
fallo
dispositivo
accede
dispositivo
pari-
dad
reconstruyen
datos
dispositivos
restantes
remplaza
dispositi-
vo
falló
datos
perdidos
restaurarse
dispositivo
operación
reanuda
reconstrucción
datos
simple
Considere
vector
unidades
dispositivos
X0
X3
contienen
datos
unidad
X4
disco
pa-
ridad
paridad
bit
i-ésimo
calcula
X4(i
X3(i
X2(i
X1(i
X0(i
función
O-exclusivo
Supóngase
falla
dispositivo
X1
suma
X4
X1(i
lados
ecuación
precedente
obtiene
X1(i
X4(i
X3(i
X2(i
X0(i
consiguiente
contenidos
banda
datos
X1
regenerarse
contenidos
bandas
correspondientes
restantes
discos
vector
principio
aplica-
ble
niveles
RAID
produce
fallo
disco
datos
disponibles
denomi-
na
reducido
lecturas
datos
perdidos
regeneran
marcha
utilizando
cálculo
O-exclusivo
escriben
datos
vector
RAID
redu-
cido
mantener
coherencia
paridad
posterior
regeneración
retorno
operación
pleno
requiere
remplace
disco
falló
regenere
contenido
com-
pleto
disco
disco
Rendimiento
datos
distribuidos
pequeñas
bandas
esquema
RAID
alcanzar
velocidades
transferencia
datos
elevadas
petición
involucrará
transferencia
paralelo
datos
discos
datos
transferencias
mejora
rendimiento
especialmente
notable
ejecutar
petición
momento
entorno
transacciones
ve
afectado
rendimiento
RAID
NIVEL
niveles
RAID
utilizan
técnica
acceso
independiente
vector
acceso
inde-
pendiente
disco
vector
opera
independientemente
servir
para-
lelo
peticiones
independientes
vectores
acceso
independiente
adecuados
aplicaciones
requieren
tasas
elevadas
peticiones
relativamente
adecuados
necesitan
tasas
elevadas
transferencias
datos
ocurre
esquemas
RAID
utiliza
distribución
datos
bandas
caso
esquemas
RAID
bandas
relativamente
RAID
cal-
cula
bit
bit
banda
paridad
bandas
correspondientes
disco
datos
al-
macenándose
bits
paridad
resultantes
banda
correspondiente
disco
paridad
esquema
RAID
implica
penalización
escrituras
tamaño
pequeño
produce
escritura
software
gestión
vector
modificar
da-
518
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
518tos
usuario
involucrados
actualizar
datos
paridad
correspondientes
Considere
vec-
tor
unidades
dispositivos
X0
X3
contienen
datos
unidad
X4
disco
paridad
Supóngase
realiza
escritura
in-
volucra
banda
disco
X1
Inicialmente
bit
cumplirá
relación
X4(i
X3(i
X2(i
X1(i
X0(i
11.1
continuación
muestra
resultado
actualización
marcado
comilla
bits
potencialmente
modificados
X4
X3(i
X2(i
X1’(i
X0(i
X3(i
X2(i
X1’(i
X0(i
X1(i
X1(i
X3(i
X2(i
X1(i
X0(i
X1(i
X1’(i
X4(i
X1(i
X1’(i
conjunto
precedente
ecuaciones
deriva
explica
continuación
línea
muestra
cambio
X1
afectará
disco
paridad
X4
línea
suman
términos
X1(i
X1(i
O-exclusivo
valor
afecta
ecuación
paso
intermedio
conveniente
llegar
línea
simplemente
cambia
orden
términos
Finalmente
utiliza
ecuación
11.1
remplazar
términos
X4(i
calcular
paridad
software
gestión
vector
leer
bandas
datos
pa-
ridad
antiguas
continuación
actualizar
bandas
datos
pari-
dad
calculada
consiguiente
escritura
banda
requiere
lecturas
escrituras
caso
escritura
tamaño
involucre
bandas
unidades
disco
paridad
calcula
fácilmente
utilizando
bits
datos
dispo-
sitivo
paridad
actualizar
paralelo
dispositivos
datos
requerir
lecturas
es-
crituras
adicionales
caso
operación
escritura
involucrar
disco
paridad
llegar
cuello
botella
RAID
NIVEL
esquema
RAID
organiza
similar
RAID
diferencia
estriba
esque-
ma
RAID
distribuye
bandas
paridad
discos
asignación
habitual
esquema
rotatorio
muestra
Figura
11.8f
vector
discos
banda
pa-
ridad
disco
primeras
listas
continuación
repite
patrón
asignación
distribución
bandas
paridad
dispositivos
evita
potencial
cue-
llo
botella
existencia
único
disco
paridad
aparece
esquema
RAID
RAID
NIVEL
esquema
RAID
propuesto
artículo
posterior
investigadores
Berkeley
KATZ89
esquema
RAID
realizan
cálculos
paridad
almacenándose
Gestión
planificación
disco
519
11-Capitulo
11
16/5/05
17:06
Página
519bloques
separados
distintos
discos
vector
RAID
cuyos
datos
usuario
requieran
discos
necesitará
discos
Figura
11.8
muestra
esquema
algoritmos
comprobación
datos
dife-
rentes
cálculo
O-exclusivo
usado
esquemas
RAID
algoritmo
comprobación
datos
independiente
permite
regenerar
datos
inclu-
so
fallan
discos
contienen
datos
usuario
ventaja
esquema
RAID
proporciona
extremadamente
alta
disponibilidad
datos
Tendrían
fallar
discos
intervalo
correspondiente
tiempo
repara-
ción
Mean
Time
To
Repair
MTTR
causar
pérdida
datos
esquema
RAID
incurre
penalización
escritura
sustancial
escritura
afecta
bloques
paridad
11.7
CACHE
DISCO
Sección
1.6
Apéndice
1A
resumen
fundamentos
memorias
cache
térmi-
memoria
cache
utiliza
normalmente
aplicado
memoria
pequeña
rápida
memoria
principal
interpone
memoria
principal
procesador
Dicha
memo-
ria
cache
reduce
tiempo
acceso
memoria
explotando
principio
proximidad
principio
aplicar
memoria
disco
Específicamente
cache
disco
buffer
memoria
principal
almacenar
sectores
disco
cache
contiene
copia
sectores
disco
petición
solicitando
determinado
sector
comprueba
sector
cache
disco
caso
afirmativo
sirve
petición
cache
fenómeno
proximidad
referencias
lee
bloque
da-
tos
cache
satisfacer
única
petición
probable
referencias
mis-
mo
bloque
futuro
CONSIDERACIONES
DISEÑO
aspectos
diseño
interés
lugar
satisface
petición
cache
disco
entregar
datos
cache
proceso
solicitante
opera-
ción
copiando
bloque
datos
almacenado
memoria
principal
asignada
cache
disco
memoria
asignada
proceso
usuario
utilizando
simplemente
técnica
memoria
compartida
pasando
puntero
bloque
correspondiente
cache
disco
estrategia
ahorra
tiempo
transferencia
memoria
memoria
permite
acceso
compartido
procesos
utilizando
modelo
lectores
escritores
descrito
Capítulo
aspecto
diseño
relacionado
estrategia
remplazo
trae
sector
cache
disco
remplazar
bloques
existentes
pro-
blema
idéntico
presentado
Capítulo
requería
algoritmo
remplazo
pági-
nas
probado
diversos
algoritmos
algoritmo
frecuentemente
utilizado
recientemente
usado
Least
Recently
Used
LRU
remplaza
bloque
cache
tiempo
accedido
Lógicamente
cache
consiste
pila
bloques
estando
blo-
recientemente
accedido
alto
pila
accede
bloque
cache
mueve
posición
actual
pila
cima
trae
bloque
memoria
secundaria
elimina
bloque
pila
situándose
bloque
entran-
cima
pila
Naturalmente
necesario
mover
realmente
bloques
memoria
principal
puesto
asociar
pila
punteros
cache
520
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
520Otra
posibilidad
algoritmo
frecuentemente
usado
Least
Frequently
Used
LFU
remplaza
bloque
conjunto
experimentado
menor
cantidad
referencias
algoritmo
LFU
implementarse
asociando
contador
bloque
trae
blo-
asigna
contador
valor
incrementando
contador
referen-
cia
bloque
requiere
remplazo
selecciona
bloque
contador
pequeño
Intuitivamente
LFU
apropiado
LRU
utiliza
información
pertinente
bloque
proceso
selección
algoritmo
LFU
sencillo
conlleva
problema
ocurrir
blo-
ques
accedan
términos
globales
forma
relativamente
infrecuente
referencia
producen
referencias
repetidas
cortos
intervalos
tiempo
proximidad
genera
contador
referencias
elevado
acaba
intervalo
valor
contador
referencias
conclusiones
erróneas
reflejando
grado
probabilidad
bloque
acceda
plazo
tiempo
efecto
proximidad
realmente
causar
algoritmo
LFU
tome
decisiones
inadecuadas
resolver
deficiencia
algoritmo
LFU
ROBI90
propone
técnica
denomina-
remplazo
basado
frecuencia
motivos
pedagógicos
considere
versión
simplificada
mostrada
Figura
11.9a
bloques
organizan
lógicamente
pila
algoritmo
LRU
porción
superior
pila
separada
sección
nue-
acierto
cache
bloque
accedido
mueve
superior
pila
bloque
sección
contador
referencias
incrementa
caso
contra-
rio
incrementa
sección
suficientemente
permanezcan
inalterados
contadores
referencias
bloques
acceden
repetidamente
intervalo
tiempo
caso
fallo
escoge
remplazar
bloque
contador
re-
ferencias
esté
sección
seleccionando
bloque
usado
reciente-
mente
caso
empate
autores
explican
estrategia
logra
ligera
mejora
algoritmo
LRU
problema
Gestión
planificación
disco
521
MRU
acceso
contador
cambia
FIFO
Sección
Sección
antigua
Fallo
trae
bloque
contador:1
LRU
MRU
secciones
LRU
Sección
intermedia
acceso
contador
contador
Sección
Sección
antigua
Figura
11.9
Remplazo
basado
frecuencia
11-Capitulo
11
16/5/05
17:06
Página
5211
fallo
cache
incluirá
bloque
sección
contador
contador
continúa
valor
bloque
permanezca
sección
tiempo
bloque
sale
sección
contador
vuelve
acceder
bloque
prontitud
probable
remplace
por-
necesariamente
menor
contador
referencias
bloques
es-
tán
sección
palabras
intervalo
suficientemente
lar-
go
bloques
abandonan
sección
puedan
aumentar
valor
contador
referencias
accedan
frecuencia
mejora
adicional
afronta
problema
dividir
pila
secciones
intermedia
antigua
contadores
referencias
incrementan
caso
bloques
incluidos
sección
seleccionan
remplazo
bloques
sección
anti-
gua
Asumiendo
sección
intermedia
esquema
proporciona
bloques
acce-
frecuencia
oportunidad
aumentar
valor
contadores
referen-
cias
llegar
candidatos
remplazo
simulaciones
realizadas
autores
indican
política
mejorada
significativamente
LRU
LFU
independencia
estrategia
remplazo
específica
remplazo
realizarse
demanda
planificado
anticipado
caso
remplaza
sector
ne-
cesita
hueco
caso
generan
simultáneamente
huecos
motivo
úl-
tima
estrategia
relacionado
necesidad
volver
escribir
sectores
disco
trae
cache
sector
lee
remplace
necesario
escribirlo
disco
actualiza
sector
necesario
volverlo
escribir
remplazarlo
caso
razonable
agrupar
escrituras
ordenarlas
minimizar
tiempo
búsqueda
CONSIDERACIONES
RENDIMIENTO
caso
aplican
consideraciones
rendimiento
analizadas
Apéndice
1A.
aspecto
rendimiento
cache
reduce
cuestión
alcanzar
determinada
tasa
fallos
dependerá
comportamiento
referencias
disco
respec-
to
proximidad
algoritmo
remplazo
factores
diseño
tasa
fallos
principalmente
función
tamaño
cache
disco
Figura
11.10
resu-
resultados
estudios
usando
LRU
sistema
UNIX
ejecutado
AX
OUST85
sistemas
operativos
mainframes
IBM
SMIT85
Figura
11.11
mues-
tra
resultados
simulaciones
algoritmo
remplazo
basado
frecuencia
compara-
ción
figuras
resalta
riesgos
tipo
evaluación
rendimiento
figu-
ras
parecen
mostrar
algoritmo
LRU
supera
algoritmo
remplazo
basado
frecuencia
comparan
patrones
referencias
idénticos
utilizando
estructura
cache
algoritmo
remplazo
basado
frecuencia
superior
secuencia
exacta
patrones
referencia
aspectos
diseño
relacionados
tamaño
bloque
ten-
drá
profunda
influencia
rendimiento
alcanzado
11.8
UNIX
SVR4
UNIX
dispositivo
asociado
fichero
especial
gestiona
sistema
ficheros
lee
escribe
ficheros
datos
usuario
pro-
porciona
interfaz
definida
uniforme
usuarios
procesos
leer
escribir
522
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
522Gestión
planificación
disco
523
50
IBM
SVS
IBM
MVS
AX
UNIX
10
20
30
40
50
60
10
15
20
25
30
Tamaño
cache
megabytes
Tasa
fallos
cache
disco
Figura
11.10
resultados
rendimiento
cache
disco
usando
LRU
50
Tamaño
cache
megabytes
IBM
VM
IBM
MVS
AX
UNIX
Tasa
fallos
cache
disco
10
20
30
40
50
60
70
10
15
20
25
30
Figura
11.11
Rendimiento
cache
disco
utilizando
remplazo
basado
frecuencia
ROBI90
11-Capitulo
11
16/5/05
17:06
Página
523de
dispositivo
realizan
peticiones
lectura
escritura
fichero
especial
asociado
dispositivo
Figura
11.12
muestra
estructura
lógica
sistema
S.
subsistema
ficheros
gestio-
na
ficheros
dispositivos
almacenamiento
secundario
sirve
interfaz
dispositivos
procesos
tratan
ficheros
tipos
UNIX
buffer
buffer
buffer
pasa
buffers
sistema
buffer
normalmente
involucra
sistema
DMA
transferencia
lugar
directamente
módulo
área
pro-
ceso
buffer
utilizan
tipos
buffers
caches
buffers
sistema
colas
caracteres
CACHE
BUFFERS
cache
buffers
UNIX
esencialmente
cache
disco
operaciones
disco
manejan
cache
buffers
transferencia
datos
cache
buffers
espacio
proceso
usuario
realiza
utilizando
DMA
cache
buf-
fers
área
proceso
memoria
principal
utiliza
caso
sistema
DMA
copia
memoria
memoria
operación
consumirá
ciclo
procesador
consume
ciclos
bus
gestionar
cache
buffers
listas
Lista
libres
Lista
huecos
cache
UNIX
hueco
denomina
buffer
hueco
almacena
sector
disco
disponibles
asignación
Lista
dispositivos
Lista
buffers
actualmente
asociados
disco
Cola
manejador
Lista
buffers
realmente
realizando
esperando
determinado
dispositivo
buffers
deberían
lista
libres
cola
manejador
asocia
buffer
dispositivo
permanece
asociado
esté
lista
libres
reutilice
realmente
pase
vinculado
dispositivo
Es-
tas
listas
gestionan
usando
punteros
asociados
buffer
utilizar
listas
físicamente
independientes
524
Sistemas
operativos
Aspectos
internos
principios
diseño
Carácter
Bloque
Cache
buffers
Subsistema
ficheros
Manejadores
dispositivos
Figura
11.12
Estructura
UNIX
11-Capitulo
11
16/5/05
17:06
Página
524Cuando
referencia
número
bloque
físico
determinado
dispositivo
sistema
operativo
comprueba
bloque
cache
buffers
minimizar
tiem-
po
búsqueda
lista
dispositivos
organiza
tabla
hash
utilizando
técnica
simi-
lar
desbordamiento
encadenamiento
estudiado
Apéndice
8A
Figura
8.27b
Figura
11.13
muestra
organización
general
cache
buffers
tabla
hash
longitud
fija
contiene
punteros
cache
buffers
referencia
dispositivo
bloque
corresponde
determinada
entrada
tabla
hash
puntero
dicha
entrada
apunta
buffer
cadena
puntero
hash
incluido
buffer
señala
buffer
cadena
correspon-
diente
entrada
tabla
hash
cumple
referencias
dispositivo
bloque
corresponden
entrada
tabla
hash
bloque
correspondiente
cache
buffers
buffer
cadena
vinculada
entrada
tabla
hash
consiguiente
longitud
búsqueda
cache
buffers
reduce
factor
orden
longitud
tabla
hash
remplazo
bloque
utiliza
algoritmo
recientemente
usado
buffer
asignado
bloque
disco
utilizarse
bloque
hayan
usado
recientemente
restantes
buffers
lista
libres
mantiene
orden
requerido
algoritmo
COLA
CARACTERES
dispositivos
orientados
bloques
disco
cinta
gestionar
eficientemente
usando
cache
buffers
dispositivos
orientados
caracteres
terminales
impresoras
requieren
tipo
buffers
colas
caracteres
cola
caracteres
Gestión
planificación
disco
525
Dispositivo
Bloque
Tabla
hash
Cache
buffers
Puntero
lista
libres
Puntero
lista
libres
Punteros
hash
Figura
11.13
Organización
cache
buffers
UNIX
11-Capitulo
11
16/5/05
17:06
Página
525ciertos
casos
escrita
dispositivo
leída
proceso
ocasio-
nes
proceso
escribe
dispositivo
lee
casos
utiliza
modelo
pro-
ductor
consumidor
presentado
Capítulo
colas
caracteres
leer
lee
carácter
destruye
contrasta
cache
buffers
leerse
múltiples
corresponde
modelo
lectores
escritores
es-
tudiado
Capítulo
BUFFER
buffer
consiste
simplemente
operación
DMA
dispositivo
espa-
cio
proceso
método
rápido
proceso
proceso
realizando
buffer
queda
residente
memoria
principal
pudiendo
resultar
ex-
pulsado
reduce
oportunidad
intercambio
fijar
residente
memo-
ria
principal
conlleva
disminución
rendimiento
global
sistema
Asimismo
dis-
positivo
queda
asociado
proceso
duración
transferencia
estando
disponible
procesos
DISPOSITIVOS
UNIX
categorías
dispositivos
reconocidos
UNIX
encuentran
siguientes
Dispositivos
disco
Dispositivos
cinta
Terminales
Líneas
comunicación
Impresoras
Tabla
11.5
muestra
tipos
apropiados
tipo
dispositivo
dispositivos
disco
utilizan
abundantemente
UNIX
orientados
bloques
principio
suelen
rendimiento
razonablemente
dispositivos
suele
buf-
fer
usando
cache
buffers
dispositivos
cinta
funcionalmente
similares
disposi-
tivos
disco
utilizando
esquemas
similares
abla
11.5
dispositivos
UNIX
buffer
Cache
buffers
Cola
caracteres
Unidad
disco
XX
Unidad
cinta
XX
erminales
Líneas
comunicación
Impresoras
XX
terminales
requieren
intercambio
relativamente
lento
caracteres
ter-
minal
utiliza
normalmente
cola
caracteres
similar
líneas
comunicación
re-
526
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
526quieren
procesamiento
serie
bytes
datos
entrada
salida
manejan
colas
caracteres
tipo
utilizado
impresora
dependerá
generalmen-
velocidad
impresoras
lentas
utilizan
normalmente
colas
caracteres
rápida
emplear
buffer
impresora
rápida
utilizarse
cache
buffers
datos
impresora
reutilizan
sobrecarga
cache
buffers
innecesaria
11.9
LINUX
términos
generales
sistema
núcleo
Linux
similar
implementa-
ciones
UNIX
caso
SVR4
núcleo
Linux
asocia
fichero
especial
manejador
dispositivo
distinguiéndose
dispositivos
bloques
caracteres
red
sección
estudiarán
características
sistema
Linux
PLANIFICACIÓN
DISCO
planificador
disco
defecto
Linux
2.4
conoce
nombre
ascensor
Linus
variación
algoritmo
LOOK
estudiado
Sección
11.3
Linux
2.6
al-
goritmo
ascensor
incluido
algoritmos
adicionales
planificador
basado
plazos
planificador
previsor
LOVE04b
continuación
estudiará
PLANIFICADOR
ASCENSOR
planificador
ascensor
mantiene
única
cola
peticiones
lectura
escritura
disco
realizando
operaciones
ordenamiento
agrupamiento
cola
términos
generales
planificador
ascensor
mantiene
lista
peticiones
ordenadas
número
bloque
manejan
peticiones
disco
dispositivo
mueve
única
direc-
ción
satisfaciendo
petición
estrategia
general
mejora
añade
petición
cola
consideran
orden
siguientes
cua-
tro
operaciones
petición
pendiente
cola
petición
corresponde
sector
disco
inmediatamente
adyacente
requerido
dicha
petición
previa
petición
existente
mezclan
petición
cola
suficientemente
antigua
petición
inserta
fi-
nal
cola
posición
adecuada
petición
sitúa
orden
correspondiente
posición
adecuada
petición
sitúa
cola
PLANIFICADOR
BASADO
PLAZOS
operación
lista
precedente
intenta
evitar
inanición
petición
efectiva
LOVE04a
intenta
servir
peticiones
plazo
tiempo
determinado
simplemente
deja
insertar
peticiones
orden
plazo
conveniente
esquema
ascensor
manifiestan
problemas
problema
retrasar
petición
Gestión
planificación
disco
527
11-Capitulo
11
16/5/05
17:06
Página
527de
bloque
distante
tiempo
considerable
cola
actualiza
dinámicamen-
ejemplo
considere
flujo
peticiones
bloques
disco
20
30
700
25
planificador
ascensor
modifica
orden
peticiones
sitúan
cola
orden
20
25
30
700
estando
petición
bloque
20
cabeza
cola
llega
se-
cuencia
continua
peticiones
corresponden
bloques
baja
numeración
petición
blo-
700
retrasa
indefinidamente
problema
serio
distinción
peticiones
lectura
escritura
Normalmente
petición
escritura
realiza
asíncronamente
proce-
so
solicita
petición
escritura
necesita
esperar
realmente
lleve
cabo
peti-
ción
aplicación
solicita
escritura
núcleo
copia
datos
buffer
apropia-
do
escribirá
considere
oportuno
copian
datos
buffer
núcleo
aplicación
continuar
operaciones
lectura
proceso
continuar
esperar
entreguen
datos
pedidos
aplicación
flujo
peticiones
escritura
ejemplo
escribir
disco
fichero
bloquear
petición
lectura
tiempo
considerable
bloquear
proceso
resolver
problemas
utiliza
planificador
basado
plazos
colas
Figura
11.14
petición
incluye
cola
ordenada
ascensor
algoritmo
previo
Asimismo
petición
sitúa
cola
FIFO
lectura
caso
petición
lectura
cola
FIFO
escritura
petición
escri-
tura
colas
lectura
escritura
almacenan
lista
peticiones
orden
Asociado
petición
tiempo
expiración
valor
defecto
0,5
segundos
caso
petición
lectura
segundos
escritura
Generalmente
planificador
extrae
peticiones
cola
ordenada
completa
peti-
ción
elimina
cabeza
cola
ordenada
cola
FIFO
correspondiente
cumple
tiempo
expiración
elemento
cabeza
colas
FIFO
planificador
pasa
servicio
cola
FIFO
extrayendo
petición
expirada
siguientes
peticiones
cola
sirve
petición
borra
cola
ordenada
esquema
planificador
basado
plazos
supera
problema
inanición
tam-
bién
problema
lecturas
frente
escrituras
528
Sistemas
operativos
Aspectos
internos
principios
diseño
Cola
ordenada
ascensor
Cola
FIFO
lectura
Cola
FIFO
escritura
Figura
11.14
planificador
basado
plazos
Linux
11-Capitulo
11
16/5/05
17:06
Página
528PLANIFICADOR
PREVISOR
planificador
ascensor
original
basado
plazos
diseñados
servir
peti-
ción
completa
petición
existente
manteniendo
disco
ocu-
pado
política
aplica
algoritmos
planificación
estudiados
Sección
11.5
política
contraproducente
numerosas
peticio-
nes
lectura
síncronas
Normalmente
aplicación
esperará
complete
petición
lectura
estén
datos
disponibles
petición
pequeño
retardo
reciben
datos
lectura
solicitud
lectura
permite
planificador
dedicarse
petición
pendiente
servir
petición
Gracias
principio
proximidad
probable
lecturas
sucesivas
proceso
encuentren
bloques
disco
estén
cerca
planificador
tuviera
retardo
periodo
tiempo
servir
petición
lectura
pu-
diera
comprobar
petición
lectura
cercana
rendimiento
global
sistema
mejorarse
filosofía
basa
planificador
previsor
propuesto
IYER01
implementado
Linux
2.6
Linux
planificador
previsor
superpuesto
planificador
basado
plazos
Cuan-
do
sirve
petición
lectura
planificador
previsor
causa
sistema
planificación
retrase
milisegundos
dependiendo
configuración
pequeño
retardo
oportunidad
apreciable
aplicación
solicitó
petición
lectura
genere
peti-
ción
lectura
región
disco
caso
petición
servirá
inmedia-
tamente
produce
petición
lectura
planificador
continúa
utilizando
algoritmo
planificación
basado
plazos
LOVE04b
muestra
resultados
pruebas
algoritmo
planificación
Linux
prueba
consistió
lectura
fichero
200
MB
larga
escritura
secuencial
ejecutando
plano
prueba
lectura
fichero
ejecutando
plano
leen
ficheros
árbol
código
fuen-
núcleo
tabla
muestran
resultados
pruebas
Planificador
núcleo
Prueba
Prueba
Ascensor
Linus
2.4
45
segundos
30
minutos
28
segundos
Planificador
basado
plazos
2.6
40
segundos
minutos
30
segundos
Planificador
previsor
2.6
4,6
segundos
15
segundos
apreciar
mejora
rendimiento
depende
naturaleza
carga
traba-
jo
casos
planificador
previsor
proporciona
mejora
considerable
CACHE
PÁGINAS
LINUX
Linux
2.2
versiones
anteriores
núcleo
mantiene
cache
páginas
lecturas
escrituras
ficheros
ordinarios
sistema
ficheros
páginas
memoria
virtual
cache
buffers
independiente
bloques
Linux
2.4
versiones
posterio-
res
única
cache
páginas
unificada
involucrada
tráfico
disco
memoria
principal
cache
páginas
conlleva
beneficios
lugar
llega
momento
escri-
bir
disco
páginas
modificadas
agrupar
conjunto
ordenándolas
Gestión
planificación
disco
529
11-Capitulo
11
16/5/05
17:06
Página
529adecuadamente
escribiéndolas
eficientemente
lugar
gracias
principio
proximidad
temporal
páginas
incluidas
cache
páginas
accederán
probablemente
expulsadas
cache
evitando
forma
operación
disco
páginas
modificadas
escriben
disco
situaciones
cantidad
memoria
libre
llega
menor
determinado
umbral
núcleo
reduce
tamaño
cache
páginas
liberando
memoria
añadirse
conjunto
memoria
libre
disponible
sistema
páginas
modificadas
envejecen
allá
determinado
umbral
escriben
disco
páginas
modificadas
11.10
WINDOWS
Figura
11.15
muestra
gestor
Windows
gestor
responsable
sistema
sistema
operativo
proporciona
interfaz
uniforme
tipos
maneja-
dores
llamar
MÓDULOS
BÁSICOS
gestor
consta
módulos
Gestor
cache
gestor
cache
maneja
gestión
cache
subsistema
proporcionando
servicio
cache
memoria
principal
componentes
sistemas
ficheros
red
incrementar
decrementar
dinámicamente
tama-
ño
cache
dedicada
determinada
actividad
varíe
cantidad
memoria
fí-
sica
disponible
gestor
cache
incluye
servicios
mejorar
rendimiento
general
Escritura
perezosa
sistema
registra
actualizaciones
cache
dis-
co
Posteriormente
grado
utilización
procesador
gestor
ca-
che
escribe
cambios
disco
actualiza
determinado
bloque
cache
mien-
ahorro
neto
Compromiso
perezoso
servicio
similar
escritura
perezosa
procesamien-
to
transacciones
registrar
inmediata
transacción
comple-
tado
éxito
sistema
almacena
cache
información
comprometida
posteriormen-
proceso
ejecutando
plano
escribe
log
sistema
ficheros
530
Sistemas
operativos
Aspectos
internos
principios
diseño
Gestor
Gestor
cache
Manejadores
sistemas
ficheros
Manejadores
red
Manejadores
disopsitivos
hardware
Figura
11.15
Gestor
Windows
11-Capitulo
11
16/5/05
17:06
Página
530•
Manejadores
sistemas
ficheros
gestor
manejador
sistema
fi-
cheros
manejador
encamina
mensajes
destinados
deter-
minados
volúmenes
manejador
software
correspondiente
adaptador
dispositivo
Manejadores
red
Windows
incluye
gestión
red
integrada
proporciona
soporte
aplicaciones
distribuidas
Manejadores
dispositivos
hardware
manejadores
acceden
registros
hardware
dispositivos
periféricos
puntos
entrada
bibliotecas
dinámicamente
en-
lazadas
Ejecutivo
Windows
conjunto
rutinas
plataforma
ejecutar
Windows
gracias
nombres
rutinas
plataformas
código
fuente
manejadores
dispositivos
Windows
pue-
transportar
distintos
tipos
procesadores
SÍNCRONA
ASÍNCRONA
Windows
ofrece
modos
operación
asíncrono
síncrono
asíncrono
uti-
liza
optimizar
rendimiento
aplicación
asíncrona
aplicación
inicia
operación
prosiguiendo
ejecución
cabo
peti-
ción
S.
síncrona
aplicación
bloquea
completa
operación
S.
asíncrona
eficiente
punto
vista
hilo
solicita
operación
permite
continuar
ejecutando
gestor
encola
operación
pos-
teriormente
realiza
dicha
operación
aplicación
invoca
operación
asíncrona
necesita
determinar
completa
operación
Windows
propor-
ciona
técnicas
notificación
finalización
operación
Activación
objeto
dispositivo
núcleo
estrategia
activa
indicador
asociado
objeto
dispositivo
completa
operación
objeto
hilo
solicitó
operación
continuar
ejecutando
alcance
punto
parar
espera
complete
operación
S.
instante
hilo
esperar
complete
operación
continuación
continuar
ejecución
téc-
nica
sencilla
fácil
utilizar
apropiada
manejar
múltiples
peticiones
S.
ejemplo
hilo
necesita
múltiples
acciones
simultáneas
único
fi-
chero
leer
fragmento
fichero
escribir
técnica
hilo
distinguir
finalización
lectura
escritura
Sabría
simple-
mente
operación
solicitada
fichero
completado
Activación
objeto
evento
núcleo
técnica
permite
múltiples
peticio-
nes
simultáneas
dispositivo
fichero
hilo
crea
evento
peti-
ción
Posteriormente
hilo
esperar
peticiones
alerta
técnica
utiliza
cola
asociada
hilo
conocida
cola
lla-
madas
procedimientos
asíncronos
Asynchronous
Procedure
Call
APC
caso
hilo
realiza
peticiones
gestor
sitúa
resultados
peticiones
cola
APC
hilo
solicitante
Puertos
finalización
S.
técnica
utiliza
servidor
Windows
optimi-
zar
hilos
Esencialmente
consiste
disponible
conjunto
hilos
necesario
crear
hilo
manejar
petición
RAID
SOFTWARE
Windows
proporciona
tipos
configuraciones
RAID
definidas
MS96
forma
Gestión
planificación
disco
531
11-Capitulo
11
16/5/05
17:06
Página
531•
RAID
hardware
Discos
físicos
independientes
agrupados
discos
lógicos
hardware
controlador
disco
armario
almacenamiento
disco
RAID
software
Espacio
disco
contiguo
agrupado
particiones
lógi-
cas
manejador
discos
software
tolerante
fallos
FTDISK
RAID
hardware
interfaz
controlador
maneja
creación
regeneración
infor-
mación
redundante
RAID
software
disponible
Windows
Server
implementa
funcionalidad
RAID
sistema
operativo
utilizarse
conjunto
múltiples
discos
sistema
RAID
software
implementa
RAID
RAID
caso
RAID
duplicado
dis-
cos
discos
contienen
particiones
primaria
duplicada
asociados
controlador
disco
configuración
denomina
duplexing
disco
11.11
RESUMEN
interfaz
computador
mundo
exterior
corresponde
arquitectura
S.
arqui-
tectura
diseñada
proporcionar
sistemático
controlar
interacción
mun-
do
exterior
proveer
sistema
operativo
información
necesita
gestionar
eficientemen-
actividad
S.
sistema
divide
generalmente
niveles
forma
niveles
inferiores
tratan
detalles
cercanos
funciones
físicas
nive-
superiores
tratan
lógica
genérica
resultado
cambios
parámetros
hardware
afectar
mayoría
software
S.
aspecto
fundamental
utilización
buffers
gestiona
sistema
lugar
procesos
aplicación
buffers
amortigua
diferencias
velocidad
in-
terna
computador
velocidad
dispositivos
S.
buffers
desvincula
transferencia
real
espacio
direcciones
proceso
aplicación
permite
sis-
tema
operativo
flexibilidad
hora
funciones
gestión
memoria
aspecto
impacto
rendimiento
general
sistema
disco
habido
auge
investigación
diseño
área
tipos
S.
planificación
disco
cache
disco
constituyen
estrategias
fre-
cuentemente
utilizadas
mejorar
rendimiento
disco
momento
cola
peticiones
disco
objetivo
planificación
disco
satisfacer
peticiones
minimice
tiempo
búsqueda
mecánica
disco
mejore
rendimiento
planificación
entran
juego
aspectos
tales
distribución
física
peticiones
pendientes
consideracio-
nes
proximidad
cache
disco
buffer
almacenado
usualmente
memoria
principal
funciona
cache
bloques
disco
memoria
disco
resto
memoria
principal
Gracias
principio
proximidad
cache
disco
debería
reducir
considerablemente
número
transferencias
bloques
memoria
principal
disco
11.12
LECTURAS
SITIOS
WEB
RECOMENDADOS
mayoría
libros
arquitectura
computadores
encontrar
estudios
generales
computador
STAL03
PATT98
MEE96a
proporciona
estudio
tecnología
grabación
discos
cintas
MEE96b
centra
técnicas
almacena-
532
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
532miento
datos
sistemas
disco
cinta
WIED87
contiene
excelente
estudio
as-
pectos
relacionados
rendimiento
disco
incluyendo
vinculados
planificación
disco
NG98
examina
aspectos
rendimiento
hardware
disco
CAO96
analiza
cache
disco
planificación
disco
WORT94
SELT90
estudios
algoritmos
planificación
disco
incluyen
análisis
rendimiento
ROSC03
proporciona
completo
resumen
tipos
sistemas
memoria
externa
in-
cluyendo
moderada
cantidad
detalles
técnicos
interesante
estudio
én-
fasis
interfaz
dispositivos
SCHW96
PAI00
des-
cripción
pedagógica
esquema
integrado
gestión
buffersy
cache
sistema
operativo
DELL00
proporciona
estudio
detallado
manejadores
dispositivos
Windows
jun-
to
profunda
revisión
arquitectura
Windows
excelente
estudio
tecnología
RAID
escrita
inventores
concepto
RAID
CHEN94
MASS97
presenta
estudio
detallado
RAID
Advisory
Board
aso-
ciación
distribuidores
consumidores
productos
relacionados
RAID
CHEN96
analiza
rendimiento
esquema
RAID
interesante
artículo
FRIE96
DALT96
describe
detalle
sistema
RAID
software
Windows
NT
CAO96
Cao
Felten
E.
Karlin
A.
Li
K.
Implementation
and
Performance
of
Integrated
Applica-
tion-Controlled
File
Caching
Prefetching
and
Disk
Scheduling
ACM
Transactions
on
Computer
Systems
Noviembre
1996
CHEN94
Chen
Lee
E.
Gibson
G.
Katz
R.
Patterson
D.
RAID
High-Performance
Reliable
Se-
condary
Storage
ACM
Computing
Surveys
Junio
1994
CHEN96
Chen
S.
Towsley
D.
Performance
Evaluation
of
RAID
Architectures
IEEE
Transactions
on
Computers
Octubre
1996
DALT96
Dalton
W.
et
Windows
NT
Server
Security
Troubleshooting
and
Optimization
Indiana-
polis
IN
New
Riders
Publishing
1996
DELL00
Dekker
E.
Newcomer
J.
Developing
Windows
NT
Device
Drivers
Programmer’s
Handbook
Reading
MA
Addison
Wesley
2000
FRIE96
Friedman
M.
RAID
Keeps
Going
and
Going
and
IEEE
Spectrum
Abril
1996
MASS97
Massiglia
editor
The
RAID
Book
Storage
System
Technology
Handbook
St
Peter
MN
The
Raid
Advisory
Board
1997
MEE96A
Mee
C.
Daniel
E.
eds
Magnetic
Recording
Technology
New
York
McGraw-Hill
1996
MEE96B
Mee
C.
Daniel
E.
eds
Magnetic
Storage
Handbook
New
York
McGraw-Hill
1996
NG98
Ng
S.
Advances
in
Disk
Technology
Performance
Issues
Computer
Mayo
1989
PAI00
Pai
V.
Druschel
Zwaenepoel
W.
IO-Lite
Unified
Buffering
and
Caching
System
ACM
Transactions
on
Computer
Systems
Febrero
2000
PATT98Patterson
D.
Hennessy
J.
Computer
Organization
and
Design
The
Hardware
Software
Inter-
face
San
Mateo
CA
Morgan
Kaufmann
1998
ROSC03
Rosch
W.
The
Winn
L.
Rosch
Hardware
Bible
Indianapolis
IN
Sams
2003
SCHW96
Schwaderer
W.
Wilson
A.
Understanding
Subsystems
Milpitas
CA
Adaptec
Press
1996
SELT90
Seltzer
M.
Chen
Ousterhout
J.
Disk
Scheduling
Revisited
Proceedings
USENIX
Win-
ter
Technical
Conference
Enero
1990
STAL03
Stallings
W.
Computer
Organization
and
Architecture
5th
ed
Upper
Saddle
River
NJ
Prenti-
ce
Hall
2000
WIED87
Wiederhold
G.
File
Organization
for
Database
Design
New
York
McGraw-Hill
1987
WORT94
Worthington
B.
Ganger
G.
Patt
Scheduling
Algorithms
for
Modern
Disk
Drives
ACM
SiGMETRICS
Mayo
1994
Gestión
planificación
disco
533
11-Capitulo
11
16/5/05
17:06
Página
533SITIOS
WEB
RECOMENDADOS
Caracterización
optimización
S.
sitio
dedicado
educación
investigación
área
diseño
rendimiento
S.
Incluye
herramientas
cursos
útiles
Gestiona-
do
universidad
Illinois
11.13
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
acceso
directo
memoria
DMA
disco
duro
paquete
discos
bloque
disco
extraíble
pista
buffer
circular
disco
flexible
procesador
buffer
disco
magnético
retardo
rotacional
cabeza
lectura
escritura
disco
extraíble
sector
cache
disco
dispositivo
orientado
bloques
tiempo
acceso
disco
canal
dispositivo
orientado
flujo
tiempo
búsqueda
CD-R
caracteres
tiempo
transferencia
CD-ROM
Entrada
salida
vector
redundante
discos
CD-RW
dispositivo
independientes
RAID
cilindro
dirigida
interrupciones
disco
cabeza
fija
lógica
disco
cabeza
móvil
programada
disco
digital
versátil
DVD
hueco
CUESTIONES
REPASO
11.1
Cite
ejemplos
recursos
reutilizables
consumibles
11.2
Enumere
defina
brevemente
técnicas
S.
11.3
diferencia
lógica
dispositivos
11.4
diferencia
dispositivos
orientados
bloques
orientados
flujos
caracteres
Proponga
ejemplos
tipo
11.5
debería
mejorar
rendimiento
utilizando
buffer
doble
lugar
único
buffer
11.6
elementos
retardo
involucrados
lectura
escritura
disco
11.7
Defina
brevemente
políticas
planificación
disco
mostradas
Figura
11.7
11.8
Defina
brevemente
niveles
RAID
11.9
tamaño
habitual
sector
disco
534
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
534PROBLEMAS
11.1
Considere
programa
accede
único
dispositivo
compare
buffer
buffer
Muestre
buffer
reducir
tiempo
ejecución
factor
máximo
11.2
Generalice
resultado
Problema
11.1
caso
programa
utiliza
dispositivos
11.3
Realice
tipo
análisis
muestra
Tabla
11.2
secuencia
peticiones
pistas
disco
27
129
110
186
147
41
10
64
120
Asu-
ma
cabeza
disco
situada
inicialmente
pista
100
moviendo
dirección
números
pista
crecientes
Repita
análisis
supo-
niendo
cabeza
disco
moviendo
dirección
contraria
11.4
Considere
disco
pistas
numeradas
suponga
sectores
pedi-
distribuyen
aleatoria
uniformemente
disco
pretende
calcular
núme-
ro
pistas
atravesadas
búsqueda
lugar
calcule
probabilidad
produzca
búsqueda
longitud
cabeza
actualmente
situada
pista
t.
Sugerencia
deter-
minar
número
combinaciones
teniendo
posiciones
pista
probabilidad
destino
búsqueda
continuación
calcule
probabilidad
produzca
búsqueda
longitud
K.
Sugerencia
cálculo
implica
suma
posibles
combinaciones
movimientos
pistas
Calcule
número
pistas
atravesadas
búsqueda
usando
fórmula
permite
obtener
valor
esperado
Demuestre
valores
número
pistas
atravesadas
búsqueda
N/3
11.5
propuesto
ecuación
memoria
cache
memoria
cache
disco
TC
TD
Generalice
ecuación
jerarquía
memoria
niveles
lugar
única-
mente
11.6
algoritmo
remplazo
basado
frecuencia
véase
Figura
11.11
define
Fnueva
Fintermedia
Fantigua
fracción
cache
corresponde
secciones
intermedia
antigua
respectivamente
Evidentemente
cumplirá
Fnueva
Fin-
termedia
Fantigua
Analice
tipo
política
cumple
Fantigua
Fnueva
Fantigua
tamaño
cache
11.7
velocidad
transferencia
unidad
cinta
magnética
pistas
velocidad
cinta
120
pulgadas
densidad
1.600
bits
lineales
pulgada
Pr
xix
ÂÂ
Gestión
planificación
disco
535
11-Capitulo
11
16/5/05
17:06
Página
53511.8
bobina
cinta
2.400
pies
zona
separación
registros
0,6
pul-
gadas
cinta
detiene
lecturas
aceleración
deceleración
lineal
arranques
paradas
zonas
separación
registros
carac-
terísiticas
cinta
iguales
Problema
11.7
datos
cinta
organiza-
registros
físicos
registro
físico
contiene
número
fijo
unidades
definidas
usuario
llamadas
registros
lógicos
tiempo
llevará
leer
cinta
completa
registros
lógicos
120
bytes
agru-
pados
bloques
10
registro
físico
Apartado
caso
agrupados
bloques
30
registros
lógicos
almacenará
cinta
usando
factores
agrupamiento
bloques
mencionados
anteriormente
tasa
transferencia
global
efectiva
factores
agrupamiento
bloques
mencionados
anteriormente
capacidad
cinta
11.9
Calcule
espacio
disco
sectores
pistas
superficies
requiere
almace-
nar
registros
lógicos
leídos
Problema
11.8b
disco
sectores
tamaño
fijo
512
bytes
sector
96
sectores
pista
110
pistas
superficie
superficies
útiles
Ignore
tipo
registro
registros
cabecera
fichero
índices
pista
suponga
registro
extender
sectores
11.10
Considere
sistema
disco
descrito
Problema
11.9
suponga
disco
rota
360
rpm
sistema
procesador
lee
sector
disco
utilizando
dirigida
interrupciones
produciéndose
interrupción
byte
tarda
2,5
ms
proce-
sar
interrupción
porcentaje
tiempo
procesador
dedica
manejar
tiempo
búsqueda
11.11
Repita
Problema
11.10
usando
DMA
suponiendo
interrupción
sector
11.12
computador
32
bits
canales
selectores
canal
multiplexor
canal
selector
gestiona
unidades
disco
magnético
cinta
magnética
canal
mul-
tiplexor
conectados
impresoras
líneas
lectores
tarjetas
termina-
VDT
Suponga
siguientes
velocidades
transferencia
Dispositivo
disco
800
Kbytes
Dispositivo
cinta
magnética
200
Kbytes
Impresora
líneas
6,6
Kbytes
Lector
tarjetas
1,2
Kbytes
VDT
Kbytes
Estime
máxima
velocidad
transferencia
conjunta
sistema
11.13
Debería
evidente
distribución
datos
bandas
discos
mejorar
tasa
transferencia
datos
tamaño
banda
pequeño
comparado
tamaño
petición
S.
Asimismo
debería
evidente
esquema
RAID
pro-
porciona
mejora
rendimiento
comparándolo
único
disco
manejarse
paralelo
múltiples
peticiones
S.
caso
necesaria
distribución
datos
bandas
técnica
mejora
tasa
peticiones
proporcionada
vector
discos
características
similares
utiliza
dicha
técnica
536
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
536APÉNDICE
11A
DISPOSITIVOS
ALMACENAMIENTO
DISCO
DISCO
MAGNÉTICO
disco
plato
circular
construido
metal
plástico
cubierto
material
magné-
tico
datos
graban
disco
posteriormente
recuperan
bobina
conductora
llamada
cabeza
operación
lectura
escritura
cabeza
estacionaria
plato
rota
mecanismo
escritura
basa
electricidad
fluye
bobina
produce
campo
magnético
envían
pulsos
cabeza
registrándose
patrones
magné-
ticos
superficie
subyacente
dependiendo
corriente
positiva
ne-
gativa
mecanismo
lectura
basa
campo
magnético
moviéndose
bobina
produce
corriente
eléctrica
bobina
superficie
disco
pasa
cabeza
genera
corriente
polaridad
grabó
previamente
ORGANIZACIÓN
FORMATO
DATOS
cabeza
dispositivo
relativamente
pequeño
capaz
leer
escribir
plato
rota
consecuencia
organización
datos
plato
consiste
conjunto
concéntrico
anillos
llamados
pistas
pista
anchura
cabeza
miles
pistas
superficie
Figura
11.16
muestra
distribución
datos
pistas
adyacentes
separadas
huecos
impide
minimiza
errores
debidos
cabeza
esté
alineada
simplemente
existan
interferencias
campos
magnéticos
Gestión
planificación
disco
537
S6
S4
S5
S3
S2
S1
SN
S6
S5
S4
S3
S2
S1
SN
Hueco
sectores
Hueco
pistas
Sectores
Pistas
Figura
11.16
Disposición
datos
disco
11-Capitulo
11
16/5/05
17:06
Página
537Los
datos
transfieren
disco
sectores
Figura
11.16
Normalmente
cientos
secto-
res
pista
longitud
fija
variable
mayoría
sistemas
contemporá-
neos
sectores
utilizan
longitud
fija
512
bytes
prácticamente
universal
tamaño
sector
evitar
imponer
requisitos
precisión
irrazonables
sistema
sectores
adya-
centes
separados
huecos
pistas
existir
huecos
sectores
pista
bit
esté
centro
disco
rotando
pasa
punto
fijo
cabeza
lectura-escritura
velocidad
bit
situado
exterior
encontrar
compensar
variación
velocidad
cabeza
leer
bits
velocidad
lograr
incrementando
espacio
bits
información
grabada
distintos
segmentos
disco
Gracias
información
accederse
velocidad
rotando
disco
velocidad
fija
conocida
velocidad
an-
gular
constante
Constant
Angular
Velocity
CA
Figura
11.17a
muestra
disposición
disco
utiliza
CA
V.
disco
dividido
sectores
forma
tarta
serie
pistas
concéntricas
ventaja
utilizar
CA
referencia
directamente
bloque
individual
datos
usando
número
pista
sector
mover
cabeza
posi-
ción
actual
dirección
específica
necesita
corto
movimiento
cabeza
pista
correspondiente
espera
sector
apropiado
gire
cabeza
desven-
taja
CA
cantidad
datos
almacenar
pistas
exteriores
longitud
almacenar
pistas
interiores
cortas
densidad
bits
pulgada
lineal
incrementa
moverse
pistas
externas
internas
capacidad
almacenamiento
disco
sistema
CA
senci-
llo
limitada
densidad
grabación
máxima
lograrse
pistas
internas
incrementar
densidad
sistemas
disco
duro
modernos
utilizan
técnica
conocida
grabación
múltiples
zonas
superficie
dividida
zonas
concéntri-
cas
normalmente
16
zona
número
bits
pista
constante
zonas
alejadas
centro
contienen
bits
sectores
zonas
cerca
centro
permite
capacidad
almacenamiento
global
coste
circuitería
compleja
mueve
cabeza
disco
zona
cambia
longitud
pista
bit
causando
cambio
temporización
lecturas
escrituras
Figura
11.17b
muestra
naturaleza
grabación
múltiples
zonas
figura
zona
anchura
pista
538
Sistemas
operativos
Aspectos
internos
principios
diseño
Velocidad
angular
constante
Grabación
múltiples
zonas
Figura
11.17
Comparación
métodos
disposición
disco
11-Capitulo
11
16/5/05
17:06
Página
538Se
necesita
forma
localizar
posición
sector
pista
Lógicamen-
punto
inicio
pista
identificar
inicio
sector
requisitos
manejan
datos
control
grabados
disco
tan-
to
disco
formatea
datos
adicionales
utilizados
controlador
disco
accesibles
usuario
CARACTERÍSTICAS
FÍSICAS
Tabla
11.6
detalla
características
principales
distinguen
diversos
tipos
discos
mag-
néticos
lugar
cabeza
fija
moverse
dirección
radial
plato
disco
cabeza
fija
cabeza
lectura
escritura
pista
cabezas
montadas
brazo
rígido
extiende
pistas
disco
cabeza
móvil
cabeza
lectura
escritura
superficie
caso
cabeza
montada
brazo
cabeza
capaz
situarse
pista
brazo
extenderse
retraerse
propósito
abla
11.6
Características
físicas
sistemas
disco
Movimiento
cabeza
Platos
Cabeza
fija
pista
Único
plato
Cabeza
móvil
superficie
Múltiples
platos
Carácter
portátil
disco
Mecanismo
cabeza
Disco
extraíble
Contacto
disco
flexible
Disco
extraíble
Separación
fija
Separación
aerodinámica
Winchester
Número
caras
plato
cara
Doble
cara
disco
montado
dispositivo
disco
consta
brazo
eje
gi-
ratorio
rota
disco
electrónica
necesaria
leer
escribir
datos
binarios
disco
ex-
traíble
montado
permanentemente
dispositivo
disco
disco
duro
computador
personal
disco
extraíble
disco
extraíble
extraído
remplazado
disco
ventaja
tipo
discos
permiten
esté
disponible
cantidad
ilimitada
datos
número
limitado
sistemas
disco
disco
tipo
mover
computador
discos
flexibles
cartuchos
ZIP
ejemplos
discos
extraíbles
mayoría
discos
cubierta
magnética
aplicada
lados
plato
denomina
doble
cara
discos
económicos
utilizan
discos
cara
dispositivos
disco
incluyen
múltiples
platos
apilados
verticalmente
separados
pulgada
existiendo
múltiples
brazos
Figura
11.18
discos
múltiples
platos
emplean
cabeza
móvil
cabeza
lectura
escritura
superficie
plato
cabezas
fijas
mecánicamente
distancia
centro
disco
mueven
conjuntamente
momento
cabezas
posicionan
pis-
tas
distancia
centro
disco
conjunto
pistas
posición
relativa
plato
denomina
cilindro
ejemplo
pistas
sombreadas
Figura
11.19
cilindro
Gestión
planificación
disco
539
11-Capitulo
11
16/5/05
17:06
Página
539Por
mecanismo
cabeza
establece
clasificación
discos
tipos
Tradicionalmente
cabeza
lectura
escritura
posiciona
distancia
fija
plato
dejando
bolsa
aire
extremo
mecanismo
cabeza
entra
real-
mente
contacto
físico
operación
lectura
escritura
mecanis-
mo
disco
flexible
plato
pequeño
flexible
constituyendo
tipo
disco
económico
comprender
tercer
tipo
disco
necesita
comentar
relación
existente
densi-
dad
datos
tamaño
bolsa
aire
cabeza
generar
detectar
campo
electromag-
nético
magnitud
suficiente
leer
escribir
apropiadamente
estrecha
cabeza
cerca
superficie
plato
funcionar
cabeza
estrecha
implica
pistas
estrechas
densidad
datos
deseable
cerca
esté
cabeza
disco
riesgo
error
impurezas
imperfecciones
de-
sarrollo
Disco
Winchester
significó
avance
considerable
tecnología
cabezas
Win-
chester
utilizan
montajes
sellados
dispositivos
prácticamente
libres
contaminan-
tes
diseñados
operar
cerca
superficie
disco
cabezas
disco
rígido
convencional
permitiendo
densidad
datos
cabeza
realmente
lámina
aerodi-
námica
descansa
ligeramente
superficie
plato
disco
inmóvil
presión
aire
generada
disco
girando
suficiente
lámina
eleve
superficie
sistema
contactos
resultante
construirse
usen
540
Sistemas
operativos
Aspectos
internos
principios
diseño
Superficie
Superficie
Superficie
Superficie
Superficie
Superficie
Superficie
Superficie
Superficie
Plato
Eje
Brazo
Cabeza
lectura
escritura
superficie
Dirección
movimiento
brazo
Superficie
Figura
11.18
Componentes
dispositivo
disco
11-Capitulo
11
16/5/05
17:06
Página
540cabezas
estrechas
operen
cerca
superficie
plato
cabezas
disco
duros
convencionales4
Tabla
11.7
muestra
parámetros
típicos
discos
cabezas
móviles
alto
rendimiento
actuales
MEMORIA
ÓPTICA
1983
presentó
productos
consumo
éxito
tiempos
siste-
ma
audio
digital
disco
compacto
Compact
Disk
CD
CD
disco
borrarse
almacenar
60
minutos
información
audio
cara
enorme
éxito
co-
mercial
CD
permitió
desarrollo
tecnología
almacenamiento
disco
óptico
coste
revolucionado
almacenamiento
datos
computador
pre-
sentado
diversos
sistemas
disco
óptico
véase
Tabla
11.8
continuación
presenta
breve-
mente
Gestión
planificación
disco
541
asunto
interés
historico
término
Winchester
utilizó
originalmente
IBM
nombre
código
mo-
delo
disco
3340
anunciado
públicamente
3340
paquete
discos
extraíble
cabezas
selladas
den
tro
paquete
término
aplica
dispositivo
disco
cuyas
unidades
selladas
diseño
ca-
beza
aerodinámico
disco
Winchester
comúnmente
computadores
personales
estaciones
trabajo
llama
disco
duro
Figura
11.19
Pistas
cilindros
11-Capitulo
11
16/5/05
17:06
Página
541542
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
11.7
.Parámetros
discos
duros
típicos
Características
Seagate
Barracuda
Seagate
Cheetah
Seagate
Barracuda
oshiba
HDD1242
IBM
Microdrive
180
X15-36LP
36ES
Aplicación
Servidor
alta
Servidor
alto
Computador
personal
Computador
portátil
Dispositivos
capacidad
rendimiento
gama
baja
portátiles
mano
Capacidad
181,6
GB
36,7
GB
18,4
GB
GB
GB
Tiempo
mínimo
0,8
ms
0,3
ms
1,0
ms
1,0
ms
búsqueda
pista
pista
Tiempo
ms
3,6
ms
9,5
ms
15
ms
12
ms
búsqueda
Velocidad
rotación
.200
rpm
15
rpm
.200
rpm
4.200
rpm
3.600
rpm
Retardo
rotacional
4,17
ms
ms
4,17
ms
14
ms
8,33
ms
Tasa
transferencia
160
MB/
522
709
MB
25
MB
66
MB
13,3
MB
máxima
Bytes
sector
512
512
512
512
512
Sectores
pista
793
485
600
63
Pistas
cilindro
24
8222
número
caras
platos
Cilindros
número
24.247
18.479
29.851
10.350
pistas
cara
plato
11-Capitulo
11
16/5/05
17:06
Página
542
abla
11.8
Diversos
tipos
discos
ópticos
CD
Disco
compacto
disco
borrarse
almacena
información
audio
digita-
lizada
sistema
estándar
discos
12
cm
grabar
60
minutos
tiempo
reproducción
ininterrumpida
CD-ROM
Disco
compacto
memoria
lectura
Read
Only
Memory
disco
bo-
rrarse
utilizado
almacenar
datos
computador
sistema
estándar
discos
12
cm
almacenar
650
Mbytes
CD-R
CD
grabable
Recordable
Similar
CD-ROM
usuario
escribir
disco
CD-RW
CD
modificable
Rewritable
Similar
CD-ROM
usuario
borrar
modificar
disco
múltiples
DVD
Disco
Digital
Versátil
Digital
Versatile
Disk
tecnología
producir
representación
comprimida
digitalizada
información
vídeo
volúmenes
datos
digitales
discos
12
cm
diámetro
capacidad
17
Gbytes
usando
doble
cara
DVD
básico
lectura
DVD-ROM
DVD-R
DVD
grabable
Recordable
Similar
DVD-ROM
usuario
escribir
disco
discos
única
cara
DVD-RW
DVD
modificable
Rewritable
Similar
DVD-ROM
usuario
borrar
modificar
disco
múltiples
discos
única
cara
CD-ROM
CD
audio
CD-ROM
Compact
Disk
Read
Only
Memory
disco
compacto
lectura
tecnología
similar
diferencia
principal
reproductores
CD-
ROM
robustos
mecanismos
corrección
errores
aseguran
datos
transfieren
correctamente
disco
computador
tipos
discos
fabrican
disco
resina
ejemplo
policarbonato
informa-
ción
grabada
digitalmente
música
datos
computador
imprime
serie
agujeros
microscópicos
superficie
policarbonato
operación
realiza
lu-
gar
láser
alta
intensidad
enfocado
precisión
creando
disco
maestro
maestro
matriz
permita
imprimir
copias
policarbonato
continuación
superficie
agujereada
cubre
superficie
reflectante
normalmente
aluminio
oro
superficie
brillante
protegida
polvo
rasguños
cubierta
superior
material
acrílico
transparente
serigrafía
etiqueta
material
acrílico
información
lee
CD
CD-ROM
láser
baja
intensidad
alojado
reproductor
disco
óptico
unidad
dispositivo
láser
ilumina
cubierta
protectora
transparente
motor
gira
disco
pasando
in-
Gestión
planificación
disco
543
11-Capitulo
11
16/5/05
17:06
Página
543tensidad
luz
láser
reflejada
cambia
enfoca
agujero
cambio
detecta
foto
sensor
convierte
señal
digital
Recuerde
disco
magnético
información
graba
pistas
concéntricas
disco
magnético
sistema
velocidad
angular
constante
Constant
Angular
Velocity
CA
sencillo
número
bits
pista
constante
lograr
incremento
densidad
esquema
grabación
múltiples
zonas
superficie
dividida
zonas
alejadas
centro
contienen
bits
cercanas
técnica
incrementa
capacidad
óptima
alcanzar
capacidad
CD
CD-ROM
organizan
información
pistas
concéntricas
lugar
disco
contiene
única
pista
espiral
comenzando
cerca
cen-
tro
girando
forma
espiral
extremo
exterior
disco
sectores
cercanos
ex-
terior
disco
longitud
cerca
interior
infor-
mación
empaquetada
uniformemente
disco
segmentos
tamaño
acceden
velocidad
rotando
disco
velocidad
variable
láser
lee
agujeros
velocidad
lineal
constante
Constant
Linear
Velocity
CLV
disco
rota
lentamente
accede
extremo
exterior
accede
cerca
centro
capacidad
pista
retardo
rotacional
incrementan
posiciones
cercanas
extremo
exterior
disco
capacidad
CD-ROM
680
MB
CD-ROM
apropiado
distribución
cantidades
datos
número
usuarios
gasto
generado
proceso
inicial
escritura
apropiado
aplicación
Comparándolo
discos
magnéticos
tradicionales
CD-ROM
ventajas
principales
capacidad
almacenamiento
información
disco
óptico
disco
óptico
información
almacenada
replicada
masiva-
mente
forma
económica
diferencia
ocurre
disco
magnético
repro-
ducir
base
datos
almacenada
disco
magnético
copiarla
disco
disco
utili-
zando
unidades
disco
disco
óptico
extraíble
permitiendo
utilizar
disco
almacenamiento
archivo
permanente
información
mayoría
discos
magnéticos
ex-
traíbles
discos
magnéticos
extraíbles
información
copiarse
cinta
dispositivo
disco
disco
utilizarse
almacenar
información
desventajas
CD-ROM
siguientes
lectura
actualizarse
tiempo
acceso
dispositivo
disco
magnético
CD
GRABABLE
adaptarse
aplicaciones
necesita
copia
pequeño
número
co-
pias
conjunto
datos
desarrollado
CD
permite
lecturas
es-
critura
denomina
CD
grabable
CD-R
CD
Recordable
CD-R
fabrica
disco
posteriormente
escribir
rayo
láser
moderada
intensidad
544
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
544tanto
controlador
disco
caro
CD-ROM
leer
disco
consumidor
escribir
substrato
CD-R
similar
idéntico
CD
CD-ROM
caso
CD
CD-ROM
información
graba
agujeros
superficie
cambia
capa-
cidad
reflectante
CD-R
substrato
incluye
capa
tinte
tinte
utiliza
cambiar
capacidad
reflectante
activado
láser
alta
intensidad
disco
resultante
leer
dispositivo
CD-R
CD-ROM
disco
óptico
CD-R
indicado
archivo
permanente
documentos
ficheros
Pro-
porciona
registro
permanente
volúmenes
datos
usuario
CD
MODIFICABLE
disco
óptico
CD-RW
Rewritable
escribir
reescribir
repetidas
ocurre
disco
magnético
intentado
diversas
estrategias
única
técnica
carácter
puramente
óptico
contraposición
técnica
magneto-óptica
presenta
posteriormente
mostrado
efectiva
denomina
cambio
fase
disco
cambio
fase
utiliza
mate-
rial
presenta
niveles
reflectantes
significativamente
fase
distin-
tos
amorfo
moléculas
presentan
orientación
aleatoria
re-
fleja
luz
cristalino
superficie
lisa
refleja
luz
rayo
luz
láser
cambiar
material
fase
desventaja
primordial
discos
ópticos
cambio
fase
material
acaba
perdiendo
forma
definitiva
permanente
propiedades
necesarias
materiales
actuales
utilizar
número
ciclos
borrado
500.000
1.000.000
CD-RW
ventaja
evidente
CD-ROM
CD-R
reescribirse
usarse
almacenamiento
secundario
compite
disco
mag-
nético
ventaja
fundamental
discos
ópticos
márgenes
tolerancia
fabri-
cación
estrictos
discos
magnéticos
alta
capacidad
presen-
fiabilidad
vida
prolongada
DISCO
DIGITAL
VERSÁTIL
capacidad
disco
digital
versátil
Digital
Versatile
Disk
DVD
industria
electrónica
encontrado
sustituto
aceptable
cinta
analógica
vídeo
VHS
DVD
remplazará
cinta
vídeo
utilizada
grabadores
casetes
vídeo
Video
Cassette
Recorder
VCR
importante
ámbito
presentación
remplazará
CD-ROM
computadores
per-
sonales
servidores
DVD
introduce
vídeo
digital
Muestra
películas
calidad
imagen
impresionante
pudiendo
accederse
aleatoria
CD
audio
reproducirse
máquinas
DVD
disco
DVD
almacenar
enormes
volúme-
nes
datos
actualmente
CD-ROM
enorme
capacidad
almace-
namiento
DVD
increíble
calidad
juegos
PC
harán
realistas
software
peda-
gógico
incorporará
vídeo
despertar
tecnología
producirá
explosión
tráfico
Internet
intranets
corporativas
incorpo-
rando
material
sitios
web
capacidad
DVD
siguientes
dife-
rencias
CD-ROM
DVD
bits
almacenan
espacio
bucles
es-
piral
CD
1,6
mm
distancia
mínima
agujeros
espiral
0,834
mm
DVD
utiliza
láser
longitud
onda
corta
alcanzando
espa-
Gestión
planificación
disco
545
11-Capitulo
11
16/5/05
17:06
Página
545cio
bucle
0,74
mm
distancia
mínima
agujeros
0,4
mm
resultado
es-
tas
mejoras
incremento
capacidad
CD-
ROM
cerca
4,7
GB
DVD
emplea
capa
agujeros
substrato
capa
DVD
capa
dual
capa
semi-reflectora
capa
reflectora
ajustando
foco
lectores
láser
dispositivos
DVD
leer
capa
separa-
damente
técnica
dobla
capacidad
disco
8,5
GB
menor
capaci-
dad
reflectora
capa
limita
capacidad
almacenamiento
lle-
ga
doble
capacidad
DVD
caras
CD
datos
graban
cara
proporciona
capacidad
17
GB
ocurre
CD
DVD
presenta
versiones
modificables
lectura
Tabla
11.8
546
Sistemas
operativos
Aspectos
internos
principios
diseño
11-Capitulo
11
16/5/05
17:06
Página
546CAPÍTULO
12
Gestión
ficheros
12.1
Descripción
básica
12.2
Organización
acceso
ficheros
12.3
Directorios
12.4
Compartición
ficheros
12.5
Bloques
registros
12.6
Gestión
almacenamiento
secundario
12.7
Gestión
ficheros
UNIX
12.8
Sistema
ficheros
virtual
Linux
12.9
Sistema
ficheros
Windows
12.10
Resumen
12.11
Lecturas
recomendadas
12.12
érminos
clave
cuestiones
repaso
problemas
12-Capitulo
12
16/5/05
17:56
Página
547N
mayoría
aplicaciones
fichero
elemento
central
excepción
aplica-
ciones
tiempo
real
aplicaciones
especializadas
entrada
aplicación
realiza
fichero
prácticamente
aplicaciones
salida
guarda
fichero
almacenamiento
plazo
acceso
posterior
usuario
programas
ficheros
vida
aplicación
individual
utilice
entrada
sa-
lida
usuarios
desean
acceder
ficheros
guardarlos
mantener
integridad
contenidos
lograr
objetivos
prácticamente
sistemas
operativos
pro-
porcionan
programas
ejecutan
aplicaciones
privilegiadas
mínimo
sistema
gestión
ficheros
necesita
servicios
especiales
sistema
operativo
máxi-
mo
sistema
gestión
ficheros
completo
sistema
operativo
apropiado
considerar
elementos
básicos
gestión
ficheros
libro
comenzará
análisis
pasando
continuación
mostrar
esquemas
organi-
zación
ficheros
organización
ficheros
generalmente
ámbito
siste-
ma
operativo
esencial
comprensión
general
alternativas
comunes
apreciar
compromisos
diseño
relacionados
gestión
ficheros
resto
capítulo
describe
temas
gestión
ficheros
12.1
DESCRIPCIÓN
BÁSICA
FICHEROS
SISTEMAS
FICHEROS
punto
vista
usuario
partes
importantes
sistema
operativo
sistema
ficheros
sistema
ficheros
proporciona
abstracciones
recursos
típicamente
aso-
ciadas
almacenamiento
secundario
sistema
ficheros
permite
usuarios
crear
colec-
ciones
datos
llamadas
ficheros
propiedades
deseables
tales
siguientes
Existencia
plazo
ficheros
almacenan
disco
almacenamiento
secun-
dario
desaparece
usuario
desconecta
Compartible
procesos
ficheros
nombres
permisos
acceso
asociados
permitan
controlar
compartición
Estructura
Dependiendo
sistema
ficheros
fichero
estructura
in-
terna
conveniente
aplicaciones
particulares
Adicionalmente
ficheros
pue-
den
organizar
estructuras
jerárquicas
complejas
reflejar
relaciones
sistema
ficheros
proporciona
almacenar
datos
organiza-
ficheros
colección
funciones
cabo
ficheros
Algu-
nas
operaciones
típicas
siguientes
Crear
define
fichero
posiciona
estructura
ficheros
Borrar
elimina
fichero
estructura
ficheros
destruye
Abrir
fichero
existente
declara
abierto
proceso
permitiendo
proceso
reali-
zar
funciones
fichero
Cerrar
determinado
proceso
cierra
fichero
forma
volver
determinadas
funciones
vuelva
abrirlo
548
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
548•
Leer
proceso
lee
fichero
datos
porción
Escribir
proceso
actualiza
fichero
añadiendo
datos
expanden
tama-
ño
fichero
cambiando
valores
elementos
datos
existentes
fichero
Típicamente
sistema
ficheros
mantiene
conjunto
atributos
asociados
fichero
Es-
tos
incluyen
propietario
tiempo
creación
tiempo
modificación
privilegios
acce-
so
etc.
ESTRUCTURA
FICHERO
términos
aparecen
normalmente
ficheros
Campo
Registro
Fichero
Base
datos
campo
elemento
básico
datos
campo
individual
contiene
único
valor
apellido
empleado
fecha
valor
sensor
caracteriza
longitud
tipo
datos
ejemplo
ASCII
cadena
caracteres
decimal
Dependiendo
diseño
fi-
chero
campo
longitud
fija
variable
caso
campo
formado
normalmente
subcampos
valor
real
almacenado
nombre
campo
casos
longitud
campo
casos
campos
longitud
variable
longitud
campo
indica
símbolos
demarcación
especiales
campos
registro
colección
campos
relacionados
tratarse
unidad
aplicación
ejemplo
registro
empleado
contener
campos
tales
nombre
número
seguridad
social
clasificación
trabajo
fecha
contratación
etc.
dependien-
do
diseño
registros
longitud
fija
variable
registro
longitud
va-
riable
campos
longitud
variable
número
campos
variar
caso
campo
acompaña
normalmente
nombre
campo
caso
registro
completo
incluye
normalmente
campo
longitud
fichero
colección
campos
similares
fichero
entidad
única
usuarios
aplicaciones
ficheros
referenciar
nombre
Dichos
fiche-
ros
crear
borrar
restricciones
control
acceso
normalmente
aplican
nivel
fichero
sistema
compartido
acceso
ficheros
completos
permitido
de-
negado
usuarios
programas
sistemas
sofisticados
tales
controles
reali-
zan
nivel
registro
nivel
campo
base
datos
colección
datos
relacionados
aspectos
esenciales
base
datos
relación
exista
elementos
datos
explícita
base
da-
tos
diseña
aplicaciones
base
datos
conte-
ner
información
relacionada
organización
proyecto
información
nego-
cio
estudio
científico
base
datos
formada
tipos
ficheros
Normalmente
sistema
gestión
base
datos
separado
sistema
operativo
programas
gestión
ficheros
usuarios
aplicaciones
desean
utilizar
ficheros
operaciones
típicas
sopor-
tarse
incluyen
Gestión
ficheros
549
12-Capitulo
12
16/5/05
17:07
Página
549•
Obtener_Todos
Obtener
registros
fichero
operación
requerirá
aplicaciones
deban
procesar
información
fichero
ejemplo
aplicación
produzca
resumen
información
existente
fichero
necesitaría
obtener
registros
operación
asocia
frecuentemente
término
procesa-
miento
secuencial
registros
acceden
secuencia
Obtener_Uno
operación
solicita
único
registro
aplicaciones
interactivas
orien-
tadas
transacciones
necesitan
operación
Obtener_Siguiente
operación
solicita
registro
secuencia
lógica
registro
recientemente
leído
aplicaciones
interactivas
tales
rellenado
formularios
requerir
tipo
operaciones
programa
reali-
za
búsqueda
utilizar
tipo
operación
Obtener_Anterior
Similar
operación
Obtener_Siguiente
caso
registro
accede
recientemente
leído
Insertar_Uno
Insertar
registro
fichero
necesario
re-
gistro
encaje
posición
específica
preservar
secuencia
fichero
Borrar_Uno
Borrar
registro
existente
enlaces
estructuras
datos
actualizarse
preservar
secuencia
fichero
Actualizar_Uno
Obtener
registro
actualizar
campos
reescribir
re-
gistro
actualizado
fichero
necesario
preservar
secuenciación
operación
longitud
registro
cambiado
operación
actualización
gene-
ralmente
difícil
preserva
longitud
Obtener_Varios
Obtener
registros
ejemplo
aplicación
usuario
de-
sear
obtener
registros
satisfacen
conjunto
criterios
naturaleza
operaciones
realizan
habitualmente
ficheros
influirá
forma
organiza
fichero
discutirá
Sección
12.2
Debería
destacarse
sistemas
ficheros
utilizan
conjunto
estructuras
discu-
tido
subsección
UNIX
sistemas
similares
estructura
fichero
básica
flujo
caracteres
ejemplo
programa
almacena
fichero
campos
físi-
cos
registros
estructuras
SISTEMAS
GESTIÓN
FICHEROS
sistema
gestión
ficheros
conjunto
software
sistema
proporciona
servicios
usuarios
aplicaciones
ficheros
Típicamente
única
forma
usuario
aplicación
acceder
ficheros
sistema
gestión
ficheros
elimina
necesidad
usuario
programador
desarrolle
software
propósito
especial
aplica-
ción
proporciona
sistema
forma
consistente
definida
controlar
recurso
importante
GROS86
sugiere
siguientes
objetivos
sistema
gestión
ficheros
Satisfacer
necesidades
gestión
datos
requisitos
usuario
incluye
almace-
namiento
datos
capacidad
cabo
operaciones
anteriormente
mencionadas
Garantizar
datos
fichero
válidos
Optimizar
rendimiento
punto
vista
sistema
términos
productividad
punto
vista
usuario
términos
tiempo
respuesta
550
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
550•
Proporcionar
soporte
variedad
tipos
dispositivos
almacenamiento
Minimizar
eliminar
potencial
pérdida
datos
Proporcionar
conjunto
estándar
rutinas
interfaces
procesos
Proporcionar
soporte
múltiples
usuarios
caso
sistemas
multiusuarios
punto
satisfacer
requisitos
usuario
depende
variedad
aplica-
ciones
entorno
sistema
computación
utilizará
sistema
interactivo
propósito
general
siguientes
características
constituyen
conjunto
mínimo
requisitos
usuario
debería
crear
borrar
leer
escribir
modificar
ficheros
usuario
tendría
acceso
controlado
ficheros
usuarios
usuario
controlar
tipos
accesos
permiten
ficheros
usuarios
usuario
reestructurar
ficheros
usuarios
forma
apropiada
problema
usuario
capaz
mover
datos
ficheros
usuario
copiar
recuperar
ficheros
usuario
caso
daño
usuario
acceder
ficheros
utilizando
nombres
simbólicos
objetivos
requisitos
tenerse
mente
discutan
sistemas
gestión
ficheros
Arquitectura
sistema
ficheros
forma
ámbito
gestión
ficheros
analizar
organización
software
típi-
ca
sugiere
Figura
12.1
distintos
sistemas
organizarán
forma
organización
razonablemente
representativa
nivel
manejadores
dispositivos
comunican
directamente
dispositivos
periféricos
controladores
cana-
controlador
dispositivo
responsable
iniciar
operaciones
dispositi-
vo
procesar
finalización
petición
S.
operaciones
ficheros
dispositi-
vos
típicos
discos
cintas
controladores
dispositivos
consideran
normalmente
sistema
operativo
nivel
denomina
sistema
ficheros
básico
nivel
físico
interfaz
primaria
entorno
sistema
computación
bloques
datos
intercambiados
discos
sistemas
cintas
nivel
encarga
coloca-
ción
bloques
dispositivo
almacenamiento
secundario
buffering
dichos
bloques
memoria
principal
encarga
interpretar
contenido
datos
estructu-
ra
ficheros
sistema
ficheros
básico
frecuentemente
considerado
sistema
operativo
supervisor
básico
encarga
iniciaciones
finalizaciones
S.
nivel
estructuras
control
tratan
dispositivos
planificación
ficheros
supervisor
básico
selecciona
dispositivo
cabo
operaciones
basándose
fichero
particular
seleccionado
encarga
planificación
disco
cinta
optimizar
rendimiento
nivel
asignan
buffers
memo-
ria
secundaria
supervisor
básico
sistema
operativo
Gestión
ficheros
551
12-Capitulo
12
16/5/05
17:07
Página
551La
lógica
permite
usuarios
aplicaciones
acceder
registros
mien-
sistema
ficheros
básico
bloques
datos
módulo
lógica
re-
gistros
ficheros
capa
lógica
proporciona
capacidad
propósito
general
nivel
registros
mantiene
datos
básicos
ficheros
nivel
sistema
ficheros
cercano
usuario
frecuentemente
denominado
método
acceso
Proporciona
interfaz
estándar
aplicaciones
sistemas
ficheros
dispo-
sitivos
contienen
datos
métodos
acceso
reflejan
estructuras
fiche-
ros
formas
acceder
procesar
datos
métodos
acceso
comu-
nes
muestran
Figura
12.1
describen
brevemente
Sección
12.2
Funciones
gestión
ficheros
forma
funciones
sistema
ficheros
muestra
Figura
12.2
Sigamos
diagrama
izquierda
derecha
usuarios
programas
aplicaciones
interaccionan
siste-
ma
ficheros
mandatos
crear
borrar
ficheros
operaciones
fi-
cheros
operación
sistema
ficheros
identificar
localizar
fi-
chero
seleccionado
requiere
tipo
directorio
utilice
describir
ubicación
ficheros
atributos
Adicionalmente
mayoría
sistemas
compar-
tidos
fuerza
control
acceso
usuario
permite
determinado
acceso
particular
usua-
rios
autorizados
operaciones
básicas
usuario
aplicación
realizan
nivel
registro
usuario
aplicación
ve
fichero
estructura
organiza
registros
tales
estructura
secuencial
ejemplo
registros
personales
almacenan
alfabéticamente
apellido
traducir
mandatos
usuario
mandatos
manipulación
fi-
cheros
específicos
emplearse
método
acceso
apropiado
estructura
ficheros
usuarios
aplicaciones
preocupan
registros
realiza
ni-
vel
bloque
registros
fichero
convertir
bloque
salida
volver
convertir
estructura
registro
entrada
soporte
bloque
nece-
sitan
funciones
gestionar
almacenamiento
secundario
supone
asignar
ficheros
bloques
libres
almacenamiento
secundario
bloques
disponibles
ficheros
utilizados
ficheros
existentes
Adicionalmente
planificar
peticiones
552
Sistemas
operativos
Aspectos
internos
principios
diseño
lógica
Supervisor
básico
Sistema
ficheros
básico
Manejador
disco
Manejador
cinta
Secuencial
indexadoFichero
Secuencial
Indexado
Hashed
Programa
usuario
Figura
12.1
Arquitectura
software
sistema
ficheros
12-Capitulo
12
16/5/05
17:07
Página
552de
bloques
individuales
tema
trató
Capítulo
11
planificación
disco
asignación
ficheros
relacionadas
optimización
rendimiento
po-
dría
esperar
funciones
necesitan
considerarse
simultáneamente
optimi-
zación
dependerá
estructura
ficheros
patrones
acceso
desarro-
llar
sistema
gestión
ficheros
óptimo
punto
vista
rendimiento
tarea
excesivamente
complicada
Figura
12.2
sugiere
división
responsabilidades
sistema
gestión
ficheros
considerado
utilidad
sistema
responsabilidades
sistema
operativo
punto
intersección
procesamiento
registros
división
arbitraria
utilizan
distintas
técnicas
diversos
sistemas
resto
capítulo
describe
aspectos
diseño
sugeridos
Figura
12.2
comienza
discusión
organizaciones
ficheros
métodos
acceso
Aun-
tema
ámbito
responsabilidad
sistema
operativo
imposible
discutir
aspectos
diseño
apreciación
organización
acceso
fiche-
ros
describe
concepto
directorio
sistema
operativo
nombre
sistema
gestión
ficheros
gestiona
frecuentemente
directorios
temas
restantes
tratan
as-
pectos
físicos
gestión
ficheros
tratados
apropiadamente
aspectos
diseño
sistemas
operativos
temas
forma
registros
lógicos
organizan
bloques
físicos
Finalmente
temas
relacionados
asignación
ficheros
almacenamiento
secundario
gestión
almacenamiento
secundario
libre
12.2
ORGANIZACIÓN
ACCESO
FICHEROS
sección
utiliza
término
organización
fichero
referirse
estructura
lógica
registros
determinados
forma
acceden
organización
física
fichero
al-
Gestión
ficheros
553
Gestión
directorios
Método
acceso
Gestión
bloques
Planificación
disco
Asignación
fichero
Estructura
fichero
Registros
Aspectos
relacionados
gestión
ficheros
Aspectos
relacionados
sistema
operativo
Bloques
físicos
buffers
memoria
principal
Bloques
físicos
almacenamiento
secundario
disco
Control
acceso
usuario
Programas
mandatos
usuario
Operación
nombre
fichero
Gestión
almacenamiento
libre
Funciones
manipulación
ficheros
Figura
12.2
Ciclo
instrucción
básico
12-Capitulo
12
16/5/05
17:07
Página
553macenamiento
secundario
depende
estrategia
bloques
asignación
ficheros
temas
tra-
tados
posteriormente
capítulo
escoger
organización
ficheros
importantes
criterios
Tiempo
acceso
corto
Facilidad
actualización
Economía
almacenamiento
Mantenimiento
sencillo
Fiabilidad
prioridad
relativa
criterios
dependerá
aplicaciones
utilizarán
fichero
ejemplo
fichero
procesar
lotes
acceso
registros
enton-
ces
acceso
rápido
único
registro
requisito
fichero
almacenado
CD-ROM
nun-
ca
actualizará
facilidad
actualización
aspecto
caso
criterios
entrar
conflicto
ejemplo
facilitar
economía
almacena-
miento
debería
mínima
redundancia
datos
redundancia
medi-
primaria
incrementar
velocidad
acceso
datos
ejemplo
constituye
índices
número
organizaciones
ficheros
alternativas
implementado
simplemente
propuesto
inmanejablemente
libro
dedicado
sistemas
ficheros
resumen
describen
organizaciones
fundamentales
mayoría
estructuras
utilizadas
sistemas
reales
cae
categorías
implementar
combinación
organizaciones
organizaciones
primeras
muestran
Figura
12.3
pila
fichero
secuencial
fichero
secuencial
indexado
fichero
indexado
fichero
acceso
directo
hash
Tabla
12.1
resume
aspectos
rendimiento
relativo
organizaciones
PILA
forma
complicada
organización
ficheros
denominar
pila
datos
alma-
cenan
orden
llegan
registro
formado
conjunto
datos
propósito
pila
simplemente
acumular
masa
datos
guardarlos
registros
dife-
rentes
campos
similares
campos
órdenes
campo
autodescrip-
tabla
emplea
notación
mayúscula
utilizada
caracterizar
complejidad
tiempo
algoritmos
ex-
plicación
notación
documento
sitio
web
libro
554
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
554tivo
incluyendo
nombre
campo
valor
longitud
campo
implícitamente
indicada
delimitadores
explícitamente
incluida
subcampo
conocida
defecto
tipo
campo
estructura
tipo
fichero
acceso
registros
búsqueda
exhaustiva
desea
encontrar
registro
contiene
campo
particular
valor
particular
necesario
examinar
registro
pila
encontrar
registro
de-
seado
terminar
recorrer
fichero
desea
encontrar
registros
contienen
campo
particular
contienen
campo
valor
particular
recorrer
fichero
entero
ficheros
pila
utilizan
datos
recogen
almacenan
procesamiento
datos
fáciles
organizar
tipo
ficheros
utiliza
espacio
adecuadamente
datos
varían
tamaño
estructura
perfectamente
adecuado
búsquedas
exhausti-
Gestión
ficheros
555
Fichero
apilado
pila
Fichero
indexado
secuencial
Fichero
indexado
Registros
longitud
variable
Conjunto
variable
campos
Orden
cronológico
Fichero
secuencial
Registros
longitud
fija
Conjunto
fijo
campos
orden
fijo
Orden
secuencial
basado
campo
clave
Fichero
principal
Fichero
desbordamiento
Niveles
indexados
Índice
exhaustivo
Índice
parcial
Fichero
primario
registros
longitud
variable
Indexado
Índice
exhaustivo
Figura
12.3
Organizaciones
comunes
ficheros
12-Capitulo
12
16/5/05
17:07
Página
555vas
fácil
actualizar
allá
usos
limitados
tipo
fichero
ina-
decuado
mayoría
aplicaciones
FICHERO
SECUENCIAL
forma
común
estructura
fichero
fichero
secuencial
tipo
ficheros
uti-
liza
formato
fijo
registros
registros
tamaño
compuestos
número
campos
longitud
fija
orden
específico
longitud
posición
campo
conocidas
necesita
almacenar
valores
campos
nom-
bre
longitud
campo
atributos
estructura
fichero
campo
particular
normalmente
campo
registro
denomina
campo
clave
campo
clave
identifica
forma
única
registro
valores
clave
registros
registros
almacenan
secuencia
clave
or-
den
alfabético
clave
texto
orden
numérico
clave
numérica
ficheros
secuenciales
utilizan
normalmente
aplicaciones
lotes
generalmente
óptimos
dichas
aplicaciones
implican
procesamiento
registros
ejem-
plo
aplicación
bancaria
nóminas
organización
fichero
secuencial
único
almacena
fácilmente
cinta
disco
aplicaciones
interactivas
suponen
consultas
actualizaciones
registros
individua-
fichero
secuencial
proporciona
pobre
rendimiento
accesos
requieren
búsqueda
556
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
12.1
Grados
rendimiento
organizaciones
ficheros
básicas
WIED87
Espacio
Actualización
Adquisición
Método
Atributos
amaño
registro
Único
Sub-de
fichero
Variable
Fijo
registro
conjunto
Exhaustivo
Pila
Secuencial
Indexado
secuencial
Indexado
BCCCABD
Hashed
FBBFBFE
Excelente
adecuado
propósito
O(r
O(o
Adecuado
O(r
log
Requiere
esfuerzo
extra
O(n
esfuerzo
extremo
O(r
razonable
propósito
O(n>1
tamaño
resultados
número
registros
desbordan
número
registros
fichero
12-Capitulo
12
16/5/05
17:07
Página
556el
fichero
encontrar
clave
fichero
entero
porción
fichero
memoria
principal
simultáneamente
utilizar
técnicas
búsqueda
eficientes
obstante
acceder
registro
fichero
secuencial
implica
procesamiento
retra-
sos
considerables
adiciones
ficheros
presentan
problemas
Típicamente
fichero
secuencial
almacena
orden
secuencial
simple
registros
bloques
organización
física
fichero
cinta
discos
encaja
directamente
organización
lógica
fi-
chero
caso
procedimiento
normal
colocar
registros
fichero
pila
separa-
do
denominado
fichero
registro
fichero
transacciones
Periódicamente
sistema
actualiza-
ción
cabo
mezcla
registro
fichero
maestro
producir
fichero
secuencia
claves
correcta
alternativa
organizar
fichero
secuencial
físicamente
lista
enlazada
registros
almacenan
bloque
físico
bloque
disco
contiene
puntero
si-
guiente
bloque
inserción
registros
implica
manipulación
punteros
re-
registros
ocupen
posición
bloque
físico
específica
obtie-
nen
ventajas
cambio
incrementar
procesamiento
sobrecarga
FICHERO
SECUENCIAL
INDEXADO
técnica
popular
eliminar
desventajas
fichero
secuencial
utilizar
ficheros
se-
cuenciales
indexados
fichero
secuencial
indexado
mantiene
características
clave
fichero
secuencial
registros
organizan
secuencia
basándose
campo
clave
características
añaden
índice
fichero
soporte
acceso
aleatorio
fichero
desbordamiento
índice
proporciona
capacidad
búsqueda
alcanzar
rápidamente
vecindad
registro
deseado
fichero
desbordamiento
similar
fichero
registro
utilizado
fichero
secuen-
cial
integra
forma
registro
fichero
desbordamiento
localiza
puntero
registro
predecesor
estructura
secuencial
indexada
sencilla
utiliza
único
nivel
indexación
índi-
ce
caso
fichero
secuencial
simple
registro
fichero
índice
formado
campos
campo
clave
campo
clave
fichero
principal
puntero
fi-
chero
principal
encontrar
campo
específico
busca
índice
contenga
valor
clave
preceda
valor
clave
deseado
búsqueda
continúa
fichero
principal
ubicación
indicada
puntero
comprobar
efectividad
técnica
considere
fichero
secuencial
millón
re-
gistros
Buscar
valor
clave
particular
requerirá
millón
accesos
registros
media
Supóngase
construye
índice
contiene
1000
entradas
claves
índice
distribuidas
uniformemente
fichero
principal
Encontrar
registro
llevará
media
500
accesos
fichero
índice
seguido
500
accesos
fichero
principal
longitud
búsqueda
media
reduce
500.000
1000
adiciones
fichero
gestionan
forma
registro
fichero
principal
contiene
campo
adicional
visible
aplicación
puntero
fichero
desbordamien-
to
inserta
registro
fichero
añade
fichero
desbordamiento
ac-
tualiza
registro
fichero
principal
inmediatamente
precede
registro
secuencia
ló-
gica
contener
puntero
registro
fichero
desbordamiento
registro
inmediatamente
precedente
fichero
desbordamiento
actualiza
puntero
registro
fichero
secuencial
fichero
secuencial
indexado
ocasio-
nalmente
mezclado
fichero
desbordamiento
batch
fichero
secuencial
indexado
reduce
enormemente
tiempo
requerido
acceder
único
registro
sacrificar
naturaleza
secuencial
fichero
procesar
fichero
entero
secuencial-
Gestión
ficheros
557
12-Capitulo
12
16/5/05
17:07
Página
557mente
registros
fichero
principal
procesan
secuencia
puntero
fichero
desbordamiento
continuación
accede
forma
continua
fichero
desborda-
miento
puntero
nulo
momento
continúa
accediendo
fichero
principal
lugar
proporcionar
eficiencia
acceso
utilizar
múltiples
niveles
indexación
continuación
menor
nivel
indexación
fichero
secuencial
crea
fichero
índice
nivel
fichero
construye
índice
nivel
10.000
entradas
construir
índice
nivel
100
entradas
bús-
queda
comienza
índice
nivel
longitud
media
50
accesos
encontrar
punto
entrada
índice
menor
nivel
índice
procesa
longitud
media
50
encontrar
punto
entrada
fichero
principal
busca
lon-
gitud
media
búsqueda
reducido
500.000
1000
1000
150
FICHERO
INDEXADO
fichero
secuencial
indexado
elimina
limitaciones
fichero
secuencial
procesa-
miento
efectivo
limita
búsquedas
basan
único
campo
fichero
ne-
cesario
buscar
atributo
campo
clave
ambas
formas
ficheros
secuen-
ciales
inadecuadas
aplicaciones
flexibilidad
deseable
lograr
flexibilidad
necesita
estructura
emplea
múltiples
índices
tipo
campo
sujeto
búsqueda
fichero
indexado
general
aban-
donan
conceptos
secuencialidad
clave
única
registros
acceden
ín-
dices
resultado
restricción
colocación
registros
puntero
índice
refiera
registro
emplear
registros
longitud
variable
utilizan
tipos
índice
índice
exhaustivo
contiene
entrada
registro
fi-
chero
principal
facilitar
búsqueda
índice
organizado
fichero
secuen-
cial
índice
parcial
contiene
entradas
registros
campo
interés
registros
longitud
variable
registros
contendrán
campos
añade
re-
gistro
fichero
principal
ficheros
índices
actualizarse
ficheros
índices
utilizan
frecuentemente
aplicaciones
temporización
in-
formación
crítica
datos
procesan
exhaustivamente
Ejemplos
tipo
aplicación
sistemas
reservas
aerolíneas
sistemas
control
inventario
FICHERO
ACCESO
DIRECTO
HASH
fichero
acceso
directo
hash
explota
capacidad
encontrada
discos
acceder
direc-
tamente
bloque
dirección
conocida
ficheros
secuenciales
se-
cuenciales
indexados
requiere
clave
registro
tipo
ficheros
concepto
ordenación
secuencial
fichero
directo
función
hash
valor
clave
función
Apéndice
8A.
Figura
8.27b
muestra
tipo
organización
hash
fichero
desborda-
miento
utiliza
normalmente
fichero
hash
ficheros
directos
utilizan
frecuentemente
requiere
acceso
rápido
re-
gistros
tamaño
fijo
registros
acceden
Ejemplos
tipo
estructu-
ra
directorios
tablas
precios
inventarios
listas
nombres
558
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
55812.3
DIRECTORIOS
CONTENIDO
Asociado
sistema
gestión
ficheros
colección
ficheros
con-
cepto
directorio
directorio
contiene
información
ficheros
incluyendo
atributos
ubi-
cación
propiedad
información
especialmente
concierne
almacenamien-
to
gestiona
sistema
operativo
directorio
fichero
accesible
rutinas
gestión
ficheros
información
directorios
disponible
usuarios
aplicaciones
proporciona
generalmente
forma
indirecta
rutinas
sistema
Tabla
12.2
muestra
información
normalmente
utilizada
directorio
fichero
sistema
punto
vista
usuario
directorio
proporciona
proyección
nom-
bres
ficheros
conocidos
usuarios
aplicaciones
ficheros
en-
trada
fichero
incluye
nombre
fichero
Prácticamente
sistemas
tratan
tipos
ficheros
distintas
organizaciones
ficheros
información
proporciona
importante
categoría
información
fichero
almacenamiento
incluyendo
ubicación
tamaño
sistemas
compartidos
importante
proporcionar
información
utilice
controlar
acceso
ficheros
Típicamente
usuario
propietario
fichero
conceder
privilegios
acceso
usuarios
Finalmente
utiliza
información
gestionar
utilización
actual
fichero
registrar
historia
ESTRUCTURA
forma
información
Tabla
12.2
almacena
difiere
ampliamente
sis-
temas
información
almacenar
registro
cabecera
asociado
fichero
reduce
cantidad
almacenamiento
requerido
directorio
fácil
almacenar
directorio
directorio
memoria
principal
incrementar
velocidad
forma
sencilla
estructura
directorio
lista
entradas
fi-
chero
estructura
representar
fichero
secuencial
simple
nombre
fi-
chero
actuando
clave
sistemas
iniciales
monousuario
utilizado
técnica
técnica
inadecuada
múltiples
usuarios
comparten
sistema
único
usuario
ficheros
comprender
requisitos
estructura
fichero
útil
considerar
tipos
ope-
raciones
cabo
directorios
Buscar
usuario
aplicación
referencia
fichero
directorio
permitir
en-
contrar
entrada
correspondiente
fichero
Crear
fichero
crea
fichero
añadir
entrada
directorio
Borrar
fichero
borra
fichero
eliminar
entrada
directorio
Listar
directorio
solicitar
directorio
completo
porción
Ge-
neralmente
usuario
solicita
petición
resultado
obtiene
listado
ficheros
propietario
atributos
fichero
ejem-
plo
información
control
acceso
información
Actualizar
directorio
atributos
almacenan
directorio
cam-
bio
atributos
requiere
cambio
entrada
directorio
correspondiente
Gestión
ficheros
559
12-Capitulo
12
16/5/05
17:07
Página
559
abla
12.2
Elementos
información
directorio
Información
básica
Nombre
fichero
Nombre
escogido
creador
usuario
programa
único
directorio
específico
Tipo
fichero
ejemplo
texto
binario
módulo
carga
etc.
Organización
fichero
sistemas
soportan
organizaciones
Información
direccionamiento
Volumen
Indica
dispositivo
almacena
fichero
Dirección
inicial
Dirección
física
inicial
almacenamiento
secundario
ejemplo
cilindro
pista
número
bloque
disco
amaño
utilizado
Tamaño
actual
fichero
bytes
palabras
bloques
amaño
asignado
Tamaño
máximo
fichero
Información
control
acceso
Propietario
Usuario
control
fichero
propietario
conce-
der
denegar
acceso
usuarios
cambiar
privilegios
Información
acceso
versión
sencilla
elemento
incluye
nombre
usuario
clave
usuario
autorizado
Acciones
permitidas
Controla
lectura
escritura
ejecución
transmisión
red
Información
Fecha
creación
Fecha
fichero
coloca
directorio
Identidad
creador
Normalmente
necesariamente
propietario
actual
Fecha
acceso
lectura
Fecha
leyó
registro
Identidad
lector
Usuario
lectura
Fecha
acceso
modificación
Fecha
actualización
inserción
borrado
Identidad
modificador
Usuario
modificación
Fecha
copia
seguridad
Fecha
fichero
copiado
almacenamiento
actual
Información
actividad
actual
fichero
pro-
ceso
procesos
fichero
abierto
bloqueado
proceso
fichero
actualizado
memoria
principal
disco
lista
sencilla
adecuada
soporte
operaciones
Considérese
necesidades
único
usuario
usuarios
tipos
ficheros
incluyendo
ficheros
pro-
cesamiento
texto
gráficos
hojas
cálculo
etc.
usuario
gustar
ficheros
or-
ganizados
proyecto
tipo
forma
conveniente
directorio
lista
secuen-
cial
simple
proporciona
ayuda
organizar
ficheros
fuerza
usuarios
cuidado
utilizar
nombre
tipos
ficheros
problema
agrava
sistema
compartido
nombrado
único
convierte
problema
serio
difícil
conceder
por-
ciones
directorio
completo
usuarios
estructura
inherente
directorio
560
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
560Una
solución
resolver
problemas
pasar
esquema
niveles
caso
directorio
usuario
directorio
maestro
directorio
maestro
entrada
directorio
usuario
proporcionando
información
dirección
control
acceso
directorio
usuario
lista
simple
ficheros
usuario
implica
nombres
únicos
colección
ficheros
único
usuario
sis-
tema
ficheros
fácilmente
asegurar
restricciones
acceso
directorios
embar-
go
proporciona
ayuda
usuarios
estructurar
colección
ficheros
técnica
potente
flexible
universalmente
adoptada
utilizar
estructu-
ra
jerárquica
forma
árbol
Figura
12.4
técnica
directorio
maestro
directorio
directorios
usuario
directorios
usuario
subdirectorios
ficheros
entradas
cumple
niveles
nivel
directorio
formado
subdirectorios
ficheros
Falta
describir
organiza
directorio
subdirectorio
enfoque
sencillo
su-
puesto
almacenar
directorio
fichero
secuencial
directorios
contuvieran
número
entradas
dicha
organización
llevaría
tiempos
búsqueda
innecesariamente
largos
caso
preferible
estructura
hash
NOMBRADO
usuarios
necesitan
referenciar
fichero
nombre
simbólico
Claramente
fichero
sistema
nombre
único
referencias
ambi-
guas
inaceptable
obligar
usuarios
proporcionen
nombres
únicos
especial-
mente
sistema
compartido
directorio
estructurado
forma
árbol
minimiza
dificultad
asignar
nombres
únicos
fichero
sistema
localizar
siguiendo
camino
directorio
raíz
maestro
bajando
ramas
alcanzar
fichero
conjunto
nombres
directorios
finalizando
nombre
fichero
constituye
nombre
camino
fichero
ejemplo
Gestión
ficheros
561
Directorio
maestro
Subdirectorio
Fichero
Subdirectorio
Subdirectorio
Subdirectorio
Subdirectorio
Fichero
Fichero
Fichero
Figura
12.4
Directorio
estructurado
forma
árbol
12-Capitulo
12
16/5/05
17:07
Página
561el
fichero
esquina
inferior
izquierda
Figura
12.5
camino
/Usuario_B
Texto
Uni-
dad_A
ABC
barra
utiliza
delimitar
nombres
secuencia
nombre
directorio
maestro
implícito
nombres
comienzan
directorio
Obsérvese
per-
fectamente
aceptable
ficheros
nombre
ficheros
tengan
nombres
camino
únicos
equivale
nombre
fichero
utilizar
directorios
ejemplo
fichero
sistema
nombre
ABC
cuyo
nombre
completo
/Usuario_B
Dibujo
ABC
nombres
camino
facilitan
selección
nombres
fichero
complicado
usuario
escribir
camino
completo
referencia
fiche-
ro
Normalmente
usuario
interactivo
proceso
asociado
directorio
actual
suele
denominar
directorio
trabajo
ficheros
referenciar
forma
relativa
direc-
562
Sistemas
operativos
Aspectos
internos
principios
diseño
Sistema
Directorio
maestro
Usuario_A
Usuario_B
Usuario_C
Directorio
Usuario_C
Directorio
Usuario_A"Directorio
Usuario_B
Dibujo
Texto
Directorio
Usuario_A
ABC
Directorio
Texto
Unidad_A
Directorio
Dibujo
ABC
Fichero
ABC
Ruta
acceso
/Usuario_B
Texto
Unidad_A
ABC
Ruta
acceso
/Usuario_B
Dibujo
ABC
Fichero
ABC
Figura
12.5
Ejemplo
directorio
estructurado
forma
árbol
12-Capitulo
12
16/5/05
17:07
Página
562torio
trabajo
ejemplo
directorio
trabajo
usuario
Texto
nombre
Unidad_A
ABC
suficiente
identificar
fichero
esquina
inferior
izquierda
Figura
12.5
usuario
interactivo
conecta
crea
proceso
directorio
trabajo
omisión
directorio
inicial
usuario
ejecución
usuario
navegar
abajo
árbol
cambiarse
directorio
trabajo
12.4
COMPARTICIÓN
FICHEROS
sistema
multiusuario
requisito
permitir
ficheros
compartan
usuarios
aspectos
relacionados
derechos
acceso
gestión
acceso
si-
multáneo
DERECHOS
ACCESO
sistema
ficheros
debería
proporcionar
herramienta
flexible
permitir
compartición
ficheros
extensiva
usuarios
sistema
ficheros
debería
proporcionar
opciones
forma
acceso
fichero
particular
controlar
Típicamente
usuarios
gru-
pos
usuarios
concede
derechos
acceso
fichero
utilizado
amplio
ran-
go
derechos
acceso
lista
representativa
derechos
acceso
asig-
nan
usuario
particular
determinado
fichero
usuario
existencia
fichero
acceder
forzar
restricción
usuario
permiso
lectura
di-
rectorio
incluye
fichero
Conocimiento
usuario
determinar
fichero
propietario
usuario
capaz
solicitar
propietario
derechos
acceso
adicionales
Ejecución
usuario
cargar
ejecutar
programa
copiarlo
programas
propietarios
utilizan
normalmente
restricciones
Lectura
usuario
leer
fichero
propósito
incluyendo
copia
ejecu-
ción
sistemas
capaces
forzar
distinción
copiar
caso
usuario
contenido
fichero
copia
Adición
usuario
añadir
datos
fichero
frecuentemente
modificar
borrar
cualquiera
contenidos
fichero
derecho
útil
recolec-
tar
datos
fuentes
Actualización
usuario
modificar
borrar
añadir
datos
fichero
normalmente
incluye
escribir
fichero
inicio
reescribirlo
completa
parcialmente
borrar
porción
datos
sistemas
diferencian
distintos
grados
actualización
Cambio
protección
usuario
cambiar
derechos
acceso
otorgados
usuarios
Normalmente
propietario
fichero
goza
derecho
siste-
propietario
extender
derecho
prevenir
abuso
meca-
nismo
propietario
fichero
normalmente
especificar
derechos
cambiar
usuario
tipo
permiso
Borrado
usuario
borrar
fichero
sistema
ficheros
derechos
considerar
jerarquía
derechos
conte-
niendo
preceden
usuario
particular
permiso
actualización
Gestión
ficheros
563
12-Capitulo
12
16/5/05
17:07
Página
563para
fichero
concreto
usuario
siguientes
derechos
conocimiento
ejecu-
ción
lectura
adición
usuario
propietario
determinado
fichero
normalmente
persona
inicialmente
creó
fichero
propietario
derechos
acceso
listados
previa-
mente
conceder
permisos
usuarios
proporcionar
accesos
dis-
tintas
clases
usuarios
Usuario
específico
Usuarios
individuales
designan
identificador
usuario
Grupos
usuarios
conjunto
usuarios
definen
individualmente
sistema
forma
gestionar
membresía
grupos
usuarios
usuarios
acceso
sistema
Dichos
ficheros
consideran
fi-
cheros
públicos
ACCESO
SIMULTÁNEO
garantiza
acceso
adición
actualización
fichero
usuario
sistema
operativo
sistema
gestión
ficheros
forzar
disciplina
técnica
fuerza
bruta
consiste
permitir
usuario
bloquear
fichero
completo
actualizar
control
grano
fino
implica
bloqueo
registros
individuales
actualización
Esencialmente
problema
lectores
escritores
discutido
Capítulo
tratar
aspectos
exclusión
mutua
interbloqueos
hora
diseñar
capacidades
acceso
compartidas
12.5
BLOQUES
REGISTROS
indica
Figura
12.2
registros
unidades
lógicas
acceso
fichero
es-
tructurado
bloques
unidades
almacenamiento
secundario
registros
organizar
bloques
aspectos
considerar
bloques
deberían
longitud
fija
varia-
ble
mayoría
sistemas
bloques
longitud
fija
simplifica
asig-
nación
buffers
memoria
principal
organización
bloques
almacenamiento
secunda-
rio
continuación
debería
tamaño
relativo
bloque
comparado
tamaño
registro
compromiso
bloque
registros
trans-
ferirán
operación
S.
procesa
fichero
forma
secuencial
supone
ventaja
reduce
número
operaciones
utilizando
bloques
mayores
tan-
to
acelerando
procesamiento
registros
acceden
forma
aleatoria
observa
proximidad
referencias
utilizar
bloques
supone
trans-
ferencias
innecesarias
registros
utilizados
combina
frecuencia
ope-
raciones
secuenciales
potencialidad
proximidad
referencias
tiempo
transferencia
reduce
utilizando
bloques
mayores
preocupación
viene
bloques
requieren
buffers
mayores
gestión
buf-
fers
difícil
tamaño
bloque
utilizar
métodos
564
Sistemas
operativos
Aspectos
internos
principios
diseño
contraposición
fichero
ristra
bytes
sistema
ficheros
UNIX
12-Capitulo
12
16/5/05
17:07
Página
564•
Bloques
fijos
utilizan
registros
longitud
fija
almacenan
bloque
número
integral
registros
espacio
utilizado
bloque
deno-
mina
fragmentación
interna
Bloques
expandidos
longitud
variable
utilizan
registros
longitud
variable
empaquetan
bloques
dejar
espacio
utilizado
registros
ex-
pandirse
bloques
continuación
indicada
puntero
bloque
sucesor
Bloques
expandidos
longitud
variable
utilizan
registros
longitud
variable
emplea
expansión
espacio
malgastado
mayoría
bloques
in-
capacidad
utilizar
resto
bloque
registro
espacio
utilizado
restante
Figura
12.6
ilustra
métodos
asumiendo
ficheros
almacenan
bloques
se-
cuenciales
disco
efecto
cambiaría
utilizara
esquema
asignación
fiche-
ros
véase
Sección
12.6
Gestión
ficheros
565
Pista
Pista
R1
R2
R3
R4
R5
R6
Bloques
fijos
Bloques
variables
extendido
R7
R8
Pista
Pista
R1
R2
R3
R5
R6
R6
R4R4
R7
R8
R8
R9
R9
R9
R10
R10
R11
R12
R13
Bloques
variables
extendido
Pista
Pista
R1
R2
R3
R5
R6
Datos
R4
R7
Huecos
diseño
hardware
Malgasto
ajuste
bloque
tamaño
Malgasto
ajuste
registro
tamaño
bloque
Malgasto
restricciones
tamaño
bloque
tamaño
registro
fijo
Figura
12.6
Métodos
asignación
registros
bloques
WIED87
12-Capitulo
12
16/5/05
17:07
Página
565Utilizar
bloques
fijos
común
ficheros
secuenciales
registros
longitud
fija
bloques
expandidos
longitud
variable
eficientes
almacenamiento
limitan
tamaño
registros
técnica
difícil
implementar
registros
ex-
panden
bloques
requieren
operaciones
ficheros
difíciles
actualizar
te-
ner
organización
bloques
expandidos
longitud
variable
implican
espacio
mal-
gastado
limitan
tamaño
registro
tamaño
bloque
técnica
bloques
registros
utilizada
interaccionar
hardware
memoria
vir-
tual
utilizara
entorno
memoria
virtual
deseable
utilizar
página
uni-
dad
básica
transferencia
páginas
generalmente
pequeñas
forma
im-
practicable
tratar
página
bloque
bloques
expandidos
Análogamente
sistemas
combinan
múltiples
páginas
crear
bloque
propósitos
S.
técnica
utiliza
ficheros
VSAM
mainframes
IBM
12.6
GESTIÓN
ALMACENAMIENTO
SECUNDARIO
almacenamiento
secundario
fichero
compuesto
colección
bloques
sistema
operativo
sistema
gestión
ficheros
responsable
asignar
bloques
ficheros
su-
pone
aspectos
relacionados
gestión
asignar
espacio
almacenamiento
secundario
ficheros
necesario
guardar
traza
espacio
disponible
asignación
Veremos
tareas
relacionadas
técnica
seleccionada
asignación
ficheros
influir
técnica
seleccionada
gestión
espacio
libre
verá
interacción
estructura
ficheros
políticas
asignación
comenzará
sección
analizando
alternativas
asignación
ficheros
único
disco
continuación
describen
aspectos
relacionados
gestión
espacio
libre
finalmente
dis-
cutirá
fiabilidad
ASIGNACIÓN
FICHEROS
aspectos
involucrados
asignación
ficheros
crea
fichero
asigna
espacio
máximo
requerido
fichero
espacio
asigna
fichero
unidades
contiguas
denomina
por-
ción
tamaño
porción
único
bloque
fichero
completo
ta-
maño
porción
debería
utilizarse
asignación
ficheros
clase
estructura
datos
tabla
utiliza
guardar
traza
porciones
asigna-
das
fichero
ejemplo
dicha
estructura
tabla
asignación
ficheros
File
Allocation
Table
FAT
encontrado
sistemas
examinarán
aspectos
continuación
Preasignación
frente
asignación
dinámica
política
preasignación
requiere
tamaño
máximo
fichero
declarado
tiempo
creación
fichero
casos
tales
compilaciones
programas
producción
ficheros
datos
resumen
transferencia
fichero
sistema
red
comuni-
566
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
566cación
estimar
valor
forma
fiable
aplicaciones
difícil
imposible
estimar
fiablemente
tamaño
máximo
potencial
fichero
dichos
casos
usuarios
programadores
aplicaciones
tenderían
sobrestimar
tamaño
fichero
forma
queden
espacio
claramente
supone
malgasto
punto
vista
asigna-
ción
espacio
almacenamiento
ventajas
gestión
dinámica
asigna
espacio
fichero
porciones
necesite
amaño
porción
aspecto
listado
tamaño
porción
asignado
fichero
extremo
asignar
porción
suficientemente
contener
fichero
completo
extremo
espacio
disco
asignar
bloque
escoger
tamaño
porción
existir
compromiso
eficiencia
punto
vista
único
fichero
efi-
ciencia
sistema
completo
WIED87
lista
aspectos
considerar
compromiso
contigüidad
espacio
incrementa
rendimiento
especialmente
operaciones
Ob-
tener_Siguiente
transacciones
ejecutándose
sistema
operativo
orientado
transacciones
Utilizar
número
porciones
pequeñas
incrementa
tamaño
tablas
necesarias
gestionar
información
asignación
Utilizar
porciones
tamaño
fijo
ejemplo
bloques
simplifica
reasignación
espacio
Utilizar
porciones
tamaño
variable
pequeñas
tamaño
fijo
minimiza
espacio
malgas-
tado
sobreasignación
elementos
interaccionan
considerar
conjuntamente
alternativas
principales
Porciones
variables
contiguas
alternativa
proporciona
rendimiento
tamaño
variable
evita
malgastar
espacio
tablas
asignación
ficheros
peque-
ñas
espacio
difícil
reutilizar
Bloques
Pequeñas
porciones
fijas
proporcionan
flexibilidad
requerir
tablas
estructuras
complejas
asignación
contigüidad
abandonada
meta
primaria
bloques
asignan
necesite
opción
compatible
preasignación
asignación
dinámica
caso
porciones
variables
contiguas
fichero
preasigna
grupo
bloques
contiguos
elimi-
na
necesidad
tabla
asignación
ficheros
requiere
puntero
pri-
mer
bloque
número
bloques
asignados
caso
bloques
porciones
reque-
ridas
asignan
significa
tabla
asignación
ficheros
fichero
tamaño
fijo
porciones
tamaño
variable
necesario
preocuparse
fragmentación
espacio
li-
bre
aspecto
trató
memoria
principal
particionada
Capítulo
siguientes
estrategias
posibles
ajuste
Escoger
grupo
contiguo
utilizado
bloques
tamaño
suficiente
lista
bloques
libres
ajuste
Escoger
grupo
pequeño
utilizado
suficiente
tamaño
Gestión
ficheros
567
12-Capitulo
12
16/5/05
17:07
Página
567•
Ajuste
Escoger
grupo
utilizado
tamaño
suficiente
cercano
asignación
previa
fichero
incremente
proximidad
estrategia
dificultad
modelar
estrategias
alternativas
factores
interaccionen
incluyendo
tipos
ficheros
patrones
acceso
ficheros
grado
multiprogramación
factores
rendimiento
sistema
caching
disco
planifica-
ción
disco
Métodos
asignación
ficheros
Habiendo
analizado
aspectos
preasignación
frente
asignación
dinámica
tamaño
porciones
posición
considerar
métodos
específicos
asignación
ficheros
métodos
común
contiguo
encadenado
indexado
Tabla
12.3
resume
características
método
abla
12.3
Métodos
asignación
ficheros
Contiguos
Encadenado
Indexado
Preasignación
Necesaria
Porciones
tamaño
Variable
Bloques
fijos
Bloques
fijos
Variable
fijo
variable
amaño
porción
Pequeño
Pequeño
Frecuencia
Pequeña
alta
Alta
Baja
asignación
Tiempo
asignar
Corto
amaño
tabla
entrada
entrada
asignación
ficheros
asignación
contigua
asigna
único
conjunto
contiguo
bloques
tiempo
crea-
ción
ficheros
Figura
12.7
estrategia
preasignación
utiliza
porcio-
nes
tamaño
variable
tabla
asignación
ficheros
necesita
entrada
fiche-
ro
mostrando
bloque
inicial
longitud
fichero
asignación
contigua
punto
vista
fichero
secuencial
individual
Múltiples
bloques
leer
mejorar
rendimiento
procesamiento
secuencial
fácil
obtener
único
blo-
ejemplo
fichero
comienza
bloque
acceder
bloque
-ésimo
fi-
chero
ubicación
almacenamiento
secundario
simplemente
asignación
contigua
presenta
problemas
Existirá
fragmentación
externa
difícil
encontrar
bloques
con-
tiguos
espacio
suficiente
longitud
necesario
cabo
algorit-
mo
compactación
liberar
espacio
adicional
disco
Figura
12.8
preasig-
nación
necesario
declarar
tamaño
fichero
tiempo
creación
problemas
mencionados
anteriormente
extremo
opuesto
asignación
contigua
asignación
encadenada
Figura
12.9
Típicamente
asignación
realiza
nivel
bloques
individuales
bloque
contiene
puntero
bloque
cadena
tabla
asignación
ficheros
necesita
entrada
fichero
mostrando
bloque
inicial
longitud
fichero
568
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
568la
preasignación
común
asignar
bloques
necesita
selección
bloques
cuestión
sencilla
bloque
libre
añadir
cadena
fragmentación
externa
preocuparse
necesita
bloque
tipo
organización
física
adapta
ficheros
secuenciales
procesan
secuencial-
mente
Seleccionar
bloque
individual
fichero
requiere
seguir
cadena
alcanzar
bloque
deseado
consecuencia
encadenamiento
describe
principio
proxi-
midad
necesario
traer
bloques
fichero
procesamiento
secuencial
requiere
serie
accesos
partes
disco
efecto
Gestión
ficheros
569
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
Fichero
Fichero
Fichero
Fichero
Fichero
18
30
26
Tabla
asignación
ficheros
Fichero
Nombre
fichero
Bloque
inicial
LongitudFichero
Fichero
Fichero
Fichero
Figura
12.7
Asignación
fichero
contiguo
Fichero
Fichero
File
Fichero
Fichero
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
Fichero
Fichero
Fichero
Fichero
Fichero
19
16
Tabla
asignación
ficheros
Nombre
fichero
Bloque
inicial
Longitud
Figura
12.8
Asignación
fichero
contiguo
compactación
12-Capitulo
12
16/5/05
17:07
Página
569significativo
sistema
monousuario
preocupante
caso
siste-
ma
compartido
resolver
problema
sistemas
consolidan
ficheros
periódicamente
Figura
12.10
asignación
indexada
resuelve
problemas
asignación
contigua
encade-
caso
tabla
asignación
ficheros
contiene
índice
separado
nivel
fichero
índice
entrada
porción
asignada
fichero
Típicamente
índi-
ces
fichero
almacenan
físicamente
tabla
asignación
ficheros
contrario
índice
ficheros
fichero
guarda
bloque
separado
entrada
fi-
chero
tabla
asignación
ficheros
apunta
bloque
asignación
realizarse
me-
570
Sistemas
operativos
Aspectos
internos
principios
diseño
Tabla
asignación
ficheros
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
Fichero
Nombre
fichero
Bloque
inicial
Longitud
Fichero
Figura
12.9
Asignación
encadenada
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
5Archivo
Nombre
fichero
Bloque
inicial
Longitud
Tabla
asignación
ficheros
Archivo
Figura
12.10
Asignación
encadenada
consolidación
12-Capitulo
12
16/5/05
17:07
Página
570diante
bloques
tamaño
fijo
Figura
12.11
porciones
tamaño
variable
Figura
12.12
asig-
nación
bloques
elimina
fragmentación
externa
asignación
porciones
ta-
maño
variable
mejora
proximidad
caso
consolidación
ficheros
reali-
zar
consolidación
ficheros
reduce
tamaño
índice
caso
porciones
tamaño
variable
caso
asignación
bloques
asignación
indexada
soporte
acceso
secuencial
directo
ficheros
forma
popular
asignación
ficheros
Gestión
ficheros
571
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
24
14
28
Tabla
asignación
ficheros
Archivo
Nombre
fichero
Bloque
indexadoArchivo
Figura
12.11
Asignación
indexada
porciones
bloques
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
28
14
Archivo
Nombre
fichero
Bloque
indexado
24
Tabla
asignación
ficheros
Bloque
inicial
Longitud
Archivo
Figura
12.12
Asignación
indexada
porciones
tamaño
variable
12-Capitulo
12
16/5/05
17:07
Página
571GESTIÓN
ESPACIO
LIBRE
forma
asigna
espacio
ficheros
gestionar
espacio
actualmente
asignado
fichero
cabo
cualquiera
técnicas
asignación
ficheros
descritas
previamente
necesario
bloques
disponibles
disco
necesita
tabla
asignación
disco
adición
tabla
asignación
ficheros
discutirán
técnicas
implementado
ablas
bits
método
utiliza
vector
formado
bit
bloque
disco
entrada
corresponde
bloque
libre
corresponde
bloque
ejemplo
compo-
sición
disco
Figura
12.7
necesita
vector
longitud
35
contenido
00111000011111000011111111111011000
tabla
bits
ventaja
relativamente
fácil
encontrar
bloque
libre
gru-
po
contiguo
bloques
libres
tabla
bits
trabaja
cualquiera
métodos
asignación
ficheros
descrito
ventaja
estructura
pequeña
posi-
ble
cantidad
memoria
bytes
requerida
mapa
bits
bloques
Tamaño
disco
bytes
tamaño
bloque
sistema
ficheros
disco
16
Gbytes
bloques
512
bits
tabla
bits
ocupa
Mbytes
almacenar
tabla
bits
Mbytes
memoria
principal
tabla
bits
acceder
necesidad
acceder
disco
tamaños
memoria
Mbytes
cantidad
considerable
memoria
principal
dedicar
única
fun-
ción
alternativa
tabla
bits
disco
tabla
bits
Mbytes
requeriría
al-
rededor
8000
bloques
disco
búsqueda
cantidad
espacio
disco
necesita
bloque
forma
tabla
bits
residente
memoria
indicada
tabla
bits
memoria
principal
búsqueda
exhaustiva
tabla
ralentizar
rendimiento
sistema
ficheros
grado
inaceptable
especial-
mente
disco
lleno
bloques
libres
restantes
forma
análoga
mayoría
sistemas
ficheros
utilizan
tablas
bits
mantienen
estructuras
datos
auxi-
liares
resumen
contenidos
subrangos
tabla
bits
ejemplo
tabla
podía
divi-
dir
lógicamente
subrangos
tamaño
tabla
resumen
incluir
su-
brango
número
bloques
libres
número
bloques
libres
contiguos
tamaño
máximo
sistema
ficheros
necesita
bloques
contiguos
analizar
tabla
resumen
encontrar
subrango
apropiado
buscar
subrango
Porciones
libres
encadenadas
porciones
libres
encadenar
utilizando
puntero
valor
longitud
porción
li-
bre
método
sobrecarga
espacio
insignificante
necesita
tabla
asig-
nación
disco
simplemente
puntero
comienzo
cadena
longitud
por-
ción
método
apropiado
métodos
asignación
ficheros
asigna
572
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
572bloque
simplemente
escoger
bloque
libre
cabeza
cadena
ajustar
pri-
mer
puntero
valor
longitud
asignación
porción
longitud
variable
utilizar
algoritmo
ajuste
cargan
cabeceras
porciones
determinar
porción
libre
apropiada
cadena
ajustan
puntero
valores
longitud
método
problemas
disco
quedará
frag-
mentado
porciones
longitud
único
bloque
obsérvese
asigne
bloque
necesita
leer
bloque
recuperar
puntero
bloque
libre
escribir
datos
bloque
necesitan
asignar
bloques
individua-
operación
ficheros
ralentiza
medida
creación
ficheros
Similarmente
borrar
ficheros
altamente
fragmentados
tarea
consume
tiempo
Indexación
técnica
indexación
espacio
libre
fichero
utiliza
tabla
índices
describió
asignación
ficheros
motivos
eficiencia
índice
debería
utilizar
base
porciones
tamaño
variable
lugar
bloques
entrada
tabla
porción
libre
disco
técnica
proporciona
soporte
eficiente
métodos
asig-
nación
ficheros
Lista
bloques
libres
método
bloque
asigna
número
secuencialmente
lista
números
bloques
libres
mantiene
porción
reservada
disco
Dependiendo
tamaño
disco
necesitarán
24
32
bits
almacenar
único
número
bloque
forma
ta-
maño
lista
bloques
libres
24
32
tamaño
correspondiente
tabla
bits
almacenarse
disco
memoria
principal
método
satisfac-
torio
Considérense
siguientes
puntos
espacio
disco
dedicado
lista
bloques
libres
menor
1%
espacio
disco
utiliza
número
bloque
32
bits
penalización
espacio
bytes
bloque
512
bytes
lista
bloques
libres
almacenarla
memoria
principal
técnicas
efectivas
almacenar
pequeña
lista
memoria
principal
lista
tratar
pila
Apéndice
1B
miles
elementos
pila
residentes
memoria
principal
asigna
bloque
saca
pila
memoria
principal
Similarmente
desasigna
bloque
coloca
pila
porción
pila
memoria
llena
vacía
transferencia
disco
memoria
principal
técnica
acceso
rápido
mayoría
ocasiones
lista
tratar
cola
FIFO
miles
entradas
cabeza
cola
memoria
principal
asigna
bloque
tomando
entrada
cabeza
cola
desasigna
añadiéndolo
cola
transferencia
disco
memoria
principal
porción
memoria
cabeza
cola
vacía
porción
memoria
cola
llena
cualquiera
estrategias
listadas
punto
precedente
pila
cola
FIFO
hilo
se-
gundo
plano
ordenar
lentamente
lista
memoria
listas
facilitar
asignación
contigua
Gestión
ficheros
573
12-Capitulo
12
16/5/05
17:07
Página
573FIABILIDAD
Considérese
escenario
usuario
solicita
asignación
ficheros
añadir
fichero
existente
petición
concede
disco
tablas
asignación
ficheros
actualizan
me-
moria
principal
disco
sistema
falla
consecuentemente
reinicia
usuario
solicita
asignación
ficheros
asigna
espacio
disco
solapa
últi-
ma
asignación
usuario
A.
usuario
accede
porción
solapada
referencia
almacena
fichero
A.
dificultad
surge
sistema
mantiene
copia
tabla
asigna-
ción
disco
tabla
asignación
ficheros
memoria
principal
motivos
eficiencia
prevenir
tipo
error
solicita
asignación
ficheros
cabo
siguientes
pasos
Bloquear
tabla
asignación
disco
disco
previene
usuario
causar
alte-
raciones
tabla
asignación
complete
Buscar
espacio
disponible
tabla
asignación
disco
supone
copia
tabla
asignación
disco
guarda
memoria
principal
traerse
disco
Asignar
espacio
actualizar
tabla
asignación
disco
actualizar
disco
Actualizar
disco
supone
escribir
tabla
asignación
disco
disco
asignación
disco
en-
cadenado
supone
actualizar
punteros
disco
Actualizar
tabla
asignación
disco
actualizar
disco
Desbloquear
tabla
asignación
disco
técnica
evitará
errores
asignan
frecuentemente
pequeñas
porciones
impacto
rendimiento
substancial
reducir
sobrecarga
utilizar
es-
quema
asignación
lotes
almacenamiento
caso
obtiene
lote
porciones
libres
disco
asignación
correspondientes
porciones
disco
marcan
asigna-
ción
utilizando
lote
realizarse
memoria
principal
finalice
lote
tabla
asignación
disco
actualiza
disco
adquirir
lote
ocurriera
fallo
sistema
porciones
disco
marcados
limpiarse
forma
puedan
reasignar
técnica
limpieza
dependerá
características
particulares
sistema
ficheros
12.7
GESTIÓN
FICHEROS
UNIX
sistema
ficheros
UNIX
distinguir
tipos
ficheros
Regulares
ordinarios
Contiene
datos
arbitrarios
cero
bloques
datos
fiche-
ros
regulares
contienen
información
introducida
usuario
aplicación
utilidad
sistema
sistema
ficheros
impone
estructura
interna
fichero
regular
ristra
bytes
574
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
574•
Directorios
Contiene
lista
nombres
ficheros
punteros
nodos-i
asociados
no-
índice
descritos
posteriormente
directorios
organizan
jerárquicamente
Figura
12.4
directorios
realmente
ficheros
ordinarios
privilegios
protección
escri-
tura
especiales
forma
sistema
ficheros
escribirlos
programas
usuario
acceso
lectura
Especiales
contienen
datos
proporcionan
mecanismo
asociar
dispositi-
vos
físicos
nombres
ficheros
utilizan
nombres
ficheros
acceder
dispositi-
vos
periféricos
tales
terminales
impresoras
dispositivo
asocia
fichero
especial
discutió
Sección
11.8
Tuberías
nombre
discutió
Sección
6.7
tubería
utilidad
co-
municación
procesos
tubería
guarda
buffer
datos
entrada
forma
proceso
lea
salida
tubería
reciba
datos
leyera
cola
FIFO
Enlaces
esencia
enlace
nombre
alternativo
fichero
fichero
existente
Enlaces
simbólicos
fichero
datos
contiene
nombre
fichero
enlaza
sección
gestión
ficheros
ordinarios
corresponden
mayoría
sistemas
ficheros
NODOS-I
tipos
ficheros
UNIX
administran
sistema
operativo
nodos-i
nodo-i
nodo
índice
estructura
control
contiene
información
clave
necesaria
fichero
particular
sistema
operativo
nombres
ficheros
asociar
úni-
co
nodo-i
nodo-i
activo
asocia
exactamente
fichero
fichero
controlado
exactamente
nodo-i
atributos
fichero
permisos
información
control
almacenan
nodo-i
Tabla
12.4
lista
atributos
ficheros
almacenados
nodo-i
implementación
UNIX
típica
disco
tabla
nodos-i
lista
nodos-i
contiene
nodos-i
fi-
cheros
sistema
ficheros
abre
fichero
trae
nodo-i
memoria
principal
almacena
tabla
nodos-i
residente
memoria
ASIGNACIÓN
FICHEROS
asignación
ficheros
realiza
nivel
bloque
asignación
dinámica
necesita
lugar
utilizar
preasignación
bloques
fichero
disco
nece-
sariamente
contiguos
utiliza
método
indexado
guardar
traza
fichero
índice
almacenado
nodo-i
fichero
nodo-i
incluye
39
bytes
información
dirección
organizan
trece
direcciones
bytes
punteros
primeras
10
direcciones
apuntan
10
bloques
datos
fichero
fichero
10
bloques
utilizan
niveles
indirección
indica
continuación
dirección
undécima
nodo-i
apunta
bloque
disco
contiene
porción
índice
conoce
bloque
indirecto
simple
bloque
contiene
punteros
siguien-
tes
bloques
fichero
Gestión
ficheros
575
12-Capitulo
12
16/5/05
17:07
Página
575Si
fichero
contiene
bloques
duodécima
dirección
nodo-i
apunta
bloque
indirec-
to
doble
bloque
contiene
lista
direcciones
bloques
indirectos
simples
adicionales
bloques
indirectos
simples
contiene
punteros
bloques
ficheros
fichero
contiene
bloques
dirección
decimotercera
nodo-i
apunta
bloque
indirecto
triple
constituye
tercer
nivel
indexación
bloque
apunta
bloques
in-
directos
dobles
adicionales
muestra
Figura
12.13
entrada
nodo-i
contiene
información
so-
bre
fichero
directorio
Tabla
12.4
entradas
restantes
direcciones
recién
descritas
número
bloques
datos
fichero
depende
capacidad
bloques
tamaño
fijo
sistema
UNIX
System
longitud
bloque
Kbyte
bloque
con-
256
direcciones
bloque
tamaño
máximo
fichero
es-
quema
cerca
16
Gbytes
Tabla
12.5
esquema
ventajas
nodo-i
tamaño
fijo
relativamente
pequeño
almacenar
me-
moria
principal
periodos
largos
576
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
12.4
Información
nodo-i
UNIX
residente
disco
fichero
Espacio
16
bits
almacena
permisos
acceso
ejecución
asociados
fichero
12-14
Tipo
fichero
regular
directorio
especial
caracteres
bloques
tubería
FIFO
9-1
Flags
ejecución
Permiso
lectura
propietario
Permiso
escritura
propietario
Permiso
ejecución
propietario
Permiso
lectura
grupo
propietario
Permiso
escritura
grupo
propietario
Permiso
ejecución
grupo
propietario
Permiso
lectura
resto
usuarios
Permiso
escritura
resto
usuarios
Permiso
ejecución
resto
usuarios
Número
enlaces
Número
directorios
referencian
nodo-i
Identificación
propietario
Propietario
individual
fichero
Identificación
grupo
propietario
Grupo
propietario
asociado
fichero
amaño
fichero
Número
bytes
fichero
Direcciones
fichero
39
bytes
información
direcciones
acceso
Fecha
acceso
fichero
modificación
Fecha
modificación
fichero
Nodo-i
modificado
Fecha
modificación
nodo-i
12-Capitulo
12
16/5/05
17:07
Página
576Gestión
ficheros
577
Acceso
directo(0
Información
fichero
Indirecto
simple
Indirecto
doble
Indirecto
triple
Nodo-i
Bloques
disco
Acceso
directo(1
Acceso
directo(2
Acceso
directo(3
Acceso
directo(4
Acceso
directo(5
Acceso
directo(6
Acceso
directo(7
Acceso
directo(8
Acceso
directo(9
Figura
12.13
Disposición
fichero
UNIX
disco
abla
12.5
Capacidad
fichero
UNIX
Nivel
Número
bloques
Número
bytes
Directo
10
10
Simple
indirecto
256
256
Doble
indirecto
256
256
65
65
riple
indirecto
256
65
16
16
12-Capitulo
12
16/5/05
17:07
Página
5772
ficheros
pequeños
acceder
indirección
reduciendo
procesamiento
tiempo
acceso
disco
tamaño
máximo
teórico
fichero
suficientemente
satisfacer
práctica-
mente
aplicaciones
DIRECTORIOS
directorios
estructuran
árbol
jerárquico
directorio
contiene
ficheros
directorios
directorio
directorio
denomina
subdirectorio
anteriormente
directorio
simplemente
fichero
contiene
lista
nombres
ficheros
punteros
nodos-i
asociados
Figura
12.14
muestra
estructura
global
entrada
directorio
entradaD
contiene
nombre
fichero
asociado
subdirectorio
entero
llamado
número-i
número
índice
accede
fichero
directorio
nú-
mero-i
utiliza
índice
tabla
nodos-i
ESTRUCTURA
VOLUMEN
sistema
ficheros
UNIX
reside
único
disco
lógico
partición
disco
compone
siguientes
elementos
Bloque
arranque
Contiene
código
requerido
arrancar
sistema
operativo
Superbloque
Contiene
atributos
información
sistema
ficheros
tama-
ño
partición
tamaño
tabla
nodos-i
Tabla
nodos-i
colección
nodos-i
fichero
Bloques
datos
espacio
almacenamiento
disponible
ficheros
datos
sub-
directorios
12.8
SISTEMA
FICHEROS
VIRTUAL
LINUX
Linux
incluye
utilidad
versátil
potente
gestión
ficheros
diseñado
soportar
variedad
sistemas
gestión
ficheros
estructuras
ficheros
enfoque
usado
Linux
con-
siste
sistema
ficheros
virtual
VFS
presenta
única
uniforme
interfaz
sistema
ficheros
procesos
usuario
VFS
define
modelo
ficheros
común
capaz
representar
característica
general
comportamiento
sistema
ficheros
concebible
VFS
asume
ficheros
objetos
sistema
almacenamiento
masivo
computador
comparten
propiedades
básicas
sistema
ficheros
concreto
hardware
subyacente
ficheros
nombres
simbólicos
permiten
identificarse
forma
única
directorio
específico
sistema
ficheros
fichero
propieta-
rio
protección
frente
accesos
modificaciones
autorizadas
propiedades
fichero
crear
leer
escribir
borrar
sistema
ficheros
específico
necesita
mó-
dulo
proyección
transforme
características
sistema
ficheros
real
características
esperadas
sistema
ficheros
virtual
Figura
12.15
indica
ingredientes
clave
estrategia
sistema
ficheros
Linux
proceso
usuario
invoca
llamada
sistema
ficheros
ejemplo
lectura
utilizando
es-
quema
ficheros
VFS
VFS
convierte
llamada
llamada
sistema
ficheros
interno
núcleo
pasa
función
proyección
sistema
ficheros
específico
ejemplo
578
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
578Gestión
ficheros
579
Tablas
nodos-i
Directorio
Nombre1i1
Nombre2i2
Nombre3i3
Nombre4i4
Figura
12.14
Directorios
nodos-i
UNIX
Proceso
usuario
Solicitud
Llamada
sistema
Núcleo
Linux
Hardware
Interfaz
llamadas
sistema
Sistemas
ficheros
virtual
VFS
IBM
JFS
FS
NTFS
ext2
FS
Cache
páginas
Manejadores
dispositivos
Controlador
disco
Figura
12.15
Contexto
sistema
ficheros
virtual
Linux
12-Capitulo
12
16/5/05
17:07
Página
579el
sistema
ficheros
JFS
Journaling
File
System
IBM
mayoría
casos
función
proyección
simplemente
proyección
llamadas
funcionales
sistema
ficheros
esquema
casos
función
proyección
compleja
ejemplo
sistemas
ficheros
utilizan
tabla
asignación
ficheros
File
Allocation
Table
FAT
almacena
posición
fichero
árbol
directorios
sistemas
ficheros
directorios
ficheros
caso
llamada
original
sistema
ficheros
traduce
llamada
nativa
sistema
ficheros
destino
software
sistema
ficheros
des-
tino
invocado
cabo
función
requerida
fichero
directorio
control
almacenamiento
secundario
resultados
operación
comunican
usua-
rio
forma
similar
Figura
12.16
indica
papel
VFS
juega
núcleo
Linux
proceso
inicia
llamada
sistema
orientada
ficheros
ejemplo
lectura
núcleo
llama
fun-
ción
VFS
función
gestiona
aspectos
independientes
sistema
ficheros
inicia
llamada
función
código
sistema
ficheros
destino
llamada
pasa
función
proyección
convierte
llamada
VFS
llamada
sistema
ficheros
destino
VFS
independiente
sistema
ficheros
implementación
fun-
ción
proyección
implementación
sistema
ficheros
Linux
siste-
ma
ficheros
destino
convierte
petición
sistema
ficheros
instrucciones
orientadas
dis-
positivo
pasan
controlador
dispositivo
funciones
cache
páginas
VFS
esquema
orientado
objetos
escrito
lugar
lengua-
je
dé
soporte
programación
objetos
C++
Java
objetos
VFS
implementan
simplemente
estructuras
datos
C.
objeto
contiene
datos
punteros
fun-
ciones
implementadas
sistema
ficheros
operan
datos
tipos
objetos
primarios
VFS
siguientes
Objeto
superbloque
Representa
sistema
ficheros
montado
específico
Objeto
nodo-i
Representa
fichero
específico
Objeto
entrada
directorio
Representa
entrada
directorio
específica
Objeto
fichero
Representa
fichero
abierto
asociado
proceso
esquema
basa
conceptos
utilizados
sistema
ficheros
UNIX
describió
Sección
12.7
conceptos
clave
sistema
ficheros
UNIX
recordar
siguientes
sistema
ficheros
compuesto
organización
jerárquica
directorios
580
Sistemas
operativos
Aspectos
internos
principios
diseño
Proceso
usuario
Ficheros
almacenamiento
secundario
mantenidos
sistema
ficheros
Sistema
ficheros
virtual
Linux
Función
proyección
sistema
ficheros
Sistema
ficheros
Llamadas
sistema
utilizan
interfaz
usuario
VFS
Llamadas
sistema
utilizan
interfaz
sistema
ficheros
Llamadas
disco
Llamadas
sistema
VFS
Figura
12.16
Concepto
sistema
ficheros
virtual
Linux
12-Capitulo
12
16/5/05
17:07
Página
580Un
directorio
análogo
carpeta
contener
ficheros
directorios
directorio
contener
directorios
forma
estructura
árbol
camino
estructura
árbol
raíz
formado
secuencia
entradas
directorio
aca-
bando
entrada
directorio
entradaD
nombre
fichero
UNIX
directorio
im-
plementa
fichero
lista
ficheros
directorios
contenidos
operacio-
nes
ficheros
cabo
ficheros
directorios
OBJETO
SUPERBLOQUE
objeto
superbloque
almacena
información
describe
sistema
ficheros
específico
Típica-
mente
superbloque
corresponde
superbloque
sistema
ficheros
bloque
control
sis-
tema
ficheros
almacena
sector
especial
disco
objeto
superbloque
formado
elementos
datos
Ejemplos
elementos
incluyen
siguientes
dispositivo
sistema
ficheros
montado
tamaño
bloque
básico
sistema
ficheros
dirty
flag
indica
cambiado
superbloque
escrito
disco
Tipo
fichero
Flags
lectura
Puntero
directorio
raíz
sistema
ficheros
Lista
ficheros
abiertos
Semáforo
controlar
acceso
sistema
ficheros
Lista
operaciones
superbloque
elemento
lista
precedente
refiere
objeto
operaciones
contenido
ob-
jeto
superbloque
objeto
operación
define
métodos
objeto
funciones
núcleo
invocar
objeto
superbloque
métodos
definidos
objeto
superbloque
incluyen
siguientes
read_inode
Leer
nodo-i
específico
sistema
ficheros
montado
write_inode
Escribir
nodo-i
disco
put_inode
Obtener
nodo-i
delete_inode
Borrar
nodo-i
disco
notify_change
Invocado
cambian
atributos
put_super
Llamado
VFS
sistema
ficheros
desmontado
obtener
superbloque
write_super
Invocado
VFS
decide
superbloque
necesita
escribirse
disco
statfs
Obtiene
estadísticas
sistema
ficheros
remount_fs
Llamado
VFS
sistema
ficheros
montado
nue-
vas
opciones
montaje
clear_inode
Obtener
nodo-i
borrar
página
contenga
datos
relacionados
Gestión
ficheros
581
12-Capitulo
12
16/5/05
17:07
Página
581EL
OBJETO
NODO-I
nodo-i
asociado
fichero
objeto
nodo-i
contiene
información
de-
terminado
fichero
nombre
contenido
real
fichero
elementos
contenidos
objeto
nodo-i
incluyen
propietario
grupo
permisos
tiempos
acceso
fichero
tamaño
datos
contiene
número
enlaces
objeto
nodo-i
incluye
objeto
operaciones
nodo-i
describe
funciones
im-
plementadas
sistema
ficheros
VFS
invocar
nodo-i
métodos
definidos
objeto
nodo-i
incluyen
siguientes
create
Crear
nodo-i
fichero
regular
asociado
objeto
entradaD
al-
gún
directorio
lookup
Buscar
directorio
nodo-i
correspondiente
nombre
fichero
mkdir
Crear
nodo-i
directorio
asociado
objeto
entradaD
directorio
OBJETO
ENTRADAD
entradaD
entrada
directorio
componente
específico
ruta
componente
nombre
directorio
nombre
fichero
objeto
entradaD
facilita
acceso
fiche-
ros
directorios
utilizan
cache
entradaD
propósito
OBJETO
FICHERO
objeto
fichero
utiliza
representar
fichero
abierto
proceso
objeto
crea
respuesta
llamada
sistema
open
destruye
respuesta
llamada
sistema
close
objeto
fichero
formado
conjunto
elementos
incluye
siguientes
Objeto
entradaD
asociado
fichero
Sistema
ficheros
contiene
fichero
Contador
objeto
fichero
Identificador
usuario
Identificador
grupo
usuario
Puntero
posición
fichero
posición
actual
fichero
lu-
gar
operación
objeto
fichero
incluye
objeto
operaciones
nodo-i
describe
funciones
im-
plementadas
sistema
ficheros
VFS
invocar
objeto
fichero
métodos
de-
finidos
objeto
fichero
incluyen
lectura
escritura
apertura
creación
bloqueo
12.9
SISTEMA
FICHEROS
WINDOWS
Windows
soporte
sistemas
ficheros
incluyendo
sistema
FAT
File
Allocation
Table
tabla
asignación
ficheros
ejecutan
Windows
95
MS-DOS
OS/2
desarrolla-
582
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
582dores
Windows
diseñaron
sistema
ficheros
sistema
ficheros
Win-
dows
NTFS
pensado
alcanzar
requisitos
altas
prestaciones
estaciones
trabajo
servidores
Ejemplos
aplicaciones
altas
prestaciones
incluyen
siguientes
Aplicaciones
cliente
servidor
tales
servidores
ficheros
servidores
computación
servidores
bases
datos
Ingeniería
intensiva
recursos
aplicaciones
científicas
Aplicaciones
red
sistemas
corporativos
CARACTERÍSTICAS
CLAVE
NTFS
NTFS
sistema
ficheros
flexible
potente
construido
verá
modelo
sistema
ficheros
elegantemente
simple
características
notables
NTFS
incluyen
siguientes
Recuperación
requisitos
importantes
sistema
ficheros
Win-
dows
capacidad
recuperarse
frente
errores
sistema
fallos
disco
caso
dichos
fallos
NTFS
capaz
reconstruir
volúmenes
disco
devolverlos
consistente
cabo
utilizando
modelo
procesamiento
transac-
ciones
cambios
sistema
ficheros
cambio
significativo
acción
atómica
realiza
forma
completa
cabo
absoluto
transacción
proceso
produce
fallo
continuación
terminada
com-
pletamente
deja
sistema
ejecución
Adicionalmente
NTFS
uti-
liza
almacenamiento
redundante
datos
sistema
ficheros
críticos
forma
fallo
sector
disco
cause
pérdida
datos
describen
estructura
sistema
ficheros
Seguridad
NTFS
utiliza
modelo
objetos
Windows
forzar
seguridad
fiche-
ro
abierto
implementa
objeto
fichero
descriptor
seguridad
define
atributos
seguridad
Discos
ficheros
NTFS
soporta
discos
ficheros
forma
efi-
ciente
mayoría
resto
sistemas
ficheros
incluyendo
FAT
Múltiples
flujos
datos
contenidos
reales
fichero
tratan
flujo
by-
tes
NTFS
definir
múltiples
flujos
datos
único
fichero
ejemplo
utilidad
característica
permite
sistemas
Macintosh
remotos
utilicen
Win-
dows
almacenar
recuperar
ficheros
Macintosh
fichero
componentes
datos
fichero
contenedor
recursos
información
fichero
NTFS
componentes
flujos
datos
Facilidad
general
indexación
NTFS
asocia
colección
atributos
fichero
conjunto
descripciones
fichero
sistema
gestión
ficheros
organiza
base
datos
relacional
forma
ficheros
indexar
atributo
VOLÚMENES
NTFS
ESTRUCTURA
FICHEROS
NTFS
siguientes
conceptos
almacenamiento
disco
Sector
unidad
física
almacenamiento
pequeña
disco
tamaño
datos
bytes
potencia
512
bytes
Gestión
ficheros
583
12-Capitulo
12
16/5/05
17:07
Página
583•
Agrupación
sectores
contiguos
pista
tamaño
agrupación
sectores
potencia
Volumen
partición
lógica
disco
formada
agrupaciones
utilizada
sistema
ficheros
asignar
espacio
momento
volumen
for-
mado
información
sistema
ficheros
colección
ficheros
espacio
restante
adicional
asignar
volumen
asignar
ficheros
volumen
único
disco
extender
múltiples
discos
em-
plea
RAID
hardware
software
volumen
compuesto
tiras
múltiples
discos
tamaño
máximo
volumen
NTFS
64
bytes
agrupación
unidad
fundamental
asignación
NTFS
reconoce
sectores
ejemplo
supóngase
sector
512
bytes
sistema
configura
sectores
agrupa-
ción
agrupación
bytes
usuario
crea
fichero
1600
bytes
asignan
agrupa-
ciones
fichero
Posteriormente
usuario
actualiza
fichero
3200
bytes
asignan
agrupaciones
agrupaciones
asignadas
fichero
necesitan
contiguas
fragmentar
fichero
disco
Actualmente
tamaño
fichero
máximo
soportado
NTFS
32
agrupa-
ciones
equivale
máximo
48
bytes
agrupación
máximo
16
bytes
agrupaciones
asignación
NTFS
independiente
tamaño
sector
físi-
co
habilita
NTFS
soportar
fácilmente
discos
estándares
tengan
tamaño
sec-
tor
512
bytes
soportar
eficientemente
discos
ficheros
utilizando
tamaño
agrupación
eficiencia
procede
sistemas
ficheros
guar-
traza
agrupación
asignada
fichero
agrupaciones
mayores
elemen-
tos
gestionar
Tabla
12.6
muestra
tamaños
agrupación
omisión
NTFS
tamaños
omi-
sión
dependen
tamaño
volumen
tamaño
agrupación
utiliza
volumen
par-
ticular
establece
NTFS
usuario
solicita
formatee
volumen
abla
12.6
Particiones
tamaños
agrupaciones
Windows
NTFS
amaño
volumen
Sectores
agrupación
amaño
agrupación
512
Mbytes
512
bytes
512
Mbytes
Gbyte
Gbyte
Gbytes
Gbytes
Gbytes
Gbytes
Gbytes
16
Gbytes
16
Gbytes
32
16
16
Gbytes
32
Gbytes
64
32
32
Gbytes
128
64
ESTRUCTURA
VOLUMEN
NTFS
NTFS
utiliza
enfoque
notablemente
simple
potente
organizar
información
volumen
disco
elemento
volumen
fichero
fichero
formado
colección
atributos
contenido
fichero
atributo
estructura
sencilla
funciones
propósito
general
suficientes
organizar
gestionar
sistema
ficheros
584
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
584La
Figura
12.17
muestra
estructura
volumen
NTFS
formado
regio-
nes
sectores
volumen
ocupados
sector
arranque
partición
llame
sector
formado
máximo
16
sectores
contiene
informa-
ción
estructura
volumen
estructuras
sistema
ficheros
información
arranque
inicio
código
seguido
tabla
maestra
ficheros
Master
File
Ta-
ble
MFT
contiene
información
ficheros
carpetas
directorios
volumen
NTFS
información
espacio
disponible
asignado
esencia
MFT
lista
contenidos
volumen
NTFS
organizada
conjunto
filas
estruc-
tura
base
datos
relacional
Siguiendo
MFT
región
típicamente
Mbyte
longitud
conteniendo
ficheros
sistema
ficheros
región
encuentran
siguientes
MFT2
espejo
primeras
filas
MFT
utilizado
garantizar
acceso
MFT
caso
fallo
único
sector
Fichero
registro
lista
pasos
transacciones
utilizadas
recuperación
NTFS
Mapa
bits
agrupaciones
representación
volumen
mostrando
agrupa-
ciones
Tabla
definición
atributos
Define
tipos
atributos
soportados
volumen
indica
indexar
recuperar
operación
recuperación
sistema
abla
maestra
ficheros
corazón
sistema
ficheros
Windows
MFT
MFT
organiza
tabla
filas
longitud
variable
llamadas
registros
fila
describe
fichero
carpeta
volumen
incluyendo
MFT
fichero
fichero
suficientemente
pequeño
fichero
completo
localiza
fila
MFT
caso
fila
fichero
contiene
in-
formación
parcial
resto
fichero
agrupaciones
disponibles
volumen
puntero
dichas
agrupaciones
fila
MFT
fichero
registro
MFT
formado
conjunto
atributos
sirve
definir
carac-
terísticas
fichero
carpeta
contenidos
Tabla
12.7
lista
atributos
encontrar
fila
habiéndose
sombreado
atributos
obligatorios
RECUPERACIÓN
NTFS
sistema
ficheros
consistente
habido
error
sistema
fallo
disco
elementos
clave
soportan
recuperación
siguientes
Figura
12.18
Gestión
ficheros
585
Sector
arranque
partición
Tabla
maestra
ficheros
Área
ficherosFicheros
sistema
Figura
12.17
Disposición
volumen
NTFS
12-Capitulo
12
16/5/05
17:07
Página
585•
Gestor
S.
Incluye
controlador
NTFS
gestiona
funciones
básicas
apertura
cierre
lectura
escritura
NTFS
Adicionalmente
módulo
software
RAID
FT-DISK
configurar
Servicio
fichero
registro
Mantiene
registro
escrituras
disco
fichero
registro
utiliza
recuperar
volumen
formateado
NTFS
caso
fallo
sis-
tema
Gestor
cache
Responsable
caching
lecturas
escrituras
fichero
incre-
mentar
rendimiento
gestor
cache
optimiza
disco
utilizando
escritura
diferi-
técnicas
transacciones
diferidas
descritas
Sección
11.8
Gestor
memoria
virtual
NTFS
accede
ficheros
cache
proyección
referencias
fichero
referencias
memoria
virtual
leyendo
escribiendo
memoria
virtual
importante
observar
procedimientos
recuperación
utilizados
NTFS
diseñan
recuperar
datos
sistema
ficheros
contenidos
fichero
error
usuario
debería
perder
volumen
estructura
directorio
fichero
sistema
ficheros
garantiza
datos
usuario
Proporcionar
recuperación
completa
inclu-
yendo
datos
usuario
implicaría
facilidad
recuperación
elaborada
supone
tiempo
ejecución
esencia
capacidad
recuperación
NTFS
registros
log-
ging
operación
altera
sistema
ficheros
transacción
subope-
586
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
12.7
.Tipos
atributos
ficheros
directorios
Windows
NTFS
Tipo
atributos
Descripción
Información
estándar
Incluye
atributos
acceso
lectura
lectura
escritura
etc.
sellos
tiempo
incluyendo
fecha
creación
modificación
directorios
apuntan
fichero
número
enlaces
Lista
atributos
lista
atributos
componen
fichero
referencia
ficheros
registro
ficheros
MFT
localiza
atributo
Utilizado
atributos
caben
único
registro
ficheros
MFT
Nombre
fichero
fichero
directorio
nombres
Descriptor
seguridad
Especifica
propietario
fichero
acceder
Datos
contenidos
fichero
fichero
conjunto
atributos
nombre
omisión
atributos
datos
nombre
Raíz
índice
Usado
implementar
carpetas
Asignación
índice
Usado
implementar
carpetas
Información
volumen
Incluye
información
relacionada
volumen
versión
nombre
volumen
Mapa
bits
Proporciona
mapa
representa
registros
MFT
carpeta
Nota
filas
coloreadas
refieren
atributos
ficheros
requeridos
atributos
opcionales
12-Capitulo
12
16/5/05
17:07
Página
586ración
transacción
altera
estructuras
datos
sistema
ficheros
importantes
graba
fichero
registro
grabarse
volumen
disco
Utilizando
registro
tran-
sacción
parcialmente
completada
momento
error
rehacer
posteriormente
desha-
cer
sistema
recupera
términos
generales
pasos
tomados
asegurar
recuperación
des-
cribe
CUST94
NTFS
llama
registro
sistema
ficheros
grabar
registro
cache
transacción
modificará
estructura
volumen
NTFS
modifica
volumen
cache
gestor
cache
llama
registro
sistema
ficheros
volcar
fichero
registro
disco
registro
actualiza
forma
segura
disco
gestor
cache
vuelca
cambios
disco
12.10
RESUMEN
sistema
gestión
ficheros
conjunto
software
sistema
proporciona
servicios
usuarios
aplicaciones
ficheros
incluyendo
accesos
ficheros
mantenimiento
direc-
torios
control
acceso
sistema
gestión
ficheros
ve
típicamente
servicio
sistema
sistema
operativo
sirve
lugar
sistema
operativo
sistema
funciones
gestión
ficheros
cabo
sis-
tema
operativo
fichero
formado
colección
registros
forma
registros
ac-
ceden
determina
organización
lógica
punto
organización
física
disco
fi-
chero
procesa
primariamente
entidad
organización
secuencial
sencilla
apropiada
necesita
acceso
secuencial
desea
acceso
aleatorio
fichero
in-
Gestión
ficheros
587
Servicio
fichero
registro
Controlador
NTFS
Gestor
Manejador
disco
Gestor
cache
Gestor
memoria
virtual
olcar
fichero
registro
Escribir
cache
Registrar
transición
Leer
escribir
volumen
espejo
espejo
Leer
escribir
disco
Leer
escribir
fichero
Cargar
datos
disco
memoria
Acceder
fichero
proyectado
volcar
cache
Manejador
tolerante
fallos
Figura
12.18
Componentes
Windows
NTFS
12-Capitulo
12
16/5/05
17:07
Página
587dividual
fichero
secuencial
indexado
proporcionar
rendimiento
accesos
fichero
principalmente
aleatorios
fichero
indexado
hash
apropiado
estructura
fichero
escogida
necesita
servicio
directorios
permite
ficheros
organicen
forma
jerárquica
organización
útil
usuario
guarde
traza
ficheros
útil
sistemas
gestión
ficheros
proporcionen
control
ac-
ceso
servicios
usuario
registros
ficheros
tamaño
fijo
generalmente
conformes
tamaño
bloque
disco
físico
necesita
especie
estrategia
asignación
bloques
compromiso
complejidad
rendimiento
utilización
espacio
determi-
na
estrategia
asignación
bloques
utilizar
función
clave
esquema
gestión
ficheros
gestión
espacio
disco
función
estrategia
asignar
bloques
disco
fichero
métodos
pue-
den
utilizarse
variedad
estructuras
datos
utilizan
guardar
traza
asigna-
ción
fichero
Adicionalmente
gestionar
espacio
disco
asignado
función
consiste
principalmente
mantener
tabla
asignación
disco
indi-
bloques
libres
12.11
LECTURAS
RECOMENDADAS
libros
gestión
ficheros
enfocan
sistemas
gestión
ficheros
tratan
aspectos
relacionados
sistema
operativo
útil
WIED87
enfoque
cuantitativo
gestión
ficheros
aspectos
descritos
Figura
12.2
planificación
disco
estructura
ficheros
LIV
A90
hincapié
estructuras
ficheros
proporcionando
abundante
revisión
análi-
sis
rendimiento
comparativos
GROS86
proporciona
visión
equilibrada
aspectos
relacio-
nados
métodos
ficheros
métodos
acceso
ficheros
contiene
des-
cripción
general
estructuras
control
necesitadas
sistema
ficheros
proporcionan
lista
útil
diseño
sistemas
ficheros
FOLK98
enfatiza
procesa-
miento
ficheros
tratando
temas
mantenimiento
búsqueda
ordenación
compartición
sistema
ficheros
Linux
examina
detalladamente
LOVE04
BOVE03
descripción
recoge
RUBI97
CUST94
proporciona
descripción
sistema
ficheros
NT
NAGA97
cubre
material
detalladamente
BOVE03
Bovet
D.
and
Cesati
M.
Understanding
the
Linux
Kernel
Sebastopol
CA
O’Reilly
2003
CUST94
Custer
H.
Inside
the
Windows
NT
File
System
Redmond
WA
Microsoft
Press
1994
FOLK98
Folk
M.
and
Zoellick
B.
File
Structures
An
Object-Oriented
Approach
with
C++
Reading
MA
Addison-Wesley
1998
GROS86
Grosshans
D.
File
Systems
Design
and
Implementation
Englewood
Cliffs
NJ
Prentice
Hall
1986
LIVA90
Livadas
File
Structures
Theory
and
Practice
Englewood
Cliffs
NJ
Prentice
Hall
1990
LOVE04
Love
R.
Linux
Kernel
Development
Indianapolis
IN
Sams
Publishing
2004
NAGA97
Nagar
R.
Windows
NT
File
System
Internals
Sebastopol
CA
O’Reilly
1997
RUBI97
Rubini
A.
The
Virtual
File
System
in
Linux
Linux
Journal
May
1997
WIED87
Wiederhold
G.
File
Organization
for
Database
Design
New
York
McGraw-Hill
1987
588
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
58812.12
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
asignación
fichero
directorio
trabajo
actual
pila
asignación
fichero
indexado
fichero
registro
asignación
ficheros
contigua
fichero
acceso
directo
hash
ruta
nombre
asignación
ficheros
encadenada
fic
hero
indexado
sistema
gestión
ficheros
base
datos
fichero
secuencial
tabla
asignación
disco
bloque
fichero
secuencial
indexado
tabla
asignación
fichero
campo
método
acceso
tabla
bits
campo
clave
nodo-i
directorio
nombre
fichero
CUESTIONES
REPASO
12.1
diferencia
campo
registro
12.2
diferencia
fichero
base
datos
12.3
sistema
gestión
ficheros
12.4
criterios
importantes
hora
escoger
organización
ficheros
12.5
Liste
defina
brevemente
organizaciones
ficheros
12.6
menor
tiempo
búsqueda
registro
fichero
fi-
chero
secuencial
indexado
fichero
secuencial
12.7
operaciones
típicas
directorio
12.8
relación
ruta
fichero
directorio
trabajo
12.9
derechos
acceso
típicos
conceder
denegar
usua-
rio
particular
fichero
particular
12.10
Liste
defina
brevemente
tipos
bloques
utilizados
12.11
Liste
defina
brevemente
métodos
asignación
ficheros
PROBLEMAS
12.1
Defina
tamaño
bloque
tamaño
registro
tamaño
puntero
bloque
factor
bloques
número
esperado
registros
bloque
Defina
fórmula
tipos
bloques
dibujados
Figu-
ra
12.6
Gestión
ficheros
589
12-Capitulo
12
16/5/05
17:07
Página
58912.2
esquema
evitar
problema
preasignación
frente
malgasto
falta
con-
tigüidad
asignar
porciones
tamaño
incremental
medida
fichero
crece
ejemplo
comenzando
tamaño
bloque
doblando
porción
asig-
nación
Considérese
fichero
registros
factor
bloques
F.
Supóngase
utiliza
índice
simple
nivel
tabla
asignación
ficheros
Obtenga
límite
superior
número
entradas
tabla
asignación
fiche-
ros
función
n.
cantidad
máxima
espacio
asigna
momento
12.3
organizaciones
fichero
escogería
maximizar
eficiencia
términos
ve-
locidad
acceso
espacio
almacenamiento
facilidad
actualización
aña-
dir
borrar
modificar
datos
actualizan
frecuentemente
acceden
frecuentemente
orden
aleatorio
actualizan
frecuentemente
acceden
totalidad
relativamente
frecuente
actualizan
frecuentemente
acceden
frecuentemente
orden
aleatorio
12.4
directorios
implementar
ficheros
especiales
acceder
forma
limitada
ficheros
datos
ordinarios
ven-
tajas
desventajas
opción
12.5
sistemas
operativos
sistema
ficheros
estructurado
forma
ár-
bol
limitan
profundidad
árbol
número
pequeño
niveles
efecto
límite
usuarios
simplifica
diseño
sistema
operativo
12.6
Considérese
sistema
ficheros
jerárquico
espacio
disco
libre
guar-
lista
espacio
libre
Supóngase
pierde
puntero
espacio
libre
sistema
reconstruir
lista
espacio
libre
Sugiera
esquema
asegure
puntero
pierde
resultado
único
fallo
memoria
12.7
Considérese
organización
fichero
UNIX
representado
nodo-i
Figura
12.13
Asúmase
12
punteros
directos
bloque
puntero
indirecto
simple
doble
triple
nodo-i
Asúmase
tamaño
bloque
sistema
tamaño
sector
disco
8K.
puntero
bloque
32
bits
bits
utilizados
identificar
disco
físico
24
bits
identificar
bloque
físico
contestar
siguientes
preguntas
tamaño
máximo
fichero
soportado
sistema
tamaño
máximo
partición
soportado
sistema
Asumiendo
conoce
nodo-i
fichero
memoria
princi-
pa
accesos
disco
requieren
acceder
byte
posición
13.423.956
590
Sistemas
operativos
Aspectos
internos
principios
diseño
12-Capitulo
12
16/5/05
17:07
Página
590PARTE
VI
SISTEMAS
DISTRIBUIDOS
SEGURIDAD
radicionalmente
función
procesamiento
datos
organizada
forma
centrali-
zada
arquitectura
procesamiento
datos
centralizada
tratamiento
datos
realizaba
computador
cluster
computadores
general
computado-
res
localizados
instalación
central
procesamiento
datos
tareas
reali-
zadas
instalación
inician
resultados
producidos
instalación
ejemplo
aplicación
nóminas
tareas
requerir
acceso
interactivo
perso-
nal
físicamente
centro
procesamiento
datos
ejemplo
función
entrada
datos
actualización
inventario
personal
cual-
quier
organización
arquitectura
centralizada
persona
terminal
local
conecta
mecanismo
comunicaciones
instalación
central
procesa-
miento
datos
instalación
totalmente
centralizada
procesamiento
datos
centralizada
sentidos
Computadores
centralizados
instalación
central
computadores
mu-
chos
casos
computadores
requieren
instalaciones
especiales
aire
acondicionado
suelos
elevados
organización
pequeña
computador
computadores
centrales
minicomputadores
sistemas
gama
media
iSeries
IBM
ejemplo
sistemas
gama
media
Procesamiento
centralizado
aplicaciones
ejecutan
instalaciones
centrales
procesamiento
datos
incluye
aplicaciones
claramente
centrales
aplicaciones
centrales
naturaleza
tales
aplicación
nóminas
aplicación
nece-
site
usuarios
determinado
departamento
organizativo
ejemplo
situa-
ción
departamento
diseño
productos
utilizar
paquete
gráfico
dise-
ño
asistido
computador
CAD
ejecuta
instalaciones
centrales
Datos
centralizados
datos
almacenan
ficheros
bases
datos
instala-
ciones
centrales
controlados
accedidos
computador
computadores
centrales
incluye
datos
utilizan
departamentos
organización
tales
figuras
inventario
datos
deberían
usados
departamento
ejemplo
situación
departamento
marketing
base
datos
información
derivada
encuestas
clientes
13-Capitulo
13
12/5/05
16:27
Página
591Una
organización
centralizada
tipo
aspectos
atractivos
re-
ducción
costos
compra
manejo
equipamiento
software
departamento
central
procesamiento
datos
permitir
programadores
profesionales
plantilla
asegurar
necesidades
departamentos
dirección
controlar
realización
procesamiento
datos
forzar
estándares
programación
estructuras
ficheros
datos
diseñar
implementar
política
seguridad
instalación
central
procesamiento
datos
dividir
diversas
maneras
imple-
mentando
estrategia
procesamiento
datos
distribuida
distributed
data
processing
DDP
instalación
distribuida
procesamiento
datos
computadores
normal-
mente
pequeños
computadores
dispersos
organización
objetivo
disper-
sión
procesar
información
forma
eficiente
basándose
consideraciones
ope-
racionales
económicas
geográficas
instalación
DDP
incluir
instalación
central
instalaciones
satélite
formada
serie
instalaciones
similares
caso
normalmente
necesita
tipo
interconexión
computadores
sistema
conectados
esperar
instalación
DDP
involucra
distribución
computadores
procesamiento
datos
ventajas
DDP
incluyen
siguientes
Receptividad
instalaciones
computación
local
gestionar
satisfacer
directamente
necesidades
gestión
organizaciones
locales
instalación
central
intenta
satisfacer
necesidades
organización
Disponibilidad
múltiples
sistemas
interconectados
pérdida
sistema
impacto
mínimo
sistemas
componentes
prioritarios
ejemplo
computadores
aplicaciones
críticas
impresoras
dispositivos
almacenamiento
masivo
re-
plicados
forma
sistema
recuperación
asumir
carga
rápidamente
fallo
Compartición
resursos
hardware
caro
compartir
usuarios
ficheros
datos
gestionar
mantener
forma
centralizada
acceso
organización
servicios
personal
programas
bases
datos
pue-
den
desarrollar
organización
distribuir
distintas
instalaciones
Crecimiento
incremental
instalación
centralizada
incremento
carga
tra-
necesidad
conjunto
aplicaciones
normalmente
supone
compra
equipamiento
significativas
actualizaciones
software
implica
gasto
im-
portante
cambios
requerir
conversión
reprogramación
aplica-
ciones
existentes
correspondiente
riesgo
errores
degradación
rendimiento
sistema
distribuido
reemplazar
gradualmente
aplicaciones
sistemas
hu-
yendo
enfoque
equipos
antiguos
dejar
instalaciones
ejecutar
aplicaciones
sencillas
coste
pasar
aplicación
máquina
justificado
participación
control
usuario
equipos
pequeños
manejables
fí-
sicamente
localizados
cerca
cliente
usuario
posibilidades
influir
dise-
ño
funcionamiento
sistema
interacción
personal
técnico
supervisor
inmediato
Productividad
usuario
sistemas
distribuidos
tienden
rapidez
respuesta
pieza
equipo
realizando
trabajo
pequeño
aplicaciones
interfaces
optimizadas
necesidades
departamento
gestores
departamento
evaluar
efectividad
local
instalación
cambios
apropiados
13-Capitulo
13
12/5/05
16:27
Página
592Para
lograr
beneficios
sistema
operativo
proporcionar
diversas
funciones
soporte
DDP
incluyen
software
intercambio
datos
máquinas
capacidad
clusters
computadores
lograr
alta
disponibilidad
altas
prestaciones
capacidad
manejar
procesos
entornos
distribuidos
conectividad
universal
virus
hackers
escándalos
fraudes
electróni-
cos
seguridad
convertido
aspecto
fundamental
tendencias
tema
particular
interés
crecimiento
explosivo
sistemas
computación
in-
terconexiones
redes
incrementado
dependencia
organizaciones
indi-
viduos
información
almacenada
comunicación
sistemas
llevado
concienciación
necesidad
proteger
datos
recursos
revelación
garantizar
autenticidad
datos
mensajes
proteger
sistemas
ataques
basados
red
Segun-
do
disciplinas
criptografía
seguridad
madurado
llevando
desarrollo
aplicaciones
prácticas
fácil
disponibilidad
imponer
seguridad
MAPA
RUTA
CAPÍTULO
13
REDES
comunicación
datos
red
sistemas
distribuidos
dependen
software
co-
municaciones
subyacente
independiente
aplicaciones
descarga
carga
intercambio
fiable
datos
software
comunicaciones
organizado
arquitectura
protocolos
destacan
protocolos
TCP
IP
Capítulo
13
introduce
concepto
arquitectura
protocolos
proporciona
visión
general
TCP
IP
CAPÍTULO
14
PROCESAMIENTO
DISTRIBUIDO
CLIENTE
SERVIDOR
CLUSTERS
Capítulo
14
examina
soporte
require
sistema
operativo
cooperen
múltiples
sistemas
capítulo
analiza
importante
concepto
computación
cliente
servidor
incluyendo
descripción
mecanismos
clave
utilizados
implementar
sistemas
cliente
servidor
paso
mensajes
llamadas
procedimiento
remoto
Capítulo
14
exa-
mina
concepto
clusters
CAPÍTULO
15
GESTIÓN
PROCESOS
DISTRIBUIDOS
Capítulo
15
examina
aspectos
fundamentales
desarrollo
sistemas
operativos
distri-
buidos
analizan
requisitos
mecanismos
migración
procesos
permiten
proceso
activo
mueva
máquina
objetivo
lograr
reparto
equili-
brado
carga
máxima
disponibilidad
analiza
concepto
global
distribui-
do
elemento
vital
desarrollo
sistemas
operativos
distribuidos
Finalmente
exploran
aspectos
clave
gestión
procesos
distribuidos
exclusión
mutua
inter-
bloqueo
CAPÍTULO
16
SEGURIDAD
Capítulo
16
proporciona
visión
general
seguridad
computadores
sistemas
opera-
tivos
capítulo
comienza
visión
general
amenazas
seguridad
analizan
me-
13-Capitulo
13
12/5/05
16:27
Página
593canismos
protección
sistemas
computación
continuación
describen
formas
contrarrestar
amenazas
intrusos
usuarios
autorizados
usuarios
autorizados
intentando
rea-
lizar
acciones
autorizadas
continuar
analizan
virus
amenazas
cono-
cidas
perjudiciales
capítulo
analiza
exhaustivo
mecanismo
seguridad
conoci-
do
sistema
confianza
Finalmente
presenta
seguridad
redes
13-Capitulo
13
12/5/05
16:27
Página
594CAPÍTULO
13
Redes
13.1
necesidad
arquitectura
protocolos
13.2
arquitectura
protocolos
TCP
IP
13.3
Sockets
13.4
Redes
Linux
13.5
Resumen
13.6
Lecturas
sitios
web
recomendados
13.7
érminos
clave
cuestiones
repaso
problemas
Apéndice
13A
protocolo
simple
transferencia
ficheros
13-Capitulo
13
12/5/05
16:27
Página
595J
unto
creciente
disponibilidad
computadores
personales
asequibles
potentes
habido
tendencia
proceso
datos
distribuido
DDP
procesadores
datos
procesamiento
datos
diseminados
organización
sistema
DDP
implica
dividir
funciones
computación
organizar
forma
distribuida
bases
datos
control
dispositivos
control
interacciones
organizaciones
dependencia
computadores
personales
asociación
servidores
computadores
personales
utilizan
soporte
aplicacio-
nes
fácil
manejo
tales
procesadores
texto
hojas
cálculo
presentación
gráficos
servidores
mantienen
bases
datos
corporativas
sofisticados
gestores
bases
datos
software
sistemas
información
necesita
conexión
computadores
personales
computadores
personales
servidores
mecanismos
común
tratar
computadores
personales
simples
terminales
alto
nivel
integración
aplicaciones
computadores
personales
servidores
tendencias
visto
favorecidas
evolución
capacidades
sistemas
ope-
rativos
utilidades
soporte
explorado
diversas
soluciones
distribuidas
Arquitectura
comunicaciones
software
soporte
grupo
computadores
red
Proporciona
soporte
aplicaciones
distribuidas
tales
correo
electrónico
transferencia
ficheros
acceso
terminales
remotos
computadores
si-
guen
entidades
independientes
usuarios
aplicaciones
comunicar
expreso
deseo
computador
sistema
operativo
mezcla
computadores
sistemas
operativos
máquinas
soporten
arquitectura
comunicaciones
arquitectura
comunicacio-
nes
ampliamente
utilizada
conjunto
protocolos
TCP
IP
examina
capítulo
Sistema
operativo
red
configuración
red
máquinas
normalmente
esta-
ciones
trabajo
usuario
máquinas
servidoras
proporcionan
servicios
red
aplicaciones
tales
almacenamiento
ficheros
gestión
impre-
sión
computador
sistema
operativo
sistema
operativo
red
añadido
sistema
operativo
local
permite
máquinas
interactuar
servidores
usuario
conoce
existencia
múltiples
computadores
trabajar
forma
explícita
Normalmente
utiliza
arquitectura
comunicaciones
común
soporte
aplicaciones
red
Sistema
operativo
distribuido
sistema
operativo
común
compartido
red
computadores
usuarios
sistema
operativo
normal
centralizado
proporciona
acceso
transparente
recursos
diversas
máquinas
sistema
operativo
distribuido
depender
arquitectura
comunicaciones
funciones
básicas
comunicación
normalmente
incorporan
conjunto
funciones
comunicación
sencillas
proporcionar
eficiencia
tecnología
arquitectura
comunicaciones
desarrollada
soportada
to-
vendedores
sistemas
operativos
red
fenómeno
reciente
algu-
productos
comerciales
central
investigación
desarrollo
sistemas
distribuidos
centra
área
sistemas
operativos
distribuidos
introducido
sistemas
comerciales
sistemas
operativos
distribuidos
complementamente
funcionales
etapa
experimental
capítulo
si-
guientes
examinan
capacidades
procesamiento
distribuido
capítulo
centra
software
protocolos
red
subyacente
596
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
59613.1
NECESIDAD
ARQUITECTURA
PROTOCOLOS
computador
terminal
dispositivo
procesamiento
datos
intercambia
datos
procedimiento
involucrado
complejo
Considere
ejemplo
transferencia
fichero
computadores
ruta
datos
computadores
enla-
ce
directo
red
comunicaciones
necesita
típicas
tareas
incluyen
siguientes
sistema
emisor
activar
enlace
directo
comunicación
datos
informar
red
comunicaciones
identidad
sistema
destinatario
deseado
sistema
emisor
verificar
sistema
destino
preparado
recibir
datos
aplicación
transferencia
ficheros
sistema
origen
verificar
programa
gestión
ficheros
sistema
destino
preparado
aceptar
almacenar
fichero
usuario
particular
formatos
ficheros
representaciones
datos
sistemas
incompati-
bles
sistemas
deberá
ejecutar
función
traducción
formato
intercambio
información
computadores
finalidad
cooperativa
conoce
co-
municación
computadores
forma
similar
computadores
interconectan
red
comunicación
conjunto
computadores
denomina
red
computadores
requiere
nivel
similar
cooperación
terminal
computador
términos
utilizan
entidades
comunicación
terminales
relación
comunicación
computadores
redes
computadores
conceptos
suma
importancia
Protocolos
Arquitectura
comunicaciones
arquitectura
protocolos
protocolo
utiliza
comunicar
entidades
sistemas
términos
entidad
sistemas
utilizan
sentido
genérico
ejemplos
entidades
programas
aplicación
usuario
paquetes
transferencia
ficheros
sistemas
gestión
bases
datos
servicios
correo
electrónico
terminales
ejemplos
sistemas
computadores
termi-
nales
sensores
remotos
Fijarse
casos
entidad
sistema
reside
ejemplo
terminales
general
entidad
cosa
capaz
enviar
recibir
información
sistema
objeto
físico
contiene
entidades
entida-
des
comuniquen
éxito
hablar
idioma
comunica
comu-
nica
comunica
hacerse
convenciones
entidades
involu-
cradas
convenciones
denominan
protocolos
definir
conjunto
reglas
gobiernan
intercambio
datos
entidades
elementos
principales
protocolo
siguientes
Sintaxis
Incluye
cosas
tales
formatos
datos
niveles
señales
Semántica
Incluye
información
control
coordinación
gestión
errores
Temporización
Incluye
ajuste
velocidades
secuenciamiento
Apéndice
13A
contiene
ejemplo
específico
protocolo
estándar
Internet
Protoco-
Transferencia
Simple
Ficheros
Trivial
File
Transfer
Protocol
TFTP
Redes
597
13-Capitulo
13
12/5/05
16:27
Página
597Conociendo
concepto
protocolo
introducir
concepto
arquitectura
pro-
tocolos
existir
alto
nivel
cooperación
sistemas
computa-
ción
lugar
implementar
lógica
módulo
tarea
descomponer
subtareas
implementar
forma
individual
ejemplo
Figura
13.1
sugiere
forma
implementar
servicio
transferencia
ficheros
utilizan-
do
módulos
tareas
lista
módulo
transferen-
cia
ficheros
módulos
sistemas
intercambian
ficheros
mandatos
embar-
go
módulo
transferencia
ficheros
encarga
detalles
transmitir
datos
mandatos
confía
misión
módulo
servicios
comunicaciones
módulo
respon-
sable
asegurarse
mandatos
transferencia
ficheros
datos
intercambian
forma
fiable
sistemas
Posteriormente
explorará
forma
trabaja
módulo
servicios
comunicaciones
cosas
realiza
tarea
naturaleza
intercambio
módulos
servicio
comunicaciones
independiente
natura-
leza
red
interconecta
construir
detalles
interfaz
red
módulo
servicios
comunicaciones
sentido
tercer
módulo
módulo
acce-
so
red
realiza
tarea
resumir
módulo
transferencia
ficheros
contiene
lógica
única
aplicación
transferencia
ficheros
transmisión
claves
mandatos
registros
ficheros
ficheros
mandatos
transmitir
forma
fiable
re-
quisitos
fiabilidad
comunes
aplicaciones
ejemplo
correo
electrónico
transferen-
cia
documentos
requisitos
acometen
módulo
servicios
comunica-
ciones
utilizar
múltiples
aplicaciones
módulo
servicios
comunicaciones
preocupa
sistemas
computación
estén
activos
listos
intercambio
da-
tos
datos
intercambiando
asegurar
entrega
em-
bargo
tareas
independientes
tipo
red
utilizando
lógica
tratar
red
pone
módulo
acceso
red
cambia
red
ve
afectado
módulo
lugar
único
módulo
comunicaciones
con-
estructurado
módulos
implementan
función
comunicaciones
estructura
co-
noce
arquitectura
protocolos
punto
útil
analogía
Suponga
eje-
cutivo
oficina
enviar
documento
ejecutivo
oficina
ejecutivo
prepara
documento
añade
nota
corresponde
acciones
aplicación
transferencia
ficheros
Figura
13.1
continuación
ejecutivo
entrega
598
Sistemas
operativos
Aspectos
internos
principios
diseño
Lógica
interfaz
red
Mensajes
relacionados
comunicación
Ficheros
mandatos
transferencia
ficheros
Computador
Módulo
acceso
red
Módulo
sevicios
comunicaciones
Aplicación
transferencia
ficheros
Red
comunicaciones
Computador
Lógica
interfaz
red
Aplicación
transferencia
ficheros
Módulo
sevicios
comunicaciones
Módulo
acceso
red
Figura
13.1
arquitectura
simplicada
transferencia
ficheros
13-Capitulo
13
12/5/05
16:27
Página
598documento
secretario
administrativo
pone
documento
escribe
dirección
dirección
remitente
X.
esté
marcado
confiden-
cial
acciones
corresponden
módulo
servicios
comunicaciones
Figura
13.1
entrega
paquete
departamento
envíos
Alguien
departamento
envíos
decide
enviar
paquete
correo
correo
urgente
etc.
departamento
envíos
añade
fran-
queo
adecuado
paquete
envía
departamento
envíos
corresponde
módulo
ac-
ceso
red
Figura
13.1
paquete
llega
ocurren
serie
acciones
similares
departamento
envíos
recibe
paquete
entrega
secretario
correspondiente
basán-
dose
nombre
paquete
abre
paquete
entrega
documento
adjunto
ejecutivo
dirigido
13.2
ARQUITECTURA
PROTOCOLOS
TCP
IP
TCP
IP
resultado
investigación
desarrollo
protocolos
llevado
cabo
red
intercambio
paquetes
ARPANET
financiada
Defense
Advanced
Research
Projects
Agency
DARPA
Normalmente
conoce
paquete
protocolos
TCP
IP
paquete
protoco-
colección
protocolos
utilizado
estándares
Internet
In-
ternet
Activities
Board
IAB
sitio
web
libro
documento
proporciona
discusión
estándares
Internet
CAPAS
TCP
IP
términos
generales
comunicaciones
involucran
agentes
aplicaciones
computadores
re-
des
transferencia
ficheros
correo
electrónico
ejemplos
aplicación
apli-
caciones
interés
capítulo
aplicaciones
distribuidas
implican
intercambio
da-
tos
sistemas
computación
aplicaciones
ejecutan
computadores
múltiples
aplicaciones
tiempo
computadores
conectados
redes
datos
intercambian
transfieren
red
computador
for-
ma
transferencia
datos
aplicación
implica
obtener
datos
computador
reside
aplicación
obtener
datos
aplicación
deseada
modelo
oficial
protocolos
TCP
IP
basándose
protocolos
es-
tándares
desarrollados
tareas
comunicación
TCP
IP
organizar
capas
relativamente
independientes
abajo
Capa
física
Capa
acceso
red
Capa
Internet
Máquina-a-máquina
capa
transporte
Capa
aplicación
capa
física
cubre
interfaz
física
dispositivo
transmisión
datos
ejemplo
estación
trabajo
computador
transmisión
red
capa
preocupa
características
transmisión
naturaleza
señales
tasa
datos
aspectos
similares
capa
acceso
red
preocupa
intercambio
datos
sistema
servi-
dor
estación
trabajo
etc.
red
unido
computador
realiza
envío
Redes
599
13-Capitulo
13
12/5/05
16:27
Página
599proporcionar
red
dirección
computador
destino
red
encaminar
datos
destino
apropiado
computador
emisor
desear
utilizar
servicios
tales
prioridad
proporcionados
red
software
específico
utilizado
capa
depende
tipo
red
utilizado
desarrollado
estándares
conmutación
circuitos
conmutación
paquetes
ejemplo
frame
relay
LANs
ejem-
plo
Ethernet
forma
separar
funciones
relacionadas
red
capa
separada
Gracias
restante
software
comunicaciones
preocupar
aspectos
específicos
red
utilizar
funcionando
correctamente
indepen-
diencia
red
capa
acceso
red
preocupa
enviar
datos
red
sistemas
fi-
nales
unidos
casos
dispositivos
estén
unidos
distintas
redes
ne-
cesita
procedimiento
permitir
datos
atravesar
múltiples
redes
interconectadas
función
capa
Internet
Protocolo
Internet
Internet
Protocol
IP
utiliza
capa
proporcionar
función
encaminamiento
múltiples
redes
proto-
colo
implementado
sistemas
finales
implementado
encamina-
dores
routers
encaminador
procesador
conecta
redes
cuya
función
principal
pasar
datos
red
ruta
sistema
origen
sistema
destino
Independientemente
naturaleza
aplicaciones
intercambiando
datos
sue-
existir
requisito
fiabilidad
pretende
asegurar
datos
lleguen
aplica-
ción
destino
hagan
orden
enviados
verá
meca-
nismos
proporcionar
fiabilidad
independientes
naturaleza
aplicaciones
forma
sentido
unir
mecanimos
capa
común
compartida
aplicaciones
capa
máquina-a-máquina
capa
transporte
Protocolo
Control
Transmisión
Transmission
Control
Protocol
TCP
protocolo
frecuente
utilizado
proporcio-
nar
funcionalidad
Finalmente
capa
aplicación
contiene
lógica
necesaria
soportar
aplicaciones
usuario
tipo
aplicación
aplicación
transferencia
ficheros
necesita
módulo
TCP
UDP
aplicaciones
utilizan
arquitectura
protocolos
TCP
IP
protoco-
capa
transporte
TCP
TCP
proporciona
conexión
fiable
transmisión
da-
tos
aplicaciones
conexión
simplemente
asociación
lógica
temporal
entidades
sistemas
duración
conexión
entidad
segui-
miento
segmentos
regular
flujo
recuperar
segmentos
perdidos
dañados
Figura
13.2a
muestra
formato
cabecera
TCP
mínimo
20
octetos
160
bits
campos
Puerto
Origen
Puerto
Destino
identifican
aplicaciones
sistemas
origen
destino
conexión
campos
Número
Secuencia
Número
Confirmación
Ventana
proporcionan
control
flujo
control
errores
Suma
Control
checksum
có-
digo
16
bits
basado
contenido
segmento
utiliza
detectar
errores
TCP
protocolo
capa
transporte
Protocolo
Datagramas
Usuario
User
Datagram
Protocol
UDP
UDP
garantiza
entrega
preser-
ve
secuencia
protección
frente
duplicación
UDP
permite
proceso
enviar
mensaje
proceso
mínimos
mecanismos
protocolo
posibles
aplicaciones
orientadas
transacciones
utilizan
UDP
ejemplo
SNMP
Simple
Network
Management
Protocol
proto-
600
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
600colo
estándar
gestión
redes
TCP
IP
orientado
conexión
UDP
trabajo
Esencialmente
añade
servicio
puertos
IP
ve
examinando
ca-
becera
UDP
mostrada
Figura
13.2b
IP
IPV6
décadas
IP
pieza
clave
arquitectura
protocolos
TCP
IP
Figura
13.3a
muestra
formato
cabecera
IP
mínimo
20
octetos
160
bits
cabecera
segmento
capa
transporte
forma
bloque
nivel
IP
conocido
datagrama
IP
paquete
IP
cabecera
incluye
direcciones
origen
destino
32
bits
campo
Suma
Control
cabecera
utiliza
detectar
errores
cabecera
propósito
evitar
fallos
envío
campo
Protocolo
indica
protocolo
capa
superior
utilizando
IP
TCP
UDP
campos
ID
Flags
Desplazamiento
Fragmento
Fragment
Offset
utilizan
procesos
fragmentación
reensamblado
datagrama
IP
divide
múltiples
da-
tagramas
IP
transmisión
vuelven
unir
destino
1995
Internet
Engineering
Task
Force
IETF
desarrolla
estándares
protocolos
Internet
publicó
especificación
generación
IP
conocida
IPng
espe-
cificación
transformó
estándar
1996
nombre
IPv6
IPv6
proporciona
serie
me-
joras
funcionales
IP
diseñado
ajustarse
redes
velocidad
existentes
mezcla
streams
datos
incluyendo
gráficos
vídeo
comunes
razón
desarrollar
protocolo
necesidad
direccionamiento
IP
actual
utiliza
direcciones
32
bits
especificar
fuente
desti-
crecimiento
explosivo
Internet
redes
privadas
unidas
Internet
longitud
direccionamiento
insuficiente
acomodar
sistemas
muestra
Figura
13.3b
IPv6
incluye
campos
dirección
128
bits
Redes
601
Puerto
origen
Puerto
destino
Suma
control
Puntero
urgente
Número
secuencia
Número
confirmación
Opciones
relleno
Reservado
Flags
Ventanalongitud
cabecera
Bit
16
31
20
octets
Longitud
segmento
Suma
control
Bit
16
31
octets
Cabecera
TCP
Cabecera
UDP
Puerto
destinoPuerto
origen
Figura
13.2
Cabeceras
TCP
UDP
13-Capitulo
13
12/5/05
16:27
Página
601Todas
instalaciones
estén
utilizando
TCP
IP
espera
migren
actual
IP
IPv6
proceso
llevará
años
décadas
FUNCIONAMIENTO
TCP
IP
Figura
13.4
muestra
configuran
protocolos
comunicación
hora
conectar
computador
red
utiliza
tipo
protocolo
acceso
red
Ether-
net
protocolo
permite
máquina
enviar
datos
red
máquina
caso
máquina
esté
red
encaminador
IP
implementado
sistemas
finales
602
Sistemas
operativos
Aspectos
internos
principios
diseño
Cabecera
IPv4
Cabecera
IPv6
Versión
DS
ECNIHL
Longitud
Identificación
Flags
Desplazamiento
fragmento
Tiempo
vida
Protocolo
Suma
control
cabecera
Dirección
origen
Bit
16
19
31
20
octetos
14
Versión
DS
DS
/H11005
Campo
servicios
diferenciados
ECN
/H11005
Campo
específico
notificación
congestión
Nota
campos
8-bit
DS
ECN
formalmente
conocidos
campo
tipo
servicio
cabecera
IPv4
campo
clase
tráfico
cabecera
IPv6
ECN
Etiqueta
flujo
Longitud
carga
útil
cabecera
Límite
saltos
Dirección
origen
Dirección
destino
Bit
10
12
16
24
31
40
octetos
Dirección
destino
Opciones
relleno
Figura
13.3
Cabeceras
IP
13-Capitulo
13
12/5/05
16:27
Página
602encaminadores
TCP
implementado
sistemas
finales
control
blo-
ques
datos
transferidos
asegurar
envían
forma
fiable
aplicación
apropiada
comunicación
satisfactoria
entidad
sistema
direc-
ción
única
necesitan
niveles
direcciones
máquina
red
direccion
Internet
global
única
permite
datos
entreguen
máquina
apropiada
dirección
utilizada
IP
entrega
aplicación
máquina
dirección
única
máquina
permite
TCP
enviar
datos
proceso
adecuado
últi-
direcciones
conocen
puertos
Hagamos
seguimiento
operación
sencilla
Suponga
proceso
asociado
puerto
máquina
enviar
mensaje
proceso
asociado
puerto
má-
quina
B.
proceso
manda
mensaje
TCP
instrucciones
enviarlo
máquina
puerto
TCP
manda
mensaje
IP
instrucciones
enviarlo
máquina
B.
importante
ob-
servar
necesita
IP
identificación
puerto
destino
necesita
datos
máquina
B.
continuación
IP
manda
mensaje
capa
acce-
so
red
ejemplo
Ethernet
instrucciones
mandarlo
encaminador
salto
camino
controlar
operación
transmitir
información
control
información
usuario
sugiere
Figura
13.5
proceso
emisor
genera
bloque
datos
pasa
TCP
TCP
romper
bloque
piezas
pequeñas
manejable
TCP
aña-
información
control
conocida
cabecera
TCP
Figura
13.2a
piezas
Redes
603
Encaminador
TCP
IP
IP
NAP
NAP
Físico
Físico
Máquina
Apl
Apl
TCP
IP
Protocolo
acceso
red
Apl
Apl
Red
Red
Dirección
Internet
global
12
24
63
Dirección
punto
unión
subred
Conexión
lógica
ejemplo
circuito
vitual
Conexión
lógica
conexión
TCP
Puerto
Máquina
Protocolo
acceso
red
Figura
13.4
Conceptos
TCP
IP
13-Capitulo
13
12/5/05
16:27
Página
603formando
segmento
TCP
información
control
utilizada
protocolo
TCP
corres-
pondiente
entidad
máquina
B.
continuación
TCP
pasa
segmento
IP
instrucciones
transmitirlo
B.
seg-
mentos
transmitir
redes
pasar
encaminadores
intermedios
operación
requiere
información
control
forma
IP
añade
cabecera
información
control
Figura
13.3
segmento
formar
data-
grama
IP
ejemplo
elemento
cabecera
IP
dirección
máquina
destino
ejemplo
datagrama
IP
manda
capa
acceso
red
transmisión
red
viaje
destino
capa
acceso
red
añade
cabecera
creando
paquete
trama
paquete
transmite
red
encaminador
J.
cabecera
paquete
contiene
información
red
necesita
transmitir
datos
Ejemplos
elementos
pue-
den
cabecera
Dirección
red
destino
red
necesita
dispositivo
entregar
paquete
caso
encaminador
J.
Petición
servicios
protocolo
acceso
red
solicitar
servicios
red
prioridad
encaminador
quita
cabecera
paquete
examina
cabecera
IP
Basándose
información
dirección
destino
cabecera
IP
módulo
IP
encaminador
dirige
datagrama
red
B.
añade
datagrama
cabecera
acceso
red
reciben
datos
sucede
proceso
inverso
capa
quita
correspon-
diente
cabecera
resto
pasa
capa
superior
datos
originales
usuario
en-
tregan
proceso
destino
604
Sistemas
operativos
Aspectos
internos
principios
diseño
Datos
usuario
Cabecera
TCP
Cabecera
red
Flujo
datos
aplicación
Segmento
TCP
Datagrama
IP
Paquete
nivel
red
Cabecera
IP
Figura
13.5
Unidades
Datos
Protocolo
PDUs
arquitectura
TCP
IP
13-Capitulo
13
16/5/05
18:10
Página
604APLICACIONES
TCP
IP
diversas
aplicaciones
estandarizadas
TCP
continuación
comentan
comunes
Protocolo
Simple
Transferencia
Correo
Simple
Mail
Transfer
Protocol
SMTP
pro-
porciona
servicio
básico
correo
electrónico
SMTP
proporciona
mecanismo
transmitir
mensajes
máquinas
características
SMTP
listas
correo
confirmaciones
reenvío
protocolo
SMTP
especifica
forma
crear
mensajes
requiere
servicio
edición
correo
electrónico
mensaje
creado
SMTP
acep-
ta
utiliza
TCP
envío
módulo
SMTP
máquina
módulo
SMTP
destino
hará
paquete
correo
electrónico
local
almacenar
mensaje
entrante
buzón
usuario
Protocolo
Transferencia
Ficheros
File
Transfer
Protocol
FTP
utiliza
enviar
ficheros
sistema
petición
usuario
enviar
ficheros
texto
binarios
protocolo
proporciona
características
control
acceso
usuarios
usuario
transferencia
fichero
FTP
establece
conexión
TCP
sis-
tema
destino
intercambio
mensajes
control
conexión
permite
enviar
identificado-
res
usuario
claves
permite
usuario
especificar
fichero
acciones
deseadas
aprobado
transferencia
ficheros
establece
conexión
TCP
envío
datos
fichero
transmite
conexión
sobrecarga
cabece-
ra
información
control
nivel
aplicación
completa
transferencia
conexión
control
indicar
finalización
aceptar
mandatos
transferencia
ficheros
TELNET
proporciona
servicio
inicio
sesión
remoto
permite
usuario
terminal
computador
personal
iniciar
sesión
computador
remoto
trabajar
estu-
viera
conectado
computador
protocolo
diseñó
trabajar
terminales
scroll
sencillo
actualidad
TELNET
implementado
módulos
TELNET
Usuario
inte-
ractúa
módulo
terminal
comunicarse
terminal
local
Convierte
ca-
racterísticas
terminal
estándar
red
viceversa
TELNET
Servidor
interactúa
aplica-
ción
actuando
manejador
terminal
sucedáneo
forma
terminales
remotos
parecen
locales
aplicación
tráfico
terminal
TELNET
Usuario
Servidor
realiza
conexión
TCP
13.3
SOCKETS
concepto
socket
programación
sockets
desarrolló
años
ochenta
entorno
UNIX
Interfaz
Sockets
Berkeley
Berkeley
Sockets
Interface
esencia
socket
permite
comunicación
proceso
cliente
proceso
servidor
orientado
cone-
xión
orientado
conexión
socket
considerar
punto
comunica-
ción
socket
cliente
computador
utiliza
dirección
llamar
socket
servidor
computador
entrado
comunicación
sockets
computadores
intercambiar
datos
Normalmente
computadores
servidores
basados
sockets
mantienen
abierto
puer-
to
TCP
UDP
preparado
llamadas
entrantes
planificadas
cliente
suele
determinar
identificación
socket
servidor
deseado
buscando
base
datos
Sistema
Nom-
bres
Dominio
Domain
Name
System
DNS
realiza
conexión
servidor
re-
dirije
diálogo
puerto
liberar
número
puerto
principal
llama-
das
entrantes
Redes
605
13-Capitulo
13
12/5/05
16:27
Página
605Aplicaciones
Internet
tales
TELNET
rlogin
inicio
sesión
remoto
sockets
ocultando
detalles
usuario
utilizar
sockets
pro-
grama
lenguajes
Java
permitiendo
programador
soportar
forma
fácil
funciones
aplicaciones
red
mecanismo
programación
sockets
incluye
semántica
suficiente
per-
mitir
procesos
relacionados
máquinas
puedan
comunicar
Berkeley
Sockets
Interface
API
Interfaz
Programación
Aplicaciones
estándar
desarrollo
aplicaciones
red
amplio
rango
sistemas
operativos
Windows
Sockets
WinSock
basado
especificación
Berkeley
API
sockets
proporciona
acceso
ge-
nérico
servicios
comunicación
procesos
forma
sockets
ideales
estudiantes
aprendan
principios
protocolos
aplicaciones
distribuidas
desarrollo
programas
SOCKET
Recordar
cabecera
TCP
UDP
incluye
campos
puerto
origen
puerto
destino
Figu-
ra
13.2
valores
puerto
identifican
respectivos
usuarios
aplicaciones
enti-
dades
TCP
cabecera
IPv4
IPv6
incluye
campos
direcciones
origen
des-
tino
Figura
13.3
direcciones
IP
identifican
respectivos
sistemas
concatenación
valor
puerto
dirección
IP
forma
socket
único
Internet
forma
Figura
13.4
combinación
direcciones
IP
máquina
número
puerto
aplica-
ción
identifican
forma
única
localización
socket
aplicación
máquina
B.
indica
figura
aplicación
múltiples
direcciones
sockets
puerto
aplicación
socket
utiliza
definir
interfaz
programación
aplicaciones
API
interfaz
genérica
comunicaciones
escribir
programas
TCP
UDP
práctica
API
socket
identifica
triplete
protocolo
dirección
local
proce-
so
local
dirección
local
dirección
IP
proceso
local
número
puerto
número
puertos
únicos
sistema
número
puerto
implica
protocolo
TCP
UDP
claridad
facilidad
implementación
sockets
utilizados
API
in-
cluyen
protocolo
dirección
IP
número
puerto
definir
socket
Correspondiéndose
protocolos
API
Sockets
reconoce
tipos
sockets
soc-
kets
stream
sockets
datagrama
socket
stream
TCP
proporcionan
transfe-
rencia
datos
fiable
orientada
conexión
sockets
stream
garantiza
bloques
datos
enviados
par
sockets
llegan
orden
enviaron
sockets
datagrama
UDP
proporciona
características
orientadas
conexión
TCP
sockets
datagrama
garantiza
entrega
mantenga
orden
tercer
tipo
sockets
proporcionados
API
Sockets
sockets
raw
sockets
raw
permiten
acceso
directo
capas
bajas
protocolo
tales
IP
LLAMADAS
INTERFAZ
SOCKET
subsección
resume
principales
llamadas
sistema
Configuración
socket
paso
utilización
Socket
crear
socket
utilizando
mandato
socket
mandato
incluye
parámetros
familia
protocolo
PF_INET
protocolos
TCP
IP
Tipo
especifica
socket
stream
datagrama
protocolo
especifica
TCP
UDP
razón
especificar
tipo
proto-
606
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
606colo
permitir
protocolos
nivel
transporte
futuras
implementaciones
forma
protocolo
transporte
tipo
datagrama
protocolo
transporte
orientado
conexión
comando
socket
devuelve
valor
entero
identifica
socket
similar
descriptor
fichero
UNIX
estructura
datos
sockets
depende
implementación
Incluye
puerto
dirección
IP
origen
conexión
abierta
pen-
diente
puerto
dirección
IP
destino
opciones
parámetros
asociados
conexión
cree
socket
asignar
dirección
escuchar
función
bind()enlaza
socket
dirección
socket
dirección
estructura
struct
sockaddr_in
short
int
sin_family
Familia
direcciones
TCP
IP
unsigned
short
int
sin_port
Número
puerto
struct
in_addr
sin_addr
Dirección
Internet
unsigned
char
sin_zero[8
tamaño
struct
sockaddr
Conexión
socket
socket
stream
creado
establecer
conexión
socket
remoto
funciona
cliente
solicita
conexión
actúa
servidor
configuración
servidora
conexión
requiere
pasos
aplicación
servidora
realiza
listen
indicar
determinado
socket
listo
aceptar
cone-
xiones
entrantes
parámetro
backlog
número
conexiones
permitidas
cola
entrada
conexiones
llega
sitúa
cola
servidor
realiza
accept
accept
utiliza
extraer
solicitud
cola
cola
vacia
llamada
accept
bloquea
proceso
llega
petición
conexión
llamada
esperando
accept()devuelve
descriptor
fichero
conexión
crea
nue-
vo
socket
dirección
IP
número
puerto
remota
dirección
IP
sistema
número
puerto
razón
asigne
socket
número
puerto
permitir
aplicación
local
seguir
escuchando
peticiones
resultado
aplicación
múltiples
conexiones
activas
tiempo
nú-
mero
puerto
local
número
puerto
devuelve
sistema
petición
conexión
TCP
aplicación
cliente
realiza
connect(),que
especifica
socket
local
direc-
ción
socket
remoto
intento
conexión
satisfactorio
llamada
devuelve
intento
satisfactorio
llamada
devuelvo
rellena
parámetro
descripción
conexión
incluir
dirección
IP
número
puerto
sockets
local
remoto
Recuerde
nú-
mero
puerto
remoto
especificado
parámetro
foreignAddress
número
puerto
cambia
máquina
remota
conexión
establecida
utilizar
getpeername
averiguar
extremo
socket
función
devuelve
valor
parámetro
sockfd
Comunicación
Socket
conexión
stream
utilizan
llamadas
send
recv
enviar
recibir
datos
conexión
identificada
parámetro
sockfd
llamada
send
parámetro
msg
apunta
bloque
datos
enviado
parámetro
len
especifica
número
bytes
enviar
parámetro
flags
contiene
flags
control
normalmente
deja
valor
llamada
send
devuelve
número
bytes
enviados
menor
Redes
607
13-Capitulo
13
12/5/05
16:27
Página
607número
especificado
parámetro
len
llamada
recv
parámetro
buf
apunta
buffer
almacenar
datos
entrantes
número
máximo
bytes
establecido
pará-
metro
len
momento
cualquiera
partes
cerrar
conexión
llamada
clo-
se(),que
evita
envíos
recepciones
llamada
shutdown()permite
llamante
dejar
en-
viar
recibir
Figura
13.6
muestra
interacción
partes
cliente
servidora
establecimiento
finalización
conexión
comunicaciones
datagrama
utilizan
funciones
sendto
recvfrom
lla-
mada
sendto
incluye
parámetros
llamada
send(),pero
especifica
di-
608
Sistemas
operativos
Aspectos
internos
principios
diseño
socket
bind
listen
accept
bloquea
conectarse
cliente
accept
crea
socket
atender
solicitud
cliente
socket
connect
send()receive
procesar
solicitud
establecimiento
conexión
Abrir
punto
comunicación
Abrir
punto
comunicación
Establecer
conexión
servidor
Enviar
recibir
datos
Desconectar
Registrar
dirección
conocida
well-known
sistema
Establecer
conexión
cliente
solicitar
tamaño
dela
cola
Aceptar
solicitud
cliente
cola
datos
respuestas
send
close
receive
close
Enviar
recibir
datos
datos
solicitud
Figura
13.6
Llamadas
sistema
sockets
protocolo
orientado
conexión
13-Capitulo
13
12/5/05
16:27
Página
608rección
destino
dirección
IP
puerto
forma
similar
llamada
recvfrom
incluye
pa-
rámetro
dirección
rellena
reciben
datos
13.4
REDES
LINUX
Linux
soporta
diversas
arquitecturas
red
particular
TCP
IP
Berkeley
Sockets
Figura
13.7
muestra
estructura
general
soporte
Linux
TCP
IP
procesos
nivel
usuario
interactúan
dispositivos
red
llamadas
sistema
Interfaz
soc-
kets
módulo
sockets
interactúa
paquete
software
núcleo
encarga
operaciones
capa
transporte
TCP
UDP
protocolo
IP
paquete
software
in-
tercambia
datos
manejador
dispositivo
tarjeta
interfaz
red
Redes
609
Nivel
socket
Controlador
interfaz
red
Proceso
usuario
Hardware
Nivel
usuarioNúcleo
Manejador
dispositivo
red
Procesamiento
IP
Recepción
paquete
nivel
inferior
Recepción
paquete
aplazada
Interrupción
dispositivo
hardware
netif_rx
softirq
net_rx_action
ip_rcv
udp_rcv
data_ready
wake_up_interruptible
tcp_rcv
data_ready
tcp_sendmsg
ip_build_xmit
ip_build_xmit
dev_queue_xmit
Mandato
envío
udp_sendmsg
Llamada
sistema
socket
Procesamiento
TCP
Procesamiento
UDP
Figura
13.7
Componentes
núcleo
Linux
procesamiento
TCP
IP
13-Capitulo
13
12/5/05
16:27
Página
609Linux
implementa
sockets
ficheros
especiales
Recuerde
Sección
12.7
sis-
temas
UNIX
fichero
especial
contiene
datos
proporciona
mecanismo
asociar
dis-
positivos
físicos
nombres
fichero
socket
núcleo
Linux
crea
nodo-i
sistema
ficheros
especial
sockfs
Figura
13.7
representa
relaciones
diversos
módulos
núcleo
involucrados
en-
vío
recepción
bloques
datos
basado
TCP
IP
restante
sección
analiza
servicios
envío
recepción
ENVÍO
DATOS
proceso
usuario
utiliza
llamadas
sockets
descritas
Sección
13.3
crear
soc-
kets
establecer
conexiones
sockets
remotos
enviar
recibir
datos
enviar
datos
proceso
usuario
escribe
datos
socket
llamada
sistema
ficheros
write(sockfd
mesg
mesglen
mesglenes
longitud
bytes
buffer
mesg
llamada
activa
método
write
objeto
fichero
asociado
descriptor
fichero
sockfd
descriptor
fichero
indica
socket
TCP
UDP
núcleo
asigna
estructuras
datos
necesarias
invoca
funciones
nivel
socket
apropiadas
pasar
datos
mó-
dulo
TCP
módulo
UDP
funciones
correspondientes
tcp_sendmsg
udp_sendmsg(),respectivamente
módulo
nivel
transporte
crea
estructura
datos
cabecera
TCP
UDP
llama
ip_build_xmit
invocar
módulo
procesamiento
capa
IP
módulo
crea
datagrama
IP
transmisión
sitúa
buffer
transmisión
socket
continuación
módulo
capa
IP
llama
dev_queue_xmit(),que
encola
buf-
fer
socket
transmisión
manejador
dispositivo
red
disponi-
ble
manejador
dispositivo
red
transmitirá
paquetes
buffer
RECEPCIÓN
DATOS
recepción
datos
evento
impredecible
utilizar
interrupciones
llega
datagrama
IP
controlador
interfaz
red
manda
interrupción
hardware
maneja-
dor
dispositivo
red
interrupción
activa
rutina
servicio
interrupción
maneja
interrupción
manejador
crea
buffer
núcleo
bloque
datos
entrante
transfiere
datos
controlador
dispositivo
buffer
controlador
llama
netif_rx()para
in-
vocar
rutina
recepción
paquetes
esencia
función
netif_rx
sitúa
bloque
datos
entrante
cola
continuación
emite
petición
interrupción
software
softirq
forma
datos
encolados
finalmente
procesarán
acción
cabo
cuan-
do
procesa
softirqes
función
net_rx_action
metido
cola
softirq
procesamiento
paquete
detiene
núcleo
ejecuta
función
softirq
equivalente
núcleo
res-
ponda
petición
interrupción
software
ejecute
función
caso
net_rx_action
asociada
interrupción
sotfware
lugares
núcleo
núcleo
verificar
softirqpendiente
procesado
interrupción
hardware
proceso
nivel
aplicación
invoca
llamada
sistema
pla-
nifica
ejecución
proceso
610
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
610Cuando
realiza
función
net_rx_action
recoge
paquete
datos
pasa
manejador
paquetes
IP
llamada
ip_rcv
manejador
paquetes
IP
procesa
cabe-
cera
IP
continuación
utiliza
tcp_rcv
udp_rcv
invocar
módulo
procesamiento
capa
transporte
módulo
capa
transporte
procesa
cabecera
capa
transporte
pasa
datos
usuario
interfaz
Sockets
llamada
wake_up_inte-
rruptible
despierta
proceso
receptor
13.5
RESUMEN
funcionalidad
comunicaciones
necesitan
aplicaciones
distribuidas
com-
pleja
funcionalidad
generalmente
implementa
conjunto
estructurado
módulos
módulos
disponen
capas
situadas
forma
vertical
capa
proporciona
funcionalidad
necesaria
depende
capa
inferior
estructura
conoce
arquitectura
comunicaciones
motivación
tipo
estructura
facilita
tarea
diseño
imple-
mentación
paquete
software
práctica
estándar
dividir
funciona-
lidad
módulos
diseñar
implementar
forma
separada
diseñar
implementar
módulo
probar
continuación
módulos
unir
probar
conjunto
motivación
llevado
vendedores
computadores
desarrollar
arquitec-
turas
protocolos
capas
propietarios
ejemplo
Systems
Network
Architecture
SNA
IBM
utilizar
arquitecura
capas
construir
conjunto
protocolos
comunicación
estándar
caso
mantienen
ventajas
diseño
modular
desa-
rrollar
forma
simultánea
estándares
protocolos
capa
arquitectura
divide
trabajo
manejable
mejora
velocidad
proceso
desarrollo
arquitectura
protocolos
TCP
IP
arquitectura
estándar
utilizada
propósito
arquitectura
contiene
capas
capa
proporciona
porción
funciones
requeridas
aplicaciones
distribuidas
trabajo
desarrollo
continúa
especialmente
capa
aplicación
definiendo
aplicaciones
distribuidas
13.6
LECTURAS
SITIOS
WEB
RECOMENDADOS
STAL04
proporciona
descripción
detallada
modelo
TCP
IP
estándares
capa
modelo
RODR02
referencia
útil
TCP
IP
cubre
espectro
protocolos
relacionados
TCP
IP
forma
concisa
DONA01
presenta
excelente
introducción
sockets
introducción
HALL01
MCKU96
WRIG95
proporcionan
detalles
implementación
sockets
BOVE03
cubre
redes
Linux
fuentes
interesantes
INSO02a
INSO02b
BOVE03
Bovet
D.
Cesati
M.
Understanding
the
Linux
Kernel
Sebastopol
CA
O’Reilly
2003
DONA01
Donahoo
M.
Clavert
K.
The
Pocket
Guide
to
TCP
IP
Sockets
San
Francisco
CA
Morgan
Kaufmann
2001
HALL01
Hall
B.
Beej’s
Guide
to
Network
Programming
Using
Internet
Sockets
2001
http://www.ecst.csuchico.edu/~beej/guide/net/html/
Redes
611
13-Capitulo
13
12/5/05
16:27
Página
611INSO02a
Insolvibile
G.
Inside
the
Linux
Packet
Filter
Linux
Journal
Febrero
2002
INSO02b
Insolvibile
G.«Inside
the
Linux
Packet
Filter
Part
II
Linux
Journal
Marzo
2002
MCKU96
McKusick
M.
Bostic
K.
Karels
M.
Quartermain
J.
The
Design
and
Implementation
of
the
4.4BSD
UNIX
Operating
System
Reading
MA
Addison-Wesley
1996
RODR02
Rodriguez
A.
et
TCP
IP
Tutorial
and
Technical
Overview
Upper
Saddle
River
NJ
Prentice
Hall
2002
STAL04
Stallings
W.
Computer
Networking
with
Internet
Protocols
and
Technology
Upper
Saddle
Ri-
NJ
Prentice
Hall
2004
WRIG95
Wright
G.
Stevens
W.
TCP
IP
Illustrated
Volume
The
Implementation
Reading
MA
Addi-
son-Wesley
1995
SITIOS
WEB
RECOMENDADOS
Networking
Links
excelente
colección
enlaces
relativos
TCP
IP
IPng
Información
IPv6
temas
relacionados
13.7
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
arquitectura
protocolos
Protocolo
Internet
IP
sockets
datagrama
Interfaz
Programación
Protocolo
Transferencia
sockets
raw
Aplicaciones
API
Ficheros
FTP
sockets
stream
protocolo
Protocolo
Simple
TELNET
Protocolo
Control
Transferencia
Correo
SMTP
Transmisión
TCP
puerto
Protocolo
Datagramas
sockets
Usuario
UDP
CUESTIONES
REPASO
13.1
función
principal
capa
acceso
red
13.2
tareas
realizan
capa
transporte
13.3
protocolo
13.4
arquitectura
protocolos
13.5
TCP
IP
13.6
propósito
interfaz
sockets
PROBLEMAS
13.1
ministros
francés
chino
necesitan
llegar
teléfono
idioma
mano
traductor
pue-
612
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
612da
traducir
idioma
ministros
traducto-
res
inglés
personal
Dibuje
diagrama
similar
Figura
13.8
descri-
bir
situación
describa
interacción
capa
suponga
traductor
ministro
chino
traducir
japo-
nés
ministro
francés
traductor
alemán
disponible
dispo-
ne
traductor
alemán
japonés
Alemania
Dibuje
diagrama
refleje
situación
describa
hipotética
conversación
teléfono
13.2
Enumere
principales
desventajas
capas
protocolos
13.3
segmento
TCP
1500
bits
datos
160
bits
cabecera
manda
capa
IP
añade
160
bits
cabecera
segmento
transmite
redes
cabecera
paquete
24
bits
red
destino
tie-
ne
tamaño
máximo
paquete
800
bits
bits
incluyendo
cabeceras
en-
tregan
protocolo
capa
red
destino
13.4
cabecera
TCP
campo
longitud
cabecera
cabecera
UDP
13.5
versión
previa
especificación
TFTP
RFC
783
incluía
sentencia
paquetes
utilizados
finalización
confirmados
individualmente
suceda
tiempo
timeout
especificación
revisada
paquetes
duplicados
ACK
utilizados
finalización
con-
firmados
individualmente
suceda
tiempo
timeout
cambio
arreglar
problema
conocido
Aprendiz
Brujo
Deduzca
explique
problema
13.6
factor
restrictivo
tiempo
requerido
transferir
fichero
utilizando
TFTP
13.7
capítulo
menciona
Frame
Relay
protocolo
sistema
específico
utilizado
conectarse
red
área
extensa
organización
colec-
ción
servicios
disponibles
Frame
Relay
ésto
depende
proveedor
cos-
equipamiento
cliente
servicios
disponibles
área
reside
lector
Redes
613
Invitado
Máquina
Teléfono
Cocinero
pizza
Línea
telefónica
Furgonta
reparto
Carretera
Invitado
Máquina
Empleado
pedidos
Teléfono
Furgonta
reparto
Cocinero
pizza
Empleado
pedidos
Figura
13.8
Arquitectura
Problema
13.1
13-Capitulo
13
12/5/05
16:27
Página
61313.8
Ethereal
paquete
sniffer
gratuito
permite
capturar
tráfico
red
área
local
utilizar
variedad
sistemas
operativos
disponible
www.ethereal.com
instalar
manejador
captura
paquetes
WinP-
cap
obtener
http://winpcap.mirror.ethereal.com/.
comenzar
captura
Ethereal
arranque
aplicación
basada
TCP
telnet
FTP
http
navegador
Web
información
captura
Direcciones
origen
destino
capa
MAC
Direcciones
origen
destino
capa
IP
Direcciones
origen
destino
capa
número
puertos
13.9
aplicación
captura
paquetes
sniffer
potente
herramienta
ges-
tión
seguridad
Utilizando
función
filtrado
preconstruida
segui-
miento
tráfico
basándose
criterios
eliminando
resto
Utilice
capaci-
dad
filtrado
Ethereal
Capturar
tráfico
entrante
dirección
MAC
computador
Capturar
tráfico
entrante
dirección
IP
computador
Capturar
transmisiones
basadas
UDP
APÉNDICE
13A
PROTOCOLO
SIMPLE
TRANSFERENCIA
FICHEROS
apéndice
contiene
visión
general
estándar
Internet
Protocolo
Simple
Transferencia
Ficheros
TFTP
propósito
lector
idea
elementos
protocolo
INTRODUCCIÓN
TFTP
TFTP
sencillo
Protocolo
Transferencia
Ficheros
FTP
estándar
proporciona
control
acceso
identificación
usuario
TFTP
adecuado
fi-
cheros
acceso
público
ejemplo
dispositivos
disco
utilizan
TFTP
descargar
firmware
inicio
TFTP
ejecuta
UDP
entidad
TFTP
inicia
transferencia
enviando
solici-
tud
lectura
escritura
segmento
UDP
puerto
destino
69
sistema
destino
módulo
UPD
destino
reconoce
puerto
identificador
módulo
TFTP
transferencia
utiliza
identificador
transferencia
TID
número
puerto
PAQUETES
TFTP
entidades
TFTP
intercambian
mandatos
respuestas
ficheros
datos
forma
paquetes
transporta
cuerpo
segmento
UDP
TFTP
soporta
tipos
paquetes
Figura
13.9
bytes
contienen
código
operación
codOp
identi-
fica
tipo
paquete
RRQ
paquete
solicitud
lectura
solicita
permiso
transferir
fichero
sistema
paquete
incluye
nombre
fichero
secuencia
bytes
614
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
614ASCII1
finalizado
byte
cero
byte
cero
forma
entidad
TFTP
receptora
termina
nombre
fichero
paquete
incluye
campo
indica
fichero
datos
interpreta
cadena
bytes
ASCII
bytes
8-bits
datos
WRQ
paquete
solicitud
escritura
solicita
permiso
transferir
fichero
sistema
Data
número
bloque
paquetes
datos
comienza
incrementa
bloque
datos
convención
permite
programa
utilizar
único
número
discriminar
paquetes
duplicados
campo
datos
longitud
512
bytes
512
bytes
longitud
bloque
bloque
datos
longitud
511
bytes
indica
transferencia
ACK
paquete
utiliza
confirmación
paquete
datos
paquete
WRQ
ACK
paquete
datos
contiene
número
bloque
paquete
datos
confirma
ACK
WRQ
contiene
cero
número
bloque
Error
paquete
error
confirmación
tipo
paquete
có-
digo
error
número
entero
indica
naturaleza
error
Tabla
13.1
mensaje
Redes
615
ASCII
American
Standard
Code
for
Information
Interchange
estándar
American
National
Standards
Institute
Designa
patrón
único
7-bits
letra
octavo
bit
utilizado
paridad
ASCII
equivalente
International
Re-
ference
Alphabet
IRA
definido
ITU-T
Recommendation
T.50
sitio
web
libro
descripción
ta-
bla
código
IRA
Paquetes
RRQ
WRQ
Paquete
datos
bytes
bytes
bytes
byte
Modo0
0Nombre
ficheroCodOp
Número
bloque
bytes
bytes
bytes
bytes
byte
MsgErr
bytes
Código
error
to
512
bytes
byten
bytes
bytes
Paquete
ACK
Paquete
error
CodOp
CodOp
CodOp
Número
bloque
CodOp
Figura
13.9
Formatos
paquetes
TFTP
13-Capitulo
13
12/5/05
16:27
Página
615de
error
comprensible
ASCII
cadenas
finaliza
byte
cero
abla
13.1
Códigos
error
TFTP
Valor
Significado
definido
mensaje
error
Fichero
encontrado
Violación
acceso
Disco
lleno
ubicación
excedida
Operación
TFTP
ilegal
ID
transferencia
desconocido
Fichero
usuario
paquetes
duplicados
ACK
explicado
utilizan
finalización
confirmados
paquete
confirmar
paquete
error
errores
convención
WRQ
paquete
datos
confirma
paquete
ACK
envía
RRQ
responde
ausencia
error
comen-
616
Sistemas
operativos
Aspectos
internos
principios
diseño
Versión
IHL
DS
Longitud
Identificación
Flags
Desplazamiento
fragmento
Tiempo
vida
Protocolo
Suma
control
cabecera
Dirección
origen
Dirección
destino
Puerto
origen
Puerto
destino
69
Datos
TFTP
ECN
Longitud
segmento
Suma
control
Cabecera
IP
Cabecera
UDP
Cabecera
TFTPCodOp
Número
bloques
Paquete
TFTP
Segmento
UDP
Datagrama
IP
Figura
13.10
paquete
TFTP
contexto
13-Capitulo
13
12/5/05
16:27
Página
616zando
enviar
fichero
forma
bloque
datos
sirve
confirmación
pa-
quete
RRQ
complete
transferencia
fichero
paquete
ACK
paquete
datos
forma
paquetes
datos
funcionan
confirmaciones
paquete
error
confirmar
tipo
paquete
depen-
diendo
circunstancias
Figura
13.10
muestra
paquete
datos
TFTP
contexto
paquete
pasa
UDP
UDP
añade
cabecera
formar
segmento
UDP
segmento
pasa
IP
añade
cabecera
IP
formar
datagrama
IP
VISIÓN
GENERAL
TRANSFERENCIA
ejemplo
mostrado
Figura
13.11
operación
transferencia
fichero
B.
sucede
error
detallan
opciones
Redes
617
AB
Tiempo
WRQ
file
XXX
mode
octet
src
1511
dst
69
ACK(Block
src
1660
dst
1511
A(Block
src
1511
dst
1660
ACK(Block
src
1660
dst
1511
A(Block
src
1511
dst
1660
ACK(Block
src
1660
dst
1511
Figura
13.11
Ejemplo
funcionamiento
TFTP
13-Capitulo
13
12/5/05
16:27
Página
617La
operación
comienza
módulo
TFTP
sistema
envía
petición
escritura
WRQ
módulo
TFTP
sistema
B.
paquete
WRQ
transfiere
cuerpo
segmento
UDP
solicitud
escritura
incluye
nombre
fichero
caso
XXX
octet
datos
raw
cabecera
UDP
número
puerto
destino
69
entidad
UDP
receptora
mensaje
aplicación
TFTP
número
puerto
origen
TID
seleccionado
caso
1511
sistema
preparado
aceptar
fichero
responde
ACK
número
bloque
cabecera
UDP
puerto
destino
1511
permite
entidad
pasar
paquetes
entrantes
módulo
TFTP
emparejar
TID
TID
WRQ
puerto
origen
TID
seleccionado
transferencia
ficheros
caso
1660
Continuando
intercambio
inicial
transcurre
transferencia
fichero
transferencia
con-
siste
paquetes
confirma
B.
paquete
datos
contiene
512
bytes
marca
transferencia
ERRORES
RETRASOS
TFTP
funciona
red
Internet
oposición
enlace
directo
datos
pierdan
paquetes
TFTP
funciona
UDP
proporciona
servicio
fiable
nece-
sita
mecanismo
TFTP
tratar
paquetes
perdidos
TFTP
mecanismo
co-
mún
timeout
tiempo
Suponga
envía
paquete
requiere
confirmación
ejemplo
paquete
ACK
duplicado
utilizados
finalización
transmitido
paquete
inicia
temporizador
temporizador
expira
recibir
confirmación
retransmite
paquete
realmente
perdido
paquete
ini-
cial
retransmisión
copia
paquete
recibido
B.
perdió
paquete
original
perdió
confirmación
recibirá
copias
paquete
simplemente
confirma
ambas
copias
números
bloque
causa
ningu-
na
confusión
única
excepción
regla
paquetes
ACK
duplicados
ACK
ignora
SINTAXIS
SEMÁNTICA
TEMPORIZACIÓN
Sección
5.1
características
principales
protocolo
clasifi-
car
sintaxis
semántica
temporización
categorías
ven
fácilmente
TFTP
for-
matos
paquetes
TFTP
determinan
sintaxis
protocolo
semántica
protocolo
muestra
definiciones
tipo
paquete
códigos
error
finalizar
secuencia
intercambian
paquetes
números
bloque
temporizadores
aspectos
temporización
TFTP
618
Sistemas
operativos
Aspectos
internos
principios
diseño
13-Capitulo
13
12/5/05
16:27
Página
618CAPÍTULO
14
Procesamiento
distribuido
cliente
servidor
clusters
14.1
Computación
cliente
servidor
14.2
Paso
mensajes
distribuido
14.3
Llamadas
procedimiento
remoto
14.4
Clusters
14.5
Servidor
Clusters
Windows
14.6
Sun
Clusters
14.7
Clusters
Beowulf
Linux
14.8
Resumen
14.9
Lecturas
recomendadas
sitios
web
14.10
érminos
clave
cuestiones
repaso
problemas
14-Capitulo
14
12/5/05
16:28
Página
619N
capítulo
comienza
examinando
conceptos
básicos
software
distribuido
inclu-
yendo
arquitectura
cliente
servidor
paso
mensajes
llamadas
procedimiento
remoto
examina
importante
arquitectura
cluster
14.1
COMPUTACIÓN
CLIENTE
SERVIDOR
concepto
computación
cliente
servidor
conceptos
relacionados
teniendo
importancia
sistemas
tecnología
información
sección
comienza
descripción
general
arquitectura
cliente
servidor
continuación
discuten
formas
alterna-
tivas
organizar
funciones
cliente
servidor
continúa
examinando
consistencia
cache
ficheros
servidores
fichero
introduce
concepto
middleware
COMPUTACIÓN
CLIENTE
SERVIDOR
tendencia
campo
computación
computación
cliente
servidor
jerga
Tabla
14.1
enumera
términos
comúnmente
utilizados
des-
cripción
productos
aplicaciones
cliente
servidor
Figura
14.1
intenta
mostrar
esencia
concepto
cliente
servidor
término
sugiere
entorno
cliente
servidor
formado
clientes
servidores
máquinas
cliente
normalmente
simples
PCs
estaciones
trabajo
proporcionan
interfaz
fácil
manejo
usuario
estaciones
cliente
suelen
utilizar
interfaz
gráfica
cómoda
usuarios
incluyen
ventanas
ratón
ejemplos
interfaces
siste-
operativos
Microsoft
Windows
Macintosh
aplicaciones
basadas
cliente
diseña-
das
fáciles
incluyen
aplicaciones
familiares
hoja
cálculo
abla
14.1
Terminología
cliente
servidor
Interfaz
programación
aplicaciones
API
conjunto
funciones
programas
permiten
clientes
servidores
intercomunicarse
Cliente
elemento
red
solicita
información
normalmente
PC
estación
trabajo
interrogar
base
datos
solicitar
información
servidor
Middleware
conjunto
controladores
API
software
adicional
mejoran
conectividad
aplicación
cliente
servidor
Base
datos
relacional
base
datos
acceso
información
restringido
selección
filas
satisfacen
criterios
búsqueda
Servidor
computador
normalmente
estación
trabajo
potencia
minicomputador
mainframe
almacena
información
clientes
red
Lenguaje
Estructurado
Consultas
SQL
Lenguaje
desarrollado
IBM
estandarizado
ANSI
permite
acceder
crear
actualizar
interrogar
bases
datos
relacionales
620
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
620Cada
servidor
entorno
cliente
servidor
proporciona
conjunto
servicios
compartidos
clientes
tipo
común
servidor
servidor
base
datos
normalmente
con-
trola
base
datos
relacional
servidor
permite
clientes
compartir
acceso
base
datos
permite
sistemas
computación
alto
rendimiento
gestionar
base
datos
clientes
servidores
tercer
elemento
esencial
entorno
cliente
servidor
red
computación
cliente
servidor
normalmente
computación
distribuida
usuarios
aplicaciones
recursos
distribuyen
respuesta
requisitos
trabajo
unen
LAN
WAN
Internet
diferencia
configuración
cliente
servidor
soluciones
procesamiento
dis-
tribuido
serie
características
juntas
diferencian
filosofía
cliente
servidor
tipos
procesamiento
distribuido
imperativo
usuarios
tengan
aplicaciones
fácil
manejo
sistemas
pro-
porciona
usuario
control
computadora
gestores
de-
partamento
capacidad
responder
necesidades
locales
aplicaciones
dispersas
realiza
esfuerzo
centralizar
bases
datos
corporativas
funciones
utilidad
gestión
redes
permite
gestores
empresa
controlar
capital
invertido
computación
sistemas
informa-
ción
permite
interoperabilidad
forma
unen
sistemas
tiempo
Procesamiento
distribuido
cliente
servidor
clusters
621
LAN
WAN
Internet
Estación
trabajo
cliente
Servidor
Figura
14.1
Entorno
genérico
cliente
servidor
14-Capitulo
14
12/5/05
16:28
Página
621descarga
departamentos
sucursales
trabajo
mantener
sofistica-
sistemas
permite
decidir
interfaz
máquina
utilizar
acceder
sistemas
compromiso
organizaciones
usuarios
vendedores
mantener
sistema
abierto
modular
significa
usuario
libertad
seleccionar
productos
combinar
equipos
vendedores
red
fundamental
forma
gestión
seguridad
red
prioridad
alta
organización
funcionamiento
sistemas
información
APLICACIONES
CLIENTE
SERVIDOR
característica
fundamental
arquitectura
cliente
servidor
distribución
tareas
aplicación
cliente
servidor
Figura
14.2
muestra
caso
general
cliente
servidor
software
básico
sistema
operativo
ejecuta
hardware
plataforma
plataforma
sistema
operativo
cliente
servidor
existir
plataformas
clientes
sistemas
operativos
dife-
rentes
plataformas
servidor
entorno
clientes
servidores
com-
partan
protocolos
comunicación
soporten
aplicaciones
diferencias
nivel
relevantes
permite
interactúen
cliente
servidor
software
comunicaciones
prin-
cipal
ejemplo
software
TCP
IP
objetivo
software
soporte
comunicaciones
sistema
operativo
proporcionar
bases
aplicaciones
distribuidas
forma
ideal
funciones
realiza
aplicación
dividir
cliente
servidor
optimice
recursos
casos
dependiendo
necesidades
aplicación
software
aplicación
ejecuta
servidor
casos
lógica
aplicación
situada
cliente
factor
esencial
éxito
entorno
cliente
servidor
forma
usuario
interac-
túa
sistema
forma
decisivo
diseño
interfaz
usuario
máquina
clien-
sistemas
cliente
servidor
énfasis
proporcionar
in-
terfaz
gráfica
usuario
GUI
fácil
fácil
aprender
potente
622
Sistemas
operativos
Aspectos
internos
principios
diseño
Sistema
operativo
servidor
Servicios
presentación
Lógica
aplicación
cliente
Software
comunicaciones
Sistema
operativo
cliente
Plataforma
hardware
Estación
trabajo
cliente
Lógica
aplicación
servidor
Servidor
Petición
Respuesta
Interacción
protocolo
Software
comunicaciones
Plataforma
hardware
Figura
14.2
Arquitectura
genérica
cliente
servidor
14-Capitulo
14
12/5/05
16:28
Página
622flexible
forma
pensar
módulo
servicios
presentación
cliente
responsable
proporcionar
interfaz
fácil
manejo
aplicaciones
distribui-
das
disponibles
entorno
Aplicaciones
base
datos
mostrar
concepto
distribuir
lógica
aplicación
en-
tre
cliente
servidor
tomaremos
ejemplo
familias
comunes
aplicacio-
nes
cliente
servidor
bases
datos
relacionales
entorno
servidor
básicamente
servidor
base
datos
interacción
cliente
servidor
realiza
tra-
vés
transacciones
cliente
realiza
petición
base
datos
recibe
respuesta
Figura
14.3
muestra
términos
generales
arquitectura
sistema
servidor
res-
ponsable
mantenimiento
base
datos
requiere
complejo
sistema
gestor
base
datos
máquinas
clientes
situar
aplicaciones
base
datos
pegamento
une
cliente
servidor
software
permite
cliente
haga
peticiones
acceder
servidor
base
datos
ejemplo
popular
lenguaje
estructurado
consultas
SQL
Figura
14.3
sugiere
lógica
aplicación
-el
software
análisis
datos-
cliente
servidor
preocupa
gestión
base
datos
configuración
apropiada
depende
estilo
propósito
aplicación
ejemplo
suponga
propósito
general
proporcionar
acceso
on-line
búsqueda
registros
Fi-
gura
14.4a
sugiere
funcionar
Suponga
servidor
manteniendo
base
da-
tos
millón
registros
denominados
filas
terminología
bases
datos
relacionales
cliente
búsqueda
devolverá
cero
registros
usuario
buscar
registros
utilizando
serie
criterios
búsqueda
ejemplo
re-
gistros
anteriores
1992
registros
individuos
Ohio
registros
determinado
evento
ca-
racterística
etc.
consulta
inicial
cliente
asociada
respuesta
100.000
registros
satisfacen
criterios
usuario
añade
información
adicional
vuelve
consulta
respuesta
indica
1000
posibles
registros
Finalmente
cliente
manda
consulta
información
resultado
búsqueda
registro
devuelve
cliente
Procesamiento
distribuido
cliente
servidor
clusters
623
Sistema
gestor
base
datos
Sistema
operativo
servidor
Lógica
base
datos
Servidor
Servicios
presentación
Lógica
aplicación
Software
comunicaciónes
Sistema
operativo
cliente
Plataforma
hardware
Estación
trabajo
cliente
Lógica
base
datos
Consulta
Respuesta
Interacción
protocolo
Software
comunicaciónes
Plataforma
hardware
Figura
14.3
Arquitectura
cliente
servidor
aplicaciones
base
datos
14-Capitulo
14
12/5/05
16:28
Página
623La
aplicación
conveniente
entorno
cliente
servidor
razones
enorme
trabajo
búsqueda
ordenamiento
base
datos
requiere
disco
banco
discos
CPU
velocidad
potente
arquitectura
S.
potencia
capacidad
necesaria
cara
estación
trabajo
PC
usuario
costoso
red
mover
millón
registros
cliente
reali-
ce
búsqueda
suficiente
servidor
capaz
recuperar
registros
base
datos
cliente
servidor
necesita
lógica
permita
búsquedas
cliente
considere
escenario
Figura
14.4b
base
datos
millón
registros
caso
consulta
transmitan
300.000
registros
red
suceder
ejemplo
usuario
deseara
encontrar
valor
campos
mu-
chos
registros
base
datos
completa
Claramente
escenario
admisible
solución
problema
mantendría
arquitectura
cliente
servidor
beneficios
trasladar
lógica
aplicación
servidor
equipar
servidor
lógica
aplicación
realice
análisis
da-
tos
recepción
búsqueda
datos
Clases
aplicaciones
cliente
servidor
marco
general
cliente
servidor
se-
rie
implementaciones
dividen
trabajo
cliente
servidor
Figura
14.5
muestra
términos
generales
principales
opciones
aplicaciones
bases
datos
posibles
divisiones
clase
aplicaciones
ca-
racterizaciones
caso
observar
figura
analizar
posibilidades
624
Sistemas
operativos
Aspectos
internos
principios
diseño
Consulta
inicial
100.000
posibles
registros
consulta
1.000
registros
posibles
Consulta
registro
devuelto
Base
datos
1.000.000
registros
Servidor
Cliente
deseable
cliente
servidor
Consulta
300.000
registros
devueltos
incorrecto
cliente
servidor
Cliente
Servidor
Base
datos
1.000.000
registros
Figura
14.4
base
datos
entorno
cliente
servidor
14-Capitulo
14
12/5/05
16:28
Página
624La
Figura
14.5
representa
clases
Procesamiento
basado
host
procesamiento
basado
host
computación
cliente
servidor
entiende
término
refiere
entornos
mainframe
tradicionales
virtualmente
procesamiento
realiza
host
central
interfaz
usuario
realiza
interfaz
tonto
usuario
empleando
computadora
estación
usuario
limita
papel
emula-
dor
terminal
Procesamiento
basado
servidor
clase
básica
configuración
cliente
servidor
cliente
principal
responsable
proporcionar
interfaz
gráfica
usua-
rio
prácticamente
procesamiento
realiza
servidor
configu-
ración
típica
comienza
utilizar
entorno
cliente
servidor
especialmente
sistemas
nivel
departamento
razonamiento
configuraciones
estación
trabajo
usuario
proporcionar
interfaz
usuario
fácil
ma-
nejo
bases
datos
aplicaciones
mantener
fácilmente
siste-
centrales
usuario
obtiene
ventaja
interfaz
tipo
confi-
guraciones
suele
generar
ventajas
productividad
cambios
fundamentales
funciones
negocio
soportadas
sistema
Procesamiento
basado
cliente
extremo
prácticamente
procesamiento
cliente
excepción
rutinas
validación
datos
Procesamiento
distribuido
cliente
servidor
clusters
625
DBMS
DBMS
Lógica
base
datos
Lógica
aplicación
DBMS
DBMS
Lógica
presentación
Procesamiento
basado
host
Procesamiento
basado
servidor
Procesamiento
cooperativo
Procesamiento
basado
servidor
Cliente
Servidor
Lógica
presentación
Lógica
presentación
Lógica
aplicación
Lógica
aplicación
Lógica
base
datos
Lógica
base
datos
Lógica
aplicación
Lógica
base
datos
Lógica
presentación
Lógica
aplicación
Lógica
base
datos
Figura
14.5
Clases
aplicaciones
cliente
servidor
14-Capitulo
14
12/5/05
16:28
Página
625funciones
lógica
base
datos
servidor
General-
mente
funciones
sofisticadas
lógica
base
datos
realizan
cliente
arquitectura
enfoque
cliente
servidor
común
actualmente
Permite
usuarios
aplicaciones
adaptadas
necesidades
locales
Procesamiento
cooperativo
configuración
procesamiento
cooperativo
procesa-
miento
aplicación
realiza
forma
óptima
beneficiándose
máquinas
cliente
servidora
distribución
datos
configuración
compleja
configurar
mantener
plazo
proporcionar
productividad
usuarios
eficiencia
red
enfoques
cliente
servidor
Figuras
14.5c
corresponden
configuraciones
carga
cliente
modelo
denominado
cliente
pesado
fat
client
popularizado
gracias
herramientas
desarrollo
aplicaciones
PowerBuilder
Sybase
Inc
SQL
Windows
Gupta
Corp
aplicaciones
desarrolladas
herramientas
suelen
departamentales
so-
portan
25
150
usuarios
ECKE95
principal
ventaja
modelo
beneficia
potencia
escritorios
descargando
servidores
haciéndolos
eficientes
pro-
pensos
cuello
botella
desventajas
estrategia
clientes
pesados
Añadir
funcionalidades
suele
sobrecargar
capacidad
ordenadores
escritorio
forzando
com-
pañías
actualizarse
modelo
sale
departamento
incorporan
usuarios
compa-
ñía
instalar
redes
locales
LAN
alta
capacidad
soporte
número
transmi-
siones
servidores
ligeros
clientes
pesados
difícil
mantener
actualizar
reemplazar
aplicaciones
distribuidas
decenas
centenas
ordenadores
Figura
14.5b
representativa
enfoque
cliente
ligero
enfoque
imita
enfoque
tradicional
centralizado
host
ruta
migración
pasar
aplicaciones
cor-
porativas
mainframe
entorno
distribuido
Arquitectura
cliente
servidor
capas
arquitectura
tradicional
cliente
servidor
impli-
ca
normalmente
niveles
capas
capa
cliente
capa
servidor
habitual
arquitectura
capas
Figura
14.6
arquitectura
software
aplicación
dis-
tribuye
tipos
máquinas
máquina
usuario
servidor
capa
central
ser-
vidor
plano
backend
máquina
usuario
máquina
cliente
viendo
modelo
capas
normalmente
cliente
ligero
máquinas
capa
central
normalmente
pasarela
clientes
ligeros
servidores
bases
datos
plano
máquinas
capa
central
convertir
protocolos
cambiar
tipo
consulta
base
datos
máquinas
capa
central
mezclar
integrar
resultados
fuentes
datos
Finalmente
servir
pasarela
apli-
caciones
escritorio
aplicaciones
servidores
plano
mediando
mundos
interacción
servidor
capa
central
servidor
plano
si-
gue
modelo
cliente
servidor
forma
sistema
capa
intermedia
actúa
cliente
servidor
Consistencia
cache
ficheros
utiliza
servidor
ficheros
rendimiento
ficheros
degradar
comparación
acceso
local
ficheros
retrasos
generados
red
reducir
problema
rendimiento
sistemas
individuales
utilizar
cache
ficheros
almacenar
registros
ficheros
accedido
recientemente
principio
localidad
cache
local
ficheros
debería
reducir
número
accesos
necesarios
servidor
remoto
626
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
626La
Figura
14.7
muestra
mecanismo
distribuido
típico
cache
ficheros
red
estaciones
trabajo
proceso
realiza
acceso
fichero
petición
presenta
pri-
mero
cache
estación
trabajo
proceso
tráfico
fichero
satisfactoria
petición
pasa
disco
local
fichero
almacenado
tráfico
disco
servidor
ficheros
fichero
almacenado
tráfico
servidor
servidor
pregunta
pri-
mero
cache
servidor
accede
disco
servidor
enfoque
doble
cache
utiliza
reducir
tráfico
comunicación
cache
cliente
disco
cache
servidor
Procesamiento
distribuido
cliente
servidor
clusters
627
Cliente
Servidor
capa
central
servidor
aplicación
Servidores
plano
servidores
datos
Figura
14.6
Arquitectura
cliente
servidor
capas
Tráfico
servidor
Tráfico
ficheros
Disco
servidor
Red
Disco
servidor
Tráfico
disco
Disco
cliente
Server
cache
Cache
cliente
Cache
cliente
Tráfico
disco
Tráfico
ficheros
Figura
14.7
Cache
ficheros
distribuida
Sprite
14-Capitulo
14
12/5/05
16:28
Página
627Cuando
cache
contiene
copias
exactas
datos
remotos
decimos
caches
consistentes
caches
vuelvan
inconsistentes
cambian
datos
re-
motos
descartan
correspondientes
copias
locales
cache
suceder
cliente
modifica
fichero
cache
cliente
problema
doble
cliente
adopta
política
escribir
inmediatamente
servidor
cambios
fichero
cual-
quier
cliente
copia
cache
fichero
cambiado
da-
tos
obsoletos
problema
cliente
retrasa
escritura
servidor
caso
servidor
versión
obsoleta
fichero
peticiones
lectura
servidor
po-
drían
obtener
datos
obsoletos
problema
mantener
actualizadas
copias
locales
cache
conocido
problema
consistencia
cache
mecanismo
sencillo
consistencia
cache
utilizar
técnicas
bloqueo
fiche-
ros
evitar
accesos
simultáneos
fichero
cliente
garantiza
consistencia
costa
rendimiento
flexibilidad
mecanismo
potente
proporciona
Sprite
NELS88
OUST88
número
procesos
remotos
abrir
fichero
lectura
al-
macenarlo
cache
solicitud
apertura
fichero
pide
accesos
escri-
tura
procesos
fichero
abierto
acceso
lectura
servidor
realiza
acciones
notifica
proceso
escribe
mantener
copia
local
mandar
servidor
bloques
cambien
inmediatamente
clientes
servidor
notifica
procesos
lectores
fichero
abierto
fichero
mantener
cache
MIDDLEWARE
desarrollo
utilización
productos
cliente
servidor
sobrepasado
esfuerzos
estandarizar
aspectos
computación
distribuida
capa
física
capa
aplicación
falta
estándares
difícil
implementar
configuración
cliente
servidor
in-
tegrada
multivendedor
empresa
problema
interoperabilidad
resuelto
beneficio
enfoque
cliente
servidor
unido
modularidad
capacidad
combinar
plataformas
aplicaciones
proporcionar
solución
negocio
lograr
verdaderos
beneficios
mecanismo
cliente
servidor
desarrolladores
conjunto
herramientas
proporcionen
estilo
acceso
uniforme
re-
cursos
sistema
plataformas
permitirá
programadores
construir
aplicaciones
parezcan
iguales
PC
estaciones
trabajo
utilicen
método
acceder
datos
independientemente
localización
forma
común
cumplir
requisitos
interfaces
programa-
ción
protocolos
estándares
aplicación
software
comunicaciones
sistema
operati-
vo
interfaces
programación
protocolos
estándares
denominan
middleware
in-
terfaces
programación
estándares
resulta
sencillo
implementar
aplicación
tipos
servidores
estaciones
trabajo
lógicamente
beneficia
clientes
vendedores
motivados
proporcionar
interfaces
razón
clientes
compran
aplicaciones
servidores
clientes
elegirán
productos
servidor
ejecuten
aplicaciones
quieren
protocolos
estandarizados
necesarios
unir
servido-
res
clientes
necesitan
acceder
diversos
paquetes
middleware
varían
sencillos
complejos
común
capacidad
esconder
complejidad
disparidad
diferen-
tes
protocolos
red
sistemas
operativos
vendedores
clientes
servidores
generalmente
proporcionan
paquetes
middleware
populares
forma
usuario
fijar
estrategia
middleware
particular
montar
equipos
vendedores
soporten
estrategia
628
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
628Arquitectura
middleware
Figura
14.8
sugiere
papel
middleware
arquitectura
cliente
servidor
papel
exacto
middleware
dependerá
estilo
computación
cliente
servidor
utilizado
olviendo
Figura
14.5
recordamos
enfoques
cliente
servidor
de-
pendiendo
forma
funciones
aplicación
dividen
caso
Figura
14.8
idea
general
arquitectura
involucrada
Obsérvese
componentes
cliente
servidor
middleware
propósito
básico
middleware
permitir
aplicación
usuario
cliente
acceder
variedad
servi-
cios
servidor
preocuparse
diferencias
servidores
área
específica
aplicación
lenguaje
estructurado
consultas
SQL
supone
proporciona
acceso
es-
tándar
base
datos
relacional
usuario
aplicación
local
remoto
mu-
chos
vendedores
bases
datos
relacionales
soportan
SQL
añadido
ex-
tensiones
permite
vendedores
diferenciar
productos
crea
potenciales
incompatibilidades
ejemplo
considere
sistema
distribuido
utilizado
soporte
cosas
departamento
personal
datos
básicos
empleado
tales
nombre
dirección
pue-
den
almacenados
base
datos
Gupta
información
salario
base
datos
Oracle
usuario
departamento
personal
acceder
registro
particular
preocupar
tipo
base
datos
contiene
regis-
tros
middleware
proporciona
capa
software
permite
acceso
uniforme
siste-
instructivo
mirar
papel
middleware
punto
vista
lógico
punto
vista
implementación
punto
vista
muestra
Figura
14.9
middleware
permite
realización
promesa
computación
cliente
servidor
sistema
distribuido
com-
pleto
conjunto
aplicaciones
recursos
disponibles
usuarios
usuarios
necesitan
preocuparse
localización
datos
localización
aplicacio-
nes
aplicaciones
operan
interfaz
programación
aplicaciones
API
unifor-
middleware
sitúa
plataformas
cliente
servidor
responsable
guiar
peticiones
servidor
apropiado
Procesamiento
distribuido
cliente
servidor
clusters
629
Servicios
aplicación
Sistema
operativo
servidor
Middleware
Servidor
Servicios
presentación
Lógica
aplicación
Software
comunicaciones
Sistema
operativo
cliente
Plataforma
hardware
Estación
trabajo
cliente
Middleware
Interacción
middleware
Interacción
protocolo
Software
comunicaciones
Plataforma
hardware
Figura
14.8
papel
middleware
arquitectura
cliente
servidor
14-Capitulo
14
12/5/05
16:28
Página
629Aunque
variedad
productos
middleware
basan
típicamente
mecanismos
paso
mensajes
llamadas
procedimiento
remoto
siguientes
sec-
ciones
examinan
métodos
14.2
PASO
MENSAJES
DISTRIBUIDO
Normalmente
sistemas
procesamiento
distribuido
computadoras
comparten
me-
moria
principal
sistema
aislado
forma
técnicas
comunicación
procesos
basan
memoria
compartida
tales
semáforos
uti-
lizar
lugar
utilizan
técnicas
basan
paso
mensajes
sección
si-
guiente
veremos
técnicas
comunes
aplicación
directa
mensajes
utilizan
único
sistema
técnica
basa
paso
men-
sajes
llamadas
procedimiento
remoto
Figura
14.10a
muestra
paso
mensajes
implementar
funciones
cliente
servidor
proceso
cliente
necesita
servicio
ejemplo
leer
fichero
impri-
mir
envía
mensaje
petición
servicio
proceso
servidor
proceso
servidor
realiza
petición
envía
mensaje
respuesta
forma
básica
necesi-
funciones
Send
mandar
Receive
recibir
función
Send
especifica
destinatario
incluye
contenido
mensaje
función
Receive
indica
desea
recibir
men-
saje
incluyendo
opción
all
proporciona
buffer
almacenará
mensaje
entrante
Figura
14.11
sugiere
implementación
paso
mensajes
procesos
servicios
módulo
paso
mensajes
peticiones
servicio
expresar
térmi-
primitivas
parámetros
primitiva
especifica
función
desea
pará-
metros
utilizan
pasar
datos
información
control
formato
real
primitivas
630
Sistemas
operativos
Aspectos
internos
principios
diseño
API
Middleware
servicios
sistema
distribuido
Interfaces
plataforma
Aplicación
Plataforma
SO
Hardware
SO
Hardware
Aplicación
Plataforma
Figura
14.9
Visión
lógica
middleware
14-Capitulo
14
12/5/05
16:28
Página
630Procesamiento
distribuido
cliente
servidor
clusters
631
Aplicación
Transporte
Red
Aplicación
Transporte
Red
Llamada
procedimiento
remoto
Invocaciones
respuestas
procedimientos
específicos
aplicación
Aplicación
Middleware
orientado
mensajes
cola
mensajes
Transporte
Red
Middlewarw
orientado
mensajes
cola
mensajes
Mensajes
específicos
aplicación
Red
Transporte
Mediador
solicitud
objeto
Red
Transporte
Servidor
objetos
Solicitud
objetos
respuestas
Aplicación
Transporte
Red
AplicaciónPrograma
esqueleto
RPC
Transporte
Red
Cliente
Servidor
Cliente
Cliente
Middleware
orientado
mensajes
cola
mensajes
Servidor
Programa
esqueleto
RPC
Servidor
Programa
esqueleto
RPC
Solicitud
objetos
respuestas
Figura
14.10
Mecanismos
middleware
Procesor
emisor
Proceso
receptor
Módulo
paso
mensajes
IdProceso
Mensaje
Módulo
paso
mensajes
Figura
14.11
Primitivas
básicas
paso
mensajes
14-Capitulo
14
12/5/05
16:28
Página
631depende
software
paso
mensajes
utilice
llamada
procedimiento
mensaje
proceso
sistema
operativo
primitiva
Send
utiliza
proceso
enviar
mensaje
parámetros
identificador
proceso
destinatario
contenido
mensaje
módulo
paso
mensajes
construye
unidad
datos
incluye
elementos
unidad
datos
envía
máquina
hospeda
proceso
destinatario
utilizando
tipo
servicios
comunicación
TCP
IP
recibe
destino
unidad
datos
servicio
comunicación
pasa
módulo
paso
mensajes
módulo
examina
campo
ID
proceso
almacena
mensaje
buffer
proceso
escenario
proceso
receptor
deseo
recibir
mensaje
desig-
nando
área
buffer
informando
módulo
paso
mensajes
primitiva
Recei-
ve
enfoque
alternativo
módulo
paso
mensajes
recibe
mensaje
señaliza
proceso
destinatario
tipo
señal
Receive
disponible
mensaje
recibido
buffer
compartido
restante
sección
analizan
aspectos
relativos
paso
mensajes
FIABLE
VS
FIABLE
servicio
fiable
paso
mensajes
garantiza
entrega
servicios
ha-
cen
protocolo
transporte
fiable
lógica
similar
realizan
comprobación
erro-
res
acuse
recibo
retransmisión
reordenamiento
mensajes
desordenados
garantiza
envío
necesario
informar
proceso
emisor
mensaje
enviado
útil
informar
proceso
emisor
vía
acuse
recibo
sepa
entrega
lugar
caso
falla
envío
mensaje
ejemplo
fallo
persistente
red
fallo
sistema
destino
informa
fracaso
proceso
emisor
extremo
servicio
paso
mensajes
fiable
simplemente
envía
mensaje
red
indica
éxito
fracaso
alternativa
reduce
enormemente
complejidad
sobrecarga
procesamiento
comunicación
servicio
paso
mensajes
aplica-
ciones
requieran
confirmación
mensaje
entregado
aplicación
en-
viar
recibir
mensajes
satisfacer
requisito
BLOQUEANTE
VS
BLOQUEANTE
primitivas
bloqueantes
asíncronas
suspende
proceso
resultado
rea-
lizar
Send
Receive
forma
proceso
realiza
primitiva
Send
sistema
operativo
devuelve
control
proceso
mensaje
puesto
cola
transmisión
copia
realiza
copia
cambio
proceso
emisor
haga
mensaje
transmisión
realizan
responsabilidad
proceso
mensaje
transmitido
copiado
lugar
seguro
transmisión
interrumpe
proceso
emisor
informarle
buffer
reutilizado
forma
si-
milar
Receive
bloqueante
permite
proceso
continúe
ejecutando
mensaje
lle-
ga
informa
proceso
interrupción
proceso
verificar
periódicamente
primitivas
bloqueantes
proporcionan
eficiente
flexible
servicios
paso
mensajes
procesos
desventaja
mecanismo
dificultad
chequear
depurar
programas
utilicen
primitivas
secuencias
irreproducibles
dependientes
tiempo
crear
problemas
delicados
difíciles
632
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
632La
alternativa
utilizar
primitivas
bloqueantes
asíncronas
Send
bloqueante
devuelve
control
proceso
emisor
mensaje
transmitido
servicio
fiable
mensaje
enviado
recibido
acuse
recibo
servicio
fiable
Receive
bloqueante
devuelve
control
mensaje
situado
correspondiente
buffer
14.3
LLAMADAS
PROCEDIMIENTO
REMOTO
llamadas
procedimiento
remoto
variante
modelo
básico
paso
mensajes
método
común
ampliamente
aceptado
encapsular
comunicación
sistema
distribuido
esencial
técnica
permitir
programas
máquinas
interactuar
llamadas
procedimiento
harían
programas
es-
tán
máquina
utilizan
llamadas
procedimiento
acceder
servi-
cios
remotos
popularidad
mecanismo
proporciona
siguientes
ventajas
llamadas
procedimiento
abstracción
ampliamente
aceptada
utilizada
entendida
llamadas
procedimiento
remoto
permite
especificar
interfaces
remotas
conjunto
operaciones
nombre
tipos
datos
dados
forma
interfaz
pue-
documentar
claramente
programas
distribuidos
comprobar
estáticamente
erro-
res
tipos
datos
especifica
interfaz
estandarizada
precisa
código
comunicación
aplicación
generar
automáticamente
especifica
interfaz
estandarizada
precisa
desarrolladores
escribir
módulos
cliente
servidor
mover
computadoras
sistemas
operativos
modificaciones
recodificaciones
mecanismo
llamadas
procedimiento
remoto
refinamiento
paso
mensajes
fiable
bloqueante
Figura
14.10b
muestra
arquitectura
general
Figura
14.12
proporciona
vista
detallada
programa
llamante
realiza
llamada
procedimiento
nor-
parámetros
máquina
ejemplo
CALL
P(X
nombre
procedimiento
argumentos
pasados
valores
devueltos
intención
invocar
procedimiento
remoto
máquina
transparente
usuario
espacio
direcciones
llamante
incluir
esqueleto
stub
procedi-
miento
enlazar
dinámicamente
tiempo
llamada
procedimiento
crea
mensa-
je
identifica
procedimiento
llamando
incluye
parámetros
forma
envía
mensaje
sistema
remoto
espera
respuesta
recibe
respuesta
pro-
cedimiento
esqueleto
vuelve
programa
llamante
proporcionando
valores
devueltos
máquina
remota
programa
esqueleto
asociado
procedimiento
llamado
llega
mensaje
examina
genera
CALL
local
procedimiento
remoto
llama
localmente
forma
suposiciones
normales
encontrar
parámetros
pila
idénticos
caso
llamada
local
Procesamiento
distribuido
cliente
servidor
clusters
633
14-Capitulo
14
12/5/05
16:28
Página
633En
restante
sección
analizan
cuestiones
relativas
llamadas
proce-
dimiento
remoto
PASO
PARÁMETROS
lenguajes
programación
permiten
parámetros
pasen
valores
denominado
valor
punteros
contienen
valores
llamado
referencia
lla-
madas
valor
fáciles
implementar
llamadas
procedimiento
remoto
parámetros
copian
mensaje
envían
sistema
remoto
difícil
implementar
llamadas
referencia
objeto
necesita
puntero
único
válido
sistema
suele
me-
recer
pena
esfuerzo
sobrecarga
genera
REPRESENTACIÓN
PARÁMETROS
aspecto
representar
parámetros
resultados
mensajes
programas
llamado
llamante
escritos
lenguaje
programación
tipo
máqui-
na
sistema
operativo
requisito
representación
proble-
ma
diferencias
áreas
probablemente
diferencias
represen-
números
cadenas
texto
utiliza
arquitectura
comunicación
completa
problema
gestiona
capa
presentación
sobrecarga
tipo
arquitectura
llevado
diseño
llamadas
procedimiento
remoto
servicios
evitan
arquitectura
comunicaciones
proporcionan
servicios
comuni-
cación
básicos
caso
responsabilidad
conversión
recae
servicio
llamada
procedimiento
remoto
ejemplo
véase
GIBB87
mecanismo
solucionar
problema
proporcionar
formato
estándar
objetos
comunes
tales
enteros
números
coma
flotante
caracteres
cadenas
caracte-
634
Sistemas
operativos
Aspectos
internos
principios
diseño
Esqueleto
local
Mecanismo
RPC
Aplicación
local
sistema
operativo
Aplicación
cliente
Aplicación
servidora
remota
Llamada
procedimiento
local
Respuesta
local
Llamada
procedimiento
remoto
Respuesta
local
Llamada
procedimiento
remoto
Esqueleto
local
Mecanismo
RPC
Respuesta
local
Llamada
procedimiento
local
Figura
14.12
Mecanismo
llamadas
procedimiento
remoto
14-Capitulo
14
12/5/05
16:28
Página
634res
forma
parámetros
nativos
máquina
convertir
represen-
tación
estándar
ENLACE
CLIENTE
SERVIDOR
enlace
especifica
establecerá
relación
procedimiento
remoto
programa
lla-
mante
forma
enlace
aplicaciones
conexión
lógica
prepa-
rados
intercambiar
datos
mandatos
enlace
permanente
significa
conexión
lógica
establece
procesos
momento
llamada
procedimiento
remoto
devuelven
valores
cierra
conexión
conexión
requiere
mantenga
información
extremos
consume
recursos
estilo
persistente
utiliza
conservar
recursos
sobrecarga
implica
establecer
conexiones
enlaces
perma-
nentes
inapropiados
procedimientos
remotos
llamados
frecuentemente
enlaces
persistentes
conexión
establece
llamada
procedimiento
remoto
mantiene
finalización
dicha
llamada
conexión
utilizada
futuras
llamadas
procedimiento
remoto
pasa
periodo
determinado
tiempo
actividad
conexión
finaliza
conexión
aplicaciones
llamadas
repetidas
procedimientos
remotos
enlace
permanente
mantiene
conexión
lógica
permite
secuencia
llamadas
utilice
conexión
SÍNCRONOS
VS
ASÍNCRONOS
conceptos
llamadas
procedimiento
remoto
síncronas
asíncronas
análogos
concep-
tos
mensajes
bloqueantes
bloqueantes
llamadas
procedimiento
remoto
RPC
tradicio-
nales
síncronas
requiere
proceso
llamante
espere
proceso
llamado
de-
vuelva
valor
forma
RPC
síncrono
comporta
llamada
subrutina
RPC
síncrono
fácil
entender
programar
comportamiento
predecible
falla
explotar
paralelismo
inherente
sistemas
distribuidos
limita
tipo
interacción
aplicación
distribuida
dando
lugar
rendimientos
bajos
proporcionar
flexibilidad
implementado
servicios
RPC
asíncronos
logra
grado
paralelismo
mantiene
familiaridad
simpli-
cidad
RPC
ANAN92
RPC
asíncronos
bloquean
llamante
respuestas
re-
cibir
requeridas
permitiendo
forma
cliente
ejecutar
paralelo
servidor
típico
RPC
asíncrono
permite
cliente
invocar
servidor
repetidamente
for-
ma
cliente
respuestas
tubería
pipeline
determinado
momento
conjunto
datos
sincronización
cliente
servidor
lograr
siguientes
maneras
aplicación
capa
superior
cliente
servidor
iniciar
intercambio
comprobar
finalizar
peticiones
cliente
enviar
cadena
llamadas
RPC
asíncronas
seguida
llamada
RPC
síncrona
servidor
responderá
llamada
RPC
síncrona
complete
trabajo
solicitado
precedentes
llamadas
RPC
asíncronas
Procesamiento
distribuido
cliente
servidor
clusters
635
14-Capitulo
14
12/5/05
16:28
Página
635En
esquemas
RPC
asíncronos
requieren
respuesta
servidor
servidor
enviar
mensaje
respuesta
esquemas
requieren
permiten
respuesta
llamante
espera
MECANISMOS
ORIENTADOS
OBJETOS
medida
tecnología
orientada
objetos
vuelve
común
diseño
sistemas
operativos
diseñadores
tecnología
cliente
servidor
empezado
adoptar
enfoque
enfoque
clientes
servidores
mandan
mensajes
objetos
comunicación
ob-
jetos
basar
estructura
mensajes
RPC
subyacente
directamente
de-
sarrollada
servicios
orientación
objetos
sistema
operativo
cliente
necesita
servicio
manda
petición
mediador
solicitud
objeto
ob-
ject
request
broker
actúa
directorio
servicios
remotos
disponibles
red
Figura
14.10c
mediador
llama
objeto
apropiado
transfiere
datos
relevantes
continuación
objeto
remoto
atiende
petición
responde
mediador
devuelve
informa-
ción
cliente
éxito
enfoque
orientado
objetos
depende
estandarización
mecanismo
objetos
Desafortunadamente
diseños
compiten
área
Modelo
Componen-
tes
Objeto
Component
Object
Model
-COM-
Microsoft
base
Enlazado
Embebido
Objetos
Object
Linking
and
Embedding
-OLE-
mecanismo
competitivo
desarrollado
Ob-
ject
Management
Group
Arquitectura
Común
Mediador
Solicitud
Objeto
Common
Object
Request
Broker
Arquitecture
-CORBA-
soporte
industria
IBM
Apple
Sun
vendedores
soporte
CORBA
14.4
CLUSTERS
importante
relativamente
reciente
diseño
sistema
computación
Cluster
Clusters
alternativa
Multiprocesamiento
Simétrico
SMP
sistemas
proporcionan
alto
rendimiento
alta
disponibilidad
particularmente
atractivos
aplicaciones
servi-
dor
definir
cluster
grupo
computadoras
completas
interconectadas
trabajan
juntas
recurso
computación
unificado
crear
ilusión
única
máquina
término
computadora
completa
significa
sistema
ejecutar
mis-
mo
aparte
cluster
literatura
computadora
Cluster
denomina
nodo
BREW97
enumera
beneficios
lograr
cluster
beneficios
tam-
bién
objetivos
requisitos
diseño
Escalabilidad
absoluta
crear
cluster
supere
potencia
máquinas
cluster
decenas
centenas
máquinas
multiprocesador
Escalabilidad
incremental
cluster
configura
añadir
nue-
vos
sistemas
cluster
pequeños
incrementos
forma
usuario
comenzar
sistema
pequeño
expandirlo
necesidades
ac-
tualizaciones
pequeño
sistema
reemplazado
Alta
disponibilidad
nodo
cluster
computadora
fallo
nodos
significa
pérdida
servicio
productos
software
mane-
ja
automáticamente
tolerancia
fallos
636
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
636•
Relación
precio
prestaciones
bloques
construcción
cluster
computacional
única
máquina
menor
coste
CONFIGURACIONES
CLUSTERS
literatura
Clusters
clasifican
maneras
configuración
sencilla
basada
computadoras
cluster
comparten
acceso
discos
Figu-
ra
14.13a
muestra
cluster
nodos
única
interconexión
enlace
alta
velocidad
utilizado
intercambio
mensajes
coordinar
activi-
dad
cluster
enlace
LAN
compartida
computadoras
cluster
interconexión
dedicada
caso
computadoras
cluster
enlace
LAN
WAN
forma
comuni-
cación
servidor
cluster
sistemas
clientes
remotos
Fijarse
figura
computadora
multiprocesador
necesario
mejora
rendimiento
disponibilidad
clasificación
representada
Figura
14.13
alternativa
cluster
disco
compartido
caso
habiendo
enlace
nodos
subsistema
discos
directamente
enlazado
múltiples
computadoras
cluster
Figura
14.13b
Procesamiento
distribuido
cliente
servidor
clusters
637
Enlace
mensajes
alta
velocidad
Servidor
espera
disco
compartido
Disco
compartido
RAID
Enlace
mensajes
alta
velocidad
Figura
14.13
Configuraciones
cluster
14-Capitulo
14
12/5/05
16:28
Página
637el
subsistema
disco
común
sistema
RAID
RAID
sistema
redundan-
cia
similar
común
cluster
disponibilidad
lograda
presencia
múlti-
ples
computadoras
comprometa
disco
compartido
punto
único
fallo
Mirando
alternativas
funcionales
idea
clara
tipos
cluster
documento
Hewlett
Packard
HP96
proporciona
clasificación
útil
líneas
funcionales
Tabla
14.2
discuten
continuación
abla
14.2
Métodos
cluster
beneficios
limitaciones
Método
Cluster
Descripción
Beneficios
Limitaciones
Pasivo
Espera
caso
fallo
Fácil
implementar
Alto
coste
servidor
primario
servidor
secundario
servidor
secundario
disponible
toma
control
procesar
tareas
Secundario
Activo
servidor
secundario
Coste
reducido
Creciente
complejidad
utiliza
servidor
secundario
procesamiento
utilizado
tareas
procesamiento
Servidores
servidor
Alta
disponibilidad
Alta
sobrecarga
discos
red
servidor
datos
copian
operaciones
continuamente
copia
servidor
primario
secundario
Servidores
Conectados
servidores
Sobrecarga
red
Normalmente
requiere
Discos
unidos
servidores
reducida
tecnologías
replicación
discos
eliminación
discos
RAID
servidor
posee
operaciones
compensar
riesgo
discos
copia
fallo
disco
servidor
falla
servidor
toma
control
discos
Servidores
Comparten
servidores
Baja
sobrecarga
Requiere
software
Discos
comparten
acceso
red
servidores
gestión
cerrojos
disco
forma
Reducido
riesgo
Normalmente
utiliza
simultánea
periodos
inactividad
tecnologías
causados
fallos
replicación
discos
disco
RAID
método
común
antiguo
conoce
pasivo
espera
consiste
com-
putadora
realizando
proceso
permanece
inactiva
esperando
tomar
control
caso
fallo
primaria
coordinar
máquinas
actividad
sistema
manda
perió-
dicamente
mensaje
latido
máquina
espera
mensajes
dejan
llegar
má-
quina
espera
asume
servidor
primario
fallado
toma
control
enfoque
mejora
disponibilidad
mejora
rendimiento
única
información
intercambian
sistemas
mensaje
control
sistemas
discos
comunes
servidor
espera
proporciona
funcionalidad
necesaria
acceso
bases
datos
manejadas
servidor
primario
638
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
638El
pasivo
espera
conoce
normalmente
cluster
término
cluster
general
refiere
múltiples
computadoras
interconectadas
realizando
procesamiento
mantiene
imagen
sistema
único
cara
exterior
enfoque
tipo
cluster
computadora
servidor
discos
discos
compartidos
sistemas
Figura
14.13a
disposición
proporciona
alto
ren-
dimiento
alta
disponibilidad
caso
necesita
tipo
software
planificación
ges-
tión
asignar
peticiones
entrantes
clientes
forma
balancee
carga
logre
alta
utilización
deseable
capacidad
recuperación
fallos
failover
significa
computadora
falla
ejecución
aplicación
computadora
cluster
tomar
control
finalizar
aplicación
suceda
copiar
constantemente
información
sistemas
forma
sistema
acceso
datos
actualizados
sistemas
sobrecarga
intercambio
datos
asegura
alta
disponibilidad
costa
rendimiento
reducir
sobrecarga
comunicaciones
cluster
consisten
ser-
vidores
conectados
discos
comunes
Figura
14.13b
variante
enfoque
denomina
compartido
shared
nothing
variante
discos
comunes
particionan
volúme-
nes
volumen
pertenece
computadora
falla
computadora
cluster
re-
configurar
computadora
tome
posesión
volumen
computadora
falló
múltiples
computadoras
compartiendo
discos
tiempo
denominada
variante
disco
compartido
shared
disk
forma
computadora
acceso
volúmenes
discos
variante
requiere
existencia
tipo
servicio
cerrojos
asegure
acceder
datos
computadora
tiempo
ASPECTOS
DISEÑO
SISTEMAS
OPERATIVOS
obtener
ventajas
configuración
hardware
cluster
necesitan
me-
joras
sistemas
operativos
Gestión
Fallos
forma
gestionar
fallos
depende
método
cluster
utilizado
Tabla
14.2
general
tratamiento
fallos
seguir
enfoques
clusters
alta
disponibilidad
clusters
tolerancia
fallos
cluster
alta
disponibilidad
ofrece
alta
posibili-
dad
recursos
estén
servicio
sucede
fallo
caída
nodo
pierda
volumen
pierden
peticiones
progreso
petición
perdida
reintente
atendida
computadora
cluster
sistema
operativo
cluster
garantiza
transacciones
parcialmente
realizadas
necesita
ges-
tionar
nivel
aplicación
cluster
tolerante
fallos
asegura
recursos
disponibles
lo-
gra
discos
redundantes
compartidos
mecanismos
deshacer
transacciones
in-
completas
función
intercambiar
aplicación
datos
sistema
fallido
sistema
alter-
nativo
cluster
denomina
recuperación
fallos
failover
restauración
aplicaciones
datos
sistema
original
reparado
denomina
restauración
fallos
failback
restauración
automática
deseable
problema
real-
mente
solucionado
probable
vuelva
suceder
forma
restauración
automá-
tica
provocar
fallos
sucesivos
sistema
inicial
generando
problemas
rendimiento
recuperación
Procesamiento
distribuido
cliente
servidor
clusters
639
14-Capitulo
14
12/5/05
16:28
Página
639Equilibrado
carga
cluster
necesita
capacidad
equilibrar
carga
computadoras
disponibles
incluye
requisito
cluster
escalable
añade
computadora
cluster
servicio
equilibrado
carga
incluir
automática-
mente
computadora
planificación
aplicaciones
mecanismos
middleware
aparecer
servicios
miembros
cluster
pudiendo
mi-
grar
miembro
Computación
paralela
casos
eficiente
cluster
necesita
ejecutar
úni-
ca
aplicación
paralelo
KAPP00
enumera
enfoques
generales
problema
Compilación
paralela
compilador
paralelo
determina
tiempo
compilación
partes
aplicación
ejecutar
paralelo
partes
asignar
compu-
tadoras
cluster
rendimiento
depende
naturaleza
problema
diseño
compilador
Aplicaciones
paralelas
enfoque
programador
escribe
aplicación
ejecu-
cluster
utiliza
paso
mensajes
mover
datos
requiera
nodos
cluster
supone
carga
programador
probablemente
forma
explotar
cluster
aplicaciones
Computación
paramétrica
enfoque
utilizar
esencia
aplicación
algoritmo
ejecutar
número
conjunto
condiciones
parámetros
iniciales
ejemplo
modelo
simulación
eje-
cutará
número
escenarios
calculará
estadísticas
resultados
enfoque
efectivo
necesitan
herramientas
procesamiento
paramétricas
organizar
ejecutar
gestionar
trabajos
forma
ordenada
ARQUITECTURA
CLUSTER
Figura
14.14
muestra
típica
arquitectura
cluster
computadoras
conectadas
LAN
alta
velocidad
conmutador
hardware
computadora
capaz
operar
independiente-
mente
computadora
instalada
capa
software
middleware
permite
operación
cluster
middleware
cluster
proporciona
imagen
única
usuario
conocida
imagen
única
sistema
single-system
image
middleware
responsa-
ble
proporcionar
alta
disponibilidad
balanceado
carga
respuesta
fallos
componentes
HWAN99
enumera
siguientes
servicios
funciones
deseables
cluster
único
punto
entrada
usuario
autentifica
cluster
determinada
computadora
única
jerarquía
ficheros
usuarios
ven
jerarquía
directorios
directorio
raíz
único
punto
control
nodo
defecto
encargado
gestionar
controlar
cluster
única
red
virtual
nodo
acceder
punto
cluster
in-
cluso
configuración
cluster
múltiples
redes
interconectadas
opera
única
red
virtual
único
espacio
memoria
memoria
compartida
distribuida
permite
programas
compartir
variables
640
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
640•
único
sistema
control
trabajos
planificador
trabajos
cluster
usuario
enviar
trabajo
especificar
computadora
ejecutará
único
interfaz
usuario
usuarios
interfaz
gráfico
común
indepen-
dientemente
estación
trabajo
utilicen
único
espacio
S.
nodo
acceder
remotamente
periférico
disco
localización
física
único
espacio
procesos
utiliza
esquema
uniforme
identificación
procesos
proceso
nodo
crear
comunicar
proceso
nodo
remoto
Puntos
control
función
salva
periódicamente
proceso
resultados
computación
intermedios
permitir
recuperarse
fallo
Migración
procesos
función
permite
balanceado
carga
elementos
lista
precedente
mejoran
disponibilidad
cluster
res-
tantes
elementos
preocupan
proporcionar
imagen
única
sistema
olviendo
Figura
14.14
cluster
incluirá
herramientas
software
permitir
ejecución
eficiente
programas
capaces
ejecutar
paralelo
CLUSTER
FRENTE
SMP
clusters
multiprocesamiento
simétrico
proporcionan
configuración
múlti-
ples
procesadores
soporte
aplicaciones
alta
demanda
Ambas
soluciones
disponi-
bles
mercado
SMP
presente
tiempo
principal
fuerza
enfoque
SMP
fácil
gestionar
configurar
cluster
SMP
cercano
modelo
original
procesador
escritas
prácticamente
aplicaciones
principal
cambio
requerido
pasar
uniprocesador
Procesamiento
distribuido
cliente
servidor
clusters
641
Hw
interfaz
red
Sw
comunicaciones
PC
Estación
trabajo
Net
interface
HW
Middleware
cluster
Imagen
sistema
infraestructura
disponibilidad
Aplicaciones
secuenciales
Red
alta
velocidad
conmutador
Aplicaciones
paralelas
Entorno
programación
paralela
PC
Estación
trabajo
PC
Estación
trabajo
PC
Estación
trabajo
PC
Estación
trabajo
Hw
interfaz
red
Hw
interfaz
red
Hw
interfaz
red
Sw
comunicaciones
Sw
comunicaciones
Sw
comunicaciones
Sw
comunicaciones
Figura
14.14
Arquitectura
computación
cluster
BUYY99a
14-Capitulo
14
12/5/05
16:28
Página
641un
multiprocesador
función
planificación
beneficio
SMP
normalmente
ocupa
espacio
físico
gasta
energía
cluster
comparable
beneficio
im-
portante
productos
SMP
establecidos
estables
plazo
ventajas
cluster
probablemente
llevarán
dominar
mer-
cado
servidores
alto
rendimiento
clusters
superiores
SMP
relación
escalabilidad
incremental
absoluta
clusters
superiores
términos
disponi-
bilidad
componentes
sistema
altamente
redundantes
14.5
SERVIDOR
CLUSTER
WINDOWS
Servidor
Cluster
Windows
formalmente
conocido
Wolfpack
cluster
tipo
compartido
volumen
disco
recursos
propiedad
único
sistema
diseño
Servidor
Cluster
Windows
siguientes
conceptos
Servicio
Cluster
colección
software
nodo
gestiona
actividad
espe-
cífica
cluster
Recurso
elemento
gestionado
servicio
cluster
recursos
objetos
representan
recursos
reales
sistema
incluyendo
dispositivos
hardware
tales
discos
tarjetas
red
elementos
lógicos
tales
volúmenes
lógicos
disco
direcciones
TCP
IP
aplicaciones
completas
bases
datos
línea
online
recurso
línea
nodo
proporcionan-
do
servicio
nodo
específico
Grupo
colección
recursos
gestionada
unidad
Normalmente
grupo
con-
elementos
necesarios
ejecutar
aplicación
específica
sis-
temas
cliente
conecten
servicio
proporcionado
aplicación
concepto
grupo
particular
importancia
grupo
combina
recursos
unidades
ma-
yores
manejar
fácilmente
recuperación
fallos
balan-
ceado
carga
operaciones
realizadas
grupo
tales
transferir
grupo
nodo
afectan
automáticamente
recursos
grupo
recursos
implementan
bi-
bliotecas
dinámicas
DLL
gestionan
monitor
recursos
monitor
recursos
interac-
túa
servicio
cluster
llamadas
procedimiento
remoto
responde
comandos
servicio
cluster
configurar
mover
grupos
recursos
Figura
14.15
muestra
componentes
relaciones
sistema
cluster
Windows
gestor
nodo
responsable
mantener
pertenencia
nodo
cluster
Pe-
riódicamente
manda
mensajes
gestores
nodo
resto
nodos
cluster
caso
gestor
nodo
detecte
pérdida
mensajes
nodo
cluster
difunde
mensaje
cluster
miembros
intercambien
mensajes
verificar
gestor
nodo
responde
quita
cluster
grupos
activos
transfieren
nodos
activos
cluster
gestor
base
datos
configuración
guarda
base
datos
configuración
cluster
base
datos
contiene
información
recursos
grupos
pertenencia
grupos
nodos
gestores
base
datos
nodos
cluster
cooperan
mantener
ima-
gen
consistente
información
configuración
asegurar
cambios
configura-
ción
cluster
realizan
forma
consistente
correcta
utiliza
software
transacciones
tole-
rante
fallos
642
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
642El
gestor
recursos
gestor
recuperación
fallos
toma
decisiones
relativas
grupos
recursos
inicia
acciones
apropiadas
tales
inicializar
reinicializar
recuperar
fallos
requiere
recuperar
fallo
gestor
recuperación
fallos
nodo
activo
coopera
negociar
distribución
grupos
recursos
sistema
fallado
resto
sistemas
activos
sistema
reinicia
fallo
gestor
recuperación
fa-
llos
decidir
regresar
grupos
sistema
particular
configurar
grupo
propietario
preferente
propietario
falla
reinicia
grupo
vuelve
nodo
procesador
eventos
conecta
componentes
servicio
cluster
maneja
operacio-
nes
comunes
controla
inicialización
gestor
comunicaciones
gestiona
intercambio
mensajes
resto
nodos
cluster
gestor
global
actualizaciones
proporciona
ser-
vicio
utilizado
componentes
cluster
14.6
SUN
CLUSTER
Sun
Cluster
sistema
operativo
distribuido
construido
conjunto
extensiones
sis-
tema
UNIX
Solaris
Proporciona
visión
unificada
usuarios
aplicaciones
ven
cluster
única
computadora
ejecutando
sistema
operativo
Solaris
Figura
14.16
muestra
estructura
global
Sun
Cluster
principales
componentes
Soporte
objetos
comunicaciones
Procesamiento
distribuido
cliente
servidor
clusters
643
Herraminetas
gestión
cluster
API
DLL
cluster
Procesador
eventos
RPC
Monitor
recursos
Gestor
comunicacionesGestor
recursos
Gestor
recuperación
fallosDLL
recursos
aplicación
DLL
recursos
físicos
DLL
recursos
lógica
DLL
recursos
aplicación
Gestor
nodos
Servicio
cluster
Interfaz
gestión
recursos
nodos
App
conscientes
App
conscientes
cluster
Gestor
base
datos
Gestor
actualizaciones
globales
Figura
14.15
Diagrama
bloques
Windows
Cluster
Server
SHOR97
14-Capitulo
14
12/5/05
16:28
Página
643•
Gestión
procesos
Redes
Sistema
ficheros
distribuido
global
SOPORTE
OBJETOS
COMUNICACIONES
implementación
Sun
Cluster
orientada
objetos
utiliza
modelo
objetos
COR-
BA
véase
Apéndice
definir
objetos
llamadas
procedimiento
remoto
RPC
uti-
liza
Lenguaje
Definición
Interfaces
IDL
CORBA
especificar
interfaces
componentes
MC
nodos
objetos
MC
implementan
lenguaje
orienta-
do
objetos
C++
modelo
objetos
uniforme
IDL
proporciona
mecanismo
comunicación
procesos
nodo
construido
núcleo
Solaris
prácticamente
cambio
núcleo
GESTIÓN
PROCESOS
gestión
global
procesos
extiende
operaciones
procesos
forma
localización
proceso
transparente
usuario
Sun
Cluster
mantiene
visión
global
procesos
forma
cluster
identificador
único
proceso
nodo
locali-
zación
proceso
migración
procesos
descrita
Capítulo
15
proce-
so
mover
nodo
ciclo
vida
objetivo
lograr
balanceado
carga
recuperar
fallos
hilos
proceso
nodo
REDES
diseñadores
Sun
Cluster
consideraron
enfoques
manejo
tráfico
red
procesamiento
protocolo
red
único
nodo
particular
aplicación
basada
TCP
IP
tráfico
entrante
saliente
nodo
tráfico
entrante
nodo
analizaría
cabeceras
TCP
IP
mandaría
datos
encapsu-
644
Sistemas
operativos
Aspectos
internos
principios
diseño
Interfaz
llamadas
sistema
Aplicaciones
Red
Sun
cluster
Sistema
ficheros
Procesos
Invocación
objetos
Estructura
objetos
nodos
Núcleo
Solaris
existente
H11001
H11001
Figura
14.16
Estructura
Sun
Cluster
14-Capitulo
14
12/5/05
16:28
Página
644lados
nodo
apropiado
tráfico
saliente
nodo
encapsularía
datos
no-
cabeceras
TCP
IP
enfoque
escalable
número
nodos
descartó
Asignar
dirección
única
nodo
ejecutar
protocolos
red
nodo
problema
enfoque
configuración
cluster
deja
transparente
mundo
exterior
complicación
dificultad
recuperación
fallos
aplicación
ejecución
mueve
nodo
dirección
red
Utilizar
filtro
paquetes
enviar
paquetes
nodo
apropiado
procesa-
miento
protocolo
nodo
Externamente
cluster
servidor
única
dirección
IP
conexiones
entrantes
peticiones
clientes
balancean
nodos
disponibles
cluster
mecanismo
adoptado
Sun
Cluster
subsistema
red
Sun
Cluster
elementos
principales
paquetes
entrantes
reciben
nodo
adaptador
red
físicamente
instala-
do
nodo
receptor
filtra
paquete
envía
nodo
objetivo
correcto
usando
intercone-
xión
cluster
paquetes
salientes
envían
interconexión
cluster
nodo
múltiples
nodos
alternativos
conexión
física
red
externa
proce-
samiento
protocolo
paquetes
salientes
realiza
nodo
origen
mantiene
base
datos
configuración
red
anotar
tráfico
red
nodo
SISTEMA
FICHEROS
GLOBAL
elemento
importante
Sun
Cluster
sistema
ficheros
global
representado
Figura
14.17
compara
gestión
ficheros
MC
esquema
básico
Solaris
basan
conceptos
nodo-v
sistema
ficheros
virtual
Procesamiento
distribuido
cliente
servidor
clusters
645
Núcleo
Sistema
ficheros
Interfaz
nodo-v
VFS
Implementación
objeto
Sun
cluster(a
Solaris
estándar
Cache
Capa
proxy
Cache
Invocación
objeto
Núcleo
Sistema
ficheros
Interfaz
nodo-v
VFS
Sistema
ficheros
Sistema
ficheros
Interfaz
nodo-v
VFS
Figura
14.17
Extensiones
sistema
ficheros
Sun
Cluster
14-Capitulo
14
12/5/05
16:28
Página
645En
Solaris
utiliza
estructura
nodo
virtual
nodo-v
proporcionar
interfaz
potente
propósito
general
tipos
sistemas
ficheros
nodo-v
utiliza
asociar
páginas
memoria
espacio
direcciones
proceso
autorizar
acceso
sistema
ficheros
nodo-i
utilizan
asociar
procesos
ficheros
UNIX
nodo-v
asociar
proceso
objeto
tipo
sistema
ficheros
forma
llamada
sistema
necesita
entender
objeto
manipulando
necesita
llamada
orientada
objetos
adecuada
utilizando
interfaz
nodo-v
interfaz
nodo-v
acepta
mandatos
manipulación
ficheros
propósito
general
tales
read
write
traduce
acciones
adecuadas
sistema
ficheros
cuestión
nodo-v
utilizan
describir
objetos
individuales
sistema
ficheros
estructuras
sistema
ficheros
virtual
virtual
file
system
vfs
utilizan
describir
sistema
ficheros
completo
interfaz
vfs
acepta
mandatos
propósito
general
funcionan
ficheros
completos
traduce
accio-
nes
adecuadas
sistema
ficheros
cuestión
Sun
Cluster
sistema
ficheros
global
proporciona
interfaz
uniforme
fiche-
ros
distribuidos
cluster
proceso
abrir
fichero
localizado
sitio
clus-
ter
procesos
nodos
utilizan
ruta
localizar
fichero
im-
plementar
acceso
global
ficheros
MC
incluye
sistema
ficheros
proxy
construido
sistema
ficheros
Solaris
existente
interfaz
nodo-v
operaciones
vfs
nodo-v
convierten
invocación
objetos
capa
proxy
véase
Figura
14.17b
objeto
invocado
residir
nodo
sistema
objeto
invocado
realiza
operación
vfs
nodo-v
local
sistema
ficheros
subyacente
núcleo
sistema
ficheros
existente
modificados
soporte
entorno
global
ficheros
reducir
número
invocaciones
objetos
remotos
utiliza
cache
Sun
Cluster
so-
porta
cache
contenidos
ficheros
información
directorios
atributos
ficheros
14.7
CLUSTERS
BEOWULF
LINUX
1994
inició
proyecto
Beowulf
patrocinio
proyecto
NASA
High
Performance
Computing
and
Communications
HPCC
Computación
Comunicación
Altas
Prestaciones
objetivo
investigar
potencial
clusters
PC
tareas
importantes
com-
putación
superando
prestaciones
estaciones
trabajo
modernas
mínimo
coste
enfoque
Beowulf
ampliamente
implementado
tecnología
cluster
disponi-
ble
importante
CARACTERÍSTICAS
BEOWULF
principales
características
Beowulf
incluyen
siguientes
RIDG97
Componentes
genéricos
disponibles
mercado
Procesadores
dedicados
ciclos
disponibles
estaciones
trabajo
ociosas
red
privada
dedicada
LAN
WAN
combinación
redes
componente
Fácilmente
replicable
múltiples
vendedores
escalable
Basado
software
gratuito
disponible
646
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
646•
Utiliza
herramientas
computación
gratuitas
mínimos
cambios
Retorno
diseño
mejoras
comunidad
elementos
software
Beowulf
implementado
diversas
plataformas
elección
obvia
basa
Linux
implementaciones
Beowulf
utiliza
cluster
estaciones
trabajo
Linux
PCs
Figura
14.18
muestra
configuración
repre-
sentativa
cluster
serie
estaciones
trabajo
posiblemente
plataformas
hardware
ejecutando
sistema
operativo
Linux
almacenamiento
secundario
estación
trabajo
disponible
acceso
distribuido
compartición
ficheros
distribuida
me-
moria
virtual
distribuida
usos
nodos
cluster
sistemas
Linux
interconectan
red
normalmente
Ethernet
Ethernet
basada
conmutador
switch
conjunto
conmutadores
interconectados
utilizan
productos
Ethernet
velocidades
es-
tándar
10
Mbps
100Mbps
Gbps
BEOWULF
SOFTWARE
software
entorno
Beowulf
implementado
ampliación
distribuciones
Linux
gratuitas
fuente
principal
software
gratuito
Beowulf
sitio
www.beowulf.org
aun-
organizaciones
ofrecen
herramientas
utilidades
Beowulf
gratuitas
nodo
Cluster
Beowulf
ejecuta
copia
núcleo
Linux
funcionar
sistema
Linux
autónomo
soporte
cluster
Beowulf
realizan
extensiones
nú-
cleo
Linux
permitir
nodos
participar
serie
espacios
nombres
globales
Al-
gunos
ejemplos
software
sistema
Beowulf
siguientes
Espacio
procesos
distribuido
Beowulf
BPROC
paquete
permite
espacio
identificadores
proceso
expandirse
múltiples
nodos
entorno
cluster
pro-
porciona
mecanismos
iniciar
procesos
nodos
objetivo
paquete
proporcionar
elementos
clave
necesarios
imagen
única
sistema
clus-
ter
Beowulf
BPROC
proporciona
mecanismo
iniciar
procesos
nodos
remotos
Procesamiento
distribuido
cliente
servidor
clusters
647
Ethernet
Ethernets
interconectados
Estaciones
trabajo
Linux
Almacenamiento
compartido
distribuido
Figura
14.18
Configuración
genérica
Beowulf
14-Capitulo
14
12/5/05
16:28
Página
647haber
iniciado
sesión
nodo
procesos
remotos
visibles
tabla
procesos
cluster
Unión
canales
Ethernet
Beowulf
mecanismo
une
múltiples
redes
coste
red
lógica
ancho
banda
único
trabajo
adicional
red
tarea
costosa
distribuir
paquetes
colas
dispositivos
disponibles
mecanismo
permite
balancear
carga
múltiples
Ethernet
conectadas
estaciones
trabajo
Linux
Pvmsync
entorno
programación
proporciona
mecanismos
sincronización
objetos
datos
compartidos
procesos
cluster
Beowulf
EnFuzion
EnFuzion
consiste
conjunto
herramientas
computación
para-
métrica
describió
Sección
14.4
computación
paramétrica
implica
ejecución
programa
trabajos
parámetros
condi-
ciones
iniciales
EnFuzion
simula
conjunto
usuarios
robot
único
nodo
raíz
accederá
múltiples
clientes
forman
cluster
trabajo
configura
ejecutar
escenario
único
programado
conjunto
adecuado
condiciones
iniciales
KAPP00
14.8
RESUMEN
computación
cliente
servidor
clave
explotar
sistemas
información
redes
mejorar
significativamente
productividad
organizaciones
mecanismo
cliente
ser-
vidor
aplicaciones
computación
distribuyen
usuarios
estaciones
trabajo
com-
putadoras
personales
tiempo
recursos
compartidos
mantie-
nen
sistemas
servidores
disponibles
clientes
forma
arquitectura
cliente
servidor
mezcla
computación
descentralizada
centralizada
Normalmente
sistema
cliente
proporciona
interfaz
gráfica
usuario
GUI
permite
usuario
sacar
provecho
múltiples
aplicaciones
entrenamiento
mínimo
relativa
facilidad
servidores
mantienen
utilidades
compartidas
tales
sistemas
gestores
base
datos
aplicaciones
dividen
cliente
servidor
forma
optimice
facilidad
rendimiento
principal
mecanismo
necesario
sistema
distribuido
comunicación
procesos
suelen
utilizar
técnicas
paso
mensajes
generaliza
mensajes
má-
quina
aplican
tipos
convenciones
reglas
sincronización
técnica
llamadas
procedimiento
remoto
técnica
programas
máqui-
nas
interactúan
usando
sintaxis
semántica
llamadas
procedimiento
programa
lla-
mante
llamado
comportan
programa
asociado
estuviera
ejecutando
máquina
cluster
grupo
computadoras
completas
interconectadas
funcionando
conjunto
recurso
computación
unificado
crear
ilusión
única
máquina
término
computadora
completa
significa
sistema
ejecutar
forma
inde-
pendiente
cluster
14.9
LECTURAS
RECOMENDADAS
SITIOS
WEB
SING99
cubre
contenidos
capítulo
BERS96
contiene
discu-
sión
técnica
aspectos
diseño
hora
situar
aplicaciones
clientes
servidores
648
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
648en
estrategias
middleware
libro
comenta
productos
esfuerzos
estandarización
visión
general
tecnología
productos
middleware
BRIT04
REAG00a
REAG00b
minucioso
tratamiento
computación
cliente
servidor
enfoques
diseño
redes
soporte
dicha
computación
TANE85
contiene
resumen
sistemas
operativos
distribuidos
cubre
comu-
nicación
procesos
distribuida
gestión
procesos
distribuida
CHAN90
proporciona
visión
general
sistemas
operativos
paso
mensajes
distribuido
TAY90
resumen
enfoques
tomado
sistemas
operativos
implementar
llamadas
procedimiento
remoto
PFIS98
lectura
obligada
persona
interesada
clusters
libro
cubre
aspectos
diseño
hardware
software
compara
clusters
SMP
clusters
tratan
detalle
BUYY99a
BUYY99b
Beowulf
tratado
RIDG97
encontrar
detalles
Beowulf
STER99
Servidor
Cluster
Windows
describe
SHOR97
RAJA00
proporciona
mayores
detalles
Sun
Cluster
describe
SUN99
KHAL96
BERS96
Berson
A.
Client
Server
Architecture
New
York
McGraw-Hill
1996
BRIT04
Britton
C.
IT
Architectures
and
Middleware
Reading
MA
Addison-Wesley
2004
BUYY99a
Buyya
R.
High
Performance
Cluster
Computing
Architectures
and
Systems
Upper
Saddle
River
NJ
Prentice
Hall
1999
BUYY99b
Buyya
R.
High
Performance
Cluster
Computing
Programming
and
Applications
Upper
Saddle
River
NJ
Prentice
Hall
1999
CHAN90
Chandras
R.
Distributed
Message
Passing
Operating
Systems
Operating
Systems
Review
Enero
1990
KHAL96
Khalidi
et
Solaris
MC
Multicomputer
Proceedings
1996
USENIX
Conference
Enero
1996
PFIS98
Pfister
G.
In
Search
of
Clusters
Upper
Saddle
River
NJ
Prentice
Hall
1998
RAJA00
Rajagopal
R.
Introduction
to
Microsoft
Windows
NT
Cluster
Server
Boca
Raton
FL
CRC
Press
2000
REAG00a
Reagan
Client
Server
Computing
Upper
Saddle
River
NJ
Prentice
Hall
2000
REAG00b
Reagan
Client
Server
Network
Design
Operation
and
Management
Upper
Saddle
River
NJ
Prentice
Hall
2000
RIDG97
Ridge
D.
et
Beowulf
Harnessing
the
Power
of
Parallelism
in
Pile-of-PCs
Proceedings
IEEE
Aerospace
1997
SHOR97
Short
R.
Gamache
R.
Vert
J.
Massa
M.
Windows
NT
Clusters
for
Availability
and
Scala-
bility
Proceedings
COMPCON
Spring
97
Febrero
1997
SING99
Singh
H.
Progressing
to
Distributed
Multiprocessing
Upper
Saddle
River
NJ
Prentice
Hall
1999
STER99
Sterling
et
How
to
Build
Beowulf
Cambridge
MA
MIT
Press
1999
SUN99
Sun
Microsystems
«Sun
Cluster
Architecture
White
Paper
Proceedings
IEEE
Computer
So-
ciety
International
Workshop
on
Cluster
Computing
Diciembre
1999
TANE85
Tanenbaum
A.
Renesse
R.
Distributed
Operating
Systems
Computing
Surveys
Diciem-
bre
1985
TA
Y90Tay
B.
Ananda
A.
Survey
of
Remote
Procedure
Calls
Operating
Systems
Review
Julio
1990
Procesamiento
distribuido
cliente
servidor
clusters
649
14-Capitulo
14
12/5/05
16:28
Página
649SITIOS
WEB
RECOMENDADOS
SQL
Standards
principales
fuentes
información
estándar
SQL
documentación
actualizada
IEEE
Computer
Society
Task
Force
on
Cluster
Computing
foro
internacional
promover
investigación
educación
computación
cluster
Beowulf
foro
internacional
promover
investigación
educación
computa-
ción
cluster
14.10
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
Beowulf
cluster
mensaje
cliente
interfaz
programación
middleware
cliente
ligero
aplicaciones
API
paso
mensajes
distribuido
cliente
pesado
interfaz
gráfico
usuario
GUI
recuperación
fallos
failback
cliente
servidor
llamadas
procedimiento
restauración
fallos
failover
consistencia
cache
ficheros
remoto
RPC
servidor
CUESTIONES
REPASO
14.1
computación
cliente
servidor
14.2
diferencia
computación
cliente
servidor
tipos
procesamiento
da-
tos
distribuido
14.3
papel
arquitectura
comunicaciones
TCP
IP
entorno
cliente
servidor
14.4
Plantee
razones
fundamentales
situar
aplicaciones
cliente
servidor
dividirlas
cliente
servidor
14.5
clientes
ligeros
pesados
filosofías
enfoques
14.6
Sugiera
pros
contras
estrategias
clientes
ligeros
clientes
pesados
14.7
Explique
fundamentos
arquitectura
cliente
servidor
capas
14.8
middleware
14.9
estándares
TCP
IP
necesita
middleware
14.10
Enumere
ventajas
desventajas
primitivas
bloqueantes
bloqueantes
paso
mensajes
14.11
Enumere
ventajas
desventajas
enlazado
persistente
persistente
RPC
650
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
65014.12
Enumere
ventajas
desventajas
RPC
síncrono
asíncrono
14.13
Enumere
defina
brevemente
métodos
cluster
PROBLEMAS
14.1
porcentaje
código
programa
ejecutar
forma
simultánea
computadoras
cluster
utilizando
conjunto
parámetros
condiciones
iniciales
Suponga
código
restante
ejecutado
se-
cuencialmente
procesador
procesador
tasa
ejecución
MIPS
Deduzca
expresión
tasa
MIPS
efectiva
sistema
única-
mente
ejecutar
programa
Hágalo
términos
x.
16
MIPS
determine
valor
rendimiento
siste-
ma
40
MIPS
14.2
aplicación
ejecutando
cluster
computadoras
programa
análi-
sis
comparativo
benchmark
tarda
tiempo
cluster
25%
tiem-
po
aplicación
ejecutando
computadoras
tiempo
restante
aplicación
ejecuta
computadora
Calcule
ganancia
speedup
efectiva
condiciones
anteriormente
expuestas
comparación
ejecución
programa
computadora
cal-
cule
porcentaje
código
paralelizado
programado
compilado
programa
Suponga
capaces
utilizar
18
computadoras
lugar
paralelizada
código
Calcule
ganancia
efectiva
logra
14.3
ejecutar
programa
FORTRAN
computadora
ejecutar
versión
paralela
cluster
32
computadoras
L1
DO
10
1,1024
L2
SUM(I)=0
L3
DO
20
L4
20
SUM(I
SUM(I
L5
10
CONTINUE
Suponga
líneas
llevan
ciclos
máquina
incluyendo
activida-
des
procesador
acceso
memoria
Ignore
sobrecarga
generada
senten-
cias
control
líneas
restantes
sobrecargas
sistema
conflictos
recursos
tiempo
ejecución
tiempo
ciclos
máquina
programa
computadora
Divida
iteraciones
bucle
32
computadoras
computadora
ejecuta
32
ciclos
32
procesador
ejecuta
siguientes
32
iteraciones
sucesivamente
tiempo
ejecución
factor
ganancia
comparación
apartado
Note
carga
computa-
cional
mandada
bucle
reparte
computadoras
Procesamiento
distribuido
cliente
servidor
clusters
651
14-Capitulo
14
12/5/05
16:28
Página
651c
Explique
modificar
paralelización
generar
ejecución
paralela
balan-
ceada
trabajo
computación
32
nodos
carga
balanceada
entiende
número
sumas
asignadas
computadora
am-
bos
bucles
tiempo
mínimo
ejecución
32
computadoras
ga-
nancia
resultante
frente
única
computadora
652
Sistemas
operativos
Aspectos
internos
principios
diseño
14-Capitulo
14
12/5/05
16:28
Página
652CAPÍTULO
15
Gestión
procesos
distribuidos
15.1
Migración
procesos
15.2
globales
distribuidos
15.3
Exclusión
mutua
distribuida
15.4
Interbloqueo
distribuido
15.5
Resumen
15.6
Lecturas
recomendadas
15.7
érminos
clave
cuestiones
repaso
problemas
15-Capitulo
15
12/5/05
16:28
Página
653N
capítulo
examina
mecanismos
clave
utilizados
sistemas
operativos
distribuidos
examinamos
migración
procesos
movimiento
proceso
activo
máquina
examinamos
cuestión
procesos
sistemas
coordinar
actividades
gobernado
reloj
local
retar-
do
intercambio
información
Finalmente
exploramos
aspectos
clave
gestión
procesos
distribuidos
exclusión
mutua
interbloqueo
15.1
MIGRACIÓN
PROCESOS
migración
procesos
transferencia
suficiente
cantidad
proceso
computador
proceso
ejecute
máquina
destino
interés
con-
cepto
surge
investigación
métodos
equilibrio
carga
múltiples
sistemas
interconectados
aplicación
concepto
extiende
allá
área
artículos
distribución
carga
basaban
implementaciones
reales
migración
procesos
incluye
capacidad
expulsar
proce-
so
máquina
reactivarlo
posteriormente
experiencia
muestra
migración
procesos
expulsiva
sobrecarga
complejidad
mayores
anticipadas
originalmente
ARTS89a
coste
llevó
observadores
concluyesen
migración
procesos
práctica
Tales
afirmaciones
probado
pesimistas
imple-
mentaciones
incluyendo
productos
comerciales
promovido
interés
continuado
desarrollos
área
sección
ofrece
repaso
MOTIVACIÓN
migración
procesos
deseable
sistemas
distribuidos
razones
SMIT88,JUL88
incluyendo
siguientes
Compartición
carga
Moviendo
procesos
sistema
cargado
cargado
carga
equilibrarse
mejorar
rendimiento
global
Datos
empíricos
sugieren
posibles
mejoras
rendimiento
sustanciales
LELA86,CABR86
te-
nerse
cuidado
diseño
algoritmos
equilibrio
carga
EAGE86
notar
comunicación
necesaria
sistema
distribuido
realice
equilibrado
rendimiento
ESKI90
encontrarse
exposición
aspecto
referencias
estudios
Rendimiento
comunicaciones
procesos
interaccionan
intensivamente
llevarse
nodo
reducir
coste
comunicaciones
dure
interac-
ción
proceso
realizando
análisis
datos
fichero
con-
ficheros
tamaño
proceso
ventajoso
mover
proceso
ha-
cia
datos
viceversa
Disponibilidad
necesitar
procesos
larga
duración
muevan
sobre-
vivir
caso
fallos
puedan
conocidos
anticipadamente
anticipándose
paradas
sistema
planificadas
sistema
operativo
proporciona
información
proceso
desea
continuar
migrar
sistema
asegurarse
rearrancarse
sistema
actual
momento
posterior
654
Sistemas
operativos
Aspectos
internos
principios
diseño
15-Capitulo
15
12/5/05
16:28
Página
654•
Utilización
facilidades
especiales
proceso
moverse
ventaja
facilidad
hardware
software
existente
únicamente
nodo
particular
MECANISMOS
MIGRACIÓN
PROCESOS
diseño
servicio
migración
procesos
considerarse
aspectos
encuentran
siguientes
inicia
migración
proceso
migra
sucede
mensajes
señales
pendientes
Iniciación
migración
inicie
migración
dependerá
objetivo
servicio
mi-
gración
objetivo
equilibrado
carga
módulo
sistema
operativo
monitorizando
carga
sistema
generalmente
responsable
decidir
su-
ceder
migración
módulo
responsable
expulsar
señalar
proceso
emigrar
determinar
migrar
módulo
necesitará
comunicación
módulos
sistemas
monitorizar
patrón
carga
sistemas
objetivo
alcan-
zar
recursos
particulares
proceso
migrarse
surja
nece-
sidad
caso
proceso
existencia
sistema
distribuido
caso
función
migración
completa
existencia
múltiples
sistemas
transparente
proceso
migra
migra
proceso
necesario
destruir
proceso
sistema
origen
crearlo
sistema
destino
movimiento
proceso
replicación
ima-
gen
proceso
consistiendo
mínimo
bloque
control
proceso
moverse
vínculo
proceso
procesos
tales
paso
mensajes
señales
actualizarse
Figura
15.1
ilustra
consideraciones
Proceso
migrado
má-
quina
pasar
Proceso
máquina
D.
identificadores
enlace
tengan
procesos
denotados
letras
minúsculas
permanecen
responsabilidad
sistema
operativo
mover
bloque
control
proceso
actualizar
mapa
enlaces
transferencia
proceso
máquina
invisible
proceso
migrado
pa-
trones
comunicación
movimiento
bloque
control
proceso
presenta
complicación
dificultad
punto
vista
prestaciones
espacio
direcciones
proceso
fichero
abierto
encuentre
asignado
proceso
Considérese
espacio
direcciones
pro-
ceso
asúmase
utiliza
esquema
memoria
virtual
paginación
paginación
segmenta-
ción
considerarse
siguientes
estrategias
MILO00
Ambicioso
Transferir
espacio
direcciones
completo
momento
migra-
ción
ciertamente
enfoque
necesidad
dejar
atrás
antiguo
sistema
traza
proceso
espacio
direcciones
proceso
necesitar
innecesariamente
cos-
toso
costes
iniciales
migración
orden
minutos
implementa-
ciones
proporcionan
servicios
punto-de-recuperación
checkpointing
rearranque
sue-
len
utilizar
enfoque
sencillo
punto-de-recuperación
rearranque
espacio
direcciones
localizado
Precopia
proceso
continúa
ejecución
nodo
origen
espacio
direccio-
nes
copia
nodo
destino
páginas
modificadas
origen
operación
Gestión
procesos
distribuidos
655
15-Capitulo
15
12/5/05
16:28
Página
655copia
copiadas
estrategia
reduce
tiempo
proceso
pasa
congelado
ejecutar
migración
Ambicioso
sucias
Transferir
páginas
espacio
direcciones
memoria
principal
modificadas
bloque
adicional
espacio
di-
recciones
virtuales
transferirá
demanda
minimiza
cantidad
datos
transfieren
requiere
obstante
máquina
origen
continúe
involucrada
vida
proceso
manteniendo
tablas
páginas
segmentos
requiere
soporte
pagina-
ción
remota
Copiar-al-referenciar
variación
ambicioso
sucias
páginas
entregadas
referencia
menor
coste
inicial
migración
proceso
yendo
decenas
centenas
microsegundos
Volcado
páginas
proceso
eliminan
memoria
principal
origen
volcando
páginas
sucias
disco
accede
páginas
necesiten
disco
memoria
nodo
origen
estrategia
libera
origen
necesidad
man-
página
proceso
migrado
memoria
principal
liberando
inmediatamente
bloque
memoria
usarse
procesos
656
Sistemas
operativos
Aspectos
internos
principios
diseño
Núcleo
Máquina
migrar
P1
P2
P3
P4
P5
ab
ef
P1
P2
P3
3a
1d
2c
3a
2c
migrar
P1
P2
P4
P5
ab
P1
P2
P3
P4
4a
ef
Núcleo
Núcleo
Núcleo
Máquina
Máquina
Máquina
Figura
15.1
Ejemplo
migración
procesos
15-Capitulo
15
12/5/05
16:28
Página
656Si
proceso
espacio
direcciones
máquina
destino
ejemplo
proceso
temporal
máquina
trabajar
archivo
retornará
sentido
utilizar
es-
trategias
acceder
momento
espacio
direccio-
nes
máquina
destino
despiece
bloques
transferencia
espa-
cio
direcciones
eficiente
simplemente
transferir
espacio
direcciones
momento
migración
usando
primeras
estrategias
casos
anticipación
necesario
utilizar
espacio
direcciones
residente
obstante
proceso
estructurado
hilos
unidad
básica
migración
hilo
proceso
estrategia
basada
paginación
remota
estrategia
obligato-
ria
restantes
hilos
proceso
quedan
atrás
necesitan
acceder
espacio
direcciones
proceso
migración
hilos
implementada
sistema
operativo
Emerald
JUL89
Consideraciones
similares
aplicación
movimiento
ficheros
abiertos
fichero
inicialmente
sistema
proceso
migrar
fichero
bloqueado
ac-
ceso
exclusivo
proceso
sentido
transferir
fichero
proceso
peligro
proceso
salir
temporal
necesitar
fi-
chero
retorne
sentido
transferir
archivo
entero
proceso
migrado
realice
solicitud
acceso
archivo
compartido
múlti-
ples
procesos
distribuidos
acceso
distribuido
fichero
mantenerse
mover
fichero
permite
cache
sistema
Sprite
Figura
14.7
introduce
complejidad
adicional
ejemplo
proceso
abierto
fichero
escritura
duplica
migra
hijo
fichero
estaría
abierto
escritura
máquinas
distintas
algo-
ritmo
consistencia
cache
Sprite
dicta
archivo
pasar
cacheable
máquinas
ejecutando
procesos
DOUG89,DOUG91
Mensajes
señales
aspecto
enumerados
previamente
mensajes
se-
ñales
ataca
proporcionando
mecanismo
almacenar
mensajes
señales
pendientes
temporalmente
acto
migración
redirigiéndolos
destino
necesario
mantener
información
redireccionamiento
sitio
inicial
tiempo
asegurar
mensajes
señales
pendientes
trasladado
escenario
migración
ejemplo
representativo
auto-migración
considérese
facili-
dades
servicio
disponible
sistema
operativo
AIX
IBM
WALK89
sistema
operati-
vo
UNIX
distribuido
funcionalidad
similar
dispone
sistema
operativo
LOCUS
POPE85
sistema
AIX
basado
desarrollo
LOCUS
servicio
portado
tam-
bién
sistema
operativo
OSF/1
AD
nombre
TNC
ZAJC93
Ocurre
secuencia
eventos
proceso
decide
migrarse
selecciona
máquina
objetivo
envía
mensaje
tarea
remota
mensaje
imagen
proceso
informa-
ción
ficheros
abiertos
sitio
destino
proceso
servidor
núcleo
crea
hijo
pasándole
información
mensaje
proceso
solicita
datos
entorno
argumentos
información
pila
medida
necesita
completar
operación
código
programa
copia
sucio
limpio
pagina
demanda
sistema
ficheros
global
Gestión
procesos
distribuidos
657
15-Capitulo
15
12/5/05
16:28
Página
6574
proceso
original
señala
completa
migración
proceso
envía
mensaje
proceso
destruye
secuencia
similar
seguiría
proceso
inicia
migración
principal
diferencia
proceso
migrar
encontrarse
suspendido
migrarse
eje-
cución
procedimiento
Sprite
ejemplo
DOUG89
escenario
precedente
migración
actividad
dinámica
conlleva
número
pasos
trasladar
imagen
proceso
migración
inicia
proceso
auto-migración
proceso
copiará
imagen
proceso
espacio
direcciones
completo
fichero
destruirá
proceso
copiara
fichero
máquina
usando
servicio
transferencia
ficheros
recreará
proceso
fichero
máquina
destino
SMIT89
describe
enfoque
Negociación
migración
aspecto
migración
procesos
relacionado
decisiones
migración
casos
decisión
toma
única
entidad
ejemplo
objetivo
equilibrado
carga
módulo
monitoriza
carga
relativa
máqui-
nas
realiza
migración
necesario
mantener
carga
equilibrada
utiliza
auto-migración
permitir
proceso
acceder
funcionalidades
especiales
ficheros
remotos
proceso
tomar
decisión
sistemas
permi-
ten
sistema
destino
designado
participe
decisión
razón
preservar
tiempo
respuesta
usuarios
usuario
estación
trabajo
ejemplo
su-
frir
degradación
significativa
tiempo
respuesta
proceso
migra
sistema
migración
sirve
proporcionar
equilibrio
global
ejemplo
mecanismo
negociación
Charlotte
FINK89,ARTS89b
política
migración
migrar
proceso
destino
responsabilidad
utilidad
Starter
proceso
responsable
planificación
plazo
ubicación
memoria
Starter
coordinar
políticas
áreas
proceso
Starter
pue-
controlar
grupo
máquinas
Starter
recibe
oportunamente
estadísticas
carga
elaboradas
frecuentemente
precisión
núcleo
máquinas
decisión
migrar
alcanzarse
conjuntamente
procesos
Starter
nodo
origen
nodo
destino
ilustra
Figura
15.2
Suceden
siguientes
pasos
Starter
controla
sistema
origen
decide
proceso
migrado
sistema
destino
concreto
Envía
mensaje
Starter
solicitando
transferencia
Starter
preparado
recibir
procesos
envía
vuelta
mensaje
positivo
reconocimiento
Starter
comunica
decisión
núcleo
vía
llamada
servicio
Starter
ejecuta
mensaje
tarea
núcleo
KJ
máquina
Starter
eje-
cuta
máquina
KJ
proceso
utilizado
convertir
mensajes
procesos
remotos
llamadas
servicios
sistema
núcleo
ofrece
envío
proceso
oferta
incluye
estadísticas
acerca
tales
edad
cargas
procesador
comunicaciones
escaso
recursos
rechazar
oferta
caso
contrario
núcleo
repite
oferta
controlador
Starter
repetición
incluye
información
oferta
S.
decisión
política
Starter
comunica
llamada
Inmigrar
reserva
recursos
necesarios
evitar
interbloqueo
problemas
control
flujo
envía
aceptación
S.
658
Sistemas
operativos
Aspectos
internos
principios
diseño
15-Capitulo
15
12/5/05
16:28
Página
658La
Figura
15.2
muestra
procesos
enlaces
abiertos
si-
guiendo
pasos
anteriores
máquina
reside
enviar
mensaje
actualización
enlace
ambas
máquinas
preservar
enlaces
P.
mensajes
actua-
lización
enlace
indican
dirección
carga
enlace
mantenido
requieren
recono-
cimiento
núcleos
notificados
objetivo
sincronización
punto
men-
saje
enviado
cualquiera
enlaces
enviado
directamente
D.
mensajes
intercambiados
concurrentemente
siguiendo
pasos
acaban
describir
Finalmente
paso
enlaces
actualizado
recolecta
contexto
único
mensaje
envía
D.
máquina
ejecutando
Charlotte
involucrada
migración
comunicación
sistemas
episodio
DESALOJO
mecanismo
negociación
permite
sistema
destino
rechace
acepte
migración
proceso
útil
permitir
sistema
expulse
proceso
inmigró
ejemplo
estación
trabajo
ociosa
procesos
migrado
usuario
estación
trabajo
pase
activo
necesario
desalojar
procesos
inmigrados
proporcionar
adecuado
tiempo
respuesta
ejemplo
capacidad
desalojo
verse
Sprite
DOUG89
Sprite
sistema
operativo
estaciones
trabajo
proceso
aparenta
ejecutar
único
sistema
du-
rante
vida
sistema
conoce
nodo
original
proceso
proceso
migrar
pasa
proceso
foráneo
máquina
destino
instante
máquina
desti-
desalojar
proceso
foráneo
obligado
volver
migrar
nodo
original
elementos
mecanismo
desalojo
Sprite
Gestión
procesos
distribuidos
659
23
Starter
Tomarás
migrar
máquina
Ofertar
Ofertar
Inmigrar
Aceptar
oferta
Emigrar
KJ
KJ
KJ
KJ
KJ
Starter
Figura
15.2
Negociación
migración
proceso
15-Capitulo
15
12/5/05
16:28
Página
6591
proceso
monitor
nodo
guarda
constancia
carga
actual
determinar
aceptar
procesos
foráneos
monitor
detecta
actividad
consola
estación
trabajo
iniciar
procedimiento
desalojo
proceso
foráneo
proceso
expulsa
migrar
vuelta
nodo
origen
proceso
mi-
grar
nuevamente
nodo
disponible
tiempo
expulsar
procesos
procesos
marcados
desalojo
suspenden
inmediatamente
Permitir
proceso
desalojado
ejecutar
esperando
expulsión
reducir
tiempo
proceso
congelado
reduce
potencia
proceso
disponible
máquina
realizando
desalojos
espacio
direcciones
completo
proceso
desalojado
transfiere
nodo
original
tiempo
expulsar
proceso
migrarlo
vuelta
nodo
original
reducido
sustancialmente
rescatando
imagen
memoria
proceso
desalojado
má-
quina
hospedó
anteriormente
medida
referencie
implica
máquina
hospedó
dedique
recursos
conteste
solicitudes
servicio
proceso
desalojado
periodo
tiempo
necesario
TRANSFERENCIAS
EXPULSIVAS
VERSUS
EXPULSIVAS
exposición
sección
abordamos
migración
procesos
expulsiva
involucra
transferencia
procesos
ejecutados
parcialmente
procesos
cuya
creación
com-
pletado
función
sencilla
transferencia
procesos
expulsiva
involucra
proce-
sos
comenzado
ejecución
requieren
transferencia
proce-
so
tipos
transferencia
información
acerca
entorno
proceso
ejecutará
transferirse
nodo
remoto
incluir
directorio
actual
trabajo
usuario
privi-
legios
heredados
proceso
recursos
heredados
descriptores
fichero
migración
procesos
expulsiva
útil
equilibrado
carga
ejemplo
véase
SHIV92
ventaja
evitar
sobrecarga
migrar
procesos
desventaja
esquema
reacciona
cambios
súbitos
distribución
carga
15.2
GLOBALES
DISTRIBUIDOS
GLOBALES
INSTANTÁNEAS
DISTRIBUIDAS
aspectos
concurrencia
enfrentamos
sistema
fuertemente
acopla-
do
tales
exclusión
mutua
interbloqueo
inanición
aparecen
sistema
distribuido
estrategias
diseño
áreas
complican
global
sistema
sistema
operativo
proceso
actual
procesos
sistema
distribuido
proceso
actual
procesos
sistema
local
accediendo
bloques
con-
trol
proceso
memoria
procesos
remotos
proceso
informa-
ción
reciba
vía
mensajes
representa
proceso
remoto
momento
análogo
situación
astronomía
conocimiento
cier-
ta
estrella
galaxia
distante
consiste
luz
ondas
electromagnéticas
llegan
objeto
distante
ondas
proporcionan
imagen
objeto
momento
ejemplo
conocimiento
objeto
distancia
años
luz
años
antigüedad
660
Sistemas
operativos
Aspectos
internos
principios
diseño
15-Capitulo
15
12/5/05
16:28
Página
660Los
retardos
tiempo
impuestos
naturaleza
sistemas
distribuidos
complican
aspectos
relacionados
concurrencia
ilustrar
presentamos
ejemplo
tomado
ANDR90
Utilizaremos
gráficos
proceso
evento
Figuras
15.3
15.4
ilustrar
problema
gráficos
línea
horizontal
proceso
representa
eje
tiempo
punto
línea
corresponde
evento
ej.
evento
interno
proceso
mensaje
enviado
mensaje
recibido
caja
recuadrando
punto
representa
instantánea
local
proceso
to-
mada
instante
flecha
representa
mensaje
procesos
ejemplo
individuo
bancaria
distribuida
filiales
ban-
co
determinar
saldo
cliente
banco
determinar
saldo
filial
Suponga
información
registrarse
exactamente
15:00
horas
Figura
15.3a
muestra
instancia
saldo
100.00
combinada
si-
tuación
Figura
15.3b
saldo
filial
tránsito
fi-
lial
momento
observación
resultado
lectura
falsa
0.00
problema
par-
ticular
resolverse
examinando
mensajes
tránsito
momento
observación
filial
guardará
registro
transferencias
identidad
desti-
natario
transferencia
incluiremos
filial
saldo
actual
registro
transferencias
examinan
cuentas
observador
transferencia
curso
filial
destinado
cliente
filial
B.
cantidad
llegado
filial
sumada
saldo
cantidad
transferido
recibido
contada
saldo
receptora
estrategia
segura
muestra
Figura
15.3c
ejemplo
relojes
ramas
perfectamente
sincronizados
cliente
filial
15:00
horas
indica
saldo
100.00
cantidad
transfiere
continuación
filial
15:01
reloj
llega
14:59
reloj
B.
cantidad
contabiliza
observación
15:00
entender
dificultad
encontramos
formular
solución
definen
si-
guientes
términos
Canal
canal
procesos
intercambian
mensajes
entender
canal
camino
medios
mensaje
transfiere
conveniencia
ca-
nales
consideran
unidireccionales
procesos
intercambian
mensajes
requieren
canales
dirección
transferencia
mensajes
proceso
secuencia
mensajes
enviado
recibido
canales
inciden
proceso
Instantánea
instantánea
registra
proceso
instantánea
incluye
registro
mensajes
enviados
recibidos
canales
instantánea
global
combinado
procesos
Instantánea
distribuida
colección
instantáneas
proceso
problema
global
real
determinarse
lapso
tiempo
asocia-
do
transferencia
mensajes
intentar
definir
global
recolectando
ins-
tantáneas
procesos
ejemplo
global
Figura
15.4a
momento
tomar
instantáneas
muestra
mensaje
tránsito
canal
tránsito
canal
tránsito
canal
mensajes
representados
apropiadamente
mensaje
instantánea
distribuida
indica
mensaje
recibido
enviado
Gestión
procesos
distribuidos
661
15-Capitulo
15
12/5/05
16:28
Página
661Deseamos
instantánea
distribuida
registre
global
consistente
glo-
bal
consistente
proceso
registra
recepción
mensaje
envío
mensaje
registrado
proceso
envió
mensaje
Figura
15.4b
ofrece
ejemplo
global
inconsistente
surge
proceso
registrado
recepción
mensaje
proceso
emisor
correspondiente
registrado
mensaje
enviado
Figura
15.4a
ALGORITMO
INSTANTÁNEA
DISTRIBUIDA
CHAN85
describe
algoritmo
instantánea
distribuida
registra
global
con-
sistente
algoritmo
asume
mensajes
entregan
orden
envían
pierden
mensajes
protocolo
transporte
fiable
ej.
TCP
satisface
requisitos
algoritmo
mensaje
control
especial
denominado
marcador
proceso
inicia
algoritmo
registrando
enviando
marcador
canales
salientes
enviar
mensaje
proceso
procede
recepción
marcador
digamos
proceso
proceso
receptor
reali-
za
662
Sistemas
operativos
Aspectos
internos
principios
diseño
Filial
/H11005
100
/H11005
SA
/H11005
100
SA
/H11005
SA
/H11005
100
SB
/H11005
100
SB
/H11005
SB
/H11005
3:00
Filial
Filial
msg
/H11005
Transferir
100
filial
3:00
3:00
3:01
2:59
Filial
Filial
msg
Transferir
100
filial
/H11005
200
3:00
3:00
3:01
2:59
Filial
Figura
15.3
Ejemplo
determinación
globales
15-Capitulo
15
12/5/05
16:28
Página
6621
registra
local
Sp
registra
canal
entrante
vacío
propaga
marcador
vecinos
canales
salientes
pasos
realizarse
atómicamente
enviar
recibir
mensajes
pasos
momento
recordar
recibe
marcador
canal
entran-
digamos
proceso
registra
canal
secuencia
mensajes
recibido
registró
local
instante
recibía
marcador
r.
algoritmo
termina
proceso
recibido
marcador
canal
entrante
ANDR90
realizan
siguientes
observaciones
acerca
algoritmo
proceso
comenzar
algoritmo
enviando
marcador
no-
independientemente
decidir
registrar
algoritmo
funcionará
algoritmo
terminará
tiempo
finito
mensaje
incluyendo
mensajes
marca-
dores
entrega
tiempo
finito
algoritmo
distribuido
proceso
responsable
registrar
canales
entrantes
Gestión
procesos
distribuidos
663
SB
SB
M1
M1
M2
M2
M3
M4
Sc
Proceso
Proceso
global
incosistente
Proceso
SB
Proceso
Proceso
global
consistente
Proceso
M4M3
Figura
15.4
globales
inconsistentes
consistentes
15-Capitulo
15
12/5/05
16:28
Página
6634
registrado
algoritmo
terminado
pro-
cesos
global
consistente
obtenido
algoritmo
ensamblarse
pro-
ceso
proceso
envíe
datos
registrado
canal
saliente
proceso
reenvíe
datos
recibe
canal
saliente
Alternativamente
proceso
iniciador
consultar
proce-
sos
adquirir
global
algoritmo
afecta
afectado
algoritmo
distribuido
pro-
cesos
estén
participando
ejemplo
algoritmo
tomado
BEN90
considere
conjunto
procesos
ilustrado
Figura
15.5
nodo
representa
proceso
línea
representa
canal
unidi-
reccional
nodos
dirección
indicada
flecha
Suponga
ejecuta
algorit-
mo
instantánea
mensajes
deberán
enviarse
canal
saliente
proceso
proceso
decide
registrar
global
enviar
mensajes
inde-
pendientemente
proceso
decide
registrar
global
enviar
mensajes
terminar
recolectan
instantáneas
proceso
resultados
muestran
Figura
15.6
proce-
so
envía
mensajes
canales
salientes
procesos
re-
gistrar
recibido
mensajes
proceso
registrar
dejando
mensajes
asociarlos
canal
lector
comprobar
consistencia
instantá-
nea
mensaje
enviado
recibido
proceso
destino
registrado
trán-
sito
canal
664
Sistemas
operativos
Aspectos
internos
principios
diseño
Figura
15.5
Gráfico
procesos
canales
Figura
15.6
Ejemplo
instantánea
Proceso
Proceso
Canales
salientes
Canales
salientes
enviado
enviado
enviado
Canales
entrantes
Canales
entrantes
recibido
almacenado
recibido
almacenado
recibido
Proceso
Proceso
Canales
salientes
Canales
salientes
enviado
enviado
enviado
Canales
entrantes
Canales
entrantes
recibido
almacenado
recibido
almacenado
recibido
15-Capitulo
15
12/5/05
16:28
Página
664El
algoritmo
instantánea
distribuida
herramienta
potente
flexible
usarse
adaptar
algoritmo
centralizado
entorno
distribuido
base
algo-
ritmo
centralizado
conocimiento
global
Ejemplos
específicos
detección
in-
terbloqueo
detección
terminación
proceso
ejemplo
véase
BEN90
LYNC96
usarse
proporcionar
instantánea
algoritmo
distribuido
permitir
recuperación
detecta
fallo
15.3
EXCLUSIÓN
MUTUA
DISTRIBUIDA
recuerda
Capítulos
consideramos
aspectos
relacionados
ejecución
procesos
concurrentes
problemas
claves
aparecieron
exclusión
mutua
interbloqueo
Capítulos
centraban
soluciones
problema
contexto
sistema
único
procesadores
memoria
principal
común
tratar
sistema
operativo
distribuido
colección
procesadores
comparten
memoria
principal
reloj
aparecen
dificultades
necesitan
soluciones
algoritmos
exclusión
mutua
interbloqueo
depender
intercambio
mensajes
depender
acce-
so
memoria
común
sección
examinamos
exclusión
mutua
interblo-
queo
contexto
sistema
operativo
distribuido
CONCEPTOS
EXCLUSIÓN
MUTUA
DISTRIBUIDA
procesos
compiten
recursos
sistema
necesidad
meca-
nismo
cumplir
exclusión
mutua
Suponga
procesos
requieren
acceder
recurso
único
compartible
impresora
curso
ejecución
proceso
enviando
mandatos
dispositivo
recibiendo
información
enviando
datos
recibiendo
datos
referiremos
recurso
recurso
crítico
porción
programa
utilizan
sección
crítica
programa
importante
programa
tiempo
permita
sección
crítica
simplemente
delegar
sistema
operativo
detecte
haga
cumplir
restricción
requisitos
detallados
obvios
caso
impre-
sora
ejemplo
deseamos
proceso
individual
control
impresora
im-
prime
archivo
entero
entremezclarían
líneas
procesos
competencia
éxito
concurrencia
procesos
precisa
habilidad
definir
secciones
críti-
cas
cumplir
exclusión
mutua
fundamental
esquema
procesa-
miento
concurrente
servicio
capacidad
pretenda
proporcionar
soporte
exclu-
sión
mutua
cumplir
siguientes
requisitos
exclusión
mutua
hacerse
cumplir
procesos
secciones
críticas
recurso
objeto
compartido
permite
proceso
tiempo
es-
tar
sección
crítica
proceso
sección
crítica
interferir
procesos
proceso
solicita
acceso
sección
crítica
retardado
in-
definidamente
interbloqueo
inanición
proceso
sección
crítica
proceso
solicite
entrar
sec-
ción
crítica
deberá
entrar
retardo
realizarse
suposiciones
velocidad
relativa
procesos
número
procesadores
proceso
permanece
sección
crítica
tiempo
finito
Gestión
procesos
distribuidos
665
15-Capitulo
15
12/5/05
16:28
Página
665La
Figura
15.7
muestra
modelo
utilizar
examinar
soluciones
exclusión
mutua
contexto
distribuido
Asumimos
número
sistemas
interconectados
tipo
servicio
comunicaciones
sistema
asumimos
función
proce-
so
sistema
operativo
responsable
ubicación
recursos
proce-
sos
controla
número
recursos
sirve
número
procesos
usuario
tarea
en-
contrar
algoritmo
procesos
puedan
cooperar
exclusión
mutua
algoritmos
exclusión
mutua
centralizados
distribuidos
algoritmo
centralizado
designa
nodo
nodo
control
controlar
acceso
objetos
compartidos
proceso
requiere
acceso
recurso
crítico
emite
solici-
tud
proceso
local
controlador
recursos
proceso
envía
mensaje
solicitud
nodo
control
devuelve
mensaje
respuesta
permiso
objeto
compartido
pasa
disponible
proceso
terminado
recurso
envía
mensaje
libera-
ción
nodo
control
algoritmo
centralizado
propiedades
clave
nodo
control
toma
decisiones
ubicación
recursos
información
necesaria
concentrada
nodo
control
incluyendo
identidad
localización
recursos
ubicación
recurso
solución
centralizada
directa
fácil
conseguirse
exclusión
mutua
nodo
control
satisfará
solicitud
recurso
recurso
liberado
em-
bargo
esquema
sufre
inconvenientes
nodo
control
falla
rompe
mecanismo
exclusión
mutua
temporalmente
ubicación
li-
beración
recursos
precisa
intercambio
mensajes
nodo
control
nodo
con-
trol
cuello
botella
666
Sistemas
operativos
Aspectos
internos
principios
diseño
RP1
Sistema
P11
P12
P1k
R11
R12
R1
RPN
Sistema
RPj
/H11005
Proceso
controlador
recurso
sistema
Pji
/H11005
Proceso
usuario
sistema
Rji
/H11005
Recurso
sistema
PN1
PN2
PNk
RN1
RN2
RNm
RPj
Sistema
Pj1
Pj2
Pjk
Rj1
Rj2
Rjm
Figura
15.7
Modelo
problema
exclusión
mutua
gestión
distribuida
procesos
15-Capitulo
15
12/5/05
16:28
Página
666Debido
problemas
algoritmo
centralizado
habido
interés
desarrollo
algorit-
mos
distribuidos
algoritmo
distribuido
caracteriza
siguientes
propiedades
MAEK87
nodos
cantidad
información
término
nodo
visión
parcial
sistema
tomar
decisiones
ba-
sándose
información
nodos
responsabilidad
decisión
nodos
realizan
esfuerzo
similar
toma
decisión
fallo
nodo
general
conlleva
colapso
sistema
reloj
global
común
sistema
regular
eventos
tiempo
puntos
necesitar
elaboración
punto
algoritmos
distribuidos
necesitan
información
conocida
nodo
comunicada
nodos
caso
momento
información
trán-
sito
llegado
nodos
retardos
tiempo
comunica-
ción
mensajes
información
nodo
normalmente
completamente
actualizada
sentido
información
parcial
punto
retardo
comunicación
sistemas
imposible
man-
reloj
ámbito
global
instantáneamente
disponible
sistemas
técnicamente
impracticable
mantener
reloj
central
relojes
locales
sincronicen
precisamente
reloj
central
periodo
tiempo
desfa-
relojes
locales
causará
pérdida
sincronización
retardo
comunicaciones
falta
reloj
común
difícil
desarrollar
mecanismos
exclusión
mutua
sistema
distribuido
comparación
sistema
centralizado
algoritmos
exclusión
mutua
distribuida
examina-
mos
enfoque
común
superar
problema
inconsistencia
relojes
ORDENACIÓN
EVENTOS
SISTEMA
DISTRIBUIDO
ordenación
temporal
eventos
fundamental
operación
mayoría
algoritmos
dis-
tribuidos
exclusión
mutua
interbloqueo
falta
reloj
común
medios
sincronización
relojes
locales
restricción
importante
problema
expresar-
capaces
evento
sistema
suce-
evento
sistema
querríamos
capaces
alcanzar
consistente-
mente
conclusión
sistemas
red
Desafortunadamente
sentencia
precisa
razones
retardo
ocurrencia
real
evento
mo-
mento
observado
sistema
falta
sincronización
va-
riación
lecturas
reloj
sistemas
superar
dificultades
método
conocido
sellos
tiempo
propuesto
Lamport
LAMP87
ordena
eventos
sistema
distribuido
utilizar
relojes
físicos
técnica
eficiente
efectiva
utiliza
mayoría
algoritmos
distribuidos
exclusión
mutua
interbloqueo
comenzar
necesitamos
decidir
definición
término
evento
instancia
interesa
acciones
ocurren
sistema
local
proceso
entra
abandona
sección
crítica
sistema
distribuido
procesos
interactúan
Gestión
procesos
distribuidos
667
15-Capitulo
15
12/5/05
16:28
Página
667es
mensajes
sentido
asociar
eventos
mensajes
evento
local
vincularse
mensaje
sencilla
ejemplo
proceso
enviar
mensaje
desea
entrar
sección
crítica
abandonando
sección
crítica
evitar
ambigüedad
asociamos
eventos
envío
mensajes
recepción
mensajes
proceso
transmite
mensaje
define
evento
corresponde
instante
mensaje
abandona
proceso
esquema
sellos
tiempo
pretende
ordenar
eventos
consistentes
transmisión
mensajes
sistema
red
mantiene
contador
local
funciona
reloj
sistema
transmite
mensaje
incrementa
reloj
mensaje
envía
forma
contenidos
mensaje
sello
tiempo
mensaje
establecido
identificador
numérico
sitio
recibe
mensaje
sistema
receptor
pone
reloj
máximo
valor
actual
sello
tiempo
entrante
Cj
max[Cj
sitio
ordenación
eventos
viene
determinada
siguientes
reglas
mensaje
sitio
mensaje
sitio
precede
cumple
siguientes
condiciones
Tj
Tj
j.
tiempo
asociado
mensaje
sello
tiempo
acompaña
mensaje
orde-
nación
tiempos
viene
determinada
reglas
precedentes
mensajes
sello
tiempo
ordenan
números
sitios
aplicación
reglas
independiente
sitio
solución
impide
problema
deriva
diversos
relojes
procesos
comunicación
Figura
15.8
muestra
ejemplo
operación
algoritmo
sitios
representado
proceso
controla
algoritmo
sello
tiempo
proceso
comienza
valor
reloj
transmitir
mensaje
incrementa
reloj
transmite
a,1,1
valor
numérico
sello
tiempo
identidad
sitio
mensaje
recibe
procesos
sitios
casos
reloj
local
tie-
ne
valor
puesto
valor
max[0,1
emite
mensaje
incremen-
tando
reloj
recepción
mensaje
P3
incrementan
relojes
En-
tonces
P1
emite
mensaje
P3
emite
mensaje
sello
tiempo
principio
ordenación
visto
previamente
causa
confusión
eventos
lugar
orden
mensajes
sitios
algoritmo
funciona
diferencias
tiempos
transmisión
parejas
sistemas
ilustra
Figura
15.9
P4
emite
mensajes
sello
tiem-
668
Sistemas
operativos
Aspectos
internos
principios
diseño
15-Capitulo
15
12/5/05
16:28
Página
668po
mensaje
P1
llega
sitio
sitio
mensajes
hayan
recibido
sitios
orden
mensajes
Obsérvese
ordenación
impuesta
esquema
corresponde
necesariamente
secuencia
real
tiempo
algoritmos
basados
esquema
sellado
tiempo
im-
portante
evento
realmente
sucedió
importante
procesos
implementan
algoritmo
acuerden
orden
único
impuesto
eventos
ejemplos
acaban
discutir
mensaje
envía
proceso
procesos
mensaje
envía
sitios
reciben
men-
sajes
sistema
imposible
sitios
tengan
ordenación
mensajes
caso
existirá
conjunto
ordenaciones
parciales
preocupa-
ción
principal
sellos
tiempo
algoritmos
distribuidos
exclusión
mutua
detección
interbloqueo
tales
algoritmos
proceso
normalmente
envía
mensaje
se-
llo
tiempo
procesos
sellos
tiempo
utilizan
determinar
procesar
mensajes
COLA
DISTRIBUIDA
versión
enfoques
propuestos
proporcionar
exclusión
mutua
dis-
tribuida
basado
concepto
cola
distribuida
LAMP78
algoritmo
basa
si-
guientes
asunciones
sistema
distribuido
consiste
nodos
numerados
única
N.
nodo
contiene
proceso
realiza
peticiones
acceso
exclusión
mutua
recur-
sos
nombre
procesos
proceso
sirve
árbitro
resolver
solici-
tudes
entrantes
nodos
solapen
tiempo
mensajes
enviados
nodo
reciben
orden
enviaron
mensaje
entrega
correctamente
destinatario
tiempo
finito
Gestión
procesos
distribuidos
669
P1
22
0Tiempo
reloj
local
P2
P3
Figura
15.8
Ejemplo
operación
algoritmo
sellado
tiempo
15-Capitulo
15
12/5/05
16:28
Página
6694
red
completamente
conectada
significa
proceso
enviar
men-
sajes
directamente
proceso
requerir
intermediación
proceso
retransmita
mensaje
suposiciones
conseguirse
protocolo
transporte
fiable
TCP
Capítulo
13
simplicidad
describe
algoritmo
caso
sitio
controla
único
re-
curso
generalización
múltiples
recursos
trivial
algoritmo
intenta
generalizar
algoritmo
funcionaría
inmediata
sistema
centralizado
proceso
central
único
gestiona
recurso
encolar
solicitudes
entrantes
darles
acceso
estricto
orden
FIFO
algoritmo
sistema
distribuido
sitios
copia
cola
utilizarse
sellado
tiempo
con-
seguir
nodos
pongan
orden
concederse
solicitudes
recursos
Aparece
complicación
dada
cantidad
finita
tiempo
mensaje
atravesar
red
peligro
sitios
distintos
pongan
proceso
cabeza
cola
Considere
Figura
15.9
punto
mensaje
llegado
mensaje
llegado
P3
mensajes
tránsito
procesos
periodo
tiempo
P1
P2
consideran
mensaje
cabeza
cola
P3
P4
consideran
mensaje
cabeza
cola
lugar
violación
requisito
exclusión
mutua
evitar
impone
regla
proceso
tomar
decisión
basándose
cola
necesita
recibido
mensaje
sitios
garantizar
mensaje
tránsito
reciente
cabeza
cola
regla
explica
3b
algoritmo
descrito
continuación
sitio
mantiene
estructura
datos
guarda
constancia
mensaje
recibido
recientemente
sitio
incluyendo
mensaje
reciente
generado
sitio
Lam-
port
refiere
estructura
cola
realmente
vector
entrada
sitio
momento
entrada
q[j
vector
local
contiene
mensaje
j.
vector
inicializa
q[j
Liberar
algoritmo
utilizan
tipos
mensajes
670
Sistemas
operativos
Aspectos
internos
principios
diseño
P1
P2
P3
P4
00
2Tiempo
reloj
local
Figura
15.9
ejemplo
operación
algoritmo
sellado
tiempo
15-Capitulo
15
12/5/05
16:28
Página
670•
Solicitud
solicitud
acceso
recurso
realizada
Pi
Respuesta
Pj
concede
acceso
recurso
control
Liberar
Pk
libera
recurso
previamente
concedió
algoritmo
necesita
acceder
recurso
emite
solicitud
Solicitud
sellada
tiempo
valor
actual
reloj
local
Pone
mensaje
vector
local
q[i
envía
mensaje
procesos
recibe
Solicitud
pone
mensaje
vector
q[i
q[i
con-
mensaje
solicitud
transmite
Respuesta
Tj
Pi
acción
imple-
menta
regla
descrita
anteriormente
asegura
mensaje
Solicitud
tránsito
momento
decisión
acceder
recurso
entrar
sección
crítica
cumplan
siguientes
condiciones
Solicitud
vector
mensaje
Solicitud
reciente
vector
mensajes
ordenan
consistente
sitios
regla
permite
procesos
acceda
recurso
momento
mensajes
vector
local
posteriores
mensaje
q[i
regla
garantiza
conoce
acerca
solicitudes
preceden
solicitud
actual
libera
recurso
emitiendo
mensaje
Liberar
pone
vector
trans-
mite
procesos
recibe
Liberar
Tj
reemplaza
contenidos
actuales
q[j
mensaje
recibe
Respuesta
Tj
reemplaza
contenidos
actuales
q[j
mensaje
ve
claramente
algoritmo
exclusión
mutua
equitativo
evita
interblo-
queo
hambruna
Exclusión
mutua
solicitudes
entrada
sección
crítica
sirven
conforme
or-
denación
impuesta
mecanismo
sello
tiempo
decide
entrar
sección
crítica
sistema
mensaje
Solicitud
transmitido
an-
tes
recibido
necesariamente
mensaje
sitios
mensajes
anteriores
mensaje
Solicitud
seguros
gracias
mecanismo
mensaje
Respuesta
recuerde
mensajes
sitios
llegar
orden
Equitativo
solicitudes
conceden
estrictamente
base
ordenación
sellos
tiempo
procesos
oportunidad
Libre
interbloqueo
ordenación
sellos
tiempo
mantiene
consistente-
mente
sitios
ocurrir
interbloqueos
Libre
hambruna
completado
sección
crítica
transmite
mensaje
Liberar
efecto
borrar
mensaje
Solicitud
sitios
permitiendo
proceso
sección
crítica
medida
eficiencia
algoritmo
nótese
garantizar
exclusión
nece-
sitan
mensajes
mensajes
Solicitud
mensajes
Respuesta
mensajes
Liberar
Gestión
procesos
distribuidos
671
15-Capitulo
15
12/5/05
16:28
Página
671Segunda
versión
RICA81
propuso
mejora
algoritmo
Lamport
busca
opti-
mizar
algoritmo
original
eliminando
mensajes
Liberar
Imperan
restricciones
necesario
mensajes
enviados
proceso
reci-
bidos
orden
enviados
sitio
contiene
proceso
controla
ubicación
recursos
proceso
mantiene
array
obedece
siguientes
reglas
necesita
acceder
recurso
emite
solicitud
Solicitud
sellada
tiempo
valor
actual
reloj
local
Pone
mensaje
vector
local
q[i
envía
mensaje
procesos
recibe
Solicitud
obedece
siguientes
reglas
actualmente
sección
crítica
aplaza
envío
mensaje
Respuesta
véase
Regla
esperando
entrar
sección
crítica
emitido
Solicitud
pendiente
transmite
Respuesta
Pi
esperando
entrar
sección
crítica
mensaje
entrante
so-
licitud
Pj
coloca
mensaje
array
q[i
aplaza
envío
mensaje
Respuesta
esperando
entrar
sección
crítica
mensaje
entrante
precede
solicitud
Pj
coloca
mensaje
array
q[i
transmite
men-
saje
Respuesta
Tj
Pi
acceder
recurso
entrar
sección
crítica
recibido
mensaje
Res-
puesta
procesos
abandona
sección
crítica
libera
recurso
enviando
mensaje
Respuesta
Solicitud
pendiente
diagrama
transiciones
proceso
muestra
Figura
15.10
resumir
proceso
desea
entrar
sección
crítica
envía
mensaje
Solicitud
sello
tiempo
procesos
recibe
Respuesta
pro-
cesos
entrar
sección
crítica
proceso
recibe
Solicitud
proceso
eventualmente
enviar
correspondiente
Respuesta
proceso
desea
entrar
sección
crítica
envía
Respuesta
momento
desea
entrar
sección
crítica
compara
sello
tiempo
Solicitud
Solicitud
recibida
reciente
aplaza
Respuesta
caso
Respuesta
envía
momento
método
requieren
mensajes
mensajes
Solicitud
in-
dique
intención
entrar
sección
crítica
mensajes
Respuesta
permitir
acceso
solicitado
sellos
tiempo
algoritmo
asegura
exclusión
mutua
evita
inter-
bloqueo
aprobar
asúmase
opuesto
men-
sajes
tránsito
situación
proceso
transmitido
Solicitud
recibido
necesaria
Respuesta
situación
suceder
decisión
diferir
Respuesta
basa
relación
ordena
Solicitudes
Solicitud
sello
tiempo
antiguo
recibirá
Respuestas
necesarias
interbloqueo
imposible
inanición
evita
Solicitudes
ordenadas
Solicitudes
sir-
ven
orden
Solicitud
llega
momento
antigua
servirá
672
Sistemas
operativos
Aspectos
internos
principios
diseño
15-Capitulo
15
12/5/05
16:28
Página
672UN
ENFOQUE
PASO
TESTIGO
número
investigadores
propuesto
enfoque
exclusión
mu-
tua
involucra
paso
testigo
procesos
participantes
testigo
entidad
momento
posee
procesos
proceso
testigo
entrar
sección
crítica
pedir
permiso
proceso
abandona
sección
crítica
pasa
testigo
proceso
subsección
vemos
eficientes
esquemas
propuesto
pri-
mera
SUZU82
propuesta
conceptualmente
equivalente
aparece
RICA83
algoritmo
necesitan
estructuras
datos
testigo
pasa
proceso
realmente
vector
testigo
cuya
entrada
registra
sello
tiempo
testi-
go
visitó
proceso
k.
proceso
mantiene
vector
solicitud
cuya
entrada
registra
sello
tiempo
Solicitud
recibida
j.
procedimiento
Inicialmente
testigo
asigna
arbitrariamente
procesos
proceso
desea
utilizar
sección
crítica
actualmente
posesión
testigo
caso
difunde
mensaje
solicitud
sello
tiempo
de-
procesos
espera
recibe
testigo
proceso
abandona
sección
crítica
transmitir
testigo
proceso
Escoge
proceso
recibir
testigo
buscando
vector
solicitud
orden
j+1
j+2
j–1
entrada
sello
tiempo
solicitud
testigo
valor
registrado
tes-
tigo
Pk
testigo
solicitud
testigo
Figura
15.11
muestra
algoritmo
partes
sección
crítica
consiste
preámbulo
seguido
sección
crítica
seguida
epílogo
Gestión
procesos
distribuidos
673
Computación
Solicitando
exclusión
mutua
Enviar
solicitud
procesos
recibido
respuestas
Salida
sección
crítica
Devolver
respuestas
solicitudes
pendientes
Solicitud
exclusión
mutua
Espera
Sección
crítica
Activando
Figura
15.10
Diagrama
algoritmo
RICA81
15-Capitulo
15
12/5/05
16:28
Página
673674
Sistemas
operativos
Aspectos
internos
principios
diseño
if
testigo_presente
reloj++
Preámbulo
difundir(solicitud
reloj
esperar(acceso
testigo
testigo_presente
testigo_tomado
sección
crítica
testigo[i
reloj
Epílogo
testigo_tomado
falso
for
int
j++
if
solicitud(j
testigo[j
testigo_presente
testigo_presente
falso
enviar(acceso
testigo[j
Figura
15.11
Algoritmo
paso
testigo
Proceso
Pi
if
recibir(solicitud
solicitud
max(solicitud(j
if
testigo_presente
testigo_tomado
texto
epílogo
Notación
enviar(j
acceso
testigo
envía
mensaje
tipo
acceso
testigo
proceso
difundir(solicitud
reloj
envía
mensaje
proceso
tipo
solicitud
sello
tiem-
po
reloj
procesos
recibir(solicitud
recibe
mensaje
proceso
tipo
solicitud
sello
tiempo
acción
tomar
recibe
solicitud
variable
reloj
contador
local
utilizado
función
sello
tiempo
operación
esperar
acceso
testigo
proceso
espere
recibe
mensaje
tipo
acce-
so
coloca
vector
testigo
15-Capitulo
15
12/5/05
16:28
Página
674El
algoritmo
requiere
•N
mensajes
difundir
solicitud
transferir
testigo
proceso
solicitante
testigo
mensaje
proceso
testigo
15.4
INTERBLOQUEO
DISTRIBUIDO
Capítulo
definimos
interbloqueo
bloqueo
permanente
conjunto
procesos
compiten
recursos
sistema
comunican
definición
válida
sistema
único
sistema
distribuido
exclusión
mutua
inter-
bloqueo
presenta
problemas
complejos
sistema
distribuido
comparado
sistema
memoria
compartida
manejo
interbloqueo
complica
sistema
distribuido
nin-
gún
nodo
conocimiento
preciso
actual
sistema
global
transferencia
mensaje
procesos
involucra
retardo
impredecible
literatura
prestado
atención
tipos
interbloqueo
distribuido
surgen
ubicación
recursos
surgen
comunicación
mensajes
interbloque-
recursos
procesos
intentan
acceder
recursos
tales
objetos
base
datos
recursos
servidor
interbloqueo
sucede
proceso
conjunto
procesos
so-
licita
recurso
proceso
conjunto
interbloqueos
comunicaciones
mensajes
recursos
esperan
procesos
interbloqueo
sucede
proceso
conjunto
esperando
mensaje
proceso
conjunto
proceso
con-
envía
mensaje
INTERBLOQUEO
UBICACIÓN
RECURSOS
Recuerde
Capítulo
interbloqueo
ubicación
recursos
cumplen
siguientes
condiciones
Exclusión
mutua
proceso
utilizar
recurso
momento
proceso
acceder
recurso
reservado
proceso
esperar
proceso
reservados
recursos
espera
asignación
expulsión
quitar
fuerza
recurso
proceso
Espera
circular
cadena
cerrada
procesos
proceso
recurso
requerido
proceso
cadena
propósito
algoritmo
trate
interbloqueo
prevenir
formación
espera
circular
detectar
ocurrencia
real
potencial
sistema
distribuido
recursos
distribuidos
sitios
acceso
regula
procesos
control
tie-
nen
conocimiento
completo
actualizado
global
sistema
tomar
decisiones
base
información
local
necesitan
algoritmos
in-
terbloqueo
ejemplo
dificultades
encuentran
gestión
distribuida
interbloqueos
fenómeno
interbloqueo
fantasma
ejemplo
interbloqueo
fantasma
muestra
Figura
15.12
notación
P2
P3
significa
P1
parado
esperando
recurso
Gestión
procesos
distribuidos
675
15-Capitulo
15
12/5/05
16:28
Página
675y
P2
esperando
recurso
Digamos
principio
ejemplo
P3
posee
re-
curso
Ra
P1
posee
recurso
b.
Suponga
emite
mensaje
liberando
mensaje
solicitando
b.
mensaje
alcanza
proceso
detección
ciclo
sucede
secuencia
Figura
15.12a
reflejan
adecuadamente
necesi-
dades
recursos
mensaje
llega
mensaje
detecta-
rá
interbloqueo
Figura
15.12b
detección
falsa
interbloqueo
real
falta
global
existiría
sistema
centralizado
Prevención
interbloqueo
técnicas
prevención
interbloqueo
expuestas
Capítulo
usarse
entorno
distribuido
condición
espera
circular
prevenirse
definiendo
ordenación
lineal
tipos
recurso
proceso
ubicado
recursos
tipo
solicitar
conti-
nuación
recursos
tipos
sigan
ordenación
desventaja
importante
método
recursos
solicitarse
orden
utilizar
recursos
reservados
tiempo
necesario
condición
tener-y-esperar
prevenirse
exigiendo
proceso
solicite
recursos
necesita
bloqueando
proceso
solicitudes
puedan
satisfacerse
simultáneamente
enfoque
ineficiente
siguientes
motivos
proceso
quedar
esperando
tiempo
complete
solicitud
recursos
avanzado
teniendo
recursos
recursos
asignados
proceso
permanecer
usarse
periodo
considerable
denegados
procesos
métodos
requieren
proceso
determine
necesidades
recursos
antelación
caso
ejemplo
aplicación
base
datos
añadirse
elementos
dinámicamente
ejemplo
solución
necesita
conocimiento
anticipado
consideramos
algoritmos
propuestos
ROSE78
desarrollaron
con-
texto
trabajo
base
datos
debemos
hablar
transacciones
procesos
métodos
propuestos
sellos
tiempo
transacción
acarrea
tiem-
po
vida
sello
tiempo
creación
establece
ordenación
estricta
transaccio-
676
Sistemas
operativos
Aspectos
internos
principios
diseño
P1
P2
Liberar
llega
solicitud
P3
P1
P2
P3
P1
Liberar
Ra
Solicita
Rb
P2
P3
P1
P2
Solicitud
llega
liberar
P3
P1
Solicita
Rb
Liberar
Ra
P2
P3
Figura
15.12
Interbloqueo
fantasma
15-Capitulo
15
12/5/05
16:28
Página
676nes
recurso
utilizado
transacción
T1
solicita
transacción
T2
conflicto
resuelve
comparando
sellos
tiempo
comparación
utiliza
prevenir
formación
condición
espera
circular
autores
proponen
variaciones
método
básico
referidas
método
esperar-morir
wait-die
método
herir-esperar
wound-wait
Supongamos
actualmente
T1
T2
realiza
solicitud
método
esperar-
morir
Figura
15.13a
muestra
algoritmo
utilizado
gestor
recurso
sitio
R.
sellos
tiempo
transacciones
denotan
e(T1
e(T2
T2
viejo
blo-
quea
T1
libera
emitiendo
activamente
liberación
matado
soli-
citar
recurso
T2
joven
rearranca
T2
sello
tiempo
caso
conflicto
transacción
antigua
prioridad
transacción
matada
revive
sello
tiempo
original
envejece
gana
prioridad
sitio
necesita
ubicación
recursos
necesita
sellos
tiempo
transacciones
solicitan
recursos
método
herir-esperar
concede
inmediatamente
solicitud
transacción
antigua
matando
transacción
joven
utilizando
recurso
solicitado
muestra
Fi-
gura
15.13b
contraste
método
esperar-morir
transacción
esperar
recurso
usado
transacción
joven
Evitación
interbloqueo
Evitar
interbloqueos
técnica
toma
deci-
sión
dinámicamente
solicitud
asignación
recurso
dada
concede
provo-
car
interbloqueo
SING94b
notar
evitar
forma
distribuida
interbloqueo
práctico
siguientes
razones
nodo
seguirle
pista
global
sistema
requiere
cantidad
sus-
tancial
almacenamiento
sobrecarga
comunicaciones
proceso
comprobar
global
seguro
mutuamente
exclusivo
nodos
considerando
solicitud
recurso
proce-
so
alcanzar
concurrentemente
conclusión
seguro
aceptar
solicitud
ambas
solicitudes
conceden
sucederá
interbloqueo
comprobación
seguros
conllevará
sobrecarga
procesamiento
considera-
ble
sistema
distribuido
número
procesos
recursos
Detección
interbloqueo
detección
interbloqueo
procesos
permite
ob-
recursos
libres
deseen
existencia
interbloqueo
determina
suceda
detecta
interbloqueo
selecciona
procesos
constituyen
solicita
liberar
recursos
necesarios
romper
interbloqueo
Gestión
procesos
distribuidos
677
if
e(T2
e(T1
if
e(T2
e(T1
Parar_T2
esperar
Matar_T1
herir
else
else
Matar_T2
morir
Parar_T2
esperar
Figura
15.13
Métodos
prevención
interbloqueo
Método
esperar-morir
Método
herir-esperar
15-Capitulo
15
12/5/05
16:28
Página
677La
dificultad
detección
interbloqueo
distribuida
sitio
conoce
recursos
interbloqueo
involucrar
recursos
distribuidos
posibles
en-
foques
dependiendo
sistema
control
centralizado
jerárquico
distribuido
Tabla
15.1
control
centralizado
sitio
responsable
detección
interbloqueos
mensajes
solicitud
liberación
envían
proceso
central
proceso
controla
recurso
particular
proceso
central
imagen
completa
posición
detec-
tar
interbloqueo
enfoque
requiere
número
mensajes
vulnerable
fallo
sitio
central
detectarse
interbloqueos
fantasma
control
jerárquico
sitios
organizan
estructura
árbol
sitio
sirve
raíz
árbol
nodo
hoja
recolecta
información
acerca
ubicación
recursos
nodos
dependientes
permite
detectar
interbloqueo
niveles
bajos
nodo
raíz
Concretamente
interbloqueo
involucre
conjunto
recursos
detec-
tado
nodo
ancestro
común
sitios
cuyos
recursos
objetos
conflicto
control
distribuido
procesos
cooperan
tarea
detectar
interbloqueos
general
significa
intercambiarse
considerable
cantidad
información
sellos
tiempo
sobrecarga
significativa
RAYN88
cita
enfoques
basados
control
distribuido
DATT90
proporciona
examen
detallado
enfoque
Veamos
ejemplo
algoritmo
distribuido
detección
interbloqueo
DATT92
JOHN91
algoritmo
sistema
distribuido
base
datos
sitio
man-
porción
base
datos
transacciones
iniciadas
sitio
transacción
máximo
solicitud
recurso
pendiente
transacción
necesita
678
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
15.1
Estrategias
distribuidas
detección
interbloqueo
Algoritmos
centralizados
Algoritmos
jerárquicos
Algoritmos
distribuidos
favor
favor
favor
•S
conceptual-
mente
sencillos
fáciles
implementar
sitio
central
información
completa
resolver
interbloqueos
óptimamente
Sobrecarga
considerable
comunicacio-
nes
nodo
enviar
información
nodo
central
Vulnerable
fallo
nodo
central
•N
vulnerable
único
punto
fallo
actividad
resolución
interbloqueos
limitada
interbloqueos
probables
localizados
difícil
configurar
sistema
interbloqueos
probables
estén
localizados
realmente
sobrecarga
solución
distribuida
•N
vulnerable
único
punto
fallo
agobia
nodo
actividad
detección
interbloqueos
resolución
interbloqueos
incómoda
sitios
detectar
interbloqueo
considerar
nodos
involucrados
interbloqueo
•L
algoritmos
difíciles
diseñar
consideracio-
nes
tiempo
15-Capitulo
15
12/5/05
16:28
Página
678más
objeto
datos
objeto
datos
solicitarse
concedido
Asociados
objeto
datos
sitio
parámetros
identificador
único
variable
Bloqueado_por(Di
variable
valor
nulo
objeto
datos
bloqueado
transacción
caso
contrario
valor
identificador
transacción
bloquea
Asociados
transacción
sitio
parámetros
identificador
único
j.
variable
Poseído_por(T
pone
nulo
transacción
ejecutando
es-
tado
Lista
caso
contrario
valor
identificador
transacción
objeto
datos
solicitado
transacción
j.
variable
Espera_por(T
valor
nulo
transacción
esperando
transacción
caso
contrario
valor
identificador
transacción
cabeza
lista
ordenada
transacciones
bloqueadas
cola
Solicitud_Q(T
contiene
solicitudes
pendientes
objetos
datos
posesión
j.
elemento
cola
forma
Dk
Tk
transacción
solicitante
Dk
objeto
datos
posesión
j.
ejemplo
suponga
transacción
esperando
objeto
datos
posesión
T1
espera
objeto
datos
posesión
parámetros
rele-
vantes
siguientes
valores
Transacción
Espera_por
Poseído_por
Solicitud_Q
T0
nulo
nulo
T1
T1
T0
T0
T2
T2
T0
T1
nulo
ejemplo
resalta
diferencia
Espera_por(T
Poseído_por(T
proceso
continuar
libere
objeto
datos
precisa
ejecutar
liberar
objeto
datos
precisa
T2
Figura
15.14
muestra
algoritmo
utilizado
detección
interbloqueo
transacción
realiza
solicitud
bloqueo
objeto
datos
proceso
servidor
asociado
objeto
datos
concede
deniega
solicitud
solicitud
concede
proce-
so
servidor
devuelve
identidad
transacción
objeto
datos
transacción
solicitante
recibe
respuesta
concesión
bloquea
objeto
datos
caso
contrario
transacción
solicitante
actualiza
variable
Poseído_por
identidad
transacción
objeto
datos
Añade
identidad
cola
Solicitud_Q
transacción
poseedora
Actualiza
variable
Espera_por
identidad
transacción
poseedora
dicha
tran-
sacción
esperando
identidad
variable
Espera_por
transacción
po-
see
variable
Espera_por
toma
valor
transacción
instancia
bloqueando
ejecución
Finalmente
transacción
solicitante
emite
mensaje
actualización
transacciones
cola
Solicitud_Q
modificar
variables
Espera_por
afectadas
cambio
Gestión
procesos
distribuidos
679
15-Capitulo
15
12/5/05
16:28
Página
679680
Sistemas
operativos
Aspectos
internos
principios
diseño
Objeto
datos
Dj
recibiendo
mirar_solicitud(Ti
Transacción
recibiendo
mensaje
actualización
if
Bloqueado_por(Dj
null
if
Esperar_por
Tj
Esperar_por
enviar(concedido
Esperar_por
Tj
Esperar_por
else
if
intersección
Esperar_por
Tj
Solicitud_Q
Tj
null
Actualizar(Esperar_por
Solicitud_Q
Tj
enviar
concedido
else
enviar
Bloqueado_por
Dj
DECLARAR
INTERBLOQUEO
transacción
solicitud
mirar
objeto
Dj
Iniciar
resolución
interbloqueo
enviar
mirar_solicitud
Dj
Tj
escoge
transacción
abortar
esperar
concedido
concedido
Tj
liberar
objetos
datos
posee
if
concedido
enviar
Limpiar
Tj
Poseído_por
asignar
objeto
datos
Di
poseido
Tj
solicitante
Bloqueado_por
Dj
Tk
Solicitud_Q
Tj
Poseído_por(T
for
transacción
Tn
Solicitud_Q
solicitando
objeto
datos
Di
poseído
Tj
else
Suponer
Dj
transacción
Encolar(Tn
Solicitud_Q
Tk
Poseído_por
Tj
Encolar(Ti
Solicitud_Q(Tj
Transacción
recibiendo
mensaje
Limpiar(Tj
Tk
if
Esperar_por(Tj
null
eliminar
tupla
Tj
transacción
solicitante
Solicitud_Q
Esperar_por
Tj
else
Esperar_por
Esperar_por
Tj
Actualizar(Esperar_por
Solicitud_Q
Figura
15.14
algoritmo
distribuido
detección
interbloqueo
15-Capitulo
15
12/5/05
16:28
Página
680Cuando
transacción
recibe
mensaje
actualización
actualiza
variable
Espera_por
reflejar
transacción
instancia
esperando
bloqueada
transacción
realiza
trabajo
real
detección
interblo-
queo
comprobando
esperando
procesos
esperando
reenvía
mensaje
actualización
transacción
envía
mensaje
Limpiar
transacción
posee
objeto
datos
solicitado
entrega
objeto
datos
posee
solicitante
cola
Solicitud_Q
encola
solicitudes
restantes
transacción
Figura
15.15
muestra
ejemplo
operación
algoritmo
realiza
solicitud
objeto
datos
poseído
crea
ciclo
T0
emite
mensaje
actualización
propaga
T2
T3
punto
descubre
intersección
variables
Espe-
ra_por
Solicitud_Q
vacía
envía
mensaje
limpiar
T3
elimina
Solicitud_Q(T2
libere
objeto
datos
posee
activando
T4
T6
INTERBLOQUEO
COMUNICACIÓN
MENSAJES
Espera
mutua
interbloqueo
comunicación
mensajes
sucede
proceso
grupo
esperando
mensaje
miembro
grupo
mensajes
tránsito
analizar
situación
detalle
definimos
conjunto
dependencia
DS
pro-
ceso
proceso
Pi
parado
esperando
mensaje
DS(P
consiste
pro-
cesos
Pi
esperando
mensaje
Típicamente
continuar
cualquiera
mensajes
esperados
llega
formulación
alternativa
continuar
des-
pués
lleguen
mensajes
esperados
situación
común
Gestión
procesos
distribuidos
681
Transación
Esperar_por
Poseído_por
Solicitud_Q
T0
T1
T2
T3
T4
T5
T6
nulo
T2
T3
T4
T6
T5
nulo
nulo
nulo
T0
T1
T2
T3
T4
T3
nulo
T0
T0
T0
T0
T0
T0
Transación
T0
T1
T2
T3
T4
T5
T6
T1
T2
T3
T4
T6
T0
T5
nulo
nulo
T3
T0
T1
T2
T3
T4
T3
T0
T0
T0
T0
T0
T0
T0
T4
T5
T0
T1
T2
T3
T6
T4
T5
T0
T1
T2
T3
T6
Esperar_por
Poseído_por
Solicitud_Q
Figura
15.15
Ejemplo
algoritmo
distribuido
detección
interbloqueo
Figura
15.14
15-Capitulo
15
12/5/05
16:28
Página
681Con
definición
precedente
interbloqueo
conjunto
procesos
definirse
procesos
parados
esperando
mensajes
contiene
conjunto
dependencias
procesos
S.
mensajes
tránsito
miembros
S.
proceso
interbloqueado
recibir
mensaje
des-
bloquee
términos
gráficos
diferencia
interbloqueo
mensajes
interbloqueo
recur-
sos
interbloqueo
recursos
interbloqueo
bucle
cerrado
ciclo
gráfi-
co
describe
dependencias
procesos
caso
recursos
proceso
depende
posee
recurso
necesita
interbloqueo
mensajes
condición
interbloqueo
sucesores
miembro
estén
asimismo
S.
Figura
15.16
ilustra
punto
Figura
15.16a
esperando
mensaje
P2
P5
P5
esperando
mensaje
enviar
mensaje
libera
resultado
enlaces
P5
P1
P2
borran
Figura
15.16b
añade
de-
pendencia
esperando
mensaje
esperando
mensaje
esperando
mensaje
esperando
mensaje
inter-
bloqueo
interbloqueo
recursos
interbloqueo
mensajes
atacado
preven-
ción
detección
RAYN88
ejemplos
disponibilidad
buffers
mensaje
forma
ocurrir
interbloqueo
sistema
paso
mensajes
ubicación
buffers
almacenamiento
mensajes
tránsito
tipo
interbloqueo
conocido
redes
datos
encaminamiento
paquetes
examinamos
problema
contexto
red
datos
vere-
mos
punto
vista
sistema
operativo
distribuido
forma
simple
interbloqueo
red
datos
interbloqueo
almacenar-y-reenviar
directo
ocurrir
nodo
encaminamiento
paquetes
depósito
común
buffers
asignan
buffers
paquetes
demanda
Figura
15.17a
muestra
situa-
ción
buffers
nodo
ocupados
paquetes
destinados
B.
opuesto
B.
nodo
aceptar
paquetes
buffers
ocupados
nodo
transmitir
recibir
enlace
682
Sistemas
operativos
Aspectos
internos
principios
diseño
interbloqueo
P1
P5
P3
P2
P4
Interbloqueo
P1
P5
P3
P2
P4
Figura
15.16
Interbloqueo
comunicación
mensajes
15-Capitulo
15
12/5/05
16:28
Página
682El
interbloqueo
almacenar-y-reenviar
directo
preverse
permitiendo
buf-
fers
terminen
dedicados
único
enlace
Usando
buffers
tamaño
fijo
separados
enlace
conseguirá
prevención
utiliza
depósito
común
buffers
evita
interblo-
queo
impide
único
enlace
ocupar
espacio
buffers
forma
sutil
interbloqueo
interbloqueo
almacenar-y-reenviar
indirecto
ilustra
Figura
15.17b
nodo
cola
nodo
adyacente
dirección
repleta
paquetes
destinados
nodo
allá
sencilla
prevenir
tipo
interbloqueo
emplear
depósito
estructurado
buffers
Figura
15.18
buffers
organizan
jerár-
quica
depósito
memoria
nivel
restringido
paquete
entrante
almace-
narse
nivel
nivel
máximo
número
saltos
camino
red
buffers
reservan
buffers
nivel
reservan
paquetes
viajado
mínimo
saltos
condiciones
alta
carga
buffers
llenan
progre-
sivamente
nivel
nivel
N.
buffers
nivel
llenos
paquetes
entrantes
cubierto
saltos
pierden
mostrarse
GOPA85
estrate-
gia
elimina
interbloqueos
almacenar-y-reenviar
directos
indirectos
problema
interbloqueo
acaba
describir
tratado
contexto
ar-
quitectura
comunicaciones
típicamente
nivel
red
tipo
problema
suce-
Gestión
procesos
distribuidos
683
Depósito
buffer
lleno
AB
Interbloqueo
almacenar-y-reenviar
directo
Interbloqueo
almacenar-y-reenviar
indirecto
CD
Lleno
paquetes
Depósito
buffer
lleno
Lleno
paquetes
Lleno
paquetes
Lleno
paquetes
Lleno
paquetes
Figura
15.17
Interbloqueo
almacenar-y-reenviar
15-Capitulo
15
12/5/05
16:29
Página
683der
sistema
operativo
distribuido
utiliza
paso
mensajes
comunicación
pro-
cesos
Concretamente
operación
envío
bloqueante
necesita
buffer
contener
mensajes
salientes
pensar
buffer
utilizado
contener
mensajes
enviados
proceso
proceso
canal
comunicaciones
canal
ca-
pacidad
finita
tamaño
buffer
finito
operación
envío
termine
suspen-
sión
proceso
buffer
tamaño
actualmente
mensajes
tránsito
re-
cibidos
proceso
destinatario
ejecución
envío
bloqueará
proceso
remitente
recepción
abra
espacio
buffer
Figura
15.19
ilustra
canales
finitos
interbloqueo
figura
muestra
canales
capacidad
mensajes
proceso
proceso
X.
exactamente
mensajes
tránsito
canales
intentan
transmisión
ejecutar
recepción
suspenden
aparece
interbloqueo
establecer
límites
superiores
número
mensajes
estarán
tránsito
pareja
procesos
sistema
estrategia
prevención
obvia
ubicar
tantos
buf-
fers
necesiten
canales
derroche
extremadamente
684
Sistemas
operativos
Aspectos
internos
principios
diseño
Depósito
común
Clase
Espacio
buffers
paquetes
viajado
saltos
Clase
Clase
Clase
Clase
Figura
15.18
Depósito
buffers
estructurado
prevención
interbloqueo
Figura
15.19
Interbloqueo
comunicaciones
sistema
distribuido
15-Capitulo
15
12/5/05
16:29
Página
684y
requiere
conocimiento
anticipado
necesidades
conocerse
anticipación
ubicación
basada
límites
superiores
definitivamente
prohibitiva
necesita
técnica
estimación
optimizar
ubicación
demostrarse
problema
solución
caso
general
BARB90
sugieren
estrategias
heurísticas
tratar
situación
15.5
RESUMEN
sistema
operativo
distribuido
proporcionar
migración
procesos
transferencia
suficiente
cantidad
proceso
máquina
proceso
eje-
cutar
máquina
destino
migración
procesos
utilizarse
equilibrado
carga
mejorar
prestaciones
minimizando
actividad
comunicaciones
mejorar
dispo-
nibilidad
permitir
procesos
accedan
facilidades
remotas
especiales
sistema
distribuido
importante
establecer
información
global
resolver
competencia
recursos
coordinar
procesos
variable
impredecible
re-
tardo
transmisión
mensajes
tenerse
cuidado
asegurar
procesos
po-
nen
orden
suceden
eventos
gestión
procesos
sistema
distribuido
incluye
servicios
proporcionar
exclu-
sión
mutua
tomar
acciones
caso
interbloqueo
casos
problemas
complejos
sistema
único
15.6
LECTURA
RECOMENDADA
GALL00
TEL01
cubren
temas
capítulo
MILO00
amplia
detallada
recopilación
mecanismos
migración
procesos
implementaciones
recopilaciones
útiles
ESKI90
SMIT88
NUTT94
describe
implementaciones
migración
procesos
SO
FIDG96
recopila
soluciones
orde-
nación
eventos
sistemas
distribuidos
concluye
preferido
enfoque
general
descrito
capítulo
Algoritmos
gestión
distribuida
procesos
exclusión
mutua
interbloqueo
en-
contrarse
SINH97
RAYN88
RAYN90
GARG02
LYNC96
contienen
tratamiento
formal
ESKI90
Eskicioglu
M.«Design
Issues
of
Process
Migration
Facilities
in
Distributed
Systems
Newslet-
ter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
Systems
and
Application
Environments
Verano
1990
FIDG96
Fidge
C.
Fundamentals
of
Distributed
System
Observation
IEEE
Software
Noviembre
1996
GALL00
Galli
D.
Distributed
Operating
Systems
Concepts
and
Practice
Upper
Saddle
River
NJ
Pren-
tice
Hall
2000
GARG02
Garg
V.
Elements
of
Distributed
Computing
New
York
Wiley
2002
YNC96Lynch
N.
Distributed
Algorithms
San
Francisco
CA
Morgan
Kaufmann
1996
MILO00
Milojicic
D.
Douglis
Paindaveine
Wheeler
R.
Zhou
S.
Process
Migration
ACM
Computing
Surveys
Septiembre
2000
NUTT94
Nuttal
M.
Brief
Survey
of
Systems
Providing
Process
or
Object
Migration
Facilities
Ope-
rating
Systems
Review
Octubre
1994
Gestión
procesos
distribuidos
685
15-Capitulo
15
12/5/05
16:29
Página
685RA
YN88Raynal
M.
Distributed
Algorithms
and
Protocols
New
York
Wiley
1988
RA
YN90Raynal
M.
Helary
J.
Synchronization
and
Control
of
Distributed
Systems
and
Programs
New
York
Wiley
1990
SING94
Singhal
M.
Shivaratri
N.
Advanced
Concepts
in
Operating
Systems
New
York
McGraw-
Hill
1994
SINH97
Sinha
Distributed
Operating
Systems
Piscataway
NJ
IEEE
Press
1997
SMIT88
Smith
J.
Survey
of
Process
Migration
Mechanisms
Operating
Systems
Review
Julio
1988
TEL01Tel
G.
Introduction
to
Distributed
Algorithms
Cambridge
Cambridge
University
Press
2001
15.7
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
canal
exclusión
mutua
distribuida
migración
procesos
desalojo
instantánea
transferencia
expulsiva
global
interbloqueo
distribuido
transferencia
expulsiva
CUESTIONES
REPASO
15.1
Enumere
razones
implementar
migración
procesos
15.2
manipula
espacio
direcciones
proceso
migración
proceso
15.3
motivaciones
migración
proceso
expulsiva
expulsiva
15.4
imposible
determinar
global
real
15.5
diferencia
exclusión
mutua
distribuida
basada
algoritmo
centraliza-
do
basada
algoritmo
distribuido
15.6
Defina
tipos
interbloqueo
distribuido
PROBLEMAS
15.1
política
volcado
describe
subsección
estrategias
migración
pro-
cesos
Sección
15.1
perspectiva
origen
estrategia
asemeja
volcado
perspectiva
destino
estrategia
asemeja
volcado
15.2
Figura
15.9
indica
procesos
asignan
ordenación
mensajes
llega
Explore
algoritmo
demos-
trar
afirmación
15.3
algoritmo
Lamport
circunstancia
ahorrarse
transmisión
mensaje
Respuesta
686
Sistemas
operativos
Aspectos
internos
principios
diseño
15-Capitulo
15
12/5/05
16:29
Página
68615.4
algoritmo
exclusión
mutua
RICA81
Pruebe
cumple
exclusión
mutua
mensajes
llegan
orden
enviados
algoritmo
garanti-
za
secciones
críticas
ejecutadas
orden
solicitudes
inanición
15.5
algoritmo
exclusión
mutua
paso
testigo
utiliza
sello
tiempo
restablecer
relojes
corregir
derivas
algoritmos
cola
distribuida
función
sello
tiempo
15.6
algoritmo
exclusión
mutua
paso
testigo
pruebe
garantiza
exclusión
mutua
evita
interbloqueo
equitativo
15.7
Figura
15.11b
explique
línea
simplemente
solici-
tud(j
Gestión
procesos
distribuidos
687
15-Capitulo
15
12/5/05
16:29
Página
68715-Capitulo
15
12/5/05
16:29
Página
688CAPÍTULO
16
Seguridad
16.1
Amenazas
seguridad
16.2
Protección
16.3
Intrusos
16.4
Software
malicioso
16.5
Sistemas
confiables
16.6
Seguridad
Windows
16.7
Resumen
16.8
Lecturas
recomendadas
sitios
web
19.9
érminos
clave
cuestiones
repaso
problemas
Apéndice
16A
Cifrado
16-Capitulo
16
16/5/05
18:35
Página
689N
área
seguridad
sistemas
informáticos
amplia
cubre
controles
físicos
ad-
ministrativos
controles
lógicos
capítulo
centraremos
únicamente
considera-
ciones
relativas
herramientas
seguridad
remota
controles
lógicos
Figura
16.1
sugiere
ámbito
responsabilidad
herramientas
Comenzaremos
examinando
tipo
peligros
enfrenta
instalación
informática
comunicaciones
continuación
grueso
capítulo
tratará
herramientas
específicas
utilizar
mejorar
seguridad
Sección
16.2
cubre
estrategias
tradicionales
garantizar
seguridad
informática
basan
protección
determinados
recursos
incluyendo
memoria
datos
Seguidamente
veremos
peligros
suponen
individuos
intentan
superar
mecanismos
protección
si-
guiente
sección
examina
peligros
derivados
virus
mecanismos
similares
continuación
examinará
concepto
sistemas
confiables
Finalmente
apéndice
capítulo
introduce
lector
cifrado
herramienta
básica
usada
aplicaciones
seguridad
16.1
AMENAZAS
SEGURIDAD
comprender
peligros
existentes
nivel
seguridad
necesario
comenzar
definición
requisitos
seguridad
seguridad
sistemas
informáticos
red
di-
rigida
requisitos
básicos
Confidencialidad
Requiere
información
sistema
informático
encuentre
accesible
lectura
partes
estén
autorizadas
tipo
acceso
tipo
acceso
incluye
impresión
mostrado
datos
formas
observación
incluyen-
do
simple
revelación
existencia
elemento
Integridad
Requiere
contenidos
sistema
informático
modificarse
partes
encuentran
autorizadas
modificaciones
incluyen
escritura
cambio
modificación
borrado
creación
Disponibilidad
Requiere
componentes
sistema
informático
estén
disponibles
partes
autorizadas
Autenticación
Requiere
sistema
informático
capaz
verificar
identidad
usuarios
TIPOS
PELIGROS
tipos
ataques
seguridad
sistema
red
clasifican
considerando
funciones
sistema
informático
tratase
proveedor
información
general
flujo
información
fuente
pudiéndose
tratar
fichero
región
me-
moria
destino
fichero
usuario
flujo
virtual
muestra
Figura
16.2a
resto
elementos
figura
muestran
siguientes
catego-
rías
generales
ataques
Interrupción
destruye
componente
sistema
disponible
utiliza-
ble
ataque
centrado
disponibilidad
Ejemplos
tipo
incluyen
destrucción
pieza
hardware
disco
duro
interrupción
canal
comunicación
eliminación
sistema
gestor
ficheros
Intercepción
autorizada
consiga
acceso
componente
ataque
di-
rigido
confidencialidad
autorizada
persona
programa
690
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
690Seguridad
691
Vigilancia
Datos
Sistema
informático
Sistema
informático
Procesos
representan
usuarios
Datos
Usuarios
peticiones
controlar
acceso
datos
protección
controlar
acceso
instalaciones
informáticas
autenticación
usuarios
datos
transmitir
forma
segura
red
seguridad
red
ficheros
sensibles
asegurar
seguridad
ficheros
Procesos
representan
usuarios
Vigilancia
Figura
16.1
Ámbito
seguridad
informática
MAEK87
Fuente
información
Destino
información
Flujo
normal
Interrupción
Intercepción
Modificación
Fabricación
Figura
16.2
Peligros
seguridad
16-Capitulo
16
16/5/05
17:08
Página
691un
ordenador
Ejemplos
estilo
escucha
canal
comunicación
captu-
rar
datos
copia
ilícita
ficheros
programas
Modificación
elemento
autorizado
acceso
componente
tam-
bién
capaz
modificarlo
ataque
dirigido
integridad
ejem-
plos
incluyen
cambiar
valores
fichero
datos
alterar
programa
exhiba
comportamiento
modificar
contenido
mensajes
transmiten
red
Fabricación
elemento
autorizado
inserta
objetos
extraños
sistema
ata-
ques
autenticación
Ejemplos
tipo
inserción
mensajes
externos
red
inclusión
registró
fichero
COMPONENTES
SISTEMA
INFORMÁTICO
componentes
sistema
informático
clasificar
hardware
software
datos
lí-
neas
comunicaciones
red
Tabla
16.1
indica
naturaleza
peligros
afectan
categorías
continuación
revisaremos
separado
Hardware
principal
peligro
hardware
sistema
informático
área
disponibilidad
hardware
componente
vulnerable
ataques
accesi-
ble
manipulación
remota
principales
peligros
incluyen
daño
accidental
deliberado
equipos
robo
proliferación
ordenadores
personales
estaciones
trabajo
in-
cremento
redes
área
local
incrementan
potenciales
pérdidas
área
ha-
cer
frente
peligros
necesitan
medidas
seguridad
física
administrativa
Software
hardware
sistema
informático
útil
negocios
individuos
sistema
operativo
utilidades
programas
aplicación
tipos
peli-
gros
abla
16.1
Peligros
seguridad
componentes
Disponibilidad
Privacidad
Integridad
Autenticación
Hardware
Equipamiento
robado
deshabitado
denegación
servicio
Software
Borrado
programas
Copia
autorizada
Modificación
denegación
acceso
software
programa
usuarios
falle
ejecución
realice
tarea
Datos
Borrar
ficheros
Lectura
autorizada
Modificación
denegación
acceso
datos
ficheros
existentes
usuarios
análisis
estadístico
creación
datos
revele
ficheros
información
subyacente
Líneas
Borrado
destrucción
Lectura
mensajes
Modificación
borrado
comunicación
mensajes
líneas
Observación
reordenación
comunicación
redes
patrones
tráfico
duplicación
mensajes
encuentran
mensajes
Fabricación
disponibles
mensajes
falsos
692
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
692Un
peligro
importante
relación
software
referente
disponibilidad
software
es-
pecialmente
software
aplicación
fácil
borrar
forma
pue-
verse
alterado
dañado
dejarlo
inservible
mantener
alta
disponibilidad
resulta
ne-
cesaria
gestión
configuración
software
cuidadosa
incluya
realización
copias
respaldo
backups
actualización
versiones
recientes
software
cuestión
com-
plicada
referente
modificación
software
programa
sigua
funcionando
comportamiento
realizaba
anteriormente
implica
peligro
integridad
autenticación
virus
informáticos
ataques
similares
encuentran
categoría
tratarán
capítulo
problema
relativo
priva-
cidad
medidas
disponibles
problema
copia
autorizada
software
resuelto
Datos
seguridad
relativa
hardware
software
habitualmente
co-
metidos
profesionales
administración
sistema
informático
caso
pequeñas
ins-
talaciones
propietarios
ordenadores
personales
problema
amplio
rela-
tivo
seguridad
datos
incluye
ficheros
tipo
datos
controlados
individuos
grupos
organizaciones
aspectos
seguridad
relativos
datos
amplios
incluyendo
disponibilidad
privacidad
integridad
caso
disponibilidad
centra
destrucción
ficheros
da-
tos
ocurrir
forma
accidental
maliciosa
aspecto
evidente
concerniente
privacidad
lectura
autorizada
ficheros
datos
bases
datos
área
volcado
cantidad
esfuerzos
in-
vestigación
área
seguridad
informática
peligro
obvio
privacidad
incluye
análisis
datos
manifiesta
llamadas
bases
datos
estadísticas
contienen
información
resumida
agregada
Presumiblemente
existencia
in-
formación
agregada
peligro
privacidad
individuos
medida
crece
bases
datos
estadísticas
incremento
potencial
filtración
infor-
mación
personal
esencia
características
individuos
concretos
identificar
análisis
minucioso
ejemplo
sencillo
registro
tabla
agregada
incluye
ingresos
correspondientes
registro
suma
ingresos
diferencia
valores
ingresos
E.
problema
acrecienta
creciente
deseo
combinar
conjuntos
datos
casos
cruce
diversos
conjuntos
informa-
ción
niveles
apropiados
relevancia
problema
determinado
implican
descender
nivel
unidades
elementales
construir
datos
necesarios
forma
uni-
dades
elementales
sujetas
consideraciones
privacidad
encuentran
disponibles
pasos
proceso
conjuntos
datos
finalizar
integridad
datos
aspecto
clave
instalaciones
modifica-
ción
ficheros
datos
serie
consecuencias
problemas
me-
nores
desastrosos
Líneas
comunicaciones
redes
mecanismo
útil
clasificación
ataques
seguridad
redes
base
términos
ataques
pasivos
ataques
activos
ataque
pasivo
intenta
aprender
información
sistema
afecta
recursos
ataque
activo
intenta
alterar
recursos
sistema
afectar
operativa
ataques
pasivos
espionaje
monitorización
transmisiones
objetivo
oponente
obtener
información
transmitiendo
tipos
ataques
pasivos
lectura
contenidos
mensajes
análisis
tráfico
lectura
contenidos
mensajes
fácil
comprender
Figura
16.3a
con-
versación
telefónica
mensaje
correo
electrónico
transferencia
fichero
conte-
Seguridad
693
16-Capitulo
16
16/5/05
17:08
Página
693ner
información
sensible
confidencial
deseable
evitar
oponente
acceso
contenidos
transmisiones
tipo
ataques
pasivos
ataques
análisis
tráfico
discretos
Figura
16.3b
Supongamos
mecanismo
ocultar
contenidos
mensajes
tráfico
información
forma
oponentes
intrusos
capturan
mensajes
puedan
ex-
traer
información
contiene
técnica
habitual
ocultar
contenidos
cifrado
protección
basada
cifrado
funcionando
oponente
observar
patrones
mensajes
oponente
determinar
ubicación
identidad
ordena-
dores
comunican
observar
frecuencia
objeto
mensajes
intercambian
información
resultar
útil
adivinar
naturaleza
comunicaciones
llevando
cabo
694
Sistemas
operativos
Aspectos
internos
principios
diseño
Lectura
contenidos
mensajes
Pepe
Darth
Alicia
Lectura
contenido
mensaje
Pepe
Alicia
Análisis
tráfico
Pepe
Darth
Alicia
Observación
patrón
mensajes
Pepe
Alicia
Internet
instalación
comunicaciones
Internet
instalación
comunicaciones
Figura
16.3
Ataques
pasivos
16-Capitulo
16
16/5/05
17:08
Página
694Los
ataques
pasivos
difíciles
detectar
implican
alteración
datos
Habitualmente
tráfico
mensajes
envía
recibe
aparentemente
nor-
emisor
receptor
tercer
elemento
leído
mensajes
ana-
lizado
patrones
tráfico
prevenir
ataques
habitualmente
me-
cifrado
forma
énfasis
ataques
pasivos
centra
prevención
detección
ataques
activos
implican
modificaciones
flujo
datos
creación
flujos
datos
falsos
subdividir
categorías
enmascaramiento
reenvío
mo-
dificación
mensajes
denegación
servicio
enmascaramiento
ocurre
elemento
intenta
hacerse
pasar
Figura
16.4a
ataque
enmascaramiento
incluye
habitualmente
formas
ataques
acti-
vos
ejemplo
capturar
secuencias
autenticación
reenviarla
posteriormente
intercambiado
secuencia
válida
forma
permita
elemento
privilegios
obtener
privilegios
extra
suplantando
posea
reenvío
implica
captura
pasiva
unidad
datos
posterior
retransmisión
producir
efecto
autorizado
Figura
16.4c
modificación
mensajes
significa
sencillamente
mensaje
válido
alterado
mensajes
borrado
reordenado
producir
efecto
autorizado
Fi-
gura
16.4c
ejemplo
modifica
mensaje
cuyo
significado
Permite
Pepe
Pérez
leer
fichero
confidencial
cuentas
diga
Permite
Juanito
Sánchez
leer
fichero
confiden-
cial
cuentas
denegación
servicio
previene
imposibilitar
normal
gestión
instalacio-
nes
comunicaciones
Figura
16.4d
ataque
objetivo
específico
ejemplo
elemento
suprimir
mensajes
dirigidos
destino
particular
ejemplo
servicio
auditoría
seguridad
forma
denegación
servicio
desarticulación
red
deshabilitándola
sobrecargándola
mensajes
degradar
rendimiento
ataques
activos
presentan
características
opuestas
ataques
pasivos
ata-
ques
pasivos
difíciles
detectar
medidas
permiten
evitar
éxito
difícil
prevenir
ataques
activos
forma
completa
ha-
cerlo
requerirían
protecciones
físicas
instalaciones
comunicaciones
ru-
tas
objetivo
caso
detección
dichos
ataques
recuperación
cual-
quier
efecto
retraso
pudieran
causar
detección
efecto
disuasorio
contribuye
prevención
16.2
PROTECCIÓN
introducción
multiprogramación
trajo
posibilidad
compartir
recursos
usuarios
compartición
implica
procesador
Memoria
Dispositivos
discos
impresoras
Programas
Datos
posibilidad
compartir
recursos
introduce
necesidad
protección
PFLE97
apunta
sistema
operativo
ofrecer
niveles
protección
rango
Seguridad
695
16-Capitulo
16
16/5/05
17:08
Página
695•
protección
Apropiado
procedimientos
sensibles
ejecutar
instantes
Aislamiento
estrategia
implica
proceso
opera
forma
separada
pro-
cesos
compartición
comunicación
proceso
espacio
di-
recciones
ficheros
objetos
Compartición
completa
compartición
propietario
objeto
ejemplo
fi-
chero
segmento
memoria
declara
público
privado
caso
proceso
acceder
objeto
procesos
propietario
pue-
den
acceder
objeto
Compartición
vía
limitaciones
acceso
sistema
operativo
verificar
permisibilidad
acceso
usuario
específico
objeto
sistema
operativo
696
Sistemas
operativos
Aspectos
internos
principios
diseño
Enmascaramiento
Pepe
Darth
Alicia
Alicia
Mensaje
Darth
provenir
Pepe
Reenvío
Pepe
Darth
Captura
mensaje
Pepe
Alicia
posterior
envío
mensaje
Alicia
Internet
instalación
comunicaciones
Internet
instalación
comunicaciones
Figura
16.4
Ataques
activos
16-Capitulo
16
16/5/05
17:08
Página
696tanto
actúa
guardián
vigilante
usuarios
objetos
asegurando
producen
accesos
autorizados
Acceso
vía
capacidades
dinámicas
Permite
creación
dinámica
derechos
acceso
objetos
limitado
objeto
forma
protección
limita
acceso
objeto
objeto
ejemplo
usuario
ca-
pacitado
documento
sensible
imprimirlo
ejemplo
usuario
acceso
base
datos
calcular
estadísticas
obtener
deter-
minados
valores
específicos
Seguridad
697
Modificación
mensajes
Pepe
Darth
Alicia
Darth
modifica
mensaje
Pepe
Alicia
Denegación
servicio
Pepe
Darth
Servidor
Darth
impide
servicio
proporcionado
servidor
Internet
instalación
comunicaciones
Internet
instalación
comunicaciones
Figura
16.4
Continuación
16-Capitulo
16
16/5/05
17:08
Página
697Los
puntos
anteriores
presentado
orden
dificultad
creciente
punto
vista
implementación
orden
detalle
protección
proporcio-
na
sistema
operativo
determinado
proporcionar
grados
protección
dis-
tintos
objetos
usuarios
aplicaciones
sistema
operativo
necesita
equilibrar
necesidad
permitir
compartición
mejora
uti-
lidad
sistema
necesidad
proteger
recursos
usuarios
sec-
ción
mostrar
mecanismos
sistema
operativo
proporcionar
protección
objetos
PROTECCIÓN
MEMORIA
entorno
multiprogramado
protección
memoria
principal
esencial
aspectos
im-
portantes
seguridad
correcto
funcionamiento
procesos
encontrar
activos
proceso
escribir
forma
inadvertida
espacio
me-
moria
proceso
ejecutará
forma
correcta
separación
espacios
memoria
procesos
requisito
fundamental
esquemas
memoria
virtual
base
segmentación
paginación
combi-
nación
ambas
necesario
proporcionar
mecanismos
efectivos
gestionar
memoria
principal
busca
aislamiento
completo
sistema
operativo
únicamente
asegurar
segmento
página
accede
proceso
asigna-
requisito
fácil
alcanzar
asegurándose
únicamente
entradas
duplicadas
tablas
páginas
segmentos
desea
permitir
compartición
segmento
página
aparecer
tabla
tipo
compartición
fácil
alcanzar
sistema
soporte
segmentación
combinación
segmentación
paginación
caso
estructura
segmentos
visible
aplicación
aplicación
declarar
determinados
segmentos
encuentren
compartidos
entorno
paginación
resulta
difícil
diferenciar
tipos
memoria
estructura
memoria
completamente
transparente
aplicación
ejemplo
soporte
hardware
proporcionar
apoyo
protección
memo-
ria
proporcionan
máquinas
zSeries
IBM
ejecuta
sistema
operativo
clave
control
almacenamiento
7-bits
asociada
marco
página
memoria
principal
sistema
operativo
fijar
bits
indican
página
ocupando
marco
referenciado
cambiado
algoritmo
reemplazo
páginas
resto
bits
utilizan
mecanismos
protección
clave
control
acceso
bits
bit
protección
búsqueda
referencias
memoria
procesador
vía
DMA
utilizar
clave
ajuste
obtener
privilegios
acceso
dicha
página
bit
protección
búsqueda
indica
clave
control
acceso
aplica
escrituras
escrituras
lecturas
indistinta-
mente
procesador
palabra
programa
program
status
word
PSW
con-
información
control
relativa
proceso
actualmente
ejecución
Incluida
palabra
clave
PSW
4-bits
proceso
intenta
acceder
página
arranca
operación
DNA
página
clave
PSW
actual
compara
código
acceso
opera-
ción
escritura
permite
códigos
coinciden
bit
protección
búsqueda
puesto
clave
PSW
coincidir
código
acceso
operaciones
lectura
CONTROL
ACCESO
ORIENTADO
USUARIO
medidas
control
acceso
sistema
procesamiento
datos
encuadran
di-
ferentes
categorías
asociadas
usuario
asociadas
datos
698
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
698El
control
acceso
usuario
domina
forma
afortunada
autentica-
ción
término
utiliza
forma
generalizada
actualidad
sentido
au-
tenticación
mensajes
evitaremos
texto
formas
advierte
lector
utilización
encontrarse
literatura
técnica
común
control
acceso
usuario
sistema
compartido
servidor
registro
conexión
usuario
user
log
on
requiere
identificaron
usuario
ID
contraseña
password
sistema
permitirá
conexión
usuario
sistema
conoce
indicador
usuario
usuario
conoce
contraseña
asociada
sistema
identificado
sistema
ID
password
método
notablemente
fiable
proporcionar
control
acce-
so
usuarios
usuarios
olvidar
contraseñas
accidentalmente
forma
intencio-
revelarlas
hackers
demostrado
especialmente
habilidosos
adivinar
identifica-
dores
contraseñas
usuarios
especiales
control
sistema
personal
gestión
sistemas
Finalmente
fichero
contiene
identificadores
contraseñas
sujeto
intento
penetración
Discutiremos
contramedidas
Sección
16.3
control
acceso
usuarios
entorno
distribuido
cabo
forma
centra-
lizada
descentralizada
forma
centralizada
red
proporciona
servicio
conexión
determina
permitido
red
permitido
conectarse
control
acceso
usuarios
descentralizado
red
enlace
comunicación
trans-
parente
mecanismo
acceso
habitual
realiza
ordenador
destino
considerarse
aspectos
seguridad
relativos
transmisión
contraseñas
red
redes
utilizar
control
acceso
niveles
ordenadores
forma
particular
proporcionar
servicio
conexión
proteger
recursos
aplicaciones
es-
pecíficas
ordenador
Adicionalmente
red
conjunto
proporcionar
protección
acceso
restringido
únicamente
usuarios
autorizados
organización
niveles
aconsejable
casos
habituales
red
conecta
ordenadores
únicamente
proporciona
mecanismos
apropiados
acceso
terminal
ordenador
red
ordenadores
uniforme
forzar
existencia
política
acceso
centralizado
pro-
porcionada
centro
control
red
CONTROL
ACCESO
ORIENTADO
DATOS
éxito
conexión
sistema
usuario
obtenido
acceso
conjuntos
ordenadores
respectivas
aplicaciones
habitualmente
suficiente
sistema
incluye
datos
sensibles
bases
datos
procedimiento
control
ac-
ceso
usuario
identifica
usuarios
sistema
Asociado
usuario
existir
perfil
especifica
operaciones
permitidas
accesos
ficheros
siste-
ma
operativo
aplicar
reglas
basen
perfiles
usuario
sistema
gestión
bases
datos
controlar
acceso
determinados
registros
partes
registros
ejemplo
permitir
persona
sección
admi-
nistración
obtenga
listado
personal
compañía
individuos
determinados
acceso
información
salarios
cuestión
simple
nivel
detalle
caso
sistema
operativo
otorgar
permisos
usuarios
acceder
fichero
utilizar
aplicación
controles
seguridad
sistema
gestión
bases
datos
consideración
intentos
acceso
usuario
decisión
dependerá
únicamente
identidad
usuario
par-
específica
datos
acceder
información
divulgada
usuario
Seguridad
699
16-Capitulo
16
16/5/05
17:08
Página
699Un
modelo
general
control
acceso
aplicado
sistema
gestión
base
datos
sistema
ficheros
denominado
matriz
acceso
Figura
16.5a
basada
figura
SAND94
elementos
básicos
modelo
siguientes
Sujeto
elemento
capaz
acceder
objetos
Realmente
concepto
sujeto
asi-
mila
proceso
usuario
aplicación
realmente
gana
acceso
objeto
proceso
representa
usuario
aplicación
Objeto
elemento
accede
forma
controlada
Posibles
ejemplos
fi-
cheros
porciones
ficheros
programas
segmentos
memoria
objetos
software
ejem-
plo
objetos
Java
Derecho
acceso
forma
objeto
accedido
sujeto
ejemplos
lectura
escriturar
ejecución
funciones
objetos
software
700
Sistemas
operativos
Aspectos
internos
principios
diseño
Own
Own
Own
AFichero
WR
Own
Own
Información
crédito
Información
débito
Usuario
Usuario
Usuario
Fichero
Matriz
acceso
Listas
control
acceso
ficheros
Listas
capacidades
ficheros
Account
Account
Usuario
RR
Usuario
RW
Own
BFichero
Own
Own
Own
Own
Fichero
1Usuario
Own
AFichero
Own
Fichero
Fichero
Fichero
Fichero
Información
crédito
Información
débito
Fichero
Fichero
Fichero
Fichero
Fichero
Fichero
Fichero
Fichero
Figura
16.5
Ejemplo
estructuras
control
acceso
16-Capitulo
16
16/5/05
17:08
Página
700Una
dimensiones
matriz
consiste
sujetos
identificados
intentar
ac-
ceder
datos
Habitualmente
lista
consistirá
usuarios
grupos
usuarios
control
acceso
determinar
terminales
ordenadores
aplicaciones
lugar
conjunción
usuarios
dimensión
indica
objetos
realizan
accesos
nivel
detalle
objetos
campos
datos
individuales
Agrupaciones
generales
registros
ficheros
base
datos
completa
aparecer
objetos
matriz
entrada
matriz
indica
derechos
acceso
sujeto
so-
bre
objeto
práctica
matriz
acceso
habitualmente
dispersa
implementa
descomposición
maneras
siguientes
matriz
descomponer
co-
lumnas
definiendo
listas
control
acceso
Figura
16.5b
forma
objeto
lista
control
acceso
muestra
usuarios
derechos
acceso
listas
control
acceso
contener
entrada
defecto
pública
permite
usuarios
encuentran
indicados
forma
explícita
propietarios
derechos
especiales
puedan
asignar
serie
derechos
omisión
elementos
dichas
listas
incluir
usuarios
in-
dividuales
grupos
usuarios
descomposición
filas
definición
tickets
capacidades
Figura
16.5c
ticket
capacidad
específica
objetos
operaciones
autorizadas
determinado
usuario
usuario
número
tickets
encontrarse
autorizado
cederlos
entregarlos
tickets
encontrarse
dispersos
sistema
representa
problema
seguridad
listas
control
acceso
particular
ticket
falsificable
forma
llevarlo
cabo
sistema
operativo
encargue
mantener
tickets
usuarios
Dichos
tickets
almacenarse
región
memoria
accesible
usuarios
consideraciones
red
control
acceso
orientado
datos
equiparables
control
acceso
orientado
usuario
permite
acceso
determinados
usuarios
elementos
datos
resultar
necesario
cifrado
proteger
dichos
ele-
mentos
transmisión
usuarios
autorizados
Habitualmente
control
acceso
datos
descentralizado
controlando
sistemas
gestión
bases
datos
basados
servidores
servidor
base
datos
red
red
control
acceso
datos
convierte
función
red
16.3
INTRUSOS
peligros
seguridad
conocidos
intrusos
virus
general-
mente
denominados
hackers
crackers
importante
estudio
preliminar
intrusión
Anderson
ANDER80
identifican
clases
intrusos
Enmascarado
individuo
autorizado
utilizar
ordenador
penetra
controles
acceso
sistema
aprovecharse
usuario
legítimo
Trasgresor
usuario
legítimo
accede
datos
programas
recursos
di-
cho
acceso
autorizado
estando
autorizado
acceso
utilizar
privilegios
forma
maliciosa
Usuario
clandestino
usuario
sobrepasa
control
supervisión
sistema
di-
cho
control
evadir
auditoría
control
acceso
suprimir
recogida
regis-
tros
acceso
intruso
enmascarado
habitualmente
usuario
externo
trasgresor
generalmente
interno
usuario
clandestino
indistintamente
interno
externo
Seguridad
701
16-Capitulo
16
16/5/05
17:08
Página
701Los
ataques
intrusos
varían
benigno
serio
benigno
escala
encuentran
personas
simplemente
desean
explorar
redes
se-
rio
encuentran
individuos
intentan
leer
datos
privilegiados
modificaciones
au-
torizadas
dichos
datos
destruir
sistema
TÉCNICAS
INTRUSIÓN
objetivo
intruso
ganar
acceso
sistema
incrementar
rango
privilegios
ac-
ceso
sistema
Generalmente
requiere
intruso
consiga
información
debiera
en-
contrarse
protegida
casos
información
forma
contraseña
usuario
conocimiento
contraseña
usuario
intruso
acceder
sistema
utilizar
privilegios
acordes
usuario
legítimo
Habitualmente
sistema
mantener
fichero
asocia
contraseñas
usuario
autorizado
fichero
almacenado
protección
fácil
ac-
ceso
leer
contraseñas
fichero
contraseñas
proteger
formas
Cifrado
unidireccional
sistema
almacena
únicamente
forma
cifrada
contraseña
usuario
usuarios
presenta
contraseña
sistema
cifra
compara
valor
almacenado
práctica
sistema
habitualmente
realiza
transforma-
ción
unidireccional
reversible
contraseña
suele
generar
código
cifrado
longitud
fija
Control
acceso
acceso
fichero
contiene
contraseñas
limitado
cuentas
aplican
ambas
contramedidas
requiere
intruso
potencial
invierta
esfuerzo
extra
contraseñas
Basándose
revisión
literatura
en-
trevistas
crackers
contraseñas
ALV
A90
informa
siguientes
técnicas
contraseñas
Intentar
contraseñas
defecto
utilizadas
cuentas
estándar
vienen
creadas
sistema
administradores
preocupan
cambiar
valores
defecto
Ensayar
forma
exhaustiva
contraseñas
pequeño
tamaño
des-
caracteres
Probar
palabras
diccionario
sistema
lista
contraseñas
habituales
Ejemplos
encuentran
disponibles
foros
hackers
Internet
Recolectar
información
usuarios
tales
nombres
completos
nombre
esposas
hijos
imágenes
oficinas
libros
despacho
relacionados
hobbies
Intentar
número
teléfono
usuario
número
seguridad
social
dirección
domicilio
Probar
números
matrículas
válidos
dicha
región
Utilización
troyanos
descrito
Sección
16.4
sobrepasar
restricciones
acceso
Pinchar
línea
usuario
remoto
sistema
destino
métodos
mecanismos
adivinar
contraseña
intruso
verificar
hipótesis
intentando
acceder
sistema
resulta
tedioso
fácilmente
evi-
702
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
702table
ejemplo
sistema
simplemente
rechazar
intento
conexión
probado
contraseñas
requiere
intruso
vuelva
establecer
conexión
ordenador
intentarlo
circunstancias
práctico
probar
puñado
contraseñas
intrusos
suelen
probar
mecanismos
burdos
ejemplo
intruso
acceso
sistema
nivel
privilegios
fichero
contraseñas
encuentre
cifrado
estrategia
capturar
fichero
utilizar
mecanis-
mo
cifrado
sistema
voluntad
encuentre
contraseña
válida
proporcio-
ne
nivel
privilegios
alto
ataques
adivinación
contraseñas
habituales
altamente
efec-
tivos
evaluar
número
hipótesis
forma
automática
verifi-
car
validez
proceso
prueba
detectarse
sección
dire-
mos
acerca
ataques
adivinación
contraseñas
séptimo
método
indicado
anteriormente
troyano
caballo
Troya
particular-
mente
difícil
contrarrestar
ejemplo
programa
superar
controles
acceso
mencionado
ALV
A90
usuario
privilegios
desarrolla
programa
juego
invita
administrador
sistema
utilizarlo
tiempo
libre
programa
verdade-
ramente
juego
contiene
código
realiza
copia
fichero
contraseñas
cifrado
protección
acceso
fichero
copia
fichero
usuario
juego
ejecutando
privilegiado
admi-
nistrador
acceso
fichero
contraseñas
octavo
ataque
lista
pinchar
escuchar
línea
cuestión
seguridad
física
Pue-
evitarse
técnicas
cifrado
enlaces
continuación
repasar
principales
contramedidas
prevención
detección
prevención
reto
seguridad
informática
dura
batalla
dificultad
estri-
ba
defensor
guarecerse
posibles
ataques
ata-
cante
libertad
intentar
encontrar
punto
débil
cadena
defensiva
atacar
di-
cho
punto
detección
centra
reconocimiento
ataques
justo
tengan
éxito
PROTECCIÓN
CONTRASEÑAS
línea
defensa
intrusos
sistema
contraseñas
Virtualmente
acceso
sistema
multiusuario
requiere
usuario
proporcione
nombre
identificador
ID
contraseña
contraseña
sirve
autentificar
identificador
conectando
sistema
identificador
proporciona
seguridad
identificador
determina
usuario
autorizado
acceso
sistema
al-
gunos
sistemas
identificador
registrado
sistema
permite
acceso
identificador
determina
privilegios
asociados
usuario
usuarios
te-
ner
estatus
supervisor
superusuario
permite
leer
ficheros
tareas
especialmente
protegidas
sistema
operativo
sistemas
disponen
cuen-
tas
anónimas
invitados
usuarios
dichas
cuentas
privilegios
limi-
tados
cualquiera
identificador
utiliza
control
acceso
discrecional
ejemplo
indican-
do
lista
identificadores
usuarios
usuario
otorgar
permisos
puedan
leer
ficheros
pertenecen
Seguridad
703
16-Capitulo
16
16/5/05
17:08
Página
703Vulnerabilidad
contraseñas
comprender
naturaleza
ataque
consideremos
esquema
ampliamente
difundido
sistemas
UNIX
contraseñas
encuen-
tran
almacenadas
lugar
utiliza
procedimiento
Figura
16.6a
usuario
selecciona
contraseña
caracteres
imprimibles
longitud
Dicha
contraseña
convierte
valor
56-bits
utilizando
código
ASCII
7-bits
vale
entrada
rutina
cifrado
rutina
cifrado
conocida
crypt(3
basa
DES
Data
Encryption
Standard
descrito
Apéndice
16A.
algoritmo
DES
modifica
utilizando
valor
12
bits
aderezo
Típicamente
valor
relacionado
momento
contra-
seña
asignó
usuario
algoritmo
DES
modificado
pasa
entrada
bloque
64
bits
cero
salida
algoritmo
sirve
entrada
cifrado
proce-
so
repite
25
Resulta
salida
64
bits
traduce
secuencia
caracteres
contraseña
texto
cifrado
almacena
copia
valor
aderezo
fichero
contraseñas
correspondiente
identificador
usuario
704
Sistemas
operativos
Aspectos
internos
principios
diseño
Id
usuario
11
caracteres
Aderezo
12
bits
56
bits
Contraseña
Carga
Selección
Carga
contraseña
Verificación
contraseña
Aderezo
Contraseña
fichero
Salida
crypt(3
crypt
Aderezo
Contraseña
cifrada
Contraseña
crypt
Comparación
Contraseña
fichero
Id
usuario
Aderezo
Salida
crypt(3)Id
usuario
Figura
16.6
esquema
contraseñas
UNIX
16-Capitulo
16
16/5/05
17:08
Página
704El
valor
aderezo
vale
fines
Evita
contraseñas
duplicadas
visibles
fichero
contraseñas
In-
cluso
usuarios
eligen
contraseña
contraseñas
asignadas
instantes
tiempo
contraseña
extendida
usuarios
Incrementa
forma
efectiva
longitud
contraseña
requerir
usuario
recuerde
caracteres
adicionales
número
posibles
contraseñas
incrementa
factor
4096
incrementando
dificultad
adivinar
dicha
contraseña
Evita
utilización
implementaciones
hardware
DES
reduce
riesgo
ataques
fuerza
bruta
usuario
intenta
acceder
sistema
UNIX
usuario
proporciona
identificador
contraseña
sistema
operativo
utiliza
identificador
indexar
fichero
contraseñas
recuperar
valor
aderezo
contraseña
cifrada
contraseña
proporcio-
usuario
utilizan
entrada
rutina
cifrado
resultado
coincide
va-
lor
almacenando
acepta
contraseña
rutina
cifrado
diseñó
desalentar
intentos
adivinación
contraseñas
implementaciones
software
DES
lentas
comparadas
versiones
hardware
utili-
zación
25
iteraciones
multiplica
tiempo
necesario
25
diseño
original
algoritmo
ocurrido
cambios
diseñado
implementacio-
nes
algoritmo
consecuente
mejora
prestaciones
ejemplo
gusano
worm
Inter-
net
capaz
intentar
contraseñas
línea
tasa
centenares
contraseñas
pe-
riodo
tiempo
relativamente
utilizando
algoritmo
cifrado
eficiente
proporcionado
forma
estándar
sistemas
UNIX
atacaba
lugar
prestacio-
nes
hardware
continúan
incrementándose
forma
algoritmo
software
ejecuta
rápidamente
peligros
esquema
contraseñas
UNIX
usua-
rio
acceso
sistema
utilizando
invitado
me-
canismo
ejecutar
programa
adivinación
contraseñas
denominado
habitualmente
password
cracker
dicha
máquina
atacante
capaz
probar
cientos
miles
posibles
contraseñas
consumo
recursos
mínimo
oponente
capaz
obtener
copia
fichero
contraseñas
programa
cracker
ejecutar
máquina
voluntad
permite
oponente
ejecutar
probando
millares
posibles
contraseñas
periodo
razonable
ejemplo
agosto
1993
Internet
ejecución
password
cracker
MADS93
Utilizando
ordenador
paralelo
Thinking
Machines
Corporation
alcanzaba
rendimiento
1560
cifrado
unidad
vectorial
unidades
vectoriales
nodo
configuración
estándar
alcanzan
800.000
cifrados
má-
quina
128
nodos
representa
tamaño
modesto
6,4
millones
cifrados
máquina
1024
nodos
increíbles
tasas
prueba
contraseñas
resulta
factible
atacante
utilizar
técnica
simple
fuerza
bruta
probar
posibles
combinaciones
caracteres
descubrir
contraseña
lugar
password
crackers
basan
mayoría
personas
eligen
contraseñas
fácilmente
adivinables
usuarios
permite
elegir
contraseña
seleccionan
ab-
surdamente
corta
resultado
estudio
universidad
Purdue
muestra
Tabla
16.2
estudio
observaba
cambios
contraseñas
54
máquinas
representaban
Seguridad
705
16-Capitulo
16
16/5/05
17:08
Página
705aproximadamente
7000
cuentas
usuarios
3%
contraseñas
caracteres
longitud
atacante
comenzar
ataque
probando
exhaustivamente
posi-
bles
contraseñas
longitud
inferior
remedio
sencillo
sistema
rechace
automáti-
camente
selección
contraseña
menor
pongamos
caracteres
requie-
ra
contraseñas
exactamente
caracteres
longitud
usuarios
quejarían
restricción
longitud
contraseña
problema
gente
permite
elegir
contraseña
seleccionan
palabra
fácilmente
adivinable
pro-
pio
nombre
nombre
calle
palabra
común
diccionario
similares
trabajo
password
cracker
sencillo
programa
simplemente
probar
fi-
chero
contraseñas
palabras
parezcan
probables
gente
utiliza
contraseñas
fácilmente
adivinables
estrategia
éxito
prácticamente
sistemas
demostración
efectividad
mecanismo
adivinación
contraseñas
encuen-
tra
recogido
KLEI90
autor
recogió
ficheros
contraseñas
UNIX
fuen-
tes
contenían
cerca
14.000
contraseñas
cifradas
resultado
autor
denomina
escalofriante
muestra
Tabla
16.3
general
cuarto
contrase-
ñas
adivinar
utilizando
estrategia
intenta
nombre
usuario
iniciales
nombre
información
personal
relevante
intentaron
130
permutaciones
usuarios
intentaron
diccionarios
autor
recopiló
diccionario
60.000
palabras
incluyendo
diccionario
sistema
tantos
muestran
tabla
intentaron
permutaciones
palabras
paso
incluyen
letra
mayúsculas
carácter
control
palabra
mayúsculas
invertir
palabra
cambiar
letra
dígito
permutaciones
añadieron
mi-
llón
palabras
lista
consideraron
combinaciones
mayúsculas
minúsculas
palabras
paso
considerado
paso
millones
palabras
lista
706
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
16.2
Longitud
contraseñas
Longitud
Número
Fracción
55
0.004
87
0.006
212
0.02
449
0.03
1260
0.09
3035
0.22
2917
0.21
5772
0.42
13.787
1.0
16-Capitulo
16
16/5/05
17:08
Página
706
abla
16.3
Contraseñas
descifradas
conjunto
entrenamiento
13797
cuentas
KLEI90
Número
Porcentaje
Tipo
contraseña
amaño
búsqueda
coincidencias
contraseñas
coincidentes
Nombre
usuario
130
368
2.7%
Secuencias
caracteres
866
22
0.2%
Números
427
0.1%
Chino
392
56
0.4%
Nombres
lugares
628
82
0.6%
Nombres
comunes
2239
548
4.0%
Nombres
mujer
4280
161
1.2%
Nombres
hombre
2866
140
1.0%
Nombres
habituales
4955
130
0.9%
Mitos
leyendas
1246
66
0.5%
Shakespeare
473
0.1%
Términos
deportivos
238
32
0.2%
Ciencia
ficción
691
59
0.4%
Películas
actores
99
12
0.1%
Dibujos
animados
92
0.1%
Gente
famosa
290
55
0.4%
Frases
términos
933
253
1.8%
Apellidos
33
0.1%
Biología
58
0.0%
Diccionario
sistema
19.683
1027
.4%
Nombres
máquinas
9018
132
1.0%
Términos
mnemotécnicos
14
0.0%
Biblia
rey
Jaime
7525
83
0.6%
Palabras
variadas
3212
54
0.4%
Palabras
hebreas
56
0.0%
esteroides
2407
19
0.1%
62.727
3340
24.2%
forma
prueba
incluía
conjunto
palabras
cercano
millones
Utilizando
implementación
rápida
Thinking
Machines
comentado
anteriormente
tiempo
cifrar
palabras
posibles
valores
aderezo
hora
búsqueda
producir
tasa
acierto
aproximada-
mente
25%
considerando
simplemente
acierto
permitir
ganar
amplio
rango
privi-
legios
sistema
forma
reciente
PERR03
recoge
estrategia
aprovecha
continuo
in-
cremento
velocidad
procesadores
capacidad
almacenamiento
estrate-
Seguridad
707
16-Capitulo
16
16/5/05
17:08
Página
707gia
número
posibles
contraseñas
valores
aderezo
alternativos
encuentran
pre-
computadas
almacenadas
tabla
consultada
momento
descifrar
con-
traseñas
informe
muestra
factibilidad
atacar
esquema
contraseñas
UNIX
Actualmente
UNIX
mayoría
distribuidores
Linux
ofrecen
alternativas
segu-
ras
estrategia
utilización
únicamente
crypt(3
Control
acceso
forma
protegerse
ataques
contraseñas
denegar
acceso
oponente
fichero
contraseñas
fichero
contraseñas
cifradas
acce-
sible
usuarios
nivel
privilegios
adecuados
oponente
leerlo
co-
nocer
previamente
contraseña
usuario
privilegiado
SPAF92
remarca
fallos
estrategia
sistemas
incluyendo
mayoría
sistemas
UNIX
susceptibles
intromisiones
forma
venga
anticipada
atacante
conseguido
acceder
al-
guna
forma
sistema
lista
contraseñas
forma
utilizar
dife-
rentes
cuentas
distintas
sesiones
conexión
reducir
riesgo
detecta-
do
usuario
dispone
desear
utilizar
acceder
datos
privilegiados
sabotear
sistema
accidente
protección
fichero
contraseñas
legible
compro-
metiendo
forma
cuentas
usuarios
cuentas
máquinas
dominios
pro-
tección
casos
utilizar
contraseña
contraseñas
leerse
cualquiera
máquina
máquina
encontrarse
comprometi-
circunstancias
forma
estrategia
efectiva
obligar
usuarios
asignar
contraseñas
difíciles
adivinar
ESTRATEGIAS
SELECCIÓN
CONTRASEÑAS
lección
aprendida
experimentos
acabamos
describir
Tablas
16.2
16.3
dejada
decisión
usuarios
eligen
contraseña
corta
dema-
siado
fácil
adivinar
extremo
usuarios
asignan
contraseñas
consistentes
caracteres
imprimibles
seleccionados
forma
aleatoria
adivinación
contraseñas
efectivamente
imposible
resultaría
imposible
mayoría
usuarios
recordar
contraseñas
Afortunadamente
limitamos
universo
contraseñas
cade-
nas
caracteres
razonable
memorizar
espacio
universo
permitir
adivinación
contraseñas
forma
práctica
objetivo
eliminar
contraseñas
adivinables
permitimos
usuarios
seleccionen
fáciles
memorizar
utilizan
técnicas
básicas
Educación
usuarios
Contraseñas
generadas
ordenador
Verificación
reactiva
contraseñas
Verificación
proactiva
contraseñas
usuarios
importancia
utilizar
contraseñas
difíciles
adivinar
proporcionar
referencias
seleccionar
contraseñas
fuertes
estrategia
708
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
708educación
usuarios
posibilidades
éxito
mayoría
instalaciones
particularmente
amplia
población
usuarios
cambios
Mu-
chos
usuarios
simplemente
ignoran
recomendaciones
jue-
ces
fortaleza
contraseña
ejemplo
usuarios
erróneamente
creen
vuelta
palabra
mayúsculas
letra
contraseña
imposible
adivinar
contraseñas
generadas
ordenador
problemas
naturaleza
contraseña
aleatoria
usuarios
recordarán
contraseña
pronun-
ciable
usuarios
problemas
recordarla
sentirse
tentados
tenerla
escrita
ge-
neral
esquemas
contraseñas
generadas
ordenador
historial
escasa
aceptación
usuarios
FIPS
PUBS
181
define
generadores
contraseñas
automáticos
diseñados
estándar
incluye
descripción
estrategia
listado
completo
código
fuente
algoritmo
algoritmo
genera
palabras
sílabas
pro-
nunciables
concatena
formar
palabra
generador
aleatorio
números
produce
flujo
caracteres
aleatorios
usado
construir
sílabas
palabras
verificación
reactiva
contraseñas
estrategia
sistema
for-
ma
periódica
ejecuta
programa
adivinación
encontrar
posibles
contraseñas
adivina-
bles
sistema
cancela
contraseña
resulta
adivinada
notifica
usuario
táctica
desventajas
lugar
requiere
intensivo
recursos
reali-
zar
trabajo
determinado
oponente
capaz
robar
fichero
con-
traseñas
dedicar
tiempo
CPU
tarea
horas
verifica-
ción
reactiva
contraseñas
desventaja
contraseñas
frágiles
permanecerán
vulnerables
verificador
contraseñas
encuentre
alternativa
prometedora
mejorar
sistema
seguridad
contraseñas
verifi-
cación
proactiva
contraseñas
esquema
usuarios
permite
seleccionar
contraseña
momento
selección
sistema
prueba
contrase-
ña
permitida
rechaza
variaciones
basan
filosofía
sufi-
ciente
supervisión
sistema
usuario
seleccionar
contraseña
memorizar
espacio
amplio
contraseñas
probablemente
fáciles
adivinar
ataque
basado
diccionario
truco
implantar
verificador
contraseñas
proactivo
encontrar
equilibrio
aceptación
usuario
fuerza
contraseña
sistema
rechaza
demasiadas
pala-
bras
usuarios
quejarán
difícil
encontrar
contraseña
sistema
utiliza
algoritmo
sencillo
definir
aceptable
proporcionar
pistas
password
crackers
refinasen
técnicas
adivinar
contraseñas
resto
sub-
sección
repasar
estrategias
validación
contraseñas
forma
proactiva
estrategia
sistema
sencillo
reglas
ejemplo
definir
siguien-
tes
reglas
contraseñas
caracteres
longitud
caracteres
contraseñas
incluir
mayúsculas
minúsculas
dígito
signo
puntuación
reglas
cumplirse
aviso
correspondiente
usuario
validación
pe-
sar
estrategia
simplemente
indicar
recomendaciones
usuarios
suficiente
defenderse
ataques
adivinación
contraseñas
esquema
alertar
programas
contraseñas
probar
adivinación
resto
Seguridad
709
16-Capitulo
16
16/5/05
17:08
Página
709Otra
posibilidad
simplemente
recopilar
diccionario
posiblemente
malas
contraseñas
usuario
selecciona
contraseña
sistema
comprueba
lista
palabras
rechazadas
problemas
estrategia
espacio
tamaño
diccionario
eficaz
ejemplo
diccionario
utilizado
estudio
universidad
Purdue
SPAF92
ocupa
30
Mbytes
almacenamiento
tiempo
tiempo
requiere
buscar
diccionario
excesivo
Adicionalmente
verificar
permutaciones
posibles
palabras
diccionario
añaden
palabras
diccionario
haciéndolo
verdaderamente
búsquedas
implicar
procesamiento
considerable
DETECCIÓN
INTRUSOS
Inevitablemente
sistema
prevención
intrusos
fallará
línea
de-
fensa
sistema
detección
intrusos
principales
focos
inves-
tigación
años
interés
motivado
diversas
consideraciones
in-
cluyendo
siguientes
intrusión
detecta
suficientemente
rápido
intruso
identificado
expulsa-
do
sistema
haga
daño
llegue
comprometer
dato
detec-
ción
suficientemente
rápida
expulsar
tiempo
detecte
intru-
sión
menor
daño
provoca
rápidamente
llegar
recuperación
sistema
detección
resulte
efectivo
actuar
forma
disuasoria
forma
previenen
intrusiones
detección
intrusos
permite
recolección
información
técnicas
intrusión
utilizarse
reforzar
servicios
prevención
detección
intrusos
basa
suposición
comportamiento
intruso
difiere
usuario
legítimo
forma
cuantificado
esperar
distinción
clara
exacta
ataque
intruso
utilización
habitual
re-
cursos
usuario
autorizado
lugar
debemos
esperar
exista
determinado
so-
lapamiento
Figura
16.7
sugiere
forma
abstracta
naturaleza
tarea
en-
cuentra
diseñador
sistema
detección
intrusos
comportamiento
típico
intruso
difiere
comportamiento
típico
usuario
autorizado
solapamiento
en-
tre
comportamientos
forma
interpretación
amplia
com-
portamiento
intruso
permite
capturar
número
llevará
elevado
número
falsos
positivos
usuarios
autorizados
identificados
intrusos
elementos
compromiso
experiencia
práctica
detección
intrusos
Estudio
Anderson
ANDE80
postulaba
confianza
razonable
distinguir
intruso
enmascarado
usuario
legítimo
patrones
comportamiento
usuarios
legítimos
observarse
datos
históricos
detectar
desviación
significativa
dichos
patrones
Anderson
sugiere
tarea
detección
trasgre-
sor
usuario
legítimo
actuando
forma
autorizada
difícil
referente
distinción
comportamiento
anormal
comportamiento
normal
pequeña
An-
derson
concluye
dichas
violaciones
serían
indetectables
únicamente
búsqueda
710
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
710comportamiento
normal
comportamiento
trasgresor
caso
de-
tectarse
definición
inteligente
clase
condiciones
sugieren
au-
torizado
concluir
detección
usuario
clandestino
allá
ámbito
técnicas
pu-
ramente
remotas
observaciones
1980
continúan
válidas
PORR92
identifica
siguientes
técnicas
detección
intrusos
Detección
estadística
anomalías
Implica
recolección
datos
relativos
comporta-
miento
usuarios
legítimos
período
tiempo
Posteriormente
aplican
serie
tests
estadísticos
comportamiento
observar
determinar
alto
nivel
confianza
comportamiento
usuario
legítimo
Detección
umbral
estrategia
implica
definición
umbrales
independientes
usuario
frecuencia
determinados
eventos
Basado
perfil
desarrolla
perfil
actividad
usuarios
utiliza
detectar
cambios
comportamiento
cuentas
forma
individual
Detección
basada
reglas
Implica
intento
definir
conjunto
reglas
pue-
utilizar
decidir
comportamiento
intruso
Detección
anomalías
Reglas
desarrolladas
detectar
desviación
patrones
usos
previos
Identificación
penetración
sistema
experto
busca
comportamiento
sospe-
choso
Seguridad
711
Solapamiento
comportamiento
observado
esperado
Perfil
comportamiento
intruso
Perfil
comportamiento
usuario
autorizado
Parámetro
comportamiento
medible
Comportamiento
intruso
Comportamiento
usuario
autorizado
Función
densidad
probabilidad
Figura
16.7
Perfiles
comportamiento
intrusos
usuarios
autorizados
16-Capitulo
16
16/5/05
17:08
Página
711En
esencia
estrategias
estadísticas
intentan
definir
comportamiento
normal
esperado
técnicas
basadas
reglas
intentan
definir
comportamiento
sospechoso
relación
tipos
atacantes
mencionados
anteriormente
detección
estadística
ano-
malías
resulta
efectiva
caso
ataques
enmascarados
posibilidades
ha-
cerse
pasar
patrones
comportamiento
cuentas
apropiado
técnicas
capaces
tratar
caso
trasgresores
tipo
ataques
estra-
tegias
basadas
reglas
identificar
eventos
secuencias
contexto
revelan
intromisión
práctica
sistema
exhibir
combinación
ambas
estrategias
resultar
efectivo
amplio
abanico
ataques
herramienta
fundamental
detección
intrusos
registro
auditoría
utilizan
registros
actividades
realizando
usuario
entrada
sistemas
detec-
ción
intrusos
Básicamente
utilizados
Registros
auditoría
nativos
Prácticamente
sistemas
operativos
multiusuario
in-
cluyen
software
auditoría
registrar
actividad
usuarios
ventaja
utilizar
información
requiere
software
adicional
recoger
datos
desventaja
registros
auditoría
nativos
información
necesaria
requerirse
esté
formato
conveniente
Registros
auditoría
específicos
detección
implementar
funcionalidad
recolección
datos
genere
registros
auditoría
contienen
información
pensada
únicamente
sistema
detección
intrusos
ventaja
dicha
estrategia
realizarse
forma
independiente
vendedor
implantarse
amplia
variedad
sistemas
desventaja
implica
sobrecarga
extra
paquetes
auditoría
ejecutándose
máquina
ejemplo
registros
auditoría
específicos
detección
desarrollados
Do-
rothy
Denning
DENN87
registros
auditoría
siguientes
campos
Sujeto
Iniciador
acción
sujeto
típicamente
terminal
usuario
tam-
bién
proceso
actúa
usuario
grupo
usuarios
actividad
serie
mandatos
lanzados
sujetos
sujetos
agruparse
clases
acceso
dichas
clases
solapadas
Acción
Operación
realizada
sujeto
utilizando
objeto
ejemplo
acceso
lectura
operación
ejecución
Objeto
receptor
acciones
ejemplos
incluyen
ficheros
programas
mensajes
re-
gistros
terminales
impresoras
estructuras
creadas
usuarios
programas
sujeto
receptor
acción
ejemplo
correo
electrónico
sujeto
objeto
sujetos
agruparse
tipos
granularidad
objetos
variar
tipo
objeto
entorno
ejemplo
acciones
bases
da-
tos
auditarse
base
datos
conjunto
nivel
registro
Condiciones
excepción
Denota
condiciones
excepción
lanzarían
respuesta
Utilización
recursos
lista
elementos
cuantitativos
elementos
calculan
cantidad
recursos
utilizados
ejemplo
número
líneas
impresas
mostra-
das
número
registros
leídos
escritos
tiempo
procesador
unidades
utilizadas
tiempo
sesión
transcurrido
Sello
tiempo
sello
único
fecha
hora
identifica
lugar
acción
712
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
712Muchas
operaciones
usuarios
constituyen
acciones
elementales
ejemplo
copia
fichero
implica
ejecución
programa
usuario
incluye
verifica-
ción
acceso
desarrollo
copia
propiamente
dicha
lectura
fichero
es-
critura
fichero
Consideremos
mandato
COPY
JUEGO.EXE
TO
Dir
JUEGO.EXE
lanzado
Pepe
copiar
fichero
ejecutable
JUEGO
directorio
actual
directorio
Dir
generarían
siguientes
registros
auditoría
Pepe
ejecución
Dir
COPY
.EXE
CPU=00002
11058721678
Pepe
lectura
Pepe
JUEGO.EXE
RECORDS=0
11058721679
Pepe
ejecución
Dir
JUEGO.EXE
wr-viol
RECORDS=0
11058721680
caso
operación
copia
abortado
Pepe
permisos
escritura
Dir
división
operaciones
usuario
acciones
elementales
trae
ventajas
objetos
entidades
sistema
protección
utilización
accio-
nes
elementales
permite
auditoría
comportamiento
refiere
objeto
forma
sistema
detectar
intentos
maliciosos
controles
acceso
notando
anomalía
número
condición
excepción
devuelto
detectar
acciones
maliciosas
éxito
notando
anomalía
conjunto
objetos
accesibles
sujeto
registros
auditoría
basados
objeto
sencillo
acción
sencilla
simplifican
modelo
implementación
estructura
uniforme
sencilla
registros
auditoría
específicos
detec-
ción
relativamente
sencillo
obtener
información
proyectan-
do
directamente
registros
auditoría
nativos
actuales
registros
específicos
detección
16.4
SOFTWARE
MALICIOSO
tipos
sofisticados
amenazas
sistema
informático
encuentran
presentes
programas
explotan
vulnerabilidades
sistema
contexto
centraremos
programas
aplicación
programas
utilidad
tales
editores
compiladores
término
genérico
amenazas
software
malicioso
malware
malware
software
diseña-
do
causar
daño
utilizar
recursos
ordenador
Frecuentemente
escondido
den-
tro
programa
enmascarado
software
legítimo
casos
distribuye
asimismo
ordenadores
correo
electrónico
diskettes
infectados
Comenzamos
sección
visión
general
espectro
relativo
amenazas
software
resto
sección
dedicado
virus
lugar
veremos
naturaleza
posibles
medidas
evitarlos
Seguridad
713
16-Capitulo
16
16/5/05
17:08
Página
713PROGRAMAS
MALICIOSOS
Figura
16.8
proporciona
taxonomía
general
software
malicioso
amenazas
dividir
categorías
necesitan
programa
anfitrión
independientes
primeras
esencialmente
fragmentos
programa
existir
forma
independiente
aplicación
utilidad
programa
sistema
particular
programas
autónomos
planificarse
ejecutarse
sistema
operativo
diferencia
casos
replicar
meros
programas
activarse
programa
anfitrión
ejecuta
función
específica
segundos
consisten
fragmento
programa
vi-
rus
programa
independiente
gusano
zombie
ejecutan
producir
copias
activarán
posteriormente
sistemas
taxonomía
Figura
16.8
útil
organizar
información
tratando
muestra
panorama
particular
bombas
lógicas
troyanos
pue-
den
virus
gusano
Puerta
secreta
puerta
secreta
punto
entrada
secreto
programa
per-
mite
alguien
conoce
existencia
dicha
puerta
secreta
acceso
utilizar
procedi-
mientos
acceso
seguridad
estándar
puertas
secretas
utilizado
forma
legítima
du-
rante
años
programadores
depurar
programas
Habitualmente
programador
desarrollando
aplicación
procedimiento
autenticación
configuración
relativamente
larga
requiere
usuario
introduzca
valores
ejecutar
aplicación
depurar
programa
desarrollador
querer
ganar
privilegios
especiales
evitar
configuración
autenticación
estándar
querer
asegurarse
método
activar
programa
momento
problema
pro-
cedimiento
autenticación
incluido
aplicación
puerta
secreta
código
reconoce
determinadas
secuencias
especiales
entrada
dispara
ejecuta
determinado
identificador
usuario
secuencial
eventos
habitual
714
Sistemas
operativos
Aspectos
internos
principios
diseño
Programas
maliciosos
Requiere
programa
anfitrión
Independiente
Bomba
lógica
Troyanos
Virus
replican
Gusano
ZombiePuerta
secreta
Figura
16.8
Taxonomía
programas
maliciosos
16-Capitulo
16
16/5/05
17:08
Página
714Las
puertas
secretas
convertirse
amenazas
utilizadas
programadores
escrúpulos
ganar
accesos
autorizados
puerta
secreta
idea
básica
vulnerabi-
lidad
retratada
película
Juegos
Guerra
COOP89
ejemplo
desarrollo
Multics
realizaron
serie
pruebas
penetración
grupo
denominado
Air-
Force
tiger
team
adversarios
simulados
técnica
empleada
enviar
actualización
falsa
sistema
operativo
ordenador
ejecutando
Multics
actualización
contenida
troyano
activar
puerta
secreta
permitía
tiger
team
acceso
sistema
amenaza
implementada
equipo
desarrolladores
Multics
capaz
encontrarlo
informados
presencia
ENGE80
difícil
implementar
controles
sistema
operativo
puertas
secretas
medidas
seguridad
centrar
desarrollo
programas
actividades
relati-
vas
actualización
software
Bomba
lógica
viejos
peligros
virus
gusanos
bombas
lógicas
bomba
lógica
código
insertado
programa
legítimo
explo-
tará
condiciones
ejemplos
condiciones
activar
bomba
lógica
presencia
ausencia
determinados
criterios
particular
semana
fecha
usuario
particular
ejecutando
aplicación
activada
bomba
al-
terar
borrar
datos
ficheros
completos
causando
máquina
detenga
produzca
al-
gún
daño
ejemplo
impacto
utilización
bomba
lógica
caso
Tim
Lloyd
condenado
costó
empresa
Omega
Engineering
10
mi-
llones
dólares
echando
tierra
estrategia
crecimiento
empresa
causando
despido
80
trabajadores
GAUD00
instancia
Lloyd
sentenciado
41
meses
prisión
obligado
pagar
millones
dólares
indemnización
royano
caballo
Troya
troyano
programa
útil
aparentemente
útil
mandato
contiene
código
oculto
invocarse
realiza
función
deseada
dañina
programas
troyanos
utilizan
tareas
forma
indirecta
usuario
auto-
rizado
directamente
ejemplo
ganar
acceso
determinados
ficheros
usuario
sistema
compartido
usuario
crear
troyano
ejecuta
cambie
permisos
ficheros
usados
forma
ficheros
accesibles
posteriormente
usuario
autor
posteriormente
inducir
usuarios
ejecutar
programa
colocándolo
directorio
común
renombrándolo
tratase
herramienta
utili-
dad
ejemplo
programa
produce
listado
ficheros
usuario
formato
determinado
usuario
utilice
programa
autor
acceso
información
ficheros
ejemplo
programa
troyano
difícil
detectar
compilador
modificado
insertar
código
adicional
deter-
minados
programas
compilan
ejemplo
caso
programa
login
sistema
THOM84
código
crear
puerta
secreta
programa
login
permite
autor
acceder
sistema
utilizando
clave
especial
troyano
descubierto
inspeccionando
código
fuente
programa
login
motivación
habitual
utilización
troyanos
destrucción
datos
programa
parecer
realiza
tarea
útil
ejemplo
programa
calculadora
borrando
silenciosamente
ficheros
usuario
ejemplo
ejecutivo
CBS
víctima
troyano
destruyo
información
contenida
ordenador
TIME90
troyano
pre-
sentaba
rutina
gráfica
ofrecida
foro
Virus
virus
programa
infectar
programas
modificándolos
modificacio-
nes
incluyen
copia
programa
virus
continuación
infectar
programas
Seguridad
715
16-Capitulo
16
16/5/05
17:08
Página
715Los
virus
biológicos
pequeños
fragmentos
código
genético
ADN
ARN
tomar
maquinaria
célula
viva
modificarla
miles
réplicas
virus
original
análogo
biológico
virus
informático
contiene
código
instrucciones
encarga
copias
Infectado
ordenador
virus
típico
toma
control
disco
sis-
tema
operativo
ordenador
Posteriormente
momento
ordenador
infectado
pone
contacto
software
quedará
infectado
copia
virus
pasa
programa
forma
infección
expandir
ordenador
ordenador
usuarios
per-
caten
intercambio
discos
enviándose
programas
red
entorno
red
posibilidad
acceder
aplicaciones
servicios
sistema
or-
denador
proporciona
infraestructura
perfecta
dispersión
virus
virus
examinan
detalle
sección
Gusano
gusanos
utilizan
conexiones
red
expandirse
sistema
encuentran
activos
sistema
gusano
red
comportar
vi-
rus
informático
implantar
troyanos
tipo
acciones
destructivas
replicarse
gusano
red
utiliza
tipo
vehículo
comunicación
ejemplo
Herramientas
correo
electrónico
gusano
envía
correo
copia
sistemas
Capacidad
ejecución
remota
gusano
ejecuta
copia
sistema
Capacidad
conexión
remota
gusano
conecta
sistema
remoto
usuario
posteriormente
utiliza
mandatos
copiarse
sistema
copia
programa
gusano
ejecuta
sistema
remoto
funciones
sistema
continúa
dispersión
forma
gusano
red
muestra
características
virus
informático
fase
latente
fase
preparación
fase
activación
fase
ejecución
fase
propagación
real-
mente
realiza
acciones
Búsqueda
sistemas
infectar
examinando
tablas
servidores
repositorios
simi-
lares
direcciones
remotas
Establecimiento
conexión
sistema
remoto
Copia
sistema
remoto
ejecución
gusano
red
intentar
determinar
sistema
previamente
infectado
an-
tes
copiarse
sistema
sistema
multiprogramado
disfrazar
presen-
cia
renombrándose
proceso
sistema
utilizando
nombre
resulte
sospechoso
operador
sistema
caso
virus
gusanos
red
difíciles
contrarrestar
medidas
seguridad
red
seguridad
sistemas
debidamente
diseñadas
implementadas
minimizan
amenaza
gusanos
Zombie
programa
zombie
toma
control
ordenador
conectado
Internet
posterior-
mente
utiliza
lanzar
ataques
difíciles
trazar
provenientes
creador
zombie
zombies
utilizan
habitualmente
ataques
denegación
servicio
habitual-
mente
sitios
web
objetivos
zombie
implanta
centenares
ordenadores
716
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
716pertenecientes
terceras
partes
desconocen
existencia
posteriormente
utiliza
puntos
acceso
derribar
sitio
web
cuestión
lanzando
tráfico
red
intenso
NATURALEZA
VIRUS
virus
programa
única
diferencia
inserta
programa
ejecuta
secretamente
programa
anfitrión
eje-
cutar
virus
ejecución
función
esté
permitida
privilegios
usuario
cuestión
borrar
ficheros
programas
tiempo
vida
virus
típico
pasa
siguientes
etapas
Fase
latente
virus
dormido
virus
activará
finalmente
dé
evento
ejemplo
fecha
presencia
programa
ficheros
capacidad
disco
exceda
determinado
límite
virus
pasan
etapa
Fase
propagación
virus
inserta
copias
idénticas
programas
áreas
disco
programa
infectado
contendrá
copia
virus
entrará
fase
propagación
Fase
activación
virus
activa
función
concebido
caso
fase
latente
fase
activación
lanzar
amplia
gama
eventos
sistema
incluyendo
contador
número
copia
virus
copia-
do
Fase
ejecución
función
cuestión
realiza
función
variar
men-
saje
inofensivo
pantalla
dañina
destrucción
programas
ficheros
datos
mayoría
virus
llevan
cabo
trabajo
específica
sistema
operati-
vo
particular
casos
específica
plataforma
hardware
diseñados
aprovecharse
detalles
debilidades
determinados
sistemas
concreto
TIPOS
VIRUS
habido
continua
carrera
diseñadores
virus
diseñadores
software
antivirus
virus
aparecieron
medida
iban
desarrollando
medidas
tipos
virus
existentes
iban
desarrollando
virus
STEP93
sugiere
siguientes
cate-
gorías
significativas
tipos
virus
Virus
parásito
Forma
tradicional
asimismo
habitual
virus
virus
parásito
inserta
ficheros
ejecutables
replica
programa
infectado
ejecución
buscando
ficheros
ejecutables
infectar
Virus
residente
memoria
Infecta
memoria
principal
programa
siste-
ma
residente
punto
virus
infectar
programa
ejecuta
Virus
sector
arranque
Infecta
sector
arranque
maestro
master
boot
record
dispersan
sistema
arranca
disco
contiene
virus
Virus
oculto
forma
virus
diseñada
expresamente
esconderse
software
de-
tección
antivirus
Virus
polimórfico
virus
muta
infección
detección
me-
firma
virus
imposible
Seguridad
717
16-Capitulo
16
16/5/05
17:08
Página
717Un
ejemplo
virus
ocultoes
utiliza
compresión
forma
programa
infectado
exactamente
longitud
versión
infectada
técnicas
sofistica-
das
ejemplo
virus
colocar
lógica
interceptación
rutinas
disco
forma
intenta
leer
partes
sospechosas
disco
utilizando
rutinas
virus
presentará
versión
original
infectada
programa
forma
ocultación
término
apli-
virus
técnica
utilizan
evitar
detección
virus
polimórfico
crea
copias
fase
replicación
funcionalmente
equiva-
lentes
representan
patrones
bits
caso
virus
ocultos
propósi-
to
derrotar
programas
encargan
buscar
virus
caso
firma
virus
va-
riará
copia
variación
virus
insertar
forma
aleatoria
instrucciones
superfluas
intercambiar
orden
instrucciones
independientes
estra-
tegia
efectiva
cifrado
virus
generalmente
denominada
motor
muta-
ción
creará
clave
cifrado
aleatoria
cifrar
resto
virus
clave
almacena
virus
motor
mutación
alterará
invoca
programa
infectado
virus
utiliza
clave
almacenada
descifrar
virus
virus
replica
selecciona
clave
aleatoria
arma
repertorio
diseñadores
virus
denominado
virus-creation
tool-
kit
herramientas
permiten
alguien
relativamente
novato
crear
rápidamente
número
vi-
rus
virus
creados
herramientas
tienden
sofistica-
virus
diseñados
cero
cantidad
virus
generan
representa
grave
problema
esquemas
antivirus
herramienta
utilizada
diseñadores
virus
foro
virus
exchange
bulletin
board
número
foros
expulsado
ADAM92
Unidos
países
foros
ofrecen
copias
virus
descargarse
trucos
crea-
ción
virus
VIRUS
BASADOS
MACROS
años
número
virus
encontrado
determinadas
empresas
incre-
mentado
dramáticamente
incremento
proliferación
tipo
virus
basado
macros
virus
basados
macros
especialmente
peligrosos
serie
razones
virus
basado
macros
independiente
plataforma
Prácticamente
virus
basados
macros
infectan
documentos
Microsoft
Word
plataforma
hardware
sistema
operativo
soporte
Word
resultar
infectado
virus
basados
macros
infectan
documentos
fragmentos
código
ejecutables
mayoría
información
introducida
ordenador
forma
documentos
programas
virus
basados
macros
distribución
sencilla
mecanismo
relativamen-
común
correo
electrónico
virus
basados
macros
aprovechan
características
presentes
Word
aplicaciones
ofimática
ejemplo
Microsoft
Excel
denominadas
macros
esencia
macro
programa
ejecutable
embebido
documento
procesador
textos
tipo
fi-
cheros
Normalmente
usuarios
utilizan
macros
automatizar
determinadas
tareas
forma
ahorrar
pulsaciones
teclado
lenguaje
macros
habitualmente
forma
lenguaje
programación
Basic
usuario
definir
secuencia
pulsaciones
ma-
718
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
718cro
configurar
macro
invoque
pulse
tecla
función
combina-
ción
corta
teclas
permite
creación
virus
basado
macros
macros
autoejecutables
macros
invocan
automáticamente
intervención
explícita
usuario
Eventos
autoeje-
cutables
críticos
abrir
fichero
cerrar
fichero
comenzar
aplicación
macro
ejecuta
copiar
documentos
borrar
ficheros
causar
tipo
daños
sistema
Microsoft
Word
tipos
macros
autoejecución
Autoejecutable
macro
llamada
AutoExec
fichero
plantilla
nor-
mal.dot
plantilla
global
almacenada
directorio
configuración
Word
ejecutará
arranca
Word
Automacro
automacro
ejecuta
ocurre
evento
predefinido
apertura
cierre
documento
creación
documento
salir
Word
Macro
mandato
macro
fichero
global
macros
macro
incluida
den-
tro
documento
nombre
mandato
existente
Word
ejecutará
invoque
mandato
ejemplo
FileSave
técnica
habitual
difundir
virus
basados
macros
añade
auto-
macro
macro
mandato
documento
Word
introduce
sistema
co-
rreo
electrónico
transferencia
ficheros
momento
documento
abierto
macro
ejecuta
macro
copia
fichero
global
macros
abre
sesión
Word
macro
global
infectada
activa
ejecu-
ta
replicar
causar
daño
sucesivas
versiones
Word
proporcionan
protección
tipo
virus
ejemplo
Microsoft
ofrece
herramienta
opcional
llamada
Macro
Virus
Protection
detecta
ficheros
sospechosos
Word
alerta
usuario
peligro
potencial
abrir
ficheros
macros
vendedores
productos
antivirus
desarrollado
herramientas
detec-
tar
eliminar
virus
basados
macros
caso
tipos
virus
competición
conti-
núa
campo
virus
basados
macros
ESTRATEGIAS
ANTIVIRUS
solución
ideal
amenaza
virus
prevención
permitiendo
virus
sistema
lugar
objetivo
general
imposible
pre-
vención
reducir
número
ataques
virus
tengan
éxito
opción
conse-
guir
Detección
ocurrido
infección
determinar
efectivamente
habido
infección
localizar
virus
Identificación
detección
llevado
acabo
identificar
virus
específico
infectado
programa
Eliminación
identificado
virus
concreto
eliminan
restos
virus
programa
infectado
recupera
original
Eliminar
virus
sistemas
infectados
infección
expandir
detección
éxito
identificación
eliminación
al-
ternativa
consiste
deshacernos
programa
infectado
volver
cargar
versión
limpia
copia
backup
Seguridad
719
16-Capitulo
16
16/5/05
17:08
Página
719Los
avances
tecnologías
virus
antivirus
mano
mano
virus
fragmentos
código
relativamente
simples
identificarse
eliminase
paquetes
software
antivirus
relativamente
simples
medida
carrera
armamentista
vi-
rus
evolucionado
virus
necesariamente
software
antivirus
crecido
convertir-
complejo
sofisticado
actualidad
apareciendo
estrategias
paque-
tes
antivirus
sofisticados
sección
remarcar
estrategias
importantes
Descifrado
genérico
tecnología
descifrado
genérico
generic
decryption
GD
permite
programas
antivirus
detectar
fácilmente
virus
polimórficos
complejos
mante-
niendo
velocidades
exploración
altas
NACH97
Recordemos
fichero
contiene
virus
polimórfico
ejecutar
virus
descifrarse
acti-
varse
objetivo
detectar
estructura
ficheros
ejecutables
recorren
es-
cáner
GD
siguientes
elementos
Emulador
CPU
ordenador
virtual
basado
software
instrucciones
en-
cuentran
fichero
ejecutable
interpretan
emulador
lugar
eje-
cutarlas
procesador
nativo
emulador
incluye
versión
software
registros
hardware
procesador
forma
procesador
nativo
ve
afectado
programas
interpretados
emulador
Escáner
firma
virus
módulo
recorre
código
analizar
buscando
firma
virus
conocidos
Módulo
control
emulación
Controla
ejecución
código
analizar
comienzo
simulación
emulador
comienza
interpretar
instrucciones
código
analizar
forma
código
incluye
rutina
descifrado
desvela
expone
virus
código
interpreta
efecto
virus
realiza
trabajo
programa
antivirus
exponiendo
código
virus
Periódicamente
módulo
control
interrumpe
interpretación
analizar
código
busca
firmas
virus
interpretación
código
analizando
causar
daño
entor-
ordenador
personal
interpretado
entorno
completamente
controlado
consideración
diseño
difícil
escáner
GD
determinar
tiempo
ejecutar
interpretación
Habitualmente
común
elementos
virus
activan
programa
empiece
ejecutar
necesariamente
ca-
sos
tiempo
tome
escáner
emular
programa
particular
probable
encuentre
virus
estén
ocultos
Sistema
inmunidad
digital
sistema
inmunidad
digital
inteligente
estrategia
protección
virus
desarrollada
IBM
WHIT99
KEPH97a
KEPH97b
motivación
desarrollo
creciente
amenaza
propagación
virus
basados
Internet
pri-
mer
lugar
comentar
amenaza
posteriormente
resumiremos
estrategia
IBM
Tradicionalmente
amenaza
virus
caracterizaba
difusión
relativamente
lenta
virus
mutaciones
software
antivirus
actualizaba
normalmente
forma
mensual
suficiente
controlar
problema
finales
años
90
Internet
ju-
gaba
papel
relativamente
pequeño
difusión
virus
CHES97
remarca
habido
tendencias
tecnología
Internet
incrementado
impacto
propaga-
ción
virus
720
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
720•
Sistemas
correo
integrado
Sistemas
tales
Lotus
Notes
Microsoft
Outlook
sencillo
envío
cosa
destinatario
trabajar
objetos
recibidos
Sistemas
programas
móviles
Funcionalidades
Java
ActiveX
permiten
pro-
gramas
moverse
sistema
respuesta
amenaza
planteada
funcionalidades
Internet
IBM
desa-
rrollado
prototipo
sistema
inmunidad
digital
sistema
extiende
emula-
ción
programas
presentado
subsección
proporciona
emulación
propósito
general
sistema
detección
virus
objetivo
sistema
proporcionar
tiempo
respuesta
rápido
forma
virus
puedan
expulsados
rápido
introducen
virus
entra
organización
sistema
inmunidad
automáticamente
cap-
tura
analiza
añade
mecanismos
detección
defensa
elimina
pasa
información
virus
sistemas
ejecutan
IBM
Anti
Virus
forman
detectarse
permita
ejecución
lugar
Figura
16.9
muestra
pasos
típicos
operación
sistema
inmunidad
digital
programa
monitorización
PC
utiliza
amplia
gama
heurísticas
basadas
comportamiento
sistema
cambios
sospechosos
programas
firmas
familiares
inferir
virus
presente
programa
monitorización
envía
copia
programa
piensa
infectado
máquina
administración
organización
máquina
administración
cifra
muestra
envía
máquina
análisis
virus
central
máquina
crea
entorno
programa
infectado
ejecutarse
forma
se-
gura
análisis
técnicas
utilizadas
incluyen
emulación
creación
entorno
protegido
programa
sospechoso
ejecutarse
monitori-
zarse
máquina
análisis
virus
finalmente
produce
tratamiento
identificar
eli-
minar
virus
tratamiento
resultante
envía
máquina
administración
máquina
administración
reenvía
tratamiento
cliente
infectado
tratamiento
envía
máquinas
clientes
organización
suscriptores
planeta
reciben
actualizaciones
regulares
antivirus
protegen
virus
éxito
sistema
inmunidad
digital
depende
habilidad
máquina
análisis
vi-
rus
detectar
corrientes
virus
innovadoras
análisis
monitorización
constante
virus
encontrados
exterior
actualizar
continuamente
software
in-
munidad
digital
mantenerlo
defensa
cualquiera
amenaza
VIRUS
CORREO
desarrollos
software
malicioso
virus
correo
virus
co-
rreo
difundieron
rápidamente
ejemplo
Melissa
utilizaba
macros
Microsoft
Word
incluidas
fichero
adjunto
receptor
abría
fichero
adjunto
correo
macro
Word
activaba
Seguridad
721
16-Capitulo
16
16/5/05
17:08
Página
7211
virus
envía
mundo
listín
direcciones
software
correo
usuario
virus
realiza
daño
localmente
finales
1999
aparecieron
versiones
virus
correo
potentes
versiones
activaban
simplemente
abriendo
correo
contenía
virus
lugar
ne-
cesitar
abriese
fichero
adjunto
virus
utilizaban
lenguaje
Visual
Basic
soportado
software
correo
electrónico
forma
vemos
aparición
generación
malware
llega
vía
correo
elec-
trónico
utiliza
funcionalidades
software
maneja
replicarse
tra-
vés
Internet
virus
propaga
activo
abriendo
fichero
ad-
directamente
correo
direcciones
conocidas
máquina
infectada
resultado
virus
solían
requerir
meses
años
propagarse
actualidad
cuestión
horas
difícil
programas
antivirus
responder
realice
daño
Finalmente
situar
grado
importante
seguridad
software
utilidad
aplicaciones
Internet
equipos
PC
contra-
rrestar
crecimiento
amenazas
SCHN99
16.5
SISTEMAS
CONFIABLES
comentado
refiere
protección
mensaje
dato
ataques
pasivos
activos
realizados
determinado
usuario
requisito
punto
ampliamente
aplicable
protección
datos
recursos
niveles
seguridad
habitualmente
clasificado
nomenclatura
mi-
litar
información
denota
clasificada
confidencial
secreta
alto
secreto
AS
niveles
superiores
concepto
igualmente
aplicable
áreas
722
Sistemas
operativos
Aspectos
internos
principios
diseño
Definición
tratamiento
Extracción
firma
Máquina
análisis
virus
Análisis
comportamiento
virus
estructura
Máquina
administración
Usuario
individual
Máquina
cliente
infectada
virus
Máquina
cliente
Cliente
Cliente
Cliente
Red
privada
red
privada
Máquina
cliente
Máquina
administración
Máquina
cliente
Figura
16.9
Sistema
inmunidad
digital
16-Capitulo
16
16/5/05
17:08
Página
722donde
información
organizar
categorías
usuarios
otorgar
credenciales
acceso
categorías
datos
ejemplo
nivel
alto
seguridad
documentos
datos
planificación
estratégica
organización
accesibles
únicamente
directivos
personal
directo
continuación
venir
datos
financieros
sensibles
personal
accesibles
personal
administrati-
vo
directivos
etc.
definen
múltiples
niveles
categorías
datos
requisitos
denomina
segu-
ridad
multinivel
directriz
general
requisitos
seguridad
multinivel
sujeto
nivel
alto
compartir
información
sujeto
nivel
inferior
comparable
me-
flujo
información
refleje
voluntad
usuario
autorizado
propósitos
imple-
mentación
requisito
articula
partes
sistema
seguro
multinivel
proporcionar
leer
read
up
sujeto
leer
objeto
nivel
seguri-
dad
inferior
denominan
literatura
propiedad
seguridad
simple
escribir
abajo
write
down
sujeto
escribir
objeto
nivel
seguridad
superior
Denominado
habitualmente
literatura
propie-
dad-
1(pronunciado
propiedad
estrella
star-property
reglas
articulan
forma
apropiada
proporcionan
seguridad
multinivel
sistema
procesamiento
datos
estrategia
tomado
objeto
múlti-
ples
investigaciones
desarrollos
basa
concepto
monitor
referencias
Dicha
estrategia
representada
figura
16.10
monitor
referencias
elemento
control
hardware
sistema
operativo
ordenador
regula
acceso
sujetos
objetos
base
parámetros
seguridad
dichos
participantes
monitor
referencia
acceso
fichero
conocido
base
datos
núcleo
seguridad
muestra
lista
privi-
legios
acceso
habilitación
sujeto
atributos
protección
nivel
clasificación
objeto
monitor
referencia
aplica
reglas
seguridad
leer
escribir
abajo
siguientes
propiedades
Mediación
completa
reglas
seguridad
aplican
acceso
ejemplo
apertura
fichero
Aislamiento
monitor
referencia
base
datos
protegidos
modifi-
cación
autorizada
Verificabilidad
corrección
monitor
referencia
probada
demostrar
matemáticamente
monitor
referencia
aplica
reglas
seguridad
proporciona
mediación
completa
aislamiento
requisitos
requeridos
requisito
mediación
completa
im-
plica
acceso
datos
memoria
principal
disco
cinta
pasar
mediador
implementaciones
software
puras
imponen
penalizaciones
rendimiento
altas
prácticas
solución
parcialmente
proporcionada
Seguridad
723
significa
especial
pensar
nombre
apropiado
propiedad
escritura
informe
modelo
asterisco
carácter
comodín
introducido
borrador
forma
editor
texto
pu
eda
encontrarlo
rápidamente
reemplazar
instancias
nombre
dicha
propiedad
propor
cionó
nombre
momento
forma
informe
publicó
intacto
16-Capitulo
16
16/5/05
17:08
Página
723hardware
requisito
aislamiento
implica
atacante
independien-
temente
listo
cambiar
lógica
monitor
referencia
contenidos
base
datos
núcleo
seguridad
Finalmente
requisitos
prueba
matemática
ex-
cesivos
complejo
ordenador
propósito
general
sistema
pro-
porcionar
dicha
verificación
denomina
sistema
confiable
elemento
mostrado
figura
16
10
fichero
auditoría
fichero
auditoría
almacena
eventos
seguridad
importantes
ejemplo
detección
violaciones
seguridad
cambios
autorizados
base
datos
núcleo
seguridad
esfuerzo
satisfacer
necesidades
servicio
público
Departa-
mento
Defensa
Unidos
1981
estableció
Centro
Seguridad
Ordena-
dores
Agencia
Seguridad
Nacional
National
Security
Agency
NSA
obje-
tivo
incentivar
difusión
general
sistemas
computación
confiables
objetivo
aplica
centro
Programa
Evaluación
Productos
Comerciales
esencia
centro
intenta
evaluar
productos
disponibles
forma
comercial
cumplen
requisitos
seguridad
escritos
centro
clasifica
productos
evaluados
gama
fun-
cionalidades
seguridad
proporcionan
evaluaciones
solicitan
reso-
luciones
Departamento
Defensa
encuentran
publicadas
libre
disposición
servir
vía
clientes
deseen
comprar
productos
comerciales
equipamientos
724
Sistemas
operativos
Aspectos
internos
principios
diseño
Fichero
auditoría
Sujetos
Objetos
Base
datos
núcleo
seguridad
Sujetos
habilitación
Objetos
nivel
clasificación
Monitor
referencia
política
Figura
16.10
Concepto
monitor
referencia
16-Capitulo
16
16/5/05
17:08
Página
724DEFENSA
TROY
ANOS
vía
defenderse
ataques
realizados
troyanos
sistemas
opera-
tivos
seguros
confiables
Figura
16.11
muestra
ejemplo
BOEB85
caso
utiliza
troyano
evitar
mecanismo
seguridad
estándar
utilizado
mayoría
sistemas
gestión
ficheros
sistemas
operativos
listas
control
acceso
ejemplo
usuario
llamado
Pepe
interacciona
programa
fichero
datos
contiene
cade-
na
caracteres
críticamente
sensible
CPE170KS
usuario
Pepe
creado
fichero
permi-
sos
lectura
escritura
delegados
programas
ejecutan
úni-
cos
procesos
acceder
fichero
cuyo
propietario
Pepe
ataque
troyano
comienza
usuario
hostil
denominado
Alicia
con-
acceso
legítimo
sistema
instala
programa
troyano
fichero
privado
utilizará
ataque
bolsillo
trasero
back
pocket
Alicia
concede
permisos
lectura
escritu-
ra
fichero
concede
Pepe
permisos
escritura
Figura
16.11a
Alicia
induce
Pepe
invoque
programa
troyano
anunciándolo
herra-
mienta
útil
programa
detecta
Pepe
ejecuta
accede
cadena
caracte-
res
protegida
fichero
usuario
copia
fichero
Alicia
denomina-
do
bolsillo
trasero
Figura
16.11b
Ambas
operaciones
lectura
escritura
satisfacen
restricciones
impuestas
listas
control
acceso
momento
Alicia
tie-
ne
acceder
fichero
creado
acceder
valor
cadena
consideremos
utilización
sistema
operativo
seguro
escenario
Figura
16.11c
niveles
seguridad
asignan
sujetos
momento
acceso
sistema
criterios
tales
terminal
conectado
usuario
usuario
ac-
cede
virtud
contraseña
identificador
ejemplo
niveles
seguri-
dad
información
sensible
gris
pública
blanco
información
sensible
nivel
seguridad
pública
procesos
propiedad
Pepe
fichero
datos
consideran
nivel
seguridad
sensible
fichero
procesos
Alicia
encuadran
nivel
seguridad
público
Pepe
ejecuta
programa
troyano
Figura
16.11d
programa
adquiere
nivel
seguridad
forma
capaz
propiedad
seguridad
simple
acceder
ca-
dena
caracteres
sensible
programa
intenta
almacenar
cadena
fichero
público
fichero
actúa
bolsillo
trasero
caso
propiedad-
resulta
violada
intento
queda
abortado
monitor
referencia
forma
intento
escribir
fichero
caso
fichero
bolsillo
trasero
resulta
abortado
listas
control
acceso
permitan
política
seguridad
precede
mecanismos
listas
control
acceso
16.6
SEGURIDAD
WINDOWS
ejemplo
conceptos
control
acceso
revisando
funcionalidades
control
acceso
Windows
aprovechan
conceptos
orientación
objetos
proporcionar
servicios
control
flexibles
potentes
Windows
proporciona
servicios
control
acceso
uniformes
aplican
procesos
threads
ficheros
semáforos
ventanas
objetos
control
acceso
regulado
entidades
testigo
acceso
asociado
proceso
descriptor
seguridad
asociado
objeto
realizan
accesos
procesos
ESQUEMA
CONTROL
ACCESO
usuario
conecta
sistema
Windows
sistema
operativo
utiliza
esquema
nom-
bre
contraseña
autenticar
usuario
acceso
éxito
crea
proceso
Seguridad
725
16-Capitulo
16
16/5/05
17:08
Página
725726
Sistemas
operativos
Aspectos
internos
principios
diseño
Alicia
RW
Pepe
Fichero
datos
CPE170KS
Pepe
RW
Alicia
RW
Pepe
CPE170KS
Pepe
RW
Alicia
RW
Pepe
CPE170KS
Pepe
RW
Alicia
RW
Pepe
Fichero
bolsillo
trasero
Pepe
Alicia
Monitor
referencia
Programa
CPE170KS
Pepe
RW
Programa
Fichero
bolsillo
trasero
Programa
Programa
Monitor
referenciaPepe
Alicia
Fichero
datosFichero
datos
Fichero
bolsillo
trasero
Programa
Programa
Programa
Programa
Fichero
datos
Fichero
bolsillo
trasero
Pepe
Alicia
Pepe
Alicia
Figura
16.11
Troyanos
sistemas
operativos
seguros
16-Capitulo
16
16/5/05
17:08
Página
726usuario
asocia
testigo
acceso
testigo
acceso
cuyos
detalles
describi-
remos
incluye
identificador
seguridad
SID
identificador
usuario
conocido
efectos
seguridad
sistema
lanza
proceso
proceso
inicial
usuario
objeto
proceso
hereda
testi-
go
acceso
testigo
acceso
sirve
Mantener
información
seguridad
necesaria
agrupada
acelerar
validación
acceso
proceso
relacionado
usuario
intenta
acceder
subsistema
seguridad
utilizar
testigo
asociado
proceso
determinar
privilegios
acceso
usuario
Permitir
proceso
modificar
características
seguridad
forma
limitada
afec-
tar
procesos
ejecuten
usuario
significado
clave
punto
relacionado
privilegios
asociar
usuario
testigo
acceso
indica
privilegios
usuario
Generalmente
testigo
inicializa
privilegios
deshabitados
posteriori
procesos
usuario
necesita
operación
privilegios
proceso
habilitar
privilegio
apropiado
intentar
acceso
deseable
mantener
información
seguridad
usuario
lu-
gar
común
sistema
desea
habilitar
privilegios
proceso
haría
habilitasen
procesos
usuario
Relacionado
objeto
procesos
accedan
des-
criptor
seguridad
componente
clave
descriptor
seguridad
lista
control
acce-
so
especifica
derechos
acceso
usuarios
grupos
usuarios
objeto
proceso
intenta
acceder
objeto
SID
proceso
compara
lista
con-
trol
acceso
objeto
determinar
permite
acceso
aplicación
abre
referencia
objeto
afectado
control
seguridad
Windows
verifica
descriptor
seguridad
objeto
otorga
acceso
aplicación
usuario
verificación
éxito
Windows
almacena
derechos
acceso
otorgado
Seguridad
727
Cabecera
ACLID
seguridad
SID
SIDs
grupos
Privilegios
Propietario
omisión
ACL
omisión
Cabecera
ACE
Flags
Propietario
Lista
control
acceso
sistema
Lista
control
acceso
discrecional
Máscara
acceso
SID
SID
Lista
control
acceso(b
Descriptor
seguridad(a
Testigo
acceso
Cabecera
ACE
Máscara
acceso
Figura
16.12
Estructuras
seguridad
Windows
16-Capitulo
16
16/5/05
17:08
Página
727Un
aspecto
importante
seguridad
Windows
concepto
personificación
simplifi-
ca
seguridad
entorno
cliente
servidor
cliente
servidor
dialogan
conexión
RPC
servidor
asumir
temporalmente
identidad
cliente
forma
evaluar
solicitudes
acceso
relativas
permisos
cliente
acceso
servidor
vuelve
asumir
identidad
TESTIGO
ACCESO
Figura
16.12a
muestra
estructura
general
testigo
acceso
incluye
siguientes
parámetros
Identificador
seguridad
SID
Identifica
usuario
forma
única
má-
quinas
red
habitualmente
corresponde
nombre
usuario
sistema
SIDs
grupos
lista
grupos
pertenece
usuario
grupo
conjunto
identificadores
usuario
denotan
grupo
efectos
control
acceso
grupo
SID
grupo
único
acceso
objeto
definir
base
SID
grupos
SID
individuales
combinación
Privilegios
lista
servicios
sistema
sujetos
seguridad
usuario
acceder
ejemplo
creación
testigo
ejemplo
privilegio
backup
usuarios
privilegio
utilizar
herramienta
backup
copias
seguridad
ficheros
normalmente
leer
mayoría
usuarios
privilegios
adicionales
Propietario
omisión
proceso
crea
objeto
campo
especifica
propietario
objeto
Generalmente
propietario
proceso
propietario
proceso
lanzado
usuario
especificar
propietario
omisión
proceso
lance
particular
SID
grupo
pertenece
ACL
omisión
lista
inicial
protecciones
aplica
objetos
usua-
rio
crea
usuario
posteriormente
alterar
lista
control
acceso
ob-
jeto
pertenece
grupos
DESCRIPTORES
SEGURIDAD
Figura
16.12b
muestra
estructura
general
descriptor
seguridad
incluye
siguien-
tes
parámetros
Flags
Define
tipo
contenidos
descriptor
seguridad
flags
indican
presentes
SACL
DACL
asignan
objeto
mecanismo
efecto
punteros
descriptor
utilizan
direccionamiento
absoluto
relativo
descriptores
relativos
necesarios
objetos
transmiten
red
ejemplo
información
transmitida
RPC
Propietario
propietario
objeto
habitualmente
acción
descriptor
seguridad
propietario
SID
individual
grupo
propie-
tario
autorizado
cambiar
contenidos
DACL
Lista
control
acceso
sistema
System
access
control
list
SACL
Indica
tipo
operaciones
objeto
generan
mensajes
auditoría
aplicación
pri-
728
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
728vilegios
correspondientes
testigo
acceso
leer
escribir
SACL
ob-
jeto
evitar
aplicaciones
autorizadas
lean
SACL
conociendo
evitar
generen
mensajes
auditoría
escribirlas
generar
trazas
auditoría
harán
operación
ilícita
pase
desapercibida
Lista
control
acceso
discrecional
Discretionary
access
control
list
DACL
Indican
usuarios
grupos
acceder
objeto
operaciones
Consiste
lista
entradas
control
acceso
ACE
crea
objeto
proceso
crea
asignar
propietario
SID
SID
grupo
encuentre
testigo
acceso
proceso
crea
asignar
propietario
identificador
encuentre
testigo
acceso
Posterior-
mente
proceso
concedido
derecho
cambiar
propietario
obje-
to
aplicando
restricción
motivo
restricción
evi-
tar
usuario
encubrir
rastro
intentar
acción
autorizada
Veamos
detalle
estructura
listas
control
acceso
en-
cuentran
corazón
servicio
control
acceso
Windows
Figura
16.12c
lista
con-
siste
cabecera
general
número
variable
entradas
control
acceso
entrada
especifica
SID
individual
grupo
máscara
acceso
define
derechos
otorgados
SID
proceso
intenta
acceder
objeto
manejador
objetos
ejecutivo
Windows
lee
SID
SID
grupos
testigo
acceso
recorre
DACL
ob-
jeto
equivalencia
ACE
SID
coincide
SID
consulta
proceso
otorgan
derechos
acceso
indicados
mascara
acceso
ACE
Figura
16.13
muestra
contenidos
mascara
acceso
16
bits
significati-
vos
especifican
derechos
acceso
aplican
tipo
objeto
particular
ejemplo
bit
objeto
fichero
acceso
Lectura
Datos
Fichero
File_Read_Data
bit
objeto
evento
acceso
Consulta
Evento
Event_Query_Status
16
bits
significativos
mascara
contienen
bits
aplican
tipos
ob-
jetos
denominan
tipos
acceso
estándar
Sincronizado
Otorgar
permisos
ejecución
sincronizada
evento
asociado
objeto
particular
objeto
utilizar
función
espera
Escritura
propietario
Permite
programa
modificar
propietario
objeto
útil
propietario
objeto
cambiarle
protección
propieta-
rio
negar
acceso
escritura
DAC
Escritura
DAC
Permite
aplicación
modificar
DACL
protección
objeto
Lectura
control
Permite
aplicación
consultar
campos
propietario
DACL
descriptor
seguridad
objeto
Borrado
Permite
aplicación
borrar
objeto
mitad
orden
superior
máscara
acceso
contiene
tipos
accesos
ge-
néricos
bits
proporcionan
forma
apropiada
fijar
tipos
accesos
específicos
número
clases
objetos
ejemplo
supongamos
aplicación
desea
crear
distintos
tipos
objetos
asegurarse
usuarios
acceso
lectura
dichos
objetos
in-
cluso
lectura
significado
tipos
objetos
proteger
objetos
tipos
bits
accesos
genéricos
aplicación
debería
cons-
Seguridad
729
16-Capitulo
16
16/5/05
17:08
Página
729truir
ACE
tipo
objeto
debería
cuidado
pasar
ACE
correcta
crea
conveniente
crear
ACE
única
exprese
concepto
genérico
permitir
lectura
simplemente
aplicando
ACE
objetos
crean
resolvería
problema
propósito
bits
accesos
genéricos
Global
genérico
permitir
accesos
Ejecución
genérica
permite
ejecución
ejecutable
Escritura
genérica
permitir
acceso
escritura
Lectura
genérica
permite
acceso
lectura
bits
genéricos
afectan
tipos
acceso
estándar
ejemplo
objeto
fi-
chero
bit
lectura
genérica
traduce
bits
estándar
Control
Lectura
Sincronizado
bits
específicos
objeto
Lectura
Datos
Fichero
File_Read_Data
Lectura
Atribu-
tos
Fichero
File_Read_Attributes
Lectura
EA
Fichero
File_Read_EA
Insertando
ACE
objeto
fichero
otorgue
SID
permiso
lectura
genérica
proporcionan
es-
tos
derechos
acceso
forma
hubiesen
especificados
forma
indivi-
dual
máscara
acceso
bits
restantes
máscara
acceso
significado
especial
bit
Acceso
Seguridad
Sistema
permite
modificar
controles
auditoría
alarmas
objeto
suficiente
bit
SID
determinado
falta
testigo
acceso
proceso
SID
incluya
privilegio
correspondiente
Finalmente
bit
Máximo
Permitido
verdaderamente
bit
acceso
modificador
algoritmo
búsqueda
utiliza
Windows
localización
SID
DACL
Habitualmente
Windows
recorrerá
DACL
encuentre
ACE
espe-
cíficamente
otorgue
bit
revoque
bit
solicitud
acceso
proceso
demanda
encuentre
DACL
cuyo
caso
acceso
deniega
bit
Máximo
Permitido
permite
propietario
objeto
definir
conjunto
730
Sistemas
operativos
Aspectos
internos
principios
diseño
Borrado
Lectura
control
Escritura
DAC
Escritura
propietario
SincronizadoTipos
accesos
genéricos
Tipos
accesos
estándar
Acceso
seguridad
sistema
Máximo
permitido
Global
genérico
Ejecución
genérica
Escritura
genérica
Lectura
genérica
Tipos
accesos
específicos
Figura
16.13
Máscara
acceso
16-Capitulo
16
16/5/05
17:08
Página
730derechos
acceso
máximo
permitir
determinado
usuario
mente
supongamos
aplicación
operaciones
solicitar
realicen
objeto
determinada
sesión
opciones
solici-
tar
acceso
Intentar
abrir
objeto
accesos
posibles
desventaja
estrategia
acceso
negar
aplicación
derechos
acce-
so
verdaderamente
necesarios
sesión
abrir
objeto
acceso
específico
solicitar
abrir
manejador
objeto
tipos
solicitudes
método
habi-
tualmente
preferido
causará
denegación
accesos
necesarios
tampo-
co
proporcionará
accesos
requieren
proporciona
sobre-
carga
adicional
Intentar
abrir
objeto
número
posibles
accesos
objeto
permita
SID
ventaja
usuario
denegar
forma
artificial
acceso
darse
aplicación
nivel
acceso
necesita
situación
ocultar
fallos
errores
aplicación
característica
importante
seguridad
Windows
aplicaciones
utilizar
marco
seguridad
proporciona
sistema
operativo
objetos
definidos
usuario
ejemplo
servidor
bases
datos
crear
descriptores
seguridad
aso-
ciarlos
partes
base
datos
Adicionalmente
restricciones
acceso
lectu-
ra
escritura
servidor
asegurar
operaciones
específicas
base
datos
tales
avanzar
conjunto
resultados
operación
join
responsabilidad
servidor
de-
finir
significado
derechos
especiales
revisar
verificaciones
acceso
veri-
ficaciones
realizarían
contexto
estándar
utilizando
cuentas
usuarios
grupos
fiche-
ros
auditoría
válidos
sistema
modelo
seguridad
extensible
resultar
útil
implementar
sistemas
ficheros
externos
16.7
RESUMEN
requisitos
seguridad
encuentran
garantizados
examinando
amenazas
seguridad
enfrenta
organización
interrupción
servicio
amenaza
disponibilidad
intercepción
información
amenaza
privacidad
finalmente
modificación
información
íntima
fabricación
información
forma
autori-
zada
amenazas
integridad
área
clave
seguridad
informática
protección
memoria
esencial
sis-
tema
múltiples
procesos
encuentran
activos
instante
esquemas
me-
moria
virtual
capacitados
típicamente
mecanismos
apropiados
tarea
técnica
seguridad
importante
control
acceso
control
acceso
asegurar
usuarios
autorizados
acceso
sistema
particular
recursos
individua-
acceso
modificación
partes
datos
limitado
individuos
progra-
estén
autorizados
Hablando
forma
estricta
control
acceso
cuestión
segu-
ridad
informática
seguridad
red
mayoría
casos
mecanismo
control
acceso
implementa
único
ordenador
controlar
acceso
equi-
po
accesos
ordenador
realizan
redes
servicios
comunicaciones
mecanismos
control
acceso
diseñarse
operar
forma
efectiva
entorno
distribuido
red
Seguridad
731
16-Capitulo
16
16/5/05
17:08
Página
731Una
amenaza
creciente
causada
virus
mecanismos
software
similares
ame-
nazas
aprovechan
vulnerabilidades
software
sistema
ganar
acceso
forma
autorizada
información
degradar
servicio
sistema
tecnología
permitiendo
aumentar
seguridad
sistemas
aplicaciones
en-
tornos
comerciales
militares
sistemas
confiables
sistema
confiable
proporciona
me-
canismos
regular
acceso
datos
basándose
autorizado
acceder
cosa
punto
clave
sistema
diseñado
implementado
forma
usuarios
seguridad
completa
sistema
forzar
siga
política
seguridad
determinada
16.8
LECTURAS
RECOMENDADAS
SITIOS
WEB
contenidos
capítulo
encuentran
tratados
detalle
STAL03
cubrir
algoritmos
criptográficos
SCHN96
trabajo
referencia
esencial
contiene
des-
cripción
numerosos
algoritmos
protocolos
criptográficos
encontrar
revisión
aspectos
relativos
sistemas
operativos
PIEP03
GOLL99
PFLE97
KENT00
MCHU99
artículos
recapitulatorios
detección
intrusos
visión
profunda
sobe
virus
HARL01
libro
leer
CASS01
FORR97
KEPH97
NACH97
artículos
revisión
virus
gusanos
COX00
CLER04
proporcionan
visión
detallada
seguridad
Windows
dirigi-
administración
gestión
muestran
diversos
aspectos
internos
Windows
concernientes
seguridad
CASS01
Cass
S.
Anatomy
of
Malice
IEEE
Spectrum
Noviembre
2001
CLER04
Clercq
J.
Windows
Server
2003
Security
Infrastructure
Core
Security
Features
Burlington
MA
Digital
Press
2004
COX00
Cox
and
Sheldon
Windows
NT
Security
Handbook
New
York
Osborne
McGraw-Hill
2000
FORR97
Forrest
S.
Hofmeyr
S.
and
Somayaji
A.
Computer
Immunology
Communications
of
the
ACM
Octubre
1997
GOLL99
Gollmann
D.
Computer
Security
New
York
Wiley
1999
HARL01
Harley
D.
Slade
R.
and
Gattiker
U.
Viruses
Revealed
New
York
Osborne
McGraw-Hill
2001
KENT00
Kent
S.
On
the
Trail
of
Intrusions
into
Information
Systems
IEEE
Spectrum
Diciembre
2000
KEPH97
Kephart
J.
Sorkin
G.
Chess
D.
and
White
S.
Fighting
Computer
Viruses
Scientific
Ameri-
can
Noviembre
1997
MCHU00
McHugh
J.
Christie
A.
and
Allen
J.
The
Role
of
Intrusion
Detection
Systems
IEEE
Soft-
ware
Septiembre
Octubre
2000
NACH97
Nachenberg
C.«Computer
Virus-Antivirus
Coevolution
Communications
of
the
ACM
Enero
1997
PEIP03
Pieprzyk
J.
Hardjono
and
Seberry
J.
Fundamentals
of
Computer
Security
New
York
Sprin-
ger
2003
PFLE97
Pfleeger
C.
Security
in
Computing
Upper
Saddle
River
NJ
Prentice
Hall
PTR,1997
SCHN96
Schneier
B.
Applied
Cryptography
New
York
Wiley
1996
STAL03
Stallings
W.
Cryptography
and
Network
Security
Principles
and
Practice
3rd
edition
Upper
Saddle
River
NJ
Prentice
Hall
2003
732
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
732PÁGINAS
WEB
RECOMENDADAS
Computer
Security
Resource
Center
Mantenido
Instituto
Nacional
Estándares
Tecnología
NIST
Contiene
amplia
gama
información
amenazas
seguridad
tecnología
estándares
CERT
Coordination
Center
organización
creció
amparo
equipo
res-
puesta
emergencia
informática
creado
Agencia
Proyectos
Investigación
Avan-
zada
Defensa
DARPA
Contiene
información
relativa
amenazas
Segu-
ridad
vía
Internet
vulnerabilidades
estadísticas
ataque
Intrusión
Detection
Working
Group
Incluye
documentos
generados
grupo
AntiVirus
On-line
Página
web
IBM
información
virus
mejores
Vmyth
Dedicado
mostrar
falsos
virus
esclarecer
errores
concepto
virus
reales
16.9
TÉRMINOS
CLAVE
CUESTIONES
REPASO
PROBLEMAS
TÉRMINOS
CLAVE
amenaza
activa
control
acceso
RSA
amenaza
pasiva
detección
intrusos
respuesta
Autenticidad
denegación
servicio
sistema
confiable
bomba
lógica
disponibilidad
software
malicioso
malware
cifrado
estándar
cifrado
avanzado
AES
triple
DES
3DES
cifrado
convencional
estándar
cifrado
datos
DES
troyano
cifrado
clave
pública
gusano
virus
cifrado
simétrico
integridad
virus
basados
macros
confidencialidad
intruso
virus
correo
contraseña
puerta
secreta
zombie
CUESTIONES
REPASO
16.1
principales
requisitos
tratados
seguridad
informática
16.2
diferencia
amenazas
seguridad
activas
pasivas
16.3
Proporcione
lista
descripción
categorías
amenazas
seguridad
activas
pasivas
16.4
elementos
necesitan
técnica
control
acceso
habitual
16.5
control
acceso
diferencia
sujeto
objeto
16.6
Explique
propósito
aderezo
Figura
16.6
16.7
Explique
diferencias
detección
intrusos
estadística
ano-
malías
basada
reglas
Seguridad
733
16-Capitulo
16
16/5/05
17:08
Página
73316.8
desarrollo
contenidos
adjuntos
malware
VBS
correo
1999
2000
ejem-
plo
Melisa
love
letter
denominan
prensa
virus
correo
apropiado
término
gusanos
correo
16.9
papel
cifrado
desarrollo
virus
16.10
estrategias
típicas
atacar
esquema
cifrado
típico
16.11
DES
triple
DES
16.12
espera
AES
mejore
triple
DES
16.13
criterio
evaluación
asignar
candidatos
AES
16.14
Explique
diferencias
cifrado
convencional
clave
pública
16.15
distinción
términos
clave
pública
clave
privada
clave
secreta
PROBLEMAS
16.1
Asuma
contraseñas
seleccionan
combinaciones
caracteres
26
caracteres
alfabeto
Suponga
adversario
capaz
intentar
contraseñas
tasa
Suponiendo
respuesta
adversario
rea-
lizado
intento
tiempo
espera
tardará
descubrir
contraseña
correcta
Suponiendo
respuesta
indicador
marque
caracteres
erróneos
contraseña
tiempo
espera
tardará
descubrir
contraseña
correcta
16.2
Asuma
elemento
origen
longitud
proyecta
forma
uniforme
elemento
destino
longitud
p.
dígitos
tomar
valo-
res
posibles
número
elementos
fuente
número
elementos
destino
número
menor
i.
elemento
origen
particular
proyecta
ele-
mento
destino
particular
y.
probabilidad
adversario
seleccionar
elemento
original
correcto
intento
probabilidad
elementos
originales
xl
xi
xl
proyecta
elemento
destino
producirse
ad-
versario
probabilidad
adversario
seleccionar
elemento
destino
correcto
intento
16.3
generador
contraseñas
fonético
toma
segmentos
forma
aleatoria
contraseña
letras
formato
segmentos
CVC
consonante
vocal
consonante
V=<a
V.
población
completa
contraseñas
probabilidad
adversario
adivine
contraseña
correcta
16.4
Suponga
contraseñas
limitadas
95
caracteres
imprimibles
códi-
go
ASCII
contraseñas
longitud
10
caracteres
Suponiendo
password
cracker
tasa
cifrado
6.4
millones
cifrados
734
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
734¿Cuánto
tiempo
llevaría
examinar
forma
exhaustiva
posibles
contraseñas
sistema
16.5
riesgo
conocido
sistema
contraseñas
UNIX
documentación
Sun-
OS-4.0
recomienda
elimine
fichero
contraseñas
sustituya
fichero
lectura
público
denominado
/etc
publickey
entrada
fichero
usua-
rio
consistirá
identificador
ID
clave
pública
usuario
KUA
clave
priva-
correspondiente
KR
A.
clave
privada
cifrada
usando
DES
clave
deri-
vada
contraseña
usuario
A.
entra
sistema
descifra
PA[KRA
obtener
KR
A.
Utilizamos
notación
x[a
indicar
cifrado
descifrado
clave
x.
sistema
verifica
posteriormente
clave
proporcionado
correc-
ta
oponente
atacar
sistema
16.6
sistema
cifrado
contraseñas
UNIX
unidireccional
reversible
correcto
verdaderamente
función
hash
mecanismo
cifrado
16.7
inclusión
valor
aderezo
esquema
contraseñas
UNIX
incrementaba
dificultad
adivinar
contraseñas
factor
4096
va-
lor
aderezo
almacenado
entrada
correspondien-
contraseña
cifrada
caracteres
conocidos
atacante
necesario
adivinarlos
asegura
incluir
valor
aderezo
incre-
menta
seguridad
16.8
Suponiendo
respondido
correctamente
problema
comprendido
importancia
valor
aderezo
cuestión
des-
mantelar
intentos
ataque
password
crackers
incrementando
os-
tensiblemente
tamaño
valor
aderezo
pongamos
24
48
bits
16.9
plantea
cuestión
desarrollar
programa
capaz
analizar
fragmento
software
determinar
virus
Considere
ejemplo
tene-
mos
programa
supone
capaz
progra-
ma
ejecutamos
D(P
resultado
TRUE
virus
FALSE
virus
Consideremos
programa
Programa
CV
programa-principal:=
if(D(CV
then
goto
else
infectar-ejecutable
programa
infectar-ejecutable
módulo
analiza
memoria
busca
programas
ejecutables
replica
dichos
programas
Determine
decidir
correctamente
CV
virus
16.10
necesidad
regla
leer
read
up
sistema
seguri-
dad
multinivel
obvia
importancia
regla
escribir
abajo
write
down
Seguridad
735
16-Capitulo
16
16/5/05
17:08
Página
73516.11
Figura
16.11
enlace
cadena
copia-y-observación
troyano
roto
posibilidades
ángulos
ataque
Alicia
Alicia
entrando
sistema
intentando
leer
cadena
directamente
Alicia
asignando
nivel
segu-
ridad
sensible
fichero
actúa
bolsillo
trasero
monitor
referencia
evita
ataques
16.12
Suponga
alguien
sugiere
mecanismo
confirmar
poseen
clave
secreta
genera
cadena
bits
longitud
clave
realiza
operación
XOR
clave
manda
resultado
red
reali-
za
operación
XOR
bloque
recibido
clave
supone
devuelve
verifica
ve
coincide
cadena
original
generado
forma
aleatoria
forma
verifica
extremo
clave
secreta
necesidad
transmitido
clave
fallo
mecanismo
APÉNDICE
16A
CRIPTOGRAFÍA
tecnología
esencial
subyace
virtualmente
aplicaciones
automatización
redes
seguridad
computadores
criptografía
utilizan
enfoques
fundamentales
criptogra-
fía
simétrica
conocida
criptografía
convencional
criptografía
clave-pública
tam-
bién
conocida
criptografía
asimétrica
apéndice
proporciona
visión
general
ti-
pos
criptografía
exposición
algoritmos
criptográficos
importantes
CRIPTOGRAFÍA
SIMÉTRICA
criptografía
simétrica
único
tipo
criptografía
introducción
cripto-
grafía
clave-pública
finales
años
70
criptografía
simétrica
usado
comunica-
ciones
secretas
incontables
individuos
grupos
Julio
Cesar
fuerza
naval
alemana
diplomáticos
militares
comerciantes
actualidad
continúa
usada
tipos
criptografía
esquema
criptografía
simétrica
ingredientes
Figura
16.14
Texto
mensaje
datos
originales
alimentan
entrada
algoritmo
Algoritmo
cifrado
algoritmo
cifrado
realiza
sustituciones
transformaciones
texto
Clave
secreta
clave
secreta
entrada
algoritmo
cifrado
susti-
tuciones
transformaciones
concretas
algoritmo
realice
dependen
clave
Texto
cifrado
mensaje
codificado
producido
salida
Depende
texto
clave
secreta
mensaje
dato
claves
producirán
textos
cifrados
Algoritmo
descifrado
esencialmente
algoritmo
cifrado
ejecutado
revés
Toma
texto
cifrado
clave
secreta
produce
texto
original
requisitos
seguro
criptografía
simétrica
Necesitamos
algoritmo
criptográfico
sólido
mínimo
algoritmo
oponente
conozca
algoritmo
acceso
mensajes
cifrados
inca-
736
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
736paz
descifrar
dichos
mensajes
deducir
clave
Normalmente
requisito
enuncia
rotunda
oponente
incapaz
descifrar
texto
cifrado
descubrir
clave
posesión
textos
cifrados
texto
produjo
dichos
textos
cifrados
Emisor
receptor
obtenido
copias
clave
secreta
segura
guardar
clave
seguridad
alguien
descubrir
clave
conoce
algoritmo
comunicación
use
clave
legible
aproximaciones
genéricas
atacar
esquema
criptografía
simétrica
ataque
conoce
criptoanálisis
ataques
criptoanalíticos
basan
naturaleza
al-
goritmo
conocimiento
características
generales
texto
in-
cluso
ejemplos
parejas
texto
claro-texto
cifrado
tipo
ataque
explota
ca-
racterísticas
algoritmo
intentar
deducir
texto
específico
deducir
clave
usando
ataque
éxito
deducir
clave
efecto
catastrófico
mensajes
futuros
pasados
cifrados
dicha
clave
comprometidos
método
conocido
ataque
fuerza-bruta
probar
clave
trozo
texto
cifrado
consiga
transformar
texto
inteligible
media
probarse
mitad
posibles
claves
éxito
Tabla
16.4
muestra
tiempo
necesita
claves
tamaños
tabla
muestra
resultados
tamaño
clave
asumiendo
simple
descifrado
tarda
realizarse
1ms
orden
magnitud
razonable
computadores
masivo
microprocesadores
organizados
paralelo
alcanzar
tasas
procesamiento
órdenes
magnitud
mayores
columna
tabla
resultados
sistema
procesar
millón
claves
microsegundo
verse
nivel
prestaciones
clave
56
bits
considerarse
computacionalmente
segura
algoritmos
cifrado
simétricos
usados
comúnmente
cifradores
bloque
cifrador
bloque
procesa
texto
introducido
bloques
tamaño
fijo
produce
blo-
texto
cifrado
tamaño
bloque
texto
algoritmos
simétricos
importantes
cifradores
bloque
Data
Encryption
Standard
DES
Advanced
Encryption
Standard
AES
Data
Encryption
Standard
DES
DES
algoritmo
criptográfico
dominante
introducción
1977
DES
utiliza
claves
56
bits
cues-
tión
tiempo
velocidad
proceso
computadores
dejen
obsoleto
1988
Elec-
Seguridad
737
Texto
entrada
Texto
cifrado
transmitido
Texto
salida
Clave
secreta
compartida
remitente
destinatario
Algoritmo
cifrado
ejemplo
DES
Algoritmo
descifrado
contrario
algoritmo
cifrado
Clave
secreta
compartida
remitente
destinatario
Figura
16.14
Modelo
simplificado
criptografía
simétrica
16-Capitulo
16
16/5/05
17:08
Página
737tronic
Frontier
Foundation
EFF
anunció
habría
roto
DES
usando
máquina
rompe
DES
propósito
específico
construida
250.000
dólares
ataque
llevó
EFF
publicado
descripción
detallada
máquina
permitiendo
construir
EFF98
hardware
continúa
abaratándose
incrementando
velocidad
DES
inútil
vida
DES
alargó
triple
DES
3DES
conlleva
repetir
algorit-
mo
DES
básico
usando
claves
distintas
clave
112
168
bits
principal
desventaja
3DES
implementación
software
algoritmo
relativa-
mente
lenta
desventaja
DES
3DES
bloques
tamaño
64
bits
deseable
tamaño
bloque
razones
eficiencia
seguridad
abla
16.4
Tiempo
Necesario
Búsqueda
Exhaustiva
Clave
amaño
clave
Número
claves
Tiempo
necesario
Tiempo
necesario
bits
alternativas
cifrado
mmsa
106
cifrado
mms
32
232
4.3
109
231
ms
35.8
minutos
2.15
milisegundos
56
256
.2
1016
255
ms
142
años
10.01
horas
128
2128
3.4
1038
2127
ms
5.4
1024
años
5.4
1018
años
168
2168
3.7
1050
2167
ms
5.9
1036
años
5.9
1030
años
26
caracteres
permutación
26
1026
1026
ms
6.4
1012
años
6.4
106
años
Advanced
Encryption
Standard
desventajas
3DES
realmente
candi-
dato
plazo
sustituto
National
Institute
of
Standards
and
Technology
NIST
solicitó
1977
propuestas
algoritmo
denominado
Advanced
Encryption
Standard
AES
debería
nivel
seguridad
3DES
eficiencia
significativamente
mejorada
requisitos
generales
NITS
especificó
AES
cifrador
simétrico
bloque
bloques
longitud
128
bits
soportar
claves
longi-
tud
128
192
256
bits
criterios
evaluación
incluyen
seguridad
eficiencia
computacional
ne-
cesidades
memoria
idoneidad
hardware
software
flexibilidad
2001
NITS
publicó
AES
estándar
federal
procesamiento
información
FIPS
197
CRIPTOGRAFÍA
CLAVE
PÚBLICA
criptografía
clave
pública
públicamente
propuesta
Diffie
Hellman
1976
avance
realmente
revolucionario
criptografía
literalmente
miles
años
razón
algoritmos
clave
pública
basan
funciones
matemáticas
simples
operaciones
patrones
bits
importante
criptografía
clave
pú-
blica
asimétrica
requiriendo
claves
separadas
contraste
criptografía
simé-
trica
utiliza
clave
claves
consecuencias
profundas
áreas
confidencialidad
distribución
clave
autenticación
seguir
debemos
mencionar
ideas
comúnmente
equivocadas
acerca
criptografía
clave
pública
criptografía
clave
pública
segura
criptoanáli-
sis
criptografía
simétrica
seguridad
esquema
criptográfico
depende
longitud
clave
trabajo
computacional
necesario
romper
cifrado
principio
738
Sistemas
operativos
Aspectos
internos
principios
diseño
16-Capitulo
16
16/5/05
17:08
Página
738nada
criptografía
simétrica
clave
pública
haga
superior
punto
vista
resistir
criptoanálisis
idea
equivocada
criptografía
clave
públi-
ca
técnica
propósito
general
dejado
obsoleta
criptografía
simétrica
con-
trario
dadas
necesidades
computacionales
esquemas
criptográficos
clave
pública
actua-
previsible
abandone
criptografía
simétrica
Finalmente
creencia
utiliza
criptografía
clave
pública
distribución
clave
trivial
comparado
complicado
protocolo
criptografía
simétrica
involucra
centros
distribución
claves
necesita
tipo
protocolo
involucrando
agente
central
procedi-
mientos
necesarios
simples
eficientes
requeridos
criptografía
simétrica
esquema
criptográfico
clave
pública
ingredientes
Figura
16.15
Texto
mensaje
datos
originales
alimentan
entrada
algoritmo
Algoritmo
cifrado
algoritmo
cifrado
realiza
sustituciones
transformaciones
texto
Claves
pública
privada
par
claves
seleccionadas
utiliza
cifrar
descifrar
transformaciones
concretas
realiza
algoritmo
cifrado
dependen
clave
pública
privada
proporciona
entrada
Texto
cifrado
mensaje
codificado
producido
salida
Depende
texto
clave
secreta
mensaje
dato
claves
producirán
textos
cifrados
Algoritmo
descifrado
algoritmo
acepta
texto
cifrado
correspondiente
clave
produce
texto
original
proceso
funciona
produce
salida
texto
correcto
importar
orden
utiliza
pareja
claves
nombre
sugiere
clave
pública
par
pública
usen
clave
privada
propietario
digamos
Pepe
enviar
mensaje
privado
Alicia
supongamos
clave
pública
Alicia
Alicia
correspondiente
clave
privada
Figura
16.15a
Usando
cla-
ve
pública
Alicia
Pepe
cifra
mensaje
producir
texto
cifrado
texto
cifrado
transmite
Alicia
Alicia
recibe
texto
cifrado
descifra
usando
clave
privada
Alicia
copia
clave
privada
descifrar
mensaje
criptografía
clave
pública
usarse
ilustra
Figura
16.15b
Su-
pongamos
Pepe
enviar
mensaje
Alicia
importante
mensaje
per-
manezca
secreto
Alicia
esté
segura
mensaje
efectivamente
caso
Pepe
clave
privada
cifrar
mensaje
Alicia
recibe
texto
cifrado
descubre
descifrarlo
clave
pública
Pepe
probándose
mensaje
ha-
ber
cifrado
Pepe
clave
privada
Pepe
creado
texto
cifrado
descifrado
clave
pública
Pepe
algoritmo
criptográfico
clave
pública
propósito
general
basa
clave
cifrar
clave
relacionada
descifrar
algoritmos
siguientes
importantes
características
computacionalmente
irrealizable
determinar
clave
descifrado
conociendo
algoritmo
criptográfico
clave
cifrado
Cualquiera
claves
relacionadas
usarse
cifrado
usarse
descifrado
Seguridad
739
16-Capitulo
16
16/5/05
17:08
Página
739Los
pasos
esenciales
siguientes
usuario
genera
par
claves
usadas
cifrado
descifrado
mensajes
usuario
pone
claves
registro
público
fichero
accesible
clave
pública
clave
acompañante
conserva
privada
sugiere
Figura
16.15a
usuario
mantiene
colección
claves
públicas
obtenidas
usuarios
Pepe
desea
enviar
mensaje
privado
Alicia
Pepe
cifra
mensaje
usando
clave
públi-
ca
Alicia
740
Sistemas
operativos
Aspectos
internos
principios
diseño
Texto
entrada
Llavero
claves
públicas
Pepe
Texto
cifrado
transmitido
Texto
salida
Algoritmo
cifrado
ejemplo
RSA
Algoritmo
descifrado
contrario
algoritmo
cifrado
Juan
Miguel
Pepe
Teo
Alicia
Clave
pública
Alicia
Clave
privada
Alicia
Cifrado
Encryption
algorithm
ejemplo
RSA
Clave
privada
Pepe
Clave
pública
Pepe
Autenticación
Llavero
claves
públicas
Alicia
Juan
Miguel
Teo
Texto
entrada
Texto
cifrado
transmitido
Algoritmo
descifrado
contrario
algoritmo
cifrado
Texto
salida
Figura
16.15
Criptografía
clave
pública
16-Capitulo
16
16/5/05
17:08
Página
7404
Alicia
recibe
mensaje
descifra
usando
clave
privada
receptor
descifrar
mensaje
Alicia
conoce
clave
privada
sistema
participantes
acceso
claves
públicas
claves
privadas
generadas
localmente
participante
necesitan
distribuidas
medida
usuario
proteja
clave
privada
comunicación
entrante
segura
momento
usuario
cambiar
clave
privada
publicar
clave
pública
correspondiente
reemplazar
antigua
clave
pública
clave
utilizada
criptografía
simétrica
conoce
normalmente
clave
secreta
claves
utilizadas
criptografía
clave
pública
conocen
clave
pública
clave
privada
Invariablemente
clave
privada
mantiene
secreta
referimos
clave
privada
clave
secreta
evitar
confusión
criptografía
simétrica
Algoritmo
Rivest-Shamir-Adleman
RSA
esquemas
clave
pública
desarrollado
1977
Ron
Rivest
Adi
Shamir
Len
Adleman
MIT
esquema
RSA
rei-
nado
momento
único
enfoque
ampliamente
aceptado
implementado
cripto-
grafía
clave
pública
RSA
cifrador
texto
texto
cifrado
ente-
ros
entren
n.
cifrado
requiere
aritmética
modular
fortaleza
algoritmo
basa
dificultad
factorizar
números
factores
primos
Seguridad
741
16-Capitulo
16
16/5/05
17:08
Página
74116-Capitulo
16
16/5/05
17:08
Página
742APÉNDICE
Temas
concurrencia
A1
Exclusión
mutua
écnicas
software
Algoritmo
Dekker
Algoritmo
Peterson
A2
Condiciones
carrera
semáforos
Definición
problema
tentativa
tentativa
tentativa
Cuarta
tentativa
tentativa
correcta
A3
problema
barbería
barbería
injusta
barbería
justa
A4
Problemas
17-Apendice
12/5/05
16:30
Página
743A1
EXCLUSIÓN
MUTUA
TÉCNICAS
SOFTWARE
implementar
técnicas
software
procesos
concurrentes
ejecutan
único
procesador
máquina
multiprocesador
memoria
principal
compartida
técni-
cas
normalmente
asumen
exclusión
mutua
elemental
nivel
acceso
memoria
LAMP91
véase
Problema
A.3
serializan
accesos
simultáneos
lectura
escritura
ubica-
ción
memoria
principal
clase
árbitro
memoria
especifique
anti-
cipado
orden
acceso
resultante
allá
asume
soporte
hardware
sistema
ope-
rativo
lenguaje
programación
ALGORITMO
DEKKER
Dijkstra
DIJK65
describió
algoritmo
exclusión
mutua
procesos
diseñado
matemático
holandés
Dekker
Siguiendo
Dijkstra
desarrollar
solución
paso
paso
técnica
ventaja
mostrar
errores
típicos
desarrollo
programas
concurrentes
tentativa
anteriormente
aproximación
exclusión
mutua
basarse
al-
gunos
mecanismos
fundamentales
exclusión
hardware
mecanismo
común
res-
tricción
determinado
momento
acceso
ubicación
memo-
ria
Utilizando
restricción
reserva
ubicación
memoria
global
etiquetada
turno
proceso
P0
P1
desee
ejecutar
sección
crítica
examina
contenido
turno
valor
turno
número
proceso
proceso
acceder
sección
crítica
caso
contrario
forzado
esperar
proceso
espera
lee
forma
repetida
valor
variable
turno
entrar
sección
crítica
procedimiento
conoce
espera
activa
proceso
logra
entrar
sección
crítica
productivo
obtiene
permisos
entrar
sección
crítica
contrario
permanecer
comprobando
periódicamente
variable
consume
tiempo
procesador
espera
activa
mien-
espera
oportunidad
proceso
obtenido
acceso
sección
crítica
com-
pletado
dicha
sección
actualizar
valor
turno
resto
procesos
términos
formales
variable
global
compartida
int
turno
Figura
A.1a
muestra
programa
procesos
solución
garantiza
propiedad
exclusión
mutua
desventajas
procesos
alternarse
estrictamente
sección
crítica
ritmo
ejecución
viene
dictado
proceso
lento
P0
utiliza
sección
crítica
hora
P1
desea
utilizar
sección
crítica
ratio
1000
hora
P1
obligado
seguir
ritmo
P0
problema
serio
proceso
falla
proceso
permanentemente
bloqueado
cumple
proceso
falla
sección
crítica
construcción
precedente
corrutina
corrutinas
diseñan
pasar
con-
trol
ejecución
véase
Problema
5.1
técnica
útil
único
proceso
inadecuado
soporte
procesamiento
concurrente
744
Sistemas
operativos
Aspectos
internos
principios
diseño
17-Apendice
12/5/05
16:30
Página
744Temas
concurrencia
745
PROCESS
PROCESS
while
turno
while
turno
sección
crítica*/
sección
crítica*/
turno
turno
Figura
A1
Tentativas
exclusión
mutua
PROCESS
PROCESS
while
estado[1
while
estado[0
estado[0
true
estado[1
true
/*sección
crítica*/
/*sección
crítica*/
estado[0
false
estado[1
false
tentativa
tentativa
PROCESS
PROCESS
estado[0
true
estado[1
true
while
estado[1
while
estado[0
sección
crítica*/
sección
crítica*/
estado[0
false
estado[1
false
PROCESS
PROCESS
estado[0
true
estado[1
true
while
estado[1
while
estado[0
estado[0
false
estado[1
false
/*retraso
/*retraso
true
true
/*sección
crítica*/
/*sección
crítica*/
estado[0
false
estado[1
false
tentativa
Cuarta
tentativa
17-Apendice
12/5/05
16:30
Página
745Segunda
tentativa
problema
tentativa
almacena
nombre
proceso
entrar
sección
crítica
necesita
información
procesos
efecto
proceso
debería
llave
entrar
sección
crítica
forma
falla
continuar
accediendo
sección
crítica
alcanzar
requisito
define
vec-
tor
booleano
estado[0
P0
estado[1
P1
proceso
exami-
nar
proceso
alterarlo
proceso
desea
entrar
sección
crítica
periódicamente
comprueba
valor
false
indica
proceso
sección
crítica
proceso
realizando
comprobación
in-
mediatamente
establece
true
procede
acceder
sección
crítica
deja
sección
crítica
establece
false
variable1
global
compartida
enum
boolean
false=0
true=1
boolean
estado[2]={0,0
Figura
A.1b
muestra
algoritmo
proceso
falla
sección
crítica
incluyendo
código
establecimiento
proceso
queda
bloqueado
proceso
entrar
sección
crítica
frecuentemente
desee
falso
proceso
falla
sección
crítica
establecer
verda-
dero
justo
entrar
sección
crítica
proceso
queda
permanentemente
bloqueado
solución
tentativa
garantiza
exclusión
mutua
to-
das
situaciones
Considérese
secuencia
P0
ejecuta
sentencia
whiley
estado[1]con
valor
falso
P1
ejecuta
sentencia
whiley
estado[0]con
valor
falso
P0
establece
estado[0]a
entra
sección
crítica
P1
establece
estado[1]a
entra
sección
crítica
procesos
encuentran
secciones
críticas
programa
inco-
rrecto
problema
solución
propuesta
independiente
velocidades
relativas
ejecución
procesos
ercera
tentativa
tentativa
falla
proceso
cambiar
pro-
ceso
cambiado
proceso
entrar
sección
crítica
arreglar
problema
simple
intercambio
sentencias
muestra
Figura
A.1c
caso
proceso
falla
sección
crítica
incluyendo
código
establecimiento
controla
sección
crítica
proceso
bloquea
proceso
falla
sección
crítica
proceso
bloquea
746
Sistemas
operativos
Aspectos
internos
principios
diseño
declaración
enum
utiliza
declarar
tipo
datos
boolean
asignar
valores
17-Apendice
12/5/05
16:30
Página
746A
continuación
comprobar
garantiza
exclusión
mutua
punto
vista
proceso
P0
P0
establecido
estado[0
P1
entrar
sección
crítica
P0
entrado
abandonado
sección
crítica
ocurrir
P1
esté
sección
crítica
P0
establece
caso
P0
quedará
bloqueado
sentencia
whilehasta
P1
dejado
sección
crítica
razonamiento
aplica
punto
vista
P1
garantiza
exclusión
mutua
crea
problema
procesos
establecen
ejecutado
sentencia
while
procesos
pensará
entrado
sección
crítica
causando
interbloqueo
Cuarta
tentativa
tentativa
proceso
establece
proceso
inter-
bloqueo
proceso
insistir
derecho
entrar
sección
crítica
oportunidad
retroceder
posición
intentar
arreglar
problema
forma
proceso
respetuoso
proceso
establece
indicar
deseo
entrar
sección
crítica
preparado
cambiar
desea
entrar
muestra
Figura
A.1d
cercano
solución
correcta
falla
exclusión
mutua
garantiza-
siguiendo
razonamiento
similar
usado
discusión
tentativa
considérese
secuencia
eventos
P0
establece
estado[0]a
P1
establece
estado[1]a
P0
comprueba
estado[1
P1
comprueba
estado[0
P0
establece
estado[0]a
falso
P1
establece
estado[1]a
falso
P0
establece
estado[0]a
P1
establece
estado[1]a
secuencia
extender
forma
indefinida
proceso
entrar
sec-
ción
crítica
Estrictamente
hablando
interbloqueo
alteración
veloci-
dad
relativa
procesos
rompería
ciclo
permitiría
entrar
sección
crítica
condición
conoce
círculo
vicioso
Recuérdese
interbloqueo
produce
conjunto
procesos
desea
entrar
secciones
críticas
proceso
lo-
grarlo
círculo
vicioso
posibles
secuencias
ejecución
permitir
avanzara
describir
secuencias
ejecución
proceso
entrara
sección
crítica
escenario
descrito
improbable
mantenga
tiempo
obs-
tante
escenario
rechazar
cuarta
alternativa
solución
válida
necesario
observar
procesos
variable
cuarta
alternativa
muestra
suficiente
imponer
orden
acti-
Temas
concurrencia
747
17-Apendice
12/5/05
16:30
Página
747vidades
procesos
evitar
problema
cortesía
mutua
descrito
anterior-
mente
utilizar
variable
turnode
alternativa
propósito
caso
variable
indica
proceso
derecho
insistir
entrar
región
crítica
solución
conocida
Algoritmo
Dekker
describe
continuación
P0
quie-
re
entrar
sección
crítica
establece
comprueba
P1
falso
P0
inmediatamente
entra
sección
crítica
caso
P0
consulta
turno
turno
turno
insistir
periódicamente
comprueba
P1
P1
punto
advertirá
turno
permitir
proceso
entrar
pondrá
falso
provocando
P0
continuar
P0
utiliza-
do
sección
crítica
establece
falso
liberar
sección
crítica
pone
turno
transferir
derecho
insistir
P1
Figura
A.2
proporciona
especificación
Algoritmo
Dekker
construcción
parale-
los(P1
P2
Pn
significa
suspender
ejecución
programa
principal
iniciar
ejecución
concurrente
procedimientos
P1
P2
Pn
procedimientos
P1
P2
Pn
hayan
terminado
continuar
programa
principal
deja
verificación
Algoritmo
Dekker
ejercicio
véase
Problema
A.1
ALGORITMO
PETERSON
Algoritmo
Dekker
resuelve
problema
exclusión
mutua
programa
complejo
difícil
seguir
cuya
corrección
difícil
probar
Peterson
PETE81
pro-
porcionado
solución
simple
elegante
caso
variable
global
estadoindi-
ca
posición
proceso
exclusión
mutua
variable
global
turnoresuelve
conflictos
simultáneos
algoritmo
presenta
Figura
A.3
exclusión
mutua
preserva
fácilmente
demostrable
Considérese
proce-
so
P0
pone
estado[0
P1
entrar
sección
crítica
estado[1
true
P0
bloquea
entrar
sección
crítica
evita
bloqueo
mútuo
Supóngase
P0
bloquea
bucle
while
significa
esta-
do[1
turno
P0
entrar
sección
crítica
estado[1
vuelva
falso
turno
vuelva
considérese
casos
exhaustivos
P1
interés
sección
crítica
caso
imposible
implica
esta-
do[1
false
P1
esperando
sección
crítica
caso
imposible
turn
P1
ca-
paz
entrar
sección
crítica
P1
utilizando
sección
crítica
repetidamente
monopolizando
acceso
suceder
P1
obligado
oportunidad
P0
estableciendo
turno
intento
entrar
sección
crítica
solución
sencilla
problema
exclusión
mutua
procesos
Algoritmo
Peterson
generalizar
fácilmente
caso
procesos
HOFR90
A2
CONDICIONES
CARRERA
SEMÁFOROS
definición
condición
carrera
dada
Sección
5.1
sencilla
expe-
riencia
mostrado
estudiantes
normalmente
dificultades
señalar
condiciones
748
Sistemas
operativos
Aspectos
internos
principios
diseño
17-Apendice
12/5/05
16:30
Página
748Temas
concurrencia
749
boolean
estado[2
int
turno
void
P0
while
true
estado[0
true
while
if
turno
estado[0
false
while
turno
estado[0
true
sección
crítica
turno
estado[0
false
resto
void
P1
while
true
estado[1
true
while
estado[0
if
turno
estado[1
false
while
turno
estado[1
true
sección
crítica
turno
estado[1
false
remainder
void
main
estado[0
false
estado[1
false
turno
paralelos
P0
P1
Figura
A2
Algoritmo
Dekker
17-Apendice
12/5/05
16:30
Página
749de
carrera
programas
propósito
sección
basa
CARR01
consiste
serie
pasos
ejemplos
utilizan
semáforos
clarificar
tema
condiciones
carrera
750
Sistemas
operativos
Aspectos
internos
principios
diseño
Quisiera
gracias
profesor
Ching-Kuang
Shene
Universidad
Tecnológica
Michigan
permitir
utilizar
ejemplo
libro
boolean
estado[2
int
turno
void
P0
while
true
estado[0
true
turno
while
turno
sección
crítica
false
resto
void
P1
while
true
true
turno
while
turno
sección
crítica
false
resto
void
main
false
false
paralelos
P0
P1
Figura
A3
Algoritmo
Peterson
procesos
17-Apendice
12/5/05
16:30
Página
750DEFINICIÓN
PROBLEMA
procesos
compuesto
hilos
concurrentes
hilo
incluye
bucle
infinito
intercambia
mensaje
hilo
proceso
mensaje
formado
entero
colocado
buffer
global
compartido
requisitos
hilo
A1
proceso
pone
disponible
mensaje
hilo
B1
proceso
A1
continuar
recibe
mensaje
B1
Análogamente
B1
pone
mensaje
disponible
A1
continuar
recibir
men-
saje
A1
hilo
A1
pone
mensaje
disposición
asegurarse
hilo
sobrescribe
buffer
global
hilo
tome
mensaje
resto
sección
mostrarán
tentativas
implementación
esquema
utilizando
semáforos
provoca
condición
carrera
Finalmente
mos-
trará
solución
correcta
ALTERNATIVA
Considérese
opción
semáforo
int
buf_a
buf_b
hilo_A
hilo_B
int
var_a
int
var_b
while
true
while
true
var_a
var_b
semSignal(b
semSignal(a
semWait(a
semWait(b
buf_a
var_a
buf_b
var_b
var_a
buf_b
var_b
buf_a
protocolo
handshaking
apretón
manos
hilo
A1
listo
intercambiar
mensajes
envía
señal
hilo
espera
hilo
B1
esté
listo
vuelve
señal
B1
percibe
función
semWait(a
A1
asume
B1
listo
cabo
intercambio
B1
comporta
forma
similar
inter-
cambio
sucede
importar
hilo
listo
alternativa
condiciones
carrera
ejemplo
considérese
se-
cuencia
sucediéndose
tiempo
forma
vertical
Temas
concurrencia
751
17-Apendice
12/5/05
16:30
Página
751Hilo
A1
Hilo
B1
semSignal(b
semWait(a
semSignal(a
semWait(b
buf_a
var_a
var_a
buf_b
buf_b
var_b
secuencia
A1
alcanza
semWait(a)y
bloquea
B1
alcanza
semWait(b)y
bloquea
expulsado
actualizar
buf_b
A1
ejecuta
lee
buf_b
valor
pretendido
punto
buf_b
valor
proporcionado
hilo
proporcionado
B1
intercambio
condición
carrera
condición
carrera
sutil
hilos
activos
Considérese
secuencia
Hilo
A1
Hilo
A2
Hilo
B1
Hilo
B2
semSignal(b
semWait(a
semSignal(a
semWait(b
semSignal(b
semWait(a
buf_b
var_b1
semSignal(a
buf_a
var_a1
buf_a
var_a2
secuencia
hilos
A1
B1
intentan
intercambiar
mensajes
apropiadas
instrucciones
señalización
semáforos
inmediatamente
ejecuten
señales
semWait
hilos
A1
B1
hilo
A2
ejecuta
semSignal(b
semWait(a
provoca
hilo
B2
ejecute
semSignal(a
liberar
A2
semWait(a
punto
A1
A2
actualizar
buf_a
continuación
daría
condición
carrera
Cambiando
secuencia
ejecución
hilos
fácilmente
encontrar
condiciones
carrera
Lección
aprendida
comparta
variable
múltiples
hilos
probable
den
condiciones
carrera
utilice
protección
exclusión
mutua
apropiada
752
Sistemas
operativos
Aspectos
internos
principios
diseño
17-Apendice
12/5/05
16:30
Página
752SEGUNDA
ALTERNATIVA
caso
utilizar
semáforo
proteger
variable
compartida
propósito
asegu-
rar
acceso
buf_ay
buf_bes
mutuamente
exclusivo
programa
semáforo
mutex
int
buf_a
buf_b
hilo_A
hilo_B
int
var_a
int
var_b
while
true
while
true
var_a
var_b
semSignal(b
semSignal(a
semWait(a
semWait(b
semWait(mutex
semWait(mutex
buf_a
var_a
buf_b
var_b
semSignal(mutex
semSignal(mutex
semSignal(b
semSignal(a
semWait(a
semWait(b
semWait(mutex
semWait(mutex
var_a
buf_b
var_b
buf_a
semSignal(mutex
semSignal(mutex
hilo
intercambiar
mensaje
cabo
protocolo
handshaking
alternativa
semáforo
mutex
protege
buf_a
buf_b
intento
asegurar
actualización
preceda
lectura
protección
adecuada
hilos
completado
fase
handshaking
valores
semáforos
ay
bson
posibilidades
hilos
digamos
A1
B1
completan
handshaking
continuan
fase
intercambio
par
hilos
comienzan
fase
hilo
par
actual
continuará
intercambiará
mensaje
hilo
recién
llegado
par
posibilidades
condiciones
carrera
ejemplo
condi-
ción
carrera
basada
posibilidad
secuencia
Temas
concurrencia
753
17-Apendice
12/5/05
16:30
Página
753Hilo
A1
Hilo
A2
Hilo
B1
semSignal(b
semWait(a
semSignal(a
semWait(b
buf_a
var_a1
buf_b
var_b1
semSinal(b
semWait(a
semSignal(a
semWait(b
buf_a
var_a2
ejemplo
A1
B1
realizan
handshake
actualizan
buf-
fers
globales
correspondientes
A2
inicia
fase
handshaking
continuación
B1
inicia
fase
handshaking
punto
A2
actualiza
buf_a
B1
leer
valor
colocado
buf_apor
A1
condición
carrera
Lección
aprendida
Proteger
única
variable
insuficiente
dicha
variable
larga
secuencia
ejecución
proteger
secuencia
ejecución
completa
ALTERNATIVA
intento
desea
expandir
sección
crítica
incluir
intercambio
mensajes
completo
hilos
actualizan
buffersy
leen
buffer
único
semáforo
insuficiente
por-
interbloqueo
esperando
programa
semáforo
alisto
ahecho
blisto
bhecho
int
buf_a
buf_b
hilo_A
hilo_B
int
var_a
int
var_b
while
true
while
true
var_a
var_b
semWait(alisto
semWait(blisto
buf_a
var_a
buf_b
var_b
semSignal(ahecho
semSignal(bhecho
semWait(bhecho
semWait(ahecho
var_a
buf_b
var_b
buf_a
semSignal(alisto
semSignal(blisto
754
Sistemas
operativos
Aspectos
internos
principios
diseño
17-Apendice
12/5/05
16:30
Página
754El
semáforo
alisto
utiliza
asegurar
hilo
actualizar
buf_a
entra
sección
crítica
semáforo
ahecho
utiliza
asegurar
hilo
intente
leer
buf_a
buf_a
actualizado
consideración
aplica
blisto
bhecho
esquema
previene
condiciones
carrera
Considérese
secuencia
Hilo
A1
Hilo
B1
buf_a
var_a
semSignal(ahecho
semWait(bhecho
buf_b
var_b
semSignal(bdone
semWait(adone
var_a
buf_b
semSignal(alisto
loop
back
semWait(alisto
buf_a
var_a
var_b
buf_a
secuencia
A1
B1
entran
secciones
críticas
depositan
mensajes
alcanzan
espera
A1
copia
mensaje
B1
abandona
sección
crítica
punto
A1
volver
programa
generar
mensaje
depositarlo
buf_a
muestra
secuencia
ejecución
posibilidad
punto
hilo
generara
mensaje
pusiera
buf_a
caso
pierde
mensaje
produce
condición
carrera
Lección
aprendida
grupos
hilos
cooperando
exclusión
mutua
garantizada
grupo
prevenir
interferencia
hilos
grupos
hilo
entra
repetidamente
sección
crítica
gestionar
apropiadamente
temporización
cooperación
hilos
CUARTA
ALTERNATIVA
alternativa
falla
forzar
hilo
permanecer
sección
crítica
hilo
recibe
mensaje
presenta
intento
lograr
objetivo
Temas
concurrencia
755
17-Apendice
12/5/05
16:30
Página
755semáforo
alisto
ahecho
blisto
bhecho
int
buf_a
buf_b
hilo_A
hilo_B
int
var_a
int
var_b
while
true
while
true
var_a
var_b
semWait(blisto
semWait(alisto
buf_a
var_a
buf_b
var_b
semSignal(ahecho
semSignal(bhecho
semWait(bhecho
semWait(ahecho
var_a
buf_b
var_b
buf_a
semSignal(alisto
semSignal(blisto
caso
hilo
entra
sección
crítica
decrementa
blisto
hilo
intentará
intercambio
mensajes
hilo
complete
intercambio
mensajes
incremente
bready
técnica
condiciones
carrera
tales
secuencia
Hilo
A1
Hilo
A2
Hilo
B1
semWait(blisto
buf_a
var_a1
semSignal(ahecho
semWait(alisto
buf_b
var_b1
semSignal(bhecho
semWait(ahecho
var_b
buf_a
semSignal(blisto
semWait(blisto
semWait(bhecho
var_a2
buf_b
secuencia
hilos
A1
B1
entran
correspondientes
secciones
críticas
in-
tercambiar
mensajes
hilo
B1
recupera
mensaje
señaliza
blisto
permite
hilo
A2
entrar
sección
crítica
A2
rápido
A1
A2
recuperar
men-
saje
enviado
A1
756
Sistemas
operativos
Aspectos
internos
principios
diseño
17-Apendice
12/5/05
16:30
Página
756Lección
aprendida
condiciones
carrera
semáforo
exclusión
mutua
liberado
propietario
cuarta
alternativa
hilo
bloquea
semáforo
hilo
desbloquea
práctica
programación
arriesgada
ALTERNATIVA
CORRECTA
lector
notar
problema
sección
variación
problema
buffer
acota-
do
resolver
forma
similar
discusión
Sección
5.4
técnica
directa
utilizar
buffers
mensajes
mensajes
B.
tamaño
buffer
necesita
entender
razones
considé-
rese
suposición
orden
liberación
hilos
primitiva
sincronización
buffer
entrada
garantizar
mensa-
jes
reciba
destinatario
apropiado
ejemplo
B1
recibir
mensaje
A1
enviar
mensaje
A1
buffer
múltiples
entradas
hilo
adquirir
mensaje
entrada
corresponde
A1
Utilizando
enfoque
básico
utiliza
Sección
5.4
desarrollar
si-
guiente
programa
semáforo
notFull_A
notFull_B
semáforo
notEmpty_A
notEmpty_B
int
buf_a
buf_b
hilo_A
hilo_B
int
var_a
int
var_b
while
true
while
true
var_a
var_b
semWait(notFull_A
semWait(notFull_B
buf_a
var_a
buf_b
var_b
semSignal(notEmpty_A
semSignal(notEmpty_B
semWait(notEmpty_B
semWait(notEmtpy_A
var_a
buf_b
var_b
buf_a
semSignal(notFull_B
semSignal(notFull_A
verificar
solución
funciona
necesita
tratar
aspectos
sección
intercambio
mensajes
mutuamente
exclusiva
grupo
hilos
valor
inicial
nolleno_A
hilo
pasar
semWait(noLleno_A
intercambio
completado
señalizado
hilo
ejecute
semSignal(noLleno_A
razonamiento
similar
aplica
hilos
B.
cumple
condición
Temas
concurrencia
757
17-Apendice
12/5/05
16:30
Página
7572
hilos
entran
secciones
críticas
intercambian
mensajes
interferirse
hilo
entrar
sección
crítica
hilo
fi-
nalizado
completamente
intercambio
hilo
entrar
sección
crítica
hilo
finalizado
completamente
intercambio
cumple
condición
hilo
abandona
sección
critica
hilo
grupo
darse
prisa
estropear
mensaje
existente
condición
satisface
utilizar
buffer
única
entrada
dirección
hilo
ejecutado
semWait(noLleno_A
entrado
sección
crítica
hilo
actuali-
zar
buf_a
correspondiente
hilo
recuperado
valor
buf_a
reali-
zado
semSignal(noLleno_A
Lección
aprendida
revisar
soluciones
problemas
conocidos
solución
correcta
problema
variación
solución
problema
conocido
A3
PROBLEMA
BARBERÍA
ejemplo
semáforos
implementar
concurrencia
considérese
simple
problema
barbería
ejemplo
instructivo
problemas
encontrados
intenta
proporcionar
acceso
adaptado
recursos
barbería
similar
encontra-
sistema
operativo
real
barbería
sillas
barberos
área
espera
acomodar
clientes
sofá
habitación
clientes
adicionales
permanecer
pie
Figura
A.4
normas
incendios
limitan
número
clientes
tienda
20
ejemplo
asumir
barbería
procesa
finalmente
50
clientes
cliente
entrará
tienda
llena
cliente
toma
asiento
sofá
permanece
pie
sofá
lleno
barbero
libre
sirve
cliente
permaneci-
do
sofá
tiempo
cliente
pie
lleve
tiempo
tien-
toma
asiento
sofá
cliente
finaliza
barbero
acepta
pago
máquina
registradora
acepta
pago
único
cliente
barberos
di-
viden
tiempo
cortar
pelo
aceptar
pagos
dormir
silla
esperan
cliente
BARBERÍA
INJUSTA
Figura
A.5
muestra
implementación
utiliza
semáforos
procedimientos
listan
columnas
ahorrar
espacio
asume
colas
semáforos
gestionan
polí-
tica
FIFO
cuerpo
programa
principal
activa
50
clientes
barberos
proceso
cajero
con-
siderará
propósito
colocación
operadores
sincronización
Capacidad
tienda
sofá
capacidad
tienda
capacidad
sofá
go-
biernan
semáforos
max_capacidad
sofa
respectivamente
758
Sistemas
operativos
Aspectos
internos
principios
diseño
deuda
profesor
Ralph
Hilzer
Universidad
California
Chico
proporcionarme
tratamiento
problema
17-Apendice
12/5/05
16:30
Página
758un
cliente
intenta
entrar
tienda
semáforo
max_capacidad
decrementa
cliente
abandona
barbería
semáforo
incrementa
cliente
tienda
llena
proceso
cliente
bloquea
max_capacidad
función
semWait
Análogamente
operaciones
semWait
semSignal
accio-
nes
sentarse
levantarse
sofá
Capacidad
silla
barbero
sillas
barbero
cuidado
uti-
lizarlas
apropiadamente
semáforo
silla_barbero
asegura
clien-
tes
intentando
obtener
servicio
intentando
evitar
indigna
situación
cliente
sentado
regazo
cliente
levantará
sofá
silla
esté
libre
semWait(silla_barbero
barbero
señaliza
acción
cliente
de-
jado
silla
semSignal(silla_barbero
asegura
acceso
justo
sillas
barberos
organización
cola
semáforo
cliente
bloquea
ocupe
silla
disponible
Obsérvese
procedimiento
cliente
semWait(si-
lla_barbero
ocurriese
semSignal(sofa
cliente
brevemente
sentaría
sofá
permanecería
pie
línea
sillas
barberos
creando
congestión
de-
jando
barberos
espacio
maniobra
Asegurar
clientes
silla
barbero
semáforo
cliente_listoenvía
señal
despierta
barbero
encuentre
durmiendo
indicándole
cliente
acaba
ocupar
silla
semáforo
barbero
dormiría
empezaría
cortar
pelo
cliente
dejara
silla
hubiese
cliente
sentado
barbero
estaría
cortando
aire
Mantenimiento
clientes
silla
barbero
sentado
cliente
perma-
nece
silla
barbero
señal
corte
finalizado
utilizando
se-
máforo
terminado
Limitar
cliente
silla
barbero
semáforo
silla_barberose
utiliza
limitar
número
clientes
sillas
barberos
semáforo
silla_barbero
realiza
adecuadamente
misión
cliente
obtiene
procesador
inmediatamente
barbero
ejecuta
semSignal(terminado
cae
hablar
vecino
silla
cliente
permita
sentarse
semáforo
dejar_silla_b
utiliza
corregir
problema
evitando
barbero
invite
cliente
silla
cliente
Temas
concurrencia
759
Sofá
Área
barbería
pie
Entrada
Salida
Sillas
barbero
Caja
registradora
Figura
A4
barbería
17-Apendice
12/5/05
16:30
Página
759no
ido
efectivamente
problemas
capítulo
analizará
in-
cluso
precaución
permite
evitar
cliente
vigoroso
siente
regazo
cliente
Pagos
recibos
Naturalmente
cuidadoso
dinero
cajero
asegurar
cliente
paga
abandonar
tienda
cliente
verifica-
ción
recibido
pago
recibo
realiza
efecto
transfe-
rencia
monetaria
cara
cara
cliente
justo
levantarse
silla
barbero
paga
avisando
cajero
dinero
semSignal(pago
espera
recibo
semWait(recibo
proceso
cajero
dedica
forma
repetida
recibir
pagos
espera
señalice
pago
acepta
dinero
señaliza
aceptación
di-
nero
necesitan
evitar
errores
programación
semSignal(pago
ocurriera
justo
acción
pagar
cliente
verse
interrumpido
señaliza-
760
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
barberia1
semaforo
max_capacidad
20
semaforo
sofa
semaforo
silla_barbero
semaforo
coord
semaforo
cliente_listo
terminado
dejar_silla_b
pago
recibo
void
cliente
void
barbero
void
cajero
wait(max_capacidad
while
true
while
true
entrar_tienda
wait(pago
wait(sofa
wait(cliente_listo
wait(coord
sentarse_en_sofa
wait(coord
aceptar_pago
wait(silla_barbero
cortar_pelo
signal(coord
levantarse_del_sofa
signal(coord
signal(recibo
signal(sofa
signal(terminado
sentarse_en_silla_de_barbero
wait(dejar_silla_b
signal(cliente_listo
signal(silla_barbero
wait(terminado
dejar_silla_barbero
signal(dejar_silla_b
pagar
signal(pago
wait(recibo
salir_tienda
signal(max_capacidad
void
main
parbegin
cliente
50
cliente
barbero
barbero
barbero
cajero
Figura
A5
barbería
injusta
17-Apendice
12/5/05
16:30
Página
760ción
dejaría
libre
cajero
aceptar
pagos
alguien
hubiera
ofrecido
error
serio
invertir
posiciones
sentencias
semSignal(pago
semWait(recibo
llevaría
interbloqueo
provocaría
to-
clientes
cajero
bloquearan
respectivos
operadores
semWait
Coordinación
funciones
barbero
cajero
ahorrar
dinero
barbería
emplea
cajero
independiente
barbero
cabo
tarea
cor-
tando
pelo
semáforo
coord
asegura
barbero
cabo
tarea
mo-
mento
determinado
Tabla
A.1
resume
semáforos
programa
abla
A.1
Funcionalidad
semáforos
Figura
A.5
Semáforo
Operación
wait
Operación
signal
max_capacidad
cliente
espera
espacio
cliente
abandona
tienda
tienda
señaliza
cliente
espera
entrar
sofa
cliente
espera
sentarse
cliente
abandona
sofa
sofá
señaliza
cliente
espera
sentarse
sofá
silla_barbero
cliente
espera
silla
barbero
señaliza
silla
barbero
vacía
vacía
cliente_listo
barbero
espera
cliente
cliente
señaliza
barbero
siente
silla
indicarle
silla
terminado
cliente
espera
barbero
señaliza
completa
corte
pelo
finalizado
cortar
pelo
cliente
dejar_silla_b
barbero
espera
cliente
cliente
señaliza
barbero
levanta
silla
levantado
silla
pago
cajero
espera
cliente
pague
cliente
señaliza
cajero
pagado
recibo
cliente
espera
recibo
pago
cajero
señaliza
aceptado
pago
coord
Espera
barbero
esté
libre
Señaliza
barbero
libre
cabo
corte
pelo
tareas
cajero
proceso
cajero
eliminar
mezclando
función
pago
procedimiento
bar-
bero
barbero
secuencialmente
cortaría
pelo
continuación
aceptaría
pago
única
caja
registradora
necesario
limitar
acceso
función
pago
aceptar
único
barbero
momento
determinado
tratando
función
sección
críti-
ca
protegiéndola
semáforo
BARBERÍA
JUSTA
Figura
A.5
intento
quedan
problemas
resto
sección
en-
carga
resolver
problemas
dejan
ejercicios
lector
véase
Pro-
blema
A.6
Temas
concurrencia
761
17-Apendice
12/5/05
16:30
Página
761762
Sistemas
operativos
Aspectos
internos
principios
diseño
programa
barberia2
semaforo
max_capacidad
20
semaforo
sofa
semaforo
silla_barbero
coord
semaforo
mutex1
mutex2
semaforo
cliente_listo
dejar_silla_b
pago
recibo
semaforo
terminado
50
int
count
void
cliente
void
barbero
void
cajero
int
numcliente
int
cliente_b
while
true
wait(max_capacidad
while
true
Entrar_tienda
wait(pago
wait(mutex1
wait(cliente_listo
wait(coord
numcliente
wait(mutex2
aceptar_pago
cuenta++
fcola1(cliente_b
signal(coord
signal(mutex1
signal(mutex2
signal(recibo
wait(sofa
wait(coord
sentarse_en_sofa
cortar_pelo
wait(silla_barbero
signal(coord
levantarse_del_sofa
signal(terminado[cliente_b
signal(sofa
wait(dejar_silla_b
sentarse_en_silla_de_barbero
signal(silla_barbero
wait(mutex2
encola1(numcliente
signal(cliente_listo
signal(mutex2
wait(terminado[numcliente
dejar_silla_barbero
signal(dejar_silla_b
pagar
signal(pago
wait(recibo
salir_tienda
signal(max_capacidad
void
main
count
parbegin
cliente
50
cliente
barbero
barbero
barbero
cajero
Figura
A6
barbería
justa
17-Apendice
12/5/05
16:30
Página
762Hay
problema
temporización
Figura
A.5
tratamiento
injusto
clientes
Supóngase
actualmente
clientes
sentados
sillas
barberos
caso
probable
clientes
estén
bloqueados
semWait(terminado
organización
cola
liberen
orden
sentaron
pasa
barberos
rápido
clientes
calvo
Liberando
cliente
sentó
resultar
situación
cliente
echado
silla
forza-
do
pagar
precio
completo
corte
pelo
parcial
retenidos
silla
in-
cluso
terminado
corte
pelo
problema
resuelve
semáforos
muestra
Figura
A.6
asigna
úni-
co
número
cliente
cliente
equivalente
cliente
coja
número
entrar
tienda
semáforo
mutex1
protege
acceso
variable
global
forma
cliente
recibe
número
único
semáforo
terminado
redefine
vector
50
semáforos
cliente
sentado
silla
barbero
ejecuta
semWait(terminado[numCliente
esperar
semáforo
barbero
finaliza
cliente
ejecuta
semSig-
nal(terminado[numCliente
liberar
cliente
apropiado
Queda
explicar
barbero
conoce
número
cliente
cliente
coloca
número
cola
encola1
justo
señalizar
barbero
semáforo
cliente_listo
barbe-
ro
listo
cortar
pelo
fcola1(cliente_b
borra
número
cliente
cima
cola
cola1
coloca
variable
local
barbero
cliente_b
A4
PROBLEMAS
A.1
Demuestre
corrección
Algoritmo
Dekker
Muestre
fuerza
exclusión
mutua
Pista
muestre
Pi
entra
sección
crítica
cumple
expresión
estado[i
and
not
estado[1-i
Muestre
proceso
requiere
acceso
sección
crítica
retrasado
inde-
finidamente
Pista
considere
siguientes
casos
único
proceso
inten-
tando
entrar
sección
crítica
procesos
intentando
entrar
sección
crítica
2a
turno
estado[0
falso
2b
turno
estado[0
A.2
Considere
Algoritmo
Dekker
escrito
número
arbitrario
procesos
cambian-
do
sentencia
ejecutada
abandona
sección
crítica
turno
1-i
P0
establece
turno
P1
establece
turno
turno
turno+1)%n
número
procesos*/
Evalúe
algoritmo
número
procesos
ejecutan
concurrentemente
ma-
yor
A.3
Demuestre
siguientes
técnicas
software
exclusión
mutua
dependen
exclusión
mutua
elemental
nivel
acceso
memoria
algoritmo
panadería
Algoritmo
Peterson
Temas
concurrencia
763
17-Apendice
12/5/05
16:30
Página
763A.4
Desarrolle
solución
problema
discutido
Sección
A.2
utiliza
único
buffer
entrada
caso
hilos
turnarse
intercambiar
mensajes
lugar
operar
paralelo
A.5
Conteste
siguientes
cuestiones
relacionadas
barbería
justa
Figura
A.6
código
requiere
barbero
termina
corte
pelo
recoja
pago
cliente
barberos
utilizan
silla
A.6
mantienen
problemas
caso
barbería
justa
Figura
A.6
Modifique
problema
corregir
siguientes
problemas
cajero
aceptar
pago
cliente
liberar
clientes
es-
tán
esperando
pagar
Afortunadamente
cliente
presenta
pago
forma
retroceder
caja
registradora
guarda
cantidad
exacta
obstante
deseable
liberar
cliente
correcto
pago
semáforo
dejar_silla_b
evita
supuestamente
múltiples
clientes
accedan
única
silla
barbero
Desafortunadamente
semáforo
realiza
tarea
adecua-
damente
casos
ejemplo
supóngase
barberos
cortado
pelo
quedado
bloqueados
semWait(dejar_silla_b
clientes
encuentran
interrumpido
justo
dejar
silla
barbero
ter-
cer
cliente
deja
silla
ejecuta
semSignal(dejar_silla_b
barbero
libera
cola
dejar_silla_b
FIFO
libera
barbero
bloqueó
barbero
cortando
pelo
cliente
señalizó
cliente
vendrá
sentará
regazo
clien-
punto
levantarse
programa
requiere
cliente
siente
sofá
silla
barbero
vacía
problema
menor
resolver
problema
implica
código
complejo
obstante
intente
resolver
problema
764
Sistemas
operativos
Aspectos
internos
principios
diseño
17-Apendice
12/5/05
16:30
Página
764APÉNDICE
Diseño
orientado
objetos
B1
Motivación
B2
Conceptos
orientación
objetos
Estructura
objeto
Clases
objeto
Agregación
B3
Beneficios
diseño
orientado
objetos
B4
CORBA
B5
Lecturas
sitios
web
recomendados
18-Apendice
12/5/05
16:30
Página
765N
Windows
sistemas
operativos
fundamentan
principios
diseño
orien-
tado
objetos
apéndice
proporciona
visión
general
principales
conceptos
diseño
orientado
objetos
B.1
MOTIVACIÓN
conceptos
orientación
objetos
populares
área
progra-
mación
promesa
construir
fragmentos
software
intercambiables
reutilizables
fácil-
mente
actualizables
fácilmente
interconectables
recientemente
diseñadores
bases
datos
comenzado
apreciar
ventajas
orientación
objetos
resultado
comenzado
aparecer
sistemas
gestión
bases
datos
orientadas
objetos
OODBMS
programación
orientada
objetos
sistemas
gestión
bases
datos
orientadas
ob-
jetos
cosas
comparten
concepto
clave
software
datos
alojados
contenedores
cosa
caja
cajas
cajas
programa
convencional
simple
paso
programa
equivale
instrucción
lenguaje
orientado
objetos
paso
caja
completa
instruccio-
nes
Similarmente
base
datos
orientada
objetos
variable
equivaler
simple
elemento
datos
equivaler
caja
completa
datos
Tabla
B.1
introduce
términos
clave
utilizados
diseño
orientado
objetos
abla
B.1
Términos
clave
orientación
objetos
érmino
Definición
Atributo
Variables
datos
contenidas
objeto
Agregación
Relación
instancias
objeto
objeto
contenedor
incluye
puntero
objeto
contenido
Encapsulación
aislamiento
atributos
servicios
instancia
objeto
entorno
externo
servicios
invocarse
nombre
atributos
accederse
servicios
Herencia
Relación
clases
objetos
atributos
servicios
clase
padre
adquiridos
clase
hija
Interfaz
Descripción
relacionada
clase
objeto
interfaz
contiene
definiciones
métodos
implementaciones
valores
constantes
interfaz
instanciarse
objeto
Mensaje
objetos
interactúan
Método
Procedimiento
objeto
activarse
objeto
funciones
Objeto
Abstracción
entidad
mundo
real
Clase
objeto
Nombre
conjunto
objetos
comparten
nombres
conjunto
atributos
servicios
Instancia
objeto
Miembro
específico
clase
objetos
valores
asignados
atributos
Polimorfismo
refiere
existencia
múltiples
objetos
nombres
servicios
presentan
interfaz
mundo
exterior
representan
tipos
entidades
Servicio
Función
realiza
operación
objeto
766
Sistemas
operativos
Aspectos
internos
principios
diseño
18-Apendice
12/5/05
16:30
Página
766B.2
CONCEPTOS
ORIENTACIÓN
OBJETOS
concepto
central
diseño
orientado
objetos
objeto
objeto
unidad
software
única
contiene
colección
variables
relacionadas
datos
métodos
procedimientos
Generalmente
variables
métodos
directamente
visibles
objeto
cambio
interfaces
definidos
permiten
software
acceso
datos
procedimientos
objeto
representa
cosa
entidad
física
concepto
módulo
software
entidad
dinámica
conexión
TCP
valores
variables
objeto
expresan
información
conoce
cosa
objeto
representa
métodos
incluyen
procedi-
mientos
cuya
ejecución
afecta
valores
objeto
posiblemente
afectan
cosa
representa
Figuras
B.1
B.2
ilustran
conceptos
clave
orientación
objetos
ESTRUCTURA
OBJETO
datos
procedimientos
contenidos
objeto
conocen
normalmente
variables
méto-
respectivamente
objeto
conoce
expresarse
variables
expresa
métodos
variables
objeto
llamadas
atributos
generalmente
escalares
sencillos
ta-
blas
variable
tipo
posiblemente
conjunto
valores
permitidos
constante
Diseño
orientado
objetos
767
carrito
compra
Objetos
ClasesUn
objeto
conoce
cosas
llamadas
atributos
cosas
llamadas
servicios
clases
especializarse
Ungrupo
objetos
parecidos
constituye
clase
transacción
venta
comprador
artículo
Clase
Artículo
Clase
Artículo
perecedero
objeto
clase
artículo
Conozco
fecha
fabricación
fecha
llegada
comprobar
disponibilidad
artículo
perecedero
Conozco
fecha
fabricación
fecha
llegada
fecha
caducidad
comprobar
disponibilidad
Figura
B.1
Objetos
18-Apendice
12/5/05
16:30
Página
767o
variable
convención
término
variable
utiliza
constantes
imponerse
restricciones
acceso
variables
usuarios
clases
usuarios
situaciones
métodos
objeto
procedimientos
dispararse
funciones
método
cambiar
objeto
actualizar
variables
actuar
recursos
externos
objeto
acceso
objetos
interactúan
mensajes
mensaje
incluye
nombre
objeto
emisor
nombre
objeto
receptor
nombre
método
objeto
receptor
cualesquiera
parámetros
necesa-
rios
cualificar
ejecución
método
mensaje
usarse
invocar
método
objeto
única
acceder
datos
internos
objeto
métodos
objeto
método
tome
acción
accedan
variables
objeto
ambas
cosas
objetos
locales
pasarle
mensaje
objeto
llamar
método
ob-
jeto
objetos
distribuidos
pasar
mensaje
exactamente
expresión
indica
interfaz
objeto
conjunto
métodos
públicos
objeto
proporciona
inter-
faz
relación
implementación
objetos
clases
implementaciones
interfaces
768
Sistemas
operativos
Aspectos
internos
principios
diseño
principio
objeto
ocultar
cosas
objetos
limitando
visibilidad
conozco
Clase
Artículo
artículo
Clase
Artículo
perecedero
artículo
perecedero
Generalización
Especialización
Datos
Encapsulación
principio
clase
ampliar
clase
previamente
definida
principio
base
organizar
clases
generalización
especialización
Herencia
Funciones
privadas
calcular
urgencia
venta
Funciones
públicas
comprobar
disponibilidad
principio
objetos
clases
entender
mensaje
responder
maneras
Polimorfismo
Comprobar
disponibilidad
Figura
B.2
Conceptos
objetos
18-Apendice
12/5/05
16:30
Página
768La
propiedad
objeto
único
interfaz
mundo
exterior
mensajes
conoce
encapsulación
métodos
variables
objeto
encapsulados
disponibles
vía
comunicación
basada
mensajes
encapsulación
ofrece
ventajas
Protege
variables
objeto
corrupción
objetos
protección
incluir
protección
frente
accesos
autorizados
protección
frente
tipos
pro-
blemas
surgen
accesos
concurrentes
interbloqueos
valores
incon-
sistentes
Oculta
estructura
interna
objeto
interacción
objeto
relativamente
sim-
ple
estandarizada
estructura
interna
procedimientos
objeto
modi-
fican
alterar
funcionalidad
externa
objetos
verán
afectados
CLASES
OBJETOS
práctica
normalmente
objetos
representando
tipos
cosas
ejem-
plo
proceso
representa
objeto
objeto
proceso
presente
sistema
Claramente
tales
objetos
necesita
conjunto
variables
em-
bargo
métodos
objeto
procedimientos
reentrantes
objetos
similares
com-
métodos
ineficiente
redefinir
métodos
variables
similar
objeto
solución
dificultades
distinguir
clase
objetos
instancia
objeto
clase
objetos
plantilla
define
métodos
variables
incluirse
tipo
objeto
particular
instancia
objeto
objeto
real
incluye
características
clase
define
instanciación
proceso
creación
instancia
objeto
clase
objetos
Herencia
concepto
clase
objetos
potente
permite
creación
instan-
cias
objeto
mínimo
esfuerzo
concepto
potente
mecanismo
herencia
TAIV96
herencia
permite
definir
clase
objetos
términos
clase
existente
clase
nivel
inferior
llamada
subclase
clase
hija
automáticamente
incluye
métodos
definiciones
variable
clase
original
nivel
superior
llamada
superclase
clase
padre
subclase
diferir
superclase
maneras
subclase
incluir
métodos
variables
adicionales
encuentran
super-
clase
subclase
anular
definición
método
variable
superclase
usando
nombre
definición
ofrece
simple
eficiente
ma-
nipular
casos
especiales
subclase
restringir
método
variable
heredados
superclase
Figura
B.3
basada
KORS90
ilustra
concepto
mecanismo
herencia
recursivo
permitiendo
subclase
superclase
subclases
construirse
jerarquía
herencia
Conceptualmente
entender
jerarquía
herencia
define
técnica
búsqueda
métodos
variables
objeto
recibe
mensaje
acabo
método
definido
clase
automáti-
camente
explora
jerarquía
método
Diseño
orientado
objetos
769
18-Apendice
12/5/05
16:30
Página
769ejecución
método
referencia
variable
definida
clase
objeto
busca
jerarquía
encontrar
variable
nombre
Polimorfismo
polimorfismo
fascinante
potente
característica
ocultar
implementaciones
interfaz
común
objetos
polimórficos
utili-
zan
nombres
métodos
presentan
interfaz
objetos
ejemplo
objetos
impresión
dispositivos
salida
tales
imprimir-
Matricial
imprimirLaser
imprimirPantalla
tipos
documentos
tales
imprimirTexto
imprimirDibujo
imprimirCompuesto
objeto
incluye
método
llamado
im-
primir
imprimirse
documento
enviando
mensaje
imprimir
objeto
apropiado
preocuparnos
cabo
realmente
método
Normalmente
poli-
morfismo
utiliza
permitir
método
múltiples
subclases
super-
clase
detalles
implementación
distintos
instructivo
comparar
polimorfismo
técnicas
usuales
programación
modular
objetivos
diseño
modular
abajo
diseñar
módulos
nivel
inferior
utilidad
general
interfaz
fijo
frente
módulos
nivel
superior
permite
módulo
nivel
inferior
invoque
módulos
nivel
superior
cambian
entresijos
mó-
dulo
nivel
inferior
cambiar
interfaz
módulos
nivel
superior
utili-
zan
verán
afectados
cambio
polimorfismo
preocupa
capacidad
objeto
nivel
superior
invocar
objetos
nivel
inferior
utilizando
formato
men-
saje
acabo
funciones
similares
polimorfismo
añadirse
objetos
nivel
inferior
cambios
mínimos
objetos
existentes
Interfaces
herencia
permite
objeto
subclase
utilice
funcionalidad
super-
clase
casos
desee
definir
subclase
funcionalidades
superclase
permitiendo
subclase
herede
770
Sistemas
operativos
Aspectos
internos
principios
diseño
superclase
subclase
hereda
derivada
heredada
añadida
código
específico
Figura
B.3
Herencia
18-Apendice
12/5/05
16:31
Página
770superclase
C++
lenguajes
permite
herencia
múltiple
simplici-
dad
mayoría
lenguajes
orientados
objetos
modernos
incluyendo
Java
Visual
Basic
.NET
limitan
herencia
única
superclase
cambio
característica
conocida
inter-
faces
utiliza
permitir
clase
tome
prestada
funcionalidad
clase
fun-
cionalidad
clase
completamente
Desafortunadamente
término
interfaz
utiliza
literatura
objetos
sig-
nificados
propósito
general
específicamente
funcional
interfaz
discutiendo
especifica
API
interfaz
programación
aplicación
funcionali-
dad
define
implementación
API
sintaxis
definición
interfaz
normal-
mente
semejante
definición
clase
código
definido
métodos
nombres
métodos
argumentos
necesarios
tipo
valor
devuelto
interfaz
implementarse
clase
funciona
semejante
he-
rencia
clase
implementa
interfaz
definidas
clase
propiedades
méto-
interfaz
métodos
implementan
codificarse
nombre
argumentos
tipo
devuelto
método
interfaz
idénticos
defi-
ne
interfaz
AGREGACIÓN
instancias
objetos
contienen
objetos
denominan
objetos
agregados
agrega-
ción
conseguirse
incluyendo
puntero
objeto
valor
objeto
ventaja
objetos
agregados
permite
representación
estructuras
complejas
ejemplo
ob-
jeto
contenido
objeto
agregado
objeto
agregado
Normalmente
estructuras
construidas
objetos
agregados
limitan
topología
ár-
bol
permiten
referencias
circulares
instancia
objeto
hija
instancia
objeto
padre
importante
aclarar
diferencia
jerarquía
herencia
clases
objetos
jerar-
quía
agregación
instancias
objeto
relacionadas
herencia
sim-
plemente
permite
definir
tipos
objetos
esfuerzo
mínimo
agregación
permite
construcción
estructuras
datos
complejas
B.3
BENEFICIOS
DISEÑO
ORIENTADO
OBJETOS
CAST92
enumera
siguientes
beneficios
diseño
orientado
objetos
organización
complejidad
inherente
herencia
de-
finirse
eficientemente
conceptos
relacionados
recursos
objetos
agregación
construirse
estructuras
datos
arbitrarias
reflejen
tarea
subyacente
manos
lenguajes
programación
estructuras
datos
orientadas
objetos
permiten
diseñadores
describir
recursos
funciones
sistema
operativo
ma-
nera
reflejen
entendimiento
diseñador
dichos
recursos
funciones
Menor
esfuerzo
desarrollo
gracias
reutilización
reutilización
clases
obje-
tos
escrito
probado
mantenido
acorta
tiempos
desarrollo
prueba
mantenimiento
Sistemas
extensibles
mantenibles
mantenimiento
incluyendo
mejoras
co-
rrecciones
producto
tradicionalmente
consume
cerca
65%
coste
vida
cual-
quier
producto
diseño
orientado
objetos
reduce
porcentaje
utilización
software
Diseño
orientado
objetos
771
18-Apendice
12/5/05
16:31
Página
771basado
objetos
ayuda
limitar
número
interacciones
potenciales
par-
tes
software
asegurando
realizarse
cambios
implementación
clase
impacto
resto
sistema
beneficios
dirigiendo
diseño
sistema
operativo
dirección
sistemas
orientados
objetos
objetos
permiten
programadores
ajusten
sistema
operativo
satisfacer
requisitos
comprometer
integridad
sistema
objetos
allanan
camino
computación
distribuida
objetos
comunican
mensajes
importa
objetos
sistema
sistemas
red
Datos
fun-
ciones
hilos
asignarse
dinámicamente
estaciones
trabajo
servidores
necesi-
ten
consiguiente
enfoque
orientado
objetos
diseño
sistemas
operativos
evidente
sistemas
operativos
estaciones
trabajo
PC
B.4
CORBA
visto
libro
conceptos
orientación
objetos
utilizado
diseñar
implementar
núcleos
sistemas
operativos
aportando
beneficios
flexibilidad
gestionabilidad
portabilidad
beneficios
utilizar
técnicas
orientación
objetos
extienden
ma-
yor
beneficio
dominio
software
distribuido
incluyendo
sistemas
operativos
distribuidos
aplicación
técnicas
orientación
objetos
diseño
implementación
software
distribuido
conoce
computación
objetos
distribuidos
distributed
object
computing
DOC
motivación
DOC
creciente
dificultad
escribir
software
distribuido
medida
hardware
computación
red
pequeños
rápidos
baratos
soft-
ware
distribuido
lento
caro
desarrollar
mantener
SCHM97
apunta
reto
software
distribuido
surge
tipos
complejidad
Inherente
complejidades
inherentes
surgen
problemas
fundamentales
distri-
bución
principales
detectar
recuperar
fallos
red
nodos
minimizar
impacto
latencia
comunicaciones
determinar
particionamiento
óptimo
componentes
servicio
carga
trabajo
computadores
red
programación
concurrente
cuestiones
bloqueo
recursos
interbloqueos
difícil
sistemas
distribuidos
inherentemente
concurrentes
Accidental
complejidades
accidentales
surgen
limitaciones
herramientas
técnicas
utilizadas
construir
software
distribuido
origen
usual
complejidad
acci-
dental
amplia
utilización
diseño
funcional
termina
sistemas
extensibles
reutilizables
DOC
enfoque
prometedor
gestión
tipos
complejidad
pieza
central
propuesta
DOC
mediadores
brokers
solicitudes
objeto
object
request
brokers
ORB
actúan
intermediarios
comunicación
objetos
locales
remotos
ORB
eliminan
aspectos
tediosos
propensos
error
portables
diseño
implementa-
ción
aplicaciones
distribuidas
Complementando
ORB
convenciones
forma-
tos
intercambio
mensajes
definiciones
interfaz
aplicaciones
infraestruc-
tura
orientada
objetos
tecnologías
principales
compitiendo
mercado
DOC
arquitectura
OMG
ob-
ject
management
group
llamada
CORBA
Arquitectura
Común
Mediadores
Solicitudes
Ob-
jeto
Common
Object
Request
Broker
Architecture
CORBA
sistema
invocación
métodos
remotos
Java
remote
method
invocation
RMI
modelo
distribuido
componentes
obje-
tos
Microsoft
Distributed
Component
Object
Model
DCOM
CORBA
avanzado
me-
772
Sistemas
operativos
Aspectos
internos
principios
diseño
18-Apendice
12/5/05
16:31
Página
772jor
asentado
líderes
industria
incluyendo
IBM
Sun
Netscape
Oracle
so-
portan
CORBA
Microsoft
anunciado
enlazará
esquema
propietario
DCOM
CORBA
resto
apéndice
proporciona
visión
general
CORBA
Tabla
B.2
define
términos
clave
utilizados
CORBA
principales
características
CORBA
Figura
B.4
Clientes
clientes
generan
solicitudes
acceden
servicios
objetos
varie-
dad
mecanismos
proporcionados
ORB
subyacente
Implementaciones
objeto
implementaciones
proporcionan
servicios
solici-
tados
clientes
sistema
distribuido
beneficio
arquitectura
CORBA
ambas
implementaciones
clientes
objetos
escritas
lenguaje
programación
proporcionar
conjunto
completo
servicios
re-
queridos
Núcleo
ORB
núcleo
ORB
responsable
comunicación
objetos
ORB
en-
cuentra
objeto
red
entrega
solicitudes
objeto
activa
objeto
activo
to-
davía
devuelve
mensaje
regreso
emisor
núcleo
ORB
proporciona
trans-
parencia
acceso
programadores
utilizan
exactamente
método
parámetros
invocan
método
local
método
remoto
núcleo
ORB
proporciona
transparencia
localización
programadores
necesitan
especi-
ficar
localización
objeto
Interfaz
interfaz
objeto
especifica
operaciones
tipos
soportados
objeto
define
solicitudes
objeto
interfaces
CORBA
simila-
res
clases
C++
interfaces
Java
diferencia
clases
C++
interfaz
CORBA
especifica
métodos
parámetros
valores
retorno
acer-
ca
implementación
objetos
clase
C++
implementación
métodos
Diseño
orientado
objetos
773
Invocación
dinámica
Stub
resguardo
IDL
Interfaz
ORB
Núcleo
ORB
Cliente
Implementación
objeto
DSI
Skeleton
esqueleto
IDL
Adaptador
objeto
ORB
Interfaz
privado
ORB
ORB
Mediador
solicitudes
objeto
IDL
Lenguaje
definición
interfaces
DSI
Interfaz
esqueleto
dinámico
Resguardos
esqueletos
específicos
interfaz
múltiples
adaptadores
objeto
Figura
B.4
Arquitectura
CORBA
Common
Object
Request
Broker
Architecture
18-Apendice
12/5/05
16:31
Página
773•
Lenguaje
definición
interfaces
OMG
IDL
IDL
lenguaje
utilizado
defi-
nir
objetos
ejemplo
definición
interfaz
IDL
//OMG
IDL
interface
Fábrica
Objeto
crear
definición
especifica
interfaz
llamado
Fábrica
soporta
operación
crear
operación
crear
recibe
parámetros
devuelve
referencia
objeto
tipo
Objeto
774
Sistemas
operativos
Aspectos
internos
principios
diseño
abla
B.2
Conceptos
Clave
Sistema
Distribuido
CORBA
Concepto
CORBA
Definición
Aplicación
cliente
Invoca
solicitudes
servidores
operaciones
objetos
aplicación
cliente
utiliza
definiciones
interfaces
describen
objetos
operaciones
cliente
solicitar
aplicación
cliente
utiliza
referencias
objetos
objetos
solicitudes
Excepción
Contiene
información
indica
solicitud
satisfactoriamente
Implementación
Define
contiene
métodos
realizan
trabajo
asociado
operación
objeto
servidor
implementaciones
Interfaz
Describe
comportarán
instancias
objeto
operaciones
válidas
objetos
Definición
interfaz
Describe
operaciones
disponibles
tipo
objeto
Invocación
proceso
enviar
solicitud
Método
código
servidor
realiza
trabajo
asociado
operación
métodos
contenidos
implementaciones
Objeto
Representa
persona
sitio
cosa
pieza
software
objeto
realizarse
operaciones
operación
promocionar
objeto
empleado
Instancia
objeto
ocurrencia
tipo
objeto
particular
Referencia
objeto
identificador
instancia
objeto
Lenguaje
lenguaje
definición
definición
interfaces
CORBA
definición
interfaces
IDL
OMG
Operación
acción
cliente
solicitarle
servidor
realice
instancia
objeto
Solicitud
mensaje
enviado
aplicación
cliente
aplicación
servidor
Aplicación
servidora
Contiene
implementaciones
objetos
operaciones
N.
T.
Fábrica
inglés
Factory
interfaz
común
desarrollo
aplicaciones
distribuidas
esquema
aplica-
ción
común
vocabulario
desarrollo
patrones
diseño
Design
Patterns
habitual
literatura
españo-
término
aparezca
inglés
Factory
18-Apendice
12/5/05
16:31
Página
774Dada
referencia
objeto
tipo
Fábrica
cliente
invocarlo
crear
nue-
vo
objeto
CORBA
IDL
lenguaje
independiente
programación
razón
cliente
invoca
directamente
operación
objeto
necesita
proyección
lenguaje
programación
cliente
servidor
cliente
programen
lenguajes
lenguaje
especifica-
ción
abordar
procesamiento
heterogéneo
entornos
múltiples
len-
guajes
plataformas
IDL
independencia
plataforma
Creación
vínculos
lenguaje
compiladores
IDL
convierten
archivo
IDL
OMG
lenguajes
programación
orientados
objetos
tales
Java
Smalltalk
Ada
C++
COBOL
proyección
incluye
definiciones
ti-
pos
datos
interfaces
procedimientos
específicos
lenguaje
acceder
objetos
servicio
interfaz
resguardo
cliente
IDL
esqueleto
IDL
adaptadores
objeto
interfaz
esqueleto
dinámico
interfaz
directo
ORB
Normalmente
clientes
co-
nocen
tiempo
compilación
interfaz
objeto
utilizan
resguardos
invocación
estática
casos
conocimiento
invoca-
ción
dinámica
Resguardo
IDL
Realiza
llamadas
núcleo
ORB
nombre
aplicación
cliente
resguardos
IDL
proporcionan
conjunto
mecanismos
abstraen
funciones
nú-
cleo
ORB
forma
mecanismos
RPC
llamada
procedimiento
remoto
emplearse
aplicaciones
cliente
finales
resguardos
implementación
combinada
ORB
objeto
remoto
parezca
estuviese
enlazada
pro-
ceso
mayoría
casos
compiladores
IDL
generan
bibliotecas
interfaces
espe-
cíficos
lenguajes
completan
interfaz
implementaciones
cliente
objeto
Esqueleto
IDL
Proporciona
código
invoca
métodos
específicos
servidor
es-
queletos
IDL
estáticos
servidor
complementan
sustitutos
IDL
cliente
Incluyen
vínculos
núcleo
ORB
implementaciones
objeto
com-
pletan
conexión
cliente
implementaciones
objeto
Invocación
dinámica
Utilizando
interfaz
invocación
dinámica
dynamic
invocation
in-
terface
DII
aplicación
cliente
invocar
solicitudes
objeto
tiempo
compilación
interfaces
objeto
detalles
interfaz
rellenan
consultando
repositorio
interfaces
fuentes
tiempo
ejecu-
ción
DII
permite
cliente
emitir
mandatos
único
sentido
respuesta
Interfaz
esqueleto
dinámico
Dynamic
Skeleton
Intereface
DSI
Parecido
relación
resguardos
IDL
esqueletos
IDL
estáticos
DSI
ofrece
entrega
dinámica
objetos
Equivale
invocación
dinámica
servidor
Adaptador
objetos
adaptador
objetos
componente
sistema
CORBA
propor-
cionado
vendedor
CORBA
manejar
tareas
generales
relacionadas
ORB
tales
activación
objetos
activación
implementaciones
adaptador
toma
es-
tas
tareas
generales
asocia
implementaciones
métodos
particulares
servidor
B.5
LECTURAS
PÁGINAS
WEB
RECOMENDADAS
KORS90
visión
general
conceptos
orientación
objetos
STRO88
clara
descripción
programación
orientada
objetos
SYND93
proporciona
interesante
perspectiva
conceptos
orientación
objetos
VINO97
visión
general
CORBA
Diseño
orientado
objetos
775
18-Apendice
12/5/05
16:31
Página
775KORS90
Korson
and
McGregor
J.
Understanding
Object-Oriented
Unifying
Paradigm
Com-
munications
of
the
ACM
Septiembre
1990
STRO88
Stroustrup
B.
What
is
Object-Oriented
Programming
IEEE
Software
Mayo
1988
SNYD93
Snyder
A.
The
Essence
of
Objects
Concepts
and
Terms
IEEE
Software
Enero
1993
VINO97
Vinoski
S.
CORBA
Integrating
Diverse
Applications
Within
Distributed
Heterogeneous
Envi-
ronments
IEEE
Communications
Magazine
Febrero
1997
PÁGINAS
WEB
RECOMENDADAS
Object
Management
Group
Consorcio
industrial
promueve
CORBA
tecnologías
objetos
relacionadas
776
Sistemas
operativos
Aspectos
internos
principios
diseño
18-Apendice
12/5/05
16:31
Página
776APÉNDICE
Proyectos
programación
sistemas
operativos
C1
Proyectos
enseñanza
sistemas
operativos
C2
Nachos
Introducción
Nachos
elegir
Nachos
OSP
BACI
C3
Proyectos
investigación
C4
Proyectos
programación
C5
areas
lectura
análisis
19-Apendice
12/5/05
16:31
Página
777N
profesores
creen
proyectos
implementación
investigación
cruciales
compresión
clara
conceptos
sistema
operativo
proyectos
di-
fícil
estudiantes
captar
abstracciones
interacciones
componentes
básicas
sistema
operativo
ejemplo
concepto
es-
tudiantes
difícil
dominar
semáforos
proyectos
refuerzan
con-
ceptos
presentados
libro
estudiante
apreciación
encajan
partes
S.O.
Asimismo
motivar
estudiantes
darles
confianza
capaces
entender
detalles
S.O.
im-
plementarlos
libro
intentado
presentar
conceptos
relacionados
aspectos
internos
SS.OO
clara
proporcionado
numerosos
ejerci-
cios
reforzar
conceptos
profesores
desearán
complementar
material
proyectos
apéndice
proporciona
guía
aspecto
describe
material
apoyo
disponible
sitio
web
profesor
Apéndices
proporcionan
detalles
adicionales
C.1
PROYECTOS
ENSEÑANZA
SISTEMAS
OPERATIVOS
profesor
escoger
siguientes
alternativas
Proyectos
Sistemas
Operativos
Operating
Systems
Projects
OSP
OSP
implementación
sistema
operativo
moderno
entorno
flexible
generar
pro-
yectos
implementación
apropiados
curso
introducción
diseño
SS.OO
OSP
incluye
propuestas
proyectos
Intérprete
Concurrente
Ben-Ari
Ben-Ari
Concurrent
Interpreter
BACI
BACI
si-
mula
ejecución
procesos
concurrentes
proporciona
semáforos
binarios
contador
monitores
BACI
incluye
propuestas
proyecto
utilizadas
reforzar
conceptos
concurrencia
Nachos
OSP
Nachos
entorno
generar
proyectos
implementación
re-
forzar
conceptos
incluyendo
diversas
propuestas
proyectos
Proyectos
investigación
sitio
web
profesor
propone
serie
tareas
investi-
gación
asignar
estudiante
estudie
determinado
tema
Inter-
net
escriba
informe
Proyectos
programación
sitio
web
profesor
proporciona
conjunto
pequeños
proyectos
programación
asignarse
reforzar
conceptos
libro
pudién-
dose
utilizar
lenguaje
proyectos
cubren
amplio
rango
temas
tratados
libro
Tareas
lectura
análisis
sitio
web
profesor
incluye
lista
artículos
importan-
tes
capítulo
asignar
estudiantes
realicen
informe
analizando
artículo
apéndice
proporciona
estudio
temas
apéndice
proporciona
introducción
detallada
OSP
información
obtener
sistema
propues-
tas
proyectos
programación
apéndice
proporciona
tipo
información
BACI
Nachos
documentado
sitio
web
describe
brevemente
próxima
sección
778
Sistemas
operativos
Aspectos
internos
principios
diseño
19-Apendice
12/5/05
16:31
Página
778C.2
NACHOS
INTRODUCCIÓN
NACHOS
Nachos
sistema
operativo
pedagógico
ejecuta
proceso
UNIX
proporcionar
estudiantes
entorno
depuración
reproducible
simule
sistema
operativo
hardwa-
re
subyacente
CHRI93
objetivo
Nachos
proporcionar
entorno
proyectos
suficientemente
realista
mostrar
funcionan
sistemas
operativos
reales
suficien-
temente
simple
estudiantes
puedan
comprenderlo
modificarlo
significativa
Web
disponible
paquete
libre
distribución
incluye
artículo
introducción
código
inicial
sencillo
corresponde
sistema
operativo
funcionamiento
simulador
computador
personal
estación
trabajo
genérico
Propuestas
proyectos
proyectos
enseñan
exploran
áreas
sistemas
operativos
modernos
incluyendo
hilos
concurrencia
multiprogramación
llamadas
siste-
ma
memoria
virtual
TLB
gestionadas
software
sistemas
ficheros
protocolos
red
llamadas
procedimientos
remotos
sistemas
distribuidos
introducción
C++
Nachos
escrito
subconjunto
C++
fácil
aprendizaje
introducción
ayuda
enseñar
subconjunto
programadores
Nachos
utiliza
cientos
universidades
mundo
adaptado
numerosos
sistemas
incluyendo
Linux
FreeBSD
NetBSD
DEC
MIPS
DEC
Alpha
Sun
Solaris
SGI
IRIS
HP-
UX
IBM
AIX
MS-DOS
Apple
Macintosh
planes
futuros
incluyen
adaptación
SimOS
Stanford
simulación
completa
estación
trabajo
SGI
Nachos
disponible
gratuita
sitio
Web
enlace
sitio
web
Wi-
lliamStallings.com/OS/OS5e.html
disponible
conjunto
soluciones
profesores
correo
electrónico
nachos@cs.berkeley.edu
lista
correo
profe-
sores
grupo
noticias
alt.os.nachos
ELEGIR
NACHOS
OSP
BACI
profesor
dispuesto
dedicar
tiempo
adaptar
simuladores
en-
torno
local
disponible
estudiantes
elección
dependerá
objetivos
opinión
personal
profesor
enfoque
proyecto
concurrencia
BACI
elección
ade-
cuada
BACI
proporciona
entorno
excelente
estudio
complejidades
sutilezas
semáforos
monitores
programación
concurrente
cambio
profesor
desea
estudiantes
exploren
diversos
mecanismos
S.O.
in-
cluyendo
programación
concurrente
espacios
direcciones
planificación
memoria
virtual
siste-
ficheros
redes
etcétera
utilizar
Nachos
OSP
libro
incluido
apéndice
OSP
mejores
vehículos
disponibles
soporte
proyectos
SS.OO
OSP
utiliza
100
sitios
proporciona
cantidad
apoyo
documentación
inconveniente
potencial
sistema
proyectos
propuestos
lista
correo
asociada
gratuitos
pequeño
manual
usua-
rio
estudiantes
deberían
comprar
compensar
puntos
fuertes
Proyectos
programación
sistemas
operativos
779
19-Apendice
12/5/05
16:31
Página
779de
entorno
similar
Nachos
sistema
utilizado
proporciona
soporte
docu-
mentación
propuestas
proyectos
anima
profesor
estudie
apéndice
inte-
resado
compare
artículo
introducción
Nachos
documentación
disponible
si-
tio
web
Nachos
C.3
PROYECTOS
INVESTIGACIÓN
efectiva
reforzar
conceptos
básicos
curso
enseñar
estudiantes
técnicas
investigación
asignarles
proyecto
investigación
tipo
proyecto
involucrar
búsqueda
bibliografía
Web
productos
comerciales
actividades
investigación
laboratorio
esfuerzos
estandarización
proyectos
asignarse
equipos
caso
proyectos
pequeños
forma
individual
caso
solicitar
alumno
tipo
propuesta
proyecto
principio
curso
dando
profesor
tiempo
evaluar
propuesta
tema
nivel
dificultad
apropiados
documentación
entregada
estudiantes
proyectos
investigación
debería
incluir
formato
propuesta
formato
informe
planificación
plazos
intermedios
finales
lista
posibles
temas
proyectos
estudiantes
seleccionar
temas
lista
diseñar
proyecto
equi-
parable
sitio
web
profesor
incluye
formato
sugerido
propuesta
informe
lista
posibles
temas
investigación
desarrollada
profesor
N.
Nguyen
Universidad
George
Mason
C.4
PROYECTOS
PROGRAMACIÓN
alternativa
desarrollo
fragmentos
SO
utilizando
OSP
Nachos
centrándose
concurrencia
utilizando
BACI
asignar
proyectos
programación
requieren
infra-
estructura
ventajas
proyectos
programación
frente
entorno
traba-
jo
apoyo
OSP
BACI
profesor
elegir
variedad
conceptos
relacionados
SO
asignar
proyectos
encajen
entorno
trabajo
apoyo
estudiantes
programar
proyecto
computador
disponible
cual-
quier
lenguaje
apropiado
independientes
plataforma
lenguaje
profesor
necesita
descargar
instalar
configurar
infraestructura
flexibilidad
tamaño
proyectos
proyectos
proporcionan
estudiantes
sensación
éxito
estudiantes
capacidad
me-
habilidades
organizativas
retrasarse
proyectos
normalmente
proporcio-
nan
beneficio
global
mejores
estudiantes
proyectos
pequeños
proporción
conceptos
código
asignar
número
oportunidad
tratar
temas
Globalmente
ventaja
inclinar-
proyectos
pequeños
sitio
web
profesor
contiene
pequeños
proyectos
destinado
completarse
semana
780
Sistemas
operativos
Aspectos
internos
principios
diseño
19-Apendice
12/5/05
16:31
Página
780satisfactorio
estudiante
profesor
proyectos
desarrolló
Stephen
Taylor
Instituto
Politécnico
Worcester
utilizado
mejorado
proyectos
curso
sistemas
operativos
docena
libro
bosquejan
proyectos
programación
envergadura
Capítulos
sitio
web
profesor
proporciona
conjunto
gradual
detallado
instrucciones
proyectos
C.5
TAREAS
LECTURA
ANÁLISIS
excelente
reforzar
conceptos
curso
proporcionar
estudiantes
experien-
cia
investigación
asignarles
artículos
bibliografía
tema
lean
analicen
sitio
web
profesor
incluye
propuesta
artículos
asignar
estudiantes
organiza-
capítulos
artículos
disponibles
Internet
biblioteca
técnica
universidad
sitio
web
profesor
incluye
documento
ejercicios
propuestos
Proyectos
programación
sistemas
operativos
781
19-Apendice
12/5/05
16:31
Página
78119-Apendice
12/5/05
16:31
Página
782APÉNDICE
OSP
entorno
proyectos
sistemas
operativos
D1
Introducción
D2
Aspectos
innovadores
OSP
D3
Comparación
herramientas
docentes
sistemas
operativos
Michael
Kifer
and
Scott
A.
Smolka
Departamento
Informática
SUNY
Stony
Brook
kifer
sas}@cs.sunysb.edu
20-Apendice
12/5/05
16:32
Página
783D.1
INTRODUCCIÓN
OSP2
OSP
implementación
sistema
operativo
moderno
entorno
flexible
generar
proyectos
implementación
apropiados
curso
introductorio
diseño
siste-
operativos
KEFE92
objetivo
complementar
libro
texto
introducto-
rio
sistemas
operativos
contiene
suficientes
proyectos
semestres
proyectos
expo-
nen
estudiantes
características
esenciales
sistemas
operativos
aislan
aspectos
nivel
dependientes
máquina
semestre
es-
tudiantes
aprender
estrategias
reemplazo
páginas
gestión
memoria
virtual
estrategias
planificación
procesador
optimizaciones
tiempo
búsqueda
disco
aspectos
relacionados
diseño
sistemas
operativos
tiempo
sistemas
proporcionan
entornos
adecuados
crear
administrar
proyectos
implementación
estudiantes
automatizando
trabajo
rutinario
profesor
proyectos
organi-
zar
orden
deseado
forma
progresen
consistente
material
clases
estudiantes
programan
proyectos
OSP
lenguaje
programación
Java
Adicional-
mente
sistema
original
OSP
basa
lenguaje
programación
disponible
sistema
OSP
utilizar
entorno
Windows
entor-
UNIX
Linux
sistema
OSP
original
trabaja
UNIX
Linux
modelo
sistema
operativo
subyacente
OSP
moderno
características
profeso-
res
prefieren
estudiantes
programen
C.
necesidad
satisfecha
sistema
OSP
original
OSP2
OSP
compuestos
módulos
cabo
servicio
sistema
operativo
básico
planificación
dispositivos
planificación
procesador
manejo
interrupciones
gestión
ficheros
gestión
memoria
gestión
procesos
gestión
recursos
comunicación
procesos
Omitiendo
selectivamente
subconjunto
módulos
profesor
generar
proyecto
estudiantes
tengan
implementar
partes
restantes
proceso
completamente
automatizado
proyectos
organi-
zar
orden
deseado
forma
progresen
consistente
material
clases
proyecto
formado
módulo
carga
parcial
módulos
estándar
estudiantes
enlazan
implementaciones
módulos
asignados
resultado
sistema
operativo
completo
parcialmente
implementado
estudiantes
proyectos
traen
plantillas
módulos
contienen
declaraciones
estructuras
datos
requeridas
módulos
asignados
ficheros
asignación
proyecto
estudiantes
rellenar
cuerpos
procedimientos
forma
fiche-
ros
plantilla
ayudan
eliminar
rutina
escritura
código
profesor
estudiantes
núcleos
OSP2
OSP
simuladores
ofrecen
ilusión
sistema
computa-
ción
colección
dinámica
procesos
usuario
multiprogramarse
resto
módulos
OSP2
OSP
construyen
responder
apropiadamente
eventos
generados
simulador
guían
sistema
operativo
simulador
comprende
interacción
módulos
frecuentemente
detectar
respuesta
errónea
módulo
evento
simulado
dichos
casos
simulador
terminará
forma
ordenada
ejecución
programa
en-
viando
mensaje
error
significativo
usuario
indicando
encontrar
error
utilidad
sirve
herramienta
depuración
estudiante
herramienta
do-
cente
profesor
asegura
programas
estudiante
prácticamente
libres
errores
784
Sistemas
operativos
Aspectos
internos
principios
diseño
20-Apendice
12/5/05
16:32
Página
784Se
ajustar
dinámicamente
dificultad
flujos
trabajo
generados
simulador
manipulación
parámetros
simulación
forma
sencilla
efectiva
comprobar
calidad
programas
estudiantes
utilidades
permiten
estudiantes
depurar
programas
interaccionando
OSP2
OSP
simulación
modelo
subyacente
OSP2
OSP
clon
sistema
operativo
específico
contrario
abstracción
características
encontradas
comúnmente
sistemas
aun-
ocasiones
tendencia
UNIX
módulos
OSP2
OSP
diseñaron
esconder
aspectos
nivel
encontrar
diseño
implementación
sistemas
operativos
módulos
tratan
aspectos
importantes
sistemas
modernos
vida
real
implementación
adapta
adecuadamente
componente
proyectos
curso
introductorio
sistemas
operativos
OSP2
describe
libro
publicado
Addison-Wesley
finales
2004
Introduction
to
Operating
System
Design
and
Implementation
The
OSP
Approach
Michael
Kifer
Scott
A.
Smolka
Addison-Wesley
OSP
original
documenta
libro
disponible
editorial
OSP
An
Environment
for
Operating
System
Projects
Michael
Kifer
Scott
A.
Smolka
Addi-
son-Wesley
ISBN
0-201-54887-9
1991
sitio
web
OSP
encuentran
disponibles
manuales
introductorios
profesores
http://www.cs.sunysb.edu/osp
usuarios
registrar
sitio
verificar
profesores
D.2
ASPECTOS
INNOVADORES
OSP
principales
aspectos
innovadores
OSP
OSP
siguientes
módulos
estudiantes
escriben
curso
semestre
construyen
responder
apropiadamente
eventos
generados
simulador
dirige
sistema
operativo
estudiantes
ajustar
dificultad
flujos
trabajos
generados
simulador
valores
parámetros
simulación
requeridos
conduce
forma
sencilla
efectiva
estudiantes
comprobar
calidad
programas
utilidades
permiten
estudiantes
depurar
programas
inte-
raccionando
OSP2
OSP
simulación
OSP
proporciona
profesor
entorno
adecuado
generador
proyectos
OSP
crear
proyectos
implementación
generador
proyectos
genera
módulo
carga
parcial
módulos
OSP
estándar
estudiantes
enlazar
imple-
mentaciones
módulos
asignados
resultado
sistema
operativo
comple-
to
parcialmente
implementado
estudiante
OSP
proporciona
generador
proyectos
viene
equipado
adicionalmente
proyectos
preensamblados
minimiza
esfuerzo
profesor
requerido
desarrollar
proyectos
estudiantes
Adicionalmente
generador
proyectos
crea
automáticamente
ficheros
plantilla
contienen
cabeceras
procedimientos
declaraciones
estructuras
datos
requeridas
módulos
asignados
ficheros
asignación
proyecto
estudiantes
rellenar
cuerpos
procedimientos
asegura
interfaz
consistente
OSP
elimina
rutina
escritura
código
profesor
estudiantes
OSP
entorno
proyectos
sistemas
operativos
785
20-Apendice
12/5/05
16:32
Página
785•
OSP
OSP
incluyen
sistemas
envío
proyectos
opcionales
profesores
utilizar
estudiantes
envíen
trabajos
forma
conveniente
se-
gura
sistema
entrega
compilará
ficheros
fuente
estudiantes
ejecutará
ejecutables
parámetro
ficheros
fuente
módulos
implementados
estudiantes
salida
fase
compilación
ejecuciones
simulación
colocan
directorio
entregas
curso
estudiantes
acceso
ficheros
salida
forma
puedan
alterarse
maliciosamente
estudiantes
entregar
programas
número
entre-
ga
sobrescribe
anteriores
entrega
asociada
sello
tiempo
forma
profesor
verificar
plazos
entrega
simuladores
OSP
OSP
monitorizan
cuidadosamente
comportamiento
tiempo
real
módulos
implementados
estudiantes
casos
mostrar
men-
saje
advertencia
comportamiento
módulo
estudiante
desvíe
norma
ejemplo
estudiante
escrito
módulo
maneja
peticiones
usuarios
simulador
comprobará
bloque
peticiones
Request
Block
IORB
insertado
adecuadamente
cola
dispositivos
apropiada
simulador
enviará
mensaje
descriptivo
avisará
estudiante
petición
manejada
correctamente
monitorización
llevada
cabo
simulador
constituye
ayuda
depuración
in-
teractiva
valiosa
estudiante
cumple
ejecución
solu-
ción
estudiante
realiza
mensaje
advertencia
código
es-
tudiante
funcionalmente
correcto
OSP2
OSP
proporcionan
amplia
interfaz
depuración
simulador
permite
estudiantes
periódicamente
vean
tomen
instantánea
sistema
simulación
información
mostrada
instantánea
incluye
contenidos
ta-
bla
marcos
memoria
principal
tablas
dispositivos
conjunto
BCP
Bloque
Control
Proceso
colas
eventos
instantánea
ofrece
usuario
oportunidad
cambiar
parámetros
simulación
dichos
parámetros
snaps-
hot_interval/
modificarlo
usuario
indicar
frecuencia
si-
mulación
mostrarse
sistema
OSP
OSP
documentados
completamente
libros
texto
libros
propor-
cionan
estudiantes
información
necesitan
completar
trabajos
inclu-
yendo
especificaciones
detalladas
módulos
instrucciones
compilar
ejecutar
entregar
trabajos
manual
profesor
añade
información
instalar
sistema
instrucciones
utilizar
sistema
entrega
sitio
web
OSP
http://www.cs.sunysb.edu/osp/
contiene
prácticas
programa-
ción
OSP
OSP
asignado
profesores
estudiantes
sitio
web
OSP
proporciona
usuarios
registrados
foro
discusión
propósito
foro
servir
discusión
OSP
usuarios
informar
comunidad
OSP
cambio
software
documentación
ejemplo
resoluciones
errores
mejoras
versiones
futuras
D.3
COMPARACIÓN
HERRAMIENTAS
DOCENTES
SISTEMAS
OPERATIVOS
herramientas
docentes
sistemas
operativos
clasificar
grupos
basa-
das
simulación
ejemplo
sistema
operativo
Toy
Berkeley
Nachos
MPX
ba-
786
Sistemas
operativos
Aspectos
internos
principios
diseño
20-Apendice
12/5/05
16:32
Página
786sadas
código
fuente
sistemas
operativos
reales
ejecutan
directamente
máquina
desnuda
ejemplo
MINIX
TANE97
XINU
COME84
Linux
OSP
cae
claramente
pri-
mera
categoría
considerar
categorías
herramientas
docentes
suponen
ni-
chos
educación
sistemas
operativos
software
máquina
desnuda
tie-
ne
ventaja
permite
estudiante
íntimamente
detalles
nivel
arquitectura
máquina
produce
sensación
inmediatez
presente
soft-
ware
basado
simulación
software
basado
simulación
libera
intencionadamen-
estudiante
aspectos
básicos
arquitectura
particular
máquina
permite
estudiante
centrarse
implementación
conceptos
sistemas
operativos
discutidos
clase
texto
curso
herramientas
basadas
simulación
OSP
OSP2
distinguen
si-
guiente
combinación
atributos
Flexibilidad
profesores
completa
libertad
asignar
proyectos
temas
favoritos
orden
proyecto
atado
estrategia
disco
específica
planificación
procesador
concreta
gestión
memoria
determina-
política
evitar
interbloqueos
aspectos
diseño
específicos
Grado
realismo
ofrecido
simulador
OSP2
OSP
basan
simulación
creí-
ble
eventos
sistema
operativo
típico
profesor
adecua-
damente
equipado
evaluar
calidad
implementaciones
estudiantes
simu-
lador
incorporada
serie
comprobaciones
seguridad
difícil
falsificar
resultados
simplifican
verificación
proyectos
estudiante
Facilidad
experiencia
mostrado
OSP2
OSP
relativamente
fáciles
utilizar
perspectiva
profesor
estudiante
profesor
quita
carga
administrativa
asignar
mano
proyectos
genera
automáticamente
ge-
nerador
proyectos
contienen
información
necesaria
estudiante
comple-
asignaciones
interfaz
depuración
simulador
decrementa
significativamen-
tiempo
estudiante
necesita
utilizar
completar
práctica
Finalmente
sistema
entrega
proyectos
vida
fácil
profesor
estudiante
Obsérvese
sitio
web
OSP
mencionado
anteriormente
dirigido
exclusivamente
profesores
cursos
sistema
operativo
utilizan
software
OSP2
OSP
particu-
lar
orientado
estudiantes
dichos
cursos
usuario
registrado
autenticarse
profesor
acceder
información
OSP
entorno
proyectos
sistemas
operativos
787
20-Apendice
12/5/05
16:32
Página
78720-Apendice
12/5/05
16:32
Página
788APÉNDICE
BACI
sistema
programación
concurrente
Ben-Ari*†
E1
Introducción
E2
BACI
Visión
general
sistema
Construcciones
concurrentes
BACI
obtener
BACI
E3
Ejemplos
programas
BACI
E4
Proyectos
BACI
Implementación
primitivas
sincronización
Semáforos
monitores
implementaciones
E5
Mejoras
sistema
BACI
Hill
Bynum
College
of
William
and
Mary
Tracy
Camp
Colorado
Scholl
of
Mines
trabajo
financiado
parcialmente
National
Science
Foundation
NSF
NCR-9702449
21-Apendice
12/5/05
16:32
Página
789E.1
INTRODUCCIÓN
Capítulo
introducen
conceptos
concurrencia
ej.
exclusión
mutua
problema
sección
crítica
proponen
técnicas
sincronización
ej.
semáforos
monitores
paso
men-
sajes
aspectos
interbloqueo
hambruna
programas
concurrentes
exponen
Ca-
pítulo
énfasis
creciente
computación
paralela
distribuida
entender
concurrencia
sincronización
necesario
entendimiento
profundo
conceptos
necesita
experiencia
práctica
escribiendo
programas
concurrentes
opciones
deseada
experiencia
directa
escri-
bir
programas
concurrentes
lenguaje
programación
concurrente
conocido
Pascal
Concurrente
Modula
Ada
lenguaje
programación
SR
experimentar
diversas
técnicas
sincronización
debemos
aprender
sintaxis
lenguajes
programa-
ción
concurrente
escribir
programas
concurrentes
usando
llamadas
siste-
ma
sistema
operativo
UNIX
fácil
distraigamos
objetivo
entender
programación
concurrente
detalles
peculiaridades
sistema
operativo
par-
ticular
ej.
detalles
llamadas
sistema
semáforos
UNIX
escri-
bir
programas
concurrentes
lenguaje
desarrollado
específicamente
proporcionar
expe-
riencia
conceptos
concurrencia
intérprete
concurrente
Ben-Ari
BACI
BYNU96
lenguaje
ofrece
variedad
técnicas
sincronización
sintaxis
normalmente
familiar
lenguajes
desarrollados
específicamente
proporcio-
nar
experiencia
conceptos
concurrencia
opción
obtener
deseada
expe-
riencia
directa
Sección
E.2
contiene
visión
general
sistema
BACI
explica
obtener
sistema
Sección
E.3
contiene
ejemplos
programas
BACI
Sección
E.4
contiene
expo-
sición
proyectos
obtener
experiencia
práctica
concurrencia
niveles
implementa-
ción
programación
Finalmente
Sección
E.5
contiene
descripción
cambios
sistema
BACI
progreso
planeados
E.2
BACI
VISIÓN
GENERAL
SISTEMA
BACI
descendiente
directo
modificación
Ben-Ari
Pascal
secuencial
Pascal-S
Pascal-S
subconjunto
Pascal
Wirth
ficheros
INPUT
OUTPUT
conjun-
tos
variables
puntero
sentencias
goto
Ben-Ari
tomó
lenguaje
Pascal-S
construcciones
programación
concurrente
tales
construcción
cobegin
coend
tipo
varia-
ble
semáforo
operaciones
wait
signal
BEN82
BACI
modificación
Pascal-S
características
sincronización
ej.
monitores
mecanismos
encapsulación
asegurar
usuario
modificar
variable
forma
inapropiada
ej.
variable
semáforo
modificada
funciones
semáforo
BACI
simula
ejecución
concurrente
procesos
soporte
siguientes
técnicas
sin-
cronización
semáforos
generales
semáforos
binarios
monitores
sistema
BACI
compone
subsistemas
ilustra
Figura
E.1
subsistema
compilador
compila
progra-
ma
usuario
código
objeto
intermedio
denominado
PCODE
compiladores
disponi-
bles
sistema
BACI
correspondientes
tipos
populares
lenguajes
cursos
introduc-
ción
programación
sintaxis
compiladores
similar
Pascal
estándar
programas
BACI
utilizan
sintaxis
Pascal
denotan
nombre-prog.pm
sintaxis
compilador
similar
C++
estándar
programas
BACI
denotan
nombre-prog.cm
790
Sistemas
operativos
Aspectos
internos
principios
diseño
21-Apendice
12/5/05
16:32
Página
790Ambos
compiladores
crean
archivos
compilación
nombre-prog.lst
nombre-
prog.pco
subsistema
sistema
BACI
intérprete
ejecuta
código
objeto
creado
compilador
palabras
intérprete
ejecuta
nombre-prog.pco
núcleo
intérprete
planificador
expulsivo
ejecución
planificador
alterna
aleatoriamente
procesos
concurrentes
simulando
ejecución
paralela
procesos
concurrentes
intérprete
ofrece
opciones
depuración
tales
ejecución
paso
paso
desensamblar
instrucciones
PCODE
mostrar
posiciones
almacenamiento
programa
CONSTRUCCIONES
CONCURRENTES
BACI
resto
apéndice
centramos
compilador
sintaxis
similar
C++
estándar
Lla-
mamos
compilador
sintaxis
similar
C++
incluye
herencia
en-
capsulación
características
programación
orientada
objetos
sección
damos
visión
general
construcciones
concurrentes
BACI
acuda
guías
usuario
sitio
Web
BACI
obtener
detalles
sintaxis
tipo
Pascal
BACI
cobegin
lista
procesos
ejecutar
concurrentemente
indicarse
bloque
cobegin
Tales
bloques
anidarse
aparecer
programa
principal
cobegin
proc1
proc2
procN
sentencias
PCODE
crea
compilador
bloque
entrelazadas
intérprete
orden
arbitrario
aleatorio
múltiples
ejecuciones
programa
contenga
bloque
cobegin
aparentarán
deterministas
Semáforos
semáforo
BACI
variable
intde
valor
negativo
ac-
cedida
llamadas
semáforos
definidas
continuación
semáforo
binario
BACI
BACI
sistema
programación
concurrente
Ben-Ari
791
bacc
bapas
Editor
texto
Compiladores
Intérprete
bainterp
Errores
compilación
Fichero
objeto
pgrmname.pco
Listado
compilación
pgrmname.lst
Entrada
teclado
Resultado
ejecución
correcta
Compilación
satisfactoria
pgrmname.cm
pgrmname.pm
bacc
pgrmname
bapas
pgrmname
bainterp
pgrmname
Resultado
ejecución
incorrecta
Figura
E.1
Visión
general
sistema
BACI
21-Apendice
12/5/05
16:32
Página
791que
toma
valores
define
subtipo
binarysem
tipo
semaphore
compilación
ejecución
compilador
intérprete
cumplir
restricciones
variable
binarysem
tomar
valores
tipo
semáforo
negativo
llamadas
semáforos
BACI
incluyen
initialsem(semaphore
sem
in
expresion
p(semaphore
sem).Si
valor
semes
cero
intérprete
decrementa
semy
re-
torna
permitiendo
llamó
pcontinúe
valor
semes
cero
intérpre-
llamó
duerma
mandato
wait
acepta
sinónimo
p.
v(semaphore
sem).Si
valor
sem
cero
procesos
durmien-
do
sem
despierta
procesos
procesos
esperando
sem
in-
crementa
sem
caso
llama
permite
continuar
BACI
ajusta
propuesta
semáforos
original
Dijkstra
escoger
aleatoriamente
proceso
despertar
llega
señal
mandato
signalse
acepta
sinónimo
v.
Monitores
BACI
soporte
concepto
monitor
propuso
Hoare
HOAR74
cier-
tas
restricciones
implementación
basa
trabajo
PRAM84
monitor
bloque
C++
bloque
definido
procedimiento
función
propiedades
adi-
cionales
ejemplo
variables
condición
BACI
monitor
declarado
nivel
global
externo
anidado
bloque
monitor
funciones
procedimientos
monitor
utilizan
construcciones
controlar
concurrencia
variables
condición
waitc
esperar
condición
signalc
señalar
condición
condición
jamás
real-
mente
valor
esperar
señalar
proceso
monitor
esperar
condición
suceda
señalar
condición
dada
sucede
llamadas
waitc
signalc
llamadas
sintaxis
semántica
waitc(condition
cond
int
prio).El
proceso
monitor
proceso
exterior
invoca
proceso
monitor
bloquea
condición
cond
asigna
prioridad
prio
waitc(condition
cond
llamada
semántica
llamada
waitc
asigna
prioridad
defecto
10
signalc(condition
cond).Despertar
proceso
esté
esperando
condque
prioridad
alta
menor
valor
proceso
espera
cond
BACI
cumple
requisito
reanudación
inmediata
palabras
señala
proceso
esperando
condición
prioridad
procesos
intenten
entrar
monitor
construcciones
concurrentes
compilador
C-
BACI
proporciona
construc-
ciones
concurrentes
nivel
utilizarse
crear
primitivas
control
concu-
rrencia
función
define
atómica
función
expulsable
palabras
intérprete
interrumpirá
función
atómica
cambio
contexto
BACI
función
sus-
pend
proceso
invoca
duerma
función
reviveretoma
proceso
suspendido
OBTENER
BACI
sistema
BACI
guías
usuario
compiladores
descripcio-
nes
detalladas
proyectos
disponible
sitio
web
BACI
enlace
sitio
web
792
Sistemas
operativos
Aspectos
internos
principios
diseño
21-Apendice
12/5/05
16:32
Página
792desde
WilliamStallings.com/OS/OS5e.html
sistema
BACI
escrito
fácil-
mente
portable
sistema
BACI
compilado
Linux
RS/6000
AIX
Sun
CYGWIN
Windows
mínimas
modificaciones
fichero
Makefile
fi-
chero
README
distribución
indican
detalles
instalación
plataforma
dada
contactar
autores
bynum@cs.wm.edu
tcamp@mines.edu
E.3
EJEMPLOS
PROGRAMAS
BACI
Capítulos
expusieron
problemas
clásicos
sincronización
ej.
problema
lectores
escritores
problema
filósofos
comensales
sección
ilustra
sistema
BACI
programas
ejemplo
ilustra
ejecución
determinista
procesos
concu-
rrentes
sistema
BACI
Considere
programa
const
int
int
void
incr(char
id
int
for(i
cout
id
cout
id
endl
main
cobegin
incr(’A
incr(’B
incr(’C
cout
suma
endl
Observe
programa
precedente
procesos
creados
ejecutaran
secuencia
suma
producida
15
ejecución
concurrente
sentencia
n=
lugar
valores
suma
compilar
programa
precedente
bacc
ejecutó
archivo
PCODE
bainterp
ejecución
produjo
sumas
15
ejemplo
ejecución
producida
intérprete
BACI
Fichero
fuente
incremen.cm
Vie
Ago
16:51:00
1997
CB
CB
=3
BACI
sistema
programación
concurrente
Ben-Ari
793
21-Apendice
12/5/05
16:32
Página
793A
=3
6C
=3
BC
10
10
311
12
B5
13A
14
suma
14
necesitan
instrucciones
máquina
especiales
sincronizar
acceso
procesos
memoria
principal
común
instrucciones
especiales
construyen
protocolos
exclusión
mutua
primitivas
sincronización
BACI
intérprete
interrumpirá
cam-
bio
contexto
función
definida
atómica
característica
permite
usuarios
im-
plementar
instrucciones
máquina
especiales
nivel
ejemplo
programa
implementación
BACI
función
testsetdefinida
Sección
5.2
Instrución
test
and
set
Stallings
Sección
5.2
atomic
int
testset(int
if
return
else
return
testset
implementar
protocolos
exclusión
mutua
muestra
programa
programa
implementación
BACI
programa
exclusión
mutua
basado
instrucción
test
and
set
programa
lanza
procesos
concurrentes
proceso
soli-
cita
exclusión
mutua
10
int
cerrojo
const
int
Repeticiones
10
void
proc(int
id
int
while(i
Repeticiones
794
Sistemas
operativos
Aspectos
internos
principios
diseño
21-Apendice
12/5/05
16:32
Página
794while
testset(cerrojo
esperar
entrar
sección
crítica
cout
id
abandonar
sección
crítica
cerrojo
i++
main
cobegin
proc(0
proc(1
proc(2
siguientes
programas
solución
BACI
problema
productor
consumidor
buf-
fer
acotado
semáforos
véase
Figura
5.13
ejemplo
productores
consumidores
tamaño
buffer
enumeran
detalles
programa
problema
incluyen
archivos
definen
implementación
buffer
acotado
solución
problema
productor
consumidor
buffer
acotado
Stallings
Figura
5.13
Introducir
maquinaria
buffer
acotado
include
boundedbuff.inc
const
int
RangoValores
20
producirán
enteros
rango
19
semaphore
ts
acceso
exclusivo
terminal
salida
semaphore
exclusión
mutua
buffer
semaphore
número
elementos
consumibles
buffer
semaphore
número
espacios
vacíos
buffer
int
producir(char
id
int
tmp
tmp
random(RangoValores
wait(ts
cout
Productor
id
produce
tmp
endl
signal(ts
return
tmp
void
consumir(char
id
int
wait(ts
cout
Consumidor
id
consume
endl
signal(ts
BACI
sistema
programación
concurrente
Ben-Ari
795
21-Apendice
12/5/05
16:32
Página
795
void
productor(char
id
int
for
producir(id
wait(e
wait(s
anyadir(i
signal(s
signal(n
void
consumidor(char
id
int
for
wait(n
wait(s
tomar
signal(s
signal(e
consumir(id
main
initialsem(s,1
initialsem(n,0
initialsem(e
TamanyoDeBuffer
initialsem(ts,1
cobegin
productor(’A
productor
consumidor(’x
consumidor
consumidor
boundedbuff.inc
fichero
incluir
buffer
acotado
const
int
TamanyoDeBuffer
int
buffer[TamanyoDeBuffer
int
in
índice
buffer
añadir
int
out
índice
buffer
tomar
796
Sistemas
operativos
Aspectos
internos
principios
diseño
21-Apendice
12/5/05
16:32
Página
796void
anyadir(int
añadir
buffer
asume
desbordamiento
evita
semáforos
condiciones
externos
buffer[in
in
in
TamanyoDeBuffer
int
tomar
devuelve
elemento
buffer
asume
extenuación
evita
semáforos
condiciones
externos
int
tmp
tmp
buffer[out
out
out
TamanyoDeBuffer
return
tmp
ejemplo
ejecución
solución
precedente
buffer
acotado
BACI
Fichero
fuente
semprodcons.cm
Vie
Ago
12:36:55
1997
Productor
produce
Productor
produce
13
Productor
produce
12
Productor
produce
Productor
produce
17
Consumidor
consume
Consumidor
consume
13
Productor
produce
16
Productor
produce
11
Consumidor
consume
12
Consumidor
consume
Consumidor
consume
17
Productor
produce
E.4
PROYECTOS
BACI
sección
exploramos
tipos
generales
proyectos
implementarse
BACI
examinamos
proyectos
involucran
implementación
operaciones
nivel
ej.
instrucciones
máquina
especiales
utilizan
sincronizar
acceso
procesos
BACI
sistema
programación
concurrente
Ben-Ari
797
21-Apendice
12/5/05
16:32
Página
797memoria
principal
común
examinamos
proyectos
construyen
operacio-
nes
nivel
ej.
problemas
clásicos
sincronización
encontrarse
información
proyectos
BYNU96
descripciones
proyectos
incluidas
distribu-
ción
BACI
profesores
deseen
acceso
soluciones
proyectos
contactar
autores
proyectos
expuestos
sección
problemas
propuestos
Capítulo
Apéndice
implementados
BACI
IMPLEMENTACIÓN
PRIMITIVAS
SINCRONIZACIÓN
Implementación
instrucciones
máquina
numerosas
instrucciones
máquina
pue-
den
implementadas
BACI
ejemplo
implementarse
instrucción
exchange
inter-
cambio
dada
Figura
5.2
operación
compare-and-swap
comparar
intercambiar
descrita
HERL90
implementación
instrucciones
basarse
función
atómica
devuelva
valor
entero
ponerse
prueba
implementación
instrucción
máquina
cons-
truyendo
protocolo
exclusión
mutua
base
operación
nivel
Implementación
semáforos
imparciales
FIFO
manipulación
semáforos
BACI
implementada
orden
extracción
aleatorio
semáforos
defini-
originalmente
Dijkstra
Sección
5.3
política
justa
FIFO
implementar
semáforos
política
extracción
FIFO
BACI
mínimo
imple-
mentación
debería
definir
siguientes
procedimientos
CreateSemaphores()para
inicializar
código
programa
InitSemaphore(int
sem_index
inicializar
semáforo
representado
sem_index
FIFOP(int
sem_index
FIFOV(int
sem_index
código
precisa
escrito
implementación
sistema
controlar
posibles
errores
palabras
diseñador
semáforo
responsable
producir
có-
digo
robusto
admita
utilizado
usuarios
ignorantes
estúpidos
maliciosos
SEMÁFOROS
MONITORES
IMPLEMENTACIONES
problemas
clásicos
programación
concurrente
problema
productor
consumidor
filósofos
comensales
problema
lectores
escritores
prioridades
proble-
ma
barbería
problema
fumadores
problemas
implementados
BACI
sección
exponen
proyectos
estándar
semáforos
monitores
implementados
BACI
ayudar
entendimiento
conceptos
concurrencia
sincronización
Aes
Bes
Semáforos
esbozo
programa
BACI
declaraciones
semáforos
globales
void
798
Sistemas
operativos
Aspectos
internos
principios
diseño
21-Apendice
12/5/05
16:32
Página
798SOLAMENTE
llamadas
void
llamadas
main
inicialización
semáforos
cobegin
complete
programa
utilizando
mínimo
número
semáforos
generales
proce-
sos
terminen
orden
copia
copia
copia
B.
Utilice
opción
intérprete
mostrar
terminación
procesos
variaciones
proyecto
ejemplo
procesos
concurrentes
terminen
or-
den
ABAA
procesos
concurrentes
terminen
orden
AABABABB
Utilizando
semáforos
binarios
Repita
proyecto
utilizando
semáforos
binarios
Expli-
solución
necesitan
sentencias
IF-THEN-ELSE
asignación
necesarias
solución
proyecto
previo
palabras
explique
caso
utilizar
Espera
activa
versus
semáforos
Compare
prestaciones
solución
exclusión
mutua
utilice
espera
activa
ej.
instrucción
testset
solución
utilice
semáforos
ejem-
plo
compare
solución
semáforos
solución
testset
proyecto
ABAAB
expuesto
previamente
caso
realice
número
ejecuciones
digamos
1000
obtener
me-
jores
estadísticas
Razone
resultados
obtenidos
explicando
implementación
prefe-
rible
Semáforos
monitores
espíritu
Problema
5.17
implemente
BACI
monitor
uti-
lizando
semáforos
generales
implemente
semáforo
general
usando
monitor
Semáforos
generales
binarios
Pruebe
semáforos
generales
semáforos
binarios
potentes
implementando
tipo
semáforo
viceversa
Tictac
Reloj
Proyecto
Monitor
forma
similar
Problema
7.17
SILB02
escriba
programa
contenga
monitor
RelojDespertador
monitor
variable
int
lla-
mada
ElReloj(inicializada
cero
funciones
Tic().Esta
función
incrementa
ElReloj
llama
cosas
signalc
necesario
int
Alarma(int
id
int
delta).Esta
función
bloquea
llamante
identificador
id
mínimo
deltatics
ElReloj
BACI
sistema
programación
concurrente
Ben-Ari
799
21-Apendice
12/5/05
16:32
Página
799El
programa
principal
funciones
void
TicTac().Este
procedimiento
llama
Tic()en
bucle
infinito
void
Hilo(int
id
int
miDelta).Esta
función
llama
Alarma()en
bucle
infinito
dotar
monitor
cualesquiera
variables
necesite
monitor
capaz
acomodar
alarmas
simultáneas
problema
panadero
popular
reciente
popularidad
panadería
clientes
esperar
servidos
gestionar
servicio
panadero
instalar
sistema
tiquets
asegure
clientes
servidos
turno
Construya
im-
plementación
BACI
sistema
tiques
E.5
MEJORAS
SISTEMA
BACI
sistema
BACI
mejorado
diversos
aspectos
añadido
interfaz
gráfica
usuario
GUI
versión
UNIX
BACI
interfaz
permite
usuario
editar
compilar
interpretar
programas
BACI
sistema
Ventanas
coloreadas
ilustran
ejecución
programas
BACI
interfaz
disponible
http://www.mines.edu/fs_home/tcamp/GUI/.
busca
GUI
alternativa
siga
leyendo
creado
versión
distribuida
BACI
similar
sucede
pro-
gramas
concurrentes
difícil
probar
corrección
programas
distribuidos
im-
plementación
BACI
distribuido
permitirá
fácil
implementación
programas
distribui-
probar
corrección
programa
distribuido
BACI
distribuido
utilizarse
comprobar
prestaciones
programa
BACI
distribuido
disponi-
ble
http://www.mines.edu/fs_home/tcamp/dbaci/
dispone
desensamblador
PCODE
proporciona
usuario
listado
anotado
fichero
PCODE
mostrando
mnemónicos
instrucción
disponible
correspondiente
fragmento
programa
fuente
generó
instrucción
desensambla-
dor
incluido
sistema
BACI
añadido
capacidad
compilación
separada
variables
externas
compila-
dores
sistema
BACI
incluye
gestor
bibliotecas
contador
permiten
crea-
ción
bibliotecas
PCODE
BACI
detalles
véase
guía
usuario
compilación
separada
BACI
Actualmente
construcción
implementación
Java
sistema
BACI
espe-
ra
concluir
verano
2004
versión
sistema
BACI
ejecutará
computador
instalada
máquina
virtual
Java
sistema
BACI
mejorado
David
Strite
estudiante
trabaja
Linda
Null
universidad
Pennsylvania
creado
depurador
BACI
GUI
depurador
disponible
http://cs.hbg.psu.edu/~null/baci/.
Utilizando
BACI
GUI
BACI
universidad
Pennsylvania
Moti
Ben-
Ari
Instituto
Ciencia
Weizmann
Israel
creó
entorno
integrado
desarrollo
aprendizaje
programación
concurrente
concurrencia
simulada
denominado
jBACI
disponible
http://stwww.weizmann.ac.il/g-cs/benari/jbaci/.
800
Sistemas
operativos
Aspectos
internos
principios
diseño
21-Apendice
12/5/05
16:32
Página
800acceso
directo
memoria
DMA
técnica
módulo
especial
llamado
módulo
DMA
controla
intercambio
datos
memoria
principal
dispositivo
S.
procesador
en-
vía
solicitud
transferencia
bloque
datos
módulo
DMA
interrumpido
transferido
bloque
completo
acceso
directo
capacidad
obtener
datos
introducir
datos
dispositivo
almacenamiento
secuencia
independiente
posición
relativa
direcciones
indican
ubicación
física
datos
acceso
indexado
Perteneciente
organización
acceso
registros
estructura
almacenamien-
to
índice
separado
registro
almacenado
acceso
secuencial
indexado
Perteneciente
organización
acceso
registros
estructura
al-
macenamiento
índice
claves
almacenan
ficheros
secuenciales
arbitrariamente
particionados
acceso
secuencial
capacidad
introducir
datos
dispositivo
almacenamiento
soporte
datos
secuencia
ordenados
datos
obtenerlos
orden
introdujeron
activar
Reservar
tiempo
procesador
trabajos
tareas
encuentran
listas
ejecución
arquitectura
comunicaciones
estructura
hardware
software
implementa
funciones
comu-
nicaciones
base
datos
colección
datos
interrelacionados
frecuentemente
control
redundancia
organi-
zados
base
esquema
sirve
aplicaciones
datos
almacenan
forma
puedan
utilizarlos
programas
preocuparse
estructura
organización
datos
utiliza
téc-
nica
común
añadir
datos
modificar
obtener
datos
existentes
Beowulf
Define
clase
computación
cluster
centra
minimizar
tasa
precio-prestaciones
comprometer
rendimiento
trabajo
computación
construido
par-
Sistemas
Beowulf
implementados
computadores
Linux
bloque
conjunto
registros
contiguos
graban
unidad
unidades
quedan
separadas
huecos
registros
bloque
grupo
bits
transmiten
unidad
bloque
control
proceso
Manifestación
proceso
sistema
operativo
estructura
da-
tos
contiene
información
características
procesos
buffer
traducción
anticipada
translation
lookaside
buffer
TLB
memoria
cache
ed
alta
velocidad
usada
almacenar
referencias
entradas
tablas
páginas
recientemente
esquema
memoria
virtual
TLB
reduce
frecuencia
accesos
memoria
principal
recuperar
entradas
tabla
páginas
bus
sistema
bus
usado
interconectar
principales
componentes
computador
procesador
memoria
buzón
estructura
datos
compartida
procesos
utiliza
cola
mensajes
mensajes
envían
buzón
extraen
buzón
pasar
directamente
emisor
receptor
Glosario
801
LOSARIO
22-Glosario
12/5/05
16:33
Página
801cache
disco
buffer
habitualmente
almacenado
memoria
principal
funciona
cache
bloques
disco
almacenamiento
disco
resto
memoria
principal
cambio
operación
hardware
activa
procesador
diferen-
kernel
usuario
pasa
usuario
kernel
guardan
contador
programa
pala-
bra
procesador
registros
cambia
kernel
usuario
restaura
información
cambio
proceso
Operación
cambia
procesador
proceso
guardado
bloque
control
proceso
registros
información
reemplazándolo
información
proceso
campo
Datos
lógicos
definidos
registro
campo
unidad
elemental
registro
contener
elemento
datos
conjunto
da-
tos
puntero
enlace
caparazón
interfaz
mandatos
porción
sistema
operativo
interpreta
mandatos
usuario
inte-
ractivos
mandatos
lenguaje
control
trabajos
Funciona
interfaz
usuario
siste-
ma
operativo
cerrojo
cíclico
mecanismo
exclusión
mutua
proceso
ejecuta
bucle
infinito
esperando
valor
variable
actúa
cerrojo
indique
disponible
ciclo
instrucción
periodo
tiempo
comprende
lectura
memoria
instrucción
ejecu-
ción
computador
procesa
instrucción
lenguaje
máquina
círculo
vicioso
livelock
condición
procesos
cambian
continuamente
respuesta
cambios
procesos
trabajo
útil
similar
interbloqueo
deadlock
progreso
difiere
proceso
bloquea
espera
cita
paso
mensajes
condición
emisor
receptor
mensaje
bloqueados
mensaje
entrega
cliente
proceso
solicita
servicios
procesos
servidores
envío
mensajes
cluster
Grupo
computadoras
completas
interconectadas
trabajan
juntas
recurso
compu-
tación
unificado
crear
ilusión
única
máquina
término
computadora
completa
significa
sistema
ejecutar
aparte
clúster
compactación
técnica
utilizada
memoria
divide
particiones
tamaño
variable
sistema
operativo
desplaza
particiones
forma
queden
contiguas
memoria
libre
quede
único
bloque
libre
Véase
fragmentación
externa
compartición
tiempo
concurrente
dispositivo
usuarios
concurrente
Relativo
procesos
hilos
lugar
intervalo
común
tiempo
compartir
alternativamente
recursos
comunes
condición
carrera
Situación
múltiples
procesos
acceden
manipulan
datos
compartidos
ma-
nera
resultado
depende
velocidad
relativa
procesos
conjunto
trabajo
conjunto
trabajo
parámetro
proceso
tiempo
W(t
conjunto
páginas
proceso
referencia
unidades
tiempo
Compárese
conjunto
residente
conjunto
residente
proceso
realmente
memoria
instante
determinado
Compá-
rese
conjunto
residente
contador
programa
Registro
dirección
instrucción
802
Sistemas
operativos
Aspectos
internos
principios
diseño
22-Glosario
12/5/05
16:33
Página
802contexto
ejecución
proceso
cortar
tiempo
operación
asignan
rodajas
tiempo
procesos
computador
creación
procesos
Creación
proceso
criptografía
conversión
texto
plano
datos
ininteligible
cómputo
matemático
reversible
descriptor
proceso
Idéntico
bloque
control
proceso
detección
interbloqueo
técnica
recursos
solicitados
asignan
disponi-
bles
Periódicamente
sistema
operativo
comprueba
existencia
interbloqueo
dirección
base
dirección
origen
cálculo
direcciones
ejecución
programa
computador
dirección
física
ubicación
absoluta
unidad
datos
memoria
ejemplo
palabra
byte
memoria
principal
bloque
memoria
secundaria
dirección
lógica
referencia
ubicación
memoria
independiente
asignación
actual
da-
tos
memoria
acceder
memoria
cabo
traducción
dirección
física
dirección
real
dirección
física
memoria
principal
dirección
relativa
dirección
calculada
desplazamiento
dirección
base
dirección
virtual
dirección
ubicación
memoria
virtual
programada
técnica
procesador
envía
mandato
módulo
continuación
esperar
complete
operación
continuar
espacio
direcciones
rango
direcciones
disponible
programa
computador
espera
activa
ejecución
repetida
bucle
código
espera
ocurra
evento
proceso
información
sistema
operativo
necesita
gestionar
proceso
procesador
necesita
ejecutar
adecuadamente
proceso
proceso
incluye
contenidos
registros
procesador
tales
contador
programa
registros
datos
incluye
información
sistema
operativo
tales
prioridad
proceso
proceso
esperando
finalización
determinado
evento
S.
contexto
ejecución
privilegiado
contexto
ejecución
permite
ejecuten
instrucciones
hardware
sen-
sibles
ejemplo
instrucción
parada
instrucciones
S.
exclusión
mutua
condición
conjunto
procesos
ca-
paz
acceder
recurso
función
dada
Véase
sección
crítica
expropiación
Quitar
recurso
proceso
terminado
usarlo
fallo
página
Ocurre
página
contiene
palabra
referenciando
en-
cuentra
memoria
principal
dispara
excepción
requiere
traiga
memoria
dicha
página
fichero
acceso
directo
hash
fichero
contiene
registros
acceder
valores
campo
clave
utiliza
método
hash
localizar
registro
base
valor
clave
fichero
indexado
fichero
cuyos
registros
acceden
valor
campos
clave
requiere
índice
indique
ubicación
registro
función
valor
clave
fichero
secuencial
indexado
fichero
cuyos
registros
ordenan
valores
campo
cla-
ve
fichero
principal
fichero
índice
contiene
lista
parcial
valores
clave
índice
propor-
ciona
capacidad
búsqueda
permite
encontrar
fácilmente
vecindad
determinado
registro
Glosario
803
22-Glosario
12/5/05
16:33
Página
803fichero
secuencial
fichero
cuyos
registros
ordenan
valores
campos
clave
procesan
secuencia
principio
fichero
fichero
conjunto
registros
tratados
unidad
fragmentación
externa
Ocurre
memoria
divide
particiones
tamaño
variable
correspon-
dientes
bloques
datos
asignados
memoria
ejemplo
segmentos
memoria
principal
segmentos
mueven
memoria
crean
huecos
porciones
memoria
ocupadas
fragmentación
interna
Ocurre
memoria
divide
particiones
tamaño
fijo
ejemplo
mar-
cos
páginas
memoria
principal
bloques
físicos
disco
asigna
bloque
datos
particiones
malgastar
espacio
partición
ocurrirá
porción
datos
pequeña
partición
grado
multiprogramación
número
procesos
parcial
totalmente
memoria
principal
gusano
Programa
viajar
ordenador
ordenador
conexiones
red
contener
virus
bacteria
hambruna
condición
proceso
postpone
indefinidamente
procesos
preferencia
hashing
Selección
posición
almacenamiento
objeto
datos
cálculo
direc-
ción
función
contenido
datos
técnica
complica
función
reserva
almacena-
miento
proporciona
recuperación
directa
datos
rápida
hilo
unidad
trabajo
planificar
Incluye
contexto
procesador
incluye
conta-
dor
programa
puntero
pila
área
pila
permitir
salto
subrutinas
hilo
ejecuta
secuencialmente
procesador
interrumpirlo
ceder
control
hilo
proceso
pue-
formado
múltiples
hilos
imagen
proceso
ingredientes
proceso
incluyendo
programa
datos
pila
bloque
control
proceso
instrucción
privilegiada
instrucción
ejecutar
determinado
habitualmente
ejecuta
programa
supervisión
interbloqueo
situación
bloqueo
indefinido
produce
múltiples
procesos
es-
tán
esperando
quede
disponible
recurso
disponible
asignado
pro-
ceso
espera
similar
interbloqueo
situación
bloqueo
indefinido
produce
múltiples
procesos
esperando
produzca
acción
respuesta
proceso
espera
similar
intercambio
hilos
acto
cambiar
control
procesador
hilo
proceso
interfaz
programación
aplicaciones
application
programming
interface
API
biblioteca
están-
herramientas
programación
utilizada
desarrolladores
software
escribir
aplicaciones
compatibles
sistema
operativo
interfaz
gráfica
específicos
interrupción
habilitada
condición
usualmente
causada
sistema
operativo
pro-
cesador
responderá
señales
petición
interrupción
determinado
tipo
interrupción
inhabilitada
condición
usualmente
causada
sistema
operativo
procesador
ignorará
señales
petición
interrupción
determinado
tipo
interrupción
suspensión
proceso
ejecución
programa
computador
causada
evento
externo
proceso
realizada
ejecución
proceso
reanudada
804
Sistemas
operativos
Aspectos
internos
principios
diseño
22-Glosario
12/5/05
16:33
Página
804inversión
prioridad
circunstancia
sistema
operativo
fuerza
tarea
priori-
dad
esperar
tarea
menor
prioridad
lenguaje
control
trabajos
job
control
language
JCL
lenguaje
orientado
problemas
diseñado
expresar
sentencias
utilizadas
identificar
trabajo
describir
requisitos
sistema
operativo
lista
encadenada
lista
elementos
dispersos
elemento
con-
identificador
localizar
llamada
procedimiento
remoto
remote
procedure
call
RPC
técnica
programas
máquinas
interaccionan
utilizando
sintaxis
semántica
call
return
programas
invo-
ca
procedimiento
invocado
comportan
ejecutaran
máquina
macronúcleo
central
tamaño
sistema
operativo
proporciona
variedad
servicios
manejador
dispositivo
módulo
sistema
operativo
normalmente
núcleo
directamente
dispositivo
módulo
S.
manejador
interrupción
rutina
generalmente
forma
sistema
operativo
pro-
duce
interrupción
transfiere
control
manejador
interrupción
realiza
acción
res-
puesta
condición
causó
interrupción
marco
página
bloque
contiguo
memoria
principal
tamaño
fijo
utiliza
contener
página
marco
almacenamiento
virtual
paginado
bloque
longitud
fija
memoria
principal
utiliza
contener
página
memoria
virtual
mediador
solicitud
objeto
object
request
broker
ORB
entidad
sistema
orientado
obje-
tos
actúa
intermediario
solicitudes
enviadas
cliente
servidor
memoria
cache
memoria
pequeña
rápida
memoria
principal
interpone
pro-
cesador
memoria
principal
cache
actúa
buffer
posiciones
memoria
recientemente
usadas
memoria
principal
memoria
interna
computador
accesible
programas
especificando
di-
recciones
cargarse
registros
posterior
ejecución
procesamiento
memoria
secundaria
memoria
situada
computador
procesador
ac-
cederla
directamente
copiarse
memoria
principal
disco
cinta
ejemplos
tipo
memoria
memoria
virtual
espacio
almacenamiento
direccionable
direcciones
virtuales
traducen
direcciones
reales
tamaño
almacenamiento
virtual
limitado
esquema
direccionamiento
sistema
computación
cantidad
memoria
secundaria
disponible
tamaño
memo-
ria
principal
mensaje
bloque
información
intercambiada
procesos
comunicación
método
acceso
método
utilizado
encontrar
fichero
registro
conjunto
registros
micronúcleo
central
pequeño
tamaño
sistema
operativo
proporciona
planificación
pro-
cesos
gestión
memoria
servicios
comunicación
depende
procesos
funciones
tradicionalmente
asociadas
núcleo
sistema
operativo
migración
proceso
transferencia
suficiente
cantidad
proceso
máquina
proceso
ejecute
máquina
destino
Glosario
805
22-Glosario
12/5/05
16:33
Página
805modo
núcleo
privilegiado
ejecución
reservado
núcleo
sistema
operativo
Normalmen-
núcleo
acceder
regiones
memoria
disponibles
procesos
ejecutan
privilegiado
permite
ejecución
instrucciones
máquina
restringidas
núcleo
denomina
sistema
privilegiado
privilegiado
núcleo
sistema
núcleo
usuario
ejecución
privilegiado
utilizar
regiones
memoria
instrucciones
máquina
monitor
construcción
lenguaje
programación
encapsula
variables
procedimientos
acceso
código
inicialización
tipo
abstracto
datos
variable
monitor
accedida
vía
procedimientos
acceso
proceso
accediendo
activamente
monitor
procedimientos
acceso
secciones
críticas
monitor
cola
procesos
esperando
acceder
multiprocesador
acceso
memoria
uniforme
nonuniform
memory
access
NUMA
procesador
memoria
compartida
tiempo
acceso
procesador
palabra
memoria
determina-
varía
dependiendo
localización
memoria
multiprocesador
computador
procesadores
acceso
común
almacenamiento
principal
multiprocesamiento
simétrico
SMP
forma
multiprocesamiento
permite
aplicaciones
eje-
cutar
procesador
disponible
procesadores
disponibles
tiempo
multiproceso
operación
permite
procesamiento
paralelo
procesadores
multiprocesador
multiprogramación
operación
permite
ejecución
intercalada
programas
único
procesador
multitarea
utilizando
terminología
multitarea
operación
permite
ejecución
intercalada
tareas
computación
multiprogramación
utilizando
terminología
mutex
semáforo
binario
núcleo
monolítico
núcleo
contiene
prácticamente
sistema
operativo
completo
incluyendo
planificación
sistema
ficheros
manejadores
dispositivos
gestión
memoria
componentes
funcionales
núcleo
acceso
estructuras
datos
rutinas
internas
Normalmente
nú-
cleo
monolítico
implementa
único
proceso
elementos
compartiendo
espa-
cio
direcciones
núcleo
porción
sistema
operativo
incluye
porciones
software
utilizadas
frecuentemen-
Generalmente
núcleo
mantiene
permanentemente
memoria
principal
núcleo
ejecuta
privilegiado
responde
llamadas
procesos
interrupciones
dispositivos
operación
asíncrona
operación
ocurre
relación
temporal
regular
predecible
deter-
minado
evento
ejemplo
invocación
rutina
diagnóstico
recibir
control
cual-
quier
momento
ejecución
programa
computador
operación
síncrona
operación
ocurre
forma
regular
predecible
aparición
determinado
evento
proceso
ejemplo
invocación
rutina
entrada
salida
recibe
control
posición
prefijada
programa
computador
organización
ficheros
orden
físico
registros
fichero
determina
método
acceso
utilizado
almacenarlos
obtenerlos
806
Sistemas
operativos
Aspectos
internos
principios
diseño
22-Glosario
12/5/05
16:33
Página
806página
almacenamiento
virtual
bloque
longitud
fija
dirección
virtual
trans-
fiere
unidad
memoria
principal
secundaria
paginación
adelantada
Recuperación
páginas
adicionales
causado
fallo
página
espe-
ranza
páginas
extra
vayan
futuro
aprovechando
disco
Compá-
rese
paginación
demanda
paginación
demanda
transferencia
página
memoria
secundaria
memoria
principal
únicamente
momento
necesite
Compárese
paginación
adelantada
paginación
transferencia
páginas
memoria
principal
secundaria
palabra
programa
PSW
registro
conjunto
registros
contiene
códigos
condi-
ción
ejecución
información
refleja
proceso
palabra
conjunto
ordenado
bytes
bits
constituyen
unidad
normal
almacena
trans-
mite
opera
información
determinado
computador
Normalmente
computador
juego
instrucciones
tamaño
fijo
longitud
instrucción
palabra
particionamiento
memoria
división
almacenamiento
secciones
independientes
pila
lista
ordenada
elementos
añaden
eliminan
extremo
lista
conocido
cima
elemento
añade
lista
coloca
cima
siguien-
elemento
eliminará
lista
tiempo
método
ca-
racteriza
entrar-el
salir
planificación
pandilla
planificación
conjunto
hilos
relacionados
ejecuten
conjunto
procesadores
relación
planificación
Seleccionar
trabajos
tareas
activados
sistemas
operativos
uni-
dades
trabajo
tales
operaciones
entrada
salida
planificadas
predicción
interbloqueo
técnica
dinámica
analiza
solicitud
recurso
res-
pecto
posibilidad
interbloqueo
solicitud
conducir
interbloqueo
solicitud
deniega
prevención
interbloqueo
técnica
garantiza
producirá
interbloqueo
preven-
ción
logra
asegurando
cumple
condiciones
necesarias
entra
sale
técnica
colas
elemento
atendido
elemento
cola
tiempo
llega
atiende
FIFO
procedimiento
reentrante
rutina
invocada
complete
ejecución
previa
ejecutándose
correctamente
procesador
computador
unidad
funcional
interpreta
ejecuta
instrucciones
procesador
consta
unidad
control
instrucciones
unidad
aritmética
procesamiento
lotes
batch
Perteneciente
técnica
ejecución
conjunto
programas
programa
ejecuta
justo
continuación
termine
programa
proceso
ligero
hilo
proceso
programa
ejecución
sistema
operativo
encarga
controlar
planificar
proceso
tarea
proximidad
referencias
tendencia
procesador
acceder
conjunto
posiciones
me-
moria
repetidamente
corto
periodo
tiempo
Glosario
807
22-Glosario
12/5/05
16:33
Página
807puerta
secreta
Punto
entrada
secreto
documentado
programa
usado
acceso
métodos
habituales
autenticación
recurso
consumible
recurso
crear
producir
destruir
consumir
proceso
ad-
recurso
tipo
recurso
deja
existir
interrupciones
señales
mensajes
in-
formación
buffers
constituyen
ejemplos
recursos
consumibles
recurso
reutilizable
recurso
usarlo
forma
segura
único
proceso
momento
destruye
procesos
obtienen
unidades
recursos
reutilizables
posteriormente
li-
beran
usen
procesos
ejemplos
tipo
recursos
procesadores
ca-
nales
memoria
primaria
secundaria
dispositivos
estructuras
datos
ficheros
bases
datos
semáforos
registro
lógico
registro
independiente
entorno
físico
localizar
porciones
registro
lógico
registros
físicos
registros
lógicos
régistros
lógicos
registro
físico
registro
grupo
elementos
datos
tratados
unidad
registros
memoria
alta
velocidad
interna
procesador
registros
visibles
usuario
disponibles
programador
juego
instrucciones
máquina
registros
procesador
propósitos
control
reubicación
dinámica
proceso
asigna
direcciones
absolutas
programa
ejecu-
ción
forma
ejecutarse
área
memoria
principal
rodaja
tiempo
máximo
tiempo
proceso
ejecuta
interrumpido
sección
crítica
procedimiento
asíncrono
programa
ejecutada
simultá-
neamente
sección
crítica
asociada
procedimiento
asíncrono
Véase
exclusión
mutua
segmentación
división
programa
aplicación
segmentos
esquema
memoria
virtual
segmento
memoria
virtual
bloque
dirección
virtual
bloques
programa
tamaño
variar
longitud
forma
dinámica
seguridad
multinivel
funcionalidad
obliga
hagan
controles
acceso
múltiples
niveles
clasificación
datos
semáforo
binario
semáforo
toma
valores
semáforo
binario
permite
proceso
hilo
acceso
recurso
crítico
compartido
semáforo
débil
semáforo
procesos
esperan
avanzarán
orden
espe-
cificado
ej.
orden
conoce
indeterminado
semáforo
fuerte
semáforo
procesos
esperan
encolan
eventual-
mente
ejecutados
orden
ejecutaron
operaciones
wait
orden
FIFO
semáforo
valor
entero
utilizado
señalización
procesos
semáforo
reali-
zarse
operaciones
atómicas
inicialización
decremento
incremento
Dependiendo
defi-
nición
exacta
semáforo
operación
decremento
provocar
bloqueo
proceso
opera-
ción
incremento
provocar
desbloqueo
proceso
conocido
semáforo
contador
semáforo
general
servidor
proceso
responde
solicitudes
clientes
vía
mensajes
servidor
red
estación
proporciona
servicios
estaciones
ejemplo
servidor
ficheros
servidor
impresión
servidor
correo
808
Sistemas
operativos
Aspectos
internos
principios
diseño
22-Glosario
12/5/05
16:33
Página
808sesión
colección
procesos
representan
única
aplicación
interactiva
usuario
función
sistema
operativo
entradas
teclado
ratón
dirigen
sesión
plano
salidas
sesiones
plano
dirigen
pantalla
sincronización
Situación
procesos
coordinan
actividades
basándose
condición
sistema
confiable
ordenador
sistema
operativo
verificarse
implementa
política
seguridad
dada
sistema
gestión
ficheros
conjunto
programas
sistema
proporcionan
servicios
usua-
rios
aplicaciones
ficheros
incluyendo
acceso
ficheros
mantenimiento
directo-
rios
control
acceso
sistema
tiempo
real
sistema
operativo
planificar
gestionar
tareas
tiempo
real
sistema
operativo
distribuido
sistema
operativo
común
compartido
red
computadores
sis-
tema
operativo
distribuido
soporte
comunicación
procesos
migración
procesos
exclusión
mu-
tua
prevención
detección
interbloqueos
sistema
operativo
módulo
software
controla
ejecución
programas
proporciona
servi-
cios
tales
asignación
recursos
planificación
control
gestión
datos
software
malicioso
software
diseñado
causar
daño
recursos
sistema
equipo
afectado
software
malicioso
malware
frecuentemente
oculta
pasar
software
legíti-
mo
caso
expande
ordenadores
correo
electrónico
disquetes
in-
fectados
tipos
software
malicioso
virus
troyanos
gusanos
software
oculto
rea-
liza
ataques
denegación
servicio
spooling
memoria
secundaria
buffer
almacenamiento
reducir
retardos
proce-
samiento
transfieren
datos
equipos
periféricos
procesadores
computador
swapping
proceso
intercambia
contenidos
area
memoria
principal
area
memo-
ria
secundaria
tabla
asignación
disco
tabla
indica
bloques
almacenamiento
secundario
libres
disponibles
asignación
ficheros
tabla
asignación
ficheros
file
allocation
table
FAT
tabla
indica
ubicación
física
al-
macenamiento
secundario
espacio
asignado
fichero
tabla
asignación
ficheros
fichero
tarea
proceso
tareas
tiempo
real
tarea
ejecuta
conexión
proceso
función
conjunto
even-
tos
externos
sistema
computo
cumplir
plazos
interactuar
efectiva
correcta-
mente
entorno
externo
tasa
aciertos
memoria
niveles
fracción
accesos
memoria
encuen-
tran
memoria
rápida
p.
ej.
cache
tiempo
ciclo
memoria
tiempo
tarda
leerse
escribirse
palabra
memoria
inverso
velocidad
leen
escriben
palabras
memoria
tiempo
respuesta
proceso
interactivo
tiempo
trascurre
lanza
petición
comienza
recibir
respuesta
trabajo
conjunto
pasos
computacionales
empaquetados
ejecutarse
unidad
traductor
direcciones
unidad
funcional
transforma
direcciones
virtuales
direcciones
reales
Glosario
809
22-Glosario
12/5/05
16:33
Página
809trap
Salto
condicional
programado
dirección
específica
hardware
activa
automáticamente
almacena
posición
salto
trasiego
thrasing
Fenómeno
esquemas
memoria
virtual
proceso
consume
tiempo
swapping
porciones
memoria
ejecutando
instrucciones
traza
Secuencia
instrucciones
ejecutan
proceso
corriendo
troyano
Rutina
secreta
documentada
insertada
programa
utilidad
ejecución
progra-
ma
dicha
rutina
ejecute
tubería
buffer
circular
permite
procesos
comuniquen
modelo
productor-consumi-
dor
cola
política
entrar-primero
salir
escrita
proceso
leída
sistemas
tubería
generaliza
permitir
seleccione
elemento
cola
consumo
turno
rotatorio
algoritmo
planificación
procesos
activan
forma
cíclica
procesos
cola
circular
proceso
continuar
ejecutando
esperando
evento
ejemplo
terminación
proceso
hijo
operación
entrada
salida
devuelve
con-
trol
planificador
entrar
salir
LIFO
técnica
gestión
cola
elemento
recupera
recientemente
incluido
cola
unidad
central
proceso
CPU
computador
lee
ejecuta
instrucciones
Consta
unidad
aritmético-lógica
Arithmetic
and
Logic
Unit
ALU
unidad
control
registros
Habitualmente
denomina
simplemente
procesador
virus
Rutina
secreta
documentada
insertada
programa
utilidad
ejecución
programa
dicha
rutina
ejecute
810
Sistemas
operativos
Aspectos
internos
principios
diseño
22-Glosario
12/5/05
16:33
Página
810ABREVIATURAS
ACM
Association
for
Computing
Machinery
IEEE
Institute
of
Electrical
and
Electronics
Engineers
Instituto
Ingenieros
Eléctricos
Electrónicos
IRE
Institute
of
Radio
Engineers
Instituto
Ingenieros
Radio
ABRA87
Abrams
M.
Podell
H.
Computer
and
Network
Security
Alamitos
CA
IEEE
Computer
Society
Press
1987
ADAM92
Adam
J.
Virus
Threats
and
Countermeasures
IEEE
Spectrum
Agosto
1992
AGAR89
Agarwal
A.
Analysis
of
Cache
Performance
for
Operating
Systems
and
Multiprogrammin
g.
Boston
Kluwer
Academic
Publishers
1989
ALV
A90
Alvare
A.
How
Crackers
Crack
Passwords
or
What
Passwords
to
Avoid
Proceedings
UNIX
Security
Workshop
II
Agosto
1990
ANAN92
Ananda
A.
Tay
B.
Koh
E.
Survey
of
Asynchronous
Remote
Procedure
Calls
Opera-
ting
Systems
Review
Abril
1992
ANDE80
Anderson
J.
Computer
Security
Threat
Monitoring
and
Surveillance
Fort
Washington
PA
Ja-
mes
P.
Anderson
Co
Abril
1980
ANDE89
Anderson
T.
Laxowska
E.
Levy
H.
The
Performance
Implications
of
Thread
Management
Alternatives
for
Shared-Memory
Multiprocessors
IEEE
Transactions
on
Computer
Diciem-
bre
1989
ANDE97
Anderson
T.
Bershad
B.
Lazowska
E.
Levy
H.
Thread
Management
for
Shared-Memory
Multiprocessors
TUCK97
ANDR90
Andrianoff
S.
Module
on
Distributed
Systems
for
the
Operating
System
Course
Procee-
dings
Twenty-First
SIGCSE
Technical
Symposium
on
Computer
Science
Education
SIGSCE
Bulletin
Febrero
1990
ARDE80
Arden
B.
editor
What
Can
Be
Automated
Cambridge
MA
MIT
Press
1980
ARTS89a
Artsy
ed
Special
Issue
on
Process
Migration
Newsletter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
Systems
Invierno
1989
ARTS89b
Artsy
Designing
Process
Migration
Facility
The
Charlotte
Experience
Computer
Sep-
tiembre
1989
ATLA89
Atlas
A.
Blundon
B.
Time
to
Reach
for
It
All
UNIX
Review
Enero
1989
AXFO88
Axford
T.
Concurrent
Programming
Fundamental
Techniques
for
Real-Time
and
Parallel
Software
Design
New
York
Wiley
1988
BACH86
Bach
M.
The
Design
of
the
UNIX
Operating
System
Englewood
Cliffs
NJ
Prentice
Hall
1986
BACO03
Bacon
J.
Harris
T.
Operating
Systems
Concurrent
and
Distributed
SoftwareDesign
Rea-
ding
MA
Addison-Wesley
1998
Referencias
811
EFERENCIAS
23-Referencias
12/5/05
16:33
Página
811BAEN97
Baentsch
M.
et
Enhancing
the
Web’s
Infrastructure
From
Caching
to
Replication
Inter-
net
Computing
Marzo
Abril
1997
BAER80
Baer
J.
Computer
Systems
Architecture
Rockville
MD
Computer
Science
Press
1980
BAR00
Bar
M.
Linux
Internals
New
York
McGraw-Hill
2000
BARB90
Barbosa
Strategies
for
the
Prevention
of
Communication
Deadlocks
in
Distributed
Parallel
Programs
IEEE
Transactions
on
Software
Engineering
Noviembre
1990
BARK89
Barkley
R.
Lee
T.
Lazy
Buddy
System
Bounded
by
Two
Coalescing
Delays
per
Class
Proceedings
of
the
Twelfth
ACM
Symposium
on
Operating
Systems
Principles
Diciembre
1989
BAYS77
Bays
C.
Comparison
of
Next-Fit
First-Fit
and
Best-Fit
Communications
of
the
AC
Marzo
1977
BECK90
Beck
L.
System
Software
Reading
MA
Addison-Wesley
1990
BELA66
Belady
L.
Study
of
Replacement
Algorithms
for
Virtual
Storage
Computer
IBM
Systems
Journal
1966
BEN82
Ben-Ari
M.
Principles
of
Concurrent
Programmin
g.
Englewood
Cliffs
NJ
Prentice
Hall
1982
BEN90
Ben-Ari
M.
Principles
of
Concurrent
and
Distributed
Programmin
g.
Englewood
Cliffs
NJ
Prentice
Hall
1990
BEN98
Ben-Ari
M.
Burns
A.
Extreme
Interleavings
IEEE
Concurrency
Julio-Septiembre
1998
BIRR89
Birrell
A.
An
Introduction
to
Programming
with
Threads
SRC
Research
Report
35
Compaq
Systems
Research
Center
Palo
Alto
CA
Enero
1989
Dsiponible
http://www.research.com-
paq.com/SRC
BLAC90
Black
D.
Scheduling
Support
for
Concurrency
and
Parallelism
in
the
Mach
Operating
Sys-
tem
Computer
Mayo
1990
BOEB85
Boebert
W.
Kain
R.
Young
W.
Secure
Computing
the
Secure
Ada
Target
Approach
Scientific
Honeyweller
Julio
1985
Reimpreso
ABRA87
BOLO89
Bolosky
W.
Fitzgerald
R.
Scott
M.«Simple
But
Effective
Techniques
for
NUMA
Memory
Management
Proceedings
Twelfth
ACM
Symposium
on
Operating
Systems
Principle
Di-
ciembre
1989
BONW94
Bonwick
J.
An
Object-Caching
Memory
Allocator
Proceedings
USENIX
Summer
Technical
Conference
1994
BORG90
Borg
A.
Kessler
R.
Wall
D.
Generation
and
Analysis
of
Very
Long
Address
Traces
Pro-
ceedings
of
the
17th
Annual
International
Symposium
on
Computer
Architectur
Mayo
1990
BOSW03
Boswell
W.
Inside
Windows
Server
2003
Reading
MA
Addison-Wesley
2003
BOVE03
Bovet
D.
Cesati
M.
Understanding
the
Linux
Kernel
Sebastopol
CA
O’Reilly
2003
BREN89
Brent
R.
Efficient
Implementation
of
the
First-Fit
Strategy
for
Dynamic
Storage
Allocation
ACM
Transactions
on
Programming
Languages
and
Systems
Julio
1989
BREW97
Brewer
E.
Clustering
Multiply
and
Conquer
Data
Communications
Julio
1997
BRIA99
Briand
Roy
D.
Meeting
Deadlines
in
Hard
Real-Time
Systems
The
Rate
Monotonic
Ap-
proach
Alamitos
CA
IEEE
Computer
Society
Press
1999
BRIN73
Brinch
Hansen
P.
Operating
System
Principles
Englewood
Cliffs
NJ
Prentice
Hall
1973
812
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
812BRIN01
Brinch
Hansen
P.
Classic
Operating
Systems
From
Batch
Processing
to
Distributed
Systems
New
York
Springer-Verlag
2001
BROW84
Brown
R.
Denning
P.
Tichy
W.
Advanced
Operating
Systems
Computer
Octubre
1984
BUHR95
Buhr
P.
Fortier
M.
Monitor
Classification
ACM
Computing
Surveys
Marzo
1995
BUTT99
Buttazzo
G.
Optimal
Deadline
Assignment
for
Scheduling
Soft
Aperiodic
Tasks
in
Hard
Real-
Time
Environments
IEEE
Transactions
on
Computers
Octubre
1999
BUYY99a
Buyya
R.
High
Performance
Cluster
Computing
Architectures
and
Systems
Upper
Saddle
Ri-
NJ
Prentice
Hall
1999
BUYY99b
Buyya
R.
High
Performance
Cluster
Computing
Programming
and
Applications
Upper
Sadd-
River
NJ
Prentice
Hall
1999
BYNU96
Bynum
B.
Camp
T.
After
You
Alfonse
Mutual
Exclusion
Toolkit
Proceedings
of
the
27th
SIGCSE
Technical
Symposium
on
Computer
Science
Education
Febrero
1996
CABR86
Cabrear
L.
The
Influence
of
Workload
on
Load
Balancing
Strategies
USENIX
Conference
Proceedings
Verano
1986
CAO96
Cao
P.
Felten
E.
Karlin
A.
Li
K.
Implementation
and
Performance
of
Integrated
Appli-
cation-Controlled
File
Caching
Prefetching
and
Disk
Scheduling
ACM
Transactions
on
Computer
Systems
Noviembre
1996
CARR81
Carr
R.
Hennessey
J.
WSClock—A
Simple
and
Efficient
Algorithm
for
Virtual
Memory
Management
Proceedings
of
the
Eighth
Symposium
on
Operating
System
Principle
s.
Di-
ciembre
1981
CARR84
Carr
R.
Virtual
Memory
Management
Ann
Arbor
UMI
Research
Press
1984
CARR89
Carriero
N.
Gelernter
D.
How
to
Write
Parallel
Programs
Guide
for
the
Perplexed
ACM
Computing
Surveys
Septiembre
1989
CARR01
Carr
Mayoo
J.
and
Shene
C.
Race
Conditions
Case
Study
The
Journal
of
Computing
in
Small
Colleges
Octubre
2001
CASA94
Casavant
T.
Singhal
M.
Distributed
Computing
Systems
Alamitos
CA
IEEE
Compu-
ter
Society
Press
1994
CASS01
Cass
S.
Anatomy
of
Malice
IEEE
Spectrum
Noviembre
2001
CAST92
Castillo
C.
Flanagan
E.
Wilkinson
N.
Object-Oriented
Design
and
Programming
AT&T
Technical
Journal
Noviembre
Diciembre
1992
CHAN85
Chandy
K.
Lamport
L.
Distributed
Snapshots
Determining
Global
States
of
Distributed
Systems
ACM
Transactions
on
Computer
Systems
Febrero
1985
CHEN92
Chen
J.
Borg
A.
Jouppi
N.
Simulation
Based
Study
of
TLB
Performance
Proceedings
of
the
19th
Annual
International
Symposium
on
Computer
Architecture
Mayo
1992
CHEN94
Chen
P.
Lee
E.
Gibson
G.
Katz
R.
Patterson
D.
RAID
High-Performance
Reliable
Se-
condary
Storage
ACM
Computing
Surveys
Junio
1994
CHEN96
Chen
S.
Towsley
D.
Performance
Evaluation
of
RAID
Architectures
IEEE
Transac-
tions
on
Computers
Octubre
1996
CHES97
Chess
D.
The
Future
of
Viruses
on
the
Internet
Proceedings
Virus
Bulletin
International
Conference
Octubre
1997
Referencias
813
23-Referencias
12/5/05
16:33
Página
813CHRI93
Christopher
W.
Procter
S.
Anderson
T.
The
Nachos
Instructional
Operating
System
Pro-
ceedings
1993
USENIX
Winter
Technical
Conference
1993
CHU72
Chu
W.
Opderbeck
H.
The
Page
Fault
Frequency
Replacement
Algorithm
Proceedings
Fall
Joint
Computer
Conference
1972
CLAR85
Clark
D.
Emer
J.
Performance
of
the
AX-11/780
Translation
Buffer
Simulation
and
Me-
asurement
ACM
Transactions
on
Computer
Systems
Febrero
1985
CLAR98
Clarke
D.
Merusi
D.
System
Software
Programming
The
Way
Things
Work
Upper
Saddle
River
NJ
Prentice
Hall
1998
CLER04
Clercq
J.
Windows
Server
2003
Security
Infrastructure
Core
Security
Features
Burlington
MA
Digital
Press
2004
COFF71
Coffman
E.
Elphick
M.
Shoshani
A.
System
Deadlocks
Computing
Survey
Junio
1971
COME84
Comer
D.
Fossum
T.
Operating
System
Design
The
Xinu
Approach
Englewood
Cliffs
NJ
Prentice
Hall
1984
CONW63
Conway
M.
Design
of
Separable
Transition-Diagram
Compiler
Communications
of
the
ACM
Julio
1963
CONW67
Conway
R.
Maxwell
W.
Miller
L.
Theory
of
Scheduling
Reading
MA
Addison-Wesley
1967
Reimpreso
Dover
Publications
2003
COOP89
Cooper
J.
Computer
and
Communications
Security
Strategies
for
the
1990
s.
New
York
Mc-
Graw-Hill
1990
CORB62
Corbato
F.
Merwin-Daggett
M.
Dealey
R.
An
Experimental
Time-Sharing
System
Pro-
ceedings
of
the
1962
Spring
Joint
Computer
Conference
1962
Reimpreso
BRIN01
CORB68
Corbato
F.
Paging
Experiment
with
the
Multics
System
MIT
Project
MAC
Report
MAC-
M-384
Mayo
1968
CORB96
Corbett
J.
Evaluating
Deadlock
Detection
Methods
for
Concurrent
Software
IEEE
Transac-
tions
on
Software
Engineering
Marzo
1996
COX89
Cox
A.
Fowler
R.
The
Implementation
of
Coherent
Memory
Abstraction
on
NUMA
Multiprocessor
Experiences
with
PLATINUM
Proceedings
Twelfth
ACM
Symposium
on
Operating
Systems
Principles
Diciembre
1989
COX00
Cox
P.
Sheldon
T.
Windows
NT
Security
Handbook
New
York
Osborne
McGraw-Hill
2000
CUST93
Custer
H.
Inside
the
Windows
NT
Redmond
WA
Microsoft
Press
1993
CUST94
Custer
H.
Inside
the
Windows
NT
File
System
Redmond
WA
Microsoft
Press
1994
DALE68
Daley
Dennis
R.
Virtual
Memory
Processes
and
Sharing
in
MULTICS
Communica-
tions
of
the
ACM
Mayo
1968
DALT96
Dalton
W.
et
Windows
NT
Server
Security
Troubleshooting
and
Optimization
Indiana-
polis
IN
New
Riders
Publishing
1996
DASG92
Dasgupta
P.
et
The
Clouds
Distributed
Operating
System
IEEE
Computer
Noviembre
1992
DATT90
Datta
A.
Ghosh
S.
Deadlock
Detection
in
Distributed
Systems
Proceedings
Phoenix
Conference
on
Computers
and
Communications
Marzo
1990
814
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
814DATT92
Datta
A.
Javagal
R.
Ghosh
S.
An
Algorithm
for
Resource
Deadlock
Detection
in
Distri-
buted
Systems
Computer
Systems
Science
and
Engineering
Octubre
1992
DELL00
Dekker
E.
Newcomer
J.
Developing
Windows
NT
Device
Drivers
Programmer
Handbo-
ok
Reading
MA
Addison-Wesley
2000
DENN68
Denning
P.
The
Working
Set
Model
for
Program
Behavior
Communications
of
the
AC
Mayo
1968
DENN70
Denning
P.
Virtual
Memory
Computing
Surveys
Septiembre
1970
DENN80a
Denning
P.
Buzen
J.
Dennis
J.
Gaines
R.
Hansen
P.
Lynch
W.
Organick
E.
Opera-
ting
Systems
ARDE80
DENN80b
Denning
P.
Working
Sets
Past
and
Present
IEEE
Transactions
on
Software
Engineerin
Enero
1980
DENN84
Denning
P.
Brown
R.«Operating
Systems
Scientific
American
Septiembre
1984
DENN87
Denning
D.
An
Intrusion-Detection
Model
IEEE
Transactions
on
Software
Engineering
Fe-
brero
1987
DIJK65
Dijkstra
E.
Cooperating
Sequential
Processe
s.
Technological
University
Eindhoven
The
Net-
herlands
1965
Reimpreso
Great
Papers
in
Computer
Science
P.
Laplante
ed
IEEE
Press
New
York
NY
1996
reimpreso
BRIN01
DIJK71
Dijkstra
E.
Hierarchical
Ordering
of
sequential
Processes
Acta
informatic
olume
Number
1971
Reimpreso
BRIN01
DIMI98
Dimitoglou
G.
Deadlocks
and
Methods
for
Their
Detection
Prevention
and
Recovery
in
Mo-
dern
Operating
Systems
Operating
Systems
Review
Julio
1998
DONA01
Donahoo
M.
Clavert
K.
The
Pocket
Guide
to
TCP
IP
Sockets
San
Francisco
CA
Morgan
Kaufmann
2001
DOUG89
Douglas
F.
Ousterhout
J.
Process
Migration
in
Sprite
Status
Report
Newsletter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
Systems
Invierno
1989
DOUG91
Douglas
F.
Ousterhout
J.
Transparent
Process
Migration
Design
Alternatives
and
the
Spri-
Implementation
Software
Practice
and
Experienc
Agosto
1991
DOWD93
Dowdy
L.
Lowery
C.
.S.
to
Operating
Systems
Upper
Saddle
River
NJ
Prentice
Hall
1993
DUBE98
Dube
R.
Comparison
of
the
Memory
Management
Sub-Systems
in
FreeBSD
and
Linux
Tech-
nical
Report
CS-TR-3929
University
of
Maryland
25
Septiembre
1998
EAGE86
Eager
D.
Lazowska
E.
Zahnorjan
J.
Adaptive
Load
Sharing
in
Homogeneous
Distributed
Systems
IEEE
Transactions
on
Software
Engineering
Mayo
1986
ECKE95
Eckerson
W.
Client
Server
Architecture
Network
World
Collaboratio
Invierno
1995
EFF98
Electronic
Frontier
Foundation
Cracking
DES
Secrets
of
Encryption
Research
Wire-tap
Poli-
tics
and
Chip
Design
Sebastopol
CA
O’Reilly
1998
ENGE80
Enger
N.
Howerton
P.
Computer
Security
New
York
Amacom
1980
ESKI90
Eskicioglu
M.
Design
Issues
of
Process
Migration
Facilities
in
Distributed
Systems
News-
letter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
Systems
and
Applica-
tion
Environments
Verano
1990
Referencias
815
23-Referencias
12/5/05
16:33
Página
815FEIT90a
Feitelson
D.
Rudolph
L.
Distributed
Hierarchical
Control
for
Parallel
Processing
Compu-
ter
Mayo
1990
FEIT90b
Feitelson
D.
Rudolph
L.
Mapping
and
Scheduling
in
Shared
Parallel
Environment
Using
Distributed
Hierarchical
Control
Proceedings
1990
International
Conference
on
Parallel
Processing
Agosto
1990
FERR83
Ferrari
D.
Yih
VSWS
The
Variable-Interval
Sampled
Working
Set
Policy
IEEE
Tran-
sactions
on
Software
Engineering
Mayo
1983
FIDG96
Fidge
C.
Fundamentals
of
Distributed
System
Observation
IEEE
Software
Noviembre
1996
FINK88
Finkel
R.
An
Operating
Systems
Vade
Mecum
Englewood
Cliffs
NJ
Prentice
Hall
1988
FINK89
Finkel
R.
The
Process
Migration
Mechanism
of
Charlotte
Newsletter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
Systems
Invierno
1989
FINK97
Finkel
R.
What
is
an
Operating
System
In
TUCK97
FLYN72
Flynn
M.
Computer
Organizations
and
Their
Effectiveness
IEEE
Transactions
on
Compu-
ters
Septiembre
1972
FOLK98
Folk
M.
Zoellick
B.
File
Structures
An
Object-Oriented
Approach
with
C++
Reading
MA
Addison-Wesley
1998
FORR97
Forrest
S.
Hofmeyr
S.
Somayoaji
A.
Computer
Immunology
Communications
of
the
ACM
Octubre
1997
FRAN97
Franz
M.
Dynamic
Linking
of
Software
Components
Computer
Marzo
1997
FRIE96
Friedman
M.
RAID
Keeps
Going
and
Going
and
IEEE
Spectrum
Abril
1996
GALL00
Galli
D.
Distributed
Operating
Systems
Concepts
and
Practice
Upper
Saddle
River
NJ
Pren-
tice
Hall
2000
GANA98
Ganapathy
N.
Schimmel
C.
General
Purpose
Operating
System
Support
for
MultiplePage
Sizes
Proceedings
USENIX
Symposium
1998
GARG02
Garg
Elements
of
Distributed
Computing
New
York
Wiley
2002
GAUD00
Gaudin
S.
The
Omega
Files
Network
World
Junio
26
2000
GEHR87
Gehringer
E.
Siewiorek
D.
Segall
Z.
Parallel
Processing
The
Experience
Bedford
MA
Digital
Press
1987
GIBB87
Gibbons
P.
Stub
Generator
for
Multilanguage
RPC
in
Heterogeneous
Environments
IEEE
Transactions
on
Software
Engineering
Enero
1987
GING90
Gingras
A.
Dining
Philosophers
Revisited
ACM
SIGCSE
Bulletin
Septiembre
1990
GOLD89
Goldman
P.
Mac
VM
Revealed
Byte
Noviembre
1989
GOLL99
Gollmann
D.
Computer
Security
New
York
Wiley
1999
GOOD94
Goodheart
B.
Cox
J.
The
Magic
Garden
Explained
The
Internals
of
UNIX
SystemV
Release
Englewood
Cliffs
NJ
Prentice
Hall
1994
GOPA85
Gopal
I.
Prevention
of
Store-and-Forward
Deadlock
in
Computer
Networks
IEEE
Transac-
tions
on
Communications
Diciembre
1985
GOYE99
Goyeneche
J.
Souse
E.
Loadable
Kernel
Modules
IEEE
Software
Enero
Febrero
1999
816
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
816GRAY97
Gray
J.
Interprocess
Communications
in
Unix
The
Nooks
and
Crannies
Upper
Saddle
River
NJ
Prentice
Hall
1997
GROS86
Grosshans
D.
File
Systems
Design
and
Implementation
Englewood
Cliffs
NJ
Prentice
Hall
1986
GUPT78
Gupta
R.
Franklin
M.
Working
Set
and
Page
Fault
Frequency
Replacement
Algorithms
Performance
Comparison
IEEE
Transactions
on
Computer
Agosto
1978
GUYN88
Guynes
J.
Impact
of
System
Response
Time
on
State
Anxiety
Communications
of
the
ACM
Marzo
1988
HALD91
Haldar
S.
Subramanian
D.
Fairness
in
Processor
Scheduling
in
Time
Sharing
Systems
Operating
Systems
Review
Enero
1991
HALL01
Hall
B.
Beej
Guide
to
Network
Programming
Using
Internet
Sockets
2001
http://www.ecst.csuchico.edu/~beej/guide/net/html/
HARL01
Harley
D.
Slade
R.
Gattiker
U.
Viruses
Revealed
New
York
Osborne
McGraw-Hill
2001
HART97
Hartig
H.
et
The
Performance
of
µ-Kernel-Based
System
Proceedings
Sixteenth
ACM
Symposium
on
Operating
Systems
Principles
Diciembre
1997
HATF72
Hatfield
D.
Experiments
on
Page
Size
Program
Access
Patterns
and
Virtual
Memory
Perfor-
mance
IBM
Journal
of
Research
and
Development
Enero
1972
HENN02
Hennessy
J.
Patterson
D.
Computer
Architecture
Quantitative
Approach
San
Mateo
CA
Morgan
Kaufmann
2002
HENR84
Henry
G.
The
Fair
Share
Scheduler
AT&T
Bell
Laboratories
Technical
Journa
Octubre
1984
HERL90
Herlihy
M.
Methodology
for
Implementing
Highly
Concurrent
Data
Structures
Procee-
dings
of
the
Second
ACM
SIGPLAN
Symposium
on
Principles
and
Practices
of
Parallel
Pro-
gramming
Marzo
1990
HOAR74
Hoare
C.
Monitors
An
Operating
System
Structuring
Concept
Communications
of
the
ACM
Octubre
1974
HOAR85
Hoare
C.
Communicating
Sequential
Processes
Englewood
Cliffs
NJ
Prentice
Hall
1985
HOFR90
Hofri
M.
Proof
of
Mutual
Exclusion
Algorithm
Operating
Systems
Review
Enero
1990
HOLT72
Holt
R.
Some
Deadlock
Properties
of
Computer
Systems
Computing
Surveys
Septiembre
1972
HONG89
Hong
J.
X.
Towsley
D.
Performance
Analysis
of
Minimum
Laxity
and
Earliest
De-
adline
Scheduling
in
Real-Time
System
IEEE
Transactions
on
Computer
Diciembre
1989
HOWA73
Howard
J.
Mixed
Solutions
for
the
Deadlock
Problem
Communications
of
the
AC
Julio
1973
HP96
Hewlett
Packard
White
Paper
on
Clustering
Junio
1996
HUCK83
Huck
T.
Comparative
Analysis
of
Computer
Architectures
Stanford
University
Technical
Re-
port
Number
83-243
Mayo
1983
HUCK93
Huck
J.
Hays
J.
Architectural
Support
for
Translation
Table
Management
in
Large
Address
Space
Machines
Proceedings
of
the
20th
Annual
International
Symposium
on
Computer
Ar-
chitecture
Mayo
1993
Referencias
817
23-Referencias
12/5/05
16:33
Página
817HWAN99
Hwang
et
Designing
SSI
Clusters
with
Hierarchical
Checkpointing
and
Single
Spa-
ce
IEEE
Concurrency
Enero-Marzo
1999
HYMA66
Hyman
H.
Comments
on
Problem
in
Concurrent
Programming
Control
Communications
of
the
ACM
Enero
1966
IBM86
IBM
National
Technical
Support
Large
Systems
Multiple
Virtual
Storage
MVS
Virtual
Stora-
ge
Tuning
Cookbook
Dallas
Systems
Center
Technical
Bulletin
G320-0597
Junio
1986
INSO02a
Insolvibile
G.
Inside
the
Linux
Packet
Filter
Linux
Journal
Febrero
2002
INSO02b
Insolvibile
G.
Inside
the
Linux
Packet
Filter
Part
II
Linux
Journal
Marzo
2002
ISLO80
Isloor
S.
Marsland
T.
The
Deadlock
Problem
An
Overview
Computer
Septiembre
1980
IYER01
Iyer
S.
Druschel
P.
Anticipatory
Scheduling
Disk
Scheduling
Framework
to
Overcome
Deceptive
Idleness
in
Synchronous
O.
Proceedings
18th
ACM
Symposium
on
Operating
Systems
Principles
Octubre
2001
JACO98a
Jacob
B.
Mudge
T.
Virtual
Memory
Issues
of
Implementation
Computer
Junio
1998
JACO98b
Jacob
B.
Mudge
T.
Virtual
Memory
in
Contemporary
Microprocessors
IEEE
Micro
Agosto
1998
JOHN91
Johnston
B.
Javagal
R.
Datta
A.
Ghosh
S.
Distributed
Algorithm
for
Resource
Dead-
lock
Detection
Proceedings
Tenth
Annual
Phoenix
Conference
on
Computers
and
Communi-
cations
Marzo
1991
JOHN92
Johnson
T.
Davis
T.
Space
Efficient
Parallel
Buddy
Memory
Management
Proceedings
Third
International
Conference
on
Computers
and
Information
Mayo
1992
JONE80
Jones
S.
Schwarz
P.
Experience
Using
Multiprocessor
Systems—A
Status
Report
Com-
puting
Surveys
Junio
1980
JONE97
Jones
M.
What
Really
Happened
on
Mars
http://research.microsoft.com/~mbj/Mars_Path-
finder
Mars_Pathfinder.html
1997
JUL88
Jul
E.
Levy
H.
Hutchinson
N.
Black
A.
Fine-Grained
Mobility
in
the
Emerald
System
ACM
Transactions
on
Computer
Systems
Febrero
1988
JUL89
Jul
E.
Migration
of
Light-Weight
Processes
in
Emerald
Newsletter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
Systems
Invierno
1989
KANG98
Kang
S.
Lee
J.
Analysis
and
Solution
of
Non-Preemptive
Policies
for
Scheduling
Readers
and
Writers
Operating
Systems
Review
Julio
1998
KAPP00
Kapp
C.
Managing
Cluster
Computers
Dr.
Dobb
Journal
Julio
2000
KATZ89
Katz
R.
Gibson
G.
Patterson
D.
Disk
System
Architecture
for
High
Performance
Compu-
ting
Proceedings
of
the
IEEE
Diciembre
1989
KAY88
Kay
J.
Lauder
P.
Fair
Share
Scheduler
Communications
of
the
ACM
Enero
1988
KEFE92
Kefir
M.
Smolka
S.
OSP
An
Environment
for
Operating
System
Projects
Operating
Sys-
tems
Review
Abril
1992
KENT00
Kent
S.
On
the
Trail
of
Intrusions
into
Information
Systems
IEEE
Spectrum
Diciembre
2000
KEPH97a
Kephart
J.
Sorkin
G.
Chess
D.
White
S.
Fighting
Computer
Viruses
Scientific
Ameri-
can
Noviembre
1997
818
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
818KEPH97b
Kephart
J.
Sorkin
G.
Swimmer
B.
White
S.
Blueprint
for
Computer
Immune
System
Proceedings
Virus
Bulletin
International
Conference
Octubre
1997
KESS92
Kessler
R.
Hill
M.
Page
Placement
Algorithms
for
Large
Real-Indexed
Caches
ACM
Transactions
on
Computer
Systems
Noviembre
1992
KHAL93
Khalidi
Talluri
M.
Williams
D.
Nelson
M.
Virtual
Memory
Support
for
Multiple
Page
Sizes
Proceedings
Fourth
Workshop
on
Workstation
Operating
Systems
Octubre
1993
KIFE92
Kifer
M.
Smolka
S.
OSP
An
Environment
for
Operating
Systems
Projects
ACM
Opera-
ting
Systems
Review
Octubre
1992
KILB62
Kilburn
T.
Edwards
D.
Lanigan
M.
Sumner
F.
One-Level
Storage
System
IRE
Tran-
sactions
Abril
1962
KLEI90
Klein
D.
Foiling
the
Cracker
Survey
of
and
Improvements
to
Password
Security
Proce-
edings
UNIX
Security
Workshop
II
Agosto
1990
KLEI95
Kleiman
S.
Interrupts
as
Threads
Operating
System
Review
Abril
1995
KLEI96
Kleiman
S.
Shah
D.
Smallders
B.
Programming
with
Threads
Upper
Saddle
River
NJ
Prentice
Hall
1996
KLEI04
Kleinrock
L.
Queuing
Systems
Volume
Three
Computer
Applications
New
York
Wiley
2004
KNUT71
Knuth
D.
An
Experimental
Study
of
FORTRAN
Programs
Software
Practice
and
Experien-
ce
ol
1971
KNUT97
Knuth
D.
The
Art
of
Computer
Programming
Volume
Fundamental
Algorithms
Reading
MA
Addison-Wesley
1997
KORS90
Korson
T.
McGregor
J.
Understanding
Object-Oriented
Unifying
Paradigm
Communi-
cations
of
the
ACM
Septiembre
1990
KRIS94
Krishna
C.
Lee
eds
Special
Issue
on
Real-Time
Systems
Proceedings
of
the
IEEE
Enero
1994
KRIS03
Krishnaprasad
S.
Concurrent
Distributed
Programming
Illustrated
Using
the
Dining
Philosop-
hers
Problem
The
Journal
of
Computing
in
Small
College
Abril
2003
KRON90
Kron
P.
Software
Developer
Looks
at
OS/2
Byte
Agosto
1990
LAMP74
Lamport
L.
New
Solution
to
Dijkstra’s
Concurrent
Programming
Problem
Communica-
tions
of
the
ACM
Agosto
1974
LAMP78
Lamport
L.
Time
Clocks
and
the
Ordering
of
Events
in
Distributed
System
Communica-
tions
of
the
ACM
Julio
1978
LAMP80
Lampson
B.
Redell
D.
Experience
with
Processes
and
Monitors
in
Mesa
Communications
of
the
ACM
Febrero
1980
LAMP86
Lamport
L.
The
Mutual
Exclusion
Problem
Journal
of
the
ACM
Abril
1986
LAMP91
Lamport
L.
The
Mutual
Exclusion
Problem
Has
Been
Solved
Communications
of
the
ACM
Enero
1991
LARO92
LaRowe
R.
Holliday
M.
Ellis
C.
An
Analysis
of
Dynamic
Page
Placement
an
NUMA
Multiprocessor
Proceedings
1992
ACM
SIGMETRICS
and
Performance
Junio
1992
LEBL87
LeBlanc
T.
Mellor-Crummey
J.
Debugging
Parallel
Programs
with
Instant
Replay
IEEE
Transactions
on
Computers
Abril
1987
Referencias
819
23-Referencias
12/5/05
16:33
Página
819LEE93
Lee
Krishna
C.
eds
Readings
in
Real-Time
Systems
Alamitos
CA
IEEE
Computer
Society
Press
1993
LELA86
Leland
W.
Ott
T.
Load-Balancing
Heuristics
and
Process
Behavior
Proceedings
ACM
SigMetrics
Performance
1986
Conference
1986
LERO76
Leroudier
J.
Potier
D.
Principles
of
Optimality
for
Multiprogramming
Proceedings
In-
ternational
Symposium
on
Computer
Performance
Modeling
Measurement
and
Evaluatio
Marzo
1976
LETW88
Letwin
G.
Inside
OS/2
Redmond
WA
Microsoft
Press
1988
LEUT90
Leutenegger
S.
Vernon
M.
The
Performance
of
Multiprogrammed
Multiprocessor
Schedu-
ling
Policies
Proceedings
Conference
on
Measurement
and
Modeling
of
Computer
System
Mayo
1990
LEVI99
Levine
J.
Linkers
and
Loaders
New
York
Elsevier
Science
and
Technology
1999
LEVI03a
Levine
G.
Defining
Deadlock
Operating
Systems
Review
Enero
2003
LEVI03b
Levine
G.
Defining
Deadlock
with
Fungible
Resources
Operating
Systems
Review
Julio
2003
LEWI96
Lewis
B.
Berg
D.
Threads
Upper
Saddle
River
NJ
Prentice
Hall
1996
LIED95
Liedtke
J.
On
-Kernel
Construction
Proceedings
of
the
Fifteenth
ACM
Symposium
on
Ope-
rating
Systems
Principles
Diciembre
1995
LIED96a
Liedtke
J.
Toward
Real
Microkernels
Communications
of
the
ACM
Septiembre
1996
LIED96b
Liedtke
J.
Microkernels
Must
and
Can
Be
Small
Proceedings
Fifth
International
Workshop
on
Object
Orientation
in
Operating
Systems
Octubre
1996
LIND04
Lindsley
R.
What’s
New
in
the
2.6
Scheduler
Linux
Journal
Marzo
2004
LIST93
Lister
A.
Eager
R.
Fundamentals
of
Operating
Systems
New
York
Springer-Verlag
1993
LIU73
Liu
C.
Layland
J.
Scheduling
Algorithms
for
Multiprogramming
in
Hard
Real-time
Envi-
ronment
Journal
of
the
ACM
Febrero
1973
LIU00
Liu
J.
Real-Time
Systems
Upper
Saddle
River
NJ
Prentice
Hall
2000
LIV
A90
Livadas
P.
File
Structures
Theory
and
Practice
Englewood
Cliffs
NJ
Prentice
Hall
1990
LOVE04a
Love
R.
Linux
Kernel
Development
Indianapolis
IN
Sams
Publishing
2004
LOVE04b
Love
R.
Schedulers
Linux
Journal
Febrero
2004
LYNC96
Lynch
N.
Distributed
Algorithms
San
Francisco
CA
Morgan
Kaufmann
1996
MADS93
Madsen
J.
World
Record
in
Password
Checking
USENET
comp.security.misc
news-group
Agosto
18
1993
MAEK87
Maekawa
M.
Oldehoeft
A.
Oldehoeft
R.
Operating
Systems
Advanced
Concepts
Menlo
Park
CA
Benjamin
Cummings
1987
MAJU88
Majumdar
S.
Eager
D.
Bunt
R.
Scheduling
in
Multiprogrammed
Parallel
Systems
Pro-
ceedings
Conference
on
Measurement
and
Modeling
of
Computer
Systems
Mayo
1988
MART88
Martin
J.
Principles
of
Data
Communication
Englewood
Cliffs
NJ
Prentice
Hall
1988
MASS97
Massiglia
P.
editor
The
RAID
Book
Storage
System
Technology
Handbook
St
Peter
MN
The
Raid
Advisory
Board
1997
820
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
820MAUR01
Mauro
J.
McDougall
R.
Solaris
Internals
Core
Kernel
Architecture
Palo
Alto
CA
Sun
Microsystems
Press
2001
MCHU00
McHugh
J.
Christie
A.
Allen
J.
The
Role
of
Intrusion
Detection
Systems
IEEE
Softwa-
re
Septiembre
Octubre
2000
MCKU96
McKusick
M.
Bostic
K.
Karels
M.
Quartermain
J.
The
Design
and
Implementation
of
the
4.4BSD
UNIX
Operating
System
Reading
MA
Addison-Wesley
1996
MEE96a
Mee
C.
Daniel
E.
eds
Magnetic
Recording
Technology
New
York
McGraw-Hill
1996
MEE96b
Mee
C.
Daniel
E.
eds
Magnetic
Storage
Handbook
New
York
McGraw-Hill
1996
MESS96
Messer
A.
Wilkinson
T.
Components
for
Operating
System
Design
Proceedings
Fifth
In-
ternational
Workshop
on
Object
Orientation
in
Operating
Systems
Octubre
1996
MILE92
Milenkovic
M.
Operating
Systems
Concepts
and
Design
New
York
McGraw-Hill
1992
MILO00
Milojicic
D.
Douglis
F.
Paindaveine
Wheeler
R.
Zhou
S.
Process
Migration
ACM
Computing
Surveys
Septiembre
2000
MORG92
Morgan
K.
The
RTOS
Difference
Byte
Agosto
1992
MOSB02
Mosberger
D.
Eranian
S.
IA-64
Linux
Kernel
Upper
Saddle
River
NJ
Prentice
Hall
2002
MS96
Microsoft
Corp
Microsoft
Windows
NT
Workstation
Resource
Kit
Redmond
WA
Microsoft
Press
1996
NACH97
Nachenberg
C.
Computer
Virus-Antivirus
Coevolution
Communications
of
the
ACM
Enero
1997
NEHM75
Nehmer
J.
Dispatcher
Primitives
for
the
Construction
of
Operating
System
Kernels
Acta
In-
formatica
vol
1975
NELS88
Nelson
M.
Welch
B.
Ousterhout
J.
Caching
in
the
Sprite
Network
File
System
ACM
Transactions
on
Computer
Systems
Febrero
1988
NELS91
Nelson
G.
Systems
Programming
with
Modula-3
Englewood
Cliffs
NJ
Prentice
Hall
1991
NG98
Ng
S.
Advances
in
Disk
Technology
Performance
Issues
Computer
Mayo
1989
NUTT94
Nuttal
M.
Brief
Survey
of
Systems
Providing
Process
or
Object
Migration
Facilities
Ope-
rating
Systems
Review
Octubre
1994
NUTT04
Nutt
G.
Operating
System
Reading
MA
Addison-Wesley
2004
OUST85
Ousterhout
J.
et
Trace-Drive
Analysis
of
the
UNIX
4.2
BSD
File
System
Proceedings
Tenth
ACM
Symposium
on
Operating
System
Principles
1985
OUST88
Ousterhout
J.
et
The
Sprite
Network
Operating
System
Computer
Febrero
1988
PAI00
Pai
Druschel
P.
Zwaenepoel
W.
IO-Lite
Unified
Buffering
and
Caching
Sys-
tem
ACM
Transactions
on
Computer
Systems
Febrero
2000
PANW88
Panwar
S.
Towsley
D.
Wolf
J.
Optimal
Scheduling
Policies
for
Class
of
Queues
with
Customer
Deadlines
in
the
Beginning
of
Service
Journal
of
the
ACM
Octubre
1988
PATT82
Patterson
D.
Sequin
C.
VLSI
RISC
Computer
Septiembre
1982
PATT85
Patterson
D.
Reduced
Instruction
Set
Computers
Communications
of
the
ACM
Enero
1985
PATT88
Patterson
D.
Gibson
G.
Katz
R.«A
Case
for
Redundant
Arrays
of
Inexpensive
Disks
RAID
Proceedings
ACM
SIGMOD
Conference
of
Management
of
Data
Junio
1988
Referencias
821
23-Referencias
12/5/05
16:33
Página
821PATT98
Patterson
D.
Hennessy
J.
Computer
Organization
and
Design
The
Hardware
Software
Inter-
face
San
Mateo
CA
Morgan
Kaufmann
1998
PEIP03
Pieprzyk
J.
Hardjono
T.
Seberry
J.
Fundamentals
of
Computer
Security
New
York
Sprin-
ger
2003
PERR03
Perrine
T.
The
End
of
crypt
Passwords
Please
login
Diciembre
2003
PETE77
Peterson
J.
Norman
T.
Buddy
Systems
Communications
of
the
ACM
Junio
1977
PETE81
Peterson
G.
Myths
About
the
Mutual
Exclusion
Problem
Information
Processing
Letters
Junio
1981
PFLE97
Pfleeger
C.
Security
in
Computing
Upper
Saddle
River
NJ
Prentice
Hall
PTR
1997
PINK89
Pinkert
J.
Wear
L.
Operating
Systems
Concepts
Policies
and
Mechanisms
Englewood
Cliffs
NJ
Prentice
Hall
1989
PIZZ89
Pizzarello
A.
Memory
Management
for
Large
Operating
System
Proceedings
Internatio-
nal
Conference
on
Measurement
and
Modeling
of
Computer
Systems
Mayo
1989
POPE85
Popek
G.
Walker
B.
The
LOCUS
Distributed
System
Architecture
Cambridge
MA
MIT
Press
1985
PORR92
Porras
P.
STAT
State
Transition
Analysis
Tool
for
Intrusion
Detection
Master’s
Thesis
Uni-
versity
of
California
at
Santa
Barbara
Julio
1992
PRAM84
Pramanik
S.
Weinberg
B.
The
Implementation
Kit
with
Monitors
SIGPLAN
Notices
Number
1984
PRZY88
Przybylski
S.
Horowitz
M.
Hennessy
J.
Performance
Trade-offs
in
Cache
Design
Pro-
ceedings
Fifteenth
Annual
International
Symposium
on
Computer
Architecture
Junio
1988
RAMA94
Ramamritham
K.
Stankovic
J.
Scheduling
Algorithms
and
Operating
Systems
Support
for
Real-Time
Systems
Proceedings
of
the
IEEE
Enero
1994
RASH88
Rashid
R.
et
Machine-Independent
Virtual
Memory
Management
for
Paged
Uniprocessor
and
Multiprocessor
Architectures
IEEE
Transactions
on
Computer
Agosto
1988
RAYN86
Raynal
M.
Algorithms
for
Mutual
Exclusion
Cambridge
MA
MIT
Press
1986
RAYN88
Raynal
M.
Distributed
Algorithms
and
Protocols
New
York
Wiley
1988
RAYN90
Raynal
M.
Helary
J.
Synchronization
and
Control
of
Distributed
Systems
and
Programs
New
York
Wiley
1990
RICA81
Ricart
G.
Agrawala
A.«An
Optimal
Algorithm
for
Mutual
Exclusion
in
Computer
Net-
works
Communications
of
the
ACM
Enero
1981
Corrigendum
Communications
of
the
ACM
Septiembre
1981
RICA83
Ricart
G.
Agrawala
A.«Author’s
Response
to
On
Mutual
Exclusion
in
Computer
Networks
by
Carvalho
Roucairol
Communications
of
the
ACM
Febrero
1983
RIDG97
Ridge
D.
et
Beowulf
Harnessing
the
Power
of
Parallelism
in
Pile-of-PCs
Proceedings
IEEE
Aerospace
1997
RITC74
Ritchie
D.
Thompson
K.
The
UNIX
Time-Sharing
System
Communications
of
the
ACM
Julio
1974
RITC78
Ritchie
D.
UNIX
Time-Sharing
System
Retrospective
The
Bell
System
Technical
Jour-
nal
Julio-Agosto
1978
822
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
822ROBI90
Robinson
J.
Devarakonda
M.
Data
Cache
Management
Using
Frequency-Based
Replace-
ment
Proceedings
Conference
on
Measurement
and
Modeling
of
Computer
Systems
Mayo
1990
RODR02
Rodriguez
A.
et
TCP
IP
Tutorial
and
Technical
Overview
Upper
Saddle
River
NJ
Prentice
Hall
2002
ROSC03
Rosch
W.
The
Winn
L.
Rosch
Hardware
Bible
Indianapolis
IN
Sams
2003
ROSE78
Rosenkrantz
D.
Stearns
R.
Lewis
P.
System
Level
Concurrency
Control
in
Distributed
Database
Systems
ACM
Transactions
on
Database
Systems
Junio
1978
RUBI97
Rubini
A.
The
Virtual
File
System
in
Linux
Linux
Journal
Mayo
1997
RUDO90
Rudolph
B.
Self-Assessment
Procedure
XXI
Concurrency
Communications
of
the
ACM
Mayo
1990
SAND94
Sandhu
Samarati
P.
Access
Control
Principles
and
Practice
IEEE
Communications
Septiembre
1994
SATY81
Satyanarayanan
M.
Bhandarkar
D.
Design
Trade-Offs
in
AX-11
Translation
Buffer
Orga-
nization
Computer
Diciembre
1981
SAUE81
Sauer
Chandy
K.
Computer
Systems
Performance
Modeling
Englewood
Cliffs
NJ
Pren-
tice
Hall
1981
SCHA62
Schay
G.
Spruth
W.
Analysis
of
File
Addressing
Method
Communications
of
the
ACM
Agosto
1962
SCHM97
Schmidt
D.
Distributed
Object
Computing
IEEE
Communications
Magazine
Febrero
1997
SCHN96
Schneier
B.
Applied
Cryptography
New
York
Wiley
1996
SCHN99
Schneier
B.
The
Trojan
Horse
Race
Communications
of
the
ACM
Septiembre
1999
SCHW96
Schwaderer
W.
Wilson
A.
Understanding
Subsystems
Milpitas
CA
Adaptec
Press
1996
SELT90
Seltzer
M.
Chen
P.
Ousterhout
J.
Disk
Scheduling
Revisited
Proceedings
USENIX
Winter
Technical
Conference
Enero
1990
SEVC96
Sevcik
P.
Designing
High-Performance
Web
Site
Business
Communications
Review
Mar-
zo
1996
SHA90
Sha
L.
Rajkumar
R.
Lehoczky
J.
Priority
Inheritance
Protocols
An
Approach
to
Real-
Time
Synchronization
IEEE
Transactions
on
Computers
Septiembre
1990
SHA91
Sha
L.
Klein
M.
Goodenough
J.
Rate
Monotonic
Analysis
for
Real-Time
Systems
TILB91
SHA94
Sha
L.
Rajkumar
R.
Sathaye
S.
Generalized
Rate-Monotonic
Scheduling
Theory
Fra-
mework
for
Developing
Real-Time
Systems
Proceedings
of
the
IEEE
Enero
1994
SHEN02
Shene
C.
Multithreaded
Programming
Can
Strengthen
an
Operating
Systems
Course
Com-
puter
Science
Education
Journal
Diciembre
2002
SHIV92
Shivaratri
N.
Krueger
P.
Singhal
M.«Load
Distributing
for
Locally
Distributed
Systems
Computer
Diciembre
1992
SHNE84
Shneiderman
B.
Response
Time
and
Display
Rate
in
Human
Performance
with
Computers
ACM
Computing
Surveys
Septiembre
1984
Referencias
823
23-Referencias
12/5/05
16:33
Página
823SHOR75
Shore
J.
On
the
External
Storage
Fragmentation
Produced
by
First-Fit
and
Best-Fit
Allocation
Strategies
Communications
of
the
ACM
Agosto
1975
SHUB03
Shub
C.
Unified
Treatment
of
Deadlock
Journal
of
Computing
in
Small
College
Octu-
bre
2003
Disponible
biblioteca
digital
ACM
SILB98
Silberschatz
A.
Galvin
P.
Operating
System
Concepts
Reading
MA
Addison-Wesley
1998
SILB04
Silberschatz
A.
Galvin
P.
Gagne
G.
Operating
System
Concepts
with
Java
Reading
MA
Addison-Wesley
2004
SING94a
Singhal
M.
Shivaratri
N.
Advanced
Concepts
in
Operating
Systems
New
York
McGraw-
Hill
1994
SING94b
Singhal
M.
Deadlock
Detection
in
Distributed
Systems
CASA94
SINH97
Sinha
P.
Distributed
Operating
Systems
Piscataway
NJ
IEEE
Press
1997
SMIT82
Smith
A.
Cache
Memories
ACM
Computing
Surveys
Septiembre
1982
SMIT83
Smith
D.
Faster
Is
Better
Business
Case
for
Subsecond
Response
Time
Computerworld
Abril
18
1983
SMIT85
Smith
A.«Disk
Cache—Miss
Ratio
Analysis
and
Design
Considerations
ACM
Transactions
on
Computer
Systems
Agosto
1985
SMIT88
Smith
J.
Survey
of
Process
Migration
Mechanisms
Operating
Systems
Review
Julio
1988
SMIT89
Smith
J.
Implementing
Remote
fork
with
Checkpoint
restart
Newsletter
of
the
IEEE
Com-
puter
Society
Technical
Committee
on
Operating
Systems
Winter
1989
SOLO00
Solomon
D.
Inside
Microsoft
Windows
2000
Redmond
WA
Microsoft
Press
2000
SPAF92
Spafford
E.
Observing
Reusable
Password
Choices
Proceedings
UNIX
Security
Symposium
III
Septiembre
1992
STAL03a
Stallings
W.
Computer
Organization
and
Architecture
6th
ed
Upper
Saddle
River
NJ
Prenti-
ce
Hall
2003
STAL03b
Stallings
W.
Cryptography
and
Network
Security
Principles
and
Practice
Third
Edition
Up-
per
Saddle
River
NJ
Prentice
Hall
2003
STAL04
Stallings
W.
Computer
Networking
with
Internet
Protocols
and
Technology
Upper
Saddle
Ri-
NJ
Prentice
Hall
2004
STAN89
Stankovic
J.
Ramamrithan
K.
The
Spring
Kernel
New
Paradigm
for
Real-Time
Opera-
ting
Systems
Operating
Systems
Review
Julio
1989
STAN93
Stankovic
J.
Ramamritham
K.
eds
Advances
in
Real-Time
Systems
Alamitos
CA
IEEE
Computer
Society
Press
1993
STEP93
Stephenson
P.
Preventive
Medicine
LAN
Magazine
Noviembre
1993
STON93
Stone
H.
High-Performance
Computer
Architecture
Reading
MA
Addison-Wesley
1993
STRE83
Strecker
W.
Transient
Behavior
of
Cache
Memories
ACM
Transactions
on
Computer
Sys-
tems
Noviembre
1983
STRO88
Stroustrup
B.
What
is
Object-Oriented
Programming
IEEE
Software
Mayo
1988
824
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
824SNYD93
Snyder
A.
The
Essence
of
Objects
Concepts
and
Terms
IEEE
Software
Enero
1993
SUZU82
Suzuki
I.
Kasami
T.
An
Optimality
Theory
for
Mutual
Exclusion
Algorithms
in
Computer
Networks
Proceedings
of
the
Third
International
Conference
on
Distributed
Computing
Sys-
tems
Octubre
1982
TALL92
Talluri
M.
Kong
S.
Hill
M.
Patterson
D.
Tradeoffs
in
Supporting
Two
Page
Sizes
Pro-
ceedings
of
the
19th
Annual
International
Symposium
on
Computer
Architectur
Mayo
1992
TAMI83
Tamir
Sequin
C.
Strategies
for
Managing
the
Register
File
in
RISC
IEEE
Transactions
on
Computers
Noviembre
1983
TANE78
Tanenbaum
A.
Implications
of
Structured
Programming
for
Machine
Architecture
Commu-
nications
of
the
ACM
Marzo
1978
TANE97
Tanenbaum
A.
Woodhull
A.
Operating
Systems
Design
and
Implementation
Upper
Saddle
River
NJ
Prentice
Hall
1997
TANE01
Tanenbaum
A.
Modern
Operating
Systems
Upper
Saddle
River
NJ
Prentice
Hall
2001
TAIV96
Taivalsaari
A.
On
the
Nature
of
Inheritance
ACM
Computing
Surveys
Septiembre
1996
TEL01
Tel
G.
Introduction
to
Distributed
Algorithms
Cambridge
Cambridge
University
Press
2001
THAD81
Thadhani
A.
Interactive
User
Productivity
IBM
Systems
Journal
1981
THOM84
Thompson
K.
Reflections
on
Trusting
Trust
Deliberate
Software
Bugs
Communications
of
the
ACM
Agosto
1984
TILB91
Tilborg
A.
Koob
eds
Foundations
of
Real-Time
Computing
Scheduling
and
Resource
Management
Boston
Kluwer
Academic
Publishers
1991
TIME90
Time
Inc
Computer
Security
Understanding
Computers
Serie
s.
Alexandria
Time-Life
Books
1990
TIME02
TimeSys
Corp
Priority
Inversion
Why
You
Care
and
What
to
Do
About
It
TimeSys
White
Paper
2002
http://www.techonline.com/community/
ed_resource
tech_paper/21779
TUCK89
Tucker
A.
Gupta
A.
Process
Control
and
Scheduling
Issues
for
Multiprogrammed
Shared-
Memory
Multiprocessors
Proceedings
Twelfth
ACM
Symposium
on
Operating
Systems
Prin-
ciples
Diciembre
1989
AHA96
Vahalia
U.
UNIX
Internals
The
New
Frontiers
Upper
Saddle
River
NJ
Prentice
Hall
1996
VINO97
Vinoski
S.
CORBA
Integrating
Diverse
Applications
Within
Distributed
Heterogeneous
En-
vironments
IEEE
Communications
Magazine
Febrero
1997
WALK89
Walker
B.
Mathews
R.
Process
Migration
in
AIX’s
Transparent
Computing
Facility
Newsletter
of
the
IEEE
Computer
Society
Technical
Committee
on
Operating
System
Invierno
1989
WARD80
Ward
S.
TRIX
Network-Oriented
Operating
System
Proceedings
COMP
1980
WARR91
Warren
C.
Rate
Monotonic
Scheduling
IEEE
Micro
Junio
1991
WAYN94a
Wayner
P.
Small
Kernels
Hit
it
Big
Byte
Enero
1994
WAYN94b
Wayner
P.
Objects
on
the
Marzo
Byte
Enero
1994
WEIZ81
Weizer
N.
History
of
Operating
Systems
Datamation
Enero
1981
Referencias
825
23-Referencias
12/5/05
16:33
Página
825WEND89
Wendorf
J.
Wendorf
R.
Tokuda
H.
Scheduling
Operating
System
Processing
on
Small-
Scale
Microprocessors
Proceedings
22nd
Annual
Hawaii
International
Conference
on
System
Science
Enero
1989
WHIT99
White
S.
Swimmer
M.
Pring
E.
Arnold
B.
Chess
D.
Morar
J.
Anatomy
of
Commer-
cial-Grade
Immune
System
IBM
White
Paper
1999
www.research.ibm.com/antivirus/SciPa-
pers.htm
WIED87
Wiederhold
G.
File
Organization
for
Database
Design
New
York
McGraw-Hill
1987
WOOD86
Woodside
C.
Controllability
of
Computer
Performance
Tradeoffs
Obtained
Using
Controlled-
Share
Queue
Schedulers
IEEE
Transactions
on
Software
Engineerin
Octubre
1986
WOOD89
Woodbury
P.
et
Shared
Memory
Multiprocessors
The
Right
Approach
to
Parallel
Proces-
sing
Proceedings
COMPCON
Spring
89
Marzo
1989
WORT94
Worthington
B.
Ganger
G.
Patt
Scheduling
Algorithms
for
Modern
Disk
Drives
ACM
SiGMETRICS
Mayo
1994
WRIG95
Wright
G.
Stevens
W.
TCP
IP
Illustrated
Volume
The
Implementation
Reading
MA
Addison-Wesley
1995
YOUN87
Young
M.
et
The
Duality
of
Memory
and
Communication
in
the
Implementation
of
Multiprocessor
Operating
System
Proceedings
of
the
Eleventh
ACM
Symposium
on
Operating
Systems
Principles
Diciembre
1987
ZAHO90
Zahorjan
J.
McCann
C.
Processor
Scheduling
in
Shared
Memory
Multiprocessors
Proce-
edings
Conference
on
Measurement
and
Modeling
of
Computer
Systems
Mayo
1990
ZAJC93
Zajcew
R.
et
An
OSF/1
UNIX
for
Massively
Parallel
Multicomputers
Proceedings
Win-
ter
USENIX
Conference
Enero
1993
ZEAD97
Zeadally
S.
An
Evaluation
of
the
Real-Time
Performance
of
SVR4.0
and
SVR4.2
Operating
Systems
Review
Enero
1977
826
Sistemas
operativos
Aspectos
internos
principios
diseño
23-Referencias
12/5/05
16:33
Página
826AES
Advanced
Encryption
Standard
Estándar
cifrado
avanzado
API
Application
Programming
Interface
Interfaz
programación
aplicaciones
CD
Compact
Disk
Disco
compacto
CORBA
Common
Object
Request
Broker
Architecture
Arquitectura
común
mediador
solicitud
objeto
CPU
Central
Processing
Unit
Unidad
central
proceso
CTSS
Compatible
Time-Sharing
System
Sistema
tiempo
compartido
compatible
DES
Data
Encryption
Standard
Estándar
cifrado
datos
DMA
Direct
Memory
Access
Acceso
directo
memoria
DVD
Digital
Versatile
Disk
Disco
digital
versátil
Entrada
Salida
FAT
File
Allocation
Table
Tabla
asignación
ficheros
FCFS
First
Come
First
Served
llegar
servirse
FIFO
First
In
First
Out
entrar
salir
GUI
Graphical
User
Interface
Interfaz
gráfica
usuario
IP
Internet
Protocol
Protocolo
Internet
IBM
International
Business
Machines
Corporation
Corporación
Internacional
Máquinas
Em-
presa
IPC
InterProcess
Communication
Comunicación
procesos
JCL
Job
Control
Language
Lenguaje
control
trabajos
LAN
Local
Area
Network
Red
área
local
LIFO
Last
In
First
Out
entrar
salir
LRU
Least
Recently
Used
recientemente
usado
MVS
Multiple
Virtual
Storage
Almacenamiento
virtual
múltiple
NTFS
NT
File
System
Sistema
ficheros
NT
NUMA
Nonuniform
Memory
Access
Acceso
memoria
uniforme
ORB
Object
Request
Broker
Mediador
solicitud
objeto
OSI
Open
Systems
Interconnection
Interconexión
sistemas
abiertos
PC
Program
Counter
Contador
programa
PSW
Processor
Status
Word(Palabra
programa
PCB
Process
Control
Block
Bloque
control
proceso
Acrónimos
827
CRÓNIMOS
24-Acronimos
12/5/05
16:34
Página
827RAID
Redundant
Array
of
Independent
Disks
Vector
redundante
discos
independientes
RISC
Reduced
Instruction
Set
Computer
Computador
juego
instrucciones
reducido
RPC
Remote
Procedure
Call
Llamada
procedimiento
remoto
SMP
Symmetric
Multiprocessing
or
Symmetric
Multiprocessor
Multiprocesamiento
simétrico
Mul-
tiprocesador
simétrico
SPOOL
Simultaneous
Peripheral
Operation
On
Line
Operación
simultánea
línea
periféricos
SVR4
System
Release
TCP
Transmission
Control
Protocol
Protocolo
control
transmisión
TLB
Translation
Lookaside
Buffer
Buffer
traducción
anticipada
UDP
User
Datagram
Protocol
Protocolo
datagramas
usuario
828
Sistemas
operativos
Aspectos
internos
principios
diseño
24-Acronimos
12/5/05
16:34
Página
828A
Acceso
dispositivos
55
Acceso
sistema
55
Acceso
controlado
ficheros
55
Acceso
directo
memoria
Direct
memory
access
DMA
17
36-37
86
494-496
Activación
procesos
455
Activación
objeto
núcleo
Windows
531
alerta
531
objeto
dispositivo
núcleo
531
objeto
evento
núcleo
531
puertos
finalización
531
Activador
111
Actualizar_Uno
550
Acumulador
AC
15
Adobe
PageMaker
hilos
164-165
Advanced
Encryption
Standard
AES
738
Afinidad
procesador
asociada
hilo
183
Afinidad
procesador
asociada
proceso
183
Afinidad
débil
187
Afinidad
fuerte
187
Aislamiento
procesos
71
Aislamiento
723
Algoritmo
Dekker
212
744-748
Algoritmo
detección
interbloqueo
275-276
Algoritmo
instantánea
distribuida
662-665
Algoritmo
paso
testigo
674
Algoritmo
Peterson
228
748
Algoritmo
remplazo
34
318
362-367
Algoritmo
banquero
270
Algoritmo
Rivest-Shamir-Adleman
RSA
741
Algoritmos
34
212
218
220
225-226
270
275
314-315
317-318
362-367
374-375
382-383
385
406-427
466-
468
662-665
666-667
674
741
744-748
algoritmo
instantánea
distribuida
662-665
centralizada
exclusión
mutua
665-666
Dekker
212
228
744-748
banquero
270
detección
interbloqueo
273-276
distribuida
exclusión
mutua
666-667
exclusión
mutua
218
220
frecuencia
fallos
página
PFF
374-375
paso
testigo
674
Peterson
228
748
planificación
tiempo-real
466-468
planificación
uniprocesador
406-427
reemplazo
páginas
LINUX
385
reemplazo
34
318
361-367
Rivest-Shamir-Adleman
RSA
741
sistema
buddy
perezoso
382-383
ubicación
memoria
314-315
317-318
allocb
382
Almacenamiento
memoria
plazo
71
Ambicioso
sucias
656
Ambicioso
655
Ámbito
reemplazo
370
Amenazas
seguridad
690-695
componentes
692-695
datos
693
hardware
692
líneas
comunicación
redes
693-695
software
692-693
tipos
690-692
Análisis
colas
rendimiento
planificación
421-424
Análisis
tráfico
694
Antivirus
estrategias
719-720
anyadir
231-232
234
Aplicación
paralela
640
Aplicaciones
cliente
servidor
622-628
aplicaciones
bases
datos
623-624
arquitectura
capas
626
clases
624-626
consistencia
caché
ficheros
626-628
Aplicaciones
bases
datos
623-624
Aplicaciones
usuario
87
Aplicaciones
estructuradas
202
Área
UNIX
147
Arquitectura
Común
Mediador
Solicitud
Objeto
Common
Object
Request
Broker
Architecture
CORBA
772-775
Arquitectura
comunicaciones
596
Arquitectura
multiprocesamiento
simétrico
SMP
172-174
múltiples
instrucciones
múltiples
flujos
datos
MIMD
172
multiprocesador
memoria
compartida
173
mútiples
instrucciones
único
flujo
datos
MISD
172
única
instrucción
múltiples
flujos
datos
SIMD
172
única
instrucción
único
flujo
datos
SISD
172
Arquitectura
protocolos
597-605
aplicaciones
TCP
IP
605
arquitectura
protocolos
TCP
IP
599-605
capas
TCP
IP
599-600
IP
IPv6
601-602
operación
TCP
IP
602-604
TCP
UDP
600-601
Arquitectura
Windows
2000
85-88
Bibliotecas
enlace
dinámico
Dynamic
Link
Libraries
DLL
87-88
capa
abstracción
hardware
hardware
abstraction
layer
HAL
86
88
componentes
núcleo
86
interfaz
programación
aplicaciones
Application
Pro-
gram
Interface
API
86
módulos
ejecutivos
86-87
Índice
Analítico
829
NDICE
NALÍTICO
25-Indice
analitico
13/5/05
16:55
Página
829organización
sistema
operativo
86-87
procesos
usuario
87-88
SMP
soporte
86
89
utilidad
llamada
procedimiento
local
Local
Proce-
dure
Call
LPC
87
utilidad
llamada
procedimiento
remoto
Remote
Procedure
Call
RPC
87
Arquitectura
maestro
esclavo
173
Arquitectura
micronúcleo
80
176-177
sistemas
operativos
monolíticos
176
sistemas
operativos
capas
176
sistemas
operativos
80
Arquitectura
85-88
92
172-174
176-177
187-188
551-
552
597-599
626
629-630
640-641
computador
cluster
640-641
maestro
esclavo
173
micronúcleo
176-177
middleware
629-630
multihilo
Solaris
187-189
multiprocesamiento
simétrico
SMP
172-174
protocolo
597-598
sistema
ficheros
551-553
sistemas
UNIX
tradicional
91-93
capas
cliente
servidor
626
Windows
2000
85
Arquitecturas
procesadores
paralelos
173
Asignación
contigua
568-569
Asignación
bloques
registros
564-566
expandidos
longitud
variable
565
fijo
565
métodos
565
expandidos
longitud
variable
565
Asignación
procesador
dedicado
460-462
Asignación
procesos
procesadores
454-455
Asignación
encadenada
568-569
Asignación
fija
370
Asignación
indexada
570-571
asignación
láminas
slab
allocation
386
Asignación
gestión
automática
71-71
Asignada
paginación
Windows
387
Ataque
fuerza-bruta
737
Ataques
activos
695-696
Ataques
pasivos
693-695
atomic_t
285
Autenticidad
seguridad
sistema
operativo
73
Autoejecución
719
Automacro
719
Barreras
LINUX
289-291
barrier
291
Base
datos
549
Base
pila
48
Beneficios
97
enlace
dinámico
96
módulos
apilables
97
tabla
97
Beowulf
646-648
características
646-647
LINUX
clusters
646-648
software
647-648
Berkeley
Software
Distribution
BSD
95
Bibliotecas
enlace
dinámico
Dynamic
Link
Libraries
DLL
87-88
Bibliotecas
pthread
195
BITMAP_SIZE
479
Bits
control
349
Bloque
arranque
UNIX
578
Bloque
control
proceso
BCP
109-110
128
130
134-
135
Bloqueado
Bloqueado
Suspendido
122
Bloqueado
Listo
119
Bloqueado
Saliente
119
Bloqueado
Suspendido
Bloqueado
124
Bloqueado
Suspendido
Listo
Suspendido
123
Bloqueo
marcos
362
Bloques
datos
UNIX
578
Bloques
31
Bomba
lógica
715
Borrar_Uno
550
Bucles
while
233-234
Buffer
circular
503
Buffer
traducción
anticipada
TLB
349-351
Buffer
doble
502-503
Buffer
único
501-502
bufferacotado
231-232
Buffering
páginas
367-368
Buffers
mensaje
disponibilidad
682-685
Bus
sistema
10
Búsqueda
asociativa
395
Búsqueda
binaria
395
Búsqueda
secuencial
395
Búsqueda
ejecución
instrucción
14
Cabeza
característica
disco
537
Cache
buffers
UNIX
524-525
Cache
disco
520-522
consideraciones
diseño
520-522
consideraciones
rendimiento
522
Cache
páginas
LINUX
529
Cambio
139-140
Cambio
proceso
137-140
cambio
140
fallo
memoria
138
interrupción
138
interrupción
reloj
138
llamada
sistema
139
mecanismos
interrupciones
138-139
trap
139
Campo
clave
556
Campo
549
Capa
abstracción
hardware
Hardware
Abstraccion
La-
yer
HAL
86
88
830
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
830Capa
acceso
red
599
Capa
aplicación
600
Capa
transporte
600
Capa
física
599
Caparazón
Interfaz
mandatos
79
Carga
absoluta
333
Carga
dinámica
tiempo
real
334
Carga
reubicable
334
Carga
331-335
absoluta
333
dinámica
tiempo
real
334
función
332
reubicable
334
cbroadcast
234
CD
grabable
CD-R
544
CD
modificable
CD-RW
545
Ceder
paso
Solaris
191
Cerrojo
cíclico
simple
286-287
cerrojo
escritura
293
cerrojo
escritura
293
Cerrojo
exclusión
mutua
Solaris
292-293
Cerrojo
lectura
escritura
Solaris
293
cerrojo
213
Cerrojos
cíclicos
básicos
LINUX
286-288
Cerrojos
cíclicos
lectura-escritura
288
Cerrojos
cíclicos
LINUX
286
básicos
286
lectura-escritura
288
implementación
286
simples
286-287
Ciclo
instrucción
14
19-20
Cifrado
unidireccional
702
Cilindro
característica
disco
539
Círculo
vicioso
livelock
203
Clase
objeto
89
769-771
Clave
privada
741
Clave
pública
741
Clave
secreta
736
741
Cliente
ligero
626
Cliente
pesado
626
Cliente
620
Cluster
173
584
Cluster
636-648
Beowulf
646-648
arquitectura
computadores
640-641
configuraciones
637-639
aspectos
diseño
SO
639-640
gestión
fallos
639
LINUX
646-648
equilibrado
carga
640
computación
paralela
640
servicios
funciones
640
SMP
comparación
641
Sun
643-646
servidor
Windows
642-643
cnotify
233
Código
programa
109
Códigos
condición
13
Cola
caracteres
UNIX
525
Cola
manejador
UNIX
524
Cola
distribuida
669-673
Compactación
316
Compartición
carga
458-459
Compartición
ficheros
563-564
acceso
simultáneo
564
derechos
acceso
563
Compartición
210-211
310
358
cooperación
procesos
210-211
gestión
memoria
310
segmentación
357-358
Competencia
procesos
208-210
Compilación
paralela
640
Componentes
computador
10-11
Componentes
núcleo
LINUX
97-99
609
controladores
dispositivo
red
99
controladores
dispositivo
tipo
carácter
99
interrupciones
99
llamadas
sistema
98
100-101
manejadores
dispositivo
orientado
bloque
99
memoria
física
99
memoria
virtual
99
procesamiento
TCP
IP
609
procesos
planificador
99
protocolos
red
99
señales
98
99
sistemas
ficheros
98
Trap
fallos
99
Comportamiento
llamada-retorno
43
Compromiso
perezoso
530
Computación
cliente
servidor
620-630
aplicaciones
622-628
definición
620-622
middleware
628-630
terminología
620
Computación
objetos
distribuidos
distributed
object
computing
DOC
772
Computación
paramétrica
640
Computadores
centralizados
591
Comunicación
procesos
Interprocess
Communication
IPC
101
179-180
193
llamadas
LINUX
100
micronúcleo
179-180
procesos
LINUX
193
Comunicación
datagramas
608
Comunicación
stream
607
Comunicación
cooperación
procesos
211
Conceder
180
Concurrencia
201-303
743-764
compartición
cooperación
procesos
210-211
comunicación
cooperación
procesos
211
condición
carrera
203
206
748-758
contextos
202
ejemplo
204-206
exclusión
mutua
208
211-215
744-748
funciones
sincronización
hilos
Solaris
291-294
inanición
203
209
215
interacción
procesos
207-211
interbloqueo
203
258-277
Índice
Analítico
831
25-Indice
analitico
13/5/05
16:55
Página
831mecanismos
UNIX
280-284
mecanismos
Windows
294-296
mecanismos
núcleo
LINUX
284-291
monitores
229-235
paso
mensajes
235-241
preocupaciones
sistema
operativo
206-207
principios
203-212
problema
barbería
758-763
problema
filósofos
comensales
277-280
problema
lectores
escritores
241-245
recursos
competencia
procesos
208-210
semáforos
215-228
748-758
términos
clave
203
velocidad
ejecución
203-204
Condición
carrera
203
206
748-758
Confiables
sistemas
722-725
Confidencialidad
seguridad
sistema
operativo
73
Conjunto
residente
340
Conjuntos
datos
109
connect
237
Consistencia
caché
ficheros
626-628
Contabilidad
56
Contador
programa
Program
counter
PC
13-14
110
Contexto
nivel
sistema
144
Contexto
nivel
usuario
145
Contexto
ejecución
69
Contexto
registros
145
Contexto
específico
procesador
proceso
LINUX
194
Contraseñas
generadas
ordenador
709
Contraseñas
703-710
adivinación
706
control
acceso
708
longitudes
706
protección
703-704
selección
708-710
vulnerabilidad
704-708
Control
centralizado
678
Control
acceso
71
698-702
708
gestión
memoria
71
orientado
datos
protección
699-701
orientado
usuarios
protección
698
seguridad
intrusos
701
708
Control
carga
376-378
389
grado
multiprogramación
376-377
suspensión
procesos
377-378
Control
emulación
módulo
720
Control
procedimientos
48-51
implementación
pila
48
llamada
retornos
49-51
procedimientos
reentrantes
51
Control
proceso
135-143
cambio
140
cambio
137-140
creación
137
ejecución
sistema
140-143
modos
ejecución
135-137
Control
usuario
sistema
operativo
tiempo-real
455
Control
distribuido
678
Control
jerárquico
678
Control
operación
35
Controladores
dispositivo
86
99-101
551
arquitectura
sistema
ficheros
551
componentes
Microsoft
Windows
86
componentes
núcleo
LINUX
97-101
Controladores
dispositivos
hardware
Windows
54
Cooperación
procesos
207-211
Copia-al-referenciar
656
Coplanificación
459
Correo
integrado
sistema
721
Correo
virus
721
Cortar
tiempo
413
Creación
procesos
115
Crecimiento
incremental
SMP
81
Criptoanálisis
737
Criptografía
clave
pública
738-741
Criptografía
simétrica
736-737
Criptografía
736-741
Advanced
Encryption
Standard
AES
738
algoritmo
Rivest-Shamir-Adleman
RSA
741
clave
pública
738-741
Data
Encryption
Standard
DES
737-738
simétrica
736-737
CRITICAL_SECTION
296
csignal
230
232-233
cv_broadcast
294
cv_signal
294
cv_wait
294
cwait
230-231
Data
Encryption
Standard
DES
737-738
Datos
centralizados
591
Datos
contexto
110
Saliente
124
Defense
Advanced
Research
Projects
Agency
DARPA
599
Definición
monitores
Hoare
231
234
Definición
monitores
Lampson
Redell
233-234
Denegación
asignación
recursos
270-273
Denegación
servicio
695
Densidad
capacidad
almacenamiento
disco
538
Desarrollo
programas
54
Desbordamiento
encadenado
398
Descifrado
genérico
generic
decryption
GD
720
Descriptor
bloques
disco
UNIX
378
Descriptor
seguridad
Security
Descriptor
SD
90
Destino
235
Detección
basada
reglas
711
Detección
posición
rotacional
504
Detección
interbloqueo
273-276
Detección
estadística
anomalías
711
Detección
respuesta
errores
55
Determinista
sistema
operativo
tiempo-real
464
Diagrama
progreso
conjunto
258
Diagrama
IP
604
Dirección
física
321
832
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
832Dirección
lógica
321
Dirección
real
72
Dirección
relativa
321
Dirección
virtual
72
Dirección
12
72
321
física
321
lógica
321
real
72
registros
12
relativa
321
virtual
72
Direccionamiento
directo
237
Direccionamiento
indirecto
237
Direccionamiento
72
235-241
384-385
formato
mensajes
237-238
memoria
virtual
LINUX
384
memoria
virtual
73
Direcciones
IP
606
Directorio
páginas
LINUX
384
Directorio
intermedio
páginas
LINUX
384
Directorios
559-563
contenido
559
estructura
559-563
nombrado
561-563
Disciplina
cola
238
Disciplina
envío
443
Disco
compacto
Compact
disk
CD
541
Disco
compacto
memoria
lectura
Compact
disk
read-only
memory
CD-ROM
543-544
Disco
cabeza
fija
539
Disco
cabeza
móvil
539
Disco
doble
cara
539
Disco
cara
539
Disco
digital
versátil
Digital
versatile
disk
DVD
545-546
Disco
duro
541
Disco
extraíble
539
Disco
flexible
540
Disco
extraíble
539
Disco
Winchester
540
disconnect
237
Diseño
asistido
computador
CAD
591
Diseño
multiprocesamiento
simétrico
SMP
173-175
fiabilidad
175
gestión
memoria
175
planificación
174
procesos
concurrentes
simultáneos
174
sincronización
175
tolerancia
fallos
175
Diseño
sistema
operativos
496-500
estructura
lógica
498-500
objetivos
496-497
Diseño
micronúcleo
177
179-181
comunicación
procesos
IPC
180
conceder
180
estructura
código
nivel
usuario
181
gestión
181
gestión
interrupciones
181
gestión
memoria
nivel
179-180
limpiar
180
paginador
externo
180
proyectar
180
Diseño
orientado
objetos
82
765-776
agregación
771
Arquitectura
Común
Mediador
Solicitud
Objeto
Common
Object
Request
Broker
Architecture
COR-
BA
772-775
beneficios
771-772
clases
objetos
769-771
Computación
objetos
distribuidos
distributed
object
computing
DOC
772
conceptos
767-771
estructura
objeto
767-769
grupo
gestión
objetos
772
herencia
769
interfaces
772
interfaz
esqueleto
dinámico
dynamic
skeleton
interfa-
ce
DSI
775
invocación
método
remoto
Java
remote
method
in-
vocation
RMI
772
lenguaje
definición
interfaz
interface
definition
language
IDL
OMG
774
mediadores
solicitud
objeto
object
request
brokers
ORBs
772
modelo
objetos
componentes
distribuidos
Mi-
crosoft
Microsoft
distributed
component
object
mo-
DCOM
772
motivación
766
polimorfismo
770
Disponibilidad
73
81
multiprocesamiento
simétrico
symmetric
multiproces-
sing
SMP
82
protección
sistema
operativo
72-73
Disponible
paginación
Windows
387
Dispositivo
orientado
bloques
500
Dispositivo
orientado
flujo
caracteres
500
Dispositivos
almacenamiento
disco
537-546
características
físicas
539-541
componentes
unidad
disco
540
disco
magnético
537-541
memoria
óptica
541-546
organización
formato
datos
537-539
parámetros
unidad
disco
duro
542
Dispositivos
bloques
manejadores
99
Dispositivos
55
492-493
acceso
55
categorías
492
diferencias
categorías
492-493
down
289
down_interruptible
289
down_trylock
289
dqactmap
482
Duplexing
disco
532
asíncrona
531-532
alerta
Windows
531
Índice
Analítico
833
25-Indice
analitico
13/5/05
16:55
Página
833E
dispositivo
498
dirigida
interrupciones
36
494
lógica
498
552
programada
34-35
493
buffer
UNIX
526
síncrona
Windows
531
Editor
enlace
335
Educación
usuarios
estrategia
708
Eficiencia
acceso
46-47
Eficiencia
sistema
496
EFLAGS
registro
132-134
EINTR
289
Ejecución
hilo
Solaris
190-191
ceder
paso
191
expulsión
191
sincronización
191
suspensión
191
Ejecución
instrucción
14-17
búsqueda
ejecución
14-16
sistema
17
Ejecución
programa
55
Ejecución
sistema
operativo
140-143
imagen
proceso
142
núcleo
procesos
141
procesos
usuario
141-143
SO
basado
procesos
143
Ejecutando
Bloqueado
119
Ejecutando
Listo
119
Ejecutando
Listo
Suspendido
124
Ejecutando
Saliente
118
Ejecutivo
86
problema
lectores
escritores
241-246
condiciones
241
definición
241
escritores
prioridad
242-245
lectores
prioridad
242
Emulador
CPU
720
Encaminador
600
Encapsulación
89
Enfoque
instrucción-máquina
215
Enfoque
paso
testigo
673-675
EnFuzion
648
Engineering
Task
Force
IETF
601
Enlace
cliente
servidor
635
Enlace
dinámico
tiempo
carga
336
Enlace
dinámico
tiempo
ejecución
337
Enlace
331
335-337
dinámico
336-337
editor
enlace
335
Enlaces
persistentes
635
Enlaces
procesos
LINUX
193
Enlazado
persistente
635-636
Enmascarado
701
EnterCriticalSection
296
Entrada
salida
entrarcritica
209-210
Envío
bloqueante
recepción
bloqueante
236
Envío
bloqueante
recepción
bloqueante
236
Envío
bloqueante
recepción
bloqueante
236
Escalabilidad
absoluta
636
Escalabilidad
incremental
636
Escalado
multiprocesamiento
simétrico
symmetric
multi-
processing
SMP
81
Escáner
firma
virus
720
Escritura
perezosa
530
Espacio
direcciones
proceso
LINUX
194
Espacio
intercambio
277
Espacio
procesos
distribuidos
Beowulf
BPROC
647
Espera
activa
213
215
Espera
cíclica
213
Espera
circular
266
268
Bloqueado
117
122
modelo
117
proceso
swapping
122
Bloqueado
Suspendido
122
ejecución
110
185
194
ejecución
programa
110
proceso
LINUX
194
Windows
185
hilos
Windows
185-186
proceso
69-71
detenido
proceso
LINUX
194
hilo
esperando
185
hilo
substituto
185
hilo
terminado
186
hilo
transición
186
Ininterrumpible
LINUX
194
inseguro
270
273
interrumpible
proceso
LINUX
194
Listo
117
122
185
hilos
Solaris
185
modelo
117
proceso
swapping
122
Listo
Suspsendido
122
seguro
270
Zombie
proceso
LINUX
194
110
operación
35
ejecución
LINUX
194
procesos
110-126
143-144
bloqueado
117
122
creación
114-115
ejecutando
117
194
listo
117
122
modelo
117-120
modelo
colas
121
modelo
113-114
117
procesos
suspendidos
120-126
saliente
117
swapping
120-124
terminación
115-116
transiciones
118-120
143-144
traza
111-112
UNIX
SVR4
143-144
globales
660-665
algoritmo
instantánea
distribuida
662-665
instantánea
distribuida
660-663
834
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
834Estrategia
conjunto
trabajo
372-375
Estructura
código
nivel
usuario
181
Estructura
modular
programas
161
Estructura
modular
LINUX
96-97
Estructura
monitor
Mesa
233
Estructuras
control
procesos
128-135
Estructuras
control
SO
sistema
operativo
126-128
tablas
127
tablas
ficheros
127
tablas
memoria
127
tablas
procesos
128
Estructuras
datos
292
378-379
sincronización
Solaris
292
paginación
UNIX
378-379
Evolución
sistemas
operativos
57-67
procesamiento
serie
58
razones
facilidad
57-58
sistemas
tiempo
compartido
64-67
sistemas
lotes
multiprogramados
61-64
sistemas
lotes
sencillos
58-61
Exclusión
mutua
203
208-209
211-215
218-221
239-241
266-267
665-675
algoritmo
centralizado
666
algoritmo
distribuido
667
algoritmo
218
220
condición
interbloqueo
266-267
definido
203
208
distribuido
665-675
enfoque
instrucción-máquina
215
ilustración
209
inhibición
interrupciones
212
instrucción
exchange
214-215
instrucción
test
and
set
213-214
instrucciones
máquina
especiales
212-215
paso
mensajes
238-241
requisitos
211-212
soluciones
semáforos
218-221
soporte
hardware
212-215
Expulsión
Solaris
191
Facilidad
general
indexación
Windows
583
Fallo
memoria
138
Fallo
página
349
Fase
búsqueda
14
Fase
ejecución
14
Fase
interrupción
19
Fiabilidad
464
574
gestión
almacenamiento
secundario
574-575
sistema
operativo
tiempo-real
464
Fichero
acceso
directo
558
Fichero
hashed
558
Fichero
indexado
558
Fichero
secuencial
indexado
557-558
Fichero
secuencial
556-557
Fichero
549
Flags
clone
LINUX
195
Fragmentación
externa
316
Fragmentación
interna
314
Frecuencia
fallos
página
PFF
algoritmo
374-375
Fuente
235
Función
correspondencia
34
Función
selección
409
Funciones
espera
Windows
294
Funciones
sincronización
hilos
Solaris
291-294
cerrojo
exclusión
mutua
292-293
cerrojo
lectura
escritura
293
estructuras
datos
292
variables
condición
294
Generalidad
sistema
497
Gestión
almacenamiento
secundario
566-574
Asignación
ficheros
566
fiabilidad
574
Gestión
espacio
libre
572
indexación
573
Lista
bloques
libres
573
Métodos
asignación
ficheros
568-571
porciones
libres
encadenadas
572
preasignación
frente
asignación
dinámica
566
tamaño
porción
567-568
Gestión
directorios
499
Gestión
LINUX
527-530
cache
páginas
529
planificación
disco
527
planificador
basado
plazos
527-528
planificador
previsor
529
planificador
ascensor
527
Gestión
UNIX
SVR4
522-527
cache
buffers
524
cola
caracteres
525
dispositivos
UNIX
526
buffer
526
Gestión
Windows
530-532
asíncrona
531
síncrona
531
módulos
básicos
530
notificación
finalización
531
RAID
hardware
532
RAID
software
532
Gestión
181
489
491-546
cache
disco
520-522
diseño
S.O.
496-500
dispositivos
almacenamiento
disco
537-546
dispositivos
492-493
LINUX
527-605
organización
sistema
493-496
planificación
disco
503-511
RAID
511-520
UNIX
SVR4
522-527
utilización
buffers
500-502
Windows
530-532
Gestión
espacio
libre
572-573
Índice
Analítico
835
25-Indice
analitico
13/5/05
16:55
Página
835Gestión
ficheros
UNIX
574-578
Asignación
ficheros
575-578
directorios
578
estructura
volumen
578
nodos-i
575
tipos
575
Gestión
ficheros
547-590
acceso
553-558
almacenamiento
secundario
566-574
arquitectura
sistema
551-552
asignación
bloques
registros
564-565
compartición
563-565
directorios
558-563
estructura
549-550
funciones
552-553
LINUX
578-582
operaciones
548-549
organización
553-558
propiedades
548
sistemas
550-551
UNIX
574-578
Windows
582-587
Gestión
hilos
SMP
Solaris
187-193
arquitectura
multihilo
187-189
conceptos
relacionados
hilos
187
ejecución
hilos
190-193
estructura
procesos
189-190
hilos
nivel
usuario
ULTs
187-189
hilos
núcleo
188-189
interrupciones
hilos
191-193
motivación
189-189
procesos
ligeros
LWP
188-189
Gestión
hilos
SMP
Windows
181-187
atributos
184
185
estructura
orientada
objetos
182-183
multihilo
183-185
multiprocesamiento
simétrico
soporte
187-188
objeto
proceso
objeto
hilo
182-183
procesos
recursos
182-183
subsistema
SO
soporte
186
Gestión
interrupciones
181
Gestión
memoria
nivel
179-180
Gestión
memoria
LINUX
384-386
algoritmo
reemplazo
páginas
385
direccionamiento
memoria
virtual
384
memoria
virtual
384-385
reemplazo
páginas
385
reserva
memoria
kernel
385
Gestión
memoria
UNIX
Solaris
378-383
asignador
memoria
kernel
380-383
parámetros
SVR4
381
sistema
paginación
378-380
Gestión
memoria
Windows
386-388
paginación
387-388
mapa
direcciones
virtuales
386
Gestión
memoria
64
71-72
175
179-180
305
307-
388
aislamiento
proceso
71
almacenamiento
plazo
71
asignación
gestión
automática
71
nivel
diseño
micronúcleo
179-181
carga
programa
331-335
compartición
310
definido
308
diseño
SMP
174-175
enlace
331-332
335-337
LINUX
384-386
memoria
virtual
71-72
organización
física
310
organización
lógica
310
paginación
321-325
particionamiento
311-321
protección
control
acceso
71
protección
309-310
requisito
sistema
operativo
64
requisitos
308-311
reubicación
308-309
segmentación
325-327
soporte
programación
modular
71
técnicas
312
UNIX
Solaris
378-383
Windows
386-388
Gestión
procesos
distribuidos
653-687
cola
versión
669-671
cola
versión
672-673
enfoque
paso
testigo
673-675
globales
660-665
exclusión
mutua
665-675
interbloqueo
675-685
migración
procesos
654-659
ordenación
eventos
667-669
Gestión
procesos
hilos
LINUX
193-196
Gestión
ventanas
86
Gestión
conjunto
residente
369-375
388
ámbito
reemplazo
370
ámbito
global
370-371
ámbito
local
370-364
371-375
asignación
fija
370
asignación
variable
370-375
tamaño
369-370
Gestor
base
datos
configuración
642
Gestor
cache
87
530
Gestor
86
Gestor
nodos
642
Gestor
potencia
87
Gestor
procesos
hilos
87
Gestor
recursos
gestión
recuperación
fallos
643
Gestor
plug
and
play
87
Grabación
múltiples
zonas
538
Grabadores
casete
vídeo
Video
Cassette
Recorder
VCR
545
Grafo
asignación
recursos
265-266
Granularidad
452-454
Grupo
gestión
objetos
772
Guía
lector
1-5
organización
libro
2-3
836
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
836orden
temas
3-4
recursos
Internet
Web
4-5
Gusanos
716
Hashing
lineal
397
Hashing
396-397
Herencia
prioridad
475
Herencia
89
769-770
Hilo
80
89
158-172
181-200
Adobe
PageMajer
164
beneficios
160-161
característica
proceso
158
definido
80
diseño
proceso
LINUX
193-196
diseño
proceso
Windows
181-187
enfoques
combinados
169
162-164
funcionalidades
hilos
162-164
multihilo
158-162
nivel
núcleo
KLTs
165
169-170
nivel
usuario(ULTs
165-169
relación
muchos-a-muchos
170
relación
uno-a-muchos
171-172
sincronización
164
sistema
multiprocesamiento
único
usuario
161
sistema
operativo
Clouds
171
soporte
Solaris
187-193
TRIX
171
Windows
89
Hilos
clonados
LINUX
196
Hilos
nivel
núcleo
KLTs
165
169-170
188-189
implementación
165-169
Solaris
187-189
Hilos
nivel
usuario
ULTs
165-169
187-190
implementación
165
169-170
Solaris
187-190
Hilos
LINUX
194
Histogramas
utilización
65
Huecos
31
Huecos
característica
disco
537
Identificador
proceso
349
Identificador
procesos
131
Identificador
110
Identificadores
procesos
LINUX
193
Imagen
proceso
128-129
142
144-145
contexto
nivel
sistema
145
contexto
nivel
usuario
145
contexto
registros
145
localización
128-129
Imagen
única
sistema
640
Implementación
pila
48
Inanición
203
209
215
Inapropiada
sincronización
69
Indexación
573
Indicadores
13
INFINITE
295
Información
auditoría
110
Información
control
proceso
132
Información
110
Información
proceso
132
init_MUTEX
289
init_MUTEX_LOCKED
289
InitializeCriticalSection
296
InitializeCriticalSectionAndSpinCount
296
Insertar_Uno
550
Instancia
89
Instrucción
exchange
214-215
Instrucciones
privilegiadas
61
Instruccuón
test
and
set
213-214
Integridad
datos
73
Interbloqueo
deadlock
69
203
209
215
257-303
675-
685
algoritmo
detección
275
comunicación
mensajes
681-685
condiciones
266
268
definido
69
203
258
detección
273-276
diagrama
progreso
conjunto
258
enfoque
instrucción-máquina
215
espacio
intercambio
277
espera
mutua
681-682
estrategia
integrada
277
estrategias
tratar
267
funciones
sincronización
hilos
Solaris
291-
294
fundamentos
258-267
gestión
procesos
distribuidos
675-685
grafos
asignación
recursos
265-266
mecanismos
UNIX
280-284
mecanismos
Windows
294-296
disponibilidad
buffers
mensaje
682-685
predicción
269-273
prevención
267-268
676-681
problema
control
209
problema
filósofos
comensales
277-280
recuperación
275-276
recursos
consumibles
263
recursos
reutilizables
262-263
ubicación
recursos
675-676
Interfaz
esqueleto
dinámico
dynamic
skeleton
interface
DSI
775
Interfaz
programación
aplicaciones
Application
Pro-
gramming
Interface
API
86
178
606
629
Interfaz
usuario
gráfica
Graphical
User
Interface
GUI
83
86
622
Interfaz
usuario
computación
sistema
operativo
54-56
acceso
dispositivos
55
acceso
sistema
55
acceso
controlado
ficheros
55
contabilidad
56
Índice
Analítico
837
25-Indice
analitico
13/5/05
16:55
Página
837desarrollos
programas
54
detección
respuesta
errores
55
ejecución
programa
55
Interfaz
uniforme
178
Internet
Activities
Board
IAB
599
Intérprete
concurrente
Ben-Ari
BACI
778
789-800
construcciones
concurrentes
791-792
definido
778
introducción
790
mejoras
sistema
800
programas
ejemplo
793-797
proyectos
797-800
visión
general
sistema
790-791
Interrupción
138
Interrupción
reloj
138
Interrupción
inhabilitada
24
Interrupción
17-27
61
97-99
138-140
191-193
cambio
139-140
cambio
proceso
137-139
ciclo
instrucción
19-20
clases
17
componentes
núcleo
LINUX
97-99
138
hilos
Solaris
191-193
llamadas
ESCRITURA
18
múltiples
24-27
procesamiento
20-24
reloj
138
sistemas
lotes
sencillos
61
Introducción
computadores
9-51
control
procedimientos
48-51
ejecución
instrucciones
14-17
elementos
básicos
10-11
interrupciones
17-27
jerarquía
memoria
27-30
memoria
cache
30-34
memoria
niveles
41-48
registros
procesador
11-14
técnicas
comunicación
34-37
Intrusos
701-713
detección
basada
reglas
711
detección
intrusos
710-713
detección
estadística
anomalías
711
enmascarado
701
protección
contraseñas
703
selección
contraseñas
708-710
técnicas
intrusión
702-703
trasgresor
701
usuario
clandestino
701
vulnerabilidad
contraseñas
704-708
Inversión
prioridad
ilimitada
475
Inversión
prioridad
474-477
Invocación
método
remoto
Java
remote
method
invo-
cation
RMI
774
Jerarquía
memoria
27-30
LeaveCriticalSection
296
Lectura
contenidos
mensajes
693
Lenguaje
control
trabajos
Job
Control
Language
JCL
60
Lenguaje
definición
interfaz
interface
definition
lan-
guage
IDL
OMG
774
libera_tenedores
279
Límite
pila
48
Limpiar
180
Limpieza
adelantada
376
Limpieza
demanda
376
LINUX
95-101
193-196
284-291
384-386
477-480
527-
530
578-582
609-611
646-648
Beowulf
646-648
clusters
LINUX
646-648
enlaces
193
ejecutando
194
flags
clone
195
gestión
527-530
gestión
memoria
384-386
gestión
procesos
hilos
193-196
hilos
195
llamadas
sistema
98
100-101
mecanismos
núcleo
284-291
planificación
477-480
redes
609-611
sistema
ficheros
virtual
578-582
sistemas
94-101
tareas
193-194
lista
apilamiento
48
Lista
bloques
libres
573
Lista
control
acceso
sistema
SACL
729
Lista
control
acceso
discrecional
DACL
729
Lista
dispositivos
UNIX
524
Lista
libres
UNIX
524
Listas
control
accesos
ACL
701
Listo
Ejecutando
118
Listo
Listo
Suspendido
124
Listo
Saliente
119
Listo
Suspendido
Listo
123
Llamada
procedimiento
asíncrona
Asynchronous
proce-
dure
call
APC
531
Llamada
sistema
139
Llamadas
procedimiento
remoto
RPC
633-636
enlace
cliente
servidor
635
mecanismos
orientados
objetos
636
paso
parámetros
634
representación
parámetros
634
síncrono
vs
asíncrono
635
Llamadas
sistema
LINUX
98
100-101
Llamadas
relacionadas
planificación
LINUX
100
Localización
proceso
128-129
Logros
sistemas
operativos
67-79
Longitud
media
búsqueda
tablas
hash
396-398
838
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
838
Macro
mandato
719
Macros
virus
basados
718-719
Malware
713
Mandato
clone
LINUX
195
Mandato
fork
LINUX
195
Mandato
LECTURA
36
Manejadores
red
Windows
531
Manejadores
sistemas
ficheros
Windows
531
Mapa
direcciones
virtuales
386
Máquina-a-máquina
TCP
602
Marcador
662
Marco
pila
49
Marcos
322
Matriz
accesos
700
MAX_PRIO
479
mb
290-291
Mecanismo
desalojo
Sprite
659
Mecanismo
disco
compartido
639
Mecanismos
concurrencia
UNIX
280-284
memoria
compartida
282
mensajes
282
semáforos
282-283
señales
283-284
tuberías
282
Mecanismos
concurrencia
Windows
294-296
funciones
espera
294
objetos
sección
crítica
296
objetos
sincronización
295-296
Mecanismos
concurrencia
núcleo
LINUX
284-291
barreras
289-291
cerrojos
cíclicos
básicos
286-288
cerrojos
cíclicos
lectura-escritura
288
cerrojos
cíclicos
286
operaciones
atómicas
284-286
semáforos
288-290
Mediación
completa
723
Mediadores
solicitud
objetos
object
request
brokers
ORBs
772
Memoria
auxiliar
30
Memoria
cache
30-34
520-522
cache
disco
520-522
definida
520
diseño
32-34
fundamentos
31-32
motivación
31
Memoria
compartida
282
Memoria
niveles
28-30
41-48
características
rendimiento
41-48
operación
44-45
parámetros
rendimiento
45-48
proximidad
41-44
Memoria
kernel
380-383
385
reserva
LINUX
385
reserva
UNIX
382-383
Memoria
óptica
541-546
CD
grabable
CD-R
544
CD
modificable
CD-RW
545
disco
compacto
compact
disk
CD
541
disco
compacto
memoria
lectura
ompact
disk
read-only
memory
CD-ROM
543
disco
digital
versátil
digital
versatile
disk
DVD
545-546
Memoria
principal
10
277
Memoria
real
341
Memoria
secundaria
30
Memoria
virtual
71-72
87
99
134
339-398
conceptos
73
definida
341
dirección
72
direccionamiento
72
gestión
LINUX
384-386
gestión
UNIX
Solaris
378-383
gestión
Windows
386-388
gestor
87
hardware
estructuras
control
340-358
paginación
343-355
políticas
SO
360
procesos
usuario
134
proximidad
341-343
segmentación
355-358
sistemas
LINUX
99
software
SO
358-378
tablas
hash
395-398
Memoria
10
27-34
41-48
305-337
339-398
698-698
auxiliar
30
cache
30-34
niveles
29-30
41-48
gestión
LINUX
384-386
gestión
UNIX
Solaris
378-383
gestión
Windows
386-388
gestión
305
307-337
hardware
estructuras
control
340-358
introducción
305-306
jerarquía
27-30
paginación
321-325
particionamiento
311-321
principal
10
protección
61
309-310
698
secundaria
30
segmentación
325-327
software
sistema
operativo
SO
358-378
virtual
305
339-398
Menor
tiempo
restante
SRT
419
frecuentemente
usado
Least
frequently
used
LFU
521
Mensaje
235
Método
acceso
552
Método
esperar-morir
677
Método
herir-esperar
677
Micronúcleo
176-181
arquitectura
176-177
beneficios
177-179
definición
176
diseño
178-181
extensibilidad
178
fiabilidad
178
Índice
Analítico
839
25-Indice
analitico
13/5/05
16:55
Página
839flexibilidad
178
interfaz
uniforme
178
portabilidad
178
rendimiento
179
sistemas
operativos
orientados
objetos
OOOS
177-178
soporte
sistemas
distribuidos
178
Microsoft
Windows
82-91
181-187
294-296
386-388
482-484
530-532
582-587
725-731
arquitectura
Windows
2000
85-88
componentes
núcleo
86
gestión
530-532
gestión
hilos
SMP
181-187
gestión
memoria
386-388
hilos
soporte
89
historia
82-84
interfaz
gráfica
usuario
graphical
user
interface
GUI
83
86
mecanismos
concurrencia
294-296
modelo
cliente
servidor
88-89
módulos
ejecutivos
86-87
multitarea
monousuario
84-85
objetos
control
micronúcleo
90-91
objetos
89-91
organización
sistema
operativo
86-87
planificación
482-484
procesos
usuario
87-88
seguridad
725-731
sistema
ficheros
Windows
NTFS
583-587
Middleware
628-630
Migración
procesos
654-660
desalojo
659
escenario
657-658
iniciación
655
mecanismos
655
mensajes
señales
657
motivación
654-655
movimiento
655-657
negociación
658-659
transferencias
expulsivas
vs
expulsivas
660
Modelo
cliente
servidor
88-89
Modelo
objetos
componentes
distribuidos
Micro-
soft
Microsoft
distributed
component
object
model
DCOM
772
Modelo
proceso
117-120
Modelos
simulación
rendimiento
planificación
424-426
Modificación
mensajes
695
decisión
409
núcleo
61
135
sistema
135
usuario
61
135
Modos
control
135
Modos
ejecución
135-137
Módulos
cargables
96
Módulos
10
Monitores
59
229-235
buffercotado
231
características
229
notificación
difusión
231-235
definición
Hoare
231
235
definición
Lampson
Redell
233-234
definido
59-60
229
estructura
monitor
Mesa
233
estructura
230
introducción
59-60
problema
filósofos
comensales
278-280
Monoprogramación
63
Montador
dinámico
335-337
msgrcv
282
msgsnd
282
Multihilo
79
82
158-162
183-185
187-189
aplicaciones
sistemas
operativos
80
82
arquitectura
Solaris
187-189
definido
80
161
descripción
general
158-162
modelo
proceso
160
sistema
multiprocesamiento
único
usuario
161
soporte
Windows
183-186
técnica
80
Múltiples
aplicaciones
202
Múltiples
flujos
datos
Windows
583
Múltiples
instrucciones
múltiples
flujos
datos
MIMD
173
Multiprocesador
memoria
compartida
173
Multiprocesamiento
simétrico
Symmetric
Multiprocessing
SMP
82-82
86
89
172-175
187-193
291
arquitectura
172-174
crecimiento
incremental
81
diseño
174-175
disponibilidad
81
ejecución
núcleo
173
escalado
81
gestión
ventanas
86
89
187-188
hilos
Solaris
187-193
operaciones
barrera
291
organización
174
rendimiento
81
Multiprocesamiento
202
Multiprogramación
63
202
455
Multitarea
63
Mutex
216
mutex_enter
293
mutex_exit
293
mutex_tryenter
293
Mútiples
instrucciones
único
flujo
datos
MISD
172
Nachos
778-780
definido
778
introducción
779
selección
778-779
compartido
639
Nivel
física
551
Niveles
RAID
513-516
Nodos-i
UNIX
575
nolleno
231-232
840
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
840novacio
231-233
nr_active
479
Núcleo
monolítico
80
Núcleo
56
Núcleo
56
86
94
Listo
118
124
Listo
Suspendido
124
nuevo_estado
271
Nulo
118
Número
página
348
Objeto
evento
Windows
296
Objeto
mutex
Windows
296
Objeto
temporizador
espera
Windows
296
Objetos
control
90
Objetos
sección
crítica
Windows
296
Objetos
sincronización
Windows
295-296
Objetos
dispatcher
91
Objetos
semáforo
Windows
296
Obtener_Varios
550
Obtener_Anterior
550
Obtener_Siguiente
550
Obtener_Todos
550
Obtener_Uno
550
obtiene_tenedores
281
Oculto
virus
718
Operación
fallo-suave
sistema
operativo
tiempo-real
465
Operación
determinista
69
Operaciones
atómicas
enteros
LINUX
285
Operaciones
atómicas
mapas
bits
LINUX
286
Organización
fichero
553-558
acceso
directo
hashed
558
fichero
indexado
558
fichero
secuencial
indexado
557-558
fichero
secuencial
556-557
pila
554-556
Organización
sistema
493-496
acceso
directo
memoria
Direct
memory
access
DMA
494-496
evolución
494-495
técnicas
493-494
Organización
física
310
499
499
gestión
memoria
311
Organización
lógica
gestión
memoria
310
Paginación
adelantada
361
Paginación
demanda
360
Paginación
321-325
342-355
357-358
378-380
387-388
buffer
traducción
adelantada
TLB
349-351
características
342
estructura
tabla
páginas
344-347
estructura
tabla
páginas
invertida
347-349
gestión
memoria
Windows
386-388
gestión
memoria
322-325
memoria
virtual
341-355
segmentación
combinada
357-358
sistema
gestión
memoria
UNIX
Solaris
378-
380
tamaño
página
351-355
Paginador
externo
180
Páginas
322
Palabra
programa
Program
status
word
PSW
21
136
Paquete
confirmación
ACK
615
Paquete
datos
615
Paquete
error
615
Paquete
solicitud
escritura
WRQ
615
Paquete
solicitud
lectura
RRQ
614
Paralelismo
452-454
grano
fino
454
grano
453-454
grueso
grueso
453
independiente
452-453
Paralelos
213
Parámetros
gestión
memoria
UNIX
SVR4
381
Parámetros
disco
duro
542-543
Particionamiento
memoria
311-321
algoritmo
ubicación
314-315
317-318
fijo
311-314
particionamiento
dinámico
315-316
reubicación
319-321
sistema
buddy
318-319
tamaños
partición
311-314
Particionamiento
dinámico
315-318
algoritmo
reemplazamiento
318
algoritmo
ubicación
317-318
Particionamiento
fijo
311-315
algoritmo
ubicación
314-315
desventajas
314
tamaños
311-313
Pasivo
espera
638
Paso
mensajes
235-241
282
630-633
bloqueante
vs
bloqueante
632
características
diseño
235
direccionamiento
237
disciplina
cola
238
distribuido
630-633
exclusión
mutua
239-241
fiable
vs
fiable
632
formato
237-238
introducción
235
mecanismos
concurrencia
UNIX
280-283
sincronización
236
Paso
parámetros
634
Petición
interrupción
19
Pila
554-556
Pistas
característica
disco
537
Planificación
aleatoria
506
Planificación
compartición
justa
FSS
426-427
Índice
Analítico
841
25-Indice
analitico
13/5/05
16:55
Página
841Planificación
disco
503-511
527-527
comparación
tiempos
505
LINUX
527-528
organización
secuencial
506
parámetros
rendimiento
503-506
política
C-SCAN
511
política
FSCAN
511
política
SCAN
N-pasos
511
política
SCAN
510
políticas
506
tiempo
servicio
corto
Shortest
ser-
vice
time
first
SSTF
510
entrar-primero
salir
FIFO
506-509
prioridad
PRI
509
retardo
rotacional
505
tiempo
búsqueda
504
entrar-primero
salir
LIFO
510
Planificación
hilos
456-462
asignación
procesador
dedicado
460-462
compartición
carga
458-459
planificación
dinámica
462
planificación
pandilla
459-460
Planificación
procesos
455
Planificación
tasa
monótona
rate
monotonic
scheduling
RMS
472-474
Planificación
tiempo-real
463-477
algoritmos
466-468
antecedentes
463
características
463-467
enfoques
dinámicos
basados
plan
466
enfoques
dinámicos
esfuerzo
466-468
enfoques
estáticos
dirigidos
tabla
466
enfoques
estáticos
expulsivos
dirigidos
prioridades
466
inversión
prioridad
474
LINUX
477-480
planificación
tasa
monótona
rate
monotonic
schedu-
ling
RMS
472-474
planificación
plazos
468-472
UNIX
SVR4
480-482
Planificación
UNIX
SVR4
480-482
clases
prioridad
481
modificaciones
algoritmo
480-481
Planificación
Windows
482-484
plainficación
multiprocesador
484
prioridades
hilos
482-484
procesos
482-484
Planificación
dinámica
basada
plan
468
Planificación
dinámica
esfuerzo
468
Planificación
dinámica
462
Planificación
pandilla
459-460
Planificación
estática
expulsión
dirigida
prioridad
468
Planificación
estática
dirigida
tabla
466
Planificación
LINUX
477-480
relación
tareas
tiempo-real
480
tiempo-no-real
478-480
tiempo-real
477-478
Planificación
multiprocesador
451-462
aspectos
diseño
454-455
clasificación
452
granularidad
452-454
paralelismo
grano
fino
454
paralelismo
grano
453-454
paralelismo
grueso
grueso
453
paralelismo
independiente
452-453
planificación
hilos
456-458
planificación
procesos
455
Planificación
plazo
468-472
Planificación
uniprocesador
UP
401-449
algoritmos
406-427
análisis
colas
421-424
características
410
comparación
políticas
412-414
comparación
rendimiento
421-426
corto
plazo
405-406
criterios
corto
plazo
406-408
plazo
403-405
plazo
405
menor
tiempo
restante
SRT
419
modelos
simulación
424-425
planificación
contribución
justa
FSS
426-427
políticas
alternativas
409-421
llegar
servirse
FCFS
411-413
prioridades
408
proceso
corto
SPN
415-418
tasa
respuesta
HRRN
419
tipos
402-406
turno
rotatorio
413-415
UNIX
tradicional
427-430
Planificación
control
498
Planificación
58
174
193
399-487
diseño
SMP
174
introducción
399
LINUX
477-480
multiprocesador
451-462
procesamiento
serie
58
procesos
LINUX
193
tiempo-real
472-477
uniprocesador
401-449
UNIX
SVR4
480-482
UNIX
tradicional
427-429
Windows
482-484
Planificación
ejecución
158
Planificador
basado
plazos
LINUX
527-528
Planificador
previsor
LINUX
528-529
Planificador
ascensor
LINUX
527
Polimórficos
virus
717
Polimorfismo
90
770
Política
C-SCAN
511
Política
escritura
34
Política
limpieza
375-376
389
Política
recuperación
360-361
388
Política
reemplazo
global
370
Política
reemplazo
local
370-375
Política
reemplazo
361-369
388
algoritmos
362-367
bloqueo
marcos
362
buffering
páginas
367-368
tamaño
cache
368-369
842
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
842Política
ubicación
361
388
Política
conjunto
trabajo
muestreo
interva-
variables
VSWS
375
Política
reloj
364-367
Política
First-in-first-out
FIFO
218
363-366
411
507-508
Política
FSCAN
510-511
Política
óptima
362
Política
SCAN
N-pasos
511
Política
SCAN
510
Porciones
libres
encadenadas
572
Precopia
655
Predicción
interbloqueo
269-273
algoritmo
banquero
270
denegación
asignación
recursos
270-273
denegación
iniciación
proceso
269-270
Prevención
interbloqueo
267-268
espera
circular
266
268
exclusión
mutua
266-267
expropiación
266
268
esperar
246
268
tiempo
servicio
corto
Shortest
service
time
first
SSTF
510
llegar
atenderse
FCFS
409
411-
413
458
Principio
proximidad
referencia
343
Prioridad
110
509
Problema
filósofos
comensales
277-280
Procedimientos
anidados
50
Procedimientos
reentrantes
51
Proceo
swapping
120-124
Procesador
eventos
643
Procesador
10
14-17
60
172-175
control
15
definición
componente
10
definido
60
14
memoria
14
multiprocesamiento
simétrico
SMP
172-175
procesamiento
datos
15
Procesadores
acceso
memoria
uniforme
NUMA
361
Procesamiento
asíncrono
161
Procesamiento
basado
cliente
625
Procesamiento
basado
host
625
Procesamiento
basado
servidor
625
Procesamiento
centralizado
591
Procesamiento
cooperativo
626
Procesamiento
datos
distribuido
DDP
592
Procesamiento
distribuido
202
619-652
clusters
Beowulf
LINUX
646-648
clusters
636-642
computación
cliente
servidor
620-630
llamadas
procedimiento
remoto
RPC
633
paso
mensajes
630-633
servidor
cluster
Windows
642-643
Sun
cluster
643-646
Procesamiento
secuencial
550
Procesamiento
serie
58
planificación
58
tiempo
configuración
58
Proceso
sistemas
especiales
87
Proceso
expulsado
119
Proceso
hijo
115
Proceso
ligero
LWP
158
188-190
Proceso
padre
115
Proceso
suspendido
120-126
características
124
razones
125
swapping
120-124
Proceso
68
80
107-200
269-270
bloque
control
109-110
características
158
control
135-143
creación
114-115
definiciones
67
109
denegación
iniciación
269-270
descripción
126-135
elementos
109-110
plano
background
108-109
110-126
estructuras
control
SO
126-128
estructuras
control
128-135
funcionalidades
hilos
162-172
gestión
hilos
SMP
Linux
193-196
gestión
hilos
SMP
Solaris
187-193
gestión
hilos
SMP
Windows
181-187
gestión
UNIX
SVR4
143-149
micronúcleos
176-181
multihilo
79
158-162
multiprocesamiento
simétrico
SMP
172-175
requisitos
108
resumen
149
196
terminación
115-116
Procesos
servicio
87
Procesos
sistema
operativo
68-71
105-303
comparación
cooperación
vía
211-212
comunicación
cooperación
vía
211
concurrencia
106
201-303
contexto
ejecución
69
descripción
control
105
107-156
hilos
SMP
micronúcleos
106
157-200
implementación
70
Inapropiada
sincronización
69
interacción
207-211
interbloqueos
deadlocks
69
introducción
gestión
105-106
preocupaciones
206-207
programa
determinista
69
recursos
competencia
208-210
requisitos
108
violación
exclusión
mutua
69
Programas
móviles
sistemas
721
Promediado
exponencial
417
Protección
memoria
61
698
Protección
seguridad
información
72-73
Protección
71-74
309-310
358
695-701
control
acceso
orientado
datos
698-701
control
acceso
orientado
usuarios
698
estructura
protección
anillo
358
Índice
Analítico
843
25-Indice
analitico
13/5/05
16:55
Página
843gestión
memoria
309-310
memoria
71
698
necesidades
696-698
segmentación
358
seguridad
información
72-73
sistema
operativo
74
Protocolo
datagramas
usuario
UPD
600
Protocolo
Internet
IP
600
Protocolo
transferencia
ficheros
FTP
605
Protocolo
Simple
Transferencia
Correo
SMTP
605
Protocolo
Simple
Transferencia
Ficheros
TFTP
614-
618
errores
retrasos
618
introducción
614
operación
transferencia
617-618
paquetes
614-617
sintaxis
semántica
temporización
618
Protocolo
597
598
Proximidad
referencias
29
Proximidad
memoria
niveles
42-45
Proximidad
espacial
44
Proximidad
temporal
44
Proyectar
180
Proyecto
MAC
66
Proyectos
sistemas
operativos
Operating
Systems
Pro-
jects
OSP
778
783-787
aspectos
innovadores
785-786
comparación
herramientas
docentes
sistemas
operativos
786
definido
778
introducción
784-785
Puertas
secretas
714-715
Puertos
finalización
Windows
531
Puntero
pila
48
Punteros
memoria
110
Punteros
cadena
349
Pvmsync
648
RAID
hardware
532
RAID
software
532
Random
access
memory
RAM
161
Reactividad
sistema
operativo
tiempo-real
464
receive
235-236
239-240
Recuperación
fallos
639
Recuperación
fallos
639
Recuperación
interbloqueo
275-276
Recuperación
Windows
583
585-587
Recurso
crítico
208
Recurso
propiedad
158
Recursos
proceso
277
Recursos
internos
277
Recursos
208-210
262-266
270-273
competencia
procesos
208-210
consumibles
263
denegación
asignación
270-273
grafos
asignación
265-266
reutilizables
262-263
Red
621
Redes
Linux
609-611
componentes
núcleo
609
envío
datos
610
recepción
datos
610
Redes
593
595-618
arquitectura
comunicaciones
596
arquitectura
protocolos
TCP
IP
599-605
arquitectura
protocolos
597-599
LINUX
609-611
Protocolo
Simple
Transferencia
Ficheros
TFTP
614-618
sistema
operativo
red
596
sistema
operativo
distribuido
596
sockets
605-609
Reemplazo
página
algoritmo
379
380
385
LINUX
385
UNIX
379
380
Reenvío
695
Registro
activación
51
Registro
datos
memoria
RDAM
16
Registro
datos
12
Registro
dirección
RDIM
16
Registro
procesador
psr
136
Registro
instrucción
Instruction
register
13
Registro
549
Registros
auditoría
específicos
detección
712
Registros
auditoría
nativos
712
Registros
auditoría
712
Registros
control
11
13
Registros
dirección
12
índice
12
puntero
pila
12
puntero
segmento
12
Registros
procesador
11-14
Registros
visibles
usuario
11
12
Relación
muchos-a-muchos
170
237
Relación
uno-a-muchos
171-172
Relación
uno-a-uno
237
Rendimiento
SMP
81
Representación
parámetros
634
Reserva
páginas
LINUX
384
Reserva
variable
371-375
Reservada
paginación
Windows
387
Residente
memoria
virus
717
Resolución
asociativa
350
Retardo
rotacional
504
retardo
223
Retroalimentación
multinivel
420
Reubicación
gestión
memoria
308-309
rmb
290-291
Rodaja
tiempo
138
RPC
asíncrono
635
RPC
síncrono
635
Rutina
servicio
interrupción
Interrupt
service
routine
ISR
24
468
Rutina
manejador
interrupción
20
844
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
844rw_downgrade
293
rw_enter
293
rw_exit
293
rw_tryenter
293
rw_tryupgrade
293
218
221
salircritica
209-210
SCHED_FIFO
477
480
SCHED_OTHER
477
480
SCHED_RR
477
480
Sección
crítica
203
208
296
Sector
arranque
partición
585
Sector
arranque
virus
717
Sector
Windows
583
Sectores
característica
disco
538
Secundario
activo
638
Segmentación
325-327
342
355-358
características
342
gestión
memoria
325-327
implicaciones
memoria
virtual
355
organización
355-356
paginación
combinada
357-358
protección
compartición
358
Segmento
TCP
604
Segmentos
325
Seguridad
multinivel
723
Seguridad
72-73
89
583
689-741
amenazas
690-695
contraseñas
703-710
criptografía
736-741
intrusos
701-713
monitor
referencia
87
protección
inforación
sistema
operativo
72-73
protección
695-701
requisitos
690
sistemas
confiables
722-725
software
malicioso
713-722
Windows
582
725-731
sema_unit
290
Semáforo
contador
216
Semáforo
débil
218
Semáforo
fuerte
218
Semáforo
general
216
Semáforos
binarios
LINUX
216-217
288-289
Semáforos
contador
LINUX
288-289
Semáforos
lectura-escritura
LINUX
289
Semáforos
215-228
282-283
288-289
748-758
binario
216
288-289
bloqueado
218
contador
288-289
lectura-escritura
289
exclusión
mutua
218-221
implementación
226-228
mecanismos
concurrencia
UNIX
280-283
mecanismos
concurrencia
núcleo
LINUX
288-
289
primitivas
217
problema
productor
consumidor
221-226
retardo
223
semSignal
216-228
semWait
216-228
solución
filósofos
comensales
278-280
tipos
216-218
condiciones
carrera
216-228
748-758
Semántica
597
618
protocolo
598
TFTP
618
semSignal
216-228
290
semWait
216-228
290
send
235-236
239-240
Sentencias
if
234
Señales
98
99
283
componentes
núcleo
LINUX
97
99
mecanismos
concurrencia
UNIX
284
285
Separación
manecillas
380
Servidor
cluster
Windows
642-643
Servidor
621
proceso
corto
SPN
415-418
tasa
respuesta
HRRN
419-419
expropiación
266
268
Sincronización
164
175
191
193
235-241
diseño
SMP
174
hilos
Solaris
164
191
paso
mensajes
235-241
procesos
LINUX
193
Sintaxis
protocolo
597
Sintaxis
TFTP
618
Sistema
batch
lotes
58-59
61-67
multiprogramado
61-67
sencillo
58-59
Sistema
buddy
perezoso
algoritmo
382-383
Sistema
buddy
318-319
Sistema
CTSS
Compatible
Time-Sharing
System
66-67
Sistema
colas
438-443
multiservidor
443
notación
441
razón
análisis
438-440
servidor
único
440-443
Sistema
ficheros
básico
551
Sistema
ficheros
Windows
NTFS
582-587
aplicaciones
583
características
clave
583
disposición
volumen
583-585
ficheros
sistema
585
recuperación
583
585-587
tabla
fichero
maestro
Master
File
Table
584-585
volumen
estructura
fichero
584
Sistema
ficheros
global
645-646
Sistema
ficheros
virtual
Virtual
File
System
VFS
578-
581
Sistema
ficheros
virtual
LINUX
578-582
definido
578-581
objeto
EntradaD
582
Índice
Analítico
845
25-Indice
analitico
13/5/05
16:55
Página
845objeto
fichero
582
objeto
nodo-i
582
objeto
superbloque
581
tipos
objetos
primarios
581
Sistema
ficheros
55
98
193
acceso
controlado
sistemas
operativos
55
componentes
núcleo
LINUX
97-101
procesos
LINUX
193
Sistema
ficheros
499
Sistema
inmunidad
digital
720-721
Sistema
Nombres
Dominio
DNS
605
Sistema
paginación
378-380
estructuras
datos
378-379
parámetros
gestión
memoria
UNIX
SVR4
381
reemplazo
páginas
379-380
Solaris
SVR4
378-380
Sistema
gráfico
86
Sistema
mutiprocesamiento
único
usuario
161
Sistema
operativo
SO
53-303
358-378
496-500
antecedentes
desarrollos
modernos
79-82
diseño
496-500
estructura
76-79
202
estructuras
control
126-128
evolución
57-67
gestión
memoria
71-72
gestor
recursos
56-57
interfaz
usuario
computación
54-56
jerarquía
diseño
77-79
LINUX
95-101
logros
67-79
Microsoft
Windows
82-91
objetivos
funciones
54-58
procesos
68-71
105-303
protección
información
seguridad
72-74
sistemas
batch
lotes
58-68
sistemas
tiempo
compartido
64-66
sistemas
UNIX
91-95
software
358-378
Sistema
operativo
Clouds
172
Sistema
operativo
red
596
Sistema
operativo
distribuido
82
596
Sistemas
tiempo
compartido
64-67
CTSS
Compatible
Time-Sharing
System
66-67
multiprogramación
batch
lotes
vs
66
Proyecto
MAC
66
Sistemas
distribuidos
178
591-687
cliente
servidor
620-636
clusters
636-648
gestión
procesos
distribuidos
653-687
introducción
591-593
procesamiento
distribuido
619-652
redes
593
595-618
soporte
178
Sistemas
lotes
multiprogramados
61-64
histogramas
utilización
65
utilización
recursos
63
Sistemas
lotes
sencillos
58-61
instrucciones
privilegiadas
61
interrupciones
61
Lenguaje
control
trabajos
Job
Control
Language
JCL
60
núcleo
61
usuario
61
monitor
59
procesador
60
protección
memoria
61
temporizador
61
Sistemas
LINUX
95-101
componentes
núcleo
97-101
estructura
modular
96-97
historia
95-96
Sistemas
operativos
orientados
objetos
OOOS
177-178
Sistemas
UNIX
modernos
94-95
187-193
480-482
522-
527
4.4BSD
95
Berkeley
Software
Distribution
BSD
95
gestión
SVR4
522-527
gestión
hilos
SMP
Solaris
187-193
gestión
procesos
UNIX
SVR4
143-149
planificación
SVR4
480-484
Solaris
95
SVR4
System
release
94
Sistemas
UNIX
tradicionales
91-94
427-429
arquitectura
92
descripción
92-93
historia
91-92
núcleo
93
planificación
uniprocesador
427-429
smp
291
Sockets
datagrama
606
Sockets
raw
606
Sockets
stream
606
Sockets
605-609
comunicación
607
configuración
606-607
definición
606
interfaz
llamadas
606-609
Software
malicioso
713-722
bomba
lógica
715
descifrado
genérico
generic
decryption
GD
720
estrategias
antivirus
719-720
gusanos
716
programas
714
puertas
secretas
714-715
sistema
inmunidad
digital
720-721
troyano
715
725
virus
correo
721
virus
716-719
zombie
716
Software
358-378
690-695
713-722
amenazas
seguridad
hardware
692
gestión
memoria
358-378
malicioso
713-722
Software
gestión
memoria
358-378
control
carga
376-378
gestión
conjunto
residente
369-375
política
limpieza
375-376
846
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
846política
recuperación
360-361
política
reemplazo
361-369
política
ubicación
361
políticas
memoria
virtual
360
sistema
operativo
SO
358-378
Solaris
95
Soporte
programación
modular
71
Subsistemas
entorno
87
Sun
cluster
UNIX
643-646
gestión
procesos
644
redes
644
sistema
ficheros
global
645-646
soporte
objetos
comunicaciones
644
Superbloque
UNIX
578
Suspensión
proceso
377-378
proceso
activado
tiempo
378
proceso
baja
prioridad
377
proceso
conjunto
residente
menor
tamaño
378
proceso
ventana
ejecución
restante
378
proceso
378
proceso
provoca
fallos
377
Suspensión
Solaris
191
SVR
System
release
94
143-148
480-482
área
UNIX
146-147
control
procesos
148
descripción
procesos
145-148
procesos
143-144
gestión
procesos
143-148
imagen
proceso
145-146
introducción
94
Planificación
480-482
Tabla
acceso
directo
395
Tabla
asignación
disco
572
Tabla
asignación
fichero
File
Allocation
Table
FAT
566
Tabla
datos
marcos
página
UNIX
378
Tabla
nodos-i
UNIX
578
Tabla
páginas
invertida
347-349
Tabla
páginas
322
344-347
378
384
definido
322
estructura
memoria
virtual
344-347
LINUX
384
UNIX
Solaris
378
Tabla
utilización
swap
UNIX
378
Tabla
maestra
ficheros
Master
File
Table
MFT
Win-
dows
584-585
Tablas
127
Tablas
ficheros
127
Tablas
memoria
127
Tablas
procesos
128
Tablas
hash
395-398
desbordamiento
encadenado
398
hashing
lineal
397
hashing
396-397
longitud
media
búsqueda
395
397-398
tabla
acceso
directo
395
Tamaño
cache
33
368-369
Tamaño
cola
442
Tamaño
población
442
Tamaño
página
351-355
Tamaño
bloque
33
Tamaño
conjunto
residente
369-370
Tamaño
relativo
memoria
tasa
aciertos
47
Tarea
aperiódica
463
Tarea
tiempo-real
duro
463
Tarea
periódica
463
Tarea
158
Tareas
tiempo-real
suave
463
Tareas
LINUX
193-194
comunicación
procesos
IPC
193
contexto
específico
procesador
194
enlaces
193
espacio
direcciones
194
193
ejecución
194
identificadores
193
planificación
193
sistema
archivos
193
tiempo
temporizadores
193
Tasa
aciertos
29
Tasa
recorrido
380
Techo
prioridad
477
Técnicas
comunicación
34-37
acceso
directo
memoria
Direct
memory
access
DMA
36-37
dirigida
interrupciones
36
programada
34-35
Técnicas
intrusión
702-703
TELNET
605
Temporización
protocolo
597
Temporización
TFTP
618
Temporizador
61
193
esperar
246
268
testset
213-214
Texto
cifrado
736
Texto
736
Tickets
capacidades
701
Tiempo
acceso
504
Tiempo
búsqueda
504
Tiempo
estancia
411
Tiempo
respuesta
435-438
Tiempo
transferencia
504
Tiempo
58
64-67
193
proceso
LINUX
193
tiempo
establecimiento
procesamiento
serie
58
sistemas
compartidos
64-67
Trabajo
plano
161
Trabajo
plano
161
Trabajo
58
Transferencia
operación
35
Transiciones
118-119
143-144
procesos
UNIX
SVR4
143-144
Índice
Analítico
847
25-Indice
analitico
13/5/05
16:55
Página
847modelo
118-119
proceso
swapping
122-123
Trap
139
Trasgresor
701
Trasiego
thrashing
343
tratado
Dijkstra
215
Traza
111-112
TRIX
171
Troyano
715
725-726
defensa
725
definido
704-715
TryEnterCriticalSection
296
Tuberías
280
Turno
rotatorio
round
robin
75
117
413-414
planificación
413
técnica
75
entrar-primero
salir
LIFO
48
510
Única
instrucción
múltiples
flujos
datos
SIMD
172
Única
instrucción
único
flujo
datos
SISD
172
Unidad
central
proceso
Central
processing
unit
CPU
10
Unión
canales
Ethernet
Beowulf
648
Uniprocesador
UP
operaciones
barrera
291
UNIX
91-95
143-149
187-193
280-284
378-383
427-
429
480-482
522-527
574-578
643-646
gestión
ficheros
574-578
gestión
memoria
378-383
mecanismos
concurrencia
280-284
sistemas
modernos
94-95
143-149
187-193
480-482
522-527
sistemas
tradicionales
91-93
427-429
Sun
cluster
643-646
Usada
recientemente
LRU
363-363
521
Usuario
clandestino
701
Utilidad
llamada
procedimiento
local
Local
Procedure
Call
LPC
87
Utilidad
llamada
procedimiento
remoto
Remote
Proce-
dure
Call
RPC
87
Utilización
buffers
500-503
buffer
circular
503
buffer
doble
502-503
buffer
único
501-502
utilidad
503
Utilización
buffers
500-503
Valor
puertos
606
Variables
condición
229
294
sincronización
monitor
229
sincronización
Solaris
294
Vector
redundante
discos
independientes
Redundant
Array
of
Independent
Disks
RAID
511-520
capacidad
transferencia
datos
elevada
516
características
512
nivel
512
514-516
nivel
516-517
nivel
517
nivel
517-518
nivel
518-519
nivel
519
nivel
519
Velocidad
angular
constante
Constant
angular
velocity
CA
538
544
Velocidad
ejecución
161
203-204
Velocidad
lineal
constante
Constant
linear
velocity
CLV
544
279
Verificabilidad
723
Verificación
proactiva
contraseñas
709
Verificación
reactiva
contraseñas
709
Violación
exclusión
mutua
69
Virus
715
717-719
721
basado
macros
718-719
correo
721
definido
715
sector
arranque
717
naturaleza
717
oculto
717
parásito
717
polimórfico
717
residente
memoria
717
Visión
alto
nivel
11
olcado
656-657
olumen
Windows
583
WaitForSingleObject
294
Windows
seguridad
725-731
descriptores
seguridad
728
esquema
control
acceso
725-728
lista
control
acceso
sistema
SACL
728
lista
control
acceso
discrecional
DACL
729
máscara
acceso
729
testigo
acceso
728
wmb
290-291
Zombie
716
848
Sistemas
operativos
Aspectos
internos
principios
diseño
25-Indice
analitico
13/5/05
16:55
Página
8480-Primeras
12/5/05
17:09
Página
iiWilliam
Stallings
5ª
edición
Sistemas
operativos
Aspectos
internos
principios
diseño
libro
ocupa
conceptos
estructura
mecanismos
sistemas
operativos
propósito
presentar
clara
completa
naturaleza
características
sistemas
operativos
edición
autor
intentado
recoger
innovaciones
mejoras
habido
disciplina
años
transcurrido
edición
manteniendo
tratamiento
amplio
completo
materia
Asimismo
profesores
imparten
disciplina
profesionales
trabajan
campo
revisado
profundidad
cuarta
edición
consecuencia
proceso
partes
libro
mejorado
claridad
redacción
ilustraciones
acompañan
texto
incluido
problemas
carácter
realista
mejoras
pedagógicas
presentación
cara
usuario
contenido
técnico
libro
actualizado
completamente
reflejar
cambios
actuales
excitante
disciplina
estudio
Linux
extendido
significativamente
basándose
versión
Linux
2.6
estudio
Windows
actualizado
incluir
Windows
XP
Windows
Server
2003
incluye
capítulo
redes
presentándose
API
Sockets
ampliado
tratamiento
diseño
orientado
objetos
sitio
web
asociado
libro
proporciona
apoyo
estudiantes
profesores
sitio
incluye
enlaces
sitios
relevantes
copias
originales
transparencias
figuras
tablas
libro
formato
PDF
Adobe
Acrobat
transparencias
PowerPoint
información
darse
alta
lista
correo
Internet
libro
página
web
WilliamStallings.com/OS/OS5e.html
www.pearsoneducacion.com
libros
interés
Nutt
Gary
Sistemas
operativos
Madrid
Pearson
Prentice
Hall
2004
ISBN
8478290672
Tanenbaum
Andrew
S.
e.a
Sistemas
operativos
México
Pearson
Prentice
Hall
1998
ISBN
9701701658
Sistemas
operativosStallings
5ª
ed
