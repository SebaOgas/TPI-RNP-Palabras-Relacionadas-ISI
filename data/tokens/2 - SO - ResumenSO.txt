Resumen
Sistemas
Operativos
Sebasti´an
Og´as
noviembre
2022´Indice
Indice
Introducci
on
1.1
Programas
usuario
1.2
Modos
1.3
Funciones
sistema
operativo
1.3.1
aquina
extendida
1.3.2
Administrador
recursos
1.4
Partes
principales
computadora
1.4.1
Procesadores
CPU
1.4.2
Memoria
1.4.3
Dispositivos
1.4.4
Buses
1.5
Arranque
computadora
1.6
Tipos
Sistemas
Operativos
1.6.1
Mainframe
1.6.2
servidores
1.6.3
multiprocesadores
1.6.4
computadoras
personales
1.6.5
computadoras
bolsillo
PDA
Personal
Digital
Assistant
1.6.6
Integrados
Incrustados
Embedded
1.6.7
nodos
sensores
1.6.8
tiempo
real
1.6.9
tarjetas
inteligentes
1.7
Conceptos
Sistemas
Operativos
10
1.7.1
Proceso
10
1.7.2
Espacios
direcciones
10
1.7.3
Archivos
10
1.7.4
Entrada
salida
11
1.7.5
Protecci
on
11
1.7.6
Shell
11
1.7.7
Evoluci
on
obsolecencia
11
1.8
Llamadas
sistema
12
1.8.1
Llamadas
sistema
administraci
on
recursos
13
1.8.2
Llamadas
sistema
administraci
on
archivos
14
1.8.3
Llamadas
sistema
administraci
on
directorios
14
III
INDICE
1.8.4
Llamadas
14
1.8.5
Windows
15
1.9
Estructuras
sistemas
operativos
15
Procesos
17
2.1
Modelo
proceso
17
2.2
Creaci
on
procesos
17
2.3
Terminaci
on
procesos
17
2.4
Jerarqu
ıa
procesos
18
2.5
proceso
18
2.6
Tabla
procesos
18
2.7
Modelado
multiprogramaci
on
19
2.8
Hilos
control
20
2.9
Formas
construir
servidor
20
2.10
Hilos
cl´asicos
20
2.11
Hilos
POSIX
Pthreads
21
2.12
Implementaci
on
hilos
seg´un
espacio
21
2.12.1
espacio
usuario
ULT
User-Level
Threads
21
2.12.2
kernel
KLT
Kernel-Level
Threads
22
2.12.3
ıbridas
22
2.12.4
Problemas
22
2.12.5
Activaciones
planificador
22
2.13
Hilos
emergentes
22
2.14
Comunicaci
on
procesos
22
2.14.1
Condiciones
carrera
regiones
cr
ıticas
23
2.14.2
Exclusi
on
mutua
espera
ocupada
23
2.14.3
Exclusi
on
mutua
bloqueo
24
2.14.4
etodos
26
2.15
Planificaci
on
26
2.15.1
Comportamiento
proceso
27
2.15.2
Llamadas
planificador
27
2.15.3
Planificaci
on
sistemas
procesamiento
lotes
27
2.15.4
Planificaci
on
sistemas
interactivos
28
2.15.5
Planificaci
on
sistemas
tiempo
real
29
2.16
Pol´ıtica
mecanismo
30
2.17
Planificaci
on
Hilos
30
2.17.1
Planificaci
on
hilos
espacio
usuario
30
2.17.2
Planificaci
on
hilos
kernel
30
2.18
Problemas
sincronizaci
on
31
2.18.1
Interbloqueo
deadlock
31
2.18.2
ırculo
vicioso
Bloqueo
activo
livelock
33
2.18.3
Inanici
on
starvation
33
2.19
IPC
problemas
cl´asicos
comunicaci´on
procesos
33
2.19.1
Problema
fil
osofos
comelones
33
2.19.2
Problema
lectores
escritores
34
2.19.3
Problema
barber
ıa
34´INDICE
III
Administraci
on
memoria
36
3.1
Administrador
memoria
36
3.2
abstracci
on
36
3.3
Abstracci
on
espacios
direcciones
37
3.4
Registros
base
ımite
37
3.5
Intercambio
37
3.5.1
Intercambio
mapas
bits
37
3.5.2
Intercambio
listas
enlazadas
37
3.6
Memoria
virtual
38
3.6.1
Memoria
virtual
memoria
ısica
39
3.6.2
Entradas
tabla
procesos
39
3.6.3
Aceleraci
on
paginaci´on
b´ufers
traducci´on
adelantada
TLB
39
3.6.4
Memorias
extensas
tablas
aginas
multinivel
40
3.6.5
Memorias
extensas
tablas
aginas
invertidas
40
3.6.6
Algoritmos
reemplazo
aginas
41
3.6.7
Pol
ıticas
asignaci´on
44
3.6.8
Control
carga
44
3.6.9
Tama
˜no
p´agina
44
3.6.10
Espacios
separados
instrucciones
datos
44
3.6.11
Compartici
on
45
3.6.12
Pol
ıtica
limpieza
45
3.6.13
Interfaz
memoria
virtual
45
3.6.14
Participaci
on
sistema
operativo
paginaci´on
46
3.6.15
Manejo
fallos
agina
46
3.6.16
Respaldo
instrucci
on
fallida
47
3.6.17
reemplazo
aginas
47
3.6.18
Almac
respaldo
47
3.6.19
Pol
ıtica
mecanismo
48
3.7
Segmentaci
on
49
3.7.1
Segmentaci
on
pura
49
3.7.2
Segmentaci
on
paginaci´on
49
Archivos
51
4.1
Almacenamiento
informaci
on
plazo
51
4.2
Estructuras
archivos
51
4.2.1
Secuencia
bytes
52
4.2.2
Secuencia
registros
52
4.2.3
Arbol
registros
52
4.3
Tipos
archivos
52
4.3.1
Regulares
52
4.3.2
Especiales
53
4.4
Acceso
archivos
53
4.5
Atributos
archivos
53
4.6
Operaciones
archivos
53
4.7
Sistemas
directorios
54
4.7.1
Sistemas
directorios
nivel
54IV
INDICE
4.7.2
Sistemas
directorios
jer
arquicos
54
4.8
Operaciones
directorios
54
4.9
Distribuci
on
sistema
archivos
55
4.10
Implementaci
on
archivos
56
4.10.1
Asignaci
on
contigua
56
4.10.2
Asignaci
on
lista
enlazada
56
4.10.3
Asignaci
on
lista
enlazada
FAT
57
4.10.4
Nodos-I
57
4.11
Implementaci
on
directorios
57
4.11.1
Acceso
archivos
atributos
57
4.11.2
Tama
˜no
nombres
58
4.11.3
Aceleraci
on
b´usqueda
58
4.12
Sistemas
archivos
alternativos
58
4.12.1
Estructurados
registro
LFS
58
4.12.2
bit
acora
JFS
59
4.12.3
Virtuales
VFS
59
4.13
Administraci
on
espacio
disco
60
4.13.1
Modos
60
4.13.2
Tama
˜no
bloque
60
4.13.3
Bloques
libres
60
4.13.4
Cuotas
disco
62
4.14
Respaldo
sistema
archivos
62
4.15
Consistencia
sistema
archivos
62
4.16
Rendimiento
sistema
archivos
63
4.16.1
Cach
63
4.16.2
Lectura
adelantada
bloque
63
4.16.3
Reducci
on
movimiento
brazo
disco
64
4.16.4
Desfragmentaci
on
disco
64
Entradas
Salidas
65
5.1
Tipos
dispositivos
Entrada
Salida
65
5.2
Comunicaci
on
dispositivos
Entrada
Salida
65
5.3
Entradas
Salidas
puertos
asignaci
on
memoria
65
5.4
Acceso
Directo
Memoria
DMA
66
5.5
Interrupciones
67
5.6
Objetivos
software
68
5.7
Maneras
69
5.7.1
programada
69
5.7.2
controlada
interrupciones
69
5.7.3
DMA
69
5.8
Capas
software
69
5.8.1
Manejadores
interrupciones
69
5.8.2
Controladores
dispositivos
70
5.8.3
Software
independiente
dispositivo
70
5.8.4
Software
usuario
71
5.9
Discos
71´INDICE
5.9.1
Discos
magn
eticos
71
5.9.2
Discos
opticos
73
5.10
Relojes
74
5.10.1
Hardware
74
5.10.2
Tareas
controladora
reloj
74
5.10.3
Temporizadores
software
75
5.11
Interfaces
usuario
75
5.11.1
Teclado
75
5.11.2
Rat
on
76
5.11.3
Interfaces
Gr
aficas
Usuario
GUIs
76
5.12
Clientes
delgados
76
5.13
Administraci
on
energ´ıa
76
Glosario
78
Siglas
79
Bibliograf´ıa
81Cap´ıtulo
Introducci´on
1.1
Programas
usuario
Tanenbaum
2009
p.
shell
l´ınea
comandos
GUI
Graphical
User
Interface
Interfaz
Gr´afica
Usuario
1.2
Modos
Tanenbaum
2009
p.
1-2
Kernel
n´ucleo
supervisor
restricciones
acceso
nivel
ISA
Instruc-
tion
Set
Architecture
Set
Instrucciones
Arquitectura
permita
sistema
operativo
ejecuta
Usuario
ejecutar
instrucci
on
motivos
seguridad
particular
aque-
llas
relacionadas
control
m´aquina
entradas
salidas
1.3
Funciones
sistema
operativo
Tanenbaum
2009
p.
4-7
Stallings
2005
p.
54-57
12
CAP´ITULO
INTRODUCCI´ON
1.3.1
aquina
extendida
sistema
operativo
toma
interfaz
compleja
t´ecnica
provista
arquitectura
laabstrae
ofreciendo
interfaz
m´as
sencilla
programas
desarrolladores
suele
proporcionar
servicios
Desarrollo
programas
Ejecuci´on
programas
Acceso
dispositivos
Acceso
controlado
archivos
Acceso
sistema
Detecci´on
respuesta
errores
Contabilidad
estad´ısticas
par´ametros
rendimiento
1.3.2
Administrador
recursos
sistema
operativo
decide
omo
distribuir
multiplexar
recursos
CPU
Memoria
buses
rutinas
requieren
espacio
dividi´endolos
tiempo
turn´andose
1.4
Partes
principales
computadora
Tanenbaum
2009
p.
19-32
Stallings
2005
p.
10-37
1.4.1
Procesadores
CPU
Ciclo
asico
obtener
instrucci
on
memoria
ciclo
usqueda
decodificarla
ejecutar-
ciclo
ejecuci
on
acci
on
realiza
instrucci
on
suele
entrar
siguientes
categor´ıas:1.4
PARTES
PRINCIPALES
COMPUTADORA
Procesador-memoria
Procesador-E
Procesamiento
datos
Control
M´etodos
mejorar
rendimiento
Canalizaci´on
pipeline
unidad
dedicada
proceso
ciclo
asico
permitiendo
obtenci´on
decodificaci´on
ejecuci´on
simult´anea
instrucciones
consecutivas
CPU
superescalar
ultiples
unidades
dedicadas
proceso
ciclo
asico
unidad
ejecuci
on
espec´ıfica
tipo
instrucci
on
decodificadas
instrucciones
colocadas
ufer
contenci
on
cu
unidades
ejecuci
on
obtienen
Registros
Generales
variables
resultados
temporales
PC
Contador
programa
Registro
instrucciones
SP
Apuntador
Pila
Stack
Pointer
apunta
cima
PSW
Palabra
Programa
Program
Status
Word
almacena
bits
control
resultados
comparaci´on
prioridad
CPU
kernel
usuario
RDIM
RDAM
Registros
Direcciones
Datos
Memoria
RDIE
RDAE
Registros
Direcciones
Datos
S.
Registros
ındice
Registros
puntero
segmento
Llamadas
sistema
llamada
procedimiento
kernel
programa
usuario
realizan
instrucci´on
TRAP
INT
Ley
Moore
n´umero
transistores
chip
duplica
18
meses
Multihilamiento
multithreading
CPU
act´ua
m´ultiples
hilos
ejecuci´on
threads
alternados
paralelismo
funciona
ley
Moore
Multin´ucleo
multicore
m´ultiples
procesadores
conectados
cach
CPU
paralelismo
verdadero.4
CAP´ITULO
INTRODUCCI´ON
1.4.2
Memoria
par´ametros
principales
definen
memoria
indicado
velocidad
tama˜no
costo
general
velocidad
menor
tama˜no
costo
As´ı
define
jerarqu´ıa
memoria
menor
velocidad
Registros
veloces
CPU
tama
˜no
32
32
bits
64
64
bits
dependiendo
CPU
Cach´e
usada
acceso
m´as
veloz
datos
almacenados
memoria
principal
utili-
zados
com´unmente
memoria
principal
divide
l´ıneas
cach´e
corresponder
64
bytes
memoria
principal
l´ınea
cach´e
procedimiento
obtener
dato
memoria
busca
cach´es
Tipos
cach´e
L1
16kB
retraso
L2
mB
retraso
ciclos
reloj
Memoria
principal
RAM
borra
apagarse
computadora
Discos
magn´eticos
disco
duro
doble
econ´omico
suele
doble
tama˜no
RAM
as
lento
mec
anico
cilindros
compuestos
pistas
le´ıdas
cabeza
brazo.1.4
PARTES
PRINCIPALES
COMPUTADORA
Cintas
magn´eticas
mec´anica
suele
utilizarse
respaldar
datos
discos
ROM
Read-Only
Memory
escrita
abrica
borrada
Suele
usada
cargador
arranque
bootstrap
loader
tarjetas
S.
EEPROM
Electrically
Erasable
PROM
flash
borradas
reescritas
lento
CMOS
vol
atil
consume
energ´ıa
Suele
utilizarse
guardar
fecha
hora
actuales
1.4.3
Dispositivos
Consiste
dispositivo
controlador
dispositivo
s´ı
dispositivo
interfaz
simple
est
andar
discos
llama
IDE
Integrated
Drive
Electronics
Electr
onica
Unidad
Integrada
controlador
conecta
dispositivo
s´ı
ofrece
interfaz
distinta
sistema
operativo
driver
software
comunica
controlador
requiere
sistema
operativo
soporte
tipo
controlador
espec
ıfico
Requiere
ejecutarse
kernel
pasar
formar
com
necesitar
reiniciar
computadora
instalar
drivers
Windows
antiguos
sistemas
UNIX
tambi´en
drivers
cargan
forma
din´amica
Dependiendo
arquitectura
computadora
requerir
instrucciones
especialesIN
OUT
registros
dispositivos
colocan
puertos
especiales
instrucciones
necesarias
registros
dispositivos
corresponden
espacio
direcciones
sistemas
operativos
M´etodos
Espera
ocupada
driver
inicia
operaci´on
espera
termine
dispositivo
Interrupciones
driver
inicia
operaci
on
controlador
genera
interrupci
on
dispositivo
s´ı
termina
interrupci´on
ejecuta
manejador(handler
pertenece
driver
ubica
memoria
apuntada
elemento
vector
interrupci´on
DMA
Direct
Memory
Access
utiliza
chip
especial
llamado
DMA
maneja
comuni-
caci´on
controlador
memoria
CPU
configura
inicio
deja
trabajar
interrupciones
programa
temporizador
reloj
fallo
hardware6
CAP´ITULO
INTRODUCCI´ON
ocurre
interrupci´on
terminar
ejecutarse
instrucci´on
actual
ciclos
b´usqueda
ejecuci´on
ejecutarse
ciclo
interrupci´on
Ejemplo
ciclo
interrupci´on
interrupciones
suceder
momentos
inconvenientes
all
manejarse
formas
Biestable
Sistema
Interrupciones
Permite
bloquear
interrupciones
ocurre
est´a
manejando
Priorizaci´on
definen
prioridades
hora
atender
interrupciones
est´a
atendiendo
aparece
ser´a
atendida
prioridad
interrumpiendo
1.4.4
Buses
Originalmente
sol´ıa
usarse
unico
bus
aumento
velocidad
dispositivos
necesaria
implementaci´on
normalmente:1.4
PARTES
PRINCIPALES
COMPUTADORA
ISA
Industry
Standard
Architecture
Bus
usado
mantener
compatibilidad
tarjetas
antiguas
obsoleto
PCI
Peripheral
Component
Interconnect
PCI
Express
sucesores
ISA
m´as
veloces
USB
Universal
Serial
Bus
Bus
Serial
Universal
conecta
dispositivos
lentos
sumi-
nistr´andolos
energ´ıa
controlador
necesario
reiniciar
agregar
dispositivos
USB
SCSI
Small
Computer
System
Interface
bus
alto
rendimiento
dispositivos
veloces
requieren
ancho
banda
IDE
Integrated
Drive
Electronics
Electr´onica
Unidad
Integrada
conecta
perif´ericos
discos
duros
CD-ROM
IEEE
1394
bus
bits
serie
m´as
veloz
USB
controlador
central
Memoria
Local
Cach´e
conecta
CPU
cach´e
L2
Plug
and
play
sistema
permite
asignar
informaci
on
dispositivos
nive-
interrupci
on
direcciones
forma
centralizada
evitar
distintos
perif´ericos
interfieran
s´ı
ejemplo
podr´ıan
sobrescribir
informaci´on.8
CAP´ITULO
INTRODUCCI´ON
1.5
Arranque
computadora
Tanenbaum
2009
p.
33
tarjetas
madre
memoria
flash
programa
llamado
BIOS
Basic
Input
Output
System
Sistema
B´asico
arrancar
computadora
ejecuta
BIOS
Comprueba
RAM
instalada
Explora
buses
ISA
PCI
detectando
dispositivos
conectados
heredados
plug
and
play
heredados
Configura
dispositivos
ultima
Comprueba
lista
dispositivos
almacenada
memoria
CMOS
determinando
dispositivo
arranque
seg´un
prioridad
Disco
flexible
CD-ROM
Disco
duro
ejecuta
programa
inicio
dispositivo
arranque
Lee
tabla
particiones
sector
arranque
determina
partici
on
activa
Lee
cargador
arranque
secundario
partici
on
activa
ejecuta
sistema
operativo
partici
on
activa
Pide
BIOS
informaci
on
configuraci´on
Comprueba
drivers
dispositivos
Solicita
usuario
instale
faltantes
Carga
drivers
kernel
Inicialia
tablas
crea
procesos
plano
requeridos
arranca
programa
inicio
sesi´on
1.6
Tipos
Sistemas
Operativos
Tanenbaum
2009
p.
33-37
Stallings
2005
p.
79-82
172-174
1.6.1
Mainframe
computadoras
ocupan
habitaci
on
entera
memoria
capacidad
S.
Ofrecen
tipos
servicios
Procesamiento
lotes
trabajos
rutina
usuario
interactivo
presente
Procesamiento
transacciones
maneja
cantidades
peque˜nas
peticiones
Tiempo
compartido
permite
ultiples
usuarios
remotos
ejecuten
trabajos
compu-
tadora
simult´aneamente1.6
TIPOS
SISTEMAS
OPERATIVOS
1.6.2
servidores
servicio
usuarios
red
permite
compartir
recursos
1.6.3
multiprocesadores
Conectan
CPU
sistema
Seg
forma
sistema
operativo
asigna
procesos
procesadores
SMP
significa
Symmetric
Multiprocessing
referencia
sistema
computaci
on
multiprocesador
acceso
recursos
funciones
procesador
realiza
planificaci´on
procesos
Maestro-esclavo
consiste
procesador
central
cu
ejecuta
ucleo
sistema
operativo
planifican
procesos
procesadores
Cluster
diferencia
anteriores
multiprocesadores
memoria
compartida
esquema
procesador
memoria
1.6.4
computadoras
personales
Proporcionan
soporte
usuario
1.6.5
computadoras
bolsillo
PDA
Personal
Digital
Assistant
computadoras
peque˜no
tama˜no
realizan
variedad
funciones
1.6.6
Integrados
Incrustados
Embedded
computadoras
aceptan
software
instalado
usuario
ubica
ROM
Usado
autos
microondas
reproductores
MP3
etc.
1.6.7
nodos
sensores
redes
peque
˜nas
computadoras
comunican
inal
ambricamente
Suelen
trabajar
ambientes
hostiles
desatendidas
largos
periodos
energ´ıa
limitada
soportar
eventuales
fallas
nodos
1.6.8
tiempo
real
tiempo
par´ametro
clave
tolerar
falla
suave
caso
contrario
duro
suelen
utilizar
industria
duros
sistemas
audio
digital
tel
efonos
digitales
suaves
1.6.9
tarjetas
inteligentes
dispositivos
tama˜no
tarjeta
cr´edito
peque˜nos
funciones
frecuentemente
sola.10
CAP´ITULO
INTRODUCCI´ON
1.7
Conceptos
Sistemas
Operativos
Tanenbaum
2009
p.
37-49
1.7.1
Proceso
Programa
ejecuci´on
ejecutarse
suspendidos
forma
temporal
sistema
operativo
guarda
tabla
procesos
guarda
estructuras
informaci´on
acerca
proceso
proceso
consiste
imagen
ucleo
espacio
direcciones
entrada
tabla
procesos
proceso
crear
procesos
hijos
creando
as´ı
arbol
procesos
se˜nal
procesos
software
interrupci´on
hardware
procesos
comunicarse
esperando
comunicaci
on
esperan
transcurre
tiempo
perdida
env´ıa
se˜nal
alarma
proceso
emisor
reenv´ıe
datos
suspendi´endolo
temporalmente
persona
autorizada
sistema
UID
User
Identificacion
proceso
guarda
UID
inici
o.
usuarios
pertenecer
grupo
GID
Group
Identification
superusuario
especial
acceder
administradores
contrase˜na
1.7.2
Espacios
direcciones
proceso
guarda
conjunto
direcciones
utilizar
valor
axi-
mo
valor
m´aximo
excede
espacio
disponible
memoria
principal
almacenar
programa
disco
irlo
cargando
memoria
medida
requerido
llama
memoria
virtual
Tambi´en
almacenar
procesos
memoria
simult´aneamente
evitar
in-
terfieran
s´ı
sistema
operativo
implementa
mecanismo
protecci´on
hardware
controlado
software
1.7.3
Archivos
sistema
archivos
arbol
archivos
organizados
directorios
buscan
ocultar
peculiaridades
discos
dispositivos
S.
nombre
ruta
cadena
permite
identificar
archivo
sistema
archivos
absoluto
comienza
buscar
directorio
ra´ız
comienza
UNIX
caso
contrario
comienza
buscar
directorio
trabajo
actual
proceso
intentar
abrir
archivo
comprueban
permisos
devuelve
entero
llamado
descriptor
utilizado
leer
escribir
sistema
archivos
montado
permite
unir
sistemas
distintos
directorio
vac´ıo
apunte
directorio
ra´ız
dispositivos
vistos
archivos
operaciones
llamadas
leer
escribir
archivos
logra
archivos
especiales
tipos:1.7
CONCEPTOS
SISTEMAS
OPERATIVOS
11
bloque
modelan
dispositivos
discos
contienen
conjunto
bloques
acceso
aleatorio
permite
acceder
forma
directa
importar
estructura
sistema
archivos
contenga
car´acter
modelan
dispositivos
impresoras
odems
emiten
reciben
flujo
caracteres
canal
pipe
pseudoarchivo
permite
comunicaci
on
procesos
utilizando
operaciones
lectura
escritura
1.7.4
Entrada
salida
subsistema
sistema
operativo
partes
dependientes
inde-
pendientes
dispositivo
1.7.5
Protecci
on
refiere
necesidad
usuarios
ocultar
informaci
on
sistemas
limitar
acceso
usuarios
sistemas
proteger
intrusos
deseados
atacantes
virus
UNIX
protecci
on
archivos
directorios
campo
bits
dividido
subcampos
bits
subcampos
refieren
usuario
grupo
usuario
usuarios
grupo
bits
subcampo
refieren
permisos
leer
escribir
ejecutar
buscar
directorio
rwx
1.7.6
Shell
refiere
int´erprete
comandos
shells
distintos
sistemas
operativos
caracter
indicador
comandos
invocar
programaa
escribe
nombre
indicar
entrada
programa
est´andar
shell
operador
indicar
salida
est´andar
operador
crear
canal
pipe
operador
indica
programa
derecha
entrada
est´andar
salida
izquierda
signo
comando
indica
ejecutar
plano
1.7.7
Evoluci
on
obsolecencia
avance
tecnolog´ıa
vuelvan
obsoletas
provocar
consideradas
obsoletas
resurjan
Memorias
extensas
memorias
peque
˜nas
exigen
manejo
espacio
dispo-
nible
suelen
programadas
ensamblador
aumentos
capacidad
vuelve
viable
programar
lenguajes
nivel
desarrollar
computado-
ras
memorias
m´as
peque˜nas
suele
volver
necesidad
ensamblador
Hardware
protecci
on
multiprogramaci
on
exige
hardware
protecci
on
evite
proceso
utilice
memoria
imagen
n´ucleo
tambi´en
aumenta
complejidad
requerida
hardware
sistema
operativo
desarrollar
procesadores12
CAP´ITULO
INTRODUCCI´ON
hardware
protecci´on
multiprogramaci´on
tiempo
suelen
agregar
soporte
Discos
dispositivos
almacenamiento
peque
˜na
capacidad
requieren
sistema
archivos
complejo
directorio
alcanza
desarrollarse
avances
discos
vuelto
usados
sistemas
directorio
Memoria
virtual
permite
ejecutar
programas
as
memoria
principal
ligar
din´amicamente
bibliotecas
tiempo
ejecuci´on
1.8
Llamadas
sistema
Tanenbaum
2009
p.
49-61
similares
procedimiento
diferencias
ejecutan
kernel
activadas
instrucci´on
TRAP
TRAP
suele
tomar
campo
bits
corresponden
ındice
tabla
contiene
apun-
tadores
manejadores
llamadas
sistema
procedimiento
biblioteca
provee
interfaz
lenguajes
programaci´on
reali-
zar
llamadas
sistema
colocando
par´ametros
registros
correspondientes
devolviendo
valor
requerido
1.8
LLAMADAS
SISTEMA
13
1.8.1
Llamadas
sistema
administraci
on
recursos
fork
crea
copia
proceso
valor
retorno
hijo
pid
process
identifier
padre
waitpid
espera
finalice
proceso
hijo
espec´ıfico
cualquiera
pid
-1
coloca
valor
retorno
hijo
statloc.14
CAP´ITULO
INTRODUCCI´ON
exit
finaliza
proceso
devuelve
status
execve
sustituye
imagen
n´ucleo
proceso
archivo
especificado
par´ametro
1.8.2
Llamadas
sistema
administraci
on
archivos
open
abre
archivo
lectura
escritura
ambas
crea
Devuelve
fd
file
descriptor
close
cerrar
archivo
liberar
fd
read
write
leen
escriben
archivo
lseek
mueve
apuntador
posici´on
archivo
inicio
posici´on
actual
stat
fstat
permiten
accesso
informaci´on
archivo
regular
especial
directo-
rio
etc.
tama˜no
ultima
modificaci´on
etc.
1.8.3
Llamadas
sistema
administraci
on
directorios
UNIX
archivo
umero
unico
inumber
identifica
ındice
tabla
inodes
archivo
indican
propietario
bloques
disco
cantidad
enlaces
etc.
directorio
archivo
contiene
conjunto
pares
inumber
nombre
mkdir
rmdir
crean
remueven
directorio
vac´ıo
link
crea
enlace
archivo
permitiendo
acceder
distintas
rutas
unlink
elimina
enlace
archivo
elimina
archivo
mount
umount
monta
desmonta
sistema
archivos
permitiendo
integrar
jerarqu´ıa
archivos
1.8.4
Llamadas
chdir
cambia
directorio
trabajo
chmod
cambia
bits
protecci´on
archivo
rwx-rwx-rwx
kill
env´ıa
˜nal
proceso
proceso
est
preparado
recibirla
ejecuta
manejador
se˜nales
caso
contrario
mata
time
devuelve
cantidad
segundos
enero
1970
medianoche.1.9
ESTRUCTURAS
SISTEMAS
OPERATIVOS
15
1.8.5
Windows
Microsoft
provee
API
Win32
biblioteca
procedimientos
forman
interfaz
programadores
sistema
operativo
Windows
95
procedimientos
provee
involucran
llamadas
sistema
variar
versiones
Windows
GUI
manejada
kernel
1.9
Estructuras
sistemas
operativos
Tanenbaum
2009
p.
62-72
Sta-
llings
2005
p.
76-79
Sistemas
monol´ıticos
sistema
operativo
colecci
on
procedimientos
ejecuta
programa
kernel
ocultamiento
informaci
on
logra
estructura
clasificar
procedimientos
programa
principal
servicio
activan
TRAP
utilitarios
ayudan
servicio).16
CAP´ITULO
INTRODUCCI´ON
Sistema
capas
sistema
operativo
divide
procesos
capas
anillos
depen-
diendo
capa
privilegios
nivel
Ejemplos
THE
MULTICS
propuesta
sistema
operativo
tipo
hecha
Brown
R.
Den-
ning
P.
13
capas
agrupadas
grupos
hardware
primeras
capas
sistema
operativo
s´ı
procesador
unicamente
capas
dispositivos
externos
capas
13
Microkernel
sistema
operativo
capas
busca
reducir
aximo
tama
˜no
kernel
as´ı
volverlo
propenso
errores
Modelo
cliente-servidor
clasifican
procesos
servidores
clientes
clientes
env´ıan
mensaje
servidores
procesan
responden
modelo
usado
redes
computadora
M´aquinas
virtuales
refieren
sistema
operativo
ejecuta
simult
aneo
implementarse
hipervisores
tipo
ejecuta
directamente
hardware
tipo
ejecuta
sistema
operativo
Exokernel
etodo
implementar
aquinas
virtuales
consiste
crear
capa
de-
kernels
llamada
exokernel
programa
encargado
asignar
recursos
m´aquinas
virtuales
comprobar
intente
Cap´ıtulo
Procesos
2.1
Modelo
proceso
Tanenbaum
2009
p.
83-86
Consiste
idea
software
ejecutable
organiza
procesos
secuenciales
proceso
actividad
programa
entrada
salida
CPU
ejecutar
proceso
lograr
pseudoparale-
lismo
proceso
contador
programa
2.2
Creaci
on
procesos
Tanenbaum
2009
p.
86-88
creados
Arranque
sistema
procesos
plano
interact´uan
usuario
plano
demonios
daemons
Ejecuci´on
llamada
sistema
proceso
Petici´on
usuario
comando
doble
clic
ıcono
ejemplo
Inicio
trabajo
lotes
enviar
trabajos
procesamiento
lotes
mainframes
coloca
cola
entrada
ejecuta
creando
proceso
2.3
Terminaci
on
procesos
Tanenbaum
2009
p.
88-89
Salida
normal
voluntaria
Salida
error
voluntaria
Error
fatal
involuntaria
Eliminado
proceso
involuntaria
1718
CAP´ITULO
PROCESOS
2.4
Jerarqu
ıa
procesos
Tanenbaum
2009
p.
89
refiere
estructura
surge
proceso
padre
crear
procesos
hijos
Windows
padre
recibe
token
manejador
crear
hijo
permite
controlarlo
restricciones
pasar
token
procesos
invalidando
jerarqu´ıa
UNIX
s´ı
proceso
descendientes
forman
grupo
procesos
Adem´as
procesos
pertenecen
grupo
llamado
ra
ız
init
proceso
llamado
ejecutar
sistema
operativo
2.5
proceso
Tanenbaum
2009
p.
90-91
Stallings
2005
p.
117-
120
planificador
procesos
sistema
operativo
asigna
CPU
distintos
procesos
lograr
pseudoparalelismo
encarga
alternar
ejecuci
on
Listo
proceso
requiere
entrada
est´a
lista
pasa
Bloqueado
finalmente
est´e
pasa
Listo
Tambi´en
considerar
existencia
adicionales
Saliente
2.6
Tabla
procesos
Tanenbaum
2009
p.
91-93
sistemas
operativos
mantienen
tabla
procesos
entrada
llamada
bloque
control
procesos
BCP
procesos
entrada
contiene
general
depende
sistema
operativo):2.7
MODELADO
MULTIPROGRAMACI´ON
19
Gracias
tabla
funcionan
planificador
procesos
interrupciones
interrupciones
manejadas
seg´un
algoritmo
hardware
mete
pila
registros
proceso
hardware
coloca
contador
programa
direcci
on
vector
interrupciones
asociada
servicio
interrupci´on
correspondiente
guardan
registros
entrada
tabla
procesos
quita
pila
establece
pila
manejador
interrupci
on
ejecutra
servicio
interrupciones
planificador
decide
proceso
ejecutar
cargan
registros
mapa
memoria
proceso
ejecuta
proceso
2.7
Modelado
multiprogramaci
on
Tanenbaum
2009
p.
93-95
UsoCPU
pn
porcentaje
tiempo
proceso
espera
completar
operaci´on
S.
grado
multiprogramaci´on
cantidad
procesos
memoria
vez.20
CAP´ITULO
PROCESOS
2.8
Hilos
control
Tanenbaum
2009
p.
95-97
Miniprocesos
forman
proceso
ejecutan
cuasi-paralelo
ultiples
hilos
creados
proceso
comparten
espacio
direcciones
m´as
r´apidos
crear
intercambiar
eliminar
procesos
permiten
ejecutar
actividades
forma
interfieran
aumentar
rendimiento
procesadores
multin´ucleo
2.9
Formas
construir
servidor
Tanenbaum
2009
p.
97-100
2.10
Hilos
cl
asicos
Tanenbaum
2009
p.
100-104
Multihilamiento
presencia
ultiples
hilos
proceso
funcionar
CPU
turnando
procesos
requieren
ejecuci
on
bloqueado
listo
terminado
procesos
poseen
datos
compartir
espacio
memoria
hilos
acceder
hilos
tambi
datos
necesarios
funcionamiento
protecci
on
hilo
modifique
elementos
deber
ıa
necesario
hilos
cooperar
s´ı
diferencia
procesos).2.11
HILOS
POSIX
PTHREADS
21
procedimientos
biblioteca
manipular
hilos
similares
procesos
thread
create
thread
exit
thread
join
thread
yield
crear
hilo
salir
hilo
bloquear
hilo
llamador
retorne
entregar
CPU
hilos
2.11
Hilos
POSIX
Pthreads
Tanenbaum
2009
p.
104-106
IEEE
definido
est´andar
llamado
1003.1c
paquete
Pthreads
usado
mayor´ıa
sistemas
UNIX
hilo
Pthreads
identificador
conjunto
registros
conjunto
atributos
Pthreads
ofrece
m´as
60
llamadas
manipular
hilos
2.12
Implementaci
on
hilos
seg´un
espacio
Tanenbaum
2009
p.
106-
112
Stallings
2005
p.
165-169
2.12.1
espacio
usuario
ULT
User-Level
Threads
veloces
proceso
tabla
hilos
encarga
administrarla
permite
algoritmos
planificaci
on
personalizados
necesarios
implementarse
inde-
pendientemente
soporte
sistema
operativo
llamadas
sistema
producir
bloqueos
proceso
sistema
operativo
hilo
avanzar
forzar´a
cambio
contexto
procesos
as
costoso
hilos
evitarse
comprobando
llamada
sistema
producir´ıa
bloqueo
t´ecnica
llama
jacketing
fallos
p´agina
salto
a22
CAP´ITULO
PROCESOS
instrucci´on
memoria
principal
tambi´en
bloquean
proceso
cargado
memoria
necesaria
requerido
hilo
renuncie
CPU
puedan
ejecutarse
2.12.2
kernel
KLT
Kernel-Level
Threads
tabla
hilos
kernel
llamadas
sistema
bloquea
hilo
proceso
planificador
decidir
ejecutar
hilo
proceso
ocurre
fallos
p´agina
lentos
costo
procesamiento
llamadas
sistema
especial
crear
destruir
hilos
2.12.3
ıbridas
hilos
kernel
corresponde
conjunto
hilos
espacio
usuario
as´ı
obtener
velocidad
crear
destruir
tantos
hilos
kernel
flexibilidad
2.12.4
Problemas
crear
procedimiento
fork
replicar
hilos
se˜nales
env´ıan
procesos
hilos
Qu´e
hilo
deber´ıa
encargarse
recibirlas
2.12.5
Activaciones
planificador
Busca
eficiencia
implementaci
on
espacio
usuario
funcionalidad
ha-
cerlo
kernel
logra
evitando
transiciones
innecesarias
usuario
kernel
Tambi
enviando
llamada
ascendente
upcall
kernel
sistema
tiempo
ejecuci
on
infor-
mar
bloqueo
hilo
replanificar
hilos
espacio
usuario
enviando
llamada
ascendente
proceso
bloqueado
est´a
listo
produce
interrupci
on
inter
proceso
interrumpido
terminar
manejador
interrupciones
coloca
hilo
interrumpido
vuelta
interrumpido
Caso
contrario
hilo
interrumpido
suspende
sistema
tiempo
ejecuci´on
inicia
CPU
virtual
decidir
cu´al
hilo
planificar
2.13
Hilos
emergentes
Tanenbaum
2009
p.
112-113
formas
manejar
mensaje
entrante
se˜nal
hilo
bloqueado
llamada
sistema
receive
creando
hilo
emergente
pop-up
thread
reciba
mensaje
hilos
emergentes
kernel
m´as
veloces
estuviera
espacio
usuario
errores
ser´ıan
m´as
peligrosos
2.14
Comunicaci
on
procesos
Tanenbaum
2009
p.
117-145
Stallings
2005
p.
180-181
202-241
resolver
cuestiones
comunicaci
on
procesos
hilos
ultimas
pasar
informaci´on
entrar
conflicto
entrada
salida
otro.2.14
COMUNICACI
ON
PROCESOS
23
2.14.1
Condiciones
carrera
regiones
cr
ıticas
condiciones
carrera
race
conditions
producen
m´as
procesos
leen
escri-
ben
simult´aneamente
informaci´on
compartida
ocasionando
salida
procesos
dependa
orden
ejecuci´on
organizada
planificador
condiciones
carrera
evitarse
exclusi´on
mutua
evitando
m´as
proceso
escriba
lea
informaci
on
compartida
define
regiones
cr´ıticas
zonas
proceso
lee
escribe
definen
necesidades
proceso
regi
on
cr´ıtica
suposiciones
velocidad
umeros
CPUs
Ning
proceso
regi´on
cr´ıtica
bloquear
procesos
Ning
proceso
esperar
entrar
regi´on
cr´ıtica
2.14.2
Exclusi
on
mutua
espera
ocupada
Deshabilitaci´on
interrupciones
Consiste
desactivar
interrupciones
entrar
regi
on
cr´ıtica
reactivarlas
salir
funciona
CPUs
multin
ucleo
desactivan
ucleo
dem
as
podr´ıan
seguir
accediendo
memoria
compartida
Adem´as
procesos
usuario
deseable
permiso
apagar
prender
interrupcio-
nes
podr´ıan
quedar
desactivadas
error
causar
fallos
cr´ıticos
Variable
candado
Consiste
crear
variable
memoria
compartida
cuyo
valor
procesos
regi´on
cr´ıtica
s´ı
m´etodo
podr´ıa
fallar
cambia
condiciones
carrera
Alternancia
estricta
Consiste
crear
variable
memoria
compartida
variable
guardar
valor
corresponda
procesos
acceder
memoria
proceso
entrar
regi
on
cr´ıtica
variable
corresponde
entra
bucle
esperar
haga
salir
regi
on
cr´ıtica
cambia
valor
variable
permitir
proceso
ejecute
regi´on
cr´ıtica
soluci´on
deseable
satisface
necesidad
proceso
esperando
ejecutar
regi´on
cr´ıtica
proceso
corresponde
valor
actual
variable
est´a
regi´on
cr´ıtica
Adem´as
espera
valor
variable
cambie
produce
bucle
consume
CPU.24
CAP´ITULO
PROCESOS
Soluci´on
Peterson
Consiste
procedimientos
entrar
salir
regi
on
cr´ıtica
entrar
indica
proceso
est´a
interesado
entrar
regi´on
cr´ıtica
turno
deber´ıa
espera
proceso
indique
est
interesado
llamando
salir
Instrucci´on
TSL
XCHG
Instrucciones
existentes
computadoras
multiprocesadores
TSL
REGISTRO
CANDADO
guarda
CANDADO
REGISTRO
coloca
CANDADO
XCHG
REGISTRO
CANDADO
intercambia
valores
REGISTRO
CANDADO
precedida
instrucci´on
MOVE
REGISTRO
efecto
TSL
Funciona
forma
similar
alternancia
estricta
entrar
consiste
bucle
coloca
CANDADO
sale
valor
registro
salir
coloca
CANDADO
2.14.3
Exclusi
on
mutua
bloqueo
problema
productor-consumidor
b´ufer
limitado
procesos
comparten
ufer
com
tama
˜no
N.
proceso
productor
coloca
datos
b´ufer
consumidor
saca
productor
deber´ıa
colocar
datos
b´ufer
est´a
lleno
consumidor
deber´ıa
sacarlos
est´a
vac´ıo
simplificaci
on
busca
mostrar
qu
espera
ocupada
conveniente
manejar
comunicaci
on
procesos
preferir
bloqueos
diferencia
segundos
desperdician
CPU
Dormir
despertar
Llamadas
sistema
provocan
bloqueo
proceso
llamador
despertar
proceso
indicado
par´ametro
respectivamente
Aplicado
problema
productor-consumidor
b´ufer
llene
productor
duerme
consumidor
quita
elemento
despierta
productor
b´ufer
vac´ıa
consumidor
duerme.2.14
COMUNICACI
ON
PROCESOS
25
productor
agrega
elemento
despierta
consumidor
ocurrir
procesos
interrumpido
dormirse
intente
despertarlo
perdiendo
se˜nal
dormir´ıa
despertar
even-
tualmente
tambi´en
solucionarse
bit
espera
despertar
evite
perder
se˜nal
ejemplo
m´as
complejo
suficiente
Sem´aforos
Registro
umero
entero
defecto
llamada
down
decrementa
caso
contrario
pone
dormir
proceso
concretar
llamada
llamada
up
incrementa
sem´aforo
m´as
procesos
durmiendo
sem´aforo
despierta
arbitrariamente
termina
ejecutar
instrucci´on
down
devolviendo
sem´aforo
importante
up
down
implementadas
forma
at
omica
llamadas
sistema
evitar
condiciones
carrera
lograr
sincronizaci´on
sem
aforos
binarios
mutexes
utilizados
lograr
exclusi
on
mutua
inicializados
proceso
ejecutar
down
entrar
regi
on
cr´ıtica
up
salir
As´ı
proceso
down
ejecutar´a
resto
realice
down
sem´aforo
est´a
dormir
regrese
up
despertado
down
sirve
entrar
regi´on
cr´ıtica
up
salir
Aplicado
problema
productor-consumidor
crean
sem´aforos
llenos
valor
inicial
consumidor
disminuye
productor
aumen-
ta
vac´ıos
valor
inicial
productor
disminuye
consumidor
aumenta
mutex
sem
aforo
binario
lograr
exclusi´on
mutua
Mutexes
variables
condici´on
mutex
variable
cerrada
abierta
hilo
entrar
regi
on
cr´ıtica
mutex
est´a
abierto
cierra
caso
contrario
hilo
bloquea
variables
condici´on
permiten
bloquear
hilo
wait
desbloquee
signal
Adem´as
wait
toma
mutex
bloqueado
argumento
desbloquea
principio
ejecuten
hilos
bloquea
recibir
se˜nal
conjunto
mutex
esperar
hilo
obtener
desea
indicar
obtenerlo
mutex
lock(&mutex
//Bloquear
mutex
while(cond
var
cond
wait(&var
cond1
mutex
//Esperar
se~
nal
//Acciones
var
cond
signal(&var
cond2
//Enviar
se~
nal
mutex
unlock(&mutex
//Desbloquear
mutex
Monitores
mutexes
variables
condici´on
funcionan
complejos
propensos
errores
alternativa
monitores
conjuntos
procedimientos
variables
estructuras
de26
CAP´ITULO
PROCESOS
datos
ultimos
accesibles
procedimientos
monitor
garantiza
activo
Tambi´en
requieren
variables
condici´on
ventaja
implementados
compilador
evita
posibles
errores
introducidos
programador
mutexes
selecci´on
lenguajes
soportan
monitores
Java
permiten
implementarlos
sencillez
2.14.4
etodos
Pasaje
Transmisi´on
mensajes
Involucra
llamadas
sistema
send
receive
send
env´ıa
mensaje(datos
proceso
receive
recibe
mensaje
perderse
prevenir
p´erdida
comunicaci´on
recibir
mensaje
proceso
env´ıa
respuesta
llamadoacknowledgement
proceso
emisor
recibe
vuel-
ve
enviar
mensaje
Adem´as
mensaje
n´umero
secuencia
identifica
perdiera
mensaje
acknowledgement
enviara
mensaje
receptor
sabr´ıa
ignorar´ıa
mensajes
guardan
tambi
identificaci
on
proceso
emisor
as
receptor
autenticarlo
Direccionamiento
refiere
d´onde
apuntan
mensajes
d´onde
ser´an
recibidos
b´ufer
llamado
buz´on
puerto
ser´a
manejado
proceso
alternativa
proceso
s´ı
implica
estrategia
llamada
encuentro
consistente
bloquear
receptor
emisor
emita
mensaje
bloquear
emisor
receptor
est´e
listo
recibir
mensaje
Barreras
Busca
sincronizar
distintos
procesos
Consiste
crear
as
barreras
bloquean
procesos
hayan
llegado
libera
2.15
Planificaci
on
Tanenbaum
2009
p.
145-161
refiere
algoritmo
selecciona
proceso
hilo
ejecutar
listo
Planificador
procesos
kernel
algoritmo
planificaci
on
prioridad
procesos
satisfacer
usuario
tambi
alternar
procesos
costoso
CPU
involucra
guardar
actual
proceso
cargar
adem´as
suele
invalidar
cach´e
algoritmo
planificaci´on
perseguir
metas
Equidad
otorgar
proceso
justa
CPU
Aplicaci´on
pol´ıticas
verificar
lleven
cabo
pol´ıticas
establecidas
Balance
mantener
ocupadas
partes
sistema2.15
PLANIFICACI
ON
27
2.15.1
Comportamiento
proceso
proceso
limitado
alculos
invierte
tiempo
CPU
limitado
O-bound
ocupa
tiempo
esperando
ınea
tiempo
corresponde
proceso
limitado
alculos
limitado
S.
2.15.2
Llamadas
planificador
Ocurren
autom´aticamente
crearse
proceso
elije
ejecutar´a
padre
hijo
terminar
proceso
hubiera
ning´un
proceso
listo
ejecuta
inactivo
provisto
sistema
bloquearse
proceso
podr
ıa
util
situaciones
contexto
definir
prioridad
particular
com´un
planificador
acceso
ocurrir
interrupci´on
S.
ocurrir
interrupci
on
reloj
sistema
operativo
llamarlo
situaciones
algoritmo
planificaci
on
apropiativo
implica
procesos
tiempo
aximo
ejecuci
on
ininterrumpida
diferencia
apropiativo
2.15.3
Planificaci
on
sistemas
procesamiento
lotes
necesario
limitar
tiempo
CPU
proceso
problema
algoritmos
planificaci´on
apropiativos
apropiativos
largos
periodos
Metas
adicionales
Rendimiento
maximizar
n´umero
trabajos
completos
hora
Tiempo
retorno
minimizar
tiempo
entrega
terminaci´on
Utilizaci´on
CPU
mantenerla
ocupada
tiempo28
CAP´ITULO
PROCESOS
entrar
atendido
First-Come
First-Served
FCFS
Utiliza
cola
equitativo
desventaja
procesos
limitados
alculos
ralentizar
significativamente
limitados
S.
trabajo
m´as
corto
Prioriza
trabajos
as
cortos
determinado
estad
ısticamente
As´ı
optimiza
tiempo
retorno
promedio
optimo
trabajos
est´an
disponibles
menor
tiempo
restante
continuaci´on
Shortest
Remaining
Time
Next
SRTN
Similar
trabajo
as
corto
elije
ejecutar
trabajo
requiera
tiempo
completado
bloqueando
ejecuci´on
necesario
2.15.4
Planificaci
on
sistemas
interactivos
sistemas
interactivos
servidores
s´ı
necesario
contar
algoritmo
apropiativo
suele
deseable
ejecute
proceso
largos
periodos
Metas
adicionales
Tiempo
respuesta
responder
peticiones
rapidez
Proporcionalidad
cumplir
expectativas
usuarios
Planificaci´on
turno
circular
round-robin
proceso
asigna
intervalo
tiempo
m´aximo
llamado
qu´antum
cu´al
ejecutar
proceso
excede
qu
antum
bloqueado
ejecuta
fila
procesos
colocando
proceso
bloqueado
fila
conmutaci
on
procesos
cambio
proceso
ejecuci
on
costosa
qu´antum
chico
problem
atico
tambi´en
colocaran
pro-
cesos
fila
ocasionar´ıa
tiempo
respuesta
ultimos
procesos
Planificaci´on
prioridad
asigna
prioridad
procesos
ejecuta
es´util
m´ultiples
usuarios
manejar
demonios
etodo
trae
problema
proceso
prioridad
podr
ıa
ejecutarse
indefini-
damente
evitarlo
podr
ıa
implementarse
qu
antum
disminuir
prioridad
proceso
ejecuci´on
interrupci´on
reloj
prioridades
asignarse
forma
est´atica
seg´un
ejemplo
importancia
usuario
propietario
Tambi´en
asignarse
forma
din´amica
ejemplo
lograr
balance
ocupar
partes
sistema
otorgando
prioridad
procesos
limitados
S.
asignaci´on
din´amica
usarse
algoritmo
ejemplo
establecer
prioridad
fracci´on
qu´antum
us´o
proceso
m´etodo
combinado
planificaci
on
turno
circular
creando
clases
prio-
ridad
ejecuten
proceso
azar
pertenezcan
clase
prioridad
Requiere
ajustar
prioridades
ocasionalmente
procesos
ejecuten.2.15
PLANIFICACI
ON
29
M´ultiples
colas
distintas
clases
prioridad
asigna
qu´antums
m´as
largos
menor
prioridad
clase
As´ı
distintos
criterios
crear
clases
asignar
prioridades
criterios
CTSS
asigna
qu
antum
clase
prioridad
as´ı
sucesivamente
XDS
940
clases
terminal
qu´antum
corto
qu´antum
menor
prioridad
criterio
busca
favorecer
procesos
interactivos
Adem´as
suele
implementar
algoritmo
mueva
procesos
clases
menor
prioridad
asegurarse
alternar
CPU
tambi´en
implementar
algoritmo
mueva
clases
prioridad
proceso
m´as
corto
continuaci´on
Similar
trabajo
as
corto
sistemas
procesamiento
lotes
em-
bargo
requiere
estimar
tiempo
ejecuci
on
requerido
realizarse
algoritmo
envejecimiento
estima
tiempo
ejecuci´on
base
tiempo
ocup´o
ejecuciones
anteriores
otorgando
importancia
m´as
recientes
Planificaci´on
garantizada
establecen
reglas
referidas
proporci
on
CPU
distribuido
intenta
cumplir
podr
ıan
usuario
corresponda
fracci
on
CPU
proceso
corresponda
fracci´on
ciclos
CPU
Planificaci´on
sorteo
otorga
procesos
boletos
loter´ıa
cantidad
tiempo
realiza
sorteo
selecciona
alg
boleto
proceso
obtiene
premio
acceso
recurso
requiere
tiempo
CPU
m´etodo
forma
sencilla
permite
crear
prioridades
otorgando
m´as
boletos
cooperaci´on
procesos
intercambiando
boletos
Planificaci´on
partes
equitativa
Relacionada
planificaci´on
garantizada
toma
propietario
proceso
otorgar
prioridades
2.15.5
Planificaci
on
sistemas
tiempo
real
sistemas
tiempo
real
suele
qu
clase
proceso
ejecutar
necesario
algoritmo
apropiativo
Metas
adicionales
Cumplir
plazos
evitar
perder
datos
Predictibilidad
evitar
degradaci´on
sistemas
multimedia30
CAP´ITULO
PROCESOS
Suelen
implementarse
procesos
cortos
planificador
intentar
organizar
procesos
cumplir
tiempo
l´ımite
detecte
eventos
externos
sistema
tiempo
real
responder
eventos
peri
odicos
ocurren
intervalos
regu-
lares
aperi´odicos
sistema
planificable
cumple
i=0
Ci
Pi
cantidad
eventos
peri´odicos
Pi
periodo
evento
Ci
tiempo
CPU
requerido
evento
algoritmos
planificaci
on
tiempo
real
est
aticos
informaci
on
perfecta
antemano
trabajo
ejecutar
toman
decisiones
sistema
ejecute
din´amicos
toman
decisiones
tiempo
ejecuci´on
sistema
2.16
Pol
ıtica
mecanismo
Tanenbaum
2009
p.
161-162
algoritmo
planificaci
on
separarse
pol´ıtica
mecanismo
planificaci
on
me-
canismo
kernel
mencionados
anteriormente
kernel
s´ı
forma
alg
proceso
deber´ıa
m´as
prioridad
eficiente
mejorarse
proveyendo
llamadas
sistema
permitan
proceso
usuario
determine
pol´ıtica
planificaci´on
importancia
procesos
hijos
2.17
Planificaci
on
Hilos
Tanenbaum
2009
p.
162-163
Depende
espacio
encuentran
2.17.1
Planificaci
on
hilos
espacio
usuario
planificador
hilos
espacio
usuario
permite
algoritmo
perso-
nalizado
potencialmente
m´as
eficiente
problema
particular
planificador
kernel
utilizar
etodos
mencionados
general
qu
antums
hilo
proceso
podr´ıa
ejecutarse
forma
indefinida
qu´atums
externos
proceso
kernel
decidir
tiempo
aximo
proceso
hilos
2.17.2
Planificaci
on
hilos
kernel
involucrar
llamadas
sistema
considerablemente
m´as
lento
optimizado
otorgar
prioridad
hilos
proceso
evitar
cambiar
mapa
memoria
invalidar
cach´e
permite
flexibilidad
necesario
ejecutar
r´afaga
hilos
pertenecientes
proceso.2.18
PROBLEMAS
SINCRONIZACI´ON
31
principal
ventaja
etodo
bloquearse
hilo
bloquear
pro-
ceso
2.18
Problemas
sincronizaci
on
Tanenbaum
2009
p.
433-461
Stallings
2005
p.
203
258-277
2.18.1
Interbloqueo
deadlock
Ocurre
conjunto
procesos
proceso
est
esperando
evento
olo
ocasionado
proceso
conjunto
eventos
esperan
liberaciones
recursos
dispositivos
hardware
piezas
in-
formaci´on
espec´ıficamente
tipo
apropiativo
quitados
proceso
causar
problemas
conoce
interbloqueos
recursos
interbloqueos
tipo
darse
recursos
reutilizables
destruyen
terminar
usados
consumibles
destruyen
proceso
productor
crea
necesitados
convenci´on
modelar
relaciones
procesos
recursos
grafos
asignaci´on
recursos
procesos
modelan
nodos
circulares
recursos
modelan
nodos
rectangulares
ejemplares
recursos
modelan
puntos
nodos
recursos
As´ı
flecha
proceso
recurso
significa
solicita
flecha
ejemplar
recurso
proceso
implica
posee
forma
identificar
interbloqueo
hallar
bucle
Condiciones
interbloqueo
Exclusi´on
mutua
recurso
asignarse
proceso
simult´aneamente
Contenci´on
espera
capacidad
solicitar
recursos
previamente
asigna-
Condici´on
apropiativa
quitar
recursos
fuerza
proceso
liberar-
Espera
circular
lista
circular
as
procesos
as
recursos
necesitados
siguiente32
CAP´ITULO
PROCESOS
Estrategias
soluci´on
interbloqueos
Ignor´andolo
algoritmo
avestruz
Detect´andolo
recuper´andolo
Detecci´on
interbloqueos
recurso
tipo
nodo
recorriendo
grafo
forma-
do
terminando
llegar
nodo
analizado
recorrer
grafos
nodos
procesos
poseen
quieren
recursos
interbloqueos
recursos
tipo
basado
marcaje
procesos
finalizados
recursos
potencialmente
disponibles
busca
proceso
finalizado
recursos
actuales
finalizar
recursos
eventualmente
disponibles
marca
proceso
algoritmo
termina
finalizar
procesos
marcar
encuentran
interbloqueo
Recuperaci´on
apropiaci
on
retroceso
realizan
puntos
comprobaci
on
peri´odicamente
restaurando
pro-
ceso
hubiera
interbloqueo
eliminaci
on
procesos
ciclo
liberar
recursos
Predici´endolo
evit´andolo
distinguiendo
seguros
inseguros
seg´un
garanti-
zarse
llevar´a
interbloqueo
evitando
asignar
recursos
proceso
requiere
llevar´ıa
inseguro
algoritmo
banquero
similar
algoritmo
detecci´on
interbloqueos
recursos
tipo
diferencia
activa
asignar
recursos
asignaci
on
llevar´ıa
inseguro
algoritmo
aplicado
cu´antos
recursos
podr´ıa
requerir
proceso
m´aximo
variara
cantidad
procesos
pudiera
disminuir
n´umero
recursos
disponibles
motivos
externos
procesos
fueran
independientes
s´ı
orden
ejecuci´on
depende
forma
alternativa
optima
implementar
m´etodo
impidiendo
proceso
inicie
necesidades
recursos
sumadas
procesos
activos
superan
recursos
disponibles
Previni´endolo
removiendo
condiciones
Exclusi
on
mutua
inviable
requiere
cuidadoso
asignar
recursos
evitar
caos
Contenci
on
espera
realizarse
solicitando
asignen
recursos
comenzar
ejecuci´on
cu´ales
cu´antos
necesitar´a
requirien-
do
solicitar
recurso
libere
resto
solicitarlos
nuevamente
vez.2.19
IPC
PROBLEMAS
CL´ASICOS
COMUNICACI´ON
PROCESOS
33
apropiativa
quitar
recursos
peligroso
virtualiza
demonio
acceder
directamente
evitar
interbloqueos
relacionados
recurso
virtualizar
consume
espacio
disco
interblo-
queo
aqu´ı
recursos
virtualizados
forma
solucionarlos
forzando
proceso
liberar
recurso
proceso
solicita
sirve
recursos
cuyo
salvado
restaurado
Espera
circular
forzando
proceso
acceso
recurso
si-
mult´aneamente
enumerando
recursos
forma
ning
proceso
adquirir
recursos
menores
contiene
Estrategia
integrada
requiere
especificar
clases
recursos
utilizando
estrategia
prevenci´on
espera
circular
enumeraci´on
evitar
interbloqueos
recursos
clases
distintas
evitar
interbloqueos
recursos
clase
elegir
estrategia
parezca
apropiada
ning
algoritmo
general
bue-
situaciones
particulares
ejemplo
bloqueo
fases
usado
sistemas
bases
datos
algoritmo
intenta
bloquear
registros
recursos
necesita
desbloque´andolos
comenzando
bloqueado
fase
actualiz´andolos
liber´andolos
finalizar
fase
tipo
distinto
interbloqueos
comunicaci
on
evento
libe-
raci´on
recursos
recepci´on
mensaje
interbloqueo
comunicaci
on
ocurrir
sencillamente
p´erdida
mensaje
Suele
solucionarse
tiempos
espera
reenviando
mensaje
recibido
respuesta
acknowledgement
lapso
tiempo
tambi´en
requiere
protocolo
validar
mensajes
ejemplo
mensaje
hubiera
retrasado
perdido
podr´ıa
causar
recepci´on
doble
mensaje
2.18.2
ırculo
vicioso
Bloqueo
activo
livelock
Ocurre
m´ultiples
procesos
cambian
respuestas
cambios
procesos
avance
realmente
procesos
dejan
ejecutarse
planificador
decida
2.18.3
Inanici
on
starvation
Ocurre
proceso
capaz
avanzar
funcionamiento
algo-
ritmo
planificaci´on
palabras
planificador
pospone
tiempo
indefinido
2.19
IPC
problemas
cl
asicos
comunicaci
on
procesos
Tanenbaum
2009
p.
163-168
Stallings
2005
p.241-245
277-280
758-763
2.19.1
Problema
fil
osofos
comelones
fil´osofo
ocupa
tiempo
comiendo
pensando
fil
osofos
sientan
mesa
redonda
platos
espagueti
tenedores
plato
tenedores
costados
Los34
CAP´ITULO
PROCESOS
fil´osofos
italianos
as´ı
necesitan
tenedores
comer
comen
vuelven
pensar
liberando
tenedores
lograr
algoritmo
ejecute
trabe
soluci
on
fil
osofo
querer
comer
intente
agarrar
tenedores
suel-
terminar
comer
Podr
ıa
producirse
interbloqueo
ejemplo
fil
osofos
agarraran
tenedor
izquierdo
soltaran
comer´ıa
modificaci
on
algoritmo
podr
ıa
fil
osofo
agarra
tenedor
agarrar
suelta
espera
tiempo
volver
intentarlo
Podr
ıa
producirse
inanici
on
fil
osofos
empiezan
intentando
comer
esperando
come
Podr´ıa
arreglarse
introduciendo
aleatoriedad
volviendo
estad
ısticamente
improbable
ina-
nici´on
suficiente
sistema
cr´ıtico
fallar
Podr´ıa
utilizarse
sem´aforo
binario
us´o
problema
productor-consumidor
coordinar
procesos
ser´ıa
confiable
eficiente
fil
osofo
comer´ıa
podr´ıan
algoritmo
mejora
ser´ıa
implementar
sem´aforo
fil´osofo
guardar
comiendo
pensando
hambriento
fil´osofo
podr´ıa
comer
vecinos
est´an
problema
tambi´en
solucionado
monitor
posea
procedimientos
obtener
liberar
tenedores
Adem´as
requiere
arreglo
valores
booleanos
almacene
disponibilidad
tenedores
variables
condici´on
tenedor
2.19.2
Problema
lectores
escritores
Modela
acceso
base
datos
lectores
escritores
ultiples
lec-
tores
acceder
escritor
est
accediendo
m´as
lector
escritor
soluci
on
implementar
sem
aforo
binario
entrar
lector
realiza
operaci
on
down
bloquee
escritores
permite
pasar
as
lectores
salga
lector
realiza
operaci
on
up
problema
lectores
escritores
podr´ıan
entrar
alternativa
escritor
espera
suspenda
lectores
lleguen
permite
escritores
esperen
lectores
llegaron
2.19.3
Problema
barber
ıa
requiere
asegurar
correcto
funcionamiento
barber
ıa
barberos
sillas
clientes
ubican
atendidos
caja
sill
on
capacidad
personas
caja
administrada
barbero
soluci´on
implementarse
m´ultiples
sem´aforos:2.19
IPC
PROBLEMAS
CL´ASICOS
COMUNICACI´ON
PROCESOS
35
Sem´aforo
wait
signal
max
capacidad
Cliente
espera
espacio
entrar
barber´ıa
Cliente
avisa
sale
bar-
ber´ıa
sill´on
Cliente
espera
lugar
sill´on
Cliente
avisa
aten-
der
levantarse
sof´a
silla
barbero
Cliente
espera
vac
ıe
si-
lla
Barbero
avisa
vac´ıa
si-
lla
cliente
listo
Barbero
espera
cliente
siente
silla
Cliente
avisa
sent´o
terminado[n
Cliente
espera
corte
pe-
completado
Barbero
avisa
termin´o
corte
dejar
silla
Barbero
espera
cliente
silla
Cliente
avisa
levantado
silla
pago
Cajero
espera
cliente
pague
Cliente
avisa
pag
recibo
Cliente
espera
obtener
reci-
bo
pago
Cajero
avisa
acept´o
pago
coord
Espera
barbero
ca-
jero
libre
funciones
Avisa
barbero
cajero
li-
ber´o
numero
Cliente
espera
ning
cliente
est´e
consiguiendo
ume-
ro
cliente
Cliente
avisa
obtuvo
n´umero
cliente
Cabe
mencionar
a˜nade
sem´aforo
n´umero
lograr
sincronizaci´on
termi-
nar
barbero
corte
terminado
arreglo
sem´aforos
up
barbero
podr´ıa
suceder
eche
cliente
silla
terminar
corte
retenga
as
tiempo
necesario
asignar
umero
cliente
barbero
˜nalizar
sem´aforo
terminado
correspondiente
Cap´ıtulo
Administraci´on
memoria
3.1
Administrador
memoria
Tanenbaum
2009
p.
175-176
sistema
operativo
asigna
libera
memoria
procesos
manteniendo
registro
partes
particularmente
memoria
principal
abstraer
memoria
3.2
abstracci
on
Tanenbaum
2009
p.
176-179
Direccionamiento
absoluto
programas
ven
memoria
ısica
formas
plantear
multiprogramaci´on
causar
problemas
procesos
usuario
podr
ıa
errores
cr´ıticos
sistema
operativo
est´a
RAM
proceso
modifica
formas
ubicar
sistema
operativo
memoria
RAM
posiciones
bajas
ROM
posiciones
altas
Controladores
dispositivos
BIOS
ROM
resto
RAM
hilos
supone
hilos
acceso
memoria
frecuente
usuario
quiera
ejecutar
programas
independientes
simult´aneo
llaves
Utilizado
IBM
360
consiste
dividir
memoria
bloques
tama˜no
fijo
asignarles
llave
bits
corresponder
llave
proceso
PSW
utilizar
bloque
direccionamiento
absoluto
proceso
ubicaci
on
memoria
intentar
ejemplo
saltar
sector
llaves
reubicaci´on
est´atica
static
relocation
Variaci´on
direcci´on
memoria
programa
suma
direcci´on
inicial
carga
evitar
referencias
sectores
Funciona
lento
363.3
ABSTRACCI
ON
ESPACIOS
DIRECCIONES
37
3.3
Abstracci
on
espacios
direcciones
Tanenbaum
2009
p.
179-
180
espacio
direcciones
conjunto
direcciones
proceso
direccionar
memoria
asignar
espacios
direcciones
procesos
distintos
etodos
registros
base
l´ımite
intercambio
memoria
virtual
3.4
Registros
base
ımite
Tanenbaum
2009
p.
180-181
Almacenan
direcci´on
inicial
longitud
programa
respectivamente
Utiliza
reubicaci´on
din´amica
sumando
valor
registro
base
referencia
memoria
momento
ejecutar
instrucci
on
realiza
relativamente
costoso
requiere
suma
comparaci
on
evitar
sobrepasar
l´ımite
3.5
Intercambio
Tanenbaum
2009
p.
181-187
Consiste
mover
procesos
completos
disco
ejecutan
ocupen
memoria
hacerse
reubicaci
on
est
atica
din
amica
registros
base
fuente
intercambiar
procesos
creando
huecos
memoria
entran
proce-
sos
combinar
hueco
compactaci´on
memoria
moviendo
procesos
abajo
costosa
espacio
direcciones
proceso
suele
requerir
crecer
ejemplo
dejar
huecos
procesos
ocupados
necesario
proceso
hueco
crecer
movido
hueco
m´as
procesos
adyacentes
crear
hueco
proceso
crecer
area
intercambio
disco
est
llena
proceso
suspenderse
libere
espacio
eliminarse
funcione
etodo
distinguir
memoria
libre
ocupada
lograrse
3.5.1
Intercambio
mapas
bits
crean
unidades
asignaci
on
partes
memoria
direcciones
longitud
mapa
bits
bit
unidad
asignaci
on
bits
bit
representa
unidad
asignaci´on
Unidades
asignaci
on
peque
˜nas
dejan
huecos
peque
˜nos
requieren
mapa
vice-
versa
proceso
memoria
buscar
secuencia
cantidad
bits
mapa
indiquen
unidad
asignaci´on
vac´ıa
costoso
3.5.2
Intercambio
listas
enlazadas
Consiste
mantener
lista(s
relacionad(as
punteros
informaci
on
necesaria
segmentos
memoria
huecos
procesos
Requiere
fusi
on
huecos
siem-38
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
pre
termina
proceso
evitar
fragmentaci
on
memoria
huecos
peque
˜nos
adyacentes
Tipos
Lista
unica
utiliza
lista
segmentos
cuyos
elementos
especifican
direcci
on
inicio
longitud
proceso
hueco
adem´as
puntero
Doble
lista
procesos
huecos
m´as
veloz
lista
unica
Doble
lista
optimizada
procesos
huecos
guarda
longitud
puntero
direcci
on
hueco
elemento
lista
inicio
hueco
correspondiente
Doble
lista
ordenada
procesos
huecos
ordenada
hueco
m´as
peque˜no
m´as
M´ultiples
listas
lista
procesos
lista
tama˜no
frecuente
hueco
reque-
rido
ubicar
procesos
Requiere
tabla
punteros
elementos
lista
huecos
Usada
unicamente
algoritmo
ajuste
r´apido
Algoritmos
ubicar
procesos
ajuste
busca
lista
segmentos
huecos
est´an
separadas
inicio
hueco
acomode
proceso
ajuste
ajuste
busca
hueco
acomod
proceso
levemente
rendidor
algoritmo
ajuste
ajuste
busca
hueco
m´as
peque˜no
proceso
evitar
dividir
huecos
as
lento
algoritmo
ajuste
dobles
listas
orde-
nadas
equivalentes
suele
causar
as
huecos
peque
˜nos
inutilizables
algoritmos
anteriores
ajuste
busca
hueco
m´as
hueco
queda
suficiente-
mente
util
Ajuste
r´apido
utiliza
m´ultiples
listas
busca
lista
huecos
tama˜no
indicado
m´as
veloz
fusi´on
huecos
tambi´en
significativamente
m´as
costosa
3.6
Memoria
virtual
Tanenbaum
2009
p.
188-234
Virtualizar
memoria
consiste
dividir
memoria
ocupa
proceso
objetivo
cargar
memoria
proceso
m´as
m´etodo
acceder
memoria
principal
f´ısica
memorias
inferiores
superiores
jerarqu´ıa
proceso
divide
llama
p´agina
Tambi´en
dividir
memoria
f´ısica
partes
iguales
capaces
contener
p´aginas
llama
marco
p´agina
memoria
virtual
implementada
hardware
MMU
Memory
Management
Unit
mantiene
tabla
p´aginas
entrada
p´agina
memoria
virtual
logra
procesos
manejen
direcciones
virtuales
procesadas
mandarse
memoria
ısica
traducidas
direcciones
ısicas
MMU.3.6
MEMORIA
VIRTUAL
39
3.6.1
Memoria
virtual
memoria
ısica
direcci
on
virtual
consta
partes
umero
agina
desplazamiento
umero
p´agina
corresponde
ındice
tabla
p´aginas
obtener
direcci´on
f´ısica
obtener
n´umero
marco
p´agina
halla
entrada
colocarlo
desplazamiento
p´agina
cuyo
n´umero
direcci´on
virtual
encuen-
tre
actualmente
memoria
ısica
bit
presente
ausente
entrada
tabla
aginas
pasa
ejecuta
TRAP
correspondiente
fallo
agina
otorga
control
sistema
operativo
traiga
agina
necesaria
memoria
secundaria
principal
3.6.2
Entradas
tabla
procesos
N´umero
marco
p´agina
secuencia
bits
utilizados
obtener
direcci´on
f´ısica
Presente
ausente
bit
indica
p´agina
memoria
f´ısica
Protecci´on
bit
secuencia
bits
indica
p´agina
ejemplo
le´ıda
escrita
le´ıda
formato
rwx
Modificada
bit
sucio
bit
indica
agina
modificada
permite
aumentar
eficiencia
traer
p´agina
marco
ocupa
salir
memoria
principal
copia
fiel
memoria
secundaria
correspondiente
necesario
actualizar
Referenciada
bit
establece
agina
usada
lectura
escri-
tura
utilizada
ayudar
sistema
operativo
elegir
agina
desalojar
necesario
cach
inhabilitado
bit
permite
deshabilitar
cach
agina
situaciones
agina
est
asociada
registro
dispositivo
lugar
memoria
principal
querr
hardware
acceso
palabra
dispositivo
actualizada
copia
cach´e
3.6.3
Aceleraci
on
paginaci´on
b´ufers
traducci´on
adelantada
TLB
tabla
p´aginas
implementada
formas
registros
hardware
MMU
veloz
peque
˜no
costoso
Adem
as
conmutaci´on
contexto
procesos
vuelve
m´as
lenta
cambiar
tambi´en
valores
arreglo
registros.40
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
memoria
principal
lento
doble
accesos
memoria
requiere
registro
MMU
apunte
inicio
tabla
aginas
conmuta-
ciones
contexto
m´as
veloces
As´ı
cach´es
reducir
acceso
memoria
principal
aumentar
velocidad
dispositivo
hardware
llamado
TLB
Translation
Lookaside
Buffer/
ufer
Traducci´on
Adelantada
memoria
guarda
entradas
tabla
aginas
n´umero
p´agina
corresponda
idealmente
acceso
frecuente
objetivo
evitar
acceso
memoria
entrada
est´e
TLB
MMU
direcci´on
virtual
traducir
algoritmo
Comparar
agina
virtual
instrucci´on
presentes
TLB
all
leer
entrada
all
buscar
entrada
tabla
p´aginas
memoria
principal
leerla
agina
memoria
principal
traerla
Traducir
direcci
on
TLB
administrado
hardware
software
d´onde
implementar´a
algoritmo
administrado
software
sistema
operativo
est
cargo
buscar
p´aginas
memoria
principal
modificar
TLB
motivo
simplificar
MMU
reduciendo
tama˜no
permitiendo
mejorar
rendimiento
m´aquina
aprovechar
espacio
MMU
encargada
buscar
entradas
tabla
aginas
TLB
admi-
nistrado
software
forma
MMU
pasa
control
sistema
operativo
encontrar
entrada
fallo
TLB
mejorar
rendimiento
procesadores
administran
TLB
software
reduciendo
fallos
TLB
intentar
adelantarse
ultiples
operaciones
memoria
p´aginas
reduciendo
costo
fallo
TLB
mantener
cach´e
entradas
TLB
software
posici´on
fija
cuya
p´agina
encuentre
TLB
as
podr´ıa
darse
situaci
on
entrada
direcci´on
virtual
cualquiera
encuentre
TLB
intentar
buscar
tabla
p´aginas
ocurra
est´e
TLB
fallo
suave
ocurre
agina
est
TLB
memoria
fallo
duro
est´a
memoria
buscar
disco
3.6.4
Memorias
extensas
tablas
aginas
multinivel
Consiste
tabla
aginas
cuyas
entradas
corresponden
umero
marco
p´agina
tablas
aginas
permite
tablas
memoria
necesa-
rias
Requiere
doble
traducci´on
memoria
virtual
niveles
3.6.5
Memorias
extensas
tablas
aginas
invertidas
Consiste
tabla
marcos
aginas
cuya
cantidad
menor
aginas
ahorran
espacio
tambi
lentas
encontrar
agina
espec´ıfico
n´umero
p´agina
ındice
lugar
buscar
marco
de3.6
MEMORIA
VIRTUAL
41
p´agina
haga
referencia
agina
buscada
Adem´as
use
TLB
usqueda
ocurrir
fallos
TLB
forma
acelerar
usqueda
agina
tabla
agina
memoria
haga
corresponder
marco
agina
tipo
tabla
llama
tabla
hash
3.6.6
Algoritmos
reemplazo
aginas
Optimo
etiqueta
agina
cantidad
instrucciones
ejecutar
an
re-
ferencie
dicha
agina
cambio
selecciona
cuyo
valor
etiqueta
imposible
implementar
cu
antas
instrucciones
tardar
pr´oxima
referencia
corrida
estimar
valores
sirve
programa
datos
entrada
usadas
recientemente
NRU
Clase
Referenciado
Modificado
Utiliza
bits
Referenciada
Modificada
en-
tradas
tabla
procesos
Establece
jerarqu´ıa
ba-
decidir
qu´e
p´agina
sacar
memoria
f´ısica
clase
buscar
p´agina
azar
sacar
ser´a
caso
as
sucesivamente
entrar
salir
FIFO
Mantiene
lista
enlazada
entradas
tabla
p´aginas
forma
producirse
fallo
p´agina
elimina
ultima
agrega
inicio
problema
podr
ıa
eliminarse
entrada
importante
tiempo
requerir
buscada
nuevamente
oportunidad
Variaci´on
FIFO
ocurre
fallo
agina
comprueba
elemento
cola
referenciado
carga
elimina
caso
contrario
mueve
elemento
principio
cola
coloca
renov´andolo
Reloj
Implementaci´on
m´as
eficiente
oportunidad
utiliza
lista
circular
marcos
p´agina
puntero
manecilla
p´agina
m´as
antigua
funcionamiento
algoritmo
anterior.42
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
usadas
recientemente
LRU
Consiste
eliminar
agina
usado
cantidad
tiempo
variantes
algoritmos
similares
LRU
lista
enlazada
agina
as
recientemente
referenciadas
frente
actualizada
referencia
buscando
llevando
agina
correspon-
diente
frente
costoso
LRU
contador
hardware
contador
incrementa
instruc-
ci´on
autom´aticamente
valor
guardarse
campo
entrada
correspondiente
p´agina
tabla
referenciada
requerir
quitar
agina
memoria
f´ısica
eliminar´a
menor
valor
campo
mencionado
LRU
matriz
hardware
aginas
matriz
bits
filas
guarda
valor
binario
p´agina
menor
indica
m´as
tiempo
usada
referencia
p´agina
aumenta
valor
fila
aximo
colocando
bits
k-´esimo
disminuye
valor
filas
colocando
k-
esimo
bit
columna
Not
Frequently
Used
NFU
interrupci
on
reloj
suma
contador
entrada
tabla
aginas
bit
R.
problema
contadores
olvidan
principio
referenci
agina
m´as
est
valor
podr´ıa
seguir
as
alto
aginas
utiles
provocando
preferencia
quitar
p´aginas
Envejecimiento
aging
variante
NFU
lugar
sumar
desplaza
contador
bit
derecha
coloca
izquierda
As
as
recientemente
referencia
garantiza
valor
contador
contador
bits
pulsos
reloj
referencias
pasadas
an
eliminadas
evitando
problema
NFU
Conjunto
trabajo
basa
agrupaci
on
aginas
frecuente
momento
proceso
suele
peque
˜na
aginas
periodo
localidad
referencia
grupo
llama
conjunto
trabajo
Sobrepaginaci´on
thrashing
situaci´on
ocurren
fallos
p´agina
consecutivos
corto
periodo
tiempo
indeseable
lentitud
ocurre
carga
proceso
disco
solucionarse
identificando
conjunto
trabajo
carg´andolo
autom´aticamente
traer
proceso
prepaginaci´on
identificar
p´aginas
pertenecientes
conjunto
trabajo
n´umero
referencias
memoria
p´aginas
m´as
recientes
inviable
requiere
enorme
ineficiente
registro
desplazamiento
referencia
o3.6
MEMORIA
VIRTUAL
43
n´umero
milisegundos
tiempo
virtual
agina
usada
opci´on
implementar
Requiere
campo
adicional
entradas
tabla
p´aginas
almacene
tiempo
agina
referenciada
ultima
adem
as
bit
colocado
interrupci´on
reloj
ocurrir
fallo
p´agina
recorre
tabla
entrada
colocar
tiempo
ultima
referencia
tiempo
virtual
actual(almacenado
tabla
procesos
calcula
edad
tiempo
virtual
actual
tiempo
ultima
referencia
edad
menor
grupo
trabajo
reserva
tempo-
ralmente
puntero
entrada
agina
grupo
edad
actualizado
necesario
edad
est´a
grupo
trabajo
reemplazada
encontrara
agina
edad
elimina
edad
puntero
WSClock
combinaci
on
algoritmo
reloj
conjunto
trabajo
ocurrir
fallo
p´agina
comprueba
M.
Referenciada
Edad
Modificada
Asignar
Cargar
p´agina
Planificar
escritura
p´agina
recorrido
intenta
buscar
p´agina
referenciada
modificar
edad
ma-
yor
p´aginas
ideales
sacar
memoria
f´ısica
Adem´as
planifica
escritura
disco
similares
anteriores
modificadas
conmutaci
on
procesos
seguir
buscando
alternativa
recorrido
darse
situaciones
planificado
escritura
buscar
agina
ideal
quitar
memoria
f´ısica
planificadas
ser´a
escrita
disco
valdr´a
planificado
escrituras
seleccionar
agina
azar
preferentemente
sobrescribir
p´aginas
est´an
conjunto
trabajo.44
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
3.6.7
Pol
ıticas
asignaci´on
locales
globales
seg´un
busquen
marcos
p´agina
sobrescribir
ocurrir
fallo
p´agina
pol´ıticas
globales
suelen
as
convenientes
com
locales
provoquen
sobrepaginaci´on
a´un
m´ultiples
marcos
disponibles
Adem´as
conjunto
trabajo
reduce
desperdicia
memoria
forma
solucionar
problemas
repartiendo
marcos
agina
procesos
Podr´ıa
hacerse
equitativamente
forma
proporcional
tama˜no
procesos
pol´ıticas
globales
tambi´en
requiere
distribuir
marcos
p´agina
forma
conveniente
decidir
cu
ando
asignar
quitar
marcos
algoritmo
Page
Fault
Frequency(PFF
mide
proporci´on
fallos
procesos
funci´on
tiempo
identifica
encuentren
rango
algoritmo
decide
qu´e
p´agina
sustituir
fallo
algoritmos
funcionar
pol´ıtica
asignaci´on
FIFO
LRU
variantes
funcionan
local
globalmente
resto
especial
conjuntos
trabajo
WSClock
sirven
forma
local
3.6.8
Control
carga
pol´ıticas
asignaci´on
globales
ocurrir
sobrepaginaci´on
solucionar
intercambiar
procesos
llev´andolos
disco
decidir
cu
intercambiar
tama
˜no
proceso
proporci
on
p´aginas
grado
multiprogramaci
on
evitar
tiempos
ociosos
CPU
3.6.9
Tama
˜no
p´agina
factores
determinar
tama˜no
m´as
conveniente
Fragmentaci´on
interna
desperdicio
espacio
ultima
p´agina
promedio
mitad
menor
fragmentaci´on
interna
tama˜nos
p´agina
menores
Partes
utilizadas
memoria
proceso
requiere
peque
˜na
porci´on
ejecu-
tarse
tama˜no
p´agina
obliga
cargar
necesidad
Tama˜no
tabla
aginas
menor
tama
˜no
agina
tama
˜no
tabla
al-
gunas
m´aquinas
conmutaci
on
procesos
cargar
tabla
registros
hardware
conmutaci´on
tardar´a
m´as
Transferencias
disco
retraso
traer
p´agina
disco
var´ıa
seg´un
tama˜no
p´agina
cantidad
memoria
m´ultiples
p´aginas
ser´a
considerablemente
m´as
lento
3.6.10
Espacios
separados
instrucciones
datos
arquitecturas
definen
espacios
direcciones
independientes
instrucciones
datos
paginada
tabla
p´aginas.3.6
MEMORIA
VIRTUAL
45
3.6.11
Compartici
on
Compartir
aginas
instrucciones
programa
suele
suponer
complicaciones
lectura
necesita
aplicar
exclusi´on
mutua
compartir
p´aginas
datos
deber´ıa
hacerse
instrucciones
lectura
momento
intente
modificar
emite
TRAP
ordena
sistema
operativo
copiar
p´agina
correspondiente
asignarle
original
copia
permiso
escritura
bits
protecci´on
entradas
tabla
p´aginas
llama
copiar
escritura
Ambas
posibles
comparticiones
simplifican
espacios
instrucciones
datos
requiere
punteros
BCP
tabla
procesos
tabla
p´aginas
Similar
instrucciones
programa
bibliotecas
compartidas
Dynamically
Linked
Library
Biblioteca
Enlaces
Din´amicoss
DLLs
ventajas
Menor
tama˜no
ejecutables
cargan
programas
est´en
usando
Actualizaci´on
autom
atica
necesario
recompilar
programas
bibliotecas
actualizadas
programa
ve
bibliotecas
compartidas
encontraran
espacio
memoria
direccionamiento
absoluto
omo
sabr´ıa
biblioteca
direcci
on
qu´e
programa
refiere
instrucci´on
utilizar
c´odigo
independiente
posici´on
direccionamiento
relativo
JUMP
lugares
bibliotecas
compartidas
implementan
archivos
asociados
memoria
archivos
accedidos
fueran
memoria
virtual
proceso
solicitando
sistema
operativo
llamada
sistema
Adem
as
archivos
asociados
permiten
obtener
canal
comunicaci´on
ancho
banda
procesos
3.6.12
Pol
ıtica
limpieza
com
existencia
demonio
paginaci
on
peri
odicamente
copie
aginas
disco
colocando
fallo
agina
deba
movimiento
urgencia
Adem´as
desalojar
p´aginas
acelerar
b´usqueda
marcos
p´agina
libres
fallos
p´agina
3.6.13
Interfaz
memoria
virtual
B´asicamente
procesos
programadores
ven
espacio
direcciones
virtuales
gran-
computadora
memoria
f´ısica
m´as
peque˜na
sistemas
proporcionan
control
mapa
memoria
posibilita
archivos
asociados
sistemas
mensajes
veloces
requieren
copiados
memoria
compartida
distribuida
distintas
m´aquinas
envi´andose
p´aginas).46
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
3.6.14
Participaci
on
sistema
operativo
paginaci´on
crear
proceso
crear
inicializar
tabla
aginas
asign
andole
memoria
Tambi
asignar
espacio
area
intercambio
disco
guardan
aginas
cargadas
guardar
informaci´on
tabla
p´aginas
area
intercambio
tabla
procesos
ejecutar
proceso
establecer
MMU
vaciar
TLB
deshacerse
aginas
proceso
tambi´en
actualizarse
tabla
p´aginas
hacerse
prepaginaci´on
ocurrir
fallo
p´agina
Determinar
direcci
on
virtual
produjo
fallo
leyendo
registros
hardware
Determinar
agina
necesaria
localizarla
disco
Buscar
marco
agina
liberarlo
necesario
copiando
contenido
agina
disco
modificada
Copiar
agina
necesaria
marco
p´agina
Restaurar
registro
contador
programa
PC
terminar
proceso
liberar
tabla
aginas
espacio
aginas
ocupan
est
an
disco
est´en
compartidas
3.6.15
Manejo
fallos
agina
hardware
guarda
PC
pila
com´unmente
informaci´on
instrucci´on
actual
registros
especiales
CPU
TRAP
kernel
rutina
guarda
registros
generales
informaci
on
vol´atil
Llama
sistema
operativo
sistema
operativo
determina
agina
necesaria
registro
especial
analizando
software
instrucci´on
produjo
fallo
sistema
operativo
comprueba
direcci
on
alida
viola
protecci
on
envi´andole
˜nal
proceso
elimin
andolo
as
sistema
selecciona
marco
p´agina
buscando
disponible
ejecutando
algoritmo
reemplazo
p´aginas
marco
est
sucio
planifica
transferencia
agina
contiene
disco
realiza
conmutaci
on
contexto
dejando
procesos
ejecuten
marca
ocupado
marco
p´agina.3.6
MEMORIA
VIRTUAL
47
marco
agina
est
limpio
sistema
operativo
busca
agina
necesaria
disco
planifica
transferencia
marco
agina
memoria
f´ısica
deja
procesos
ejecutarse
ocurre
disco
emite
interrupci
on
terminarse
transferencia
sistema
operativo
actualiza
tablas
p´agina
marca
normal
marco
p´agina
respalda
instrucci
on
fallida
restablece
PC
planifica
proceso
fallido
sistema
operativo
regresa
control
rutina
llam
o.
10
rutina
recarga
registros
dem
as
informaci´on
regresando
espacio
usuario
seguir
ejecuci´on
3.6.16
Respaldo
instrucci
on
fallida
Instrucciones
m´ultiples
referencias
memoria
as´ı
instrucciones
ocupan
m´ultiples
palabras
aumentando
contador
programa
medida
ejecutan
ocurrir
fallo
agina
basta
guardar
PC
actual
tambi
guardar
PC
inician
instrucciones
solucionarlo
dise˜nadores
CPUs
agregando
registro
interno
oculto
Instrucciones
autoincremento
autodecremento
Seg´un
microinstrucciones
instrucci´on
incrementar
decrementar
m´as
registros
despu
potencial
fallo
agina
ocurren
ning
problema
previos
fallo
deshacer
cambios
hayan
continuar
ejecuci´on
traer
agina
memoria
Tambi
solucionarse
registros
indiquen
cu´ales
registros
incrementados
cu´anto
3.6.17
reemplazo
aginas
proceso
inicia
transferencia
DMA
conmuta
proceso
fallo
agina
decida
mover
agina
encargada
recibir
datos
transferencia
disco
datos
an
escritos
agina
correspondiente
resto
quedar´an
p´agina
ocupa
marco
solucionarse
bloqueo
p´aginas
memoria
fijaci´on
evitar
eliminada
opci´on
forzar
transferencias
realicen
b´ufers
n´ucleo
copie
datos
p´agina
correspondiente
3.6.18
Almac
respaldo
refiere
forma
p´aginas
almacenan
disco
partici´on
intercambio
especial
disco
disco
separado
sistema
operativo
partici´on
disco
separado
administra
lista
trozos
libres
comenzar
ejecutarse
proceso
inicializar
area
intercambio
sea:48
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
Copiando
imagen
proceso
area
intercambio
llevarse
memoria
necesario
aqu
util
designar
areas
separadas
texto
datos
pila
tama˜no
ultimos
cambia
tambi´en
realizarse
optimizaci´on
designa
area
texto
archivo
ejecutable
cambia
direcciones
inicio
areas
intercambio
guardan
BCP
proceso
Cargando
proceso
memoria
dejando
pagine
afuera
escribi´endose
disco
intercambios
Adem
as
posibilidad
ahorrar
espacio
area
inter-
cambio
tambi
liberan
aginas
disco
escribirlas
memoria
principal
desventajas
aprovecha
bit
falta
tabla
proceso
alma-
cene
ubicaci´on
p´agina
disco
3.6.19
Pol
ıtica
mecanismo
organizaci
on
m´as
modular
odigo
dividir
espacios
ucleo
usuario
mecanismo
implementado
ucleo
manejador
fallos
pol´ıtica
proceso
usuario
paginador
externo
fallos
p´agina
administrados
forma
indicada
gr´afico
complicaci´on
decidir
d´onde
ejecuta
algoritmo
reemplazo
p´aginas
paginador
externo
acceso
bits
probablemente
haga
falta
pasarlos
forma
algoritmo
estuviera
aqu´ı
manejador
fallos
indicar
paginador
externo
p´agina
desalojar
interact´ua
disco
separar
pol
ıtica
mecanismo
obtiene
odigo
modular
as
flexible
eficiente
sistema
requerir
m´as
cambios
modo.3.7
SEGMENTACI´ON
49
3.7
Segmentaci
on
Tanenbaum
2009
234-247
Consiste
dividir
memoria
ısica
virtual
partes
llamadas
segmentos
espacios
direcciones
independientes
ventajas
Facilitar
expansi´on
compresi´on
partes
proceso
afectar
Optimiza
compilaci
on
segmento
espacio
direcciones
actualizaci´on
requiere
recompilar
resto
util
bibliotecas
compartidas
Permitir
establecimiento
protecciones
distintos
segmentos
evitando
ejemplo
escriba
segmento
texto
ejecute
segmento
arreglo
pila
gracias
diferencia
paginaci
on
segmentaci
on
manipu-
lada
programadores
segmentos
unidades
ogicas
programador
est
consciente
3.7.1
Segmentaci
on
pura
memoria
divide
segmentos
distintos
tama˜nos
reemplazados
conforme
pasa
tiempo
evitar
fragmentaci´on
externa
divisi´on
memoria
trozos
ocupados
compactar
peri´odicamente
memoria
intercam-
bio
procesos
3.7.2
Segmentaci
on
paginaci´on
Consiste
dividir
memoria
segmentos
segmentos
aginas
direc-
ciones
selectores
consistir
partes
umero
segmento
umero
agina
desplazamiento
p´agina
consecuencia
proceso
tabla
segmentos
cuyas
entradas
denominan
descriptores
segmento
descriptor
segmento
puntero
tabla
p´aginas
imagen
describe
conversi´on
direcci´on
sistema
operativo
MULTICS
direcci´on
memoria
principal
50
CAP´ITULO
ADMINISTRACI´ON
MEMORIA
organizaci
on
requiere
complejidad
TLB
adem
as
agina
almacenar
segmento
sistema
operativo
MULTICS
TLB
a´un
m´as
complejo
soporta
m´as
tama˜no
p´agina
sistemas
Intel
Pentium
adem
as
tabla
segmentos
proceso
LDT
Local
Descriptor
Table
tabla
segmentos
global
GDT
Global
Descriptor
table
almacena
segmentos
sistema
Intel
Pentium
tambi
soporta
desactivar
segmentaci
on
paginaci´on
protecci´on
suele
implementarse
segmento
MULTICS
Intel
Pentium
nive-
programa
segmento
nivel
acceder
segmentos
niveles
menores
excepci´on
instrucci´on
CALL
utiliza
selector
identificar
descriptor
llamado
compuerta
llamada
contiene
direcci
on
procedimiento
nivel
inferior
evitar
saltos
direcciones
arbitrarias
LosTRAPs
interrupciones
funcionan
an´alogamen-
Cap´ıtulo
Archivos
4.1
Almacenamiento
informaci
on
plazo
Tanenbaum
2009
p.
255-256
requerimientos
considerar
almacenamiento
informaci
on
plazo
capacidad
informaci´on
Persistencia
informaci´on
terminaci´on
procesos
utilicen
acceso
concurrente
m´ultiples
procesos
almacenamiento
refiere
memoria
secundaria
suele
involucrar
discos
organizados
linealmente
bloques
datos
tama
˜no
fijo
operaciones
leer
escribir
bloque
ındice
sistema
operativo
crea
interfaz
as
conveniente
procesos
usuario
puedan
manejar
almacenamiento
plazo
sistema
archivos
archivo
unidad
l´ogica
informaci´on
creada
proceso
archivos
nombres
sistemas
operativos
determinan
qu
caracteres
conte-
ner
nombres
nombres
suelen
separarse
as
partes
dependiendo
sistema
operativo
significado
usuario
divisi´on
com´un
nom-
bre.extensi´on
4.2
Estructuras
archivos
Tanenbaum
2009
p.
259-260
5152
CAP´ITULO
ARCHIVOS
tipos
estructura
interna
archivo
4.2.1
Secuencia
bytes
estructura
tipo
m´as
flexible
4.2.2
Secuencia
registros
M´ultiples
registros
tama˜no
fijo
accedidos
ındice
4.2.3
Arbol
registros
registro
tama
˜no
variable
llave
proporcionada
acceder
tambi´en
accederse
registros
secuencialmente
4.3
Tipos
archivos
Tanenbaum
2009
p.
260-262
4.3.1
Regulares
Archivos
regulares
Contienen
informaci´on
usuario
ASCII
texto
mostrados
est
an
editados
impresos
sencillez
Adem´as
facilitan
canalizaci
on
programas
programa
entrada
salida
distintas
convenciones
c´omo
deber´ıa
terminar
l´ınea
avance
l´ınea
line
feed
LF
retorno
carro
carriage
return
CR
CRLF
Binario
texto
Suelen
estructura
interna
usados
programas
espec´ıficos
contenido
podr
mostrarse
directamente
archivos
ASCII
sistemas
operativos
suelen
reconocer
tipo
ejecutables.4.4
ACCESO
ARCHIVOS
53
Directorios
regulares
Sistemas
archivos
permiten
mantener
estructura
4.3.2
Especiales
prop´osito
particular
transparente
usuario
ejemplos
podr´ıan
UNIX
caracteres
modelar
dispositivos
serie
bloques
modelar
discos
4.4
Acceso
archivos
Tanenbaum
2009
p.
262
refiere
lectura
datos
secuencial
acceso
aleatorio
indicando
posici
on
Com
unmente
combinaci
on
ambas
operaciones
seek
colocar
posici´on
comenzar´a
leer
read
leer
4.5
Atributos
archivos
Tanenbaum
2009
p.
263-264
atributos
metadatos
campos
informaci
on
adicional
acerca
archivo
guardan
sistemas
operativos
aspectos
suelen
relacionarse
atributos
protecci´on
creador
propie-
tario
tama˜no
registro
tama
˜no
llave
posici
on
llaves
horas
creaci
on
ultimos
acceso
modificaci´on
tama˜nos
actual
m´aximo
4.6
Operaciones
archivos
Tanenbaum
2009
p.
264-265
T´ıpicamente
Create
datos
avisa
creaci´on
establece
atributos
Delete
liberar
espacio
disco
Open
trae
archivo
disco
memoria
principal
Close
escribe
bloque
archivo
memoria
principal
disco
bloques
ante-
riores
hab´ıan
escritos
Read
lee
datos
archivo
ufer
posici
on
actual
indicar
cantidad
datos
le´ıda
Write
escribe
datos
archivo
posici´on
actual
archivo
sobrescribe
contenido
aumenta
tama˜no
archivo
Append
Write
escribe
Seek
coloca
apuntador
archivo
posici´on
especificada54
CAP´ITULO
ARCHIVOS
Get
attributes
devuelve
valor
atributos
Set
attributes
establece
valor
atributos
Rename
cambia
nombre
archivo
4.7
Sistemas
directorios
Tanenbaum
2009
p.
268-272
4.7.1
Sistemas
directorios
nivel
archivos
encuentran
un´unico
directorio
util
unicamente
sistemas
simples
4.7.2
Sistemas
directorios
jer
arquicos
arbol
directorios
directorios
considerados
archivos
siste-
ma
directorio
contener
directorios
archivos
sistemas
requieren
nombres
rutapara
ubicar
archivos
directorios
nombres
ruta
consisten
secuencia
nombres
directorios
separadas
caracter
especial
sistema
operativo
establece
Windows
UNIX
MULTICS
nombre
archivo
regular
tipos
nombres
ruta
Absolutas
comienzan
caracter
especial
comenzar
b´usqueda
directorio
ra´ız
Relativas
comienzan
caracter
especial
buscan
directorio
trabajo
Adem´as
sistemas
operativos
proveen
entradas
especiales
usadas
lugar
nombres
directorios
archivos
referencia
directorio
trabajo
referencia
directorio
padre
directorio
trabajo
excepci
on
ra
ız
referencia
s´ı
4.8
Operaciones
directorios
Tanenbaum
2009
p.
272-273
283-285
operaciones
comunes
Create
crea
directorio
vac´ıo
Delete
elimina
directorio
est´e
vac´ıo
contiene
Opendir
abre
directorio
leer
contenido
Closedir
cierra
directorio
liberar
espacio
Readdir
devuelve
entrada
directorio
abierto4.9
DISTRIBUCI
ON
SISTEMA
ARCHIVOS
55
Rename
cambia
nombre
directorio
operaci´on
archivos
Link
vincula
v´ınculo
liga
dura
archivo
directorio
vinculaci
on
permite
archivo
aparezca
ultiples
directorios
ultiples
rutas
usado
UNIX
Nodos-I
Unlink
desvincula
archivo
directorio
eliminando
entrada
unica
referencia
archivo
tambi´en
elimina
definitivamente
tambi´en
v´ınculos
ligas
simb
olicos
archivo
apunta
modificar
archivo
apuntado
buscar
ruta
leerlo
buscar
ruta
conten´ıa
eficiente
v´ınculo
duro
diferencia
nombrar
archivos
computadoras
remotas
4.9
Distribuci
on
sistema
archivos
Tanenbaum
2009
p.
273-274
discos
dividen
particiones
partici´on
correspondiendo
sistema
archivos
sistema
operativo
sector
disco
Registro
Maestro
Arranque
MBR
Master
Boot
Record
halla
tabla
particiones
proporciona
informaci
on
inicio
marca
partici´on
activa
partici´on
divide
bloques
distribuci´on
var´ıa
sistema
ar-
chivos
suelen
bloques
com´un
ning´un
orden
particular
excepci´on
bloque
arranque
Bloque
arranque
contiene
programa
carga
sistema
operativo
contenido
par-
tici´on
arrancar
aquina
carga
ejecuta
bloque
arranque
partici
on
activa
est´a
Superbloque
contiene
par´ametros
clave
sistema
archivos
lee
memoria
arranque
sistema
operativo
interacci´on
sistema
archivos
Administraci´on
espacio
libre
mapa
bits
lista
enlazada
manejar
bloques
libres
Nodos-I
arreglo
estructuras
datos
informaci´on
archivos
Directorio
ra´ız
archivos
directorios56
CAP´ITULO
ARCHIVOS
4.10
Implementaci
on
archivos
Tanenbaum
2009
p.
274-280
321-323
refiere
forma
organizan
archivos
espacio
destinado
disco
4.10.1
Asignaci
on
contigua
dividir
disco
bloques
tama
˜no
colocar
archivo
ocupando
cantidad
bloques
archivo
asociar
umeros
bloque
inicio
cantidad
bloques
ocupa
asignar
bloques
indivisibles
implica
quedar´a
utilizar
fragmentaci´on
interna
m´etodo
sencillo
implementar
eficiente
bloques
archivo
encuentran
juntos
falta
operaci´on
b´usqueda
acarrea
problema
fragmentaci´on
externa
fragmentaci
on
externa
ocurre
eliminan
archivos
quedan
bloques
libres
ocupados
implica
elegir
forma
agregar
archivos
buscando
huecos
libres
requiere
tama˜no
m´aximo
archivo
solucionar
fragmentaci´on
externa
recurrir
compactaci´on
disco
proceso
caro
asignaci
on
contigua
ideal
almacenamiento
permanente
ROM
eliminarse
archivos
produce
fragmentaci´on
externa
4.10.2
Asignaci
on
lista
enlazada
archivo
consiste
conjunto
bloques
bloque
contiene
palabra
reservada
comienzo
almacena
puntero
bloque
soluciona
fragmentaci
on
externa
usqueda
lenta
puesto
llegar
bloque
requiere
le´ıdo
anteriores
peque˜na
desventaja
bloque
tendr´a
tama˜no
utilizable
distinto
potencia
ralentizar
operaciones
lectura
programa
cree
ocupar
tama
˜no
real
disponible
bloque
implicar
ıa
escritura
bloques).4.11
IMPLEMENTACI´ON
DIRECTORIOS
57
4.10.3
Asignaci
on
lista
enlazada
FAT
Utiliza
principio
lista
enlazada
normal
almacenando
punteros
tabla
FAT
File
Allocation
Table
Tabla
Asignaci´on
Memoria
memoria
principal
m´etodo
acelera
b´usqueda
recorrer
lista
llegar
bloque
punteros
encuentran
memoria
principal
Adem
as
ogicamente
tama
˜no
disponible
bloque
tama˜no
real
necesita
guardar
puntero
acarrea
desventaja
significativa
cantidad
bloques
requiere
tabla
mantenerse
cargada
memoria
principal
tiempo
4.10.4
Nodos-I
Consiste
estructura
datos
relacionada
archivo
particular
Nodos-I
nodos
ındice
guardan
disco
cargan
memoria
abre
archivo
suele
umero
aximo
archivos
abiertos
simult
aneamente
n´umero
m´aximo
Nodos-I
memoria
espacio
deber
reservarse
memoria
independiente
tama
˜no
disco
cantidad
bloques
diferencia
lista
enlazada
FAT
suele
m´as
peque˜no
Nodo-I
contiene
atributos
archivo
apuntadores
bloques
contenido
apuntador
bloque
as
apuntadores
contenido
archivo
requiriera
m´as
espacio
Tambi´en
cu
antas
referencias
archivo
eliminado
eliminar
ultima
referencia
forma
suelen
Nodos-I
suele
Atributos
10
apuntadores
directos
bloques
archivo
apuntador
indirecto
simple
bloque
apuntadores
bloques
archivo
apuntador
indirecto
doble
bloque
apuntadores
bloques
apuntadores
bloques
archivo
apuntador
indirecto
triple
similar
anteriores
capas
4.11
Implementaci
on
directorios
Tanenbaum
2009
p.
280-282
4.11.1
Acceso
archivos
atributos
directorio
almacenar
nombres
archivos
contiene
posibilitar
acceder
archivo
atributos.58
CAP´ITULO
ARCHIVOS
Implementaci´on
Archivos
Acceso
archivos
Ubicaci
on
atri-
butos
Continua
Direcci
on
disco
archivo
entrada
di-
rectorio
Lista
enlazada
umero
bloque
inicial
entrada
di-
rectorio
FAT
umero
bloque
inicial
entrada
di-
rectorio
Nodos-I
umero
Nodo-I
Nodo-I
4.11.2
Tama
˜no
nombres
longitud
Fija
obliga
nombres
ocupen
espacio
conlleva
desperdicio
considerable
permiten
nombres
largos
Variable
entrada
requiere
almacenar
longitud
entrada
inicio
seguida
campos
necesarios
acceso
contenido
archivo
atributos
nombre
archivo
Implica
entradas
tama
˜no
variable
produciendo
fragmentaci
on
externa
costosa
compactar
memoria
principal
heap
almacena
puntero
direcci
on
heap
directorio
prop´osito
espec´ıfico
guardar
nombres
4.11.3
Aceleraci
on
b´usqueda
formas
organizar
entradas
nombres
mencionadas
requieren
b´usqueda
lineal
leyendo
entrada
entrada
encontrar
cuyo
nombre
coincida
buscado
lento
directorios
archivos
acelerar
usqueda
crearse
tabla
hash
procesa
nombre
archivo
devuelve
c´odigo
hash
entradas
c´odigo
colocan
lista
enlazada
reduciendo
b´usqueda
lectura
fracci´on
entradas
alternativa
implementaci
on
cach
unicamente
util
archivos
accede
suelen
4.12
Sistemas
archivos
alternativos
Tanenbaum
2009
p.
285-291
4.12.1
Estructurados
registro
LFS
Dada
lenta
mejora
velocidad
discos
comparada
evoluci
on
medios
almacenamiento
hardware
general
dise˜nado
sistema
archivos
busca
m´as
eficiente
LFS
Log-structured
File
System
Sistema
archivos
estructurado
registro
basa
disco
aumenta
velocidad
ritmo
suficientemente
apido
cach´es
disco4.12
SISTEMAS
ARCHIVOS
ALTERNATIVOS
59
s´ı
ıa
operaciones
lectura
requieren
acceso
disco
representan
problema
inconveniente
cantidad
escrituras
peque
˜nas
necesitan
LFS
utiliza
ufer
memoria
realizan
escrituras
tiempo
hilo
escritor
realiza
escritura
disco
segmento
disco
registro
utilizan
Nodos-I
escrituras
ocurrir
an
tenerlos
fija
memoria
reducir
ıa
medida
efectividad
sistema
archivos
lugar
mantiene
tabla
cach´e
relaciona
entrada
nodo
apuntando
est´e
disco
Adem´as
LFS
requiere
hilo
limpiador
recorra
registro
compactarlo
implica
Verificar
Nodos-I
contiene
sobrescritos
tabla
apuntadores
apunta
Verificar
bloques
contiene
a´un
est´an
Nodos-I
apuntan
Escribir
nodos
bloques
est´en
ufer
memoria
escritos
segmento
Liberar
segmento
s´ıntesis
disco
estructura
ufer
circular
disco
escritor
llena
hilo
limpiador
vac´ıa
4.12.2
bit
acora
JFS
JFS
Journaling
File
System
Sistema
archivos
bit
acora
buscan
forma
robusta
salvar
posibles
fallas
proceso
requiere
m´ultiples
escrituras
logra
creando
entrada
registro
disco
operaciones
ejecutarlas
borrando
entrada
finalizar
forma
ocurre
fallo
aquina
reinicia
har
sistema
operativo
buscar
entradas
acciones
listadas
importante
acciones
idempotentes
puedan
rea-
lizarse
m´ultiples
ning´un
peligro
acciones
idempotentes
suelen
convertirse
tipo
cambios
Adem´as
conveniente
acciones
realicen
transacci´on
at
omica
au-
mentar
confiabilidad
garantizar
acci´on
quedar´a
ejemplos
JFS
NTFS
Windows
ReiserFS
ext3
Linux
4.12.3
Virtuales
VFS
sistema
operativo
suele
capaz
manejar
m´as
sistema
archivos
simult´aneamente
Windows
logra
asign
andole
sistema
letra
unidad
sistemas
UNIX
unifican
montura
VFS
Virtual
File
System
Sistema
archivos
virtual
VFS
intervienen
interfaces
procesos
usuario
POSIX
sistemas
archivos
Ambas
consisten
llamadas
llamadas
POSIX
funciones
definidas
VFS
implementadas
sistema
archivos.60
CAP´ITULO
ARCHIVOS
VFS
define
objetos
Superbloque
sistema
archivos
Directorio
directorio
sistema
archivos
Nodo-V
archivo
objeto
llamadas
montarse
sistema
archivos
arranque
registrar
VFS
provey´endole
llamadas
necesita
unico
vector
objeto
operaci´on
lectura
requiere
identificar
accede
sistema
montado
as´ı
Identificar
superbloque
correspondiente
sistema
archivos
Identificar
directorio
ra
ız
superbloque
seguir
ruta
especificada
Crear
Nodo-V
llamada
sistema
archivos
copie
informaci
on
Nodo-I
correspondiente
informaci´on
puntero
vector
funciones
Crear
entrada
tabla
descriptores
archivos
file
descriptors
apunte
Nodo-V
As´ı
utilizando
descriptor
archivo
acceder
archivo
correspondiente
importar
qu´e
dispositivo
encuentre
4.13
Administraci
on
espacio
disco
Tanenbaum
2009
p.
292-298
4.13.1
Modos
archivo
ocupar
bytes
consecutivos
bloques
necesariamente
contiguos
m´as
veloz
b´usqueda
inaceptablemente
lento
movido
sector
disco
provoca
fragmentaci´on
externa
suele
bloques
tama˜no
fijo
4.13.2
Tama
˜no
bloque
tama
˜no
bloque
implica
desperdicio
espacio
fragmentaci
on
interna
peque˜no
implica
rendimiento
archivos
m´as
tama˜no
bloque
requieren
m´as
b´usquedas
espacio
disco
aumenta
m´as
r´apido
velocidad
suele
favorecerse
tama˜no
bloque
m´as
4.13.3
Bloques
libres
necesario
sistema
operativo
capaz
identificar
bloques
disponibles
ocupados
crearse
archivos
agrandarse
existentes
hacerse
formas:4.13
ADMINISTRACI
ON
ESPACIO
DISCO
61
Lista
enlazada
utilizan
bloques
guardar
punteros
bloques
libres
reservan
palabra
guardar
puntero
bloque
punteros
bloques
libres
m´etodo
ocupa
memoria
bloque
libre
requerir´a
bits
apunten
est´a
disco
2n
tama˜no
lista
cambia
din´amicamente
disminuyera
cantidad
bloques
libres
tambi
disminuir´ıa
cantidad
bloques
ocupados
lista
liber´andolos
sistema
operativo
acceso
informaci
on
bloques
libres
m´etodo
mantener
momento
bloque
punteros
memoria
principal
agrandar
crear
archivo
podr´a
saberse
qu´e
bloques
ocupados
achicar
eliminar
archivo
podr´a
marcarse
bloques
correspondientes
libres
requiriera
m´as
bloques
libres
apuntados
bloque
punteros
memoria
traer
disco
opuesto
pasa
liberado
as
bloques
apuntados
bloque
actualmente
cargado
memoria
intercambia
bloque
punteros
disco
conveniente
mover
bloque
as´ı
evita
posibilidad
produzcan
operaciones
intercambio
bloques
Caso
contrario
moverse
bloques
completos
Teniendo
bloque
punteros
llenos
liberarse
as
bloques
bloque
actual
disco
traer
vac´ıo
Teniendo
bloque
punteros
vac
ıo
ocuparse
bloques
traer
bloque
lleno
disco
Est´a
posibilidad
estando
cualquiera
situaciones
comience
liberarse
ocuparse
disco
intercaladamente
ralentizando
sistema
Lista
enlazadas
bloques
consecutivos
variaci
on
listas
enlazadas
lugar
guardar
puntero
bloque
libre
guarda
puntero
n´umero
permiten
identificar
secuencia
bloques
libres
puntero
apuntando
bloque
n´umero
guardando
cantidad
bloques
libres
Mapa
bits
corresponder
forma
secuencial
bit
bloque
disco
est
ocupado
est´a
libre
viceversa
Ocupa
espacio
lista
enlazada
general
espacio
ocupado
disco
tama
˜no
fijo
colocarse
memoria
virtual
paginado
necesario
Adem
as
est
ordenado
encontrar
bloques
libres
requiere
usquedas
bloques
cercanos
disco
aumentando
rendimiento.62
CAP´ITULO
ARCHIVOS
4.13.4
Cuotas
disco
sistemas
operativos
multiusuario
suelen
limitar
espacio
disco
ocupar
usuarios
logra
asignando
cuota
usuario
guardan
tabla
cuotas
archivo
est
abierto
entrada
tabla
archivos
abiertos
almacena
UID
propietario
archivo
puntero
entrada
tabla
cuotas
forma
aumento
disminuci
on
cantidad
bloques
archivos
correspondan
usuario
quedan
registrados
tabla
cuotas
almacena
tambi´en
bloques
archivos
l´ımite
suave
sobrepasado
n´umero
advertencias
pendientes
disminuye
inicia
sesi
on
sobrepasado
l´ımite
suave
impide
ingreso
usuario
agota
n´umero
advertencias
ignorarlo
l´ımite
duro
sobrepasado
4.14
Respaldo
sistema
archivos
Tanenbaum
2009
p.
298-304
Vaciar
refiere
copia
seguridad
disco
Completo
archivos
Incremental
archivos
sufrido
modificaciones
respaldo
Tambi´en
vaciados
F´ısicos
programa
simple
respalda
disco
completo
orden
r´apido
desaprovecha
espacio
L´ogicos
comienzan
directorio
respaldan
contenidos
forma
recursiva
incremental
caso
vaciado
ogico
incremental
respaldar
directorios
contengan
archivos
directorios
modificados
hayan
modificados
respaldar
archivos
modificados
as
recuperaci
on
arme
estructura
directorios
sistema
archivos
comenzar
colocar
contenidos
cuestiones
relacionadas
vaciados
ogicos
incrementales
seg-
mentos
huecos
programas
v´ınculos
archivos
especiales
canales
4.15
Consistencia
sistema
archivos
Tanenbaum
2009
p.
304-307
sistemas
operativos
suelen
proveer
programas
verifican
consistencia
sistema
archivos
ultiples
aspectos
verificados
corregidos
autom´aticamente
verificaciones
comunes
son:4.16
RENDIMIENTO
SISTEMA
ARCHIVOS
63
Archivos
tablas
contadores
bloques
ocupados
archivos
bloques
libres
analiza
bloque
est´e
ocupado
archivo
aparezca
lista
enlazada
mapa
bits
bloques
libres
as
darse
situaciones
bloque
aparece
ocupado
libre
coloca
libre
bloque
aparece
libre
lista
enlazada
unicamente
elimina
punteros
lista
bloque
aparece
ocupado
copiar
contenidos
bloque
libre
asignar
bloque
archivos
dejen
compartirlo
Directorios
construye
tabla
contadores
archivos
Comienza
analizando
di-
rectorio
ra´ız
terminar
verifica
cantidad
aparece
archivo
coincida
indicada
Nodo-I.
as
modificarse
valor
almacenado
Nodo-I.
4.16
Rendimiento
sistema
archivos
Tanenbaum
2009
p.
307-312
4.16.1
Cach
cach
colecci
on
bloques
pertenece
disco
mantienen
memoria
mejorar
rendimiento
administrar
algoritmos
reemplazo
agina
problemas
probable
bloque
utilice
vuelta
bloque
esencial
consistencia
sistema
archivos
As´ı
organizan
bloques
lista
enlazada
decidir
cu
ales
bloques
deber´ıan
escritos
inmediatamente
disco
cu´ales
esperar
est´e
escribiendo
bloque
frecuencia
requiere
escrituras
disco
perder
trabajo
m´as
all´a
diga
lista
enlazada
solucionado
llamada
sistema
sync
ejecutada
programa
llamado
update
tiempo
30
segundos
UNIX
forma
as
confiable
veloz
escrituras
disco
cach
escritura
inmediata
Actualmente
dejado
4.16.2
Lectura
adelantada
bloque
Consiste
bloque
archivo
cach´e
solicitado
beneficioso
archivos
acceso
secuencial
sistema
operativo
podr´ıa
registro
forma
accedido
archivo
recientemente
secuencial
aleatoria.64
CAP´ITULO
ARCHIVOS
4.16.3
Reducci
on
movimiento
brazo
disco
lograr
maneras
colocando
bloques
pertenecientes
archivo
sectores
cercanos
sencillo
administran
bloques
libres
mapa
bits
forma
disminuyendo
distancia
promedio
Nodos-I
archivos
colocan
Nodos-I
disco
tiempo
usqueda
promedio
mitad
estuvieran
inicio
4.16.4
Desfragmentaci
on
disco
algoritmo
programa
llamado
desfragmentador
consiste
mover
blo-
ques
partici´on
pertenecientes
archivo
queden
contiguos
as´ı
mejorar
rendimiento
Cap´ıtulo
Entradas
Salidas
5.1
Tipos
dispositivos
Entrada
Salida
Tanenbaum
2009
p.
330
bloque
organizan
bloques
memoria
buscados
caracter
maneja
flujo
caracteres
5.2
Comunicaci
on
dispositivos
Entrada
Salida
Tanen-
baum
2009
p.
331-332
unidad
consiste
dispositivo
controlador
dispositivo
adaptador
encarga
proveer
interfaz
sistema
operativo
manejar
dispositivos
corres-
pondientes
interfaz
controladora
dispositivo
suele
acomodarse
alg
est´andar
Suele
nivel
comunicaci
on
realiz´andose
flujo
serial
bits
precedido
pre´ambulo
sucedido
ECC
Error
Correction
Code
C´odigo
Correci´on
Errores
suma
comprobaci´on
recibir
flujo
bits
controladora
ensambla
registro
interno
verifica
errores
usando
ECC
5.3
Entradas
Salidas
puertos
asignaci
on
me-
moria
Tanenbaum
2009
p.
332-336
controladores
registros
control
ufers
datos
permiten
sistema
operativo
ordenes
dispositivos
informaci
on
acerca
transmitirles
recibir
informa-
ci´on
registros
control
b´ufers
implementarse
maneras
puertos
asign´andole
registro
control
umero
puerto
proveyendo
instrucciones
especiales
IN
OUT
manipularlos
6566
CAP´ITULO
ENTRADAS
SALIDAS
asignaci
on
memoria
escribiendo
contenido
registros
control
ufers
datos
memoria
implementaci´on
asignaci´on
memoria
ventajas
requerir
instruccio-
nes
especiales
facilitando
programaci
on
nivel
permite
instrucciones
manipulaci´on
memoria
registros
control
moverlos
imple-
mentarse
protecci´on
simplemente
colocando
memoria
contiene
registros
b´ufers
espacio
direcciones
virtuales
usuario
m´etodo
tambi´en
requiere
solucionar
problemas
Problema
cach
registros
control
colocaran
cach
controladora
actualizara
memoria
principal
cambio
ıa
reflejado
cach
e.
soluci´on
implementaci´on
cach´e
selectiva
hardware
manejada
sistema
operativo
Problema
an´alisis
direcciones
actualiza
registro
control
controladora
correspondiente
consecuencia
registros
est´an
memoria
unica
forma
controladoras
sepan
analizando
referencia
memoria
haga
soluciones
posibles
Enviar
referencias
memoria
memoria
responde
mandarla
buses
Colocar
dispositivo
husmeador
pase
direcciones
bus
memoria
dispositivos
inconveniente
llegar
m´as
lentos
Filtrar
direcciones
chip
puente
PCI
cargando
rango
memoria
inicio
sistema
hallan
registros
control
ufers
datos
direc-
ciones
encuentren
rango
enviadas
bus
PCI
lugar
memoria
5.4
Acceso
Directo
Memoria
DMA
Tanenbaum
2009
p.
336-339
chip
DMA
Direct
Memory
Access
permite
operaciones
depender
CPU
nombre
indica
accede
directamente
memoria.5.5
INTERRUPCIONES
67
Inicialmente
CPU
programa
DMA
sepa
qu
transferir
onde
chip
maneja
controlador
dispositivo
correspondiente
concretar
transferencia
finaliza
provocando
interrupci´on
CPU
DMA
bus
tiempo
aqu´ı
surgen
mecanismos
Robo
ciclo
controlador
DMA
solicita
transferencia
palabra
obtiene
forzando
CPU
esperar
tambi´en
quisiera
bus
r´afaga
realiza
transferencia
m´ultiples
palabras
consecutivo
mecanismos
utilizar
DMA
seg´un
recorrido
datos
transferir
fly-by
controlador
dispositivo
transfiere
directamente
memoria
principal
chip
DMA
controlador
dispositivo
transifere
DMA
memoria
mecanismo
m´as
flexible
m´as
costoso
5.5
Interrupciones
Tanenbaum
2009
p.
139-343
interrupciones
emitidas
controlador
interrupciones
recibir
˜nales
emitidas
dispositivos
indicando
finalizaron
CPU
reconoce
interrupci
on
est´a
lista
procesar
otra.68
CAP´ITULO
ENTRADAS
SALIDAS
provocar
interrupci´on
controlador
interrupciones
coloca
umero
l´ıneas
direcci´on
IRQ
Interrupt
Request
usado
hallar
direcci
on
memoria
servicio
atenci´on
interrupci´on
tabla
vectores
interrupci´on
interrupciones
clasificarse
precisas
imprecisas
entrando
categor
ıa
s´ı
s´ı
cumplen
PC
guarda
lugar
conocido
instrucciones
anteriores
apuntada
PC
ejecutado
completo
instrucciones
posteriores
apuntada
PC
ejecutado
conoce
ejecuci´on
instrucci´on
apuntada
PC
interrupciones
imprecisas
comunes
aquinas
superescalares
pipelines
tuber´ıas
as´ı
interrupci
on
requerir´ıa
guardar
informaci
on
res-
taurar
contexto
opta
guardarla
ıa
caso
TRAP
in-
terrupci´on
interna
producida
error
fatal
divisi
on
ejemplo
tendremos
restaurar
contexto
5.6
Objetivos
software
Tanenbaum
2009
p.
343-344
Independencia
dispositivos
crear
programas
accedan
disposi-
tivo
especificarlo
adelantado
Denominaci´on
uniforme
nombre
archivo
dispositivo
cadena
umero
depender
dispositivo
Manejo
errores
realizarse
nivel
controlador
Sincron´ıa
transferencias
transferencias
suelen
as
ıncronas
controladas
interrup-
ciones
m´as
f´acil
programar
consider´andolas
s´ıncronas
sistema
operativo
encargarse
transferencias
controladas
interrupciones
parezcan
s´ıncronas
median-
bloqueo
procesos
b´ufer
datos
entrantes
suelen
almacenados
b´ufer
sistema
operativo
copiados
destino
Dispositivos
compartidos
dedicados
dispositivos
clasificarse
compartidos
dedicados
seg´un
as
usuario
use
sistema
operativo
capaz
manejar
correctamente
evitar
interbloqueos.5.7
MANERAS
69
5.7
Maneras
Tanenbaum
2009
p.
344-347
5.7.1
programada
Utiliza
sondeo
ocupado
espera
carga
ufer
informaci
on
transferir
entra
bucle
transferida
dispositivo
entra
bucle
recibir
informaci´on
dispositivo
desventaja
ocupa
CPU
desperdiciando
tiempo
5.7.2
controlada
interrupciones
inicia
transferencia
parcial
bloquea
proceso
realiza
controlador
dispositivo
emita
interrupci
on
indicando
termin
transferencia
permitiendo
continuar
repitiendo
diferencia
programada
utilizan
bloqueos
lugar
espera
ocupa-
permitiendo
procesos
ejecutarse
dispositivo
trabajo
5.7.3
DMA
lugar
interrupci
on
transferida
controlada
interrup-
ciones
chip
DMA
realiza
trabajo
emite
unica
interrupci´on
ahorrando
tiempo
CPU
desventajas
leves
requiere
hardware
especial
ıpicamente
as
lento
CPU
llegar
m´as
lento
alg´un
dispositivo
5.8
Capas
software
Tanenbaum
2009
p.
348-360
5.8.1
Manejadores
interrupciones
Atender
interrupci
on
requiere
pasos
previos
guardar
contexto
pro-
ceso
ejecut
andose
previamente
cambio
contexto
Tambi
involucra
llamada
planificador
procesos
posterior
atenci´on
cambio
contexto
correspondien-
transferencia
pas´o
proceso
bloqueado
listo
elegible
proceso
ocupa
cantidad
considerable
instrucciones
dependiendo
aquina
involucrar
MMU
TLB
tabla
p´aginas.70
CAP´ITULO
ENTRADAS
SALIDAS
5.8.2
Controladores
dispositivos
controladores
dispositivos
odrivers
software
provisto
general
fabricante
dispositivo
S.
ejecutan
kernel
usuario
driver
interfaz
software
independiente
dispositivo
dispositivos
S.
valida
informaci´on
capa
superior
env´ıa
comprobar
dispositivo
correspondiente
funcionamiento
listo
env´ıa
secuencia
comandos
enviada
secuencia
driver
bloquear´a
dispositivo
finalice
activi-
dades
haci´endoselo
interrupci
on
errores
devuelve
informaci´on
software
independiente
dispositivo
sistemas
operativos
permiten
agregar
quitar
dispositivos
aqui-
na
funcionamiento
requiere
software
adicional
permita
abortar
transferencia
pendiente
curso
da˜nar
estructura
datos
kernel
5.8.3
Software
independiente
dispositivo
encarga
actividades
comunes
transferencias
dispositivos
S.
Suele
cumplir
funciones
Interfaz
uniforme
drivers
interfaz
est´andar
iguales
fuere
caso
tipo
interfaz
sistema
operativo
define
conjunto
operaciones
driver
definir
As
kernel
importa
qu
dispositivo
utilizar
operaciones
proporcionadas
nombre
coloca
dispositivo
tambi´en
est´a
relacionado
interfaz
uniforme
b´ufer
refiere
partes
memoria
utilizadas
almacenar
datos
transfe-
rencia
temporalmente
ufer
fragmento
informaci
on
transmitida
transmitir
deber
ıa
iniciar
proceso
usuario
bloquearlo
instante
despu´es
ineficiente
ufer
espacio
usuario
podr
ıa
ocurrir
agina
llevada
disco
ocasionando
problemas
Bloquear
aginas
ufers
ser´ıa
soluci´on
viable
bajar´ıa
rendimiento
bloqueadas
b´ufer
espacio
usuario
kernel
evita
problema
p´aginas
queda
ufer
kernel
podr
ıa
transfiriendo
datos
ufer
espacio
usuario
dispositivo
deber´ıa
recibir
simult´aneamente
soluci´on
doble
ufer
utiliza
aparte
mencionados
ufer
kernel
est
enviando
contenidos
encargado
recibir
viceversa
alternativa
b´ufer
circular
consiste
regi´on
memoria
punteros
palabra
libre
ultima
palabra
eliminar.5.9
DISCOS
71
Reporte
errores
controladora
dispositivo
encargada
detectar
errores
reales
software
independiente
dispositivo
encargado
proporcionar
marco
tratamiento
Tambi´en
consideran
errores
mala
programaci´on
proceso
pide
imposible
proporciona
par´ametros
inv´alidos
Asignaci´on
liberaci´on
dispositivos
dedicados
dispositivos
accedidos
proceso
requieren
mecanismos
especiales
garanticen
mecanismo
podr
ıa
manejarlos
archivos
especiales
open
solicite
acceso
fallando
estuviera
ocupado
close
libere
forma
ser´ıa
operaciones
especiales
bloqueen
proceso
solicita
asigne
dispositivo
dedicado
ocupado
coloc´andolo
cola
liberado
Tama˜no
bloque
independiente
dispositivo
Proporcionar
tama
˜no
bloque
caracter
procesos
usuario
importar
c´omo
funcione
realmente
dispositivo
5.8.4
Software
usuario
Consiste
procedimientos
biblioteca
realizan
llamadas
sistema
formateando
datos
Tambi´en
capa
colas
spooling
utilizadas
virtualizar
alg
dispositivo
as´ı
daemons
administran
5.9
Discos
Tanenbaum
2009
p.
360-388
5.9.1
Discos
magn
eticos
discos
flexibles
discos
duros
organizan
pistas
circulares
conc
entricas
apiladas
cilindros
cabezas
leerlas
Adem´as
pistas
subdividen
sectores
huecos
sectores
pre
ambulo
informaci
on
umero
cilindro
pista
sector
datos
area
destinada
ECC
organizaci
on
formato
nivel
disco
magn
etico
controlador
encarga
transferencias
as
correcci´on
errores
Tambi´en
b´ufers
cach´es
almac´en
datos
escribir
datos
posiblemente
le´ıdos
usqueda
especificar
cilindro
cabeza
sector
con-
trolador
ordenar´a
cabeza
correspondiente
mueva
cilindro
indicado
rotar´a
disco
llegar
sector
busca
com´un
s´olo
busque
sector
lectura
realidad
lean
siguientes
tambi´en
escriban
cach´e
rotaci´on
contin´ua.72
CAP´ITULO
ENTRADAS
SALIDAS
lectura
requiere
validaci´on
ECC
leer
m´ultiples
sectores
consecuti-
vos
demorar
m´as
tiempo
necesario
rotaci
on
continu´o
cabeza
pas
sector
asumiendo
entraron
cach
lograr
entrelaza-
do
intercalar
sectores
controladora
solicite
sector
cabeza
encuentre
pr´oxima
sector
mayor´ıa
computadoras
conocido
MBR
Master
Boot
Record
Registro
Maestro
Arranque
odigo
inicio
aquina
adem´as
tabla
particiones
formato
alto
nivel
consiste
estructuraci
on
particiones
divisiones
disco
formada
sectores
bloques
arranque
superbloque
administraci
on
espacio
libre
Nodos-I
etc.
b´usqueda
disco
realizarse
distintos
algoritmos
llegar
atendido
First
Come
First
Served(FCFS
b´usqueda
m´as
corta
Shortest
Seek
First
SSF
Algoritmo
elevador
direcci´on
llegar
extremo
direcci´on
algoritmos
buscan
disminuir
tiempo
usqueda
tarda
brazo
moverse
cilindro
actual
requerido
retraso
rotacional
tiempo
tarda
sector
indicado
colo-
carse
cabeza
tiempo
transferencia
datos
actual
irrelevantes
comparaci
on
RAID
Redundant
Array
of
Independent
Disks
Arreglo
Redundante
Discos
Independien-
tes
organizaci
on
ultiples
discos
permite
aumentar
rendimiento
confiabilidad
m´ultiples
discos
alternativas
bloque
consecutivo
disco
round-robin
bloque
consecutivo
disco
doble
discos
bloque
copia
bit
incluidos
Hamming
detecci
on
correcci
on
errores
disco
distinto
bit
incluido
paridad
detecci´on
errores
disco
distinto
bloque
consecutivo
disco
as
disco
bloques
paridad
bloques
bloque
consecutivo
disco
seleccionando
bloques
round-robin
contener
bloques
paridad
bloques
detectan
errores
abrica
controlador
marca
sector
defectuoso
utilizan
sectores
adicionales
quedan
blanco
grabar
datos
lugar
defectuoso
As´ı
estrategias
Escribir
contenido
directamente
sector
adicional
potencialmente
as
lentas
b´usquedas)5.9
DISCOS
73
Mover
sectores
mantener
orden
proceso
costoso
especialmente
sectores
est´an
blanco
requerir´ıan
copiar
pre´ambulo
forma
similar
JFS
busca
salvar
posibles
fallas
discos
asegur
andose
transferencias
concreten
realicen
punto
logra
etodo
llamado
almacenamiento
estable
almacenamiento
estable
utiliza
discos
contenidos
id´enticos
correctos
Define
operaciones
Escritura
estable
escribe
sector
disco
lee
escrito
comprobar
correcto
serlo
repite
operaci´on
pasan
intentos
escritura
fallidos
sector
defectuoso
comienza
probar
escritura
concret´o
correctamente
disco
Lectura
estable
lee
bloque
disco
ECC
validara
contenido
lectura
correcta
hiciera
vuelve
intentar
lecturas
siguiera
incorrecto
lee
bloque
disco
probabilidad
hayan
vuelto
defectuosos
min´uscula
Recuperaci´on
fallas
falla
exploran
discos
sector
espec´ıfico
sabe-
mos
cu
ocurrir
falla
determinar
problema
escritura
bloques
verifican
ECC
iguales
est
detecta
error
ECC
sobrescribe
correctos
distintos
bloque
disco
sobrescribe
asunci´on
escrito
escritura
concret´o
5.9.2
Discos
opticos
general
lectura
menor
capacidad
discos
magn
eticos
m´as
lentos
tambi´en
m´as
baratos
escribe
espiral
CD-ROM
graban
hoyos
areas
lisas
ıdos
aser
discos
magn
eticos
graban
sectores
pre´ambulo
ECC
CD-R
grabables
distintos
momentos
puesto
colorantes
reaccionan
l´aser
lugar
hoyos
areas
lisas
CD-RW
regrabables
aleaci
on
plata
indio
antimonio
telurio
reacciona
distintas
potencias
l´aser
cambia
cristalino
amorfo
distintas
reflectividades.74
CAP´ITULO
ENTRADAS
SALIDAS
DVD
Significa
Digital
Versatile
Disk
Disco
Vers´atil
Digital
similares
CD-ROM
hoyos
m´as
peque˜nos
espiral
m´as
estrecha
l´aser
potente
rojo
As´ı
capacidad
m´as
coloca
doble
capa
graba
lados
Blu-ray
HD
DVD
mejora
DVDs
l´aser
a´un
potente
azul
aumenta
m´as
capacidad
5.10
Relojes
Tanenbaum
2009
p.
388-394
5.10.1
Hardware
relojes
temporizadores
programables
utilizan
oscilador
cristal
cuarzo
genera
se˜nales
peri
odicas
alta
frecuencia
Cuentan
registro
contador
registro
conte-
nedor
coloca
cantidad
˜nales
transcurrir
emita
interrupci´on
funcionamiento
consiste
cargar
contenedor
contador
disminuir
al´ultimo
se˜nal
oscilador
contador
volver
cargado
contador
llega
produce
interrupci
on
busca
generar
pulsos
reloj
llama
onda
cuadrada
computadoras
suelen
contar
reloj
respaldo
energizado
bater´ıa
guar-
fecha
hora
a´un
m´aquina
est´a
apagada
5.10.2
Tareas
controladora
reloj
Mantener
hora
d´ıa
iniciarse
computadora
utiliza
reloj
respaldo
obtener
hora
actual
pide
usuario
ingrese
reloj
hora
calcularse
formas
Contando
pulsos
ocurrido
momento
tiempo
registro
64
bits
evitar
desbordamiento
Contar
segundos
ocurrido
momento
tiempo
Contar
pulsos
ocurrido
inici´o
sistema
Implementar
quantum
Establece
contador
cantidad
pulsos
quantum
proceso
pasa
ejecuci´on
decrementa
pulso
llega
controladora
llama
planificador.5.11
INTERFACES
USUARIO
75
Contabilizar
CPU
realizarse
temporizador
secundario
campo
incremente
pulso
reloj
ocurrido
proceso
est´a
ejecuci´on
Llamada
sistema
alarm
hacerse
tabla
guarde
alarmas
tiempos
ocurrir
variable
proporcione
tiempo
pr´oxima
alarma
forma
as
eficiente
lista
enlazada
ıtem
alarma
guarde
tiempo
transcurrir
alarma
Temporizadores
guardianes
watchdogs
llamada
alarm
procesos
kernel
produce
interrupciones
directamente
llama
procedimiento
proporcionado
diferencia
alarm
Perfilamiento
supervisi´on
recopilaci´on
estad´ısticas
sistemas
operativos
proporcionan
mecanismo
procesos
usuario
solicitar
construya
histograma
ubicaciones
suele
pasar
PC
5.10.3
Temporizadores
software
alternativa
manejo
peri´odica
interrupciones
baja
latencia
retraso
provocan
cambio
contexto
costoso
tiempo
sondeo
consiste
programa
compruebe
tiempo
transferencia
concretado
alta
latencia
evento
ocurre
justo
despu´es
sondeo
temporizador
software
comprueba
computadora
est
punto
salir
kernel
evitar
interrupciones
cambios
contexto
adicionales
procedimiento
ocurre
all´ı
temporizador
restablece
continuaci´on
5.11
Interfaces
usuario
Tanenbaum
2009
p.
394-415
5.11.1
Teclado
genera
interrupci´on
presiona
suelta
tecla
controlador
adoptar
filosof´ıas
crudo
can
onico
orientado
caracteres
controlador
recibe
caracteres
pasa
procesamiento
cocido
can´onico
orientado
l´ıneas
controlador
espera
termine
ingresar
l´ınea
procesarla
corregirla
com´un
requiera
eco
presiona
teclado
mostrado
monitor
momento.76
CAP´ITULO
ENTRADAS
SALIDAS
5.11.2
Rat
on
bolita
opticos
fuere
producir
interrupciones
transmiten
par´ame-
tros
∆x
∆y
botones
presionados
5.11.3
Interfaces
Gr
aficas
Usuario
GUIs
GUI
Graphical
User
Interface
Interfaz
Gr
afica
Usuario
sistema
ventanas
sistemas
operativos
interactivos
modernos
implementados
Win-
dows
UNIX
kernel
entrada
GUIs
suele
teclado
rat
on
salida
suele
adaptador
gr´aficos
hardware
especial
contiene
RAM
video
GUI
elementos
principales
conocidos
WIMP
ventanas
Windows
ıco-
Icons
men´ues
Menus
dispositivo
se˜nalador
Pointing
device
GUIs
reciben
eventos
trav´es
ventanas
colocan
cola
eventos
ventanas
contienen
elementos
visuales
permiten
interacci
on
usuario
elementos
llama
widgets
concepto
recursos
estructuras
datos
informaci
on
relevante
GUI
ventanas
fuentes
mapas
bits
ventanas
mostrar
gr
aficos
formas
vectoriales
funciones
indican
c´omo
dibujarse
mapas
bits
5.12
Clientes
delgados
Tanenbaum
2009
p.
415-417
refiere
terminales
tontas
aquinas
consisten
monitor
teclado
rat´on
conectan
mainframe
realiza
computaci
on
monitor
qu´e
mostrar
Actualmente
modelo
viable
usuarios
quieren
cosas
navegador
ahorr´andose
as´ı
administraci´on
computadora
5.13
Administraci
on
energ´ıa
Tanenbaum
2009
p.
417-425
capacidad
bater
ıas
aumentado
paso
˜nos
ideado
etodos
ahorrar
energ
ıa
asignaci
on
CPU
memoria
dispositivos
encendido
inactivo
hibernando
apagado
tardan
reaccionar
consumen
m´as
energ´ıa
pantallas
ponerse
inactividad
dejen
emitir
luz
volver
encenderlas
requiere
leer
RAM
video
ocurrir
usuario
decida
tiempo
disco
duro
ponerse
hibernar
deja
girar
tarda
tiempo
considerable
volver
m´axima
velocidad
memoria
vaciarse
apagarse
cach
inactividad
hacerse
memoria
principal
hibernaci´on
adem´as
requiere
apagado
CPU
comunicaci
on
inal
ambrica
tambi
representar
problema
receptor
esperando
comunicaci
on
soluci
on
avise
emisor
apagarse5.13
ADMINISTRACI
ON
ENERG´IA
77
env´ıe
vuelva
prenderse
tambi
avisa
emisor
env´ıe
temporalmente
debi´o
guardar
b´ufer
tema
considerar
ser´ıa
sobrecalentamiento
evitarse
venti-
lador
ruido
consume
energ
ıa
disminuyendo
consumo
energ
ıa
aparatos
mencionados
computadora
bater´ıas
inteligentes
est´a
conectada
alimentaci´on
administrarlas
correctamente
puesto
as
logra
avisar
usuario
apagado
ordenado
detectarse
carga
baja
Adem
as
ultiples
bater´ıas
tambi
alternarlas
detectar
carga
fuere
controladoras
dispositivos
suelen
capaces
permitir
administraci´on
energ´ıa
dispositivo
computadora
orden
andoles
cambios
dispositivos
tambi´en
deber´ıan
capaces
activar
computadora
CPU
memoria
est´an
inactivas
hibernando
forma
adicional
ahorrar
energ
ıa
software
degradando
rendimiento
pos
aumentar
tiempo
durar´a
bater´ıa
Glosario
BCP
Bloque
Control
Proceso
entrada
tabla
procesos
18
45
48
75
CMOS
Memoria
vol´atil
consume
energ´ıa
DMA
Direct
Memory
Access
chip
maneja
comunicaci
on
controladores
disposi-
tivo
memoria
principal
liberando
CPU
47
66
67
69
EEPROM
Electrically
Erasable
PROM
memoria
borrada
reescrita
lentamente
grado
multiprogramaci´on
Cantidad
procesos
memoria
19
44
PFF
Page
Fault
Frequency
Frecuencia
Fallos
agina
Algoritmo
mide
proporci
on
fallos
p´agina
proceso
tiempo
identifica
encuentren
determinado
rango
44
rwx
Bits
protecci´on
lectura
read
escritura
write
ejecuci´on
execute
11
14
39
shell
Interfaz
l´ınea
comandos
11
SMP
Symmetric
Multiprocessing
sistema
computaci
on
multiprocesador
acceso
recursos
funciones
WSClock
Algoritmo
reemplazo
aginas
combina
algoritmos
reloj
conjunto
trabajo
43
44
78Siglas
BIOS
Basic
Input
Output
System
Sistema
B´asico
S.
36
CD-ROM
Compact
Disc
Read-Only
Memory
ROM
74
CPU
Central
Processing
Unit
Unidad
Central
Procesamiento
17
18
20
21
22
23
24
26
27
29
30
44
46
47
67
76
77
DLL
Dynamically
Linked
Library
Biblioteca
Enlaces
Din´amicos
45
Entradas
Salidas
10
11
19
27
28
29
39
47
53
65
66
67
68
69
70
71
75
76
77
78
79
80
ECC
Error
Correction
Code
C´odigo
Correci´on
Errores
65
71
72
73
FAT
File
Allocation
Table
Tabla
Asignaci´on
Memoria
57
58
GID
Group
Identification
Identificaci´on
Grupo
10
GUI
Graphical
User
Interface
Interfaz
Gr´afica
Usuario
15
76
IDE
Integrated
Drive
Electronics
Electr´onica
Unidad
Integrada
Instruction
Register
Registro
Instrucciones
ISA
Instruction
Set
Architecture
Set
Instrucciones
Arquitectura
ISA
Industry
Standard
Architecture
Bus
JFS
Journaling
File
System
Sistema
archivos
bit´acora
59
73
LFS
Log-structured
File
System
Sistema
archivos
estructurado
registro
58
59
LRU
Least
Recently
Used
Usadas
Recientemente
algoritmo
reemplazo
aginas
42
44
MBR
Master
Boot
Record
Registro
Maestro
Arranque
55
72
MMU
Memory
Management
Unit
Unidad
Administraci
on
Memoria
hardware
38
39
40
46
69
7980
Siglas
NFU
Not
Frequently
Used
Usadas
Frecuentemente
algoritmo
reemplazo
p´aginas
42
PC
Program
Counter
Contador
programa
46
47
68
75
PCI
Peripheral
Component
Interconnect
66
PSW
Program
Status
Word
Palabra
Programa
36
RAID
Redundant
Array
of
Independent
Disks
Arreglo
Redundante
Discos
Independientes
72
RAM
Random
Access
Memory
Memoria
Acceso
Aleatorio
36
76
RDAE
Registro
Datos
S.
RDAM
Registro
Datos
Memoria
RDIE
Registro
Direcciones
S.
RDIM
Registro
Direcciones
Memoria
ROM
Read-Only
Memory
Memoria
Lectura
36
79
SCSI
Small
Computer
System
Interface
SP
Stack
Pointer
apuntador
pila
TLB
Translation
Lookaside
Buffer
B´ufer
Traducci´on
Adelantada
hardware
40
41
46
50
69
UID
User
Identification
Identificaci´on
Usuario
10
62
USB
Universal
Serial
Bus
Bus
Serial
Universal
VFS
Virtual
File
System
Sistema
archivos
virtual
59
60Bibliograf´ıa
Stallings
W.
2005).Sistemas
Operativos
Aspectos
internos
principios
dise˜no
Pearson
Prentice
Hall
edition
Tanenbaum
A.
S.
2009
Sistemas
Operativos
Modernos
Pearson
Education
edition
81
