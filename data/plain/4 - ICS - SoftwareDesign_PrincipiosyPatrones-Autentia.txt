V . 1 
Principios y patrones del
desarrollo de software
SOFTWARE
DESIGN
Primera  parte
GUIA PARA 
DIRECTIVOS Y TÃ‰CNICOS V . 1 Software Design 
Principios y patrones del
desarrollo de software
Este documento forma parte de las guÃ­as de onboarding de 
Autentia. Si te apasiona el desarrollo de software de calidad 
ayÃºdanos a difundirlas y anÃ­mate a unirte al equipo. Este es un 
documento vivo y puedes encontrar la Ãºltima versiÃ³n, asÃ­ como el 
resto de partes que completan este documento, en nuestra web.
https://www.autentia.com/libros/
Esta obra estÃ¡ licenciada bajo la licencia Creative Commons 
Attribution ShareAlike 4.0 International (CC BY-SA 4.0)
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWARE
En las fases iniciales del desarrollo 
de un proyecto de software, 
durante sus primeras versiones, 
las nuevas funcionalidades fluyen 
de manera graciosa y natural, casi 
parecen construirse solas y â€œtodo 
son vino y rosasâ€. A medida que 
los proyectos van avanzando y 
creciendo, de repente, toda esa 
magia desaparece y comienzan 
a surgir una serie de problemas 
y situaciones que muestran que 
algo no va bien, son sÃ­ntomas de 
que nuestros diseÃ±os se estÃ¡n 
degradando y pudriendo.
â€œSÃ³lo el tiempo 
demostrarÃ¡ si 
nuestro software, 
al  enfrentarse a 
los fuertes vientos 
del cambio, estÃ¡ 
asentado sobre roca 
firme o sobre arenaâ€PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWARE
Los sÃ­ntomas mÃ¡s evidentes son:
â€¢ Rigidez: el so
ftware se vuelve difÃ­cil de cambiar incluso en tareas 
sencillas. Las estimaciones son cada vez mÃ¡s abultadas y cada 
funcionalidad nueva cuesta horrores cuando antes era casi inmediata
â€¢ Fragilida
d: muy relacionado con la rigidez, la fragilidad es la tendencia 
a que el software se rompa en mÃºltiples sitios cada vez que se hace 
un cambio, incluso en partes que conceptualmente no tienen relaciÃ³n 
ninguna las unas con las otras. Cuando subimos una nueva versiÃ³n 
que ha costado â€œsudor y lÃ¡grimasâ€, resulta que se rompen cosas que 
aparentemente no tienen nada que ver con lo que hemos hecho.
â€¢
 Inmovilidad o poca
 reutilizaciÃ³n: cuando resulta imposible reutilizar 
software de otros proyectos o incluso de otras partes del mismo 
proyecto. Suele ocurrir porque el mÃ³dulo que queremos reutilizar 
tiene una mochila de dependencias demasiado grande como para 
asumir el esfuerzo y el riesgo de desacoplarlo. Se piden cosas que 
son prÃ¡cticamente una copia de otras funcionalidades de las que ya 
disponemos, sin embargo esto no parece ser una ventaja y cuesta 
demasiado sacar lo comÃºn para reutilizarlo, tendiendose a copiar y 
duplicar cÃ³digo.
â€¢
 Viscosidad: la
 viscosidad en el Ã¡mbito del diseÃ±o se da cuando 
es mÃ¡s sencillo hacer las cosas mal, hacer la â€œÃ±apaâ€, que tratar de PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWARE
hacerlas por el camino trazado. La viscosidad en el entorno ocurre 
cuando el ecosistema de desarrollo es lento e ineficiente en el mÃ¡s 
amplio sentido de la palabra. Por ejemplo, cuando una vez tenemos la 
funcionalidad terminada, hacerla llegar hasta producciÃ³n supone una 
autÃ©ntica aventura y se necesitan dÃ­as (o semanas).
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWARE
Los principios de desarrollo de software son una serie de reglas y 
recomendaciones especÃ­ficas que los programadores deben seguir 
durante el desarrollo si quieren escribir un cÃ³digo limpio, comprensible 
y fÃ¡cil de mantener. No hay una varita mÃ¡gica por medio de la cual se 
pueda transformar una combinaciÃ³n de variables, clases y funciones en 
el cÃ³digo ideal, pero hay algunos consejos y sugerencias que pueden 
ayudar al programador a determinar si estÃ¡ haciendo las cosas bien y 
tratar de evitar las situaciones que a modo de ejemplo hemos narrado 
en el apartado anterior, y que seguro, que si llevamos el tiempo suficiente 
dedicados a esta  maravillosa profesiÃ³n del desarrollo de software, 
habremos vivido, sino igual, al menos de manera similar.Software
Design
Ãndice
Principios y patrones del desarrollo de software
â€¢ Principios generales
â€¢ Principios S.O.L.I.D.
â€¢  Single responsibility (
SRP)
â€¢  Open/closed 
(OCP)
â€¢  Liskov substitution (LSP
)
â€¢  Interface segr
egation (ISP)
â€¢  Dependency inver
sion (DIP)
â€¢  Donâ€™t Repeat 
Yourself (DRY)
â€¢  Inversion o
f Control (IoC)
â€¢  You Aren
â€™t Gonna Need It (YAGNI)
â€¢  Keep It Simple, Stupid (KISS
)
â€¢  Law of
 Demeter (LoD)
â€¢  Strive for loosel
y coupled design between objects that interact
â€¢  Composition over inheritance
â€¢  Encapsulate wha
t varies
â€¢  The four
 rules of simple design
â€¢  The boy scout rule
â€¢  Last Responsible Momentâ€¢ Design Patterns
â€¢ Patrones creacionales
â€¢ Builder
â€¢ Singleton
â€¢ Dependency Injection
â€¢ Service Locator
â€¢ Abstract Factory
â€¢ Factory Me
thod
â€¢ Patrones estructurales
â€¢ Adapter
â€¢ Data A
ccess Object (DAO)
â€¢ Query Object
â€¢ Decorator
â€¢ Bridge
â€¢ Patrones de comportamien
to
â€¢ Command
â€¢ Chain of Responsibility
â€¢ Strategy
â€¢ Template Me
thod
â€¢ Interpre
ter
â€¢ Observer
â€¢ State
â€¢ Visitor
â€¢ Iterator
â€¢ BibliografÃ­a
â€¢ Lecciones aprendidasÂ 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         7Â Â 
Principios generalesÂ 
Principios S.O.L.I.D.Â 
Â 
S.O.L.I.D. es un acrÃ³nimo mnemÃ³nico para cinco principios de diseÃ±oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
destinados a hacer que los diseÃ±os de software sean mÃ¡s comprensibles,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
flexibles y mantenibles. Los principios son un subconjunto de muchosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
principios promovidos por el ingeniero e instructor de softwareÂ  Â  Â  Â  Â  Â  Â  Â  Â 
estadounidense Robert C. Martin. Aunque se aplican a cualquier diseÃ±oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
orientado a objetos, los principios SOLID tambiÃ©n pueden formar unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
filosofÃ­a central para metodologÃ­as como el desarrollo Ã¡gil o el desarrolloÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de software adaptativo.Â 
Los principios comprendidos en S.O.L.I.D. son:Â 
â— Sâ€‹: â€‹Single responsibilityâ€‹.Â 
â— Oâ€‹: â€‹Open/closedâ€‹.Â 
â— Lâ€‹: â€‹Liskov substitutionâ€‹.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         8Â Â 
â— Iâ€‹: â€‹Interface segregationâ€‹.Â 
â— Dâ€‹: â€‹Dependency inversionâ€‹.Â 
Aplicar estos principios facilitarÃ¡ mucho el trabajo, tanto propio como ajenoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
(es muy probable que nuestro cÃ³digo lo acaben leyendo muchos otrosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
desarrolladores a lo largo de su ciclo de vida). Algunas de las ventajas deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
aplicarlo son:Â 
â— Facilitar el mantenimiento del cÃ³digo.Â 
â— Reducir la complejidad de aÃ±adir nuevas funcionalidades.Â 
â— Aumentar la reusabilidad de piezas y componentes.Â 
â— Mejorar la calidad del cÃ³digo y su comprensiÃ³n.Â 
â€‹Single responsibility (SRP)Â 
El principio de responsabilidad Ãºnica o single responsibility establece queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un mÃ³dulo de software debe tener una y solo una razÃ³n para cambiarâ€‹. EstaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
razÃ³n para cambiar es lo que se entiende por responsabilidad.Â 
Â 
Â 
Â 
Â 
â€œReÃºna las cosas que cambian por lasÂ  Â  Â  Â  Â  Â  Â 
mismas razones. Separe las cosasÂ  Â  Â  Â  Â 
que cambian por diferentes razones.â€Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         9Â Â 
Â 
Este principio estÃ¡ estrechamente relacionado con los conceptos deÂ  Â  Â  Â  Â  Â  Â  Â  Â 
acoplamiento y cohesiÃ³n. Queremos aumentar la cohesiÃ³n entre las cosasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que cambian por las mismas razones y disminuir el acoplamiento entre lasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cosas que cambian por diferentes razones. Este principio trata sobreÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
limitar el impacto de un cambioâ€‹.Â 
Si existe mÃ¡s de una razÃ³n para cambiar una clase, probablemente tengaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ¡s de una responsabilidad. Otro posible â€œmal olorâ€ es que tengaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
diferentes comportamientos dependiendo de su estado. Tener mÃ¡s de unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
responsabilidad tambiÃ©n hace que el cÃ³digo sea difÃ­cil de leer, testear yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mantener. Es decir, hace que el cÃ³digo sea menos flexible.Â 
Entre las ventajas de aplicar este principio encontramos que, si se necesitaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
hacer algÃºn cambio, Ã©ste serÃ¡ fÃ¡cil de detectar ya que estarÃ¡ aislado enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
una clase claramente definida y comprensible. Minimizando los efectosÂ  Â  Â  Â  Â  Â  Â  Â  Â 
colaterales en otras clases. Algunos ejemplos que encontramos en la vidaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
real son:Â 
Si cambia la forma en que se compra un artÃ­culo, no tendremos queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
modificar el cÃ³digo responsable de almacenarlo. Si cambia la base deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
datos, no habrÃ¡ que arreglar cada pedazo de cÃ³digo donde se utiliza.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹[S.O.L.I.D.] Single responsibility principle /Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Principio de Responsabilidad Ãšnicaâ€‹ en Adictos al Trabajo.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         10Â Â 
Â 
â€‹Open/closed (OCP)Â 
Este principio nos dice que â€‹los mÃ³dulos de software deben ser abiertosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
para su extensiÃ³n pero cerrados para su modificaciÃ³nâ€‹. Â¿A quÃ© se refiereÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
con esto?Â 
â— Abierto para la extensiÃ³nâ€‹: esto significa que el comportamiento delÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ³dulo puede extenderse. A medida que cambian los requisitos de laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
aplicaciÃ³n, podemos ampliar el mÃ³dulo con nuevos comportamientosÂ  Â  Â  Â  Â  Â  Â  Â 
que satisfagan esos cambios. En otras palabras, podemos cambiar loÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que hace el mÃ³dulo.Â 
â— Cerrado por modificaciÃ³nâ€‹: un mÃ³dulo estarÃ¡ cerrado si dispone deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
una descripciÃ³n (interface) estable y bien definida. Extender elÂ  Â  Â  Â  Â  Â  Â  Â  Â 
comportamiento de un mÃ³dulo no deberÃ­a afectar al cÃ³digo yaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
existente en el mÃ³dulo, es decir, el cÃ³digo original del mÃ³dulo noÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         11Â Â 
deberÃ­a verse afectado y tener que modificarse.Â 
Y esa es realmente la esencia de este principio. DeberÃ­a ser fÃ¡cil cambiar elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
comportamiento de un mÃ³dulo sin cambiar el cÃ³digo fuente de ese mÃ³dulo.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Esto no significa que nunca cambiarÃ¡ el cÃ³digo fuente. Lo que significa esÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que debemos esforzarnos por lograr que nuestro cÃ³digo estÃ© estructuradoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de forma que, cuando el comportamiento cambie de la manera esperada,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
no debamos hacer cambios radicales en todos los mÃ³dulos del sistema.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Idealmente, podremos agregar el nuevo comportamiento, aÃ±adiendo cÃ³digoÂ  Â  Â  Â  Â  Â  Â  Â 
nuevo y cambiando poco o nada del cÃ³digo antiguo.Â 
La forma de implementar este principio en el mundo prÃ¡ctico, es a travÃ©sÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
del polimorfismo, ya sea por interfaces o clases abstractas.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹[S.O.L.I.D.] Open-Closed Principle / PrincipioÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Abierto-Cerradoâ€‹ en Adictos al Trabajo.Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         12Â Â 
â€‹Liskov substitution (LSP)Â 
Â 
â€œSi se ve como un pato, hace cuacÂ 
como un pato, pero necesita baterÃ­as,Â 
probablemente tengas la abstracciÃ³nÂ 
incorrecta.â€Â 
Â 
La sustituciÃ³n de Liskov nos dice que los â€‹objetos de un programa deberÃ­anÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
ser reemplazables por instancias de sus subtipos sin alterar el correctoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
funcionamiento del programa. BÃ¡sicamente, si en alguna parte de nuestroÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cÃ³digo estamos usando una clase, y esta clase es extendida, tenemos queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
poder utilizar cualquiera de las clases hijas y que el programa siga siendoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
vÃ¡lido. Esto nos obliga a asegurarnos de que cuando extendemos una claseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
no estamos alterando el comportamiento de la clase padre.Â 
Este principio nos â€‹ayuda a utilizar la herencia de forma correcta y nosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
muestra que no se debe mapear automÃ¡ticamente el mundo real en unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
modelo orientado a objetos, ya que no existe una equivalencia unÃ­vocaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
entre ambos modelos.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹[S.O.L.I.D.] Liskov substitution en Adictos alÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Trabajo.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         13Â Â 
Â 
â€‹Interface segregation (ISP)Â 
El principio de segregaciÃ³n de interfaces establece que â€‹muchas interfacesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cliente especÃ­ficas son mejores que una interfaz de propÃ³sito generalâ€‹.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Cuando los clientes son forzados a utilizar interfaces que no usan porÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
completo, estÃ¡n sujetos a cambios de esa interfaz. Esto al final resulta enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un acoplamiento innecesario entre los clientes.Â 
Dicho de otra manera, cuando un cliente depende de una clase queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementa una interfaz, cuya funcionalidad este cliente no usa pero queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
otros clientes si, este cliente estarÃ¡ siendo afectado por los cambios queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
fuercen otros clientes en la clase en cuestiÃ³n.Â 
Debemos intentar evitar este tipo de acoplamiento cuando sea posible.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Esto se consigue separando las interfaces en otras mÃ¡s pequeÃ±as yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
especÃ­ficas.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         14Â Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹[S.O.L.I.D.] Interface Segregation Principle /Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Principio de segregaciÃ³n de interfazâ€‹ en Adictos al Trabajo.Â 
Â 
â€‹Dependency inversion (DIP)Â 
El principio de inversiÃ³n de dependencia nos dice que â€‹las entidades deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
software deben depender de abstracciones, no de implementacionesâ€‹. A suÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
vez, los mÃ³dulos de alto nivel no deberÃ­an depender de los de bajo nivel.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Ambos deberÃ­an depender de abstracciones.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         15Â Â 
Â 
Mediante este principio ocultamos los detalles de implementaciÃ³n, ganandoÂ  Â  Â  Â  Â  Â  Â  Â  Â 
en flexibilidad. Cuando estamos haciendo tests, podemos reemplazarÂ  Â  Â  Â  Â  Â  Â  Â 
dependencias reales por objetos mockeados.Â 
Gracias a esta flexibilidad, vamos a poder sustituir componentes sin queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
los clientes que los consumen se vean afectados ya que dependen de laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
abstracciÃ³n y no de la implementaciÃ³n concreta.Â 
Lo que se pretende es que no existan dependencias directas entreÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ³dulos, sino que dependan de abstracciones. De esta forma, nuestrosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ³dulos pueden ser mÃ¡s fÃ¡cilmente reutilizables. Es fundamental que laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
abstracciÃ³n se defina en base a las necesidades del mÃ³dulo o cliente y noÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
en las capacidades de la implementaciÃ³n, de lo contrario, la abstracciÃ³nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
estarÃ­a bastante acoplada a la implementaciÃ³n teniendo asÃ­ menosÂ  Â  Â  Â  Â  Â  Â  Â  Â 
flexibilidad.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹[S.O.L.I.D.] Dependency inversion principle /Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Principio de inversiÃ³n de dependenciasâ€‹ en Adictos al Trabajo.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         16Â Â 
Â 
â€‹Donâ€™t Repeat Yourself (DRY)Â 
Â 
Su objetivo principal es â€‹evitar la duplicaciÃ³n de lÃ³gicaâ€‹. Cada pieza deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
funcionalidad debe tener una â€‹identidad Ãºnicaâ€‹, â€‹no ambigua y â€‹representativaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
dentro del sistema.Â 
SegÃºn este principio toda pieza de funcionalidad nunca deberÃ­a estarÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
duplicada ya que esta duplicidad incrementa la dificultad en los cambios yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         17Â Â 
su evoluciÃ³n posterior, puede perjudicar la claridad y crear un espacio paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
posibles inconsistencias.Â 
Por pieza de funcionalidad, no nos referimos a cÃ³digo sino a lÃ³gica, y mÃ¡sÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
concretamente a funciÃ³n lÃ³gica. No es saludable tener tres mÃ©todos paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
abrir una conexiÃ³n a una base de datos, cada uno con su propio cÃ³digo, siÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
no hay un motivo que asÃ­ lo justifique. Como se ve en este caso, los tresÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ©todos pueden tener distinto cÃ³digo, pero la funciÃ³n final de los tresÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
sigue siendo conectarse a la base de datos. Si en la evoluciÃ³n de nuestroÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
software se nos solicita cambiar la forma de conectarnos, el tipo de baseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de datos o incluso enviar los datos a otros sistema de almacenamiento,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
deberemos modificar los tres mÃ©todos, lo que incrementa la cantidad deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
trabajo ya que debemos escribir el cÃ³digo tres veces y, consecuentemente,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
probarlo, introduce mÃ¡s posibilidades de cometer errores, aumenta laÂ  Â  Â  Â  Â  Â  Â  Â  Â 
complejidad del cÃ³digo y mÃ¡s. Si ademÃ¡s, no somos los autores originalesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de todo este cÃ³digo y solo nos toca mantenerlo, todo parece mÃ¡s difÃ­cil yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
laborioso aÃºn.Â 
Cuando el principio DRY se aplica de forma eficiente, los cambios enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cualquier parte del proceso requieren cambios en un Ãºnico lugar. Por elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
contrario, si algunas partes del proceso estÃ¡n repetidas por varios sitios,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
los cambios pueden provocar fallos con mayor facilidad si todos los sitiosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
en los que aparece no se encuentran sincronizados.Â 
En resumen, Â¿por quÃ© es importante?Â 
â— Hace el cÃ³digo mÃ¡s mantenibleâ€‹. Evitar la repeticiÃ³n de lÃ³gica permiteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que si alguna vez cambia la funcionalidad en cuestiÃ³n, no lo tengasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que hacer en todos los lugares en los que lo repetiste.Â 
â— Reduce el tamaÃ±o del cÃ³digoâ€‹. Esto lo hace mÃ¡s legible y entendibleÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
porque hay menos cÃ³digo.Â 
â— Ahorra tiempoâ€‹. Al tener pedazos de lÃ³gica disponibles paraÂ  Â  Â  Â  Â  Â  Â  Â  Â 
reutilizarlos, en el futuro, estamos mÃ¡s preparados para lograr loÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         18Â Â 
mismo en menos tiempo.Â 
Â 
â€‹Inversion of Control (IoC)Â 
Como su nombre indica, â€œinversiÃ³n de controlâ€,Â  Â  Â  Â  Â  Â  Â 
se utiliza en el diseÃ±o orientado a objetos paraÂ  Â  Â  Â  Â  Â  Â  Â  Â 
delegar en un tercero diferentes tipos de flujosÂ  Â  Â  Â  Â  Â  Â  Â 
de control â€‹para lograr un bajo acoplamiento.Â  Â  Â  Â  Â  Â  Â 
Esto incluye el control sobre el flujo de unaÂ  Â  Â  Â  Â  Â  Â  Â  Â 
aplicaciÃ³n y el control sobre el flujo de laÂ  Â  Â  Â  Â  Â  Â  Â  Â 
creaciÃ³n de un objeto o la creaciÃ³n y vinculaciÃ³n de objetos dependientes.Â 
El principio de IoC ayuda a aumentar la modularidad del programa y alÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
diseÃ±o de clases con bajo acoplamiento, lo que las hace testeables,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mantenibles y extensibles.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         19Â Â 
Algunos patrones de diseÃ±o son implementaciones de este principio:Â 
â— Service locatorâ€‹.Â 
â— Dependency injectionâ€‹.Â 
â— Template methodâ€‹.Â 
â— Strategyâ€‹.Â 
â— Abstract Factoryâ€‹.Â 
â— Observerâ€‹.Â 
A este principio se lo conoce tambiÃ©n como â€‹Donâ€™t call us, weâ€™ll call youâ€‹ (NoÂ 
nos llame, nosotros lo llamamos) o â€‹Hollywood Principleâ€‹ (Principio deÂ 
Hollywood).Â 
Â 
â€‹You Arenâ€™t Gonna Need It (YAGNI)Â 
Este principio, que podemos traducir como â€œNo vas a necesitar esoâ€, es unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         20Â Â 
principio que indica que â€‹no â€‹se â€‹deben â€‹agregar funcionalidades extras hastaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que no sea necesarioâ€‹. La tentaciÃ³n de escribir cÃ³digo que no es necesarioÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pero que puede serlo en un futuro, tiene varias desventajas, como elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
desperdicio del tiempo que se destinarÃ­a para la funcionalidad bÃ¡sica (lasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
nuevas caracterÃ­sticas deben ser depuradas, documentadas y soportadas) oÂ  Â  Â  Â  Â  Â  Â  Â  Â 
que cuando se requieran las nuevas funcionalidades, estas no funcionenÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
correctamente, ya que hasta que no estÃ¡ definido para quÃ© se puedeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
necesitar, es imposible saber quÃ© debe hacer.Â 
Ver el artÃ­culo â€‹El principio YAGNIâ€‹, en Adictos al Trabajo, para mÃ¡s detalle.Â 
â€‹Keep It Simple, Stupid (KISS)Â 
El principio KISS (ğŸ¤˜ğŸ’‹) es un acrÃ³nimo que provieneÂ  Â  Â  Â  Â  Â  Â  Â  Â 
de la frase inglesa â€œkeep it simple, stupidâ€, queÂ  Â  Â  Â  Â  Â  Â  Â  Â 
podemos traducir como â€œmantenlo simple, estÃºpidoâ€.Â  Â  Â  Â  Â  Â 
Se entiende como la necesidad de minimizar losÂ  Â  Â  Â  Â  Â  Â  Â 
errores tratando de realizar las tareas de formaÂ  Â  Â  Â  Â  Â  Â  Â 
efectiva y eficiente complicandose lo mÃ­nimo posible.Â 
La simplicidad debe ser un objetivo clave tanto en el diseÃ±o, como en elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
desarrollo de la soluciÃ³n y se debe evitar la â€‹complejidad innecesariaâ€‹.Â 
â€‹Law of Demeter (LoD)Â 
La Ley de Demeter, tambiÃ©n conocida como el â€‹Principle of least knowledgeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
o principio â€‹Donâ€™t talk to strangers nos dice que un mÃ©todo de un objetoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
sÃ³lo deberÃ­a interactuar con:Â 
1. MÃ©todos del propio objeto.Â 
2. Los argumentos que recibe.Â 
3. Cualquier objeto creado dentro del mÃ©todo.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         21Â Â 
4. Cualquier propiedad / campo directo dentro del propio objeto.Â 
La idea principal es que un objeto â€‹no tiene porquÃ© conocer la estructuraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interna de los objetos con los que colaboraâ€‹. En otras palabras, lo que seÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
quiere evitar es el cÃ³digo con una estructura similar a la siguiente:Â 
object.getX().getY().getZ().doSomething()Â 
Â 
Â¿CuÃ¡l es el problema? BÃ¡sicamente, la cadena denota un fuerteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
acoplamiento a la estructura de las clases involucradas en ella,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
afectÃ¡ndonos cualquier cambio o modificaciÃ³n en las mismas.Â 
Entre las ventajas de aplicar este principio, encontramos:Â 
â— El software resultante tiende a ser mÃ¡s fÃ¡cil de mantener y adaptar,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
ya que los objetos dependen menos de la estructura interna de otrosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objetos, lo que reduce el acoplamiento.Â 
â— Se vuelve mÃ¡s sencillo reutilizar las clases.Â 
â— El cÃ³digo es mÃ¡s fÃ¡cil de probar.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹Ley de Demeterâ€‹ en Adictos al Trabajo.Â 
â€‹Strive for loosely coupled design betweenÂ  Â  Â  Â  Â  Â 
objects that interactÂ 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         22Â Â 
En espaÃ±ol â€œconseguir un diseÃ±o dÃ©bilmente acoplado entre objetos queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interactÃºanâ€. El acoplamiento se refiere al grado de conocimiento directoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que un elemento tiene de otro.Â 
El objetivo es â€‹reducir el riesgo de que un cambio en los objetos con los queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interaccionamos provoque cambios en otros objetosâ€‹.Â 
Limitar las interconexiones puede ayudar a aislar los problemas cuando lasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cosas salen mal y simplificar los procedimientos de prueba, mantenimientoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
y soluciÃ³n de problemas. Esto nos permite construir sistemas flexibles queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pueden manejar los cambios porque reducen la dependencia entreÂ  Â  Â  Â  Â  Â  Â  Â  Â 
mÃºltiples objetos.Â 
La arquitectura con bajo acoplamiento tiene las siguientes caracterÃ­sticas:Â 
â— Reduce el riesgo de que un cambio en un elemento pueda provocarÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cambios en otros elementos.Â 
â— Simplifica las pruebasâ€‹, el mantenimiento y la resoluciÃ³n deÂ  Â  Â  Â  Â  Â  Â  Â  Â 
problemas.Â 
â— Los componentes en un sistema dÃ©bilmente acoplado puedenÂ  Â  Â  Â  Â  Â  Â  Â 
reemplazarse con implementaciones alternativas que brinden losÂ  Â  Â  Â  Â  Â  Â 
mismos servicios.Â 
Un claro ejemplo de la implementaciÃ³n de este principio es el patrÃ³nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Observerâ€‹:Â 
â€‹Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         23Â Â 
Composition over inheritanceÂ 
Â 
El principio de composiciÃ³n sobre la herencia (tambiÃ©n conocido comoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
composite reuse principleâ€‹) establece que las clases deben â€‹lograr unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
comportamiento polimÃ³rfico y la reutilizaciÃ³n del cÃ³digo mediante laÂ  Â  Â  Â  Â  Â  Â  Â  Â 
composiciÃ³n (al contener instancias de otras clases que implementan laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
funcionalidad deseada), en lugar de a travÃ©s de la la herencia de una claseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
base o primaria, siempre que sea posible.Â 
Con la herencia, estructuramos las clases alrededor de lo que son. ConÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
composiciÃ³n, estructuramos las clases basÃ¡ndonos en lo que hacen. AlÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
favorecer la composiciÃ³n sobre la herencia y â€‹pensar en tÃ©rminos de lo queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
hacen las cosas en lugar de lo que son, nos liberamos de estructuras deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         24Â Â 
herencia frÃ¡giles y estrechamente acopladas.Â 
El gran problema con la herencia es que tendemos a predecir el futuro, aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
construir una estructura rÃ­gida con un fuerte acoplamiento entre clasesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
padres e hijas en una etapa muy temprana del proyecto y lo mÃ¡s probable,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
es que cometamos errores de diseÃ±o al hacer esto, dado que no podemosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
predecir el futuro, y cambiar o salir de estas estructuras o taxonomÃ­as deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
herencia es mucho mÃ¡s difÃ­cil de lo que parece.Â 
Al favorecer la composiciÃ³n sobre la herencia, dotamos al diseÃ±o de unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mayor flexibilidad. Es mÃ¡s natural construir clases a partir de variosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
componentes que tratar de encontrar puntos en comÃºn entre ellos y crearÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un Ã¡rbol genealÃ³gico. Por ejemplo, un pedal acelerador y un volanteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
comparten muy pocos rasgos comunes, sin embargo, ambos sonÂ  Â  Â  Â  Â  Â  Â  Â  Â 
componentes vitales en un automÃ³vil. Lo que pueden hacer y cÃ³mo seÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pueden utilizar para beneficiar al automÃ³vil se define fÃ¡cilmente. LaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
composiciÃ³n tambiÃ©n proporciona un dominio mÃ¡s estable a largo plazo, yaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que es menos propenso a las peculiaridades de los miembros. En otrasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
palabras, es mejor componer lo que un objeto puede hacer, verificando queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
se cumpla la relaciÃ³n â€‹HAS-A o â€‹TIENE-UNâ€‹, que extender lo que es. Esto noÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
significa que nunca se utilice la herencia, se puede implementar siempreÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que esta sea simple y tenga sentido dentro del modelo y,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
fundamentalmente, verificando siempre que se cumpla la relaciÃ³n â€‹IS-A oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
ES-UNâ€‹.Â 
El diseÃ±o inicial se simplifica identificando los comportamientos de losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objetos del sistema en interfaces separadas, en lugar de crear una relaciÃ³nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
jerÃ¡rquica para distribuir los comportamientos entre las clases a travÃ©s deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la herencia. Este enfoque es mÃ¡s flexible a cambios futuros que de otroÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
modo requerirÃ­an una reestructuraciÃ³n completa de las clases de dominioÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
en el modelo de herencia. AdemÃ¡s, evita problemas a menudo asociadosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
con cambios relativamente menores en un modelo basado en la herenciaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         25Â Â 
que incluye varias generaciones de clases. Evitando posibles diseÃ±os dondeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
se requiera herencia mÃºltiple, ya que muchos lenguajes no la soportan.Â 
Como desventaja, los diseÃ±os basados en un enfoque por composiciÃ³n sonÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
menos intuitivos.Â 
â€‹Encapsulate what variesÂ 
Este principio se refiere a que cuando se identifiquen partes de laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
aplicaciÃ³n que â€‹pueden cambiarâ€‹, se deben â€‹aislar y â€‹encapsular enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
abstracciones que permitan realizar el cambio sin afectar a otras partes deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la aplicaciÃ³n.Â 
Este principio se apoya en otros dos vistos en apartados anteriores comoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
son  â€‹Single responsibility (SRP)â€‹ y â€‹Open/closed (OCP)â€‹.Â Â 
Con la correcta aplicaciÃ³n de este principio se puede obtener dosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
beneficios fundamentales:Â 
â— Cuando una responsabilidad es correctamente acotada en un ÃºnicoÂ  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ³dulo, variaciones en los requisitos de esa responsabilidad influyenÂ  Â  Â  Â  Â  Â  Â  Â  Â 
Ãºnicamente en dicho mÃ³dulo, reduciendo la fragilidad de nuestroÂ  Â  Â  Â  Â  Â  Â  Â  Â 
sistema y aumentando su reusabilidad.Â 
â— La solicitud de nuevos requisitos o nuevos comportamientos seÂ  Â  Â  Â  Â  Â  Â  Â  Â 
obtiene mediante la incorporaciÃ³n de nuevos elementos en lugar deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la modificaciÃ³n de los elementos ya existentes, se reduce la rigidezÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de nuestro sistema (se vuelve mÃ¡s versÃ¡til y flexible) y se reduceÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
tambiÃ©n la fragilidad del mismo, ya que el cÃ³digo anterior (y por loÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
tanto probado) no se modifica.Â 
La mayorÃ­a de los patrones de diseÃ±o se basan en estos principios. AlgunosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de estos patrones son:Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         26Â Â 
â— Abstract Factoryâ€‹.Â 
â— Factory Methodâ€‹.Â 
â— Adapterâ€‹.Â 
â— Bridgeâ€‹.Â 
â— Decoratorâ€‹.Â 
â— Iteratorâ€‹.Â 
â— Observerâ€‹.Â 
â— Stateâ€‹.Â 
â— Strategyâ€‹.Â 
â— Template Methodâ€‹.Â 
â— Visitorâ€‹.Â 
â€‹The four rules of simple designÂ 
Hay 4 reglas que Kent Beck introdujo en los aÃ±os 90 sobre los puntosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
fundamentales que se deben tener en cuenta a la hora de diseÃ±ar software,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
buscando una â€‹manera â€‹objetiva de poder â€‹medir la calidad de un diseÃ±oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
desde la perspectiva de minimizar los costes y maximizar el beneficio yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
huyendo de valoraciones subjetivas. Estas cuatro reglas sencillas deÂ  Â  Â  Â  Â  Â  Â  Â  Â 
recordar estÃ¡n ordenadas por relevancia:Â 
1. Los tests pasanâ€‹: el testing es una pieza que no puede faltar cuandoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
desarrollamos software. El objetivo principal es que cada tareaÂ  Â  Â  Â  Â  Â  Â  Â  Â 
funcione de la manera esperada y que haya un/unos tests queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
verifican que estos criterios se cumplen.Â 
2. Expresan intenciÃ³nâ€‹: el cÃ³digo es autoexplicativo, fÃ¡cil de entender yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
facilita la comunicaciÃ³n del propÃ³sito del mismo.Â 
3. No hay duplicidades (DRY): se debe reducir al mÃ¡ximo la duplicidadÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de la lÃ³gica en el cÃ³digo, ya que de no hacerlo asÃ­, estaremosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
construyendo software frÃ¡gil y cualquier cambio, por muy pequeÃ±oÂ  Â  Â  Â  Â  Â  Â  Â  Â 
que sea, puede â€œromperâ€ otras partes.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         27Â Â 
4. MÃ­nimo nÃºmero de elementosâ€‹: se debe procurar reducir el nÃºmero deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
componentes, clases, mÃ©todos, etc., a lo imprescindible, eliminandoÂ  Â  Â  Â  Â  Â  Â  Â 
todas aquellas cosas que incrementen la complejidad del sistema deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
manera innecesaria.Â 
Estas 4 reglas han sido discutidas en gran variedad de libros y forosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
diversos dando lugar a una buena cantidad de ideas interesantes alÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
respecto, destacando  entre otras:Â 
â— No hay unanimidad en el orden de los puntos 2 y 3, originando unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
idea generalizada de que ambos deberÃ­an estar en el mismo nivel deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
importancia.Â Â 
â— El primer punto podrÃ­a no ser considerado siquiera como un puntoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
del diseÃ±o simple, sino como algo esencial y connatural al desarrolloÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de software. Es decir, ni siquiera se deberÃ­a plantear la posibilidad deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un cÃ³digo sin tests.Â Â 
â— El Ãºltimo punto es considerado para muchos como una consecuenciaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de la continua aplicaciÃ³n de los puntos 2 y 3.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         28Â Â 
Â 
â€‹The boy scout ruleÂ 
Los Boy Scouts tienen la regla de dejar el campamento mÃ¡s limpio de loÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que se lo encontraron y en caso de ensuciarlo, se limpia y se deja lo mejorÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
posible para la siguiente persona que venga. Si se aplica esto al desarrolloÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de software, se puede decir que si vemos alguna parte del cÃ³digo que seÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pueda mejorar, independientemente de quiÃ©n lo haya hecho, debemosÂ  Â  Â  Â  Â  Â  Â  Â  Â 
hacerlo.Â 
El objetivo principal es mejorar la calidad del cÃ³digo y evitar su deterioroÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
con el fin de ayudar al siguiente desarrollador (o a uno mismo dentro de unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
tiempo), a cambiar o desarrollar una nueva funcionalidad de una forma mÃ¡sÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
sencilla. Se promueve el trabajo en equipo por encima de la individualidad,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
ya que no solo es importante la tarea que esa persona ha realizado, sino elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
proyecto en general y si se ve que algo se puede mejorar, se hace. La ideaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         29Â Â 
es mejorar pequeÃ±as partes de cÃ³digo de manera acotada y segura, ya queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
tampoco es cuestiÃ³n de cambiar un mÃ³dulo entero, sino poco a poco, irÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mejorando su calidad.Â 
Para aplicar esta regla, se deben tener claros los principios â€‹SOLIDâ€‹.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹La regla del Boy Scout y la OxidaciÃ³n delÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Softwareâ€‹ en Adictos al Trabajo.Â 
â€‹Last Responsible MomentÂ 
El desarrollo de software es una disciplina realmente curiosa. No esÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
extraÃ±o, y me atreverÃ­a decir que es lo mÃ¡s habitual, encontrarseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
trabajando ya sobre las funcionalidades de un proyecto incipiente oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
aÃ±adiendo nuevas a otro ya mÃ¡s avanzado, sin tener aÃºn claramenteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
descritos los requisitos. â€‹Este principio propone como estrategia paraÂ  Â  Â  Â  Â  Â  Â  Â  Â 
abordar nuestros diseÃ±os, diferir nuestras decisiones, especialmenteÂ  Â  Â  Â  Â  Â  Â 
aquellas que se puedan considerar irreversibles, hasta el â€‹Ãºltimo momentoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
posibleâ€‹. Este momento serÃ­a aquel en el que no tomar la decisiÃ³n, suponeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un coste mayor que tomarla. Cuanto mÃ¡s tiempo mantengamos nuestrasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
decisiones abiertas, mÃ¡s informaciÃ³n iremos acumulando para optar por laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
decisiÃ³n mÃ¡s adecuada.Â Â 
Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         30Â Â 
Design PatternsÂ 
Â 
â€œLos patrones de diseÃ±o sonÂ 
descripciones de objetos y clasesÂ 
conectadas que se personalizan paraÂ 
resolver un problema de diseÃ±oÂ 
general en un contexto particularâ€.Â 
- Gang of FourÂ 
Â 
Los patrones de diseÃ±o ofrecen â€‹soluciones comunes a problemasÂ  Â  Â  Â  Â  Â  Â  Â  Â 
recurrentes de diseÃ±o de aplicaciones. En la programaciÃ³n orientada aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objetos, los patrones de diseÃ±o normalmente estÃ¡n dirigidos a resolver losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
problemas asociados con la creaciÃ³n e interacciÃ³n de objetos, en lugar deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
los problemas a gran escala que afrontan las arquitecturas generales delÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
software. Proporcionan soluciones generalizadas en forma de repeticionesÂ  Â  Â  Â  Â  Â  Â  Â 
que se pueden aplicar a problemas de la vida real.Â 
Los patrones de diseÃ±o son soluciones Ãºtiles y probadas para losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
problemas que inevitablemente aparecen. No solo albergan aÃ±os deÂ  Â  Â  Â  Â  Â  Â  Â  Â 
conocimiento y experiencia colectiva, sino que ademÃ¡s los patrones deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
diseÃ±o ofrecen un â€‹vocabulario comÃºn entre los desarrolladores y arrojanÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
luz sobre muchos problemas.Â 
Sin embargo, el uso innecesario o excesivo de patrones de diseÃ±o puedeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
suponer tambiÃ©n una sobre ingenierÃ­a, dando como resultado un sistemaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         31Â Â 
excesivamente complejo que lejos de resolver los problemas, los aumenta,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
dando lugar a un diseÃ±o ineficiente, bajo rendimiento y problemas deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mantenimiento.Â 
Los patrones de diseÃ±o se clasificaron originalmente en tres grupos:Â 
â— Creacionales.Â 
â— Estructurales.Â 
â— De comportamiento.Â 
Con el tiempo, fueron apareciendo nuevos patrones y con ellos, nuevasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
categorÃ­as de problemas que solucionan, por ejemplo, los patrones deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
concurrencia.Â 
Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         32Â Â 
Patrones creacionalesÂ 
BuilderÂ 
Este patrÃ³n pretende separar la lÃ³gica de construcciÃ³n de suÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
representaciÃ³n. Para ello, define una clase abstracta, Builder, que es laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
encargada de crear las instancias de los objetos. Los elementos queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
intervienen son los siguientes:Â 
â— Builder: interfaz abstracta que crea los productos.Â 
â— Builder concreto: implementaciÃ³n concreta del builder que creaÂ  Â  Â  Â  Â  Â  Â  Â 
productos de un cierto tipo.Â 
â— Director: el encargado de utilizar la clase builder para crear losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objetos.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         33Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         34Â Â 
SingletonÂ 
Este patrÃ³n consiste en utilizar â€‹una sola instancia de clase, definiendo asÃ­Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un Ãºnico punto global de acceso a ella. Dicha instancia es la encargada deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la inicializaciÃ³n, creaciÃ³n y acceso a las propiedades de clase.Â  Â 
Este patrÃ³n es muy utilizado cuando se quiere controlar el acceso a unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Ãºnico recurso fÃ­sico (fichero de lectura de uso exclusivo), o haya datos queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
deban estar disponibles para el resto de objetos de la aplicaciÃ³n (unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
instancia de log, por ejemplo).Â 
Se define un mÃ©todo de acceso para recuperar la instancia de la clase. EsteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ©todo tambiÃ©n se encargarÃ¡ de crear la instancia en el caso de que seÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
solicite por primera vez. Hay que prestar atenciÃ³n a los problemas queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pudiera haber de acceso exclusivo.Â 
Â  
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         35Â Â 
Dependency InjectionÂ 
Se trata de un patrÃ³n de diseÃ±o que se encarga de extraer laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
responsabilidad de la â€‹creaciÃ³n de instancias de un componente paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
delegarla en otro. Permite que un objeto reciba otros objetos de los queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
depende, en lugar de ser el propio objeto el que los cree. Estos otrosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objetos se llaman dependencias. En la tÃ­pica relaciÃ³n de "uso", el objetoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
receptor se llama cliente y el objeto pasado (es decir, "inyectado") se llamaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
servicio. El cÃ³digo que pasa el servicio al cliente puede ser de muchos tiposÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
y se llama inyector. En lugar de que el cliente especifique quÃ© servicioÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
usarÃ¡, el inyector le dice al cliente quÃ© servicio usar. La "inyecciÃ³n" seÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
refiere al paso de una dependencia (un servicio), al objeto (un cliente) queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
lo usarÃ­a.Â 
La inyecciÃ³n de dependencias es una forma de lograr la â€‹inversiÃ³n deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
controlâ€‹.Â 
El cliente Ãºnicamente necesita conocer las interfaces de los servicios sinÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
preocuparse de la implementaciÃ³n real de los mismosÂ 
Â 
By Vanderjoe - Own work, CC BY-SA 4.0,Â 
https://commons.wikimedia.org/wiki/File:W3sDesign_Dependency_Injection_Design_Pattern_UML.jpgÂ 
Para mÃ¡s detalle, ver el artÃ­culo â€‹PatrÃ³n de InyecciÃ³n de dependencias enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Adictos al Trabajo.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         36Â Â 
Service LocatorÂ 
El patrÃ³n de localizaciÃ³n de servicios es un patrÃ³n de diseÃ±o utilizado paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
encapsular los procesos involucrados en la obtenciÃ³n de un servicio conÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
una capa de abstracciÃ³n fuerte. Este patrÃ³n utiliza un registro centralÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
conocido como el "Service Locator" que, a demanda, devuelve elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
componente necesario para realizar una determinada tarea.Â 
Se basa en la creaciÃ³n de una clase, llamada ServiceLocator, que sabeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cÃ³mo crear las dependencias de otros tipos. A menudo, el localizador deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
servicios actÃºa como un depÃ³sito para objetos de servicios previamenteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
inicializados. Cuando se requiere uno de estos servicios, se solicita elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mismo llamando a un mÃ©todo determinado del ServiceLocator. En algunosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
casos, el mÃ©todo encargado de la localizaciÃ³n de servicios crea instanciasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de objetos a medida que se necesitan.Â 
Los defensores del patrÃ³n dicen que el enfoque simplifica las aplicacionesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
basadas en componentes, donde todas las dependencias se enumeranÂ  Â  Â  Â  Â  Â  Â  Â  Â 
limpiamente al comienzo de todo el diseÃ±o de la aplicaciÃ³n, lo que haceÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que la inyecciÃ³n de dependencias tradicional sea una forma mÃ¡s complejaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de conectar objetos. Los crÃ­ticos del patrÃ³n argumentan que el software esÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ¡s difÃ­cil de probar.Â 
La principal diferencia frente a la inyecciÃ³n de dependencias es que en esteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
caso hay una solicitud explÃ­cita para obtener la dependencia mientras queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
en la inyecciÃ³n de dependencias la obtenciÃ³n viene ya dada.Â 
Este patrÃ³n es otra implementaciÃ³n del principio de â€‹inversiÃ³n de controlÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
(IoC)â€‹.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         37Â Â 
Â 
Abstract FactoryÂ 
El propÃ³sito de Abstract Factory es proporcionar una interfaz para â€‹crearÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
familias de â€‹objetos relacionados, sin especificar clases concretas.Â  Â  Â  Â  Â  Â  Â  Â 
Normalmente, el cliente crea una implementaciÃ³n concreta de la fÃ¡bricaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
abstracta y luego utiliza la interfaz genÃ©rica de la misma para crear losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objetos concretos. El cliente no sabe (ni le importa) quÃ© objetos concretosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
obtiene de cada una de estas fÃ¡bricas internas, ya que utiliza solo lasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interfaces genÃ©ricas de sus productos. Este patrÃ³n separa los detalles de laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciÃ³n de un conjunto de objetos de su uso general y se basa enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la composiciÃ³n del objeto, ya que la creaciÃ³n de objetos se implementa enÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
los mÃ©todos expuestos en la interfaz de fÃ¡brica.Â 
La estructura tÃ­pica del patrÃ³n Abstract Factory es la siguiente:Â 
â— Cliente: la clase que llamarÃ¡ a la factorÃ­a adecuada ya que necesitaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
crear uno de los objetos que provee la factorÃ­a.Â 
â— Abstract Factory: es la definiciÃ³n de las interfaces de las factorÃ­as.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Debe de proveer un mÃ©todo para la obtenciÃ³n de cada objeto queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pueda crear.Â 
â— FactorÃ­as Concretas: estas son las diferentes familias de productos.Â  Â  Â  Â  Â  Â  Â  Â  Â 
Provee la instancia concreta del tipo de objeto que se encarga deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         38Â Â 
crear.Â 
â— Producto abstracto: definiciÃ³n de las interfaces para la familia deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
productos genÃ©ricos.Â 
â— Producto concreto: implementaciÃ³n de los diferentes productos.Â 
Este patrÃ³n es otra implementaciÃ³n del principio de â€‹inversiÃ³n de controlÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
(IoC)â€‹.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         39Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         40Â Â 
Factory MethodÂ 
Provee una interfaz o clase abstracta (creator) que permite encapsular laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
lÃ³gica de creaciÃ³n de los objetos en subclases y Ã©stas deciden quÃ© claseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
instanciar. Los objetos se crean a partir de un mÃ©todo (factory method) yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
no a travÃ©s de un constructor como se hace normalmente. AdemÃ¡s, losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
ConcreteCreators devuelven siempre la interfaz (Product), esto permite queÂ  Â  Â  Â  Â  Â  Â  Â  Â 
el cliente trate a los productos por igual, tengan una implementaciÃ³n uÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
otra.Â 
La estructura tÃ­pica del patrÃ³n Factory method es la siguiente:Â 
â— Product: definiciÃ³n de las interfaces para la familia de productosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
genÃ©ricos.Â 
â— ConcreteProduct: implementaciÃ³n de los diferentes productos.Â 
â— Creator: declara el factory method que se encargarÃ¡ de instanciarÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
nuevos objetos. Es importante que este mÃ©todo devuelva la interfazÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Product. Normalmente el Creator suele ser una clase abstracta conÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cierta lÃ³gica de negocio relacionada con los productos a crear.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Dependiendo de la instancia de producto que se devuelva, se puedeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
seguir un flujo u otro.Â 
â— ConcreteCreator:  crea la instancia del producto concreto.Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         41Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         42Â Â 
Patrones estructuralesÂ 
AdapterÂ 
El libro [GoF] indica que este patrÃ³n "proporciona una â€‹interfaz â€‹unificada aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
un conjunto de interfaces en un subsistema". Head First Design Patterns daÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la misma explicaciÃ³n y seÃ±ala que convierte la interfaz de una clase en otraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interfaz que los clientes esperan. El adaptador permite que las clasesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
puedan trabajar juntas ya que de otro modo, no podrÃ­an debido a tenerÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interfaces incompatibles.Â 
En el libro [GoF] se nos describen dos tipos principales de adaptadores:Â 
â— Adaptadores de clase: generalmente usan herencia mÃºltiple o variasÂ  Â  Â  Â  Â  Â  Â  Â  Â 
interfaces para implementarlo.Â 
â— Adaptadores de objetos: realizan las composiciones de objetos paraÂ  Â  Â  Â  Â  Â  Â  Â  Â 
adaptarlos.Â 
Un adaptador se puede considerar como la aplicaciÃ³n del principio deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
inversiÃ³n de dependencias (DIP)â€‹, cuando la clase de alto nivel define suÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
propia interfaz (adaptador) para el mÃ³dulo de bajo nivel (implementado porÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
una clase adaptada).Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         43Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         44Â Â 
Data Access Object (DAO)Â 
La soluciÃ³n original que propuso el patrÃ³n DAO se definiÃ³ en el libro CoreÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
J2EE Patterns: Best Practices and Design Strategies de la siguiente manera:Â 
â€œSe usa el Data Access Object (DAO) para â€‹abstraer y encapsular todo elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
acceso a la fuente de datosâ€‹. El DAO gestiona la conexiÃ³n con la fuente deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
datos para obtener y almacenar datosâ€.Â 
El problema que se resolviÃ³ con la abstracciÃ³n y la encapsulaciÃ³n de laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
fuente de datos, fue evitar que la aplicaciÃ³n dependiera de laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciÃ³n de la fuente de datos. Esto desacopla la capa de negocioÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de la fuente de datos.Â 
Aunque originariamente permitÃ­a protegerse frente a cambios en el motorÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de base de datos, el patrÃ³n DAO sigue siendo un patrÃ³n valioso y suÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
soluciÃ³n original, sigue siendo vÃ¡lida. En lugar de protegerse contra elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
impacto de un cambio improbable en el tipo de fuente de datos, el valorÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
estÃ¡ en su capacidad de prueba y su uso para estructurar el cÃ³digo yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mantenerlo limpio de cÃ³digo de acceso a datos.Â 
El patrÃ³n DAO encapsula las operaciones de acceso a los datos en unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interfaz implementada por una clase en concreto. Si se mockea esta clase,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
se pueden probar las clases de negocio sin hacer conexiones a la base deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
datos. La implementaciÃ³n concreta de un DAO utiliza API de bajo nivel paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
realizar las operaciones de acceso a datos.Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         45Â Â 
Â 
Â 
Query ObjectÂ 
Este patrÃ³n se puede consultar en el libro Patterns of EnterpriseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Application Architecture. Un Query Object es un â€‹intÃ©rprete [GoF], es decir,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
una estructura de objetos que puede â€‹formar una consulta â€‹SQLâ€‹. Puede crearÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
esta consulta haciendo referencia a clases y campos en lugar de tablas yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
columnas. De esta forma, quienes escriben las consultas pueden hacerloÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
independientemente del esquema de la base de datos y los cambios en elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
esquema, se pueden localizar en un solo lugar.Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         46Â Â 
DecoratorÂ 
El propÃ³sito de este patrÃ³n es el de asignar â€‹responsabilidades â€‹adicionalesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
a un objeto â€‹dinÃ¡micamenteâ€‹, proporcionando una alternativa flexible a laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
herencia para extender la funcionalidad.Â 
La estructura estÃ¡ compuesta por:Â 
â— Component: deï¬ne la interfaz que deben implementar los objetos aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
los que se les pueden aÃ±adir funcionalidades.Â 
â— ConcreteComponent: deï¬ne un objeto al cual se le pueden agregarÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
responsabilidades adicionales. Implementa la interfaz Component.Â 
â— Decorator: mantiene una referencia al Component asociado.Â  Â  Â  Â  Â  Â  Â 
Implementa la interfaz de la super clase Component, delegando en elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Component asociado. El Decorator, en general, aÃ±adeÂ  Â  Â  Â  Â  Â  Â 
comportamiento antes o despuÃ©s de un mÃ©todo que ya existe en elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Component.Â 
â— ConcreteDecorator: aÃ±ade responsabilidades al Component.Â 
Entre las ventajas de implementar este patrÃ³n, podemos encontrar:Â 
â— Es mÃ¡s flexible que la herencia.Â 
â— Permite aÃ±adir y eliminar responsabilidades en tiempo de ejecuciÃ³n.Â 
â— Evita la herencia con muchas clases y la herencia mÃºltiple.Â 
â— Limita la responsabilidad de los componentes para evitar clases conÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
excesivas responsabilidades en los niveles superiores de la jerarquÃ­a.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         47Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         48Â Â 
BridgeÂ 
Tiene como objetivo â€‹desacoplar la â€‹abstracciÃ³n de la â€‹implementaciÃ³nâ€‹.Â  Â  Â  Â  Â  Â  Â  Â  Â 
Permite que la abstracciÃ³n y la implementaciÃ³n se desarrollen de formaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
independiente a travÃ©s de un puente (bridge) entre ambas. El cÃ³digo delÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cliente podrÃ¡ acceder a la abstracciÃ³n sin preocuparse por la parte deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciÃ³n.Â 
Participantes:Â 
â— Abstraction: recibe por parÃ¡metro la interfaz que servirÃ¡ de puenteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
con las implementaciones y es la que se comunicarÃ¡ con el cliente.Â 
â— ConcreteAbstraction: puede trabajar con distintas implementacionesÂ  Â  Â  Â  Â  Â 
a travÃ©s de la interfaz.Â Â 
â— Implementator: declara una interfaz con sus respectivos mÃ©todosÂ  Â  Â  Â  Â  Â  Â  Â 
que serÃ¡n los que actÃºen de enlace entre la abstracciÃ³n y lasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciones.Â 
â— ConcreteImplementator: contiene cÃ³digo concreto sobre cadaÂ  Â  Â  Â  Â  Â 
implementaciÃ³n.Â 
Entre las ventajas de implementar este patrÃ³n podemos encontrar:Â 
â— El cliente siempre trabaja con abstracciones y nunca conÂ  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciones.Â 
â— Cumple con el principio Open/Closed ya que se pueden aÃ±adir nuevasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciones independientes unas de otras.Â 
â— Permite reducir el nÃºmero de subclases que si usaramos herenciaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pura.Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         49Â Â 
Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         50Â Â 
Patrones de comportamientoÂ 
CommandÂ 
El libro The Gang of Four [GoF] indica que se usa el patrÃ³n de ComandoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
para â€œâ€‹encapsular una â€‹solicitudâ€ como un objeto, permitiendo definir unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interfaz comÃºn para invocar acciones diversas.Â Â 
Simplificando, el objetivo de un comando es ejecutar una serie de accionesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
en su receptor (Receiver). El cliente crea un objeto Command yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
generalmente, le pasa el Receiver para poder acceder a Ã©l. Cuando el ClientÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
desea ejecutar el Command, se utiliza el Invoker que almacena elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Command y se encarga de iniciar su ejecuciÃ³n en algÃºn momento,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
invocando al mÃ©todo execute del Command.Â 
Esto permite aÃ±adir otras funcionalidades a las acciones comoÂ  Â  Â  Â  Â  Â  Â  Â  Â 
encolamiento, registro, acciones de deshacer o rehacer las operaciones,Â  Â  Â  Â  Â  Â  Â  Â  Â 
etc., gracias a â€‹desacoplarâ€‹ la â€‹solicitudâ€‹ de una acciÃ³n de su ejecuciÃ³n.Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         51Â Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         52Â Â 
Â 
Chain of ResponsibilityÂ 
El libro The Gang of Four [GoF] indica que se usa el patrÃ³n â€œevitar acoplarÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
el remitente de una solicitud a su receptor, al darle a â€‹mÃ¡s de un objeto laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
oportunidad de â€‹manejar la â€‹solicitudâ€‹. Se encadenan los objetos receptores yÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pasa la solicitud a lo largo de la cadena hasta que un receptor lo maneja.â€Â 
AquÃ­ se procesan una serie de receptores uno por uno (es decir, de formaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
secuencial). Una fuente iniciarÃ¡ este procesamiento. Con este patrÃ³n,Â  Â  Â  Â  Â  Â  Â  Â  Â 
constituimos una cadena donde cada uno de los objetos de receptoresÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
puede tener cierta lÃ³gica para manejar un tipo particular de objeto. Una vezÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que se realiza el procesamiento, si aÃºn hay algo pendiente, se puedeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
reenviar al siguiente receptor de la cadena.Â 
Cabe indicar que este tipo de patrÃ³n establece una jerarquÃ­a entre losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
receptores, pues los primeros en la cadena tienen prioridad sobre losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         53Â Â 
siguientes. Podemos agregar nuevos receptores en cualquier momento alÂ  Â  Â  Â  Â  Â  Â  Â  Â 
final de una cadena.Â 
Â 
By Vanderjoe - Own work, CC BY-SA 4.0, â€‹https://commons.wikimedia.org/w/index.php?curid=62530468Â 
Este patrÃ³n representa una implementaciÃ³n del concepto definido en elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
principio de â€‹responsabilidad Ãºnica (SRP)â€‹.Â 
Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         54Â Â 
StrategyÂ 
El libro The Gang of Four [GoF] indica que se usa este patrÃ³n para definirÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
una familia de â€‹algoritmos que se encapsulan cada uno de forma que seanÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
intercambiablesâ€‹. El patrÃ³n estrategia permite que el algoritmo varÃ­eÂ  Â  Â  Â  Â  Â  Â  Â  Â 
independientemente de un cliente a otro.Â 
La clave para aplicar el patrÃ³n Strategy es diseÃ±ar interfaces para laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
estrategia y su contexto, que sean lo suficientemente generales como paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
admitir una variedad de algoritmos. No deberÃ­a tener que cambiar laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
estrategia o la interfaz de contexto para admitir un nuevo algoritmo.Â Â 
SegÃºn el patrÃ³n de estrategia, los comportamientos de una clase no debenÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
heredarse. En su lugar, deben encapsularse utilizando interfaces. Esto esÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
compatible con el principio â€‹Open/Closed (OCP)â€‹, que propone que las clasesÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
deben estar abiertas para la extensiÃ³n pero cerradas para la modificaciÃ³n.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹Utilizando el patrÃ³n Estrategia en AdictosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
al Trabajo.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         55Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         56Â Â 
Template MethodÂ 
El libro The Gang of Four [GoF] indica que se usa este patrÃ³n para definir elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
esqueleto de un â€‹algoritmo en una operaciÃ³n, â€‹delegando algunos â€‹pasos aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
subclases. El mÃ©todo plantilla permite que las subclases redefinan ciertosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
pasos de un algoritmo sin cambiar la estructura del algoritmo.Â 
En un template method, definimos la estructura mÃ­nima o esencial de unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
algoritmo. Luego diferimos algunas funcionalidades (responsabilidades) aÂ  Â  Â  Â  Â  Â  Â 
las subclases. Como resultado, podemos redefinir ciertos pasos de unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
algoritmo manteniendo la estructura clave fija para ese algoritmo.Â 
En tiempo de ejecuciÃ³n, el algoritmo representado por el mÃ©todo deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
plantilla se ejecuta enviando el mensaje de plantilla a una instancia de unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de las subclases concretas. A travÃ©s de la herencia, el mÃ©todo de plantillaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
en la clase base comienza a ejecutarse delegando parte de los detalles deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
la implementaciÃ³n en las clases hijas. Este mecanismo garantiza que elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
algoritmo general siga los mismos pasos cada vez, al tiempo que permiteÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que los detalles de algunos pasos dependan de quÃ© instancia recibiÃ³ laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
solicitud original para ejecutar el algoritmo.Â 
Este patrÃ³n es un ejemplo de â€‹inversiÃ³n de control porque el cÃ³digo de altoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
nivel ya no determina quÃ© algoritmos ejecutar, en su lugar, se selecciona unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
algoritmo de nivel inferior en tiempo de ejecuciÃ³n.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         57Â Â 
Â 
By Vanderjoe - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=63155402Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹El patrÃ³n de diseÃ±o Template Methodâ€‹ enÂ 
Adictos al Trabajo.Â 
Â 
InterpreterÂ 
El libro [GoF] lo define de la siguiente manera:Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         58Â Â 
â€œDado un lenguaje, define una representaciÃ³n de su â€‹gramÃ¡tica junto con unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
intÃ©rprete que usa dicha representaciÃ³n para interpretar sentencias delÂ  Â  Â  Â  Â  Â  Â  Â  Â 
lenguaje.â€Â 
En otras palabras, el patrÃ³n define la gramÃ¡tica de un lenguaje particularÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de una manera orientada a objetos que puede ser evaluada por el propioÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
intÃ©rprete.Â 
Teniendo esto en cuenta, tÃ©cnicamente podrÃ­amos construir nuestraÂ  Â  Â  Â  Â  Â  Â  Â 
expresiÃ³n regular personalizada, un intÃ©rprete DSL personalizado oÂ  Â  Â  Â  Â  Â  Â  Â 
podrÃ­amos analizar cualquiera de los lenguajes humanos, construir Ã¡rbolesÂ  Â  Â  Â  Â  Â  Â  Â  Â 
de sintaxis abstracta y luego ejecutar la interpretaciÃ³n.Â 
El patrÃ³n intÃ©rprete, generalmente debe usarse cuando la gramÃ¡tica esÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
relativamente simple. De lo contrario, podrÃ­a ser difÃ­cil de mantener.Â 
Â 
By Vanderjoe - Own work, CC BY-SA 4.0,Â 
https://upload.wikimedia.org/wikipedia/commons/3/33/W3sDesign_Interpreter_Design_Pattern_UML.jpgÂ 
Â 
Ventajas e inconvenientes:Â 
â— Facilidad de cambiar y ampliar: puesto que el patrÃ³n usa clases paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
representar las reglas de la gramÃ¡tica, se puede usar la herencia paraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cambiar o extender Ã©sta.Â 
â— FÃ¡cil implementaciÃ³n:. las clases que definen los nodos del Ã¡rbolÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         59Â Â 
sintÃ¡ctico abstracto tienen implementaciones similares.Â Â 
â— Las gramÃ¡ticas complejas son difÃ­ciles de mantener ya que define, alÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
menos, una clase para cada regla de la gramÃ¡tica. De ahÃ­ que lasÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
gramÃ¡ticas que contienen muchas reglas puedan ser difÃ­ciles deÂ  Â  Â  Â  Â  Â  Â  Â  Â 
controlar y mantener.Â 
Para mÃ¡s detalle, ver el artÃ­culo â€‹PatrÃ³n IntÃ©rpreteâ€‹ en Adictos al Trabajo.Â 
ObserverÂ 
Este patrÃ³n define una â€‹dependencia entre objetos de forma que cuando unÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objeto â€‹cambia su â€‹estadoâ€‹, todos los objetos que dependen de Ã©l sonÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
notificadosâ€‹ y pueden reaccionar si lo desean a una acciÃ³n.Â 
El objeto de datos, o Subject, provee de mÃ©todos para que cualquier objetoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Observer pueda suscribirse o cancelar la suscripciÃ³n, pasando unaÂ  Â  Â  Â  Â  Â  Â  Â  Â 
referencia de sÃ­ mismo al Observable o Subject. El Subject mantiene unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
lista con las referencias a sus Observers para notificarles cada cambio deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
estado (si procede).Â Â 
Los Observers a su vez estÃ¡n obligados a implementar los mÃ©todos queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
utiliza el Subject para notificar a sus Observers de los cambios que sufreÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
para que todos ellos tengan la oportunidad de reaccionar a ese cambio deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
manera que, cuando se produzca un cambio en el Subject, Ã©ste puedaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
recorrer la lista de Observers notificando a cada uno.Â 
Este patrÃ³n es aplicable cuando:Â 
â— Una abstracciÃ³n tiene dos puntos de vista dependientes uno del otro.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Encapsular estos puntos de vista en objetos separados permiteÂ  Â  Â  Â  Â  Â  Â  Â  Â 
cambiarlos y reutilizarlos.Â 
â— Un cambio en un objeto requiere cambiar otros y no sabemosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cuÃ¡ntos objetos van a cambiar.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         60Â Â 
â— Un objeto deberÃ­a poder notificar a otros sin saber quiÃ©nes son.Â 
Â 
Entre las ventajas de utilizar este patrÃ³n encontramos:Â 
â— Podemos modificar el Subject y los Observers de formaÂ  Â  Â  Â  Â  Â  Â  Â  Â 
independiente al estar desacoplados.Â 
â— Nos permite reutilizar tanto Observers como Subjects.Â 
â— Respeta el principio Open/Closed, permitiendo aÃ±adir Observers sinÂ  Â  Â  Â  Â  Â  Â  Â 
modificar los Subjects.Â 
â— Reduce el acoplamiento entre Subject y Observer, ya que un SubjectÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
sÃ³lo conoce su lista de Observers a travÃ©s de un interfaz pero no laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
clase concreta.Â 
â— El Subject se comunica con los Observers mediante broadcast oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
difusiÃ³n.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         61Â Â 
Â 
StateÂ 
SegÃºn el libro de [GoF], el patrÃ³n State â€œpermite que un objeto â€‹modifiqueÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
su â€‹comportamiento cada vez que â€‹cambie su â€‹estado interno. ParecerÃ¡ queÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
cambia la clase del objetoâ€. Podemos dibujar el comportamiento de nuestroÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
objeto como si se tratase de una â€œmÃ¡quina de estados finitaâ€.Â 
El patrÃ³n estado se usa para encapsular todo el comportamiento variableÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
de un objeto en funciÃ³n de su estado interno. Es una manera mÃ¡s limpia deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
construir un objeto que cambia su comportamiento en tiempo de ejecuciÃ³nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
sin recurrir a declaraciones condicionales, respetando el principioÂ  Â  Â  Â  Â  Â  Â  Â 
Open/Closed y el Single Responsibility Principle, ya que cada estado estÃ¡Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
representado por una clase que implementa una interfaz. Esto facilita laÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mantenibilidad del cÃ³digo.Â Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         62Â Â 
Â 
Participantes:Â 
â— Context:Â 
â—‹ Define la interfaz que serÃ¡ usada por los clientes.Â 
â—‹ Mantiene una instancia que representa el estado actual delÂ  Â  Â  Â  Â  Â  Â  Â  Â 
objeto.Â 
â— State:Â 
â—‹ Define una interfaz para encapsular el comportamientoÂ  Â  Â  Â  Â  Â  Â 
asociado con un determinado estado del Context.Â 
â— Subclases de State:Â 
â—‹ Cada subclase implementa un comportamiento asociado a losÂ  Â  Â  Â  Â  Â  Â  Â 
diferentes estados del Context.Â 
Â 
Principales ventajas:Â 
â— Separa el comportamiento del objeto por estados. Al aislar elÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
comportamiento en estados y convertirlo en clases separadas, nosÂ  Â  Â  Â  Â  Â  Â  Â  Â 
permite fÃ¡cilmente aÃ±adir nuevos estados y definir las transicionesÂ  Â  Â  Â  Â  Â  Â  Â  Â 
hacia ellos.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         63Â Â 
â— Hace explÃ­citas las transiciones entre estados. Podemos evitar lasÂ  Â  Â  Â  Â  Â  Â  Â  Â 
transiciones a estados internos inconsistentes, ya que lasÂ  Â  Â  Â  Â  Â  Â  Â 
transiciones son atÃ³micas para el Context.Â 
â— Los objetos State pueden compartirse por diferentes contextos.Â  Â  Â  Â  Â  Â  Â  Â 
Siempre que estos no tengan estado interno, comportÃ¡ndose comoÂ  Â  Â  Â  Â  Â  Â  Â  Â 
objetos del patrÃ³n Flyweight (sin estado intrÃ­nseco y conÂ  Â  Â  Â  Â  Â  Â  Â  Â 
comportamiento).Â 
Â 
Â 
VisitorÂ 
Permite â€‹aÃ±adir â€‹funcionalidad â€‹sin necesidad de â€‹cambiar las clases de losÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
elementos en los que va a ejecutarse, a travÃ©s de los denominados Visitors.Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
El patrÃ³n sugiere que situemos el comportamiento en una nueva claseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
llamada Visitor, en vez de integrarlo todo en la clase base. Cada vez que seÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         64Â Â 
necesite aÃ±adir un nuevo comportamiento, se harÃ¡ en una nuevaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
implementaciÃ³n de un Visitor y la clase base solo tiene que aceptar oÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
delegar este comportamiento en el Visitor correspondiente.Â 
Participantes:Â 
â— Visitor: interfaz que declara una serie de mÃ©todos, normalmenteÂ  Â  Â  Â  Â  Â  Â  Â  Â 
llamados visit y que reciben como parÃ¡metro elementos concretos aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
los que se les va a aÃ±adir funcionalidad. Se deben crear tantosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
mÃ©todos visit como clases concretas tengamos por lo que al llamarseÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
igual, se diferenciarÃ¡n por la firma del mÃ©todo.Â 
â— ConcreteVisitor: implementan la interfaz Visitor y definen lasÂ  Â  Â  Â  Â  Â  Â  Â 
funcionalidades que se aplicarÃ¡n a los elementos o clase base. AquÃ­Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
es donde se debe definir el comportamiento que debe tener nuestraÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
clase base. En caso de querer hacer alguna modificaciÃ³n, se harÃ¡Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
siempre en los ConcreteVisitors y nunca directamente en elÂ  Â  Â  Â  Â  Â  Â  Â  Â 
elemento. Recordemos que la clase base Ãºnicamente delega al VisitorÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
que realice estas modificaciones.Â 
â— Element: interfaz que declara un mÃ©todo que acepta los Visitors.Â 
â— ConcreteElement: clase base que implementa la interfaz Element yÂ  Â  Â  Â  Â  Â  Â  Â  Â 
tiene como objetivo redirigir al Visitor concreto que se encargarÃ¡ deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
aÃ±adir el comportamiento especÃ­fico.Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         65Â Â 
Â 
IteratorÂ 
Provee una forma de acceder secuencialmente a los elementos de unaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
colecciÃ³n sin necesidad de exponer su representaciÃ³n interna. El objetivoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
principal es el de extraer el comportamiento de una colecciÃ³n en un objetoÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
llamado Iterator que se encargarÃ¡ de tener toda la informaciÃ³n necesariaÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
para manipularla. El cliente estÃ¡ siempre trabajando con abstracciones aÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
travÃ©s de sus interfaces. Esto le permite hacer uso de varios tipos deÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
colecciones e iteradores con el mismo cÃ³digo.Â 
Participantes:Â 
â— Client: interactÃºa tanto con Iterator como Iterable a travÃ©s de susÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
interfaces para no acoplarse a clases concretas.Â 
â— Iterable: declara un mÃ©todo responsable de instanciar el objetoÂ  Â  Â  Â  Â  Â  Â  Â  Â 
Iterator. Importante que el mÃ©todo devuelva la interfaz para noÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         66Â Â 
acoplarnos a implementaciones.Â 
â— ConcreteIterable: implementa la interfaz e instancia el IteratorÂ  Â  Â  Â  Â  Â  Â  Â 
concreto que iterarÃ¡ sobre una colecciÃ³n especÃ­fica.Â 
â— Iterator: declara los mÃ©todos necesarios para recorrer la colecciÃ³n.Â  Â  Â  Â  Â  Â  Â  Â  Â 
Puede declarar varios mÃ©todos como remove, getFirst, currentItem,Â  Â  Â  Â  Â  Â  Â  Â 
size, next, etc.Â 
â— ConcreteIterator: implementa los mÃ©todos declarados en la interfaz yÂ  Â  Â  Â  Â  Â  Â  Â  Â 
es responsable de gestionar la posiciÃ³n de la iteraciÃ³n.Â 
Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         67Â Â 
Â 
Â 
Â 
Â 
PRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWAREÂ         68Â Â 
BibliografÃ­aÂ 
Â 
Estas son las fuentes que hemos consultado y en las que nos hemosÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
basado para la redacciÃ³n de este material:Â 
â— The 4 rules of simple design:Â 
https://blog.jbrains.ca/permalink/the-four-elements-of-simple-desig
nÂ 
https://blog.thecodewhisperer.com/permalink/putting-an-age-old-ba
ttle-to-restÂ 
â€‹Understanding the Four Rules of Simple Design, Corey HainesÂ 
â— The Clean Code Blog by Robert C. Martin (Uncle Bob):Â 
https://blog.cleancoder.comÂ 
â— Head First Design Patterns. Eric Freeman & Elisabeth Freeman.Â 
â— Design Patterns: Elements of Reusable Object-Oriented Software.Â 
Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides. [GoF]Â 
â— Core J2EE Patterns: Best Practices and Design Strategies. DeepakÂ 
Alur, John Crupi, Dan Malks.Â 
â— Patterns of Enterprise Application Architecture. Martin Fowler con laÂ 
colaboraciÃ³n de David Rice, Matthew Foemmel, Edward Hieatt,Â 
Robert Mee y Randy Stafford.Â 
Â 
PÃ¡gina 50
En esta guÃ­a hemos visto los 
principales principios y patrones 
de diseÃ±o. Estas prÃ¡cticas no son 
mÃ¡s que la experiencia de los 
profesionales del sector, reunidas 
en una serie de recetas o buenas 
prÃ¡cticas para que el software 
crezca y evolucione de una forma 
sostenible.
Hemos visto los malos olores 
que puede desprender el cÃ³digo 
y como profesionales, es nuestra 
responsabilidad irlos solucionando 
poco a poco y no ir generando una 
deuda tÃ©cnica que sea como una 
bola de nieve.
Hacer de boy scout va implÃ­cito 
en nuestras tareas del dÃ­a a dÃ­a 
y es lo que va a permitir que las 
futuras entregas de valor sean 
rÃ¡pidas, de calidad y que no rompan 
funcionalidad existente.
A menudo se pide permiso a 
managers, product owners o 
gente de desarrollo de negocio 
para acometer estas tareas 
asumiendo que es su decisiÃ³n, ya 
que son tareas que conllevan una 
inversiÃ³n de tiempo. Esto es un 
error de base. La construcciÃ³n de 
software es responsabilidad de 
los desarrolladores de software, lo 
mismo que el estado del software.
Conocer los patrones creacionales,  
estructurales y de comportamiento 
nos van a proporcionar herramientas 
vÃ¡lidas para entregar valor constante 
y de calidad.
Conocer las buenas prÃ¡cticas y 
los principios de diseÃ±o nos va 
a proporcionar las herramientas 
necesarias para afrontar nuevos 
desarrollos con seguridad, sabiendo 
quÃ© decisiones tomar, cuÃ¡les aplazar 
y cÃ³mo construir software sobre 
pilares sÃ³lidos, que cambio tras 
cambio se mantengan firmes.
Lecciones 
aprendidas
con esta guÃ­aPRINCIPIOS Y PATRONES DEL DESARROLLO DE SOFTWARE
En Autentia proporcionamos soporte al desarrollo de software y 
ayudamos a la transformaciÃ³n digital de grandes organizaciones siendo 
referentes en eficacia y buenas prÃ¡cticas. Te invito a que te informes 
sobre los servicios profesionales de Autentia y el soporte que podemos 
proporcionar para la transformaciÃ³n digital de tu empresa.
Â¡Conoce mÃ¡s!
SOPORTE A DESARROLLO
Construimos entornos sÃ³lidos para 
los proyectos, trabajando a diario 
con los equipos de desarrollo.
AUDITORÃA DE DESARROLLO
Analizamos la calidad tÃ©cnica de 
tu producto y te ayudamos a 
recuperar la productividad 
perdida.
ACOMPAÃ‘AMIENTO AGILE
Ayudamos a escalar modelos Ã¡giles 
en las organizaciones.
FORMACIÃ“N
Formamos empresas, con clases 
impartidas por desarrolladores 
profesionales en activo.
DISEÃ‘O DE PRODUCTO Y UX
Convertimos tus ideas en productos 
digitales de valor para los usuarios 
ï¬nales.
SOFTWARE A MEDIDA
Desarrollamos aplicaciones web y 
mÃ³viles. Fullstack developers, 
expertos en backend.
Expertos en creaciÃ³n de
software de calidad
DiseÃ±amos productos digitales y experiencias a medida
www.autentia.com  
info@autentia.com | T. 91  675 33 06  
Â¡SÃ­guenos en nuestros canales!
