jjj!cXTefbaXWhVTV\ba!Vb
`


(
¬£
XW
!


ATSTbSTR^\_dcPS^aPb


Kurose


Ross


Redes
de
computadoras
es
el
principal
libro
de
texto
en
el


aprendizaje
de
los
aspectos
b√°sicos
de
redes
.
Los
profesores


Jim
Kurose
y
Keith
Ross
hacen
una
presentaci√≥n
muy
atrac-


tiva
de
todos
los
temas
,
utilizando
un
enfoque
desde
arriba


hacia
abajo
en
el
tratamiento
de
redes
e
Internet
.


Esta
edici√≥n
conserva
el
√©nfasis
original
sobre
los
para-


digmas
de
capa
de
aplicaci√≥n
,
la
programaci√≥n
de
aplicacio-


nes
y
los
protocolos
de
capa
superior
,
fomentando
la
trans-


misi√≥n
de
la
experiencia
con
conceptos
sobre
protocolos
y


redes
.


Este
libro
incluye
una
suscripci√≥n
de
seis
meses
al
si-


tio
web
que
complementa
al
libro
.
Esta
suscripci√≥n
gratuita
 

proporciona
complementos
de
apoyo
al
estudiante
,
inclu-


yendo
:


U√ä
"
¬òVi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬è>L¬ú√Ä
>
√å¬ú√Ä¬à¬ú√äV¬ú¬ò√ä7¬à√Äi√É
¬Ö
>
√Ä¬é
¬∞


U√ä
 
√ïi√õi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬´√Ä¬ú}√Ä>¬ì>V¬à¬ù¬ò
¬∞


U√ä
¬´¬´¬èi√å√É√äi¬ò√ä>√õ
>
√ä¬µ√ïi√ä¬à¬è√ï√É√å√Ä>¬ò√ä`¬à√õi√Ä√É¬ú√É√äV¬ú¬òVi¬´√å¬ú√É√äV¬è>√õi√ä√ä


de
las
redes
.


U√ä


√ïi√É√å¬à¬ú¬ò>√Ä¬à¬ú√É√ä¬à¬ò√åi√Ä
>
V√å¬à√õ¬ú√É√ä¬µ√ïi√ä¬èi√ä
>
√û√ï`>√Ä?¬ò√ä
>
√äi√õ>¬è√ï
>
√Ä√ä√ä


su
grado
de
comprensi√≥n
de
los
temas
estudiados
.


U√ä
¬ò√åi√Äi√É>¬ò√åi√É√äi¬ò¬è>Vi√É√ä
>
√ä¬ú√å√Ä¬ú√É√ä√ÄiV√ï√Ä√É¬ú√É
¬∞


James
F
.
Kurose


i¬à√å
¬Ö
√ä7
¬∞
√ä,¬ú√É√É


ATSTbSTR^\_dcPS^aPb


D]T]U^`dTSTbRT]ST]cT


(
¬£
XW\V\¬âa


>
ca^b[XQa^bSTX]cTa{b
)


Fred
Halsall


Redes
de
computadores
e
Internet


*

,-
"
√ä

-
"
√ä7

-

9


-
	 
√ä¬ô√án¬án{¬á√án√ì¬ô¬á√§n√é¬á√é

 
¬àV¬ú¬è?√É√ä
	
>
√ÄV¬à>√ä6?√¢¬µ√ïi√¢


Redes
de
computadores
y
arquitecturas


de
comunicaciones
.
Supuestos
pr√°cticos


*

,-
"
√ä
*
,
 
/


√ä


-
	 
√ä¬ô√án¬án{¬á√ì√§x¬á{√à√§√á¬á√§


redes.indd
  
1
26/3/10
  
08:21:18ACCESO
EN
L√çNEA
a
Redes
de
computadoras
:
un
enfoque
descendente
,
5.¬™
edici√≥n
 

Gracias
por
comprar
una
copia
nueva
de
Redes
de
computadoras
:
un
enfoque
descendente
,
x
¬∞
¬ß√äi`¬àV¬à¬ù¬ò
¬∞


-√ï√ä¬è¬àL√Ä¬ú√ä¬à¬òV¬è√ï√ûi√ä√Éi¬à√É√ä¬ìi√Éi√É√ä`i√ä
>
VVi√É¬ú√ä¬´√Äi¬´>}>`¬ú√ä>¬è√ä√É¬à√å¬à¬ú√ä√úiL√äi¬ò√ä¬à¬ò}¬èj√É√ä¬µ√ïi√äV¬ú¬ì¬´¬èi¬ìi¬ò√å
>
√ä>¬è√ä¬è¬àL√Ä¬ú
¬∞
√ä

√É√å
>


suscripci√≥n
gratuita
le
proporciona
acceso
completo
a
todas
las
√°reas
de
apoyo
al
estudiante
,
incluyendo
:


U√ä
"
¬òVi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬è>L¬ú√Ä
>
√å¬ú√Ä¬à¬ú√äV¬ú¬ò√ä7¬à√Äi√É
¬Ö
>
√Ä¬é
¬∞


U√ä
 
√ïi√õi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬´√Ä¬ú}√Ä>¬ì>V¬à¬ù¬ò
¬∞


U√ä
¬´¬´¬èi√å√É√äi¬ò√ä>√õ
>
√ä¬µ√ïi√ä¬à¬è√ï√É√å√Ä>¬ò√ä`¬à√õi√Ä√É¬ú√É√äV¬ú¬òVi¬´√å¬ú√É√äV¬è>√õi√ä`i√ä¬è>√É√ä√Äi`i√É
¬∞


U√ä


√ïi√É√å¬à¬ú¬ò>√Ä¬à¬ú√É√ä¬à¬ò√åi√Ä
>
V√å¬à√õ¬ú√É√ä¬µ√ïi√ä¬èi√ä
>
√û√ï`>√Ä?¬ò√ä
>
√äi√õ>¬è√ï
>
√Ä√ä√É√ï√ä}√Ä>`¬ú√ä`i√äV¬ú¬ì¬´√Äi¬ò√É¬à¬ù¬ò√ä`i√ä¬è¬ú√É√ä√åi¬ì>√É√äi√É√å√ï`¬à>`¬ú√É
¬∞


U√ä
¬ò√åi√Äi√É>¬ò√åi√É√äi¬ò¬è>Vi√É√ä
>
√ä¬ú√å√Ä¬ú√É√ä√ÄiV√ï√Ä√É¬ú√É
¬∞


Por
favor
,
lea
a
continuaci√≥n
las
instrucciones
de
registro
.


Para
acceder
por
primera
vez
al
sitio
web
de
acompa√±amiento
de
Redes
de
computadoras
:
un
enfoque
descen-


dente
,
x
¬∞
¬ß√äi`¬àV¬à¬ù¬ò
:


/i¬ò`√Ä?√ä¬µ√ïi√ä√Äi}¬à√É√å√Ä
>
√Ä√Éi√äi¬ò√ä¬è¬â¬òi
>
√ä¬ìi`¬à>¬ò√åi√ä√ï¬ò>√äV¬ú¬ì¬´√ï√å>`¬ú√Ä
>
√ä¬µ√ïi√ä`¬à√É¬´¬ú¬ò}>√ä`i√äV¬ú¬òi√ù¬à¬ù¬ò√ä
>
√ä¬ò√åi√Ä¬òi√å√ä√û√ä¬µ√ïi√ä√åi¬ò-


ga
instalado
un
explorador
web
.
El
proceso
le
llevar√°
un
par
de
minutos
y
s√≥lo
lo
tendr√°
que
hacer
una
vez
.


¬£
¬∞
√ä
VVi`>√ä
>
√ähttp://www.aw.com
/
kurose_ross


√ì
¬∞
√ä
>}>√äV¬è¬àV√äi¬ò√äStudent
Resources
.


√é
¬∞
√ä
>}>√äV¬è¬àV√äi¬ò√äi¬è√äL¬ú√å¬ù¬ò√äRegister
.


{
¬∞
√ä

¬ò√ä¬è>√ä¬´?}¬à¬ò>√ä`i√ä√Äi}¬à√É√å√Ä¬ú]√ä¬à¬ò√å√Ä¬ú`√ï√¢V
>
√ä√É√ï√äV¬ù`¬à}¬ú√ä`i√ä
>
VVi√É¬ú√ä`i√äi√É√å√ï`¬à>¬ò√åiI√ä¬µ√ïi√äi¬òV¬ú¬ò√å√Ä
>
√Ä?√ä`iL>¬ç¬ú√ä`i√ä¬è>√ä√ä


√ä
v√Ä>¬ò¬ç>√ä`i√ä√å¬à¬ò√å
>
√ä√Äi¬ì¬ú√õ¬àL¬èi
¬∞
√ä
 
¬ú√äi√ÉV√Ä¬àL
>
√ä¬è¬ú√É√ä}√ï¬à¬ú¬òi√É
¬∞
√ä*√ïi`i√ä√ï√å¬à¬è¬à√¢
>
√Ä√ä¬èi√å√Ä
>
√É√ä¬ì¬à¬ò√ñ√ÉV√ï¬è>√É√ä¬ú√ä¬ì>√û√ñ√ÉV√ï¬è>√É
¬∞


x
¬∞
√ä
-¬à}>√ä¬è>√É√ä¬à¬ò√É√å√Ä√ïVV¬à¬ú¬òi√É√ä¬à¬ò`¬àV>`>√É√äi¬ò√ä¬´>¬ò√å>¬è¬è>
¬∞
√ä-¬à√ä¬òiVi√É¬à√å
>
√ä
>
√û√ï`>√äi¬ò√äV√ï>¬è¬µ√ï¬ài√Ä√ä¬ì¬ú¬ìi¬ò√å¬ú√ä`√ï√Ä>¬ò√åi√äi¬è√ä¬´√Ä¬úVi√É¬ú√ä

 
de
registro
,
simplemente
haga
clic
en
el
icono
Need
Help
?


√à
¬∞
√ä
1¬ò>√ä√õi√¢√ä¬µ√ïi√ä√É√ï√ä¬ò¬ú¬ìL√Äi√ä`i√ä√ï√É√ï
>
√Ä¬à¬ú√ä¬≠login
name
¬Æ
√ä√û√ä√É√ï√äV¬ú¬ò√å√Ä
>
√Éi¬ö>√ä¬≠password
)
est√©n
conÔ¨Årmados
,
podr√°
 
 
comenzar
a
utilizar
el
sitio
web
de
acompa√±amiento
de
Redes
de
computadoras
:
un
enfoque
descendente
,
 

√ä
x
¬∞
¬ß√äi`¬àV¬à¬ù¬ò
¬∞


C√≥mo
salir
despu√©s
de
haberse
registrado
:


-¬ù¬è¬ú√äi√É√ä¬òiVi√É
>
√Ä¬à¬ú√ä√Äi}¬à√É√å√Ä
>
√Ä√Éi√ä√ï¬ò>√ä√õi√¢√äi¬ò√äi√É√åi√ä√É¬à√å¬à¬ú√ä√úiL
¬∞
√ä


1¬ò>√ä√õi√¢√ä¬µ√ïi√ä√Éi√ä
¬Ö
>
√û
>
√ä√Äi}¬à√É√å√Ä>`¬ú]√ä¬´¬ú`√Ä?√ä¬à¬ò¬àV¬à>√Ä√ä√ï¬ò>√ä√Éi√É¬à¬ù¬ò√ä√É¬ài¬ì¬´√Äi√ä¬µ√ïi√ä¬è¬ú√ä`i√Éii√ä
>
VVi`¬ài¬ò`¬ú√ä
>


http://www.aw.com/kurose_ross
y
proporcionando
su
nombre
de
usuario
y
su
contrase√±a
cuando


se
le
soliciten
.


I¬ì¬´¬ú√Ä√å>¬ò√åi\√äi¬è√äV¬ù`¬à}¬ú√ä`i√ä
>
VVi√É¬ú√ä√É¬ù¬è¬ú√ä√Éi√ä¬´√ïi`i√ä√ï√å¬à¬è¬à√¢
>
√Ä√ä√ï¬ò>√ä√õi√¢
¬∞
√ä

√É√å
>
√ä√É√ï√ÉV√Ä¬à¬´V¬à¬ù¬ò√äi√É√ä√õ?¬è¬à`>√ä¬´>√Ä
>
√ä√ï¬ò√ä¬´i√Ä¬à¬ú`¬ú√ä


`
i√ä√Éi¬à√É√ä¬ìi√Éi√É√ä`i√É`i√äi¬è√ä¬ì¬ú¬ìi¬ò√å¬ú√ä`i√ä√É√ï√ä
>
V√å¬à√õ
>
V¬à¬ù¬ò√ä√û√ä¬ò¬ú√äi√É√ä√å√Ä>¬ò√Évi√Ä¬àL¬èi
¬∞
√ä-¬à√äi√É√åi√äV¬ù`¬à}¬ú√ä`i√ä
>
VVi√É¬ú√ä√û
>
√ä
¬Ö
>
√ä√É¬à`¬ú√ä


√ï√å¬à¬è¬à√¢>`¬ú]√äi√É√ä¬´¬ú√É¬àL¬èi√ä¬µ√ïi√ä√û
>
√ä¬ò¬ú√ä√Éi
>
√ä√õ?¬è¬à`¬ú
¬∞
√ä-¬à√ä√Éi√äi¬òV√ïi¬ò√å√Ä
>
√äi¬ò√äi√É√åi√äV
>
√É¬ú]√ä¬´√ïi`i√ä>`¬µ√ï¬à√Ä¬à√Ä√ä√ï¬ò>√ä√É√ï√ÉV√Ä¬à¬´V¬à¬ù¬ò√ä
>
VVi-


diendo
a
http://www.aw.com/kurose_ross
y
siguiendo
las
instrucciones
mostradas
en
pantalla
.


redes.indd
  
2
26/3/10
  
08:21:18ACCESO
EN
L√çNEA
a
Redes
de
computadoras
:
un
enfoque
descendente
,
5.¬™
edici√≥n
 

Gracias
por
comprar
una
copia
nueva
de
Redes
de
computadoras
:
un
enfoque
descendente
,
x
¬∞
¬ß√äi`¬àV¬à¬ù¬ò
¬∞


-√ï√ä¬è¬àL√Ä¬ú√ä¬à¬òV¬è√ï√ûi√ä√Éi¬à√É√ä¬ìi√Éi√É√ä`i√ä
>
VVi√É¬ú√ä¬´√Äi¬´>}>`¬ú√ä>¬è√ä√É¬à√å¬à¬ú√ä√úiL√äi¬ò√ä¬à¬ò}¬èj√É√ä¬µ√ïi√äV¬ú¬ì¬´¬èi¬ìi¬ò√å
>
√ä>¬è√ä¬è¬àL√Ä¬ú
¬∞
√ä

√É√å
>


suscripci√≥n
gratuita
le
proporciona
acceso
completo
a
todas
las
√°reas
de
apoyo
al
estudiante
,
incluyendo
:


U√ä
"
¬òVi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬è>L¬ú√Ä
>
√å¬ú√Ä¬à¬ú√äV¬ú¬ò√ä7¬à√Äi√É
¬Ö
>
√Ä¬é
¬∞


U√ä
 
√ïi√õi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬´√Ä¬ú}√Ä>¬ì>V¬à¬ù¬ò
¬∞


U√ä
¬´¬´¬èi√å√É√äi¬ò√ä>√õ
>
√ä¬µ√ïi√ä¬à¬è√ï√É√å√Ä>¬ò√ä`¬à√õi√Ä√É¬ú√É√äV¬ú¬òVi¬´√å¬ú√É√äV¬è>√õi√ä`i√ä¬è>√É√ä√Äi`i√É
¬∞


U√ä


√ïi√É√å¬à¬ú¬ò>√Ä¬à¬ú√É√ä¬à¬ò√åi√Ä
>
V√å¬à√õ¬ú√É√ä¬µ√ïi√ä¬èi√ä
>
√û√ï`>√Ä?¬ò√ä
>
√äi√õ>¬è√ï
>
√Ä√ä√É√ï√ä}√Ä>`¬ú√ä`i√äV¬ú¬ì¬´√Äi¬ò√É¬à¬ù¬ò√ä`i√ä¬è¬ú√É√ä√åi¬ì>√É√äi√É√å√ï`¬à>`¬ú√É
¬∞


U√ä
¬ò√åi√Äi√É>¬ò√åi√É√äi¬ò¬è>Vi√É√ä
>
√ä¬ú√å√Ä¬ú√É√ä√ÄiV√ï√Ä√É¬ú√É
¬∞


Por
favor
,
lea
a
continuaci√≥n
las
instrucciones
de
registro
.


Para
acceder
por
primera
vez
al
sitio
web
de
acompa√±amiento
de
Redes
de
computadoras
:
un
enfoque
descen-


dente
,
x
¬∞
¬ß√äi`¬àV¬à¬ù¬ò
:


/i¬ò`√Ä?√ä¬µ√ïi√ä√Äi}¬à√É√å√Ä
>
√Ä√Éi√äi¬ò√ä¬è¬â¬òi
>
√ä¬ìi`¬à>¬ò√åi√ä√ï¬ò>√äV¬ú¬ì¬´√ï√å>`¬ú√Ä
>
√ä¬µ√ïi√ä`¬à√É¬´¬ú¬ò}>√ä`i√äV¬ú¬òi√ù¬à¬ù¬ò√ä
>
√ä¬ò√åi√Ä¬òi√å√ä√û√ä¬µ√ïi√ä√åi¬ò-


ga
instalado
un
explorador
web
.
El
proceso
le
llevar√°
un
par
de
minutos
y
s√≥lo
lo
tendr√°
que
hacer
una
vez
.


¬£
¬∞
√ä
VVi`>√ä
>
√ähttp://www.aw.com
/
kurose_ross


√ì
¬∞
√ä
>}>√äV¬è¬àV√äi¬ò√äStudent
Resources
.


√é
¬∞
√ä
>}>√äV¬è¬àV√äi¬ò√äi¬è√äL¬ú√å¬ù¬ò√äRegister
.


{
¬∞
√ä

¬ò√ä¬è>√ä¬´?}¬à¬ò>√ä`i√ä√Äi}¬à√É√å√Ä¬ú]√ä¬à¬ò√å√Ä¬ú`√ï√¢V
>
√ä√É√ï√äV¬ù`¬à}¬ú√ä`i√ä
>
VVi√É¬ú√ä`i√äi√É√å√ï`¬à>¬ò√åiI√ä¬µ√ïi√äi¬òV¬ú¬ò√å√Ä
>
√Ä?√ä`iL>¬ç¬ú√ä`i√ä¬è>√ä√ä


√ä
v√Ä>¬ò¬ç>√ä`i√ä√å¬à¬ò√å
>
√ä√Äi¬ì¬ú√õ¬àL¬èi
¬∞
√ä
 
¬ú√äi√ÉV√Ä¬àL
>
√ä¬è¬ú√É√ä}√ï¬à¬ú¬òi√É
¬∞
√ä*√ïi`i√ä√ï√å¬à¬è¬à√¢
>
√Ä√ä¬èi√å√Ä
>
√É√ä¬ì¬à¬ò√ñ√ÉV√ï¬è>√É√ä¬ú√ä¬ì>√û√ñ√ÉV√ï¬è>√É
¬∞


x
¬∞
√ä
-¬à}>√ä¬è>√É√ä¬à¬ò√É√å√Ä√ïVV¬à¬ú¬òi√É√ä¬à¬ò`¬àV>`>√É√äi¬ò√ä¬´>¬ò√å>¬è¬è>
¬∞
√ä-¬à√ä¬òiVi√É¬à√å
>
√ä
>
√û√ï`>√äi¬ò√äV√ï>¬è¬µ√ï¬ài√Ä√ä¬ì¬ú¬ìi¬ò√å¬ú√ä`√ï√Ä>¬ò√åi√äi¬è√ä¬´√Ä¬úVi√É¬ú√ä

 
de
registro
,
simplemente
haga
clic
en
el
icono
Need
Help
?


√à
¬∞
√ä
1¬ò>√ä√õi√¢√ä¬µ√ïi√ä√É√ï√ä¬ò¬ú¬ìL√Äi√ä`i√ä√ï√É√ï
>
√Ä¬à¬ú√ä¬≠login
name
¬Æ
√ä√û√ä√É√ï√äV¬ú¬ò√å√Ä
>
√Éi¬ö>√ä¬≠password
)
est√©n
conÔ¨Årmados
,
podr√°
 
 
comenzar
a
utilizar
el
sitio
web
de
acompa√±amiento
de
Redes
de
computadoras
:
un
enfoque
descendente
,
 

√ä
x
¬∞
¬ß√äi`¬àV¬à¬ù¬ò
¬∞


C√≥mo
salir
despu√©s
de
haberse
registrado
:


-¬ù¬è¬ú√äi√É√ä¬òiVi√É
>
√Ä¬à¬ú√ä√Äi}¬à√É√å√Ä
>
√Ä√Éi√ä√ï¬ò>√ä√õi√¢√äi¬ò√äi√É√åi√ä√É¬à√å¬à¬ú√ä√úiL
¬∞
√ä


1¬ò>√ä√õi√¢√ä¬µ√ïi√ä√Éi√ä
¬Ö
>
√û
>
√ä√Äi}¬à√É√å√Ä>`¬ú]√ä¬´¬ú`√Ä?√ä¬à¬ò¬àV¬à>√Ä√ä√ï¬ò>√ä√Éi√É¬à¬ù¬ò√ä√É¬ài¬ì¬´√Äi√ä¬µ√ïi√ä¬è¬ú√ä`i√Éii√ä
>
VVi`¬ài¬ò`¬ú√ä
>


http://www.aw.com/kurose_ross
y
proporcionando
su
nombre
de
usuario
y
su
contrase√±a
cuando


se
le
soliciten
.


I¬ì¬´¬ú√Ä√å>¬ò√åi\√äi¬è√äV¬ù`¬à}¬ú√ä`i√ä
>
VVi√É¬ú√ä√É¬ù¬è¬ú√ä√Éi√ä¬´√ïi`i√ä√ï√å¬à¬è¬à√¢
>
√Ä√ä√ï¬ò>√ä√õi√¢
¬∞
√ä

√É√å
>
√ä√É√ï√ÉV√Ä¬à¬´V¬à¬ù¬ò√äi√É√ä√õ?¬è¬à`>√ä¬´>√Ä
>
√ä√ï¬ò√ä¬´i√Ä¬à¬ú`¬ú√ä


`
i√ä√Éi¬à√É√ä¬ìi√Éi√É√ä`i√É`i√äi¬è√ä¬ì¬ú¬ìi¬ò√å¬ú√ä`i√ä√É√ï√ä
>
V√å¬à√õ
>
V¬à¬ù¬ò√ä√û√ä¬ò¬ú√äi√É√ä√å√Ä>¬ò√Évi√Ä¬àL¬èi
¬∞
√ä-¬à√äi√É√åi√äV¬ù`¬à}¬ú√ä`i√ä
>
VVi√É¬ú√ä√û
>
√ä
¬Ö
>
√ä√É¬à`¬ú√ä


√ï√å¬à¬è¬à√¢>`¬ú]√äi√É√ä¬´¬ú√É¬àL¬èi√ä¬µ√ïi√ä√û
>
√ä¬ò¬ú√ä√Éi
>
√ä√õ?¬è¬à`¬ú
¬∞
√ä-¬à√ä√Éi√äi¬òV√ïi¬ò√å√Ä
>
√äi¬ò√äi√É√åi√äV
>
√É¬ú]√ä¬´√ïi`i√ä>`¬µ√ï¬à√Ä¬à√Ä√ä√ï¬ò>√ä√É√ï√ÉV√Ä¬à¬´V¬à¬ù¬ò√ä
>
VVi-


diendo
a
http://www.aw.com/kurose_ross
y
siguiendo
las
instrucciones
mostradas
en
pantalla
.


redes.indd
  
2
26/3/10
  
08:21:18REDES
DE
COMPUTADORAS


Un
enfoque
descendente


QUINTA
EDICI√ìN


A01_KUROSE_ROMANOS.qxd
 
23/3/10
 
11:25
 
P√°gina
iA01_KUROSE_ROMANOS.qxd
 
23/3/10
 
11:25
 
P√°gina
iiREDES
DE
COMPUTADORAS


Un
enfoque
descendente


QUINTA
EDICI√ìN


James
F.
Kurose


University
of
Massachusetts
,
Amherst


Keith
W.
Ross


Politechnic
Institute
of
NYU


REVISI√ìN
T√âCNICA


Carolina
Ma√±oso
Hierro
√Ångel
P√©rez
de
Madrid
y
Pablo


Profesora
Titular
de
Universidad
Profesor
Titular
de
Universidad


Dpto
.
de
Sistemas
de
Comunicaci√≥n
y
Control
Dpto
.
de
Sistemas
de
Comunicaci√≥n
y
Control


Escuela
T√©cnica
Superior
de
Ingenier√≠a
Inform√°tica
Escuela
T√©cnica
Superior
de
Ingenier√≠a
Inform√°tica


Universidad
Nacional
de
Educaci√≥n
a
Distancia
Universidad
Nacional
de
Educaci√≥n
a
Distancia


REVISI√ìN
T√âCNICA
PARA
LATINOAM√âRICA


Luis
Marrone
Ingeniero
Rubin
Ayma
Alejo
Fedor


Ingeniero
Electromec√°nico
-
Profesor
Titular
Director
del
Dpto
.
de
Tecnolog√≠a
Inform√°tica


Fac
.
de
Inform√°tica
,
Universidad
Nacional
de
 
Fac
.
de
Ingenier√≠a
,
Universidad
Argentina


La
Plata
,
Buenos
Aires
(
Argentina
)
de
la
Empresa
,
Buenos
Aires
(
Argentina
)


Paula
Venosa
Ingeniero
Carlos
Alberto
Binker


Licenciada
en
Inform√°tica
-
Profesora
Adjunta
Coordinador
de
la
especialidad
de
Redes
de


Fac
.
de
Inform√°tica
,
Universidad
Nacional
de
Ingenier√≠a
en
Inform√°tica


La
Plata
,
Buenos
Aires
(
Argentina
)
Universidad
Nacional
de
la
Matanza
,


San
Justo
,
Buenos
Aires
(
Argentina
)


Ingeniero
Mario
Groppo


Coordinador
del
Laboratorio
de
Redes
del
Departamento
de
Sistemas


Universidad
Tecnol√≥gica
Regional
de
C√≥rdoba
,
C√≥rdoba
(
Argentina
)


Addison
Wesley


es
un
sello
editorial
de


Harlow
,
England
‚Ä¢
London
‚Ä¢
New
York
‚Ä¢
Boston
‚Ä¢
San
Francisco
‚Ä¢
Toronto
‚Ä¢
Sydney
‚Ä¢


Singapore
‚Ä¢
Hong
Kong
‚Ä¢
Tokyo
‚Ä¢
Seoul
‚Ä¢
Taipei
‚Ä¢
New
Delhi
‚Ä¢
Cape
Town


Madrid
‚Ä¢
Mexico
City
‚Ä¢
Amsterdam
‚Ä¢
Munich
‚Ä¢
Paris
‚Ä¢
Milan


A01_KUROSE_ROMANOS.qxd
 
23/3/10
 
11:25
 
P√°gina
iiiCualquier
forma
de
reproducci√≥n
,
distribuci√≥n
,
comunicaci√≥n
p√∫blica
o
transformaci√≥n
de
esta
obra
s√≥lo
puede
ser


realizada
con
la
autorizaci√≥n
de
sus
titulares
,
salvo
excepci√≥n
prevista
por
la
ley
.
La
infracci√≥n
de
los
derechos


mencionados
puede
ser
constitutiva
de
delito
contra
la
propiedad
intelectual
(
arts
.
270
y
sgts
.
C√≥digo
penal
)
.


Dir√≠jase
a
CEDRO
(
Centro
Espa√±ol
de
Derechos
Reprogr√°ficos
:
www.cedro.org
)
,
si
necesita
fotocopiar
o


escanear
alg√∫n
fragmento
de
esta
obra
.


DERECHOS
RESERV
ADOS


¬©
2010
,
PEARSON
EDUCACI√ìN
S.
A.


Ribera
del
Loira
,
28


28042
Madrid
(
Espa√±a
)


ISBN
:
978-84-7829-119-9


Authorized
translation
from
the
English
language
edition
,
entitled
COMPUTER
NETWORKING
:
A
TOP-DOWN


APPROACH
,
5th
Edition
by
JAMES
KUROSE
;
KEITH
ROSS
,
published
by
Pearson
Education
,
Inc
,
publishing


as
Addison-Wesley
,
Copyright
¬©
2010
.
All
rights
reserved
.
No
part
of
this
book
may
be
reproduced
or
transmitted


in
any
form
or
by
any
means
,
electronic
or
mechanical
,
including
photocopying
,
recording
or
by
any
information


storage
retrieval
system
,
without
permission
from
Pearson
Education
,
Inc
.
SPANISH
language
edition
published


by
PEARSON
EDUCACION
S.A.
,
Copyright
¬©
2010
.


Dep√≥sito
Legal
:


Traducci√≥n
y
Maquetaci√≥n
:
Vuelapluma
,
S.L.U.


Equipo
editorial
:


Editor
:
Miguel
Mart√≠n-Romo


T√©cnico
Editorial
:
Esther
Mart√≠n


Equipo
de
producci√≥n
:


Director
:
Jos√©
A.
Clares


T√©cnico
:
Isabel
Mu√±oz


Dise√±o
de
cubierta
:
Equipo
de
dise√±o
de
Pearson
Educaci√≥n
,
S.
A.


Impreso
por
:


IMPRESO
EN
ESPA√ëA
-
PRINTED
IN
SPAIN


Este
libro
ha
sido
impreso
con
papel
y
tintas
ecol√≥gicos


Nota
sobre
enlaces
a
p√°ginas
web
ajenas
:
Este
libro
puede
incluir
enlaces
a
sitios
web
gestionados
por
terceros
y


ajenos
a
PEARSON
EDUCACI√ìN
S.
A.
que
se
incluyen
s√≥lo
con
finalidad
informativa
.


PEARSON
EDUCACI√ìN
S.
A.
no
asume
ning√∫n
tipo
de
responsabilidad
por
los
da√±os
y
perjuicios
derivados
del


uso
de
los
datos
personales
que
pueda
hacer
un
tercero
encargado
del
mantenimiento
de
las
p√°ginas
web
ajenas
a


PEARSON
EDUCACI√ìN
S.
A
y
del
funcionamiento
,
accesibilidad
o
mantenimiento
de
los
sitios
web
no
gestio-


nados
por
PEARSON
EDUCACI√ìN
S.
A.
Las
referencias
se
proporcionan
en
el
estado
en
que
se
encuentran
en
el


momento
de
publicaci√≥n
sin
garant√≠as
,
expresas
o
impl√≠citas
,
sobre
la
informaci√≥n
que
se
proporcione
en
ellas
.


REDES
DE
COMPUTADORAS
:
UN
ENFOQUE
DESCENDENTE


James
F.
Kurose
,
Keith
W.
Ross


PEARSON
EDUCACI√ìN
,
S.
A.
2010


ISBN
:
978-84-7829-119-9


Materia
:
,
004
.
Computadores


Formato
:
195x250
mm
       
P√°ginas
:
844


A01_KUROSE_ROMANOS.qxd
 
23/3/10
 
11:25
 
P√°gina
ivAJ
u
l
i
e
 
y
 
a
 
n
u
e
s
t
r
a
s
 
t
r
e
s
 

preciosidades
:
Chris
,
Charlie
y
Nina


JFK


Am
i
 
m
a
r
a
v
i
l
l
o
s
a
 
e
s
p
o
s
a
,
 
V
√©
r
o
n
i
q
u
e
,
 

y
a
nuestras
tres
hijas
,
C√©cile
,
Claire
y
Katie


KWR


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
vA01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
viAcerca
de
los
autores


Jim
Kurose


Jim
Kurose
es
profesor
de
Ciencias
de
la
Computaci√≥n
en
la
Universidad
de


Massachusetts
,
Amherst
.


Kurose
ha
recibido
numerosos
reconocimientos
por
sus
actividades
en
el
campo


de
la
educaci√≥n
,
entre
los
que
se
incluyen
el
premio
a
la
excelencia
en
la
labor


pedag√≥gica
de
la
Universidad
Tecnol√≥gica
Nacional
(
ocho
veces
)
,
la
Universidad


de
Massachusetts
y
la
asociaci√≥n
Northeast
Association
of
Graduate
Schools
.


Ha
recibido
la
Medalla
Taylor
Booth
del
IEEE
a
la
Educaci√≥n
y
es
bien
conocido


por
haber
liderado
la
iniciativa
Commonwealth
Information
Technology
de


Massachusetts
.
Ha
obtenido
una
beca
de
investigaci√≥n
GE
Fellowship
,
un
premio


IBM
al
desarrollo
del
profesorado
y
una
beca
Lilly
de
ense√±anza
.


El
Dr.
Kurose
ha
sido
editor
jefe
de
las
revistas
IEEE
Transactions
on


Communications
e
IEEE
/
ACM
Transactions
on
Networking
.
Ha
participado
varios


a√±os
en
los
comit√©s
de
programa
de
las
conferencias
IEEE
Infocom
,
ACM
SIG-


COMM
,
ACM
Internet
Measurement
Conference
y
ACM
SIGMETRICS
y
ha
sido


tambi√©n
Co-director
T√©cnico
de
Programa
para
dichas
conferencias
.
Es
miembro
del


IEEE
de
la
ACM
.
Entre
sus
intereses
de
investigaci√≥n
se
incluyen
las
arquitecturas
y


protocolos
de
red
,
las
medidas
de
red
,
las
redes
de
sensores
,
la
comunicaci√≥n


multimedia
y
el
modelado
y
la
evaluaci√≥n
de
rendimiento
.
Es
doctor
en
Ciencias


de
la
Computaci√≥n
por
la
Universidad
de
Columbia
.


Keith
Ross


Keith
Ross
es
Jefe
del
Departamento
de
Ciencias
de
la
Computaci√≥n
en
el
Instituto


Polit√©cnico
de
la
Universidad
de
Nueva
York
(
en
Brooklyn
)
y
cuenta
con
la
distinci√≥n


pedag√≥gica
Leonard
J.
Shustek
de
dicho
departamento
.
Entre
1985
y
1998
fue


profesor
del
Departamento
de
Ingenier√≠a
de
Sistemas
en
la
Universidad
de


Pennsylvania
.
De
1998
a
2003
trabaj√≥
como
profesor
en
el
Departamento
de


Comunicaciones
Multimedia
del
Instituto
Eurecom
en
Francia
.
Keith
Ross
fue
tambi√©n


el
fundador
principal
y
primer
consejero
delegado
de
Wimba
,
que
desarrolla


tecnolog√≠as
de
Voz
sobre
IP
y
transmisi√≥n
de
flujos
multimedia
para
el
mercado


de
la
ense√±anza
electr√≥nica
.


Entre
sus
intereses
de
investigaci√≥n
se
encuentran
las
redes
P2P
,
las
medidas


para
Internet
,
la
tecnolog√≠a
de
flujos
de
v√≠deo
,
las
cach√©s
web
,
las
redes
de


distribuci√≥n
de
contenido
,
la
seguridad
de
red
,
Voz
sobre
IP
y
el
modelado


estoc√°stico
.
Es
miembro
del
IEEE
y
actualmente
trabaja
como
editor
asociado
para


la
revista
IEEE
/
ACM
Transactions
on
Networking
.
Ha
actuado
como
asesor
para
la


Comisi√≥n
Federal
de
Comercio
sobre
compartici√≥n
de
archivos
P2P
y
ha
formado


tambi√©n
parte
de
los
comit√©s
de
programa
de
las
conferencias
IEEE
Infocom
,
ACM


SIGCOMM
,
ACM
CoNext
,
IPTPS
,
ACM
Multimedia
,
ACM
Internet
Measurement


Conference
y
ACM
SIGMETRICS
.
Es
doctor
en
Ingenier√≠a
de
computaci√≥n
,


informaci√≥n
y
control
por
la
Universidad
de
Michigan
.


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
viiA01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
viiiPrefacio


Bienvenido
a
la
quinta
edici√≥n
de
Redes
de
computadoras
:
un
enfoque
descendente
.
Desde


la
publicaci√≥n
de
la
primera
edici√≥n
hace
nueve
a√±os
,
nuestro
libro
ha
sido
adoptado
por


centenares
de
universidades
,
traducido
a
m√°s
de
una
docena
de
idiomas
y
utilizado
por
m√°s


cien
mil
estudiantes
y
usuarios
de
todo
el
mundo
.
Hemos
tenido
noticias
de
muchos
de
estos


lectores
y
estamos
abrumados
por
su
positiva
respuesta
.


Novedades
en
la
quinta
edici√≥n


Creemos
que
una
raz√≥n
importante
de
este
√©xito
ha
sido
que
nuestro
libro
contin√∫a
ofreciendo


un
enfoque
novedoso
y
oportuno
para
la
formaci√≥n
en
el
campo
de
las
redes
de
computadoras
.


Hemos
realizado
cambios
en
esta
quinta
edici√≥n
,
pero
tambi√©n
hemos
dejado
todo
aquello
que


creemos
que
constituyen
(
y
en
lo
que
coinciden
los
estudiantes
y
los
profesores
que
han
utili-


zado
nuestro
libro
)
los
aspectos
m√°s
importantes
del
libro
:
su
enfoque
descendente
,
el
hecho
de


que
est√°
centrado
en
Internet
y
en
un
tratamiento
moderno
de
las
redes
de
computadoras
,
su


atenci√≥n
tanto
a
los
principios
como
a
la
pr√°ctica
y
su
estilo
y
enfoque
pedag√≥gico
accesibles


en
lo
que
respecta
al
aprendizaje
de
las
redes
de
computadoras
.


De
todos
modos
,
se
ha
realizado
una
serie
de
cambios
importantes
en
la
quinta
edici√≥n
.


En
el
Cap√≠tulo
1
,
hemos
actualizado
nuestra
introducci√≥n
al
tema
de
las
redes
y
tambi√©n


hemos
actualizado
y
ampliado
el
tratamiento
de
las
redes
de
acceso
(
en
particular
,
el
uso
de


redes
de
cable
,
DSL
y
redes
de
fibra
como
redes
de
acceso
a
la
Internet
p√∫blica
)
.
En
el
Cap√≠-


tulo
2
,
hemos
eliminado
el
material
sobre
b√∫squedas
entre
pares
que
hab√≠a
quedado
un
tanto


obsoleto
,
con
el
fin
de
dejar
espacio
para
una
nueva
secci√≥n
sobre
tablas
hash
distribuidas
.


Como
siempre
,
cuando
se
ha
eliminado
material
del
libro
,
√©ste
sigue
estando
disponible
en
el


sitio
web
de
acompa√±amiento
(
v√©ase
m√°s
adelante
)
.
La
presentaci√≥n
de
los
sistemas
de
con-


trol
de
congesti√≥n
de
TCP
en
el
Cap√≠tulo
3
est√°
basada
ahora
en
una
representaci√≥n
gr√°fica


(
m√°quina
de
estados
finitos
)
de
TCP
,
lo
que
a√±ade
una
mejor
estructura
y
claridad
a
la
expo-


sici√≥n
.
El
Cap√≠tulo
5
se
ha
ampliado
significativamente
con
nuevas
secciones
dedicadas
a
las


redes
de
√°rea
local
virtuales
(
VLAN
)
y
al
an√°lisis
detallado
del
proceso
que
sigue
una
solici-


tud
web
.
En
esta
√∫ltima
secci√≥n
se
realiza
un
seguimiento
de
toda
la
actividad
de
red
y
los


protocolos
implicados
en
el
proceso
de
satisfacer
la
aparentemente
simple
solicitud
de
extrac-


ci√≥n
y
visualizaci√≥n
de
una
p√°gina
web
almacenada
en
un
servidor
remoto
,
lo
que
ayuda
a


ilustrar
y
sintetizar
buena
parte
del
material
cubierto
en
los
primeros
cinco
cap√≠tulos
.
En
el


Cap√≠tulo
6
,
hemos
eliminado
parte
de
la
‚Äú
sopa
de
letras
‚Äù
de
est√°ndares
y
protocolos
de
telefo-


n√≠a
celular
y
hemos
a√±adido
una
nueva
secci√≥n
sobre
la
arquitectura
de
las
redes
celulares
y


c√≥mo
interoperan
las
redes
celulares
e
Internet
para
proporcionar
servicios
de
Internet
a
dis-


positivos
m√≥viles
,
tales
como
un
tel√©fono
Blackberry
o
un
iPhone
.
El
tratamiento
de
la
segu-


ridad
en
las
redes
en
el
Cap√≠tulo
8
ha
sufrido
una
 
importante
revisi√≥n
.
Se
ha
revisado
el


material
dedicado
a
la
autenticaci√≥n
de
punto
terminal
,
al
encadenamiento
de
sistemas
de


cifrado
de
bloque
y
a
la
criptograf√≠a
de
clave
p√∫blica
,
y
el
material
sobre
IPsec
ha
sido
rees-


crito
y
ampliado
con
el
fin
de
incluir
el
tema
de
la
redes
privadas
virtuales
(
VPN
)
.
A
lo
largo


del
libro
,
hemos
incluido
nuevos
ejemplos
avanzados
y
referencias
actualizadas
.
En
el
mate-


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
ixrial
incluido
al
final
de
cada
cap√≠tulo
,
hemos
a√±adido
nuevos
problemas
(
como
nos
hab√≠an


solicitado
muchos
profesores
)
,
hemos
portado
las
pr√°cticas
de
laboratorio
de
Ethereal
a


Wireshark
,
hemos
a√±adido
nuevas
pr√°cticas
de
laboratorio
con
Wireshark
y
tambi√©n
una


nueva
pr√°ctica
de
laboratorio
sobre
IPsec
.


Audiencia


Este
libro
de
texto
es
para
un
primer
curso
sobre
redes
de
computadoras
.
Se
puede
utilizar


tanto
en
departamentos
de
inform√°tica
como
de
ingenier√≠a
el√©ctrica
.
En
relaci√≥n
con
los
len-


guajes
de
programaci√≥n
,
se
supone
que
el
estudiante
s√≥lo
tiene
experiencia
con
C
,
C++
o


Java
(
e
incluso
esa
suposici√≥n
s√≥lo
se
hace
en
algunos
pocos
lugares
)
.
Aunque
este
libro
es


m√°s
preciso
y
anal√≠tico
que
muchos
otros
textos
introductorios
a
las
redes
de
computadoras
,


rara
vez
utiliza
conceptos
matem√°ticos
que
no
se
hayan
aprendido
en
el
bachillerato
.
Hemos


hecho
un
esfuerzo
deliberado
por
evitar
el
uso
de
cualquier
concepto
de
c√°lculo
avanzado
,


probabilidad
o
procesos
estoc√°sticos
(
aunque
hemos
incluido
algunos
problemas
para
los


estudiantes
que
dominen
estos
conceptos
)
.
El
libro
es
apropiado
por
tanto
para
cursos
de
pri-


mer
ciclo
y
para
el
primer
a√±o
de
los
cursos
de
segundo
ciclo
.
Tambi√©n
puede
ser
adecuado


para
los
trabajadores
del
sector
de
las
telecomunicaciones
.


¬ø
Qu√©
hace
especial
a
este
libro
de
texto
?


El
tema
de
las
redes
de
computadoras
es
enormemente
complejo
,
implicando
muchos
con-


ceptos
,
protocolos
y
tecnolog√≠as
que
est√°n
entrelazados
de
una
manera
intrincada
.
Para
abar-


car
este
alcance
y
complejidad
,
muchos
textos
de
redes
se
han
organizado
a
menudo
sobre


las
‚Äú
capas
‚Äù
de
una
arquitectura
de
red
.
Con
una
organizaci√≥n
en
capas
,
los
estudiantes
pue-


den
ver
a
trav√©s
de
la
complejidad
de
las
redes
de
computadoras
y
aprender
los
distintos
con-


ceptos
y
protocolos
de
una
parte
de
la
arquitectura
a
la
vez
que
ven
el
gran
esquema
de
c√≥mo


todas
las
partes
se
ajustan
entre
s√≠
.
Desde
una
perspectiva
pedag√≥gica
,
nuestra
experiencia


personal
ha
sido
que
dicho
enfoque
en
capas
es
efectivamente
muy
deseable
.
Sin
embargo
,


hemos
comprobado
que
el
enfoque
tradicional
de
ense√±anza
ascendente
,
es
decir
,
desde
la


capa
f√≠sica
a
la
capa
de
aplicaci√≥n
,
no
es
el
mejor
enfoque
para
un
curso
moderno
sobre


redes
de
computadoras
.


Un
enfoque
descendente


Nuestro
libro
rompi√≥
moldes
hace
diez
a√±os
al
abordar
el
tema
de
las
redes
de
arriba
hacia


abajo
;
es
decir
,
comenzando
con
la
capa
de
aplicaci√≥n
y
descendiendo
desde
all√≠
hacia
la


capa
f√≠sica
.
Los
comentarios
recibidos
tanto
de
profesores
como
de
estudiantes
nos
confir-


man
que
el
enfoque
descendente
tiene
muchas
ventajas
y
resulta
pedag√≥gicamente
ade-


cuado
.
En
primer
lugar
,
hace
√©nfasis
en
la
capa
de
aplicaci√≥n
(
un
‚Äú
√°rea
de
elevado


crecimiento
‚Äù
en
las
redes
)
.
De
hecho
,
muchas
revoluciones
recientes
en
las
redes
de
compu-


tadoras
,
incluyendo
la
Web
,
la
compartici√≥n
de
archivos
P2P
y
los
flujos
de
audio
y
v√≠deo
,


han
tenido
lugar
en
la
capa
de
aplicaci√≥n
.
Un
√©nfasis
inicial
en
la
capa
de
aplicaci√≥n


difiere
de
los
m√©todos
considerados
en
la
mayor
parte
de
otros
textos
,
que
incluyen
s√≥lo


una
peque√±a
cantidad
de
material
sobre
las
aplicaciones
de
red
,
sus
requisitos
,
paradigmas


(
por
ejemplo
,
cliente-servidor
y
P2P
)
e
interfaces
de
programaci√≥n
de
aplicaciones
.
En


x
Prefacio


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xPrefacio
xi


segundo
lugar
,
nuestra
experiencia
como
profesores
(
y
de
muchos
profesores
que
han
utili-


zado
este
texto
)
ha
sido
que
el
ense√±ar
las
aplicaciones
de
redes
al
principio
de
curso
es
una


potente
herramienta
de
motivaci√≥n
.
Los
estudiantes
se
emocionan
al
aprender
c√≥mo
funcio-


nan
las
aplicaciones
de
red
,
aplicaciones
tales
como
el
correo
electr√≥nico
o
la
Web
,
que
la


mayor√≠a
de
los
estudiantes
utilizan
diariamente
.
Una
vez
que
los
estudiantes
comprenden
las


aplicaciones
,
pueden
entonces
entender
los
servicios
de
red
necesarios
para
proporcionarles


ese
soporte
.
El
estudiante
puede
entonces
,
a
su
vez
,
examinar
las
distintas
formas
en
que
tales


servicios
pueden
ser
suministrados
por
,
e
implementados
en
,
las
capas
inferiores
.
Por
tanto
,


tratar
las
aplicaciones
inicialmente
proporciona
motivaci√≥n
para
abordar
el
resto
del
texto
.


En
tercer
lugar
,
un
enfoque
descendente
permite
a
los
profesores
introducir
el
desarro-


llo
de
aplicaciones
de
red
en
una
etapa
temprana
.
Los
estudiantes
no
s√≥lo
ven
c√≥mo
fun-


ciona
una
serie
de
populares
aplicaciones
y
protocolos
,
sino
que
tambi√©n
aprenden
lo
f√°cil


que
es
crear
sus
propias
aplicaciones
de
red
y
protocolos
del
nivel
de
aplicaci√≥n
.
Con
el


enfoque
descendente
,
los
estudiantes
descubren
pronto
las
nociones
acerca
de
las
interfaces


de
programaci√≥n
de
aplicaciones
(
API
)
,
los
modelos
de
servicio
y
los
protocolos
(
concep-


tos
importantes
que
vuelven
a
serlo
en
todas
las
capas
subsiguientes
)
.
Al
proporcionar


ejemplos
de
programaci√≥n
de
sockets
en
Java
,
destacamos
las
ideas
centrales
sin
confundir


a
los
estudiantes
con
fragmentos
complejos
de
c√≥digo
.
Los
estudiantes
de
primer
ciclo
de


Ingenier√≠a
El√©ctrica
y
Ciencias
de
la
Computaci√≥n
no
deben
tener
dificultades
para
com-


prender
el
c√≥digo
Java
.


Un
enfoque
Internet


Aunque
en
la
cuarta
edici√≥n
del
libro
eliminamos
del
t√≠tulo
la
frase
‚Äú
Caracterizaci√≥n
de


Internet
‚Äù
,
¬°
no
quiere
decir
que
hayamos
eliminado
el
enfoque
de
Internet
!
¬°
Nada
m√°s
lejos


de
la
realidad
!
En
lugar
de
ello
,
y
dado
que
Internet
se
ha
vuelto
tan
ubicua
,
pensamos
que


cualquier
libro
de
texto
sobre
redes
debe
centrarse
significativamente
en
Internet
,
por
lo
que


la
frase
del
t√≠tulo
era
hasta
cierto
punto
innecesaria
.
En
el
texto
,
continuamos
utilizando
la


arquitectura
y
los
protocolos
de
Internet
como
veh√≠culo
principal
para
estudiar
los
conceptos


fundamentales
de
las
redes
de
computadoras
.
Por
supuesto
,
tambi√©n
incluimos
conceptos
y


protocolos
de
las
arquitecturas
de
red
,
pero
el
foco
est√°
centrado
claramente
en
Internet
,
un


hecho
que
se
ha
reflejado
en
la
organizaci√≥n
del
libro
,
que
est√°
centrada
alrededor
de
la


arquitectura
de
cinco
capas
de
Internet
:
las
capas
de
aplicaci√≥n
,
transporte
,
red
,
enlace
y


f√≠sica
.


Otro
de
los
beneficios
de
centrar
la
atenci√≥n
en
Internet
es
que
la
mayor√≠a
de
los
estu-


diantes
de
Ciencias
de
la
Computaci√≥n
y
de
Ingenier√≠a
El√©ctrica
est√°n
deseosos
de
aprender


cosas
sobre
Internet
y
sus
protocolos
.
Saben
que
Internet
ha
sido
una
tecnolog√≠a
revolucio-


naria
y
conflictiva
que
est√°
cambiando
profundamente
nuestro
mundo
.
Dada
la
enorme
rele-


vancia
de
Internet
,
los
estudiantes
sienten
una
natural
curiosidad
por
ver
lo
que
hay
‚Äú
entre


bastidores
‚Äù
.
Por
tanto
,
es
f√°cil
para
un
profesor
conseguir
que
los
estudiantes
se
interesen


por
los
principios
b√°sicos
cuando
se
utiliza
Internet
como
foco
gu√≠a
.


C√≥mo
ense√±ar
los
principios
de
las
redes


Dos
de
las
caracter√≠sticas
√∫nicas
del
libro
(
su
enfoque
descendente
y
su
foco
puesto
en
Inter-


net
)
se
han
utilizado
en
el
t√≠tulo
en
sucesivas
ediciones
.
Si
hubi√©ramos
podido
introducir
una


tercera
frase
en
el
subt√≠tulo
,
√©sta
habr√≠a
contenido
la
palabra
principios
.
El
campo
de
las


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xiredes
est√°
ahora
lo
suficientemente
maduro
como
para
que
se
puedan
identificar
una
serie


de
temas
fundamentalmente
importantes
.
Por
ejemplo
,
en
la
capa
de
transporte
,
los
temas


fundamentales
son
la
comunicaci√≥n
fiable
sobre
una
capa
de
red
no
fiable
,
el
establecimiento


y
el
cierre
de
la
conexi√≥n
y
el
proceso
de
acuerdo
,
el
control
de
congesti√≥n
y
flujo
,
y
la
multi-


plexaci√≥n
.
Dos
temas
enormemente
importantes
de
la
capa
de
red
son
la
determinaci√≥n
de


‚Äú
buenas
‚Äù
rutas
entres
dos
routers
y
la
interconexi√≥n
de
un
n√∫mero
grande
redes
heterog√©neas
.


En
la
capa
de
enlace
de
datos
,
un
problema
fundamental
es
la
compartici√≥n
de
un
canal
de


acceso
m√∫ltiple
.
En
el
campo
de
la
seguridad
de
red
,
las
t√©cnicas
que
permiten
proporcionar


confidencialidad
,
autenticaci√≥n
e
integridad
de
los
mensajes
est√°n
basadas
en
los
principios


de
la
criptograf√≠a
.
Este
texto
identifica
los
temas
fundamentales
acerca
de
las
redes
y
estudia


los
m√©todos
para
abordarlos
.
El
estudiante
que
aprenda
estos
principios
adquirir√°
una
serie
de


conocimientos
con
una
larga
‚Äú
vida
√∫til
‚Äù
:
mucho
despu√©s
de
que
los
est√°ndares
y
protocolos


de
red
actuales
hayan
quedado
obsoletos
,
los
principios
en
que
se
basan
continuar√°n
teniendo


importancia
y
siendo
relevantes
.
Pensamos
que
la
combinaci√≥n
del
uso
de
Internet
para
atis-


bar
las
posibilidades
y
el
√©nfasis
posterior
en
los
temas
fundamentales
y
las
soluciones
permi-


tir√°n
al
estudiante
comprender
r√°pidamente
cualquier
tecnolog√≠a
de
redes
.


El
sitio
web


Al
adquirir
este
libro
de
texto
,
el
lector
podr√°
acceder
durante
seis
meses
al
sitio
web
de


acompa√±amiento
en
la
direcci√≥n
http://www.aw.com/kurose-ross
.
Este
sitio
incluye
:


‚Ä¢
Material
de
aprendizaje
interactivo
.
El
sitio
web
contiene
varios
applets
Java
interacti-


vos
,
que
ilustran
muchos
de
los
conceptos
clave
de
redes
.
El
sitio
tambi√©n
ofrece
pregun-


tas
de
test
interactivas
que
permiten
a
los
estudiantes
comprobar
su
conocimiento
b√°sico


del
tema
en
cuesti√≥n
.
Los
profesores
pueden
integrar
estas
caracter√≠sticas
interactivas
en


sus
clases
o
utilizarlas
como
mini
pr√°cticas
de
laboratorio
.


‚Ä¢
Material
t√©cnico
adicional
.
Am
e
d
i
d
a
 
q
u
e
 
h
e
m
o
s
 
i
d
o
 
a
√±
a
d
i
e
n
d
o
 
n
u
e
v
o
 
m
a
t
e
r
i
a
l
 
e
n
 
c
a
d
a


edici√≥n
del
libro
,
hemos
tenido
que
eliminar
parte
del
tratamiento
de
alguno
de
los
temas


existentes
,
para
que
el
libro
tuviera
una
longitud
aceptable
.
Por
ejemplo
,
para
hacer
sitio


para
el
nuevo
material
incluido
en
esta
edici√≥n
,
hemos
eliminado
diversos
materiales


sobre
redes
ATM
y
b√∫squedas
P2P.
Pero
el
material
incluido
en
las
ediciones
anteriores


del
libro
sigue
de
inter√©s
y
puede
encontrarse
en
el
sitio
web
de
acompa√±amiento
.


‚Ä¢
Tareas
de
programaci√≥n
.
El
sitio
web
tambi√©n
proporciona
una
serie
de
tareas
de
pro-


gramaci√≥n
detalladas
,
entre
las
que
se
incluyen
la
construcci√≥n
de
un
servidor
web


multihebra
,
la
construcci√≥n
de
un
cliente
de
correo
electr√≥nico
con
una
interfaz
gr√°-


fica
de
usuario
(
GUI
)
,
la
programaci√≥n
de
los
lados
emisor
y
receptor
de
un
protocolo


de
transporte
de
datos
fiable
,
la
programaci√≥n
de
un
algoritmo
de
enrutamiento
distri-


buido
y
otros
.
 

‚Ä¢
Pr√°cticas
de
laboratorio
con
Wireshark
.
La
comprensi√≥n
de
los
protocolos
de
red
puede


verse
ampliada
significativamente
viendo
esos
protocolos
en
acci√≥n
.
El
sitio
web
propor-


ciona
numerosas
pr√°cticas
con
Wireshark
que
permiten
a
los
estudiantes
observar
la


secuencia
de
mensajes
intercambiados
entre
dos
entidades
de
protocolo
.
El
sitio
web


incluye
pr√°cticas
de
laboratorio
con
Wireshark
independientes
sobre
HTTP
,
DNS
,
TCP
,


UDP
,
IP
,
ICMP
,
Ethernet
,
ARP
,
WiFi
,
SSL
,
y
sobre
c√≥mo
realizar
una
traza
de
todos
los


protocolos
implicados
en
satisfacer
una
solicitud
de
extracci√≥n
de
una
p√°gina
web
.
Con-


tinuaremos
a√±adiendo
nuevas
pr√°cticas
de
laboratorio
en
el
futuro
.


xii
Prefacio


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xiiPrefacio
xiii


Caracter√≠sticas
pedag√≥gicas


Cada
uno
de
nosotros
lleva
ense√±ando
redes
de
computadoras
durante
m√°s
de
20
a√±os
.


Proporcionamos
a
este
texto
la
experiencia
combinada
de
ense√±ar
durate
45
a√±os
a


muchos
miles
de
estudiantes
.
Hemos
sido
tambi√©n
investigadores
activos
en
redes
de


computadoras
durante
este
tiempo
.
(
De
hecho
,
Jim
y
Keith
se
conocieron
cuando
eran


estudiantes
de
m√°ster
en
un
curso
sobre
redes
de
computadoras
impartido
por
Mischa
Sch-


wartz
en
1979
en
la
Universidad
de
Columbia
.
)
Pensamos
que
todo
esto
nos
proporciona


una
buena
perspectiva
de
cu√°l
ha
sido
la
evoluci√≥n
de
las
redes
y
hacia
d√≥nde
es
probable


que
vayan
en
el
futuro
.
Sin
embargo
,
hemos
resistido
a
la
tentaci√≥n
de
dirigir
el
material


de
este
libro
hacia
las
preferencias
de
nuestros
proyectos
de
investigaci√≥n
.
Consideramos


que
el
lector
puede
visitar
nuestros
sitios
web
personales
si
est√°
interesado
en
nuestras


investigaciones
.
Por
tanto
,
este
libro
se
ocupa
de
las
redes
de
computadoras
modernas
(
de


los
protocolos
y
tecnolog√≠as
contempor√°neos
,
as√≠
como
de
los
principios
subyacentes
a


dichos
protocolos
y
tecnolog√≠as
)
.
Tambi√©n
creemos
que
aprender
(
y
ense√±ar
)
redes
puede


ser
divertido
.
Esperamos
que
el
sentido
del
humor
,
el
uso
de
analog√≠as
y
los
ejemplos
del


mundo
real
contenidos
en
el
libro
hagan
el
material
m√°s
divertido
.


Notas
sobre
historia
,
pr√°ctica
y
seguridad


El
campo
de
las
redes
de
computadoras
tiene
una
rica
y
fascinante
historia
.
Hemos
hecho
un


esfuerzo
especial
para
contar
la
historia
de
las
redes
de
computadoras
.
Hemos
incluido
una


secci√≥n
hist√≥rica
especial
en
el
Cap√≠tulo
1
y
una
docena
de
notas
hist√≥ricas
distribuidas
por


el
resto
de
los
cap√≠tulos
.
En
estas
historias
hemos
hablado
de
la
invenci√≥n
de
la
conmuta-


ci√≥n
de
paquetes
,
de
la
evoluci√≥n
de
Internet
,
del
nacimiento
de
los
principales
gigantes
de


las
redes
como
Cisco
y
3Com
,
y
de
otros
muchos
hechos
importantes
.
Los
estudiantes
se


sentir√°n
estimulados
por
estas
historias
.
Hemos
incluido
asimismo
notas
especiales
que
des-


tacan
los
principios
importantes
en
las
redes
de
computadoras
.
Estas
notas
ayudar√°n
a
los


estudiantes
a
apreciar
algunos
de
los
conceptos
fundamentales
que
se
aplican
en
las
redes


modernas
.
El
tratamiento
de
los
temas
de
seguridad
en
las
redes
se
ha
ampliado
,
incluyendo


por
ejemplo
las
notas
especiales
‚Äú
Seguridad
‚Äù
en
cada
uno
de
los
cap√≠tulos
fundamentales


del
libro
.


Entrevistas


Tambi√©n
hemos
incluido
otras
caracter√≠stica
original
que
nuestros
lectores
nos
dicen
que
les


resulta
particularmente
interesante
e
inspiradora
:
las
entrevistas
con
innovadores
de
renom-


bre
en
el
campo
de
las
redes
.
Hemos
entrevistado
a
Len
Kleinrock
,
Bram
Cohen
,
Sally


Floyd
,
Vint
Cerf
,
Simon
Lam
,
Charlie
Perkins
,
Henning
Schulzrinne
,
Steven
Bellovin
y
Jeff


Case
.


Suplementos
para
los
profesores


Proporcionamos
un
paquete
de
suplementos
completo
para
ayudar
a
los
profesores
a
la
hora


de
impartir
este
curso
.
Se
puede
acceder
a
este
material
en
el
Centro
de
recursos
de
formaci√≥n


de
Addison-Wesley
(
http://www.pearsonhighered.com/irc
)
.
Visite
este
centro
o
env√≠e
un
correo


electr√≥nico
a
computing@aw.com
para
obtener
informaci√≥n
sobre
c√≥mo
acceder
a
los
suple-


mentos
para
los
profesores
.


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xiii‚Ä¢
Diapositivas
PowerPoint
¬Æ
.
Proporcionamos
diapositivas
para
los
nueve
cap√≠tulos
.
Las


diapositivas
para
esta
quinta
edici√≥n
se
han
actualizado
de
forma
significativa
.
Estas
pre-


sentaciones
en
diapositivas
cubren
cada
cap√≠tulo
en
detalle
.
Se
utilizan
gr√°ficos
y
anima-


ciones
(
en
lugar
de
emplear
√∫nicamente
mon√≥tonas
listas
de
vi√±etas
)
que
hacen
que
las


diapositivas
sean
interesantes
y
visualmente
atractivas
.
Proporcionamos
las
diapositivas


originales
de
PowerPoint
de
modo
que
pueda
personalizarlas
con
el
fin
de
adaptarlas
a


sus
necesidades
a
la
hora
de
impartir
el
curso
.
Algunas
de
estas
diapositivas
han
sido


aportadas
por
otros
profesores
que
han
ense√±ado
con
nuestro
libro
.


‚Ä¢
Soluciones
de
los
problemas
.
Proporcionamos
un
manual
de
soluciones
para
los
proble-


mas
incluidos
en
el
texto
,
las
tareas
de
programaci√≥n
y
las
pr√°cticas
de
laboratorio
de


Wireshark
.
Como
hemos
dicho
anteriormente
,
hemos
a√±adido
muchos
problemas
nuevos


en
los
primeros
cinco
cap√≠tulos
del
libro
.


Dependencias
entre
cap√≠tulos


El
primer
cap√≠tulo
de
este
texto
presenta
una
panor√°mica
general
autocontenida
de
las
redes


de
computadoras
,
introduci√©ndose
muchos
conceptos
clave
y
terminolog√≠a
;
este
cap√≠tulo


define
el
escenario
para
el
resto
del
libro
.
Todos
los
cap√≠tulos
restantes
dependen
de
este
pri-


mer
cap√≠tulo
.
Recomendamos
a
los
profesores
que
,
despu√©s
de
completar
el
Cap√≠tulo
1
,


aborden
los
Cap√≠tulos
2
a
5
en
orden
,
siguiendo
nuestra
filosof√≠a
del
enfoque
descendente
.


Cada
uno
de
estos
cinco
cap√≠tulos
se
apoya
en
el
material
de
los
cap√≠tulos
anteriores
.
Una


vez
completados
los
primeros
cinco
cap√≠tulos
,
el
profesor
tiene
bastante
flexibilidad
.
No


existen
interdependencias
entre
los
cuatro
√∫ltimos
cap√≠tulos
,
por
lo
que
se
pueden
abordar


en
cualquier
orden
.
Sabemos
que
algunos
profesores
despu√©s
de
explicar
el
cap√≠tulo
de


introducci√≥n
,
saltan
al
Cap√≠tulo
5
y
van
hacia
atr√°s
(
enfoque
ascendente
)
e
incluso
otro
pro-


fesor
que
comienza
por
la
mitad
(
Cap√≠tulo
4
)
y
luego
va
progresando
en
ambas
direcciones
.


Sin
embargo
,
cada
uno
de
los
√∫ltimos
cuatro
cap√≠tulos
depende
del
material
de
los
primeros


cinco
.
Muchos
profesores
explican
los
primeros
cinco
cap√≠tulos
y
luego
uno
de
los
cuatro


√∫ltimos
como
‚Äú
postre
‚Äù
.


Una
√∫ltima
nota
:
agradecemos
cualquier
comentario


Animamos
a
los
estudiantes
y
profesores
a
enviarnos
por
correo
electr√≥nico
cualquier


comentario
que
tengan
sobre
nuestro
libro
.
Ha
sido
maravilloso
para
nosotros
escuchar
opi-


niones
de
profesores
y
estudiantes
de
todo
el
mundo
sobre
las
cuatro
primeras
ediciones
.


Muchas
de
esas
sugerencias
se
han
incorporado
en
ediciones
posteriores
del
libro
.
Tambi√©n


animamos
a
los
profesores
a
enviarnos
nuevos
problemas
(
y
sus
soluciones
)
que
comple-


menten
los
problemas
actualmente
incluidos
,
los
cuales
a√±adiremos
√∫nicamente
en
la
parte


de
acceso
exclusivo
para
profesores
del
sitio
web
.
Animamos
tambi√©n
a
los
profesores
y
estu-


diantes
a
crear
nuevos
applets
Java
que
ilustren
los
conceptos
y
protocolos
de
este
libro
.
Si
tiene


un
applet
que
piensa
que
podr√≠a
ser
adecuado
para
este
texto
,
por
favor
,
envienoslo
.
Si
el


applet
(
incluyendo
la
notaci√≥n
y
terminolog√≠a
)
es
apropiado
,
estaremos
encantados
de


incluirlo
en
el
sitio
web
del
libro
,
junto
con
la
apropiada
referencia
a
los
autores
del
mismo
.


Si√©ntase
libre
de
enviarnos
URL
interesantes
,
ind√≠quenos
los
errores
tipogr√°ficos
,


disienta
de
nuestras
afirmaciones
y
d√≠ganos
lo
que
cree
que
funciona
y
lo
que
no
.
D√≠ga-


xiv
Prefacio


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xivPrefacio
xv


nos
qu√©
es
los
que
piensa
que
deber√≠a
o
no
deber√≠a
ser
incluido
en
la
siguiente
edici√≥n
.


Env√≠enos
su
correo
electr√≥nico
a
kurose@cs.umass.edu
y
ross@poly.edu
.


Agradecimientos


Desde
que
comenzamos
a
escribir
este
libro
en
1996
,
muchas
personas
nos
han
proporcio-


nado
una
ayuda
inestimable
y
nos
ha
influido
dando
forma
a
nuestras
ideas
sobre
c√≥mo
orga-


nizar
e
impartir
un
curso
de
redes
.
MUCHAS
GRACIAS
a
todos
los
que
nos
han
ayudado


desde
el
primer
borrador
del
libro
hasta
la
quinta
edici√≥n
.
Estamos
tambi√©n
muy
agradecidos


a
los
muchos
cientos
de
lectores
de
todo
el
mundo
(
estudiantes
,
profesores
,
usuarios
)
que
nos


han
enviado
ideas
y
comentarios
sobre
las
ediciones
anteriores
del
libro
y
sugerencias
sobre


las
futuras
ediciones
del
mismo
.
Gracias
especiales
a
:


Al
Aho
(
Universidad
de
Columbia
)


Hisham
Al-Mubaid
(
Universidad
de
Houston-Clear
Lake
)


Pratima
Akkunoor
(
Universidad
del
Estado
de
Arizona
)


Paul
Amer
(
Universidad
de
Delaware
)


Shamiul
Azom
(
Universidad
del
Estado
de
Arizona
)


Lichun
Bao
(
Universidad
de
California
en
Irvine
)


Paul
Barford
(
Universidad
de
Wisconsin
)


Bobby
Bhattacharjee
(
Universidad
de
Maryland
)


Steven
Bellovin
(
Universidad
de
Columbia
)


Pravin
Bhagwat
(
Wibhu
)


Supratik
Bhattacharyya
(
anteriormente
en
Sprint
)


Ernst
Biersack
(
Instituto
Eur√©com
)


Shahid
Bokhari
(
Universidad
de
Ingenier√≠a
y
Tecnolog√≠a
,
Lahore
)


Jean
Bolot
(
Sprint
)


Daniel
Brushteyn
(
antigua
Universidad
de
Pensilvania
)


Ken
Calvert
(
Universidad
de
Kentucky
)


Evandro
Cantu
(
Universidad
Federal
de
Santa
Catarina
)


Jeff
Case
(
SNMP
Research
International
)


Jeff
Chaltas
(
Sprint
)


Vinton
Cerf
(
Google
)


Byung
Kyu
Choi
(
Universidad
Tenol√≥gica
de
Michigan
)


Bram
Cohen
(
BitTorrent
,
Inc
.
)


Constantine
Coutras
(
Pace
University
)


John
Daigle
(
Universidad
de
Mississippi
)


Edmundo
A.
de
Souza
e
Silva
(
Universidad
Federal
de
R√≠o
de
Janiero
)


Philippe
Decuetos
(
Instituto
Eur√©com
)


Christophe
Diot
(
Thomson
Research
)


Prithula
Dhunghel
(
Instituto
Polit√©cnico
de
NYU
)


Michalis
Faloutsos
(
Universidad
de
California
en
Riverside
)


Wu-chi
Feng
(
Oregon
Graduate
Institute
)


Sally
Floyd
(
ICIR
,
Universidad
de
California
en
Berkeley
)


Paul
Francis
(
Instituto
Max
Planck
)


Lixin
Gao
(
Universidad
de
Massachusetts
)


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xvJJ
Garcia-Luna-Aceves
(
Universidad
de
California
en
Santa
Cruz
)


Mario
Gerla
(
Universidad
de
California
de
Los
Angeles
)


David
Goodman
(
Universidad
Polit√©cnica
)


Tim
Griffin
(
Universidad
de
Cambridge
)


Max
Hailperin
(
Gustavus
Adolphus
College
)


Bruce
Harvey
(
Florida
A&M
University
,
Florida
State
University
)


Carl
Hauser
(
Universidad
del
Estado
de
Washington
)


Rachelle
Heller
(
George
Washington
University
)


Phillipp
Hoschka
(
INRIA
/
W3C
)


Wen
Hsin
(
Park
University
)


Albert
Huang
(
former
University
of
Pennsylvania
student
)


Esther
A.
Hughes
(
Virginia
Commonwealth
University
)


Jobin
James
(
Universidad
de
California
en
Riverside
)


Sugih
Jamin
(
Universidad
de
Michigan
)


Shivkumar
Kalyanaraman
(
Rensselaer
Polytechnic
Institute
)


Jussi
Kangasharju
(
Universidad
de
Darmstadt
)


Sneha
Kasera
(
Universidad
de
Utah
)


Hyojin
Kim
(
former
Universidad
de
Pennsylvania
student
)


Leonard
Kleinrock
(
Universidad
de
California
en
Los
Angeles
)


David
Kotz
(
Dartmouth
College
)


Beshan
Kulapala
(
Universidad
del
Estado
de
Arizona
)


Rakesh
Kumar
(
Bloomberg
)


Miguel
A.
Labrador
(
Universidad
de
South
Florida
)


Simon
Lam
(
Universidad
de
Texas
)


Steve
Lai
(
Universidad
del
Estado
de
Ohio
)


Tom
LaPorta
(
Universidad
de
Penn
State
)


Tim-Berners
Lee
(
World
Wide
Web
Consortium
)


Lee
Leitner
(
Universidad
de
Drexel
)


Brian
Levine
(
Universidad
de
Massachusetts
)


William
Liang
(
antigua
Universidad
de
Pensilvania
)


Willis
Marti
(
Universidad
de
Texas
A&M
)


Nick
McKeown
(
Universidad
de
Stanford
)


Josh
McKinzie
(
Universidad
de
Park
)


Deep
Medhi
(
Universidad
de
Missouri
,
Kansas
City
)


Bob
Metcalfe
(
International
Data
Group
)


Sue
Moon
(
KAIST
)


Erich
Nahum
(
IBM
Research
)


Christos
Papadopoulos
(
Universidad
del
Estado
de
Colorado
)


Craig
Partridge
(
Tecnolog√≠as
BBN
)


Radia
Perlman
(
Sun
Microsystems
)


Jitendra
Padhye
(
Microsoft
Research
)


Vern
Paxson
(
Universidad
de
California
en
Berkeley
)


Kevin
Phillips
(
Sprint
)


George
Polyzos
(
Universidad
de
Atenas
of
Economics
and
Business
)


Sriram
Rajagopalan
(
Universidad
del
Estado
de
Arizona
)


Ramachandran
Ramjee
(
Microsoft
Research
)


Ken
Reek
(
Instituto
de
Tecnolog√≠a
de
Rochester
)


xvi
Prefacio


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xviPrefacio
xvii


Martin
Reisslein
(
Universidad
del
Estado
de
Arizona
)


Jennifer
Rexford
(
Universidad
de
Princeton
)


Leon
Reznik
(
Instituto
de
Tecnolog√≠a
Rochester
)


Sumit
Roy
(
Universidad
de
Washington
)


Avi
Rubin
(
Universidad
de
Johns
Hopkins
)


Dan
Rubenstein
(
Universidad
de
Columbia
)


Douglas
Salane
(
John
Jay
College
)


Despina
Saparilla
(
Cisco
Systems
)


Henning
Schulzrinne
(
Universidad
de
Columbia
)


Mischa
Schwartz
(
Universidad
de
Columbia
)


Harish
Sethu
(
Universidad
de
Drexel
)


K.
Sam
Shanmugan
(
Universidad
de
Kansas
)


Prashant
Shenoy
(
Universidad
de
Massachusetts
)


Clay
Shields
(
Universidad
de
Georgetown
)


Subin
Shrestra
(
Universidad
de
Pensilvania
)


Mihail
L.
Sichitiu
(
Universidad
de
NC
State
)


Peter
Steenkiste
(
Universidad
de
Carnegie
Mellon
)


Tatsuya
Suda
(
Universidad
de
California
en
Irvine
)


Kin
Sun
Tam
(
Universidad
del
Estado
de
Nueva
York
en
Albany
)


Don
Towsley
(
Universidad
de
Massachusetts
)


David
Turner
(
Universidad
del
Estado
de
California
,
San
Bernardino
)


Nitin
Vaidya
(
Universidad
de
Illinois
)


Michele
Weigle
(
Universidad
de
Clemson
)


David
Wetherall
(
Universidad
de
Washington
)


Ira
Winston
(
Universidad
de
Pensilvania
)


Di
Wu
(
Instituto
Polit√©cnico
de
NYU
)


Raj
Yavatkar
(
Intel
)


Yechiam
Yemini
(
Universidad
de
Columbia
)


Ming
Yu
(
Universidad
del
Estado
de
Nueva
York
en
Binghamton
)


Ellen
Zegura
(
Instituto
de
Tecnolog√≠a
de
Georgia
)


Honggang
Zhang
(
Universidad
de
Suffolk
)


Hui
Zhang
(
Universidad
de
Carnegie
Mellon
)


Lixia
Zhang
(
Universidad
de
California
en
Los
Angeles
)


Shuchun
Zhang
(
former
Universidad
de
Pennsylvania
student
)


Xiaodong
Zhang
(
Universidad
del
Estado
de
Ohio
)


ZhiLi
Zhang
(
Universidad
de
Minnesota
)


Phil
Zimmermann
(
consultor
independiente
)


Cliff
C.
Zou
(
Universidad
de
Central
Florida
)


Queremos
dar
las
gracias
al
profesor
Honggang
Zhang
de
la
Universidad
de
Suffolk
por
tra-


bajar
con
nosotros
durante
la
revisi√≥n
y
mejora
de
los
conjuntos
de
problemas
de
esta
edi-


ci√≥n
.
Tambi√©n
deseamos
dar
las
gracias
al
equipo
completo
de
Addison-Wesley
,
y
en


particular
a
Michael
Hirsch
,
Marilyn
Lloyd
y
Stephanie
Sellinger
,
que
han
hecho
un
trabajo


absolutamente
excelente
en
esta
quinta
edici√≥n
(
y
que
han
sabido
llevar
a
dos
autores
que


parecen
cong√©nitamente
incapaces
de
cumplir
con
los
plazos
)
.
Gracias
tambi√©n
a
nuestros


artistas
,
Janet
Theurer
y
Patrice
Rossi
Calkin
,
por
su
trabajo
en
las
bonitas
figuras
del
libro
,


as√≠
como
a
Nesbitt
Graphics
,
Harry
Druding
y
Rose
Kernan
por
el
maravilloso
trabajo
de
pro-


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xviiducci√≥n
de
esta
edici√≥n
.
Por
√∫ltimo
,
una
gratitud
muy
especial
a
Michael
Hirsch
,
nuestro
edi-


tor
en
Addison-Wesley
,
y
Susan
Hartman
,
nuestra
anterior
editora
de
Addison-Wesley
.
Este


libro
no
ser√≠a
lo
que
es
(
e
incluso
puede
que
nunca
hubiera
llegado
a
ser
)
sin
su
apropiada


gesti√≥n
del
proyecto
,
su
apoyo
constante
,
su
paciencia
casi
infinita
,
su
buen
humor
y
su
per-


severancia
.


xviii
Prefacio


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xviiiContenido


Cap√≠tulo
1
Redes
de
computadoras
e
Internet
     
1


1.1
¬ø
Qu√©
es
Internet
?
2


1.1.1
Descripci√≥n
de
los
componentes
esenciales
2


1.1.2
Descripci√≥n
de
los
servicios
5


1.1.3
¬ø
Qu√©
es
un
protocolo
?
7


1.2
La
frontera
de
la
red
9


1.2.1
Programas
cliente
y
servidor
9


1.2.2
Redes
de
acceso
12


1.2.3
Medios
f√≠sicos
20


1.3
El
n√∫cleo
de
la
red
23


1.3.1
Conmutaci√≥n
de
circuitos
y
conmutaci√≥n
de
paquetes
23


1.3.2
¬ø
C√≥mo
atraviesan
los
paquetes
las
redes
de
conmutaci√≥n
de
paquetes
?
31


1.3.3
Redes
troncales
de
Internet
y
proveedores
ISP
32


1.4
Retardos
,
p√©rdidas
y
tasa
de
transferencia
en
las
redes
de
conmutaci√≥n
 
34


de
paquetes


1.4.1
Retardo
en
las
redes
de
conmutaci√≥n
de
paquetes
35


1.4.2
Retardo
de
cola
y
p√©rdida
de
paquetes
38


1.4.3
Retardo
terminal
a
terminal
40


1.4.4
Tasa
de
transferencia
en
las
redes
de
computadoras
42


1.5
Capas
de
protocolos
y
sus
modelos
de
servicio
46


1.5.1
Arquitectura
en
capas
46


1.5.2
Mensajes
,
segmentos
,
datagramas
y
tramas
52


1.6
Ataques
a
las
redes
53


1.7
Historia
de
Internet
y
de
las
redes
de
computadoras
58


1.7.1
El
desarrollo
de
la
conmutaci√≥n
de
paquetes
:
1961‚Äì1972
58


1.7.2
Redes
propietarias
e
interredes
:
1972‚Äì1980
60


1.7.3
Proliferaci√≥n
de
las
redes
:
1980‚Äì1990
62


1.7.4
La
explosi√≥n
de
Internet
:
d√©cada
de
1990
63


1.7.5
Desarrollos
recientes
64


1.8
Resumen
65


Mapa
de
este
libro
65


Problemas
y
cuestiones
de
repaso
66


Problemas
69


Preguntas
para
la
discusi√≥n
76


Pr√°cticas
de
laboratorio
con
Wireshark
77


Entrevista
:
Leonard
Kleinrock
79


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xixCap√≠tulo
2
La
capa
de
aplicaci√≥n
81


2.1
Principios
de
las
aplicaciones
de
red
82


2.1.1
Arquitecturas
de
las
aplicaciones
de
red
82


2.1.2
Procesos
de
comunicaci√≥n
86


2.1.3
Servicios
de
transporte
disponibles
para
las
aplicaciones
88


2.1.4
Servicios
de
transporte
proporcionados
por
Internet
90


2.1.5
Protocolos
de
la
capa
de
aplicaci√≥n
94


2.1.6
Aplicaciones
de
red
en
este
libro
95


2.2
La
Web
y
HTTP
95


2.2.1
Introducci√≥n
a
HTTP
96


2.2.2
Conexiones
persistentes
y
no
persistentes
98


2.2.3
Formato
de
los
mensajes
HTTP
101


2.2.4
Interacci√≥n
usuario-servidor
:
cookies
105


2.2.5
Almacenamiento
en
cach√©
web
107


2.2.6
GET
condicional
111


2.3
Transferencia
de
archivos
:
FTP
112


2.3.1
Comandos
y
respuestas
de
FTP
114


2.4
Correo
electr√≥nico
en
Internet
115


2.4.1
SMTP
116


2.4.2
Comparaci√≥n
con
HTTP
120


2.4.3
Formatos
de
los
mensajes
de
correo
120


2.4.4
Protocolos
de
acceso
para
correo
electr√≥nico
121


2.5
DNS
:
servicio
de
directorio
de
Internet
125


2.5.1
Servicios
proporcionados
por
DNS
126


2.5.2
C√≥mo
funciona
DNS
128


2.5.3
Registros
y
mensajes
DNS
134


2.6
Aplicaciones
P2P
139


2.6.1
Distribuci√≥n
de
archivos
P2P
139


2.6.2
Tablas
hash
distribuidas
(
DHT
)
145


2.6.3
Caso
de
estudio
:
telefon√≠a
Internet
P2P
con
Skype
150


2.7
Programaci√≥n
de
sockets
con
TCP
151


2.7.1
Programaci√≥n
de
sockets
con
TCP
153


2.7.2
Ejemplo
de
aplicaci√≥n
cliente-servidor
en
Java
154


2.8
Programaci√≥n
de
sockets
con
UDP
161


2.9
Resumen
168


Problemas
y
cuestiones
de
repaso
168


Problemas
171


Preguntas
para
la
discusi√≥n
179


Tareas
sobre
programaci√≥n
de
sockets
180


Pr√°cticas
de
laboratorio
con
Wireshark
181


Entrevista
:
Bram
Cohen
183


Cap√≠tulo
3
La
capa
de
transporte
185


3.1
La
capa
de
transporte
y
sus
servicios
186


3.1.1
Relaciones
entre
las
capas
de
transporte
y
de
red
186


3.1.2
La
capa
de
transporte
en
Internet
189


3.2
Multiplexaci√≥n
y
demultiplexaci√≥n
190


xx
Contenido


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxContenido
xxi


3.3
Transporte
sin
conexi√≥n
:
UDP
198


3.3.1
Estructura
de
los
segmentos
UDP
201


3.3.2
Suma
de
comprobaci√≥n
de
UDP
201


3.4
Principios
de
un
servicio
de
transferencia
de
datos
fiable
203


3.4.1
Construcci√≥n
de
un
protocolo
de
transferencia
de
datos
fiable
205


3.4.2
Protocolo
de
transferencia
de
datos
fiable
con
procesamiento
en
cadena
215


3.4.3
Retroceder
N
(
GBN
)
218


3.4.4
Repetici√≥n
selectiva
(
SR
)
222


3.5
Transporte
orientado
a
la
conexi√≥n
:
TCP
228


3.5.1
La
conexi√≥n
TCP
229


3.5.2
Estructura
del
segmento
TCP
231


3.5.3
Estimaci√≥n
del
tiempo
de
ida
y
vuelta
y
fin
de
temporizaci√≥n
236


3.5.4
Transferencia
de
datos
fiable
239


3.5.5
Control
de
flujo
246


3.5.6
Gesti√≥n
de
la
conexi√≥n
TCP
249


3.6
Principios
del
control
de
congesti√≥n
255


3.6.1
Las
causas
y
los
costes
de
la
congesti√≥n
256


3.6.2
M√©todos
para
controlar
la
congesti√≥n
262


3.6.3
Ejemplo
de
control
de
congesti√≥n
asistido
por
la
red
:
control


de
congesti√≥n
en
el
servicio
ABR
de
las
redes
ATM
263


3.7
Mecanismo
de
control
de
congesti√≥n
de
TCP
265


3.7.1
Equidad
274


3.8
Resumen
277


Problemas
y
cuestiones
de
repaso
280


Problemas
282


Preguntas
para
la
discusi√≥n
294


Tareas
sobre
programaci√≥n
295


Pr√°cticas
de
laboratorio
con
Wireshark
295


Entrevista
:
Sally
Floyd
297


Cap√≠tulo
4
La
capa
de
red
299


4.1
Introducci√≥n
300


4.1.1
Reenv√≠o
y
enrutamiento
300


4.1.2
Modelos
de
servicio
de
red
304


4.2
Redes
de
circuitos
virtuales
y
de
datagramas
306


4.2.1
Redes
de
circuitos
virtuales
307


4.2.2
Redes
de
datagramas
310


4.2.3
Or√≠genes
de
las
redes
de
circuitos
virtuales
y
de
datagramas
312


4.3
El
interior
de
un
router
312


4.3.1
Puertos
de
entrada
314


4.3.2
Entramado
de
conmutaci√≥n
317


4.3.3
Puertos
de
salida
319


4.3.4
¬ø
D√≥nde
se
crean
colas
?
319


4.4
Protocolo
de
Internet
(
IP
):
reenv√≠o
y
direccionamiento
en
Internet
323


4.4.1
Formato
de
los
datagramas
323


4.4.2
Direccionamiento
IPv4
329


4.4.3
Protocolo
de
mensajes
de
control
de
Internet
(
ICMP
)
343


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxi4.4.4
IPv6
345


4.4.5
Una
breve
incursi√≥n
en
la
seguridad
IP
352


4.5
Algoritmos
de
enrutamiento
353


4.5.1
Algoritmo
de
enrutamiento
de
estado
de
enlaces
(
LS
)
356


4.5.2
Algoritmo
de
enrutamiento
por
vector
de
distancias
(
DV
)
360


4.5.3
Enrutamiento
jer√°rquico
367


4.6
Enrutamiento
en
Internet
371


4.6.1
Enrutamiento
interno
de
un
sistema
aut√≥nomo
de
Internet
:
RIP
371


4.6.2
Enrutamiento
interno
de
un
AS
en
Internet
:
OSPF
375


4.6.3
Enrutamiento
entre
sistemas
aut√≥nomos
:
BGP
377


4.7
Enrutamiento
por
difusi√≥n
y
por
multidifusi√≥n
384


4.7.1
Algoritmos
de
enrutamiento
por
difusi√≥n
385


4.7.2
Multidifusi√≥n
390


4.8
Resumen
397


Problemas
y
cuestiones
de
repaso
398


Problemas
401


Preguntas
para
la
discusi√≥n
412


Tareas
sobre
programaci√≥n
413


Pr√°cticas
de
laboratorio
con
Wireshark
414


Entrevista
:
Vinton
G.
Cerf
415


Cap√≠tulo
5
La
capa
de
enlace
y
las
redes
de
√°rea
local
417


5.1
Capa
de
enlace
:
introducci√≥n
y
servicios
419


5.1.1
Servicios
proporcionados
por
la
capa
de
enlace
419


5.1.2
¬ø
D√≥nde
se
implementa
la
capa
de
enlace
?
422


5.2
T√©cnicas
de
detecci√≥n
y
correcci√≥n
de
errores
424


5.2.1
Comprobaciones
de
paridad
425


5.2.2
M√©todos
basados
en
suma
de
comprobaci√≥n
427


5.2.3
Comprobaci√≥n
de
redundancia
c√≠clica
(
CRC
)
428


5.3
Protocolos
de
acceso
m√∫ltiple
430


5.3.1
Protocolos
de
particionamiento
del
canal
433


5.3.2
Protocolos
de
acceso
aleatorio
434


5.3.3
Protocolos
de
toma
de
turnos
441


5.3.4
Redes
de
√°rea
local
(
LAN
)
442


5.4
Direccionamiento
de
la
capa
de
enlace
444


5.4.1
Direcciones
MAC
444


5.4.2
Protocolo
de
resoluci√≥n
de
direcciones
(
ARP
)
445


5.5
Ethernet
450


5.5.1
Estructura
de
la
trama
de
Ethernet
452


5.5.2
CSMA
/
CD
:
protocolo
de
acceso
m√∫ltiple
de
Ethernet
454


5.5.3
Tecnolog√≠as
Ethernet
458


5.6
Conmutadores
de
la
capa
de
enlace
460


5.6.1
Reenv√≠o
y
filtrado
460


5.6.2
Auto-aprendizaje
462


5.6.3
Propiedades
de
la
conmutaci√≥n
de
la
capa
de
enlace
463


5.6.4
Conmutadores
frente
a
routers
464


5.6.5
Redes
de
√°rea
local
virtuales
(
VLAN
)
466


xxii
Contenido


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxiiContenido
xxiii


5.7
PPP
:
Protocolo
punto
a
punto
470


5.7.1
Trama
de
datos
PPP
472


5.8
Virtualizaci√≥n
de
enlaces
:
la
red
como
una
capa
de
enlace
474


5.9
Un
d√≠a
en
la
vida
de
una
solicitud
de
p√°gina
web
477


5.10
Resumen
483


Problemas
y
cuestiones
de
repaso
484


Problemas
486


Preguntas
para
la
discusi√≥n
493


Pr√°cticas
de
laboratorio
con
Wireshark
494


Entrevista
:
Simon
S.
Lam
495


Cap√≠tulo
6
Redes
inal√°mbricas
y
m√≥viles
497


6.1
Introducci√≥n
498


6.2
Caracter√≠sticas
de
las
redes
y
enlaces
inal√°mbricos
503


6.2.1
CDMA
506


6.3
WiFi
:
redes
LAN
inal√°mbricas
802.11
508


6.3.1
La
arquitectura
802.11
510


6.3.2
El
protocolo
MAC
802.11
514


6.3.3
La
trama
IEEE
802.11
520


6.3.4
Movilidad
dentro
de
la
misma
subred
IP
523


6.3.5
Caracter√≠sticas
avanzadas
de
802.11
524


6.3.6
M√°s
all√°
de
802.11
:
Bluetooth
y
WiMAX
526


6.4
Acceso
celular
a
Internet
529


6.4.1
Panor√°mica
de
la
arquitectura
de
las
redes
celulares
530


6.5
Gesti√≥n
de
la
movilidad
:
principios
535


6.5.1
Direccionamiento
538


6.5.2
Enrutamiento
hacia
un
nodo
m√≥vil
539


6.6
IP
m√≥vil
545


6.7
Gesti√≥n
de
la
movilidad
en
redes
celulares
549


6.7.1
Enrutamiento
de
llamadas
hacia
un
usuario
m√≥vil
550


6.7.2
Transferencia
de
llamadas
en
GSM
551


6.8
Tecnolog√≠a
inal√°mbrica
y
movilidad
:
impacto
sobre


los
protocolos
de
las
capas
superiores
555


6.9
Resumen
557


Problemas
y
cuestiones
de
repaso
557


Problemas
559


Preguntas
para
la
discusi√≥n
562


Pr√°cticas
de
laboratorio
con
Wireshark
563


Entrevista
:
Charlie
Perkins
564


Cap√≠tulo
7
Redes
multimedia
567


7.1
Aplicaciones
de
redes
multimedia
568


7.1.1
Ejemplos
de
aplicaciones
multimedia
568


7.1.2
Obst√°culos
para
la
informaci√≥n
multimedia
en
Internet
571


7.1.3
¬ø
C√≥mo
deber√≠a
evolucionar
Internet
para
dar
un
mejor


soporte
a
las
aplicaciones
multimedia
?
572


7.1.4
Compresi√≥n
de
audio
y
v√≠deo
574


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxiii7.2
Flujos
de
audio
y
de
v√≠deo
almacenado
576


7.2.1
Acceso
al
audio
y
al
v√≠deo
a
trav√©s
de
un
servidor
web
578


7.2.2
  
Env√≠o
de
informaci√≥n
multimedia
desde
un
servidor
de
flujos


a
una
aplicaci√≥n
de
ayuda
579


7.2.3
  
Protocolo
de
transmisi√≥n
de
flujos
en
tiempo
real
(
RTSP
)
582


7.3
Utilizaci√≥n
√≥ptima
del
servicio
de
entrega
de
mejor
esfuerzo
585


7.3.1
Limitaciones
de
un
servicio
de
entrega
de
mejor
esfuerzo
586


7.3.2
Eliminaci√≥n
de
las
fluctuaciones
al
reproducir
el
audio
en
el
receptor
588


7.3.3
Recuperaci√≥n
frente
a
p√©rdidas
de
paquetes
592


7.3.4
Distribuci√≥n
multimedia
en
la
red
Internet
actual
:


redes
de
distribuci√≥n
de
contenido
595


7.3.5
Dimensionamiento
de
las
redes
con
servicio
de
entrega


de
mejor
esfuerzo
para
proporcionar
calidad
de
servicio
598


7.4
Protocolos
para
aplicaciones
interactivas
en
tiempo
real
600


7.4.1
RTP
600


7.4.2
Protocolo
de
control
de
RTP
(
RTCP
)
605


7.4.3
SIP
607


7.4.4
H.323
613


7.5
M√∫ltiples
clases
de
servicios
615


7.5.1
Escenarios
616


7.5.2
Mecanismos
de
planificaci√≥n
y
vigilancia
620


7.5.3
Diffserv
627


7.6
Garant√≠as
de
calidad
de
servicio
632


7.6.1
Ejemplo
explicativo
632


7.6.2
Reserva
de
recursos
,
admisi√≥n
de
llamadas
,
establecimiento


de
llamadas
633


7.7
Resumen
638


Problemas
y
cuestiones
de
repaso
640


Problemas
641


Preguntas
para
la
discusi√≥n
647


Tareas
de
programaci√≥n
648


Entrevista
:
Henning
Schulzrinne
650


Cap√≠tulo
8
Seguridad
en
las
redes
de
computadoras
653


8.1
¬ø
Qu√©
es
la
seguridad
de
red
?
654


8.2
Principios
de
la
criptograf√≠a
656


8.2.1
Criptograf√≠a
de
clave
sim√©trica
658


8.2.2
Cifrado
de
clave
p√∫blica
664


8.3
Integridad
de
los
mensajes
y
autenticaci√≥n
de
los
 
puntos
terminales
669


8.3.1
Funciones
hash
criptogr√°ficas
670


8.3.2
C√≥digo
de
autenticaci√≥n
del
mensaje
672


8.3.3
Firmas
digitales
673


8.4
Correo
electr√≥nico
seguro
684


8.4.1
Correo
electr√≥nico
seguro
686


8.4.2
PGP
689


8.5
Conexiones
TCP
seguras
:
SSL
691


8.5.1
Panor√°mica
general
693


xxiv
Contenido


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxivContenido
xxv


8.5.2
Una
panor√°mica
m√°s
completa
695


8.6
Seguridad
de
la
capa
de
red
:
IPsec
y
redes
privadas
virtuales
697


8.6.1
IPsec
y
redes
privadas
virtuales
(
VPN
)
698


8.6.2
Los
protocolos
AH
y
ESP
699


8.6.3
Asociaciones
de
seguridad
700


8.6.4
El
datagrama
IPsec
701


8.6.5
IKE
:
gesti√≥n
de
claves
en
IPsec
704


8.7
Seguridad
de
las
redes
LAN
inal√°mbricas
705


8.7.1
WEP
(
Wired
Equivalent
Privacy
)
706


8.7.2
IEEE
802.11i
708


8.8
 
Seguridad
operacional
:
cortafuegos
y
sistemas
de
detecci√≥n
de
intrusiones
710


8.8.1
Cortafuegos
711


8.8.2
Sistemas
de
detecci√≥n
de
intrusiones
718


8.9
Resumen
721


Problemas
y
cuestiones
de
repaso
723


Problemas
725


Preguntas
para
la
discusi√≥n
731


Pr√°cticas
de
laboratorio
con
Wireshark
731


Pr√°cticas
de
laboratorio
con
IPsec
732


Entrevista
:
Steven
M.
Bellovin
733


Cap√≠tulo
9
Gesti√≥n
de
redes
735


9.1
¬ø
Qu√©
es
la
gesti√≥n
de
redes
?
735


9.2
Infraestructura
para
la
gesti√≥n
de
red
739


9.3
 
El
entorno
de
gesti√≥n
est√°ndar
de
Internet
742


9.3.1
Estructura
de
la
informaci√≥n
de
gesti√≥n
(
SMI
)
745


9.3.2
Base
de
informaci√≥n
de
gesti√≥n
(
MIB
)
749


9.3.3
 
Operaciones
del
protocolo
SNMP
y
correspondencias
de
transporte
751


9.3.4
Seguridad
y
administraci√≥n
754


9.4
ASN.1
757


9.5
Conclusi√≥n
760


Problemas
y
cuestiones
de
repaso
762


Problemas
763


Preguntas
para
la
discusi√≥n
763


Entrevista
:
Jeff
Case
764


Referencias
767


√çndice
793


A01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxvA01_KURO9675_05_SE_FM.qxd
 
22/3/10
 
08:14
 
P√°gina
xxviCAP√çTULO
1


Redes
de


computadoras


e
Internet


1


Hoy
d√≠a
,
Internet
es
casi
indiscutiblemente
el
sistema
de
ingenier√≠a
m√°s
grande
creado
por
la


mano
del
hombre
,
con
cientos
de
millones
de
computadoras
conectadas
,
enlaces
de
comuni-


caciones
y
switches
;
cientos
de
millones
de
usuarios
que
se
conectan
de
forma
intermitente


a
trav√©s
de
sus
tel√©fonos
m√≥viles
y
sus
PDA
;
y
dispositivos
tales
como
sensores
,
c√°maras


web
,
consolas
de
juegos
,
marcos
de
fotograf√≠as
e
incluso
lavadoras
que
se
conectan
a
Inter-


net
.
Dado
que
Internet
es
una
red
tan
enorme
e
incluye
tantos
componentes
distintos
y
tiene


tantos
usos
,
¬ø
es
posible
tener
la
esperanza
de
comprender
c√≥mo
funciona
y
,
m√°s
concreta-


mente
,
c√≥mo
funcionan
las
redes
de
computadoras
?
¬ø
Existen
unos
principios
y
una
estruc-


tura
b√°sicos
que
puedan
proporcionar
una
base
para
comprender
un
sistema
tan


asombrosamente
complejo
y
grande
?
Y
,
en
caso
afirmativo
,
¬ø
es
posible
que
pueda
resultar


tan
interesante
y
divertido
como
para
dedicarse
a
estudiar
las
redes
de
computadoras
?
Afor-


tunadamente
,
la
respuesta
a
todas
estas
preguntas
es
un
rotundo
S√ç
.
Ciertamente
,
el
objetivo


de
este
libro
es
el
de
iniciar
al
lector
en
el
din√°mico
campo
de
las
redes
de
computadoras
,


proporcion√°ndole
los
principios
y
los
conocimientos
pr√°cticos
que
necesitar√°
para
entender


no
s√≥lo
las
redes
actuales
,
sino
tambi√©n
las
del
futuro
.


En
el
primer
cap√≠tulo
se
hace
una
amplia
introducci√≥n
al
mundo
de
las
redes
de
compu-


tadoras
y
de
Internet
.
Nuestro
objetivo
es
proporcionar
una
visi√≥n
general
y
establecer
el


contexto
para
el
resto
del
libro
,
con
el
fin
de
poder
ver
el
bosque
a
trav√©s
de
los
√°rboles
.
En


este
cap√≠tulo
de
introducci√≥n
se
abordan
muchos
de
los
fundamentos
,
as√≠
como
muchos
de


los
componentes
que
forman
una
red
de
computadoras
,
siempre
sin
perder
de
vista
la
pano-


r√°mica
general
.


Vamos
a
estructurar
esta
introducci√≥n
a
las
redes
de
computadoras
de
la
siguiente


forma
:
despu√©s
de
exponer
algunos
conceptos
y
t√©rminos
fundamentales
,
examinaremos
los


componentes
esenciales
que
forman
una
red
de
computadoras
.
Comenzaremos
por
la
fron-


tera
de
la
red
y
echaremos
un
vistazo
a
los
sistemas
terminales
y
aplicaciones
que
se
ejecu-


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
1tan
en
la
red
.
A
continuaci√≥n
,
exploraremos
el
n√∫cleo
de
una
red
de
computadoras
,
exami-


nando
los
enlaces
y
los
switches
que
transportan
los
datos
,
as√≠
como
las
redes
de
acceso
y


los
medios
f√≠sicos
que
conectan
los
sistemas
terminales
con
el
n√∫cleo
de
la
red
.
Aprendere-


mos
que
Internet
es
una
red
de
redes
y
c√≥mo
estas
redes
se
conectan
entre
s√≠
.


Una
vez
completada
la
introducci√≥n
sobre
la
frontera
y
el
n√∫cleo
de
una
red
de
compu-


tadoras
,
en
la
segunda
mitad
del
cap√≠tulo
adoptaremos
un
punto
de
vista
m√°s
amplio
y
abs-


tracto
.
Examinaremos
los
retardos
,
las
p√©rdidas
y
la
tasa
de
transferencia
de
datos
en
una
red


de
computadoras
y
proporcionaremos
modelos
cuantitativos
simples
para
los
retardos
y


tasas
de
transferencia
de
terminal
a
terminal
:
modelos
que
tienen
en
cuenta
los
retardos
de


transmisi√≥n
,
de
propagaci√≥n
y
de
cola
.
A
continuaci√≥n
,
presentaremos
algunos
de
los
princi-


pios
b√°sicos
sobre
las
arquitecturas
de
red
,
en
concreto
,
las
capas
de
protocolos
y
los
mode-


los
de
servicios
.
Tambi√©n
veremos
que
las
redes
son
vulnerables
a
muchos
tipos
distintos
de


ataques
;
revisaremos
algunos
de
estos
ataques
y
veremos
c√≥mo
es
posible
conseguir
que
las


redes
sean
m√°s
seguras
.
Por
√∫ltimo
,
concluiremos
el
cap√≠tulo
con
una
breve
historia
de


las
redes
de
comunicaciones
.


1.1
¬ø
Qu√©
es
Internet
?


En
este
libro
,
vamos
a
emplear
la
red
p√∫blica
Internet
,
una
red
de
computadoras
espec√≠fica
,


como
nuestro
principal
veh√≠culo
para
explicar
las
redes
de
computadoras
y
sus
protocolos
.


Pero
,
¬ø
qu√©
es
Internet
?
Hay
dos
formas
de
responder
a
esta
pregunta
.
La
primera
de
ellas
es


describiendo
las
tuercas
y
tornillos
que
forman
la
red
;
es
decir
,
los
componentes
hardware
y


software
b√°sicos
que
forman
Internet
.
La
segunda
es
describi√©ndola
en
t√©rminos
de
la
infra-


estructura
de
red
que
proporciona
servicios
a
aplicaciones
distribuidas
.
Comenzaremos
por


la
descripci√≥n
de
los
componentes
esenciales
,
utilizando
la
Figura
1.1
para
ilustrar
la
expo-


sici√≥n
.


1.1.1
Descripci√≥n
de
los
componentes
esenciales


Internet
es
una
red
de
computadoras
que
interconecta
cientos
de
millones
de
dispositivos


inform√°ticos
a
lo
largo
de
todo
el
mundo
.
No
hace
demasiado
tiempo
,
estos
dispositivos
eran


fundamentalmente
computadoras
PC
de
escritorio
tradicionales
,
estaciones
de
trabajo
Linux


y
los
llamados
servidores
que
almacenaban
y
transmit√≠an
informaci√≥n
tal
como
p√°ginas
web


y
mensajes
de
correo
electr√≥nico
.
Sin
embargo
,
cada
vez
m√°s
sistemas
terminales
no
tradi-


cionales
como
televisiones
,
computadoras
port√°tiles
,
consolas
de
juegos
,
tel√©fonos
m√≥viles
,


c√°maras
web
,
sistemas
de
detecci√≥n
medioambientales
y
de
autom√≥viles
y
dispositivos
de


seguridad
y
electrodom√©sticos
est√°n
conectados
a
Internet
.
Por
tanto
,
el
t√©rmino
red
de
com-


putadoras
est√°
comenzando
a
quedar
algo
desactualizado
a
causa
de
la
gran
cantidad
de
dis-


positivos
no
tradicionales
que
est√°n
conectados
a
Internet
.
En
la
jerga
de
Internet
,
todos


estos
dispositivos
se
denominan
hosts
o
sistemas
terminales
.
En
julio
de
2008
,
hab√≠a
casi


600
millones
de
sistemas
terminales
conectados
a
Internet
[
ISC
2009
]
,
sin
contar
los
tel√©fo-


nos
m√≥viles
,
las
computadoras
port√°tiles
y
otros
dispositivos
que
se
conectan
de
forma
inter-


mitente
a
Internet
.


Los
sistemas
terminales
se
conectan
entre
s√≠
mediante
una
red
de
enlaces
de
comunica-


ciones
y
dispositivos
de
conmutaci√≥n
de
paquetes
.
En
la
Secci√≥n
1.2
veremos
que
existen


muchos
tipos
de
enlaces
de
comunicaciones
,
los
cuales
est√°n
compuestos
por
diferentes


2
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
21.1
‚Ä¢
¬ø
QU√â
ES
INTERNET
?
3


Clave
:


Host


(
o
sistema
terminal
)


Servidor
Dispositivo


m√≥vil


Conmutador


de
paquetes


M√≥dem
Estaci√≥n


base


Tel√©fono


m√≥vil


Torre
de


telefon√≠a


m√≥vil


ISP
nacional
o


globalRed


m√≥vil


ISP
local
o


regional


Red
empresarial


Red
dom√©stica


Figura
1.1
‚Ä¢
Algunos
de
los
componentes
esenciales
de
Internet
.


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
3tipos
de
medios
f√≠sicos
,
entre
los
que
se
incluyen
el
cable
coaxial
,
el
hilo
de
cobre
,
la
fibra


√≥ptica
y
el
espectro
de
radio
.
Los
distintos
enlaces
pueden
transmitir
los
datos
a
distintas


velocidades
y
la
velocidad
de
transmisi√≥n
de
un
enlace
se
mide
en
bits
/
segundo
.
Cuando


un
sistema
terminal
tiene
que
enviar
datos
a
otro
sistema
terminal
,
el
emisor
segmenta
los


datos
y
a√±ade
bits
de
cabecera
a
cada
segmento
.
Los
paquetes
de
informaci√≥n
resultantes
,


conocidos
como
paquetes
en
la
jerga
inform√°tica
,
se
env√≠an
entonces
a
trav√©s
de
la
red
hasta


el
sistema
terminal
receptor
,
donde
vuelven
a
ser
ensamblados
para
obtener
los
datos
origi-


nales
.


Un
conmutador
de
paquetes
toma
el
paquete
que
llega
de
uno
de
sus
enlaces
de
comu-


nicaciones
de
entrada
y
lo
reenv√≠a
a
uno
de
sus
enlaces
de
comunicaciones
de
salida
.
Los


dispositivos
de
conmutaci√≥n
de
paquetes
se
suministran
en
muchas
formas
y
modelos
,
pero


los
dos
tipos
m√°s
utilizados
actualmente
en
Internet
son
los
routers
y
los
switches
de
la


capa
de
enlace
.
Ambos
tipos
reenv√≠an
los
paquetes
hacia
sus
destinos
finales
.
Los
switches


de
la
capa
de
enlace
normalmente
se
emplean
en
las
redes
de
acceso
,
mientras
que
los
rou-


ters
suelen
utilizarse
en
el
n√∫cleo
de
la
red
.
La
secuencia
de
enlaces
de
comunicaciones
y


conmutadores
de
paquetes
que
atraviesa
un
paquete
desde
el
sistema
terminal
emisor
hasta


el
sistema
terminal
receptor
se
conoce
como
ruta
a
trav√©s
de
la
red
.
Es
dif√≠cil
estimar
la
can-


tidad
exacta
de
tr√°fico
que
se
transporta
a
trav√©s
de
Internet
[
Odylsko
2003
]
.
Pri-Metrica


[
PriMetrica
2009
]
estima
que
,
en
2008
,
los
proveedores
de
Internet
emplearon
10
terabits


por
segundo
de
capacidad
internacional
y
que
dicha
capacidad
se
duplica
aproximadamente


cada
dos
a√±os
.


Las
redes
de
conmutaci√≥n
de
paquetes
(
que
transportan
paquetes
)
son
similares
en


muchos
aspectos
a
las
redes
de
transporte
formadas
por
autopistas
,
carreteras
e
interseccio-


nes
(
que
transportan
veh√≠culos
)
.
Por
ejemplo
,
imagine
que
una
f√°brica
necesita
trasladar
un


enorme
cargamento
a
un
cierto
almac√©n
de
destino
que
se
encuentra
a
miles
de
kil√≥metros
.


En
la
f√°brica
,
el
cargamento
se
reparte
y
se
carga
en
una
flota
de
camiones
.
Cada
cami√≥n


hace
el
viaje
hasta
el
almac√©n
de
destino
de
forma
independiente
a
trav√©s
de
la
red
de
auto-


pistas
,
carreteras
e
intersecciones
.
En
el
almac√©n
de
destino
,
la
carga
de
cada
cami√≥n
se
des-


carga
y
se
agrupa
con
el
resto
del
cargamento
a
medida
que
va
llegando
.
Luego
,
en
cierto


sentido
,
los
paquetes
son
como
los
camiones
,
los
enlaces
de
comunicaciones
como
las
auto-


pistas
y
carreteras
,
los
dispositivos
de
conmutaci√≥n
de
paquetes
como
las
intersecciones
y


los
sistemas
terminales
son
como
los
edificios
(
la
f√°brica
y
el
almac√©n
)
.
Al
igual
que
un


cami√≥n
sigue
una
ruta
a
trav√©s
de
la
red
de
transporte
por
carretera
,
un
paquete
sigue
una


ruta
a
trav√©s
de
una
red
de
computadoras
.


Los
sistemas
terminales
acceden
a
Internet
a
trav√©s
de
los
ISP
(
Internet
Service
Provi-


der
,
Proveedor
de
servicios
de
Internet
)
,
incluyendo
los
ISP
residenciales
como
son
las


compa√±√≠as
telef√≥nicas
o
de
cable
locales
;
los
ISP
corporativos
;
los
ISP
universitarios
y
los


ISP
que
proporcionan
acceso
inal√°mbrico
(
WiFi
)
en
aeropuertos
,
hoteles
,
caf√©s
y
otros
luga-


res
p√∫blicos
.
Cada
ISP
es
en
s√≠
mismo
una
red
de
conmutadores
de
paquetes
y
enlaces
de


comunicaciones
.
Los
ISP
proporcionan
una
amplia
variedad
de
tipos
de
acceso
a
red
a
los


sistemas
terminales
,
entre
los
que
se
incluyen
el
acceso
a
trav√©s
de
m√≥dem
de
acceso
telef√≥-


nico
a
56
kbps
,
el
acceso
de
banda
ancha
residencial
,
mediante
m√≥dem
por
cable
o
DSL
,
el


acceso
LAN
(
Local
Area
Network
,
Red
de
√°rea
local
)
de
alta
velocidad
y
el
acceso
inal√°m-


brico
.
Los
ISP
tambi√©n
proporcionan
acceso
a
Internet
a
los
proveedores
de
contenido
,


conectando
sitios
web
directamente
a
Internet
.
Internet
es
todo
lo
que
conecta
a
los
sistemas


terminales
entre
s√≠
,
por
lo
que
los
ISP
que
proporcionan
el
acceso
a
los
sistemas
terminales


tambi√©n
tienen
que
estar
interconectados
entre
ellos
.
Estos
ISP
de
nivel
inferior
se
interco-


4
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
4nectan
a
trav√©s
de
los
ISP
de
nivel
superior
nacionales
e
internacionales
,
como
AT&T
y


Sprint
.
Un
ISP
de
nivel
superior
consiste
en
routers
de
alta
velocidad
interconectados
a
tra-


v√©s
de
enlaces
de
fibra
√≥ptica
de
alta
velocidad
.
La
red
de
cada
ISP
,
sea
de
nivel
inferior
o


superior
,
se
administra
de
forma
independiente
,
ejecuta
el
protocolo
IP
(
v√©ase
m√°s
adelante
)


y
se
ajusta
a
determinados
convenios
de
denominaci√≥n
y
de
asignaci√≥n
de
direcciones
.
En
la


Secci√≥n
1.3
examinaremos
m√°s
detalladamente
los
ISP
y
sus
interconexiones
.


Los
sistemas
terminales
,
los
conmutadores
de
paquetes
y
otros
dispositivos
de
Internet


ejecutan
protocolos
que
controlan
el
env√≠o
y
la
recepci√≥n
de
la
informaci√≥n
dentro
de
Inter-


net
.
El
protocolo
TCP
(
Transmission
Control
Protocol
,
Protocolo
de
control
de
transmi-


si√≥n
)
y
el
protocolo
IP
(
Internet
Protocol
,
Protocolo
de
Internet
)
son
dos
de
los
protocolos


m√°s
importantes
de
Internet
.
El
protocolo
IP
especifica
el
formato
de
los
paquetes
que
se


env√≠an
y
reciben
entre
los
routers
y
los
sistemas
terminales
.
Los
principales
protocolos
de


Internet
se
conocen
colectivamente
como
protocolos
TCP
/
IP
.
En
este
cap√≠tulo
de
introduc-


ci√≥n
comenzaremos
a
estudiar
los
protocolos
,
pero
esto
s√≥lo
es
el
principio
,
ya
que
gran


parte
del
libro
se
dedica
a
los
protocolos
empleados
por
las
redes
de
computadoras
.


Debido
a
la
importancia
de
los
protocolos
en
Internet
,
es
importante
que
todo
el
mundo


est√©
de
acuerdo
en
qu√©
hacen
todos
y
cada
uno
de
ellos
,
siendo
aqu√≠
donde
entran
en
juego


los
est√°ndares
.
Los
est√°ndares
de
Internet
son
desarrollados
por
el
IETF
(
Internet
Engine-


ering
Task
Force
)
[
IETF
2009
]
.
Los
documentos
asociados
a
estos
est√°ndares
IETF
se
cono-


cen
como
documentos
RFC
(
Request
For
Comments
,
Solicitud
de
comentarios
)
.
Los
RFC


nacieron
como
solicitudes
de
comentarios
de
car√°cter
general
(
de
ah√≠
su
nombre
)
para
solu-


cionar
los
problemas
de
dise√±o
de
la
red
y
de
los
protocolos
a
los
que
se
enfrent√≥
el
precur-


sor
de
Internet
.
El
contenido
de
estos
documentos
suele
ser
bastante
t√©cnico
y
detallado
.


Definen
protocolos
tales
como
TCP
,
IP
,
HTTP
(
para
la
Web
)
y
SMTP
(
para
el
correo
elec-


tr√≥nico
)
.
Actualmente
,
existen
m√°s
de
5.000
documentos
RFC
.
Existen
tambi√©n
otros
orga-


nismos
dedicados
a
especificar
est√°ndares
para
componentes
de
red
,
m√°s
espec√≠ficamente


para
los
enlaces
de
red
.
El
comit√©
de
est√°ndares
IEEE
802
LAN
/
MAN
[
IEEE
802
2009
]
,
por


ejemplo
,
especifica
los
est√°ndares
para
redes
Ethernet
y
WiFi
.


1.1.2
Descripci√≥n
de
los
servicios


Hasta
el
momento
hemos
identificado
muchos
de
los
componentes
que
forman
Internet
,
pero


tambi√©n
podemos
describir
Internet
desde
un
punto
de
vista
completamente
diferente
,
en


concreto
como
una
infraestructura
que
proporciona
servicios
a
las
aplicaciones
.
Entre
estas


aplicaciones
se
incluyen
el
correo
electr√≥nico
,
la
navegaci√≥n
web
,
la
mensajer√≠a
instant√°nea
,


Vo
z
 
s
o
b
r
e
 
I
P
(
Vo
I
P
)
,
 
l
a
 
r
a
d
i
o
 
p
o
r
 
I
n
t
e
r
n
e
t
,
 
l
o
s
 
f
l
u
j
o
s
 
d
e
 
v
√≠
d
e
o
,
 
l
o
s
 
j
u
e
g
o
s
 
d
i
s
t
r
i
b
u
i
d
o
s
,
 
l
a


compartici√≥n
de
archivos
en
redes
entre
iguales
o
entre
pares
(
P2P
,
Peer-to-peer
)
,
la
televi-


si√≥n
a
trav√©s
de
Internet
,
las
sesiones
remotas
y
otras
muchas
.
Se
dice
que
las
aplicaciones


son
aplicaciones
distribuidas
,
p
o
r
q
u
e
 
i
m
p
l
i
c
a
n
 
a
 
v
a
r
i
o
s
 
s
i
s
t
e
m
a
s
 
t
e
r
m
i
n
a
l
e
s
 
q
u
e
 
i
n
t
e
r
c
a
m
-


bian
datos
entre
s√≠
.
Es
importante
saber
que
las
aplicaciones
de
Internet
se
ejecutan
en
los


sistemas
terminales
,
no
en
los
conmutadores
de
paquetes
disponibles
en
el
n√∫cleo
de
la
red
.


Aunque
los
dispositivos
de
conmutaci√≥n
de
paquetes
facilitan
el
intercambio
de
datos
entre


sistemas
terminales
,
no
se
preocupan
de
la
aplicaci√≥n
que
est√©
actuando
como
origen
o
des-


tino
de
los
datos
.


Vamos
a
ahondar
un
poco
m√°s
en
lo
que
queremos
decir
con
una
infraestructura
que


proporciona
servicios
a
las
aplicaciones
.
Para
ello
,
supongamos
que
tenemos
una
excitante


1.1
‚Ä¢
¬ø
QU√â
ES
INTERNET
?
5


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
5nueva
idea
para
una
aplicaci√≥n
distribuida
de
Internet
,
que
puede
beneficiar
enormemente


a
la
humanidad
o
que
simplemente
puede
hacernos
ricos
y
famosos
.
¬ø
C√≥mo
podr√≠amos


transformar
esa
idea
en
una
aplicaci√≥n
real
de
Internet
?
Puesto
que
las
aplicaciones
se
eje-


cutan
en
los
sistemas
terminales
,
tendremos
que
escribir
programas
software
que
se
ejecu-


ten
en
dichos
sistemas
.
Por
ejemplo
,
podr√≠amos
escribir
programas
en
Java
,
C
o
Python
.


Ahora
bien
,
dado
que
estamos
desarrollando
una
aplicaci√≥n
Internet
distribuida
,
los
pro-


gramas
que
se
ejecuten
en
los
distintos
sistemas
terminales
tendr√°n
que
enviarse
datos
entre


s√≠
.
Y
aqu√≠
es
cuando
llegamos
al
meollo
de
la
cuesti√≥n
,
a
la
que
nos
lleva
a
la
forma
alter-


nativa
de
describir
Internet
como
una
plataforma
para
aplicaciones
.
¬ø
C√≥mo
una
aplicaci√≥n


que
se
ejecuta
en
un
sistema
terminal
instruye
a
Internet
para
entregar
datos
a
otro
pro-


grama
que
se
ejecuta
en
otro
sistema
terminal
?


Los
sistemas
terminales
conectados
a
Internet
proporcionan
una
API
(
Application
Pro-


gramming
Interface
,
Interfaz
de
programaci√≥n
de
aplicaciones
)
,
que
especifica
c√≥mo
un


programa
de
software
que
se
ejecuta
en
un
sistema
terminal
pide
a
la
infraestructura
de
Inter-


net
que
suministre
datos
a
un
programa
de
software
de
destino
espec√≠fico
que
se
ejecuta
en


otro
sistema
terminal
.
La
API
de
Internet
consta
de
un
conjunto
de
reglas
que
el
programa


que
transmite
los
datos
debe
cumplir
para
que
Internet
pueda
entregar
esos
datos
al
programa


de
destino
.
En
el
Cap√≠tulo
2
se
aborda
en
detalle
la
API
de
Internet
.
Por
el
momento
,
veamos


una
sencilla
analog√≠a
,
una
que
emplearemos
con
frecuencia
a
lo
largo
de
este
libro
.
Suponga-


mos
que
Alicia
desea
enviar
una
carta
a
Benito
utilizando
el
servicio
postal
.
Por
supuesto
,


Alicia
no
puede
escribir
la
carta
(
los
datos
)
y
lanzar
la
carta
por
la
ventana
.
En
lugar
de
ello
,


ser√°
necesario
que
Alicia
introduzca
la
carta
en
un
sobre
,
escriba
el
nombre
completo
de


Benito
,
su
direcci√≥n
y
c√≥digo
postal
en
el
sobre
,
lo
cierre
y
pegue
un
sello
en
la
esquina
supe-


rior
derecha
del
sobre
.
Por
√∫ltimo
,
tendr√°
que
introducir
el
sobre
en
un
buz√≥n
del
servicio


postal
.
Por
tanto
,
el
servicio
postal
de
correos
tiene
su
propia
‚Äú
API
de
servicio
postal
‚Äù
,
es


decir
,
su
propio
conjunto
de
reglas
,
que
Alicia
debe
seguir
para
que
el
servicio
de
correos


entregue
su
carta
a
Benito
.
De
forma
similar
,
Internet
tiene
una
API
que
el
programa
que


env√≠a
los
datos
debe
seguir
para
que
Internet
entregue
los
datos
al
software
que
los
recibir√°
.


Por
supuesto
,
el
servicio
de
correos
proporciona
m√°s
de
un
servicio
a
sus
clientes
,
como


correo
urgente
,
acuse
de
recibo
,
correo
ordinario
y
otros
muchos
.
Del
mismo
modo
,
Internet


proporciona
m√∫ltiples
servicios
a
sus
aplicaciones
.
Cuando
desarrolle
una
aplicaci√≥n
de


Internet
,
tambi√©n
tendr√°
que
seleccionar
uno
de
los
servicios
de
Internet
para
su
aplicaci√≥n
.


En
el
Cap√≠tulo
2
describiremos
los
servicios
de
Internet
.


Esta
segunda
descripci√≥n
de
Internet
,
una
infraestructura
que
permite
proporcionar
ser-


vicios
a
aplicaciones
distribuidas
,
es
muy
importante
.
Cada
vez
m√°s
,
las
necesidades
de
las


nuevas
aplicaciones
est√°n
dirigiendo
los
avances
de
los
componentes
esenciales
de
Internet
.


Por
tanto
,
es
importante
tener
presente
que
Internet
es
una
infraestructura
en
la
que
se
est√°n


inventando
e
implementando
constantemente
nuevas
aplicaciones
.


Aqu√≠
s√≥lo
hemos
dado
dos
descripciones
de
Internet
;
una
en
t√©rminos
de
sus
componen-


tes
esenciales
y
otra
como
infraestructura
que
permite
proporcionar
servicios
a
aplicaciones


distribuidas
.
Pero
es
posible
que
todav√≠a
no
tenga
claro
qu√©
es
Internet
.
¬ø
Qu√©
es
la
conmuta-


ci√≥n
de
paquetes
,
TCP
/
IP
y
una
API
?
¬ø
Qu√©
son
los
routers
?
¬ø
Qu√©
tipos
de
enlaces
de
comu-


nicaciones
existen
en
Internet
?
¬ø
Qu√©
es
una
aplicaci√≥n
distribuida
?
¬ø
C√≥mo
puede
una


tostadora
o
un
sensor
de
temperatura
conectarse
a
Internet
?
Si
se
siente
un
poco
abrumado


por
todas
estas
preguntas
,
no
se
preocupe
,
el
prop√≥sito
de
este
libro
es
presentarle
tanto
los


componentes
hardware
como
software
de
Internet
,
as√≠
como
los
principios
que
regulan
c√≥mo


y
por
qu√©
funciona
.
En
las
siguientes
secciones
y
cap√≠tulos
explicaremos
todos
estos
t√©rmi-


nos
y
daremos
respuesta
a
estas
cuestiones
.


6
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
61.1.3
¬ø
Qu√©
es
un
protocolo
?


Ahora
que
ya
hemos
visto
por
encima
para
qu√©
sirve
Internet
,
vamos
a
ocuparnos
de
otro


t√©rmino
importante
en
el
mundo
de
las
redes
de
computadoras
:
protocolo
.
¬ø
Qu√©
es
un
proto-


colo
?
¬ø
Qu√©
hace
un
protocolo
?


Analog√≠a
humana


Probablemente
,
sea
m√°s
sencillo
comprender
el
concepto
de
protocolo
de
red
considerando


en
primer
lugar
algunas
analog√≠as
humanas
,
ya
que
las
personas
llevamos
a
cabo
protocolos


casi
constantemente
.
Piense
en
lo
que
hace
cuando
necesita
preguntar
a
alguien
qu√©
hora
es
.


En
la
Figura
1.2
se
muestra
c√≥mo
se
lleva
a
cabo
un
intercambio
de
este
tipo
.
El
protocolo


entre
personas
(
o
las
buenas
maneras
,
al
menos
)
dicta
que
para
iniciar
un
proceso
de
comuni-


caci√≥n
con
alguien
lo
primero
es
saludar
(
el
primer
‚Äú
Hola
‚Äù
mostrado
en
la
Figura
1.2
)
.
La


respuesta
t√≠pica
a
este
saludo
ser√°
tambi√©n
‚Äú
Hola
‚Äù
.
Impl√≠citamente
,
el
saludo
de
respuesta
se


toma
como
una
indicaci√≥n
de
que
se
puede
continuar
con
el
proceso
de
comunicaci√≥n
y
pre-


guntar
la
hora
.
Una
respuesta
diferente
al
‚Äú
hola
‚Äù
inicial
(
como
por
ejemplo
,
¬°
No
me
moleste
‚Äù


o
‚Äú
No
hablo
su
idioma
‚Äù
,
o
cualquier
otra
respuesta
impublicable
no
debemos
escribir
)
indi-


car√°
una
indisposici√≥n
o
incapacidad
para
comunicarse
.
En
este
caso
,
el
protocolo
de
las
rela-


ciones
entre
personas
establece
que
no
debe
preguntarse
la
hora
.
En
ocasiones
,
no
se
obtiene


ninguna
respuesta
,
en
cuyo
caso
habr√°
que
renunciar
a
preguntar
a
esa
persona
la
hora
que


es
.
Tenga
en
cuenta
que
,
en
el
protocolo
entre
personas
,
existen
mensajes
espec√≠ficos
que


1.1
‚Ä¢
¬ø
QU√â
ES
INTERNET
?
7


GET
http://www.awl.com/kurose-ross


Solicitud
de
conexi√≥n
TCP


Tiempo
Tiempo


Respuesta
de
conexi√≥n
TCP


<
archivo
>


Hola


¬ø
Qu√©
hora
es
?


Tiempo
Tiempo


Hola


2:00


Figura
1.2
‚Ä¢
Un
protocolo
humano
y
un
protocolo
de
red
.


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
7enviamos
y
acciones
espec√≠ficas
que
tomamos
como
respuesta
a
los
mensajes
de
contesta-


ci√≥n
recibidos
o
a
otros
sucesos
(
como
por
ejemplo
no
recibir
una
respuesta
en
un
periodo


de
tiempo
determinado
)
.
Evidentemente
,
los
mensajes
transmitidos
y
recibidos
y
las
accio-


nes
tomadas
al
enviar
o
recibir
estos
mensajes
u
otros
sucesos
desempe√±an
un
papel
princi-


pa
l
en
el
protocolo
humano
.
Si
las
personas
adoptan
protocolos
diferentes
(
por
ejemplo
,
si


una
persona
guarda
las
formas
pero
la
otra
no
lo
hace
,
o
si
uno
comprende
el
concepto
de


tiempo
y
el
otro
no
)
,
los
protocolos
no
interoperar√°n
y
la
comunicaci√≥n
no
podr√°
tener
lugar
.


Esta
misma
idea
tambi√©n
es
aplicable
a
las
redes
:
es
necesario
que
las
entidades
(
dos
o
m√°s
)


que
deseen
comunicarse
ejecuten
el
mismo
protocolo
para
poder
llevar
a
cabo
la
tarea
.


Consideremos
ahora
una
segunda
analog√≠a
humana
.
Suponga
que
est√°
asistiendo
a
una


clase
(
por
ejemplo
,
sobre
redes
)
.
El
profesor
est√°
hablando
acerca
de
los
protocolos
y
usted


no
le
comprende
.
El
profesor
detiene
su
explicaci√≥n
y
dice
:
‚Äú
¬ø
Alguna
pregunta
?
‚Äù
(
un
men-


saje
dirigido
a
todos
los
estudiantes
,
que
no
est√°n
dormidos
,
y
que
todos
ellos
reciben
)
.


Usted
levanta
la
mano
(
transmitiendo
un
mensaje
impl√≠cito
al
profesor
)
.
El
profesor
le
dirige


una
sonrisa
y
le
dice
‚Äú
¬ø
Si
.
.
.
?
‚Äù
(
mensaje
que
le
anima
a
plantear
su
pregunta
,
ya
que
los
pro-


fesores
adoran
que
les
planteen
cuestiones
)
y
,
a
continuaci√≥n
,
usted
hace
la
pregunta
(
es


decir
,
transmite
su
mensaje
al
profesor
)
.
El
profesor
escucha
la
pregunta
(
recibe
su
mensaje
)


y
le
responde
(
le
transmite
una
respuesta
)
.
De
nuevo
,
vemos
que
la
transmisi√≥n
y
la
recep-


ci√≥n
de
mensajes
y
el
conjunto
de
acciones
convencionales
tomadas
cuando
se
env√≠an
y
reci-


ben
estos
mensajes
,
constituyen
el
n√∫cleo
de
este
protocolo
de
pregunta-respuesta
.


Protocolos
de
red


Un
protocolo
de
red
es
similar
a
un
protocolo
humano
,
excepto
en
que
las
entidades
que


intercambian
mensajes
y
llevan
a
cabo
las
acciones
son
los
componentes
hardware
o
soft-


ware
de
cierto
dispositivo
(
por
ejemplo
,
una
computadora
,
una
PDA
,
un
tel√©fono
m√≥vil
,
un


router
u
otro
dispositivo
de
red
)
.
Cualquier
actividad
de
Internet
que
implique
dos
o
m√°s


entidades
remotas
que
se
comunican
est√°
gobernada
por
un
protocolo
.
Por
ejemplo
,
los
pro-


tocolos
implementados
por
hardware
en
las
tarjetas
de
interfaz
de
red
de
dos
computadoras


conectadas
f√≠sicamente
controlan
el
flujo
de
bits
a
trav√©s
del
‚Äú
cable
‚Äù
conectado
entre
las
dos


tarjetas
de
interfaz
de
red
;
los
protocolos
de
control
de
congesti√≥n
de
los
sistemas
terminales


controlan
la
velocidad
a
la
que
se
transmiten
los
paquetes
entre
el
emisor
y
el
receptor
;
los


protocolos
de
los
routers
determinan
la
ruta
que
seguir√°
un
paquete
desde
el
origen
al
des-


tino
.
Los
protocolos
se
ejecutan
por
todas
partes
en
Internet
y
,
en
consecuencia
,
gran
parte


de
este
libro
est√°
dedicada
a
los
protocolos
de
redes
de
computadoras
.


Bas√°ndonos
en
un
protocolo
de
red
con
el
que
probablemente
estar√°
familiarizado
,


vamos
a
ver
lo
que
ocurre
cuando
se
hace
una
solicitud
a
un
servidor
web
,
es
decir
,
cuando


usted
escribe
el
URL
de
una
p√°gina
web
en
un
navegador
.
Este
escenario
se
ilustra
en
la


mitad
derecha
de
la
Figura
1.2
.
En
primer
lugar
,
su
computadora
enviar√°
un
mensaje
de
soli-


citud
de
conexi√≥n
al
servidor
web
y
esperar√°
una
respuesta
.
El
servidor
web
recibir√°
su
men-


saje
de
solicitud
y
le
devolver√°
un
mensaje
de
respuesta
de
conexi√≥n
.
Sabiendo
ahora
que
es


posible
solicitar
el
documento
web
,
su
computadora
env√≠a
el
nombre
de
la
p√°gina
web
que


desea
extraer
del
servidor
web
mediante
un
mensaje
GET
.
Por
√∫ltimo
,
el
servidor
web
env√≠a


la
p√°gina
web
(
archivo
)
a
su
computadora
.


Bas√°ndonos
en
los
ejemplos
anteriores
de
protocolos
humanos
y
de
red
,
el
intercambio


de
mensajes
y
las
acciones
tomadas
cuando
se
env√≠an
y
reciben
estos
mensajes
constituyen


los
elementos
claves
para
la
definici√≥n
de
un
protocolo
:


8
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
8Un
protocolo
define
el
formato
y
el
orden
de
los
mensajes
intercambiados
entre
dos
o


m√°s
entidades
que
se
comunican
,
as√≠
como
las
acciones
tomadas
en
la
transmisi√≥n
y
/
o


la
recepci√≥n
de
un
mensaje
u
otro
suceso
.


Internet
,
y
las
redes
de
computadoras
en
general
,
hacen
un
uso
extensivo
de
los
proto-


colos
.
Los
distintos
protocolos
se
utilizan
para
llevar
a
cabo
las
distintas
tareas
de
comuni-


caci√≥n
.
Como
podr√°
leer
a
lo
largo
del
libro
,
ver√°
que
algunos
protocolos
son
simples
y


directos
,
mientras
que
otros
son
complejos
e
intelectualmente
profundos
.
Dominar
el
campo


de
las
redes
de
computadoras
es
equivalente
a
entender
el
qu√©
,
el
por
qu√©
y
el
c√≥mo
de
los


protocolos
de
red
.


1.2
La
frontera
de
la
red


En
la
secci√≥n
anterior
hemos
presentado
una
introducci√≥n
de
car√°cter
general
sobre
Internet


y
los
protocolos
de
red
.
Ahora
vamos
a
profundizar
un
poco
m√°s
en
los
componentes
de
una


red
de
computadoras
(
y
de
Internet
,
en
concreto
)
.
Comenzaremos
la
secci√≥n
en
la
frontera


de
una
red
y
nos
fijaremos
en
los
componentes
con
los
que
estamos
m√°s
familiarizados
,
es


decir
,
las
computadoras
,
las
PDA
,
los
tel√©fonos
m√≥viles
y
otros
dispositivos
que
utilizamos


a
diario
.
En
la
siguiente
secci√≥n
nos
desplazaremos
desde
la
frontera
de
la
red
hasta
el


n√∫cleo
de
la
misma
y
examinaremos
los
procesos
de
conmutaci√≥n
y
enrutamiento
que
tie-


nen
lugar
en
las
redes
.


Recuerde
de
la
secci√≥n
anterior
que
en
la
jerga
de
las
redes
inform√°ticas
,
las
computa-


doras
y
el
resto
de
los
dispositivos
conectados
a
Internet
a
menudo
se
designan
como
siste-


mas
terminales
,
porque
se
sit√∫an
en
la
frontera
de
Internet
,
como
se
muestra
en
la
Figura
1.3
.


Entre
los
sistemas
terminales
de
Internet
se
incluyen
las
computadoras
de
escritorio
(
por


ejemplo
,
PC
de
escritorio
,
computadoras
Mac
y
equipos
Linux
)
,
servidores
(
por
ejemplo
,


servidores
web
y
de
correo
electr√≥nico
)
y
equipos
m√≥viles
(
por
ejemplo
,
computadoras
por-


t√°tiles
,
dispositivos
PDA
y
tel√©fonos
con
conexiones
a
Internet
inal√°mbricas
)
.
Adem√°s
,
una


cantidad
creciente
de
dispositivos
alternativos
est√°n
actualmente
conect√°ndose
a
Internet


como
sistemas
terminales
(
v√©ase
el
recuadro
de
la
p√°gina
siguiente
)
.


Los
sistemas
terminales
tambi√©n
se
conocen
como
hosts
,
ya
que
albergan
(
es
decir
,


ejecutan
)
programas
de
aplicaci√≥n
tales
como
navegadores
web
,
servidores
web
,
progra-


mas
de
lectura
de
mensajes
de
correo
electr√≥nico
o
servidores
de
correo
electr√≥nico
.
A
lo


largo
de
este
libro
utilizaremos
indistintamente
los
t√©rminos
host
y
sistema
terminal
;
es


decir
,
host
=
sistema
terminal
.
En
ocasiones
,
los
hosts
se
clasifican
en
dos
categor√≠as
:


clientes
y
servidores
.
En
general
,
podr√≠amos
decir
que
los
clientes
suelen
ser
las
computa-


doras
de
escritorio
y
port√°tiles
,
las
PDA
,
etc.
,
mientras
que
los
servidores
suelen
ser
equi-


pos
m√°s
potentes
que
almacenan
y
distribuyen
p√°ginas
web
,
flujos
de
v√≠deo
,
correo


electr√≥nico
,
etc.


1.2.1
Programas
cliente
y
servidor


En
el
contexto
del
software
de
red
,
existe
otra
definici√≥n
para
los
t√©rminos
cliente
y
servi-


dor
,
definici√≥n
a
la
que
haremos
referencia
a
lo
largo
del
libro
.
Un
programa
cliente
es
un


programa
que
se
ejecuta
en
un
sistema
terminal
que
solicita
y
recibe
un
servicio
de
un
pro-


grama
servidor
que
se
ejecuta
en
otro
sistema
terminal
.
La
Web
,
el
correo
electr√≥nico
,
la


1.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
9


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
9transferencia
de
archivos
,
las
sesiones
remotas
,
los
grupos
de
noticias
y
muchas
otras
apli-


caciones
populares
adoptan
el
modelo
cliente-servidor
.
Puesto
que
un
programa
cliente


normalmente
se
ejecuta
en
una
computadora
y
el
programa
servidor
en
otra
,
las
aplicacio-


nes
Internet
cliente-servidor
son
,
por
definici√≥n
,
aplicaciones
distribuidas
.
El
programa


cliente
y
el
programa
servidor
interact√∫an
envi√°ndose
entre
s√≠
mensajes
a
trav√©s
de
Inter-


net
.
En
este
nivel
de
abstracci√≥n
,
los
routers
,
los
enlaces
y
los
restantes
componentes
de


Internet
sirven
de
forma
colectiva
como
una
caja
negra
que
transfiere
mensajes
entre
los


componentes
distribuidos
entre
los
que
se
establece
la
comunicaci√≥n
de
una
aplicaci√≥n
de


Internet
.
Este
nivel
de
abstracci√≥n
se
ilustra
en
la
Figura
1.3
.


No
todas
las
aplicaciones
de
Internet
actuales
est√°n
constituidas
por
programas
cliente


puros
que
interact√∫an
con
programas
servidor
puros
.
Cada
vez
m√°s
aplicaciones
son
aplica-


10
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


UNA
ASOMBROSA
COLECCI√ìN
DE
SISTEMAS
TERMINALES
DE
INTERNET


No
hace
demasiado
tiempo
,
los
sistemas
terminales
conectados
a
Internet
eran
fundamental-


mente
computadoras
tradicionales
como
los
equipos
de
escritorio
y
los
potentes
servidores
.


Desde
finales
de
la
d√©cada
de
1990
y
hasta
el
momento
actual
,
un
amplio
rango
de
intere-


santes
dispositivos
cada
vez
m√°s
diversos
est√°n
conect√°ndose
a
Internet
.
Todos
estos
dispositivos


comparten
la
caracter√≠stica
com√∫n
de
necesitar
enviar
y
recibir
datos
digitales
hacia
y
desde


otros
dispositivos
.
Dada
la
omnipresencia
de
Internet
,
sus
protocolos
bien
definidos
(
estandariza-


dos
)
y
la
disponibilidad
de
productos
hardware
preparados
para
Internet
,
lo
l√≥gico
es
utilizar
la


tecnolog√≠a
de
Internet
para
conectar
estos
dispositivos
entre
s√≠
.


Algunos
de
estos
dispositivos
parecen
haber
sido
creados
exclusivamente
para
el
entreteni-


miento
.
Un
marco
de
fotograf√≠as
IP
de
escritorio
[
Ceiva
2009
]
descarga
fotograf√≠as
digitales
de


un
servidor
remoto
y
las
muestra
en
un
dispositivo
que
parece
un
marco
para
fotograf√≠as
tradi-


cional
;
una
tostadora
Internet
descarga
informaci√≥n
metereol√≥gica
de
un
servidor
y
graba
una


imagen
de
la
previsi√≥n
del
d√≠a
(
por
ejemplo
,
nubes
y
claros
)
en
su
tostada
matutina
[
BBC


2001
]
.
Otros
dispositivos
proporcionan
informaci√≥n
√∫til
;
por
ejemplo
,
las
c√°maras
web
mues-


tran
el
estado
del
tr√°fico
y
las
condiciones
meteorol√≥gicas
o
vigilan
un
lugar
de
inter√©s
,
los


electrodom√©sticos
conectados
a
Internet
,
entre
los
que
se
incluyen
lavadoras
,
frigor√≠ficos
y
hor-


nos
,
incorporan
interfaces
de
tipo
navegador
web
que
permiten
su
monitorizaci√≥n
y
control


remotos
.
Los
telef√≥nos
m√≥viles
IP
con
capacidades
GPS
(
como
el
nuevo
iPhone
de
Apple
)
ponen


al
alcance
de
la
mano
la
navegaci√≥n
por
la
Web
,
el
uso
del
correo
electr√≥nico
y
de
servicios


dependientes
de
la
ubicaci√≥n
.
Una
nueva
clase
de
sistemas
de
sensores
de
red
promete
revolu-


cionar
la
forma
en
que
observaremos
e
interactuaremos
con
nuestro
entorno
.
Los
sensores
en


red
integrados
en
nuestro
entorno
f√≠sico
permiten
la
vigilancia
de
edificios
,
puentes
,
de
la
activi-


dad
s√≠smica
,
de
h√°bitats
de
la
fauna
y
la
flora
,
de
estuarios
y
de
las
capas
inferiores
de
la


atm√≥sfera
[
CENS
2009
,
CASA
2009
]
.
Los
dispositivos
biom√©dicos
pueden
estar
integrados
y


conectados
en
red
,
dando
lugar
a
numerosos
problemas
de
seguridad
e
intimidad
[
Halperin


2008
]
.
Un
transpondedor
RFID
(
identificaci√≥n
por
radiofrecuencia
)
o
un
peque√±o
sensor
inte-


grado
en
cualquier
objeto
puede
hacer
que
la
informaci√≥n
acerca
del
objeto
est√©
disponible
en


Internet
,
lo
que
nos
permitir√°
disfrutar
de
una
‚Äú
Internet
de
objetos
‚Äù
[
ITU
2005
]
.


HISTORIA


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
10ciones
entre
iguales
o
entre
pares
(
P2P
,
Peer-to-Peer
)
,
en
las
que
los
sistemas
terminales


interact√∫an
y
ejecutan
programas
que
realizan
tanto
funciones
de
cliente
como
de
servidor
.


Por
ejemplo
,
en
las
aplicaciones
de
compartici√≥n
de
archivos
P2P
(
como
BitTorrent
y


eMule
)
,
el
programa
disponible
en
el
sistema
terminal
del
usuario
act√∫a
como
cliente
cuando


solicita
un
archivo
a
un
par
y
como
servidor
cuando
env√≠a
un
archivo
a
otro
par
.
En
la
tele-


fon√≠a
por
Internet
,
las
dos
partes
que
intervienen
en
la
comunicaci√≥n
interact√∫an
como
igua-


les
(
la
sesi√≥n
es
sim√©trica
,
enviando
y
recibiendo
ambas
partes
datos
)
.
En
el
Cap√≠tulo
2
,


compararemos
y
contrastaremos
en
detalle
las
arquitecturas
cliente-servidor
y
P2P.


1.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
11


ISP
nacional


o
globalRed


m√≥vil


ISP
local


o
regional


Red
empresarial


Red
dom√©stica


Figura
1.3
‚Ä¢
Interacci√≥n
de
los
sistemas
terminales
.


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
1112
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


1.2.2
Redes
de
acceso


Una
vez
vistas
las
aplicaciones
y
los
sistemas
terminales
existentes
en
la
‚Äú
frontera
de
la
red
‚Äù
,


podemos
pasar
a
ver
las
redes
de
acceso
,
los
enlaces
f√≠sicos
que
conectan
un
sistema
termi-


nal
con
el
primer
router
(
conocido
tambi√©n
como
‚Äú
router
de
frontera
‚Äù
)
de
una
ruta
entre
el


sistema
terminal
y
cualquier
otro
sistema
terminal
distante
.
La
Figura
1.4
muestra
varios


tipos
de
enlaces
de
acceso
entre
un
sistema
terminal
y
el
router
de
frontera
(
los
enlaces
de


acceso
est√°n
resaltados
mediante
l√≠neas
m√°s
gruesas
)
.
En
esta
secci√≥n
se
repasan
muchas
de
 

Figura
1.4
‚Ä¢
Redes
de
acceso
.


ISP
nacional


o
globalRed


m√≥vil


ISP
local


o
regional


Red
empresarial


Red
dom√©stica


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
121.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
13


las
tecnolog√≠as
m√°s
comunes
de
las
redes
de
acceso
,
desde
las
de
baja
velocidad
hasta
las
de


alta
velocidad
.


Enseguida
veremos
que
muchas
de
estas
tecnolog√≠as
de
acceso
emplean
,
en
distintos


grados
,
partes
de
la
infraestructura
de
la
telefon√≠a
cableada
tradicional
local
,
la
cual
es
pro-


porcionada
por
la
compa√±√≠a
de
telefon√≠a
local
,
a
la
que
haremos
referencia
simplemente


como
telco
local
.
Algunos
ejemplos
de
estas
compa√±√≠as
ser√≠an
Verizon
en
Estados
Unidos
y


France
Telecom
en
Francia
.
Cada
residencia
(
chalet
o
piso
)
dispone
de
un
enlace
directo
de


cobre
de
par
trenzado
a
un
switch
de
la
compa√±√≠a
telef√≥nica
,
el
cual
se
encuentra
en
un
edi-


ficio
denominado
central
telef√≥nica
en
la
jerga
del
campo
de
la
telefon√≠a
.
(
M√°s
adelante
en


esta
secci√≥n
explicaremos
lo
que
es
un
cable
de
cobre
de
par
trenzado
.
)
Normalmente
,
una


compa√±√≠a
telef√≥nica
local
posee
cientos
de
centrales
telef√≥nicas
y
enlaza
a
cada
uno
de
sus


clientes
con
la
central
m√°s
pr√≥xima
.


Acceso
telef√≥nico


En
la
d√©cada
de
1990
,
casi
todos
los
usuarios
residenciales
acced√≠an
a
Internet
a
trav√©s
de


las
l√≠neas
telef√≥nicas
anal√≥gicas
normales
utilizando
un
m√≥dem
de
acceso
telef√≥nico
.


Actualmente
,
muchos
usuarios
de
pa√≠ses
subdesarrollados
y
de
√°reas
rurales
en
pa√≠ses
desa-


rrollados
(
donde
el
acceso
de
banda
ancha
no
est√°
disponible
)
todav√≠a
tienen
que
acceder
a


Internet
mediante
una
conexi√≥n
de
acceso
telef√≥nico
.
De
hecho
,
se
estima
que
el
10%
de
los


usuarios
residenciales
de
Estados
Unidos
utilizaban
en
2008
conexiones
de
acceso
telef√≥-


nico
[
Pew
2008
]
.


Se
utiliza
el
t√©rmino
‚Äú
acceso
telef√≥nico
‚Äù
(
dial-up
)
porque
el
software
del
usuario
real-


mente
llama
al
n√∫mero
de
tel√©fono
de
un
ISP
y
establece
una
conexi√≥n
telef√≥nica
tradicional


con
el
mismo
(
por
ejemplo
,
con
AOL
)
.
Como
se
muestra
en
la
Figura
1.5
,
el
PC
est√°
conec-


tado
a
un
m√≥dem
de
acceso
telef√≥nico
,
que
a
su
vez
est√°
conectado
a
la
l√≠nea
telef√≥nica
ana-


l√≥gica
del
domicilio
.
Esta
l√≠nea
telef√≥nica
anal√≥gica
est√°
hecha
de
un
hilo
de
cobre
de
paz


trenzado
y
es
la
misma
l√≠nea
de
tel√©fono
que
se
emplea
para
las
llamadas
telef√≥nicas
ordina-


rias
.
El
m√≥dem
convierte
la
salida
digital
del
PC
en
una
se√±al
anal√≥gica
apropiada
para
ser


transmitida
a
trav√©s
de
la
l√≠nea
telef√≥nica
anal√≥gica
.
En
el
otro
extremo
de
la
conexi√≥n
,
un


m√≥dem
del
ISP
convierte
la
se√±al
anal√≥gica
que
recibe
en
una
se√±al
digital
que
ser√°
la
se√±al


de
entrada
para
el
router
del
ISP
.


Figura
1.5
‚Ä¢
Acceso
telef√≥nico
a
Internet
.


Conmutador


de
circuitos


PC


dom√©stico


Red


telef√≥nicaCentral


telef√≥nica


M√≥dem
de


acceso


telef√≥nico


dom√©stico


M√≥dem
del
ISP


(
por
ejmplo
,

 
AOL
)


Internet


Clave
:


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
1314
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


El
acceso
telef√≥nico
a
Internet
presenta
dos
inconvenientes
importantes
.
El
primero
y


m√°s
destacable
es
que
es
extremadamente
lento
,
proporcionando
una
velocidad
m√°xima
de


56
kbps
.
A
esta
velocidad
,
se
tardan
aproximadamente
ocho
minutos
en
descargar
un


archivo
MP3
de
una
canci√≥n
de
tres
minutos
y
se
necesitar√≠an
varios
d√≠as
para
descargar


una
pel√≠cula
de
1
Gbyte
.
El
segundo
,
un
m√≥dem
de
acceso
telef√≥nico
ocupa
la
l√≠nea
telef√≥-


nica
del
usuario
,
as√≠
que
mientras
que
un
miembro
de
la
familia
utiliza
el
m√≥dem
de
acceso


telef√≥nico
para
navegar
por
la
Web
,
el
resto
de
la
familia
no
puede
recibir
ni
hacer
llama-


das
telef√≥nicas
normales
a
trav√©s
de
esa
l√≠nea
de
tel√©fono
.


DSL


Hoy
en
d√≠a
,
los
dos
tipos
de
acceso
residencial
de
banda
ancha
predominantes
son
las
l√≠neas


DSL
(
Digital
Subscriber
Line
,
L√≠nea
de
abonado
digital
)
y
el
cable
.
En
la
mayor√≠a
de
los


pa√≠ses
desarrollados
de
hoy
en
d√≠a
,
m√°s
del
50%
de
los
domicilios
particulares
disponen
de


acceso
de
banda
ancha
,
con
Corea
del
Sur
,
Islandia
,
Holanda
,
Dinamarca
y
Suiza
a
la
cabeza


con
una
penetraci√≥n
de
m√°s
del
74%
de
los
hogares
en
2008
[
ITIF
2008
]
.
En
Estados
Uni-


dos
,
las
l√≠neas
DSL
y
cable
tienen
aproximadamente
la
misma
cuota
de
mercado
para
el


acceso
de
banda
ancha
[
Pew
2008
]
.
Fuera
de
Estados
Unidos
y
Canad√°
domina
la
tecnolo-


g√≠a
DSL
,
especialmente
en
Europa
,
donde
en
muchos
pa√≠ses
m√°s
del
90%
de
las
conexiones


de
banda
ancha
se
hacen
mediante
DSL
.


Por
regla
general
,
los
domicilios
particulares
contratan
el
servicio
DSL
de
acceso
a


Internet
con
la
misma
empresa
que
le
proporciona
el
acceso
telef√≥nico
local
(
es
decir
,
la


compa√±√≠a
telef√≥nica
)
.
Por
tanto
,
cuando
se
utiliza
el
acceso
mediante
DSL
,
la
compa√±√≠a
tele-


f√≥nica
del
cliente
tambi√©n
act√∫a
como
ISP
.
Como
se
muestra
en
la
Figura
1.6
,
cada
m√≥dem


DSL
de
un
cliente
utiliza
la
l√≠nea
telef√≥nica
existente
(
hilo
de
cobre
de
par
trenzado
)
para


intercambiar
datos
con
un
multiplexor
de
acceso
DSL
(
DSLAM
)
,
que
normalmente
se


encuentra
en
la
central
de
la
compa√±√≠a
telef√≥nica
.
La
l√≠nea
telef√≥nica
transporta
simult√°nea-


mente
los
datos
y
las
se√±ales
telef√≥nicas
,
las
cuales
se
codifican
a
frecuencias
distintas
:


‚Ä¢
Un
canal
de
descarga
de
alta
velocidad
opera
en
la
banda
de
50
kHz
a
1
MHz
.


‚Ä¢
Un
canal
de
carga
de
velocidad
media
opera
en
la
banda
de
4
kHz
a
50
kHz
.


‚Ä¢
Un
canal
telef√≥nico
ordinario
bidireccional
opera
en
la
banda
de
0
a
4
kHz
.


Figura
1.6
‚Ä¢
Acceso
mediante
DSL
a
Internet
.


PC


dom√©stico


Tel√©fono


del
domicilio


M√≥dem


DSL


Internet


Red


telef√≥nica


Circuito


separador


L√≠nea
telef√≥nica
existente
:


telefon√≠a
0-4
kHz
;
4-50
kHz


carga
de
datos
;
50
kHz
‚Äì


1
MHz
descarga
de
datos


Central


telef√≥nica


DSLAM


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
14Este
m√©todo
hace
que
un
√∫nico
enlace
DSL
se
comporte
como
tres
enlaces
separados
,


de
manera
que
una
llamada
de
tel√©fono
y
una
conexi√≥n
a
Internet
pueden
compartir
el
enlace


DSL
a
un
mismo
tiempo
.
En
la
Secci√≥n
1.3.1
describiremos
esta
t√©cnica
de
multiplexaci√≥n


por
divisi√≥n
en
frecuencia
.
En
el
lado
del
cliente
,
las
se√±ales
que
llegan
al
domicilio
son


separadas
como
se√±ales
de
datos
y
telef√≥nicas
mediante
un
circuito
separador
(
splitter
)
que


reenv√≠a
la
se√±al
de
datos
al
m√≥dem
DSL
.
En
el
lado
de
la
compa√±√≠a
telef√≥nica
,
en
la
central
,


el
multiplexor
DSLAM
separa
las
se√±ales
de
datos
y
de
telefon√≠a
y
env√≠a
los
datos
a
Internet
.


Cientos
o
incluso
miles
de
viviendas
se
conectan
a
un
mismo
DSLAM
[
Cha
2009
,
Dischin-


ger
2007
]
.


DSL
presenta
dos
ventajas
principales
en
comparaci√≥n
con
el
m√©todo
de
acceso
telef√≥-


nico
a
Internet
.
En
primer
lugar
,
puede
transmitir
y
recibir
datos
a
velocidades
mucho
m√°s


altas
.
T√≠picamente
,
un
cliente
DSL
presentar√°
una
velocidad
de
transmisi√≥n
en
el
rango
com-


prendido
entre
1
y
2
Mbps
para
las
descargas
(
comunicaciones
desde
la
central
al
domicilio


del
usuario
)
y
de
entre
128
kbps
a
1
Mbps
para
las
cargas
(
comunicaciones
desde
el
domici-


lio
a
la
central
)
.
Puesto
que
las
velocidades
de
descarga
y
carga
son
diferentes
,
se
dice
que
el


acceso
es
asim√©trico
.
La
segunda
ventaja
importante
es
que
los
usuarios
pueden
hablar
por


tel√©fono
y
acceder
a
Internet
simult√°neamente
.
A
diferencia
del
m√©todo
de
acceso
telef√≥nico
,


el
usuario
no
tiene
que
llamar
al
n√∫mero
de
tel√©fono
del
ISP
para
tener
acceso
a
Internet
;
en


su
lugar
,
dispone
de
una
conexi√≥n
permanente
‚Äú
siempre
activa
‚Äù
con
el
DSLAM
del
ISP


(
y
por
tanto
con
Internet
)
.


Las
velocidades
de
transmisi√≥n
reales
de
descarga
y
de
carga
disponibles
en
el
domicilio


del
usuario
son
funci√≥n
de
la
distancia
entre
la
casa
y
la
central
telef√≥nica
,
el
calibre
de
la


l√≠nea
de
par
trenzado
y
el
grado
de
interferencia
el√©ctrica
.
Los
ingenieros
han
dise√±ado
expre-


samente
sistemas
DSL
para
distancias
cortas
entre
el
domicilio
y
la
central
,
lo
que
ha
permi-


tido
conseguir
velocidades
de
transmisi√≥n
sustancialmente
mayores
.
Para
incrementar
la


velocidad
de
transmisi√≥n
de
los
datos
,
el
sistema
DSL
se
basa
en
algoritmos
avanzados
de


procesamiento
de
se√±ales
y
de
correcci√≥n
de
errores
,
que
pueden
conducir
a
importantes


retardos
de
los
paquetes
.
Sin
embargo
,
si
el
domicilio
no
se
encuentra
en
un
radio
de
entre
8
y


16
kil√≥metros
de
la
central
,
la
tecnolog√≠a
DSL
de
procesamiento
de
las
se√±ales
ya
no
ser√°
tan


efectiva
y
el
usuario
deber√°
recurrir
a
una
forma
alternativa
de
acceso
a
Internet
.


Actualmente
,
existe
tambi√©n
una
amplia
variedad
de
tecnolog√≠as
DSL
de
alta
velocidad


que
gozan
de
aceptaci√≥n
en
muchos
pa√≠ses
.
Por
ejemplo
,
la
tecnolog√≠a
VDSL
(
Very-high


speed
DSL
)
,
con
la
m√°xima
penetraci√≥n
hoy
d√≠a
en
Corea
del
Sur
y
Jap√≥n
,
proporciona
velo-


cidades
de
entre
12
y
55
Mbps
para
las
descargas
y
velocidades
de
carga
comprendidas
entre


1,6
y
20
Mbps
[
DSL
2009
]
.


Cable


Muchos
domicilios
de
Am√©rica
del
Norte
y
de
muchos
otros
lugares
reciben
cientos
de
cana-


les
de
televisi√≥n
a
trav√©s
de
redes
de
cable
coaxial
(
veremos
m√°s
adelante
en
esta
secci√≥n
el


cable
coaxial
)
.
En
un
sistema
de
televisi√≥n
por
cable
tradicional
,
el
terminal
de
cabecera


de
cable
difunde
los
canales
de
televisi√≥n
a
trav√©s
de
una
red
de
distribuci√≥n
de
cable
coa-


xial
y
amplificadores
hasta
los
domicilios
de
los
usuarios
.


Mientras
que
la
DSL
y
el
acceso
telef√≥nico
emplean
la
infraestructura
de
la
telefon√≠a


local
existente
,
el
acceso
por
cable
a
Internet
utiliza
la
infraestructura
de
la
televisi√≥n
por


cable
existente
.
Las
casas
obtienen
el
acceso
por
cable
a
Internet
de
la
misma
compa√±√≠a
que


proporciona
la
televisi√≥n
por
cable
.
Como
se
ilustra
en
la
Figura
1.7
,
la
fibra
√≥ptica
conecta


el
terminal
de
cabecera
del
cable
a
una
serie
de
nodos
de
√°rea
situados
en
el
vecindario
,
a


1.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
15


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
15Figura
1.7
‚Ä¢
Red
de
acceso
h√≠brida
de
fibra
√≥ptica
y
cable
coaxial
.


partir
de
los
cuales
se
utiliza
el
cable
coaxial
tradicional
para
llegar
a
todos
los
domicilios
.


Cada
nodo
de
√°rea
suele
dar
soporte
a
entre
500
y
5.000
viviendas
.
Puesto
que
en
este
sis-


tema
se
emplea
tanto
cable
coaxial
como
fibra
,
a
menudo
se
denomina
sistema
HFC


(
Hybrid
Fiber
Coax
,
H√≠brido
de
fibra
y
coaxial
)
.


El
acceso
por
cable
a
Internet
requiere
el
uso
de
modems
especiales
,
que
se
conocen


como
modems
por
cable
.
Al
igual
que
un
m√≥dem
DSL
,
normalmente
el
m√≥dem
por
cable


es
un
dispositivo
externo
que
se
conecta
a
un
PC
a
trav√©s
de
un
puerto
Ethernet
(
en
el
Cap√≠-


tulo
5
veremos
m√°s
detalles
acerca
de
Ethernet
)
.
Los
modems
por
cable
dividen
la
red
HFC


en
dos
canales
:
un
canal
de
descarga
y
un
canal
de
carga
.
Al
igual
que
en
el
caso
de
la
DSL
,


el
acceso
suele
ser
asim√©trico
,
teniendo
normalmente
el
canal
de
descarga
asignada
una


velocidad
de
transmisi√≥n
mayor
que
el
canal
de
carga
.


Una
caracter√≠stica
importante
del
acceso
a
Internet
por
cable
es
que
se
trata
de
un
medio


de
difusi√≥n
compartido
.
Es
decir
,
cada
uno
de
los
paquetes
enviados
por
el
terminal
de
cabe-


cera
se
descargan
a
trav√©s
de
cada
enlace
hasta
cada
vivienda
y
los
paquetes
enviados
desde


las
viviendas
viajan
a
trav√©s
del
canal
de
carga
hasta
el
terminal
de
cabecera
.
As√≠
,
si
varios


usuarios
descargan
simult√°neamente
un
archivo
de
v√≠deo
a
trav√©s
del
canal
de
descarga
,
la


velocidad
real
a
la
que
cada
usuario
recibe
su
archivo
de
v√≠deo
ser√°
significativamente


menor
que
la
velocidad
acumulada
de
descarga
por
cable
.
Por
el
contrario
,
si
s√≥lo
hay
unos


pocos
usuarios
activos
que
est√°n
navegando
por
la
Web
,
cada
uno
de
ellos
recibir√°
las
p√°gi-


nas
web
a
la
velocidad
de
descarga
m√°xima
del
cable
,
ya
que
los
usuarios
rara
vez
solicita-


r√°n
una
p√°gina
web
al
mismo
tiempo
.
Puesto
que
el
canal
de
carga
tambi√©n
est√°
compartido
,


se
necesita
un
protocolo
distribuido
de
acceso
m√∫ltiple
para
coordinar
las
transmisiones
y


evitar
las
colisiones
(
veremos
el
problema
de
las
colisiones
en
detalle
en
el
Cap√≠tulo
5
al


abordar
la
tecnolog√≠a
Ethernet
)
.


En
favor
de
la
tecnolog√≠a
DSL
debemos
apuntar
que
se
trata
de
una
conexi√≥n
punto
a


punto
entre
la
vivienda
y
el
ISP
y
que
,
por
tanto
,
toda
la
capacidad
de
transmisi√≥n
del
enlace


DSL
entre
el
domicilio
y
el
ISP
est√°
dedicada
en
lugar
de
ser
compartida
.
Sin
embargo
,


podemos
decir
en
favor
de
la
transmisi√≥n
por
cable
que
una
red
HFC
correctamente
dimen-


sionada
proporciona
velocidades
de
transmisi√≥n
m√°s
altas
que
la
DSL
.
Existe
una
batalla


Cable
de
fibra


Cable
coaxial


Cientos
de


viviendas


Terminal
de


cabecera


de
cable


Cientos
de


viviendas


Nodo
de


fibra


Nodo
de


fibra


16
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
16feroz
entre
las
tecnolog√≠as
DSL
y
HFC
para
el
acceso
residencial
de
alta
velocidad
,
espe-


cialmente
en
Am√©rica
del
Norte
.
En
las
√°reas
rurales
,
donde
no
est√°
disponible
ninguna
de


estas
tecnolog√≠as
,
se
puede
utilizar
un
enlace
v√≠a
sat√©lite
para
conectar
una
vivienda
con


Internet
a
velocidades
superiores
a
1
Mbps
;
StarBand
y
HughesNet
son
dos
proveedores
de


acceso
v√≠a
sat√©lite
.


Tecnolog√≠a
FTTH
(
Fiber-To-The-Home
,
Fibra
hasta
el
hogar
)


La
fibra
√≥ptica
(
que
veremos
en
la
Secci√≥n
1.2.3
)
puede
ofrecer
velocidades
de
transmisi√≥n


significativamente
m√°s
altas
que
el
cable
de
cobre
de
par
trenzado
o
el
cable
coaxial
.
En


muchos
pa√≠ses
,
algunas
compa√±√≠as
telef√≥nicas
han
tendido
recientemente
conexiones
de


fibra
√≥ptica
desde
sus
centrales
hasta
las
viviendas
,
proporcionando
acceso
a
Internet
de
alta


velocidad
,
as√≠
como
servicios
de
telefon√≠a
y
televisi√≥n
por
fibra
√≥ptica
.
En
Estados
Unidos
,


Verizon
ha
sido
especialmente
agresiva
en
el
mercado
de
la
tecnolog√≠a
FTTH
,
a
trav√©s
de
su


servicio
FIOS
[
Verizon
FIOS
2009
]
.


Existen
varias
tecnolog√≠as
que
compiten
por
la
distribuci√≥n
a
trav√©s
de
fibra
√≥ptica


desde
las
centrales
a
los
hogares
.
La
red
de
distribuci√≥n
√≥ptica
m√°s
simple
se
denomina


fibra
directa
,
en
la
que
existe
una
fibra
que
sale
de
la
central
hasta
cada
domicilio
.
Este


tipo
de
distribuci√≥n
puede
proporcionar
un
ancho
de
banda
grande
,
dado
que
cada


cliente
dispone
de
su
propia
fibra
dedicada
todo
el
camino
hasta
la
central
.
Sin
embargo
,


lo
m√°s
habitual
es
que
cada
fibra
saliente
de
la
central
sea
compartida
por
muchas


viviendas
y
√©sta
no
se
divida
en
fibras
individuales
espec√≠ficas
del
cliente
hasta
llegar
a


un
punto
muy
pr√≥ximo
a
las
viviendas
.
Hay
disponibles
dos
arquitecturas
de
distribu-


ci√≥n
de
fibra
√≥ptica
que
llevan
a
cabo
esta
separaci√≥n
:
las
redes
√≥pticas
activas
(
AON
,


Active
Optical
Network
)
y
las
redes
√≥pticas
pasivas
(
PON
,
Passive
Optical
Network
)
.


Las
redes
AON
son
fundamentalmente
redes
Ethernet
conmutadas
,
las
cuales
abordare-


mos
en
el
Cap√≠tulo
5
.
Aqu√≠
vamos
a
ver
brevemente
las
redes
√≥pticas
pasivas
,
que
se
uti-


lizan
en
el
servicio
FIOS
de
Verizon
.
La
Figura
1.8
muestra
el
uso
de
la
tecnolog√≠a


FTTH
utilizando
la
arquitectura
de
distribuci√≥n
PON
.
Cada
vivienda
dispone
de
una
ter-


minaci√≥n
de
red
√≥ptica
(
ONT
,
Optical
Network
Terminator
)
,
que
se
conecta
a
un
distri-


buidor
del
vecindario
mediante
un
cable
de
fibra
√≥ptica
dedicado
.
El
distribuidor


combina
una
cierta
cantidad
de
viviendas
(
normalmente
menos
de
100
)
en
un
√∫nico


cable
de
fibra
√≥ptica
compartido
,
que
se
conecta
a
una
terminaci√≥n
de
l√≠nea
√≥ptica
(
OLT
,
 

Figura
1.8
‚Ä¢
Acceso
a
Internet
mediante
FTTH
.


Internet


Central


Distribuidor


√≥ptico


ONT


ONT


ONT


OLT


Cables


de
fibra


√≥ptica


1.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
17


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
17Optical
Line
Terminator
)
de
la
central
de
la
compa√±√≠a
telef√≥nica
.
La
OLT
,
que
realiza
la


conversi√≥n
de
se√±ales
√≥pticas
en
el√©ctricas
,
se
conecta
a
trav√©s
de
Internet
mediante
un


router
de
la
compa√±√≠a
telef√≥nica
.
En
los
domicilios
,
los
usuarios
conectan
su
router


dom√©stico
(
normalmente
un
router
inal√°mbrico
)
con
la
ONT
y
acceden
a
Internet
a
tra-


v√©s
de
este
router
.
En
la
arquitectura
PON
,
todos
los
paquetes
enviados
desde
la
OLT
al


distribuidor
se
replican
en
este
distribuidor
(
de
forma
similar
a
un
terminal
de
cabecera


de
cable
)
.


En
teor√≠a
,
la
tecnolog√≠a
FTTH
puede
proporcionar
velocidades
de
acceso
a
Internet
del


orden
de
los
gigabits
por
segundo
.
Sin
embargo
,
la
mayor√≠a
de
los
ISP
de
FTTH
ofrecen


diferentes
velocidades
,
siendo
l√≥gicamente
m√°s
caras
cuanto
m√°s
altas
son
.
La
mayor√≠a
de


los
clientes
actuales
de
la
tecnolog√≠a
FTTH
disfrutan
de
velocidades
de
descarga
compren-


didas
entre
10
y
20
Mbps
,
y
de
velocidades
de
carga
de
entre
2
y
10
Mbps
.
Adem√°s
del


acceso
a
Internet
,
la
fibra
√≥ptica
permite
proporcionar
servicios
de
televisi√≥n
y
el
servicio
de


telefon√≠a
tradicional
.


Ethernet


En
los
campus
universitarios
y
corporativos
,
normalmente
se
utiliza
una
red
de
√°rea
local


(
LAN
,
Local
Area
Network
)
para
conectar
un
sistema
terminal
al
router
de
frontera
.
Aunque


existen
muchos
tipos
de
tecnolog√≠as
LAN
,
Ethernet
es
con
mucho
la
tecnolog√≠a
de
acceso


predominante
en
las
redes
corporativas
y
universitarias
.
Como
se
ilustra
en
la
Figura
1.9
,
los


usuarios
de
Ethernet
utilizan
cable
de
cobre
de
par
trenzado
para
conectarse
a
un
switch


Ethernet
(
tecnolog√≠a
que
se
ver√°
en
detalle
en
el
Cap√≠tulo
5
)
.
Con
acceso
Ethernet
,
normal-


mente
los
usuarios
disponen
de
velocidades
de
acceso
de
100
Mbps
,
y
los
servidores
pueden


alcanzar
velocidades
de
1
Gbps
o
incluso
10
Gbps
.


WiFi


Cada
vez
es
m√°s
habitual
que
los
usuarios
accedan
a
Internet
a
trav√©s
de
conexiones
ina-


l√°mbricas
,
bien
a
trav√©s
de
una
computadora
port√°til
o
mediante
un
dispositivo
m√≥vil
,


como
un
iPhone
,
una
Blackberry
o
un
tel√©fono
Google
(
v√©ase
el
recuadro
anterior
‚Äú
Una


asombrosa
colecci√≥n
de
sistemas
terminales
de
Internet
‚Äù
)
.
Actualmente
,
existen
dos
tipos


de
acceso
inal√°mbrico
a
Internet
.
En
una
LAN
inal√°mbrica
,
los
usuarios
inal√°mbricos


Figura
1.9
‚Ä¢
Acceso
a
Internet
utilizando
tecnolog√≠a
Ethernet
.


Switch


Ethernet


Router


institucional


100
Mbps


100
Mbps


100
Mbps


Servidor


Al
ISP
de
la


instituci√≥n


18
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
18transmiten
paquetes
a
(
y
reciben
paquetes
de
)
un
punto
de
acceso
,
el
cual
a
su
vez
est√°


conectado
a
la
red
Internet
cableada
.
Habitualmente
,
los
usuarios
de
una
LAN
inal√°mbrica


deben
encontrarse
a
unas
pocas
decenas
de
metros
del
punto
de
acceso
.
En
las
redes
ina-


l√°mbricas
de
√°rea
extensa
,
los
paquetes
se
transmiten
a
una
estaci√≥n
base
a
trav√©s
de
la


misma
infraestructura
inal√°mbrica
utilizada
por
la
telefon√≠a
m√≥vil
.
En
este
caso
,
el
provee-


dor
de
la
red
m√≥vil
gestiona
la
estaci√≥n
base
y
,
normalmente
,
el
usuario
puede
estar
a
unas


pocas
decenas
de
kil√≥metros
de
la
estaci√≥n
base
.


Actualmente
,
el
acceso
mediante
LAN
inal√°mbrica
basada
en
la
tecnolog√≠a
IEEE


802.11
,
es
decir
WiFi
,
podemos
encontrarlo
por
todas
partes
:
universidades
,
oficinas
,
caf√©s
,


aeropuertos
,
domicilios
e
incluso
en
los
aviones
.
La
mayor
parte
de
las
universidades
han


instalado
estaciones
base
IEEE
802.11
por
sus
campus
,
lo
que
permite
a
los
estudiantes


enviar
y
recibir
mensajes
de
correo
electr√≥nico
o
navegar
por
la
Web
estando
en
cualquier


lugar
del
campus
.
En
muchas
ciudades
,
alguien
puede
estar
parado
en
la
esquina
de
una


calle
y
encontrarse
dentro
del
alcance
de
diez
o
veinte
estaciones
base
(
para
ver
un
mapa


global
navegable
de
estaciones
base
802.11
descubiertas
y
registradas
en
un
sitio
web
por


personas
que
disfrutan
haciendo
este
tipo
de
cosas
,
consulte
[
wigle.net
2009
]
)
.
Como
se


explica
en
el
Cap√≠tulo
6
,
actualmente
,
la
tecnolog√≠a
802.11
proporciona
una
velocidad
de


transmisi√≥n
compartida
de
hasta
54
Mbps
.


Muchas
viviendas
combinan
acceso
residencial
de
banda
ancha
(
es
decir
,
modems
por


cable
o
DSL
)
con
tecnolog√≠a
LAN
inal√°mbrica
barata
para
crear
redes
dom√©sticas
poten-


tes
.
La
Figura
1.10
muestra
un
esquema
de
una
red
dom√©stica
t√≠pica
.
Esta
red
dom√©stica


est√°
formada
por
un
port√°til
con
funci√≥n
de
itinerancia
(
roaming
)
y
un
PC
de
sobremesa
;


una
estaci√≥n
base
(
el
punto
de
acceso
inal√°mbrico
)
,
que
se
comunica
con
el
port√°til
ina-


l√°mbrico
;
un
m√≥dem
por
cable
,
que
proporciona
el
acceso
de
banda
ancha
a
Internet
y
un


router
,
que
interconecta
la
estaci√≥n
base
y
el
PC
de
sobremesa
con
el
m√≥dem
por
cable
.


Esta
red
permite
a
los
usuarios
de
esta
red
dom√©stica
tener
acceso
de
banda
ancha
a
Inter-


net
mediante
un
dispositivo
m√≥vil
con
el
que
se
puede
ir
de
la
cocina
a
los
dormitorios
y


al
jard√≠n
.


Figura
1.10
‚Ä¢
Esquema
de
una
red
dom√©stica
t√≠pica
.


Terminal
de


cabecera


de
cable


Vivienda


Internet


1.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
19


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
19Acceso
inal√°mbrico
de
√°rea
extensa


Cuando
se
accede
a
Internet
a
trav√©s
de
una
red
LAN
inal√°mbrica
,
normalmente
es
necesa-


rio
estar
a
unas
pocas
decenas
de
metros
del
punto
de
acceso
.
Esto
es
viable
en
viviendas
,


caf√©s
y
,
de
forma
m√°s
general
,
en
el
interior
y
los
alrededores
de
un
edificio
.
Pero
,
¬ø
qu√©
ocu-


rre
cuando
se
necesita
tener
acceso
a
Internet
y
se
est√°
en
la
playa
,
en
un
autob√∫s
o
en
el


coche
?
Para
este
tipo
de
acceso
de
√°rea
extensa
,
los
usuarios
itinerantes
de
Internet
utilizan


la
infraestructura
de
la
telefon√≠a
m√≥vil
para
acceder
a
estaciones
base
que
est√°n
separadas


entre
s√≠
unas
decenas
de
kil√≥metros
.


Las
empresas
de
telecomunicaciones
han
hecho
grandes
inversiones
en
lo
que
se
conoce


como
redes
inal√°mbricas
de
tercera
generaci√≥n
(
3
G
)
,
que
proporcionan
acceso
inal√°mbrico


a
Internet
mediante
una
red
de
√°rea
extensa
de
conmutaci√≥n
de
paquetes
a
velocidades
por


encima
de
1
Mbps
.
Actualmente
,
millones
de
usuarios
emplean
estas
redes
para
leer
y
enviar


mensajes
de
correo
electr√≥nico
,
navegar
por
la
Web
y
descargar
m√∫sica
mientras
se
despla-


zan
de
un
lugar
a
otro
.


WiMAX


Como
siempre
,
existe
una
posible
tecnolog√≠a
‚Äú
definitiva
‚Äù
que
espera
destronar
a
estos
est√°n-


dares
.
WiMAX
[
Intel
WiMAX
2009
,
WiMAX
Forum
2009
]
,
tambi√©n
conocido
como
IEEE


802.16
,
es
un
primo
lejano
del
protocolo
WiFi
802.11
citado
anteriormente
.
WiMAX
opera


independientemente
de
la
red
de
telefon√≠a
m√≥vil
y
promete
velocidades
comprendidas
entre


5
y
10
Mbps
o
superiores
para
distancias
de
decenas
de
kil√≥metros
.
Sprint-Nextel
ha
inver-


tido
miles
de
millones
de
d√≥lares
en
la
implantaci√≥n
de
WiMAX
a
partir
del
a√±o
2007
.
En
el


Cap√≠tulo
6
se
abordan
en
detalle
las
tecnolog√≠as
WiFi
,
WiMAX
y
3G.


1.2.3
Medios
f√≠sicos


En
la
subsecci√≥n
anterior
hemos
proporcionado
una
panor√°mica
de
algunas
de
las
tecnolo-


g√≠as
de
acceso
a
red
m√°s
importantes
disponibles
para
Internet
.
Seg√∫n
hemos
ido
descri-


biendo
estas
tecnolog√≠as
,
hemos
indicado
los
medios
f√≠sicos
utilizados
.
Por
ejemplo
,
hemos


dicho
que
la
tecnolog√≠a
HFC
emplea
una
combinaci√≥n
de
cable
de
fibra
√≥ptica
y
de
cable


coaxial
.
Tambi√©n
hemos
se√±alado
que
los
modems
de
acceso
telef√≥nico
a
56
kbps
y
las
DSL


utilizan
cable
de
cobre
de
par
trenzado
.
Asimismo
,
tambi√©n
hemos
comentado
que
las
redes


para
acceso
m√≥vil
usan
el
espectro
de
radio
.
En
esta
subsecci√≥n
vamos
a
hacer
una
breve


introducci√≥n
a
√©stos
y
otros
medios
de
transmisi√≥n
que
se
emplean
habitualmente
en
Inter-


net
.


Para
definir
lo
que
se
entiende
por
medio
f√≠sico
,
reflexionemos
sobre
la
breve
vida
de


un
bit
.
Imagine
un
bit
que
viaja
desde
un
sistema
terminal
atravesando
una
serie
de
enla-


ces
y
routers
hasta
otro
sistema
terminal
.
Este
pobre
bit
se
desplaza
de
un
lado
a
otro
sin


descanso
.
En
primer
lugar
,
el
sistema
terminal
de
origen
transmite
el
bit
y
poco
tiempo


despu√©s
el
primer
router
de
la
serie
recibe
dicho
bit
;
el
primer
router
transmite
entonces
el


bit
y
poco
despu√©s
lo
recibe
el
segundo
router
,
y
as√≠
sucesivamente
.
Por
tanto
,
nuestro
bit
,


al
viajar
desde
el
origen
hasta
el
destino
,
atraviesa
una
serie
de
parejas
de
transmisores
y


receptores
.
En
cada
par
transmisor-receptor
,
el
bit
se
env√≠a
mediante
ondas
electromagn√©-


ticas
o
pulsos
√≥pticos
a
lo
largo
de
un
medio
f√≠sico
.
Este
medio
f√≠sico
puede
tener
muchas


formas
y
no
tiene
que
ser
del
mismo
tipo
para
cada
par
transmisor-receptor
existente
a
lo


largo
de
la
ruta
.
Entre
los
ejemplos
de
medios
f√≠sicos
se
incluyen
el
cable
de
cobre
de
par


20
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
20trenzado
,
el
cable
coaxial
,
el
cable
de
fibra
√≥ptica
multimodo
,
el
espectro
de
radio
terrestre


y
el
espectro
de
radio
por
sat√©lite
.
Los
medios
f√≠sicos
se
pueden
clasificar
dentro
de
dos


categor√≠as
:
medios
guiados
y
medios
no
guiados
.
En
los
medios
guiados
,
las
ondas
se


transportan
a
trav√©s
de
un
medio
s√≥lido
,
como
por
ejemplo
un
cable
de
fibra
√≥ptica
,
un


cable
de
cobre
de
par
trenzado
o
un
cable
coaxial
.
En
los
medios
no
guiados
,
las
ondas
se


propagan
por
la
atm√≥sfera
y
el
espacio
exterior
,
tal
como
ocurre
en
las
redes
LAN
inal√°m-


bricas
o
en
un
canal
de
sat√©lite
digital
.


Pero
antes
de
abordar
las
caracter√≠sticas
de
los
distintos
tipos
de
medios
,
veamos
algu-


nos
detalles
acerca
de
los
costes
.
El
coste
real
de
un
enlace
f√≠sico
(
cable
de
cobre
,
de
fibra


√≥ptica
,
o
coaxial
,
etc.
)
suele
ser
relativamente
peque√±o
cuando
se
compara
con
los
restantes


costes
de
la
red
.
En
particular
,
el
coste
de
mano
de
obra
asociado
con
la
instalaci√≥n
del


enlace
f√≠sico
puede
ser
de
varios
√≥rdenes
de
magnitud
mayor
que
el
coste
del
material
.
Por


ello
,
muchos
constructores
instalan
cables
de
par
trenzado
,
de
fibra
√≥ptica
y
coaxial
en
todas


las
habitaciones
de
los
edificios
.
Incluso
aunque
inicialmente
s√≥lo
se
utilice
uno
de
los


medios
,
existen
muchas
posibilidades
de
que
se
emplee
alg√∫n
otro
medio
f√≠sico
en
un
futuro


pr√≥ximo
y
,
por
tanto
,
se
ahorre
dinero
al
no
tener
que
tirar
cables
adicionales
.


Cable
de
cobre
de
par
trenzado


El
medio
de
transmisi√≥n
guiado
m√°s
barato
y
m√°s
com√∫nmente
utilizado
es
el
cable
de


cobre
de
par
trenzado
.
Se
ha
utilizado
durante
un
siglo
en
las
redes
telef√≥nicas
.
De
hecho
,


m√°s
del
99
por
ciento
de
las
conexiones
cableadas
utilizan
cable
de
cobre
de
par
trenzado


entre
el
propio
tel√©fono
y
el
conmutador
telef√≥nico
local
.
La
mayor√≠a
de
nosotros
dispone-


mos
de
cable
de
par
trenzado
en
nuestros
hogares
y
entornos
de
trabajo
.
Este
cable
consta


de
dos
hilos
de
cobre
aislados
,
de
un
mil√≠metro
de
espesor
cada
uno
de
ellos
,
que
siguen
un


patr√≥n
regular
en
espiral
.
Los
hilos
se
trenzan
para
reducir
las
interferencias
el√©ctricas
pro-


cedentes
de
pares
similares
pr√≥ximos
.
Normalmente
,
una
serie
de
pares
se
meten
dentro
de


un
cable
envolviendo
los
pares
en
una
pantalla
protectora
.
Un
par
de
hilos
constituyen
un


√∫nico
enlace
de
comunicaciones
.
El
par
trenzado
no
apantallado
(
UTP
,
Unshielded


Twisted
Pair
)
se
utiliza
habitualmente
en
las
redes
de
computadoras
ubicadas
dentro
de


un
edificio
,
es
decir
,
para
las
redes
LAN
.
La
velocidad
de
transmisi√≥n
de
datos
de
las


LAN
actuales
que
emplean
cables
de
par
trenzado
var√≠an
entre
10
Mbps
y
1
Gbps
.
Las


velocidades
de
transmisi√≥n
de
datos
que
se
pueden
alcanzar
dependen
del
espesor
del


cable
y
de
la
distancia
existente
entre
el
transmisor
y
el
receptor
.


Cuando
en
la
d√©cada
de
1980
surgi√≥
la
tecnolog√≠a
de
la
fibra
√≥ptica
,
muchas
personas


despreciaron
el
cable
de
par
trenzado
a
causa
de
sus
relativamente
bajas
velocidades
de


transmisi√≥n
.
Algunos
pensaron
incluso
que
la
fibra
√≥ptica
desplazar√≠a
por
completo
al
cable


de
par
trenzado
.
Pero
el
cable
de
par
trenzado
no
se
dar√≠a
por
vencido
tan
f√°cilmente
.
La
tec-


nolog√≠a
moderna
del
par
trenzado
,
como
por
ejemplo
los
cables
UTP
de
categor√≠a
5
,
pueden


alcanzar
velocidades
de
datos
de
1
Gbps
para
distancias
de
hasta
100
metros
.
Al
final
,
los


cables
de
par
trenzado
se
han
establecido
como
la
soluci√≥n
dominante
para
las
redes
LAN


de
alta
velocidad
.


Como
hemos
mencionado
anteriormente
,
los
cables
de
par
trenzado
tambi√©n
suelen
uti-


lizarse
para
el
acceso
a
Internet
de
tipo
residencial
.
Hemos
dicho
que
los
modems
de
acceso


telef√≥nico
permiten
establecer
conexiones
a
velocidades
de
hasta
56
kbps
utilizando
cables


de
par
trenzado
.
Tambi√©n
hemos
comentado
que
la
tecnolog√≠a
DSL
(
Digital
Subscriber


Line
)
ha
permitido
a
los
usuarios
residenciales
acceder
a
Internet
a
velocidades
superiores
a


1.2
‚Ä¢
LA
FRONTERA
DE
LA
RED
21


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
2122
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


6
Mbps
empleando
cables
de
par
trenzado
(
siempre
y
cuando
los
usuarios
vivan
en
las
pro-


ximidades
del
m√≥dem
del
ISP
)
.


Cable
coaxial


Al
igual
que
el
par
trenzado
,
el
cable
coaxial
consta
de
dos
conductores
de
cobre
,
pero
dis-


puestos
de
forma
conc√©ntrica
en
lugar
de
en
paralelo
.
Con
esta
construcci√≥n
y
un
aisla-


miento
y
apantallamiento
especiales
,
el
cable
coaxial
puede
proporcionar
velocidades
de


transmisi√≥n
de
bit
bastante
altas
.
El
cable
coaxial
es
bastante
com√∫n
en
los
sistemas
de
tele-


visi√≥n
por
cable
.
Como
hemos
mencionado
anteriormente
,
recientemente
los
sistemas
de


televisi√≥n
por
cable
han
comenzado
a
incorporar
modems
por
cable
con
el
fin
de
proporcio-


nar
a
los
usuarios
residenciales
acceso
a
Internet
a
velocidades
de
1
Mbps
o
superiores
.
En


la
televisi√≥n
por
cable
y
en
el
acceso
a
Internet
por
cable
,
el
transmisor
desplaza
la
se√±al


digital
a
una
banda
de
frecuencia
espec√≠fica
y
la
se√±al
anal√≥gica
resultante
se
env√≠a
desde
el


transmisor
a
uno
a
o
m√°s
receptores
.
El
cable
coaxial
puede
utilizarse
como
un
medio
com-


partido
guiado
;
es
decir
,
una
serie
de
sistemas
terminales
pueden
estar
conectados
directa-


mente
al
cable
,
recibiendo
todos
ellos
lo
que
env√≠en
los
otros
sistemas
terminales
.


Fibra
√≥ptica


La
fibra
√≥ptica
es
un
medio
flexible
y
de
poco
espesor
que
conduce
pulsos
de
luz
,
repre-


sentando
cada
pulso
un
bit
.
Un
√∫nico
cable
de
fibra
√≥ptica
puede
soportar
velocidades
de


bit
tremendamente
altas
,
por
encima
de
decenas
o
incluso
centenas
de
gigabits
por


segundo
.
La
fibra
√≥ptica
es
inmune
a
las
interferencias
electromagn√©ticas
,
presenta
una
ate-


nuaci√≥n
de
la
se√±al
muy
baja
hasta
una
distancia
de
100
kil√≥metros
y
es
muy
dif√≠cil
que


alguien
pueda
llevar
a
cabo
un
‚Äú
pinchazo
‚Äù
en
una
de
estas
l√≠neas
.
Estas
caracter√≠sticas


hacen
de
la
fibra
√≥ptica
el
medio
de
transmisi√≥n
guiado
a
larga
distancia
preferido
,
espe-


cialmente
para
los
enlaces
transoce√°nicos
.
Muchas
de
las
redes
telef√≥nicas
para
larga
dis-


tancia
de
Estados
Unidos
y
otros
pa√≠ses
utilizan
hoy
d√≠a
exclusivamente
fibra
√≥ptica
.
La


fibra
√≥ptica
tambi√©n
es
el
medio
predominante
en
las
redes
troncales
de
Internet
.
Sin


embargo
,
el
alto
coste
de
los
dispositivos
√≥pticos
,
como
son
los
transmisores
,
receptores
y


conmutadores
,
est√°n
entorpeciendo
su
implantaci√≥n
para
el
transporte
a
corta
distancia
,


como
por
ejemplo
en
el
caso
de
una
LAN
o
en
el
domicilio
de
una
red
de
acceso
residen-


cial
.
Las
velocidades
del
enlace
est√°ndar
de
portadora
√≥ptica
(
OC
,
Optical
Carrier
)
est√°n


comprendidas
en
el
rango
de
51,8
Mbps
a
39,8
Gbps
;
suele
hacerse
referencia
a
estas
espe-


cificaciones
como
OC-n
,
donde
la
velocidad
del
enlace
es
igual
a
n
 
51,8
Mbps
.
Entre
los


est√°ndares
en
uso
actuales
se
encuentran
:
OC-1
,
OC-3
,
OC-12
,
OC-24
,
OC-48
,
OC-96
,


OC-192
,
OC-768
.
[
IEC
Optical
2009
;
Goralski
2001
;
Ramaswami
1998
y
Mukherjee
1997
]


proporcionan
informaci√≥n
acerca
de
diversos
aspectos
de
las
redes
√≥pticas
.


Canales
de
radio
terrestres


Los
canales
de
radio
transportan
se√±ales
en
el
espectro
electromagn√©tico
.
Constituyen
un


medio
atractivo
porque
no
requieren
la
instalaci√≥n
de
cables
f√≠sicos
,
pueden
atravesar
las


paredes
,
proporcionan
conectividad
a
los
usuarios
m√≥viles
y
,
potencialmete
,
pueden
trans-


portar
una
se√±al
a
grandes
distancias
.
Las
caracter√≠sticas
de
un
canal
de
radio
dependen
de


forma
significativa
del
entorno
de
propagaci√≥n
y
de
la
distancia
a
la
que
la
se√±al
tenga
que


ser
transportada
.
Las
consideraciones
ambientales
determinan
la
p√©rdida
del
camino
,
la
ate-


nuaci√≥n
de
sombra
(
lo
que
disminuye
la
intensidad
de
la
se√±al
a
medida
que
recorre
una
dis-


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
221.3
‚Ä¢
EL
N√öCLEO
DE
LA
RED
23


tancia
y
rodea
/
atraviesa
los
objetos
que
obstruyen
su
camino
)
,
la
atenuaci√≥n
multicamino


(
debida
a
la
reflexi√≥n
de
la
se√±al
en
los
objetos
que
interfieren
)
y
las
interferencias
(
debidas


a
otras
transmisiones
y
a
las
se√±ales
electromagn√©ticas
)
.


Las
canales
de
radio
terrestre
pueden
clasificarse
en
dos
amplios
grupos
:
aqu√©llos
que


operan
en
las
√°reas
locales
,
normalmente
con
un
alcance
de
entre
diez
y
unos
cientos
de


metros
y
los
que
operan
en
un
√°rea
extensa
,
con
alcances
de
decenas
de
kil√≥metros
.
Las


redes
LAN
inal√°mbricas
descritas
en
la
Secci√≥n
1.2.2
emplean
canales
de
radio
de
√°rea


local
y
las
tecnolog√≠as
celulares
utilizan
canales
de
radio
de
√°rea
extensa
.
En
el
Cap√≠tulo
6


se
estudian
en
detalle
los
canales
de
radio
.


Canales
de
radio
v√≠a
sat√©lite


Las
comunicaciones
por
sat√©lite
enlazan
dos
o
m√°s
transmisores
/
receptores
de
microondas


con
base
en
la
Tierra
,
que
se
conocen
como
estaciones
terrestres
.
El
sat√©lite
recibe
las
trans-


misiones
en
una
banda
de
frecuencia
,
regenera
la
se√±al
utilizando
un
repetidor
(
v√©ase
m√°s


adelante
)
y
transmite
la
se√±al
a
otra
frecuencia
.
En
este
tipo
de
comunicaciones
se
emplean


dos
tipos
de
sat√©lites
:
los
sat√©lites
geoestacionarios
y
los
sat√©lites
de
la
√≥rbita
baja
terres-


tre
(
LEO
,
Low-Earth
Orbiting
)
.


Los
sat√©lites
geoestacionarios
est√°n
permanentemente
situados
en
el
mismo
punto
por


encima
de
la
Tierra
.
Esta
presencia
estacionaria
se
consigue
poniendo
el
sat√©lite
en
√≥rbita
a


una
distancia
de
36.000
kil√≥metros
por
encima
de
la
superficie
de
la
Tierra
.
La
distancia


entre
la
estaci√≥n
terrestre
y
el
sat√©lite
m√°s
la
distancia
de
vuelta
desde
el
sat√©lite
a
la
estaci√≥n


terrestre
introduce
un
retardo
de
propagaci√≥n
de
la
se√±al
de
280
milisegundos
.
No
obstante
,


los
enlaces
v√≠a
sat√©lite
,
que
pueden
operar
a
velocidades
de
cientos
de
Mbps
,
a
menudo
se


emplean
en
√°reas
en
las
que
no
hay
disponible
acceso
a
Internet
mediante
DSL
o
cable
.


Los
sat√©lites
LEO
se
colocan
mucho
m√°s
cerca
de
la
Tierra
y
no
se
encuentran
perma-


nentemente
en
la
misma
posici√≥n
,
sino
que
giran
alrededor
de
la
Tierra
(
al
igual
que
la
Luna
)


y
pueden
comunicarse
entre
s√≠
,
as√≠
como
con
las
estaciones
terrestres
.
Para
poder
proporcio-


nar
una
cobertura
continua
a
un
√°rea
,
es
preciso
poner
en
√≥rbita
muchos
sat√©lites
.
Actual-


mente
se
est√°n
desarrollando
muchos
sistemas
de
comunicaciones
de
baja
altitud
.
La
p√°gina


web
Lloyd‚Äôs
satellite
constellations
[
Wood
2009
]
proporciona
y
recopila
informaci√≥n
acerca


de
los
sistemas
de
constelaciones
de
sat√©lites
para
comunicaciones
.
La
tecnolog√≠a
de
los


sat√©lites
de
la
√≥rbita
baja
terrestre
(
LEO
)
podr√°
utilizarse
,
en
alg√∫n
momento
en
el
futuro
,


para
acceder
a
Internet
.


1.3
El
n√∫cleo
de
la
red


Una
vez
que
hemos
examinado
la
frontera
de
Internet
,
vamos
a
adentrarnos
en
el
n√∫cleo
de
la


red
,
la
malla
de
conmutadores
de
paquetes
y
enlaces
que
interconectan
los
sistemas
termina-


les
de
Internet
.
En
la
Figura
1.11
se
ha
resaltado
el
n√∫cleo
de
la
red
con
l√≠neas
m√°s
gruesas
.


1.3.1
Conmutaci√≥n
de
circuitos
y
conmutaci√≥n
de
paquetes


Existen
dos
m√©todos
fundamentales
que
permiten
transportar
los
datos
a
trav√©s
de
una
red


de
enlaces
y
conmutadores
:
la
conmutaci√≥n
de
circuitos
y
la
conmutaci√≥n
de
paquetes
.


En
las
redes
de
conmutaci√≥n
de
circuitos
,
los
recursos
necesarios
a
lo
largo
de
una
ruta


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
2324
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


Figura
1.11
‚Ä¢
El
n√∫cleo
de
la
red
.


(
buffers
,
velocidad
de
transmisi√≥n
del
enlace
)
que
permiten
establecer
la
comunicaci√≥n


entre
los
sistemas
terminales
est√°n
reservados
durante
el
tiempo
que
dura
la
sesi√≥n
entre


dichos
sistemas
terminales
.
En
las
redes
de
conmutaci√≥n
de
paquetes
,
estos
recursos
no


est√°n
reservados
;
los
mensajes
de
una
sesi√≥n
utilizan
los
recursos
bajo
petici√≥n
y
,
en
con-


ISP
nacional


o
globalRed


m√≥vil


ISP
local


o
regional


Red
empresarial


Red
dom√©stica


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
241.3
‚Ä¢
EL
N√öCLEO
DE
LA
RED
25


secuencia
,
pueden
tener
que
esperar
(
es
decir
,
ponerse
en
cola
)
para
poder
acceder
a
un


enlace
de
comunicaciones
.
Veamos
una
sencilla
analog√≠a
.
Piense
en
dos
restaurantes
,
en


uno
de
ellos
es
necesario
hacer
reserva
y
en
el
otro
no
se
requiere
hacer
reserva
ni
tampoco


las
admiten
.
Para
comer
en
el
restaurante
que
precisa
reserva
,
tenemos
que
molestarnos
en


llamar
por
tel√©fono
antes
de
salir
de
casa
,
pero
al
llegar
all√≠
,
en
principio
,
podremos
sentar-


nos
y
pedir
nuestro
men√∫
al
camarero
de
manera
inmediata
.
En
el
restaurante
que
no


admite
reservas
,
no
tenemos
que
molestarnos
en
reservar
mesa
,
pero
al
llegar
all√≠
,
es
posi-


ble
que
tengamos
que
esperar
para
tener
una
mesa
antes
de
poder
hablar
con
el
camarero
.


Las
omnipresentes
redes
telef√≥nicas
son
ejemplos
de
redes
de
conmutaci√≥n
de
circui-


tos
.
Considere
lo
que
ocurre
cuando
una
persona
desea
enviar
informaci√≥n
(
de
voz
o
fax-


s√≠mil
)
a
otra
a
trav√©s
de
una
red
telef√≥nica
.
Antes
de
que
el
emisor
pueda
transmitir
la


informaci√≥n
,
la
red
debe
establecer
una
conexi√≥n
entre
el
emisor
y
el
receptor
.
Se
trata
de


una
conexi√≥n
de
buena
fe
en
la
que
los
conmutadores
existentes
en
la
ruta
entre
el
emisor
y


el
receptor
mantienen
el
estado
de
la
conexi√≥n
para
dicha
comunicaci√≥n
.
En
la
jerga
del


campo
de
la
telefon√≠a
,
esta
conexi√≥n
se
denomina
circuito
.
Cuando
la
red
establece
el
cir-


cuito
,
tambi√©n
reserva
una
velocidad
de
transmisi√≥n
constante
en
los
enlaces
de
la
red
para


el
tiempo
que
dure
la
conexi√≥n
.
 
Dado
que
el
ancho
de
banda
para
esta
conexi√≥n
emisor-


receptor
ha
sido
reservado
,
el
emisor
puede
transferir
los
datos
al
receptor
a
la
velocidad


constante
garantizada
.


La
red
Internet
de
hoy
d√≠a
es
la
quinta
esencia
de
las
redes
de
conmutaci√≥n
de
paquetes
.


Veamos
qu√©
ocurre
cuando
un
host
desea
enviar
un
paquete
a
otro
host
a
trav√©s
de
Internet
.


Al
igual
que
con
la
conmutaci√≥n
de
circuitos
,
el
paquete
se
transmite
a
trav√©s
de
una
serie


de
enlaces
de
comunicaciones
.
Pero
con
la
t√©cnica
de
conmutaci√≥n
de
paquetes
,
el
paquete


se
env√≠a
a
la
red
sin
haber
reservado
ancho
de
banda
.
Si
uno
de
los
enlaces
est√°
congestio-


nado
porque
otros
paquetes
tienen
que
ser
transmitidos
a
trav√©s
de
√©l
al
mismo
tiempo
,


entonces
nuestro
paquete
tendr√°
que
esperar
en
un
buffer
en
el
lado
del
emisor
del
enlace
de


transmisi√≥n
y
,
por
tanto
,
sufrir√°
un
retardo
.
Internet
realiza
el
m√°ximo
esfuerzo
para
sumi-


nistrar
los
paquetes
a
tiempo
,
pero
no
existe
ninguna
garant√≠a
.


No
todas
las
redes
de
telecomunicaciones
pueden
clasificarse
como
redes
puras
de
con-


mutaci√≥n
de
circuitos
o
redes
puras
de
conmutaci√≥n
de
paquetes
.
No
obstante
,
esta
clasifica-


ci√≥n
es
un
excelente
punto
de
partida
para
comprender
la
tecnolog√≠a
de
las
redes
de


telecomunicaciones
.


Conmutaci√≥n
de
circuitos


Este
libro
est√°
dedicado
a
las
redes
de
computadoras
,
Internet
y
la
conmutaci√≥n
de
paquetes
,


no
a
las
redes
telef√≥nicas
y
la
conmutaci√≥n
de
circuitos
.
No
obstante
,
es
importante
com-


prender
por
qu√©
Internet
y
otras
redes
de
computadoras
utilizan
la
tecnolog√≠a
de
conmuta-


ci√≥n
de
paquetes
en
lugar
de
la
tecnolog√≠a
m√°s
tradicional
de
conmutaci√≥n
de
circuitos
de


las
redes
telef√≥nicas
.
Por
esta
raz√≥n
,
a
continuaci√≥n
vamos
a
ofrecer
una
breve
introducci√≥n


a
la
conmutaci√≥n
de
circuitos
.


La
Figura
1.12
ilustra
una
red
de
conmutaci√≥n
de
circuitos
.
En
esta
red
,
los
cuatro
con-


mutadores
de
circuitos
est√°n
interconectados
mediante
cuatro
enlaces
.
Cada
uno
de
los
enla-


ces
tiene
n
circuitos
,
por
lo
que
cada
enlace
puede
dar
soporte
a
n
conexiones
simult√°neas
.


Cada
uno
de
los
hosts
(
por
ejemplo
,
los
PC
y
estaciones
de
trabajo
)
est√°
conectado
directa-


mente
a
uno
de
los
conmutadores
.
Cuando
dos
hosts
desean
comunicarse
,
la
red
establece


una
conexi√≥n
terminal
a
terminal
dedicada
entre
ellos
(
por
supuesto
,
las
llamadas
entre
 

M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
2526
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


Figura
1.12
‚Ä¢
Red
de
conmutaci√≥n
de
circuitos
simple
formada
por
cuatro


dispositivos
de
conmutaci√≥n
y
cuatro
enlaces
.


m√°s
de
dos
dispositivos
tambi√©n
son
posibles
,
pero
con
el
fin
de
que
el
lector
comprenda
el


concepto
,
vamos
a
suponer
por
el
momento
que
s√≥lo
intervienen
dos
hosts
en
cada
cone-


xi√≥n
)
.
Por
tanto
,
para
que
el
host
A
env√≠e
mensajes
al
host
B
,
la
red
tiene
que
reservar
en
pri-


mer
lugar
un
circuito
en
cada
uno
de
los
dos
enlaces
.
Dado
que
cada
enlace
tiene
n
circuitos
,


para
cada
enlace
utilizado
por
la
conexi√≥n
terminal
a
terminal
,
la
conexi√≥n
obtiene
una
frac-


ci√≥n
1
/
n
del
ancho
de
banda
del
enlace
para
el
tiempo
de
duraci√≥n
de
la
conexi√≥n
.


Multiplexaci√≥n
en
redes
de
conmutaci√≥n
de
circuitos


Un
circuito
en
un
enlace
se
implementa
bien
mediante
multiplexaci√≥n
por
divisi√≥n
de


frecuencia
(
FDM
,
Frequency-Division
Multiplexing
)
o
mediante
multiplexaci√≥n
por


divisi√≥n
en
el
tiempo
(
TDM
,
Time-Division
Multiplexing
)
.
Con
FDM
,
el
espectro
de
fre-


cuencia
de
un
enlace
se
reparte
entre
las
conexiones
establecidas
a
lo
largo
del
enlace
.


Espec√≠ficamente
,
el
enlace
dedica
una
banda
de
frecuencias
a
cada
conexi√≥n
durante
el


tiempo
que
√©sta
dure
.
En
las
redes
telef√≥nicas
,
esta
banda
de
frecuencias
normalmente


tiene
un
ancho
de
4
kHz
(
es
decir
,
4.000
hercios
o
4.000
ciclos
por
segundo
)
.
El
ancho
de


esta
banda
se
denomina
l√≥gicamente
ancho
de
banda
.
Las
estaciones
de
radio
FM
tam-


bi√©n
emplean
la
multiplexaci√≥n
FDM
para
compartir
el
espectro
de
frecuencias
entre
88


MHz
y
108
MHz
,
teniendo
cada
estaci√≥n
asignada
una
banda
de
frecuencias
espec√≠fica
.


En
un
enlace
TDM
,
el
tiempo
se
divide
en
marcos
de
duraci√≥n
fija
y
cada
marco
se


divide
en
un
n√∫mero
fijo
de
particiones
.
Cuando
la
red
establece
una
conexi√≥n
a
trav√©s
de


un
enlace
,
la
red
dedica
una
partici√≥n
de
cada
marco
a
dicha
conexi√≥n
.
Estas
particiones


est√°n
dedicadas
para
uso
exclusivo
de
dicha
conexi√≥n
con
una
partici√≥n
disponible
para
uti-


lizar
(
en
cada
marco
)
para
transmitir
los
datos
de
la
conexi√≥n
.


La
Figura
1.13
ilustra
las
multiplexaciones
FDM
y
TDM
para
un
enlace
de
red
espec√≠-


fico
que
da
soporte
a
cuatro
circuitos
.
En
el
caso
de
la
multiplexaci√≥n
por
divisi√≥n
de


Conexi√≥n
terminal
a
terminal
entre


los
hosts
A
y
B
,
utilizando
un
‚Äú
circuito
‚Äù


en
cada
uno
de
los
enlaces
.


Host
A


Host
B


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
26Figura
1.13
‚Ä¢
Con
FDM
cada
circuito
obtiene
de
forma
continua
una
fracci√≥n


del
ancho
de
banda
.
Con
TDM
,
cada
circuito
dispone
de
todo
el


ancho
de
banda
peri√≥dicamente
durante
breves
intervalos
de


tiempo
(
es
decir
,
durante
las
particiones
)
.


frecuencia
,
el
dominio
de
frecuencia
se
segmenta
en
cuatro
bandas
,
siendo
el
ancho
de


banda
de
cada
una
de
ellas
de
4
kHz
.
En
el
caso
de
la
multiplexaci√≥n
TDM
,
el
dominio
del


tiempo
se
divide
en
cuatro
marcos
,
conteniendo
cada
uno
de
ellos
cuatro
particiones
.
A
cada


circuito
se
le
asigna
la
misma
partici√≥n
dedicada
dentro
de
los
marcos
,
de
forma
c√≠clica
.
En


la
multiplexaci√≥n
TDM
,
la
velocidad
de
transmisi√≥n
de
un
circuito
es
igual
a
la
velocidad
de


marco
multiplicada
por
el
n√∫mero
de
bits
existentes
en
una
partici√≥n
.
Por
ejemplo
,
si
el


enlace
transmite
8.000
marcos
por
segundo
y
cada
partici√≥n
consta
de
8
bits
,
entonces
la


velocidad
de
transmisi√≥n
de
un
circuito
es
igual
a
64
kbps
.


Los
partidarios
de
la
tecnolog√≠a
de
conmutaci√≥n
de
paquetes
siempre
han
argumentado


que
la
conmutaci√≥n
de
circuitos
es
derrochadora
,
porque
los
circuitos
dedicados
quedan
inu-


tilizados
durantes
los
periodos
de
inactividad
.
Por
ejemplo
,
cuando
una
persona
deja
de


hablar
durante
una
llamada
telef√≥nica
,
los
recursos
de
red
inactivos
(
bandas
de
frecuencia
o


particiones
temporales
del
enlace
a
lo
largo
de
la
ruta
de
la
conexi√≥n
)
no
pueden
ser
emplea-


dos
por
otras
conexiones
en
curso
.
Otro
ejemplo
de
c√≥mo
estos
recursos
pueden
ser
infrauti-


lizados
ser√≠a
un
radi√≥logo
que
empleara
una
red
de
conmutaci√≥n
de
circuitos
para
acceder


remotamente
a
una
serie
de
radiograf√≠as
de
rayos
X.
El
radi√≥logo
establece
una
conexi√≥n
,


solicita
una
imagen
,
la
contempla
y
luego
solicita
otra
imagen
.
Los
recursos
de
la
red
est√°n


asignados
a
la
conexi√≥n
pero
no
se
utilizan
(
es
decir
,
se
desperdician
)
durante
el
tiempo
que


el
radi√≥logo
contempla
las
im√°genes
.
Los
partidarios
de
la
conmutaci√≥n
de
paquetes
tam-


bi√©n
disfrutan
apuntando
que
el
establecimiento
de
circuitos
terminal
a
terminal
y
la
reserva


de
ancho
de
banda
terminal
a
terminal
son
procesos
complicados
que
requieren
el
uso
de


software
de
se√±alizaci√≥n
complejo
para
coordinar
el
funcionamiento
de
los
switches
a
lo


largo
de
la
ruta
terminal
a
terminal
.


Antes
de
terminar
con
esta
exposici√≥n
acerca
de
la
conmutaci√≥n
de
circuitos
,
vamos
a


ver
un
ejemplo
num√©rico
que
deber√≠a
arrojar
m√°s
luz
sobre
este
tema
.
Consideremos
el


4
kHz


TDM


Enlace
Frecuencia


4
kHz


Partici√≥n


Clave
:


Todas
las
particiones
etiquetadas
como
‚Äú
2
‚Äù
est√°n


dedicadas
a
un
par
emisor-receptor
espec√≠fico


Marco


1


2


234
1234
12341234


Tiempo


1.3
‚Ä¢
EL
N√öCLEO
DE
LA
RED
27


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
2728
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


tiempo
que
se
tarda
en
enviar
un
archivo
de
640.000
bits
desde
el
host
A
al
host
B
a
trav√©s


de
una
red
de
conmutaci√≥n
de
circuitos
.
Supongamos
que
todos
los
enlaces
de
la
red
utilizan


multiplexaci√≥n
TDM
con
24
particiones
y
tienen
una
velocidad
de
bit
de
1,536
Mbps
.


Supongamos
tambi√©n
que
se
tardan
500
milisegundos
en
establecer
el
circuito
terminal
a
ter-


minal
antes
de
que
el
host
A
pueda
comenzar
a
transmitir
el
archivo
.
¬ø
Cu√°nto
tiempo
se
tarda


en
transmitir
el
archivo
?
La
velocidad
de
transmisi√≥n
de
cada
circuito
es
(
1,536
Mbps)/24
=


64
kbps
,
por
lo
que
se
precisan
(
640.000
bits)/(64
kbps
)
=
10
segundos
en
transmitir
el


archivo
.
A
estos
10
segundos
tenemos
que
sumarles
el
tiempo
de
establecimiento
del
cir-


cuito
,
lo
que
da
como
resultado
10,5
segundos
de
tiempo
total
de
transmisi√≥n
del
archivo
.


Observe
que
el
tiempo
de
transmisi√≥n
es
independiente
del
n√∫mero
de
enlaces
:
el
tiempo
de


transmisi√≥n
ser√°
10
segundos
independientemente
de
que
el
circuito
terminal
a
terminal
pase


a
trav√©s
de
un
enlace
o
de
cien
enlaces
.
(
El
retardo
real
terminal
a
terminal
tambi√©n
incluye


un
retardo
de
propagaci√≥n
;
v√©ase
la
Secci√≥n
1.4
.
)


Conmutaci√≥n
de
paquetes


Las
aplicaciones
distribuidas
intercambian
mensajes
para
llevar
a
cabo
sus
tareas
.
Los
men-


sajes
pueden
contener
cualquier
cosa
que
el
dise√±ador
del
protocolo
desee
.
Los
mensajes


pueden
realizar
una
funci√≥n
de
control
(
por
ejemplo
,
los
mensajes
de
saludo
‚Äú
Hola
‚Äù
del


ejemplo
anterior
sobre
establecimiento
de
la
comunicaci√≥n
)
o
pueden
contener
datos
,
como


por
ejemplo
un
mensaje
de
correo
electr√≥nico
,
una
imagen
JPEG
o
un
archivo
de
audio


MP3
.
En
las
redes
de
computadoras
modernas
,
el
origen
divide
los
mensajes
largos
en
frag-


mentos
de
datos
m√°s
peque√±os
que
se
conocen
como
paquetes
.
Entre
el
origen
y
el
destino
,


cada
uno
de
estos
paquetes
viaja
a
trav√©s
de
los
enlaces
de
comunicaciones
y
de
los


conmutadores
de
paquetes
(
de
los
que
existen
dos
tipos
predominantes
:
los
routers
y
los


switches
de
la
capa
de
enlace
)
.
Los
paquetes
se
transmiten
a
trav√©s
de
cada
enlace
de
comu-


nicaciones
a
una
velocidad
igual
a
la
velocidad
de
transmisi√≥n
m√°xima
del
enlace
.


La
mayor√≠a
de
los
conmutadores
de
paquetes
emplean
el
m√©todo
de
transmisi√≥n
de


almacenamiento
y
reenv√≠o
en
las
entradas
de
los
enlaces
.
Transmisi√≥n
de
almacenamiento


y
reenv√≠o
significa
que
el
conmutador
tiene
que
recibir
el
paquete
completo
antes
de
poder


comenzar
a
transmitir
el
primer
bit
del
paquete
al
enlace
de
salida
.
Por
tanto
,
los
conmuta-


dores
de
paquetes
de
almacenamiento
y
reenv√≠o
a√±aden
un
retardo
de
almacenamiento
y


reenv√≠o
en
la
entrada
de
cada
enlace
existente
a
lo
largo
de
la
ruta
que
debe
seguir
el


paquete
.
Veamos
el
tiempo
que
se
tarda
en
enviar
un
paquete
de
L
bits
desde
un
host
a
otro


host
en
una
red
de
conmutaci√≥n
de
paquetes
.
Supongamos
que
existen
Q
enlaces
entre
los


dos
hosts
,
y
que
la
velocidad
en
cada
uno
de
ellos
es
igual
a
R
bps
.
Suponemos
que
√©ste
es
el


√∫nico
paquete
presente
en
la
red
.
En
primer
lugar
,
el
paquete
tiene
que
enviarse
a
trav√©s
del


primer
enlace
que
sale
del
 
host
A
,
lo
que
consume
un
tiempo
de
L
/
R
segundos
.
A
continua-


ci√≥n
,
tiene
que
ser
transmitido
por
cada
uno
de
los
Q
‚Äì
1
enlaces
restantes
;
es
decir
,
se
tiene


que
almacenar
y
reenviar
Q
‚Äì
1
veces
,
a√±adi√©ndose
cada
vez
un
retardo
de
almacenamiento


y
reenv√≠o
de
L
/
R.
Por
tanto
,
el
retardo
total
es
igual
a
QL
/
R.


Cada
conmutador
de
paquetes
tiene
varios
enlaces
conectados
a
√©l
y
para
cada
enlace


conectado
,
el
conmutador
de
paquetes
dispone
de
un
buffer
de
salida
(
tambi√©n
denominado


cola
de
salida
)
,
que
almacena
los
paquetes
que
el
router
enviar√°
a
trav√©s
de
dicho
enlace
.
El


buffer
de
salida
desempe√±a
un
papel
clave
en
la
conmutaci√≥n
de
paquetes
.
Si
un
paquete


entrante
tiene
que
ser
transmitido
a
trav√©s
de
un
enlace
,
pero
se
encuentra
con
que
el
enlace


est√°
ocupado
transmitiendo
otro
paquete
,
el
paquete
entrante
tendr√°
que
esperar
en
el
buffer


de
salida
.
Por
tanto
,
adem√°s
de
los
retardos
de
almacenamiento
y
reenv√≠o
,
los
paquetes
se


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
28ven
afectados
por
los
retardos
de
cola
del
buffer
de
salida
.
Estos
retardos
son
variables
y


dependen
del
nivel
de
congesti√≥n
de
la
red
.
Puesto
que
la
cantidad
de
espacio
en
el
buffer
es


finita
,
un
paquete
entrante
puede
encontrarse
con
que
el
buffer
est√°
completamente
lleno
con


otros
paquetes
que
esperan
a
ser
transmitidos
.
En
este
caso
,
se
producir√°
una
p√©rdida
de


paquetes
,
bien
el
paquete
que
acaba
de
llegar
o
uno
que
ya
se
encuentra
en
la
cola
ser√°
des-


cartado
.
Si
volvemos
a
la
analog√≠a
de
los
restaurantes
vista
anteriormente
en
esta
secci√≥n
,
el


retardo
de
cola
es
an√°logo
a
la
cantidad
de
tiempo
que
usted
pierde
en
el
bar
del
restaurante


esperando
a
que
una
mesa
se
quede
libre
.
La
p√©rdida
de
paquetes
es
an√°loga
a
que
el
cama-


rero
le
comunique
que
es
mejor
que
vaya
a
otro
restaurante
porque
ya
hay
demasiadas
per-


sonas
esperando
en
el
bar
para
conseguir
una
mesa
.


La
Figura
1.14
ilustra
una
red
de
conmutaci√≥n
de
paquetes
simple
.
En
esta
figura
y
en


las
siguientes
,
los
paquetes
se
han
representado
mediante
bloques
tridimensionales
.
El
ancho


de
un
bloque
representa
el
n√∫mero
de
bits
que
contiene
el
paquete
.
En
esta
figura
,
todos
los


paquetes
tienen
el
mismo
ancho
y
,
por
tanto
,
la
misma
longitud
.
Suponga
ahora
que
los
hosts


A
y
B
est√°n
enviando
paquetes
al
host
E.
En
primer
lugar
,
los
hosts
A
y
B
env√≠an
sus
paque-


tes
a
trav√©s
de
los
enlaces
Ethernet
a
10
Mbps
hasta
el
primer
conmutador
de
paquetes
.
A


continuaci√≥n
,
√©ste
dirige
los
paquetes
al
enlace
de
1,5
Mbps
.
Si
la
velocidad
de
llegada
de


los
paquetes
al
conmutador
excede
la
velocidad
a
la
que
el
conmutador
puede
reenviar
los


paquetes
a
trav√©s
del
enlace
de
salida
de
1,5
Mbps
,
se
producir√°
congesti√≥n
a
medida
que


los
paquetes
se
pongan
en
cola
en
el
buffer
de
salida
del
enlace
antes
de
poder
ser
transmiti-


dos
.
En
la
Secci√≥n
1.4
examinaremos
m√°s
detalladamente
el
retardo
de
cola
.


Conmutaci√≥n
de
paquetes
frente
a
conmutaci√≥n
de
circuitos
:


multiplexaci√≥n
estad√≠stica


Ahora
que
ya
hemos
descrito
las
tecnolog√≠as
de
conmutaci√≥n
de
circuitos
y
de
paquetes
,


vamos
a
pasar
a
compararlas
.
Los
detractores
de
la
tecnolog√≠a
de
conmutaci√≥n
de
paquetes
a


menudo
han
argumentado
que
esta
tecnolog√≠a
no
es
adecuada
para
los
servicios
en
tiempo


real
,
como
por
ejemplo
las
llamadas
telef√≥nicas
y
las
videoconferencias
,
porque
sus
retardos


Figura
1.14
‚Ä¢
Conmutaci√≥n
de
paquetes
.


10
Mbps
Ethernet


Clave
:


Paquetes


A


B


C


DE


1,5
Mbps


Multiplexaci√≥n


estad√≠stica


Cola
de
paquetes


que
esperan
a
acceder


al
enlace
de
salida


1.3
‚Ä¢
EL
N√öCLEO
DE
LA
RED
29


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
29terminal
a
terminal
son
variables
e
impredecibles
(
a
causa
principalmente
de
que
los
retar-


dos
de
cola
de
los
paquetes
son
variables
e
impredecibles
)
.
Por
otro
lado
,
los
partidarios
de


la
conmutaci√≥n
de
paquetes
argumentan
que
(
1
)
ofrece
una
mejor
compartici√≥n
del
ancho


de
banda
que
la
tecnolog√≠a
de
conmutaci√≥n
de
circuitos
y
(
2
)
es
m√°s
sencilla
,
m√°s
eficiente


y
menos
cara
de
implementar
que
la
conmutaci√≥n
de
circuitos
.
Puede
encontrar
una
expo-


sici√≥n
interesante
acerca
de
la
conmutaci√≥n
de
paquetes
frente
a
la
conmutaci√≥n
de
circui-


tos
en
[
Molinero-Fern√°ndez
2002
]
.
Generalmente
,
las
personas
que
no
se
molestan
en


reservar
mesa
en
un
restaurante
prefieren
la
conmutaci√≥n
de
paquetes
a
la
conmutaci√≥n
de


circuitos
.


¬ø
Por
qu√©
es
m√°s
eficiente
la
conmutaci√≥n
de
paquetes
?
Veamos
un
ejemplo
sencillo
.


Suponga
que
varios
usuarios
comparten
un
enlace
de
1
Mbps
.
Suponga
tambi√©n
que
cada


usuario
alterna
entre
periodos
de
actividad
(
cuando
genera
datos
a
una
velocidad
constante
de


100
kbps
)
y
periodos
de
inactividad
(
cuando
no
genera
datos
)
.
Adem√°s
,
suponga
que
un
usua-


rio
s√≥lo
est√°
activo
un
10
por
ciento
del
tiempo
(
y
est√°
inactivo
tomando
caf√©
durante
el
90


por
ciento
del
tiempo
restante
)
.
Con
la
tecnolog√≠a
de
conmutaci√≥n
de
circuitos
,
tienen
que


reservarse
100
kbps
para
cada
usuario
todas
las
veces
.
Por
ejemplo
,
en
una
red
de
conmuta-


ci√≥n
de
circuitos
con
multiplexaci√≥n
TDM
,
si
un
marco
de
un
segundo
se
divide
en
10
parti-


ciones
de
100
ms
,
entonces
cada
usuario
tendr√≠a
asignada
una
partici√≥n
por
marco
.


Por
tanto
,
el
enlace
de
conmutaci√≥n
de
circuitos
s√≥lo
podr√°
dar
soporte
a
10


(=
1
Mbps/100
kbps
)
usuarios
simult√°neamente
.
En
el
caso
de
utilizar
la
conmutaci√≥n
de


paquetes
,
la
probabilidad
de
que
un
determinado
usuario
est√©
activo
es
0,1
(
es
decir
,
del
10


por
ciento
)
.
Si
hay
35
usuarios
,
la
probabilidad
de
que
11
o
m√°s
usuarios
est√©n
activos
simul-


t√°neamente
es
aproximadamente
igual
a
0,0004
.
(
El
Problema
P7
indica
c√≥mo
se
obtiene


esta
probabilidad
.
)
Cuando
hay
10
o
menos
usuarios
activos
a
la
vez
(
lo
que
ocurre
con
una


probabilidad
del
0,9996
)
,
la
velocidad
acumulada
de
llegada
de
los
datos
es
menor
o
igual
a


1
Mbps
,
la
velocidad
de
salida
del
enlace
.
Por
tanto
,
cuando
el
n√∫mero
de
usuarios
activos


es
10
o
menor
,
los
paquetes
fluyen
a
trav√©s
del
enlace
pr√°cticamente
sin
retardo
,
como
en
el


caso
de
la
tecnolog√≠a
de
conmutaci√≥n
de
circuitos
.
Cuando
hay
m√°s
de
10
usuarios
activos


simult√°neamente
,
entonces
la
velocidad
acumulada
de
llegada
de
los
paquetes
excede
la


capacidad
de
salida
del
enlace
y
la
cola
de
salida
comenzar√°
a
crecer
.
(
Contin√∫a
creciendo


hasta
que
la
velocidad
acumulada
de
entrada
cae
por
debajo
de
1
Mbps
,
punto
en
el
que
la


longitud
de
la
cola
comenzar√°
a
disminuir
.
)
Puesto
que
la
probabilidad
de
que
haya
m√°s
de


10
usuarios
conectados
a
la
vez
es
muy
baja
en
este
ejemplo
,
la
conmutaci√≥n
de
paquetes


proporciona
pr√°cticamente
el
mismo
rendimiento
que
la
conmutaci√≥n
de
circuitos
,
pero
lo


hace
permitiendo
que
haya
un
n√∫mero
de
usuarios
m√°s
de
tres
veces
superior
.


Consideremos
ahora
otro
ejemplo
sencillo
.
Suponga
que
hay
10
usuarios
y
que
de


repente
un
usuario
genera
1.000
paquetes
de
1.000
bits
,
mientras
que
los
usuarios
restantes


permanecen
inactivos
y
no
generan
paquetes
.
Con
la
tecnolog√≠a
de
conmutaci√≥n
de
circuitos


con
multiplexaci√≥n
TDM
con
10
particiones
por
marco
y
con
cada
partici√≥n
formada
por


1.000
bits
,
el
usuario
activo
s√≥lo
puede
emplear
su
partici√≥n
por
marco
para
transmitir
los


datos
,
mientras
que
las
restantes
nueve
particiones
de
cada
marco
permanecen
inactivas
.


Transcurrir√°n
10
segundos
antes
de
que
el
mill√≥n
de
bits
de
datos
del
usuario
activo
hayan


sido
transmitidos
.
Sin
embargo
,
con
la
conmutaci√≥n
de
paquetes
,
el
usuario
activo
puede


enviar
de
forma
continuada
sus
paquetes
a
la
velocidad
m√°xima
del
enlace
de
1
Mbps
,
ya
que


no
hay
ning√∫n
otro
usuario
generando
paquetes
que
tengan
que
ser
multiplexados
con
los


paquetes
del
usuario
activo
.
En
este
caso
,
todos
los
datos
del
usuario
activo
se
transmitir√°n
en


un
segundo
.


30
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
30Los
ejemplos
anteriores
han
servido
para
ilustrar
dos
casos
en
los
que
el
rendimiento
de


la
tecnolog√≠a
de
conmutaci√≥n
de
paquetes
puede
resultar
superior
a
la
de
la
conmutaci√≥n
de


circuitos
.
Tambi√©n
ha
quedado
patente
la
diferencia
crucial
entre
las
dos
formas
de
compar-


tir
la
velocidad
de
transmisi√≥n
del
enlace
entre
varios
flujos
de
datos
.
La
conmutaci√≥n
de


circuitos
preasigna
el
uso
del
enlace
de
transmisi√≥n
independientemente
de
la
demanda
,
con


lo
que
el
tiempo
de
enlace
asignado
,
pero
innecesario
,
se
desperdicia
.
Por
el
contrario
,
la


conmutaci√≥n
de
paquetes
asigna
el
uso
del
enlace
bajo
demanda
.
La
capacidad
de
transmi-


si√≥n
del
enlace
se
compartir√°
paquete
a
paquete
s√≥lo
entre
aquellos
usuarios
que
tienen


paquetes
que
transmitir
a
trav√©s
del
enlace
.
La
compartici√≥n
de
recursos
bajo
petici√≥n
(
en


lugar
de
por
preasignaci√≥n
)
a
veces
se
denomina
multiplexaci√≥n
estad√≠stica
de
recursos
.


Aunque
hoy
en
d√≠a
las
redes
de
telecomunicaciones
predominantes
son
las
de
conmuta-


ci√≥n
de
circuitos
y
de
paquetes
,
realmente
se
est√°
tendiendo
hacia
las
redes
de
conmutaci√≥n


de
paquetes
.
Incluso
muchas
de
las
redes
de
telefon√≠a
de
conmutaci√≥n
de
circuitos
actuales


se
est√°n
migrando
lentamente
a
redes
de
conmutaci√≥n
de
paquetes
.
En
particular
,
las
redes


telef√≥nicas
suelen
emplear
la
conmutaci√≥n
de
paquetes
en
la
parte
internacional
,
que
es
la


m√°s
cara
de
una
llamada
telef√≥nica
.


1.3.2
¬ø
C√≥mo
atraviesan
los
paquetes
las
redes


de
conmutaci√≥n
de
paquetes
?


Anteriormente
hemos
dicho
que
un
router
toma
un
paquete
entrante
en
uno
de
sus
enlaces


de
comunicaciones
,
pero
¬ø
c√≥mo
el
router
determina
el
enlace
por
el
que
deber√°
reenviar
el


paquete
?
En
realidad
,
los
diferentes
tipos
de
redes
pueden
hacer
esto
de
diversas
formas
.
En


este
cap√≠tulo
de
introducci√≥n
vamos
a
describir
un
m√©todo
popular
,
el
m√©todo
empleado
por


Internet
.


En
Internet
,
cada
paquete
que
atraviesa
la
red
contiene
en
su
cabecera
la
direcci√≥n
del


destino
del
paquete
.
Al
igual
que
las
direcciones
postales
,
esta
direcci√≥n
tiene
una
estructura


jer√°rquica
.
Cuando
llega
un
paquete
a
un
router
de
la
red
,
el
router
examina
una
parte
de
la


direcci√≥n
de
destino
del
paquete
y
lo
reenv√≠a
a
un
router
adyacente
.
M√°s
espec√≠ficamente
,


cada
router
dispone
de
una
tabla
de
reenv√≠o
que
asigna
las
direcciones
de
destino
(
o
una


parte
de
las
mismas
)
a
los
enlaces
salientes
.
Cuando
llega
un
paquete
a
un
router
,
√©ste
exa-


mina
la
direcci√≥n
y
busca
en
su
tabla
esa
direcci√≥n
de
destino
para
localizar
el
enlace
de


salida
apropiado
.
A
continuaci√≥n
,
el
router
dirige
el
paquete
a
ese
enlace
de
salida
.


Acabamos
de
ver
que
un
router
utiliza
la
direcci√≥n
de
destino
de
un
paquete
para
inde-


xar
una
tabla
de
reenv√≠o
y
determinar
el
enlace
de
salida
apropiado
.
Pero
esta
afirmaci√≥n
nos


lleva
a
la
siguiente
pregunta
:
¬ø
c√≥mo
se
definen
las
tablas
de
reenv√≠o
?
¬ø
Se
configuran


manualmente
en
cada
router
o
Internet
utiliza
un
procedimiento
m√°s
automatizado
?
Estas


cuestiones
se
abordan
en
detalle
en
el
Cap√≠tulo
4
,
pero
para
ir
abriendo
boca
,
diremos
que


Internet
dispone
de
una
serie
de
protocolos
de
enrutamiento
especiales
que
se
utilizan
para


definir
autom√°ticamente
las
tablas
de
reenv√≠o
.
Por
ejemplo
,
un
protocolo
de
enrutamiento


determina
la
ruta
m√°s
corta
desde
cada
router
hasta
cada
destino
y
el
uso
de
la
ruta
m√°s
corta


da
como
resultado
la
configuraci√≥n
de
las
tablas
de
reenv√≠o
en
los
routers
.


El
proceso
de
enrutamiento
de
terminal
a
terminal
es
an√°logo
al
que
sigue
el
conductor


de
un
autom√≥vil
que
no
utiliza
un
mapa
,
sino
que
prefiere
preguntar
c√≥mo
llegar
hasta
una


determinada
direcci√≥n
.
Por
ejemplo
,
suponga
que
Juan
sale
de
Filadelfia
y
tiene
que
llegar


al
156
de
Lakeside
Drive
en
Orlando
,
Florida
.
Lo
primero
que
hace
Juan
es
dirigirse
a
la


estaci√≥n
de
servicio
m√°s
pr√≥xima
y
preguntar
c√≥mo
llegar
a
su
destino
.
El
empleado
se


1.3
‚Ä¢
EL
N√öCLEO
DE
LA
RED
31


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
31queda
con
el
nombre
del
estado
Florida
,
y
le
dice
que
debe
tomar
la
autopista
interestatal


I-95
Sur
y
que
existe
una
entrada
a
la
misma
nada
m√°s
salir
de
la
estaci√≥n
de
servicio
.
Tam-


bi√©n
le
dice
a
Juan
que
una
vez
que
haya
entrado
en
Florida
,
pregunte
a
alguien
c√≥mo
llegar


a
su
destino
.
As√≠
,
Juan
toma
la
I-95
Sur
hasta
Jacksonville
,
Florida
,
lugar
donde
vuelve
a


preguntar
tambi√©n
en
una
estaci√≥n
de
servicio
.
El
dependiente
extrae
de
la
direcci√≥n
la
infor-


maci√≥n
que
hace
referencia
a
Orlando
y
le
dice
que
debe
continuar
por
la
I-95
hasta
Day-


tona
Beach
y
que
luego
pregunte
.
En
otra
estaci√≥n
de
servicio
de
Daytona
Beach
,
el


empleado
de
nuevo
extrae
la
informaci√≥n
referente
a
Orlando
y
le
dice
que
tomando
la
I-4


llegar√°
directamente
a
Orlando
.
Juan
toma
la
I-4
y
la
abandona
en
la
salida
que
indica
a


Orlando
.
De
nuevo
se
detiene
en
otra
gasolinera
y
esta
vez
el
dependiente
extrae
la
parte
de


la
informaci√≥n
de
la
direcci√≥n
referente
a
Lakeside
Drive
y
le
indica
la
carretera
que
debe


seguir
para
llegar
all√≠
.
Una
vez
que
Juan
se
encuentra
en
Lakeside
Drive
,
pregunta
a
un
ni√±o


que
va
en
bicicleta
c√≥mo
llegar
a
su
destino
.
El
ni√±o
extrae
el
dato
156
de
la
direcci√≥n
y
le


se√±ala
una
casa
.
Por
fin
,
Juan
ha
llegado
a
su
destino
.


En
esta
analog√≠a
,
los
dependientes
de
las
estaciones
de
servicio
y
el
ni√±o
de
la
bicicleta


son
los
routers
,
y
sus
tablas
de
reenv√≠o
,
que
son
sus
cerebros
,
se
han
ido
configurando
a
lo


largo
de
a√±os
de
experiencia
.


¬ø
C√≥mo
podr√≠amos
ver
la
ruta
terminal
a
terminal
que
siguen
los
paquetes
en
Internet
?


Le
invitamos
a
que
utilice
el
programa
Traceroute
,
visitando
el
sitio
http://www.traceroute
.


org
.
(
Para
obtener
m√°s
informaci√≥n
acerca
de
Traceroute
,
consulte
la
Secci√≥n
1.4
.
)


1.3.3
Redes
troncales
de
Internet
y
proveedores
ISP


Anteriormente
hemos
visto
que
los
sistemas
terminales
(
los
PC
de
usuario
,
las
PDA
,
los
ser-


vidores
web
,
los
servidores
de
correo
electr√≥nico
,
etc.
)
se
conectan
a
Internet
a
trav√©s
de
un


ISP
local
.
El
ISP
puede
proporcionar
conectividad
cableada
o
inal√°mbrica
,
mediante
una


amplia
variedad
de
tecnolog√≠as
de
acceso
,
entre
las
que
se
incluyen
DSL
,
cable
,
FTTH
,
Wi-


Fi
,
celular
y
WiMAX
.
Observe
que
el
ISP
local
no
tiene
que
ser
una
compa√±√≠a
telef√≥nica
ni


una
compa√±√≠a
de
cable
:
puede
ser
,
por
ejemplo
,
una
universidad
(
que
proporciona
acceso
a


Internet
a
los
estudiantes
,
al
personal
y
a
las
facultades
)
o
una
empresa
(
que
proporciona


acceso
a
sus
empleados
)
.
Pero
la
conexi√≥n
de
los
usuarios
finales
y
de
los
proveedores
de


contenido
a
los
ISP
locales
es
s√≥lo
una
peque√±a
parte
del
problema
de
conectar
los
cientos


de
millones
de
sistemas
terminales
y
los
cientos
de
miles
de
redes
que
conforman
Internet
.


Internet
es
una
red
de
redes
y
entender
esta
afirmaci√≥n
es
fundamental
para
resolver
este


puzzle
.


En
la
red
p√∫blica
Internet
,
los
ISP
de
acceso
situados
en
la
frontera
de
Internet
est√°n


conectados
al
resto
de
Internet
a
trav√©s
de
una
jerarqu√≠a
de
niveles
de
proveedores
ISP
,
como


se
muestra
en
la
Figura
1.15
.
Los
ISP
de
acceso
se
sit√∫an
en
el
nivel
inferior
de
esta
jerar-


qu√≠a
.
En
el
 
nivel
superior
de
la
jerarqu√≠a
se
encuentran
en
un
n√∫mero
relativamente
m√°s


peque√±o
los
ISP
de
nivel
1
.
Por
un
lado
,
un
ISP
de
nivel
1
es
igual
que
cualquier
red
(
est√°
for-


mado
por
enlaces
y
routers
,
y
est√°
conectado
a
otras
redes
)
.
Sin
embargo
,
estos
ISP
presen-


tan
otras
caracter√≠sticas
que
los
hace
especiales
.
La
velocidad
de
enlace
suele
ser
de
622


Mbps
o
superior
,
por
lo
que
los
ISP
de
nivel
1
de
mayor
tama√±o
disponen
de
enlaces
en
el


rango
comprendido
entre
2,5
y
10
Gbps
;
en
consecuencia
,
sus
routers
deben
poder
reenviar


los
paquetes
a
velocidades
extremadamente
altas
.
Los
ISP
de
nivel
1
tambi√©n
se
caracterizan


por
lo
siguiente
:


‚Ä¢E
s
t
√°
n
 
c
o
n
e
c
t
a
d
o
s
 
d
i
r
e
c
t
a
m
e
n
t
e
 
a
 
cada
uno
de
los
restantes
ISP
de
nivel
1
.


32
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
32Figura
1.15
‚Ä¢
Interconexi√≥n
de
los
ISP
.


‚Ä¢
Est√°n
conectados
a
un
gran
n√∫mero
de
ISP
de
nivel
2
y
a
otras
redes
cliente
.


‚Ä¢
Proporcionan
cobertura
internacional
.


Los
ISP
de
nivel
1
tambi√©n
se
conocen
como
redes
troncales
de
Internet
.
Entre
estos


ISP
se
incluyen
Sprint
,
Verizon
,
MCI
(
anteriormente
UUNet
/
WorldCom
)
,
AT&T
,
NTT
,


Level3
,
Qwest
y
Cable
&
Wireless
.
Resulta
curioso
que
,
oficialmente
,
no
existe
ning√∫n
grupo


que
conceda
el
estatus
de
nivel
1
;
como
reza
el
dicho
:
si
tienes
que
preguntar
si
eres
miembro


de
un
grupo
,
es
que
probablemente
no
lo
eres
.


Por
regla
general
,
un
ISP
de
nivel
2
tiene
cobertura
regional
o
nacional
y
lo
que
es
m√°s


importante
,
s√≥lo
est√°
conectado
a
unos
pocos
ISP
de
nivel
1
(
v√©ase
la
Figura
1.15
)
.
Por
tanto
,


para
llegar
a
gran
parte
de
la
red
Internet
global
,
un
ISP
de
nivel
2
tiene
que
enrutar
el
tr√°-


fico
a
trav√©s
de
uno
de
los
ISP
de
nivel
1
a
los
que
est√°
conectado
.
Se
dice
que
un
ISP
de


nivel
2
es
un
cliente
del
ISP
de
nivel
1
al
que
est√°
conectado
y
que
el
ISP
de
nivel
1
es
un


proveedor
de
dicho
cliente
.
Muchas
instituciones
y
empresas
de
gran
tama√±o
conectan
sus


redes
empresariales
directamente
a
un
ISP
de
nivel
1
o
de
nivel
2
,
convirti√©ndose
as√≠
en
un


cliente
de
dicho
ISP
.
Un
ISP
proveedor
cobra
unas
determinadas
tasas
al
ISP
cliente
,
que


normalmente
dependen
de
la
velocidad
de
transmisi√≥n
del
enlace
que
los
conecta
.
Una
red


de
nivel
2
tambi√©n
se
puede
conectar
directamente
a
otras
redes
de
nivel
2
,
en
cuyo
caso
el


tr√°fico
puede
fluir
entre
las
dos
redes
de
nivel
2
sin
tener
que
pasar
a
trav√©s
de
una
red
de


nivel
1
.
Por
debajo
de
los
ISP
de
nivel
2
se
encuentran
los
ISP
de
nivel
inferior
,
que
se


conectan
a
Internet
a
trav√©s
de
uno
o
m√°s
ISP
de
nivel
2
.
En
el
nivel
m√°s
bajo
de
la
jerarqu√≠a


Nivel
1


Nivel
2


Nivel
3


1.3
‚Ä¢
EL
N√öCLEO
DE
LA
RED
33


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
33se
encuentran
los
ISP
de
acceso
.
Para
complicar
a√∫n
m√°s
las
cosas
,
algunos
proveedores
de


nivel
1
tambi√©n
son
proveedores
de
nivel
2
(
es
decir
,
est√°n
integrados
verticalmente
)
,
que


venden
directamente
acceso
a
Internet
a
los
usuarios
finales
y
proveedores
de
contenido
,
as√≠


como
a
los
ISP
del
nivel
inferior
.
Cuando
dos
ISP
est√°n
conectados
directamente
entre
s√≠
en


el
mismo
nivel
,
se
dice
que
son
igualitarios
.
Existe
un
interesante
estudio
[
Subramanian


2002
]
que
intenta
definir
la
estructura
en
niveles
de
Internet
de
forma
m√°s
precisa
estu-


diando
la
topolog√≠a
de
Internet
en
funci√≥n
de
las
relaciones
cliente-proveedor
y
las
rela-


ciones
entre
iguales
.
Consulte
[
Van
der
Berg
2008
]
para
ver
una
explicaci√≥n
bastante
com-


prensible
acerca
de
las
relaciones
entre
iguales
y
cliente-proveedor
.


Dentro
de
la
red
de
un
ISP
,
los
puntos
en
los
que
el
ISP
se
conecta
a
otros
ISP
(
sean
de


nivel
inferior
,
superior
o
del
mismo
nivel
dentro
de
la
jerarqu√≠a
)
se
conocen
como
Puntos


de
presencia
(
POP
,
Point
of
Presence
)
.
Un
POP
es
simplemente
un
grupo
de
uno
o
m√°s


routers
de
la
red
del
ISP
en
los
que
los
routers
de
otros
ISP
o
de
las
redes
que
pertenecen
a


los
clientes
del
ISP
pueden
conectarse
.
Un
proveedor
de
nivel
1
normalmente
tiene
muchos


POP
dispersos
por
distintas
localizaciones
geogr√°ficas
dentro
de
la
red
,
con
m√∫ltiples
redes


y
otros
ISP
conectados
a
cada
POP
.
Normalmente
,
cuando
una
red
cliente
tiene
que
conec-


tarse
al
POP
de
un
proveedor
,
alquila
un
enlace
de
alta
velocidad
de
un
proveedor
de
teleco-


municaciones
de
una
tercera
empresa
y
conecta
directamente
uno
de
sus
routers
a
un
router


ubicado
en
el
POP
del
proveedor
.
Adem√°s
,
dos
ISP
pueden
disponer
de
varios
puntos
de


conexi√≥n
entre
iguales
,
conect√°ndose
entre
s√≠
en
m√∫ltiples
pares
de
POP
.


En
resumen
,
la
topolog√≠a
de
Internet
es
compleja
y
est√°
formada
por
docenas
de
ISP
de


nivel
1
y
de
nivel
2
y
por
miles
de
ISP
de
nivel
inferior
.
La
cobertura
de
los
ISP
puede
ser


muy
variada
,
pudi√©ndose
extender
a
varios
continentes
y
oc√©anos
hasta
estar
limitada
a


peque√±as
regiones
del
mundo
.
Los
ISP
del
nivel
inferior
se
conectan
a
los
ISP
de
los
nive-


les
superiores
y
√©stos
a
su
vez
se
interconectan
entre
s√≠
.
Los
usuarios
y
los
proveedores
de


contenido
son
clientes
de
los
ISP
de
nivel
inferior
y
√©stos
son
clientes
de
los
ISP
de
nivel


superior
.


1.4
Retardos
,
p√©rdidas
y
tasa
de
transferencia


en
las
redes
de
conmutaci√≥n
de
paquetes


En
la
Secci√≥n
1.1
hemos
dicho
que
Internet
puede
verse
como
una
infraestructura
que
pro-


porciona
servicios
a
aplicaciones
distribuidas
que
se
ejecutan
en
sistemas
terminales
.
Ideal-


mente
,
desear√≠amos
que
los
servicios
de
Internet
pudieran
transportar
tantos
datos
como


quisi√©ramos
entre
cualesquiera
dos
sistemas
terminales
de
forma
instant√°nea
y
sin
que


tuviera
lugar
ninguna
p√©rdida
de
datos
.
Evidentemente
,
en
la
realidad
,
este
objetivo
es
inal-


canzable
,
ya
que
necesariamente
las
redes
de
computadoras
tienen
que
restringir
su
tasa
de


transferencia
(
la
cantidad
de
datos
por
segundo
que
pueden
transmitir
)
entre
sistemas
termi-


nales
,
introducir
retardos
entre
los
sistemas
terminales
y
perder
paquetes
.
Por
una
parte
,
es


lamentable
que
las
leyes
f√≠sicas
introduzcan
retardos
y
p√©rdidas
,
as√≠
como
que
restrinjan
las


tasas
de
transferencia
,
pero
,
por
otra
parte
,
puesto
que
las
redes
de
computadoras
presentan


estos
problemas
,
existen
muchas
cuestiones
interesantes
relacionadas
con
c√≥mo
abordarlos
,


¬°
m√°s
que
suficientes
como
para
llenar
un
curso
sobre
redes
de
computadoras
y
para
motivar


cientos
de
tesis
doctorales
!
En
esta
secci√≥n
comenzaremos
examinando
y
cuantificando
los


retardos
,
las
p√©rdidas
y
la
tasa
de
transferencia
en
las
redes
de
computadoras
.


34
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
341.4.1
Retardo
en
las
redes
de
conmutaci√≥n
de
paquetes


Recordemos
que
los
paquetes
se
inician
en
un
host
(
el
origen
)
,
atraviesan
una
serie
de
rou-


ters
y
terminan
su
viaje
en
otro
host
(
el
destino
)
.
Cuando
un
paquete
viaja
de
un
nodo
(
host


o
router
)
al
siguiente
nodo
(
host
o
router
)
a
lo
largo
de
una
ruta
,
el
paquete
sufre
varios


tipos
de
retardo
en
cada
uno
de
los
nodos
de
dicha
ruta
.
Los
m√°s
importantes
de
estos
retar-


dos
son
:
el
retardo
de
procesamiento
nodal
,
e
l
 
retardo
de
cola
,
el
retardo
de
transmi-


si√≥n
y
el
retardo
de
propagaci√≥n
;
todos
estos
retardos
se
suman
para
proporcionar
el


retardo
nodal
total
.
Para
adquirir
un
conocimiento
profundo
de
la
tecnolog√≠a
de
conmuta-


ci√≥n
de
paquetes
y
de
las
redes
de
computadoras
,
es
preciso
comprender
la
naturaleza
e


importancia
de
estos
retardos
.


Tipos
de
retardos


Utilizaremos
la
Figura
1.16
para
explorar
estos
retardos
.
Como
parte
de
la
ruta
terminal
a


terminal
entre
el
origen
y
el
destino
,
un
paquete
se
env√≠a
desde
el
nodo
anterior
a
trav√©s
del


router
A
hasta
el
router
B.
Nuestro
objetivo
es
caracterizar
el
retardo
nodal
en
el
router
A.


Observe
que
el
router
A
dispone
de
un
enlace
de
salida
que
lleva
hasta
el
router
B.
Este


enlace
est√°
precedido
por
una
cola
(
o
buffer
)
.
Cuando
el
paquete
llega
al
router
A
procedente


del
nodo
anterior
,
el
router
A
examina
la
cabecera
del
paquete
para
determinar
cu√°l
es
el


enlace
de
salida
apropiado
para
el
paquete
y
luego
dirige
dicho
paquete
a
ese
enlace
.
En
este


ejemplo
,
el
enlace
de
salida
para
el
paquete
es
el
√∫nico
que
lleva
hasta
el
router
B.
Un


paquete
puede
transmitirse
a
trav√©s
de
un
enlace
s√≥lo
si
actualmente
no
se
est√°
transmitiendo


ning√∫n
otro
paquete
a
trav√©s
de
√©l
y
si
no
hay
otros
paquetes
que
le
precedan
en
la
cola
;
si


el
enlace
est√°
ocupado
actualmente
o
si
existen
otros
paquetes
en
la
cola
esperando
para
ese


enlace
,
entonces
el
paquete
reci√©n
llegado
tendr√°
que
ponerse
a
la
cola
.


Retardo
de
procesamiento


El
tiempo
requerido
para
examinar
la
cabecera
del
paquete
y
determinar
d√≥nde
hay
que


enviarlo
es
parte
del
retardo
de
procesamiento
.
El
retardo
de
procesamiento
tambi√©n
incluye


otros
factores
como
el
tiempo
necesario
para
comprobar
los
errores
de
nivel
de
bit
del
paquete


que
se
producen
al
transmitir
los
bits
del
paquete
desde
el
nodo
anterior
al
router
A.
Los
retar-


dos
de
procesamiento
en
los
routers
de
alta
velocidad
suelen
ser
del
orden
de
los
microse-


gundos
o
menores
.
Una
vez
efectuado
el
procesamiento
nodal
,
el
router
dirige
el
paquete
a
la


Figura
1.16
‚Ä¢
Retardo
nodal
en
el
router
A.


A


B


Procesamiento

       
nodal


En
cola


(
esperando


para
transmisi√≥n
)


Transmisi√≥n


Propagaci√≥n


1.4
‚Ä¢
RETARDOS
,
P√âRDIDAS
Y
TASA
DE
TRANSFERENCIA
35


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
35cola
que
precede
al
enlace
que
lleva
al
router
B.
(
En
el
Cap√≠tulo
4
estudiaremos
los
detalles


acerca
de
c√≥mo
funciona
un
router
.
)


Retardo
de
cola


En
la
cola
,
el
paquete
experimenta
un
retardo
de
cola
al
tener
que
esperar
para
ser
transmitido


a
trav√©s
del
enlace
.
La
duraci√≥n
del
retardo
de
cola
de
un
determinado
paquete
depender√°
del


n√∫mero
de
paquetes
que
hayan
llegado
antes
a
la
cola
y
que
est√°n
esperando
para
ser
transmi-


tidos
por
el
enlace
.
Si
la
cola
est√°
vac√≠a
y
no
se
est√°
transmitiendo
ning√∫n
paquete
actualmente
,


entonces
el
retardo
de
cola
de
nuestro
paquete
ser√°
cero
.
Por
el
contrario
,
si
hay
mucho
tr√°fico


y
muchos
paquetes
tambi√©n
est√°n
esperando
para
ser
transmitidos
,
el
retardo
de
cola
puede
ser


grande
.
Vamos
a
ver
brevemente
que
el
n√∫mero
de
paquetes
que
un
paquete
entrante
puede


esperar
encontrar
es
una
funci√≥n
de
la
intensidad
y
de
la
naturaleza
del
tr√°fico
que
llega
a
la


cola
.
En
la
pr√°ctica
,
los
retardos
de
cola
pueden
ser
del
orden
de
microsegundos
a
milisegun-


dos
.


Retardo
de
transmisi√≥n


Suponiendo
que
los
paquetes
se
transmiten
de
manera
que
el
primero
que
llega
es
el
primero


que
sale
,
lo
que
es
una
pr√°ctica
com√∫n
en
las
redes
de
conmutaci√≥n
de
paquetes
,
nuestro


paquete
s√≥lo
puede
ser
transmitido
despu√©s
de
que
todos
los
paquetes
que
hayan
llegado
antes


que
√©l
hayan
sido
transmitidos
.
Sea
la
longitud
del
paquete
igual
a
L
bits
y
la
velocidad
de


transmisi√≥n
del
enlace
del
router
A
hasta
el
router
B
igual
a
R
bits
/
segundo
.
Entonces
,
por


ejemplo
,
para
un
enlace
Ethernet
a
10
Mbps
,
la
velocidad
es
R
=
10
Mbps
;
para
un
enlace


Ethernet
a
100
Mbps
,
la
velocidad
ser√°
R
=
100
Mbps
.
El
retardo
de
transmisi√≥n
(
tambi√©n


denominado
retardo
de
almacenamiento
y
reenv√≠o
,
como
hemos
visto
en
la
Secci√≥n
1.3
)
ser√°


igual
a
 
L
/
R.
Este
es
el
tiempo
necesario
para
introducir
(
es
decir
,
transmitir
)
todos
los
bits
del


paquete
por
el
enlace
.
Normalmente
,
en
la
pr√°ctica
,
los
retardos
de
transmisi√≥n
son
del
orden


de
los
microsegundos
a
los
milisegundos
.


Retardo
de
propagaci√≥n


Una
vez
que
un
bit
ha
entrado
en
el
enlace
,
tiene
que
propagarse
hasta
el
router
B.
El
tiempo


necesario
para
propagarse
desde
el
principio
del
enlace
hasta
el
router
B
es
el
retardo
de


propagaci√≥n
.
El
bit
se
propaga
a
la
velocidad
de
propagaci√≥n
del
enlace
.
Esta
velocidad


depende
del
medio
f√≠sico
del
enlace
(
es
decir
,
que
el
medio
sea
cable
de
fibra
√≥ptica
,
cable


de
cobre
de
par
trenzado
,
etc.
)
y
est√°
comprendido
en
el
rango
entre


2
 
108
metros
/
segundo
y
3
 
108
metros
/
segundo


que
es
igual
o
menor
que
la
velocidad
de
la
luz
.
El
retardo
de
propagaci√≥n
es
igual
a
la
dis-


tancia
entre
dos
routers
dividida
entre
la
velocidad
de
propagaci√≥n
.
Es
decir
,
el
retardo
de


propagaci√≥n
es
igual
a
d
/
s
,
donde
d
es
la
distancia
entre
el
router
A
y
el
router
B
y
s
es
la


velocidad
de
propagaci√≥n
del
enlace
.
Una
vez
que
el
√∫ltimo
bit
del
paquete
se
ha
propagado


hasta
el
nodo
B
,
√©ste
y
todos
los
bits
anteriores
del
paquete
se
almacenan
en
el
router
B.
A


continuaci√≥n
,
el
router
B
lleva
a
cabo
el
reenv√≠o
.
En
las
redes
de
√°rea
extensa
,
los
retardos


de
propagaci√≥n
son
del
orden
de
los
milisegundos
.


36
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
36Comparaci√≥n
de
los
retardos
de
transmisi√≥n
y
de
propagaci√≥n


Los
reci√©n
llegados
al
campo
de
las
redes
de
computadoras
en
ocasiones
tienen
dificultades


para
comprender
la
diferencia
entre
el
retardo
de
transmisi√≥n
y
el
de
propagaci√≥n
.
Esta
dife-


rencia
es
sutil
pero
importante
.
El
retardo
de
transmisi√≥n
es
la
cantidad
de
tiempo
necesario


para
que
el
router
saque
fuera
el
paquete
;
es
una
funci√≥n
de
la
longitud
del
paquete
y
de
la


velocidad
de
transmisi√≥n
del
enlace
,
pero
no
tiene
nada
que
ver
con
la
distancia
existente


entre
los
dos
routers
.
Por
el
contrario
,
el
retardo
de
propagaci√≥n
es
el
tiempo
que
tarda
un


bit
en
propagarse
de
un
router
al
siguiente
;
es
una
funci√≥n
de
la
distancia
entre
los
dos
rou-


ters
,
pero
no
tiene
nada
que
ver
con
la
longitud
del
paquete
ni
con
la
velocidad
de
transmi-


si√≥n
del
enlace
.


Veamos
una
analog√≠a
que
nos
va
a
permitir
clarificar
los
conceptos
de
retardo
de
trans-


misi√≥n
y
de
retardo
de
propagaci√≥n
.
Imagine
una
autopista
en
la
que
hay
un
puesto
de
peaje


cada
100
kil√≥metros
,
como
se
muestra
en
la
Figura
1.17
.
Podemos
imaginar
que
los
segmen-


tos
de
autopista
entre
peajes
son
los
enlaces
y
las
casetas
de
peaje
son
los
routers
.
Suponga


que
los
autom√≥viles
viajan
(
es
decir
,
se
propagan
)
por
la
autopista
a
una
velocidad
de
100


km
/
hora
(
es
decir
,
cuando
un
coche
sale
de
un
peaje
,
instant√°neamente
acelera
hasta
adqui-


rir
la
velocidad
de
100
km
/
hora
y
la
mantiene
entre
puestos
de
peaje
)
.
Supongamos
ahora


que
hay
10
coches
que
viajan
en
caravana
unos
detr√°s
de
otros
en
un
orden
fijo
.
Podemos


pensar
que
cada
coche
es
un
bit
y
que
la
caravana
es
un
paquete
.
Supongamos
tambi√©n
que


cada
puesto
de
peaje
da
servicio
(
es
decir
,
transmite
)
a
los
coches
a
una
velocidad
de
un


coche
cada
12
segundos
y
que
es
tarde
por
la
noche
,
por
lo
que
en
la
autopista
s√≥lo
se


encuentra
nuestra
caravana
de
coches
.
Por
√∫ltimo
,
supongamos
que
cuando
el
primer
coche


de
la
caravana
llega
a
un
peaje
,
espera
en
la
entrada
hasta
que
los
otros
nueve
coches
han


llegado
y
se
han
detenido
detr√°s
de
√©l
(
as√≠
,
la
caravana
completa
tiene
que
almacenarse
en
el


peaje
antes
de
poder
ser
reenviada
)
.
El
tiempo
necesario
para
que
el
peaje
ponga
a
la
cara-


vana
completa
en
la
autopista
es
igual
a
(
10
coches)/(5
coches
/
minuto
)
=
2
minutos
.
Este


tiempo
es
an√°logo
al
retardo
de
transmisi√≥n
de
un
router
.
El
tiempo
necesario
para
que
un


coche
se
desplace
desde
la
salida
del
peaje
hasta
el
siguiente
puesto
de
peaje
es
100
km/(100


km
/
hora
)
=
1
hora
.
Este
tiempo
es
an√°logo
al
retardo
de
propagaci√≥n
.
Por
tanto
,
el
tiempo


que
transcurre
desde
que
la
caravana
queda
colocada
delante
de
un
peaje
hasta
que
vuelve
a


quedar
colocada
delante
del
siguiente
peaje
es
la
suma
del
tiempo
de
transmisi√≥n
y
el
tiempo


de
propagaci√≥n
(
en
este
caso
,
dicho
tiempo
ser√°
igual
a
62
minutos
)
.


Profundicemos
un
poco
m√°s
en
esta
analog√≠a
.
¬ø
Qu√©
ocurrir√≠a
si
el
tiempo
de
servicio


del
puesto
de
peaje
invertido
en
una
caravana
fuera
mayor
que
el
tiempo
que
tarda
un
coche


en
viajar
de
un
peaje
al
siguiente
?
Por
ejemplo
,
supongamos
que
los
coches
viajan
a
una


velocidad
de
1.000
km
/
hora
y
que
los
peajes
operan
a
una
velocidad
de
un
coche
por
minuto
.


Luego
el
retardo
de
desplazarse
entre
dos
puestos
de
peaje
ser√°
de
6
minutos
y
el
tiempo
que


tarda
el
puesto
de
peaje
en
dar
servicio
a
una
caravana
es
de
10
minutos
.
En
este
caso
,
los
 

Figura
1.17
‚Ä¢
Analog√≠a
de
la
caravana
.


Caravana
de


diez
coches


Peaje
Peaje


100
km
100
km


1.4
‚Ä¢
RETARDOS
,
P√âRDIDAS
Y
TASA
DE
TRANSFERENCIA
37


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
37primeros
coches
de
la
caravana
llegar√°n
al
segundo
puesto
de
peaje
antes
de
que
los
√∫ltimos


coches
de
la
caravana
hayan
salido
del
primer
peaje
.
Esta
situaci√≥n
tambi√©n
se
produce
en


las
redes
de
conmutaci√≥n
de
paquetes
:
los
primeros
bits
de
un
paquete
pueden
llegar
a
un


router
mientras
que
gran
parte
de
los
bits
restantes
del
paquete
todav√≠a
est√°n
esperando
a
ser


transmitidos
por
el
router
anterior
.


Si
una
imagen
vale
m√°s
que
mil
palabras
,
entonces
una
animaci√≥n
vale
m√°s
que
un


mill√≥n
de
palabras
.
En
el
sitio
web
de
este
libro
de
texto
se
proporciona
un
applet
Java
inte-


ractivo
que
ilustra
y
compara
los
retardos
de
transmisi√≥n
y
de
propagaci√≥n
.
Animamos
a
los


lectores
a
visitar
este
applet
.


Sean
dproc
,
dcola
,
dtrans
y
dprop
los
retardos
de
procesamiento
,
de
cola
,
de
transmisi√≥n
y
de


propagaci√≥n
,
respectivamente
.
Entonces
el
retardo
total
nodal
estar√°
dado
por
:


dnodal
=
dproc
+
dcola
+
dtrans
+
dprop


Las
contribuciones
de
estos
componentes
de
retardo
pueden
variar
significativamente
.
Por


ejemplo
,
dprop
puede
ser
despreciable
(
digamos
un
par
de
microsegundos
)
para
un
enlace
que


conecte
dos
routers
del
mismo
campus
universitario
;
sin
embargo
,
dprop
ser√°
igual
a
cientos


de
milisegundos
para
dos
routers
interconectados
mediante
un
enlace
v√≠a
sat√©lite
geoesta-


cionario
y
puede
ser
el
t√©rmino
dominante
en
la
expresi√≥n
que
proporciona
el
retardo
dnodal
.


Del
mismo
modo
,
dtrans
puede
ser
despreciable
o
significativo
.
Su
contribuci√≥n
normalmente


es
despreciable
para
velocidades
de
transmisi√≥n
de
10
Mbps
y
superiores
(
por
ejemplo
,
para


las
redes
LAN
)
;
sin
embargo
,
puede
ser
igual
a
cientos
de
milisegundos
para
paquetes
gran-


des
de
Internet
enviados
a
trav√©s
del
modems
de
acceso
telef√≥nico
de
baja
velocidad
.
El


retardo
de
procesamiento
,
dproc
,
suele
ser
despreciable
;
sin
embargo
,
tiene
una
gran
influen-


cia
sobre
la
tasa
de
transferencia
m√°xima
del
router
,
que
es
la
velocidad
m√°xima
a
la
que
un


router
puede
reenviar
los
paquetes
.


1.4.2
Retardo
de
cola
y
p√©rdida
de
paquetes


El
componente
m√°s
complejo
e
interesante
del
retardo
nodal
es
el
retardo
de
cola
,
dcola
.
De


hecho
,
el
retardo
de
cola
es
tan
importante
e
interesante
en
las
redes
de
computadoras
que
se


han
escrito
miles
de
art√≠culos
y
muchos
libros
sobre
√©l
[
Bertsekas
1991
;
Daigle
1991
;
Klein-


rock
1975
,
1976
;
Ross
1995
]
.
Aqu√≠
s√≥lo
vamos
a
abordarlo
de
forma
intuitiva
y
panor√°mica
;


los
lectores
m√°s
curiosos
pueden
echar
un
vistazo
a
algunos
de
los
libros
que
se
ocupan
de


este
tema
(
¬°
o
incluso
pueden
escribir
una
tesis
doctoral
sobre
el
asunto
!
)
.
A
diferencia
de
los


otros
tres
retardos
(
dproc
,
dtrans
y
dprop
)
,
el
retardo
de
cola
puede
variar
de
un
paquete
a
otro
.


Por
ejemplo
,
si
llegan
10
paquetes
a
una
cola
vac√≠a
al
mismo
tiempo
,
el
primer
paquete


transmitido
no
sufrir√°
retardo
de
cola
,
mientras
que
el
√∫ltimo
paquete
transmitido
sufrir√°
un


retardo
de
cola
relativamente
largo
(
mientras
espera
a
que
los
restantes
nueve
paquetes
sean


transmitidos
)
.
Por
tanto
,
al
caracterizar
el
retardo
de
cola
,
suelen
emplearse
medidas
esta-


d√≠sticas
,
como
el
retardo
medio
de
cola
,
la
varianza
del
retardo
de
cola
y
la
probabilidad
de


que
el
retardo
de
cola
exceda
un
cierto
valor
especificado
.


¬ø
En
qu√©
casos
el
retardo
de
cola
es
grande
y
en
qu√©
casos
es
insignificante
?
La
respuesta


a
esta
pregunta
depende
de
la
velocidad
a
la
que
llega
el
tr√°fico
a
la
cola
,
de
la
velocidad
de


transmisi√≥n
del
enlace
y
de
la
naturaleza
del
tr√°fico
entrante
,
es
decir
,
si
el
tr√°fico
llega
peri√≥-


dicamente
o
a
r√°fagas
.
Vamos
a
profundizar
en
este
punto
.
Sea
a
la
velocidad
media
a
la
que


llegan
los
paquetes
a
la
cola
(
a
se
expresa
en
paquetes
/
segundo
)
.
Recuerde
que
R
es
la
veloci-


38
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
38dad
de
transmisi√≥n
;
es
decir
,
es
la
velocidad
(
en
bits
/
segundo
)
a
la
que
los
bits
salen
de
la


cola
.
Con
el
fin
de
simplificar
,
supongamos
tambi√©n
que
todos
los
paquetes
constan
de
L
bits
.


Luego
la
velocidad
media
a
la
que
llegan
los
bits
a
la
cola
es
igual
a
La
bits
/
segundo
.
Supon-


gamos
por
√∫ltimo
que
la
cola
es
muy
grande
,
por
lo
que
podemos
decir
que
puede
almacenar


un
n√∫mero
infinito
de
bits
.
La
relaci√≥n
La
/
R
,
denominada
intensidad
de
tr√°fico
,
suele


desempe√±ar
un
papel
importante
a
la
hora
de
estimar
la
magnitud
del
retardo
de
cola
.
Si
La
/
R


>
1
,
entonces
la
velocidad
media
a
la
que
los
bits
llegan
a
la
cola
excede
la
velocidad
a
la
que


los
bits
pueden
ser
transmitidos
desde
la
cola
.
En
esta
desafortunada
situaci√≥n
,
la
cola
tender√°


a
aumentar
sin
l√≠mite
y
el
retardo
de
cola
se
aproximar√°
a
¬°
infinito
!
Por
tanto
,
una
de
las


reglas
de
oro
en
la
ingenier√≠a
de
tr√°fico
es
:
dise√±e
su
sistema
de
modo
que
la
intensidad
de


tr√°fico
no
sea
mayor
que
1
.


Veamos
ahora
el
caso
en
que
La
/
R
 
1
.
Aqu√≠
la
naturaleza
del
tr√°fico
entrante
influye


sobre
el
retardo
de
cola
.
Por
ejemplo
,
si
los
paquetes
llegan
peri√≥dicamente
,
es
decir
,
llega


un
paquete
cada
L
/
R
segundos
,
entonces
todos
los
paquetes
llegar√°n
a
una
cola
vac√≠a
y
no


habr√°
retardo
de
cola
.
Por
el
contrario
,
si
los
paquetes
llegan
a
r√°fagas
pero
de
forma
peri√≥-


dica
,
puede
aparecer
un
retardo
medio
de
cola
significativo
.
Por
ejemplo
,
supongamos
que


llegan
simult√°neamente
N
paquetes
cada
(
L
/
R)N
segundos
.
En
este
caso
,
el
primer
paquete


transmitido
no
tiene
asociado
un
retardo
de
cola
,
el
segundo
paquete
transmitido
presentar√°


un
retardo
de
cola
de
L
/
R
segundos
y
,
de
forma
m√°s
general
,
el
n-√©simo
paquete
transmitido


presentar√°
un
retardo
de
cola
de
(
n
/H110021)L
/
R
segundos
.
Dejamos
como
ejercicio
para
el
lec-


tor
el
c√°lculo
del
retardo
medio
de
cola
de
este
ejemplo
.


Los
dos
ejemplos
de
llegada
peri√≥dica
de
los
paquetes
que
acabamos
de
describir
se


corresponden
con
casos
te√≥ricos
.
Normalmente
,
el
proceso
de
llegada
a
una
cola
es


aleatorio
;
es
decir
,
las
llegadas
no
siguen
ning√∫n
patr√≥n
y
los
paquetes
quedan
separados
por


periodos
de
tiempo
aleatorios
.
En
este
caso
m√°s
realista
,
la
cantidad
La
/
R
normalmente
no
es


suficiente
para
caracterizar
completamente
las
estad√≠sticas
del
retardo
de
cola
.
Aun
as√≠
,


resulta
√∫til
tener
una
idea
intuitiva
de
la
magnitud
del
retardo
de
cola
.
En
particular
,
si
la


intensidad
de
tr√°fico
es
pr√≥xima
a
cero
,
entonces
las
llegadas
de
paquetes
ser√°n
pocas
y
esta-


r√°n
bastante
espaciadas
entre
s√≠
,
por
lo
que
ser√°
improbable
que
un
paquete
que
llegue
a
la


cola
se
encuentre
con
que
hay
otro
paquete
en
la
cola
.
Por
tanto
,
el
retardo
medio
de
cola
ser√°


pr√≥ximo
a
cero
.
Por
el
contrario
,
cuando
la
intensidad
de
tr√°fico
es
pr√≥xima
a
1
,
habr√°
inter-


valos
de
tiempo
en
los
que
la
velocidad
de
llegada
exceda
a
la
capacidad
de
transmisi√≥n
(
a


causa
de
las
variaciones
en
la
velocidad
de
llegada
de
los
paquetes
)
,
por
lo
que
se
formar√°


una
cola
durante
estos
periodos
de
tiempo
;
si
la
velocidad
de
llegada
es
menor
que
la
capaci-


dad
de
transmisi√≥n
,
la
longitud
de
la
cola
disminuir√°
.
Sin
embargo
,
cuando
la
intensidad
de


tr√°fico
se
aproxime
a
1
,
la
longitud
media
de
la
cola
ser√°
cada
vez
mayor
.
La
dependencia


cualitativa
del
retardo
medio
de
cola
con
relaci√≥n
a
la
intensidad
de
tr√°fico
se
muestra
en
la


Figura
1.18
.


Un
aspecto
importante
de
la
Figura
1.18
es
el
hecho
de
que
cuando
la
intensidad
de
tr√°-


fico
se
aproxima
a
1
,
el
retardo
medio
de
cola
aumenta
r√°pidamente
.
Un
peque√±o
porcentaje


de
aumento
en
la
intensidad
dar√°
lugar
a
un
incremento
en
porcentaje
muy
grande
del


retardo
.
Es
posible
que
haya
experimentado
este
fen√≥meno
en
una
autopista
.
Si
viaja
regu-


larmente
por
una
autopista
que
habitualmente
est√°
congestionada
,
quiere
decir
que
la
inten-


sidad
de
tr√°fico
en
esa
autopista
es
pr√≥xima
a
1
.
En
el
caso
de
que
se
produzca
un
suceso


que
d√©
lugar
a
una
cantidad
de
tr√°fico
ligeramente
mayor
que
la
usual
,
los
retardos
que
se


experimenten
pueden
llegar
a
ser
enormes
.


Con
el
fin
de
que
entienda
bien
lo
que
son
los
retardos
de
cola
animamos
de
nuevo
al


lector
a
visitar
el
sitio
web
dedicado
a
este
libro
,
donde
se
proporciona
un
applet
de
Java


1.4
‚Ä¢
RETARDOS
,
P√âRDIDAS
Y
TASA
DE
TRANSFERENCIA
39


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
39Figura
1.18
‚Ä¢
Dependencia
del
retardo
medio
de
cola
con
relaci√≥n


a
la
intensidad
de
tr√°fico
.


interactivo
para
una
cola
.
Si
establece
una
velocidad
de
llegada
de
los
paquetes
lo
suficien-


temente
alta
como
para
que
la
intensidad
de
tr√°fico
sea
mayor
que
1
,
comprobar√°
que
la
cola


aumenta
lentamente
con
el
tiempo
.


P√©rdida
de
paquetes


En
la
secci√≥n
anterior
hemos
supuesto
que
la
cola
es
capaz
de
almacenar
un
n√∫mero
infinito


de
paquetes
.
En
la
pr√°ctica
,
una
cola
para
acceder
a
un
enlace
tiene
una
capacidad
finita
,
aun-


que
la
capacidad
de
la
cola
depende
fundamentalmente
del
dise√±o
y
del
coste
del
router
.


Puesto
que
la
capacidad
de
cola
es
finita
,
los
retardos
de
los
paquetes
realmente
no
se
apro-


ximan
a
infinito
cuando
la
intensidad
de
tr√°fico
se
aproxima
a
1
.
En
su
lugar
,
un
paquete


puede
llegar
y
encontrarse
con
que
la
cola
est√°
llena
.
Si
no
hay
sitio
para
almacenar
un


paquete
,
el
router
lo
elimina
;
es
decir
,
el
paquete
se
pierde
.
Este
desbordamiento
de
una
cola


puede
verse
tambi√©n
en
el
applet
de
Java
,
cuando
la
intensidad
de
tr√°fico
es
mayor
que
1
.


Desde
el
punto
de
vista
de
un
sistema
terminal
,
un
paquete
perdido
es
un
paquete
que


ha
sido
transmitido
al
n√∫cleo
de
la
red
pero
que
nunca
sale
de
la
red
en
su
destino
.
El
n√∫mero


de
paquetes
perdidos
aumenta
cuando
la
intensidad
de
tr√°fico
aumenta
.
Por
tanto
,
el
rendi-


miento
de
un
nodo
suele
medirse
no
s√≥lo
en
funci√≥n
de
los
retardos
,
sino
tambi√©n
en
fun-


ci√≥n
de
la
probabilidad
de
p√©rdida
de
paquetes
.
Como
veremos
en
los
siguientes
cap√≠tulos
,


un
paquete
perdido
puede
retransmitirse
de
terminal
a
terminal
para
garantizar
que
todos
los


datos
sean
transferidos
desde
el
origen
hasta
su
destino
.


1.4.3
Retardo
terminal
a
terminal


Hasta
el
momento
nos
hemos
centrado
en
el
retardo
nodal
,
es
decir
,
el
retardo
en
un
√∫nico


router
.
Ahora
vamos
a
ocuparnos
del
retardo
total
entre
el
origen
y
el
destino
.
Para
entender


este
concepto
,
suponga
que
hay
N
/H110021
routers
entre
el
host
de
origen
y
el
host
de
destino
.


Suponga
tambi√©n
,
por
el
momento
,
que
la
red
no
est√°
congestionada
(
por
lo
que
los
retardos


de
cola
son
despreciables
)
,
el
retardo
de
procesamiento
en
cada
router
y
en
el
host
de
origen


es
dproc
,
la
velocidad
de
transmisi√≥n
de
salida
de
cada
router
y
del
host
de
origen
es
de


Retardo
medio
de
cola


1


40
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
40R
bits
/
segundo
y
el
retardo
de
propagaci√≥n
en
cada
enlace
es
igual
a
dprop
.
Los
retardos
noda-


les
se
suman
para
proporcionar
el
retardo
terminal
a
terminal
,
luego


dterminal-terminal
=
N
(
dproc
+
dtrans
+
dprop
)


donde
,
de
nuevo
,
dtrans
=
L
/
R
,
siendo
L
el
tama√±o
del
paquete
.
Dejamos
para
el
lector
el
ejer-


cicio
de
generalizar
esta
f√≥rmula
para
el
caso
en
que
los
retardos
en
los
nodos
sean
diferen-


tes
y
exista
un
retardo
medio
de
cola
en
cada
nodo
.


Traceroute


Para
ver
el
orden
de
magnitud
del
retardo
terminal
a
terminal
de
una
red
de
computadoras
,


podemos
utilizar
el
programa
Traceroute
.
Se
trata
de
un
programa
simple
que
se
puede
eje-


cutar
en
cualquier
host
de
Internet
.
Cuando
el
usuario
especifica
un
nombre
de
host
de
des-


tino
,
el
programa
del
host
de
origen
env√≠a
varios
paquetes
especiales
al
destino
.
A
medida


que
estos
paquetes
se
dirigen
a
su
destino
,
pasan
a
trav√©s
de
una
serie
de
routers
.
Cuando
un


router
recibe
uno
de
estos
paquetes
especiales
,
devuelve
al
origen
un
mensaje
corto
que
con-


tiene
el
nombre
y
la
direcci√≥n
del
router
.


M√°s
concretamente
,
suponga
que
hay
N
/H110021
routers
entre
el
origen
y
el
destino
.
Luego


el
origen
enviar√°
N
paquetes
especiales
a
la
red
dirigidos
al
destino
final
.
Estos
N
paquetes


especiales
se
marcan
de
1
a
N
,
quedando
el
primer
paquete
marcado
como
1
y
el
√∫ltimo


como
N.
Cuando
el
router
n-√©simo
recibe
el
paquete
n-√©simo
marcado
como
N
,
el
router
no


reenv√≠a
el
paquete
hacia
su
destino
,
sino
que
devuelve
un
mensaje
al
origen
.
Cuando
el
host


de
destino
recibe
el
paquete
n-√©simo
,
tambi√©n
devuelve
un
mensaje
al
origen
.
El
origen


registra
el
tiempo
transcurrido
entre
el
momento
en
que
envi√≥
un
paquete
y
el
momento
en


que
recibe
el
correspondiente
mensaje
de
vuelta
;
tambi√©n
registra
el
nombre
y
la
direcci√≥n


del
router
(
o
del
host
de
destino
)
que
devuelve
el
mensaje
.
De
esta
forma
,
el
origen
puede


reconstruir
la
ruta
seguida
por
los
paquetes
que
fluyen
desde
el
origen
hasta
el
destino
,
y
el


origen
puede
determinar
los
retardos
de
ida
y
vuelta
de
todos
los
routers
que
intervienen
en


el
proceso
.
Traceroute
repite
el
proceso
que
acabamos
de
describir
tres
veces
,
de
modo
que


el
origen
realmente
env√≠a
3
‚Ä¢
N
paquetes
al
destino
.
El
documento
RFC
1393
describe
en


detalle
el
programa
Traceroute
.


He
aqu√≠
un
ejemplo
de
la
salida
proporcionada
por
el
programa
Traceroute
,
en
el
que


se
ha
trazado
la
ruta
desde
el
host
de
origen
gaia.cs.umass.edu
(
en
la
Universidad
de
Mas-


sachusetts
)
al
host
cis.poly.edu
(
en
la
Universidad
Polit√©cnica
de
Brooklyn
)
.
La
salida


consta
de
seis
columnas
:
la
primera
de
ellas
contiene
el
valor
n
descrito
anteriormente
,
es


decir
,
el
n√∫mero
del
router
a
lo
largo
de
la
ruta
;
la
segunda
columna
especifica
el
nombre


del
router
;
la
tercera
indica
la
direcci√≥n
del
router
(
con
el
formato
xxx.xxx.xxx.xxx
)
;
las


tres
√∫ltimas
columnas
especifican
los
retardos
de
ida
y
vuelta
correspondientes
a
los
tres


experimentos
.
Si
el
origen
recibe
menos
de
tres
mensajes
de
cualquier
router
(
debido
a
la


p√©rdida
de
paquetes
en
la
red
)
,
Traceroute
incluye
un
asterisco
justo
despu√©s
del
n√∫mero
de


router
y
proporciona
menos
de
tres
tiempos
de
ida
y
vuelta
para
dicho
router
.


1
cs-gw
(
128.119.240.254
)
1.009
ms
0.899
ms
0.993
ms


2
128.119.3.154
(
128.119.3.154
)
0.931
ms
0.441
ms
0.651
ms


3
border4-rt-gi-1-3.gw.umass.edu
(
128.119.2.194
)
1.032
ms
0.484
ms
0.451
ms


4
acr1-ge-2-1-0.Boston.cw.net
(
208.172.51.129
)
10.006
ms
8.150
ms
8.460
ms


5
agr4-loopback.NewYork.cw.net
(
206.24.194.104
)
12.272
ms
14.344
ms
13.267
ms


1.4
‚Ä¢
RETARDOS
,
P√âRDIDAS
Y
TASA
DE
TRANSFERENCIA
41


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
416
acr2-loopback.NewYork.cw.net
(
206.24.194.62
)
13.225
ms
12.292
ms
12.148
ms


7
pos10-2.core2.NewYork1.Level3.net
(
209.244.160.133
)
12.218
ms
11.823
ms
11.793
ms


8
gige9-1-52.hsipaccess1.NewYork1.Level3.net
(
64.159.17.39
)
13.081
ms
11.556
ms
13.297
ms


9
p0-0.polyu.bbnplanet.net
(
4.25.109.122
)
12.716
ms
13.052
ms
12.786
ms


10
cis.poly.edu
(
128.238.32.126
)
14.080
ms
13.035
ms
12.802
ms


Podemos
ver
en
esta
traza
que
existen
nueve
routers
entre
el
origen
y
el
destino
.
La


mayor
parte
de
estos
routers
tiene
un
nombre
y
todos
ellos
tienen
direcciones
.
Por
ejemplo
,


el
nombre
del
router
3
es
border4-rt-gi-1-3.gw.umass.edu
y
su
direcci√≥n
es


128.119.2.194
.
Si
observamos
los
datos
proporcionados
para
este
mismo
router
,
vemos


que
en
la
primera
de
las
tres
pruebas
el
retardo
de
ida
y
vuelta
entre
el
origen
y
el
router
ha


sido
de
1,03
milisegundos
.
Los
retardos
de
ida
y
vuelta
para
las
dos
pruebas
siguientes
han


sido
0,48
y
0,45
milisegundos
,
respectivamente
.
Estos
retardos
de
ida
y
vuelta
contienen


todos
los
retardos
que
acabamos
de
estudiar
,
incluyendo
los
retardos
de
transmisi√≥n
,
de
pro-


pagaci√≥n
,
de
procesamiento
del
router
y
de
cola
.
Puesto
que
el
retardo
de
cola
var√≠a
con
el


tiempo
,
el
retardo
de
ida
y
vuelta
del
paquete
n
env√≠ado
al
router
n
puede
,
en
ocasiones
,
ser


mayor
que
el
retardo
de
ida
y
vuelta
del
paquete
n+1
enviado
al
router
n+1
.
Efectivamente
,


puede
observar
este
fen√≥meno
en
el
ejemplo
anterior
:
los
retardos
correspondientes
al
router


6
son
mayores
que
los
correspondientes
al
router
7
.


¬ø
Desea
probar
el
programa
Traceroute
?
Le
recomendamos
vivamente
que
visite
el
sitio


http://
www.traceroute.org
,
donde
se
proporciona
una
interfaz
web
a
una
extensa
lista
de


or√≠genes
para
el
trazado
de
rutas
.
Seleccione
un
origen
y
especifique
el
nombre
de
host


de
cualquier
destino
.
El
programa
Traceroute
har√°
entonces
todo
el
trabajo
.
Hay
disponibles


diversos
programas
software
gratuitos
que
proporcionan
una
interfaz
gr√°fica
para
Trace-


route
;
uno
de
nuestros
programa
favoritos
es
PingPlotter
[
PingPlotter
2009
]
.


Retardos
de
los
sistemas
terminales
,
de
las
aplicaciones
y
otros


Adem√°s
de
los
retardos
de
procesamiento
,
de
transmisi√≥n
y
de
propagaci√≥n
,
en
los
sistemas


terminales
pueden
existir
retardos
adicionales
significativos
.
Por
ejemplo
,
los
modems


de
acceso
telef√≥nico
introducen
un
retardo
de
modulaci√≥n
/
codificaci√≥n
,
que
puede
ser
del


orden
de
decenas
de
milisegundos
(
los
retardos
de
modulaci√≥n
/
codificaci√≥n
para
otras
tecno-


log√≠as
de
acceso
,
como
Ethernet
,
modems
por
cable
y
DSL
,
son
menos
significativos
y
sue-


len
ser
despreciables
)
.
Un
sistema
terminal
que
desea
transmitir
un
paquete
a
trav√©s
de
un


medio
compartido
(
por
ejemplo
,
en
un
escenario
WiFi
o
Ethernet
)
puede
retardar
su
transmi-


si√≥n
a
prop√≥sito
como
parte
de
su
protocolo
,
para
compartir
el
medio
con
otros
sistemas
ter-


minales
.
Veremos
estos
protocolos
en
detalle
en
el
Cap√≠tulo
5
.
Otro
retardo
importante
es
el


retardo
de
empaquetamiento
del
medio
,
que
aparece
en
las
aplicaciones
de
V
oz
sobre
IP


(
V
oIP
,
Voice-over-IP
)
.
En
V
oIP
,
el
lado
emisor
debe
,
en
primer
lugar
,
rellenar
un
paquete
con


voz
digitalizada
codificada
antes
de
pasar
el
paquete
a
Internet
.
El
tiempo
que
se
tarda
en


rellenar
un
paquete
(
lo
que
se
denomina
retardo
de
empaquetamiento
)
puede
ser
significa-


tivo
y
puede
repercutir
en
la
calidad
percibida
por
el
usuario
de
una
llamada
 
V
oIP
.
Este
pro-


blema
se
abordar√°
m√°s
detalladamente
en
uno
de
los
problemas
del
final
del
cap√≠tulo
.


1.4.4
Tasa
de
transferencia
en
las
redes
de
computadoras


Adem√°s
de
los
retardos
y
la
p√©rdida
de
paquetes
,
otra
medida
cr√≠tica
de
rendimiento
de
las


redes
de
computadoras
es
la
tasa
de
transferencia
de
terminal
a
terminal
.
Para
definir
la
tasa


42
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
42de
transferencia
,
consideremos
la
transferencia
de
un
archivo
de
gran
tama√±o
desde
el
host


A
al
host
B
a
trav√©s
de
una
red
.
Por
ejemplo
,
esta
transferencia
podr√≠a
consistir
en
transferir


un
clip
de
v√≠deo
de
gran
tama√±o
desde
un
par
(
peer
)
a
otro
en
un
sistema
de
compartici√≥n
de


archivos
P2P.
La
tasa
de
transferencia
instant√°nea
en
cualquier
instante
de
tiempo
es
la


velocidad
(
en
bits
/
segundo
)
a
la
que
el
host
B
recibe
el
archivo
.
(
Muchas
aplicaciones
,
inclu-


yendo
muchos
sistemas
de
compartici√≥n
de
archivos
P2P
,
muestran
la
tasa
de
transferencia


instant√°nea
durante
las
descargas
en
la
interfaz
del
usuario
;
¬°
es
posible
que
ya
se
haya
fijado


anteriormente
en
este
detalle
!
)
Si
el
archivo
consta
de
F
bits
y
la
transferencia
dura
T
segun-


dos
hasta
que
el
host
 
B
recibe
los
F
bits
,
entonces
la
tasa
media
de
transferencia
del


archivo
es
igual
a
F
/
T
bits
/
segundo
.
En
algunas
aplicaciones
,
tales
como
la
telefon√≠a
por


Internet
,
es
deseable
tener
un
retardo
peque√±o
y
una
tasa
de
transferencia
instant√°nea
por


encima
de
un
cierto
umbral
(
por
ejemplo
,
por
encima
de
24
kbps
para
ciertas
aplicaciones


de
telefon√≠a
por
Internet
y
por
encima
de
256
kbps
para
las
aplicaciones
de
v√≠deo
en
tiempo


real
)
.
Para
otras
aplicaciones
,
entre
las
que
se
incluyen
aqu√©llas
que
implican
la
transferen-


cia
de
archivos
,
el
retardo
no
es
cr√≠tico
,
pero
es
deseable
que
la
tasa
de
transferencia
sea
lo


m√°s
alta
posible
.


Con
el
fin
de
comprender
mejor
el
importante
concepto
de
tasa
de
transferencia
,
vamos
a


ver
algunos
ejemplos
.
La
Figura
1.19(a
)
muestra
dos
sistemas
terminales
,
un
servidor
y
un


cliente
,
conectados
mediante
dos
enlaces
de
comunicaciones
y
un
router
.
Consideremos
la


tasa
de
transferencia
para
transmitir
un
archivo
desde
el
servidor
al
cliente
.
Sea
Rs
la
veloci-


dad
del
enlace
entre
el
servidor
y
el
router
,
y
sea
Rc
la
velocidad
del
enlace
entre
el
router
y


el
cliente
.
Supongamos
que
los
√∫nicos
bits
que
est√°n
siendo
enviados
a
trav√©s
de
la
red
son


los
que
van
desde
el
servidor
al
cliente
.
En
este
escenario
ideal
,
¬ø
cu√°l
es
la
tasa
de
transferen-


cia
del
servidor
al
cliente
?
Para
responder
a
esta
pregunta
,
podemos
pensar
en
los
bits
como


en
un
fluido
y
en
los
enlaces
de
comunicaciones
como
en
las
tuber√≠as
.
Evidentemente
,
el


servidor
no
puede
bombear
los
bits
a
trav√©s
de
su
enlace
a
una
velocidad
mayor
que
Rs
bps
;


y
el
router
no
puede
reenviar
los
bits
a
una
velocidad
mayor
que
Rc
bps
.
Si
Rs
<
Rc
,
entonces


los
bits
bombeados
por
el
servidor
‚Äú
fluir√°n
‚Äù
a
trav√©s
del
router
y
llegar√°n
al
cliente
a
una


velocidad
de
Rs
bps
,
obteni√©ndose
una
tasa
de
transferencia
de
Rs
bps
.
Si
,
por
el
contrario
,


Rc
<
Rs
,
entonces
el
router
no
podr√°
reenviar
los
bits
tan
r√°pidamente
como
los
recibe
.
En


Figura
1.19
‚Ä¢
Tasa
de
transferencia
para
la
transmisi√≥n
de
un
archivo
desde
un


servidor
a
un
cliente
.


Servidor
Cliente


Servidor


a.


b.


Cliente


1.4
‚Ä¢
RETARDOS
,
P√âRDIDAS
Y
TASA
DE
TRANSFERENCIA
43


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
4344
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


este
caso
,
los
bits
abandonar√°n
el
router
a
una
velocidad
de
s√≥lo
Rc
,
dando
lugar
a
una
tasa
de


transferencia
de
terminal
a
terminal
igual
a
Rc
.
(
Observe
tambi√©n
que
si
contin√∫an
llegando


bits
al
router
a
una
velocidad
Rs
,
y
siguen
abandonando
el
router
a
una
velocidad
igual
a
Rc
,


la
cantidad
de
bits
en
el
router
que
est√°n
esperando
a
ser
transmitidos
hacia
el
cliente
aumen-


tar√°
constantemente
,
lo
que
es
una
situaci√≥n
nada
deseable
.
)
Por
tanto
,
en
esta
sencilla
red
de


dos
enlaces
,
la
tasa
de
transferencia
es
m√≠n{Rc
,
Rs
}
,
es
decir
,
la
velocidad
de
transmisi√≥n
del


enlace
cuello
de
botella
.
Una
vez
determinada
la
tasa
de
transferencia
,
podemos
aproximar


el
tiempo
que
se
tardar√°
en
transferir
un
archivo
de
gran
tama√±o
de
F
bits
desde
el
servidor
al


cliente
como
F
/
m√≠n{Rs
,
Rc
}
.
Veamos
un
ejemplo
concreto
.
Suponga
que
est√°
descargando
un


archivo
MP3
de
F
=
32
millones
de
bits
,
el
servidor
tiene
una
velocidad
de
transmisi√≥n
de


Rs
=
2
Mbps
y
la
velocidad
del
enlace
es
Rc
=
1
Mbps
.
El
tiempo
necesario
para
transferir
el


archivo
ser√°
igual
a
32
segundos
.
Por
supuesto
,
estas
expresiones
para
la
tasa
de
transferencia


y
el
tiempo
de
transferencia
son
√∫nicamente
aproximaciones
,
ya
que
no
se
han
tenido
en


cuenta
las
cuestiones
relativas
al
protocolo
y
a
nivel
de
paquete
.


La
Figura
1.19(b
)
muestra
una
red
con
N
enlaces
entre
el
servidor
y
el
cliente
,
siendo


las
velocidades
de
transmisi√≥n
de
los
N
enlaces
iguales
a
R1
,
R2
,
...
,
RN
.
Aplicando
el
mismo


an√°lisis
que
para
la
red
de
dos
enlaces
,
podemos
determinar
que
la
tasa
de
transferencia
para


transferir
un
archivo
desde
el
servidor
al
cliente
es
m√≠n
{
R1
,
R2,
...
,RN
}
,
que
es
de
nuevo
la


velocidad
de
transmisi√≥n
del
enlace
cuello
de
botella
existente
en
la
ruta
entre
el
servidor
y


el
cliente
.


Veamos
ahora
otro
ejemplo
inspirado
en
la
red
Internet
de
hoy
d√≠a
.
La
Figura
1.20(a
)


muestra
dos
sistemas
terminales
,
un
servidor
y
un
cliente
,
conectados
a
una
red
de
computa-


doras
.
Considere
la
tasa
de
transferencia
para
transmitir
un
archivo
desde
el
servidor
al


cliente
.
El
servidor
est√°
conectado
a
la
red
mediante
un
enlace
de
acceso
cuya
velocidad
es


Rs
y
el
cliente
est√°
conectado
a
la
red
mediante
un
enlace
de
acceso
de
velocidad
Rc
.
Supon-


gamos
ahora
que
todos
los
enlaces
existentes
en
el
n√∫cleo
de
la
red
de
comunicaciones
tie-


nen
velocidades
de
transmisi√≥n
muy
altas
,
muy
por
encima
de
Rs
y
Rc
.
Ciertamente
,
hoy
en


d√≠a
,
el
n√∫cleo
de
Internet
est√°
sobredimensionado
,
con
enlaces
de
alta
velocidad
que
experi-


mentan
una
congesti√≥n
muy
baja
[
Akella
2003
]
.
Supongamos
tambi√©n
que
√∫nicamente
se


est√°n
enviando
a
la
red
los
bits
que
se
transfieren
desde
el
servidor
al
cliente
.
Dado
que
el


n√∫cleo
de
la
red
es
como
una
tuber√≠a
ancha
en
este
ejemplo
,
la
velocidad
a
la
que
los
bits


pueden
fluir
desde
el
origen
hasta
el
destino
de
nuevo
es
el
m√≠nimo
de
Rs
y
Rc
,
es
decir
,
la


tasa
de
transferencia
es
igual
a
m√≠n{Rs
,
Rc
}
.
Por
tanto
,
normalmente
,
el
factor
de
restricci√≥n


de
la
tasa
de
transferencia
en
Internet
actualmente
es
la
red
de
acceso
.


Veamos
un
√∫ltimo
ejemplo
.
Vamos
a
utilizar
la
Figura
1.20(b
)
;
en
ella
vemos
que
hay


10
servidores
y
10
clientes
conectados
al
n√∫cleo
de
la
red
de
computadoras
.
En
este
ejem-


plo
,
tienen
lugar
10
descargas
simult√°neas
,
lo
que
implica
a
10
pares
cliente-servidor
.


Supongamos
que
estas
10
descargas
son
el
√∫nico
tr√°fico
existente
en
la
red
a
un
mismo


tiempo
.
Como
se
muestra
en
la
figura
,
hay
un
enlace
en
el
n√∫cleo
que
es
atravesado
por
las


10
descargas
.
Sea
R
la
velocidad
de
transmisi√≥n
de
este
enlace
R.
Supongamos
que
los
enla-


ces
de
acceso
de
todos
los
servidores
tienen
la
misma
velocidad
Rs
,
los
enlaces
de
acceso
de


todos
los
clientes
tienen
la
misma
velocidad
Rc
y
las
velocidades
de
transmisi√≥n
de
todos
los


enlaces
del
n√∫cleo
(
excepto
el
enlace
com√∫n
de
velocidad
R
)
tienen
velocidades
mucho


mayores
que
Rs
,
Rc
y
R.
Ahora
deseamos
saber
cu√°les
son
las
tasas
de
transferencia
de
las


descargas
.
Evidentemente
,
si
la
velocidad
del
enlace
com√∫n
,
R
,
es
por
ejemplo
cien
veces


mayor
que
Rs
y
Rc
,
entonces
la
tasa
de
transferencia
de
cada
descarga
ser√°
de
nuevo
m√≠n{Rs
,


Rc
}
.
Pero
,
¬ø
qu√©
ocurre
si
la
velocidad
del
enlace
com√∫n
es
del
mismo
orden
que
Rs


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
44Figura
1.20
‚Ä¢
Tasa
de
transferencia
terminal
a
terminal
:
(
a
)
un
cliente
descarga


un
archivo
de
un
servidor
;
(
b
)
10
clientes
descargando
con
10


servidores
.


y
Rc
?
¬ø
Cu√°l
ser√°
la
tasa
de
transferencia
en
este
caso
?
Veamos
un
ejemplo
concreto
.
Supon-


gamos
que
Rs
=
2
Mbps
,
Rc
=
1
Mbps
,
R
=
5
Mbps
y
que
el
enlace
com√∫n
divide
su
veloci-


dad
de
transmisi√≥n
en
partes
iguales
entre
las
10
descargas
.
Luego
,
ahora
,
el
cuello
de


botella
para
cada
descarga
ya
no
se
encuentra
en
la
red
de
acceso
,
sino
en
el
enlace
compar-


tido
del
n√∫cleo
que
s√≥lo
proporciona
una
tasa
de
transferencia
de
500
kbps
a
cada
descarga
.


Luego
la
tasa
de
transferencia
terminal
a
terminal
para
cada
descarga
ahora
se
ha
reducido
a


500
kbps
.


Los
ejemplos
de
las
Figuras
1.19
y
1.20(a
)
demuestran
que
la
tasa
de
transferencia


depende
de
las
velocidades
de
transmisi√≥n
de
los
enlaces
a
trav√©s
de
los
que
fluyen
los
datos
.


Hemos
visto
que
cuando
no
existe
ning√∫n
otro
tr√°fico
,
la
tasa
de
transferencia
puede
simple-


mente
aproximarse
a
la
velocidad
m√≠nima
de
transmisi√≥n
a
lo
largo
de
la
ruta
entre
el
origen


y
el
destino
.
El
ejemplo
de
la
Figura
1.20(b
)
muestra
que
,
generalmente
,
la
tasa
de
transfe-


rencia
depende
no
s√≥lo
de
las
velocidades
de
transmisi√≥n
de
los
enlaces
a
lo
largo
de
la
ruta
,


sino
tambi√©n
del
tr√°fico
existente
.
En
particular
,
un
enlace
con
una
velocidad
de
transmisi√≥n


alta
puede
ser
el
enlace
cuello
de
botella
para
la
transferencia
de
un
archivo
si
hay
muchos


otros
flujos
de
datos
atravesando
tambi√©n
ese
enlace
.
Examinaremos
m√°s
detalladamente
la


tasa
de
transferencia
en
las
redes
de
computadoras
en
los
problemas
que
el
lector
realizar√°


en
su
casa
y
en
los
cap√≠tulos
siguientes
.


Servidor


a.
b.


Cliente
10
clientes


10
servidores


1.4
‚Ä¢
RETARDOS
,
P√âRDIDAS
Y
TASA
DE
TRANSFERENCIA
45


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
451.5
Capas
de
protocolos
y
sus
modelos
de
servicio


Despu√©s
de
lo
que
hemos
visto
hasta
aqu√≠
,
parece
que
Internet
es
un
sistema
extremadamente


complicado
.
Hemos
visto
que
son
muchas
las
piezas
que
conforman
Internet
:
numerosas


aplicaciones
y
protocolos
,
distintos
tipos
de
sistemas
terminales
,
dispositivos
de
conmuta-


ci√≥n
de
paquetes
y
diversos
tipos
de
medios
para
los
enlaces
.
Dada
esta
enorme
compleji-


dad
,
¬ø
tenemos
alguna
esperanza
de
poder
organizar
una
arquitectura
de
red
o
al
menos


nuestra
exposici√≥n
sobre
la
misma
?
Afortunadamente
,
la
respuesta
a
ambas
preguntas
es
s√≠
.


1.5.1
Arquitectura
en
capas


Antes
de
intentar
organizar
nuestras
ideas
sobre
la
arquitectura
de
Internet
,
vamos
a
ver
una


analog√≠a
humana
.
Realmente
,
de
forma
continua
estamos
tratando
con
sistemas
complejos


en
nuestra
vida
cotidiana
.
Imagine
que
alguien
le
pide
que
describa
,
por
ejemplo
,
c√≥mo
fun-


ciona
el
sistema
de
l√≠neas
a√©reas
.
¬ø
Qu√©
estructura
utilizar√≠a
para
describir
este
complejo
sis-


tema
que
emplea
agencias
de
viajes
para
la
venta
de
billetes
,
personal
para
el
control
de


equipajes
,
puertas
de
embarque
,
pilotos
,
aviones
,
control
de
tr√°fico
a√©reo
y
un
sistema
de


√°mbito
mundial
para
dirigir
los
aviones
?
Una
forma
de
describir
este
sistema
podr√≠a
consis-


tir
en
describir
la
serie
de
acciones
que
usted
realiza
(
o
que
otros
realizan
para
usted
)
cuando


se
vuela
en
un
avi√≥n
.
En
primer
lugar
,
usted
compra
un
billete
,
luego
factura
el
equipaje
,
se


dirige
a
la
puerta
de
embarque
y
por
√∫ltimo
sube
al
avi√≥n
.
El
avi√≥n
despega
y
se
dirige
a
su


destino
.
Una
vez
que
el
avi√≥n
ha
tomado
tierra
,
usted
desembarca
y
recoge
su
equipaje
.
Si
el


viaje
ha
sido
malo
,
se
quejar√°
de
ello
a
la
agencia
de
viajes
(
lo
que
,
por
supuesto
,
no
le
ser-


vir√°
de
nada
)
.
Este
escenario
se
muestra
en
la
Figura
1.21
.


Podemos
ver
algunas
analog√≠as
con
las
redes
de
computadoras
:
la
compa√±√≠a
√°rea
le
tras-


lada
desde
un
origen
hasta
un
destino
,
al
igual
que
Internet
trasporta
un
paquete
desde
un


origen
hasta
un
destino
.
Pero
√©sta
no
es
la
analog√≠a
que
est√°bamos
buscando
.
Lo
que
quere-


mos
es
encontrar
una
cierta
estructura
en
la
Figura
1.21
.
Si
nos
fijamos
en
esta
figura
,
obser-


varemos
que
hay
una
funci√≥n
Billete
en
cada
extremo
;
tambi√©n
existe
una
funci√≥n
Equipaje


Figura
1.21
‚Ä¢
Acciones
para
realizar
un
viaje
en
avi√≥n
.


Billete
(
compra
)


Equipaje
(
facturaci√≥n
)


Embarque
(
carga
)


Despegue


Control
de
vuelo


Billete
(
reclamaci√≥n
)


Equipaje
(
recogida
)


Desembarque
(
descarga
)


Aterrizaje


Control
de
vuelo


Control
de
vuelo


46
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
46Figura
1.22
‚Ä¢
Disposici√≥n
de
capas
en
horizontal
de
las
funcionalidades
de
una


compa√±√≠a
√°rea
.


para
los
pasajeros
que
tienen
un
billete
y
una
funci√≥n
Embarque
para
los
pasajeros
que
tie-


nen
billete
y
han
facturado
su
equipaje
.
Para
los
pasajeros
que
han
embarcado
(
es
decir
,
que


han
adquirido
un
billete
,
han
facturado
las
maletas
y
han
embarcado
)
,
existe
una
funci√≥n
de


despegue
y
aterrizaje
y
durante
el
vuelo
,
hay
una
funci√≥n
de
control
del
avi√≥n
.
Esto
sugiere


que
podemos
fijarnos
en
las
funcionalidades
se√±aladas
en
la
Figura
1.21
de
forma
horizon-


tal
,
como
se
muestra
en
la
Figura
1.22
.


En
la
Figura
1.22
se
han
separado
las
distintas
funciones
de
la
compa√±√≠a
a√©rea
en
capas
,


proporcionando
un
marco
de
trabajo
en
el
que
podemos
explicar
c√≥mo
se
realiza
un
viaje
en


avi√≥n
.
Observe
que
cada
capa
,
combinada
con
las
capas
que
tiene
por
debajo
,
implementa


una
cierta
funcionalidad
,
un
cierto
servicio
.
En
las
capas
Billete
e
inferiores
se
lleva
a
cabo


la
transferencia
de
una
persona
de
un
mostrador
de
l√≠nea
a√©rea
a
otro
.
En
las
capas
Equipaje


e
inferiores
se
realiza
la
transferencia
de
una
persona
y
su
equipaje
dese
el
punto
de
factura-


ci√≥n
hasta
la
recogida
de
equipaje
.
Observe
que
la
capa
Equipaje
s√≥lo
proporciona
este
ser-


vicio
a
las
personas
que
ya
han
adquirido
un
billete
.
En
la
capa
Embarque
,
se
realiza
la


transferencia
embarque
/
desembarque
de
una
persona
y
su
equipaje
.
En
la
capa
Despegue/


Aterrizaje
,
se
realiza
la
transferencia
pista
a
pista
de
personas
y
equipajes
.
Cada
capa
pro-


porciona
su
servicio
(
1
)
llevando
a
cabo
determinadas
acciones
dentro
de
dicha
capa
(
por


ejemplo
,
en
la
capa
Embarque
,
se
hace
subir
y
bajar
al
pasaje
del
avi√≥n
)
y
(
2
)
utilizando
los


servicios
de
la
capa
que
tiene
directamente
debajo
de
ella
(
por
ejemplo
,
en
la
capa
Embar-


que
,
utilizando
el
servicio
de
transferencia
de
pasajeros
pista
a
pista
de
la
capa
Despegue/


Aterrizaje
)
.


Una
arquitectura
de
capas
nos
permite
estudiar
una
parte
espec√≠fica
y
bien
definida
de


un
sistema
m√°s
grande
y
complejo
.
Esta
simplificaci√≥n
por
s√≠
misma
tiene
un
valor
conside-


rable
al
proporcionar
modularidad
,
haciendo
mucho
m√°s
f√°cil
modificar
la
implementaci√≥n


del
servicio
suministrado
por
la
capa
.
Dado
que
la
capa
proporciona
el
mismo
servicio
a
la


capa
que
tiene
por
encima
de
ella
y
emplea
los
mismos
servicios
de
la
capa
que
tiene
por


debajo
,
el
resto
del
sistema
permanece
invariable
cuando
se
modifica
la
implementaci√≥n
de


una
capa
.
(
Tenga
en
cuenta
que
cambiar
la
implementaci√≥n
de
un
servicio
es
muy
diferente


a
cambiar
el
propio
servicio
.
)
Por
ejemplo
,
si
se
modificara
la
funci√≥n
Embarque
para
que


las
personas
embarcaran
y
desembarcaran
por
alturas
,
el
resto
del
sistema
de
la
compa√±√≠a


a√©rea
no
se
ver√≠a
afectado
,
ya
que
la
capa
Embarque
continuar√≠a
llevando
a
cabo
la
misma


funci√≥n
(
cargar
y
descargar
personas
)
;
simplemente
implementa
dicha
funci√≥n
de
una
forma


1.5
‚Ä¢
CAPAS
DE
PROTOCOLOS
Y
SUS
MODELOS
DE
SERVICIO
47


Billete
(
compra
)


Equipaje
(
facturaci√≥n
)


Embarque
(
carga
)


Despegue


Control
de
vuelo
Control
de
vuelo
Control
de
vuelo


Billete
(
reclamaci√≥n
)


Equipaje
(
recogida
)


Embarque
(
descarga
)


Aterrrizaje


Control
de
vuelo


Billete


Equipaje


Embarque


Despegar
/
Aterrizar


Aeropuerto


de
salida


Centros
intermedios
de


control
del
tr√°fico
a√©reo


Aeropuerto


de
llegada


Control
de
vuelo


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
4748
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


diferente
despu√©s
de
realizar
el
cambio
.
En
sistemas
complejos
de
gran
tama√±o
que
se
actua-


lizan
constantemente
,
la
capacidad
de
modificar
la
implementaci√≥n
de
un
servicio
sin
afec-


tar
al
resto
de
los
componentes
del
sistema
es
otra
importante
ventaja
de
la
disposici√≥n
en


capas
.


Capas
de
protocolos


Pero
ya
hemos
hablado
suficiente
de
compa√±√≠as
a√©reas
.
Dirijamos
ahora
nuestra
atenci√≥n
a


los
protocolos
de
red
.
Para
proporcionar
una
estructura
al
dise√±o
de
protocolos
de
red
,
los


dise√±adores
de
redes
organizan
los
protocolos
(
y
el
hardware
y
el
software
de
red
que
imple-


mentan
los
protocolos
)
en
capas
.
Cada
protocolo
pertenece
a
una
de
las
capas
,
del
mismo


modo
que
cada
funci√≥n
en
la
arquitectura
de
la
compa√±√≠a
a√©rea
de
la
Figura
1.22
pertene-


c√≠a
a
una
capa
.
De
nuevo
,
estamos
interesados
en
los
servicios
que
ofrece
una
capa
a
la


capa
que
tiene
por
encima
,
lo
que
se
denomina
modelo
de
servicio
de
capa
.
Como
en
el


caso
del
ejemplo
de
la
compa√±√≠a
a√©rea
,
cada
capa
proporciona
su
servicio
(
1
)
llevando
a


cabo
ciertas
acciones
en
dicha
capa
y
(
2
)
utilizando
los
servicios
de
la
capa
que
tiene


directamente
debajo
de
ella
.
Por
ejemplo
,
los
servicios
proporcionados
por
la
capa
n
pue-


den
incluir
la
entrega
fiable
de
mensajes
de
un
extremo
de
la
red
al
otro
.
Esto
podr√≠a


implementarse
mediante
un
servicio
no
fiable
de
entrega
de
mensajes
terminal
a
terminal


de
la
capa
n
/H110021
,
y
a√±adiendo
la
funcionalidad
de
la
capa
n
para
detectar
y
retransmitir
los


mensajes
perdidos
.


Una
capa
de
protocolo
puede
implementarse
por
software
,
por
hardware
o
mediante
una


combinaci√≥n
de
ambos
.
Los
protocolos
de
la
capa
de
aplicaci√≥n
,
como
HTTP
y
SMTP
,
casi


siempre
se
implementan
por
software
en
los
sistemas
terminales
,
al
igual
que
los
protocolos


de
la
capa
de
transporte
.
Puesto
que
la
capa
f√≠sica
y
las
capas
de
enlace
de
datos
son
respon-


sables
de
manejar
la
comunicaci√≥n
a
trav√©s
de
un
enlace
espec√≠fico
,
normalmente
se
imple-


mentan
en
las
tarjetas
de
interfaz
de
red
(
por
ejemplo
,
tarjetas
Ethernet
o
WiFi
)
asociadas


con
un
determinado
enlace
.
La
capa
de
red
a
menudo
es
una
implementaci√≥n
mixta
de
 
hard-


ware
y
software
.
Observe
tambi√©n
que
al
igual
que
las
funciones
de
la
arquitectura
de
la


compa√±√≠a
a√©rea
estaban
distribuidas
entre
los
distintos
aeropuertos
y
el
centro
de
control
de


vuelo
que
formaban
el
sistema
,
tambi√©n
un
protocolo
de
capa
n
est√°
distribuido
entre
los
sis-


temas
terminales
,
los
dispositivos
de
conmutaci√≥n
de
paquetes
y
los
restantes
componentes


que
conforman
la
red
.
Es
decir
,
suele
haber
una
parte
del
protocolo
de
capa
n
en
cada
uno
de


estos
componentes
de
red
.


Las
capas
de
protocolos
presentan
ventajas
conceptuales
y
estructurales
.
Como
hemos


visto
,
las
capas
proporcionan
una
forma
estructurada
de
estudiar
los
componentes
del
sis-


tema
.
Adem√°s
,
la
modularidad
facilita
la
actualizaci√≥n
de
los
componentes
del
sistema
.
Sin


embargo
,
tenemos
que
comentar
que
algunos
investigadores
e
ingenieros
de
redes
se
opo-


nen
vehemente
a
la
estructura
de
capas
[
Wakeman
1992
]
.
Un
potencial
inconveniente
de
la


estructura
de
capas
es
que
una
capa
puede
duplicar
la
funcionalidad
de
la
capa
inferior
.
Por


ejemplo
,
muchas
pilas
de
protocolos
proporcionan
una
funci√≥n
de
recuperaci√≥n
de
errores


tanto
por
enlace
como
extremo
a
extremo
.
Un
segundo
potencial
inconveniente
es
que
la


funcionalidad
de
una
capa
puede
precisar
informaci√≥n
(
por
ejemplo
,
un
valor
de
una
marca


temporal
)
que
s√≥lo
existe
en
otra
capa
,
y
esto
viola
el
objetivo
de
la
separaci√≥n
en
capas
.


Cuando
los
protocolos
de
las
distintas
capas
se
toman
en
conjunto
se
habla
de
pila
de


protocolos
.
La
pila
de
protocolos
de
Internet
consta
de
cinco
capas
:
capa
f√≠sica
,
capa
de


enlace
,
capa
de
red
,
capa
de
transporte
y
capa
de
aplicaci√≥n
,
como
se
muestra
en
la
 

M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
48Figura
1.23
‚Ä¢
Pila
de
protocolos
de
Internet
(
a
)
y
modelo
de
referencia
OSI
(
b
)
.


Figura1.23(a
)
.
Si
examina
el
Contenido
,
comprobar√°
que
hemos
organizado
el
libro
utili-


zando
las
capas
de
la
pila
de
protocolos
de
Internet
.
Vamos
a
aplicar
el
enfoque
descen-


dente
,
abordando
en
primer
lugar
la
capa
de
aplicaci√≥n
y
continuando
hacia
abajo
por
la


pila
.


Capa
de
aplicaci√≥n


La
capa
de
aplicaci√≥n
es
donde
residen
las
aplicaciones
de
red
y
sus
protocolos
.
La
capa
de


aplicaci√≥n
de
Internet
incluye
muchos
protocolos
,
tales
como
el
protocolo
HTTP
(
que
per-


mite
la
solicitud
y
transferencia
de
documentos
web
)
,
SMTP
(
que
permite
la
transferencia


de
mensajes
de
correo
electr√≥nico
)
y
FTP
(
que
permite
la
transferencia
de
archivos
entre
dos


sistemas
terminales
)
.
Veremos
que
determinadas
funciones
de
red
,
como
la
traducci√≥n
de


los
nombres
legibles
que
utilizamos
las
personas
para
los
sistemas
terminales
de
Internet


(
por
ejemplo
,
www.ietf.org
)
en
direcciones
de
red
de
32
bits
se
realiza
tambi√©n
con
la
ayuda


de
un
protocolo
espec√≠fico
de
la
capa
de
aplicaci√≥n
,
en
concreto
,
el
Sistema
de
nombres
de


dominio
(
DNS
,
Domain
Name
System
)
.
En
el
Cap√≠tulo
2
veremos
que
es
muy
f√°cil
crear
e


implantar
nuestros
propios
protocolos
de
la
capa
de
aplicaci√≥n
.


Un
protocolo
de
la
capa
de
aplicaci√≥n
est√°
distribuido
a
lo
largo
de
varios
sistemas
ter-


minales
,
estando
la
aplicaci√≥n
en
un
sistema
terminal
que
utiliza
el
protocolo
para
intercam-


biar
paquetes
de
informaci√≥n
con
la
aplicaci√≥n
de
otro
sistema
terminal
.
A
este
paquete
de


informaci√≥n
de
la
capa
de
aplicaci√≥n
lo
denominaremos
mensaje
.


Capa
de
transporte


La
capa
de
transporte
de
Internet
transporta
los
mensajes
de
la
capa
de
aplicaci√≥n
entre


los
puntos
terminales
de
la
aplicaci√≥n
.
En
Internet
,
existen
dos
protocolos
de
transporte
,


TCP
y
UDP
,
pudiendo
cada
uno
de
ellos
transportar
los
mensajes
de
la
capa
de
aplicaci√≥n
.


TCP
ofrece
a
sus
aplicaciones
un
servicio
orientado
a
la
conexi√≥n
.
Este
servicio
propor-


ciona
un
suministro
garantizado
de
los
mensajes
de
la
capa
de
aplicaci√≥n
al
destino
y
un


mecanismo
de
control
del
flujo
(
es
decir
,
adaptaci√≥n
de
las
velocidades
del
emisor
y
el


receptor
)
.
TCP
tambi√©n
divide
los
mensajes
largos
en
segmentos
m√°s
cortos
y
proporciona


un
mecanismo
de
control
de
congesti√≥n
,
de
manera
que
un
emisor
regula
su
velocidad
de


Transporte


Aplicaci√≥n


Red


Enlace


F√≠sica


a.
 
Pila
de
protocolos
de

 
I
n
t
e
r
n
e
t
 
d
e
 
c
i
n
c
o
 
c
a
p
a
s


Transporte


Sesi√≥n


Aplicaci√≥n


Presentaci√≥n


Red


Enlace


F√≠sica


b.
 
Modelo
de
referencia
OSI

    
de
ISO
de
siete
capas


1.5
‚Ä¢
CAPAS
DE
PROTOCOLOS
Y
SUS
MODELOS
DE
SERVICIO
49


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
49transmisi√≥n
cuando
la
red
est√°
congestionada
.
El
protocolo
UDP
proporciona
a
sus
aplica-


ciones
un
servicio
sin
conexi√≥n
.
Es
un
servicio
b√°sico
que
no
ofrece
ninguna
fiabilidad
,
ni


control
de
flujo
,
ni
control
de
congesti√≥n
.
En
este
libro
,
denominaremos
a
los
paquetes
de
la


capa
de
transporte
segmentos
.


Capa
de
red


La
capa
de
red
de
Internet
es
responsable
de
trasladar
los
paquetes
de
la
capa
de
red
,
conoci-


dos
como
datagramas
,
de
un
host
a
otro
.
El
protocolo
de
la
capa
de
transporte
(
TCP
o
UDP
)


de
Internet
de
un
host
de
origen
pasa
un
segmento
de
la
capa
de
transporte
y
una
direcci√≥n


de
destino
a
la
capa
de
red
,
al
igual
que
damos
al
servicio
de
correo
postal
una
carta
con
una


direcci√≥n
de
destino
.
Luego
,
la
capa
de
red
proporciona
el
servicio
de
suministrar
el
seg-


mento
a
la
capa
de
transporte
del
host
de
destino
.


La
capa
de
red
de
Internet
incluye
el
conocido
protocolo
IP
,
que
define
los
campos
del


datagrama
,
as√≠
como
la
forma
en
que
act√∫an
los
sistemas
terminales
y
los
routers
sobre
estos


campos
.
Existe
un
√∫nico
protocolo
IP
y
todos
los
componentes
de
Internet
que
tienen
una


capa
de
red
deben
ejecutar
el
protocolo
IP
.
La
capa
de
red
de
Internet
tambi√©n
contiene
los


protocolos
de
enrutamiento
que
determinan
las
rutas
que
los
datagramas
siguen
entre
los
or√≠-


genes
y
los
destinos
.
Internet
dispone
de
muchos
protocolos
de
enrutamiento
.
Como
hemos


visto
en
la
Secci√≥n
1.3
,
Internet
es
una
red
de
redes
y
,
dentro
de
una
red
,
el
administrador
de


la
red
puede
ejecutar
cualquier
protocolo
de
enrutamiento
que
desee
.
Aunque
la
capa
de
red


contiene
tanto
el
protocolo
IP
como
numerosos
protocolos
de
enrutamiento
,
suele
hacerse


referencia
a
ella
simplemente
como
la
capa
IP
,
lo
que
refleja
el
hecho
de
que
IP
es
el
pega-


mento
que
une
todo
Internet
.


Capa
de
enlace


La
capa
de
red
de
Internet
encamina
un
datagrama
a
trav√©s
de
una
serie
de
routers
entre
el


origen
y
el
destino
.
Para
trasladar
un
paquete
de
un
nodo
(
host
o
router
)
al
siguiente
nodo
de


la
ruta
,
la
capa
de
red
conf√≠a
en
los
servicios
de
la
capa
de
enlace
.
En
concreto
,
en
cada
nodo
,


la
capa
de
red
pasa
el
datagrama
a
la
capa
de
enlace
,
que
entrega
el
datagrama
al
siguiente


nodo
existente
a
lo
largo
de
la
ruta
.
En
el
siguiente
nodo
,
la
capa
de
enlace
pasa
el
datagrama


a
la
capa
de
red
.


Los
servicios
proporcionados
por
la
capa
de
enlace
dependen
del
protocolo
de
la
capa


de
enlace
concreto
que
se
emplee
en
el
enlace
.
Por
ejemplo
,
algunos
protocolos
de
la


capa
de
enlace
proporcionan
una
entrega
fiable
desde
el
nodo
transmisor
,
a
trav√©s
del
enlace


y
hasta
el
nodo
receptor
.
Observe
que
este
servicio
de
entrega
fiable
es
diferente
del
servicio


de
entrega
fiable
de
TCP
,
que
lleva
a
cabo
una
entrega
fiable
desde
un
sistema
terminal
a


otro
.
Entre
los
ejemplos
de
protocolos
de
la
capa
de
enlace
se
incluyen
Ethernet
,
WiFi
y
el


Protocolo
punto
a
punto
(
PPP
,
Point-to-Point
Protocol
)
.
Puesto
que
normalmente
los
data-


gramas
necesitan
atravesar
varios
enlaces
para
viajar
desde
el
origen
hasta
el
destino
,
un


datagrama
puede
ser
manipulado
por
distintos
protocolos
de
la
capa
de
enlace
en
los
distin-


tos
enlaces
disponibles
a
lo
largo
de
la
ruta
.
Por
ejemplo
,
un
datagrama
puede
ser
manipu-


lado
por
 
Ethernet
en
un
enlace
y
por
PPP
en
el
siguiente
enlace
.
La
capa
de
red
recibir√°
un


servicio
diferente
por
parte
de
cada
uno
de
los
distintos
protocolos
de
la
capa
de
enlace
.
En


este
libro
,
denominaremos
a
los
paquetes
de
la
capa
de
enlace
tramas
.


50
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
50Capa
f√≠sica


Mientras
que
el
trabajo
de
la
capa
de
enlace
es
mover
las
tramas
completas
de
un
elemento


de
la
red
hasta
el
elemento
de
red
adyacente
,
el
trabajo
de
la
capa
f√≠sica
es
el
de
mover
los


bits
individuales
dentro
de
la
trama
de
un
nodo
al
siguiente
.
Los
protocolos
de
esta
capa
son


de
nuevo
dependientes
del
enlace
y
,
por
tanto
,
dependen
del
medio
de
transmisi√≥n
del
enlace


(
por
ejemplo
,
cable
de
cobre
de
par
trenzado
o
fibra
√≥ptica
monomodo
)
.
Por
ejemplo
,
Ether-


net
dispone
de
muchos
protocolos
de
la
capa
f√≠sica
:
uno
para
cable
de
cobre
de
par
trenzado
,


otro
para
cable
coaxial
,
otro
para
fibra
,
etc.
En
cada
caso
,
los
bits
se
desplazan
a
trav√©s
del


enlace
de
forma
diferente
.


El
modelo
OSI


Una
vez
vista
en
detalle
la
pila
de
protocolos
de
Internet
,
deber√≠amos
mencionar
que
no
es


la
√∫nica
pila
de
protocolos
existente
.
En
concreto
,
a
finales
de
la
d√©cada
de
1970
,
la
Orga-


nizaci√≥n
Internacional
de
Estandarizaci√≥n
(
ISO
,
International
Organization
for
Standar-


dization
)
propuso
que
las
redes
de
computadoras
fueran
organizadas
utilizando
siete


capas
,
en
lo
que
se
vino
a
denominar
modelo
OSI
(
Open
Systems
Interconnection
,
Inter-


conexi√≥n
de
sistemas
abiertos
)
[
ISO
2009
]
.
El
modelo
OSI
tom√≥
forma
cuando
los
proto-


colos
que
se
convertir√≠an
en
los
protocolos
de
Internet
estaban
en
su
infancia
y
eran


simplemente
uno
de
los
muchos
conjuntos
de
protocolos
diferentes
que
estaban
en
desa-


rrollo
;
de
hecho
,
probablemente
los
inventores
del
modelo
OSI
original
no
estaban
pen-


sando
en
Internet
cuando
lo
crearon
.
No
obstante
,
a
partir
de
la
d√©cada
de
1970
,
muchos


cursos
universitarios
y
de
formaci√≥n
,
siguiendo
las
recomendaciones
de
ISO
,
organizaron


cursos
sobre
el
modelo
de
siete
capas
.
A
causa
de
su
temprano
impacto
sobre
la
formaci√≥n


en
redes
,
el
modelo
de
siete
capas
todav√≠a
perdura
en
algunos
libros
de
texto
y
cursos
de


formaci√≥n
sobre
redes
.


Las
siete
capas
del
modelo
de
referencia
OSI
,
mostrado
en
la
Figura
1.23(b
)
,
son
:


capa
de
aplicaci√≥n
,
capa
de
presentaci√≥n
,
capa
de
sesi√≥n
,
capa
de
transporte
,
capa
de
red
,


capa
de
enlace
de
datos
y
capa
f√≠sica
.
La
funcionalidad
de
cinco
de
estas
capas
es
b√°sica-


mente
la
misma
que
sus
contrapartidas
del
mismo
nombre
de
Internet
.
Por
tanto
,
vamos
a


centrarnos
en
las
dos
capas
adicionales
del
modelo
de
referencia
OSI
:
la
capa
de
presenta-


ci√≥n
y
la
capa
de
sesi√≥n
.
La
funci√≥n
de
la
capa
de
presentaci√≥n
es
la
de
proporcionar
ser-


vicios
que
permitan
a
las
aplicaciones
que
se
comunican
interpretar
el
significado
de
los


datos
intercambiados
.
Estos
servicios
incluyen
la
compresi√≥n
y
el
cifrado
de
los
datos


(
funciones
cuyos
nombres
son
autoexplicativos
)
,
as√≠
como
la
descripci√≥n
de
los
datos
(
lo


que
,
como
veremos
en
el
Cap√≠tulo
9
,
libera
a
la
aplicaci√≥n
de
tener
que
preocuparse
por
el


formato
interno
en
el
que
los
datos
se
representan
y
almacenan
,
formatos
que
pueden
dife-


rir
de
una
computadora
a
otra
)
.
La
capa
de
sesi√≥n
permite
delimitar
y
sincronizar
el
inter-


cambio
de
datos
,
incluyendo
los
medios
para
crear
un
punto
de
restauraci√≥n
y
un
esquema


de
recuperaci√≥n
.


El
hecho
de
que
en
Internet
falten
dos
de
las
capas
existentes
en
el
modelo
de
referencia


OSI
plantea
un
par
de
cuestiones
interesantes
:
¬ø
acaso
los
servicios
proporcionados
por
estas


dos
capas
no
son
importantes
?
¬ø
Qu√©
ocurre
si
una
aplicaci√≥n
necesita
uno
de
estos
servi-


cios
?
La
respuesta
de
Internet
a
ambas
preguntas
es
la
misma
:
es
problema
del
desarrollador


de
la
aplicaci√≥n
.
El
desarrollador
de
la
aplicaci√≥n
tiene
que
decidir
si
un
servicio
es
impor-


tante
y
si
lo
es
,
ser√°
su
problema
el
incorporar
dicha
funcionalidad
a
la
aplicaci√≥n
.


1.5
‚Ä¢
CAPAS
DE
PROTOCOLOS
Y
SUS
MODELOS
DE
SERVICIO
51


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
511.5.2
Mensajes
,
segmentos
,
datagramas
y
tramas


La
Figura
1.24
muestra
la
ruta
f√≠sica
que
siguen
los
datos
al
descender
por
la
pila
de
proto-


colos
de
un
sistema
terminal
emisor
,
al
ascender
y
descender
por
las
pilas
de
protocolos
de


un
switch
de
la
capa
de
enlace
y
de
un
router
,
para
finalmente
ascender
por
la
pila
de
proto-


colos
del
sistema
terminal
receptor
.
Como
veremos
m√°s
adelante
en
el
libro
,
los
routers
y
los


switches
de
la
capa
de
enlace
operan
como
dispositivos
de
conmutaci√≥n
de
paquetes
.
De


forma
similar
a
los
sistemas
terminales
,
los
routers
y
los
switches
de
la
capa
de
enlace
orga-


nizan
su
hardware
y
software
de
red
en
capas
.
Pero
estos
dispositivos
no
implementan
todas


las
capas
de
la
pila
de
protocolos
;
habitualmente
s√≥lo
implementan
las
capas
inferiores
.


Como
se
muestra
en
la
Figura
1.24
,
los
switches
de
la
capa
de
enlace
implementan
las
capas


1
y
2
;
y
los
routers
implementan
las
capas
1
a
3
.
Esto
significa
,
por
ejemplo
,
que
los
routers


de
Internet
son
capaces
de
implementar
el
protocolo
IP
(
un
protocolo
de
la
capa
3
)
y
los


switches
de
la
capa
de
enlace
no
.
Veremos
m√°s
adelante
que
aunque
los
switches
de
la
capa


de
enlace
no
reconocen
las
direcciones
IP
,
pueden
reconocer
las
direcciones
de
la
capa
2
,


como
por
ejemplo
las
direcciones
Ethernet
.
Observe
que
los
hosts
implementan
las
cinco


capas
,
lo
que
es
coherente
con
la
idea
de
que
la
arquitectura
de
Internet
es
mucho
m√°s
com-


pleja
en
las
fronteras
de
la
red
.


La
Figura
1.24
tambi√©n
ilustra
el
importante
concepto
de
encapsulaci√≥n
.
En
el
host
emi-


sor
,
un
mensaje
de
la
capa
de
aplicaci√≥n
(
M
en
la
Figura
1.24
)
se
pasa
a
la
capa
de
trans-


porte
.
En
el
caso
m√°s
simple
,
la
capa
de
transporte
recibe
el
mensaje
y
a√±ade
informaci√≥n


52
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M


M


M


M


Ht


Ht


Ht


Hn


HnHl


HtHnHl


Switch
de
la
capa
de
enlace


Router


Aplicaci√≥n


Transporte


Red


Enlace


F√≠sica


Mensaje


Segmento


Datagrama


Trama


M


M


M


M


Ht


Ht


Ht


Hn


HnHl


Enlace


F√≠sica


Origen


Red


Enlace


F√≠sica


Destino


Aplicaci√≥n


Transporte


Red


Enlace


F√≠sica


MH
tHnHl
M


HtHn
MH
tHn
M


HtHnHl
MH
tHnHl
M


Figura
1.24
‚Ä¢
Hosts
,
routers
y
switches
de
la
capa
de
enlace
.
Cada
uno
de
ellos


contiene
un
conjunto
distinto
de
capas
,
lo
que
refleja
sus
distintas


funcionalidades
.


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
52adicional
(
denominada
informaci√≥n
de
cabecera
de
la
capa
de
transporte
,
H
t
en
la
Figura


1.24
)
que
ser√°
utilizada
por
la
capa
de
transporte
del
lado
receptor
.
El
mensaje
de
la
capa
de


aplicaci√≥n
y
la
informaci√≥n
de
cabecera
de
la
capa
de
transporte
constituyen
el
segmento
de


la
capa
de
transporte
.
El
segmento
de
la
capa
de
transporte
encapsula
el
mensaje
de
la
capa


de
aplicaci√≥n
.
La
informaci√≥n
a√±adida
debe
incluir
informaci√≥n
que
permita
a
la
capa
de


transporte
del
lado
receptor
entregar
el
mensaje
a
la
aplicaci√≥n
apropiada
y
los
bits
de
detec-


ci√≥n
de
errores
que
permitan
al
receptor
determinar
si
los
bits
del
mensaje
han
cambiado
a
lo


largo
de
la
ruta
.
A
continuaci√≥n
,
la
capa
de
transporte
pasa
el
segmento
a
la
capa
de
red
,
que


a√±ade
informaci√≥n
de
cabecera
de
la
capa
de
red
(
H
n
en
la
Figura
1.24
)
como
son
las
direc-


ciones
de
los
sistemas
terminales
de
origen
y
de
destino
,
creando
un
datagrama
de
la
capa


de
red
.
Este
datagrama
se
pasa
entonces
a
la
capa
de
enlace
,
que
(
¬°
por
supuesto
!
)
a√±adir√°
su


propia
informaci√≥n
de
cabecera
dando
lugar
a
una
trama
de
la
capa
de
enlace
.
As√≠
,
vemos


que
en
cada
capa
,
un
paquete
est√°
formado
por
dos
tipos
de
campos
:
los
campos
de
cabecera


y
un
campo
de
carga
√∫til
.
Normalmente
,
la
carga
√∫til
es
un
paquete
de
la
capa
superior
.


Una
buena
analog√≠a
para
ilustrar
este
tema
ser√≠a
el
env√≠o
de
un
informe
interno
de


empresa
desde
una
sucursal
a
otra
a
trav√©s
del
servicio
postal
p√∫blico
.
Supongamos
que
Ali-


cia
,
que
se
encuentra
en
una
sucursal
,
quiere
enviar
un
informe
a
Benito
,
que
se
encuentra


en
la
otra
sucursal
.
El
informe
es
an√°logo
al
mensaje
de
la
capa
de
aplicaci√≥n
.
Alicia
intro-


duce
el
informe
en
un
sobre
para
correo
interno
de
la
empresa
y
escribe
en
√©l
el
nombre
y
el


n√∫mero
de
departamento
de
Benito
.
El
sobre
para
correo
interno
es
an√°logo
a
un
segmento


de
la
capa
de
transporte
(
contiene
la
informaci√≥n
de
cabecera
,
el
nombre
y
el
departamento


de
Benito
)
y
encapsula
el
mensaje
de
la
capa
de
aplicaci√≥n
(
el
informe
)
.
Cuando
en
la
sala


de
correo
de
la
sucursal
emisora
se
recibe
este
sobre
,
lo
meten
en
otro
sobre
adecuado
para


enviar
el
informe
mediante
el
servicio
p√∫blico
de
correos
.
En
la
sala
de
correo
de
la
empresa


tambi√©n
se
escriben
en
el
segundo
sobre
las
direcciones
postales
tanto
de
la
sucursal
emi-


sora
como
de
la
sucursal
receptora
.
Aqu√≠
,
el
sobre
postal
es
an√°logo
al
datagrama
,
encap-


sula
el
segmento
de
la
capa
de
transporte
(
el
sobre
para
correo
interno
)
,
que
encapsula
el


mensaje
original
(
el
informe
)
.
El
servicio
postal
entrega
el
sobre
postal
a
la
sala
de
correos


de
la
sucursal
receptora
,
donde
comienza
el
proceso
de
desencapsulaci√≥n
.
En
esta
sala
se


extrae
el
informe
y
se
env√≠a
a
Benito
.
Por
√∫ltimo
,
Benito
abre
el
sobre
para
correo
interno
y


saca
el
informe
.


El
proceso
de
encapsulaci√≥n
puede
ser
m√°s
complejo
que
el
que
acabamos
de
describir
.


Por
ejemplo
,
un
mensaje
largo
puede
dividirse
en
varios
segmentos
de
la
capa
de
transporte


(
los
cuales
a
su
vez
pueden
dividirse
en
varios
datagramas
de
la
capa
de
red
)
.
En
el
extremo


receptor
,
cada
segmento
tiene
entonces
que
ser
reconstruido
a
partir
de
sus
datagramas
cons-


tituyentes
.


1.6
Ataques
a
las
redes


Internet
se
ha
convertido
en
una
herramienta
cr√≠tica
para
muchas
instituciones
actuales
,


incluyendo
empresas
peque√±as
y
medianas
,
universidades
y
organismos
gubernamentales
.


Muchas
personas
individuales
tambi√©n
conf√≠an
en
Internet
para
llevar
a
cabo
muchas
de
sus


actividades
profesionales
,
sociales
y
personales
.
Pero
detr√°s
de
todas
estas
utilidades
y
emo-


ciones
,
hay
un
lado
oscuro
,
un
lado
donde
los
‚Äú
chicos
malos
‚Äù
intentan
hacer
estragos
en


nuestras
vidas
diarias
da√±ando
nuestras
computadoras
conectadas
a
Internet
,
violando
nues-


1.6
‚Ä¢
ATAQUES
A
LAS
REDES
53


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
53tra
privacidad
y
volviendo
inoperables
los
servicios
de
Internet
de
los
que
dependemos


[
Skoudis
2006
]
.


El
campo
de
la
seguridad
de
red
se
ocupa
de
ver
c√≥mo
los
‚Äú
chicos
malos
‚Äù
pueden
ata-


car
a
las
redes
de
computadoras
y
de
c√≥mo
nosotros
,
que
pronto
seremos
expertos
en
redes
,


podemos
defendernos
frente
a
estos
ataques
,
o
mejor
todav√≠a
,
de
c√≥mo
dise√±ar
nuevas
arqui-


tecturas
que
sean
inmunes
a
tales
ataques
.
Dada
la
frecuencia
y
variedad
de
ataques
existen-


tes
,
as√≠
como
la
amenaza
de
nuevos
y
m√°s
destructivos
ataques
futuros
,
la
seguridad
de
red


se
ha
convertido
en
un
tema
principal
en
el
campo
de
las
redes
de
comunicaciones
en
los


√∫ltimos
a√±os
.
Una
de
las
caracter√≠sticas
de
este
libro
de
texto
es
que
lleva
las
cuestiones


sobre
la
seguridad
en
las
redes
a
primer
plano
.
En
esta
secci√≥n
comenzaremos
nuestra
incur-


si√≥n
en
el
campo
de
la
seguridad
de
red
,
describiendo
brevemente
algunos
de
los
ataques


actuales
m√°s
da√±inos
y
predominantes
en
Internet
.
A
continuaci√≥n
,
en
los
siguientes
cap√≠tu-


los
nos
ocuparemos
en
detalle
de
las
tecnolog√≠as
y
los
protocolos
de
red
y
consideraremos


los
diversos
problemas
relacionados
con
la
seguridad
,
asociados
con
dichas
tecnolog√≠as
y


protocolos
.
Por
√∫ltimo
,
en
el
Cap√≠tulo
8
,
armados
con
nuestra
experiencia
reci√©n
adquirida


en
las
redes
de
computadoras
y
los
protocolos
de
Internet
,
estudiaremos
en
profundidad


c√≥mo
las
redes
se
pueden
defender
frente
a
los
ataques
,
o
dise√±arse
y
operar
para
hacer
que


esos
ataques
sean
imposibles
en
primera
instancia
.


Puesto
que
todav√≠a
no
tenemos
experiencia
ni
en
redes
ni
en
los
protocolos
de
Internet
,


comenzaremos
haciendo
un
repaso
de
algunos
de
los
problemas
de
seguridad
que
predominan


en
la
actualidad
,
con
el
fin
de
abrir
boca
para
las
explicaciones
m√°s
sustanciosas
que
propor-


cionaremos
en
los
cap√≠tulos
siguientes
.
As√≠
que
podemos
preguntarnos
,
¬ø
qu√©
es
lo
que
no
fun-


ciona
?
¬ø
En
qu√©
sentido
son
vulnerables
las
redes
de
computadoras
?
¬ø
Cu√°les
son
los
principales


tipos
de
ataques
hoy
d√≠a
?


Los
‚Äú
malos
‚Äù
pueden
introducir
software
malicioso


en
su
host
a
trav√©s
de
 
Internet


Conectamos
nuestros
dispositivos
a
Internet
porque
deseamos
recibir
y
enviar
datos
a


Internet
,
lo
que
incluye
todo
tipo
de
cosas
,
p√°ginas
web
,
mensajes
de
correo
electr√≥nico
,


archivos
MP3
,
llamadas
telef√≥nicas
,
v√≠deos
en
directo
,
resultados
de
motores
de
b√∫squeda
,


etc.
Pero
,
lamentablemente
,
junto
con
todos
estos
elementos
beneficiosos
tambi√©n
existen


elementos
maliciosos
,
lo
que
se
conoce
de
forma
colectiva
como
software
malicioso
o


malware
,
que
puede
acceder
a
nuestros
dispositivos
e
infectarlos
.
Una
vez
que
el
malware


ha
infectado
un
dispositivo
puede
hacer
todo
tipo
de
maldades
,
como
borrar
nuestros
archi-


vos
,
instalar
software
esp√≠a
que
recopile
nuestra
informaci√≥n
personal
,
como
el
n√∫mero
de


la
seguridad
social
,
contrase√±as
y
pulsaciones
de
teclas
y
luego
enviar
estos
datos
(
a
trav√©s


de
Internet
,
por
supuesto
)
a
los
‚Äú
chicos
malos
‚Äù
,
a
los
atacantes
.
Nuestro
host
comprometido


tambi√©n
puede
pertenecer
a
una
red
de
miles
de
dispositivos
comprometidos
de
forma
simi-


lar
,
lo
que
se
conoce
de
forma
colectiva
como
botnet
(
red
robot
)
,
que
los
atacantes
contro-


lan
y
aprovechan
para
la
distribuci√≥n
de
correo
electr√≥nico
basura
(
spam
)
o
para
llevar
a


cabo
ataques
distribuidos
de
denegaci√≥n
de
servicio
(
que
pronto
explicaremos
)
contra
los


hosts
objetivo
.


Gran
parte
del
malware
que
existe
actualmente
es
auto-replicante
:
una
vez
que
infecta


un
host
,
busca
c√≥mo
acceder
desde
dicho
host
a
otros
hosts
a
trav√©s
de
Internet
,
y
de
nuevo


desde
esos
hosts
que
acaba
de
infectar
,
busca
c√≥mo
acceder
a
otros
.
De
esta
forma
,
el
mal-


ware
auto-replicante
puede
extenderse
r√°pidamente
de
forma
exponencial
.
Por
ejemplo
,
el


n√∫mero
de
dispositivos
infectados
por
el
gusano
2003
Saphire
/
Slammer
se
replicaba
cada


54
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
541.6
‚Ä¢
ATAQUES
A
LAS
REDES
55


8,5
segundos
en
los
primeros
minutos
despu√©s
del
brote
,
infectando
m√°s
del
90
por
ciento


de
los
hosts
vulnerables
en
10
minutos
[
Moore
2003
]
.
El
malware
puede
extenderse
en


forma
de
virus
,
de
un
gusano
o
de
un
caballo
de
Troya
[
Skoudis
2004
]
.
Un
virus
es
un
soft-


ware
malicioso
que
requiere
cierta
interacci√≥n
del
usuario
para
infectar
el
dispositivo
.
El


ejemplo
cl√°sico
es
un
adjunto
de
correo
electr√≥nico
que
contiene
c√≥digo
ejecutable
mali-


cioso
.
Si
un
usuario
recibe
y
abre
un
adjunto
de
este
tipo
,
el
usuario
inadvertidamente
ejecu-


tar√°
el
malware
en
el
dispositivo
.
Normalmente
,
tales
virus
enviados
en
los
mensajes
de


correo
electr√≥nico
se
replican
a
s√≠
mismos
:
una
vez
que
se
ha
ejecutado
,
el
virus
puede


enviar
un
mensaje
id√©ntico
con
el
mismo
adjunto
malicioso
a
,
por
ejemplo
,
todos
los
con-


tactos
de
su
libreta
de
direcciones
.
Un
gusano
(
como
el
gusano
Slammer
)
es
malware
que


puede
entrar
en
un
dispositivo
sin
que
el
usuario
interaccione
de
forma
expl√≠cita
.
Por
ejem-


plo
,
un
usuario
puede
estar
ejecutando
una
aplicaci√≥n
de
red
vulnerable
a
la
que
un
atacante


puede
enviar
software
malicioso
.
En
algunos
casos
,
sin
que
el
usuario
intervenga
,
la
aplica-


ci√≥n
puede
aceptar
el
malware
de
Internet
y
ejecutarlo
,
creando
un
gusano
.
El
gusano
insta-


lado
ahora
en
el
dispositivo
reci√©n
infectado
explora
entonces
Internet
,
buscando
otros
hosts


que
ejecuten
la
misma
aplicaci√≥n
de
red
vulnerable
.
Cuando
encuentra
otros
hosts
vulnera-


bles
,
env√≠a
una
copia
de
s√≠
mismo
a
esos
hosts
.
Por
√∫ltimo
,
un
caballo
de
Troya
es
un
mal-


ware
que
est√°
oculto
dentro
de
otro
software
que
es
√∫til
.
Hoy
d√≠a
,
el
malware
est√°


generalizado
y
es
dif√≠cil
defenderse
de
√©l
.
A
lo
largo
del
libro
,
le
animaremos
a
que
piense


en
la
siguiente
cuesti√≥n
:
¬ø
qu√©
pueden
hacer
los
dise√±adores
de
redes
de
computadoras
para


defender
a
los
dispositivos
conectados
a
Internet
de
los
ataques
de
malware
?


Los
‚Äú
malos
‚Äù
pueden
atacar
a
los
servidores
y
a
la
infraestructura
de
red


Muchas
de
las
amenazas
de
seguridad
pueden
clasificarse
como
ataques
de
denegaci√≥n
de


servicio
(
DoS
,
Denial-of-Service
)
.
Como
su
nombre
sugiere
,
un
ataque
DoS
vuelve
inutili-


zable
una
red
,
un
host
o
cualquier
otro
elemento
de
la
infraestructura
para
los
usuarios
leg√≠-


timos
.
Los
servidores
web
,
los
servidores
de
correo
electr√≥nico
,
los
servidores
DNS
(
que
se


estudian
en
el
Cap√≠tulo
2
)
y
las
redes
institucionales
pueden
ser
todos
ellos
objeto
de
ata-


ques
DoS.
Los
ataques
DoS
de
Internet
son
muy
comunes
,
teniendo
lugar
miles
de
ataques


de
este
tipo
cada
a√±o
[
Moore
2001
;
Mirkovic
2005
]
.
La
mayor√≠a
de
los
ataques
DoS
de


Internet
pueden
clasificarse
dentro
de
una
de
las
tres
categor√≠as
siguientes
:


‚Ä¢
Ataque
de
vulnerabilidad
.
Este
ataque
implica
el
env√≠o
de
unos
pocos
mensajes
bien


construidos
a
una
aplicaci√≥n
o
sistema
operativo
vulnerable
que
est√©
ejecut√°ndose
en
un


host
objetivo
.
Si
se
env√≠a
la
secuencia
de
paquetes
correcta
a
una
aplicaci√≥n
o
un
sistema


operativo
vulnerable
,
el
servicio
puede
detenerse
o
,
lo
que
es
peor
,
el
host
puede
sufrir


un
fallo
catastr√≥fico
.


‚Ä¢
Inundaci√≥n
del
ancho
de
banda
.
El
atacante
env√≠a
una
gran
cantidad
de
paquetes
al
host


objetivo
,
de
modo
que
comienzan
a
inundar
el
enlace
de
acceso
del
objetivo
,
impidiendo


que
los
paquetes
leg√≠timos
puedan
alcanzar
al
servidor
.


‚Ä¢
Inundaci√≥n
de
conexiones
.
El
atacante
establece
un
gran
n√∫mero
de
conexiones
TCP


completamente
abiertas
o
semi-abiertas
(
estas
conexiones
se
estudian
en
el
Cap√≠tulo
3
)


en
el
host
objetivo
.
El
host
puede
comenzar
a
atascarse
con
estas
conexiones
fraudulen-


tas
impidi√©ndose
as√≠
que
acepte
las
conexiones
leg√≠timas
.


Vamos
a
ver
a
continuaci√≥n
el
ataque
por
inundaci√≥n
del
ancho
de
banda
m√°s
detallada-


mente
.
Recuerde
el
an√°lisis
que
hemos
realizado
en
la
Secci√≥n
1.4.2
sobre
los
retardos
y
la


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
55p√©rdida
de
paquetes
;
es
evidente
que
si
el
servidor
tiene
una
velocidad
de
acceso
de
R
bps
,


entonces
el
atacante
tendr√°
que
enviar
el
tr√°fico
a
una
velocidad
de
aproximadamente
R


bps
para
causar
da√±os
.
Si
R
es
muy
grande
,
es
posible
que
un
√∫nico
origen
de
ataque
no
sea


capaz
de
generar
el
tr√°fico
suficiente
como
para
da√±ar
al
servidor
.
Adem√°s
,
si
todo
el
tr√°fico


procede
de
un
mismo
origen
,
un
router
situado
en
un
punto
anterior
de
la
ruta
puede
detectar
el


ataque
y
bloquear
todo
el
tr√°fico
procedente
de
ese
origen
antes
de
que
llegue
cerca
del
servi-


dor
.
En
un
ataque
DoS
distribuido
(
DDoS
,
Distributed
DoS
)
,
como
el
mostrado
en
la
Figura


1.25
,
el
atacante
controla
varios
or√≠genes
y
hace
que
cada
uno
de
ellos
bombardee
el
objetivo


con
tr√°fico
.
Con
este
m√©todo
,
la
tasa
acumulada
de
tr√°fico
para
 
todos
los
or√≠genes
controlados


tiene
que
ser
aproximadamente
igual
a
R
para
inutilizar
el
servicio
.
Actualmente
,
se
producen


de
forma
com√∫n
ataques
DDoS
que
utilizan
botnets
con
miles
de
hosts
comprometidos
[
Mir-


kovic
2005
]
.
Los
ataques
DDoS
son
mucho
m√°s
dif√≠ciles
de
detectar
y
es
mucho
m√°s
compli-


cado
defenderse
de
ellos
que
de
los
ataques
DoS
procedentes
de
un
√∫nico
host
.


Le
animamos
a
que
piense
en
la
siguiente
pregunta
seg√∫n
vaya
leyendo
el
libro
:
¬ø
qu√©


pueden
hacer
los
dise√±adores
de
redes
de
computadoras
para
defenderlas
de
los
ataques


DoS
?
Veremos
que
son
necesarias
diferentes
defensas
para
cada
uno
de
los
tres
tipos
de
ata-


ques
DoS.


Los
‚Äú
malos
‚Äù
pueden
examinar
y
analizar
los
paquetes


Actualmente
,
muchos
usuarios
acceden
a
Internet
a
trav√©s
de
dispositivos
inal√°mbricos
,
tales


como
computadoras
port√°tiles
con
conexi√≥n
WiFi
o
dispositivos
de
mano
con
conexiones


Internet
m√≥viles
(
lo
que
veremos
en
el
Cap√≠tulo
6
)
.
Aunque
el
omnipresente
acceso
a
Inter-


net
es
extremadamente
√∫til
y
habilita
maravillosas
aplicaciones
para
los
usuarios
m√≥viles
,


tambi√©n
crea
una
importante
vulnerabilidad
de
seguridad
,
al
colocar
un
receptor
pasivo
en


las
vecindades
del
transmisor
inal√°mbrico
,
que
puede
recibir
una
copia
de
todos
los
paque-


tes
que
se
est√°n
transmitiendo
.
Estos
paquetes
pueden
contener
todo
tipo
de
informaci√≥n


confidencial
,
incluyendo
contrase√±as
,
n√∫meros
de
la
seguridad
social
,
secretos
comerciales


Figura
1.25
‚Ä¢
Ataque
de
denegaci√≥n
de
servicio
distribuido
.


Atacante


‚Äú
inicio
del

    
ataque
‚Äù


Esclavo


Esclavo


Esclavo


V√≠ctima


Esclavo


Esclavo


56
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
56y
mensajes
personales
privados
.
Un
receptor
pasivo
que
registra
una
copia
de
todos
los


paquetes
que
pasan
por
√©l
se
conoce
como
packet
sniffer
(
husmeador
de
paquetes
)
.


Los
sniffers
tambi√©n
pueden
implantarse
en
entornos
cableados
.
En
entornos
cableados


de
multidifusi√≥n
,
como
en
muchas
redes
LAN
Ethernet
,
un
sniffer
puede
obtener
copias
de


todos
los
paquetes
enviados
a
trav√©s
de
la
LAN
.
Como
se
ha
descrito
en
la
Secci√≥n
1.2
,
las


tecnolog√≠as
de
acceso
por
cable
tambi√©n
difunden
paquetes
y
por
tanto
son
vulnerables
a
ser


monitorizados
y
analizados
.
Adem√°s
,
un
atacante
que
consigue
acceder
al
enlace
de
acceso


o
al
router
de
acceso
de
una
instituci√≥n
puede
colocar
un
sniffer
que
haga
una
copia
de
todos


los
paquetes
entrantes
y
salientes
de
la
organizaci√≥n
.
Los
paquetes
as√≠
monitorizados
pueden


ser
analizados
despu√©s
para
obtener
la
informaci√≥n
confidencial
.


El
software
sniffer
est√°
disponible
de
forma
gratuita
en
varios
sitios
web
y
como
productos


comerciales
.
Los
profesores
que
imparten
cursos
sobre
redes
suelen
realizar
pr√°cticas
de
labora-


torio
que
implican
escribir
un
programa
sniffer
y
un
programa
de
reconstrucci√≥n
de
datos
de
la


capa
de
aplicaci√≥n
.
Por
supuesto
,
las
pr√°cticas
de
laboratorio
con
Wireshark
[
Wireshark
2009
]


asociadas
con
este
texto
(
v√©ase
la
pr√°ctica
de
laboratorio
introductoria
de
Wireshark
al
final
del


cap√≠tulo
)
utilizan
exactamente
un
programa
sniffer
as√≠
para
monitorizar
y
analizar
paquetes
.


Puesto
que
los
programas
sniffer
son
pasivos
,
es
decir
,
no
inyectan
paquetes
en
el
canal
,


son
dif√≠ciles
de
detectar
.
Por
tanto
,
cuando
env√≠amos
paquetes
a
un
canal
inal√°mbrico
,
tene-


mos
que
aceptar
que
existe
la
posibilidad
de
que
alg√∫n
atacante
pueda
registrar
copias
de


nuestros
paquetes
.
Como
es
posible
que
haya
adivinado
,
una
de
las
mejores
formas
de


defenderse
frente
a
los
programas
sniffer
son
las
t√©cnicas
criptogr√°ficas
.
En
el
Cap√≠tulo
8


veremos
c√≥mo
se
aplica
la
criptograf√≠a
a
la
seguridad
de
la
red
.


Los
‚Äú
malos
‚Äù
pueden
suplantar
identidades


Es
sorprendentemente
f√°cil
(
y
el
lector
tendr√°
los
conocimientos
necesarios
para
hacerlo


muy
pronto
a
medida
que
vaya
leyendo
este
texto
)
crear
un
paquete
con
una
direcci√≥n
de


origen
,
un
contenido
de
paquete
y
una
direcci√≥n
de
destino
arbitrarios
y
luego
transmitir


dicho
paquete
a
Internet
,
que
reenviar√°
el
paquete
a
su
destino
.
Imagine
que
el
receptor
con-


fiado
(
por
ejemplo
,
un
router
de
Internet
)
que
recibe
tal
paquete
,
toma
la
direcci√≥n
de
origen


(
falsa
)
como
buena
y
luego
ejecuta
alg√∫n
comando
integrado
en
el
contenido
del
paquete


(
por
ejemplo
,
modifica
la
tabla
de
reenv√≠o
)
.
La
capacidad
para
inyectar
paquetes
en
Internet


con
una
direcci√≥n
de
origen
falsa
se
conoce
como
suplantaci√≥n
IP
y
es
una
de
las
muchas


formas
en
las
que
un
usuario
puede
hacerse
pasar
por
otro
.


Para
resolver
este
problema
,
necesitaremos
aplicar
un
medio
de
autenticaci√≥n
en
el


punto
terminal
,
es
decir
,
un
mecanismo
que
nos
permita
determinar
con
seguridad
si
un


mensaje
tiene
su
origen
donde
creemos
que
lo
tiene
.
De
nuevo
,
animamos
a
los
lectores
a


que
,
a
medida
que
avanzan
por
los
cap√≠tulos
del
libro
,
piensen
en
c√≥mo
pueden
hacer
esto


las
aplicaciones
y
protocolos
de
red
.
En
el
Cap√≠tulo
8
exploraremos
los
mecanismos
de


autenticaci√≥n
en
el
punto
terminal
.


Los
‚Äú
malos
‚Äù
pueden
modificar
o
borrar
los
mensajes


Terminamos
este
breve
repaso
sobre
los
ataques
de
red
describiendo
los
ataques
de
inter-


posici√≥n
.
En
este
tipo
de
ataques
,
los
atacantes
se
introducen
en
la
ruta
de
comunicaciones


existente
entre
dos
entidades
que
han
establecido
una
conexi√≥n
.
Sean
por
ejemplo
estas
enti-


dades
Alicia
y
Benito
,
que
pueden
ser
personas
reales
o
entidades
de
red
,
como
por
ejemplo


dos
routers
o
dos
servidores
de
correo
.
El
atacante
podr√≠a
ser
por
ejemplo
un
router
del
que


1.6
‚Ä¢
ATAQUES
A
LAS
REDES
57


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
57el
atacante
haya
tomado
el
control
en
la
ruta
de
comunicaci√≥n
,
o
un
m√≥dulo
software
resi-


dente
en
uno
de
los
hosts
terminales
en
una
capa
inferior
de
la
pila
de
protocolos
.
En
los
ata-


ques
de
interposici√≥n
,
el
atacante
no
s√≥lo
tiene
la
capacidad
de
examinar
y
analizar
los


paquetes
que
pasan
entre
Benito
y
Alicia
,
sino
que
tambi√©n
puede
inyectar
,
modificar
o


borrar
paquetes
.
En
la
jerga
utilizada
al
hablar
de
la
seguridad
de
las
redes
,
se
dice
que
un


ataque
de
interposici√≥n
puede
comprometer
la
integridad
de
los
datos
enviados
entre
Alicia


y
Benito
.
Como
veremos
en
el
Cap√≠tulo
8
,
los
mecanismos
que
proporcionan
confidenciali-


dad
(
protecci√≥n
frente
al
husmeo
de
los
paquetes
)
y
autenticaci√≥n
en
el
punto
terminal
(
lo


que
permite
al
receptor
verificar
con
certeza
al
originador
del
mensaje
)
no
necesariamente


proporcionan
integridad
de
los
datos
.
Por
tanto
,
necesitaremos
otras
t√©cnicas
para
propor-


cionar
esta
funcionalidad
.


Para
terminar
con
este
secci√≥n
,
vale
la
pena
comentar
cu√°l
es
la
raz√≥n
de
que
Internet
se


haya
convertido
en
un
lugar
inseguro
.
B√°sicamente
,
la
respuesta
es
que
Internet
fue
dise√±ada


originalmente
para
ser
insegura
,
ya
que
se
basaba
en
el
modelo
de
un
‚Äú
grupo
de
usuarios
que


confiaban
entre
s√≠
conectados
a
una
red
transparente
‚Äù
[
Blumenthal
2001
]
,
un
modelo
en
el
que


(
por
definici√≥n
)
no
hab√≠a
necesidad
de
pensar
en
la
seguridad
.
Muchos
aspectos
de
la
arquitec-


tura
de
Internet
original
reflejan
esta
idea
de
confianza
mutua
.
Por
ejemplo
,
la
posibilidad
de


que
un
usuario
env√≠e
un
paquete
a
cualquier
otro
usuario
es
la
opci√≥n
predeterminada
,
en
lugar


de
ser
una
capacidad
solicitada
/
concedida
,
al
igual
que
lo
normal
es
creer
que
la
identidad
del


usuario
es
la
que
declara
,
en
lugar
de
autenticarle
por
defecto
.


Pero
,
actualmente
Internet
no
implica
realmente
‚Äú
usuarios
de
confianza
mutua
‚Äù
.
Sin


embargo
,
los
usuarios
de
hoy
d√≠a
necesitan
comunicarse
aunque
no
necesariamente
conf√≠en


entre
s√≠
,
pueden
desear
comunicarse
de
forma
an√≥nima
,
pueden
comunicarse
indirectamente


a
trav√©s
de
terceros
(
por
ejemplo
,
cach√©s
web
,
que
estudiaremos
en
el
Cap√≠tulo
2
,
o
asisten-


tes
de
movilidad
,
que
veremos
en
el
Cap√≠tulo
6
)
,
y
deben
desconfiar
del
hardware
,
el
soft-


ware
e
incluso
del
aire
a
trav√©s
del
que
se
comunican
.
A
lo
largo
del
libro
vamos
a


encontrarnos
con
muchos
retos
relacionados
con
la
seguridad
,
buscaremos
formas
de
defen-


dernos
frente
a
los
sniffer
,
la
suplantaci√≥n
de
identidades
en
el
punto
terminal
,
los
ataques


de
interposici√≥n
,
los
ataques
DDoS
,
el
software
malicioso
,
etc.
Tenemos
que
tener
presente


que
la
comunicaci√≥n
entre
usuarios
de
mutua
confianza
es
la
excepci√≥n
m√°s
que
la
regla
.


¬°
Bienvenido
al
mundo
de
las
redes
modernas
de
comunicaciones
!


1.7
Historia
de
Internet
y
de
las
redes


de
computadoras


En
las
Secciones
1.1
a
1.6
se
ha
hecho
una
presentaci√≥n
de
las
tecnolog√≠as
utilizadas
en
las


redes
de
comunicaciones
e
Internet
.
Ahora
ya
sabe
lo
suficiente
como
para
impresionar
a
sus


familiares
y
amigos
.
Sin
embargo
,
si
realmente
desea
causar
una
gran
impresi√≥n
en
la


siguiente
fiesta
a
la
que
asista
,
deber√≠a
salpicar
su
discurso
con
algunos
detalles
interesantes


acerca
de
la
fascinante
historia
de
Internet
[
Segaller
1998
]
.


1.7.1
El
desarrollo
de
la
conmutaci√≥n
de
paquetes
:
1961-1972


Tanto
Internet
como
las
redes
de
computadoras
de
hoy
d√≠a
tienen
sus
inicios
a
principios


de
la
d√©cada
de
1960
,
cuando
la
red
telef√≥nica
era
la
red
de
comunicaciones
dominante


58
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
58en
el
mundo
.
Recordemos
de
la
Secci√≥n
1.3
que
la
red
telef√≥nica
utiliza
mecanismos
de


conmutaci√≥n
de
circuitos
para
transmitir
la
informaci√≥n
entre
un
emisor
y
un
receptor
,


una
opci√≥n
apropiada
en
la
que
la
voz
se
transmite
a
una
velocidad
constante
entre
el


emisor
y
el
receptor
.
Debido
a
la
creciente
importancia
(
y
los
enormes
costes
)
de
las


computadoras
en
los
primeros
a√±os
de
la
d√©cada
de
1960
y
a
la
aparici√≥n
de
las
computa-


doras
de
tiempo
compartido
,
quiz√°
fue
natural
(
¬°
al
menos
retrospectivamente
!
)
conside-


rar
la
cuesti√≥n
de
c√≥mo
enlazar
las
computadoras
con
el
fin
de
que
pudieran
ser


compartidas
entre
usuarios
geogr√°ficamente
distribuidos
.
El
tr√°fico
generado
por
esos


usuarios
probablemente
era
a
r√°fagas
,
compuesto
por
periodos
de
actividad
como
el


env√≠o
de
un
comando
a
una
computadora
remota
,
seguido
de
periodos
de
inactividad


mientras
se
espera
a
obtener
una
respuesta
o
mientras
se
contempla
la
respuesta
recibida
.


Tres
grupos
de
investigaci√≥n
repartidos
por
el
mundo
,
cada
uno
de
ellos
ignorante
de
la


existencia
de
los
otros
[
Leiner
1998
]
,
comenzaron
a
trabajar
en
la
conmutaci√≥n
de
paquetes


como
en
una
alternativa
eficiente
y
robusta
a
la
conmutaci√≥n
de
circuitos
.
El
primer
trabajo


publicado
sobre
las
t√©cnicas
de
conmutaci√≥n
de
paquetes
fue
el
de
Leonard
Kleinrock


[
Kleinrock
1961
;
Kleinrock
1964
]
,
un
estudiante
graduado
en
el
MIT
.
Bas√°ndose
en
la
teo-


r√≠a
de
colas
,
el
trabajo
de
Kleinrock
demostraba
de
forma
elegante
la
efectividad
de
la
t√©c-


nica
de
conmutaci√≥n
de
paquetes
para
las
fuentes
que
generaban
tr√°fico
a
r√°fagas
.
En
1964
,


Paul
Baran
[
Baran
1964
]
en
el
Rand
Institute
hab√≠a
comenzado
a
investigar
el
uso
de
la
con-


mutaci√≥n
de
paquetes
para
las
comunicaciones
de
voz
seguras
en
redes
militares
y
,
en
el


National
Physical
Laboratory
(
NPL
)
de
Inglaterra
,
Donald
Davies
y
Roger
Scantlebury
tam-


bi√©n
estaban
desarrollando
sus
ideas
acerca
de
la
conmutaci√≥n
de
paquetes
.


Los
trabajos
realizados
en
el
MIT
,
en
el
instituto
Rand
y
en
los
laboratorios
NPL
esta-


blecieron
las
bases
de
la
red
Internet
actual
.
Pero
Internet
tambi√©n
tiene
una
larga
tradici√≥n


de
‚Äú
hag√°moslo
y
demostremos
que
funciona
‚Äù
que
tambi√©n
se
remonta
a
la
d√©cada
de
1960
.


J.
C.
R.
Licklider
[
DEC
1990
]
y
Lawrence
Roberts
,
ambos
colegas
de
Kleinrock
en
el
MIT
,


dirigieron
el
programa
de
Ciencias
de
la
Computaci√≥n
en
la
Agencia
de
Proyectos
de
Inves-


tigaci√≥n
Avanzada
(
ARPA
,
Advanced
Research
Projects
Agency
)
de
Estados
Unidos
.


Roberts
public√≥
un
plan
global
para
la
red
ARPAnet
[
Roberts
1967
]
,
la
primera
red
de
com-


putadoras
de
conmutaci√≥n
de
paquetes
y
un
ancestro
directo
de
la
red
Internet
p√∫blica


actual
.
Los
primeros
conmutadores
de
paquetes
se
conoc√≠an
como
procesadores
de
mensa-


jes
de
interfaz
(
IMP
,
Interface
Message
Processors),y
 
e
l
 
c
o
n
t
r
a
t
o
 
p
a
r
a
 
c
o
n
s
t
r
u
i
r
 
e
s
t
o
s
 
c
o
n
-


mutadores
fue
concedido
a
la
empresa
BBN
.
El
D√≠a
del
Trabajo
de
1969
,
se
instal√≥
el


primer
IMP
en
UCLA
bajo
la
supervisi√≥n
de
Kleinrock
y
poco
despu√©s
se
instalaron
tres


IMP
adicionales
en
el
Instituto
de
Investigaci√≥n
de
Stanford
(
SRI
)
en
UC
Santa
Barbara
y


en
la
Universidad
de
Utah
(
Figura
1.26
)
.
Hacia
finales
de
1969
estaba
disponible
la
red
pre-


cursora
de
Internet
,
que
estaba
formada
por
cuatro
nodos
.
Kleinrock
recuerda
la
primera


vez
que
utiliz√≥
la
red
para
llevar
a
cabo
un
inicio
de
sesi√≥n
remoto
desde
UCLA
al
SRI
,


consiguiendo
que
el
sistema
fallara
[
Kleinrock
2004
]
.


Hacia
1972
,
la
red
ARPAnet
hab√≠a
crecido
aproximadamente
hasta
15
nodos
y
la
pri-


mera
demostraci√≥n
p√∫blica
fue
realizada
por
Robert
Kahn
en
1972
en
la
International
Con-


ference
on
Computer
Communications
.
Se
complet√≥
el
primer
protocolo
host
a
host
entre


sistemas
terminales
de
ARPAnet
,
conocido
como
el
protocolo
de
control
de
red
(
NCP
,
Net-


work
Control
Protocol
)
[
RFC
001
]
.
Disponiendo
de
un
protocolo
terminal
a
terminal
,
ahora


pod√≠an
escribirse
aplicaciones
.
Ray
Tomlinson
de
BBN
escribi√≥
el
primer
programa
de


correo
electr√≥nico
en
1972
.


1.7
‚Ä¢
HISTORIA
DE
INTERNET
Y
DE
LAS
REDES
DE
COMPUTADORAS
59


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
5960
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


Figura
1.26
‚Ä¢
Uno
de
los
primeros
procesadores
de
mensajes
de
interfaz
(
IMP
)


y
L.
Kleinrock
(
Mark
J.
Terrill
,
AP
/
Wide
World
Photos
)
.


1.7.2
Redes
propietarias
e
interredes
:
1972-1980


La
red
inicial
ARPAnet
era
una
√∫nica
red
cerrada
.
Para
establecer
una
comunicaci√≥n
con
un


host
de
la
red
ARPAnet
,
hab√≠a
que
estar
realmente
conectado
a
otro
IMP
de
ARPAnet
.
A


mediados
de
la
d√©cada
de
1970
,
comenzaron
a
surgir
otras
redes
de
conmutaci√≥n
de
paque-


tes
aut√≥nomas
adem√°s
de
ARPAnet
,
entre
las
que
se
incluyen
las
siguientes
:


‚Ä¢A
L
O
H
A
N
e
t
,
 
u
n
a
 
r
e
d
 
d
e
 
m
i
c
r
o
o
n
d
a
s
 
q
u
e
 
e
n
l
a
z
a
b
a
 
u
n
i
v
e
r
s
i
d
a
d
e
s
 
d
e
 
l
a
s
 
i
s
l
a
s
 
H
a
w
a
i


[
Abramson
1970
]
,
as√≠
como
redes
de
conmutaci√≥n
de
paquetes
v√≠a
sat√©lite
de
DARPA


[
RFC
829
]
y
redes
de
conmutaci√≥n
de
paquetes
v√≠a
radio
[
Kahn
1978
]
.


‚Ä¢T
e
l
e
n
e
t
,
 
u
n
a
 
r
e
d
 
d
e
 
c
o
n
m
u
t
a
c
i
√≥
n
 
d
e
 
p
a
q
u
e
t
e
s
 
c
o
m
e
r
c
i
a
l
 
d
e
 
B
B
N
 
b
a
s
a
d
a
 
e
n
 
l
a
 
t
e
c
n
o
l
o
-


g√≠a
ARPAnet
.


‚Ä¢C
y
c
l
a
d
e
s
,
 
u
n
a
 
r
e
d
 
d
e
 
c
o
n
m
u
t
a
c
i
√≥
n
 
d
e
 
p
a
q
u
e
t
e
s
 
f
r
a
n
c
e
s
a
 
d
i
r
i
g
i
d
a
 
p
o
r
 
L
o
u
i
s
 
P
o
u
z
i
n
 
[
T
h
i
n
k


2009
]
.


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
60‚Ä¢R
e
d
e
s
 
d
e
 
t
i
e
m
p
o
 
c
o
m
p
a
r
t
i
d
o
 
t
a
l
e
s
 
c
o
m
o
 
T
y
m
n
e
t
 
y
 
l
a
 
r
e
d
 
d
e
 
S
e
r
v
i
c
i
o
s
 
d
e
 
i
n
f
o
r
m
a
c
i
√≥
n
 
G
E
,


entre
otras
,
a
finales
de
la
d√©cada
de
1960
y
principios
de
la
d√©cada
de
1970
[
Schwartz


1977
]
.


‚Ä¢L
a
 
r
e
d
 
S
N
A
d
e
 
I
B
M
 
(
1
9
6
9
-
1
9
7
4
)
,
 
q
u
e
 
c
o
n
s
t
i
t
u
√≠
a
 
u
n
 
d
e
s
a
r
r
o
l
l
o
 
p
a
r
a
l
e
l
o
 
a
l
 
d
e
 
A
R
P
A
n
e
t


[
Schwartz
1977
]
.


El
n√∫mero
de
redes
fue
creciendo
.
Retrospectivamente
,
podemos
ver
que
hab√≠a
llegado


el
momento
de
desarrollar
una
arquitectura
completa
para
la
interconexi√≥n
de
redes
.
El
tra-


bajo
pionero
sobre
interconexi√≥n
de
redes
(
realizado
bajo
el
patrocinio
de
la
Agencia


DARPA
,
Defense
Advanced
Research
Projects
Agency
)
,
que
en
esencia
es
la
creaci√≥n
de
una


red
de
redes
,
fue
realizado
por
Vinton
Cerf
y
Robert
Kahn
[
Cerf
1974
]
;
el
t√©rmino
internet-


ting
(
interredes
o
interconexi√≥n
de
redes
)
fue
acu√±ado
para
describir
este
trabajo
.


Estos
principios
arquitect√≥nicos
fueron
integrados
en
TCP
.
Sin
embargo
,
las
prime-


ras
versiones
de
TCP
eran
bastante
distintas
al
TCP
de
hoy
d√≠a
.
Esas
primeras
versiones


combinaban
una
entrega
fiable
en
secuencia
de
los
datos
mediante
retransmisiones
del


sistema
terminal
(
esta
funci√≥n
todav√≠a
la
realiza
TCP
hoy
d√≠a
)
con
funciones
de
reenv√≠o


(
que
actualmente
son
realizadas
por
IP
)
.
Los
primeros
experimentos
con
TCP
,
combina-


dos
con
el
reconocimiento
de
la
importancia
de
disponer
de
un
servicio
de
transporte
ter-


minal
a
terminal
no
fiable
y
sin
control
de
flujo
para
aplicaciones
tales
como
voz


empaquetada
,
llevaron
a
la
separaci√≥n
de
IP
de
TCP
y
al
desarrollo
del
protocolo
UDP
.


Los
tres
protocolos
clave
de
Internet
que
se
emplean
actualmente
(
TCP
,
UDP
e
IP
)
fue-


ron
concebidos
a
finales
de
la
d√©cada
de
1970
.


Adem√°s
de
las
investigaciones
relativas
a
Internet
de
la
agencia
DARPA
,
tambi√©n
se


llevaron
a
cabo
muchas
otras
importantes
actividades
de
red
.
En
Hawai
,
Norman
Abramson


desarroll√≥
ALOHAnet
,
una
red
de
paquetes
v√≠a
radio
que
permit√≠a
a
varios
sitios
remotos
de


las
islas
Hawai
comunicarse
entre
s√≠
.
El
protocolo
ALOHA
[
Abramson
1970
]
fue
el
primer


protocolo
de
acceso
m√∫ltiple
,
que
permiti√≥
a
usuarios
distribuidos
geogr√°ficamente
compar-


tir
un
mismo
medio
de
comunicaci√≥n
de
difusi√≥n
(
una
frecuencia
de
radio
)
.
Metcalfe
y


Boggs
se
basaron
en
el
protocolo
de
acceso
m√∫ltiple
de
Abramson
para
desarrollar
el
proto-


colo
Ethernet
[
Metcalfe
1976
]
para
redes
de
difusi√≥n
compartidas
basadas
en
cable
;
v√©ase
la


Figura
1.27
.
Es
interesante
comentar
que
el
protocolo
Ethernet
de
Metcalfe
y
Boggs
fue


motivado
por
la
necesidad
de
conectar
varios
PC
,
impresoras
y
discos
compartidos
[
Perkins


1994
]
.
Hace
veinticinco
a√±os
,
bastante
antes
de
la
revoluci√≥n
de
los
PC
y
de
la
explosi√≥n
de


las
redes
,
 
Metcalfe
y
Boggs
establecieron
las
bases
para
las
redes
LAN
de
computadoras


PC
actuales
.
La
tecnolog√≠a
Ethernet
tambi√©n
represent√≥
un
paso
importante
en
la
intercone-


xi√≥n
de
redes
(
interred
)
.
Cada
red
de
√°rea
local
Ethernet
era
una
red
por
s√≠
misma
,
y
dado


que
el
n√∫mero
de
redes
LAN
proliferaba
,
la
necesidad
de
interconectar
estas
redes
LAN


adquir√≠a
cada
vez
m√°s
importancia
.
En
el
Cap√≠tulo
5
veremos
en
detalle
Ethernet
,
ALOHA
y


otras
tecnolog√≠as
LAN
.


1.7.3
Proliferaci√≥n
de
las
redes
:
1980-1990


Af
i
n
a
l
e
s
 
d
e
 
l
a
 
d
√©
c
a
d
a
 
d
e
 
1
9
7
0
,
 
h
a
b
√≠
a
 
u
n
o
s
 
d
o
s
c
i
e
n
t
o
s
 
h
o
s
t
s
 
c
o
n
e
c
t
a
d
o
s
 
a
 
l
a
 
r
e
d
 
A
R
P
A
n
e
t
.
 
A


finales
de
la
d√©cada
de
1980
,
el
n√∫mero
de
hosts
conectados
a
la
red
Internet
p√∫blica
,
una


confederaci√≥n
de
redes
similar
a
la
Internet
actual
,
llegar√≠a
a
los
cien
mil
.
La
d√©cada
de
1980


fue
una
√©poca
de
enorme
crecimiento
.


Gran
parte
de
este
crecimiento
fue
el
resultado
de
varios
y
distintos
esfuerzos
por
crear


redes
de
computadoras
que
enlazaran
universidades
.
BITNET
proporcionaba
servicios
de


1.7
‚Ä¢
HISTORIA
DE
INTERNET
Y
DE
LAS
REDES
DE
COMPUTADORAS
61


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
6162
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


Figura
1.27
‚Ä¢
Concepci√≥n
original
de
Ethernet
de
Metcalfe
.


correo
electr√≥nico
y
de
transferencia
de
archivos
entre
varias
universidades
.
CSNET
(
Com-


puter
Science
Network
)
se
form√≥
para
que
investigadores
universitarios
que
no
ten√≠an


acceso
a
la
red
ARPAnet
pudieran
comunicarse
.
En
1986
se
cre√≥
NSFNET
para
proporcio-


nar
acceso
a
los
centros
de
supercomputaci√≥n
patrocinados
por
NSF
.
Inicialmente
,
con
una


velocidad
en
la
red
troncal
de
56
kbps
,
la
red
troncal
de
NSFNET
llegar√≠a
a
operar
a
1,5


Mbps
a
finales
de
la
d√©cada
y
servir√≠a
como
una
red
troncal
primaria
para
enlazar
redes


regionales
.


En
la
comunidad
ARPAnet
,
muchas
de
las
piezas
finales
de
la
arquitectura
de
Internet


actual
fueron
encajando
.
El
1
de
enero
de
1983
se
llev√≥
a
cabo
el
lanzamiento
oficial
de


TCP
/
IP
como
el
nuevo
protocolo
de
host
est√°ndar
para
ARPAnet
(
reemplazando
al
protocolo


NCP
)
.
La
transici√≥n
[
RFC
801
]
de
NCP
a
TCP
/
IP
fue
un
suceso
se√±alado
:
a
todos
los
hosts
se


les
requiri√≥
pasar
a
utilizar
TCP
/
IP
ese
d√≠a
.
A
finales
de
la
d√©cada
de
1980
,
se
realizaron


importantes
extensiones
en
TCP
con
el
fin
de
implementar
el
control
de
congesti√≥n
basado
en


host
[
Jacobson
1988
]
.
Tambi√©n
se
desarroll√≥
el
sistema
DNS
,
que
se
emplea
para
establecer


la
correspondencia
entre
los
nombres
de
Internet
que
usamos
las
personas
(
por
ejemplo
,


gaia.cs.umass.edu
)
y
sus
direcciones
IP
de
32
bits
[
RFC
1034
]
.


En
paralelo
con
el
desarrollo
de
ARPAnet
(
realizado
fundamentalmente
en
Estados


Unidos
)
,
a
principios
de
la
d√©cada
de
1980
,
los
franceses
lanzaron
el
proyecto
Minitel
,
un


ambicioso
plan
para
llevar
las
redes
de
datos
a
todos
los
hogares
.
Patrocinado
por
el


gobierno
franc√©s
,
el
sistema
Minitel
consist√≠a
en
una
red
p√∫blica
de
conmutaci√≥n
de
paque-


tes
(
basada
en
la
serie
de
protocolos
X.25
)
,
servidores
Minitel
y
terminales
econ√≥micos
que


incorporaban
modems
de
baja
velocidad
.
Minitel
alcanz√≥
un
gran
√©xito
en
1984
cuando
el


gobierno
franc√©s
proporcion√≥
un
terminal
Minitel
gratuito
a
todo
aquel
que
deseara
tener


uno
en
su
casa
.
Los
sitios
Minitel
inclu√≠an
sitios
gratuitos
,
como
por
ejemplo
el
directorio


telef√≥nico
,
y
sitios
privados
,
que
cobraban
sus
tarifas
bas√°ndose
en
la
utilizaci√≥n
del
servi-


cio
.
A
mediados
de
la
d√©cada
de
1990
,
se
produjo
el
pico
de
servicios
ofertados
ofreciendo


m√°s
de
20.000
servicios
,
desde
servicios
de
banca
hasta
bases
de
datos
de
investigaci√≥n


especializadas
.
Esta
red
era
utilizada
por
m√°s
del
20
por
ciento
de
la
poblaci√≥n
de
Francia
,


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
621.7
‚Ä¢
HISTORIA
DE
INTERNET
Y
DE
LAS
REDES
DE
COMPUTADORAS
63


gener√≥
m√°s
de
1.000
millones
de
d√≥lares
de
ingresos
anuales
y
di√≥
lugar
a
la
creaci√≥n
de


10.000
puestos
de
trabajo
.
Minitel
se
utiliz√≥
en
muchos
hogares
de
Francia
10
a√±os
antes


de
que
los
americanos
ni
siquiera
hubieran
o√≠do
hablar
de
Internet
.


1.7.4
La
explosi√≥n
de
Internet
:
d√©cada
de
1990


La
d√©cada
de
1990
estuvo
marcada
por
una
serie
de
acontecimientos
que
simbolizaron
la


continua
evoluci√≥n
y
la
pronta
llegada
de
la
comercializaci√≥n
de
Internet
.
ARPAnet
,
el
pro-


genitor
de
Internet
,
dej√≥
de
exi
stir
.
MILNET
y
la
Red
de
Datos
de
Defensa
hab√≠an
crecido


durante
la
d√©cada
de
1980
transportando
la
mayor
parte
del
tr√°fico
relacionado
con
el


Departamento
de
Defensa
de
Estados
Unidos
y
NSFNET
hab√≠a
empezado
a
servir
como
red


troncal
para
conectar
las
redes
regionales
de
Estados
Unidos
y
las
redes
nacionales
de
ultra-


mar
.
En
1991
,
NSFNET
retir√≥
sus
restricciones
sobre
el
uso
de
NSFNET
para
prop√≥sitos


comerciales
.
La
propia
NSFNET
fue
eliminada
del
servicio
activo
en
1995
,
siendo
el
tr√°fico


troncal
de
Internet
transportado
por
los
Proveedores
de
servicios
de
Internet
comerciales
.


Sin
embargo
,
el
principal
acontecimiento
de
la
d√©cada
de
1990
fue
la
aparici√≥n
de
la


World
Wide
Web
,
que
llevar√≠a
Internet
a
los
hogares
y
negocios
de
millones
de
personas
de


todo
el
mundo
.
La
Web
sirvi√≥
como
plataforma
para
posibilitar
e
implantar
cientos
de
nue-


vas
aplicaciones
,
que
hoy
damos
por
sentadas
.
Si
desea
conocer
una
breve
historia
sobre
la


primera
√©poca
de
la
Web
,
consulte
[
W3C
1995
]
.


La
Web
fue
inventada
en
el
CERN
por
Tim
Berners-Lee
entre
1989
y
1991
[
Berners-


Lee
1989
]
,
bas√°ndose
en
las
ideas
de
los
primeros
trabajos
acerca
del
hipertexto
desarrolla-


das
en
la
d√©cada
de
1940
por
Vannevar
Bush
[
Bush
1945
]
y
luego
en
la
d√©cada
de
1960
por


Ted
Nelson
[
Xanadu
2009
]
.
Berners-Lee
y
sus
socios
desarrollaron
las
versiones
iniciales
de


HTML
,
HTTP
,
un
servidor
web
y
un
navegador
(
los
cuatro
componentes
clave
de
la
Web
)
.


Hacia
finales
del
a√±o
1993
estaban
operativos
aproximadamente
doscientos
servidores
web
.


Esta
colecci√≥n
de
servidores
s√≥lo
ser√≠a
un
presagio
de
lo
que
estaba
por
venir
.
Al
mismo


tiempo
,
hab√≠a
varios
investigadores
desarrollando
navegadores
web
con
interfaces
GUI
,


entre
los
que
se
encontraba
Marc
Andreessen
,
que
lider√≥
el
desarroll√≥
del
popular
navegador


con
interfaz
GUI
Mosaic
.
En
1994
,
Marc
Andreessen
y
Jim
Clark
crearon
Mosaic
Commu-


nications
,
que
m√°s
tarde
se
convertir√≠a
en
Netscape
Communications
Corporation
[
Cusu-


mano
1998
;
Quittner
1998
]
.
Hacia
1995
,
los
estudiantes
universitarios
empleaban
los


navegadores
Mosaic
y
Netscape
para
navegar
por
la
Web
diariamente
.
Tambi√©n
por
esa


√©poca
,
las
empresas
,
grandes
y
peque√±as
,
comenzaron
a
trabajar
con
servidores
web
y
a
rea-


lizar
transacciones
comerciales
a
trav√©s
de
la
Web
.
En
1996
,
Microsoft
empez√≥
a
desarrollar


navegadores
y
comenzar√≠a
la
guerra
de
los
navegadores
entre
Netscape
y
Microsoft
,
que
ter-


minar√≠a
ganando
Microsoft
unos
pocos
a√±os
despu√©s
[
Cusumano
1998
]
.


La
segunda
mitad
de
la
d√©cada
de
1990
fue
un
periodo
de
gran
crecimiento
e
innova-


ci√≥n
para
Internet
,
con
las
principales
corporaciones
y
miles
de
empresas
creando
productos


y
servicios
Internet
.
El
correo
electr√≥nico
a
trav√©s
de
Internet
continu√≥
evolucionando
con


lectores
de
correo
cada
vez
con
m√°s
funcionalidades
que
proporcionaban
libretas
de
direc-


ciones
,
adjuntos
,
hiperv√≠nculos
activos
y
transporte
multimedia
.
Al
final
del
milenio
,
Inter-


net
daba
soporte
a
cientos
de
aplicaciones
populares
,
entre
las
que
se
incluyen
:
 

‚Ä¢C
o
r
r
e
o
 
e
l
e
c
t
r
√≥
n
i
c
o
,
 
i
n
c
l
u
y
e
n
d
o
 
l
o
s
 
a
d
j
u
n
t
o
s
 
y
 
e
l
 
c
o
r
r
e
o
 
e
l
e
c
t
r
√≥
n
i
c
o
 
a
c
c
e
s
i
b
l
e
 
a
 
t
r
a
v
√©
s
 
d
e


la
Web
.


‚Ä¢L
a
 
W
e
b
,
 
i
n
c
l
u
y
e
n
d
o
 
l
a
 
n
a
v
e
g
a
c
i
√≥
n
 
w
e
b
 
y
 
e
l
 
c
o
m
e
r
c
i
o
 
p
o
r
 
I
n
t
e
r
n
e
t
.


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
63‚Ä¢L
a
 
m
e
n
s
a
j
e
r
√≠
a
 
i
n
s
t
a
n
t
√°
n
e
a
,
 
c
o
n
 
l
i
s
t
a
s
 
d
e
 
c
o
n
t
a
c
t
o
s
,
 
p
r
i
m
e
r
a
m
e
n
t
e
 
i
n
t
r
o
d
u
c
i
d
a
 
p
o
r
 
I
C
Q
.


‚Ä¢L
a
 
c
o
m
p
a
r
t
i
c
i
√≥
n
 
i
g
u
a
l
i
t
a
r
i
a
 
d
e
 
a
r
c
h
i
v
o
s
 
M
P
3
,
 
d
e
 
l
a
 
q
u
e
 
N
a
p
s
t
e
r
 
f
u
e
 
l
a
 
p
i
o
n
e
r
a
.


Es
interesante
saber
que
las
dos
primeras
de
esta
aplicaciones
estrella
fueron
creadas
por
la


comunidad
de
investigadores
,
mientras
que
las
dos
√∫ltimas
lo
fueron
por
unos
pocos
j√≥venes


emprendedores
.


El
periodo
comprendido
entre
1995
y
2001
fue
un
paseo
en
monta√±a
rusa
para
Internet


en
los
mercados
financieros
.
Antes
de
que
fueran
incluso
rentables
,
cientos
de
nuevas


empresas
de
Internet
fueron
vendidas
en
el
mercado
burs√°til
con
oferta
p√∫blica
inicial
.


Muchas
empresas
fueron
valoradas
en
miles
de
millones
de
d√≥lares
sin
tener
ingresos
signi-


ficativos
.
Las
acciones
de
Internet
se
hundieron
en
2000-2001
y
muchas
de
esas
empresas


de
nueva
creaci√≥n
cerraron
.
No
obstante
,
algunas
de
ellas
emergieron
como
los
grandes


ganadores
en
el
espacio
Internet
,
entre
las
que
se
incluyen
Microsoft
,
Cisco
,
Yahoo
,
e-Bay
,


Google
y
Amazon
.


1.7.5
Desarrollos
recientes


La
innovaci√≥n
en
las
redes
de
computadoras
contin√∫a
a
buen
paso
.
Se
han
hecho
avances
en


todos
los
frentes
,
incluyendo
la
implementaci√≥n
de
nuevas
aplicaciones
,
distribuci√≥n
de
con-


tenidos
,
telefon√≠a
por
Internet
,
velocidades
de
transmisi√≥n
m√°s
altas
en
las
redes
LAN
y
rou-


ters
m√°s
r√°pidos
.
Pero
los
tres
desarrollos
que
merecen
una
atenci√≥n
especial
son
la


proliferaci√≥n
de
m√©todos
de
acceso
de
alta
velocidad
(
incluido
el
acceso
inal√°mbrico
)
,
la


seguridad
y
las
redes
P2P.


Como
se
ha
visto
en
la
Secci√≥n
1.2
,
la
creciente
penetraci√≥n
del
acceso
a
Internet
resi-


dencial
mediante
m√≥dem
por
cable
y
DSL
abre
una
etapa
de
abundancia
para
nuevas
aplica-


ciones
multimedia
,
incluyendo
voz
y
v√≠deo
sobre
IP
[
Skype
2009
]
,
compartici√≥n
de
v√≠deos


[
YouTube
2009
]
y
televisi√≥n
sobre
IP
[
PPLive
2009
]
.
La
creciente
omnipresencia
de
las


redes
p√∫blicas
Wi-Fi
de
alta
velocidad
(
11
Mbps
y
superior
)
y
el
acceso
a
Internet
a
veloci-


dades
medias
(
cientos
de
kbps
)
mediante
redes
de
telefon√≠a
m√≥vil
no
hacen
s√≥lo
posible


estar
constantemente
conectado
,
sino
que
tambi√©n
habilitan
un
nuevo
y
excitante
conjunto


de
servicios
espec√≠ficos
de
la
ubicaci√≥n
.
En
el
Cap√≠tulo
6
nos
ocuparemos
de
las
redes
ina-


l√°mbricas
y
de
la
movilidad
.


Despu√©s
de
una
serie
de
ataques
de
denegaci√≥n
de
servicio
en
los
servidores
web
m√°s


importantes
a
finales
de
la
d√©cada
de
1990
y
de
la
proliferaci√≥n
de
ataques
mediante
gusa-


nos
(
como
el
gusano
Blaster
)
,
la
seguridad
de
las
redes
se
convirti√≥
en
un
tema
extremada-


mente
importante
.
Estos
ataques
dieron
lugar
al
desarrollo
de
los
sistemas
de
detecci√≥n
de


intrusiones
,
que
son
capaces
de
advertir
en
una
fase
temprana
de
un
ataque
,
y
al
uso
de
cor-


tafuegos
para
filtrar
el
tr√°fico
no
deseado
antes
de
que
entre
en
la
red
.
En
el
Cap√≠tulo
8
vere-


mos
unos
cuantos
temas
importantes
relacionados
con
la
seguridad
.


La
√∫ltima
innovaci√≥n
de
la
que
tomaremos
nota
son
las
redes
P2P.
Una
aplicaci√≥n
de


red
P2P
explota
los
recursos
disponibles
en
las
computadoras
de
los
usuarios
(
almacena-


miento
,
contenido
,
ciclos
de
CPU
y
presencia
humana
)
y
tiene
una
autonom√≠a
significativa


con
respecto
a
los
servidores
centrales
.
Normalmente
,
las
computadoras
de
los
usuarios
(
es


decir
,
los
pares
)
disponen
de
una
conectividad
intermitente
.
Son
numerosas
las
historias
de


√©xito
P2P
que
han
tenido
lugar
en
los
√∫ltimos
a√±os
,
entre
las
que
se
incluyen
la
compartici√≥n


de
archivos
P2P
(
Napster
,
Kazaa
,
Gnutella
,
eDonkey
,
LimeWire
,
etc.
)
,
la
distribuci√≥n
de


64
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
64archivos
(
BitTorrent
)
,
V
oz
sobre
IP
(
Skype
)
e
IPTV
(
PPLive
,
ppStream
)
.
En
el
Cap√≠tulo
2


veremos
muchas
de
estas
aplicaciones
P2P.


1.8
Resumen


En
este
cap√≠tulo
hemos
presentado
una
gran
cantidad
de
material
.
Hemos
hablado
de
las
dis-


tintas
piezas
hardware
y
software
que
forman
Internet
en
particular
y
las
redes
de
computa-


doras
en
general
.
Hemos
partido
de
la
frontera
de
la
red
,
fij√°ndonos
en
los
sistemas


terminales
y
las
aplicaciones
,
y
en
el
servicio
de
transporte
proporcionado
a
las
aplicaciones


que
se
ejecutan
en
los
sistemas
terminales
.
Tambi√©n
hemos
hablado
de
las
tecnolog√≠as
de
la


capa
de
enlace
y
de
los
medios
f√≠sicos
que
pueden
encontrarse
normalmente
en
la
red
de


acceso
.
A
continuaci√≥n
,
nos
hemos
adentrado
en
el
interior
de
la
red
,
en
su
n√∫cleo
,
y
hemos


identificado
los
mecanismos
de
conmutaci√≥n
de
paquetes
y
de
conmutaci√≥n
de
circuitos


como
los
dos
m√©todos
b√°sicos
utilizados
para
el
transporte
de
datos
a
trav√©s
de
una
red
de


telecomunicaciones
,
y
hemos
examinado
las
fortalezas
y
las
debilidades
de
cada
m√©todo
.


Tambi√©n
hemos
examinado
la
estructura
global
de
Internet
,
y
hemos
aprendido
que
es
una


red
de
redes
.
Hemos
visto
que
la
estructura
jer√°rquica
de
Internet
,
formada
por
los
ISP
de


nivel
superior
e
inferior
,
ha
permitido
que
Internet
crezca
hasta
incluir
miles
de
redes
.


En
la
segunda
parte
de
este
cap√≠tulo
de
introducci√≥n
,
hemos
abordado
varios
temas
funda-


mentales
del
campo
de
las
redes
.
En
primer
lugar
,
hemos
estudiado
las
causas
de
los
retardos
,


la
tasa
de
transferencia
y
la
p√©rdida
de
paquetes
en
una
red
de
conmutaci√≥n
de
paquetes
.


Hemos
desarrollado
modelos
cuantitativos
simples
para
determinar
los
retardos
de
transmi-


si√≥n
,
de
propagaci√≥n
y
de
cola
,
as√≠
como
para
la
tasa
de
transferencia
;
hemos
hecho
un
uso


exhaustivo
de
estos
modelos
de
retardo
en
los
problemas
de
repaso
incluidos
al
final
del
cap√≠-


tulo
.
A
continuaci√≥n
,
hemos
visto
las
capas
de
protocolos
y
los
modelos
de
servicio
,
las
princi-


pales
claves
arquitect√≥nicas
de
las
redes
a
las
que
se
volver√°
a
hacer
referencia
a
lo
largo
del


libro
.
Asimismo
,
hemos
repasado
los
ataques
de
seguridad
m√°s
habituales
actualmente
en


Internet
.
Hemos
terminado
nuestra
introducci√≥n
con
un
breve
repaso
a
la
historia
de
las
redes


de
computadoras
.
Este
primer
cap√≠tulo
en
s√≠
mismo
constituye
un
minicurso
sobre
redes
de


computadoras
.


Por
tanto
,
hemos
cubierto
una
enorme
cantidad
de
conceptos
b√°sicos
en
este
primer


cap√≠tulo
.
Si
est√°
un
poco
abrumado
,
no
se
preocupe
,
en
los
siguientes
cap√≠tulos
revisaremos


todas
estas
ideas
,
vi√©ndolas
con
mucho
m√°s
detalle
(
lo
que
es
una
promesa
,
no
una
ame-


naza
)
.
En
este
punto
,
esperamos
que
termine
el
cap√≠tulo
teniendo
ya
una
idea
sobre
las
pie-


zas
que
forman
una
red
,
teniendo
un
conocimiento
(
que
todav√≠a
deber√°
desarrollar
)
del


vocabulario
del
campo
de
las
redes
de
computadoras
(
no
se
asuste
por
tener
que
volver
a


consultar
este
cap√≠tulo
)
y
habiendo
incrementado
su
deseo
por
aprender
m√°s
acerca
de
las


redes
.
√âsta
es
la
tarea
que
tenemos
por
delante
durante
el
resto
del
libro
.


Mapa
de
este
libro


Antes
de
iniciar
cualquier
viaje
,
siempre
deber√≠a
echarse
un
vistazo
a
un
mapa
de
carreteras


para
familiarizarse
con
las
principales
carreteras
y
desv√≠os
con
los
que
nos
encontraremos


m√°s
adelante
.
En
el
viaje
en
el
que
nos
hemos
embarcado
nosotros
,
el
destino
final
es
cono-


cer
en
profundidad
el
c√≥mo
,
el
qu√©
y
el
por
qu√©
de
las
redes
de
computadoras
,
y
nuestro


mapa
son
los
cap√≠tulos
de
este
libro
:


1.8
‚Ä¢
RESUMEN
65


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
651
.
Redes
de
computadoras
e
Internet


2
.
La
capa
de
aplicaci√≥n


3
.
La
capa
de
transporte


4
.
La
capa
de
red


5
.
La
capa
de
enlace
y
las
redes
de
√°rea
local


6
.
Redes
inal√°mbricas
y
m√≥viles


7
.
Redes
multimedia


8
.
Seguridad
en
las
redes
de
computadoras


9
.
Gesti√≥n
de
redes


Los
Cap√≠tulos
2
a
5
son
los
cuatro
cap√≠tulos
centrales
del
libro
.
Observar√°
que
est√°n


organizados
seg√∫n
las
cuatro
capas
superiores
de
la
pila
de
protocolos
de
Internet
de
cinco


capas
,
un
cap√≠tulo
por
capa
.
Observar√°
tambi√©n
que
nuestro
viaje
va
a
comenzar
por
la
parte


superior
de
la
pila
de
protocolos
de
Internet
,
es
decir
,
por
la
capa
de
aplicaci√≥n
,
y
luego
con-


tinuaremos
nuestro
trabajo
descendiendo
por
la
pila
.
El
razonamiento
de
hacer
este
recorrido


de
arriba-abajo
es
porque
una
vez
que
conozcamos
las
aplicaciones
,
estaremos
en
condicio-


nes
de
comprender
los
servicios
de
red
necesarios
para
dar
soporte
a
esas
aplicaciones
.


Podremos
as√≠
examinar
las
distintas
formas
en
que
tales
servicios
pueden
ser
implementados


por
una
arquitectura
de
red
.
Ocuparnos
de
las
aplicaciones
en
primer
lugar
nos
va
a
propor-


cionar
la
motivaci√≥n
necesaria
para
abordar
el
resto
del
texto
.


En
la
segunda
mitad
del
libro
,
los
Cap√≠tulos
6
a
9
,
se
abordan
cuatro
temas
enorme-


mente
importantes
(
y
en
cierto
modo
independientes
)
en
las
redes
de
comunicaciones


modernas
.
En
el
Cap√≠tulo
6
,
examinaremos
las
redes
inal√°mbricas
y
celulares
,
incluyendo


las
redes
LAN
inal√°mbricas
(
lo
que
incluye
las
tecnolog√≠as
WiFi
,
WiMAX
y
Bluetooth
)
,
las


redes
de
telefon√≠a
m√≥vil
(
lo
que
incluye
las
redes
GSM
)
y
la
movilidad
(
tanto
en
redes
IP


como
GSM
)
.
En
el
Cap√≠tulo
7
,
‚Äú
Redes
multimedia
‚Äù
,
examinaremos
aplicaciones
de
audio
y


de
v√≠deo
tales
como
la
telefon√≠a
Internet
,
la
videoconferencia
y
los
flujos
de
informaci√≥n


multimedia
almacenada
.
Tambi√©n
veremos
c√≥mo
pueden
dise√±arse
las
redes
de
conmuta-


ci√≥n
de
paquetes
para
proporcionar
una
calidad
de
servicio
coherente
a
las
aplicaciones
de


audio
y
de
v√≠deo
.
En
el
Cap√≠tulo
8
,
‚Äú
Seguridad
en
las
redes
de
computadoras
‚Äù
,
veremos
en


primer
lugar
los
fundamentos
de
los
mecanismos
de
cifrado
y
de
seguridad
de
red
y
despu√©s


examinaremos
c√≥mo
est√°
siendo
aplicada
la
teor√≠a
b√°sica
a
un
amplio
rango
de
contextos
de


Internet
.
El
√∫ltimo
cap√≠tulo
,
‚Äú
Gesti√≥n
de
redes
‚Äù
,
examina
los
problemas
fundamentales
de
la


administraci√≥n
de
red
,
as√≠
como
los
principales
protocolos
de
Internet
empleados
para
admi-


nistrar
la
red
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
1
Cuestiones
de
repaso


SECCI√ìN
1.1


R1
.
¬ø
Cu√°l
es
la
diferencia
entre
un
host
y
un
sistema
terminal
?
Enumere
los
tipos
de
siste-


mas
terminales
.
¬ø
Es
un
servidor
web
un
sistema
terminal
?


R2
.
El
t√©rmino
protocolo
a
menudo
se
emplea
para
describir
las
relaciones
diplom√°ticas
.


Proporcione
un
ejemplo
de
un
protocolo
diplom√°tico
.


66
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
66SECCI√ìN
1.2


R3
.
¬ø
Qu√©
es
un
programa
cliente
?
¬ø
Qu√©
es
un
programa
servidor
?
¬ø
Un
programa
servidor


solicita
y
recibe
servicios
de
un
programa
cliente
?


R4
.
Enumere
seis
tecnolog√≠as
de
acceso
.
Clasif√≠quelas
como
de
acceso
residencial
,
acceso


empresarial
o
acceso
m√≥vil
.


R5
.
¬ø
La
velocidad
de
transmisi√≥n
en
un
sistema
HFC
es
dedicada
o
compartida
entre
los


usuarios
?
¬ø
Pueden
producirse
colisiones
en
un
canal
de
descarga
HFC
?
¬ø
Por
qu√©
?


R6
.
Enumere
las
tecnolog√≠as
de
acceso
residencial
disponibles
en
su
ciudad
.
Para
cada
tipo


de
acceso
,
detalle
la
velocidad
de
descarga
,
la
velocidad
de
carga
y
el
precio
mensual
.


R7
.
¬ø
Cu√°l
es
la
velocidad
de
transmisi√≥n
en
las
redes
LAN
Ethernet
?
Para
una
determi-


nada
velocidad
de
transmisi√≥n
,
¬ø
pueden
los
usuarios
de
la
LAN
transmitir
continua-


mente
a
dicha
velocidad
?


R8
.
Cite
algunos
de
los
medios
f√≠sicos
sobre
los
que
se
puede
emplear
la
tecnolog√≠a
Ether-


net
.


R9
.
Para
el
acceso
residencial
se
emplean
los
modems
de
acceso
telef√≥nico
,
los
sistemas


HFC
,
DSL
y
FTTH
.
Para
cada
una
de
estas
tecnolog√≠as
de
acceso
,
detalle
el
rango
de


velocidades
de
transmisi√≥n
e
indique
si
la
velocidad
de
transmisi√≥n
es
dedicada
o


compartida
.


R10
.
Describa
las
tecnolog√≠as
de
acceso
inal√°mbrico
a
Internet
m√°s
populares
hoy
d√≠a
.


SECCI√ìN
1.3


R11
.
¬ø
Qu√©
ventajas
presenta
una
red
de
conmutaci√≥n
de
circuitos
frente
a
una
red
de
con-


mutaci√≥n
de
paquetes
?
¬ø
Qu√©
desventajas
tiene
la
multiplexaci√≥n
TDM
frente
a
la
mul-


tiplexaci√≥n
FDM
en
una
red
de
conmutaci√≥n
de
circuitos
?


R12
.
¬ø
Por
qu√©
se
dice
que
la
conmutaci√≥n
de
paquetes
emplea
multiplexaci√≥n
estad√≠stica
?


Compare
la
multiplexaci√≥n
estad√≠stica
con
la
multiplexaci√≥n
por
divisi√≥n
en
el
tiempo


(
TDM
)
.


R13
.
Suponga
que
hay
un
√∫nico
dispositivo
de
conmutaci√≥n
de
paquetes
entre
un
host
emi-


sor
y
un
host
receptor
.
Las
velocidades
de
transmisi√≥n
entre
el
host
emisor
y
el
dis-


positivo
de
conmutaci√≥n
(
switch
)
y
entre
el
switch
y
el
host
receptor
son
R1
y
R2
,


respectivamente
.
Suponiendo
que
el
switch
utiliza
el
mecanismo
de
conmutaci√≥n
de


paquetes
de
almacenamiento
y
reenv√≠o
,
¬ø
cu√°l
es
el
retardo
total
terminal
a
terminal
si


se
env√≠a
un
paquete
de
longitud
L
?
(
Ignore
los
retardos
de
cola
,
de
propagaci√≥n
y
de


procesamiento
.
)


R14
.
¬ø
Cu√°l
es
la
diferencia
entre
un
ISP
de
nivel
1
y
un
ISP
de
nivel
2
?


R15
.
Suponga
que
los
usuarios
comparten
un
enlace
de
2
Mbps
y
que
cada
usuario
trans-


mite
a
una
velocidad
de
1
Mbps
continuamente
,
pero
s√≥lo
durante
el
20
por
ciento
del


tiempo
.
(
V√©ase
la
explicaci√≥n
sobre
la
multiplexaci√≥n
estad√≠stica
de
la
Secci√≥n
1.3
.
)


a.
Si
se
utiliza
la
conmutaci√≥n
de
circuitos
,
¬ø
a
cu√°ntos
usuarios
puede
darse
soporte
?


b.
Para
el
resto
del
problema
,
suponga
que
se
utiliza
la
conmutaci√≥n
de
paquetes
.
¬ø
Por


qu√©
pr√°cticamente
no
habr√°
retardo
de
cola
antes
del
enlace
si
dos
o
menos
usua-


rios
transmiten
a
un
mismo
tiempo
?
¬ø
Por
qu√©
existir√°
retardo
de
cola
si
tres


usuarios
transmiten
simult√°neamente
?


PROBLEMAS
Y
CUESTIONES
DE
REPASO
67


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
67c
.
Calcule
la
probabilidad
de
que
un
usuario
dado
est√©
transmitiendo
.


d.
Suponga
ahora
que
hay
tres
usuarios
.
Calcule
la
probabilidad
de
que
en
un
instante


determinado
los
tres
usuarios
est√©n
transmitiendo
simult√°neamente
.
Halle
la
frac-


ci√≥n
de
tiempo
durante
la
que
la
cola
crece
.


SECCI√ìN
1.4


R16
.
Considere
el
env√≠o
de
un
paquete
desde
un
host
emisor
a
un
host
receptor
a
trav√©s
de


una
ruta
fija
.
Enumere
los
componentes
del
retardo
terminal
a
terminal
.
¬ø
Cu√°les
de


estos
retardos
son
constantes
y
cu√°les
son
variables
?


R17
.
Visite
el
applet
Transmission
Versus
Propagation
Delay
(
transmisi√≥n
frente
a
retardo


de
propagaci√≥n
)
disponible
en
el
sitio
web
del
libro
.
Utilizando
las
velocidades
,
retar-


dos
de
propagaci√≥n
y
tama√±os
de
paquete
disponibles
,
determine
una
combinaci√≥n


para
la
cual
el
emisor
termine
la
operaci√≥n
de
transmisi√≥n
antes
de
que
el
primer
bit


del
paquete
haya
llegado
al
receptor
.
Halle
otra
combinaci√≥n
para
la
que
el
primer


bit
del
paquete
haga
llegado
al
receptor
antes
de
que
el
emisor
haya
terminado
de


transmitir
.


R18
.
¬ø
Cu√°nto
tiempo
tarda
un
paquete
cuya
longitud
es
de
1.000
bytes
en
propagarse
a
tra-


v√©s
de
un
enlace
a
una
distancia
de
2.500
km
,
siendo
la
velocidad
de
propagaci√≥n


igual
a
 
2,5
¬∑
10
8
m
/
s
y
la
velocidad
de
transmisi√≥n
a
2
Mbps
?
De
forma
m√°s
general
,


¬ø
cu√°nto
tiempo
tarda
un
paquete
de
longitud
L
en
propagarse
a
trav√©s
de
un
enlace
a


una
distancia
d
,
con
una
velocidad
de
propagaci√≥n
s
y
una
velocidad
de
transmisi√≥n


de
R
bps
?
¬ø
Depende
este
retardo
de
la
longitud
del
paquete
?
¬ø
Depende
este
retardo
de


la
velocidad
de
transmisi√≥n
?


R19
.
Suponga
que
el
host
A
desea
enviar
un
archivo
de
gran
tama√±o
al
host
B.
La
ruta
desde


el
host
A
al
host
B
est√°
formada
por
tres
enlaces
,
cuyas
velocidades
son
R1
=
500
kbps
,


R2
=
2
Mbps
y
R3
=
1
Mbps
.


a.
Suponiendo
que
no
hay
tr√°fico
en
la
red
,
¬ø
cu√°l
es
la
tasa
de
transferencia
para
el


archivo
?


b.
Suponga
que
el
tama√±o
del
archivo
es
de
4
millones
de
bytes
.
Dividiendo
el
tama√±o


del
archivo
entre
la
tasa
de
transferencia
,
¬ø
cu√°nto
tiempo
tardar√°
aproximadamente


en
transferirse
el
archivo
al
host
B
?


c.
Repita
los
apartados
(
a
)
y
(
b
)
,
pero
ahora
con
R2
igual
a
100
kbps
.


R20
.
Suponga
que
el
sistema
terminal
A
desea
enviar
un
archivo
de
gran
tama√±o
al
sistema


terminal
B.
Sin
entrar
en
detalles
,
describa
c√≥mo
crea
el
sistema
terminal
A
los
paque-


tes
a
partir
del
archivo
.
Cuando
uno
de
estos
paquetes
llega
a
un
conmutador
de
pa-


quetes
,
¬ø
qu√©
informaci√≥n
del
mismo
utiliza
el
conmutador
para
determinar
el
enlace


por
el
que
debe
ser
reenviado
el
paquete
?
¬ø
Por
qu√©
la
conmutaci√≥n
de
paquetes
en


Internet
es
an√°loga
a
viajar
de
una
ciudad
a
otra
preguntando
por
la
direcci√≥n
a
la
que


nos
dirigimos
?


R21
.
V
isite
el
applet
Queuing
and
Loss
(
colas
y
p√©rdida
de
paquetes
)
en
el
sitio
web
del


libro
.
¬ø
Cu√°les
son
las
velocidades
de
transmisi√≥n
m√°xima
y
m√≠nima
?
Para
esas
veloci-


dades
,
¬ø
cu√°l
es
la
intensidad
de
tr√°fico
?
Ejecute
el
applet
con
esas
velocidades
y
deter-


mine
cu√°nto
tiempo
tiene
que
transcurrir
para
que
tenga
lugar
una
p√©rdida
de
paquetes
.


Ac
o
n
t
i
n
u
a
c
i
√≥
n
,
 
r
e
p
i
t
a
 
e
l
 
e
x
p
e
r
i
m
e
n
t
o
 
u
n
a
 
s
e
g
u
n
d
a
 
v
e
z
 
y
 
d
e
t
e
r
m
i
n
e
 
d
e
 
n
u
e
v
o
 
c
u
√°
n
t
o


68
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
68tiempo
pasa
hasta
producirse
una
p√©rdida
de
paquetes
.
¬ø
Son
diferentes
los
valores


obtenidos
?
¬ø
Por
qu√©
?


SECCI√ìN
1.5


R22
.
Enumere
cinco
tareas
que
puede
realizar
una
capa
.
¬ø
Es
posible
que
una
(
o
m√°s
)
de


estas
tareas
pudieran
ser
realizadas
por
dos
(
o
m√°s
)
capas
?


R23
.
¬ø
Cu√°les
son
las
cinco
capas
de
la
pila
de
protocolos
Internet
?
¬ø
Cu√°les
son
las
respon-


sabilidades
principales
de
cada
una
de
estas
capas
?


R24
.
¬ø
Qu√©
es
un
mensaje
de
la
capa
de
aplicaci√≥n
?
¬ø
Y
un
segmento
de
la
capa
de
trans-


porte
?
¬ø
Y
un
datagrama
de
la
capa
de
red
?
¬ø
Y
una
trama
de
la
capa
de
enlace
?


R25
.
¬ø
Qu√©
capas
de
la
pila
de
protocolos
de
Internet
procesa
un
router
?
¬ø
Qu√©
capas
procesa


un
switch
de
la
capa
de
enlace
?
¬ø
Qu√©
capas
procesa
un
host
?


SECCI√ìN
1.6


R26
.
¬ø
Cu√°l
es
la
diferencia
entre
un
virus
,
un
gusano
y
un
caballo
de
Troya
?


R27
.
Describa
c√≥mo
puede
crearse
una
red
robot
(
botnet
)
y
c√≥mo
se
puede
utilizar
en
un


ataque
DDoS.


R28
.
Suponga
que
Alicia
y
Benito
est√°n
envi√°ndose
paquetes
entre
s√≠
a
trav√©s
de
una
red
.


Imagine
que
Victoria
se
introduce
en
la
red
de
modo
que
puede
capturar
todos
los


paquetes
enviados
por
Alicia
y
que
luego
env√≠a
lo
que
ella
quiere
a
Benito
.
Adem√°s
,


tambi√©n
puede
capturar
todos
los
paquetes
enviados
por
Benito
y
luego
enviar
a
Ali-


cia
lo
que
le
parezca
.
Enumere
algunos
de
los
da√±os
que
Victoria
puede
ocasionar


desde
su
posici√≥n
.


Problemas


P1
.
Dise√±e
y
describa
un
protocolo
de
nivel
de
aplicaci√≥n
que
ser√°
utilizado
entre
un


cajero
autom√°tico
y
la
computadora
central
de
un
banco
.
El
protocolo
deber√°
permitir


verificar
la
tarjeta
y
la
contrase√±a
del
usuario
,
consultar
el
saldo
de
la
cuenta
(
que
se


almacena
en
la
computadora
central
)
y
hacer
un
apunte
en
la
cuenta
por
la
cantidad


retirada
por
el
usuario
.
Las
entidades
del
protocolo
deben
poder
controlar
todos
los


casos
en
los
que
no
hay
suficiente
saldo
en
la
cuenta
como
para
cubrir
el
reembolso
.


Especifique
el
protocolo
enumerando
los
mensajes
intercambiados
y
las
acciones
rea-


lizadas
por
el
cajero
autom√°tico
o
la
computadora
central
del
banco
al
transmitir
y


recibir
mensajes
.
Haga
un
boceto
del
funcionamiento
del
protocolo
para
el
caso
de
una


retirada
de
efectivo
sin
errores
,
utilizando
un
diagrama
similar
al
mostrado
en
la


Figura
1.2
.
Establezca
expl√≠citamente
las
suposiciones
hechas
por
el
protocolo
acerca


del
servicio
de
transporte
terminal
a
terminal
subyacente
.


P2
.
Considere
una
aplicaci√≥n
que
transmite
datos
a
una
velocidad
constante
(
por
ejemplo
,


el
emisor
genera
una
unidad
de
datos
de
N
bits
cada
k
unidades
de
tiempo
,
donde
k
es


un
valor
peque√±o
y
fijo
)
.
Adem√°s
,
cuando
esta
aplicaci√≥n
se
inicia
,
se
ejecutar√°


durante
un
periodo
de
tiempo
relativamente
largo
.
Responda
a
las
siguientes
cuestio-


nes
de
forma
breve
y
justificando
su
respuesta
:


PROBLEMAS
69


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
69a
.
¬ø
Qu√©
ser√≠a
m√°s
apropiado
para
esta
aplicaci√≥n
,
una
red
de
conmutaci√≥n
de
circui-


tos
o
una
red
de
conmutaci√≥n
de
paquetes
?
¬ø
Por
qu√©
?


b.
Suponga
que
se
utiliza
una
red
de
conmutaci√≥n
de
paquetes
y
el
√∫nico
tr√°fico
que


existe
en
la
misma
procede
de
la
aplicaci√≥n
que
acabamos
de
describir
.
Adem√°s
,


suponga
que
la
suma
de
las
velocidades
de
datos
de
la
aplicaci√≥n
es
menor
que
las


capacidades
de
cada
uno
de
los
enlaces
.
¬ø
Ser√°
necesario
alg√∫n
mecanismo
de
con-


trol
de
congesti√≥n
?
¬ø
Por
qu√©
?


P3
.
Considere
la
red
de
conmutaci√≥n
de
circuitos
de
la
Figura
1.12
.
Recuerde
que
hay
n


circuitos
en
cada
enlace
.


a.
¬ø
Cu√°l
es
el
n√∫mero
m√°ximo
de
conexiones
simult√°neas
que
pueden
estar
en
curso


en
un
determinado
instante
de
tiempo
en
esta
red
?


b.
Suponga
que
todas
las
conexiones
se
encuentran
entre
el
dispositivo
de
conmuta-


ci√≥n
de
la
esquina
superior
izquierda
y
el
dispositivo
de
conmutaci√≥n
de
la
esquina


inferior
derecha
.
¬ø
Cu√°l
ser√°
el
n√∫mero
m√°ximo
de
conexiones
que
puede
haber
en


curso
?


P4
.
Repase
la
analog√≠a
de
la
caravana
de
coches
de
la
Secci√≥n
1.4
.
Suponga
una
velocidad


de
propagaci√≥n
de
100
km
/
hora
.


a.
Suponga
que
la
caravana
se
mueve
a
una
velocidad
de
150
km
,
partiendo
de
la


caseta
de
peaje
,
pasando
por
una
segunda
caseta
de
peaje
y
deteni√©ndose
justo
des-


pu√©s
de
la
tercera
caseta
de
peaje
.
¬ø
Cu√°l
es
el
retardo
terminal
a
terminal
?


b.
Repita
el
apartado
(
a
)
suponiendo
ahora
que
en
la
caravana
hay
ocho
coches
en


lugar
de
diez
.


P5
.
En
este
problema
se
exploran
los
retardos
de
propagaci√≥n
y
de
transmisi√≥n
,
dos
con-


ceptos
fundamentales
en
las
redes
de
datos
.
Considere
dos
hosts
,
A
y
B
,
conectados


por
un
enlace
cuya
velocidad
es
de
R
bps
.
Suponga
que
los
dos
hosts
est√°n
separados


m
metros
y
que
la
velocidad
de
propagaci√≥n
a
lo
largo
del
enlace
es
igual
a
s


metros
/
segundo
.
El
host
A
env√≠a
un
paquete
de
tama√±o
L
bits
al
host
B.


a.
Exprese
el
retardo
de
propagaci√≥n
,
dprop
,
en
funci√≥n
de
m
y
s.


b.
Determine
el
tiempo
de
transmisi√≥n
del
paquete
,
dtrans
,
en
funci√≥n
de
L
y
R.


c.
Ignorando
los
retardos
de
procesamiento
y
de
cola
,
obtenga
una
expresi√≥n
para
el


retardo
terminal
a
terminal
.


d.
Suponga
que
el
host
A
comienza
a
transmitir
el
paquete
en
el
instante
t
=
0
.
En
el
ins-


tante
t
=
dtrans
,
¬ø
d√≥nde
estar√°
el
√∫ltimo
bit
del
paquete
?


e.
Suponga
que
dprop
es
mayor
que
dtrans
.
En
el
instante
t
=
dtrans
,
¬ø
d√≥nde
estar√°
el
pri-


mer
bit
del
paquete
?


f.
Suponga
que
dprop
es
menor
que
dtrans
.
En
el
instante
t
=
dtrans
,
¬ø
d√≥nde
estar√°
el
pri-


mer
bit
del
paquete
?


g.
Suponga
que
s
=
2,5
¬∑
10
8
metros
/
segundo
,
L
=
120
bits
y
R
=
56
kbps
.
Determine


la
distancia
m
de
modo
que
dprop
sea
igual
a
dtrans
.


P6
.
En
este
problema
vamos
a
considerar
la
transmisi√≥n
de
voz
en
tiempo
real
desde
el


host
A
al
host
B
a
trav√©s
de
una
red
de
conmutaci√≥n
de
paquetes
(
V
oIP
)
.
El
host
A
con-


vierte
sobre
la
marcha
la
voz
anal√≥gica
en
un
flujo
de
bits
digital
a
64
kbps
.
A
conti-


nuaci√≥n
,
el
host
A
agrupa
los
bits
en
paquetes
de
56
bytes
.
Entre
el
host
A
y
el
host
B


existe
un
enlace
,
cuya
velocidad
de
transmisi√≥n
es
de
2
Mbps
y
su
retardo
de
propaga-


70
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
70ci√≥n
es
igual
a
10
milisegundos
.
Tan
pronto
como
el
host
A
forma
un
paquete
,
lo
env√≠a


al
host
B.
Cuando
el
host
B
recibe
un
paquete
completo
,
convierte
los
bits
del
paquete


en
una
se√±al
anal√≥gica
.
¬ø
Cu√°nto
tiempo
transcurre
desde
el
momento
en
que
se
crea


un
bit
(
a
partir
de
la
se√±al
anal√≥gica
en
el
host
A
)
hasta
que
se
decodifica
(
como
parte


de
la
se√±al
anal√≥gica
en
el
host
B
)
?


P7
.
Suponga
que
varios
usuarios
comparten
un
enlace
de
3
Mbps
.
Suponga
tambi√©n
que


cada
usuario
requiere
150
kbps
para
transmitir
y
que
s√≥lo
transmite
durante
el
10
por


ciento
del
tiempo
.
(
V√©ase
la
explicaci√≥n
sobre
la
multiplexaci√≥n
estad√≠stica
de
la
Sec-


ci√≥n
1.3
.
)


a.
Si
se
utiliza
la
conmutaci√≥n
de
circuitos
,
¬ø
a
cu√°ntos
usuarios
puede
darse
soporte
?


b.
Para
el
resto
de
este
problema
,
suponga
que
se
utiliza
una
red
de
conmutaci√≥n
de


paquetes
.
Halle
la
probabilidad
de
que
un
determinado
usuario
est√©
transmitiendo
.


c.
Suponga
que
hay
120
usuarios
.
Determine
la
probabilidad
de
que
en
un
instante


determinado
haya
exactamente
n
usuarios
transmitiendo
simult√°neamente
.
(
Suge-


rencia
:
utilice
la
distribuci√≥n
binomial
.
)


d.
Calcule
la
probabilidad
de
que
haya
21
o
m√°s
usuarios
transmitiendo
simult√°nea-


mente
.


P8
.
Consulte
la
explicaci√≥n
acerca
de
la
multiplexaci√≥n
estad√≠stica
de
la
Secci√≥n
1.3
,
en
la


que
se
proporciona
un
ejemplo
con
un
enlace
a
1
Mbps
.
Los
usuarios
est√°n
generando


datos
a
una
velocidad
de
100
kbps
cuando
est√°n
ocupados
,
pero
s√≥lo
lo
est√°n
con


una
probabilidad
de
p
=
0,1
.
Suponga
que
el
enlace
a
1
Mbps
se
sustituye
por
un


enlace
a
1
Gbps
.


a.
¬ø
Cu√°l
es
el
valor
de
N
,
el
n√∫mero
m√°ximo
de
usuarios
a
los
que
se
les
puede
dar


soporte
simult√°neamente
,
cuando
se
emplea
una
red
de
conmutaci√≥n
de
circuitos
?


b.
Considere
ahora
que
se
utiliza
una
red
conmutaci√≥n
de
paquetes
y
que
el
n√∫mero


de
usuarios
es
M.
Proporcione
una
f√≥rmula
(
en
funci√≥n
de
p
,
M
,
N
)
para
determinar


la
probabilidad
de
que
m√°s
de
N
usuarios
est√©n
enviando
datos
.


P9
.
Considere
un
paquete
de
longitud
L
que
tiene
su
origen
en
el
sistema
terminal
A
y


que
viaja
a
trav√©s
de
tres
enlaces
hasta
un
sistema
terminal
de
destino
.
Estos
tres


enlaces
est√°n
conectados
mediante
dos
dispositivos
de
conmutaci√≥n
de
paquetes
.


Sean
di
,
si
y
Ri
la
longitud
,
la
velocidad
de
propagaci√≥n
y
la
velocidad
de
transmi-


si√≥n
del
enlace
i
,
para
i
=
1
,
2
,
3
.
El
dispositivo
de
conmutaci√≥n
de
paquetes
retarda


cada
paquete
dproc
.
Suponiendo
que
no
se
produce
retardo
de
cola
,
¬ø
cu√°l
es
el
retardo


total
terminal
a
terminal
del
paquete
en
funci√≥n
de
di
,
si
,
Ri
,
(
i
=
1
,
2
,
3
)
y
L
?
Suponga


ahora
que
la
longitud
del
paquete
es
de
1.500
bytes
,
la
velocidad
de
propagaci√≥n
en


ambos
enlaces
es
igual
a
2,5
¬∑
10
8
m
/
s
,
la
velocidad
de
transmisi√≥n
en
los
tres
enla-


ces
es
de
2
Mbps
,
el
retardo
de
procesamiento
en
el
conmutador
de
paquetes
es
de
3


milisegundos
,
la
longitud
del
primer
enlace
es
de
5.000
km
,
la
del
segundo
de
4.000


km
y
la
del
√∫ltimo
enlace
es
de
1.000
km
.
Para
estos
valores
,
¬ø
cu√°l
es
el
retardo
ter-


minal
a
terminal
?


P10
.
En
el
problema
anterior
,
suponga
que
R1
=
R2
=
R3
=
R
y
dproc
=
0
.
Suponga
tambi√©n


que
el
conmutador
de
paquetes
no
almacena
los
paquetes
y
los
reenv√≠a
,
sino
que
trans-


mite
inmediatamente
cada
bit
que
recibe
sin
esperar
a
que
llegue
el
paquete
completo
.


¬ø
Cu√°l
ser√°
el
retardo
terminal
a
terminal
?


PROBLEMAS
71


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
71P11
.
Un
conmutador
de
paquetes
recibe
un
paquete
y
determina
el
enlace
saliente
por
el
que


deber√°
ser
reenviado
.
Cuando
el
paquete
llega
,
hay
otro
paquete
ya
transmitido
hasta


la
mitad
por
el
mismo
enlace
de
salida
y
adem√°s
hay
otros
cuatro
paquetes
esperando


para
ser
transmitidos
.
Los
paquetes
se
transmiten
seg√∫n
el
orden
de
llegada
.
Suponga


que
todos
los
paquetes
tienen
una
longitud
de
1.500
bytes
y
que
la
velocidad
del
enlace


es
de
2
Mbps
.
¬ø
Cu√°l
es
el
retardo
de
cola
para
el
paquete
?
En
sentido
m√°s
general
,


¬ø
cu√°l
es
el
retardo
de
cola
cuando
todos
los
paquetes
tienen
una
longitud
L
,
la
veloci-


dad
de
transmisi√≥n
es
R
,
x
bits
del
paquete
que
se
est√°
transmitiendo
actualmente
ya


han
sido
transmitidos
y
hay
n
paquetes
en
la
cola
esperando
a
ser
transmitidos
?


P12
.
Suponga
que
N
paquetes
llegan
simult√°neamente
a
un
enlace
en
el
que
actualmente
no


se
est√°
transmitiendo
ning√∫n
paquete
ni
tampoco
hay
ning√∫n
paquete
en
cola
.
Cada


paquete
tiene
una
longitud
L
y
el
enlace
tiene
una
velocidad
de
transmisi√≥n
R.
¬ø
Cu√°l


es
el
retardo
medio
de
cola
para
los
N
paquetes
?


P13
.
Considere
el
retardo
de
cola
en
el
buffer
de
un
router
(
que
precede
a
un
enlace
de


salida
)
.
Suponga
que
todos
los
paquetes
tienen
L
bits
,
que
la
velocidad
de
transmisi√≥n


es
R
bps
y
que
llegan
simult√°neamente
N
paquetes
al
buffer
cada
LN
/
R
segundos
.


Calcule
el
retardo
medio
de
cola
de
un
paquete
.
(
Sugerencia
:
el
retardo
de
cola
para
el


primer
paquete
es
igual
a
cero
;
para
el
segundo
paquete
es
L
/
R;p
a
r
a
 
e
l
 
t
e
r
c
e
r
oe
s
 
2L
/
R.


El
paquete
N
ya
habr√°
sido
transmitido
cuando
el
segundo
lote
de
paquetes
llegue
.
)


P14
.
Considere
el
retardo
de
cola
en
el
buffer
de
un
router
.
Sea
I
la
intensidad
de
tr√°fico
;
es


decir
,
I
=
La
/
R.
Suponga
que
el
retardo
de
cola
puede
expresarse
como
IL
/
R
(
1
‚Äì
I
)


para
I
<
1
.


a.
Determine
una
f√≥rmula
para
calcular
el
retardo
total
,
es
decir
,
el
retardo
de
cola


m√°s
el
retardo
de
transmisi√≥n
.


b.
Dibuje
el
retardo
total
en
funci√≥n
de
L
/
R.


P15
.
Sea
a
la
velocidad
de
llegada
de
los
paquetes
a
un
enlace
en
paquetes
/
segundo
y
sea
¬µ


la
velocidad
de
transmisi√≥n
del
enlace
en
paquetes
/
segundo
.
Bas√°ndose
en
la
f√≥rmula


del
retardo
total
(
es
decir
,
el
retardo
de
cola
m√°s
el
retardo
de
transmisi√≥n
)
obtenida
en


el
problema
anterior
,
deduzca
una
f√≥rmula
para
el
retardo
total
en
funci√≥n
de
a
y
¬µ.
  

P16
.
Considere
el
buffer
de
un
router
que
precede
a
un
enlace
de
salida
.
En
este
problema


utilizaremos
la
f√≥rmula
de
Little
,
una
f√≥rmula
famosa
en
la
teor√≠a
de
colas
.
Sea
N
el


n√∫mero
medio
de
paquetes
que
hay
en
el
buffer
m√°s
el
paquete
que
est√°
siendo
trans-


mitido
.
Sea
a
la
velocidad
a
la
que
los
paquetes
llegan
al
enlace
.
Sea
d
el
retardo
medio


total
(
es
decir
,
el
retardo
de
cola
m√°s
el
retardo
de
transmisi√≥n
)
experimentado
por
un


paquete
.
La
f√≥rmula
de
Little
es
N
=
a
¬∑
d.
Suponga
que
como
media
,
el
buffer
contiene


10
paquetes
y
que
el
retardo
medio
de
cola
de
un
paquete
es
igual
a
10
milisegundos
.


La
velocidad
de
transmisi√≥n
del
enlace
es
igual
a
100
paquetes
/
segundo
.
Utilizando
la


f√≥rmula
de
Little
,
¬ø
cu√°l
es
la
velocidad
media
de
llegada
de
los
paquetes
suponiendo


que
no
se
produce
p√©rdida
de
paquetes
?


P17
.
a.
Generalice
la
f√≥rmula
del
retardo
terminal
a
terminal
dada
en
la
Secci√≥n
1.4.3
para


velocidades
de
procesamiento
,
velocidades
de
transmisi√≥n
y
retardos
de
propaga-


ci√≥n
heterog√©neos
.


b.
Repita
el
apartado
(
a
)
,
pero
suponiendo
ahora
que
existe
un
retardo
medio
de
cola


dcola
en
cada
nodo
.


72
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
72P18
.
Realice
un
trazado
de
la
ruta
(
Traceroute
)
entre
un
origen
y
un
destino
situados
en
un


mismo
continente
para
tres
horas
del
d√≠a
diferentes
.


a.
Determine
la
media
y
la
desviaci√≥n
est√°ndar
de
los
retardos
de
ida
y
vuelta
para


cada
una
de
las
horas
.


b.
Determine
el
n√∫mero
de
routers
existente
en
la
ruta
para
cada
una
de
las
horas
.
¬ø
Ha


variado
la
ruta
para
alguna
de
las
horas
?


c.
Intente
identificar
el
n√∫mero
de
redes
de
ISP
que
los
paquetes
de
Traceroute
atra-


viesan
desde
el
origen
hasta
el
destino
.
Los
routers
con
nombres
similares
y
/
o


direcciones
IP
similares
deben
considerarse
como
parte
del
mismo
ISP
.
En
sus


experimentos
,
¬ø
los
retardos
m√°s
largos
se
producen
en
las
interfaces
situadas
entre


proveedores
ISP
adyacentes
?


d.
Repita
el
apartado
anterior
para
un
origen
y
un
destino
situados
en
diferentes
conti-


nentes
.
Compare
los
resultados
para
ubicaciones
en
un
mismo
continente
y
en
dis-


tintos
continentes
.


P19
.
Considere
el
ejemplo
sobre
la
tasa
de
transferencia
correspondiente
a
la
Figura


1.20(b
)
.
Suponga
que
hay
M
parejas
cliente-servidor
en
lugar
de
10
.
Sean
Rs
,
Rc
y
R


las
velocidades
de
los
enlaces
de
servidor
,
de
los
enlaces
de
cliente
y
del
enlace
de
red
.


Suponga
que
todos
los
enlaces
tienen
la
capacidad
suficiente
y
que
no
existe
otro
tr√°-


fico
en
la
red
que
el
generado
por
las
M
parejas
cliente-servidor
.
Deduzca
una
expre-


si√≥n
general
para
la
tasa
de
transferencia
en
funci√≥n
de
Rs
,
Rc
,
R
,
y
M.


P20
.
Considere
la
Figura
1.19(b
)
.
Suponga
que
existen
M
rutas
entre
el
servidor
y
el
cliente
.


No
hay
dos
rutas
que
compartan
ning√∫n
enlace
.
La
ruta
k
(
k
=
1
,
.
.
.
,
M
)
consta
de
N


enlaces
con
velocidades
de
transmisi√≥n
iguales
a
Rk


1
,
Rk


2
,
.
.
.
,
Rk


N.
Si
el
servidor
s√≥lo


puede
utilizar
una
ruta
para
enviar
datos
al
cliente
,
¬ø
cu√°l
ser√°
la
m√°xima
tasa
de
trans-


ferencia
que
puede
alcanzar
dicho
servidor
?
Si
el
servidor
puede
emplear
las
M
rutas


para
enviar
datos
,
¬ø
cu√°l
ser√°
la
m√°xima
tasa
de
transferencia
que
puede
alcanzar
el
ser-


vidor
?


P21
.
Considere
la
Figura
1.19(b
)
.
Suponga
que
cada
enlace
entre
el
servidor
y
el
cliente


tiene
una
probabilidad
de
p√©rdida
de
paquetes
p
y
que
las
probabilidades
de
p√©rdida


de
paquetes
de
estos
enlaces
son
independientes
.
¬ø
Cu√°l
es
la
probabilidad
de
que
un


paquete
(
enviado
por
el
servidor
)
sea
recibido
correctamente
por
el
receptor
?
Si
un


paquete
se
pierde
en
el
camino
que
va
desde
el
servidor
hasta
el
cliente
,
entonces
el


servidor
volver√°
a
transmitir
el
paquete
.
Como
media
,
¬ø
cu√°ntas
veces
tendr√°
que


retransmitir
el
paquete
el
servidor
para
que
el
cliente
lo
reciba
correctamente
?


P22
.
Considere
la
Figura
1.19(a
)
.
Suponga
que
sabemos
que
el
enlace
cuello
de
botella
a
lo


largo
de
la
ruta
entre
el
servidor
y
el
cliente
es
el
primer
enlace
,
cuya
velocidad
es
Rs


bits
/
segundo
.
Suponga
que
env√≠amos
un
par
de
paquetes
uno
tras
otro
desde
el
servi-


dor
al
cliente
y
que
no
hay
m√°s
tr√°fico
que
ese
en
la
ruta
.
Suponga
que
cada
paquete


tiene
un
tama√±o
de
L
bits
y
que
ambos
enlaces
presentan
el
mismo
retardo
de
propa-


gaci√≥n
dprop
.


a.
¬ø
Cu√°l
es
el
periodo
entre
llegadas
de
paquetes
al
destino
?
Es
decir
,
¬ø
cu√°nto
tiempo


transcurre
desde
que
el
√∫ltimo
bit
del
primer
paquete
llega
hasta
que
lo
hace
el


√∫ltimo
bit
del
segundo
paquete
?


b.
Suponga
ahora
que
el
enlace
cuello
de
botella
es
el
segundo
enlace
(
es
decir
,
Rc
<


Rs
)
.
¬ø
Es
posible
que
el
segundo
paquete
tenga
que
esperar
en
la
cola
de
entrada
del


PROBLEMAS
73


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
73segundo
enlace
?
Explique
su
respuesta
.
Suponga
ahora
que
el
servidor
env√≠a
el


segundo
paquete
T
segundos
despu√©s
de
enviar
el
primero
.
¬ø
Qu√©
valor
debe
tener


T
para
garantizar
que
el
segundo
paquete
no
tenga
que
esperar
en
la
cola
de
entrada


del
segundo
enlace
?
Explique
su
respuesta
.


P23
.
Suponga
que
necesita
enviar
de
forma
urgente
40
terabytes
de
datos
de
Boston
a
Los


√Ångeles
.
Dispone
de
un
enlace
dedicado
a
100
Mbps
para
transferencia
de
datos
.
¬ø
Qu√©


preferir√≠a
,
transmitir
los
datos
a
trav√©s
del
enlace
o
utilizar
FedEx
para
hacer
el
env√≠o


por
la
noche
?
Explique
su
respuesta
.
 

P24
.
Se
tienen
dos
hosts
,
A
y
B
,
separados
20.000
kil√≥metros
y
conectados
mediante
un


enlace
directo
con
R
=
2
Mbps
.
Suponga
que
la
velocidad
de
propagaci√≥n
por
el
enlace


es
igual
a
2,5
 
108
metros
/
segundo
.


a.
Calcule
el
producto
ancho
de
banda-retardo
,
R
 
dprop
.


b.
Se
env√≠a
un
archivo
cuyo
tama√±o
es
de
800.000
bits
desde
el
host
A
al
host
B.


Suponga
que
el
archivo
se
env√≠a
de
forma
continua
como
un
mensaje
de
gran


tama√±o
.
¬ø
Cu√°l
es
el
n√∫mero
m√°ximo
de
bits
que
habr√°
en
el
enlace
en
un
instante


de
tiempo
determinado
?


c.
Haga
una
interpretaci√≥n
del
producto
ancho
de
banda-retardo
.


d.
¬ø
Cu√°l
es
el
ancho
(
en
metros
)
de
un
bit
dentro
del
enlace
?
¬ø
Es
m√°s
grande
que
un


campo
de
f√∫tbol
?


e.
Deduzca
una
expresi√≥n
general
para
la
anchura
de
un
bit
en
funci√≥n
de
la
veloci-


dad
de
propagaci√≥n
s
,
la
velocidad
de
transmisi√≥n
R
y
la
longitud
del
enlace
m.


P25
.
Continuando
con
el
Problema
P24
,
suponga
que
podemos
modificar
R.
¬ø
Para
qu√©


valor
de
R
es
el
ancho
de
un
bit
tan
grande
como
la
longitud
del
enlace
?


P26
.
Considere
el
Problema
P24
pero
ahora
para
un
enlace
con
R
=
1
Gbps
.


a.
Calcule
el
producto
ancho
de
banda-retardo
,
R
 
dprop
.


b.
Considere
el
env√≠o
de
un
archivo
de
800.000
bits
desde
el
host
A
al
host
B.


Suponga
que
el
archivo
se
env√≠a
de
forma
continua
como
si
fuera
un
mensaje
de


gran
tama√±o
.
¬ø
Cu√°l
es
el
n√∫mero
m√°ximo
de
bits
que
puede
haber
en
el
enlace
en


cualquier
instante
de
tiempo
dado
?


c.
¬ø
Cu√°l
es
el
ancho
(
en
metros
)
de
un
bit
dentro
del
enlace
?


P27
.
Haciendo
referencia
de
nuevo
al
problema
P24
.


a.
¬ø
Cu√°nto
tiempo
tarda
en
enviarse
el
archivo
suponiendo
que
se
env√≠a
de
forma
con-


tinua
?


b.
Suponga
ahora
que
el
archivo
se
divide
en
20
paquetes
conteniendo
cada
uno
de


ellos
40.000
bits
.
Suponga
tambi√©n
que
el
receptor
confirma
la
recepci√≥n
de
cada


paquete
y
que
el
tiempo
de
transmisi√≥n
de
un
paquete
de
confirmaci√≥n
es
despre-


ciable
.
Por
√∫ltimo
,
suponga
que
el
emisor
no
puede
transmitir
un
paquete
hasta
que


el
anterior
haya
sido
confirmado
.
¬ø
Cu√°nto
tiempo
se
tardar√°
en
enviar
el
archivo
?


c.
Compare
los
resultados
obtenidos
en
los
apartados
(
a
)
y
(
b
)
.


P28
.
Suponga
que
existe
un
enlace
de
microondas
a
10
Mbps
entre
un
sat√©lite
geoestaciona-


rio
y
su
estaci√≥n
base
en
la
Tierra
.
El
sat√©lite
toma
una
fotograf√≠a
digital
por
minuto
y


la
env√≠a
a
la
estaci√≥n
base
.
La
velocidad
de
propagaci√≥n
es
2,4
 
108
metros
/
segundo
.


a.
¬ø
Cu√°l
es
el
retardo
de
propagaci√≥n
del
enlace
?


74
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
74b
.
¬ø
Cu√°l
es
el
producto
ancho
de
banda-retardo
,
R
¬∑
dprop
?


c.
Sea
x
el
tama√±o
de
la
fotograf√≠a
.
¬ø
Cu√°l
es
el
valor
m√≠nimo
de
x
para
que
el
enlace


de
microondas
est√©
transmitiendo
continuamente
?


P29
.
Considere
la
analog√≠a
de
la
compa√±√≠a
a√©rea
utilizada
en
la
Secci√≥n
1.5
dedicada
a
las


capas
y
la
adici√≥n
de
cabeceras
a
las
unidades
de
datos
del
protocolo
a
medida
que
flu-


yen
en
sentido
descendente
por
la
pila
de
protocolos
.
¬ø
Existe
alg√∫n
concepto
equiva-


lente
a
la
informaci√≥n
de
cabecera
que
pueda
a√±adirse
a
los
pasajeros
y
al
equipaje
a


medida
que
descienden
por
la
pila
de
protocolos
de
la
compa√±√≠a
a√©rea
?


P30
.
En
las
redes
de
conmutaci√≥n
de
paquetes
modernas
,
el
host
de
origen
segmenta
los


mensajes
largos
de
la
capa
de
aplicaci√≥n
(
por
ejemplo
,
una
imagen
o
un
archivo
de


m√∫sica
)
en
paquetes
m√°s
peque√±os
y
los
env√≠a
a
la
red
.
Despu√©s
,
el
receptor
ensambla


los
paquetes
para
formar
el
paquete
original
.
Este
proceso
se
conoce
como


segmentaci√≥n
de
mensajes
.
La
Figura
1.28
ilustra
el
transporte
terminal
a
terminal
de


un
mensaje
con
y
sin
segmentaci√≥n
del
mensaje
.
Imagine
que
se
env√≠a
un
mensaje


cuya
longitud
es
de
8
¬∑
10
6
bits
desde
el
origen
hasta
el
destino
mostrados
en
la
Figura


1.28
.
Suponga
que
cada
enlace
de
los
mostrados
en
la
figura
son
enlaces
a
2
Mbps
.


Ignore
los
retardos
de
propagaci√≥n
,
de
cola
y
de
procesamiento
.


a.
Suponga
que
el
mensaje
se
transmite
desde
el
origen
al
destino
sin
segmentarlo
.


¬ø
Cu√°nto
tiempo
tarda
el
mensaje
en
desplazarse
desde
el
origen
hasta
el
primer


conmutador
de
paquetes
?
Teniendo
en
cuenta
que
cada
conmutador
de
paquetes


utiliza
el
m√©todo
de
conmutaci√≥n
de
almacenamiento
y
reenv√≠o
,
¬ø
cu√°l
el
tiempo


total
que
invierte
el
mensaje
para
ir
desde
el
host
de
origen
hasta
el
host
de
des-


tino
?


b.
Suponga
ahora
que
el
mensaje
se
segmenta
en
4.000
paquetes
y
que
la
longitud
de


cada
paquete
es
de
2.000
bits
.
¬ø
Cu√°nto
tiempo
tarda
el
primer
paquete
en
transmi-


tirse
desde
el
origen
hasta
el
primer
conmutador
de
paquetes
?
Cuando
se
est√°


enviando
el
primer
paquete
del
primer
conmutador
al
segundo
,
el
host
de
origen


env√≠a
un
segundo
paquete
al
primer
conmutador
de
paquetes
.
¬ø
En
qu√©
instante
de


tiempo
habr√°
recibido
el
primer
conmutador
el
segundo
paquete
completo
?


Figura
1.28
‚Ä¢
Transporte
de
mensajes
terminal
a
terminal
:
(
a
)
sin
segmentaci√≥n


de
mensajes
;
(
b
)
con
segmentaci√≥n
de
mensajes
.


Origenb
.
Conmutador


de
paquetes


Paquete


Conmutador


de
paquetes


Destino


Origena
.
Conmutador


de
paquetes


Conmutador


de
paquetes


Destino


Mensaje


PROBLEMAS
75


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
75c
.
¬ø
Cu√°nto
tiempo
tarda
en
transmitirse
el
archivo
desde
el
host
de
origen
al
host
de


destino
cuando
se
emplea
la
segmentaci√≥n
de
mensajes
?
Compare
este
resultado


con
la
respuesta
del
apartado
(
a
)
y
com√©ntelo
.


d.
Comente
los
inconvenientes
de
la
segmentaci√≥n
de
mensajes
.


P31
.
Experimente
con
la
applet
Message
Segmentation
(
segmentaci√≥n
de
mensajes
)
dispo-


nible
en
el
sitio
web
del
libro
.
¬ø
Se
corresponden
los
retardos
indicados
en
el
applet
con


los
retardos
del
problema
anterior
?
¬ø
C√≥mo
afectan
los
retardos
de
propagaci√≥n
del


enlace
al
retardo
global
terminal
a
terminal
de
la
conmutaci√≥n
de
paquetes
(
con
seg-


mentaci√≥n
de
mensajes
)
y
de
la
conmutaci√≥n
de
mensajes
?


P32
.
Se
env√≠a
un
archivo
de
gran
tama√±o
de
F
bits
desde
el
host
A
al
host
B.
Entre
los
hosts
A


y
B
hay
tres
enlaces
(
y
dos
dispositivos
de
conmutaci√≥n
)
y
los
enlaces
no
est√°n
conges-


tionados
(
es
decir
,
no
existen
retardos
de
cola
)
.
El
host
A
divide
el
archivo
en
segmen-


tos
de
S
bits
y
a√±ade
80
bits
de
cabecera
a
cada
segmento
,
formando
paquetes
de
L
=
80


+
S
bits
.
La
velocidad
de
transmisi√≥n
de
cada
enlace
es
de
R
bps
.
Calcule
el
valor
de
S


que
minimiza
el
retardo
al
transmitir
el
archivo
desde
el
host
A
al
host
B.
No
tenga
en


cuenta
el
retardo
de
propagaci√≥n
.


Preguntas
para
la
discusi√≥n


D1
.
¬ø
Qu√©
tipos
de
servicios
inal√°mbricos
m√≥viles
hay
disponibles
en
la
regi√≥n
donde
vive
?


D2
.
Utilizando
la
tecnolog√≠a
LAN
inal√°mbrica
802.11
,
dise√±e
una
red
dom√©stica
para
su


casa
o
la
de
sus
padres
.
Enumere
los
modelos
espec√≠ficos
de
los
productos
,
as√≠
como


los
costes
correspondientes
de
su
red
dom√©stica
.


D3
.
Describa
los
servicios
Skype
de
PC
a
PC
.
Pruebe
el
servicio
de
v√≠deo
de
Skype
de
PC


a
PC
y
redacte
un
informe
narrando
la
experiencia
.


D4
.
Skype
ofrece
un
servicio
que
permite
realizar
una
llamada
telef√≥nica
desde
un
PC
a


un
tel√©fono
tradicional
.
Esto
significa
que
la
llamada
de
voz
debe
pasar
por
Internet
y


una
red
telef√≥nica
.
Explique
c√≥mo
puede
hacerse
esto
.


D5
.
¬ø
Qu√©
es
un
Servicio
de
mensajes
cortos
(
SMS
,
Short
Message
Service
)
?
¬ø
En
qu√©
pa√≠-


ses
y
continentes
es
popular
este
servicio
?
¬ø
Es
posible
enviar
un
mensaje
SMS
desde


un
sitio
web
a
un
tel√©fono
m√≥vil
?


D6
.
¬ø
Qu√©
es
la
transmisi√≥n
de
flujos
de
v√≠deo
almacenado
?
¬ø
Cu√°les
son
algunos
de
los


sitios
web
m√°s
populares
que
suministran
actualmente
flujos
de
v√≠deo
?


D7
.
¬ø
Qu√©
son
los
flujos
P2P
de
v√≠deo
en
directo
?
¬ø
Cu√°les
son
algunos
de
los
sitios
web


m√°s
populares
que
proporcionan
actualmente
este
servicio
?


D8
.
Localice
cinco
empresas
que
proporcionen
servicios
de
compartici√≥n
de
archivos
P2P.


Para
cada
empresa
,
¬ø
con
qu√©
tipo
de
archivos
trabajan
,
es
decir
,
qu√©
tipo
de
contenido


gestionan
?


D9
.
¬ø
Qui√©n
invent√≥
ICQ
,
es
decir
,
el
primer
servicio
de
mensajer√≠a
instant√°nea
?
¬ø
Cu√°ndo


fue
inventado
y
cu√°l
era
la
edad
de
sus
inventores
?
¬ø
Qui√©n
invent√≥
Napster
,
cu√°ndo
y


qu√©
edades
ten√≠an
sus
inventores
?


76
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
76D10
.
Compare
el
acceso
a
Internet
inal√°mbrico
WiFi
y
el
acceso
a
Internet
inal√°mbrico
3G.


¬ø
Cu√°les
son
las
velocidades
de
bit
de
estos
dos
servicios
?
¬ø
Cu√°les
son
los
costes
?


Comente
brevemente
el
concepto
de
itinerancia
y
ubicuidad
de
acceso
.


D11
.
¬ø
Por
qu√©
ya
no
existe
el
servicio
de
compartici√≥n
de
archivos
P2P
de
Napster
origi-


nal
?
¬ø
Qu√©
es
la
RIAA
y
qu√©
medidas
se
est√°n
tomando
para
limitar
la
compartici√≥n


P2P
de
archivos
con
derechos
de
propiedad
intelectual
?
¬ø
Cu√°l
es
la
diferencia
entre
la


infracci√≥n
directa
e
indirecta
de
los
derechos
de
propiedad
intelectual
?


D12
.
¬ø
Qu√©
es
BitTorrent
?
¬ø
Qu√©
es
lo
que
le
hace
fundamentalmente
diferente
de
un
servicio


de
compartici√≥n
de
archivos
P2P
como
eDonkey
,
LimeWire
o
Kazaa
?


D13
.
¬ø
Cree
que
dentro
de
10
a√±os
seguir√°n
comparti√©ndose
de
modo
habitual
archivos
con


derechos
de
propiedad
intelectual
a
trav√©s
de
las
redes
de
comunicaciones
?
¬ø
Por
qu√©
?


Razone
su
respuesta
.


Pr√°cticas
de
laboratorio
con
Wireshark


‚Äú
D√≠melo
y
lo
olvidar√©
.
Ens√©√±amelo
y
lo
recordar√©
.
Impl√≠came
y
lo
entender√©
.
‚Äù


Proverbio
chino


Para
comprender
mejor
los
protocolos
de
red
se
puede
profundizar
enormemente
en
ellos


vi√©ndolos
en
acci√≥n
y
observando
,
por
ejemplo
,
la
secuencia
de
mensajes
intercambiados


entre
dos
entidades
,
examinando
los
detalles
de
la
operaci√≥n
del
protocolo
,
haciendo
que
lle-


ven
a
cabo
determinadas
acciones
y
observando
dichas
acciones
y
sus
consecuencias
.
Esto


puede
hacerse
en
escenarios
simulados
o
en
un
entorno
de
red
real
,
como
Internet
.
Los


applets
Java
disponibles
en
el
sitio
web
del
libro
aplican
el
primero
de
estos
m√©todos
.
En
el


laboratorio
con
Wireshark
se
aplicar√°
el
segundo
m√©todo
.
Se
ejecutan
aplicaciones
de
red
en


diversos
escenarios
utilizando
una
computadora
dom√©stica
,
de
una
oficina
o
de
un
laborato-


rio
de
pr√°cticas
.
Podr√°
observar
los
protocolos
de
red
en
su
equipo
,
interactuando
e
inter-


cambiando
mensajes
con
entidades
que
se
ejecutan
en
cualquier
punto
de
Internet
.
As√≠
,
usted


y
su
computadora
ser√°n
una
parte
integral
de
estas
pr√°cticas
de
laboratorio
.
Podr√°
observar


practicando
y
,
de
ese
modo
,
aprender
.


La
herramienta
b√°sica
para
observar
los
mensajes
intercambiados
entre
entidades
que


ejecutan
protocolos
es
un
husmeador
de
paquetes
(
packet
sniffer
)
.
Como
su
nombre
sugiere
,


un
husmeador
de
paquetes
copia
de
forma
pasiva
los
mensajes
que
est√°n
siendo
enviados
y


recibidos
por
una
computadora
;
tambi√©n
muestra
el
contenido
de
los
distintos
campos
de


protocolo
de
los
mensajes
capturados
.
En
la
Figura
1.29
se
muestra
una
captura
de
pantalla


del
software
Wireshark
.
Wireshark
es
un
husmeador
de
paquetes
gratuito
que
se
ejecuta
en


sistemas
Windows
,
Linux
/
Unix
y
Mac
.
A
lo
largo
del
libro
,
encontrar√°
pr√°cticas
de
laborato-


rio
con
Wireshark
que
le
permitir√°n
explorar
los
protocolos
estudiados
en
el
cap√≠tulo
.
En
la


primera
pr√°ctica
de
laboratorio
con
Wireshark
,
tendr√°
que
conseguir
e
instalar
una
copia
de


Wireshark
,
acceder
a
un
sitio
web
y
capturar
y
examinar
los
mensajes
de
protocolo
que
est√©n


siendo
intercambiados
entre
su
navegador
web
y
el
servidor
web
.


Puede
encontrar
todos
los
detalles
acerca
de
esta
primera
pr√°ctica
de
laboratorio
con


Wireshark
(
incluyendo
las
instrucciones
acerca
de
c√≥mo
obtener
e
instalar
Wireshark
)
en


el
sitio
web
http://www.awl.com/kurose-ross
.


PR√ÅCTICAS
DE
LABORATORIO
CON
WIRESHARK
77


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
77Figura
1.29
‚Ä¢
Una
captura
de
pantalla
de
Wireshark
.


78
CAP√çTULO
1
‚Ä¢
REDES
DE
COMPUTADORAS
E
INTERNET


Men√∫
de


comandos


Listado


de
paquetes


capturados


Detalles


de
la


cabecera


del
paquete


seleccionado


Contenido


del
paquete
en


hexadecimal


y
ASCII


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
78Leonard
Kleinrock


Leonard
Kleinrock
es
catedr√°tico
de
Ciencias
de
la
Computaci√≥n
en


la
Universidad
de
California
,
Los
√Ångeles
.
En
1969
,
su
computado-


ra
en
UCLA
se
convirti√≥
en
el
primer
nodo
de
Internet
.
Su
definici√≥n


de
los
principios
de
la
conmutaci√≥n
de
paquetes
en
1961
se
con-


virti√≥
en
la
tecnolog√≠a
en
la
que
hoy
se
basa
Internet
.
Recibi√≥
su


licenciatura
en
el
City
College
of
New
York
(
CCNY
)
y
sus
t√≠tulos


de
m√°ster
y
doctor
en
Ingenier√≠a
El√©ctrica
en
el
MIT
.


UNA
ENTREVISTA
CON
...


¬ø
Qu√©
le
hizo
decidirse
a
especializarse
en
la
tecnolog√≠a
de
redes
e
Internet
?


Como
estudiante
de
doctorado
en
el
MIT
en
1959
,
me
di
cuenta
de
que
la
mayor
parte
de
mis
compa-


√±eros
de
clase
estaban
realizando
sus
investigaciones
en
el
√°rea
de
la
teor√≠a
de
la
informaci√≥n
y
de
la


teor√≠a
de
la
codificaci√≥n
.
En
el
MIT
se
encontraba
el
gran
investigador
Claude
Shannon
,
quien
hab√≠a


abierto
estos
campos
de
investigaci√≥n
y
que
ya
hab√≠a
resuelto
la
mayor
parte
de
los
problemas
impor-


tantes
.
Los
problemas
de
investigaci√≥n
que
quedaban
eran
muy
complicados
y
de
consecuencias


mucho
menos
importantes
.
As√≠
que
decid√≠
iniciarme
en
una
nueva
√°rea
en
la
que
nadie
hab√≠a
pensado


todav√≠a
.
En
el
MIT
,
estaba
rodeado
de
montones
de
computadoras
y
vi
claramente
que
pronto
esas


m√°quinas
necesitar√≠an
comunicarse
entre
s√≠
.
En
aquel
momento
,
no
exist√≠a
una
forma
efectiva
de
hacer-


lo
,
por
lo
que
decid√≠
desarrollar
la
tecnolog√≠a
que
permitir√≠a
crear
redes
de
datos
eficientes
y
fiables
.


¬ø
Cu√°l
fue
su
primer
trabajo
en
la
industria
inform√°tica
?
¬ø
Qu√©
signific√≥
para
usted
?


Entre
1951
y
1957
realic√©
en
el
CCNY
los
estudios
de
grado
en
Ingenier√≠a
El√©ctrica
en
el
turno
de


tarde
.
Durante
el
d√≠a
,
trabaj√©
primero
como
t√©cnico
y
luego
como
ingeniero
en
una
peque√±a
empre-


sa
de
electr√≥nica
industrial
llamada
Photobell
.
Mientras
estuve
all√≠
,
introduje
la
tecnolog√≠a
digital


en
sus
l√≠neas
de
productos
.
B√°sicamente
,
utiliz√°bamos
dispositivos
fotoel√©ctricos
para
detectar
la


presencia
de
ciertos
elementos
(
cajas
,
personas
,
etc.
)
.
El
uso
de
un
circuito
que
por
entonces
se


denominaba
multivibrador
biestable
era
la
clase
de
tecnolog√≠a
que
necesit√°bamos
para
llevar
el


procesamiento
digital
al
campo
de
la
detecci√≥n
.
Estos
circuitos
resultaron
ser
la
base
de
las
com-


putadoras
y
ahora
se
conocen
como
flip-flops
,
biestables
o
conmutadores
en
la
jerga
actual
.


¬ø
Qu√©
pas√≥
por
su
cabeza
cuando
envi√≥
el
primer
mensaje
de
un
host
a
otro
(
desde
UCLA
al


Instituto
de
Investigaci√≥n
de
Stanford
)
?


Francamente
,
no
ten√≠amos
ni
idea
de
la
importancia
de
aquel
suceso
.
No
ten√≠amos
preparado
un
men-


saje
especial
que
pasara
a
la
historia
,
como
tantos
otros
inventores
del
pasado
(
Samuel
Morse
con
‚Äú
¬°
Lo


que
ha
hecho
Dios
!
‚Äù
,
Alexander
Graham
Bell
con
‚Äú
Watson
,
¬°
ven
aqu√≠
!
Te
necesito
‚Äù
o
Neal
Amstrong


con
‚Äú
Un
peque√±o
paso
para
el
hombre
,
pero
un
gran
paso
para
la
Humanidad
‚Äù
)
¬°
Aquellos
tipos
s√≠
eran


inteligentes
!
Conoc√≠an
a
los
medios
de
comunicaci√≥n
y
sab√≠an
lo
que
eran
las
relaciones
p√∫blicas
.
Todo


lo
que
nosotros
quer√≠amos
hacer
era
iniciar
una
sesi√≥n
en
la
computadora
del
SRI
.
Por
lo
que
escribi-


mos
‚Äú
L
‚Äù
,
lo
que
fue
correctamente
recibido
,
escribimos
luego
la
letra
‚Äú
o
‚Äù
,
que
fue
recibida
,
y
despu√©s


la
letra
‚Äú
g
‚Äù
,
que
hizo
que
la
computadora
host
del
SRI
fallara
estrepitosamente
.
As√≠
,
nuestro
mensaje
fue


el
m√°s
corto
de
la
historia
:
‚Äú
Lo
!
‚Äù
.


Anteriormente
,
aquel
a√±o
,
yo
hab√≠a
sido
citado
en
una
revista
de
UCLA
diciendo
que
una
vez
que


la
red
estuviera
activa
y
funcionando
,
ser√≠a
posible
acceder
a
las
utilidades
inform√°ticas
desde
nuestros


79


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
79hogares
y
oficinas
tan
f√°cilmente
como
ya
era
disponer
de
electricidad
y
tel√©fono
.
Por
tanto
,
mi
visi√≥n


en
aquel
momento
era
que
Internet
estar√≠a
en
todas
partes
,
siempre
en
funcionamiento
,
siempre
dispo-


nible
,
que
cualquiera
con
cualquier
dispositivo
podr√≠a
conectarse
desde
cualquier
lugar
y
que
ser√≠a
invi-


sible
.
Sin
embargo
,
nunca
pude
prever
que
mi
madre
con
99
a√±os
utilizar√≠a
Internet
,
y
realmente
la
uti-


liz√≥
.


¬ø
C√≥mo
ve
el
futuro
de
las
redes
?


La
parte
f√°cil
de
la
visi√≥n
es
predecir
la
propia
infraestructura
.
Preveo
que
veremos
una
considerable


implantaci√≥n
de
la
computaci√≥n
n√≥mada
,
los
dispositivos
m√≥viles
y
los
espacios
inteligentes
.
De
hecho
,


la
disponibilidad
de
dispositivos
inform√°ticos
ligeros
,
baratos
,
de
altas
prestaciones
y
port√°tiles
,
y
la
dis-


ponibilidad
de
dispositivos
de
comunicaciones
(
combinado
con
la
omnipresencia
de
Internet
)
nos
ha


permitido
convertirnos
en
n√≥madas
.
La
computaci√≥n
n√≥mada
hace
referencia
a
la
tecnolog√≠a
que
per-


mite
a
los
usuarios
finales
ir
de
un
lugar
a
otro
obteniendo
acceso
a
los
servicios
de
Internet
de
forma


transparente
,
independientemente
de
por
d√≥nde
viajen
e
independientemente
del
dispositivo
que
utili-


cen
.
La
parte
m√°s
complicada
de
esta
visi√≥n
de
futuro
es
predecir
las
aplicaciones
y
servicios
,
que
siem-


pre
nos
han
sorprendido
de
forma
incre√≠ble
(
correo
electr√≥nico
,
tecnolog√≠as
de
b√∫squeda
,
la
world-wide-


web
,
los
blogs
,
las
redes
sociales
,
la
generaci√≥n
y
compartici√≥n
por
parte
de
los
usuarios
de
m√∫sica
,
foto-


graf√≠as
y
v√≠deos
,
etc.
)
.
Nos
encontramos
en
el
amanecer
de
una
nueva
era
de
aplicaciones
m√≥viles
sor-


prendentes
e
innovadoras
,
que
podremos
utilizar
con
nuestros
dispositivos
de
mano
.


La
siguiente
ola
nos
permitir√°
pasar
del
mundo
virtual
del
ciberespacio
al
mundo
f√≠sico
de
los
espa-


cios
inteligentes
.
Nuestros
entornos
(
mesas
,
paredes
,
veh√≠culos
,
relojes
,
etc.
)
cobrar√°n
vida
con
la
tec-


nolog√≠a
,
mediante
actuadores
,
sensores
,
l√≥gica
,
procesamiento
,
almacenamiento
,
c√°maras
,
micr√≥fonos
,


altavoces
,
pantallas
y
comunicaci√≥n
.
Esta
tecnolog√≠a
integrada
permitir√°
a
nuestro
entorno
proporcionar


los
servicios
IP
que
deseemos
.
Cuando
accedamos
a
una
habitaci√≥n
,
la
habitaci√≥n
sabr√°
que
hemos


entrado
.
Podremos
comunicarnos
con
nuestro
entorno
de
forma
natural
,
hablando
en
nuestra
lengua


materna
;
nuestras
solicitudes
generar√°n
respuestas
que
nos
presentar√°n
p√°ginas
web
en
pantallas
de


pared
,
en
los
cristales
de
las
gafas
,
en
forma
de
texto
hablado
,
de
hologramas
,
etc.


Mirando
un
poco
m√°s
lejos
,
preveo
un
futuro
en
red
que
incluya
los
siguientes
componentes
adi-


cionales
fundamentales
.
Veo
agentes
software
inteligentes
por
toda
la
red
,
cuya
funci√≥n
ser√°
escarbar


en
los
datos
,
actuar
de
acuerdo
con
ellos
,
detectar
tendencias
y
llevar
a
cabo
tareas
de
forma
din√°mi-


ca
y
adaptativa
.
Preveo
que
habr√°
una
cantidad
de
tr√°fico
de
red
considerablemente
mayor
,
generada


no
tanto
por
los
seres
humanos
,
sino
por
estos
dispositivos
integrados
y
esos
agentes
software
inteli-


gentes
.
Preveo
que
habr√°
grandes
conjuntos
de
sistemas
dotados
de
auto-organizaci√≥n
y
encargados


de
controlar
esa
red
tan
enorme
y
tan
r√°pida
.
Preveo
que
habr√°
enormes
cantidades
de
informaci√≥n


viajando
instant√°neamente
a
trav√©s
de
esa
red
y
vi√©ndose
sometida
en
el
camino
a
enormes
cantida-


des
de
procesamiento
y
de
filtrado
.
Internet
ser√°
,
esencialmente
,
un
sistema
nervioso
global
que
lle-


gar√°
a
todas
partes
.
Preveo
que
suceder√°n
todas
estas
cosas
y
muchas
m√°s
a
medida
que
nos
vayamos


adentrando
en
el
siglo
XXI
.


¬ø
Qu√©
personas
le
han
inspirado
profesionalmente
?


Con
diferencia
,
el
que
m√°s
me
ha
inspirado
ha
sido
Claude
Shannon
del
MIT
,
un
brillante
investigador


que
ten√≠a
la
capacidad
de
relacionar
sus
ideas
matem√°ticas
con
el
mundo
f√≠sico
de
una
forma
extrema-


damente
intuitiva
.
Estuvo
en
el
tribunal
de
mi
tesis
doctoral
.


¬ø
Tiene
alg√∫n
consejo
para
los
estudiantes
que
se
inician
ahora
en
el
campo
de
las
redes


y
de
Internet
?


Internet
y
todo
lo
que
esa
red
hace
posible
constituye
una
nueva
frontera
de
grandes
dimensiones
,
llena


de
desaf√≠os
asombrosos
.
Hay
grandes
oportunidades
para
la
innovaci√≥n
y
no
hay
que
sentirse
restrin-


gido
por
la
tecnolog√≠a
actual
.
Lo
que
hay
que
hacer
es
abrir
la
mente
e
imaginar
c√≥mo
podr√≠an
ser
las


cosas
,
y
luego
hacer
que
eso
suceda
.
 

80


M01_KURO9675_05_SE_CH01.qxd
 
21/3/10
 
11:37
 
P√°gina
80CAP√çTULO
2


La
capa
de


aplicaci√≥n


81


Las
aplicaciones
de
red
son
la
raz√≥n
de
ser
de
una
red
de
computadoras
(
si
no
pudi√©ramos


concebir
ninguna
aplicaci√≥n
√∫til
,
no
existir√≠a
la
necesidad
de
dise√±ar
protocolos
de
red
para


darlas
soporte
)
.
En
los
√∫ltimos
40
a√±os
,
se
han
creado
muchas
aplicaciones
de
red
ingenio-


sas
y
sorprendentes
.
Entre
estas
aplicaciones
se
incluyen
las
cl√°sicas
aplicaciones
basadas


en
texto
que
se
hicieron
populares
en
las
d√©cadas
de
1970
y
1980
,
como
son
el
correo
elec-


tr√≥nico
de
texto
,
el
acceso
remoto
a
computadoras
,
la
transferencia
de
archivos
,
los
grupos


de
noticias
y
los
chats
de
texto
.
Entre
√©stas
,
tambi√©n
se
incluye
la
aplicaci√≥n
por
excelencia


de
mediados
de
la
d√©cada
de
1990
:
la
World
Wide
Web
,
acompa√±ada
de
la
navegaci√≥n
web
,


las
b√∫squedas
web
y
el
comercio
electr√≥nico
.
Adem√°s
,
tenemos
que
citar
las
dos
aplicacio-


nes
estrella
aparecidas
a
finales
del
milenio
:
la
mensajer√≠a
instant√°nea
con
listas
de
contac-


tos
y
la
compartici√≥n
de
archivos
P2P.
Asimismo
,
tambi√©n
se
incluyen
muchas
aplicaciones


de
√©xito
de
audio
y
v√≠deo
,
como
la
telefon√≠a
por
Internet
,
la
compartici√≥n
de
v√≠deos
y
los
flu-


jos
de
v√≠deo
,
la
radio
por
Internet
y
la
televisi√≥n
IP
(
IPTV
)
.
Adem√°s
,
el
incremento
en
el
uso


del
acceso
residencial
de
banda
ancha
y
la
creciente
omnipresencia
del
acceso
inal√°mbrico


constituyen
la
base
para
nuevas
y
excitantes
aplicaciones
que
nos
esperan
en
el
futuro
.


En
este
cap√≠tulo
vamos
a
estudiar
los
aspectos
conceptuales
y
de
implementaci√≥n
de
las


aplicaciones
de
red
.
Comenzaremos
definiendo
los
conceptos
fundamentales
relativos
a
la


capa
de
aplicaci√≥n
,
incluyendo
los
servicios
de
red
requeridos
por
las
aplicaciones
,
los
clien-


tes
y
servidores
,
los
procesos
y
las
interfaces
de
la
capa
de
transporte
.
Examinaremos
en


detalle
varias
aplicaciones
de
red
,
como
la
Web
,
el
correo
electr√≥nico
,
el
sistema
DNS
,
la


distribuci√≥n
de
archivos
en
redes
entre
pares
(
P2P
,
Peer-to-Peer
)
y
la
telefon√≠a
Internet


P2P.
A
continuaci√≥n
,
nos
ocuparemos
del
desarrollo
de
las
aplicaciones
de
red
,
tanto
sobre


TCP
como
UDP
.
En
particular
,
estudiaremos
las
API
de
sockets
y
echaremos
un
vistazo
a


algunas
aplicaciones
cliente-servidor
simples
implementadas
en
Java
.
Tambi√©n
proporcio-


naremos
al
final
del
cap√≠tulo
varias
divertidas
e
interesantes
tareas
de
programaci√≥n
de
soc-


kets
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
81La
capa
de
aplicaci√≥n
es
un
lugar
particularmente
bueno
para
comenzar
el
estudio
de


los
protocolos
,
ya
que
es
un
terreno
familiar
.
Habitualmente
,
empleamos
muchas
de
las
apli-


caciones
que
se
basan
en
los
protocolos
que
vamos
a
estudiar
.
Nos
dar√°
una
idea
adecuada


de
qu√©
son
los
protocolos
y
nos
servir√°
para
introducir
muchas
de
las
cuestiones
que
tendre-


mos
que
volver
a
ver
cuando
estudiemos
los
protocolos
de
las
capas
de
transporte
,
de
red
y


de
enlace
.


2.1
Principios
de
las
aplicaciones
de
red


Imagine
que
se
le
ha
ocurrido
una
idea
para
desarrollar
una
nueva
aplicaci√≥n
de
red
.
Es
posi-


ble
que
esa
aplicaci√≥n
llegue
a
hacer
un
gran
servicio
a
la
Humanidad
,
o
que
simplemente
le


guste
a
su
profesor
,
le
haga
ganar
una
fortuna
o
,
√∫nicamente
,
le
divierta
desarrollarla
.
Sea


cual
sea
la
motivaci√≥n
,
a
continuaci√≥n
vamos
a
ver
c√≥mo
transformar
la
idea
en
una
aplica-


ci√≥n
de
red
real
.


B√°sicamente
,
el
desarrollo
de
una
aplicaci√≥n
de
red
implica
escribir
programas
que
se


ejecuten
en
distintos
sistemas
terminales
y
que
se
comuniquen
entre
s√≠
a
trav√©s
de
la
red
.
Por


ejemplo
,
en
la
aplicaci√≥n
Web
se
emplean
dos
programas
diferentes
que
se
comunican
entre


s√≠
:
el
navegador
que
se
ejecuta
en
el
host
del
usuario
(
una
computadora
de
escritorio
,
un
por-


t√°til
,
una
PDA
,
un
tel√©fono
m√≥vil
,
etc.
)
y
el
programa
del
servidor
web
que
se
ejecuta
en
el


host
servidor
web
.
Otro
ejemplo
ser√≠a
el
caso
de
un
sistema
de
compartici√≥n
de
archivos
P2P


en
el
que
se
emplea
un
programa
en
cada
host
que
participa
en
la
comunidad
de
comparti-


ci√≥n
de
archivos
.
En
este
caso
,
los
programas
instalados
en
los
distintos
hosts
pueden
ser


similares
o
id√©nticos
.


Por
tanto
,
al
desarrollar
su
nueva
aplicaci√≥n
tendr√°
que
escribir
software
que
se
ejecu-


tar√°
en
varios
sistemas
.
Este
software
podr√≠a
escribirse
en
C
,
Java
o
Python
.
Una
cuesti√≥n


importante
es
que
no
es
necesario
escribir
software
que
se
ejecute
en
los
dispositivos
del


n√∫cleo
de
la
red
,
como
por
ejemplo
los
routers
o
los
switches
de
la
capa
de
enlace
.
Incluso


aunque
deseara
escribir
software
de
aplicaci√≥n
para
estos
dispositivos
del
n√∫cleo
de
la
red
,


no
podr√≠a
hacerlo
.
Como
hemos
visto
en
el
Cap√≠tulo
1
y
se
ilustra
en
la
Figura
1.24
,
los
dis-


positivos
del
n√∫cleo
de
la
red
no
operan
en
la
capa
de
aplicaci√≥n
,
sino
en
las
capas
inferio-


res
,
espec√≠ficamente
en
la
capa
de
red
e
inferiores
.
Este
dise√±o
b√°sico
(
que
confina
el


software
de
aplicaci√≥n
a
los
sistemas
terminales
)
,
que
se
muestra
en
la
Figura
2.1
,
ha
facili-


tado
el
r√°pido
desarrollo
y
la
implementaci√≥n
de
una
gran
cantidad
de
aplicaciones
de
red
.


2.1.1
Arquitecturas
de
las
aplicaciones
de
red


Antes
de
profundizar
en
la
codificaci√≥n
del
software
,
deber√≠amos
disponer
de
una
visi√≥n


general
de
la
arquitectura
de
la
aplicaci√≥n
.
Tenga
en
cuenta
que
la
arquitectura
de
una
apli-


caci√≥n
es
muy
distinta
de
la
arquitectura
de
la
red
(
como
por
ejemplo
la
arquitectura
de


Internet
de
cinco
capas
vista
en
el
Cap√≠tulo
1
)
.
Desde
la
perspectiva
del
desarrollador
de


aplicaciones
,
la
arquitectura
de
la
red
es
fija
y
proporciona
un
conjunto
espec√≠fico
de
servi-


cios
a
las
aplicaciones
.
Por
otro
lado
,
el
desarrollador
de
aplicaciones
dise√±a
la
arquitectura


de
la
aplicaci√≥n
,
q
u
e
 
e
s
t
a
b
l
e
c
e
 
c
√≥
m
o
 
l
a
 
a
p
l
i
c
a
c
i
√≥
n
 
d
e
b
e
 
e
s
t
r
u
c
t
u
r
a
r
s
e
 
e
n
 
l
o
s
 
d
i
s
t
i
n
t
o
s
 
s
i
s
t
e
-


mas
terminales
.
Al
seleccionar
la
arquitectura
de
la
aplicaci√≥n
,
el
desarrollador
probable-


mente
utilizar√°
uno
de
los
dos
paradigmas
arquitect√≥nicos
predominantes
en
las
aplicaciones


de
red
modernas
:
la
arquitectura
cliente-servidor
o
la
arquitectura
P2P.


82
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
822.1
‚Ä¢
PRINCIPIOS
DE
LAS
APLICACIONES
DE
RED
83


Transporte


Red


Enlace


F√≠sica


Aplicaci√≥n


ISP
nacional


o
globalRed


m√≥vil


ISP
local
o


regional


Red
empresarial


Red
dom√©stica


Transporte


Red


Enlace


Aplicaci√≥n


F√≠sica


Transporte


Red


Enlace


F√≠sica


Aplicaci√≥n


Figura
2.1
‚Ä¢
La
comunicaci√≥n
de
una
aplicaci√≥n
de
red
tiene
lugar
entre


sistemas
terminales
en
la
capa
de
aplicaci√≥n
.


En
una
arquitectura
cliente-servidor
siempre
existe
un
host
activo
,
denominado


servidor
,
que
da
servicio
a
las
solicitudes
de
muchos
otros
hosts
,
que
son
los
clientes
.
Los


hosts
clientes
pueden
estar
activos
siempre
o
de
forma
intermitente
.
Un
ejemplo
cl√°sico
es


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
83la
Web
en
la
que
un
servidor
web
siempre
activo
sirve
las
solicitudes
de
los
navegadores
que


se
ejecutan
en
los
hosts
clientes
.
Cuando
un
servidor
web
recibe
una
solicitud
de
un
objeto


de
un
host
cliente
,
responde
envi√°ndole
el
objeto
solicitado
.
Observe
que
,
con
la
arquitec-


tura
cliente-servidor
,
los
clientes
no
se
comunican
directamente
entre
s√≠
;
por
ejemplo
,
en
la


aplicaci√≥n
web
,
dos
navegadores
no
se
comunican
entre
s√≠
.
Otra
caracter√≠stica
de
la
arqui-


tectura
cliente-servidor
es
que
el
servidor
tiene
una
direcci√≥n
fija
y
conocida
,
denominada


direcci√≥n
IP
(
de
la
que
hablaremos
enseguida
)
.
Puesto
que
el
servidor
tiene
una
direcci√≥n


fija
y
conocida
,
y
siempre
est√°
activo
,
un
cliente
siempre
puede
contactar
con
√©l
enviando


un
paquete
a
su
direcci√≥n
.
Entre
las
aplicaciones
m√°s
conocidas
que
utilizan
la
arquitectura


cliente-servidor
se
encuentran
las
aplicaciones
web
,
FTP
,
Telnet
y
de
correo
electr√≥nico
.
En


la
Figura
2.2(a
)
se
muestra
la
arquitectura
cliente-servidor
.


Normalmente
,
en
una
aplicaci√≥n
cliente-servidor
un
√∫nico
host
servidor
es
incapaz
de


responder
a
todas
las
solicitudes
de
sus
clientes
.
Por
ejemplo
,
el
sitio
de
una
red
social
popu-


lar
puede
verse
r√°pidamente
desbordado
si
s√≥lo
dispone
de
un
servidor
para
gestionar
todas


las
solicitudes
.
Por
esta
raz√≥n
,
en
las
arquitecturas
cliente-servidor
suele
utilizarse
una
agru-


paci√≥n
(
cluster
)
de
hosts
,
que
a
veces
se
denomina
centro
de
datos
,
para
crear
un
servidor


virtual
de
gran
capacidad
.
Los
servicios
de
aplicaciones
basadas
en
una
arquitectura
cliente-


servidor
a
menudo
precisan
una
infraestructura
intensiva
,
ya
que
requieren
que
los
prove-


edores
de
servicios
compren
,
instalen
y
mantengan
granjas
de
servidores
.
Adem√°s
,
los


84
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


a.
Arquitectura
cliente-servidor
b.
Arquitectura
P2P


Figura
2.2
‚Ä¢
(
a
)
Arquitectura
cliente-servidor
;
(
b
)
arquitectura
P2P.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
84proveedores
del
servicio
deben
afrontar
los
costes
de
las
recurrentes
interconexiones
y
ancho


de
banda
para
enviar
datos
a
Internet
y
recibirlos
.
Servicios
populares
como
los
motores
de


b√∫squeda
(
por
ejemplo
,
Google
)
,
el
comercio
por
Internet
(
como
Amazon
y
e-Bay
)
,
el


correo
electr√≥nico
web
(
como
por
ejemplo
Yahoo
Mail
)
,
las
redes
sociales
(
como
MySpace


y
Facebook
)
y
la
compartici√≥n
de
v√≠deos
(
como
YouTube
)
precisan
una
infraestructura


intensiva
y
su
suministro
es
enormemente
costoso
.


En
una
arquitectura
P2P
existe
una
m√≠nima
(
o
ninguna
)
dependencia
de
una
infraes-


tructura
de
servidores
siempre
activos
.
En
su
lugar
,
la
aplicaci√≥n
explota
la
comunicaci√≥n


directa
entre
parejas
de
hosts
conectados
de
forma
intermitente
,
conocidos
como
peers


(
pares
)
.
Los
pares
no
son
propiedad
del
proveedor
del
servicio
,
sino
que
son
las
computa-


doras
de
escritorio
y
port√°tiles
controlados
por
usuarios
,
encontr√°ndose
la
mayor√≠a
de
los


pares
en
domicilios
,
universidades
y
oficinas
.
Puesto
que
los
pares
se
comunican
sin
pasar


por
un
servidor
dedicado
,
la
arquitectura
se
denomina
arquitectura
peer-to-peer
(
P2P
)
.


Muchas
de
las
aplicaciones
actuales
m√°s
populares
y
con
un
elevado
nivel
de
tr√°fico
est√°n


basadas
en
arquitecturas
P2P.
Entre
estas
aplicaciones
se
incluyen
la
distribuci√≥n
de
archi-


vos
(
por
ejemplo
,
BitTorrent
)
,
la
compartici√≥n
de
archivos
(
como
eMule
y
LimeWire
)
,
la


telefon√≠a
por
Internet
(
como
Skype
)
e
IPTV
(
como
PPLive
)
.
En
la
Figura
2.2(b
)
se
ilustra
la


arquitectura
P2P.
Hemos
mencionado
que
algunas
aplicaciones
tienen
arquitecturas
h√≠bri-


das
que
combinan
elementos
cliente-servidor
y
P2P.
Por
ejemplo
,
en
muchas
aplicaciones


de
mensajer√≠a
instant√°nea
los
servidores
se
utilizan
para
hacer
un
seguimiento
de
las
direc-


ciones
IP
de
los
usuarios
,
pero
los
mensajes
de
usuario
a
usuario
se
env√≠an
directamente


entre
los
hosts
de
dichos
usuarios
(
sin
pasar
por
los
servidores
intermedios
)
.


Una
de
las
caracter√≠sticas
m√°s
convincentes
de
las
arquitecturas
P2P
es
su
auto-escala-


bilidad
.
Por
ejemplo
,
en
una
aplicaci√≥n
de
compartici√≥n
de
archivos
P2P
,
aunque
cada
peer


genera
una
carga
de
trabajo
solicitando
archivos
,
tambi√©n
a√±ade
capacidad
de
servicio
al
sis-


tema
distribuyendo
archivos
a
otros
peers
.
Las
arquitecturas
P2P
tambi√©n
presentan
una


buena
relaci√≥n
coste-prestaciones
,
ya
que
normalmente
no
requieren
una
infraestructura
de


servidores
significativa
ni
un
gran
ancho
de
banda
de
servidor
.
Para
reducir
costes
,
los
pro-


veedores
de
servicios
(
MSN
,
Yahoo
,
etc.
)
cada
vez
est√°n
m√°s
interesados
en
emplear
las


arquitecturas
P2P
para
sus
aplicaciones
[
Chuang
2007
]
.
Sin
embargo
,
las
futuras
aplicaciones


P2P
se
enfrentan
a
tres
retos
importantes
:


1
.
Orientadas
al
ISP
.
La
mayor√≠a
de
los
ISP
residenciales
(
incluyendo
los
ISP
de
l√≠neas


DSL
y
cable
)
est√°n
dimensionados
para
hacer
un
uso
‚Äú
asim√©trico
‚Äù
del
ancho
de
banda
,


es
decir
,
para
dar
soporte
a
mucho
m√°s
tr√°fico
de
descarga
que
de
carga
.
Pero
las
aplica-


ciones
P2P
para
distribuci√≥n
de
archivos
y
de
flujos
de
v√≠deo
desplazan
el
tr√°fico
de


carga
de
los
servidores
a
los
ISP
residenciales
,
ejerciendo
en
consecuencia
una
gran
pre-


si√≥n
sobre
los
ISP
.
Las
aplicaciones
P2P
futuras
tendr√°n
que
ser
dise√±adas
pensando
en


los
ISP
[
Xie
2008
]
.


2
.
Seguridad
.
Debido
a
su
naturaleza
extremadamente
distribuida
y
abierta
,
las
aplicacio-


nes
P2P
pueden
ser
un
reto
para
la
seguridad
[
Doucer
2002
;
Yu
2006
;
Liang
2006
;


Naoumov
2006
;
Dhungel
2008
]
.


3
.
Incentivos
.
El
√©xito
de
las
aplicaciones
P2P
futuras
tambi√©n
depende
de
convencer
a
los


usuarios
para
ofrecer
voluntariamente
a
las
aplicaciones
recursos
de
ancho
de
banda
,
de


almacenamiento
y
de
computaci√≥n
,
lo
que
constituye
todo
un
reto
de
dise√±o
de
incenti-


vos
[
Feldman
2005
;
Piatek
2008
;
Aperjis
2008
]
.


2.1
‚Ä¢
PRINCIPIOS
DE
LAS
APLICACIONES
DE
RED
85


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
852.1.2
Procesos
de
comunicaci√≥n


Antes
de
crear
su
aplicaci√≥n
de
red
,
tambi√©n
necesita
disponer
de
unos
conocimientos
b√°si-


cos
sobre
c√≥mo
los
programas
que
se
ejecutan
en
varios
sistemas
terminales
se
comunican


entre
s√≠
.
En
la
jerga
de
los
sistemas
operativos
,
realmente
no
son
los
programas
sino
los


procesos
los
que
se
comunican
.
Un
proceso
puede
interpretarse
como
un
programa
que
se


ejecuta
dentro
de
un
sistema
terminal
.
Cuando
los
procesos
se
ejecutan
en
el
mismo
sistemas


terminal
,
pueden
comunicarse
entre
s√≠
mediante
la
comunicaci√≥n
entre
procesos
aplicando
las


reglas
gobernadas
por
el
sistema
operativo
del
sistema
terminal
.
Pero
,
en
este
libro
,
no
esta-


mos
especialmente
interesados
en
c√≥mo
se
comunican
los
procesos
que
tienen
lugar
en
un


mismo
host
,
sino
en
c√≥mo
se
comunican
los
procesos
que
se
ejecutan
en
hosts
diferentes
(
con


sistemas
operativos
potencialmente
diferentes
)
.


Los
procesos
de
dos
sistemas
terminales
diferentes
se
comunican
entre
ellos
intercam-


biando
 
mensajes
a
trav√©s
de
la
red
de
computadoras
.
Un
proceso
emisor
crea
y
env√≠a
men-


sajes
a
la
red
;
un
proceso
receptor
recibe
estos
mensajes
y
posiblemente
responde


devolviendo
mensajes
.
La
Figura
2.1
ilustra
que
los
procesos
se
comunican
entre
s√≠
utili-


zando
la
capa
de
aplicaci√≥n
de
la
pila
de
protocolos
de
cinco
capas
.


Procesos
cliente
y
servidor


Una
aplicaci√≥n
de
red
consta
de
parejas
de
procesos
que
se
env√≠an
mensajes
entre
s√≠
a
trav√©s


de
una
red
.
Por
ejemplo
,
en
la
aplicaci√≥n
web
,
un
proceso
de
un
navegador
cliente
intercam-


bia
mensajes
con
un
proceso
de
un
servidor
web
.
En
un
sistema
de
compartici√≥n
de
archivos


P2P
,
se
transfiere
un
archivo
desde
un
proceso
de
un
peer
a
un
proceso
de
otro
par
.
Normal-


mente
,
en
una
pareja
de
procesos
que
est√°n
comunic√°ndose
,
etiquetamos
a
uno
de
los
proce-


sos
como
el
cliente
y
al
otro
como
el
servidor
.
En
una
aplicaci√≥n
web
,
un
navegador
es
un


proceso
cliente
y
el
servidor
web
es
un
proceso
servidor
.
En
la
compartici√≥n
de
archivos
P2P
,
el


host
que
descarga
el
archivo
se
etiqueta
como
el
cliente
y
el
host
que
est√°
cargando
el
archivo
se


etiqueta
como
el
servidor
.


Es
posible
que
haya
observado
que
en
algunas
aplicaciones
,
tales
como
la
compartici√≥n
de


archivos
P2P
,
un
proceso
puede
ser
tanto
un
cliente
como
un
servidor
.
De
hecho
,
un
proceso
en


un
sistema
de
compartici√≥n
de
archivos
P2P
puede
cargar
y
descargar
archivos
.
No
obstante
,
en


el
contexto
de
cualquier
sesi√≥n
de
comunicaci√≥n
entre
una
pareja
de
procesos
,
podemos
etique-


tar
a
uno
de
los
procesos
como
el
cliente
y
al
otro
como
el
servidor
.
Definimos
los
procesos


cliente
y
servidor
como
sigue
:


En
el
contexto
de
una
sesi√≥n
de
comunicaci√≥n
entre
una
pareja
de
procesos
,
el
proceso


que
inicia
la
comunicaci√≥n
(
es
decir
,
que
inicialmente
se
pone
en
contacto
con
el
otro


proceso
al
principio
de
la
sesi√≥n
)
se
etiqueta
como
el
cliente
.
El
proceso
que
espera
a


ser
contactado
para
comenzar
la
sesi√≥n
es
el
servidor
.


En
la
Web
,
un
proceso
de
navegador
inicia
el
contacto
con
un
proceso
de
servidor
web
;


por
tanto
,
el
proceso
de
navegador
es
el
cliente
y
el
proceso
de
servidor
web
es
el
servidor
.


En
la
compartici√≥n
de
archivos
P2P
,
cuando
un
par
A
pide
a
un
par
B
que
le
env√≠e
un


determinado
archivo
,
el
A
es
el
cliente
y
el
B
es
el
servidor
en
el
contexto
de
esta
sesi√≥n
de


comunicaci√≥n
concreta
.
Si
no
existe
ning√∫n
tipo
de
confusi√≥n
,
en
ocasiones
,
tambi√©n
emple-


aremos
la
terminolog√≠a
‚Äú
lado
del
cliente
y
lado
del
servidor
de
una
aplicaci√≥n
‚Äù
.
Al
final
del


cap√≠tulo
,
examinaremos
un
c√≥digo
simple
tanto
para
el
lado
del
cliente
como
para
el
lado


del
servidor
de
las
aplicaciones
de
red
.


86
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
86Interfaz
entre
el
proceso
y
la
red
de
computadoras


Como
hemos
mencionado
anteriormente
,
la
mayor√≠a
de
las
aplicaciones
constan
de
parejas


de
procesos
de
comunicaci√≥n
que
se
env√≠an
mensajes
entre
ellos
.
Cualquier
mensaje
enviado


de
un
proceso
al
otro
debe
atravesar
la
red
subyacente
.
Un
proceso
env√≠a
mensajes
a
la
red
y


los
recibe
de
la
red
a
trav√©s
de
una
interfaz
software
denominada
socket
.
Veamos
una
analo-


g√≠a
que
nos
ayudar√°
a
comprender
los
conceptos
de
proceso
y
socket
.
Un
proceso
es
an√°logo


a
una
casa
y
un
socket
es
an√°logo
a
la
puerta
de
la
casa
.
Cuando
un
proceso
desea
enviar
un


mensaje
a
otro
proceso
que
se
est√°
ejecutando
en
otro
host
,
env√≠a
el
 
mensaje
a
trav√©s
de
la


puerta
(
socket
)
.
Este
proceso
emisor
supone
que
existe
una
infraestructura
de
transporte
al


otro
lado
de
la
puerta
que
llevar√°
el
mensaje
hasta
la
puerta
del
proceso
de
destino
.
Una
vez


que
el
mensaje
llega
al
host
de
destino
,
√©ste
pasa
a
trav√©s
de
la
puerta
(
socket
)
del
proceso


receptor
,
actuando
entonces
el
proceso
receptor
sobre
el
mensaje
.


La
Figura
2.3
ilustra
la
comunicaci√≥n
mediante
sockets
entre
dos
procesos
que
se
comu-


nican
a
trav√©s
de
Internet
.
(
En
la
Figura
2.3
se
supone
que
el
protocolo
de
transporte
subya-


cente
utilizado
por
los
procesos
es
el
protocolo
TCP
de
Internet
.
)
Como
se
muestra
en
la


figura
,
un
socket
es
la
interfaz
entre
la
capa
de
aplicaci√≥n
y
la
capa
de
transporte
de
un
host
.


Tambi√©n
se
conoce
como
Interfaz
de
programaci√≥n
de
aplicaciones
(
API
,
Application


Programming
Interface
)
que
opera
entre
la
aplicaci√≥n
y
la
red
,
ya
que
el
socket
es
la
inter-


faz
de
programaci√≥n
con
la
que
se
construyen
las
aplicaciones
de
red
.
El
desarrollador
de
la


aplicaci√≥n
tiene
el
control
sobre
todos
los
elementos
del
lado
de
la
capa
de
aplicaci√≥n
del


socket
pero
apenas
tiene
control
sobre
el
lado
de
la
capa
de
transporte
del
socket
.
El
√∫nico


control
que
tiene
el
desarrollador
de
la
aplicaci√≥n
sobre
el
lado
de
la
capa
de
transporte
es


(
1
)
la
elecci√≥n
del
protocolo
de
transporte
y
(
2
)
quiz√°
la
capacidad
de
fijar
unos
pocos
par√°-


metros
de
la
capa
de
transporte
,
como
por
ejemplo
los
tama√±os
m√°ximo
del
buffer
y
de
seg-


mento
(
lo
que
veremos
en
el
Cap√≠tulo
3
)
.
Una
vez
que
el
desarrollador
de
la
aplicaci√≥n
ha


seleccionado
un
protocolo
de
transporte
(
si
hay
disponibles
varios
entre
los
que
elegir
)
,
la


aplicaci√≥n
se
crea
utilizando
los
servicios
de
la
capa
de
transporte
proporcionados
por
dicho


protocolo
.
En
las
Secciones
2.7
y
2.8
exploraremos
en
detalle
los
sockets
.


2.1
‚Ä¢
PRINCIPIOS
DE
LAS
APLICACIONES
DE
RED
87


Proceso


Host
o


servidor


Host
o


servidor


Controlado


por
el


desarrollador


de
aplicaciones


Controlado


por
el


desarrollador


de
aplicaciones


Proceso


TCP
con


buffers
,


variables
Internet


Controlado


por
el
sistema


operativo


Controlado


por
el
sistema


operativo


TCP
con


buffers
,


variables


Socket
Socket


Figura
2.3
‚Ä¢
Procesos
de
aplicaci√≥n
,
sockets
y
protocolo
de
transporte
subyacente
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
872.1.3
Servicios
de
transporte
disponibles


para
las
aplicaciones


Recordemos
que
un
socket
es
la
interfaz
entre
el
proceso
de
la
aplicaci√≥n
y
el
protocolo


de
la
capa
de
transporte
.
La
aplicaci√≥n
del
lado
emisor
empuja
los
mensajes
a
trav√©s
del


socket
.
En
el
otro
lado
del
socket
,
el
protocolo
de
la
capa
de
transporte
tiene
la
responsabili-


dad
de
llevar
los
mensajes
hasta
la
‚Äú
puerta
‚Äù
del
socket
de
recepci√≥n
.


Muchas
redes
,
incluyendo
Internet
,
proporcionan
m√°s
de
un
protocolo
de
la
capa
de


transporte
.
Cuando
vaya
a
desarrollar
una
aplicaci√≥n
,
tendr√°
que
elegir
uno
de
los
protoco-


los
de
la
capa
de
transporte
disponibles
.
¬ø
C√≥mo
llevar
a
cabo
esta
selecci√≥n
?
Muy
probable-


mente
,
tendr√°
que
estudiar
los
servicios
que
ofrecen
los
protocolos
de
la
capa
de
transporte


disponibles
y
despu√©s
elegir
aquel
protocolo
que
proporcione
los
servicios
que
mejor
se


adapten
a
las
necesidades
de
la
aplicaci√≥n
.
La
situaci√≥n
es
similar
a
tener
que
elegir
entre


viajar
en
tren
o
en
avi√≥n
para
ir
de
una
ciudad
a
otra
.
Tiene
que
elegir
un
medio
de
trans-


porte
u
otro
,
y
cada
uno
de
ellos
ofrece
servicios
diferentes
.
Por
ejemplo
,
el
tren
le
ofrece


partir
y
llegar
al
centro
de
las
ciudades
,
mientras
que
el
avi√≥n
ofrece
un
tiempo
de
viaje
m√°s


corto
.


¬ø
Cu√°les
son
los
servicios
que
puede
ofrecer
un
protocolo
de
la
capa
de
transporte
a
las


aplicaciones
que
le
invocan
?
Podemos
clasificar
los
posibles
servicios
de
forma
bastante


general
seg√∫n
cuatro
par√°metros
:
transferencia
de
datos
fiable
,
tasa
de
transferencia
,
tempo-


rizaci√≥n
y
seguridad
.


Transferencia
de
datos
fiable


Como
se
ha
explicado
en
el
Cap√≠tulo
1
,
en
una
red
de
computadoras
pueden
perderse
paque-


tes
.
Por
ejemplo
,
un
paquete
puede
desbordar
el
buffer
de
un
router
,
o
podr√≠a
ser
descartado


por
un
host
o
un
router
despu√©s
de
comprobar
que
algunos
de
sus
bits
est√°n
corrompidos
.
En


muchas
aplicaciones
(
como
el
correo
electr√≥nico
,
la
transferencia
de
archivos
,
el
acceso


remoto
a
hosts
,
la
transferencia
de
documentos
web
y
las
aplicaciones
financieras
)
la
p√©r-


dida
de
datos
puede
tener
consecuencias
catastr√≥ficas
(
en
el
√∫ltimo
caso
,
para
el
banco
y


para
¬°
el
cliente
!
)
.
Por
tanto
,
para
dar
soporte
a
estas
aplicaciones
,
es
preciso
hacer
algo
para


garantizar
que
los
datos
enviados
desde
un
terminal
de
la
aplicaci√≥n
sean
todos
ellos
entre-


gados
correcta
y
completamente
al
otro
terminal
de
la
aplicaci√≥n
.
Si
un
protocolo
propor-


ciona
un
servicio
de
entrega
de
datos
garantizado
,
se
dice
que
proporciona
una


transferencia
de
datos
fiable
.
Un
servicio
importante
que
un
protocolo
de
la
capa
de
trans-


porte
puede
potencialmente
proporcionar
a
una
aplicaci√≥n
es
la
transferencia
de
datos
fiable


proceso
a
proceso
.
Cuando
un
protocolo
de
transporte
suministra
este
servicio
,
el
proceso


emisor
puede
pasar
sus
datos
al
socket
y
sabe
con
certidumbre
absoluta
que
los
datos
llega-


r√°n
sin
errores
al
proceso
receptor
.


Si
un
protocolo
de
la
capa
de
transporte
no
proporciona
una
transferencia
de
datos
fia-


ble
,
los
datos
enviados
por
el
proceso
emisor
pueden
no
llegar
nunca
al
proceso
de
recep-


ci√≥n
.
Esto
puede
ser
aceptable
para
aplicaciones
tolerantes
a
p√©rdidas
;
por
ejemplo
,
la


mayor
parte
de
las
aplicaciones
multimedia
como
las
de
audio
/
v√≠deo
en
tiempo
real
o
las
de


audio
/
v√≠deo
almacenado
pueden
tolerar
que
cierta
cantidad
de
datos
se
pierda
.
En
estas
apli-


caciones
multimedia
,
la
p√©rdida
de
datos
puede
dar
lugar
a
una
peque√±a
interrupci√≥n
al


reproducir
el
audio
/
v√≠deo
,
lo
que
no
constituye
un
problema
fundamental
.
 

88
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
88Tasa
de
transferencia


En
el
Cap√≠tulo
1
hemos
presentado
el
concepto
de
tasa
de
transferencia
disponible
,
el
cual


podemos
trasladar
al
contexto
de
una
sesi√≥n
de
comunicaciones
entre
dos
procesos
a
lo
largo


de
una
ruta
de
red
como
la
tasa
a
la
que
el
proceso
emisor
puede
suministrar
bits
al
proceso


de
recepci√≥n
.
Puesto
que
otras
sesiones
compartir√°n
el
ancho
de
banda
a
lo
largo
de
la
ruta


de
red
y
puesto
que
esas
otras
sesiones
se
iniciar√°n
y
terminar√°n
aleatoriamente
,
la
tasa
de


transferencia
disponible
puede
fluctuar
con
el
tiempo
.
Estas
observaciones
nos
llevan
a
otro


servicio
que
un
protocolo
de
la
capa
de
transporte
podr√≠a
proporcionar
,
una
tasa
de
transfe-


rencia
disponible
garantizada
a
un
cierta
velocidad
especificada
.
Con
un
servicio
as√≠
,
la
apli-


caci√≥n
podr√≠a
solicitar
una
tasa
de
transferencia
garantizada
de
r
bits
/
segundo
y
el
protocolo


de
transporte
podr√≠a
entonces
garantizar
que
la
tasa
de
transferencia
disponible
sea
siempre


al
menos
de
r
bits
/
segundo
.
Un
servicio
que
ofreciera
una
tasa
de
transferencia
garantizada


resultar√≠a
atractivo
para
muchas
aplicaciones
.
Por
ejemplo
,
si
una
aplicaci√≥n
de
telefon√≠a
por


Internet
codifica
voz
a
32
kbps
,
tendr√°
que
enviar
datos
a
la
red
y
tendr√°
que
entregar
los


datos
a
la
aplicaci√≥n
receptora
a
esa
velocidad
.
Si
el
protocolo
de
transporte
no
puede
pro-


porcionar
esa
tasa
de
transferencia
,
la
aplicaci√≥n
tendr√°
que
realizar
la
codificaci√≥n
a
una


velocidad
menor
(
y
recibir
a
una
tasa
de
transferencia
adecuada
como
para
mantener
esa


velocidad
de
codificaci√≥n
m√°s
lenta
)
o
bien
tendr√°
que
renunciar
,
puesto
que
recibir
a
la


mitad
de
la
tasa
de
transferencia
necesaria
no
tiene
ninguna
utilidad
para
esta
 
aplicaci√≥n
de


telefon√≠a
por
Internet
.
Las
aplicaciones
con
requisitos
de
tasa
de
transferencia
se
conocen


como
aplicaciones
sensibles
al
ancho
de
banda
.
Muchas
aplicaciones
multimedia
actuales


son
sensibles
al
ancho
de
banda
,
pero
algunas
de
ellas
pueden
emplear
t√©cnicas
de
codifica-


ci√≥n
adaptativa
para
realizar
la
codificaci√≥n
a
una
velocidad
que
se
adapte
a
la
tasa
de
trans-


ferencia
disponible
actualmente
.


Mientras
que
las
aplicaciones
sensibles
al
ancho
de
banda
tienen
que
cumplir
requisitos


espec√≠ficos
para
la
tasa
de
transferencia
,
las
aplicaciones
el√°sticas
pueden
hacer
uso
de
la


tasa
de
transferencia
,
mucha
o
poca
,
que
haya
disponible
.
El
correo
electr√≥nico
,
la
transfe-


rencia
de
archivos
y
las
transferencias
web
son
todas
ellas
aplicaciones
el√°sticas
.
Por


supuesto
,
cuanto
mayor
sea
la
tasa
de
transferencia
,
mejor
.
 

Temporizaci√≥n


Un
protocolo
de
la
capa
de
transporte
tambi√©n
puede
proporcionar
garant√≠as
de
temporiza-


ci√≥n
.
Al
igual
que
con
las
tasas
de
transferencia
garantizadas
,
las
garant√≠as
de
temporizaci√≥n


tambi√©n
pueden
darse
de
diversas
formas
.
Un
ejemplo
de
garant√≠a
podr√≠a
ser
que
cada
bit


que
el
emisor
empuja
por
su
socket
llegue
al
socket
del
receptor
en
no
m√°s
de
100
milisegun-


dos
.
Un
servicio
as√≠
ser√≠a
atractivo
para
las
aplicaciones
interactivas
en
tiempo
real
,
como
la


telefon√≠a
por
Internet
,
los
entornos
virtuales
,
la
teleconferencia
y
los
juegos
multijugador
,


todas
las
cuales
requieren
restricciones
de
temporizaci√≥n
muy
estrictas
sobre
la
entrega
de


datos
para
ser
efectivas
.
(
V√©ase
el
Cap√≠tulo
7
y
[
Gauthier
1999
;
Ramjee
1994
]
.
)
Por
ejemplo
,


los
retardos
largos
en
la
telefon√≠a
por
Internet
tienden
a
dar
lugar
a
pausas
antinaturales
en


una
conversaci√≥n
;
en
un
juego
multijugador
o
en
un
entorno
virtual
interactivo
,
un
retardo


largo
entre
la
realizaci√≥n
de
una
acci√≥n
y
la
visualizaci√≥n
de
la
respuesta
del
entorno
(
por


ejemplo
,
de
otro
jugador
que
se
encuentra
en
el
otro
extremo
de
una
conexi√≥n
extremo
a


extremo
)
hace
que
la
aplicaci√≥n
parezca
menos
realista
.
En
las
aplicaciones
que
no
se
ejecu-


tan
en
tiempo
real
,
siempre
es
preferible
un
retardo
peque√±o
que
grande
,
pero
no
se
aplican


restricciones
estrictas
a
los
retardos
extremo
a
extremo
.


2.1
‚Ä¢
PRINCIPIOS
DE
LAS
APLICACIONES
DE
RED
89


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
89Seguridad


Por
√∫ltimo
,
un
protocolo
de
transporte
puede
proporcionar
a
una
aplicaci√≥n
uno
o
m√°s
servi-


cios
de
seguridad
.
Por
ejemplo
,
en
el
host
emisor
,
un
protocolo
de
transporte
puede
cifrar


todos
los
datos
transmitidos
por
el
proceso
emisor
,
y
en
el
host
receptor
puede
descifrar
los


datos
antes
de
entregarlos
al
proceso
receptor
.
Un
servicio
as√≠
debe
proporcionar
confiden-


cialidad
entre
los
dos
procesos
,
incluso
aunque
los
datos
sean
observados
de
alguna
manera


entre
los
procesos
emisor
y
receptor
.
Un
protocolo
de
transporte
tambi√©n
puede
proporcio-


nar
otros
servicios
de
seguridad
adem√°s
del
de
la
confidencialidad
,
como
pueden
ser
los


mecanismos
para
garantizar
la
integridad
de
los
datos
y
mecanismos
de
autenticaci√≥n
en
el


punto
terminal
,
temas
que
abordaremos
en
detalle
en
el
Cap√≠tulo
8
.


2.1.4
Servicios
de
transporte
proporcionados
por
Internet


Hasta
el
momento
hemos
considerado
los
servicios
de
transporte
que
una
red
de
computa-


doras
podr√≠a
proporcionar
en
general
.
Seamos
ahora
un
poco
m√°s
espec√≠ficos
y
examine-


mos
el
tipo
de
soporte
que
Internet
proporciona
a
las
aplicaciones
.
Internet
(
y
,
de
forma
m√°s


general
,
las
redes
TCP
/
IP
)
pone
a
disposici√≥n
de
las
aplicaciones
dos
protocolos
de
trans-


porte
:
UDP
y
TCP
.
Cuando
como
desarrollador
de
aplicaciones
cree
una
nueva
aplicaci√≥n


de
red
para
Internet
,
una
de
las
primeras
decisiones
que
tendr√°
que
tomar
es
si
utilizar
UDP


o
TCP
.
Cada
uno
de
estos
protocolos
ofrece
un
conjunto
diferente
de
servicios
a
las
aplica-


ciones
que
los
invocan
.
La
Figura
2.4
detalla
los
requisitos
de
servicio
para
algunas
aplica-


ciones
seleccionadas
.


Servicios
TCP


El
modelo
de
servicio
TCP
incluye
un
servicio
orientado
a
la
conexi√≥n
y
un
servicio
de


transferencia
de
datos
fiable
.
Cuando
una
aplicaci√≥n
invoca
TCP
como
su
protocolo
de


transporte
,
la
aplicaci√≥n
recibe
estos
dos
servicios
de
TCP
.


Aplicaci√≥n
P√©rdida
de
datos
Ancho
de
banda
Sensible
al
tiempo


Transferencia
de
archivos
Sin
p√©rdidas
El√°stica
No


Corre
electr√≥nico
Sin
p√©rdidas
El√°stica
No


Documentos
web
Sin
p√©rdidas
El√°stica
(
pocos
kbps
)
No


Telefon√≠a
por
Internet/
Tolerante
a
las
Audio
:
unos
pocos
kbps‚Äì1
Mbps
S√≠
:
d√©cimas
de
segundo


Videoconferencia
p√©rdidas
V√≠deo
:
10
kbps‚Äì5
Mbps


Audio
/
v√≠deo
almacenado
Tolerante
a
las
Como
el
anterior
S√≠
:
unos
pocos
segundos


p√©rdidas


Juegos
interactivos
Tolerante
a
las
Unos
pocos
kbps‚Äì10
kbps
S√≠
:
d√©cimas
de
segundos


p√©rdidas


Mensajer√≠a
instant√°nea
Sin
p√©rdidas
El√°stica
S√≠
y
no


Figura
2.4
‚Ä¢
Requisitos
de
algunas
aplicaciones
de
red
seleccionadas
.


90
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
90‚Ä¢
Servicio
orientado
a
la
conexi√≥n
.
TCP
hace
que
el
cliente
y
el
servidor
intercambien
la


informaci√≥n
de
control
de
la
capa
de
transporte
entre
s√≠
antes
de
que
empiecen
a
fluir
los


mensajes
del
nivel
de
aplicaci√≥n
.
Este
procedimiento
denominado
de
negociaci√≥n
,
de


reconocimiento
o
de
establecimiento
de
la
conexi√≥n
alerta
al
cliente
y
al
servidor
,
permi-


ti√©ndoles
prepararse
para
el
intercambio
de
paquetes
.
Despu√©s
de
esta
fase
de
negocia-


ci√≥n
,
se
dice
que
existe
una
conexi√≥n
TCP
entre
los
sockets
de
los
dos
procesos
.
La


conexi√≥n
es
una
conexi√≥n
full-duplex
ya
que
los
dos
procesos
pueden
enviarse
mensajes


entre
s√≠
a
trav√©s
de
la
conexi√≥n
al
mismo
tiempo
.
Una
vez
que
la
aplicaci√≥n
ha
terminado


de
enviar
mensajes
,
es
necesario
desactivar
la
conexi√≥n
.
Se
dice
que
es
un
servicio
‚Äú
orien-


tado
a
la
conexi√≥n
‚Äù
en
lugar
de
un
servicio
de
‚Äú
conexi√≥n
‚Äù
porque
los
dos
procesos
est√°n


conectados
de
una
forma
muy
laxa
.
En
el
Cap√≠tulo
3
examinaremos
los
servicios
orienta-


dos
a
la
conexi√≥n
y
veremos
c√≥mo
se
implementan
.


‚Ä¢
Servicio
de
transferencia
de
datos
fiable
.
Los
procesos
de
comunicaci√≥n
pueden
confiar


en
TCP
para
entregar
todos
los
datos
enviados
sin
errores
y
en
el
orden
correcto
.
Cuando


un
lado
de
la
aplicaci√≥n
pasa
un
flujo
de
bytes
a
un
socket
,
puede
contar
con
TCP
para


entregar
el
mismo
flujo
de
bytes
al
socket
receptor
sin
p√©rdida
ni
duplicaci√≥n
de
bytes
.


TCP
tambi√©n
incluye
un
mecanismo
de
control
de
congesti√≥n
,
que
es
un
servicio
para


mejorar
el
funcionamiento
general
de
Internet
,
m√°s
que
para
el
beneficio
directo
de
los
pro-


cesos
que
se
comunican
.
Este
mecanismo
de
control
de
congesti√≥n
de
TCP
regula
el
proceso


emisor
(
cliente
o
servidor
)
cuando
la
red
est√°
congestionada
entre
el
emisor
y
el
receptor
.


Como
se
explica
en
el
Cap√≠tulo
3
,
el
control
de
congesti√≥n
de
TCP
tambi√©n
intenta
limitar


cada
conexi√≥n
TCP
para
que
utilice
una
cuota
equitativa
de
ancho
de
banda
de
la
red
.
La


regulaci√≥n
de
la
velocidad
de
transmisi√≥n
puede
tener
efectos
muy
da√±inos
sobre
las
aplica-


ciones
de
audio
y
de
v√≠deo
en
tiempo
real
,
que
tienen
unos
requisitos
m√≠nimos
de
tasa
de


transferencia
.
Adem√°s
,
las
aplicaciones
en
tiempo
real
son
tolerantes
a
las
p√©rdidas
y
no
nece-


sitan
un
servicio
de
transporte
completamente
fiable
.
Por
estas
razones
,
los
desarrolladores


de
aplicaciones
en
tiempo
real
a
menudo
deciden
ejecutar
sus
aplicaciones
utilizando
el
pro-


tocolo
UDP
en
lugar
de
TCP
.


Servicios
UDP


UDP
es
un
protocolo
de
transporte
ligero
simple
que
proporciona
unos
servicios
m√≠nimos
y


no
est√°
orientado
a
la
conexi√≥n
,
por
lo
que
no
tiene
lugar
un
procedimiento
de
negociaci√≥n


antes
de
que
los
dos
procesos
comiencen
a
comunicarse
.
UDP
proporciona
un
servicio
de


transferencia
de
datos
no
fiable
;
es
decir
,
cuando
un
proceso
env√≠a
un
mensaje
a
un
socket


UDP
,
el
protocolo
UDP
no
ofrece
ninguna
garant√≠a
de
que
el
mensaje
vaya
a
llegar
al
pro-


ceso
receptor
.
Adem√°s
,
los
mensajes
que
s√≠
llegan
al
proceso
receptor
pueden
hacerlo
de


manera
desordenada
.


UDP
no
incluye
tampoco
un
mecanismo
de
control
de
congesti√≥n
,
por
lo
que
el
lado


emisor
de
UDP
puede
introducir
datos
en
la
capa
inferior
(
la
capa
de
red
)
a
la
velocidad
que


le
parezca
.
(
Sin
embargo
,
debe
observar
que
la
tasa
de
transferencia
extremo
a
extremo
 
real


puede
ser
menor
que
esta
velocidad
a
causa
del
ancho
de
banda
limitado
de
los
enlaces
inter-


vinientes
o
a
causa
de
la
congesti√≥n
.
)
Puesto
que
las
aplicaciones
en
tiempo
real
a
menudo


pueden
tolerar
ciertas
p√©rdidas
pero
requieren
una
velocidad
m√≠nima
para
ser
efectivas
,
los


desarrolladores
de
estas
aplicaciones
en
ocasiones
deciden
ejecutarlas
usando
UDP
,
sosla-


yando
los
mecanismos
de
control
de
congesti√≥n
y
la
sobrecarga
de
gesti√≥n
de
los
paquetes


TCP
.
Por
otro
lado
,
dado
que
muchos
cortafuegos
est√°n
configurados
para
bloquear
casi


2.1
‚Ä¢
PRINCIPIOS
DE
LAS
APLICACIONES
DE
RED
91


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
91todos
los
tipos
de
tr√°fico
UDP
,
los
dise√±adores
est√°n
decidiendo
cada
vez
m√°s
frecuente-


mente
ejecutar
las
aplicaciones
multimedia
en
tiempo
real
sobre
TCP
[
Sripanidkulchai


2004
]
.


Servicios
no
proporcionados
por
los
protocolos
de
transporte
de
Internet


Hemos
organizado
los
posibles
servicios
del
protocolo
de
transporte
seg√∫n
cuatro
par√°me-


tros
:
transferencia
de
datos
fiable
,
tasa
de
transferencia
,
temporizaci√≥n
y
seguridad
.
¬ø
Cu√°les


de
estos
servicios
proporcionan
TCP
y
UDP
?
Ya
hemos
mencionado
que
TCP
proporciona


transferencia
de
datos
extremo
a
extremo
fiable
.
Y
tambi√©n
sabemos
que
TCP
se
puede


mejorar
f√°cilmente
en
la
capa
de
aplicaci√≥n
con
SSL
para
proporcionar
servicios
de
seguri-


dad
.
Pero
en
esta
breve
descripci√≥n
de
TCP
y
UDP
hemos
omitido
notoriamente
hacer
men-


ci√≥n
de
las
garant√≠as
relativas
a
la
tasa
de
transferencia
o
la
temporizaci√≥n
(
servicios
que
no


proporcionan
los
protocolos
de
transporte
de
Internet
de
hoy
d√≠a
)
.
¬ø
Significa
esto
que
las


aplicaciones
sensibles
al
tiempo
como
la
telefon√≠a
por
Internet
no
se
pueden
ejecutar
actual-


mente
en
Internet
?
Evidentemente
,
la
respuesta
es
no
,
Internet
lleva
muchos
a√±os
albergando


aplicaciones
sensibles
al
tiempo
.
Estas
aplicaciones
suelen
funcionar
bastante
bien
porque


han
sido
dise√±adas
para
hacer
frente
a
esta
falta
de
garant√≠as
de
la
mejor
forma
posible
.
En


92
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


TCP
SEGURO


Ni
TCP
ni
UDP
proporcionan
ning√∫n
mecanismo
de
cifrado
(
los
datos
que
el
proceso
emisor


pasa
al
socket
son
los
mismos
datos
que
viajan
a
trav√©s
de
la
red
hasta
el
proceso
de


destino
)
.
Luego
,
por
ejemplo
,
si
el
proceso
emisor
env√≠a
una
contrase√±a
en
texto
legible
(
es


decir
,
no
cifrada
)
a
su
socket
,
esa
contrase√±a
viajar√°
a
trav√©s
de
todos
los
enlaces
entre
el


emisor
y
el
receptor
,
pudiendo
ser
husmeada
y
descubierta
en
cualquiera
de
los
enlaces


intervinientes
.
Puesto
que
la
confidencialidad
y
otras
cuestiones
de
seguridad
son
cr√≠ticas


para
muchas
aplicaciones
,
la
comunidad
de
Internet
ha
desarrollado
una
mejora
para
TCP
,


denominada
SSL
(
Secure
Sockets
Layer
,
Capa
de
conectores
seguros
)
.
TCP
mejorado
con


SSL
no
s√≥lo
hace
todo
lo
que
hace
el
protocolo
TCP
tradicional
,
sino
que
tambi√©n
proporcio-


na
servicios
cr√≠ticos
de
seguridad
proceso
a
proceso
,
entre
los
que
se
incluyen
mecanismos


de
cifrado
,
de
integridad
de
los
datos
y
de
autenticaci√≥n
en
el
punto
terminal
.
Debemos


destacar
que
SSL
no
es
un
tercer
protocolo
de
transporte
de
Internet
,
al
mismo
nivel
que


TCP
y
UDP
,
sino
que
es
una
mejora
de
TCP
,
que
se
implementa
en
la
capa
de
aplicaci√≥n
.


En
concreto
,
si
una
aplicaci√≥n
desea
utilizar
los
servicios
de
SSL
,
tiene
que
incluir
c√≥digo
SSL


(
existen
clases
y
librer√≠as
enormemente
optimizadas
)
tanto
en
el
lado
del
cliente
como
en
el


del
servidor
de
la
aplicaci√≥n
.
SSL
tiene
su
propia
API
de
sockets
,
que
es
similar
a
la
API
de


sockets
del
protocolo
TCP
tradicional
.
Cuando
una
aplicaci√≥n
utiliza
SSL
,
el
proceso
emisor


pasa
los
datos
en
texto
legible
al
socket
SSL
;
a
continuaci√≥n
,
SSL
cifra
los
datos
en
el
host


emisor
y
los
pasa
al
socket
TCP
.
Los
datos
cifrados
viajan
a
trav√©s
de
Internet
hasta
el
socket


TCP
del
proceso
receptor
.
El
socket
de
recepci√≥n
pasa
los
datos
cifrados
a
SSL
,
que
los


descifra
.
Por
√∫ltimo
,
SSL
pasa
los
datos
en
texto
legible
a
trav√©s
de
su
socket
al
proceso


receptor
.
En
el
Cap√≠tulo
8
se
cubre
en
detalle
SSL
.


SEGURIDAD


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
92Aplicaci√≥n
Protocolo
de
la
capa
 
Protocolo
de
transporte


de
aplicaci√≥n
subyacente


Correo
electr√≥nico
SMTP
[
RFC
5321
]
TCP


Acceso
remoto
a
terminal
Telnet
[
RFC
854
]
TCP


Web
HTTP
[
RFC
2616
]
TCP


Transferencia
de
archivos
FTP
[
RFC
959
]
TCP


Flujos
multimedia
HTTP
(
por
ejemplo
,
YouTube
)
,
RTP
TCP
o
UDP


Telefon√≠a
por
Internet
SIP
,
RTP
,
o
proprietario
(
por
ejemplo
,
Skype
)
T√≠picamente
UDP


Figura
2.5
‚Ä¢
Aplicaciones
populares
de
Internet
,
sus
protocolos
de
la
capa
de


aplicaci√≥n
y
sus
protocolos
de
transporte
subyacentes
.


el
Cap√≠tulo
7
veremos
algunos
de
estos
trucos
de
dise√±o
.
No
obstante
,
un
dise√±o
inteli-


gente
tiene
sus
limitaciones
cuando
el
retardo
es
excesivo
,
como
suele
ocurrir
a
menudo


en
el
caso
de
la
Internet
p√∫blica
.
En
resumen
,
actualmente
Internet
puede
ofrecer
servicios


satisfactorios
a
las
aplicaciones
sensibles
al
tiempo
,
pero
no
puede
proporcionar
ninguna


garant√≠a
de
ancho
de
banda
ni
de
temporizaci√≥n
.


La
Figura
2.5
enumera
los
protocolos
de
transporte
utilizados
por
algunas
aplicaciones


populares
de
Internet
.
Veremos
que
aplicaciones
como
el
correo
electr√≥nico
,
el
acceso


remoto
a
terminales
,
la
Web
y
la
transferencia
de
archivos
utilizan
TCP
.
Estas
aplicaciones


han
elegido
TCP
principalmente
porque
este
protocolo
ofrece
un
servicio
de
transferencia


de
datos
fiable
,
garantizando
que
todos
los
datos
llegar√°n
finalmente
a
su
destino
.
Tambi√©n


hemos
visto
que
normalmente
la
telefon√≠a
por
Internet
se
ejecuta
sobre
UDP
.
Cada
lado
de


una
aplicaci√≥n
de
telefon√≠a
por
Internet
necesita
enviar
datos
a
trav√©s
de
la
red
a
una
cierta


velocidad
m√≠nima
(
v√©ase
el
audio
en
tiempo
real
en
la
Figura
2.4
)
;
esto
ser√°
posible
m√°s
pro-


bablemente
con
UDP
que
con
TCP
.
Adem√°s
,
las
aplicaciones
de
telefon√≠a
por
Internet
son


tolerantes
a
las
p√©rdidas
de
datos
,
por
lo
que
no
necesitan
el
servicio
de
transferencia
de


datos
fiable
proporcionado
por
TCP
.


Direccionamiento
de
procesos


Hasta
el
momento
nos
hemos
centrado
en
los
servicios
de
transporte
existentes
entre
dos


procesos
que
se
comunican
.
Pero
,
¬ø
c√≥mo
indica
un
proceso
con
qu√©
proceso
desea
comuni-


carse
utilizando
estos
servicios
?
¬ø
C√≥mo
especifica
un
proceso
que
se
ejecuta
en
un
host


situado
en
Amherst
,
Massachusetts
,
Estados
Unidos
,
que
desea
comunicarse
con
un
deter-


minado
proceso
que
est√°
ejecut√°ndose
en
un
host
ubicado
en
Bangkok
,
Tailandia
?
Para
iden-


tificar
al
proceso
de
recepci√≥n
,
tienen
que
especificarse
dos
elementos
de
informaci√≥n
:
(
1
)


el
nombre
o
direcci√≥n
del
host
y
(
2
)
un
identificador
que
especifique
el
proceso
de
recep-


ci√≥n
en
el
host
de
destino
.


En
Internet
,
el
host
se
identifica
mediante
su
direcci√≥n
IP
.
En
el
Cap√≠tulo
4
veremos
en


detalle
las
direcciones
IP
.
Por
el
momento
,
todo
lo
que
necesitamos
saber
es
que
una
direc-


ci√≥n
IP
es
una
magnitud
de
32
bits
que
identifica
de
forma
un√≠voca
a
un
host
.
(
Sin
embargo
,


como
veremos
en
el
Cap√≠tulo
4
,
la
extendida
implantaci√≥n
de
los
traductores
de
direcciones


2.1
‚Ä¢
PRINCIPIOS
DE
LAS
APLICACIONES
DE
RED
93


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
93de
red
(
NAT
,
Network
Address
Translators
)
ha
hecho
que
,
en
la
pr√°ctica
,
una
√∫nica
direc-


ci√≥n
IP
de
32
bits
no
defina
solamente
a
un
host
.
)


Adem√°s
de
conocer
la
direcci√≥n
del
host
al
que
est√°
destinado
un
mensaje
,
el
host
emi-


sor
tambi√©n
debe
identificar
el
proceso
de
recepci√≥n
que
est√°
ejecut√°ndose
en
el
host
.
Esta


informaci√≥n
es
necesaria
porque
,
en
general
,
un
host
podr√≠a
estar
ejecutando
muchas
aplica-


ciones
de
red
.
Un
n√∫mero
de
puerto
de
destino
sirve
a
este
prop√≥sito
.
Las
aplicaciones
popu-


lares
tienen
asignados
n√∫meros
de
puerto
espec√≠ficos
.
Por
ejemplo
,
un
servidor
web
queda


identificado
por
el
n√∫mero
de
puerto
80
.
Un
proceso
de
un
servidor
de
correo
(
que
utilice
el


protocolo
SMTP
)
se
identifica
mediante
el
n√∫mero
de
puerto
25
.
Puede
encontrar
una
lista


de
n√∫meros
de
puerto
bien
conocidos
para
todos
los
protocolos
est√°ndar
de
Internet
en


http://www.iana.org
.
Cuando
un
desarrollador
crea
una
nueva
aplicaci√≥n
de
red
,
√©sta
debe


asignarse
a
un
nuevo
n√∫mero
de
puerto
.
Examinaremos
los
n√∫meros
de
puerto
en
detalle
en


el
Cap√≠tulo
3
.


2.1.5
Protocolos
de
la
capa
de
aplicaci√≥n


Acabamos
de
aprender
que
los
procesos
de
red
se
comunican
entre
s√≠
enviando
mensajes
a


sus
sockets
.
Pero
,
¬ø
c√≥mo
est√°n
estructurados
estos
mensajes
?
¬ø
Cu√°l
es
el
significado
de
cada


uno
de
los
campos
de
estos
mensajes
?
¬ø
Cu√°ndo
env√≠an
los
procesos
los
mensajes
?
Estas
pre-


guntas
nos
llevan
al
√°mbito
de
los
protocolos
de
la
capa
de
aplicaci√≥n
.
Un
protocolo
de
la


capa
de
aplicaci√≥n
define
c√≥mo
los
procesos
de
una
aplicaci√≥n
,
que
se
ejecutan
en
distintos


sistemas
terminales
,
se
pasan
los
mensajes
entre
s√≠
.
En
particular
,
un
protocolo
de
la
capa
de


aplicaci√≥n
define
:


‚Ä¢L
o
s
 
t
i
p
o
s
 
d
e
 
m
e
n
s
a
j
e
s
 
i
n
t
e
r
c
a
m
b
i
a
d
o
s
;
 
p
o
r
 
e
j
e
m
p
l
o
,
 
m
e
n
s
a
j
e
s
 
d
e
 
s
o
l
i
c
i
t
u
d
 
y
 
m
e
n
s
a
j
e
s
 
d
e


respuesta
.


‚Ä¢L
a
 
s
i
n
t
a
x
i
s
 
d
e
 
l
o
s
 
d
i
v
e
r
s
o
s
 
t
i
p
o
s
 
d
e
 
m
e
n
s
a
j
e
s
,
 
e
s
 
d
e
c
i
r
,
 
l
o
s
 
c
a
m
p
o
s
 
d
e
 
l
o
s
 
q
u
e
 
c
o
n
s
t
a
 
e
l


mensaje
y
c√≥mo
se
delimitan
esos
campos
.


‚Ä¢L
a
 
s
e
m
√°
n
t
i
c
a
 
d
e
 
l
o
s
 
c
a
m
p
o
s
,
 
e
s
 
d
e
c
i
r
,
 
e
l
 
s
i
g
n
i
f
i
c
a
d
o
 
d
e
 
l
a
 
i
n
f
o
r
m
a
c
i
√≥
n
 
c
o
n
t
e
n
i
d
a
 
e
n
 
l
o
s


campos
.


‚Ä¢L
a
s
 
r
e
g
l
a
s
 
p
a
r
a
 
d
e
t
e
r
m
i
n
a
r
 
c
u
√°
n
d
o
 
y
 
c
√≥
m
o
 
u
n
 
p
r
o
c
e
s
o
 
e
n
v
√≠
a
 
m
e
n
s
a
j
e
s
 
y
 
r
e
s
p
o
n
d
e
 
a
 
l
o
s


mismos
.


Algunos
protocolos
de
la
capa
de
aplicaci√≥n
est√°n
especificados
en
documentos
RFC
y
,
por


tanto
,
son
de
dominio
p√∫blico
.
Por
ejemplo
,
el
protocolo
de
la
capa
de
aplicaci√≥n
para
la


Web
,
HTTP
(
HyperText
Transfer
Protocol
[
RFC
2616
]
)
,
est√°
disponible
como
un
RFC
.
Si


un
navegador
web
sigue
las
reglas
dadas
en
el
RFC
que
se
ocupa
de
HTTP
,
el
navegador


podr√°
recuperar
p√°ginas
web
de
cualquier
servidor
web
que
tambi√©n
se
ajuste
a
dicho
RFC
.


Existen
muchos
otros
protocolos
de
la
capa
de
aplicaci√≥n
que
son
propietarios
y
que
inten-


cionadamente
no
est√°n
disponibles
para
todo
el
mundo
.
Por
ejemplo
,
muchos
de
los
siste-


mas
de
compartici√≥n
de
archivos
P2P
existentes
utilizan
protocolos
de
la
capa
de
aplicaci√≥n


propietarios
.


Es
importante
diferenciar
entre
aplicaciones
de
red
y
protocolos
de
la
capa
de
aplica-


ci√≥n
.
Un
protocolo
de
la
capa
de
aplicaci√≥n
es
√∫nicamente
un
elemento
de
una
aplicaci√≥n
de


red
.
Veamos
un
par
de
ejemplos
.
La
Web
es
una
aplicaci√≥n
cliente-servidor
que
permite
a


los
usuarios
obtener
documentos
almacenados
en
servidores
web
bajo
demanda
.
La
Web


consta
de
muchos
componentes
,
entre
los
que
se
incluyen
un
est√°ndar
para
los
formatos
de


documentos
(
es
decir
,
HTML
)
,
navegadores
web
(
como
Firefox
y
Microsoft
Internet
Explo-


94
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
94rer
)
,
servidores
web
(
por
ejemplo
,
servidores
Apache
y
Microsoft
)
y
un
protocolo
de
la
capa


de
aplicaci√≥n
.
El
protocolo
de
la
capa
de
aplicaci√≥n
de
la
Web
,
HTTP
,
define
el
formato
y
la


secuencia
de
los
mensajes
que
se
pasan
entre
el
navegador
web
y
el
servidor
web
.
Por
tanto
,


HTTP
es
s√≥lo
una
pieza
(
aunque
una
pieza
importante
)
de
la
aplicaci√≥n
web
.
Otro
ejemplo


ser√≠a
una
aplicaci√≥n
de
correo
electr√≥nico
Internet
,
la
cual
tambi√©n
est√°
constituida
por


muchos
componentes
,
entre
los
que
se
incluyen
,
los
servidores
de
correo
que
albergan
los


buzones
de
los
usuarios
;
los
lectores
de
correo
que
permiten
a
los
usuarios
leer
y
crear
men-


sajes
;
un
est√°ndar
para
definir
la
estructura
de
los
mensajes
de
correo
electr√≥nico
y
los
pro-


tocolos
de
la
capa
de
aplicaci√≥n
que
definen
c√≥mo
se
pasan
los
mensajes
entre
los


servidores
,
c√≥mo
se
pasan
los
mensajes
entre
los
servidores
y
los
lectores
de
correo
y
c√≥mo


se
interpretan
los
contenidos
de
ciertas
partes
de
los
mensajes
(
como
por
ejemplo
,
la
cabe-


cera
)
.
El
principal
protocolo
de
la
capa
de
aplicaci√≥n
para
el
correo
electr√≥nico
es
el
proto-


colo
SMTP
(
Simple
Mail
Transfer
Protocol
,
Protocolo
simple
de
transferencia
de
correo
)


[
RFC
5321
]
.
Por
tanto
,
el
protocolo
SMTP
s√≥lo
es
un
componente
(
aunque
un
componente


importante
)
de
la
aplicaci√≥n
de
correo
electr√≥nico
.


2.1.6
Aplicaciones
de
red
en
este
libro


Todos
los
d√≠as
se
desarrollan
nuevas
aplicaciones
de
Internet
tanto
de
dominio
p√∫blico
como


propietarias
.
En
lugar
de
abordar
un
gran
n√∫mero
de
aplicaciones
de
Internet
a
modo
de


enciclopedia
,
hemos
decidido
centrarnos
en
unas
pocas
aplicaciones
dominantes
e
impor-


tantes
.
En
este
cap√≠tulo
abordaremos
cinco
aplicaciones
importantes
:
Web
,
transferencia
de


archivos
,
correo
electr√≥nico
,
servicio
de
directorio
y
P2P.
En
primer
lugar
veremos
la
Web
,


no
s√≥lo
porque
es
una
aplicaci√≥n
enormemente
popular
,
sino
porque
tambi√©n
su
protocolo


de
la
capa
de
aplicaci√≥n
,
HTTP
,
es
sencillo
y
f√°cil
de
comprender
.
Despu√©s
de
ver
esta
apli-


caci√≥n
,
pasaremos
a
examinar
brevemente
FTP
,
porque
proporciona
un
buen
contraste
con


HTTP
.
A
continuaci√≥n
,
veremos
la
aplicaci√≥n
de
correo
electr√≥nico
,
que
es
la
aplicaci√≥n
m√°s


popular
de
Internet
.
El
correo
electr√≥nico
es
m√°s
complejo
que
la
Web
en
el
sentido
de
que


no
utiliza
uno
sino
varios
protocolos
de
la
capa
de
aplicaci√≥n
.
A
continuaci√≥n
,
abordaremos


el
sistema
DNS
,
que
proporciona
un
servicio
de
directorio
a
Internet
.
La
mayor√≠a
de
los


usuarios
no
interact√∫an
directamente
con
DNS
;
en
su
lugar
,
invocan
indirectamente
a
DNS
a


trav√©s
de
otras
aplicaciones
(
entre
las
que
se
incluyen
las
aplicaciones
web
,
de
transferencia


de
archivos
y
de
correo
electr√≥nico
)
.
DNS
ilustra
c√≥mo
puede
implementarse
en
la
capa
de


aplicaci√≥n
de
Internet
un
elemento
de
la
funcionalidad
de
red
b√°sica
(
traducci√≥n
nombre
de


red
a
direcci√≥n
de
red
)
.
Por
√∫ltimo
,
veremos
varias
aplicaciones
P2P
,
como
la
distribuci√≥n


de
archivos
,
las
bases
de
datos
distribuidas
y
la
telefon√≠a
IP
.


2.2
La
Web
y
HTTP


Hasta
principios
de
la
d√©cada
de
1990
,
Internet
era
utilizada
principalmente
por
investigado-


res
,
profesores
y
estudiantes
universitarios
para
acceder
a
hosts
remotos
,
transferir
archivos


desde
los
hosts
locales
a
los
hosts
remotos
,
y
viceversa
;
y
recibir
y
enviar
noticias
y
 
mensa-


jes
de
correo
electr√≥nico
.
Aunque
estas
aplicaciones
eran
(
y
contin√∫an
siendo
)
extremada-


mente
√∫tiles
,
Internet
era
pr√°cticamente
desconocida
fuera
de
las
comunidades
acad√©micas
y


dedicadas
a
la
investigaci√≥n
.
Fue
entonces
,
a
principios
de
la
d√©cada
de
1990
,
cuando
una


nueva
aplicaci√≥n
importante
apareci√≥
en
escena
:
la
World
Wide
Web
[
Berners-Lee
1994
]
.


2.2
‚Ä¢
LA
WEB
Y
HTTP
95


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
95La
Web
fue
la
primera
aplicaci√≥n
de
Internet
que
atrajo
la
atenci√≥n
del
p√∫blico
general
.


Cambi√≥
de
manera
dram√°tica
,
y
contin√∫a
cambiando
,
la
forma
en
que
las
personas
interac-


t√∫an
dentro
y
fuera
de
sus
entornos
de
trabajo
.
Hizo
que
Internet
pasar√°
de
ser
una
de
las


muchas
redes
de
datos
a
ser
pr√°cticamente
la
√∫nica
red
de
datos
.


Quiz√°
lo
que
atrae
a
la
mayor√≠a
de
los
usuarios
es
que
la
Web
opera
bajo
demanda
.
Los


usuarios
reciben
lo
que
desean
y
cuando
lo
desean
.
Es
muy
diferente
a
la
radio
y
la
televi-


si√≥n
,
que
fuerza
a
los
usuarios
a
sintonizar
los
programas
cuando
el
proveedor
de
contenido


tiene
disponible
el
contenido
.
Adem√°s
de
estar
disponible
bajo
demanda
,
la
Web
disfruta
de


muchas
otras
maravillosas
funciones
que
a
todo
el
mundo
le
gustan
.
Para
cualquier
indivi-


duo
es
tremendamente
f√°cil
publicar
informaci√≥n
en
la
Web
(
todo
el
mundo
puede
conver-


tirse
en
editor
con
unos
costes
extremadamente
bajos
)
.
Los
hiperv√≠nculos
y
los
motores
de


b√∫squeda
nos
ayudan
a
navegar
a
trav√©s
de
un
oc√©ano
de
sitios
web
.
Los
gr√°ficos
estimulan


nuestros
sentidos
.
Los
formularios
,
los
applets
de
Java
y
muchos
otros
dispositivos
nos
per-


miten
interactuar
con
las
p√°ginas
y
sitios
.
Cada
vez
m√°s
,
la
Web
proporciona
una
interfaz
de


men√∫s
para
grandes
cantidades
de
material
de
audio
y
v√≠deo
almacenado
en
Internet
(
mate-


rial
multimedia
bajo
demanda
)
.


2.2.1
Introducci√≥n
a
HTTP


El
Protocolo
de
transferencia
de
hipertexto
(
HTTP
,
HyperText
Transfer
Protocol
)
es
el
pro-


tocolo
de
la
capa
de
aplicaci√≥n
de
la
Web
y
se
encuentra
en
el
coraz√≥n
de
la
Web
.
Est√°
defi-


nido
en
los
documentos
[
RFC
1945
]
y
[
RFC
2616
]
.
HTTP
se
implementa
en
dos
programas
:


un
programa
cliente
y
un
programa
servidor
.
El
programa
cliente
y
el
programa
servidor
,


que
se
ejecutan
en
sistemas
terminales
diferentes
,
se
comunican
entre
s√≠
intercambiando


mensajes
HTTP
.
HTTP
define
la
estructura
de
estos
mensajes
y
c√≥mo
el
cliente
y
el
servidor


intercambian
los
mensajes
.
Antes
de
explicar
en
detalle
HTTP
,
vamos
a
hacer
un
breve


repaso
de
la
terminolog√≠a
Web
.


Una
p√°gina
web
(
tambi√©n
denominada
documento
web
)
consta
de
objetos
.
Un
objeto


es
simplemente
un
archivo
(
como
por
ejemplo
,
un
archivo
HTML
,
una
imagen
JPEG
,
un


applet
Java
o
un
clip
de
v√≠deo
)
que
puede
direccionarse
mediante
un
√∫nico
URL
.
La
mayo-


r√≠a
de
las
p√°ginas
web
est√°n
constituidas
por
un
archivo
base
HTML
y
varios
objetos
refe-


renciados
.
Por
ejemplo
,
si
una
p√°gina
web
contiene
texto
HTML
y
cinco
im√°genes
JPEG
,


entonces
la
p√°gina
web
contiene
seis
objetos
:
el
archivo
base
HTML
y
las
cinco
im√°genes
.


El
archivo
base
HTML
hace
referencia
a
los
otros
objetos
contenidos
en
la
p√°gina
mediante


los
URL
de
los
objetos
.
Cada
URL
tiene
dos
componentes
:
el
nombre
de
host
del
servidor


que
alberga
al
objeto
y
el
nombre
de
la
ruta
al
objeto
.
Por
ejemplo
,
en
el
URL


http://www.unaEscuela.edu/unDepartmento/imagen.gif


www.unaEscuela.edu
corresponde
a
un
nombre
de
host
y
/unDepartmento
/
imagen
.


gif
es
el
nombre
de
una
ruta
.
Puesto
que
los
navegadores
web
(
como
Internet
Explorer
y


Firefox
)
implementan
el
lado
del
cliente
de
HTTP
,
en
el
contexto
de
la
Web
utilizaremos
los


t√©rminos
navegador
y
cliente
de
forma
indistinta
.
Los
servidores
web
,
que
implementan
el


lado
del
servidor
de
HTTP
,
albergan
los
objetos
web
,
siendo
cada
uno
de
ellos
direccionable


mediante
un
URL
.
Entre
los
servidores
web
m√°s
populares
se
incluyen
Apache
y
Microsoft


Internet
Information
Server
.


HTTP
define
c√≥mo
los
clientes
web
solicitan
p√°ginas
web
a
los
servidores
web
y
c√≥mo


estos
servidores
transfieren
esas
p√°ginas
web
a
los
clientes
.
M√°s
adelante
veremos
la
inte-


96
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
96Figura
2.6
‚Ä¢
Comportamiento
solicitud-respuesta
de
HTTP
.


racci√≥n
entre
el
cliente
y
el
servidor
en
detalle
,
si
bien
la
idea
general
se
ilustra
en
la
Figura


2.6
.
Cuando
un
usuario
solicita
una
p√°gina
web
(
por
ejemplo
,
haciendo
clic
en
un
hiperv√≠n-


culo
)
,
el
navegador
env√≠a
al
servidor
mensajes
de
solicitud
HTTP
para
los
objetos
conteni-


dos
en
la
p√°gina
.
El
servidor
recibe
las
solicitudes
y
responde
con
mensajes
de
respuesta


HTTP
que
contienen
los
objetos
.


HTTP
utiliza
TCP
como
su
protocolo
de
transporte
subyacente
(
en
lugar
de
ejecutarse


por
encima
de
UDP
)
.
El
cliente
HTTP
primero
inicia
una
conexi√≥n
TCP
con
el
servidor
.


Una
vez
que
la
conexi√≥n
se
ha
establecido
,
los
procesos
de
navegador
y
de
servidor
acce-


den
a
TCP
a
trav√©s
de
sus
interfaces
de
socket
.
Como
se
ha
descrito
en
la
Secci√≥n
2.1
,
en
el


lado
del
cliente
la
interfaz
del
socket
es
la
puerta
entre
el
proceso
cliente
y
la
conexi√≥n


TCP
;
en
el
lado
del
servidor
,
es
la
puerta
entre
el
proceso
servidor
y
la
conexi√≥n
TCP
.
El


cliente
env√≠a
mensajes
de
solicitud
HTTP
a
su
interfaz
de
socket
y
recibe
mensajes
de
res-


puesta
HTTP
procedentes
de
su
interfaz
de
socket
.
De
forma
similar
,
el
servidor
HTTP


recibe
mensajes
de
solicitud
de
su
interfaz
de
socket
y
env√≠a
mensajes
de
respuesta
a
trav√©s


de
la
interfaz
de
su
socket
.
Una
vez
que
el
cliente
env√≠a
un
mensaje
a
su
interfaz
de
socket
,


el
mensaje
deja
de
estar
‚Äú
en
las
manos
‚Äù
del
cliente
y
pasa
‚Äú
a
las
manos
‚Äù
de
TCP
.
Como


hemos
visto
en
la
Secci√≥n
2.1
,
TCP
proporciona
un
servicio
de
transferencia
de
datos
fia-


ble
a
HTTP
.
Esto
implica
que
cada
mensaje
de
solicitud
HTTP
enviado
por
un
proceso


cliente
llegar√°
intacto
al
servidor
;
del
mismo
modo
,
cada
mensaje
de
respuesta
HTTP


enviado
por
el
proceso
servidor
llegar√°
intacto
al
cliente
.
Esta
es
una
de
las
grandes
venta-


jas
de
una
arquitectura
en
capas
:
HTTP
no
tiene
que
preocuparse
por
las
p√©rdidas
de
datos


o
por
los
detalles
sobre
c√≥mo
TCP
recupera
los
datos
perdidos
o
los
reordena
dentro
de
la


red
.
√âste
es
el
trabajo
de
TCP
y
de
los
protocolos
de
las
capas
inferiores
de
la
pila
de
proto-


colos
.


Es
importante
observar
que
el
servidor
env√≠a
los
archivos
solicitados
a
los
clientes
sin


almacenar
ninguna
informaci√≥n
acerca
del
estado
del
cliente
.
Si
un
determinado
cliente
pide


el
mismo
objeto
dos
veces
en
un
espacio
de
tiempo
de
unos
pocos
segundos
,
el
servidor
no


responde
diciendo
que
acaba
de
servir
dicho
objeto
al
cliente
;
en
su
lugar
,
el
servidor
reenv√≠a


el
objeto
,
ya
que
ha
olvidado
por
completo
que
ya
lo
hab√≠a
hecho
anteriormente
.
Dado
que
un


servidor
HTTP
no
mantiene
ninguna
informaci√≥n
acerca
de
los
clientes
,
se
dice
que
HTTP
es


un
protocolo
sin
memoria
del
estado
.
Debemos
destacar
tambi√©n
que
la
Web
utiliza
la
arqui-


Solicitud
HTTP


Respuesta
HTTP


Respuesta
HTTP


Solicitud
HTTP


PC
ejecutando
Internet
Explorer
Linux
ejecutando
Firefox


Servidor
ejecutando
un


servidor
web
Apache


2.2
‚Ä¢
LA
WEB
Y
HTTP
97


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
97tectura
de
aplicaci√≥n
cliente-servidor
,
como
se
ha
explicado
en
la
Secci√≥n
2.1
.
Un
servidor
web


siempre
est√°
activo
y
tiene
una
direcci√≥n
IP
fija
y
da
servicio
a
solicitudes
procedentes
de
,


potencialmente
,
millones
de
navegadores
distintos
.
  

2.2.2
Conexiones
persistentes
y
no
persistentes


En
muchas
aplicaciones
de
Internet
,
el
cliente
y
el
servidor
est√°n
en
comunicaci√≥n
durante


un
periodo
de
tiempo
amplio
,
haciendo
el
cliente
una
serie
de
solicitudes
y
el
servidor
res-


pondiendo
a
dichas
solicitudes
.
Dependiendo
de
la
aplicaci√≥n
y
de
c√≥mo
se
est√©
empleando


la
aplicaci√≥n
,
las
solicitudes
pueden
hacerse
una
tras
otra
,
peri√≥dicamente
a
intervalos
regu-


lares
o
de
forma
intermitente
.
Cuando
esta
interacci√≥n
cliente-servidor
tiene
lugar
sobre


TCP
,
el
desarrollador
de
la
aplicaci√≥n
tiene
que
tomar
una
decisi√≥n
importante
:
¬ø
deber√≠a


cada
par
solicitud
/
respuesta
enviarse
a
trav√©s
de
una
conexi√≥n
TCP
separada
o
deber√≠an


enviarse
todas
las
solicitudes
y
sus
correspondientes
respuestas
a
trav√©s
de
la
misma
cone-


xi√≥n
TCP
?
Si
se
utiliza
el
primer
m√©todo
,
se
dice
que
la
aplicaci√≥n
utiliza
conexiones
no


persistentes
;
si
se
emplea
la
segunda
opci√≥n
,
entonces
se
habla
de
conexiones
persistentes
.


Con
el
fin
de
profundizar
en
esta
cuesti√≥n
de
dise√±o
,
vamos
a
examinar
las
ventajas
y
des-


ventajas
de
las
conexiones
persistentes
en
el
contexto
de
una
aplicaci√≥n
espec√≠fica
,
como


por
ejemplo
HTTP
,
que
puede
utilizar
ambos
tipos
de
conexi√≥n
.
Aunque
HTTP
emplea


conexiones
persistentes
en
su
modo
por
defecto
,
los
clientes
y
servidores
HTTP
se
pueden


configurar
para
emplear
en
su
lugar
conexiones
no
persistentes
.


HTTP
con
conexiones
no
persistentes


Sigamos
los
pasos
que
permiten
transferir
una
p√°gina
web
desde
un
servidor
a
un
cliente
en


el
caso
de
conexiones
no
persistentes
.
Supongamos
que
la
p√°gina
consta
de
un
archivo
base


HTML
y
de
10
im√°genes
JPEG
,
residiendo
los
11
objetos
en
el
mismo
servidor
.
Suponga-


mos
tambi√©n
que
el
URL
del
archivo
base
HTML
es
:


http://www.unaEscuela.edu/unDepartmento/home.index


Lo
que
ocurre
es
lo
siguiente
:


1
.
El
proceso
cliente
HTTP
inicia
una
conexi√≥n
TCP
con
el
servidor
www.unaEscuela.edu


en
el
puerto
n√∫mero
80
,
que
es
el
n√∫mero
de
puerto
por
defecto
para
HTTP
.
Asociados


con
la
conexi√≥n
TCP
,
habr√°
un
socket
en
el
cliente
y
un
socket
en
el
servidor
.


2
.
El
cliente
HTTP
env√≠a
un
mensaje
de
solicitud
HTTP
al
servidor
a
trav√©s
de
su
socket
.
El


mensaje
de
solicitud
incluye
el
nombre
de
la
ruta
/unDepartmento
/
home.index
.
(
M
√°
s


adelante
veremos
en
detalle
los
mensajes
HTTP
.
)


3
.
El
proceso
servidor
HTTP
recibe
el
mensaje
de
solicitud
a
trav√©s
de
su
socket
,
recupera


el
objeto
/unDepartmento
/
home.index
de
su
medio
de
almacenamiento
 
(
RAM
o


disco
)
,
encapsula
el
objeto
en
un
mensaje
de
respuesta
HTTP
y
lo
env√≠a
al
cliente
a
tra-


v√©s
de
su
socket
.


4
.
El
proceso
servidor
HTTP
indica
a
TCP
que
cierre
la
conexi√≥n
TCP
.
(
Pero
TCP
real-


mente
no
termina
la
conexi√≥n
hasta
que
est√°
seguro
de
que
el
cliente
ha
recibido
el
men-


saje
de
respuesta
en
perfecto
estado
.
)


5
.
El
cliente
HTTP
recibe
el
mensaje
de
respuesta
.
La
conexi√≥n
TCP
termina
.
El
mensaje


indica
que
el
objeto
encapsulado
es
un
archivo
HTML
.
El
cliente
extrae
el
archivo
del


98
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
98mensaje
de
respuesta
,
examina
el
archivo
HTML
y
localiza
las
referencias
a
los
10
obje-


tos
JPEG
.


6
.
Los
cuatro
primeros
pasos
se
repiten
entonces
para
cada
uno
de
los
objetos
JPEG
refe-


renciados
.


Cuando
el
navegador
recibe
la
p√°gina
web
,
la
muestra
al
usuario
.
Dos
navegadores
distin-


tos
pueden
interpretar
(
es
decir
,
mostrar
al
usuario
)
una
p√°gina
web
de
formas
distintas
.
HTTP


no
tiene
nada
que
ver
con
c√≥mo
un
cliente
interpreta
una
p√°gina
web
.
Las
especificaciones


HTTP
(
[
RFC
1945
]
y
[
RFC
2616
]
)
√∫nicamente
definen
el
protocolo
de
comunicaci√≥n
entre
el


programa
HTTP
cliente
y
el
programa
HTTP
servidor
.


Los
pasos
anteriores
ilustran
el
uso
de
las
conexiones
no
persistentes
,
donde
cada
cone-


xi√≥n
TCP
se
cierra
despu√©s
de
que
el
servidor
env√≠e
el
objeto
(
la
conexi√≥n
no
se
mantiene


para
los
restantes
objetos
)
.
Observe
que
cada
conexi√≥n
TCP
transporta
exactamente
un
men-


saje
de
solicitud
y
un
mensaje
de
respuesta
.
Por
tanto
,
en
este
ejemplo
,
cuando
un
usuario


solicita
la
p√°gina
web
,
se
generan
11
conexiones
TCP
.


En
los
pasos
descritos
anteriormente
,
hemos
sido
intencionadamente
vagos
en
lo
que


respecta
a
si
el
cliente
obtiene
las
diez
im√°genes
JPEG
a
trav√©s
de
diez
conexiones
serie


TCP
o
si
algunas
de
dichas
im√°genes
se
obtienen
a
trav√©s
de
conexiones
TCP
paralelo
.
De


hecho
,
los
usuarios
pueden
configurar
los
navegadores
modernos
para
controlar
el
grado
de


paralelismo
.
En
sus
modos
por
defecto
,
la
mayor√≠a
de
los
navegadores
abren
de
5
a
10
cone-


xiones
TCP
paralelo
y
cada
una
de
estas
conexiones
gestiona
una
transacci√≥n
solicitud-res-


puesta
.
Si
el
usuario
lo
prefiere
,
el
n√∫mero
m√°ximo
de
conexiones
en
paralelo
puede


establecerse
en
uno
,
en
cuyo
caso
se
establecer√°n
diez
conexiones
en
serie
.
Como
veremos


en
el
siguiente
cap√≠tulo
,
el
uso
de
conexiones
paralelo
reduce
el
tiempo
de
respuesta
.


Antes
de
continuar
,
vamos
a
realizar
un
c√°lculo
aproximado
para
estimar
la
cantidad
de


tiempo
que
transcurre
desde
que
un
cliente
solicita
el
archivo
base
HTML
hasta
que
recibe


dicho
archivo
completo
.
Para
ello
,
definimos
el
tiempo
de
ida
y
vuelta
(
RTT
,
Round-Trip


Time
)
,
que
es
el
tiempo
que
tarda
un
paquete
peque√±o
en
viajar
desde
el
cliente
al
servidor
y


volver
de
nuevo
al
cliente
.
El
tiempo
RTT
incluye
los
retardos
de
propagaci√≥n
de
los
paque-


tes
,
los
retardos
de
cola
en
los
routers
y
switches
intermedios
y
los
retardos
de
procesa-


miento
de
los
paquetes
(
estos
retardos
se
explican
en
la
Secci√≥n
1.4
)
.
Consideremos
ahora


lo
que
ocurre
cuando
un
usuario
hace
clic
en
un
hiperv√≠nculo
.
Como
se
muestra
en
la
Figura


2.7
,
esto
hace
que
el
navegador
inicie
una
conexi√≥n
TCP
entre
el
navegador
y
el
servidor


web
,
lo
que
implica
un
proceso
de
‚Äú
acuerdo
en
tres
fases
‚Äù
(
el
cliente
env√≠a
un
peque√±o
seg-


mento
TCP
al
servidor
,
el
servidor
reconoce
y
responde
con
otro
peque√±o
segmento
TCP
y
,


por
√∫ltimo
,
el
cliente
devuelve
un
mensaje
de
reconocimiento
al
servidor
)
.
Las
dos
primeras


partes
de
este
proceso
de
acuerdo
en
tres
fases
tardan
un
periodo
de
tiempo
RTT
.
Despu√©s


de
completarse
las
dos
primeras
fases
de
la
negociaci√≥n
,
el
cliente
env√≠a
a
la
conexi√≥n
TCP


el
mensaje
de
solicitud
HTTP
combinado
con
la
tercera
parte
de
la
negociaci√≥n
(
el
mensaje


de
reconocimiento
)
.
Una
vez
que
el
mensaje
de
solicitud
llega
al
servidor
,
√©ste
env√≠a
el


archivo
HTML
a
la
conexi√≥n
TCP
.
Este
mensaje
de
solicitud
/
respuesta
HTTP
consume
otro


periodo
de
tiempo
RTT
.
Luego
el
tiempo
de
respuesta
total
es
aproximadamente
igual
a
dos


RTT
m√°s
el
tiempo
de
transmisi√≥n
del
archivo
HTML
en
el
servidor
.


HTTP
con
conexiones
persistentes


Las
conexiones
no
persistentes
presentan
algunos
inconvenientes
.
En
primer
lugar
,
tiene


que
establecerse
y
mantenerse
una
conexi√≥n
completamente
nueva
para
cada
objeto
soli-


2.2
‚Ä¢
LA
WEB
Y
HTTP
99


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
99Figura
2.7
‚Ä¢
C√°lculo
aproximado
del
tiempo
necesario
para
solicitar
y
recibir
un


archivo
HTML
.


citado
.
Para
cada
una
de
estas
conexiones
,
deben
asignarse
los
buffers
TCP
y
las
variables


TCP
tienen
que
mantenerse
tanto
en
el
cliente
como
en
el
servidor
.
Esto
puede
sobrecargar


de
forma
significativa
al
servidor
web
,
ya
que
puede
estar
sirviendo
solicitudes
de
cientos


de
clientes
distintos
simult√°neamente
.
En
segundo
lugar
,
como
ya
hemos
explicado
,
cada


objeto
sufre
un
retardo
de
entrega
de
dos
RTT
:
un
RTT
para
establecer
la
conexi√≥n
TCP
y


otro
RTT
para
solicitar
y
recibir
un
objeto
.


Con
las
conexiones
persistentes
,
el
servidor
deja
la
conexi√≥n
TCP
abierta
despu√©s
de


enviar
una
respuesta
.
Las
subsiguientes
solicitudes
y
respuestas
que
tienen
lugar
entre
el


mismo
cliente
y
el
servidor
pueden
enviarse
a
trav√©s
de
la
misma
conexi√≥n
.
En
concreto
,


una
p√°gina
web
completa
(
en
el
ejemplo
anterior
,
el
archivo
base
HTML
y
las
10
im√°genes
)


se
puede
enviar
a
trav√©s
de
una
misma
conexi√≥n
TCP
persistente
.
Adem√°s
,
varias
p√°ginas


web
que
residan
en
el
mismo
servidor
pueden
enviarse
desde
el
servidor
a
un
mismo
cliente


a
trav√©s
de
una
√∫nica
conexi√≥n
TCP
persistente
.
Estas
solicitudes
de
objetos
pueden
reali-


zarse
una
tras
otra
sin
esperar
a
obtener
las
respuestas
a
las
solicitudes
pendientes
(
pipeli-


ning
,
procesamiento
en
cadena
)
.
Normalmente
,
el
servidor
HTTP
cierra
una
conexi√≥n


cuando
no
se
ha
utilizado
durante
cierto
tiempo
(
un
intervalo
de
fin
de
temporizaci√≥n
confi-


gurable
)
.
Cuando
el
servidor
recibe
solicitudes
una
tras
otra
,
env√≠a
los
objetos
uno
tras
otro
.


El
modo
por
defecto
de
HTTP
utiliza
conexiones
persistentes
con
procesamiento
en
cadena
.


En
los
problemas
de
repaso
de
los
Cap√≠tulos
2
y
3
compararemos
cuantitativamente
el
ren-


dimiento
de
las
conexiones
persistentes
y
no
persistentes
.
Le
animamos
tambi√©n
a
que
con-


sulte
[
Heidemann
1997
;
Nielsen
1997
]
.


Tiempo
en
el
cliente
Tiempo
en
el
servidor


Inicio
de
la


conexi√≥n
TCP


RTT


Solicitud
del


archivo


RTT


Recepci√≥n
del


archivo
completo


Tiempo
invertido
en


transmitir
el
archivo


100
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1002.2.3
Formato
de
los
mensajes
HTTP


Las
especificaciones
HTTP
[
RFC
2616
]
)
incluyen
las
definiciones
de
los
formatos
de
los


mensajes
HTTP
.
A
continuaci√≥n
vamos
a
estudiar
los
dos
tipos
de
mensajes
HTTP
existen-


tes
:
mensajes
de
solicitud
y
mensajes
de
respuesta
.


Mensaje
de
solicitud
HTTP


Ac
o
n
t
i
n
u
a
c
i
√≥
n
 
l
e
 
p
r
o
p
o
r
c
i
o
n
a
m
o
s
 
u
n
 
m
e
n
s
a
j
e
 
d
e
 
s
o
l
i
c
i
t
u
d
 
H
T
T
Pt
√≠
p
i
c
o
:


GET
/unadireccion
/
pagina.html
HTTP/1.1


Host
:
www.unaescuela.edu


Connection
:
close


User-agent
:
Mozilla/4.0


Accept-language
:
fr


Podemos
aprender
muchas
cosas
si
miramos
en
detalle
este
sencillo
mensaje
de
solici-


tud
.
En
primer
lugar
,
podemos
comprobar
que
el
mensaje
est√°
escrito
en
texto
ASCII
nor-


mal
,
por
lo
que
cualquier
persona
con
conocimientos
inform√°ticos
puede
leerlo
.
En
segundo


lugar
,
vemos
que
el
mensaje
consta
de
cinco
l√≠neas
,
cada
una
de
ellas
seguida
por
un
retorno


de
carro
y
un
salto
de
l√≠nea
.
La
√∫ltima
l√≠nea
va
seguida
de
un
retorno
de
carro
y
un
salto
de


l√≠nea
adicionales
.
Aunque
este
mensaje
en
concreto
est√°
formado
por
cinco
l√≠neas
,
un
men-


saje
de
solicitud
puede
constar
de
muchas
m√°s
l√≠neas
o
tener
tan
pocas
como
√∫nicamente


una
.
La
primera
l√≠nea
de
un
mensaje
de
solicitud
HTTP
se
denomina
l√≠nea
de
solicitudy
las


siguientes
l√≠neas
son
las
l√≠neas
de
cabecera
.
La
l√≠nea
de
solicitud
consta
de
tres
campos
:
el


campo
de
m√©todo
,
el
campo
URL
y
el
campo
de
la
versi√≥n
HTTP
.
El
campo
que
especifica


el
m√©todo
puede
tomar
diferentes
valores
,
entre
los
que
se
incluyen
GET
,
POST
,
HEAD
,


PUT
y
DELETE
.
La
inmensa
mayor√≠a
de
los
mensajes
de
solicitud
HTTP
utilizan
el
m√©todo


GET
.
Este
m√©todo
se
emplea
cuando
el
navegador
solicita
un
objeto
,
identificando
dicho


objeto
en
el
campo
URL
.
En
este
ejemplo
,
el
navegador
est√°
solicitando
el
objeto
/unadi-


reccion
/
pagina
.
html
.
El
campo
correspondiente
a
la
versi√≥n
se
explica
por
s√≠
mismo
;


en
este
ejemplo
,
el
navegador
utiliza
la
versi√≥n
HTTP/1.1
.


Analicemos
ahora
las
l√≠neas
de
cabecera
de
este
ejemplo
.
La
l√≠nea
de
cabecera
Host
:


www.unaescuela.edu
especifica
el
host
en
el
que
reside
el
objeto
.
Podr√≠a
pensarse
que


esta
l√≠nea
de
cabecera
es
innecesaria
,
puesto
que
ya
existe
una
conexi√≥n
TCP
activa
con
el


host
.
Pero
,
como
veremos
en
la
Secci√≥n
2.2.5
,
las
cach√©s
proxy
web
necesitan
la
informa-


ci√≥n
proporcionada
por
la
l√≠nea
de
cabecera
del
host
.
Al
incluir
la
l√≠nea
de
cabecera
Con-


nection
:
close
,
el
navegador
est√°
diciendo
al
servidor
que
no
desea
molestarse
en


trabajar
con
conexiones
persistentes
,
sino
que
desea
que
el
servidor
cierre
la
conexi√≥n
des-


pu√©s
de
enviar
el
objeto
solicitado
.
La
l√≠nea
de
cabecera
User-agent
:
especifica
el
agente


de
usuario
,
es
decir
,
el
tipo
de
navegador
que
est√°
haciendo
la
solicitud
al
servidor
.
En
este


caso
,
el
agente
de
usuario
es
Mozilla/4.0
,
un
navegador
de
Netscape
.
Esta
l√≠nea
de
cabecera


resulta
√∫til
porque
el
servidor
puede
enviar
versiones
diferentes
del
mismo
objeto
a
los
dis-


tintos
tipos
de
agentes
de
usuario
(
el
mismo
URL
direcciona
a
cada
una
de
las
versiones
)
.


Por
√∫ltimo
,
la
l√≠nea
de
cabecera
Accept-language
:
indica
que
el
usuario
prefiere
recibir


una
versi√≥n
en
franc√©s
del
objeto
,
si
tal
objeto
existe
en
el
servidor
;
en
caso
contrario
,
el
ser-


vidor
enviar√°
la
versi√≥n
por
defecto
.
La
l√≠nea
de
cabecera
Accept-language
:
s√≥lo
es
una


de
las
muchas
cabeceras
de
negociaci√≥n
del
contenido
disponibles
en
HTTP
.


2.2
‚Ä¢
LA
WEB
Y
HTTP
101


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
101Figura
2.8
‚Ä¢
Formato
general
de
un
mensaje
de
solicitud
HTTP
.


Una
vez
visto
este
ejemplo
,
vamos
a
estudiar
el
formato
general
de
un
mensaje
de
soli-


citud
como
el
de
la
Figura
2.8
.
Podemos
comprobar
que
el
formato
general
es
muy
similar


al
usado
en
el
ejemplo
anterior
.
Sin
embargo
,
f√≠jese
en
que
despu√©s
de
las
l√≠neas
de
cabecera


(
y
el
retorno
de
carro
y
el
salto
de
l√≠nea
adicionales
)
se
incluye
un
‚Äú
cuerpo
de
entidad
‚Äù
.
Este


campo
queda
vac√≠o
cuando
se
utiliza
el
m√©todo
GET
,
pero
no
cuando
se
usa
el
m√©todo
POST
.


A
menudo
,
un
cliente
HTTP
utiliza
el
m√©todo
POSTcuando
el
usuario
completa
un
formula-


rio
;
por
ejemplo
,
cuando
especifica
t√©rminos
para
realizar
una
b√∫squeda
utilizando
un
motor


de
b√∫squeda
.
Con
un
mensaje
POST
,
el
usuario
solicita
una
p√°gina
web
al
servidor
,
pero
el


contenido
concreto
de
la
misma
depender√°
de
lo
que
el
usuario
haya
escrito
en
los
campos


del
formulario
.
Si
el
valor
del
campo
m√©todo
es
POST
,
entonces
el
cuerpo
de
la
entidad
con-


tendr√°
lo
que
el
usuario
haya
introducido
en
los
campos
del
formulario
.


Ser√≠amos
descuidados
si
no
dij√©ramos
que
una
solicitud
generada
con
un
formulario
no


necesariamente
utiliza
el
m√©todo
POST
.
En
su
lugar
,
a
menudo
los
formularios
HTML


emplean
el
m√©todo
GETe
incluyen
los
datos
de
entrada
(
especificados
en
los
campos
del
for-


mulario
)
en
el
URL
solicitado
.
Por
ejemplo
,
si
un
formulario
emplea
el
m√©todo
GETy
tiene


dos
campos
,
y
las
entradas
a
esos
dos
campos
son
monkeys
y
bananas
,
entonces
el
URL


tendr√°
la
estructura
www.unsitio.com/animalsearch?monkeys&bananas
.
Probable-


mente
,
al
navegar
por
la
Web
habr√°
visto
direcciones
URL
de
este
tipo
.


El
m√©todo
HEADes
similar
al
m√©todo
GET
.
Cuando
un
servidor
recibe
una
solicitud
con


el
m√©todo
HEAD
,
responde
con
un
mensaje
HTTP
,
pero
excluye
el
objeto
solicitado
.
Los


desarrolladores
de
aplicaciones
a
menudo
utilizan
el
m√©todo
HEAD
para
labores
de
depura-


ci√≥n
.
El
m√©todo
PUT
suele
utilizarse
junto
con
herramientas
de
publicaci√≥n
web
.
Esto
per-


mite
a
un
usuario
cargar
un
objeto
en
una
ruta
espec√≠fica
(
directorio
)
en
un
servidor
web


determinado
.
Las
aplicaciones
que
necesitan
cargar
objetos
en
servidores
web
tambi√©n


emplean
el
m√©todo
PUT
.
El
m√©todo
DELETE
permite
a
un
usuario
o
a
una
aplicaci√≥n
borrar


un
objeto
de
un
servidor
web
.


Mensajes
de
respuesta
HTTP


A
continuaci√≥n
proporcionamos
un
mensaje
de
respuesta
HTTP
t√≠pico
.
Este
mensaje
de
res-


puesta
podr√≠a
ser
la
respuesta
al
mensaje
de
solicitud
ejemplo
que
acabamos
de
ver
.


m√©todo
sp
sp
cr
lf


cr
lfNombre
de
campo

     
de
cabecera


L√≠neas
de


cabecera


L√≠nea
en


blanco


Cuerpo
de


entidad


L√≠nea
de


solicitud


valor
sp


cr
lf


cr
lf


Nombre
de
campo

     
de
cabecera
valor
sp


URL
Versi√≥n


102
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
102HTTP/1.1
200
OK


Connection
:
close


Date
:
Sat
,
07
Jul
2007
12:00:15
GMT


Server
:
Apache/1.3.0
(
Unix
)


Last-Modified
:
Sun
,
6
May
2007
09:23:24
GMT


Content-Length
:
6821


Content-Type
:
text
/
html


(
datos
datos
datos
datos
datos
...
)


Examinemos
detenidamente
este
mensaje
de
respuesta
.
Tiene
tres
secciones
:
una
l√≠nea


de
estado
inicial
,
seis
l√≠neas
de
cabecera
y
el
cuerpo
de
entidad
.
El
cuerpo
de
entidad
es


la
parte
m√°s
importante
del
mensaje
,
ya
que
contiene
el
objeto
solicitado
en
s√≠
(
representado


por
la
l√≠nea
datos
datos
datos
datos
datos
...
)
.
La
l√≠nea
de
estado
contiene
tres


campos
:
el
que
especifica
la
versi√≥n
del
protocolo
,
el
correspondiente
al
 
c√≥digo
de
estado
y


el
tercero
que
contiene
el
mensaje
explicativo
del
estado
correspondiente
.
En
este
ejemplo
,


la
l√≠nea
de
estado
indica
que
el
servidor
est√°
utilizando
HTTP/1.1
y
que
todo
es
correcto


(
OK
)
;
es
decir
,
que
el
servidor
ha
encontrado
y
est√°
enviando
el
objeto
solicitado
.


Veamos
ahora
las
l√≠neas
de
cabecera
.
El
servidor
utiliza
la
l√≠nea
Connection
:
close


para
indicar
al
cliente
que
va
a
cerrar
la
conexi√≥n
TCP
despu√©s
de
enviar
el
mensaje
.
La


l√≠nea
de
cabecera
Date
:
indica
la
hora
y
la
fecha
en
la
que
se
cre√≥
la
respuesta
HTTP
y
fue


enviada
por
el
servidor
.
Observe
que
no
especifica
la
hora
en
que
el
objeto
fue
creado
o


modificado
por
√∫ltima
vez
;
es
la
hora
en
la
que
el
servidor
recupera
el
objeto
de
su
sistema


de
archivos
,
inserta
el
objeto
en
el
mensaje
de
respuesta
y
lo
env√≠a
.
La
l√≠nea
de
cabecera


Server
:
indica
que
el
mensaje
fue
generado
por
un
servidor
web
Apache
;
√©sta
es
an√°loga
a


la
l√≠nea
de
cabecera
User-agent
:
del
mensaje
de
solicitud
HTTP
.
La
l√≠nea
Last-Modi-


fied
:
especifica
la
hora
y
la
fecha
en
que
el
objeto
fue
creado
o
modificado
por
√∫ltima
vez
.


La
l√≠nea
de
cabecera
Last-Modified
:
,
que
enseguida
estudiaremos
en
detalle
,
resulta
fun-


damental
para
el
almacenamiento
en
cach√©
del
objeto
,
tanto
en
el
cliente
local
como
en
los


servidores
de
almacenamiento
en
cach√©
de
la
red
(
tambi√©n
conocidos
como
servidores


proxy
)
.
La
l√≠nea
Content-Length
:
especifica
el
n√∫mero
de
bytes
del
objeto
que
est√°


siendo
enviado
.
La
l√≠nea
Content-Type
:
indica
que
el
objeto
especificado
en
el
cuerpo
de


entidad
es
texto
HTML
.
(
El
tipo
de
objeto
est√°
indicado
oficialmente
por
la
l√≠nea
de
cabe-


cera
Content-Type
:
y
no
por
la
extensi√≥n
del
archivo
.
)
.


Una
vez
visto
un
ejemplo
,
vamos
a
pasar
a
examinar
el
formato
general
de
un
mensaje


de
respuesta
,
como
el
mostrado
en
la
Figura
2.9
.
Este
formato
general
de
mensaje
de
res-


puesta
se
corresponde
con
el
del
ejemplo
anterior
.
Comentaremos
algunas
cosas
acerca
de


los
c√≥digos
de
estado
y
sus
descripciones
.
El
c√≥digo
de
estado
y
su
frase
asociada
indican
el


resultado
de
la
solicitud
.
Algunos
de
los
c√≥digos
de
estado
y
sus
frases
asociadas
son
:


‚Ä¢
200
OK
:
La
solicitud
se
ha
ejecutado
con
√©xito
y
se
ha
devuelto
la
informaci√≥n
en
el


mensaje
de
respuesta
.


‚Ä¢
301
Moved
Permanently
:
El
objeto
solicitado
ha
sido
movido
de
forma
permanente
;


el
nuevo
URL
se
especifica
en
la
l√≠nea
de
cabecera
Location
:
del
mensaje
de
respuesta
.


El
software
cliente
recuperar√°
autom√°ticamente
el
nuevo
URL
.


‚Ä¢
400
Bad
Request
:
Se
trata
de
un
c√≥digo
de
error
gen√©rico
que
indica
que
la
solicitud


no
ha
sido
comprendida
por
el
servidor
.


2.2
‚Ä¢
LA
WEB
Y
HTTP
103


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
103Figura
2.9
‚Ä¢
Formato
general
de
un
mensaje
de
respuesta
HTTP
.


‚Ä¢
404
Not
Found
:
El
documento
solicitado
no
existe
en
este
servidor
.
          

‚Ä¢
505
HTTP
Version
Not
Supported
:
La
versi√≥n
de
protocolo
HTTP
solicitada
no
es


soportada
por
el
servidor
.


¬ø
Le
gustar√≠a
ver
un
mensaje
de
respuesta
HTTP
real
?
Esto
es
muy
recomendable
y
ade-


m√°s
es
muy
f√°cil
de
hacer
.
En
primer
lugar
,
establezca
una
conexi√≥n
Telnet
con
su
servidor


web
favorito
.
A
continuaci√≥n
escriba
un
mensaje
de
solicitud
de
una
l√≠nea
para
obtener
alg√∫n


objeto
que
est√©
almacenado
en
ese
servidor
.
Por
ejemplo
,
si
tiene
acceso
a
la
l√≠nea
de
coman-


dos
(
prompt
)
,
escriba
:


telnet
cis.poly.edu
80


GET
/~ross/
HTTP/1.1


Host
:
cis.poly.edu


(
Pulse
dos
veces
la
tecla
retorno
de
carro
despu√©s
de
escribir
la
√∫ltima
l√≠nea
.
)
De
este
modo


se
abre
una
conexi√≥n
TCP
en
el
puerto
80
del
host
cis.poly.eduy
luego
se
env√≠a
el
men-


saje
de
solicitud
HTTP
.
Deber√≠a
ver
un
mensaje
de
respuesta
que
incluya
el
archivo
base


HTML
de
la
p√°gina
inicial
del
profesor
Ross
.
Para
ver
simplemente
las
l√≠neas
del
mensaje


HTTP
y
no
recibir
el
objeto
,
sustituya
GET
por
HEAD
.
Por
√∫ltimo
,
sustituya
/~ross/
por


/~banana
/
y
f√≠jese
en
el
tipo
de
mensaje
de
respuesta
que
recibe
.


En
esta
secci√≥n
hemos
visto
una
serie
de
l√≠neas
de
cabecera
que
pueden
utilizarse
en
los


mensajes
HTTP
de
solicitud
y
respuesta
.
La
especificaci√≥n
de
HTTP
define
un
gran
n√∫mero


de
otras
l√≠neas
de
cabecera
que
pueden
ser
insertadas
por
los
navegadores
,
servidores
web
y


servidores
de
almacenamiento
en
cach√©
de
la
red
.
Hemos
cubierto
√∫nicamente
una
peque√±a


parte
de
la
totalidad
disponible
de
l√≠neas
de
cabecera
.
A
continuaci√≥n
veremos
unas
pocas


m√°s
y
en
la
Secci√≥n
2.2.5
algunas
otras
,
al
hablar
del
almacenamiento
en
cach√©s
web
de
la


red
.
Puede
leer
una
exposici√≥n
enormemente
clara
y
comprensible
acerca
del
protocolo


HTTP
,
incluyendo
sus
cabeceras
y
c√≥digos
de
estado
en
[
Krishnamurty
2001
]
;
consulte
tam-


bi√©n
[
Luotonen
1998
]
para
ver
una
exposici√≥n
desde
el
punto
de
vista
del
desarrollador
.


versi√≥n
sp
sp
cr
lf


cr
lfnombre
de
campo


de
cabecera
:


L√≠neas
de


cabecera


L√≠nea
en


blanco


Cuerpo
de


entidad


L√≠nea
de


estado


valor


cr


sp


sp
lf


cr
lf


nombre
de
campo


de
cabecera
:
valor


c√≥digo


de
estado
frase


104
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
104¬øC√≥mo
decide
un
navegador
qu√©
l√≠neas
de
cabecera
incluir
en
un
mensaje
de
solicitud
?


¬ø
C√≥mo
decide
un
servidor
web
qu√©
l√≠neas
de
cabecera
incluir
en
un
mensaje
de
respuesta
?


Un
navegador
generar√°
l√≠neas
de
cabecera
en
funci√≥n
del
tipo
y
la
versi√≥n
del
navegador


(
por
ejemplo
,
un
navegador
HTTP/1.0
no
generar√°
ninguna
l√≠nea
de
cabecera
correspon-


diente
a
la
versi√≥n
1.1
)
,
de
la
configuraci√≥n
del
navegador
que
tenga
el
usuario
(
por
ejem-


plo
,
el
idioma
preferido
)
y
de
si
el
navegador
actualmente
tiene
en
cach√©
una
versi√≥n
del


objeto
,
posiblemente
desactualizada
.
Los
servidores
web
se
comportan
de
forma
similar
:


existen
productos
,
versiones
y
configuraciones
diferentes
,
que
influyen
en
las
l√≠neas
de
cabe-


cera
que
se
incluir√°n
en
los
mensajes
de
respuesta
.


2.2.4
Interacci√≥n
usuario-servidor
:
cookies


Hemos
mencionado
anteriormente
que
un
servidor
HTTP
no
tiene
memoria
del
estado
de
la


conexi√≥n
.
Esto
simplifica
el
dise√±o
del
servidor
y
ha
permitido
a
los
ingenieros
desarrollar


servidores
web
de
alto
rendimiento
que
pueden
gestionar
miles
de
conexiones
TCP
simult√°-


neas
.
Sin
embargo
,
para
un
sitio
web
,
a
menudo
es
deseable
poder
identificar
a
los
usuarios
,


bien
porque
el
servidor
desea
restringir
el
acceso
a
los
usuarios
o
porque
desea
servir
el
con-


tenido
en
funci√≥n
de
la
identidad
del
usuario
.
Para
estos
prop√≥sitos
,
HTTP
utiliza
cookies
.


Las
cookies
,
definidas
en
el
documento
RFC
2965
,
permiten
a
los
sitios
seguir
la
pista
a
los


usuarios
.
Actualmente
,
la
mayor√≠a
de
los
sitios
web
comerciales
m√°s
importantes
utilizan


cookies
.


Como
se
muestra
en
la
Figura
2.10
,
la
tecnolog√≠a
de
las
cookies
utiliza
cuatro
compo-


nentes
:
(
1
)
una
l√≠nea
de
cabecera
de
la
cookie
en
el
mensaje
de
respuesta
HTTP
;
(
2
)
una


l√≠nea
de
cabecera
de
la
cookie
del
mensaje
de
solicitud
HTTP
;
(
3
)
el
archivo
de
cookies


almacenado
en
el
sistema
terminal
del
usuario
y
gestionado
por
el
navegador
del
usuario
;


(
4
)
una
base
de
datos
back-end
en
el
sitio
web
.
Bas√°ndonos
en
la
Figura
2.10
,
vamos
a
ver


mediante
un
ejemplo
c√≥mo
funcionan
las
cookies
.
Suponga
que
Susana
,
que
accede
siempre


a
la
Web
utilizando
Internet
Explorer
en
el
PC
de
su
casa
,
entra
en
Amazon.com
por
primera


vez
.
Supongamos
que
anteriormente
ella
hab√≠a
visitado
el
sitio
de
eBay
.
Cuando
la
solicitud


llega
al
servidor
web
de
Amazon
,
el
servidor
crea
un
n√∫mero
de
identificaci√≥n
√∫nico
y
crea


una
entrada
en
su
base
de
datos
back-end
que
est√°
indexada
por
el
n√∫mero
de
identificaci√≥n
.


El
servidor
web
de
Amazon
responde
entonces
al
navegador
de
Susana
,
incluyendo
en
la


respuesta
HTTP
una
l√≠nea
de
cabecera
Set-cookie
:
,
que
contiene
el
n√∫mero
de
identifica-


ci√≥n
.
Por
ejemplo
,
la
l√≠nea
de
cabecera
podr√≠a
ser
:


Set-cookie
:
1678


Cuando
el
navegador
de
Susana
recibe
el
mensaje
de
respuesta
HTTP
,
ve
la
cabecera


Set-cookie
:
.
Entonces
el
navegador
a√±ade
una
l√≠nea
a
su
archivo
especial
de
cookies
.


Esta
l√≠nea
incluye
el
nombre
de
host
del
servidor
y
el
n√∫mero
de
identificaci√≥n
en
la
cabe-


cera
Set-cookie
:
.
Observe
que
el
archivo
de
cookies
ya
tiene
una
entrada
para
eBay
,
dado


que
Susana
hab√≠a
visitado
dicho
sitio
en
el
pasado
.
A
medida
que
Susana
contin√∫a


navegando
por
el
sitio
de
Amazon
,
cada
vez
que
solicita
una
p√°gina
web
su
navegador


consulta
su
archivo
de
cookies
,
extrae
su
n√∫mero
de
identificaci√≥n
para
ese
sitio
y
a√±ade


una
cabecera
de
cookie
que
incluye
el
n√∫mero
en
identificaci√≥n
de
la
solicitud
HTTP
.
Espe-


c√≠ficamente
,
cada
una
de
sus
solicitudes
HTTP
al
servidor
de
Amazon
incluyen
la
l√≠nea
de


cabecera
:


Cookie
:
1678


2.2
‚Ä¢
LA
WEB
Y
HTTP
105


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
105Figura
2.10
‚Ä¢
Mantenimiento
del
estado
del
usuario
mediante
cookies
.


De
esta
forma
,
el
servidor
de
Amazon
puede
seguir
la
actividad
de
Susana
en
su
sitio
.
Aun-


que
el
sitio
web
de
Amazon
no
necesariamente
conoce
el
nombre
de
Susana
,
sabe
exacta-


mente
qu√©
p√°ginas
ha
visitado
el
usuario
n√∫mero
1678
,
en
qu√©
orden
y
cu√°ntas
veces
.


Amazon
utiliza
cookies
para
proporcionar
su
servicio
de
carro
de
la
compra
;
Amazon
puede


mantener
una
lista
de
todas
las
compras
de
Susana
,
con
el
fin
de
que
ella
pueda
pagarlas


todas
juntas
al
final
de
la
sesi√≥n
.


Si
Susana
vuelve
al
sitio
de
Amazon
,
por
ejemplo
,
una
semana
m√°s
tarde
,
su
navegador


continuar√°
incluyendo
la
l√≠nea
de
cabecera
Cookie
:
1678
en
los
mensajes
de
solicitud
.


Amazon
tambi√©n
recomienda
productos
a
Susana
bas√°ndose
en
las
p√°ginas
web
que
ha
visi-


tado
anteriormente
dentro
del
sitio
.
Si
Susana
se
registra
en
Amazon
,
proporcionando
su


nombre
completo
,
direcci√≥n
de
correo
electr√≥nico
,
direcci√≥n
postal
y
la
informaci√≥n
de
su


tarjeta
cr√©dito
,
entonces
Amazon
podr√°
incluir
esta
informaci√≥n
en
su
base
de
datos
,
aso-


ciando
el
nombre
de
Susana
con
su
n√∫mero
de
identificaci√≥n
(
¬°
y
todas
las
p√°ginas
que
ha


106
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


Host
cliente
Host
servidor


mensaje
usual
de


solicitud
http


mensaje
usual
de


respuesta
http
usual


Set-cookie
:
1678mensaje
usual
de


solicitud
http


cookie
:
1678


mensaje
usual
de


respuesta
http


mensaje
usual
de


solicitud
http


cookie
:
1678


mensaje
usual
de


respuesta
http


Tiempo


Una
semana


m√°s
tarde


ebay
:
8734


El
servidor
crea
el


ID
1678
para
el


usuario


Tiempo


Archivo
de
cookies


Clave
:


amazon
:
1678


ebay
:
8734


amazon
:
1678


ebay
:
8734


Acci√≥n
de
la


cookie
espec√≠fica


acceso


acceso


entrada
en
la
base


de
datos
de
back-end


Acci√≥n
de
la


cookie
espec√≠fica


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
106visitado
dentro
del
sitio
en
el
pasado
!
)
.
As√≠
es
como
Amazon
y
otros
sitios
de
comercio
elec-


tr√≥nico
proporcionan
el
servicio
de
‚Äú
compra
con
un
clic
‚Äù
;
cuando
Susana
desee
comprar
un


producto
en
una
visita
posterior
,
no
tendr√°
que
volver
a
escribir
su
nombre
,
el
n√∫mero
de
la


tarjeta
de
cr√©dito
ni
su
direcci√≥n
.


Por
tanto
,
podemos
afirmar
que
las
cookies
pueden
utilizarse
para
identificar
a
un
usua-


rio
.
La
primera
vez
que
un
usuario
visita
un
sitio
,
el
usuario
puede
proporcionar
una
identi-


ficaci√≥n
del
mismo
(
posiblemente
su
nombre
)
.
As√≠
,
en
las
sesiones
posteriores
,
el
navegador


pasa
una
cabecera
de
cookie
al
servidor
,
identificando
al
usuario
ante
el
servidor
.
Las
coo-


kies
pueden
por
tanto
utilizarse
para
crear
una
capa
de
sesi√≥n
por
encima
del
protocolo


HTTP
sin
memoria
del
estado
de
la
conexi√≥n
.
Por
ejemplo
,
cuando
un
usuario
inicia
una


sesi√≥n
en
una
aplicaci√≥n
de
correo
electr√≥nico
basada
en
la
Web
(
como
por
ejemplo
Hot-


mail
)
,
el
navegador
env√≠a
al
servidor
la
informaci√≥n
de
la
cookie
,
permitiendo
al
servidor


identificar
al
usuario
a
lo
largo
de
la
sesi√≥n
que
el
usuario
mantenga
con
la
aplicaci√≥n
.


Aunque
las
cookies
a
menudo
simplifican
a
los
usuarios
la
realizaci√≥n
de
compras
por


Internet
,
son
controvertidas
,
porque
tambi√©n
pueden
considerarse
como
una
invasi√≥n
de
la


intimidad
del
usuario
.
Como
acabamos
de
ver
,
empleando
una
combinaci√≥n
de
cookies
y
de


la
informaci√≥n
sobre
cuentas
suministrada
por
el
usuario
,
un
sitio
web
puede
obtener
mucha


informaci√≥n
de
un
usuario
y
,
potencialmente
,
puede
vender
esa
informaci√≥n
a
otras
empre-


sas
.
Cookie
Central
[
Cookie
Central
2008
]
proporciona
mucha
informaci√≥n
acerca
de
la


controversia
de
las
cookies
.


2.2.5
Almacenamiento
en
cach√©
web


Una
cach√©
web
,
tambi√©n
denominada
servidor
proxy
,
es
una
entidad
de
red
que
satisface


solicitudes
HTTP
en
nombre
de
un
servidor
web
de
origen
.
La
cach√©
web
dispone
de
su


propio
almacenamiento
en
disco
y
mantiene
en
√©l
copias
de
los
objetos
solicitados
recien-


temente
.
Como
se
muestra
en
la
Figura
2.11
,
el
navegador
de
un
usuario
se
puede
configu-


rar
de
modo
que
todas
sus
solicitudes
HTTP
se
dirijan
en
primer
lugar
a
la
cach√©
web
.
Por


ejemplo
,
suponga
que
un
navegador
est√°
solicitando
el
objeto
 
http://www.unaEs-


cuela.edu/campus.gif
.
Veamos
qu√©
es
lo
que
ocurre
:


Figura
2.11
‚Ä¢
Clientes
que
solicitan
objetos
a
trav√©s
de
una
cach√©
web
.


Solicitud
HTTP


Respuesta
HTTP


Solicitud
HTTP


Respuesta
HTTP


Solicitud
HTTP


Respuesta
HTTP


Solicitud
HTTP


Respuesta
HTTP


Cliente
Servidor


de
origen


Servidor


de
origen


Cliente


Servidor


proxy


2.2
‚Ä¢
LA
WEB
Y
HTTP
107


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1071
.
El
navegador
establece
una
conexi√≥n
TCP
con
la
cach√©
web
y
env√≠a
una
solicitud


HTTP
para
el
objeto
a
la
cach√©
web
.


2
.
La
cach√©
web
comprueba
si
tiene
una
copia
del
objeto
almacenada
localmente
.
Si
la


tiene
,
la
cach√©
web
devuelve
el
objeto
dentro
de
un
mensaje
de
respuesta
HTTP
al
nave-


gador
del
cliente
.


3
.
Si
la
cach√©
web
no
tiene
el
objeto
,
abre
una
conexi√≥n
TCP
con
el
servidor
de
origen
,
es


decir
,
con
www.unaEscuela.edu
.
La
cach√©
web
env√≠a
entonces
una
solicitud
HTTP
para


obtener
el
objeto
a
trav√©s
de
la
conexi√≥n
TCP
cach√©-servidor
.
Despu√©s
de
recibir
esta


solicitud
,
el
servidor
de
origen
env√≠a
el
objeto
dentro
de
un
mensaje
de
respuesta
HTTP


a
la
cach√©
web
.


4
.
Cuando
la
cach√©
web
recibe
el
objeto
,
almacena
una
copia
en
su
dispositivo
de
almace-


namiento
local
y
env√≠a
una
copia
,
dentro
de
un
mensaje
de
respuesta
HTTP
,
al
navega-


dor
del
cliente
(
a
trav√©s
de
la
conexi√≥n
TCP
existente
entre
el
navegador
del
cliente
y
la


cach√©
web
)
.


Observe
que
una
cach√©
es
a
la
vez
un
servidor
y
un
cliente
.
Cuando
recibe
solicitudes
de
y


env√≠a
respuestas
a
un
navegador
,
se
comporta
como
un
servidor
.
Cuando
env√≠a
solicitudes
a


y
recibe
respuestas
de
un
servidor
de
origen
,
entonces
act√∫a
como
un
cliente
.


Habitualmente
es
un
ISP
quien
adquiere
e
instala
una
cach√©
web
.
Por
ejemplo
,
una
uni-


versidad
podr√≠a
instalar
una
cach√©
en
su
red
del
campus
y
configurar
todos
los
navegadores


del
campus
apuntando
a
la
cach√©
.
O
un
ISP
residencial
de
gran
tama√±o
(
como
AOL
)
podr√≠a


instalar
una
o
m√°s
cach√©s
en
su
red
y
preconfigurar
los
navegadores
que
suministre
para
que


apunten
a
las
cach√©s
instaladas
.
 

El
almacenamiento
en
cach√©
web
se
ha
implantado
en
Internet
por
dos
razones
.
La
pri-


mera
raz√≥n
es
que
una
cach√©
web
puede
reducir
sustancialmente
el
tiempo
de
respuesta
a
la


solicitud
de
un
cliente
,
especialmente
si
el
ancho
de
banda
cuello
de
botella
entre
el
cliente


y
el
servidor
de
origen
es
mucho
menor
que
el
ancho
de
banda
cuello
de
botella
entre
el


cliente
y
la
cach√©
.
Si
existe
una
conexi√≥n
de
alta
velocidad
entre
el
cliente
y
la
cach√©
,
lo
que


ocurre
a
menudo
,
y
si
la
cach√©
tiene
el
objeto
solicitado
,
entonces
√©sta
podr√°
suministrar
el


objeto
r√°pidamente
al
cliente
.
La
segunda
raz√≥n
es
que
,
como
ilustraremos
enseguida
con
un


ejemplo
,
las
cach√©s
web
pueden
reducir
sustancialmente
el
tr√°fico
en
el
enlace
de
acceso
a


Internet
de
una
instituci√≥n
.
Reduciendo
el
tr√°fico
,
la
instituci√≥n
(
por
ejemplo
,
una
empresa
o


una
universidad
)
no
tiene
que
mejorar
el
ancho
de
banda
tan
r√°pidamente
,
lo
que
implica


una
reducci√≥n
de
costes
.
Adem√°s
,
las
cach√©s
web
pueden
reducir
mucho
el
tr√°fico
web
glo-


bal
en
Internet
,
mejorando
en
consecuencia
el
rendimiento
de
todas
las
aplicaciones
.


Para
adquirir
un
conocimiento
profundo
de
las
ventajas
de
las
cach√©s
,
vamos
a
ver
un


ejemplo
en
el
contexto
ilustrado
en
la
Figura
2.12
.
Esta
figura
muestra
dos
redes
:
la
red
ins-


titucional
y
el
resto
de
la
red
p√∫blica
Internet
.
La
red
institucional
es
una
LAN
de
alta
velo-


cidad
.
Un
router
de
la
red
institucional
y
un
router
de
Internet
est√°n
conectados
mediante
un


enlace
a
15
Mbps
.
Los
servidores
de
origen
est√°n
conectados
a
Internet
pero
se
encuentran


distribuidos
por
todo
el
mundo
.
Suponga
que
el
tama√±o
medio
del
objeto
es
de
1
Mbits
y


que
la
tasa
media
de
solicitudes
de
los
navegadores
de
la
instituci√≥n
a
los
servidores
de
ori-


gen
es
de
15
solicitudes
por
segundo
.
Suponga
que
los
mensajes
de
solicitud
HTTP
son


extremadamente
peque√±os
y
que
por
tanto
no
crean
tr√°fico
en
las
redes
ni
en
el
enlace
de


acceso
(
desde
el
router
institucional
al
router
de
Internet
)
.
Suponga
tambi√©n
que
el
tiempo


que
se
tarda
en
reenviar
una
solicitud
HTTP
(
contenida
en
un
datagrama
IP
)
desde
el
router


del
lado
de
Internet
del
enlace
de
acceso
de
la
Figura
2.12
hasta
que
se
recibe
la
respuesta


108
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
108(normalmente
contenida
en
muchos
datagramas
IP
)
es
igual
a
dos
segundos
.
Informalmente
,


vamos
a
denominar
a
este
√∫ltimo
retardo
‚Äú
retardo
de
Internet
‚Äù
.


El
tiempo
total
de
respuesta
,
es
decir
,
el
tiempo
desde
que
el
navegador
solicita
un


objeto
hasta
que
lo
recibe
,
es
la
suma
del
retardo
de
la
LAN
,
el
retardo
de
acceso
(
es
decir
,


el
retardo
entre
los
dos
routers
)
y
el
retardo
de
Internet
.
Hagamos
ahora
un
burdo
c√°lculo


para
estimar
este
retardo
.
La
intensidad
de
tr√°fico
en
la
LAN
es
(
v√©ase
la
Secci√≥n
1.4.2
):


(
15
solicitudes
/
seg
)
/H11080(1
Mbits
/
solicitud)/(100
Mbps
)
=
0,15


mientras
que
la
intensidad
de
tr√°fico
en
el
enlace
de
acceso
(
desde
el
router
de
Internet
hasta


el
router
de
la
instituci√≥n
)
es
:


(
15
solicitudes
/
seg
)
/H11080(1
Mbits
/
solicitud)/(15
Mbps
)
=
1


Una
intensidad
de
tr√°fico
de
0,15
en
una
LAN
normalmente
da
resultados
,
como
m√°ximo
,


de
decenas
de
milisegundos
de
retardo
;
por
tanto
,
podemos
despreciar
el
retardo
de
la
LAN
.


Sin
embargo
,
como
hemos
visto
en
la
Secci√≥n
1.4.2
,
cuando
la
intensidad
de
tr√°fico
se


aproxima
a
1
(
como
es
el
caso
del
enlace
de
acceso
de
la
Figura
2.12
)
,
el
retardo
en
el
enlace


comienza
a
aumentar
y
crece
sin
l√≠mite
.
Por
tanto
,
el
tiempo
medio
de
respuesta
para
satisfa-


cer
las
solicitudes
es
del
orden
de
minutos
,
si
no
mayor
,
lo
que
es
inaceptable
para
los
usua-


rios
de
la
instituci√≥n
.
Evidentemente
,
es
necesario
hacer
algo
.


Figura
2.12
‚Ä¢
Cuello
de
botella
entre
una
red
institucional
e
Internet
.


Internet
p√∫blica


Red
institucional


Enlace
de
acceso
a
15
Mbps


LAN
a
100
Mbps


Servidores
de
origen


2.2
‚Ä¢
LA
WEB
Y
HTTP
109


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
109Figura
2.13
‚Ä¢
Adici√≥n
de
una
cach√©
a
una
red
institucional
.


Una
posible
soluci√≥n
es
incrementar
la
velocidad
de
acceso
de
15
Mbps
a
,
por
ejemplo
,


100
Mbps
.
Esto
disminuir√°
la
intensidad
de
tr√°fico
en
el
enlace
de
acceso
a
0,15
,
lo
que
se


traduce
en
retardos
despreciables
entre
los
dos
routers
.
En
este
caso
,
el
tiempo
total
de
res-


puesta
ser√°
de
unos
dos
segundos
,
es
decir
,
el
retardo
de
Internet
.
Pero
esta
soluci√≥n
tambi√©n


implica
que
la
instituci√≥n
debe
actualizar
su
enlace
de
acceso
de
15
Mbps
a
100
Mbps
,
lo


que
resulta
ser
una
soluci√≥n
cara
.


Consideremos
ahora
la
soluci√≥n
alternativa
de
no
actualizar
el
enlace
de
acceso
sino
,
en


su
lugar
,
instalar
una
cach√©
web
en
la
red
institucional
.
Esta
soluci√≥n
se
ilustra
en
la
Figura


2.13
.
Las
tasas
de
acierto
,
es
decir
,
la
fracci√≥n
de
solicitudes
que
son
satisfechas
por
una


cach√©
,
suelen
estar
comprendidas
,
en
la
pr√°ctica
,
entre
0,2
y
0,7
.
Con
prop√≥sitos
ilustrativos
,


supongamos
que
la
cach√©
proporciona
una
tasa
de
acierto
de
0,4
para
esta
instituci√≥n
.
Dado


que
los
clientes
y
la
cach√©
est√°n
conectados
a
la
misma
LAN
de
alta
velocidad
,
el
40
por


ciento
de
la
solicitudes
ser√°n
satisfechas
casi
de
forma
inmediata
,
es
decir
,
en
10
milisegun-


dos
o
menos
por
la
cach√©
.
No
obstante
,
el
restante
60
por
ciento
de
las
solicitudes
todav√≠a


tendr√°n
que
ser
satisfechas
por
los
servidores
de
origen
.
Pero
s√≥lo
con
el
60
por
ciento
de


los
objetos
solicitados
atravesando
el
enlace
de
acceso
,
la
intensidad
de
tr√°fico
en
el
mismo


se
reduce
de
1,0
a
0,6
.
T√≠picamente
,
una
intensidad
de
tr√°fico
menor
que
0,8
se
corresponde


con
un
retardo
peque√±o
,
digamos
de
unas
decenas
de
milisegundos
,
en
un
enlace
de
15


Mbps
.
Este
retardo
es
despreciable
comparado
con
los
dos
segundos
del
retardo
de
Internet
.


Teniendo
en
cuenta
todo
esto
,
el
retardo
medio
ser√°
entonces
:


Internet
p√∫blica


Red
institucional


Enlace
de
acceso
a
15
Mbps


Cach√©


institucional


LAN
a
100
Mbps


Servidores
de
origen


110
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1100,4
/H11080(0,01
segundos
)
+
0,6
/H11080(2,01
segundos
)


lo
que
es
algo
m√°s
de
1,2
segundos
.
Por
tanto
,
esta
segunda
soluci√≥n
proporciona
incluso
un


tiempo
de
respuesta
menor
que
la
primera
y
no
requiere
que
la
instituci√≥n
actualice
su
enla-


ce
con
Internet
.
Por
supuesto
,
la
instituci√≥n
tiene
que
comprar
e
instalar
una
cach√©
web
,
pero


este
coste
es
bajo
,
ya
que
muchas
cach√©s
utilizan
software
de
dominio
p√∫blico
que
se
ejecu-


ta
en
computadoras
PC
baratas
.


2.2.6
GET
condicional


Aunque
el
almacenamiento
en
cach√©
puede
reducir
los
tiempos
de
respuesta
percibidos
por


el
usuario
,
introduce
un
nuevo
problema
:
la
copia
de
un
objeto
que
reside
en
la
cach√©
puede


estar
desactualizada
.
En
otras
palabras
,
el
objeto
almacenado
en
el
servidor
web
puede
haber


sido
modificado
desde
que
la
copia
fue
almacenada
en
la
cach√©
del
cliente
.
Afortunada-


mente
,
HTTP
dispone
de
un
mecanismo
que
permite
a
la
cach√©
verificar
que
sus
objetos


est√°n
actualizados
.
Este
mecanismo
se
denomina
GET
condicional
.
Un
mensaje
de
solici-


tud
HTTP
se
denomina
tambi√©n
mensaje
GET
condicional
si
(
1
)
el
mensaje
de
solicitud


utiliza
el
m√©todo
GET
y
(
2
)
el
mensaje
de
solicitud
incluye
una
l√≠nea
de
cabecera
If-


Modified-Since
:
.


Para
ilustrar
c√≥mo
opera
el
GET
condicional
,
veamos
un
ejemplo
.
En
primer
lugar
,
una


cach√©
proxy
env√≠a
un
mensaje
de
solicitud
a
un
servidor
web
en
nombre
de
un
navegador


que
realiza
una
solicitud
:


GET
/fruit
/
kiwi.gif
HTTP/1.1


Host
:
www.exotiquecuisine.com


En
segundo
lugar
,
el
servidor
web
env√≠a
a
la
cach√©
un
mensaje
de
respuesta
con
el
objeto


solicitado
:


HTTP/1.1
200
OK


Date
:
Sat
,
7
Jul
2007
15:39:29


Server
:
Apache/1.3.0
(
Unix
)


Last-Modified
:
Wed
,
4
Jul
2007
09:23:24


Content-Type
:
image
/
gif


(
datos
datos
datos
datos
datos
...
)


La
cach√©
reenv√≠a
el
objeto
al
navegador
que
lo
ha
solicitado
pero
tambi√©n
lo
almacena
local-


mente
.
Y
lo
que
es
m√°s
importante
,
la
cach√©
tambi√©n
almacena
la
fecha
de
la
√∫ltima
modifi-


caci√≥n
junto
con
el
objeto
.
En
tercer
lugar
,
una
semana
despu√©s
,
otro
navegador
solicita
el


mismo
objeto
a
trav√©s
de
la
cach√©
y
el
objeto
todav√≠a
se
encuentra
almacenado
all√≠
.
Puesto


que
este
objeto
puede
haber
sido
modificado
en
el
servidor
web
en
el
transcurso
de
la


semana
,
la
cach√©
realiza
una
comprobaci√≥n
de
actualizaci√≥n
ejecutando
un
GET
condicio-


nal
.
Espec√≠ficamente
,
la
cach√©
env√≠a
:


GET
/fruit
/
kiwi.gif
HTTP/1.1


Host
:
www.exotiquecuisine.com


If-modified-since
:
Wed
,
4
Jul
2007
09:23:24


2.2
‚Ä¢
LA
WEB
Y
HTTP
111


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
111Observe
que
el
valor
de
la
l√≠nea
de
cabecera
If-modified-since
:
es
exactamente
igual


al
valor
de
la
l√≠nea
de
cabecera
Last-Modified
:
que
fue
enviada
por
el
servidor
hace
una


semana
.
Este
GET
condicional
le
pide
al
servidor
que
env√≠e
el
objeto
s√≥lo
si
√©ste
ha
sido


modificado
despu√©s
de
la
√∫ltima
fecha
especificada
.
Suponga
que
el
objeto
no
ha
sido
modi-


ficado
desde
el
4
de
julio
de
2007
a
las
09:23:24
.
Por
√∫ltimo
y
en
cuarto
lugar
,
el
servidor


web
env√≠a
un
mensaje
de
respuesta
a
la
cach√©
:


HTTP/1.1
304
Not
Modified


Date
:
Sat
,
14
Jul
2007
15:39:29


Server
:
Apache/1.3.0
(
Unix
)


(
cuerpo
de
entidad
vac√≠o
)


Vemos
que
en
respuesta
al
GET
condicional
el
servidor
web
env√≠a
un
mensaje
de
respuesta
,


pero
no
incluye
el
objeto
solicitado
en
el
mismo
.
Si
incluyera
el
objeto
solicitado
s√≥lo
conse-


guir√≠a
desperdiciar
ancho
de
banda
e
incrementar
el
tiempo
de
respuesta
percibido
por
el
usua-


rio
,
especialmente
si
el
tama√±o
del
objeto
es
grande
.
Observe
que
este
√∫ltimo
mensaje
de


respuesta
muestra
en
la
l√≠nea
de
estado
el
texto
304
Not
Modified(no
modificado
)
,
lo
que


indica
a
la
cach√©
que
puede
reenviar
la
copia
del
objeto
que
tiene
en
cach√©
al
navegador
que
lo


haya
solicitado
.


Aqu√≠
terminamos
nuestra
exposici√≥n
acerca
de
HTTP
,
el
primer
protocolo
de
Internet


(
un
protocolo
de
la
capa
de
aplicaci√≥n
)
que
hemos
estudiado
en
detalle
.
Hemos
examinado


el
formato
de
los
mensajes
HTTP
y
las
acciones
realizadas
por
el
servidor
y
el
cliente
web


seg√∫n
se
env√≠an
y
reciben
estos
mensajes
.
Tambi√©n
hemos
visto
algo
acerca
de
la
infraes-


tructura
de
las
aplicaciones
web
,
incluyendo
las
cach√©s
,
las
cookies
y
las
bases
de
datos


back-end
,
elementos
todos
ellos
que
est√°n
ligados
de
alguna
manera
con
el
protocolo
HTTP
.


2.3
Transferencia
de
archivos
:
FTP


En
una
sesi√≥n
FTP
t√≠pica
,
el
usuario
est√°
sentado
frente
a
un
host
(
el
host
local
)
y
desea


transferir
archivos
a
o
desde
un
host
remoto
.
Para
que
el
usuario
pueda
acceder
a
la
cuenta


remota
,
debe
proporcionar
una
identificaci√≥n
de
usuario
y
una
contrase√±a
.
Una
vez
propor-


cionada
esta
informaci√≥n
de
autorizaci√≥n
,
el
usuario
puede
transferir
archivos
desde
el
sis-


tema
de
archivos
local
al
sistema
de
archivos
remoto
,
y
viceversa
.
Como
se
muestra
en
la


Figura
2.14
,
el
usuario
interact√∫a
con
FTP
a
trav√©s
de
un
agente
de
usuario
FTP
.
En
primer


lugar
,
el
usuario
proporciona
el
nombre
del
host
remoto
,
lo
que
hace
que
el
proceso
cliente


FTP
en
el
host
local
establezca
una
conexi√≥n
TCP
con
el
proceso
servidor
FTP
en
el
host


remoto
.
A
continuaci√≥n
,
el
usuario
proporciona
su
identificaci√≥n
y
su
contrase√±a
,
que
son


enviados
a
trav√©s
de
la
conexi√≥n
TCP
como
parte
de
los
comandos
FTP
.
Una
vez
que
el
servi-


dor
ha
autorizado
al
usuario
,
el
usuario
copia
uno
o
m√°s
archivos
almacenados
en
el
sistema


de
archivos
local
en
el
sistema
de
archivos
remoto
(
o
viceversa
)
.


HTTP
y
FTP
son
protocolos
de
transferencia
de
archivos
y
tienen
muchas
caracter√≠sti-


cas
en
com√∫n
;
por
ejemplo
,
ambos
se
ejecutan
por
encima
de
TCP
.
Sin
embargo
,
estos
dos


protocolos
de
la
capa
de
aplicaci√≥n
tambi√©n
presentan
algunas
diferencias
importantes
.
La


diferencia
principal
es
que
FTP
utiliza
dos
conexiones
TCP
paralelas
para
transferir
un


archivo
,
una
conexi√≥n
de
control
y
una
conexi√≥n
de
datos
.
La
conexi√≥n
de
control
se


emplea
para
enviar
informaci√≥n
de
control
entre
los
dos
hosts
,
como
la
identificaci√≥n
del


112
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
112Figura
2.14
‚Ä¢
FTP
transfiere
archivos
entre
un
sistema
de
archivos
local


y
un
sistema
de
archivos
remoto
.


Figura
2.15
‚Ä¢
Conexiones
de
control
y
de
datos
.


usuario
,
la
contrase√±a
,
comandos
para
modificar
el
directorio
remoto
y
comandos
para
‚Äú
intro-


ducir
‚Äù
(
PUT
)
y
‚Äú
extraer
‚Äù
(
GET
)
archivos
.
La
conexi√≥n
de
datos
se
utiliza
para
enviar
un


archivo
.
Puesto
que
FTP
utiliza
una
conexi√≥n
de
control
separada
,
se
dice
que
FTP
env√≠a
su


informaci√≥n
de
control
fuera
de
banda
.
En
el
Cap√≠tulo
7
veremos
que
el
protocolo
RTSP
,


que
se
utiliza
para
controlar
la
transferencia
de
medios
continuos
como
audio
y
v√≠deo
,
tam-


bi√©n
env√≠a
su
informaci√≥n
de
control
fuera
de
banda
.
Como
recordar√°
,
HTTP
env√≠a
las
l√≠neas


de
cabecera
de
solicitud
y
respuesta
por
la
misma
conexi√≥n
TCP
que
transporta
el
propio


archivo
transferido
.
Por
esta
raz√≥n
,
se
dice
que
HTTP
env√≠a
su
informaci√≥n
de
control
en


banda
.
En
la
siguiente
secci√≥n
veremos
que
SMTP
,
el
principal
protocolo
para
el
correo
elec-


tr√≥nico
,
tambi√©n
env√≠a
la
informaci√≥n
de
control
en
banda
.
En
la
Figura
2.15
se
ilustran
las


conexiones
de
control
y
de
datos
de
FTP
.


Cuando
un
usuario
inicia
una
sesi√≥n
FTP
con
un
host
remoto
,
el
lado
del
cliente
de
FTP


(
usuario
)
establece
en
primer
lugar
una
conexi√≥n
de
control
TCP
con
el
lado
del
servidor


(
host
remoto
)
en
el
puerto
de
servidor
n√∫mero
21
.
El
lado
del
cliente
de
FTP
env√≠a
la
identi-


ficaci√≥n
y
la
contrase√±a
del
usuario
a
trav√©s
de
esta
conexi√≥n
de
control
.
El
lado
del


cliente
FTP
tambi√©n
env√≠a
,
a
trav√©s
de
la
conexi√≥n
control
,
comandos
para
modificar
el


directorio
remoto
.
Cuando
el
lado
del
servidor
recibe
un
comando
para
realizar
una
trans-


ferencia
de
archivo
a
trav√©s
de
la
conexi√≥n
de
control
(
bien
a
,
o
desde
el
host
remoto
)
,
el


lado
del
servidor
inicia
una
conexi√≥n
de
datos
TCP
con
el
lado
del
cliente
.
FTP
env√≠a


exactamente
un
archivo
a
trav√©s
de
la
conexi√≥n
de
datos
y
luego
cierra
la
conexi√≥n
de


datos
.
Si
durante
la
misma
sesi√≥n
el
usuario
desea
transferir
otro
archivo
,
FTP
abre
otra


conexi√≥n
de
datos
.
Luego
,
con
FTP
,
la
conexi√≥n
de
control
permanece
abierta
mientras
que


Conexi√≥n
de
control
TCP


sobre
puerto
21

     
Conexi√≥n
de
datos
TCP


sobre
puerto
20Cliente


FTP


Servidor


FTP


Interfaz
de


usuario
FTP


Sistema
de


archivos
local


Usuario


o
host


Sistema
de


archivos
remoto


Cliente


FTP


Servidor


FTP


Transferencia
de
archivos


2.3
‚Ä¢
TRANSFERENCIA
DE
ARCHIVOS
:
FTP
113


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
113dure
la
sesi√≥n
de
usuario
,
pero
se
crea
una
nueva
conexi√≥n
de
datos
para
cada
archivo
trans-


ferido
dentro
de
la
sesi√≥n
(
es
decir
,
las
conexiones
de
datos
no
son
persistentes
)
.


Al
o
 
l
a
r
g
o
 
d
e
 
l
a
 
s
e
s
i
√≥
n
,
 
e
l
 
s
e
r
v
i
d
o
r
 
F
T
Pt
i
e
n
e
 
q
u
e
 
m
a
n
t
e
n
e
r
 
u
n
 
estado
del
usuario
.
En


concreto
,
el
servidor
debe
asociar
la
conexi√≥n
de
control
con
una
cuenta
de
usuario
espec√≠-


fica
y
debe
estar
al
tanto
del
directorio
actual
del
usuario
cuando
√©ste
se
mueve
por
el
√°rbol


del
directorio
remoto
.
Llevar
el
control
de
esta
informaci√≥n
de
estado
para
cada
sesi√≥n
de


usuario
activa
restringe
de
forma
significativa
el
n√∫mero
total
de
sesiones
que
FTP
puede


mantener
simult√°neamente
.
Recuerde
que
HTTP
,
por
el
contrario
,
es
un
protocolo
sin


memoria
del
estado
(
no
tiene
que
recordar
el
estado
de
los
usuarios
)
.


2.3.1
Comandos
y
respuestas
de
FTP


Vamos
a
terminar
esta
secci√≥n
con
una
breve
explicaci√≥n
de
algunos
de
los
comandos
y
res-


puestas
de
FTP
m√°s
comunes
.
Los
comandos
,
del
cliente
al
servidor
,
y
las
respuestas
,
del


servidor
al
cliente
,
se
env√≠an
a
trav√©s
de
la
conexi√≥n
de
control
en
formato
ASCII
de
7
bits
.


Por
tanto
,
al
igual
que
los
comandos
HTTP
,
las
personas
pueden
leer
los
comandos
FTP
.


Para
separar
los
comandos
sucesivos
se
a√±ade
un
retorno
de
carro
y
un
salto
de
l√≠nea
al
final


de
cada
comando
.
Cada
comando
consta
de
cuatro
caracteres
ASCII
en
letras
may√∫sculas
y


algunos
emplean
argumentos
opcionales
.
Algunos
de
los
comandos
m√°s
comunes
son
los


siguientes
:


‚Ä¢
USER
nombre_de_usuario
:
se
utiliza
para
enviar
la
identificaci√≥n
del
usuario
al
ser-


vidor
.


‚Ä¢
PASS
contrase√±a
:
se
utiliza
para
enviar
la
contrase√±a
del
usuario
al
servidor
.


‚Ä¢
LIST
:
se
utiliza
para
pedir
al
servidor
que
devuelva
una
lista
de
todos
los
archivos
exis-


tentes
en
el
directorio
remoto
actual
.
La
lista
de
archivos
se
env√≠a
a
trav√©s
de
una
cone-


xi√≥n
de
datos
(
nueva
y
no
persistente
)
,
en
lugar
de
a
trav√©s
de
la
conexi√≥n
de
control
TCP
.


‚Ä¢
RETR
nombre_de_archivo
:
se
utiliza
para
recuperar
(
es
decir
,
extraer
)
un
archivo
del


directorio
actual
del
host
remoto
.
Este
comando
hace
que
el
host
remoto
inicie
una
cone-


xi√≥n
de
datos
y
env√≠e
el
archivo
solicitado
a
trav√©s
de
la
conexi√≥n
de
datos
.


‚Ä¢
STOR
nombre_de_archivo
:
se
utiliza
para
almacenar
(
es
decir
,
introducir
)
un
archivo


en
el
directorio
actual
del
host
remoto
.


Existe
una
correspondencia
uno
a
uno
entre
el
comando
que
ejecuta
el
usuario
y
el


comando
FTP
enviado
a
trav√©s
de
la
conexi√≥n
de
control
.
Cada
comando
va
seguido
de
una


respuesta
,
enviada
desde
el
servidor
al
cliente
.
Las
respuestas
son
n√∫meros
de
tres
d√≠gitos
,


con
un
mensaje
opcional
que
sigue
al
n√∫mero
.
Esta
estructura
es
similar
a
la
del
c√≥digo
de


estado
y
la
frase
explicativa
de
la
l√≠nea
de
estado
en
los
mensajes
de
respuesta
HTTP
.
Algu-


nas
respuestas
t√≠picas
,
junto
con
sus
posibles
frases
,
son
las
siguientes
:


‚Ä¢
331
Username
OK
,
password
required


‚Ä¢
125
Data
connection
already
open
;
transfer
starting


‚Ä¢
425
Can‚Äôt
open
data
connection


‚Ä¢
452
Error
writing
file


Los
lectores
que
est√©n
interesados
en
obtener
m√°s
informaci√≥n
acerca
de
otros
comandos


FTP
y
sus
respuestas
les
animamos
a
leer
el
documento
RFC
959
.


114
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1142.4
Correo
electr√≥nico
en
Internet


El
correo
electr√≥nico
ha
existido
desde
que
Internet
viera
la
luz
.
Era
la
aplicaci√≥n
m√°s
popu-


lar
cuando
Internet
estaba
en
sus
comienzos
[
Segaller
1998
]
y
a
lo
largo
de
los
a√±os
se
ha


ido
convirtiendo
en
una
aplicaci√≥n
cada
vez
m√°s
elaborada
y
potente
.
En
la
actualidad
conti-


n√∫a
siendo
una
de
las
aplicaciones
m√°s
importantes
y
utilizadas
de
Internet
.


Al
igual
que
el
servicio
ordinario
de
correo
postal
,
el
correo
electr√≥nico
es
un
medio
de


comunicaci√≥n
as√≠ncrono
(
las
personas
env√≠an
y
leen
los
mensajes
cuando
les
conviene
,
sin


tener
que
coordinarse
con
las
agendas
de
otras
personas
)
.
En
contraste
con
el
correo
postal
,


el
correo
electr√≥nico
es
r√°pido
,
f√°cil
de
distribuir
y
barato
.
Las
aplicaciones
modernas


de
correo
electr√≥nico
disponen
de
muchas
caracter√≠sticas
potentes
.
Mediante
las
listas
de


correo
,
se
pueden
enviar
mensajes
de
correo
electr√≥nico
y
correo
basura
(
spam
)
a
miles


de
destinatarios
a
un
mismo
tiempo
.
A
menudo
,
los
mensajes
de
correo
electr√≥nico
incluyen


adjuntos
,
hiperv√≠nculos
,
texto
en
formato
HTML
y
fotograf√≠as
.


En
esta
secci√≥n
vamos
a
examinar
los
protocolos
de
la
capa
de
aplicaci√≥n
que
forman
la


base
del
correo
electr√≥nico
en
Internet
.
Pero
antes
de
sumergirnos
en
una
explicaci√≥n
deta-


llada
acerca
de
estos
protocolos
,
vamos
a
proporcionar
una
visi√≥n
de
conjunto
del
sistema


de
correo
de
Internet
y
sus
componentes
fundamentales
.


La
Figura
2.16
muestra
una
visi√≥n
general
del
sistema
de
correo
de
Internet
.
A
partir
de


este
diagrama
,
vemos
que
existen
tres
componentes
principales
:
agentes
de
usuario
,


servidores
de
correo
y
el
Protocolo
simple
de
transferencia
de
correo
(
SMTP
,
Simple


Mail
Transfer
Protocol
)
.
A
continuaci√≥n
vamos
a
describir
cada
uno
de
estos
componentes


en
el
contexto
de
un
emisor
,
Alicia
,
que
env√≠a
un
mensaje
de
correo
electr√≥nico
a
un
desti-


natario
,
Benito
.
Los
agentes
de
usuario
permiten
a
los
usuarios
leer
,
responder
,
reenviar
,


guardar
y
componer
mensajes
.
(
Los
agentes
de
usuario
para
el
correo
electr√≥nico
a
veces
se


denominan
lectores
de
correo
,
aunque
en
general
nosotros
hemos
evitado
el
uso
de
este
t√©r-


mino
a
lo
largo
del
libro
.
)
Cuando
Alicia
termina
de
componer
su
mensaje
,
su
agente
de


usuario
env√≠a
el
mensaje
a
su
servidor
de
correo
,
donde
el
mensaje
es
colocado
en
la
cola
de


mensajes
salientes
del
servidor
de
correo
.
Cuando
Benito
quiere
leer
un
mensaje
,
su
agente


de
usuario
recupera
el
mensaje
de
su
buz√≥n
,
que
se
encuentra
en
el
servidor
de
correo
.
A


finales
de
la
d√©cada
de
1990
comenzaron
a
popularizarse
los
agentes
de
usuario
con
interfaz


gr√°fica
de
usuario
(
GUI
,
Graphical
User
Interface
)
,
permitiendo
a
los
usuarios
ver
y
com-


poner
mensajes
multimedia
.
Actualmente
,
Microsoft
Outlook
,
Apple
Mail
y
Mozilla
Thun-


derbird
se
encuentran
entre
los
agentes
de
usuario
con
interfaz
GUI
m√°s
populares
para


correo
electr√≥nico
.
Existen
tambi√©n
muchas
interfaces
de
usuario
de
dominio
p√∫blico


para
correo
electr√≥nico
basadas
en
texto
(
como
por
ejemplo
,
mail
,
pine
y
elm
)
,
as√≠
como


interfaces
basadas
en
la
Web
,
como
veremos
enseguida
.
 

Los
servidores
de
correo
forman
el
n√∫cleo
de
la
infraestructura
del
correo
electr√≥nico
.


Cada
destinatario
,
como
por
ejemplo
Benito
,
tiene
un
buz√≥n
de
correo
ubicado
en
uno
de


los
servidores
de
correo
.
El
buz√≥n
de
Benito
gestiona
y
mantiene
los
mensajes
que
le
han


sido
enviados
.
Un
mensaje
t√≠pico
inicia
su
viaje
en
el
agente
de
usuario
del
emisor
,
viaja


hasta
el
servidor
de
correo
del
emisor
y
luego
hasta
el
servidor
de
correo
del
destinatario
,


donde
es
depositado
en
el
buz√≥n
del
mismo
.
Cuando
Benito
quiere
acceder
a
los
mensajes


contenidos
en
su
buz√≥n
,
el
servidor
de
correo
que
lo
contiene
autentica
a
Benito
(
mediante


el
nombre
de
usuario
y
la
contrase√±a
)
.
El
servidor
de
correo
de
Alicia
tambi√©n
tiene
que
ocu-


parse
de
los
fallos
que
se
producen
en
el
servidor
de
correo
de
Benito
.
Si
el
servidor
de
Ali-


cia
no
puede
enviar
el
mensaje
de
correo
al
servidor
de
Benito
,
entonces
el
servidor
de
Alicia


2.4
‚Ä¢
CORREO
ELECTR√ìNICO
EN
INTERNET
115


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
115Figura
2.16
‚Ä¢
Esquema
general
del
sistema
de
correo
electr√≥nico
de
Internet
.


mantiene
el
mensaje
en
una
cola
de
mensajes
e
intenta
enviarlo
m√°s
tarde
.
Normalmente
,


los
reintentos
de
env√≠o
se
realizan
m√°s
o
menos
cada
30
minutos
;
si
despu√©s
de
varios
d√≠as


no
se
ha
conseguido
,
el
servidor
elimina
el
mensaje
y
se
lo
notifica
al
emisor
(
Alicia
)


mediante
un
mensaje
de
correo
electr√≥nico
.


SMTP
es
el
principal
protocolo
de
la
capa
de
aplicaci√≥n
para
el
correo
electr√≥nico
por


Internet
.
Utiliza
el
servicio
de
transferencia
de
datos
fiable
de
TCP
para
transferir
el
correo


desde
el
servidor
de
correo
del
emisor
al
servidor
de
correo
del
destinatario
.
Al
igual
que
la


mayor√≠a
de
los
protocolos
de
la
capa
de
aplicaci√≥n
,
SMTP
tiene
dos
lados
:
el
lado
del


cliente
,
que
se
ejecuta
en
el
servidor
de
correo
del
emisor
,
y
el
lado
del
servidor
,
que
se
eje-


cuta
en
el
servidor
de
correo
del
destinatario
.
Tanto
el
lado
del
cliente
como
el
del
servidor


de
SMTP
se
ejecutan
en
todos
los
servidores
de
correo
.
Cuando
un
servidor
de
correo
env√≠a


mensajes
de
correo
a
otros
servidores
de
correo
,
act√∫a
como
un
cliente
SMTP
.
Cuando
un


servidor
de
correo
recibe
correo
de
otros
servidores
,
act√∫a
como
un
servidor
SMTP
.


2.4.1
SMTP


El
protocolo
SMTP
,
que
est√°
definido
en
el
documento
RFC
5321
,
es
el
coraz√≥n
del
correo


electr√≥nico
por
Internet
.
Como
hemos
mencionado
anteriormente
,
SMTP
transfiere
mensa-


Cola
de
mensajes


salientes


Clave
:


Buz√≥n
de
correo
del
usuario


SMTP


Agente


de
usuario


Agente


de
usuario


Agente


de
usuario


Agente


de
usuario


Agente


de
usuarioAgente


de
usuario


Servidor


de
correo


Servidor


de
correo


Servidor


de
correo


SMTP


SMTP


116
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
116jes
desde
los
servidores
de
correo
de
los
emisores
a
los
servidores
de
correo
de
los
destinata-


rios
.
SMTP
es
mucho
m√°s
antiguo
que
HTTP
.
(
El
RFC
original
que
se
ocupa
de
SMTP
data


de
1982
y
SMTP
ya
exist√≠a
bastante
tiempo
antes
.
)
Aunque
SMTP
tienen
muchas
cualidades


maravillosas
,
como
prueba
su
presencia
en
Internet
,
es
una
tecnolog√≠a
heredada
que
utiliza


algunas
funcionalidades
arcaicas
.
Por
ejemplo
,
restringe
el
cuerpo
(
no
s√≥lo
las
cabeceras
)
de


todos
los
mensajes
a
formato
ASCII
de
7
bits
.
Esta
restricci√≥n
ten√≠a
sentido
a
principios
de


la
d√©cada
de
1980
,
cuando
la
capacidad
de
transmisi√≥n
era
escasa
y
nadie
enviaba
mensajes


con
adjuntos
o
im√°genes
de
gran
tama√±o
,
o
archivos
de
audio
o
v√≠deo
.
Pero
actualmente
,
en


la
era
multimedia
,
la
restricci√≥n
del
formato
ASCII
de
7
bits
causa
muchos
problemas
:


requiere
que
los
datos
binarios
multimedia
se
codifiquen
a
ASCII
antes
de
ser
transmitidos
a


trav√©s
de
SMTP
y
requiere
que
el
correspondiente
mensaje
ASCII
sea
decodificado
de
vuelta


a
binario
una
vez
realizado
el
transporte
SMTP
.
Recuerde
,
como
hemos
visto
en
la
Secci√≥n


2.2
,
que
HTTP
no
precisa
que
los
datos
multimedia
sean
codificados
a
ASCII
antes
de
ser


transferidos
.


Para
ilustrar
el
funcionamiento
b√°sico
de
SMTP
vamos
a
recurrir
a
un
escenario
ya


conocido
.
Suponga
que
Alicia
desea
enviar
a
Benito
un
sencillo
mensaje
ASCII
.


2.4
‚Ä¢
CORREO
ELECTR√ìNICO
EN
INTERNET
117


CORREO
ELECTR√ìNICO
WEB


En
diciembre
de
1995
,
s√≥lo
unos
pocos
a√±os
despu√©s
de
que
se
‚Äú
inventara
‚Äù
la
Web
,


Sabeer
Bhatia
y
Jack
Smith
visitaron
la
empresa
de
capital
riesgo
en
Internet
de
Draper


Fisher
Jurvetson
y
le
propusieron
desarrollar
un
sistema
gratuito
de
correo
electr√≥nico
basa-


do
en
la
Web
.
La
idea
era
proporcionar
una
cuenta
de
correo
electr√≥nico
gratuita
a
cual-


quiera
que
lo
deseara
y
hacer
que
las
cuentas
fueran
accesibles
desde
la
Web
.
A
cambio


de
un
15
por
ciento
de
la
compa√±√≠a
,
Draper
Fisher
Jurvetson
financi√≥
a
Bhatia
y
Smith
,
que


montaron
la
empresa
Hotmail
.
Con
tres
personas
trabajando
a
tiempo
completo
y
14
a


tiempo
parcial
,
que
trabajaban
a
cambio
de
opci√≥n
de
compra
de
acciones
,
fueron
capa-


ces
de
desarrollar
y
lanzar
el
servicio
en
julio
de
1996
.
Un
mes
despu√©s
del
lanzamiento


ten√≠an
100.000
suscriptores
.
En
diciembre
de
1997
,
menos
de
18
meses
despu√©s
del
lan-


zamiento
del
servicio
,
Hotmail
ten√≠a
aproximadamente
12
millones
de
suscriptores
y
fue


adquirida
por
Microsoft
por
400
millones
de
d√≥lares
.
El
√©xito
de
Hotmail
a
menudo
se
atri-


buye
a
su
‚Äú
ventaja
de
ser
el
primero
en
tomar
la
iniciativa
‚Äù
y
al
‚Äú
marketing
viral
‚Äù
intr√≠nseco


al
correo
electr√≥nico
.
(
Quiz√°
algunos
de
los
estudiantes
que
est√©n
leyendo
este
libro
se


encuentren
entre
los
nuevos
emprendedores
que
ser√°n
los
primeros
en
concebir
y
desarrollar


servicios
de
Internet
con
‚Äú
ventaja
de
ser
el
primero
‚Äù
y
con
t√©cnicas
inherentes
de
‚Äú
marketing


viral
‚Äù
.
)


El
correo
electr√≥nico
contin√∫a
proliferando
,
haci√©ndose
cada
a√±o
que
pasa
m√°s
sofisti-


cado
y
potente
.
Uno
de
los
servicios
m√°s
populares
actualmente
es
gmail
de
Google
,
que


ofrece
gigabytes
de
almacenamiento
gratuito
,
servicios
avanzados
de
filtrado
de
correo


basura
y
de
detecci√≥n
de
virus
,
un
servicio
opcional
de
cifrado
de
correo
electr√≥nico
(
con


SSL
)
,
acceso
a
servicios
de
correo
electr√≥nico
de
terceros
y
una
interfaz
orientada
a
la
reali-


zacion
de
b√∫squedas
.


HISTORIA


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1171
.
Alicia
invoca
a
su
agente
de
usuario
para
correo
electr√≥nico
,
proporciona
la
direcci√≥n


de
correo
electr√≥nico
de
Benito
(
por
ejemplo
,
benito@unaescuela.edu
)
,
compone


un
mensaje
e
indica
al
agente
de
usuario
que
lo
env√≠e
.


2
.
El
agente
de
usuario
de
Alicia
env√≠a
el
mensaje
al
servidor
de
correo
de
ella
,
donde
es


colocado
en
una
cola
de
mensajes
.


3
.
El
lado
del
cliente
de
SMTP
,
que
se
ejecuta
en
el
servidor
de
correo
de
Alicia
,
ve
el


mensaje
en
la
cola
de
mensajes
.
Abre
una
conexi√≥n
TCP
con
un
servidor
SMTP
,
que
se


ejecuta
en
el
servidor
de
correo
de
Benito
.


4
.
Despu√©s
de
la
fase
de
negociaci√≥n
inicial
de
SMTP
,
el
cliente
SMTP
env√≠a
el
mensaje


de
Alicia
a
trav√©s
de
la
conexi√≥n
TCP
.


5
.
En
el
servidor
de
correo
de
Benito
,
el
lado
del
servidor
de
SMTP
recibe
el
mensaje
.
El


servidor
de
correo
de
Benito
coloca
entonces
el
mensaje
en
el
buz√≥n
de
Benito
.


6
.
Benito
invoca
a
su
agente
de
usuario
para
leer
el
mensaje
cuando
le
apetezca
.


En
la
Figura
2.17
se
resume
este
escenario
.


Es
importante
observar
que
normalmente
SMTP
no
utiliza
servidores
de
correo
inter-


medios
para
enviar
correo
,
incluso
cuando
los
dos
servidores
de
correo
se
encuentran
en


extremos
opuestos
del
mundo
.
Si
el
servidor
de
Alicia
est√°
en
Hong
Kong
y
el
de
Benito
est√°


en
St
.
Louis
,
la
conexi√≥n
TCP
ser√°
una
conexi√≥n
directa
entre
los
servidores
de
Hong
Kong


y
St
.
Louis
.
En
particular
,
si
el
servidor
de
correo
de
Benito
est√°
fuera
de
servicio
,
el
servi-


dor
de
Alicia
conservar√°
el
mensaje
y
lo
intentar√°
de
nuevo
(
el
mensaje
no
se
deja
en
un
ser-


vidor
de
correo
intermedio
)
.


Veamos
en
detalle
c√≥mo
transfiere
SMTP
un
mensaje
desde
un
servidor
de
correo
emi-


sor
a
un
servidor
de
correo
receptor
.
Comprobaremos
que
el
protocolo
SMTP
presenta


muchas
similitudes
con
los
protocolos
empleados
por
las
personas
para
las
interacciones


cara
a
cara
.
En
primer
lugar
,
el
cliente
SMTP
(
que
se
ejecuta
en
el
host
servidor
de
correo


emisor
)
establece
una
conexi√≥n
TCP
con
el
puerto
25
del
servidor
SMTP
(
que
se
ejecuta
en


el
host
servidor
de
correo
receptor
)
.
Si
el
servidor
no
est√°
operativo
,
el
cliente
lo
intentar√°


m√°s
tarde
.
Una
vez
que
se
ha
establecido
la
conexi√≥n
,
el
servidor
y
el
cliente
llevan
a
cabo


el
proceso
de
negociaci√≥n
de
la
capa
de
aplicaci√≥n
(
al
igual
que
las
personas
,
que
antes
de


intercambiar
informaci√≥n
se
presentan
,
los
clientes
y
servidores
SMTP
se
presentan
a
s√≠
mis-


mos
antes
de
transferir
la
informaci√≥n
)
.
Durante
esta
fase
de
negociaci√≥n
SMTP
,
el
cliente


118
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


SMTP


Servidor
de


correo
de
Alicia


Servidor
de


correo
de
Benito


Agente


de
Alicia


Agente


de
Benito


1


2
4
6


5


Cola
de
mensajes


Clave
:


Buz√≥n
de
correo
del
usuario


3


Figura
2.17
‚Ä¢
Alicia
env√≠a
un
mensaje
a
Benito
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
118SMTP
especifica
la
direcci√≥n
de
correo
electr√≥nico
del
emisor
(
la
persona
que
ha
generado


el
mensaje
)
y
la
direcci√≥n
de
correo
electr√≥nico
del
destinatario
.
Una
vez
que
el
cliente
y
el


servidor
SMTP
se
han
presentado
a
s√≠
mismos
,
el
cliente
env√≠a
el
mensaje
.
SMTP
cuenta
con


el
servicio
de
transferencia
de
datos
fiable
de
TCP
para
transferir
el
mensaje
al
servidor
sin


errores
.
El
cliente
repite
entonces
este
proceso
a
trav√©s
de
la
misma
conexi√≥n
TCP
si
tiene


que
enviar
otros
mensajes
al
servidor
;
en
caso
contrario
,
indica
a
TCP
que
cierre
la
cone-


xi√≥n
.


Veamos
ahora
una
transcripci√≥n
de
ejemplo
de
los
mensajes
intercambiados
entre
un


cliente
SMTP
(
C
)
y
un
servidor
SMTP
(
S
)
.
El
nombre
de
host
del
cliente
es
crepes.fr
y
el


nombre
de
host
del
servidor
es
hamburger.edu
.
Las
l√≠neas
de
texto
ASCII
precedidas
por


C
:
son
exactamente
las
l√≠neas
que
el
cliente
env√≠a
a
su
socket
TCP
y
las
l√≠neas
de
texto


ASCII
precedidas
por
S
:
son
las
l√≠neas
que
el
servidor
env√≠a
a
su
socket
TCP
.
La
siguiente


transcripci√≥n
comienza
tan
pronto
como
se
establece
la
conexi√≥n
TCP
.


S
:
220
hamburger.edu


C
:
HELO
crepes.fr


S
:
250
Hello
crepes.fr
,
pleased
to
meet
you


C
:
MAIL
FROM
:
<
alicia@crepes.fr
>


S
:
250
alicia@crepes.fr
...
Sender
ok


C
:
RCPT
TO
:
<
benito@hamburger.edu
>


S
:
250
benito@hamburger.edu
...
Recipient
ok


C
:
DATA


S
:
354
Enter
mail
,
end
with
‚Äú
.
‚Äù
on
a
line
by
itself


C
:
¬ø
Te
gusta
el
ketchup
?


C
:
¬ø
Y
los
pepinillos
en
vinagre
?


C
:
.


S
:
250
Message
accepted
for
delivery


C
:
QUIT


S
:
221
hamburger.edu
closing
connection


En
el
ejemplo
anterior
,
el
cliente
env√≠a
un
mensaje
(
‚Äú
¬ø
Te
gusta
el
ketchup
?
¬ø
Y
los


pepinillos
en
vinagre
?
‚Äù
)
desde
el
servidor
de
correo
crepes.fr
al
servidor
de


correo
hamburger.edu
.
Como
parte
del
di√°logo
,
el
cliente
ejecuta
cinco
comandos
:
HELO


(
una
abreviatura
de
HELLO
)
,
MAIL
FROM
,
RCPT
TO
,
DATA
y
QUIT
.
Estos
comandos
se


explican
por
s√≠
mismos
.
El
cliente
tambi√©n
env√≠a
una
l√≠nea
que
consta
√∫nicamente
de
un


punto
,
que
indica
el
final
del
mensaje
para
el
servidor
.
(
En
la
jerga
ASCII
,
cada
mensaje
ter-


mina
con
CRLF.CRLF
,
donde
CR
y
LF
se
corresponden
con
el
retorno
de
carro
y
el
salto
de


l√≠nea
,
respectivamente
.
)
El
servidor
responde
a
cada
comando
,
teniendo
cada
una
de
las
res-


puestas
un
c√≥digo
de
respuesta
y
una
explicaci√≥n
(
opcional
)
en
ingl√©s
.
Hemos
mencionado


que
SMTP
utiliza
conexiones
persistentes
:
si
el
servidor
de
correo
emisor
tiene
varios
men-


sajes
que
enviar
al
mismo
servidor
de
correo
receptor
,
puede
enviar
todos
los
mensajes
a
tra-


v√©s
de
la
misma
conexi√≥n
TCP
.
Para
cada
mensaje
,
el
cliente
inicia
el
proceso
con
un
nuevo


comando
MAIL
FROM
:
crepes.fr
,
designa
el
final
del
mensaje
con
un
√∫nico
punto
y
eje-


cuta
el
comando
QUITs√≥lo
despu√©s
de
que
todos
los
mensajes
hayan
sido
enviados
.


Es
muy
recomendable
que
utilice
Telnet
para
establecer
un
di√°logo
directo
con
un
ser-


vidor
SMTP
.
Para
ello
,
ejecute
:


telnet
NombreServidor
25


2.4
‚Ä¢
CORREO
ELECTR√ìNICO
EN
INTERNET
119


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
119donde
NombreServidores
el
nombre
de
un
servidor
de
correo
local
.
Al
hacer
esto
,
simple-


mente
est√°
estableciendo
una
conexi√≥n
TCP
entre
su
host
local
y
el
servidor
de
correo
.
Des-


pu√©s
de
escribir
esta
l√≠nea
,
deber√≠a
recibir
inmediatamente
la
respuesta
220
del
servidor
.
A


continuaci√≥n
,
ejecute
los
comandos
SMTPHELO
,
MAIL
FROM
,
RCPT
TO
,
DATA
,
CRLF.CRLF


y
QUIT
en
los
instantes
apropiados
.
Tambi√©n
es
extremadamente
recomendable
que
realice


la
Tarea
de
programaci√≥n
2
incluida
al
final
del
cap√≠tulo
.
En
esta
tarea
,
tendr√°
que
crear
un


agente
de
usuario
simple
que
implemente
el
lado
del
cliente
de
SMTP
.
Esto
le
permitir√°


enviar
un
mensaje
de
correo
electr√≥nico
a
un
destinatario
arbitrario
a
trav√©s
de
un
servi-


dor
de
correo
local
.


2.4.2
Comparaci√≥n
con
HTTP


Vamos
ahora
a
comparar
brevemente
SMTP
con
HTTP
.
Ambos
protocolos
se
emplean
para


transferir
archivos
de
un
host
a
otro
:
HTTP
transfiere
archivos
(
tambi√©n
denominados
obje-


tos
)
desde
un
servidor
web
a
un
cliente
web
(
normalmente
,
un
navegador
)
;
SMTP
transfiere


archivos
(
es
decir
,
mensajes
de
correo
electr√≥nico
)
desde
un
servidor
de
correo
a
otro
servi-


dor
de
correo
.
Para
transferir
los
archivos
,
tanto
HTTP
persistente
como
SMTP
emplean


conexiones
persistentes
.
Por
tanto
,
ambos
protocolos
tienen
caracter√≠sticas
comunes
.
Sin


embargo
,
tambi√©n
presentan
algunas
diferencias
.
En
primer
lugar
,
HTTP
es
principalmente


un
protocolo
pull
(
protocolo
de
extracci√≥n
):
alguien
carga
la
informaci√≥n
en
un
servidor


web
y
los
usuarios
utilizan
HTTP
para
extraer
la
informaci√≥n
del
servidor
cuando
desean
.


En
concreto
,
la
m√°quina
que
desea
recibir
el
archivo
inicia
la
conexi√≥n
TCP
.
Por
el
contra-


rio
,
SMTP
es
fundamentalmente
un
protocolo
push
(
protocolo
de
inserci√≥n
):
el
servidor
de


correo
emisor
introduce
el
archivo
en
el
servidor
de
correo
receptor
.
En
concreto
,
la
m√°quina


que
desea
enviar
el
archivo
inicia
la
conexi√≥n
TCP
.


Una
segunda
diferencia
,
a
la
que
hemos
aludido
anteriormente
,
es
que
SMTP
requiere


que
cada
mensaje
,
incluyendo
el
cuerpo
de
cada
mensaje
,
est√©
en
el
formato
ASCII
de
7
bits
.


Si
el
mensaje
contiene
caracteres
que
no
corresponden
a
dicho
formato
(
como
por
ejemplo
,


caracteres
acentuados
)
o
contiene
datos
binarios
(
como
por
ejemplo
un
archivo
de
imagen
)
,


entonces
el
mensaje
tiene
que
ser
codificado
en
ASCII
de
7
bits
.
Los
datos
HTTP
no
impo-


nen
esta
restricci√≥n
.


Una
tercera
diferencia
importante
tiene
que
ver
con
c√≥mo
se
maneja
un
documento
que


conste
de
texto
e
im√°genes
(
junto
con
posiblemente
otros
tipos
multimedia
)
.
Como
hemos


visto
en
la
Secci√≥n
2.2
,
HTTP
encapsula
cada
objeto
en
su
propio
mensaje
de
respuesta


HTTP
.
El
correo
Internet
incluye
todos
los
objetos
del
mensaje
en
un
mismo
mensaje
.


2.4.3
Formatos
de
los
mensajes
de
correo


Cuando
Alicia
escribe
una
carta
por
correo
ordinario
a
Benito
,
puede
incluir
todo
tipo
de


informaci√≥n
accesoria
en
la
parte
superior
de
la
carta
,
como
la
direcci√≥n
de
Benito
,
su
pro-


pia
direcci√≥n
de
respuesta
y
la
fecha
.
De
forma
similar
,
cuando
una
persona
env√≠a
un
men-


saje
de
correo
electr√≥nico
a
otra
,
una
cabecera
que
contiene
la
informaci√≥n
administrativa


antecede
al
cuerpo
del
mensaje
.
Esta
informaci√≥n
se
incluye
en
una
serie
de
l√≠neas
de


cabecera
,
que
est√°n
definidas
en
el
documento
RFC
5322
.
Las
l√≠neas
de
cabecera
y
el


cuerpo
del
mensaje
se
separan
mediante
una
l√≠nea
en
blanco
(
es
decir
,
mediante
CRLF
)
.


RFC
5322
especifica
el
formato
exacto
de
las
l√≠neas
de
cabecera
,
as√≠
como
sus
interpreta-


ciones
sem√°nticas
.
Como
con
HTTP
,
cada
l√≠nea
de
cabecera
contiene
texto
legible
,
que


120
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
120consta
de
una
palabra
clave
seguida
de
dos
puntos
y
de
un
valor
.
Algunas
de
las
palabras


clave
son
obligatorias
y
otras
son
opcionales
.
Toda
cabecera
tiene
que
estar
formada
por


una
l√≠nea
de
cabecera
From
:
y
una
l√≠nea
de
cabecera
To
:
;
tambi√©n
puede
incluir
una
l√≠nea


Subject
:
,
as√≠
como
otras
l√≠neas
de
cabecera
opcionales
.
Es
importante
destacar
que
estas


l√≠neas
de
cabecera
son
diferentes
de
los
comandos
SMTP
que
hemos
estudiado
en
la
Sec-


ci√≥n
2.4.1
(
incluso
aunque
contengan
algunas
palabra
comunes
como
‚Äú
from
‚Äù
y
‚Äú
to
‚Äù
)
.
Los


comandos
vistos
en
esa
secci√≥n
forman
parte
del
protocolo
de
negociaci√≥n
de
SMTP
;
las


l√≠neas
de
cabecera
examinadas
en
esta
secci√≥n
forman
parte
del
propio
mensaje
de
correo
.


Una
cabecera
de
mensaje
t√≠pica
ser√≠a
como
la
siguiente
:


From
:
alicia@crepes.fr


To
:
benito@hamburger.edu


Subject
:
B√∫squeda
del
significado
de
la
vida
.


Despu√©s
del
mensaje
de
cabecera
se
incluye
una
l√≠nea
en
blanco
y
,
a
continuaci√≥n
,
el
cuerpo


del
mensaje
(
en
ASCII
)
.
Deber√≠a
utilizar
Telnet
para
enviar
un
mensaje
a
un
servidor
de


correo
que
contenga
varias
l√≠neas
de
cabecera
,
incluyendo
la
l√≠nea
de
cabecera
del
asunto


Subject
:
.
Para
ello
,
ejecute
el
comando
telnet
NombreServidor
25
,
como
se
ha


explicado
en
la
Secci√≥n
2.4.1
.


2.4.4
Protocolos
de
acceso
para
correo
electr√≥nico


Una
vez
que
SMTP
env√≠a
el
mensaje
del
servidor
de
correo
de
Alicia
al
servidor
de
correo


de
Benito
,
el
mensaje
se
coloca
en
el
buz√≥n
de
este
√∫ltimo
.
A
lo
largo
de
esta
exposici√≥n
,


hemos
supuesto
t√°citamente
que
Benito
lee
su
correo
registr√°ndose
en
el
host
servidor
y
uti-


lizando
despu√©s
un
lector
de
correo
que
se
ejecuta
en
dicho
host
.
Hasta
principios
de
la


d√©cada
de
1990
√©sta
era
la
forma
habitual
de
hacer
las
cosas
.
Pero
,
actualmente
,
el
acceso
al


correo
electr√≥nico
utiliza
una
arquitectura
cliente-servidor
;
el
usuario
t√≠pico
lee
el
correo


electr√≥nico
con
un
cliente
que
se
ejecuta
en
el
sistema
terminal
del
usuario
,
por
ejemplo
,
en


un
PC
de
la
oficina
,
en
un
port√°til
o
en
una
PDA
.
Ejecutando
un
cliente
de
correo
en
un
PC


local
,
los
usuarios
disponen
de
un
rico
conjunto
de
funcionalidades
,
entre
las
que
se
incluye


la
posibilidad
de
visualizar
documentos
adjuntos
y
mensajes
multimedia
.


Puesto
que
Benito
(
el
destinatario
)
ejecuta
su
agente
de
usuario
en
su
PC
local
,
es
natu-


ral
que
considere
tambi√©n
incluir
un
servidor
de
correo
en
su
PC
local
.
De
esta
forma
,
el
ser-


vidor
de
correo
de
Alicia
dialogar√°
directamente
con
el
PC
de
Benito
.
Sin
embargo
,
hay
un


problema
con
este
m√©todo
.
Recuerde
que
un
servidor
de
correo
gestiona
buzones
de
correo


y
ejecuta
los
lados
del
cliente
y
del
servidor
de
SMTP
.
Si
el
servidor
de
correo
de
Benito


residiera
en
su
PC
local
,
entonces
el
PC
de
Benito
tendr√≠a
que
estar
siempre
encendido
y


conectado
a
Internet
para
recibir
los
nuevos
correos
que
pudieran
llegar
en
cualquier


momento
.
Pero
esto
es
impracticable
para
muchos
usuarios
de
Internet
.
En
su
lugar
,
un
usua-


rio
t√≠pico
ejecuta
un
agente
de
usuario
en
el
PC
local
pero
accede
a
su
buz√≥n
de
correo
alma-


cenado
en
un
servidor
de
correo
compartido
que
siempre
est√°
encendido
.
Este
servidor
es


compartido
con
otros
usuarios
y
,
normalmente
,
mantenido
por
el
ISP
del
usuario
(
por
ejem-


plo
,
una
universidad
o
una
empresa
)
.


Ahora
vamos
a
ver
qu√©
ruta
sigue
un
mensaje
de
correo
electr√≥nico
que
Alicia
env√≠a
a


Benito
.
Acabamos
de
estudiar
que
en
alg√∫n
punto
a
lo
largo
de
la
ruta
el
mensaje
de
correo


electr√≥nico
tiene
que
ser
depositado
en
el
servidor
de
correo
de
Benito
.
Esto
se
podr√≠a
con-


seguir
f√°cilmente
haciendo
que
el
agente
de
usuario
de
Alicia
env√≠e
el
mensaje
directamente


2.4
‚Ä¢
CORREO
ELECTR√ìNICO
EN
INTERNET
121


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
121al
servidor
de
correo
de
Benito
.
Y
esto
podr√≠a
hacerse
utilizando
SMTP
(
de
hecho
,
SMTP
ha


sido
dise√±ado
para
llevar
el
correo
electr√≥nico
de
un
host
a
otro
.
Sin
embargo
,
normalmente


el
agente
de
usuario
del
emisor
no
se
comunica
directamente
con
el
servidor
de
correo
del


destinatario
.
En
su
lugar
,
como
se
muestra
en
la
Figura
2.18
,
el
agente
de
usuario
de
Alicia


utiliza
SMTP
para
introducir
el
mensaje
de
correo
en
su
propio
servidor
de
correo
,
y
a
conti-


nuaci√≥n
el
servidor
de
correo
de
Alicia
utiliza
SMTP
(
como
un
cliente
SMTP
)
para
pasar
el


mensaje
al
servidor
de
correo
de
Benito
.
¬ø
Por
qu√©
este
procedimiento
en
dos
pasos
?
Funda-


mentalmente
,
porque
sin
la
retransmisi√≥n
a
trav√©s
del
servidor
de
correo
de
Alicia
,
el
agente


de
usuario
de
√©sta
no
tiene
ninguna
forma
de
acceder
a
un
servidor
de
correo
de
destino
inal-


canzable
.
Al
hacer
que
Alicia
deposite
primero
el
mensaje
en
su
propio
servidor
de
correo
,


√©ste
puede
intentar
una
y
otra
vez
enviar
el
mensaje
al
servidor
de
correo
de
Benito
,
por


ejemplo
,
cada
30
minutos
,
hasta
que
el
servidor
de
Benito
est√©
de
nuevo
operativo
.
(
Y
si
el


servidor
de
correo
de
Alicia
no
funciona
,
entonces
ella
tiene
el
recurso
de
¬°
quejarse
al
admi-


nistrador
del
sistema
!
)
.
El
RFC
que
se
ocupa
de
SMTP
define
c√≥mo
se
pueden
utilizar
los


comandos
SMTP
para
transmitir
un
mensaje
a
trav√©s
de
varios
servidores
 
SMTP
.


¬°
Pero
todav√≠a
falta
una
pieza
del
puzzle
!
¬ø
C√≥mo
un
destinatario
como
Benito
,
que
eje-


cuta
un
agente
de
usuario
en
su
PC
local
,
obtiene
sus
mensajes
,
que
se
encuentran
en
un
ser-


vidor
de
correo
de
su
ISP
?
Tenga
en
cuenta
que
el
agente
de
usuario
de
Benito
no
puede


utilizar
SMTP
para
obtener
los
mensajes
porque
es
una
operaci√≥n
de
extracci√≥n
(
pull
)
mien-


tras
que
SMTP
es
un
protocolo
push
(
de
inserci√≥n
)
.
As√≠
,
el
puzzle
se
completa
a√±adiendo
un


protocolo
especial
de
acceso
al
correo
que
permita
transferir
los
mensajes
del
servidor
de


correo
de
Benito
a
su
PC
local
.
Actualmente
existen
varios
protocolos
de
acceso
a
correo


electr√≥nico
populares
,
entre
los
que
se
incluyen
el
Protocolo
de
oficina
de
correos
versi√≥n


3
(
POP3
,
Post
Office
Protocol‚ÄîVersion
3
)
,
el
Protocolo
de
acceso
de
correo
de
Internet


(
IMAP
,
Internet
Mail
Access
Protocol
)
y
HTTP
.


La
Figura
2.18
proporciona
un
resumen
de
los
protocolos
que
se
utilizan
para
el
correo


de
Internet
:
SMTP
se
emplea
para
transferir
correo
desde
el
servidor
de
correo
del
emisor
al


servidor
de
correo
del
destinatario
;
SMTP
tambi√©n
se
utiliza
para
transferir
correo
desde
el


agente
de
usuario
del
emisor
al
servidor
de
correo
del
mismo
.
Para
transferir
los
mensajes


de
correo
almacenados
en
el
servidor
de
correo
del
destinatario
al
agente
de
usuario
del


mismo
se
emplea
un
protocolo
de
acceso
a
correo
,
como
POP3
.


POP3


POP3
es
un
protocolo
de
acceso
a
correo
extremadamente
simple
.
Est√°
definido
en
[
RFC


1939
]
,
que
es
un
documento
corto
y
bastante
claro
.
Dado
que
el
protocolo
es
tan
simple
,


su
funcionalidad
es
bastante
limitada
.
POP3
se
inicia
cuando
el
agente
de
usuario
(
el


122
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


SMTP


Servidor
de


correo
de
Alicia


Servidor
de


correo
de
Benito


Agente


de
Alicia


Agente


de
BenitoSMTP
POP3
,


IMAP
o


HTTP


Figura
2.18
‚Ä¢
Protocolos
de
correo
electr√≥nico
y
entidades
que
los
utilizan
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
122cliente
)
abre
una
conexi√≥n
TCP
en
el
puerto
110
al
servidor
de
correo
(
el
servidor
)
.
Una


vez
establecida
la
conexi√≥n
TCP
,
POP3
pasa
a
trav√©s
de
tres
fases
:
autorizaci√≥n
,
transac-


ci√≥n
y
actualizaci√≥n
.
Durante
la
primera
fase
,
la
autorizaci√≥n
,
el
agente
de
usuario
env√≠a


un
nombre
de
usuario
y
una
contrase√±a
(
en
texto
legible
)
para
autenticar
al
usuario
.


Durante
la
segunda
fase
,
la
de
transacci√≥n
,
el
agente
de
usuario
recupera
los
mensajes
;


tambi√©n
durante
esta
fase
,
el
agente
de
usuario
puede
marcar
los
mensajes
para
borrado
,


eliminar
las
marcas
de
borrado
y
obtener
estad√≠sticas
de
correo
.
La
tercera
fase
,
la
actuali-


zaci√≥n
,
tiene
lugar
despu√©s
que
el
cliente
haya
ejecutado
el
comando
quit
,
terminando
la


sesi√≥n
POP3
;
en
este
instante
,
el
servidor
de
correo
borra
los
mensajes
que
han
sido
mar-


cados
para
borrado
.


En
una
transacci√≥n
POP3
,
el
agente
de
usuario
ejecuta
comandos
y
el
servidor
devuelve


para
cada
comando
una
respuesta
.
Existen
dos
posibles
respuestas
:
+
OK(seguida
en
ocasio-


nes
por
una
serie
de
datos
servidor-cliente
)
,
utilizada
por
el
servidor
para
indicar
que
el


comando
anterior
era
correcto
;
y
-ERR
,
utilizada
por
el
servidor
para
indicar
que
hab√≠a
alg√∫n


error
en
el
comando
anterior
.


La
fase
de
autorizaci√≥n
tiene
dos
comandos
principales
:
user
<
nombreusuario
>
y


pass
<
contrase√±a
>
.
Para
ilustrar
estos
dos
comandos
,
le
sugerimos
que
establezca
una


conexi√≥n
Telnet
directamente
en
un
servidor
POP3
,
utilizando
el
puerto
110
,
y
ejecute
estos


comandos
.
Suponga
que
mailServer
es
el
nombre
de
su
servidor
de
correo
.
Ver√°
algo


similar
a
lo
siguiente
:


telnet
mailServer
110


+
OK
POP3
server
ready


user
benito


+
OK


pass
hambre


+
OK
user
successfully
logged
on


Si
escribe
mal
un
comando
,
el
servidor
POP3
le
responder√°
con
un
mensaje
-ERR
.


Abordemos
ahora
la
fase
de
transacci√≥n
.
Un
agente
de
usuario
que
utilice
POP3
suele


ser
configurado
(
por
el
usuario
)
para
‚Äú
descargar
y
borrar
‚Äù
o
para
‚Äú
descargar
y
guardar
‚Äù
.
La


secuencia
de
comandos
que
ejecute
un
agente
de
usuario
POP3
depender√°
de
en
cu√°l
de


estos
dos
modos
est√©
operando
.
En
el
modo
descargar
y
borrar
,
el
agente
de
usuario
ejecu-


tar√°
los
comandos
list
,
retry
dele
.
Por
ejemplo
,
suponga
que
el
usuario
tiene
dos
men-


sajes
en
su
buz√≥n
de
correo
.
En
el
di√°logo
que
proporcionamos
a
continuaci√≥n
,
C
:
(
que


quiere
decir
cliente
)
es
el
agente
de
usuario
y
S:(que
quiere
decir
servidor
)
es
el
servidor
de


correo
.
La
transacci√≥n
ser√°
similar
a
lo
siguiente
:


C
:
list


S
:
1
498


S
:
2
912


S
:
.


C
:
retr
1


S
:
(
bla
bla
...


S
:
.................


S
:
..........
bla
)


S
:
.


C
:
dele
1


2.4
‚Ä¢
CORREO
ELECTR√ìNICO
EN
INTERNET
123


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
123C
:
retr
2


S
:
(
bla
bla
...


S
:
.................


S
:
..........
bla
)


S
:
.


C
:
dele
2


C
:
quit


S
:
+
OK
POP3
server
signing
off


En
primer
lugar
,
el
agente
de
usuario
pide
al
servidor
de
correo
que
le
informe
del
tama√±o


de
cada
uno
de
los
mensajes
almacenados
.
A
continuaci√≥n
,
el
agente
de
usuario
recupera
y


borra
cada
uno
de
los
mensajes
del
servidor
.
Observe
que
despu√©s
de
la
fase
de
autorizaci√≥n
,


el
agente
de
usuario
s√≥lo
ha
utilizado
cuatro
comandos
:
list
,
retr
,
dele
y
quit
.
La
sin-


taxis
de
estos
comandos
est√°
definida
en
el
documento
RFC
1939
.
Despu√©s
de
procesar
el


comando
quit
,
el
servidor
POP3
entra
en
la
fase
de
actualizaci√≥n
y
borra
los
mensajes
1
y


2
del
buz√≥n
.


Un
problema
en
este
modo
de
descarga
y
borrado
es
que
el
destinatario
,
Benito
,
puede


ser
algo
n√≥mada
y
puede
desear
poder
acceder
a
sus
mensajes
de
correo
desde
varias
m√°qui-


nas
;
por
ejemplo
,
desde
el
PC
de
la
oficina
,
el
PC
de
su
casa
y
el
port√°til
.
El
modo
de
des-


carga
y
borrado
reparte
los
mensajes
de
correo
de
Benito
entre
estas
tres
m√°quinas
;
en


particular
,
si
Benito
lee
un
mensaje
en
el
PC
de
la
oficina
,
no
podr√°
volver
a
leerlo
en
el
por-


t√°til
en
su
casa
por
la
noche
.
En
el
modo
descargar
y
guardar
,
el
agente
de
usuario
deja
los


mensajes
en
el
servidor
de
correo
despu√©s
de
que
se
hayan
descargado
.
En
este
caso
,
Benito


podr√°
volver
a
leer
los
mensajes
desde
distintas
m√°quinas
;
puede
acceder
a
un
mensaje
en
el


trabajo
y
luego
tambi√©n
en
su
casa
si
lo
desea
.


Durante
una
sesi√≥n
POP3
entre
un
agente
de
usuario
y
el
servidor
de
correo
,
el
servidor


POP3
mantiene
cierta
informaci√≥n
de
estado
;
en
concreto
,
mantiene
la
relaci√≥n
de
los
men-


sajes
de
usuario
que
han
sido
marcados
para
ser
borrados
.
Sin
embargo
,
el
servidor
POP3
no


conserva
la
informaci√≥n
de
estado
de
una
sesi√≥n
POP3
a
otra
.
Esta
falta
de
memoria
del


estado
entre
sesiones
simplifica
enormemente
la
implementaci√≥n
de
un
servidor
POP3
.


IMAP


Con
el
acceso
POP3
,
una
vez
que
Benito
ha
descargado
sus
mensajes
en
la
m√°quina
local
,


puede
crear
carpetas
de
correo
y
mover
los
mensajes
descargados
a
las
carpetas
.
A
continua-


ci√≥n
,
puede
borrar
los
mensajes
,
pasarlos
a
carpetas
y
realizar
b√∫squedas
de
mensajes
(
por


nombre
del
emisor
o
asunto
)
.
Pero
este
paradigma
,
es
decir
,
las
carpetas
y
los
mensajes
guar-


dos
en
la
m√°quina
local
,
plantea
un
problema
para
el
usuario
n√≥mada
,
que
preferir√°
mante-


ner
una
jerarqu√≠a
de
carpetas
en
un
servidor
remoto
al
que
pueda
acceder
desde
cualquier


computadora
.
Esto
no
es
posible
con
POP3
(
el
protocolo
POP3
no
proporciona
ning√∫n


medio
al
usuario
para
crear
carpetas
remotas
y
asignar
mensajes
a
las
mismas
)
.


Para
resolver
este
y
otros
problemas
se
invent√≥
el
protocolo
IMAP
,
definido
en
[
RFC


3501
]
.
Al
igual
que
POP3
,
IMAP
es
un
protocolo
de
acceso
a
correo
.
Ofrece
muchas
m√°s
fun-


cionalidades
que
POP3
,
pero
tambi√©n
es
significativamente
m√°s
complejo
(
y
,
por
tanto
,
las


implementaciones
del
lado
del
cliente
y
del
lado
del
servidor
son
bastante
m√°s
complejas
)
.


Un
servidor
IMAP
asociar√°
cada
mensaje
con
una
carpeta
;
cuando
un
mensaje
llega
al


servidor
,
se
asocia
con
la
carpeta
INBOX
(
Bandeja
de
entrada
)
del
destinatario
,
el
cual


puede
entonces
pasar
el
mensaje
a
una
nueva
carpeta
creada
por
el
usuario
,
leer
el
mensaje
,


124
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
124borrarlo
,
etc.
El
protocolo
IMAP
proporciona
comandos
que
permiten
a
los
usuarios
crear


carpetas
y
mover
los
mensajes
de
una
carpeta
a
otra
.
IMAP
tambi√©n
proporciona
comandos


que
permiten
a
los
usuarios
realizar
b√∫squedas
en
carpetas
remotas
para
localizar
mensajes


que
cumplan
unos
determinados
criterios
.
Observe
que
,
a
diferencia
de
POP3
,
un
servidor


IMAP
mantiene
informaci√≥n
acerca
del
estado
a
lo
largo
de
las
sesiones
IMAP
,
como
por


ejemplo
,
los
nombres
de
las
carpetas
y
los
mensajes
asociados
con
cada
una
de
ellas
.
 

Otra
importante
caracter√≠stica
de
IMAP
es
que
dispone
de
comandos
que
permiten
a
un


agente
de
usuario
obtener
partes
componentes
de
los
mensajes
.
Por
ejemplo
,
un
agente
de


usuario
puede
obtener
s√≥lo
la
cabecera
del
mensaje
o
s√≥lo
una
parte
de
un
mensaje
MIME


de
varias
partes
.
Esta
caracter√≠stica
resulta
√∫til
cuando
se
emplea
una
conexi√≥n
con
un
ancho


de
banda
peque√±o
(
por
ejemplo
,
un
enlace
de
m√≥dem
de
baja
velocidad
)
entre
el
agente
de


usuario
y
su
servidor
de
correo
.
Con
una
conexi√≥n
de
ancho
de
banda
peque√±o
,
puede
que
el


usuario
no
quiera
descargar
todos
los
mensajes
guardados
en
su
buz√≥n
y
que
desee
saltarse


los
mensajes
largos
que
pueda
haber
;
por
ejemplo
un
archivo
de
audio
o
de
v√≠deo
.
Puede


obtener
m√°s
informaci√≥n
acerca
de
IMAP
en
el
sitio
oficial
de
IMAP
[
IMAP
2009
]
.


Correo
electr√≥nico
Web


Actualmente
,
cada
vez
m√°s
usuarios
env√≠an
y
acceden
a
su
correo
electr√≥nico
a
trav√©s
de
sus


navegadores
web
.
Hotmail
introdujo
a
mediados
de
la
d√©cada
de
1990
el
acceso
basado
en


la
Web
;
actualmente
,
tambi√©n
ofrece
este
servicio
Yahoo
,
Google
,
as√≠
como
casi
todas
las


principales
universidades
y
empresas
.
Con
este
servicio
,
el
agente
de
usuario
es
un
navega-


dor
web
corriente
y
el
usuario
se
comunica
con
su
buz√≥n
remoto
a
trav√©s
de
HTTP
.
Cuando


un
destinatario
,
como
Benito
,
desea
acceder
a
un
mensaje
de
su
buz√≥n
,
√©ste
es
enviado
desde


el
servidor
de
correo
de
Benito
al
navegador
del
mismo
utilizando
el
protocolo
HTTP
en


lugar
de
los
protocolos
POP3
o
IMAP
.
Cuando
un
emisor
,
como
Alicia
,
desea
enviar
un


mensaje
de
correo
electr√≥nico
,
√©ste
es
transmitido
desde
su
navegador
a
su
servidor
de


correo
a
trav√©s
de
HTTP
en
lugar
de
mediante
SMTP
.
Sin
embargo
,
el
servidor
de
correo
de


Alicia
,
contin√∫a
enviando
mensajes
a
,
y
recibiendo
mensajes
de
,
otros
servidores
de
correo


que
emplean
SMTP
.


2.5
DNS
:
servicio
de
directorio
de
Internet


Las
personas
podemos
ser
identificadas
de
muchas
maneras
.
Por
ejemplo
,
podemos
ser
iden-


tificadas
por
el
nombre
que
aparece
en
nuestro
certificado
de
nacimiento
,
por
nuestro


n√∫mero
de
la
seguridad
social
o
por
el
n√∫mero
del
carnet
de
conducir
.
Aunque
cada
uno
de


estos
datos
se
puede
utilizar
para
identificar
a
las
personas
,
dentro
de
un
determinado
con-


texto
un
identificador
puede
ser
m√°s
apropiado
que
otro
.
Por
ejemplo
,
las
computadoras
del


IRS
(
la
terrible
agencia
tributaria
de
Estados
Unidos
)
prefieren
utilizar
los
n√∫meros
de
la


seguridad
social
de
longitud
fija
que
el
nombre
que
aparece
en
el
certificado
de
nacimiento
.


Por
otro
lado
,
las
personas
prefieren
emplear
el
nombre
que
figura
en
los
certificados
de


nacimiento
,
m√°s
f√°ciles
de
recordar
,
a
los
n√∫meros
de
la
seguridad
social
(
puede
imaginar


que
alguien
le
dijera
‚Äú
Hola
.
Mi
nombre
es
132-67-9875
.
√âste
es
mi
marido
,
178-87-1146
.
‚Äù
)


No
s√≥lo
las
personas
podemos
ser
identificadas
de
diversas
formas
,
los
hosts
de
Internet


tambi√©n
.
Un
identificador
para
los
hosts
es
el
nombre
de
host
.
Los
nombres
de
host
,
como


por
ejemplo
cnn.com
,
www.yahoo.com
,
gaia.cs.umass.edu
y
cis.poly.edu
,
son


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
125


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
125mnem√≥nicos
y
son
,
por
tanto
,
entendidos
por
las
personas
.
Sin
embargo
,
los
nombres
de
host


proporcionan
poca
o
ninguna
informaci√≥n
acerca
de
la
ubicaci√≥n
del
host
dentro
de
Internet
.


(
Un
nombre
de
host
como
www.eurecom.fr
,
que
termina
con
el
c√≥digo
de
pa√≠s
,
.fr
,
nos


informa
de
que
es
probable
que
el
host
se
encuentre
en
Francia
,
pero
esto
no
dice
mucho


m√°s
.
)
Adem√°s
,
puesto
que
los
nombres
de
host
pueden
constar
de
caracteres
alfanum√©ricos


de
longitud
variable
,
podr√≠an
ser
dif√≠ciles
de
procesar
por
los
routers
.
Por
estas
razones
,
los


hosts
tambi√©n
se
identifican
mediante
direcciones
IP
.


En
el
Cap√≠tulo
4
veremos
en
detalle
las
direcciones
IP
,
pero
le
resultar√°
√∫til
leer
ahora


una
breve
exposici√≥n
sobre
las
mismas
.
Una
direcci√≥n
IP
consta
de
cuatro
bytes
y
sigue
una


r√≠gida
estructura
jer√°rquica
.
El
aspecto
de
una
direcci√≥n
IP
es
,
por
ejemplo
,
121.7.106.83
,


donde
cada
punto
separa
uno
de
los
bytes
expresados
en
notaci√≥n
decimal
con
valores
com-


prendidos
entre
0
y
255
.
Una
direcci√≥n
IP
es
jer√°rquica
porque
al
explorar
la
direcci√≥n
de


izquierda
a
derecha
,
se
obtiene
informaci√≥n
cada
vez
m√°s
espec√≠fica
acerca
del
lugar
en
el


que
est√°
ubicado
el
host
dentro
de
Internet
(
es
decir
,
en
qu√©
red
de
la
red
de
redes
)
.
De
forma


similar
,
cuando
examinamos
una
direcci√≥n
postal
de
abajo
a
arriba
,
obtenemos
cada
vez


informaci√≥n
m√°s
espec√≠fica
acerca
del
lugar
definido
por
la
direcci√≥n
.


2.5.1
Servicios
proporcionados
por
DNS


Acabamos
de
ver
que
hay
dos
formas
de
identificar
un
host
,
mediante
un
nombre
de
host
y


mediante
una
direcci√≥n
IP
.
Las
personas
prefieren
utilizar
como
identificador
el
nombre
de


host
(
m√°s
f√°cil
de
recordar
)
,
mientras
que
los
routers
prefieren
emplear
las
direcciones
IP
de


longitud
fija
y
que
siguen
una
estructura
jer√°rquica
.
Para
reconciliar
estas
preferencias
nece-


sitamos
un
servicio
de
directorio
que
traduzca
los
nombres
de
host
en
direcciones
IP
.
Esta
es


la
tarea
principal
que
lleva
a
cabo
el
Sistema
de
nombres
de
dominio
(
DNS
,
Domain


Name
System
)
de
Internet
.
DNS
es
(
1
)
una
base
de
datos
distribuida
implementada
en
una


jerarqu√≠a
de
ser-vidores
DNS
y
(
2
)
un
protocolo
de
la
capa
de
aplicaci√≥n
que
permite
a
los


hosts
consultar
la
base
de
datos
distribuida
.
Los
servidores
DNS
suelen
ser
m√°quinas
UNIX


que
ejecutan
el
software
BIND
(
Berkeley
Internet
Name
Domain
,
Dominio
de
nombres
de


Internet
de
Berkeley
)
[
BIND
2009
]
.
El
protocolo
DNS
se
ejecuta
sobre
UDP
y
utiliza
el


puerto
53
.


Otros
protocolos
de
la
capa
de
aplicaci√≥n
,
como
HTTP
,
SMTP
y
FTP
,
emplean
habitual-


mente
DNS
para
traducir
los
nombres
de
host
suministrados
por
el
usuario
en
direcciones


IP
.
Por
ejemplo
,
veamos
qu√©
ocurre
cuando
un
navegador
(
es
decir
,
un
cliente
HTTP
)
,
que


se
ejecuta
en
un
determinado
host
de
usuario
,
solicita
el
URL
www.unaescuela.edu/


index.html
.
Para
que
el
host
del
usuario
pueda
enviar
un
mensaje
de
solicitud
HTTP
al


servidor
web
www.unaescuela.edu
,
el
host
del
usuario
debe
obtener
en
primer
lugar
la


direcci√≥n
IP
de
www.unaescuela.edu
.
Esto
se
hace
del
siguiente
modo
:


1
.
La
propia
m√°quina
cliente
ejecuta
el
lado
del
cliente
de
la
aplicaci√≥n
DNS
.


2
.
El
navegador
extrae
el
nombre
de
host
,
www.unaescuela.edu
,
del
URL
y
pasa
el
nombre


de
host
al
lado
del
cliente
de
la
aplicaci√≥n
DNS
.


3
.
El
cliente
DNS
env√≠a
una
consulta
que
contiene
el
nombre
de
host
a
un
servidor
DNS
.


4
.
El
cliente
DNS
recibe
finalmente
una
respuesta
,
que
incluye
la
direcci√≥n
IP
correspon-


diente
al
nombre
del
host
.


5
.
Una
vez
que
el
navegador
recibe
la
direcci√≥n
IP
del
servidor
DNS
,
puede
iniciar
una


conexi√≥n
TCP
con
el
proceso
servidor
HTTP
localizado
en
el
puerto
80
en
esa
direcci√≥n
.


126
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
126Podemos
ver
a
partir
de
este
ejemplo
que
DNS
a√±ade
un
retardo
adicional
,
en
ocasiones
,


sustancial
,
a
las
aplicaciones
de
Internet
que
le
utilizan
.
Afortunadamente
,
como
veremos


m√°s
adelante
,
la
direcci√≥n
IP
deseada
a
menudo
est√°
almacenada
en
cach√©
en
un
servidor


DNS
‚Äú
pr√≥ximo
‚Äù
,
lo
que
ayuda
a
reducir
el
tr√°fico
de
red
DNS
,
as√≠
como
el
retardo
medio
del


servicio
DNS
.


DNS
proporciona
algunos
otros
servicios
importantes
adem√°s
de
la
traducci√≥n
de
los


nombres
de
host
en
direcciones
IP
:


‚Ä¢
Alias
de
host
.
Un
host
con
un
nombre
complicado
puede
tener
uno
o
m√°s
alias
.
Por
ejem-


plo
,
un
nombre
de
host
como
relay1.west-coast.enterprise.com
podr√≠a
tener
,


digamos
,
dos
alias
como
enterprise.com
y
www.enterprise.com
.
En
este
caso
,
el


nombre
de
host
relay1.west-coast.enterprise.com
se
dice
que
es
el
nombre
de


host
can√≥nico
.
Los
alias
de
nombres
de
host
,
cuando
existen
,
normalmente
son
m√°s
mne-


m√≥nicos
que
los
nombres
can√≥nicos
.
Una
aplicaci√≥n
puede
invocar
DNS
para
obtener


el
nombre
de
host
can√≥nico
para
un
determinado
alias
,
as√≠
como
la
direcci√≥n
IP
del
host
.


‚Ä¢
Alias
del
servidor
de
correo
.
Por
razones
obvias
,
es
enormemente
deseable
que
las


direcciones
de
correo
electr√≥nico
sean
mnem√≥nicas
.
Por
ejemplo
,
si
Benito
tiene
una


cuenta
de
Hotmail
,
su
direcci√≥n
de
correo
puede
ser
tan
simple
como
benito@hot-


mail.com
.
Sin
embargo
,
el
nombre
de
host
del
servidor
de
correo
de
Hotmail
es
m√°s


complicado
y
mucho
menos
mnem√≥nico
que
simplemente
hotmail.com
(
por
ejemplo
,


el
nombre
can√≥nico
podr√≠a
ser
algo
parecido
a
relay1.west-coast.hotmail.com
)
.


Una
aplicaci√≥n
de
correo
puede
invocar
al
servicio
DNS
para
obtener
el
nombre
de
host


can√≥nico
para
un
determinado
alias
,
as√≠
como
la
direcci√≥n
IP
del
host
.
De
hecho
,
el
regis-


tro
MX
(
v√©ase
m√°s
adelante
)
permite
al
servidor
de
correo
y
al
servidor
web
de
una


empresa
tener
nombres
de
host
(
con
alias
)
iguales
;
por
ejemplo
,
tanto
el
servidor
web


como
el
servidor
de
correo
de
una
empresa
se
pueden
llamar
enterprise.com
.


‚Ä¢
Distribuci√≥n
de
carga
.
DNS
tambi√©n
se
emplea
para
realizar
la
distribuci√≥n
de
carga
entre


servidores
replicados
,
como
los
servidores
web
replicados
.
Los
sitios
con
una
gran
carga
de


trabajo
,
como
cnn.com
,
est√°n
replicados
en
varios
servidores
,
ejecut√°ndose
cada
ser-


vidor
en
un
sistema
terminal
distinto
y
teniendo
cada
uno
una
direcci√≥n
IP
diferente
.


Para
los
servidores
web
replicados
hay
asociado
un
conjunto
de
direcciones
IP
con
un


√∫nico
nombre
de
host
can√≥nico
.
La
base
de
datos
DNS
contiene
este
conjunto
de
direccio-


nes
IP
.
Cuando
los
clientes
realizan
una
consulta
DNS
sobre
un
nombre
asignado
a
un


conjunto
de
direcciones
,
el
servidor
responde
con
el
conjunto
completo
de
direcciones
IP
,


pero
rota
el
orden
de
las
direcciones
en
cada
respuesta
.
Dado
que
normalmente
un
cliente


env√≠a
su
mensaje
de
solicitud
 
HTTP
a
la
direcci√≥n
IP
que
aparece
en
primer
lugar
dentro


del
conjunto
,
la
rotaci√≥n
DNS
distribuye
el
tr√°fico
entre
los
servidores
replicados
.
La
rota-


ci√≥n
DNS
tambi√©n
se
emplea
para
el
correo
electr√≥nico
de
modo
que
m√∫ltiples
servidores


de
correo
pueden
tener
el
mismo
alias
.
Recientemente
,
las
empresas
de
distribuci√≥n
de


contenido
como
Akamai
[
Akamai
2009
]
han
utilizado
DNS
de
formas
muy
sofisticadas


para
proporcionar
la
distribuci√≥n
de
contenido
web
(
v√©ase
el
Cap√≠tulo
7
)
.


DNS
est√°
especificado
en
los
documentos
RFC
1034
y
RFC
1035
,
y
actualizado
en


varios
RFC
adicionales
.
Se
trata
de
un
sistema
complejo
y
aqu√≠
s√≥lo
hemos
tocado
los
aspec-


tos
b√°sicos
de
su
funcionamiento
.
El
lector
interesado
puede
consultar
estos
RFC
y
el
libro


de
Abitz
y
Liu
[
Abitz
1993
]
;
tambi√©n
puede
consultar
el
documento
retrospectivo
[
Mockape-


tris
1988
]
,
que
proporciona
una
agradable
descripci√≥n
sobre
qu√©
es
DNS
y
el
por
qu√©
de


DNS
;
asimismo
puede
ver
[
Mockapetris
2005
]
.


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
127


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1272.5.2
C√≥mo
funciona
DNS


Ahora
vamos
a
presentar
a
alto
nivel
c√≥mo
funciona
DNS
.
Nos
centraremos
en
el
servicio


de
traducci√≥n
nombre
de
host-direcci√≥n
IP
.


Suponga
que
una
determinada
aplicaci√≥n
(
como
por
ejemplo
un
navegador
web
o
un


lector
de
correo
)
,
que
se
ejecuta
en
el
host
de
un
usuario
,
necesita
traducir
un
nombre
de
host


en
una
direcci√≥n
IP
.
La
aplicaci√≥n
invocar√°
al
lado
del
cliente
de
DNS
,
especificando
el


nombre
de
host
del
que
necesita
la
correspondiente
traducci√≥n
.
(
En
muchos
sistemas
basa-


dos
en
UNIX
,
gethostbyname
(
)
es
la
llamada
a
funci√≥n
que
una
aplicaci√≥n
utiliza
para


llevar
a
cabo
la
traducci√≥n
.
En
la
Secci√≥n
2.7
,
veremos
c√≥mo
una
aplicaci√≥n
Java
puede


invocar
al
servicio
DNS
.
)
Entonces
,
la
aplicaci√≥n
DNS
en
el
host
del
usuario
entra
en
fun-


cionamiento
,
enviando
un
mensaje
de
consulta
a
la
red
.
Todos
los
mensajes
de
consulta
y
de


respuesta
DNS
se
env√≠an
dentro
de
datagramas
UDP
al
puerto
53
.
Transcurrido
un
cierto


retardo
,
del
orden
de
milisegundos
a
segundos
,
el
servicio
DNS
del
host
del
usuario
recibe


un
mensaje
de
respuesta
DNS
que
proporciona
la
traducci√≥n
deseada
,
la
cual
se
pasa
enton-


ces
a
la
aplicaci√≥n
que
lo
ha
invocado
.
Por
tanto
,
desde
la
perspectiva
de
dicha
aplicaci√≥n


que
se
ejecuta
en
el
host
del
usuario
,
DNS
es
una
caja
negra
que
proporciona
un
servicio
de


traducci√≥n
simple
y
directo
.
Pero
,
de
hecho
,
la
caja
negra
que
implementa
el
servicio
es


compleja
,
constando
de
un
gran
n√∫mero
de
servidores
DNS
distribuidos
por
todo
el
mundo
,


as√≠
como
de
un
protocolo
de
la
capa
de
aplicaci√≥n
que
especifica
c√≥mo
los
servidores
DNS


y
los
hosts
que
realizan
las
consultas
se
comunican
.


Un
dise√±o
simple
de
DNS
podr√≠a
ser
un
servidor
DNS
que
contuviera
todas
las
corres-


pondencias
entre
nombres
y
direcciones
.
En
este
dise√±o
centralizado
,
los
clientes
simple-


mente
dirigir√≠an
todas
las
consultas
a
un
mismo
servidor
DNS
y
√©ste
responder√≠a


directamente
a
las
consultas
de
los
clientes
.
Aunque
la
simplicidad
de
este
dise√±o
es
atrac-


tiva
,
es
inapropiado
para
la
red
Internet
de
hoy
d√≠a
a
causa
de
la
enorme
(
y
creciente
)
canti-


dad
de
hosts
.
Entre
los
problemas
con
un
dise√±o
centralizado
podemos
citar
los
siguientes
:


128
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


DNS
:
FUNCIONES
CR√çTICAS
DE
RED
MEDIANTE


EL
PARADIGMA
CLIENTE-SERVIDOR


Como
HTTP
,
FTP
y
SMTP
,
el
protocolo
DNS
es
un
protocolo
de
la
capa
de
aplicaci√≥n
puesto
que
(
1
)


se
ejecuta
entre
sistemas
terminales
que
est√°n
en
comunicaci√≥n
utilizando
el
paradigma
cliente-servi-


dor
y
(
2
)
se
basa
en
un
protocolo
de
transporte
subyacente
extremo
a
extremo
para
transferir
los


mensajes
DNS
entre
los
sistemas
terminales
en
comunicaci√≥n
.
Sin
embargo
,
desde
otro
punto
de


vista
,
la
funci√≥n
de
DNS
es
bastante
diferente
a
la
de
las
aplicaciones
web
de
transferencia
de


archivos
y
de
correo
electr√≥nico
.
A
diferencia
de
estas
aplicaciones
,
DNS
no
es
una
aplicaci√≥n
con


la
que
el
usuario
interact√∫e
directamente
;
en
su
lugar
,
DNS
lleva
a
cabo
una
de
las
funciones
b√°si-


cas
en
Internet
:
traducir
los
nombres
de
hosts
en
sus
direcciones
IP
subyacentes
para
las
aplica-


ciones
de
usuario
y
otras
aplicaciones
software
de
Internet
.
Hemos
mencionado
en
la
Secci√≥n
1.2


que
gran
parte
de
la
complejidad
de
la
arquitectura
de
Internet
se
encuentra
en
las
‚Äú
fronteras
‚Äù
de
la


red
.
DNS
,
que
implementa
el
importante
proceso
de
traducci√≥n
de
nombres
en
direcciones
,
utilizan-


do
clientes
y
servidores
ubicados
en
la
frontera
de
la
red
,
es
otro
ejemplo
m√°s
de
dicha
filosof√≠a
de


dise√±o
.


PR√ÅCTICA


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
128‚Ä¢
Un
√∫nico
punto
de
fallo
.
Si
el
servidor
DNS
falla
,
entonces
¬°
tambi√©n
falla
toda
la
red


Internet
!


‚Ä¢
Volumen
de
tr√°fico
.
Un
√∫nico
servidor
DNS
tendr√≠a
que
gestionar
todas
las
consultas


DNS
(
de
todas
las
solicitudes
HTTP
y
mensajes
de
correo
electr√≥nico
generados
en
cien-


tos
de
millones
de
hosts
)
.


‚Ä¢
Base
de
datos
centralizada
distante
.
Un
√∫nico
servidor
DNS
no
puede
‚Äú
estar
cerca
‚Äù
de


todos
los
clientes
que
efect√∫an
consultas
.
Si
colocamos
ese
√∫nico
servidor
DNS
en
la
ciu-


dad
de
Nueva
York
,
entonces
todas
las
consultas
desde
Australia
deber√≠an
viajar
hasta
el


otro
extremo
del
globo
,
quiz√°
a
trav√©s
de
enlaces
lentos
y
congestionados
.
Esto
podr√≠a


llevar
por
tanto
a
retardos
significativos
.


‚Ä¢
Mantenimiento
.
Ese
√∫nico
servidor
DNS
tendr√≠a
que
mantener
registros
de
todos
los


hosts
de
Internet
.
No
s√≥lo
ser√≠a
una
enorme
base
de
datos
centralizada
,
sino
que
tendr√≠a


que
ser
actualizada
con
frecuencia
con
el
fin
de
incluir
todos
los
hosts
nuevos
.


En
resumen
,
una
base
de
datos
centralizada
almacenada
en
un
√∫nico
servidor
DNS
sim-


plemente
no
podr√≠a
escalarse
.
En
consecuencia
,
el
sistema
DNS
utiliza
un
dise√±o
distri-


buido
.
De
hecho
,
DNS
es
un
estupendo
ejemplo
de
c√≥mo
se
puede
implementar
una
base
de


datos
distribuida
en
Internet
.


Una
base
de
datos
jer√°rquica
y
distribuida


Para
abordar
el
problema
del
escalado
,
DNS
utiliza
un
gran
n√∫mero
de
servidores
,
organiza-


dos
de
forma
jer√°rquica
y
distribuidos
alrededor
de
todo
el
mundo
.
Ning√∫n
servidor
DNS


dispone
de
todas
las
correspondencias
de
todos
los
hosts
de
Internet
.
En
su
lugar
,
las
corres-


pondencias
est√°n
repartidas
por
los
servidores
DNS
.
En
una
primera
aproximaci√≥n
,
pode-


mos
decir
que
existen
tres
clases
de
servidores
DNS
:
los
servidores
DNS
ra√≠z
,
los
servidores


DNS
de
dominio
de
nivel
superior
(
TLD
,
Top-Level
Domain
)
y
los
servidores
DNS
autorita-


tivos
,
organizados
en
una
jerarqu√≠a
como
la
mostrada
en
la
Figura
2.19
.
Con
el
fin
de
com-


prender
c√≥mo
estas
tres
clases
de
servidores
interact√∫an
,
suponga
que
un
cliente
 
DNS
desea


determinar
la
direcci√≥n
IP
correspondiente
al
nombre
de
host
www.amazon.com
.
En
una


primera
aproximaci√≥n
tienen
lugar
los
siguientes
acontecimientos
:
primero
,
el
cliente
con-


tacta
con
uno
de
los
servidores
ra√≠z
,
el
cual
devuelve
las
direcciones
IP
para
los
servi-


Figura
2.19
‚Ä¢
Parte
de
la
jerarqu√≠a
de
los
servidores
DNS
.


Servidores
DNS


.edu


Servidores
DNS


.org


Servidores
DNS


.com


Servidores
DNS


poly.edu


Servidores
DNS


yahoo.com


Servidores
DNS


amazon.com


Servidores
DNS


pbs.org


Servidores
DNS


umass.edu


Servidores


DNS
ra√≠z


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
129


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
129Figura
2.20
‚Ä¢
Servidores
DNS
ra√≠z
en
2009
(
nombre
,
organizaci√≥n


y
ubicaci√≥n
)
.


dores
TLD
del
dominio
de
nivel
superior
.
com
.
A
continuaci√≥n
,
el
cliente
contacta
con
uno


de
estos
servidores
TLD
,
que
devuelve
la
direcci√≥n
IP
de
un
servidor
autoritativo
para
ama-


zon.com
.
Por
√∫ltimo
,
el
cliente
contacta
con
uno
de
los
servidores
autoritativos
de


amazon.com
,
el
cual
devuelve
la
direcci√≥n
IP
correspondiente
al
nombre
de
host
www.ama-


zon.com
.
Enseguida
examinaremos
este
proceso
de
b√∫squeda
DNS
con
m√°s
detalle
.
Pero
en


primer
lugar
,
echemos
un
vistazo
a
estas
tres
clases
de
servidores
DNS
:


‚Ä¢
Servidores
DNS
ra√≠z
.
En
Internet
,
existen
13
servidores
DNS
ra√≠z
(
etiquetados
como
A


hasta
M
)
,
la
mayor√≠a
de
los
cuales
se
localizan
en
Am√©rica
del
Norte
.
En
la
Figura
2.20


se
muestra
un
mapa
de
octubre
de
2006
de
los
servidores
DNS
ra√≠z
.
Hay
disponible
una


lista
de
los
servidores
DNS
ra√≠z
actuales
en
[
Root-servers
2009
]
.
Aunque
hemos
hecho


referencia
a
cada
uno
de
los
13
servidores
DNS
ra√≠z
como
si
fueran
un
√∫nico
servidor
,


cada
‚Äú
servidor
‚Äù
es
realmente
una
agrupaci√≥n
(
cluster
)
de
servidores
replicados
,
tanto
por


prop√≥sitos
de
seguridad
como
de
fiabilidad
.


‚Ä¢
Servidores
de
dominio
de
nivel
superior
(
TLD
)
.
Estos
servidores
son
responsables
de


los
dominios
de
nivel
superior
,
como
son
com
,
org
,
net
,
edu
y
gov
,
y
todos
los
dominios


de
nivel
superior
correspondientes
a
los
distintos
pa√≠ses
,
como
por
ejemplo
,
uk
,
fr
,
ca
y


jp
.
La
empresa
Network
Solutions
mantiene
los
servidores
TLD
para
el
dominio
de
nivel


superior
.com
y
la
empresa
Educause
mantiene
los
servidores
TLD
para
el
dominio
de


nivel
superior
.edu
.


‚Ä¢
Servidores
DNS
autoritativos
.
Todas
las
organizaciones
que
tienen
hosts
accesibles


p√∫blicamente
(
como
son
los
servidores
web
y
los
servidores
de
correo
)
a
trav√©s
de
Inter-


net
deben
proporcionar
registros
DNS
accesibles
p√∫blicamente
que
establezcan
la
corres-


pondencia
entre
los
nombres
de
dichos
hosts
y
sus
direcciones
IP
.
Un
servidor
DNS


autoritativo
de
una
organizaci√≥n
alberga
estos
registros
DNS
.
Una
organizaci√≥n
puede


a.


c.


d.


g.


h.


j.


Verisign
,
Dulles
,
VA


Cogent
,
Herndon
,
VA
(
tambi√©n
Los
Angeles
)


U
Maryland
College
Park
,
MD


US
DoD
Viena
,
VA


ARL
Aberdeen
,
MD


Verisign
,
(
21
localizaciones
)


i.
Autonomica
,
Estocolmo


(
m√°s
otras
28
localizaciones
)


k.
RIPE
Londres


(
y
otras
16
localizaciones
)


m.
WIDE
Tokio

     
(
tambi√©n
Seul
,
Par√≠s
,

     
San
Francisco
)


e.


f.


NASA
Mt
View
,
CA


Internet
Software
C.


Palo
Alto
,
CA


(
y
otras
36
localizaciones
)


b.

 
l.


USC-ISI
Marina
del
Rey
,
CA


ICANN
Los
Angeles
,
CA


130
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
130elegir
implementar
su
propio
servidor
DNS
autoritativo
para
almacenar
estos
registros
;


alternativamente
,
la
organizaci√≥n
puede
pagar
por
tener
esos
registros
almacenados
en


un
servidor
DNS
autoritativo
de
alg√∫n
proveedor
de
servicios
.
La
mayor√≠a
de
las
univer-


sidades
y
de
las
empresas
de
gran
tama√±o
implementan
y
mantienen
sus
propios
servido-


res
DNS
autoritativos
principal
y
secundario
(
backup
)
.


Todos
los
servidores
DNS
ra√≠z
,
TLD
y
autoritativos
pertenecen
a
la
jerarqu√≠a
de
servi-


dores
DNS
,
como
se
muestra
en
la
Figura
2.19
.
Existe
otro
tipo
importante
de
servidor
DNS


conocido
como
servidor
DNS
local
.
Un
servidor
DNS
local
no
pertenece
estrictamente
a
la


jerarqu√≠a
de
servidores
,
pero
no
obstante
es
importante
dentro
de
la
arquitectura
DNS
.
Cada


ISP
(
como
por
ejemplo
un
ISP
de
una
universidad
,
de
un
departamento
acad√©mico
,
de
una


empresa
o
residencial
)
tiene
un
servidor
DNS
local
(
tambi√©n
denominado
servidor
de
nom-


bres
predeterminado
)
.
Cuando
un
host
se
conecta
a
un
ISP
,
√©ste
proporciona
al
host
las
direc-


ciones
IP
de
uno
o
m√°s
de
sus
servidores
DNS
locales
(
normalmente
a
trav√©s
de
DHCP
,
lo


que
veremos
en
el
Cap√≠tulo
4
)
.
Usted
puede
determinar
f√°cilmente
la
direcci√≥n
IP
de
su
ser-


vidor
DNS
local
accediendo
a
las
ventanas
de
estado
de
la
red
en
Windows
o
UNIX
.
Gene-


ralmente
,
un
servidor
DNS
local
de
un
host
se
encuentra
‚Äú
cerca
‚Äù
de
ese
host
.
En
el
caso
de


un
ISP
institucional
,
el
servidor
DNS
local
puede
encontrarse
en
la
misma
LAN
que
el
host
;


en
el
caso
de
un
ISP
residencial
,
estar√°
separado
del
host
no
m√°s
de
unos
pocos
routers
.


Cuando
un
host
realiza
una
consulta
DNS
,
√©sta
se
env√≠a
al
servidor
DNS
local
,
que
act√∫a


como
proxy
,
reenviando
la
consulta
a
la
jerarqu√≠a
de
servidores
DNS
,
como
veremos
m√°s


detalladamente
a
continuaci√≥n
.


Veamos
un
ejemplo
sencillo
.
Suponga
que
el
host
cis.poly.edu
desea
conocer
la


direcci√≥n
de
gaia.cs.umass.edu
.
Suponga
tambi√©n
que
el
servidor
DNS
local
de
la
Uni-


versidad
Polit√©cnica
se
denomina
dns.poly.edu
y
que
un
servidor
DNS
autoritativo
para


gaia.cs.umass.edu
se
llama
dns.umass.edu
.
Como
se
muestra
en
la
Figura
2.21
,
el


host
cis.poly.eduenv√≠a
en
primer
lugar
un
mensaje
de
consulta
DNS
a
su
servidor
 
DNS


local
,
dns.poly.edu
.
El
mensaje
de
consulta
contiene
el
nombre
de
host
que
debe
ser
tra-


ducido
,
gaia.cs.umass.edu
.
El
servidor
DNS
local
reenv√≠a
la
consulta
a
un
servidor


DNS
ra√≠z
,
el
cual
toma
el
sufijo
eduy
devuelve
al
servidor
DNS
local
una
lista
de
las
direc-


ciones
IP
de
los
servidores
TLD
responsables
del
dominio
.edu
.
El
servidor
DNS
local
reen-


v√≠a
a
continuaci√≥n
el
mensaje
de
consulta
a
uno
de
estos
servidores
TLD
.
El
servidor
TLD


toma
nota
del
sufijo
umass.edu
y
responde
con
la
direcci√≥n
IP
del
servidor
DNS
autorita-


tivo
correspondiente
a
la
Universidad
de
Massachusetts
,
es
decir
,
dns.umass.edu
.
Por


√∫ltimo
,
el
servidor
DNS
local
reenv√≠a
la
consulta
directamente
a
dns.umass.edu
,
que
res-


ponde
con
la
direcci√≥n
IP
de
gaia.cs.umass.edu
.
Observe
que
en
este
ejemplo
,
para


obtener
la
direcci√≥n
correspondiente
a
un
nombre
de
host
,
se
han
env√≠ado
ocho
mensajes


DNS
:
¬°
cuatro
mensajes
de
consulta
y
cuatro
mensajes
de
respuesta
!
Pronto
veremos
c√≥mo
el


almacenamiento
en
cach√©
DNS
reduce
este
tr√°fico
de
consultas
.


En
el
ejemplo
anterior
supon√≠amos
que
el
servidor
TLD
conoce
el
servidor
DNS
autori-


tativo
correspondiente
al
nombre
de
host
.
En
general
esto
no
es
as√≠
.
En
lugar
de
ello
,
el
ser-


vidor
TLD
puede
saber
√∫nicamente
de
un
servidor
DNS
intermedio
,
el
cual
a
su
vez
sabe


cu√°l
es
el
servidor
DNS
autoritativo
para
el
nombre
de
host
.
Por
ejemplo
,
suponga
de
nuevo


que
la
Universidad
de
Massachusetts
tiene
un
servidor
DNS
para
la
universidad
,
denomi-


nado
dns.umass.edu
.
Suponga
tambi√©n
que
cada
uno
de
los
departamentos
de
la
Uni-


versidad
de
Massachusetts
tiene
su
propio
servidor
DNS
y
que
cada
servidor
DNS


departamental
es
un
servidor
autoritativo
para
todos
los
hosts
del
departamento
.
En
este


caso
,
cuando
el
servidor
DNS
intermedio
dns.umass.edurecibe
una
consulta
para
un
host


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
131


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
131Figura
2.21
‚Ä¢
Interacci√≥n
de
los
diversos
servidores
DNS
.


cuyo
nombre
termina
en
cs.umass.edu
,
devuelve
a
dns.poly.edu
la
direcci√≥n
IP
de


dns.cs.umass.edu
,
que
es
autoritativo
para
todos
los
nombres
de
host
que
terminan
con


cs.umass.edu
.
El
servidor
DNS
local
dns.poly.eduenv√≠a
entonces
la
consulta
al
servi-


dor
DNS
autoritativo
,
que
devuelve
la
correspondencia
deseada
al
servidor
DNS
local
,
el


cual
a
su
vez
devuelve
la
correspondencia
al
host
que
ha
hecho
la
solicitud
.
En
este
caso
,
¬°
se


han
env√≠ado
un
total
de
10
mensajes
!


El
ejemplo
mostrado
en
la
Figura
2.21
utiliza
tanto
consultas
recursivas
como


consultas
iterativas
.
La
consulta
enviada
desde
cis.poly.edu
a
dns.poly.edu
es
una


consulta
recursiva
,
ya
que
la
consulta
solicita
a
dns.poly.edu
que
obtenga
por
s√≠
mismo


la
correspondencia
.
Pero
las
tres
consultas
siguientes
son
iterativas
puesto
que
todas
las
res-


puestas
son
devueltas
directamente
a
dns.poly.edu
.
En
teor√≠a
,
cualquier
consulta
DNS


puede
ser
iterativa
o
recursiva
.
Por
ejemplo
,
la
Figura
2.22
muestra
una
cadena
de
consultas


DNS
para
las
que
todas
las
consultas
son
recursivas
.
En
la
pr√°ctica
,
las
consultas
normal-


mente
siguen
el
patr√≥n
mostrado
en
la
Figura
2.21
:
la
consulta
procedente
del
host
que
hace


la
solicitud
al
servidor
DNS
local
es
recursiva
y
las
restantes
consultas
son
iterativas
.
 

Almacenamiento
en
cach√©
DNS


Hasta
el
momento
hemos
ignorado
el
almacenamiento
en
cach√©
DNS
,
una
funcionalidad


extremadamente
importante
del
sistema
DNS
.
En
realidad
,
DNS
explota
exhaustivamente
el


Host
solicitante


cis.poly.edu


Servidor
DNS
local
Servidor
DNS
TLD


dns.poly.edu


Servidor
DNS
ra√≠z


1


8


2


7


4


5


3


6


Servidor
DNS
autoritativo


dns.umass.edu


gaia.cs.umass.edu


132
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
132Figura
2.22
‚Ä¢
Consultas
recursivas
en
DNS
.


almacenamiento
en
cach√©
para
mejorar
el
comportamiento
de
los
retardos
y
reducir
el


n√∫mero
de
mensajes
DNS
que
van
de
un
lado
a
otro
por
Internet
.
La
idea
que
se
esconde


detr√°s
del
almacenamiento
en
cach√©
DNS
es
muy
simple
.
En
una
cadena
de
consultas
,


cuando
un
servidor
DNS
recibe
una
respuesta
DNS
(
que
contiene
,
por
ejemplo
,
una
corres-


pondencia
entre
un
nombre
de
host
y
una
direcci√≥n
IP
)
,
puede
almacenar
esta
informaci√≥n


en
su
memoria
local
.
Por
ejemplo
,
en
la
Figura
2.21
,
cada
vez
que
el
servidor
DNS
local


dns.poly.edu
recibe
una
respuesta
de
alg√∫n
servidor
DNS
,
puede
almacenar
en
cach√©


cualquier
informaci√≥n
contenida
en
esa
respuesta
.
Si
una
relaci√≥n
nombre
de
host
/
direcci√≥n


IP
se
almacena
en
la
cach√©
de
un
servidor
DNS
y
llegan
otras
consultas
a
ese
mismo
servi-


dor
DNS
preguntando
por
el
mismo
nombre
de
host
,
el
servidor
DNS
puede
proporcionar
la


direcci√≥n
IP
deseada
,
incluso
aunque
no
sea
autoritativo
para
el
nombre
de
host
.
Dado
que


los
hosts
y
las
correspondencias
entre
nombres
de
host
y
direcciones
IP
no
son
permanentes
,


los
servidores
DNS
descartan
la
informaci√≥n
almacenada
en
cach√©
pasado
un
cierto
periodo


de
tiempo
(
normalmente
,
unos
dos
d√≠as
)
.


Por
ejemplo
,
suponga
que
un
host
apricot.poly.edu
consulta
a
dns.poly.edu


solicit√°ndole
la
direcci√≥n
IP
correspondiente
al
nombre
de
host
cnn.com
.
Suponga
tambi√©n


que
unas
pocas
horas
m√°s
tarde
,
otro
host
de
la
Universidad
Polit√©cnica
,
digamos


Host
solicitante


cis.poly.edu


Servidor
DNS
local
Servidor
DNS
TLD


dns.poly.edu


Servidor
DNS
ra√≠z


1


8


5


4


2


7


Servidor
DNS
autoritativo


dns.umass.edu


gaia.cs.umass.edu


6
3


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
133


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
133kiwi.poly.fr
,
tambi√©n
hace
una
consulta
a
dns.poly.eduespecificando
el
mismo
nom-


bre
de
host
.
Gracias
al
almacenamiento
en
cach√©
,
el
servidor
DNS
local
podr√°
devolver
de


forma
inmediata
la
direcci√≥n
IP
de
cnn.com
al
segundo
host
que
la
ha
solicitado
sin
tener


que
consultar
a
ning√∫n
otro
servidor
DNS
.
Un
servidor
DNS
local
tambi√©n
puede
almacenar


en
cach√©
las
direcciones
IP
de
los
servidores
TLD
,
permitiendo
as√≠
a
los
servidores
DNS


locales
saltarse
a
los
servidores
DNS
ra√≠z
en
una
cadena
de
consultas
(
lo
que
ocurre
con
fre-


cuencia
)
.


2.5.3
Registros
y
mensajes
DNS


Los
servidores
DNS
que
implementan
conjuntamente
la
base
de
datos
distribuida
DNS


almacenan
los
registros
de
recursos
(
RR
)
,
incluyendo
los
que
proporcionan
las
correspon-


dencias
entre
nombre
de
host
y
direcci√≥n
IP
.
Cada
mensaje
de
respuesta
DNS
transporta
uno


o
m√°s
registros
de
recursos
.
En
√©sta
y
en
la
subsecci√≥n
siguiente
,
proporcionamos
una
breve


introducci√≥n
a
los
recursos
y
mensajes
DNS
;
puede
encontrar
informaci√≥n
detallada
en


[
Abitz
1993
]
o
en
los
RFC
sobre
DNS
[
RFC
1034
;
RFC
1035
]
.


Un
registro
de
recurso
est√°
formado
por
los
siguientes
cuatro
campos
:


(
Nombre
,
Valor
,
Tipo
,
TTL
)


TTL
es
el
tiempo
de
vida
del
registro
de
recurso
;
determina
cu√°ndo
un
recurso
deber√≠a
ser


eliminado
de
una
cach√©
.
En
los
registros
de
ejemplo
dados
a
continuaci√≥n
,
hemos
ignorado


el
campo
TTL
.
El
significado
de
Nombrey
Valordepende
del
campo
Tipo
:


‚Ä¢S
i
 
Tipo
=
A
,
entonces
Nombre
es
un
nombre
de
host
y
Valor
es
la
direcci√≥n
IP
corres-


pondiente
a
dicho
nombre
.
Por
tanto
,
un
registro
de
tipo
A
proporciona
la
corresponden-


cia
est√°ndar
nombre
de
host-direcci√≥n
IP
.
Por
ejemplo
,
(
relay1.bar.foo.com
,


145.37.93.126
,
A)es
un
registro
de
tipo
A.


‚Ä¢S
i
 
Tipo
=
NS
,
entonces
Nombrees
un
dominio
(
como
foo.com
)
y
Valores
el
nombre
de


host
de
un
servidor
DNS
autoritativo
que
sabe
c√≥mo
obtener
las
direcciones
IP
de
los


hosts
del
dominio
.
Este
registro
se
utiliza
para
encaminar
las
consultas
DNS
a
lo
largo
de


la
cadena
de
consultas
.
Por
ejemplo
,
(
foo.com
,
dns.foo.com
,
NS)es
un
registro
de


tipo
NS
.


‚Ä¢S
i
 
Tipo
=
CNAME
,
entonces
Valores
un
nombre
de
host
can√≥nico
correspondiente
al
alias


especificado
por
Nombre
.
Este
registro
puede
proporcionar
a
los
hosts
que
hacen
consul-


tas
el
nombre
can√≥nico
correspondiente
a
un
nombre
de
host
.
Por
ejemplo
,
(
foo.com
,


relay1.bar.foo.com
,
CNAME)es
un
registro
CNAME
.


‚Ä¢S
i
 
Tipo
=
MX
,
entonces
Valor
es
el
nombre
can√≥nico
de
un
servidor
de
correo
que
tiene


un
alias
dado
por
Nombre
.
Por
ejemplo
,
(
foo.com
.
mail.bar.foo.com
,
MX
)
es
un


registro
MX
.
Los
registros
MX
permiten
a
los
nombres
de
host
de
los
servidores
de


correo
tener
alias
simples
.
Observe
que
utilizando
el
registro
MX
,
una
empresa
puede


tener
el
mismo
alias
para
su
servidor
de
correo
y
para
uno
de
sus
otros
servidores
(
como


por
ejemplo
,
el
servidor
web
)
.
Para
obtener
el
nombre
can√≥nico
del
servidor
de
correo
,


un
cliente
DNS
consultar√≠a
un
registro
MX
y
para
conocer
el
nombre
can√≥nico
del
otro


servidor
,
consultar√≠a
el
registro
CNAME
.


Si
un
servidor
DNS
es
autoritativo
para
un
determinado
nombre
de
host
,
entonces
el


servidor
DNS
contendr√°
un
registro
de
tipo
A
para
el
nombre
de
host
.
(
Incluso
aunque


134
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
134el
servidor
DNS
no
sea
autoritativo
,
puede
contener
un
registro
de
tipo
A
en
su
cach√©
.
)
Si
un


servidor
no
es
autoritativo
para
un
nombre
de
host
,
entonces
el
servidor
contendr√°
un
regis-


tro
de
tipo
NS
para
el
dominio
que
incluye
el
nombre
de
host
;
tambi√©n
contendr√°
un
registro


de
tipo
A
que
proporcione
la
direcci√≥n
IP
del
servidor
DNS
en
el
campo
Valor
del
registro


NS
.
Por
ejemplo
,
suponga
un
servidor
TLD
edu
que
no
es
autoritativo
para
el
host


gaia.cs.umass.edu
.
Por
tanto
,
este
servidor
contendr√°
un
registro
para
un
dominio
que


incluye
el
host
gaia.cs.umass.edu
,
por
ejemplo
,
(
umass.edu
,
dns.umass.edu
,


NS
)
.
El
servidor
TLD
edutambi√©n
contendr√≠a
un
registro
de
tipo
A
,
que
establece
la
corres-


pondencia
entre
el
servidor
DNS
dns.umass.edu
y
una
direcci√≥n
IP
,
como
en


(
dns.umass.edu
,
128.119.40.111
,
A
)
.


Mensajes
DNS


Anteriormente
en
esta
secci√≥n
hemos
hecho
referencia
a
los
mensajes
de
respuesta
y
consul-


tas
DNS
.
√önicamente
existen
estas
dos
clases
de
mensajes
DNS
.
Adem√°s
,
tanto
los
mensa-


jes
de
respuesta
como
de
consulta
utilizan
el
mismo
formato
,
que
se
muestra
en
la
Figura


2.23
.
La
sem√°ntica
en
los
distintos
campos
de
un
mensaje
DNS
es
la
siguiente
:


‚Ä¢L
o
s
 
p
r
i
m
e
r
o
s
 
1
2
 
b
y
t
e
s
 
c
o
n
s
t
i
t
u
y
e
n
 
l
a
 
secci√≥n
de
cabecera
,
la
cual
contiene
una
serie
de


campos
.
El
primero
de
estos
campos
es
un
n√∫mero
de
16
bits
que
identifica
la
consulta
.


Este
identificador
se
copia
en
el
mensaje
de
respuesta
a
la
consulta
,
lo
que
permite
al


cliente
establecer
las
correspondencias
correctas
entre
las
respuestas
recibidas
y
las
con-


sultas
enviadas
.
En
el
campo
Indicadores
se
incluyen
,
como
su
nombre
indica
,
una
serie


de
indicadores
.
Un
indicador
consulta
/
respuesta
de
1
bit
informa
de
si
el
mensaje
es
una


consulta
(
0
)
o
una
respuesta
(
1
)
.
Un
indicador
autoritativo
de
1
bit
se
activa
en
un
men-


saje
de
respuesta
cuando
un
servidor
DNS
es
un
servidor
autoritativo
para
un
nombre


soli-citado
.
 

Figura
2.23
‚Ä¢
Formato
de
los
mensajes
DNS
.


Identificaci√≥n


N√∫mero
de
cuestiones


N√∫mero
de
RR
de
autoridad


Campos
de
nombre
y
tipo


para
una
consulta


12
bytes


Registros
RR
en
respuesta


a
la
consulta


Registros
para
los


servidores
autoritativos


Informaci√≥n
de
‚Äú
ayuda
‚Äù


adicional
que
se
puede
utilizar


Indicadores


N√∫mero
de
RR
de
respuesta


N√∫mero
de
RR
adicionales


Autoridad


(
n√∫mero
variable
de
registros
de
recursos
)


Informaci√≥n
adicional


(
n√∫mero
variable
de
registros
de
recursos
)


Respuestas


(
n√∫mero
variable
de
registros
de
recursos
)


Cuestiones


(
n√∫mero
variable
de
cuestiones
)


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
135


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
135El
indicador
recursi√≥n-deseada
,
tambi√©n
de
1
bit
,
se
activa
cuando
un
cliente
(
host
o
ser-


vidor
DNS
)
desea
que
el
servidor
DNS
realice
una
recursi√≥n
cuando
no
disponga
del


registro
.
En
un
mensaje
de
respuesta
,
el
campo
de
recursi√≥n-disponible
de
1
bit
se
activa


si
el
servidor
DNS
soporta
la
recursi√≥n
.
En
la
cabecera
tambi√©n
se
incluyen
cuatro
cam-


pos
‚Äú
n√∫mero
de
‚Äù
,
que
indican
el
n√∫mero
de
apariciones
de
los
cuatro
tipos
de
secciones


de
datos
que
siguen
a
la
cabecera
.


‚Ä¢L
a
 
secci√≥n
cuestiones
contiene
informaci√≥n
acerca
de
la
consulta
que
se
va
a
realizar
.


Esta
secci√≥n
incluye
(
1
)
un
campo
de
nombre
que
contiene
el
nombre
que
se
va
a
consul-


tar
y
(
2
)
un
campo
de
tipo
que
especifica
el
tipo
de
cuesti√≥n
que
se
plantea
acerca
del


nombre
;
por
ejemplo
,
la
direcci√≥n
del
host
asociada
con
un
nombre
(
tipo
A
)
o
el
servidor


de
correo
para
un
nombre
(
tipo
MX
)
.


‚Ä¢E
n
 
u
n
a
 
r
e
s
p
u
e
s
t
a
 
d
e
 
u
n
 
s
e
r
v
i
d
o
r
 
D
N
S
,
 
l
a
 
secci√≥n
respuestas
contiene
los
registros
del


recurso
para
el
nombre
que
fue
consultado
originalmente
.
Recuerde
que
en
cada
registro


de
recurso
existe
un
par√°metro
Tipo
(
por
ejemplo
,
A
,
NS
,
CNAME
y
MX
)
,
un
par√°me-


tro
Valor
y
el
par√°metro
TTL
.
Una
respuesta
puede
devolver
varios
registros
de
recur-


sos
,
ya
que
un
nombre
de
host
puede
tener
asociadas
varias
direcciones
IP
(
por
ejemplo
,


para
los
servidores
web
replicados
,
como
hemos
visto
anteriormente
en
esta
secci√≥n
)
.


‚Ä¢L
a
 
secci√≥n
autoridad
contiene
registros
de
otros
servidores
autoritativos
.


‚Ä¢L
a
 
s
e
c
c
i
√≥
n
 
informaci√≥n
adicional
contiene
otros
registros
√∫tiles
.
Por
ejemplo
,
el
campo


de
respuesta
en
un
mensaje
de
respuesta
a
una
consulta
MX
contiene
un
registro
de


recurso
que
proporciona
el
nombre
de
host
can√≥nico
de
un
servidor
de
correo
.
Esta
sec-


ci√≥n
de
informaci√≥n
adicional
contiene
un
registro
de
tipo
A
que
proporciona
la
direc-


ci√≥n
IP
para
el
nombre
de
host
can√≥nico
del
servidor
de
correo
.


¬ø
Le
gustar√≠a
enviar
un
mensaje
de
consulta
DNS
directamente
desde
el
host
en
el
que


est√°
trabajando
a
alg√∫n
servidor
DNS
?
Esto
podr√≠a
hacerse
f√°cilmente
con
el
programa


nslookup
,
que
est√°
disponible
en
la
mayor√≠a
de
las
plataformas
Windows
y
UNIX
.
Por


ejemplo
,
en
un
host
Windows
basta
con
abrir
la
aplicaci√≥n
S√≠mbolo
del
sistema
(
prompt
)
e


invocar
al
programa
nslookup
escribiendo
simplemente
‚Äú
nslookup
‚Äù
.
A
continuaci√≥n
,
podr√°


enviar
una
consulta
DNS
a
cualquier
servidor
DNS
(
ra√≠z
,
TLD
o
autoritativo
)
.
Despu√©s
de


recibir
el
mensaje
de
respuesta
del
servidor
DNS
,
nslookup
mostrar√°
los
registros
incluidos


en
la
respuesta
(
en
un
formato
legible
para
las
personas
)
.
Como
alternativa
a
la
ejecuci√≥n
de


nslookup
desde
su
propio
host
,
puede
visitar
uno
de
los
muchos
sitios
web
que
permiten
uti-


lizar
nslookup
de
forma
remota
(
basta
con
escribir
‚Äú
nslookup
‚Äù
en
un
motor
de
b√∫squeda


para
acceder
a
uno
de
estos
sitios
)
.


Inserci√≥n
de
registros
en
la
base
de
datos
DNS


La
exposici√≥n
anterior
se
ha
centrado
en
c√≥mo
se
recuperan
los
registros
de
la
base
de
datos


DNS
.
Es
posible
que
ahora
se
est√©
preguntando
c√≥mo
se
introducen
los
registros
en
dicha


base
de
datos
.
Veamos
c√≥mo
se
hace
esto
en
el
contexto
de
un
ejemplo
concreto
.
Suponga


que
hemos
creado
una
nueva
empresa
llamada
Network
Utopia
.
Lo
primero
que
segura-


mente
desear√°
hacer
es
registrar
el
nombre
de
dominio
networkutopia.com
en
un
regis-


tro
.
Un
registrador
es
una
entidad
comercial
que
verifica
la
unicidad
del
nombre
de


dominio
,
lo
a√±ade
a
la
base
de
datos
DNS
(
como
veremos
m√°s
adelante
)
y
percibe
unas


peque√±as
tasas
por
sus
servicios
.
Antes
de
1999
,
un
√∫nico
registrador
,
Network
Solutions
,


136
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
136ten√≠a
el
monopolio
sobre
el
registro
de
nombres
para
los
dominios
com
,
net
y
org
.
Pero


actualmente
,
existen
muchas
entidades
registradoras
que
compiten
por
los
clientes
.
La


ICANN
(
Internet
Corporation
for
Assigned
Names
and
Numbers
,
Corporaci√≥n
de
Internet


para
nombres
y
n√∫meros
asignados
)
acredita
a
las
distintas
entidades
registradoras
.
En
la


direcci√≥n
http://www.internic.net
.
puede
encontrar
una
lista
completa
de
estas
enti-


dades
.


Al
registrar
el
nombre
de
dominio
networkutopia.com
en
alguna
entidad
registra-


dora
,
tambi√©n
tendr√°
que
proporcionarle
los
nombres
y
direcciones
IP
de
sus
servidores
DNS


autoritativos
principal
y
secundario
.
Suponga
que
en
nuestro
ejemplo
estos
datos
son
:


dns1.networkutopia.com
,
dns2.networkutopia.com
,
212.212.212.1
y
212
.


212.212.2
.
Para
cada
uno
de
estos
dos
servidores
el
registrador
se
asegura
de
que
se
intro-


duzca
un
registro
de
tipo
NS
y
un
registro
de
tipo
A
en
los
servidores
TLD
com
.
Espec√≠fi-


camente
,
para
el
servidor
autoritativo
principal
de
networkutopia.com
,
la
entidad


registradora
deber√°
insertar
los
siguientes
dos
registros
de
recursos
en
el
sistema
DNS
:


(
networkutopia.com
,
dns1.networkutopia.com
,
NS
)


(
dns1.networkutopia.com
,
212.212.212.1
,
A
)


Tambi√©n
tendr√°
que
asegurarse
de
que
el
registro
de
recurso
de
tipo
A
para
su
servidor
web


www.networkutopia.com
y
el
registro
de
recurso
de
tipo
MX
para
su
servidor
de
correo


mail.networkutopia.com
se
han
introducido
en
sus
servidores
DNS
autoritativos
.


(
Hasta
hace
poco
,
los
contenidos
de
los
servidores
DNS
se
configuraban
est√°ticamente
;
por


ejemplo
,
a
partir
de
un
archivo
de
configuraci√≥n
creado
por
un
administrador
del
sistema
.


Sin
embargo
,
recientemente
se
ha
a√±adido
una
opci√≥n
de
actualizaci√≥n
(
UPDATE
)
al
proto-


colo
DNS
que
permite
a√±adir
o
borrar
din√°micamente
los
datos
de
la
base
de
datos
mediante


mensajes
DNS
.
En
los
documentos
[
RFC
2136
]
y
[
RFC
3007
]
se
especifican
las
actualiza-


ciones
din√°micas
de
DNS
.
)


Una
vez
que
haya
completado
estos
pasos
,
los
usuarios
podr√°n
visitar
su
sitio
web
y


enviar
correos
electr√≥nicos
a
los
empleados
de
su
empresa
.
Vamos
a
terminar
esta
exposi-


ci√≥n
verificando
que
esta
afirmaci√≥n
es
cierta
.
Esta
verificaci√≥n
tambi√©n
le
ayudar√°
a
con-


solidar
lo
que
ha
aprendido
sobre
DNS
.
Suponga
que
Alicia
se
encuentra
en
Australia
y


desea
ver
la
p√°gina
web
www.networkutopia.com
.
Como
hemos
explicado
anterior-


mente
,
su
host
enviar√°
en
primer
lugar
una
consulta
DNS
a
su
servidor
DNS
local
,
el
cual
a


su
vez
se
pondr√°
en
contacto
con
un
servidor
TLD
com
.
(
El
servidor
DNS
local
tambi√©n


tendr√°
que
comunicarse
con
un
servidor
DNS
ra√≠z
si
no
tiene
en
cach√©
la
direcci√≥n
de
un


servidor
TLD
com
.
)
El
servidor
TLD
contendr√°
los
registros
de
recursos
de
tipo
NS
y
de


tipo
A
enumerados
anteriormente
,
ya
que
la
entidad
registradora
los
habr√°
almacenado
en


todos
los
servidores
TLD
com
.
El
servidor
TLD
com
env√≠a
entonces
una
respuesta
al
servi-


dor
DNS
local
de
Alicia
,
conteniendo
dicha
respuesta
los
dos
registros
de
recursos
.
A
con-


tinuaci√≥n
,
el
servidor
DNS
local
transmite
una
consulta
DNS
a
212.212.212.1
,


solicitando
el
registro
de
tipo
A
correspondiente
a
www.networkutopia.com
.
Este
regis-


tro
proporciona
la
direcci√≥n
IP
del
servidor
web
deseado
,
por
ejemplo
,
212.212.71.4
,


que
el
servidor
DNS
local
pasa
al
host
de
Alicia
.
En
este
momento
,
el
navegador
de
Alicia


puede
iniciar
una
conexi√≥n
TCP
con
el
host
212.212.71.4
y
enviar
una
solicitud
HTTP
a


trav√©s
de
la
misma
.
Como
ha
podido
ver
,
son
muchas
las
cosas
que
suceden
entre
bastido-


res
cuando
navegamos
por
la
Web
.


2.5
‚Ä¢
DNS
:
SERVICIO
DE
DIRECTORIO
DE
INTERNET
137


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
137138
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


VULNERABILIDADES
DNS


Hemos
visto
que
DNS
es
un
componente
fundamental
de
la
infraestructura
de
Internet
y
que


muchos
servicios
importantes
,
entre
los
que
incluyen
las
aplicaciones
web
y
de
correo
elec-


tr√≥nico
no
podr√≠an
funcionar
sin
√©l
.
Por
tanto
,
lo
natural
es
preguntarse
:
¬ø
C√≥mo
puede
ser


atacado
DNS
?
¬ø
Es
DNS
un
blanco
f√°cil
,
que
espera
a
ser
puesto
fuera
de
servicio
,
arrastran-


do
con
√©l
a
la
mayor√≠a
de
las
aplicaciones
de
Internet
?


El
primer
tipo
de
ataque
que
nos
viene
a
la
mente
es
un
ataque
DDoS
por
inundaci√≥n
de


ancho
de
banda
(
v√©ase
la
Secci√≥n
1.6
)
contra
los
servidores
DNS
.
Por
ejemplo
,
un
atacante


podr√≠a
intentar
enviar
a
cada
uno
de
los
servidores
DNS
ra√≠z
una
gran
cantidad
de
paquetes
,


tantos
que
la
mayor
parte
de
las
consultas
DNS
leg√≠timas
nunca
fueran
contestadas
.
Un
ataque


DDoS
a
gran
escala
contra
servidores
DNS
ra√≠z
tuvo
lugar
realmente
el
21
de
octubre
de


2002
.
En
ese
ataque
,
los
atacantes
utilizaron
una
botnet
para
enviar
enormes
cargas
de
mensa-


jes
ping
ICMP
a
los
13
servidores
DNS
ra√≠z
.
 
(
Los
mensajes
ICMP
se
estudian
en
el
Cap√≠tulo
4
.


Por
el
momento
,
nos
basta
con
saber
que
los
paquetes
ICMP
son
tipos
especiales
de
datagramas


IP
.
)
Afortunadamente
,
este
ataque
a
gran
escala
caus√≥
unos
da√±os
m√≠nimos
,
sin
tener
apenas


impacto
sobre
la
experiencia
en
Internet
de
los
usuarios
.
Los
atacantes
dirigieron
con
√©xito
gran


cantidad
de
paquetes
a
los
servidores
ra√≠z
,
pero
muchos
de
estos
servidores
estaban
protegi-


dos
mediante
mecanismos
de
filtrado
de
paquetes
configurados
para
bloquear
siempre
todos


los
mensajes
ping
ICMP
dirigidos
a
los
mismos
.
Estos
servidores
protegidos
estaban
resguarda-


dos
y
funcionaron
normalmente
.
Adem√°s
,
la
mayor√≠a
de
los
servidores
DNS
locales
ten√≠an
alma-


cenadas
en
cach√©
las
direcciones
IP
de
los
servidores
de
dominio
de
nivel
superior
,
permitiendo
el


procesamiento
de
consultas
ignorando
normalmente
a
los
servidores
DNS
ra√≠z
.


Un
ataque
DDoS
potencialmente
m√°s
efectivo
contra
servidores
DNS
consistir√≠a
en
enviar


una
gran
cantidad
de
consultas
DNS
a
los
servidores
de
dominio
de
alto
nivel
;
por
ejemplo
,


a
todos
aquellos
servidores
que
administren
el
dominio
.com
.
Ser√≠a
bastante
complicado


filtrar
las
consultas
DNS
dirigidas
a
servidores
DNS
;
y
los
servidores
de
dominio
de
nivel


superior
no
pueden
ser
puenteados
tan
f√°cilmente
como
los
servidores
ra√≠z
.
Pero
la
severidad


de
un
ataque
as√≠
podr√≠a
ser
parcialmente
mitigada
por
el
almacenamiento
en
cach√©
de
los


servidores
DNS
locales
.


El
sistema
DNS
tambi√©n
podr√≠a
ser
atacado
en
teor√≠a
de
otras
maneras
.
En
un
ataque
por


intermediaci√≥n
(
man-in-the-middle
)
,
el
atacante
intercepta
las
consultas
de
los
hosts
y
devuelve


respuestas
falsas
.
En
el
ataque
por
envenenamiento
DNS
,
el
atacante
env√≠a
respuestas
falsas


a
un
servidor
DNS
,
enga√±√°ndole
y
haciendo
que
almacene
en
su
cach√©
registros
falsos
.


Cualquiera
de
estos
ataques
podr√≠a
utilizarse
,
por
ejemplo
,
para
redirigir
a
un
usuario
web


inadvertido
al
sitio
web
del
atacante
.
Sin
embargo
,
estos
ataques
son
dif√≠ciles
de
implemen-


tar
,
ya
que
requieren
interceptar
los
paquetes
o
enga√±ar
a
los
servidores
[
Skoudis
2006
]
.


Otro
importante
ataque
DNS
no
es
un
ataque
al
servicio
DNS
en
s√≠
,
sino
que
se
aprove-


cha
de
la
infraestructura
de
DNS
para
lanzar
un
ataque
DDoS
contra
un
host
objetivo
(
por


ejemplo
,
el
servidor
de
correo
de
una
universidad
)
.
En
este
ataque
,
el
atacante
env√≠a
consultas


DNS
a
muchos
servidores
DNS
autoritativos
,
incluyendo
en
cada
consulta
como
direcci√≥n
de


origen
la
del
host
objetivo
.
Los
servidores
DNS
enviar√°n
entonces
sus
respuestas
directamente
al


host
objetivo
.
Si
las
consultas
pueden
crearse
de
tal
forma
que
una
respuesta
sea
mucho
m√°s


larga
(
en
bytes
)
que
una
consulta
(
lo
que
se
conoce
como
amplificaci√≥n
)
,
entonces
el
atacante


SEGURIDAD


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
138podr√≠a
potencialmente
colapsar
al
host
objetivo
sin
tener
que
generar
√©l
mismo
gran
parte
de


ese
tr√°fico
.
Hasta
la
fecha
,
estos
ataques
por
reflexi√≥n
que
explotan
DNS
han
tenido
un
√©xito


limitado
 
[
Mirkovic
2005
]
.


En
resumen
,
DNS
ha
demostrado
ser
sorprendentemente
robusto
frente
a
los
ataques
.


Hasta
el
momento
,
no
ha
habido
ning√∫n
ataque
que
haya
conseguido
interrumpir
con
√©xito
el


servicio
DNS
.
Por
el
contrario
,
s√≠
han
tenido
√©xito
ataques
por
reflexi√≥n
;
no
obstante
,
este
tipo


de
ataques
pueden
ser
(
y
est√°n
siendo
)
controlados
mediante
la
apropiada
configuraci√≥n
de


los
servidores
DNS
.


2.6
‚Ä¢
APLICACIONES
P2P
139


SEGURIDAD


2.6
Aplicaciones
P2P


Las
aplicaciones
descritas
en
este
cap√≠tulo
hasta
el
momento
,
incluyendo
las
aplicaciones


web
,
de
correo
electr√≥nico
y
DNS
,
emplean
todas
ellas
arquitecturas
cliente-servidor
que


dependen
en
gran
medida
de
que
exista
una
infraestructura
de
servidores
siempre
activos
.


Recuerde
de
la
Secci√≥n
2.1.1
que
con
una
arquitectura
P2P
no
se
depende
m√°s
que
m√≠nima-


mente
(
o
no
se
depende
en
absoluto
)
de
que
exista
esa
infraestructura
de
servidores
siempre


activos
.
En
su
lugar
,
una
serie
de
parejas
de
hosts
conectados
de
forma
intermitente
,
deno-


minados
pares
o
peers
,
se
comunican
directamente
entre
s√≠
.
Los
pares
no
son
propiedad
de


un
proveedor
de
servicios
,
sino
que
son
computadoras
de
escritorio
o
port√°tiles
controlados


por
los
usuarios
.


En
esta
secci√≥n
examinaremos
tres
tipos
de
aplicaciones
diferentes
que
est√°n
particular-


mente
bien
adaptadas
a
los
dise√±os
P2P.
La
primera
de
ellas
es
la
distribuci√≥n
de
archivos
,


donde
la
aplicaci√≥n
distribuye
un
archivo
desde
un
√∫nico
origen
a
un
gran
n√∫meros
de
pares
.


La
distribuci√≥n
de
archivos
es
un
buen
punto
de
partida
para
investigar
el
funcionamiento


de
P2P
,
ya
que
muestra
de
forma
clara
la
caracter√≠stica
de
auto-escalabilidad
de
las
arquitec-


turas
P2P.
Como
ejemplo
espec√≠fico
de
la
distribuci√≥n
de
archivos
,
vamos
a
describir
el


popular
sistema
BitTorrent
.
Con
la
segunda
aplicaci√≥n
P2P
,
examinaremos
una
base
de
datos


distribuida
a
lo
largo
de
una
comunidad
de
peers
de
gran
tama√±o
.
Para
esta
aplicaci√≥n
,
usa-


remos
el
concepto
de
Tabla
hash
distribuida
(
DHT
,
Distributed
Hash
Table
)
.
Por
√∫ltimo
y


como
tercera
aplicaci√≥n
,
estudiaremos
Skype
,
una
aplicaci√≥n
de
telefon√≠a
por
Internet
P2P


de
gran
√©xito
.


2.6.1
Distribuci√≥n
de
archivos
P2P


Comenzaremos
nuestra
incursi√≥n
en
P2P
considerando
una
aplicaci√≥n
muy
corriente
,
la
dis-


tribuci√≥n
de
un
archivo
de
gran
tama√±o
desde
un
√∫nico
servidor
a
muchos
otros
hosts
.
El


archivo
podr√≠a
ser
una
nueva
versi√≥n
del
sistema
operativo
Linux
,
un
parche
software
para


una
aplicaci√≥n
o
un
sistema
operativo
existentes
,
un
archivo
de
audio
 
MP3
o
un
archivo
de


v√≠deo
MPEG
.
En
la
distribuci√≥n
de
archivos
cliente-servidor
,
el
servidor
debe
enviar
una


copia
del
archivo
a
cada
uno
de
los
pares
,
provocando
una
enorme
sobrecarga
en
el
servidor


y
consumiendo
una
gran
cantidad
de
su
ancho
de
banda
.
En
la
distribuci√≥n
de
archivos
P2P
,


cada
par
puede
redistribuir
cualquier
parte
del
archivo
que
ha
recibido
a
cualesquiera
otros


pares
,
ayudando
de
este
modo
al
servidor
a
llevar
a
cabo
el
proceso
de
distribuci√≥n


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
139Figura
2.24
‚Ä¢
Problema
de
distribuci√≥n
de
un
archivo
.


En
el
momento
de
escribir
estas
l√≠neas
(
oto√±o
de
2009
)
,
el
protocolo
de
distribuci√≥n
de


archivos
P2P
m√°s
popular
es
BitTorrent
[
BitTorrent
2009
]
.
Originalmente
,
fue
desarrollado


por
Bram
Cohen
(
v√©ase
la
entrevista
a
Bram
Cohen
al
final
del
cap√≠tulo
)
,
pero
ahora
exis-


ten
muchos
clientes
BitTorrent
independientes
distintos
que
cumplen
con
el
protocolo
Bit-


Torrent
,
al
igual
que
existen
diversos
navegadores
web
que
cumplen
el
protocolo
HTTP
.


En
esta
subsecci√≥n
examinaremos
en
primer
lugar
la
caracter√≠stica
de
auto-escalabilidad
de


las
arquitecturas
P2P
en
el
contexto
de
la
distribuci√≥n
de
archivos
.
Despu√©s
describiremos


en
detalle
BitTorrent
,
destacando
sus
funcionalidades
y
caracter√≠sticas
m√°s
importantes
.


Escalabilidad
de
las
arquitecturas
P2P


Con
el
fin
de
comparar
las
arquitecturas
cliente-servidor
con
las
arquitecturas
P2P
y
para


ilustrar
la
auto-escalabilidad
inherente
de
P2P
,
ahora
vamos
a
considerar
un
modelo
cuanti-


tativo
simple
para
la
distribuci√≥n
de
un
archivo
a
un
conjunto
fijo
de
pares
en
ambos
tipos


de
arquitectura
.
Como
se
muestra
en
la
Figura
2.24
,
el
servidor
y
los
pares
est√°n
conecta-


dos
a
Internet
mediante
enlaces
de
acceso
.
Sea
us
la
velocidad
de
carga
del
enlace
de
acceso


del
servidor
,
ui
la
velocidad
de
carga
del
enlace
de
acceso
del
par
i
y
di
la
velocidad
de
des-


carga
del
enlace
de
acceso
del
par
i.
Sea
F
el
tama√±o
en
bits
del
archivo
que
se
va
a
distri-


buir
y
N
el
n√∫mero
de
pares
que
desean
obtener
una
copia
del
archivo
.
El
tiempo
de


distribuci√≥n
es
el
tiempo
que
tardan
los
N
pares
en
obtener
una
copia
del
archivo
.
En
el


an√°lisis
del
tiempo
de
distribuci√≥n
que
proporcionamos
a
continuaci√≥n
,
para
ambas
arqui-


tecturas
,
hemos
hecho
una
simplificaci√≥n
(
pero
generalmente
precisa
[
Akella
2003
]
):
supo-


ner
que
el
n√∫cleo
de
Internet
tiene
el
ancho
de
banda
suficiente
,
lo
que
implica
que
todos


los
cuellos
de
botella
se
encuentran
en
el
acceso
a
red
.
Tambi√©n
hemos
supuesto
que
el
ser-


vidor
y
los
clientes
no
est√°n
participando
en
ninguna
otra
aplicaci√≥n
de
red
,
de
modo
que


Internet


Archivo
:
F


Servidor


us


u1
u2


u3


d1


d2


d3


u4


u5u6


d4


d5


d6


uN


dN


140
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1402.6
‚Ä¢
APLICACIONES
P2P
141


los
anchos
de
banda
para
carga
y
descarga
est√°n
dedicados
completamente
a
distribuir
el


archivo
.


En
primer
lugar
,
vamos
a
determinar
el
tiempo
de
distribuci√≥n
para
la
arquitectura


cliente-servidor
,
el
cual
denotaremos
como
Dcs
.
En
esta
arquitectura
,
ninguno
de
los
pares


ayudan
a
distribuir
el
archivo
.
Tenemos
que
hacer
las
dos
observaciones
siguientes
:


‚Ä¢E
l
 
s
e
r
v
i
d
o
r
 
d
e
b
e
 
t
r
a
n
s
m
i
t
i
r
 
u
n
a
 
c
o
p
i
a
 
d
e
l
 
a
r
c
h
i
v
o
 
a
 
c
a
d
a
 
u
n
o
 
d
e
 
l
o
s
 
N
pares
.
Por
tanto
,
el


servidor
tiene
que
transmitir
NF
bits
.
Puesto
que
la
velocidad
de
carga
del
servidor
es
us
,


el
tiempo
para
distribuir
el
archivo
tiene
que
ser
como
m√≠nimo
NF
/
us
.


‚Ä¢S
e
a
 
dm√≠n
la
velocidad
de
descarga
del
par
cuya
velocidad
de
descarga
sea
menor
;
es
decir
,


dm√≠n
=
m√≠n
{
d1,dp
,
...
,
dN
}
.
El
par
con
la
menor
velocidad
de
descarga
no
puede
obtener
los


F
bits
del
archivo
en
menos
de
F
/
dm√≠n
segundos
.
Por
tanto
,
el
tiempo
m√≠nimo
de
distribu-


ci√≥n
es
,
al
menos
igual
a
F
/
dm√≠n
.


Teniendo
en
cuenta
estas
dos
observaciones
,
se
obtiene
:


Dcs
 
m√°x


Esto
proporciona
un
l√≠mite
inferior
al
tiempo
de
distribuci√≥n
para
la
arquitectura


cliente-servidor
.
En
los
problemas
de
repaso
se
le
pedir√°
que
demuestre
que
el
servidor


puede
planificar
sus
transmisiones
de
manera
que
el
l√≠mite
inferior
sea
alcanzado
realmente
.


Por
tanto
,
tomemos
este
l√≠mite
inferior
como
el
tiempo
de
distribuci√≥n
real
,
es
decir
,


(
2.1
)


Ap
a
r
t
i
r
 
d
e
 
l
a
 
E
c
u
a
c
i
√≥
n
 
2
.
1
,
 
s
e
 
v
e
 
q
u
e
 
p
a
r
a
 
N
lo
suficientemente
grande
,
el
tiempo
de
distri-


buci√≥n
en
una
arquitectura
cliente-servidor
est√°
dada
por
NF
/
us
.
Por
tanto
,
el
tiempo
de
dis-


tribuci√≥n
aumenta
linealmente
con
el
n√∫mero
de
pares
N.
As√≠
,
por
ejemplo
,
si
el
n√∫mero
de


pares
se
multiplica
por
mil
en
una
semana
,
pasando
de
mil
a
un
mill√≥n
,
el
tiempo
necesario


para
distribuir
el
archivo
a
todos
los
pares
se
ver√°
multiplicado
por
1.000
.


Hagamos
ahora
un
an√°lisis
similar
para
la
arquitectura
P2P
,
donde
cada
par
puede
ayu-


dar
al
servidor
a
distribuir
el
archivo
.
Cuando
un
par
recibe
datos
del
archivo
,
puede
utilizar


su
propia
capacidad
de
carga
para
redistribuir
los
datos
a
otros
pares
.
Calcular
el
tiempo
de


distribuci√≥n
para
la
arquitectura
P2P
es
algo
m√°s
complicado
que
para
la
arquitectura


cliente-servidor
,
ya
que
el
tiempo
de
distribuci√≥n
depende
de
c√≥mo
cada
par
implicado
dis-


tribuya
partes
del
archivo
a
los
dem√°s
pares
.
No
obstante
,
puede
obtenerse
una
expresi√≥n


simple
que
permite
calcular
el
tiempo
m√≠nimo
de
distribuci√≥n
[
Kumar
2006
]
.
Para
este
fin
,


debemos
tener
en
cuenta
las
siguientes
observaciones
:


‚Ä¢A
l
 
c
o
m
e
n
z
a
r
 
e
l
 
p
r
o
c
e
s
o
 
d
e
 
d
i
s
t
r
i
b
u
c
i
√≥
n
,
 
e
l
 
a
r
c
h
i
v
o
 
s
√≥
l
o
 
l
o
 
t
i
e
n
e
 
e
l
 
s
e
r
v
i
d
o
r
.
 
P
a
r
a
 
q
u
e
 
e
s
t
e


archivo
llegue
a
la
comunidad
de
pares
,
el
servidor
tiene
que
enviar
cada
bit
del
archivo


al
menos
una
vez
por
su
enlace
de
acceso
.
Por
tanto
,
el
tiempo
m√≠nimo
de
distribuci√≥n


es
,
como
m√≠nimo
,
F
/
us
.
(
A
diferencia
de
lo
que
ocurre
en
el
esquema
cliente-servidor
,
un


bit
enviado
por
el
servidor
puede
no
tener
que
ser
enviado
de
nuevo
por
el
mismo
,
ya
que


los
pares
pueden
distribuirlo
entre
ellos
.
)


NF


us


F


dm√≠n


Dcs
=
m√°x
{
      
,
         
}
.


NF


us


F


dm√≠n

 
{
      
,
         
}
.
 

M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
141‚Ä¢A
l
 
i
g
u
a
l
 
q
u
e
 
e
n
 
l
a
 
a
r
q
u
i
t
e
c
t
u
r
a
 
c
l
i
e
n
t
e
-
s
e
r
v
i
d
o
r
,
 
e
l
 
p
a
r
 
c
o
n
 
l
a
 
m
e
n
o
r
 
v
e
l
o
c
i
d
a
d
 
d
e
 
d
e
s
c
a
r
g
a


no
puede
obtener
los
F
bits
del
archivo
en
menos
de
F
/
dm√≠n
segundos
.
Por
tanto
,
el
tiempo


m√≠nimo
de
distribuci√≥n
es
al
menos
igual
a
F
/
dm√≠n
.


‚Ä¢P
o
r
 
√∫
l
t
i
m
o
,
 
o
b
s
e
r
v
e
 
q
u
e
 
l
a
 
c
a
p
a
c
i
d
a
d
 
t
o
t
a
l
 
d
e
 
c
a
r
g
a
 
d
e
l
 
s
i
s
t
e
m
a
 
c
o
m
o
 
u
n
 
t
o
d
o
 
e
s
 
i
g
u
a
l
 
a


la
velocidad
de
carga
del
servidor
m√°s
las
velocidades
de
carga
de
cada
par
,
es
decir
,
utotal


=
us
+
u1
+
‚Ä¶
+
uN.
El
sistema
tiene
que
suministrar
(
cargar
)
F
bits
en
cada
uno
de
los
N


peers
,
suministrando
en
total
NF
bits
.
Esto
no
se
puede
hacer
a
una
velocidad
mayor
que


utotal
;
por
tanto
,
el
tiempo
m√≠nimo
de
distribuci√≥n
es
tambi√©n
mayor
o
igual
que


NF/(us
+
u1
+
‚Ä¶
+
uN
)
.


Teniendo
en
cuenta
estas
tres
observaciones
,
obtenemos
el
tiempo
m√≠nimo
de
distribuci√≥n


para
la
arquitectura
P2P
,
DP2P.


(
2.2
)


La
Ecuaci√≥n
2.2
proporciona
un
l√≠mite
inferior
para
el
tiempo
m√≠nimo
de
distribuci√≥n
en
una


arquitectura
P2P.
Si
suponemos
que
cada
peer
puede
redistribuir
un
bit
tan
pronto
como
lo


recibe
,
entonces
existe
un
esquema
de
redistribuci√≥n
que
permite
alcanzar
este
l√≠mite
infe-


rior
[
Kumar
2006
]
.
(
Demostraremos
un
caso
especial
de
este
resultado
en
los
problemas
de


repaso
.
)
En
realidad
,
cuando
se
redistribuyen
fragmentos
del
archivo
en
lugar
de
bits
indivi-


duales
,
la
Ecuaci√≥n
2.2
sirve
como
una
buena
aproximaci√≥n
del
tiempo
m√≠nimo
de
distribu-


ci√≥n
real
.
Por
tanto
,
vamos
a
tomar
el
l√≠mite
inferior
dado
por
la
Ecuaci√≥n
2.2
como
el


tiempo
m√≠nimo
de
distribuci√≥n
real
,
es
decir
,


(
2.3
)


La
Figura
2.25
compara
el
tiempo
m√≠nimo
de
distribuci√≥n
de
las
arquitecturas
cliente-


servidor
y
P2P
,
suponiendo
que
todos
los
pares
tienen
la
misma
velocidad
de
carga
u.
En
la


figura
,
hemos
establecido
que
F
/
u
=
1
hora
,
us
=
10u
y
dm√≠n
 
us
.
Por
tanto
,
un
par
puede


transmitir
el
archivo
completo
en
una
hora
,
la
velocidad
de
transmisi√≥n
del
servidor
es
10


veces
la
velocidad
de
carga
del
par
y
(
para
simplificar
)
las
velocidades
de
descarga
de
los


pares
son
lo
suficientemente
grandes
como
para
no
tener
ning√∫n
efecto
.
A
partir
de
la
Figura


2.25
,
podemos
ver
que
para
la
arquitectura
cliente-servidor
el
tiempo
de
distribuci√≥n


aumenta
linealmente
y
sin
l√≠mite
a
medida
que
el
n√∫mero
de
pares
aumenta
.
Sin
embargo
,


en
una
arquitectura
P2P
,
el
tiempo
m√≠nimo
de
distribuci√≥n
no
s√≥lo
siempre
es
menor
que
el


tiempo
de
distribuci√≥n
en
la
arquitectura
cliente-servidor
;
tambi√©n
es
menor
que
una
hora


para
cualquier
n√∫mero
N
de
pares
.
Por
tanto
,
las
aplicaciones
que
emplean
arquitectura


P2P
pueden
auto-escalarse
.
Esta
escalabilidad
es
una
consecuencia
directa
de
que
los


pares
act√∫an
a
la
vez
como
redistribuidores
y
consumidores
de
bits
.


BitTorrent


BitTorrent
es
un
popular
protocolo
P2P
para
la
distribuci√≥n
de
archivos
[
BitTorrent


2009
]
.
En
la
jerga
de
BitTorrent
,
la
colecci√≥n
de
todos
los
pares
que
participan
en
la
distri-


F


us


F


dm√≠n


NF


us
+
‚àë
ui


N


i=1

 
DP2P
=
m√°x
{
      
,
         
,
                  
}


F


us


F


dm√≠n


NF


us
+
‚àë
ui


N


i=1

 
DP2P
‚â•
m√°x
{
      
,
         
,
                  
}


142
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
142Figura
2.25
‚Ä¢
Tiempo
de
distribuci√≥n
para
las
arquitecturas
P2P


y
cliente-servidor
.


buci√≥n
de
un
determinado
archivo
se
conoce
como
torrent
(
torrente
)
.
Los
peers
de
un


torrente
descargan
fragmentos
del
mismo
tama√±o
del
archivo
de
uno
a
otro
,
siendo
el


tama√±o
t√≠pico
de
un
fragmento
de
256
kBytes
.
Cuando
un
par
se
une
por
primera
vez
a
un


torrente
,
no
tiene
fragmentos
del
archivo
.
A
lo
largo
del
tiempo
va
acumulando
cada
vez


m√°s
fragmentos
.
A
la
vez
que
descarga
fragmentos
,
actualiza
fragmentos
en
otros
pares
.


Una
vez
que
un
par
ha
adquirido
el
archivo
completo
,
puede
(
ego√≠stamente
)
abandonar
el


torrente
,
o
(
de
forma
altruista
)
permanecer
en
el
mismo
y
continuar
suministrando
frag-


mentos
a
otros
pares
.
Adem√°s
,
cualquier
par
puede
abandonar
el
torrente
en
cualquier
ins-


tante
con
s√≥lo
un
subconjunto
de
fragmentos
,
y
volver
 
a
unirse
m√°s
tarde
.


Veamos
ahora
m√°s
de
cerca
c√≥mo
opera
BitTorrent
.
Puesto
que
BitTorrent
es
un
sistema


y
protocolo
bastante
complejo
,
s√≥lo
vamos
a
describir
sus
mecanismos
m√°s
importantes
,


vamos
a
dejar
al
margen
algunos
detalles
con
el
fin
de
poder
ver
claramente
c√≥mo
funciona
.


Cada
torrente
tiene
un
nodo
de
infraestructura
denominado
tracker
(
rastreador
)
.
Cuando
un


par
se
une
a
un
torrente
,
se
registra
mediante
el
tracker
y
,
peri√≥dicamente
,
informa
de
que


todav√≠a
se
encuentra
en
el
torrente
.
De
esta
manera
,
el
tracker
sigue
la
pista
a
los
pares
que


est√°n
participando
en
el
torrente
.
Un
determinado
torrente
puede
tener
en
un
instante
dado


un
n√∫mero
de
pares
participantes
tan
bajo
como
diez
o
tan
alto
como
mil
.


Como
se
muestra
en
la
Figura
2.26
,
cuando
un
nuevo
par
,
Alicia
,
se
une
al
torrente
,
el


tracker
selecciona
aleatoriamente
un
subconjunto
de
pares
(
digamos
por
ejemplo
50
,
con
el


fin
de
concretar
)
del
conjunto
de
peers
participantes
y
env√≠a
las
direcciones
IP
de
estos
50


peers
a
Alicia
.
Teniendo
en
su
poder
esta
lista
de
pares
,
Alicia
intenta
establecer
conexiones


TCP
concurrentes
con
todos
los
pares
incluidos
en
dicha
lista
.
Denominaremos
a
todos
los


pares
con
los
que
Alicia
consigue
establecer
con
√©xito
una
conexi√≥n
TCP
‚Äú
pares
vecinos
‚Äù
.


(
En
la
Figura
2.26
vemos
que
Alicia
s√≥lo
tiene
tres
pares
vecinos
.
Normalmente
,
podr√≠a
tener


muchos
m√°s
.
)
A
medida
que
pasa
el
tiempo
,
algunos
de
estos
pares
pueden
abandonar
la


conexi√≥n
y
otros
(
aparte
de
los
50
iniciales
)
pueden
intentar
establecer
conexiones
TCP
con


Alicia
.
Por
tanto
,
los
pares
vecinos
de
un
determinado
par
ir√°n
variando
con
el
tiempo
.


0


5
10
15
20
25
300


N


Tiempo
m√≠nimo
de
distribuci√≥n


35


0,5


1,5


2,5


1,0


3,0


2,0


3,5


Cliente-servidor


P2P


2.6
‚Ä¢
APLICACIONES
P2P
143


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
143Figura
2.26
‚Ä¢
Distribuci√≥n
de
archivos
con
BitTorrent
.


En
un
determinado
instante
de
tiempo
,
cada
peer
tendr√°
un
subconjunto
de
fragmentos


del
archivo
,
disponiendo
los
distintos
pares
de
subconjuntos
diferentes
.
Peri√≥dicamente
,
Ali-


cia
preguntar√°
a
cada
uno
de
sus
vecinos
(
a
trav√©s
de
las
conexiones
TCP
)
por
la
lista
de


fragmentos
de
la
que
disponen
.
Si
Alicia
tiene
L
vecinos
diferentes
obtendr√°
L
listas
de
frag-


mentos
.
Con
esta
informaci√≥n
,
Alicia
solicitar√°
(
a
trav√©s
de
las
conexiones
TCP
,
claro
est√°
)


los
fragmentos
que
ella
no
tiene
.


De
esta
manera
,
en
un
determinado
instante
,
Alicia
tendr√°
un
subconjunto
de
fragmen-


tos
y
sabr√°
qu√©
fragmentos
tienen
sus
vecinos
.
Con
esta
informaci√≥n
,
Alicia
tendr√°
que


tomar
dos
importantes
decisiones
.
En
primer
lugar
,
qu√©
fragmentos
debe
solicitar
primero
a


sus
vecinos
.
Y
en
segundo
lugar
,
a
cu√°les
de
sus
vecinos
debe
enviar
ella
los
fragmentos


solicitados
.
Para
decidir
qu√©
fragmentos
solicitar
,
Alicia
utiliza
una
t√©cnica
conocida
como


primero
el
menos
com√∫n
.
La
idea
es
determinar
,
de
entre
los
fragmentos
que
ella
no
tiene
,


los
fragmentos
menos
comunes
entre
sus
vecinos
(
es
decir
,
los
fragmentos
de
los
que
existe


el
menor
n√∫mero
de
copias
repetidas
repartidas
entre
los
vecinos
)
y
solicitar
entonces
en
pri-


mer
lugar
esos
fragmentos
menos
comunes
.
De
esta
manera
,
dichos
fragmentos
se
redistri-


buir√°n
m√°s
r√°pidamente
,
consiguiendo
que
el
n√∫mero
de
copias
de
cada
fragmento
sea


aproximadamente
igual
dentro
del
torrente
.


Para
determinar
a
qu√©
solicitudes
debe
ella
responder
,
BitTorrent
utiliza
un
algoritmo


de
intercambio
inteligente
.
La
idea
b√°sica
es
que
Alicia
d√©
prioridad
a
los
vecinos
que


actualmente
est√°n
suministrando
sus
datos
a
mayor
velocidad
.
Espec√≠ficamente
,
para
cada


uno
de
los
vecinos
,
Alicia
mide
de
forma
continua
la
velocidad
a
la
que
recibe
bits
y
deter-


mina
cu√°les
son
los
cuatro
pares
que
le
env√≠an
bits
a
mayor
velocidad
.
Entonces
,
ella
,
de


forma
rec√≠proca
,
env√≠a
fragmentos
a
esos
mismos
cuatro
pares
.
Cada
10
segundos
,
vuelve
a


Tracker


Comercio
de
fragmentos


Par


Obtener


la
lista
de


pares


Alicia


144
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
144calcular
las
velocidades
y
,
posiblemente
,
tendr√°
que
modificar
el
conjunto
formado
por
los


cuatro
pares
.
En
la
jerga
de
BitTorrent
,
se
dice
que
estos
cuatro
pares
est√°n
no
filtrados


(
unchoked
)
.
Adem√°s
,
y
lo
que
es
m√°s
importante
,
cada
30
segundos
Alicia
elige
de
forma


aleatoria
un
vecino
adicional
y
le
env√≠a
fragmentos
.
Supongamos
que
el
par
elegido
aleato-


riamente
es
el
de
Benito
.
En
la
jerga
de
BitTorrent
,
se
dice
que
Benito
est√°
no
filtrado
de


forma
optimista
.
Dado
que
Alicia
est√°
enviando
datos
a
Benito
,
ella
puede
convertirse
en


uno
de
los
cuatro
suministradores
principales
de
Benito
,
en
cuyo
caso
Benito
comenzar√≠a
a


enviar
datos
a
Alicia
.
Si
la
velocidad
a
la
que
Benito
env√≠a
datos
a
Alicia
es
lo
suficiente-


mente
alta
,
Benito
podr√≠a
entonces
,
a
su
vez
,
convertirse
en
uno
de
los
cuatro
suministrado-


res
principales
de
Alicia
.
En
otras
palabras
,
cada
30
segundos
Alicia
elegir√°
aleatoriamente


un
nuevo
socio
de
intercambio
e
iniciar√°
las
transacciones
con
√©l
.
Si
los
dos
pares
est√°n


satisfechos
con
el
intercambio
,
se
incluir√°n
en
sus
respectivas
listas
de
los
cuatro
principales


y
continuar√°n
realizando
intercambios
hasta
que
uno
de
los
pares
encuentre
un
socio
mejor
.


El
efecto
es
que
los
pares
capaces
de
suministrar
datos
a
velocidades
compatibles
tienden
a


emparejarse
.
La
selecci√≥n
aleatoria
de
vecinos
tambi√©n
permite
a
los
nuevos
pares
obtener


fragmentos
,
con
el
fin
de
tener
algo
que
intercambiar
.
Todos
los
dem√°s
pares
vecinos


excepto
estos
cinco
(
los
cuatro
pares
‚Äú
principales
‚Äù
m√°s
el
par
de
prueba
)
est√°n
‚Äú
filtrados
‚Äù
,


es
decir
,
no
reciben
fragmentos
de
Alicia
.
BitTorrent
dispone
de
una
serie
de
interesantes


mecanismos
que
no
vamos
a
ver
aqu√≠
,
entre
los
que
se
incluyen
la
gesti√≥n
de
piezas
(
mini-


fragmentos
)
,
el
procesamiento
en
cadena
,
la
selecci√≥n
aleatoria
del
primer
fragmento
,
el


modo
endgame
y
el
anti-snubbing
[
Cohen
2003
]
.


El
mecanismo
de
incentivos
para
intercambio
que
acabamos
de
describir
a
menudo
se


denomina
tit-for-tat
(
toma
y
daca
,
una
estrategia
de
la
teor√≠a
de
juegos
)
[
Cohen
2003
]
.
Se
ha


demostrado
que
este
esquema
de
incentivos
puede
soslayarse
maliciosamente
[
Liogkas


2006
;
Locher
2006
;
Piatek
2007
]
.
No
obstante
,
el
ecosistema
BitTorrent
ha
tenido
un
√©xito


b√°rbaro
,
con
millones
de
pares
simult√°neos
compartiendo
activamente
archivos
en
cientos


de
miles
de
torrentes
.
Si
BitTorrent
se
hubiera
dise√±ado
sin
la
estrategia
tit-for-tat
(
o
una


variante
)
,
y
aunque
todo
el
resto
de
caracter√≠sticas
fueran
las
mismas
,
es
posible
que
BitTo-


rrent
no
existiera
actualmente
,
ya
que
la
mayor
parte
de
los
usuarios
hubieran
pretendido


aprovecharse
de
los
dem√°s
[
Saroiu
2002
]
.


En
[
Guo
2005
;
Piatek
2007
]
se
proponen
interesantes
variantes
del
protocolo
BitTo-


rrent
.
Adem√°s
,
muchas
de
las
aplicaciones
P2P
para
flujos
multimedia
en
directo
,
como


PPLive
y
ppstream
,
est√°n
inspiradas
en
BitTorrent
[
Hei
2007
]
.


2.6.2
Tablas
hash
distribuidas
(
DHT
)


Un
componente
cr√≠tico
de
muchas
aplicaciones
P2P
y
otras
aplicaciones
distribuidas
es
un


√≠ndice
(
es
decir
,
una
base
de
datos
simple
)
que
soporte
operaciones
de
b√∫squeda
y
de
actua-


lizaci√≥n
.
Cuando
esta
base
de
datos
est√°
distribuida
,
los
pares
pueden
llevar
a
cabo
opera-


ciones
de
almacenamiento
del
contenido
en
cach√©
y
de
enrutamiento
complejo
de
consultas


entre
ellos
.
Dado
que
la
indexaci√≥n
de
la
informaci√≥n
y
la
realizaci√≥n
de
b√∫squedas
es
un


componente
cr√≠tico
en
estos
sistemas
,
vamos
a
estudiar
a
continuaci√≥n
una
t√©cnica
popular


de
indexaci√≥n
y
de
b√∫squeda
:
las
tablas
hash
distribuidas
(
DHT
,
Distributed
Hash
Table
)
.


Veamos
c√≥mo
construir
una
base
de
datos
distribuida
simple
sobre
un
gran
n√∫mero
(
del


orden
de
millones
)
de
pares
que
permita
la
indexaci√≥n
y
la
realizaci√≥n
de
consultas
simples
.


La
informaci√≥n
almacenada
en
esta
base
de
datos
estar√°
formada
por
parejas
(
clave
,
valor
)
.


Por
ejemplo
,
las
claves
podr√≠an
ser
los
n√∫meros
de
la
seguridad
social
y
los
valores
los
nom-


bres
correspondientes
de
las
personas
;
en
este
caso
,
una
pareja
(
clave
,
valor
)
de
ejemplo


2.6
‚Ä¢
APLICACIONES
P2P
145


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
145ser√≠a
(
156-45-7081
,
Johnny
Wu
)
.
Las
claves
tambi√©n
podr√≠an
ser
nombres
de
contenidos


(
por
ejemplo
,
nombres
de
pel√≠culas
,
albums
o
paquetes
software
)
y
los
valores
podr√≠an
ser


las
direcciones
IP
en
las
que
estuvieran
almacenados
dichos
contenidos
;
por
ejemplo
,
en
este


caso
una
pareja
clave-valor
ser√≠a
(
Led
Zeppelin
IV
,
203.17.123.38
)
.
Los
peers
consultar√°n


esta
base
de
datos
suministrando
la
clave
:
si
existen
parejas
(
clave
,
valor
)
en
la
base
de
datos


que
se
corresponden
con
esa
clave
,
entonces
la
base
de
datos
devuelve
los
pares
correspon-


dientes
al
peer
que
haya
realizado
la
consulta
.
As√≠
,
por
ejemplo
,
si
la
base
de
datos
almacena


n√∫meros
de
la
seguridad
social
y
los
nombres
de
las
personas
asociados
a
ellos
,
un
peer


puede
consultar
un
n√∫mero
concreto
de
la
seguridad
social
y
la
base
de
datos
le
devolver√°
el


nombre
de
la
persona
con
ese
n√∫mero
.
Los
pares
tambi√©n
podr√°n
insertar
parejas
(
clave
,


valor
)
en
la
base
de
datos
.


La
construcci√≥n
de
una
base
de
datos
as√≠
es
sencilla
mediante
una
arquitectura
cliente-


servidor
en
la
que
todas
las
parejas
(
clave
,
valor
)
se
encuentran
almacenados
en
un
servidor


central
.
Este
enfoque
centralizado
tambi√©n
se
empleaba
en
los
primeros
sistemas
P2P
,
como


Napster
.
Pero
el
problema
es
significativamente
m√°s
interesante
y
constituye
un
mayor
desa-


f√≠o
en
sistemas
distribuidos
formados
por
millones
de
pares
conectados
sin
una
autoridad


central
.
En
un
sistema
P2P
,
lo
que
se
desea
es
distribuir
las
parejas
(
clave
,
valor
)
a
todos
los


pares
,
de
manera
que
cada
par
s√≥lo
almacene
un
peque√±o
subconjunto
de
la
totalidad
de
las


parejas
(
clave
,
valor
)
.
Un
m√©todo
sencillo
para
construir
una
base
de
datos
P2P
consiste
en


(
1
)
diseminar
de
manera
aleatoria
las
parejas
(
clave
,
valor
)
a
lo
largo
de
los
pares
y
(
2
)
man-


tener
en
cada
par
una
lista
de
las
direcciones
IP
de
todos
los
pares
participantes
.
De
esta


manera
,
el
par
que
realiza
una
consulta
puede
enviarla
a
todos
los
dem√°s
pares
,
y
los
pares


que
contienen
las
parejas
(
clave
,
valor
)
que
se
corresponden
con
la
clave
consultada
pueden


responder
con
las
parejas
apropiadas
.
Por
supuesto
,
este
m√©todo
no
es
en
absoluto
escalable
,


ya
que
requerir√≠a
que
cada
par
siguiera
la
pista
a
todos
los
dem√°s
pares
(
posiblemente
millo-


nes
de
ellos
)
e
,
incluso
peor
,
tendr√≠a
que
enviar
cada
consulta
a
todos
los
pares
.


Ac
o
n
t
i
n
u
a
c
i
√≥
n
 
v
a
m
o
s
 
a
 
d
e
s
c
r
i
b
i
r
 
u
n
 
m
√©
t
o
d
o
 
e
l
e
g
a
n
t
e
 
p
a
r
a
 
d
i
s
e
√±
a
r
 
u
n
a
 
b
a
s
e
 
d
e
 
d
a
t
o
s


P2P.
Para
ello
,
en
primer
lugar
asignaremos
un
identificador
a
cada
par
,
siendo
cada
identi-


ficador
un
entero
comprendido
en
el
rango
[
0
,
2
n
 
1
]
para
un
cierto
n
fijo
.
Observe
que


cada
identificador
puede
expresarse
mediante
una
representaci√≥n
de
n
bits
.
Tambi√©n
es


necesario
que
cada
clave
sea
un
entero
perteneciente
al
mismo
rango
.
Si
ha
estado
atento
,


se
habr√°
dado
cuenta
de
que
las
claves
de
ejemplo
citadas
anteriormente
(
los
n√∫meros
de
la


seguridad
social
y
los
nombres
de
contenidos
multimedia
)
no
eran
n√∫meros
enteros
.
Para


generar
enteros
a
partir
de
esas
claves
,
vamos
a
utilizar
una
funci√≥n
hash
que
asocie
cada


clave
(
por
ejemplo
,
el
n√∫mero
de
la
seguridad
social
)
a
un
n√∫mero
entero
comprendido
en


el
rango
[
0
,
2
n
 
1
]
.
Una
funci√≥n
hash
es
una
funci√≥n
muchos
a
uno
para
la
que
dos
entra-


das
diferentes
pueden
tener
asociada
la
misma
salida
(
el
mismo
entero
)
,
pero
la
probabili-


dad
de
que
les
corresponda
esa
misma
salida
es
extremadamente
baja
.
(
Los
lectores
que
no


est√©n
familiarizados
con
las
funciones
hash
pueden
consultar
el
Cap√≠tulo
7
,
en
el
que
se


estudian
estas
funciones
en
detalle
.
)
Se
asume
que
la
funci√≥n
hash
est√°
p√∫blicamente
dis-


ponible
para
todos
los
peers
del
sistema
.
De
aqu√≠
en
adelante
,
cuando
hablemos
de
la


‚Äú
clave
‚Äù
,
estaremos
haciendo
referencia
a
la
funci√≥n
hash
de
la
clave
original
.
Por
ejemplo
,


si
la
clave
original
es
‚Äú
Led
Zeppelin
IV
‚Äù
,
la
clave
ser√°
el
n√∫mero
entero
igual
al
valor
hash


de
‚Äú
Led
Zeppelin
IV
‚Äù
.
Adem√°s
,
puesto
que
estamos
empleando
valores
hash
de
claves
,
en


lugar
de
las
propias
claves
,
de
ahora
en
adelante
nos
referiremos
a
la
base
de
datos
distri-


buida
como
a
una
tabla
hash
distribuida
(
DHT
)
.


Abordemos
el
problema
de
almacenar
las
parejas
(
clave
,
valor
)
en
la
tabla
DHT
.
La


cuesti√≥n
central
es
definir
una
regla
para
asignar
las
claves
a
los
pares
.
Puesto
que
cada
par


146
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
146tiene
asociado
un
identificador
entero
y
cada
clave
tambi√©n
es
un
entero
contenido
en
el


mismo
rango
,
ser√≠a
natural
asignar
cada
pareja
(
clave
,
valor
)
al
peer
cuyo
identificador
sea


el
m√°s
pr√≥ximo
a
la
clave
.
Para
implementar
este
esquema
,
tendremos
que
definir
qu√©
que-


remos
decir
con
‚Äú
el
m√°s
pr√≥ximo
‚Äù
,
y
para
ello
son
muchos
los
convenios
que
podemos


adoptar
.
Por
conveniencia
,
vamos
a
definir
el
peer
m√°s
pr√≥ximo
como
el
inmediato
sucesor


de
la
clave
.
Veamos
ahora
un
ejemplo
.
Supongamos
que
n
 
4
,
luego
en
este
caso
todos
los


identificadores
de
los
peers
y
las
claves
se
encuentran
en
el
rango
[
0
,
15
]
.
Supongamos
tam-


bi√©n
que
hay
ocho
peers
en
el
sistema
con
los
siguientes
identificadores
:
1
,
3
,
4
,
5
,
8
,
10
,
12


y
15
.
Por
√∫ltimo
,
supongamos
que
deseamos
almacenar
la
pareja
clave-valor
(
11
,
Johnny


Wu
)
en
uno
de
los
ocho
pares
;
pero
¬ø
en
qu√©
par
?
Aplicando
nuestro
convenio
del
m√°s
pr√≥-


ximo
,
dado
que
el
par
12
es
el
inmediato
sucesor
para
la
clave
11
,
almacenaremos
el
par
(
11
,


Johnny
Wu
)
en
el
par
12
.
Para
completar
nuestra
definici√≥n
del
m√°s
pr√≥ximo
,
establecemos


que
si
la
clave
es
exactamente
igual
a
uno
de
los
identificadores
de
par
,
almacenaremos
la


pareja
(
clave-valor
)
en
dicho
par
;
y
si
la
clave
es
mayor
que
todos
los
identificadores
de
par
,


aplicaremos
el
convenio
de
m√≥dulo
de
2n
,
almacenando
la
pareja
(
clave-valor
)
en
el
par
con


el
identificador
m√°s
peque√±o
.


Imaginemos
ahora
que
el
par
de
Alicia
desea
insertar
una
pareja
(
clave-valor
)
en
la
tabla


DHT
.
Conceptualmente
,
esto
es
sencillo
:
en
primer
lugar
,
ella
determina
el
par
cuyo
identi-


ficador
es
m√°s
pr√≥ximo
a
la
clave
;
a
continuaci√≥n
,
env√≠a
un
mensaje
a
dicho
par
,
d√°ndole


instrucciones
para
almacenar
la
pareja
(
clave
,
valor
)
.
Pero
,
¬ø
c√≥mo
determina
Alicia
el
par


cuyo
identificador
es
m√°s
pr√≥ximo
a
la
clave
?
Si
Alicia
tuviera
que
llevar
la
cuenta
de
todos


los
pares
del
sistema
(
sus
identificadores
y
las
correspondientes
direcciones
IP
)
,
podr√≠a


determinar
localmente
cu√°l
es
el
par
m√°s
pr√≥ximo
.
Pero
este
m√©todo
requiere
que
cada
par


tenga
controlados
a
todos
los
restantes
pares
de
la
tabla
DHT
,
lo
que
es
totalmente
impracti-


cable
en
un
sistema
a
gran
escala
formado
por
millones
de
pares
.


DHT
circular


Para
afrontar
este
problema
de
escala
,
consideremos
que
disponemos
los
pares
en
un
c√≠rculo
.


Con
esta
disposici√≥n
circular
,
cada
par
s√≥lo
tiene
que
controlar
a
su
inmediato
sucesor


(
m√≥dulo
2
n
)
.
En
la
Figura
2.27(a
)
se
muestra
un
ejemplo
de
esta
disposici√≥n
circular
.
En


este
caso
,
n
de
nuevo
es
igual
a
4
y
hay
exactamente
los
mismos
ocho
pares
que
en
el
ejem-


plo
anterior
.
Cada
par
s√≥lo
es
consciente
de
la
existencia
de
su
inmediato
sucesor
;
por
ejem-


plo
,
el
par
5
conoce
la
direcci√≥n
IP
y
el
identificador
del
par
8
,
pero
no
tiene
por
qu√©
saber


nada
acerca
de
los
restantes
pares
que
pueda
haber
en
la
DHT
.
Esta
disposici√≥n
circular
de


los
pares
es
un
caso
especial
de
red
solapada
.
En
una
red
solapada
,
los
pares
forman
una


red
l√≥gica
abstracta
que
reside
por
encima
de
la
red
de
computadoras
‚Äú
subyacente
‚Äù
formada


por
los
enlaces
f√≠sicos
,
los
routers
y
los
hosts
.
Los
enlaces
de
una
red
solapada
no
son
enla-


ces
f√≠sicos
,
simplemente
son
uniones
virtuales
entre
parejas
de
pares
.
En
la
red
solapada
de


la
Figura
2.27(a
)
,
hay
ocho
pares
y
ocho
enlaces
solapados
;
en
la
red
solapada
de
la
Figura


2.27(b
)
,
hay
ocho
peers
y
16
enlaces
solapados
.
Normalmente
,
un
enlace
solapado
utiliza


muchos
enlaces
f√≠sicos
y
routers
de
la
red
subyacente
.


Utilizando
la
red
solapada
circular
de
la
Figura
2.27(a
)
,
suponemos
que
el
par
3
desea


determinar
qu√©
par
de
la
tabla
DHT
es
responsable
de
la
clave
11
,
bien
para
insertar
o
con-


sultar
una
pareja
(
clave
,
valor
)
.
Utilizando
la
red
solapada
,
el
par
de
origen
(
el
par
3
)
crea


un
mensaje
que
dice
:
‚Äú
¬ø
Qui√©n
es
el
responsable
de
la
clave
11
?
‚Äù
y
env√≠a
este
mensaje
a
su


sucesor
,
el
par
4
.
Cuando
un
par
recibe
tal
mensaje
,
dado
que
conoce
el
identificador
de


su
sucesor
,
puede
determinar
si
√©l
es
el
responsable
de
esa
clave
en
cuesti√≥n
(
es
decir
,
el
m√°s
 

2.6
‚Ä¢
APLICACIONES
P2P
147


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
147Figura
2.27
‚Ä¢
(
a
)
Una
DHT
circular
.
El
peer
3
desea
determinar
qui√©n
es
el


responsable
de
la
clave
11
.
(
b
)
Una
DHT
circular
con
atajos
.


pr√≥ximo
)
.
Si
un
par
no
es
el
responsable
de
la
clave
,
simplemente
env√≠a
el
mensaje
a
su
suce-


sor
.
De
este
modo
,
por
ejemplo
,
cuando
el
par
4
recibe
el
mensaje
que
pregunta
por
la
clave


11
,
determina
que
no
es
el
responsable
de
la
misma
(
porque
su
sucesor
est√°
m√°s
pr√≥ximo
a
la


clave
)
,
por
lo
que
simplemente
pasa
el
mensaje
a
su
propio
sucesor
,
al
par
5
.
Este
proceso
con-


tin√∫a
hasta
que
el
mensaje
llega
al
par
12
,
el
cual
determina
que
√©l
es
el
par
m√°s
pr√≥ximo
a
la


clave
11
.
En
este
punto
,
el
par
12
puede
devolver
un
mensaje
al
origen
,
al
par
3
,
informando


de
que
es
el
responsable
de
la
clave
11
.


La
DHT
circular
proporciona
una
soluci√≥n
muy
elegante
para
reducir
la
cantidad
de


informaci√≥n
solapada
que
debe
gestionar
cada
par
.
En
resumen
,
cada
par
s√≥lo
es
consciente


de
la
existencia
de
otros
dos
pares
,
su
inmediato
sucesor
y
su
inmediato
predecesor
.
(
Por


defecto
,
el
par
sabe
de
la
existencia
de
su
predecesor
porque
√©ste
le
env√≠a
mensajes
.
)
.
Pero


esta
soluci√≥n
introduce
un
nuevo
problema
.
Aunque
cada
par
√∫nicamente
es
consciente
de


sus
dos
pares
vecinos
,
para
encontrar
al
nodo
responsable
de
una
clave
(
en
el
caso
peor
)
,


todos
los
N
nodos
de
la
DHT
tendr√°n
que
reenviar
un
mensaje
siguiendo
el
contorno
del
c√≠r-


culo
,
luego
,
como
media
,
se
enviar√°n
N/2
mensajes
.


Por
tanto
,
al
dise√±ar
una
DHT
hay
que
llegar
a
un
compromiso
entre
el
n√∫mero
de


vecinos
del
que
cada
par
puede
llevar
la
cuenta
y
el
n√∫mero
de
mensajes
que
la
DHT
nece-


sita
enviar
para
resolver
una
√∫nica
consulta
.
Por
un
lado
,
si
cada
par
lleva
la
cuenta
de
todos


los
dem√°s
pares
(
solapamiento
en
malla
)
,
entonces
s√≥lo
habr√°
que
enviar
un
mensaje
por


consulta
,
pero
cada
par
tiene
que
controlar
a
N
pares
.
Por
otro
lado
,
con
una
DHT
circular
,


cada
par
s√≥lo
es
consciente
de
la
existencia
de
dos
pares
,
pero
se
env√≠an
N/2
mensajes
como


media
por
cada
consulta
.
Afortunadamente
,
podemos
ajustar
nuestro
dise√±o
de
la
DHT
de


manera
que
el
n√∫mero
de
vecinos
por
par
,
as√≠
como
el
n√∫mero
de
mensajes
por
consulta
se


mantenga
en
un
tama√±o
aceptable
.
Una
posible
mejora
consistir√≠a
en
utilizar
la
red
sola-


pada
circular
como
base
y
a√±adir
‚Äú
atajos
‚Äù
,
de
modo
que
cada
par
no
s√≥lo
tenga
controlado


a
su
inmediato
sucesor
,
sino
tambi√©n
a
un
n√∫mero
relativamente
peque√±o
de
pares
de


‚Äú
atajo
‚Äù
dispersos
alrededor
del
c√≠rculo
.
En
la
Figura
2.27(b
)
se
muestra
un
ejemplo
de
una


DHT
circular
con
algunos
atajos
.
Estos
atajos
se
emplean
para
agilizar
el
enrutamiento
de


los
mensajes
de
consulta
.
Espec√≠ficamente
,
cuando
un
par
recibe
un
mensaje
para
consultar


1


3


¬ø
Qui√©n
es
el


responsable


de
la
clave
11
?


4


5


8


a.
b.


10


12


15


1


3


4


5


8


10


12


15


148
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
148una
clave
,
reenv√≠a
el
mensaje
al
vecino
(
al
sucesor
o
a
uno
de
los
vecinos
atajo
)
m√°s
pr√≥-


ximo
a
la
clave
.
As√≠
,
en
la
Figura
2.27(b
)
,
cuando
el
par
4
recibe
el
mensaje
preguntando


por
la
clave
11
,
determina
que
el
par
m√°s
pr√≥ximo
a
la
clave
(
entre
sus
vecinos
)
es
su


vecino
atajo
10
y
,
a
continuaci√≥n
,
reenv√≠a
el
mensaje
directamente
al
par
10
.
Evidente-


mente
,
los
atajos
pueden
reducir
de
forma
significativa
el
n√∫mero
de
mensajes
utilizado


para
procesar
una
consulta
.


En
consecuencia
,
ahora
la
pregunta
que
debemos
plantearnos
es
:
‚Äú
¬ø
Cu√°ntos
vecinos


atajo
debe
tener
cada
par
y
qu√©
pares
deber√≠an
ser
esos
vecinos
atajo
?
‚Äù
Los
investigadores


han
dedicado
mucho
esfuerzo
a
resolver
esta
cuesti√≥n
[
Stoica
2001
;
Rowstron
2001
;
Ratna-


samy
2001
;
Zhao
2004
;
Maymounkov
2002
;
Garces-Erce
2003
]
.
Se
ha
demostrado
que
una


DHT
se
puede
dise√±ar
de
modo
que
tanto
el
n√∫mero
de
vecinos
por
par
,
as√≠
como
el
n√∫mero


de
mensajes
por
consulta
,
sea
igual
a
O(log
N
)
,
donde
N
es
el
n√∫mero
de
pares
.
Este
tipo
de


dise√±o
proporciona
un
compromiso
satisfactorio
entre
las
soluciones
extremas
de
emplear


topolog√≠as
solapadas
de
red
en
malla
y
redes
circulares
.


Abandono
de
los
pares


En
los
sistemas
P2P
,
un
par
puede
entrar
o
salir
del
sistema
sin
avisar
.
As√≠
,
al
dise√±ar
una


DHT
tambi√©n
tenemos
que
preocuparnos
por
actualizar
la
red
solapada
DHT
teniendo
en


cuenta
el
fen√≥meno
del
abandono
de
los
pares
.
Con
el
fin
de
proporcionar
una
imagen
gene-


ral
de
c√≥mo
se
podr√≠a
conseguir
esto
,
consideremos
de
nuevo
la
DHT
circular
de
la
Figura


2.27(a
)
.
Para
gestionar
el
abandono
de
los
pares
,
tendremos
que
hacer
que
cada
par
tenga


controlados
a
su
primer
y
segundo
sucesores
(
es
decir
,
que
conozca
sus
direcciones
IP
)
;
por


ejemplo
,
ahora
el
par
4
tendr√°
que
tener
localizados
a
los
pares
5
y
8
.
Tambi√©n
necesitare-


mos
que
cada
par
verifique
peri√≥dicamente
que
sus
dos
sucesores
est√°n
activos
(
por
ejem-


plo
,
envi√°ndoles
peri√≥dicamente
mensajes
ping
y
solicit√°ndoles
respuestas
)
.
Consideremos


ahora
c√≥mo
se
actualiza
una
DHT
cuando
un
par
abandona
repentinamente
el
sistema
.
Por


ejemplo
,
supongamos
que
el
par
5
de
la
Figura
2.27(a
)
abandona
de
repente
la
red
.
En
este


caso
,
los
dos
pares
anteriores
(
4
y
3
)
detectan
que
el
5
ha
abandonado
porque
ya
no
responde


a
sus
mensajes
ping
.
Los
pares
4
y
3
tienen
entonces
que
actualizar
la
informaci√≥n
de
estado


que
indica
cu√°les
son
sucesores
.
Veamos
c√≥mo
el
par
4
actualiza
esta
informaci√≥n
de
estado
:


1
.
El
par
4
sustituye
a
su
primer
sucesor
(
par
5
)
por
su
segundo
sucesor
(
par
8)
.


2
.
A
continuaci√≥n
,
el
par
4
pide
a
su
nuevo
primer
sucesor
(
par
8)
el
identificador
y
la


direcci√≥n
IP
de
su
sucesor
inmediato
(
par
10
)
.
Despu√©s
,
el
par
4
hace
que
el
par
10
sea


su
segundo
sucesor
.


En
los
problemas
de
repaso
deber√°
determinar
c√≥mo
actualizar√≠a
el
par
3
su
informaci√≥n
de


enrutamiento
para
la
red
solapada
.


Ahora
que
hemos
visto
lo
que
ocurre
cuando
un
par
abandona
la
red
,
consideremos
lo


que
pasa
cuando
un
par
se
une
a
la
DHT
.
Supongamos
que
un
par
cuyo
identificador
es
13


desea
unirse
a
la
DHT
y
que
en
el
momento
de
hacerlo
s√≥lo
sabe
de
la
existencia
del
par
1


en
esa
DHT
.
El
par
13
deber√≠a
enviar
en
primer
lugar
un
mensaje
al
par
1
,
preguntando
cu√°-


les
ser√°n
su
predecesor
y
su
sucesor
.
Este
mensaje
ser√°
reenviado
a
trav√©s
de
la
DHT
hasta


llegar
al
par
12
,
quien
se
dar√°
cuenta
de
que
es
el
predecesor
de
13
y
de
que
su
sucesor


actual
,
el
par
15
,
pasar√°
a
ser
el
sucesor
de
13
.
A
continuaci√≥n
,
el
par
12
env√≠a
esta
informa-


ci√≥n
acerca
del
predecesor
y
del
sucesor
al
par
13
,
el
cual
ahora
puede
unirse
a
la
DHT


haciendo
al
par
15
su
sucesor
y
notificando
al
par
12
que
debe
modificar
su
sucesor
inme-


diato
a
13
.


2.6
‚Ä¢
APLICACIONES
P2P
149


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
149Las
DHT
se
utilizan
ampliamente
en
la
pr√°ctica
.
Por
ejemplo
,
BitTorrent
utiliza
la


DHT
Kademlia
para
crear
un
tracker
distribuido
.
En
BitTorrent
,
la
clave
es
el
identificador


del
torrente
y
el
valor
son
las
direcciones
IP
de
todos
los
pares
que
est√°n
participando


actualmente
en
el
torrente
[
Falkner
2007
,
Neglia
2007
]
.
De
este
modo
,
al
consultar
la
DHT


con
un
identificador
de
torrente
,
un
par
BitTorrent
reci√©n
llegado
puede
determinar
cu√°l
es


el
par
responsable
del
identificador
(
es
decir
,
qui√©n
se
encarga
de
llevar
la
cuenta
de
los


pares
existentes
en
el
torrente
)
.
Una
vez
que
ha
localizado
dicho
par
,
el
par
reci√©n
llegado


puede
consultarle
para
obtener
la
lista
de
los
dem√°s
pares
del
torrente
.
Las
DHT
se
emplean


ampliamente
en
el
sistema
de
compartici√≥n
de
archivos
eMule
para
la
localizaci√≥n
de
con-


tenido
en
los
pares
[
Liang
2006
]
.


2.6.3
Caso
de
estudio
:


telefon√≠a
Internet
P2P
con
Skype


Skype
es
una
aplicaci√≥n
P2P
inmensamente
popular
,
que
suele
tener
del
orden
de
siete
u


ocho
millones
de
usuarios
conectados
simult√°neamente
.
Adem√°s
de
proporcionar
un
servi-


cio
de
telefon√≠a
Internet
PC
a
PC
,
Skype
ofrece
servicios
de
telefon√≠a
de
PC
a
tel√©fono
,
de


tel√©fono
a
PC
y
de
videoconferencia
PC
a
PC
.
Fundada
por
los
mismos
emprendedores
que


crearon
FastTrack
y
Kazaa
,
Skype
fue
adquirida
por
eBay
en
2005
por
2.600
millones
de


d√≥lares
.


Skype
utiliza
t√©cnicas
P2P
en
una
serie
de
formas
bastante
innovadoras
,
que
ilustran
a


la
perfecci√≥n
c√≥mo
puede
utilizarse
P2P
en
aplicaciones
que
van
m√°s
all√°
de
la
distribuci√≥n


de
contenido
y
la
compartici√≥n
de
archivos
.
Al
igual
que
sucede
con
la
mensajer√≠a
instant√°-


nea
,
la
telefon√≠a
Internet
PC
a
PC
es
inherentemente
P2P
,
puesto
que
la
base
de
la
aplicaci√≥n


est√°
en
que
hay
parejas
de
usuarios
(
es
decir
,
peers
)
comunic√°ndose
entre
s√≠
en
tiempo
real
.


Pero
Skype
tambi√©n
emplea
t√©cnicas
P2P
para
otras
dos
importantes
funciones
:
la
ubicaci√≥n


de
los
usuarios
y
el
NAT
transversal
.


No
s√≥lo
son
propietarios
los
protocolos
de
Skype
sino
que
,
adem√°s
,
todas
las
transmi-


siones
de
paquetes
de
Skype
(
paquetes
de
voz
y
de
control
)
est√°n
cifradas
.
A
pesar
de
ello
,
a


partir
de
la
informaci√≥n
contenida
en
el
sitio
web
de
Skype
y
de
una
serie
de
estudios
t√©cni-


cos
,
los
investigadores
han
logrado
determinar
c√≥mo
funciona
Skype
en
t√©rminos
generales


[
Baset
2006
;
Guha
2006
;
Chen
2006
;
Suh
2006
;
Ren
2006
]
.
Al
igual
que
sucede
en
Fast-


Track
,
los
nodos
de
Skype
est√°n
organizados
en
una
red
jer√°rquica
superpuesta
en
la
que


cada
par
se
clasifica
como
super
par
o
como
par
normal
.
Skype
incluye
un
√≠ndice
que
asigna


los
nombres
de
usuario
de
Skype
a
las
direcciones
IP
actuales
(
junto
con
sus
n√∫meros
de


puertos
)
.
Este
√≠ndice
est√°
distribuido
sobre
los
super
pares
.
Cuando
Alicia
quiere
llamar
a


Benito
,
su
cliente
Skype
busca
en
el
√≠ndice
distribuido
para
determinar
la
direcci√≥n
IP
actual


de
Benito
.
Puesto
que
el
protocolo
de
Skype
es
propietario
,
no
est√°
claro
actualmente
c√≥mo


est√°n
organizadas
las
asignaciones
de
√≠ndice
entre
los
super
pares
,
aunque
es
bastante
posi-


ble
que
se
emplee
alg√∫n
tipo
de
organizaci√≥n
DHT
.


Tambi√©n
se
emplean
t√©cnicas
P2P
en
los
retransmisores
(
relays
)
Skype
,
que
se
usan


para
establecer
llamadas
entre
hosts
situados
en
redes
dom√©sticas
.
Muchas
configuraciones


de
redes
dom√©sticas
proporcionan
acceso
a
Internet
a
trav√©s
de
un
router
(
normalmente
de


un
router
inal√°mbrico
)
.
Estos
routers
son
,
en
realidad
,
algo
m√°s
que
simples
routers
,
y
sue-


len
incluir
un
mecanismo
de
Traducci√≥n
de
direcciones
de
red
(
NAT
,
Network
Address


Translator
)
.
Estudiaremos
los
mecanismos
NAT
en
el
Cap√≠tulo
4
.
Por
ahora
,
lo
√∫nico
que


necesitamos
saber
es
que
un
mecanismo
NAT
impide
que
un
host
situado
fuera
de
la
red


150
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
150dom√©stica
inicie
una
conexi√≥n
con
un
host
situado
dentro
de
esa
red
.
Si
ambos
interlocuto-


res
Skype
tienen
activados
mecanismos
NAT
,
entonces
se
producir√°
un
problema
:
ninguno


de
los
dos
podr√°
aceptar
una
llamada
iniciada
por
el
otro
,
lo
que
aparentemente
hace
que
las


llamadas
sean
imposibles
.
La
utilizaci√≥n
inteligente
de
los
super
pares
y
de
los
retransmiso-


res
permite
resolver
de
forma
elegante
este
problema
.
Suponga
que
en
el
momento
de
ini-


ciar
Alicia
la
sesi√≥n
,
se
le
asigna
un
super
par
sin
mecanismo
NAT
.
Alicia
podr√°
iniciar
una


sesi√≥n
con
su
super
par
,
ya
que
su
NAT
s√≥lo
proh√≠be
las
sesiones
iniciadas
fuera
de
su
red


dom√©stica
.
Esto
permite
a
Alicia
y
a
su
super
par
intercambiar
mensajes
de
control
en
esa


sesi√≥n
.
Lo
mismo
sucede
para
Benito
cuando
inicia
su
sesi√≥n
.
Ahora
,
cuando
Alicia
quiere


llamar
a
Benito
informa
a
su
super
par
,
que
a
su
vez
informa
al
super
par
de
Benito
,
que
por


su
parte
informa
a
Benito
acerca
de
la
llamada
entrante
de
Alicia
.
Si
Benito
acepta
la
lla-


mada
,
los
dos
super
pares
seleccionan
un
tercer
super
par
sin
NAT
(
el
nodo
retransmisor
)


cuyo
trabajo
consistir√°
en
retransmitir
los
datos
entre
Alicia
y
Benito
.
Los
super
pares
de


Benito
y
Alicia
dan
entonces
instrucciones
a
Benito
y
Alicia
,
respectivamente
,
para
iniciar


una
sesi√≥n
con
el
retransmisor
.
Alicia
enviar√°
sus
paquetes
de
voz
al
retransmisor
a
trav√©s


de
la
conexi√≥n
Alicia-retransmisor
(
que
ha
sido
iniciada
por
Alicia
)
y
el
retransmisor
reen-


viar√°
esos
paquetes
a
trav√©s
de
la
conexi√≥n
retransmisor-Benito
(
que
ha
sido
iniciada
por


Benito
)
;
los
paquetes
enviados
por
Benito
a
Alicia
fluyen
a
trav√©s
de
las
dos
mismas
cone-


xiones
de
retransmisi√≥n
,
pero
en
orden
inverso
.
¬°
Problema
resuelto
!
Benito
y
Alicia
dispon-


dr√°n
de
una
conexi√≥n
terminal
a
terminal
bajo
demanda
aun
cuando
ninguno
de
los
dos


pueda
aceptar
una
sesi√≥n
que
tenga
su
origen
fuera
de
su
red
LAN
.
La
utilizaci√≥n
de
retrans-


misores
ilustra
el
dise√±o
cada
vez
m√°s
sofisticado
de
los
sistemas
P2P
,
en
los
que
los
pares


llevan
a
cabo
servicios
b√°sicos
del
sistema
para
otros
(
dos
ejemplos
ser√≠an
el
servicio
de


√≠ndice
y
la
retransmisi√≥n
)
,
al
mismo
tiempo
que
utilizan
el
servicio
de
usuario
final
(
por


ejemplo
,
la
descarga
de
archivos
o
la
telefon√≠a
IP
)
que
el
sistema
P2P
proporciona
.


Skype
es
una
aplicaci√≥n
Internet
con
un
extraordinario
√©xito
,
siendo
utilizada
por
dece-


nas
de
millones
de
usuarios
.
La
enormemente
r√°pida
adopci√≥n
global
de
Skype
,
al
igual
que


la
de
la
compartici√≥n
de
archivos
P2P
,
la
Web
y
la
mensajer√≠a
instant√°nea
anteriormente
,
es


una
prueba
palpable
de
la
sabidur√≠a
inherente
al
dise√±o
arquitect√≥nico
global
de
Internet
,
un


dise√±o
que
no
pod√≠a
haber
previsto
el
enorme
y
cada
vez
m√°s
amplio
conjunto
de
aplicacio-


nes
Internet
que
se
desarrollar√≠an
a
lo
largo
de
los
30
a√±os
siguientes
.
Los
servicios
de
red


ofrecidos
a
las
aplicaciones
Internet
[
transporte
de
datagramas
sin
conexi√≥n
(
UDP
)
,
transfe-


rencia
fiable
de
datagramas
orientada
a
conexi√≥n
(
TCP
)
,
la
interfaz
de
sockets
,
el
direccio-


namiento
y
el
sistema
de
nombres
(
DNS
)
,
entre
otros
]
,
han
demostrado
ser
capaces
de


permitir
el
desarrollo
de
miles
de
aplicaciones
.
Puesto
que
todas
estas
aplicaciones
se
han


construido
sobre
las
cuatro
capas
inferiores
de
la
pila
de
protocolos
de
Internet
,
s√≥lo
necesi-


tan
que
se
desarrollen
nuevos
programas
cliente-servidor
y
peer-to-peer
para
emplearlos
en


los
sistemas
de
usuario
final
.
Esto
,
a
su
vez
,
ha
permitido
que
estas
aplicaciones
se
implan-


ten
y
adopten
tambi√©n
de
una
forma
extraordinariamente
r√°pida
.


2.7
Programaci√≥n
de
sockets
con
TCP


Ahora
que
hemos
examinado
una
serie
de
importantes
aplicaciones
de
red
,
vamos
a
ver


c√≥mo
se
escriben
en
la
pr√°ctica
los
programas
de
aplicaciones
de
redes
.
En
esta
secci√≥n
,


escribiremos
programas
de
aplicaci√≥n
que
utilizan
TCP
,
mientras
que
en
la
secci√≥n
siguiente


veremos
c√≥mo
se
escriben
los
programas
que
usan
UDP
.


2.7
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
TCP
151


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
151Recuerde
de
la
Secci√≥n
2.1
que
muchas
aplicaciones
de
red
est√°n
compuestas
por
una


pareja
de
programas
(
un
programa
cliente
y
un
programa
servidor
)
que
residen
en
dos
siste-


mas
terminales
distintos
.
Cuando
se
ejecutan
estos
dos
programas
,
se
crean
un
proceso


cliente
y
un
proceso
servidor
,
y
estos
dos
procesos
se
comunican
entre
s√≠
leyendo
y
escri-


biendo
en
sockets
.
Cuando
se
crea
una
aplicaci√≥n
de
red
,
la
tarea
principal
del
desarrollador


es
escribir
el
c√≥digo
para
los
programas
cliente
y
servidor
.


Existen
dos
tipos
de
aplicaciones
de
red
.
Uno
de
ellos
es
una
implementaci√≥n
de
un


est√°ndar
de
protocolo
definido
en
,
por
ejemplo
,
un
RFC
.
Para
este
tipo
de
implementacio-


nes
,
los
programas
cliente
y
servidor
deben
adaptarse
a
las
reglas
dictadas
por
ese
RFC
.
Por


ejemplo
,
el
programa
cliente
podr√≠a
ser
una
implementaci√≥n
del
lado
del
cliente
del
proto-


colo
FTP
,
descrito
en
la
Secci√≥n
2.3
y
definido
expl√≠citamente
en
el
documento
RFC
959
;
de


forma
similar
,
el
programa
servidor
podr√≠a
ser
una
implementaci√≥n
del
protocolo
de
servi-


dor
FTP
,
que
tambi√©n
est√°
definido
expl√≠citamente
en
el
documento
RFC
959
.
Si
un
desarro-


llador
escribe
c√≥digo
para
el
programa
cliente
y
otro
desarrollador
independiente
escribe


c√≥digo
para
el
programa
servidor
y
ambos
desarrolladores
siguen
cuidadosamente
las
reglas


marcadas
en
el
RFC
,
entonces
los
dos
programas
ser√°n
capaces
de
interoperar
.
Ciertamente
,


muchas
de
las
aplicaciones
de
red
actuales
implican
la
comunicaci√≥n
entre
programas


cliente
y
servidor
que
han
sido
creados
por
desarrolladores
independientes
(
por
ejemplo
,
un


navegador
Firefox
comunic√°ndose
con
un
servidor
web
Apache
,
o
un
cliente
FTP
de
un
PC


cargando
un
archivo
en
un
servidor
FTP
Linux
)
.
Cuando
un
programa
cliente
o
un
programa


servidor
implementa
un
protocolo
definido
en
un
RFC
,
debe
emplear
el
n√∫mero
de
puerto


asociado
con
el
protocolo
.
(
Los
n√∫meros
de
puerto
se
han
explicado
brevemente
en
la
Sec-


ci√≥n
2.1
y
se
tratan
m√°s
detalladamente
en
el
Cap√≠tulo
3
.
)


El
otro
tipo
de
aplicaci√≥n
de
red
son
las
aplicaciones
propietarias
.
En
este
caso
,
el
pro-


tocolo
de
la
capa
de
aplicaci√≥n
utilizado
por
los
programas
cliente
y
servidor
no
tiene
que


cumplir
necesariamente
ninguna
recomendaci√≥n
RFC
existente
.
Un
√∫nico
desarrollador
(
o


un
equipo
de
desarrollo
)
crea
tanto
el
programa
cliente
como
el
programa
servidor
,
y
ese


desarrollador
tiene
el
control
completo
sobre
aquello
que
se
incluye
en
el
c√≥digo
.
Pero
como


el
c√≥digo
no
implementa
ning√∫n
protocolo
de
dominio
p√∫blico
,
otros
desarrolladores
inde-


pendientes
no
podr√°n
desarrollar
c√≥digo
que
interopere
con
esa
aplicaci√≥n
.
A
la
hora
de
crear


una
aplicaci√≥n
propietaria
,
el
desarrollador
debe
tener
cuidado
de
no
utilizar
ninguno
de
los


n√∫meros
de
puerto
bien
conocidos
definidos
en
los
documentos
RFC
.


En
esta
secci√≥n
y
en
la
siguiente
vamos
a
examinar
los
problemas
fundamentales
del


desarrollo
de
aplicaciones
propietarias
cliente-servidor
.
Durante
la
fase
de
desarrollo
,
una
de


las
primeras
decisiones
que
el
desarrollador
debe
tomar
es
si
la
aplicaci√≥n
se
ejecutar√°
sobre


TCP
o
sobre
UDP
.
Recuerde
que
TCP
est√°
orientado
a
la
conexi√≥n
y
proporciona
un
canal


fiable
de
flujo
de
bytes
a
trav√©s
del
cual
se
transmiten
los
datos
entre
los
dos
sistemas
termi-


nales
.
Por
su
parte
,
UDP
es
un
protocolo
sin
conexi√≥n
,
que
env√≠a
paquetes
de
datos
indepen-


dientes
de
un
sistema
terminal
a
otro
,
sin
ning√∫n
tipo
de
garant√≠a
acerca
de
la
entrega
.


En
esta
secci√≥n
vamos
a
desarrollar
una
aplicaci√≥n
cliente
simple
que
se
ejecute
sobre


TCP
.
En
la
siguiente
secci√≥n
desarrollaremos
otra
aplicaci√≥n
cliente
simple
que
se
ejecute


sobre
UDP
.
Presentamos
estas
aplicaciones
TCP
y
UDP
en
Java
.
Podr√≠amos
haber
escrito
el


c√≥digo
en
C
o
C++
,
pero
hemos
optado
por
Java
principalmente
porque
en
este
lenguaje
las


aplicaciones
se
escriben
de
forma
m√°s
clara
y
n√≠tida
.
Con
Java
se
utilizan
menos
l√≠neas
de


c√≥digo
y
cada
l√≠nea
puede
explicarse
a
un
programador
inexperto
sin
demasiada
dificultad
.


Pero
no
tiene
por
qu√©
asustarse
si
no
est√°
muy
familiarizado
con
Java
.
Si
tiene
experiencia


de
programaci√≥n
en
cualquier
otro
lenguaje
,
deber√≠a
poder
seguir
el
c√≥digo
f√°cilmente
.


152
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
152Figura
2.28
‚Ä¢
Procesos
comunic√°ndose
a
trav√©s
de
sockets
TCP
.


Para
los
lectores
que
est√©n
interesados
en
la
programaci√≥n
cliente-servidor
en
C
,
hay


disponibles
varias
buenas
referencias
[
Donahoo
2001
;
Stevens
1997
;
Frost
1994
;
Kurose


1996
]
.


2.7.1
Programaci√≥n
de
sockets
con
TCP


Recuerde
de
la
Secci√≥n
2.1
que
los
procesos
que
se
ejecutan
en
m√°quinas
diferentes
se


comunican
entre
s√≠
enviando
mensajes
a
trav√©s
de
sockets
.
Dijimos
que
cada
proceso
era


an√°logo
a
una
vivienda
y
que
el
socket
del
proceso
era
an√°logo
a
una
puerta
.
Como
se
mues-


tra
en
la
Figura
2.28
,
el
socket
es
la
puerta
entre
el
proceso
de
aplicaci√≥n
y
TCP
.
El
desarro-


llador
de
la
aplicaci√≥n
dispone
de
control
sobre
todo
lo
que
est√°
situado
en
el
lado
de
la
capa


de
aplicaci√≥n
del
socket
;
sin
embargo
,
el
control
que
tiene
sobre
el
lado
de
la
capa
de
trans-


porte
es
muy
peque√±o
(
como
mucho
,
el
desarrollador
de
la
aplicaci√≥n
tiene
la
posibilidad
de


fijar
unos
pocos
par√°metros
de
TCP
,
como
el
tama√±o
m√°ximo
de
buffer
y
el
tama√±o
m√°ximo


de
segmento
)
.


Ahora
,
examinemos
m√°s
en
detalle
la
interacci√≥n
entre
los
programas
cliente
y
servi-


dor
.
Al
cliente
le
corresponde
iniciar
el
contacto
con
el
servidor
.
Para
que
√©ste
puede
reac-


cionar
al
contacto
inicial
del
cliente
,
tendr√°
que
estar
preparado
,
lo
que
implica
dos
cosas
.


En
primer
lugar
,
el
programa
servidor
no
puede
estar
durmiendo
(
es
decir
,
tiene
que
estar


ejecut√°ndose
como
proceso
antes
de
que
el
cliente
trate
de
iniciar
el
contacto
)
;
en
segundo


lugar
,
el
programa
servidor
debe
disponer
de
alg√∫n
tipo
de
puerta
(
o
,
m√°s
precisamente
,
un


socket
)
que
acepte
alg√∫n
contacto
inicial
procedente
de
un
proceso
cliente
que
se
est√©
ejecu-


tando
en
un
host
arbitrario
.
Utilizando
nuestra
analog√≠a
de
la
vivienda
/
puerta
para
un
pro-


ceso
/
socket
,
en
ocasiones
nos
referiremos
a
este
contacto
inicial
del
cliente
diciendo
que
es


equivalente
a
‚Äú
llamar
a
la
puerta
de
entrada
‚Äù
.


Con
el
proceso
servidor
ejecut√°ndose
,
el
proceso
cliente
puede
iniciar
una
conexi√≥n


TCP
con
el
servidor
.
Esto
se
hace
en
el
programa
cliente
creando
un
socket
.
Cuando
el


cliente
crea
su
socket
,
especifica
la
direcci√≥n
del
proceso
servidor
,
es
decir
,
la
direcci√≥n
IP


2.7
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
TCP
153


Proceso


Host
o


servidor


Host
o


servidor


Controlado


por
el


desarrollador


de
aplicaciones


Controlado


por
el


desarrollador


de
aplicaciones


Proceso


TCP
con


buffers
,


variables
Internet


Controlado


por
el
sistema


operativo


Controlado


por
el
sistema


operativo


TCP
con


buffers
,


variables


Socket
Socket


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
153del
host
servidor
y
el
n√∫mero
de
puerto
del
proceso
servidor
.
Una
vez
creado
el
socket
en
el


programa
cliente
,
el
protocolo
TCP
del
cliente
inicia
un
proceso
de
acuerdo
en
tres
fases
y


establece
una
conexi√≥n
con
el
servidor
.
El
proceso
de
acuerdo
en
tres
fases
,
que
tiene
lugar


en
la
capa
de
transporte
,
es
completamente
transparente
para
los
programas
cliente
y
servi-


dor
.


Durante
el
proceso
de
acuerdo
en
tres
fases
,
el
proceso
cliente
llama
a
la
puerta
de


entrada
del
proceso
servidor
.
Cuando
el
servidor
‚Äú
escucha
‚Äù
la
llamada
,
crea
una
nueva


puerta
(
o
de
forma
m√°s
precisa
,
un
nuevo
socket
)
que
estar√°
dedicado
a
ese
cliente
concreto
.


En
el
ejemplo
que
sigue
,
nuestra
puerta
de
entrada
es
un
objeto
ServerSocket
que
deno-


minamos
socketAcogida
.
Cuando
un
cliente
llama
a
esta
puerta
,
el
programa
invoca
el


m√©todo
accept
(
)
de
socketAcogida
,
que
crea
una
nueva
puerta
para
el
cliente
.
Al
final


de
la
fase
de
negociaci√≥n
,
existir√°
una
conexi√≥n
TCP
entre
el
socket
del
cliente
y
el
nuevo


socket
del
servidor
.
En
lo
sucesivo
,
nos
referiremos
al
nuevo
socket
dedicado
del
servidor


con
el
nombre
de
socket
de
conexi√≥n
del
servidor
.


Desde
la
perspectiva
de
la
aplicaci√≥n
,
la
conexi√≥n
TCP
es
un
conducto
virtual
directo


entre
el
socket
del
cliente
y
el
socket
de
conexi√≥n
del
servidor
.
El
proceso
cliente
puede


enviar
bytes
arbitrarios
a
trav√©s
de
su
socket
,
y
TCP
garantiza
que
el
proceso
servidor
reci-


bir√°
(
a
trav√©s
del
socket
de
conexi√≥n
)
cada
byte
en
el
orden
en
que
ha
sido
enviado
.
Por


tanto
,
TCP
proporciona
un
servicio
fiable
de
flujo
de
bytes
entre
los
procesos
cliente
y
ser-


vidor
.
Adem√°s
,
al
igual
que
las
personas
pueden
entrar
y
salir
a
trav√©s
de
una
misma
puerta
,


el
proceso
cliente
no
s√≥lo
env√≠a
bytes
a
trav√©s
de
su
socket
,
sino
que
tambi√©n
puede
recibir-


los
;
de
forma
similar
,
el
proceso
servidor
no
s√≥lo
puede
recibir
,
sino
tambi√©n
enviar
bytes
a


trav√©s
de
su
socket
de
conexi√≥n
.
Esto
se
ilustra
en
la
Figura
2.29
.
Puesto
que
los
sockets


desempe√±an
un
papel
fundamental
en
las
aplicaciones
cliente-servidor
,
el
desarrollo
de
este


tipo
de
aplicaciones
tambi√©n
se
suele
denominar
programaci√≥n
de
sockets
.


Antes
de
proporcionar
un
ejemplo
de
aplicaci√≥n
cliente-servidor
,
resulta
√∫til
explicar
el


concepto
de
flujo
.
Un
flujo
es
una
secuencia
de
caracteres
que
entran
o
salen
de
un
proceso
.


Cada
flujo
puede
ser
un
flujo
de
entrada
o
un
flujo
de
salida
del
proceso
.
Si
se
trata
de
un


flujo
de
entrada
,
entonces
estar√°
asociado
a
alg√∫n
tipo
de
fuente
de
entrada
para
el
proceso
,


como
por
ejemplo
la
entrada
est√°ndar
(
el
teclado
)
o
un
socket
a
trav√©s
del
cual
fluyan
datos


procedentes
de
Internet
.
Si
se
trata
de
un
flujo
de
salida
,
entonces
estar√°
asociado
con
alg√∫n


dispositivo
de
salida
del
proceso
,
como
la
salida
est√°ndar
(
el
monitor
)
o
un
socket
a
trav√©s


del
cual
fluyan
los
datos
hacia
Internet
.


2.7.2
Ejemplo
de
aplicaci√≥n
cliente-servidor
en
Java


Vamos
a
utilizar
la
siguiente
aplicaci√≥n
cliente-servidor
simple
para
demostrar
c√≥mo
pro-


gramar
un
socket
tanto
para
TCP
como
para
UDP
:


1
.
Un
cliente
lee
una
l√≠nea
de
su
entrada
est√°ndar
(
teclado
)
y
la
env√≠a
a
trav√©s
de
su
soc-


ket
al
servidor
.


2
.
El
servidor
lee
una
l√≠nea
de
su
socket
de
conexi√≥n
.


3
.
El
servidor
pasa
la
l√≠nea
a
caracteres
en
may√∫scula
.


4
.
El
servidor
env√≠a
la
l√≠nea
modificada
a
trav√©s
de
su
socket
de
conexi√≥n
al
cliente
.


5
.
El
cliente
lee
la
l√≠nea
modificada
de
su
socket
y
la
muestra
en
su
salida
est√°ndar


(
monitor
)
.


154
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
154Figura
2.29
‚Ä¢
Socket
de
cliente
,
socket
de
acogida
y
socket
de
conexi√≥n
.


La
Figura
2.30
ilustra
la
actividad
relativa
a
los
sockets
del
cliente
y
del
servidor
.


A
continuaci√≥n
proporcionamos
la
pareja
de
programas
cliente-servidor
para
una
imple-


mentaci√≥n
TCP
de
la
aplicaci√≥n
.
Realizaremos
un
an√°lisis
detallado
l√≠nea
a
l√≠nea
de
cada
uno


de
los
programas
.
El
nombre
del
programa
cliente
es
TCPCliente.java
y
el
nombre
del


programa
servidor
es
TCPServidor.java
.
Con
el
fin
de
poner
el
√©nfasis
en
las
cuestiones


fundamentales
,
hemos
proporcionado
de
manera
intencionada
c√≥digo
que
funciona
correc-


tamente
pero
que
no
es
a
prueba
de
balas
.
Un
‚Äú
c√≥digo
realmente
bueno
‚Äù
tendr√≠a
unas
pocas


m√°s
l√≠neas
auxiliares
.


Una
vez
que
los
dos
programas
est√°n
compilados
en
sus
respectivos
hosts
,
el
programa


servidor
se
ejecuta
primero
en
el
host
servidor
,
que
crea
un
proceso
servidor
en
el
host
.


Como
se
ha
mencionado
anteriormente
,
el
proceso
servidor
espera
a
ser
contactado
por
un


proceso
cliente
.
En
esta
aplicaci√≥n
de
ejemplo
,
cuando
el
programa
cliente
se
ejecuta
se
crea


un
proceso
en
el
cliente
y
este
proceso
contacta
inmediatamente
al
servidor
y
establece
una


conexi√≥n
TCP
con
√©l
.
El
usuario
que
est√°
en
el
cliente
puede
entonces
utilizar
la
aplicaci√≥n


para
enviar
una
l√≠nea
y
recibir
a
continuaci√≥n
la
misma
l√≠nea
escrita
en
letras
may√∫sculas
.


TCPCliente.java


He
aqu√≠
el
c√≥digo
para
el
lado
del
cliente
de
la
aplicaci√≥n
:


import
java.io
.
*
;


import
java.net
.
*
;


class
TCPCliente
{


public
static
void
main(String
argv
[
]
)
throws
Exception


{


String
frase
;


Proceso
cliente
Proceso
servidor


Socket


de
cliente


Socket
de


acogida


(
welcoming


socket
)


Acuerdo
en
tres
fases


Socket
de


conexi√≥n


bytes


bytes


2.7
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
TCP
155


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
155String
fraseModificada
;


BufferedReader
entradaDesdeUsuario
=
new
BufferedReader
(


new
InputStreamReader(System.in
)
)
;


Socket
socketCliente
=
new
Socket(‚Äúnombrehost
‚Äù
,
6789
)
;


DataOutputStream
salidaAServidor
=
new
DataOutputStream
(


socketCliente.getOutputStream
(
)
)
;


BufferedReader
entradaDesdeServidor
=


new
BufferedReader(new
InputStreamReader
(


socketCliente.getInputStream
(
)
)
)
;


frase
=
entradaDesdeUsuario.readLine
(
)
;


salidaAServidor.writeBytes(frase
+
‚Äò
\n
‚Äô
)
;


modifiedSentence
=
entradaDesdeServidor.readLine
(
)
;


System.out.println(‚ÄúDEL
SERVIDOR
:
‚Äú
+


fraseModificada
)
;


socketCliente.close
(
)
;


}


}


Figura
2.30
‚Ä¢
Aplicaci√≥n
cliente-servidor
que
utiliza
servicios
de
transporte


orientados
a
la
conexi√≥n
.


Crear
socket
port
=
x
,


para
solicitud
entrante
:


Servidor


socketAcogida
=


ServerSocket
(
)


(
Ejecuci√≥n
en
hostid
)


Cliente


Establecimiento
 

de
la
conexi√≥n
TCPEsperar
solicitud
de


conexi√≥n
entrante


socketConexion
=


socketAcogida.accept
(
)


Leer
solicitud
de


socketConexion


Escribir
respuesta
a


socketConexion


Cerrar


socketConexion


Crear
socket
conectado
a


hostid
,
port
=
x


socketCliente
=


Socket
(
)


Enviar
solicitud
usando


socketCliente


Leer
respuesta
de


socketCliente


Cerrar


socketCliente


156
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
156Figura
2.31
‚Ä¢
TCPclientetiene
tres
flujos
a
trav√©s
de
los
cuales
se
transmiten


los
caracteres
.


El
programa
TCPCliente
crea
tres
flujos
y
un
socket
,
como
se
muestra
en
la
Figura
2.31
.


El
socket
se
denomina
socketCliente
.
El
flujo
entradaDesdeUsuario
es
un
flujo
de


entrada
al
programa
;
est√°
asociado
a
la
entrada
est√°ndar
(
es
decir
,
al
teclado
)
.
Cuando
el


usuario
escribe
caracteres
en
el
teclado
,
los
caracteres
entran
en
el
flujo
entradaDesdeU-


suario
.
El
flujo
entradaDesdeServidores
otro
flujo
de
entrada
al
programa
y
est√°
aso-


ciado
al
socket
.
Los
caracteres
que
llegan
procedentes
del
flujo
de
la
red
entran
en
el
flujo


entradaDesdeUsuario
.
Por
√∫ltimo
,
el
flujo
salidaAServidor
es
un
flujo
de
salida
del


programa
,
que
tambi√©n
est√°
asociado
al
socket
.
Los
caracteres
que
env√≠a
el
cliente
al
flujo


de
la
red
entran
en
el
flujo
salidaAServidor
.


Comentemos
ahora
las
distintas
l√≠neas
que
forman
el
c√≥digo
.


import
java.io
.
*
;


import
java.net
.
*
;


java.ioy
java.netson
paquetes
Java
.
El
paquete
java.iocontiene
clases
para
los
flu-


jos
de
entrada
y
de
salida
.
En
concreto
,
el
paquete
java.io
contiene
las
clases
Buffere-


dReader
y
DataOutputStream
,
clases
que
utiliza
el
programa
para
crear
los
tres
flujos


anteriormente
mencionados
.
El
paquete
java.net
proporciona
clases
para
el
soporte
de


red
.
En
particular
,
contiene
las
clases
Socket
y
ServerSocket
.
El
objeto
socket-


Clientede
este
programa
se
deriva
de
la
clase
Socket
.


Proceso


Teclado


Flujo
de


salida


Flujo
de


entrada


Monitor


Flujo
de


entrada


salidaAServidor
entradaDesdeUsuario


entradaDesdeServidor


socketCliente
Socket
TCP


A
la
capa


de
transporte


De
la
capa


de
transporte


2.7
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
TCP
157


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
157class
TCPCliente
{


public
static
void
main(String
argv
[
]
)
throws
Exception


{
......
}


}


Hasta
el
momento
,
lo
que
hemos
visto
es
lo
mismo
que
puede
encontrar
al
principio
de
la


mayor√≠a
de
los
c√≥digos
en
Java
.
La
tercera
l√≠nea
es
el
principio
de
un
bloque
de
definici√≥n


de
una
clase
.
La
palabra
clave
class
inicia
la
definici√≥n
de
la
clase
cuyo
nombre
es
TCP-


Cliente
.
Una
clase
contiene
variables
y
m√©todos
.
Tanto
las
variables
como
los
m√©todos
se


encierran
entre
llaves
que
establecen
el
principio
y
el
final
del
bloque
de
definici√≥n
de
la


clase
.
La
clase
TCPClienteno
tiene
ninguna
variable
de
clase
y
tiene
exactamente
un
solo


m√©todo
,
el
m√©todo
main
(
)
.
Los
m√©todos
son
similares
a
las
funciones
o
los
procedimientos


en
lenguajes
como
por
ejemplo
C
;
el
m√©todo
main
(
)
en
el
lenguaje
Java
es
como
la
fun-


ci√≥n
main()de
C
y
C++
.
Cuando
el
int√©rprete
Java
ejecuta
una
aplicaci√≥n
(
al
ser
invocado


para
la
clase
que
controla
la
aplicaci√≥n
)
,
comienza
llamando
al
m√©todo
main
(
)
de
la
clase
.


Entonces
,
el
m√©todo
main
(
)
llama
a
los
restantes
m√©todos
necesarios
para
ejecutar
la
apli-


caci√≥n
.
En
esta
introducci√≥n
a
la
programaci√≥n
de
sockets
en
Java
,
vamos
a
ignorar
las
pala-


bras
clave
public
,
static
,
void
,
main
y
throws
Exceptions
(
aunque
debe
incluirlas


en
el
c√≥digo
)
.


String
frase
;


String
fraseModificada
;


Las
dos
l√≠neas
anteriores
declaran
objetos
de
tipo
String
.
El
objeto
frase
es
la
cadena


escrita
por
el
usuario
y
enviada
al
servidor
.
El
objeto
fraseModificada
es
la
cadena
pro-


porcionada
por
el
servidor
y
enviada
a
la
salida
est√°ndar
del
usuario
.


BufferedReader
entradaDesdeUsuario
=
new
BufferedReader
(


new
InputStreamReader(System.in
)
)
;


La
l√≠nea
anterior
crea
el
objeto
de
flujo
entradaDesdeUsuario
de
tipo
Buffered
Rea-


der
.
El
flujo
de
entrada
se
inicializa
con
System.in
,
que
asocia
el
flujo
a
la
entrada
est√°n-


dar
.
El
comando
permite
al
cliente
leer
texto
introducido
a
trav√©s
de
su
teclado
.


Socket
socketCliente
=
new
Socket(‚Äúnombrehost
‚Äù
,
6789
)
;


La
l√≠nea
anterior
crea
el
objeto
socketCliente
de
tipo
Socket
.
Tambi√©n
inicia
la


conexi√≥n
TCP
entre
el
cliente
y
el
servidor
.
La
cadena
‚Äú
nombrehost
‚Äù
tiene
que
sustituirse


por
el
nombre
de
host
del
servidor
(
por
ejemplo
,
‚Äú
apple.poly.edu
‚Äù
)
.
Antes
de
que
la


conexi√≥n
 
TCP
se
inicie
realmente
,
el
cliente
realiza
una
b√∫squeda
DNS
con
el
nombre
de


host
para
obtener
la
direcci√≥n
IP
correspondiente
.
El
n√∫mero
6789
es
el
n√∫mero
de
puerto
.


Puede
utilizar
un
n√∫mero
de
puerto
diferente
,
pero
debe
asegurarse
de
utilizar
el
mismo


n√∫mero
de
puerto
en
el
lado
del
servidor
de
la
aplicaci√≥n
.
Como
ya
hemos
mencionado
con


anterioridad
,
la
direcci√≥n
IP
del
host
junto
con
el
n√∫mero
de
puerto
de
la
aplicaci√≥n
identifi-


can
al
proceso
servidor
.


DataOutputStream
salidaAServidor
=


new
DataOutputStream(socketCliente.getOutputStream
(
)
)
;


BufferedReader
entradaDesdeServidor
=


new
BufferedReader(new
inputStreamReader
(


socketCliente.getInputStream
(
)
)
)
;


158
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
158Las
l√≠neas
anteriores
crean
objetos
de
flujo
que
est√°n
asociados
al
socket
.
El
flujo
salida-


AServidorproporciona
la
salida
del
proceso
hacia
el
socket
.
El
flujo
entradaDesdeSer-


vidorproporciona
la
entrada
de
proceso
a
partir
del
socket
(
v√©ase
la
Figura
2.31
)
.


frase
=
entradaDesdeServidor.readLine
(
)
;


Esta
l√≠nea
introduce
el
texto
escrito
por
el
usuario
en
la
cadena
frase
.
Esta
cadena


frase
contin√∫a
recopilando
caracteres
hasta
que
el
usuario
termina
la
l√≠nea
introduciendo


un
retorno
de
carro
.
La
l√≠nea
pasa
desde
la
entrada
est√°ndar
a
trav√©s
del
flujo
entradaDes-


deUsuarioa
la
cadena
frase
.


salidaAServidor.writeBytes(frase
+
‚Äò
\n
‚Äô
)
;


La
l√≠nea
anterior
introduce
la
cadena
frase
con
un
retorno
de
carro
adicional
en
el
flujo


salidaAServidor
.
Esta
cadena
aumentada
fluye
a
trav√©s
del
socket
del
cliente
y
entra
en


el
canal
TCP
.
El
cliente
entonces
espera
a
recibir
los
caracteres
procedentes
del
servidor
.


fraseModificada
=
entradaDesdeServidor.readLine
(
)
;


Cuando
llegan
caracteres
desde
el
servidor
,
entran
en
el
flujo
entradaDesdeServidor
y


se
almacenan
en
la
cadena
fraseModificada
.
Los
caracteres
contin√∫an
acumul√°ndose
en


modifiedSentencehasta
que
la
l√≠nea
termina
con
un
car√°cter
de
retorno
de
carro
.


System.out.println(‚ÄúDEL
SERVIDOR
‚Äú
+
fraseModificada
)
;


La
l√≠nea
anterior
muestra
en
el
monitor
la
cadena
fraseModificadadevuelta
por
el
servi-


dor
.


socketCliente.close
(
)
;


Esta
√∫ltima
l√≠nea
cierra
el
socket
y
,
por
tanto
,
cierra
tambi√©n
la
conexi√≥n
TCP
entre
el
cliente


y
el
servidor
.
Hace
que
TCP
en
el
cliente
env√≠e
un
mensaje
TCP
a
TCP
en
el
servidor
(
v√©ase


la
Secci√≥n
3.5
)
.


TCPServidor.java


Ahora
veamos
el
programa
de
servidor
.


import
java.io
.
*
;


import
java.net
.
*
;


class
TCPServidor
{


public
static
void
main(String
argv
[
]
)
throws
Exception


{


String
fraseCliente
;


String
fraseMayusculas
;


ServerSocket
socketAcogida
=
new
ServerSocket
(
6789
)
;


while(true
)
{


Socket
socketConexion
=
socketAcogida.accept
(
)
;


BufferedReader
entradaDesdeCliente
=


new
BufferedReader(new
InputStreamReader
(


socketConexion.getInputStream
(
)
)
)
;


DataOutputStream
salidaACliente
=


2.7
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
TCP
159


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
159new
DataOutputStream
(


socketConexion.getOutputStream
(
)
)
;


fraseCliente
=
entradaDesdeCliente.readLine
(
)
;


fraseMayusculas
=


fraseCliente.toUpperCase
(
)
+
‚Äò
\n
‚Äô
;


salidaACliente.writeBytes(fraseMayusculas
)
;


}


}


}


TCPServidor
tiene
muchas
similitudes
con
TCPCliente
.
Analicemos
ahora
las
l√≠neas


de
TCPServidor.java
.
No
comentaremos
las
l√≠neas
que
son
id√©nticas
o
similares
a
los


comandos
del
programa
TCPCliente.java
.


La
primera
l√≠nea
de
TCPServidor
es
completamente
distinta
a
lo
que
hemos
visto
en


TCPCliente
:


ServerSocket
socketAcogida
 
=
new
ServerSocket(6789
)
;


Esta
l√≠nea
crea
el
objeto
socketAcogida
,
cuyo
tipo
es
ServerSocket
.
El
objeto
socket-


Acogidaes
como
una
puerta
que
escucha
a
ver
si
un
cliente
llama
.
socketAcogida
escu-


cha
en
el
n√∫mero
de
puerto
6789
.
La
siguiente
l√≠nea
es
:


Socket
socketConexion
=
socketAcogida
.accept
(
)
;


Esta
l√≠nea
crea
un
nuevo
socket
,
denominado
socketConexion
,
cuando
alg√∫n
cliente
env√≠a


una
solicitud
a
trav√©s
de
socketAcogida
.
Este
socket
tambi√©n
tiene
el
n√∫mero
de
puerto


6789
.
(
En
el
Cap√≠tulo
3
explicaremos
por
qu√©
los
dos
sockets
tienen
el
mismo
n√∫mero
de


puerto
.
)
TCP
establece
a
continuaci√≥n
un
canal
virtual
directo
entre
socketCliente
en
el


cliente
y
socketConexionen
el
servidor
.
El
cliente
y
el
servidor
pueden
entonces
enviarse


bytes
a
trav√©s
del
canal
y
todos
los
bytes
llegan
al
otro
lado
en
orden
.
Una
vez
establecido


socketConexion
,
el
servidor
puede
continuar
a
la
escucha
de
solicitudes
procedentes
de


otros
clientes
y
dirigidas
a
la
aplicaci√≥n
,
utilizando
socketAcogida
.
(
Esta
versi√≥n
del
pro-


grama
no
se
pone
realmente
a
la
escucha
de
otras
solicitudes
de
conexi√≥n
,
pero
se
puede


modificar
utilizando
hebras
para
que
lo
haga
.
)
El
programa
crea
a
continuaci√≥n
varios
obje-


tos
de
flujo
de
datos
,
an√°logos
a
los
objetos
de
flujo
de
datos
de
socketCliente
.
Fij√©mo-


nos
ahora
en
esta
l√≠nea
:


fraseMayusculas
=
fraseCliente.toUpperCase
(
)
+
‚Äò
\n
‚Äô
;


Este
comando
es
el
n√∫cleo
de
la
aplicaci√≥n
.
Toma
la
l√≠nea
enviada
por
el
cliente
,
la
pasa
a


caracteres
en
may√∫scula
y
a√±ade
un
retorno
de
carro
.
Utiliza
el
m√©todo
toUpperCase
(
)
.


Los
restantes
comandos
del
programa
son
menos
fundamentales
;
se
emplean
para
la
comu-


nicaci√≥n
con
el
cliente
.


Para
probar
los
dos
programas
,
instale
y
compile
TCPCliente.java
en
un
host
y


TCPServidor.java
en
otro
.
Aseg√∫rese
de
incluir
el
nombre
de
host
apropiado
del
servi-


dor
en
TCPCliente.java
.
A
continuaci√≥n
,
ejecute
en
el
servidor
TCPServidor.class
,
e
l


programa
de
servidor
compilado
.
De
este
modo
,
se
crea
un
proceso
en
el
servidor
que
est√°


inactivo
hasta
que
es
contactado
por
alg√∫n
cliente
.
A
continuaci√≥n
,
ejecute
en
el
cliente


TCPCliente.class
,
el
programa
cliente
compilado
.
Esto
crea
un
proceso
en
el
cliente
y


160
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1602.8
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
UDP
161


establece
una
conexi√≥n
TCP
entre
los
procesos
cliente
y
servidor
.
Por
√∫ltimo
,
para
utilizar
la


aplicaci√≥n
,
escriba
una
cadena
de
caracteres
seguida
por
un
retorno
de
carro
.


Para
desarrollar
su
propia
aplicaci√≥n
cliente-servidor
,
puede
comenzar
modificando


ligeramente
los
programas
.
Por
ejemplo
,
en
lugar
de
poner
todas
las
letras
en
may√∫sculas
,
el


servidor
puede
contar
el
n√∫mero
de
veces
que
aparece
la
letra
s
y
devolver
dicho
n√∫mero
.


2.8
Programaci√≥n
de
sockets
con
UDP


Hemos
visto
en
la
secci√≥n
anterior
que
cuando
dos
procesos
se
comunican
mediante
TCP
,
es


como
si
existiera
un
conducto
(
pipe
)
entre
los
mismos
.
Este
conducto
se
mantiene
hasta
que


uno
de
los
dos
procesos
se
cierra
.
Cuando
uno
de
los
procesos
desea
enviar
algunos
bytes
al


otro
,
simplemente
inserta
los
bytes
en
el
conducto
.
El
proceso
de
env√≠o
no
asocia
una
direc-


ci√≥n
de
destino
a
los
bytes
porque
el
conducto
est√°
conectado
l√≥gicamente
al
destino
.
Ade-


m√°s
,
el
conducto
proporciona
un
canal
fiable
de
flujo
de
bytes
;
la
secuencia
de
bytes
recibida


por
el
proceso
receptor
es
exactamente
igual
a
la
que
el
emisor
insert√≥
en
el
conducto
.


UDP
tambi√©n
permite
que
dos
(
o
m√°s
)
procesos
que
est√©n
ejecut√°ndose
en
hosts
dife-


rentes
se
comuniquen
.
Sin
embargo
,
UDP
se
diferencia
de
TCP
en
muchos
puntos
funda-


mentales
.
En
primer
lugar
,
UDP
es
un
servicio
sin
conexi√≥n
(
no
existe
una
fase
inicial
de


negociaci√≥n
durante
la
que
se
establezca
un
conducto
para
la
comunicaci√≥n
entre
los
dos


procesos
)
.
Dado
que
UDP
no
dispone
de
un
conducto
,
cuando
un
proceso
desea
enviar
un


lote
de
bytes
a
otro
proceso
,
el
proceso
emisor
tiene
que
asociar
la
direcci√≥n
del
proceso
de


destino
al
lote
de
bytes
.
Y
esto
tiene
que
hacerse
para
cada
lote
de
bytes
que
el
proceso
emi-


sor
desee
transmitir
.
Veamos
una
analog√≠a
.
Considere
un
grupo
de
20
personas
que
toman


cinco
taxis
para
dirigirse
a
un
mismo
destino
;
seg√∫n
las
personas
van
subiendo
en
los
taxis


informan
al
conductor
sobre
el
lugar
al
que
desean
ir
.
As√≠
,
UDP
es
similar
a
un
servicio
de


taxi
.
La
direcci√≥n
de
destino
es
una
tupla
formada
por
la
direcci√≥n
IP
del
host
de
destino
y
el


n√∫mero
de
puerto
del
proceso
de
destino
.
Al
conjunto
formado
por
el
lote
de
bytes
de
infor-


maci√≥n
,
la
direcci√≥n
IP
de
destino
y
el
n√∫mero
de
puerto
vamos
a
denominarlo
‚Äú
paquete
‚Äù
.


UDP
proporciona
un
modelo
de
servicio
no
fiable
orientado
al
mensaje
,
en
el
que
se
hace
el


m√°ximo
esfuerzo
posible
por
suministrar
el
lote
de
bytes
al
destino
.
Es
un
servicio
orientado


al
mensaje
,
en
el
sentido
de
que
los
lotes
de
bytes
que
se
env√≠an
en
una
√∫nica
operaci√≥n
en


el
lado
del
emisor
ser√°n
entregados
como
un
lote
en
el
extremo
de
recepci√≥n
;
esto
contrasta


con
la
sem√°ntica
de
flujo
de
bytes
de
TCP
.
UDP
es
un
servicio
de
entrega
de
mejor
esfuerzo


(
best
effort
)
en
el
que
no
se
garantiza
que
el
lote
de
bytes
sea
entregado
.
El
servicio
UDP
por


tanto
se
diferencia
enormemente
(
en
varios
aspectos
)
del
modelo
de
servicio
fiable
de
flujo


de
bytes
de
TCP
.


Una
vez
creado
un
paquete
,
el
proceso
emisor
lo
pone
en
la
red
a
trav√©s
de
un
socket
.


Continuando
con
nuestra
analog√≠a
de
los
taxis
,
en
el
otro
lado
del
socket
emisor
hay
un
taxi


esperando
al
paquete
.
El
taxi
entonces
se
pone
en
marcha
y
se
dirige
a
la
direcci√≥n
de
des-


tino
del
paquete
.
Sin
embargo
,
el
taxi
no
garantiza
que
finalmente
el
paquete
llegue
a
la


direcci√≥n
de
destino
(
el
taxi
se
puede
averiar
o
sufrir
cualquier
otro
tipo
de
imprevisto
)
.
En


otras
palabras
,
UDP
proporciona
un
servicio
de
transporte
no
fiable
a
los
procesos
en


comunicaci√≥n
(
no
garantiza
que
un
paquete
llegue
a
su
destino
final
)
.


En
esta
secci√≥n
vamos
a
ilustrar
la
programaci√≥n
de
sockets
volviendo
a
desarrollar


la
misma
aplicaci√≥n
que
en
la
secci√≥n
anterior
,
pero
en
esta
ocasi√≥n
para
UDP
.
Compro-


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
161baremos
que
el
c√≥digo
para
UDP
es
diferente
del
c√≥digo
para
TCP
en
muchos
puntos


importantes
.
En
particular
,
(
1
)
no
existe
una
fase
de
acuerdo
inicial
entre
los
dos
procesos


y
,
por
tanto
,
no
se
necesita
el
socket
de
acogida
,
(
2
)
no
hay
flujos
asociados
a
los
 
sockets
,


(
3
)
el
host
emisor
crea
paquetes
asociando
la
direcci√≥n
IP
de
destino
y
el
n√∫mero
de
puerto


a
cada
lote
de
bytes
que
desea
enviar
y
(
4
)
el
proceso
receptor
tiene
que
desenmara√±ar


cada
paquete
recibido
para
obtener
los
bytes
de
informaci√≥n
del
paquete
.
Recordemos
una


vez
m√°s
nuestra
sencilla
aplicaci√≥n
:


1
.
Un
cliente
lee
una
l√≠nea
de
su
entrada
est√°ndar
(
el
teclado
)
y
la
env√≠a
a
trav√©s
de
su
soc-


ket
al
servidor
.


2
.
El
servidor
lee
la
l√≠nea
de
su
socket
.


3
.
El
servidor
convierte
la
l√≠nea
a
may√∫sculas
.


4
.
El
servidor
env√≠a
la
l√≠nea
modificada
al
cliente
a
trav√©s
de
su
socket
.


5
.
El
cliente
lee
la
l√≠nea
modificada
en
su
socket
y
la
muestra
en
su
salida
est√°ndar
(
el


monitor
)
.


La
Figura
2.32
destaca
la
actividad
principal
relativa
a
los
sockets
del
cliente
y
del
ser-


vidor
que
se
comunican
sobre
un
servicio
de
transporte
sin
conexi√≥n
(
UDP
)
.


Figura
2.32
‚Ä¢
Aplicaci√≥n
cliente-servidor
que
utiliza
servicios
de
transporte
sin


conexi√≥n
.


Crear
socket
port
=
x
,


para
la
solicitud
entrante
:


Servidor


socketServidor
=


DatagramSocket
(
)


(
Ejecuci√≥n
de
hostid
)


Cliente


Leer
solicitud
de


socketServidor


Escribir
respuesta
a


especificando
el
n√∫mero
de


puerto
y
la
direcci√≥n
del


host
cliente


socketServidor


Crear
direcci√≥n


(
hostid
,
port
=
x
)


enviar
solicitud
de
datagrama
usando


socketCliente


Crear
socket


socketCliente
=


DatagramSocket
(
)


Leer
respuesta
de


socketCliente


Cerrar


socketCliente


162
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
162UDPCliente.java


He
aqu√≠
el
c√≥digo
para
el
lado
del
cliente
de
la
aplicaci√≥n
:


import
java.io
.
*
;


import
java.net
.
*
;


class
UDPCliente
{


public
static
void
main(String
args
[
]
)
throws
Exception


{


BufferedReader
entradaDesdeUsuario
=


new
BufferedReader(new
InputStreamReader


(
System.in
)
)
;


DatagramSocket
socketCliente=
new
DatagramSocket
(
)
;


InetAddress
DireccionIP
=


InetAddress.getByName(‚Äúnombrehost
‚Äù
)
;


byte
[
]
enviarDatos
=
new
byte[1024
]
;


byte
[
]
recibirDatos
=
new
byte[1024
]
;


String
frase
=
entradaDesdeUsuario.readLine
(
)
;


enviarDatos
=
frase.getBytes
(
)
;


DatagramPacket
enviarPaquete
=


new
DatagramPacket(enviarDatos
,
enviarDatos.length
,


DireccionIP
,
9876
)
;


socketCliente.send(enviarPaquete
)
;


DatagramPacket
recibirPaquete
=


new
DatagramPacket(recibirDatos
,


recibirDatos.length
)
;


socketCliente.receive(recibirPaquete
)
;


String
fraseModificada
=


new
String(recibirPaquete.getData
(
)
)
;


System.out.println(‚ÄúDEL
SERVIDOR
:
‚Äù
+


fraseModificada
)
;


socketCliente.close
(
)
;


}


}


Como
se
muestra
en
la
Figura
2.33
,
el
programa
UDPCliente.javacrea
un
flujo
y
un
soc-


ket
.
El
nombre
del
socket
es
socketCliente
y
su
tipo
es
DatagramSocket
.
Observe
que


UDP
utiliza
en
el
cliente
una
clase
diferente
de
socket
que
TCP
.
En
concreto
,
con
UDP
nues-


tro
cliente
utiliza
el
tipo
DatagramSocket
,
mientras
que
con
TCP
nuestro
cliente
emple-


aba
un
Socket
.
El
flujo
entradaDesdeUsuario
es
un
flujo
de
entrada
al
programa
,
que


est√°
conectado
a
la
entrada
est√°ndar
,
es
decir
,
al
teclado
.
Ten√≠amos
un
flujo
equivalente
en


nuestra
versi√≥n
TCP
del
programa
.
Cuando
el
usuario
escribe
caracteres
en
el
teclado
,
estos


entran
en
el
flujo
entradaDesdeUsuario
.
Pero
a
diferencia
de
lo
que
ocurre
en
TCP
,
en


este
caso
no
hay
flujos
(
ni
de
entrada
ni
de
salida
)
asociados
al
socket
.
En
lugar
de
introdu-


cir
bytes
en
el
flujo
asociado
a
un
objeto
Socket
,
UDP
introducir√°
paquetes
individuales
a


trav√©s
del
objeto
DatagramSocket
.


Echemos
ahora
un
vistazo
a
las
l√≠neas
del
c√≥digo
que
son
significativamente
diferen-


tes
de
las
del
programa
TCPCliente.java
.


2.8
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
UDP
163


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
163DatagramSocket
socketCliente=
new
DatagramSocket
(
)
;


Esta
l√≠nea
crea
el
objeto
socketClientede
tipo
DatagramSocket
.
En
contraste
con
TCP-


Cliente.java
,
esta
l√≠nea
no
inicia
una
conexi√≥n
TCP
.
En
concreto
,
el
cliente
no
se
pone


en
contacto
con
el
host
servidor
al
ejecutar
esta
l√≠nea
.
Por
esta
raz√≥n
,
el
constructor
Data-


gramSocket
(
)
no
toma
como
argumentos
ni
el
nombre
de
host
del
servidor
ni
el
n√∫mero


de
puerto
.
Utilizando
nuestra
analog√≠a
de
las
puertas
y
conductos
,
la
ejecuci√≥n
de
la
l√≠nea


anterior
crea
una
puerta
para
el
proceso
cliente
,
pero
no
crea
un
conducto
entre
los
dos
pro-


cesos
.


InetAddress
DireccionIP
=
InetAddress.getByName(‚Äúnombrehost
‚Äù
)
;


Para
enviar
bytes
a
un
proceso
de
destino
,
necesitamos
conocer
la
direcci√≥n
del
proceso
.
Parte


de
esta
direcci√≥n
es
la
direcci√≥n
IP
del
host
de
destino
.
La
l√≠nea
anterior
invoca
una
b√∫squeda


DNS
que
traduzca
el
nombre
de
host
(
en
este
ejemplo
,
suministrado
en
el
c√≥digo
por
el
desarro-


llador
)
en
una
direcci√≥n
IP
.
La
versi√≥n
TCP
del
programa
cliente
tambi√©n
invocaba
a
DNS
,
aun-


que
lo
hac√≠a
de
manera
impl√≠cita
,
en
lugar
de
expl√≠cita
.
El
m√©todo
getByName()toma
como


argumento
el
nombre
de
host
del
servidor
y
devuelve
la
direcci√≥n
IP
del
mismo
y
almacena


dicha
direcci√≥n
en
el
objeto
DireccionIPde
tipo
InetAddress
.


byte
[
]
enviarDatos
=
new
byte[1024
]
;


byte
[
]
recibirDatos
=
new
byte[1024
]
;


164
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


Proceso


Teclado


Paquete
de


datagramas


UDP


Paquete
de


datagramas


UDP


Monitor


Flujo
de


entrada


enviarPaquete
entradaDesdeUsuario


recibirPaquete


socketCliente
Socket
UDP


A
la
capa


de
transporte


De
la
capa


de
transporte


Figura
2.33
‚Ä¢
UDPClienttiene
un
flujo
;
el
socket
acepta
paquetes
del


proceso
y
suministra
paquetes
al
proceso
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
164Los
arrays
de
bytes
enviarDatos
y
recibirDatos
almacenar√°n
los
datos
que
el
cliente


env√≠a
y
recibe
,
respectivamente
.


enviarDatos
=
frase.getBytes
(
)
;


La
l√≠nea
anterior
realiza
b√°sicamente
una
conversi√≥n
de
tipos
.
Toma
la
cadena
frase
y
la


renombra
como
enviarDatos
,
que
es
un
array
de
bytes
.


DatagramPacket
enviarPaquete
=
new
DatagramPacket
(


enviarDatos
,
enviarDatos.length
,
DireccionIP
,
9876
)
;


Esta
l√≠nea
construye
el
paquete
,
enviarPaquete
,
que
el
cliente
introducir√°
en
la
red
a
tra-


v√©s
de
su
socket
.
Este
paquete
incluye
los
datos
contenidos
en
el
paquete
enviarDatos
,
la


longitud
de
estos
datos
,
la
direcci√≥n
IP
del
servidor
y
el
n√∫mero
de
puerto
de
la
aplicaci√≥n


(
que
hemos
definido
como
9876
)
.
Observe
que
enviarPaquetees
de
tipo
DatagramPac-


ket
.


socketCliente.send(enviarPaquete
)
;


En
la
l√≠nea
anterior
,
el
m√©todo
send
(
)
del
objeto
socketCliente
toma
el
paquete
que
se


acaba
de
crear
y
lo
introduce
en
la
red
a
trav√©s
de
socketCliente
.
Observe
una
vez
m√°s


que
UDP
env√≠a
la
l√≠nea
de
caracteres
de
forma
muy
diferente
a
como
lo
hace
TCP
.
TCP
sim-


plemente
insertaba
la
cadena
de
caracteres
en
un
flujo
de
datos
,
que
ten√≠a
una
conexi√≥n


l√≥gica
directa
con
el
servidor
;
UDP
crea
un
paquete
que
incluye
la
direcci√≥n
del
servidor
.


Despu√©s
de
enviar
el
paquete
,
el
cliente
espera
entonces
recibir
un
paquete
procedente
del


servidor
.


DatagramPacket
recibirPaquete
=


new
DatagramPacket(recibirDatos
,
recibirDatos.length
)
;


En
la
l√≠nea
anterior
,
el
cliente
crea
un
contenedor
para
el
paquete
,
recibirPaquete
,
un


objeto
de
tipo
DatagramPacket
,
mientras
espera
recibir
el
paquete
del
servidor
.


socketCliente.receive(recibirPaquete
)
;


El
cliente
est√°
inactivo
hasta
que
recibe
un
paquete
y
cuando
le
llega
,
lo
almacena
en
 
reci-


birPaquete
.


String
fraseModificada
=


new
String(recibirPaquete.getData
(
)
)
;


La
l√≠nea
anterior
extrae
los
datos
de
recibirPaquete
y
realiza
una
conversi√≥n
de
tipos
,


convirtiendo
un
array
de
bytes
en
la
cadena
fraseModificada
.


System.out.println(‚ÄúDEL
SERVIDOR
:
‚Äù
+
fraseModificada
)
;


Esta
l√≠nea
,
que
tambi√©n
aparece
en
TCPCliente
,
muestra
la
cadena
fraseModificadaen


el
monitor
del
cliente
.


socketCliente.close
(
)
;


2.8
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
UDP
165


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
165Esta
√∫ltima
l√≠nea
cierra
el
socket
.
Puesto
que
UDP
proporciona
un
servicio
sin
conexi√≥n
,


esta
l√≠nea
no
hace
que
el
cliente
env√≠e
un
mensaje
de
la
capa
de
transporte
al
servidor
(
a
dife-


rencia
del
caso
de
TCPCliente
)
.


UDPServidor.java


Veamos
ahora
el
lado
del
servidor
de
la
aplicaci√≥n
:


import
java.io
.
*
;


import
java.net
.
*
;


class
UDPServidor
{


public
static
void
main(String
args
[
]
)
throws
Exception


{


DatagramSocket
socketServidor
=
new


DatagramSocket(9876
)
;


byte
[
]
recibirDatos
=
new
byte[1024
]
;


byte
[
]
enviarDatos
=
new
byte[1024
]
;


while(true
)


{


DatagramPacket
recibirPaquete
=


new
DatagramPacket(recibirDatos
,


recibirDatos.length
)
;


socketServidor.receive(recibirPaquete
)
;


String
frase
=
new
String
(


recibirPaquete.getData
(
)
)
;


InetAddress
DireccionIP
=


recibirPaquete.getAddress
(
)
;


int
puerto
=
recibirPaquete.getPort
(
)
;


String
fraseMayusculas
=


frase.toUpperCase
(
)
;


enviarDatos
=
fraseMayusculas.getBytes
(
)
;


DatagramPacket
enviarPaquete
=


new
DatagramPacket(enviarDatos
,


enviarDatos.length
,
DireccionIP
,
puerto
)
;


socketServidor.send(enviarPaquete
)
;


}


}


}


El
programa
UDPServidor.java
crea
un
socket
,
como
se
muestra
en
la
Figura
2.34
.
El


nombre
del
socket
es
socketServidor
.
Se
trata
de
un
objeto
de
tipo
DatagramSocket
,


al
igual
que
lo
era
el
socket
del
lado
del
cliente
de
la
aplicaci√≥n
.
De
nuevo
,
no
hay
flujos


asociados
al
socket
.


Examinemos
las
l√≠neas
de
este
c√≥digo
que
son
diferentes
a
las
de
TCPServidor.java
.


DatagramSocket
socketServidor
=
new
DatagramSocket(9876
)
;


La
l√≠nea
anterior
crea
el
socketServidor
de
tipo
DatagramSocket
en
el
puerto
9876
.


Todos
los
datos
enviados
y
recibidos
pasar√°n
a
trav√©s
de
este
socket
.
Puesto
que
UDP
pro-


166
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
166porciona
un
servicio
sin
conexi√≥n
,
no
tenemos
que
crear
un
nuevo
socket
y
continuar
escu-


chando
para
captar
nuevas
solicitudes
de
conexi√≥n
como
se
hace
en
TCPServidor.java
.


Si
varios
clientes
acceden
a
esta
aplicaci√≥n
,
todos
ellos
enviar√°n
sus
paquetes
a
trav√©s
de


esta
misma
puerta
,
socketServidor
.


String
frase
=
new
String(recibirPaquete.getData
(
)
)
;


InetAddress
DireccionIP
=
recibirPaquete.getAddress
(
)
;


int
puerto
=
recibirPaquete.getPort
(
)
;


Las
tres
l√≠neas
anteriores
decodifican
el
paquete
que
llega
procedente
del
cliente
.
La
pri-


mera
de
ellas
extrae
los
datos
del
paquete
y
los
almacena
en
la
cadena
frase
;
hay
una
l√≠nea


similar
en
el
programa
UDPCliente
.
La
segunda
l√≠nea
extrae
la
direcci√≥n
IP
y
la
tercera


l√≠nea
extrae
el
n√∫mero
de
puerto
del
cliente
,
que
es
elegido
por
el
cliente
y
es
diferente
del


n√∫mero
de
puerto
de
servidor
,
9876
(
en
el
siguiente
cap√≠tulo
estudiaremos
m√°s
en
detalle


los
n√∫meros
de
puerto
del
cliente
)
.
Necesariamente
,
el
servidor
tiene
que
obtener
la
direc-


ci√≥n
IP
y
el
n√∫mero
de
puerto
del
cliente
,
con
el
fin
de
poder
devolverle
el
texto
convertido


a
may√∫sculas
al
cliente
.


Esto
completa
nuestro
an√°lisis
de
los
dos
programas
UDP
.
Para
probar
la
aplicaci√≥n
,


instale
y
compile
UDPCliente.javaen
un
host
y
UDPServidor.javaen
otro
host
.
(
Ase-


g√∫rese
de
incluir
el
nombre
de
host
apropiado
del
servidor
en
el
programa
UDPCliente
.


java
.
)
A
continuaci√≥n
,
ejecute
los
dos
programas
en
sus
respectivos
hosts
.
A
diferencia
de


TCP
,
puede
ejecutar
primero
el
lado
del
cliente
y
luego
el
lado
del
servidor
.
La
raz√≥n
de
ello


es
que
el
proceso
cliente
no
intenta
establecer
una
conexi√≥n
con
el
servidor
nada
m√°s
ejecu-


tarse
el
programa
cliente
.
Una
vez
que
haya
ejecutado
los
programas
cliente
y
servidor
,


puede
utilizar
la
aplicaci√≥n
escribiendo
una
l√≠nea
en
el
cliente
.


2.8
‚Ä¢
PROGRAMACI√ìN
DE
SOCKETS
CON
UDP
167


Proceso


Paquete
de


datagramas


UDP


Paquete
de


datagramas


UDP


Socket
UDP


puerto
9876


A
la


capa
de


transporte


De
la


capa
de


transporte


enviarPaquete


recibirPaquete


socketServidor


toUpperCase
(
)


Figura
2.34
‚Ä¢
UDPServidorno
tiene
flujos
;
el
socket
acepta
paquetes
del
proceso


y
suministra
paquetes
al
proceso
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
1672.9
Resumen


En
este
cap√≠tulo
hemos
estudiado
los
aspectos
conceptuales
y
de
implementaci√≥n
de
las
apli-


caciones
de
red
.
Hemos
podido
comprobar
la
omnipresencia
de
la
arquitectura
cliente-servi-


dor
adoptada
por
muchas
aplicaciones
de
Internet
y
ver
su
uso
en
los
protocolos
HTTP
,
FTP
,


SMTP
,
POP3
y
DNS
.
Hemos
estudiado
estos
importantes
protocolos
del
nivel
de
aplicaci√≥n


y
sus
correspondientes
aplicaciones
asociadas
(
la
Web
,
la
transferencia
de
archivos
,
el


correo
electr√≥nico
y
DNS
)
con
cierto
detalle
.
Tambi√©n
hemos
aprendido
acerca
de
la
arqui-


tectura
P2P
que
est√°
empezando
a
predominar
y
c√≥mo
se
utiliza
en
muchas
aplicaciones
.


Hemos
examinado
c√≥mo
puede
utilizarse
la
API
de
sockets
para
crear
aplicaciones
de
red
.


Asimismo
,
hemos
estudiado
el
uso
de
los
sockets
para
los
servicios
de
transporte
terminal
a


terminal
orientados
a
la
conexi√≥n
(
TCP
)
y
sin
conexi√≥n
(
UDP
)
.
¬°
Hemos
completado
la
pri-


mera
etapa
de
nuestro
viaje
por
la
arquitectura
de
red
en
capas
!


Al
principio
del
libro
,
en
la
Secci√≥n
1.1
,
hemos
proporcionado
una
definici√≥n
algo
vaga


de
protocolo
:
‚Äú
el
formato
y
el
orden
de
los
mensajes
intercambiados
entre
dos
o
m√°s
entida-


des
que
se
comunican
,
as√≠
como
las
acciones
realizadas
en
la
transmisi√≥n
y
/
o
recepci√≥n
de


un
mensaje
u
otro
evento
.
‚Äù
El
material
facilitado
en
este
cap√≠tulo
,
y
en
concreto
el
estudio


detallado
de
los
protocolos
HTTP
,
FTP
,
SMTP
,
POP3
y
DNS
,
aporta
a
esta
definici√≥n
una


gran
profundidad
.
Los
protocolos
son
un
concepto
clave
en
las
redes
y
nuestro
estudio
de


los
protocolos
de
aplicaci√≥n
nos
ha
proporcionado
la
oportunidad
de
desarrollar
una
idea


m√°s
intuitiva
sobre
qu√©
son
los
protocolos
.


En
la
Secci√≥n
2.1
hemos
descrito
los
modelos
de
servicio
que
ofrecen
TCP
y
UDP
a
las


aplicaciones
que
los
invocan
.
En
las
Secciones
2.7
y
2.8
hemos
visto
en
detalle
estos
mode-


los
de
servicio
para
el
desarrollo
de
aplicaciones
sencillas
que
se
ejecutan
sobre
TCP
y
UDP
.


Sin
embargo
,
hemos
hablado
poco
acerca
de
c√≥mo
TCP
y
UDP
proporcionan
estos
modelos


de
servicio
.
Por
ejemplo
,
sabemos
que
TCP
proporciona
un
servicio
de
datos
fiable
,
pero


todav√≠a
no
sabemos
c√≥mo
lo
hace
.
En
el
siguiente
cap√≠tulo
veremos
detenidamente
no
s√≥lo


qu√©
servicios
proporcionan
,
sino
tambi√©n
el
c√≥mo
y
el
por
qu√©
del
funcionamiento
de
los


protocolos
de
transporte
.


Ahora
que
ya
tenemos
algunos
conocimientos
acerca
de
la
estructura
de
las
aplicacio-


nes
de
Internet
y
de
los
protocolos
de
la
capa
de
aplicaci√≥n
,
estamos
preparados
para


seguir
descendiendo
por
la
pila
de
protocolos
y
examinar
la
capa
de
transporte
en
el
Cap√≠-


tulo
3
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
2
Cuestiones
de
repaso


SECCI√ìN
2.1


R.1
.
Enumere
cinco
aplicaciones
de
Internet
no
propietarias
y
los
protocolos
de
la
capa
de


aplicaci√≥n
que
utilizan
.


R.2
.
¬ø
Cu√°l
es
la
diferencia
entre
la
arquitectura
de
red
y
la
arquitectura
de
aplicaci√≥n
?


R.3
.
En
una
sesi√≥n
de
comunicaci√≥n
entre
dos
procesos
,
¬ø
qu√©
proceso
es
el
cliente
y
qu√©


proceso
es
el
servidor
?


168
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
168PROBLEMAS
Y
CUESTIONES
DE
REPASO
169


R.4
.
En
una
aplicaci√≥n
de
compartici√≥n
de
archivos
P2P
,
¬ø
est√°
de
acuerdo
con
la
siguiente


afirmaci√≥n
:
‚Äú
No
existen
los
lados
de
cliente
y
de
servidor
en
una
sesi√≥n
de
comunica-


ci√≥n
‚Äù
?
¬ø
Por
qu√©
?


R.5
.
¬ø
Qu√©
informaci√≥n
utiliza
un
proceso
que
se
ejecuta
en
un
host
para
identificar
a
un


proceso
que
se
ejecuta
en
otro
host
?


R.6
.
Suponga
que
desea
realizar
una
transici√≥n
desde
un
cliente
remoto
a
un
servidor
lo


m√°s
r√°pidamente
posible
.
¬ø
Qu√©
utilizar√≠a
,
UDP
o
TCP
?
¬ø
Por
qu√©
?


R.7
.
Utilizando
la
Figura
2.4
,
podemos
ver
que
ninguna
de
las
aplicaciones
indicadas
en


dicha
figura
presenta
a
la
vez
requisitos
de
temporizaci√≥n
y
de
ausencia
de
p√©rdida
de


datos
.
¬ø
Puede
concebir
una
aplicaci√≥n
que
requiera
que
no
haya
p√©rdida
de
datos
y
que


tambi√©n
sea
extremadamente
sensible
al
tiempo
?


R.8
.
Enumere
las
cuatro
clases
principales
de
servicios
que
puede
proporcionar
un
proto-


colo
de
transporte
.
Para
cada
una
de
las
clases
de
servicios
,
indique
si
UDP
o
TCP
(
o


ambos
)
proporcionan
un
servicio
as√≠
.


R.9
.
Recuerde
que
TCP
puede
mejorarse
con
SSL
para
proporcionar
servicios
de
seguridad


proceso
a
proceso
,
incluyendo
mecanismos
de
cifrado
.
¬ø
En
qu√©
capa
opera
SSL
,
en
la


capa
de
transporte
o
en
la
capa
de
aplicaci√≥n
?
Si
el
desarrollador
de
la
aplicaci√≥n


desea
mejorar
TCP
con
SSL
,
¬ø
qu√©
tendr√°
que
hacer
?


SECCIONES
2.2‚Äì2.5


R.10
.
¬ø
Qu√©
quiere
decir
el
t√©rmino
protocolo
de
acuerdo
?


R.11
.
¬ø
Por
qu√©
HTTP
,
FTP
,
SMTP
y
POP3
se
ejecutan
sobre
TCP
en
lugar
de
sobre
UDP
?


R.12
.
Un
sitio
de
comercio
electr√≥nico
desea
mantener
un
registro
de
compras
para
cada
uno


de
sus
clientes
.
Describa
c√≥mo
se
puede
hacer
esto
utilizando
cookies
.


R.13
.
Describa
c√≥mo
el
almacenamiento
en
cach√©
web
puede
reducir
el
retardo
de
recepci√≥n


de
un
objeto
solicitado
.
¬ø
Reducir√°
este
tipo
de
almacenamiento
el
retardo
de
todos
los


objetos
solicitados
por
el
usuario
o
s√≥lo
el
de
algunos
objetos
?
¬ø
Por
qu√©
?


R.14
.
Establezca
una
sesi√≥n
Telnet
en
un
servidor
web
y
env√≠e
un
mensaje
de
solicitud
de


varias
l√≠neas
.
Incluya
en
dicho
mensaje
la
l√≠nea
de
cabecera
If-modified-since
:


para
forzar
un
mensaje
de
respuesta
con
el
c√≥digo
de
estado
304
Not
Modified
.


R.15
.
¬ø
Por
qu√©
se
dice
que
FTP
env√≠a
la
informaci√≥n
de
control
‚Äú
fuera
de
banda
‚Äù
?


R.16
.
Suponga
que
Alicia
,
que
dispone
de
una
cuenta
de
correo
electr√≥nico
web
(
como
por


ejemplo
Hotmail
o
gmail
)
,
env√≠a
un
mensaje
a
Benito
,
que
accede
a
su
correo
alma-


cenado
en
su
servidor
de
correo
utilizando
POP3
.
Explique
c√≥mo
se
transmite
el


mensaje
desde
el
host
de
Alicia
hasta
el
de
Benito
.
Aseg√∫rese
de
citar
la
serie
de
pro-


tocolos
de
la
capa
de
aplicaci√≥n
que
se
utilizan
para
llevar
el
mensaje
de
un
host
al


otro
.


R.17
.
Imprima
la
cabecera
de
un
mensaje
de
correo
electr√≥nico
que
haya
recibido
reciente-


mente
.
¬ø
Cu√°ntas
l√≠neas
de
cabecera
Received
:
contiene
?
Analice
cada
una
de
las


l√≠neas
de
cabecera
del
mensaje
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
169R.18
.
Desde
la
perspectiva
de
un
usuario
,
¬ø
cu√°l
es
la
diferencia
entre
el
modo
‚Äú
descargar
y


borrar
‚Äù
y
el
modo
‚Äú
descargar
y
mantener
‚Äù
en
POP3
?


R.19
.
¬ø
Pueden
el
servidor
web
y
el
servidor
de
correo
electr√≥nico
de
una
organizaci√≥n
tener


exactamente
el
mismo
alias
para
un
nombre
de
host
(
por
ejemplo
,
foo.com
)
?
¬ø
Cu√°l


ser√≠a
el
tipo
especificado
en
el
registro
de
recurso
(
RR
)
que
contiene
el
nombre
de
host


del
servidor
de
correo
?


SECCI√ìN
2.6


R.20
.
En
BitTorrent
,
suponga
que
Alicia
proporciona
fragmentos
a
Benito
a
intervalos
de
30


segundos
.
¬ø
Devolver√°
necesariamente
Benito
el
favor
y
proporcionar√°
fragmentos
a


Alicia
en
el
mismo
intervalo
de
tiempo
?
¬ø
Por
qu√©
?


R.21
.
Suponga
que
un
nuevo
par
Alicia
se
une
a
BitTorrent
sin
tener
en
su
posesi√≥n
ning√∫n


fragmento
.
Dado
que
no
posee
fragmentos
,
no
puede
convertirse
en
uno
de
los
cuatro


principales
suministradores
de
ninguno
de
los
otros
pares
,
ya
que
no
tiene
nada
que


suministrar
.
¬ø
C√≥mo
obtendr√°
entonces
Alicia
su
primer
fragmento
?


R.22
.
¬ø
Qu√©
es
una
red
solapada
?
¬ø
Contiene
routers
?
¬ø
Cu√°les
son
las
fronteras
en
una
red


solapada
?
¬ø
C√≥mo
se
crea
y
se
mantiene
la
red
solapada
que
se
encarga
de
distribuir


las
consultas
?


R.23
.
¬ø
En
qu√©
sentido
la
mensajer√≠a
instant√°nea
con
un
√≠ndice
centralizado
es
un
h√≠brido
de


las
arquitecturas
cliente-servidor
y
P2P
?


R.24
.
Considere
una
DHT
con
una
topolog√≠a
de
red
solapada
en
malla
(
es
decir
,
cada
par


controla
a
todos
los
dem√°s
pares
del
sistema
)
.
¬ø
Cu√°les
son
las
ventajas
y
desventajas


de
un
dise√±o
de
este
tipo
?
¬ø
Cu√°les
son
las
ventajas
y
desventajas
de
una
DHT
circular


(
sin
atajos
)
?


R.25
.
Skype
utiliza
t√©cnicas
P2P
para
dos
funciones
importantes
.
¬ø
Cu√°les
son
dichas
funcio-


nes
?


R.26
.
Cite
al
menos
cuatro
aplicaciones
distintas
que
se
adapten
de
forma
natural
a
las
arqui-


tecturas
P2P.
(
Sugerencia
:
la
distribuci√≥n
de
archivos
y
la
mensajer√≠a
instant√°nea
son


dos
de
ellas
.
)


SECCIONES
2.7‚Äì2.8


R.27
.
El
servidor
UDP
descrito
en
la
Secci√≥n
2.8
s√≥lo
necesitaba
un
socket
,
mientras
que
el


servidor
TCP
descrito
en
la
Secci√≥n
2.7
necesitaba
dos
.
¬ø
Por
qu√©
?
Si
el
servidor
TCP


tuviera
que
soportar
n
conexiones
simult√°neas
,
cada
una
procedente
de
un
host
cliente


distinto
,
¬ø
cu√°ntos
sockets
necesitar√≠a
el
servidor
TCP
?


R.28
.
En
la
aplicaci√≥n
cliente-servidor
sobre
TCP
descrita
en
la
Secci√≥n
2.7
,
¬ø
por
qu√©
tiene


que
ser
ejecutado
el
programa
servidor
antes
que
el
programa
cliente
?
En
la
aplicaci√≥n


cliente-servidor
sobre
UDP
descrita
en
la
Secci√≥n
2.8
,
¬ø
por
qu√©
el
programa
cliente


puede
ejecutarse
antes
que
el
programa
servidor
?


170
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
170Problemas


P1
.
¬ø
Verdadero
o
falso
?


a.
Un
usuario
solicita
una
p√°gina
web
que
consta
de
texto
y
tres
im√°genes
.
Para
obte-


ner
esa
p√°gina
,
el
cliente
env√≠a
un
mensaje
de
solicitud
y
recibe
cuatro
mensajes
de


respuesta
.


b.
Dos
p√°ginas
web
diferentes
(
por
ejemplo
,
www.mit.edu/research.htmly
www
.


mit.edu/students.html
)
se
pueden
enviar
a
trav√©s
de
la
misma
conexi√≥n
per-


sistente
.


c.
Con
las
conexiones
no
persistentes
entre
un
navegador
y
un
servidor
de
origen
,
un


√∫nico
segmento
TCP
puede
transportar
dos
mensajes
de
solicitud
HTTP
distintos
.


d.
La
l√≠nea
de
cabecera
Date
:
del
mensaje
de
respuesta
HTTP
indica
cu√°ndo
el
objeto


fue
modificado
por
√∫ltima
vez
.


e.
Los
mensajes
de
respuesta
HTTP
nunca
incluyen
un
cuerpo
de
mensaje
vac√≠o
.


P2
.
Lea
el
documento
RFC
959
relativo
a
FTP
.
Enumere
todos
los
comandos
cliente
que


est√°n
soportados
por
dicho
documento
.


P3
.
Un
cliente
HTTP
desea
recuperar
un
documento
web
que
se
encuentra
en
un
URL


dado
.
Inicialmente
,
la
direcci√≥n
IP
del
servidor
HTTP
es
desconocida
.
¬ø
Qu√©
protoco-


los
de
la
capa
de
aplicaci√≥n
y
de
la
capa
de
transporte
adem√°s
de
HTTP
son
necesarios


en
este
escenario
?


P4
.
La
siguiente
cadena
de
caracteres
ASCII
ha
sido
capturada
por
Wireshark
cuando
el


navegador
enviaba
un
mensaje
GET
HTTP
(
es
decir
,
√©ste
es
el
contenido
real
de
un
men-


saje
GET
HTTP
)
.
Los
caracteres
<
cr><lf
>
representan
el
retorno
de
carro
y
el
salto
de


l√≠nea
(
es
decir
,
la
cadena
de
caracteres
en
cursiva
<
cr
>
del
texto
que
sigue
a
este


p√°rrafo
representa
el
car√°cter
de
retorno
de
carro
contenido
en
dicho
punto
de
la
cabe-


cera
HTTP
)
.
Responda
a
las
siguientes
cuestiones
,
indicando
en
qu√©
parte
del


siguiente
mensaje
GET
HTTP
se
encuentra
la
respuesta
.


GET
/cs453
/
index.html
HTTP/1.1
<
cr><lf
>
Host
:
gai


a.cs.umass.edu
<
cr><lf
>
User-Agent
:
Mozilla/5.0
(


Windows;U
;
Windows
NT
5.1
;
en-US
;
rv:1.7.2
)
Gec


ko/20040804
Netscape/7.2
(
ax
)
<
cr><lf
>
Accept
:
ex


t
/
xml
,
application
/
xml
,
application
/
xhtml+xml
,
text


/html;q=0.9
,
text
/
plain;q=0.8,image
/
png,*/*;q=0.5


<
cr><lf
>
Accept-Language
:
en-us
,
en;q=0.5
<
cr><lf
>
Accept-


Encoding
:
zip
,
deflate
<
cr><lf
>
Accept-Charset
:
ISO


-8859-1,utf-8;q=0.7,*;q=0.7
<
cr><lf
>
Keep-Alive
:
300
<
cr
>


<
lf
>
Connection
:
keep-alive
<
cr><lf><cr><lf
>


a.
¬ø
Cu√°l
es
el
URL
del
documento
solicitado
por
el
navegador
?


b.
¬ø
Qu√©
versi√≥n
de
HTTP
se
est√°
ejecutando
en
el
navegador
?


c.
¬ø
Qu√©
tipo
de
conexi√≥n
solicita
el
navegador
,
persistente
o
no
persistente
?


d.
¬ø
Cu√°l
es
la
direcci√≥n
IP
del
host
en
el
que
se
est√°
ejecutando
el
navegador
?


PROBLEMAS
171


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
171e
.
¬ø
Qu√©
tipo
de
navegador
inicia
este
mensaje
?
¬ø
Por
qu√©
es
necesario
indicar
el
tipo


de
navegador
en
un
mensaje
de
solicitud
HTTP
?


P5
.
El
siguiente
texto
muestra
la
respuesta
devuelta
por
el
servidor
al
mensaje
de
solicitud


GET
HTTP
del
problema
anterior
.
Responda
a
las
siguientes
cuestiones
,
indicando
en


qu√©
parte
del
siguiente
mensaje
se
encuentran
las
respuestas
.


HTTP/1.1
200
OK
<
cr><lf
>
Date
:
Tue
,
07
Mar
2008


12:39:45GMT
<
cr><lf
>
Server
:
Apache/2.0.52
(
Fedora
)


<
cr><lf
>
Last-Modified
:
Sat
,
10
Dec2005
18:27:46


GMT
<
cr><lf
>
ETag
:
‚Äú
526c3-f22-a88a4c80‚Äù<cr><lf
>


Accept-Ranges
:
bytes
<
cr><lf
>
Content-Length
:
3874
<
cr><lf
>


Keep-Alive
:
timeout
=
max=100
<
cr><lf
>
Connection
:


Keep-Alive
<
cr><lf
>
Content-Type
:
text
/
html
;
charset=


ISO-8859-1
<
cr><lf><cr><lf><!doctype
html
public
‚Äú
-


//w3c//dtd
html
4.0
transitional//en‚Äù><lf><html><lf
>


<
head><lf
>
<
meta
http-equiv=‚ÄùContent-Type
‚Äù


content=‚Äùtext
/
html
;
charset
=
iso-8859-1‚Äù><lf
>


<
meta
name=‚ÄùGENERATOR
‚Äù
content=‚ÄùMozilla/4.79
[
en
]
(
Windows
NT


5.0
;
U
)
Netscape]‚Äù><lf
>
<
title
>
CMPSCI
453
/
591
/


NTU-ST550A
Spring
2005
homepage</title><lf></head><lf
>


<
aqu√≠
contin√∫a
el
texto
del
documento
(
no
mostrado
)
>


a.
¬ø
Ha
podido
el
servidor
encontrar
el
documento
?
¬ø
En
qu√©
momento
se
suministr√≥
la


respuesta
con
el
documento
?


b.
¬ø
Cu√°ndo
fue
modificado
por
√∫ltima
vez
el
documento
?


c.
¬ø
Cu√°ntos
bytes
contiene
el
documento
devuelto
?


d.
¬ø
Cu√°les
son
los
primeros
cinco
bytes
del
documento
que
se
est√°
devolviendo
?
¬ø
Ha


acordado
el
servidor
emplear
una
conexi√≥n
persistente
?


P6
.
Utilice
la
especificaci√≥n
HTTP/1.1
(
RFC
2616
)
para
responder
a
las
siguientes
cues-


tiones
:


a.
Explique
el
mecanismo
de
se√±alizaci√≥n
entre
el
cliente
y
el
servidor
para
indicar


que
se
est√°
cerrando
una
conexi√≥n
persistente
.
¬ø
Qui√©n
puede
se√±alizar
el
cierre
de


la
conexi√≥n
,
el
cliente
,
el
servidor
o
ambos
?


b.
¬ø
Qu√©
servicios
de
cifrado
proporciona
HTTP
?


c.
¬ø
Puede
un
cliente
abrir
tres
o
m√°s
conexiones
simult√°neas
con
un
determinado
ser-


vidor
?


d.
Un
servidor
o
un
cliente
pueden
cerrar
una
conexi√≥n
de
transporte
entre
ellos
si
uno


detecta
que
la
conexi√≥n
ha
estado
inactiva
durante
un
cierto
tiempo
.
¬ø
Es
posible


que
un
lado
inicie
el
cierre
de
una
conexi√≥n
mientras
que
el
otro
lado
est√°
transmi-


tiendo
datos
a
trav√©s
de
dicha
conexi√≥n
?
Explique
su
respuesta
.


P7
.
Suponga
que
en
su
navegador
hace
clic
en
un
v√≠nculo
a
una
p√°gina
web
.
La
direcci√≥n


IP
correspondiente
al
URL
asociado
no
est√°
almacenado
en
la
cach√©
de
su
host
local
,


por
lo
que
es
necesario
realizar
una
b√∫squeda
DNS
para
obtener
la
direcci√≥n
IP
.


Suponga
que
antes
de
que
su
host
reciba
la
direcci√≥n
IP
de
DNS
se
han
visitado
n
ser-


vidores
DNS
y
que
los
tiempos
de
ida
y
vuelta
(
RTT
)
de
las
sucesivas
visitas
son


172
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
172RTT1
,
.
.
.
,
RTTn
.
Suponga
adem√°s
que
la
p√°gina
web
asociada
con
el
v√≠nculo
contiene


exactamente
un
objeto
,
que
consta
de
un
peque√±o
fragmento
de
texto
HTML
.
Sea


RTT0
el
tiempo
RTT
entre
el
host
local
y
el
servidor
que
contiene
el
objeto
.
Supo-


niendo
un
tiempo
de
transmisi√≥n
despreciable
para
el
objeto
,
¬ø
cu√°nto
tiempo
transcu-


rre
desde
que
el
cliente
hace
clic
en
el
v√≠nculo
hasta
que
recibe
el
objeto
?


P8
.
Continuando
con
el
Problema
P7
,
suponga
que
el
archivo
HTML
hace
referencia
a


ocho
objetos
muy
peque√±os
que
se
encuentran
en
el
mismo
servidor
.
Despreciando
los


tiempos
de
transmisi√≥n
,
¬ø
cu√°nto
tiempo
transcurre
si
se
utiliza


a.
HTTP
no
persistente
sin
conexiones
TCP
en
paralelo
?


b.
HTTP
no
persistente
con
el
navegador
configurado
para
5
conexiones
paralelo
?


c.
HTTP
persistente
?


P9
.
En
la
red
institucional
conectada
a
Internet
de
la
Figura
2.12
,
suponga
que
el
tama√±o


medio
de
objeto
es
de
850.000
bits
y
que
la
tasa
media
de
solicitudes
de
los
navegado-


res
de
la
instituci√≥n
a
los
servidores
de
origen
es
de
16
solicitudes
por
segundo
.


Suponga
tambi√©n
que
el
tiempo
que
se
tarda
desde
que
el
router
en
el
lado
de
Internet


del
enlace
de
acceso
reenv√≠a
una
solicitud
HTTP
hasta
que
recibe
la
respuesta
es
,


como
media
,
de
tres
segundos
(
v√©ase
la
Secci√≥n
2.2.5
)
.
Modele
el
tiempo
medio
de


respuesta
total
como
la
suma
del
retardo
medio
de
acceso
(
es
decir
,
el
retardo
desde
el


router
de
Internet
al
router
de
la
instituci√≥n
)
y
el
retardo
medio
de
Internet
.
Para


el
retardo
medio
de
acceso
,
utilice
la
expresi√≥n
 
/(1
‚Äì
  
)
,
donde
 
es
el
tiempo


medio
requerido
para
enviar
un
objeto
a
trav√©s
del
enlace
de
acceso
y
 
es
la
tasa
de


llegada
de
los
objetos
al
enlace
de
acceso
.


a.
Calcule
el
tiempo
medio
de
respuesta
total
.


b.
Ahora
suponga
que
hay
instalada
una
cach√©
en
la
LAN
institucional
.
Suponga
que


la
tasa
de
fallos
es
de
0,4
.
Calcule
el
tiempo
de
respuesta
total
.


P10
.
Dispone
de
un
enlace
corto
de
10
metros
a
trav√©s
del
cual
un
emisor
puede
transmitir


a
una
velocidad
de
150
bits
/
segundo
en
ambos
sentidos
.
Suponga
que
los
paquetes
de


datos
tienen
una
longitud
de
100.000
bits
y
los
paquetes
que
contienen
s√≥lo
comandos


de
control
(
por
ejemplo
,
ACK
o
de
acuerdo
)
tienen
una
longitud
de
200
bits
.
Suponga


que
hay
N
conexiones
en
paralelo
y
que
cada
una
utiliza
1/
N
del
ancho
de
banda
del


enlace
.
Considere
ahora
el
protocolo
HTTP
y
suponga
que
cada
objeto
descargado
es


de
100
kbytes
de
largo
y
que
el
objeto
inicialmente
descargado
contiene
10
objetos


referenciados
procedentes
del
mismo
emisor
.
¬ø
Tiene
sentido
en
este
caso
realizar
des-


cargas
en
paralelo
mediante
instancias
paralelas
de
HTTP
no
persistente
?
Considere


ahora
HTTP
persistente
.
¬ø
Cabe
esperar
alguna
ventaja
significativa
respecto
del
caso


no
persistente
?
Justifique
y
explique
su
respuesta
.


P11
.
Continuando
con
el
escenario
del
problema
anterior
,
suponga
que
Benito
comparte
el


enlace
con
otros
cuatro
usuarios
.
Benito
utiliza
instancias
paralelas
de
HTTP
no
persis-


tente
y
los
otros
cuatro
usuarios
utilizan
HTTP
no
persistente
sin
descargas
en
paralelo
.


a.
¬ø
Le
ayudan
a
Benito
las
conexiones
en
paralelo
a
obtener
las
p√°ginas
m√°s
r√°pida-


mente
?
¬ø
Por
qu√©
?


b.
Si
los
cinco
usuarios
abren
cinco
instancias
paralelas
de
HTTP
no
persistente
,


¬ø
seguir√°n
siendo
beneficiosas
las
conexiones
en
paralelo
de
Benito
?
¬ø
Por
qu√©
?


PROBLEMAS
173


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
173P12
.
Escriba
un
programa
TCP
simple
para
un
servidor
que
acepte
l√≠neas
de
entrada
proce-


dentes
de
un
cliente
y
muestre
dichas
l√≠neas
en
la
salida
est√°ndar
del
servidor
.
(
Puede


realizar
esta
tarea
modificando
el
programa
TCPServidor.javavisto
en
el
cap√≠tulo
.
)


Compile
y
ejecute
su
programa
.
En
cualquier
otra
m√°quina
que
disponga
de
un
nave-


gador
web
,
configure
el
servidor
proxy
en
el
navegador
para
que
apunte
al
host
que


est√°
ejecutando
su
programa
servidor
;
configure
tambi√©n
el
n√∫mero
de
puerto
de
la


forma
apropiada
.
Su
navegador
deber√°
ahora
enviar
sus
mensajes
de
solicitud
GET
a


su
servidor
y
el
servidor
tendr√°
que
mostrar
dichos
mensajes
en
su
salida
est√°ndar
.
Uti-


lice
esta
plataforma
para
determinar
si
su
navegador
genera
mensajes
GET
condicio-


nales
para
los
objetos
almacenados
localmente
en
la
cach√©
.


P13
.
¬ø
Cu√°l
es
la
diferencia
entre
MAIL
FROM
:
en
SMTP
y
From
:
en
el
propio
mensaje
de


correo
?


P14
.
¬ø
C√≥mo
marca
SMTP
el
final
del
cuerpo
de
un
mensaje
?
¬ø
C√≥mo
lo
hace
HTTP
?


¬ø
Puede
HTTP
utilizar
el
mismo
m√©todo
que
SMTP
para
marcar
el
final
del
cuerpo
de


un
mensaje
?
Explique
su
respuesta
.
 

P15
.
Lea
el
documento
RFC
5321
dedicado
a
SMTP
.
¬ø
Qu√©
quiere
decir
MTA
?
Considere
el


siguiente
mensaje
de
correo
basura
recibido
(
modificado
a
partir
de
un
correo
basura


real
)
.
Suponiendo
que
√∫nicamente
el
remitente
de
este
mensaje
de
correo
es
malicioso


y
que
los
dem√°s
hosts
son
honestos
,
identifique
al
host
malicioso
que
ha
generado
este


correo
basura
.


From
-
Fri
Nov
07
13:41:30
2008


Return-Path
:
<
tennis5@pp33head.com
>


Received
:
from
barmail.cs.umass.edu


(
barmail.cs.umass.edu
[
128.119.240.3
]
)
by
cs.umass.edu


(
8.13.1/8.12.6
)
for
<
hg@cs.umass.edu
>
;
Fri
,
7
Nov
2008


13:27:10
-0500


Received
:
from
asusus-4b96
(
localhost
[
127.0.0.1
]
)
by


barmail.cs.umass.edu
(
Spam
Firewall
)
for


<
hg@cs.umass.edu
>
;
Fri
,
 
7
Nov
2008
13:27:07
-0500


(
EST
)


Received
:
from
asusus-4b96
(
[
58.88.21.177
]
)
by


barmail.cs.umass.edu
for
<
hg@cs.umass.edu
>
;
Fri
,


07
Nov
2008
13:27:07
-0500
(
EST
)


Received
:
from
[
58.88.21.177
]
by


inbnd55.exchangeddd.com
;
Sat
,
8
Nov
2008
01:27:07
+0700


From
:
"
Jonny
"
<
tennis5@pp33head.com
>


To
:
<
hg@cs.umass.edu
>


Subject
:
C√≥mo
asegurar
sus
ahorros


P16
.
Lea
el
documento
RFC
1939
dedicado
a
POP3
.
¬ø
Cu√°l
es
el
prop√≥sito
del
comando


UIDL
POP3
?


P17
.
Imagine
que
accede
a
su
correo
electr√≥nico
utilizando
POP3
.


a.
Suponga
que
ha
configurado
su
cliente
de
correo
POP
para
operar
en
el
modo
des-


cargar
y
borrar
.
Complete
la
siguiente
transacci√≥n
:


174
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
174C
:
list


S
:
1
498


S
:
2
912


S
:
.


C
:
retr
1


S
:
bla
bla
...


S
:
..........
blah


S
:
.


?


?


b.
Suponga
que
ha
configurado
su
cliente
de
correo
POP
para
operar
en
el
modo
des-


cargar
y
guardar
.
Complete
la
siguiente
transacci√≥n
:


C
:
list


S
:
1
498


S
:
2
912


S
:
.


C
:
retr
1


S
:
bla
bla
...


S
:
..........
bla


S
:
.


?


?


c.
Suponga
que
ha
configurado
su
cliente
de
correo
POP
para
operar
en
el
modo
des-


cargar
y
guardar
.
Utilizando
su
transcripci√≥n
del
apartado
(
b
)
,
suponga
que
recu-


pera
los
mensajes
1
y
2
,
sale
de
POP
,
y
cinco
minutos
m√°s
tarde
vuelve
a
acceder


otra
vez
a
POP
para
recuperar
un
nuevo
mensaje
de
correo
.
Suponga
que
en
ese


intervalo
de
cinco
minutos
nadie
le
ha
enviado
un
nuevo
mensaje
de
correo
.
Pro-


porcione
una
transcripci√≥n
de
esta
segunda
sesi√≥n
de
POP
.


P18
.
a.
¬ø
Qu√©
es
una
base
de
datos
whois
?


b.
Utilice
varias
bases
de
datos
whois
de
Internet
para
obtener
los
nombres
de
dos
ser-


vidores
DNS
.
Indique
qu√©
bases
de
datos
whois
ha
utilizado
.


c.
Utilice
el
programa
nslookup
en
su
host
local
para
enviar
consultas
DNS
a
tres
ser-


vidores
DNS
:
su
servidor
DNS
local
y
los
dos
servidores
DNS
que
haya
encontrado


en
el
apartado
(
b
)
.
Intente
realizar
consultas
para
obtener
registros
de
recursos
de


tipo
A
,
NS
y
MX
.
Escriba
un
resumen
de
sus
hallazgos
.


d.
Utilice
el
programa
nslookup
para
localizar
un
servidor
web
que
tenga
varias
direc-


ciones
IP
.
¬ø
Tiene
el
servidor
web
de
su
instituci√≥n
(
centro
de
estudios
o
empresa
)


varias
direcciones
IP
?


e.
Utilice
la
base
de
datos
whois
ARIN
para
determinar
el
rango
de
direcciones
IP
uti-


lizado
en
su
universidad
.


f.
Describa
c√≥mo
un
atacante
puede
utilizar
las
bases
de
datos
whois
y
la
herramienta


nslookup
para
realizar
labores
de
reconocimiento
en
una
instituci√≥n
antes
de
lanzar


un
ataque
.


g.
Explique
por
qu√©
las
bases
de
datos
whois
deben
estar
disponibles
p√∫blicamente
.


PROBLEMAS
175


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
175P19
.
En
este
problema
emplear√°
la
√∫til
herramienta
dig
,
disponible
en
los
hosts
Unix
y


Linux
para
explorar
la
jerarqu√≠a
de
los
servidores
DNS
.
Como
se
muestra
en
la
Figura


2.21
,
un
servidor
DNS
que
se
encuentra
en
un
nivel
superior
de
la
jerarqu√≠a
DNS


delega
una
consulta
DNS
en
un
servidor
DNS
que
se
encuentra
en
un
nivel
m√°s
bajo


de
la
jerarqu√≠a
,
devolviendo
al
cliente
DNS
el
nombre
de
dicho
servidor
DNS
del
nivel


m√°s
bajo
.
Lea
primero
la
p√°gina
de
manual
dedicada
a
dig
y
,
a
continuaci√≥n
,
responda


a
las
siguientes
preguntas
.
 

a.
Comenzando
por
un
servidor
DNS
ra√≠z
(
uno
de
los
servidores
ra√≠z
[
a-m].root-ser-


vers.net
)
,
inicie
una
secuencia
de
consultas
para
obtener
la
direcci√≥n
IP
del
servi-


dor
web
de
su
departamento
,
utilizando
la
herramienta
dig
.
Visualice
la
lista
de


nombres
de
los
servidores
DNS
incluidos
en
la
cadena
de
delegaci√≥n
que
ha
obte-


nido
como
respuesta
a
su
consulta
.


b.
Repita
el
apartado
(
a
)
para
varios
sitios
web
populares
,
como
por
ejemplo


google.com
,
yahoo.com
o
amazon.com
.


P20
.
Suponga
que
puede
acceder
a
las
cach√©s
de
los
servidores
DNS
locales
de
su
departa-


mento
.
¬ø
Puede
proponer
una
forma
de
determinar
de
manera
aproximada
los
servido-


res
web
(
situados
fuera
de
su
departamento
)
que
son
m√°s
populares
entre
los
usuarios


del
departamento
?
Explique
su
respuesta
.
 

P21
.
Suponga
que
su
departamento
tiene
un
servidor
DNS
local
para
todas
las
computado-


ras
del
departamento
.
Usted
es
un
usuario
normal
(
es
decir
,
no
es
un
administrador
de


la
red
o
del
sistema
)
.
¬ø
Puede
determinar
de
alguna
manera
si
desde
alguna
computa-


dora
de
su
departamento
se
ha
accedido
hace
unos
pocos
segundos
a
un
determinado


sitio
web
externo
?
Explique
su
respuesta
.
 

P22
.
Desea
distribuir
un
archivo
de
F
=
15
Gbits
a
N
pares
.
El
servidor
tiene
una
velocidad


de
carga
de
us
=
30
Mbps
,
y
cada
par
tiene
una
velocidad
de
descarga
de
di
=
2
Mbps
y


una
velocidad
de
carga
igual
a
u.
Para
N
=
10
,
100
y
1.000
,
y
u
=
300
kbps
,
700
kbps


y
2
Mbps
,
prepare
una
gr√°fica
que
proporcione
el
tiempo
m√≠nimo
de
distribuci√≥n
para


cada
una
de
las
combinaciones
de
N
y
u
,
tanto
para
una
distribuci√≥n
cliente-servidor


como
para
una
distribuci√≥n
P2P.


P23
.
Desea
distribuir
un
archivo
de
F
bits
a
N
pares
utilizando
una
arquitectura
cliente-


servidor
.
Suponga
un
modelo
flexible
,
en
el
que
el
servidor
puede
transmitir
simult√°-


neamente
a
varios
pares
,
transmitiendo
a
cada
par
a
distintas
velocidades
,
siempre
y


cuando
la
velocidad
combinada
no
sea
mayor
que
us
.


a.
Suponga
que
us
/
N
 
dm√≠n
.
Especifique
un
esquema
de
distribuci√≥n
que
tenga
un


tiempo
de
distribuci√≥n
de
NF
/
us
.


b.
Suponga
que
us
/
N
 
dm√≠n
.
Especifique
un
esquema
de
distribuci√≥n
que
tenga
un


tiempo
de
distribuci√≥n
de
F
/
dm√≠n
.


c.
Demuestre
que
,
en
general
,
el
tiempo
m√≠nimo
de
distribuci√≥n
est√°
dado
por


m√°x
{
NF
/
us
,
F
/
dm√≠n
}
.


P24
.
Desea
distribuir
un
archivo
de
F
bits
a
N
pares
utilizando
una
arquitectura
P2P.


Suponga
un
modelo
flexible
.
Con
el
fin
de
simplificar
,
suponga
que
dm√≠n
es
muy


grande
,
por
lo
que
el
ancho
de
banda
de
descarga
de
los
pares
no
es
nunca
un
cuello


de
botella
.


176
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
176a
.
Suponga
que
us
 
(
us
+
u1
+
...
+
uN)/N.
Especifique
un
esquema
de
distribuci√≥n


que
tenga
un
tiempo
de
distribuci√≥n
de
F
/
us
.


b.
Suponga
que
us
 
(
us
+
u1
+
...
+
uN)/N.
Especifique
un
esquema
de
distribuci√≥n


que
tenga
un
tiempo
de
distribuci√≥n
de
NF/(us
+
u1
+
...
+
uN
)
.


c.
Demuestre
que
,
en
general
,
el
tiempo
m√≠nimo
de
distribuci√≥n
est√°
dado
por


m√°x
{
F
/
us
,
NF/(us
+
u1
+
...
+
uN
)
}
.


P25
.
Considere
una
red
solapada
con
N
pares
activos
,
disponiendo
cada
pareja
de
pares
de


una
conexi√≥n
TCP
activa
.
Suponga
tambi√©n
que
las
conexiones
TCP
atraviesan
un
total


de
M
routers
.
¬ø
Cu√°ntos
nodos
y
fronteras
existen
en
la
correspondiente
red
solapada
?


P26
.
Suponga
que
Benito
se
une
a
un
torrente
BitTorrent
,
pero
no
desea
suministrar
datos
a


otros
pares
(
lo
que
se
denomina
‚Äú
ir
por
libre
‚Äù
)
.


a.
Benito
afirma
que
puede
recibir
una
copia
completa
del
archivo
compartido
por
el


conjunto
de
usuarios
.
¬ø
Es
correcto
lo
que
dice
Benito
?
¬ø
Por
qu√©
?


b.
Benito
a√±ade
que
puede
hacer
m√°s
eficientes
sus
descargas
utilizando
varias
com-


putadoras
(
con
distintas
direcciones
IP
)
del
laboratorio
de
su
departamento
.
¬ø
C√≥mo


puede
hacer
esto
?


P27
.
En
este
problema
,
el
objetivo
es
determinar
la
eficiencia
de
un
sistema
de
comparti-


ci√≥n
de
archivos
P2P
como
BitTorrent
.
Considere
los
pares
Benito
y
Alicia
.
√âstos
se


unen
a
un
torrente
en
el
que
,
en
total
,
hay
M
pares
(
incluyendo
a
Benito
y
Alicia
)
que


est√°n
compartiendo
un
archivo
que
consta
de
N
fragmentos
.
Suponga
que
en
un


instante
determinado
t
,
los
fragmentos
que
tiene
un
par
est√°n
seleccionados
de
forma


aleatoria
y
uniforme
de
entre
los
N
fragmentos
y
que
ning√∫n
par
tiene
todos
los
N
frag-


mentos
.
Responda
a
las
siguientes
preguntas
.


a.
¬ø
Cu√°l
es
la
probabilidad
de
que
Benito
tenga
todos
los
fragmentos
que
tiene
Alicia
,


si
expresamos
el
n√∫mero
de
fragmentos
que
tiene
cada
uno
como
nb
(
Benito
)
y
na


(
Alicia
)
?


b.
Elimine
algunas
de
las
suposiciones
del
apartado
(
a
)
para
calcular
la
probabilidad
de


que
Benito
tenga
todos
los
fragmentos
que
tiene
Alicia
,
si
√©sta
tiene
na
fragmentos
?


c.
Suponga
que
cada
par
de
BitTorrent
tiene
cinco
vecinos
.
¬ø
Cu√°l
es
la
probabilidad


de
que
Benito
tenga
datos
que
sean
del
inter√©s
de
al
menos
uno
de
sus
cinco
veci-


nos
?


P28
.
En
el
ejemplo
de
la
DHT
circular
de
la
Secci√≥n
2.6.2
,
suponga
que
el
par
3
sabe
que
el


par
5
ha
abandonado
la
red
.
¬ø
C√≥mo
actualiza
el
par
3
la
informaci√≥n
de
estado
de
su


sucesor
?
¬ø
Qu√©
par
ser√°
ahora
su
primer
sucesor
?
¬ø
Y
su
segundo
sucesor
?
 

P29
.
En
el
ejemplo
de
la
DHT
circular
de
la
Secci√≥n
 
2.6.2
,
suponga
que
un
nuevo
par
6


desea
unirse
a
la
DHT
y
que
inicialmente
el
par
6
s√≥lo
conoce
la
direcci√≥n
IP
del
par


15
.
¬ø
Qu√©
pasos
tendr√°
que
dar
?


P30
.
Sea
una
red
DHT
circular
con
nodos
e
identificadores
de
clave
en
el
rango
de
[
0
,
63
]
.


Suponga
que
hay
ocho
pares
cuyos
identificadores
son
0
,
8
,
16
,
24
,
32
,
40
,
48
y
56
.


a.
Suponga
que
cada
par
puede
tener
un
par
de
atajo
.
Para
cada
uno
de
los
ocho
pares
,


determine
su
par
de
atajo
,
de
manera
que
el
n√∫mero
de
mensajes
enviados
para


cualquier
consulta
(
iniciada
en
cualquier
par
)
sea
m√≠nimo
.


PROBLEMAS
177


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
177b
.
Repita
el
apartado
(
a
)
pero
ahora
permita
que
cada
par
tenga
dos
pares
de
atajo
.


P31
.
Puesto
que
un
n√∫mero
entero
perteneciente
al
intervalo
[
0
,
2
n
 
1
]
se
puede
expresar


como
un
n√∫mero
binario
de
n
bits
en
una
DHT
,
cada
clave
se
puede
expresar
como


k
=
(
k0
,
k1
,
.
.
.
,
kn‚Äì1
)
y
cada
identificador
de
un
par
como
p
=
(
p0
,
p1
,
.
.
.
,
pn‚Äì1
)
,
defi-


nimos
la
distancia
 
XOR
entre
una
clave
k
y
un
par
p
como


Explique
c√≥mo
se
puede
utilizar
esta
m√©trica
para
asignar
parejas
(
clave
,
valor
)
a
los


pares
.
(
Para
obtener
m√°s
informaci√≥n
sobre
c√≥mo
crear
una
DHT
eficiente
utilizando


esta
m√©trica
natural
,
consulte
[
Maymounkov
2002
]
donde
se
describe
la
DHT


Kademlia
.
)


P32
.
Considere
una
versi√≥n
generalizada
del
esquema
descrito
en
el
problema
anterior
.
En


lugar
de
utilizar
n√∫meros
binarios
,
ahora
vamos
a
tratar
las
claves
y
los
identificadores


de
los
pares
como
n√∫meros
en
base
b
,
donde
b
>
2
,
y
luego
utilizaremos
la
m√©trica
del


problema
anterior
para
dise√±ar
una
DHT
(
sustituyendo
2
por
b
)
.
Compare
esta
DHT


basada
en
n√∫meros
en
base
b
con
la
DHT
basada
en
n√∫meros
binarios
.
En
el
caso
peor
,


¬ø
qu√©
DHT
genera
m√°s
mensajes
por
consulta
?
¬ø
Por
qu√©
?


P33
.
Dado
que
las
DHT
son
redes
solapadas
,
no
necesariamente
se
corresponden
con
las


redes
f√≠sicas
subyacentes
en
el
sentido
de
que
dos
pares
vecinos
pueden
estar
f√≠sica-


mente
muy
alejados
;
por
ejemplo
,
un
par
podr√≠a
encontrarse
en
Asia
y
su
vecino
estar


en
Am√©rica
del
Norte
.
Si
asignamos
identificadores
de
forma
aleatoria
y
uniforme
a


los
pares
que
acaban
de
unirse
a
la
red
,
¬ø
podr√≠a
este
esquema
de
asignaciones
hacer


que
se
produjera
esa
no
correspondencia
?
Explique
su
respuesta
.
¬ø
C√≥mo
podr√≠a
esa


no
correspondencia
afectar
al
rendimiento
de
la
DHT
?


P34
.
Instale
y
compile
los
programas
Java
TCPCliente
y
UDPCliente
en
un
host
y
los


programas
TCPServidory
UDPServidoren
otro
host
.


a.
Suponga
que
ejecuta
TCPCliente
antes
que
el
programa
TCPServidor
.
¬ø
Qu√©


ocurrir√°
?
¬ø
Por
qu√©
?


b.
Suponga
que
ejecuta
el
programa
UDPCliente
antes
que
UDPServidor
.
¬ø
Qu√©


ocurrir√°
?
¬ø
Por
qu√©
?


c.
¬ø
Qu√©
ocurrir√°
si
utiliza
diferentes
n√∫meros
de
puerto
para
los
lados
de
cliente
y
de


servidor
?


P35
.
Suponga
que
en
el
programa
UDPClient.javasustituimos
la
l√≠nea


DatagramSocket
socketCliente=
new
DatagramSocket
(
)
;


por


DatagramSocket
socketCliente=
new
DatagramSocket(5432
)
;


¬ø
Ser√°
necesario
modificar
el
programa
UDPServidor.java
?
¬ø
Cu√°les
son
los
n√∫me-


ros
de
puerto
para
los
sockets
en
UDPClienty
UDPServidor
?
¬ø
Cu√°les
eran
antes
de


realizar
este
cambio
?


d(k
,
p
)
=
‚àí


=


‚àí


‚àë
||k
pjj


j


n


j


0


1


2


178
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
178Preguntas
para
la
discusi√≥n


D1
.
¬ø
Por
qu√©
cree
que
las
aplicaciones
de
compartici√≥n
de
archivos
P2P
son
tan
popula-


res
?
¬ø
Es
acaso
porque
distribuyen
m√∫sica
y
v√≠deos
de
foma
gratuita
(
algo
que
puede


ser
ilegal
)
?
¬ø
Es
porque
su
enorme
cantidad
de
servidores
responden
de
forma
eficiente


a
una
enorme
demanda
de
megabytes
?
¬ø
O
es
por
todas
estas
razones
?


D2
.
Lea
el
documento
‚Äú
The
Darknet
and
the
Future
of
Content
Distribution
‚Äù
de
Biddle
,


England
,
Peinado
y
Willman
[
Biddle
2003
]
.
¬ø
Est√°
de
acuerdo
con
los
puntos
de
vista


de
los
autores
?
¬ø
Por
qu√©
?


D3
.
Los
sitios
web
dedicados
al
comercio
electr√≥nico
y
otros
suelen
disponer
de
bases
de


datos
back-end
.
¬ø
C√≥mo
se
comunican
los
servidores
HTTP
con
estas
bases
de
datos


back-end
?


D4
.
¬ø
C√≥mo
se
puede
configurar
un
navegador
para
almacenamiento
en
cach√©
local
?
¬ø
De


qu√©
opciones
de
almacenamiento
en
cach√©
dispone
?


D5
.
¬ø
Puede
configurar
su
navegador
para
abrir
varios
conexiones
simult√°neas
con
un
sitio


web
?
¬ø
Cu√°les
son
las
ventajas
y
desventajas
de
disponer
de
un
gran
n√∫mero
de
cone-


xiones
TCP
simult√°neas
?


D6
.
Hemos
visto
que
los
sockets
TCP
de
Internet
tratan
los
datos
que
est√°n
siendo
envia-


dos
como
un
flujo
de
bytes
,
pero
los
sockets
UDP
reconocen
los
l√≠mites
de
los
mensa-


jes
.
Cite
una
ventaja
y
una
desventaja
de
las
API
orientadas
a
byte
y
de
tener
una
API


que
reconozca
y
mantenga
expl√≠citamente
los
l√≠mites
de
los
mensajes
definidos
por
la


aplicaci√≥n
?


D7
.
¬ø
Qu√©
es
un
servidor
web
Apache
?
¬ø
Cu√°nto
cuesta
?
¬ø
Qu√©
funcionalidad
proporciona


actualmente
?


D8
.
Muchos
clientes
BitTorrent
utilizan
tablas
DHT
para
crear
un
tracker
distribuido
.
Para


dichas
DHT
,
¬ø
cu√°l
es
la
‚Äú
clave
‚Äù
y
cu√°l
es
el
‚Äú
valor
‚Äù
?


D9
.
Imagine
que
las
organizaciones
de
est√°ndares
web
deciden
cambiar
el
convenio
de


denominaci√≥n
,
de
modo
que
cada
objeto
se
nombre
y
se
referencie
mediante
un
√∫nico


nombre
que
sea
independiente
de
la
ubicaci√≥n
(
lo
que
se
denomina
un
URN
)
.
Indique


algunos
de
los
problemas
que
implicar√≠a
tal
cambio
.


D10
.
¬ø
Hay
actualmente
compa√±√≠as
que
distribuyan
a
trav√©s
de
Internet
televisi√≥n
en


directo
?
En
caso
afirmativo
,
¬ø
utilizan
dichas
empresas
arquitecturas
cliente-servidor
o


P2P
?


D11
.
¬ø
Est√°n
las
empresas
proporcionando
actualmente
un
servicio
de
v√≠deo
a
la
carta
a
tra-


v√©s
de
Internet
utilizando
una
arquitectura
P2P
?


D12
.
¬ø
C√≥mo
proporciona
Skype
un
servicio
PC
a
tel√©fono
a
tantos
pa√≠ses
de
destino
dis-


tintos
?


D13
.
¬ø
Cu√°les
son
hoy
d√≠a
algunos
de
los
clientes
BitTorrent
m√°s
populares
?


PREGUNTAS
PARA
LA
DISCUSI√ìN
179


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
179Tareas
sobre
programaci√≥n
de
sockets


Tarea
1
:
servidor
web
multihebra


Al
terminar
esta
tarea
de
programaci√≥n
,
habr√°
desarrollado
,
en
Java
,
un
servidor
web
mul-


tihebra
capaz
de
servir
varias
solicitudes
en
paralelo
.
Va
a
implementar
la
versi√≥n
1.0
de


HTTP
,
tal
y
como
se
define
en
el
documento
RFC
1945
.


HTTP/1.0
crea
una
conexi√≥n
TCP
separada
para
cada
par
solicitud
/
respuesta
.
Una
hebra


separada
gestiona
cada
una
de
las
conexiones
.
Tambi√©n
habr√°
una
hebra
principal
,
en
la
que


el
servidor
escuche
a
los
clientes
que
deseen
establecer
una
conexi√≥n
.
Para
simplificar
la


tarea
de
programaci√≥n
,
desarrollaremos
el
c√≥digo
en
dos
etapas
.
En
la
primera
,
escribir√°
el


c√≥digo
para
un
servidor
multihebra
que
simplemente
muestre
el
contenido
del
mensaje
de


solicitud
HTTP
que
haya
recibido
.
Una
vez
que
este
programa
se
ejecute
correctamente
,


deber√°
a√±adir
el
c√≥digo
necesario
para
generar
una
respuesta
apropiada
.


Am
e
d
i
d
a
 
q
u
e
 
v
a
y
a
 
d
e
s
a
r
r
o
l
l
a
n
d
o
 
e
l
 
c
√≥
d
i
g
o
,
 
p
u
e
d
e
 
p
r
o
b
a
r
 
s
u
 
s
e
r
v
i
d
o
r
 
c
o
n
 
u
n
 
n
a
v
e
g
a
d
o
r


web
.
Pero
recuerde
que
no
est√°
proporcionando
el
servicio
a
trav√©s
del
puerto
est√°ndar
80
,


por
lo
que
tendr√°
que
especificar
el
n√∫mero
de
puerto
dentro
del
URL
que
proporcione
al


navegador
.
Por
ejemplo
,
si
el
nombre
de
host
es
host.unaEscuela.edu
,
su
servidor
est√°


a
la
escucha
en
el
puerto
6789
y
desea
recuperar
el
archivo
index.html
,
entonces
tendr√°


que
especificar
el
siguiente
URL
en
el
navegador
:


http://host.unaescuela.edu:6789/index.html


Cuando
su
servidor
detecte
un
error
,
deber√°
enviar
un
mensaje
de
respuesta
con
un
c√≥digo


fuente
HTML
apropiado
,
de
manera
que
la
informaci√≥n
acerca
del
error
se
muestre
en
la


ventana
del
navegador
.
Puede
encontrar
todos
los
detalles
de
esta
tarea
,
as√≠
como
√∫tiles
frag-


mentos
en
c√≥digo
Java
en
el
sitio
web
http://www.awl.com/kurose-ross
.


Tarea
2
:
cliente
de
correo


En
esta
tarea
tendr√°
que
desarrollar
,
en
Java
,
un
agente
de
usuario
de
correo
con
las
siguien-


tes
caracter√≠sticas
:


‚Ä¢D
e
b
e
 
p
r
o
p
o
r
c
i
o
n
a
r
 
u
n
a
 
i
n
t
e
r
f
a
z
 
g
r
√°
f
i
c
a
 
a
l
 
e
m
i
s
o
r
,
 
c
o
n
 
c
a
m
p
o
s
 
p
a
r
a
 
e
l
 
s
e
r
v
i
d
o
r
 
d
e
 
c
o
r
r
e
o


local
,
la
direcci√≥n
de
correo
electr√≥nico
del
emisor
,
la
direcci√≥n
de
correo
electr√≥nico
del


receptor
,
el
asunto
del
mensaje
y
el
propio
mensaje
.


‚Ä¢D
e
b
e
 
e
s
t
a
b
l
e
c
e
r
 
u
n
a
 
c
o
n
e
x
i
√≥
n
 
T
C
P
e
n
t
r
e
 
e
l
 
c
l
i
e
n
t
e
 
d
e
 
c
o
r
r
e
o
 
y
 
e
l
 
s
e
r
v
i
d
o
r
 
d
e
 
c
o
r
r
e
o
 
l
o
c
a
l
,


enviar
comandos
SMTP
al
servidor
de
correo
local
,
y
recibir
y
procesar
los
comandos


SMTP
procedentes
del
servidor
de
correo
local
.


La
interfaz
tendr√°
que
ser
similar
a
la
captura
de
pantalla
mostrada
en
la
p√°gina
siguiente
.


Debe
desarrollar
el
agente
de
usuario
de
manera
que
env√≠e
un
mensaje
de
correo
electr√≥nico


como
m√°ximo
a
un
destinatario
cada
vez
.
Adem√°s
,
el
agente
de
usuario
supondr√°
que
la


parte
del
dominio
de
la
direcci√≥n
de
correo
electr√≥nico
del
destinatario
es
el
nombre
can√≥-


nico
del
servidor
SMTP
del
destinatario
.
(
El
agente
de
usuario
no
realizar√°
una
b√∫squeda


DNS
para
obtener
un
registro
MX
,
por
lo
que
el
emisor
debe
suministrar
el
nombre
real
del


servidor
de
correo
.
)
En
el
sitio
web
del
libro
,
http://www.awl.com/kurose-ross
,
puede
encon-


trar
todos
los
detalles
de
esta
tarea
,
as√≠
como
√∫tiles
fragmentos
de
c√≥digo
Java
.


180
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
180Tarea
3
:
generador
de
comandos
Ping
UDP


En
esta
pr√°ctica
de
laboratorio
tendr√°
que
implementar
un
servidor
y
un
cliente
Ping
basa-


dos
en
UDP
.
La
funcionalidad
proporcionada
por
estos
programas
es
similar
al
programa


est√°ndar
Ping
disponible
en
los
sistemas
operativos
actuales
.
El
programa
est√°ndar
Ping


env√≠a
mensajes
ECHO
ICMP
(
Internet
Control
Message
Protocol
)
,
que
la
m√°quina
remota


devuelve
al
emisor
.
El
emisor
puede
as√≠
determinar
el
tiempo
de
ida
y
vuelta
transcurrido


desde
que
ejecuta
el
comando
Ping
hasta
que
recibe
la
respuesta
de
la
otra
computadora
.


Java
no
proporciona
ninguna
funcionalidad
para
enviar
ni
recibir
mensajes
ICMP
,
raz√≥n


por
la
que
en
esta
pr√°ctica
de
laboratorio
tendr√°
que
implementar
un
programa
Ping
en
la
capa


de
aplicaci√≥n
con
mensajes
y
sockets
UDP
est√°ndar
.
En
el
sitio
web
del
libro
,
http://www


.awl.com
/
kurose-ross
,
puede
encontrar
todos
los
detalles
de
esta
tarea
,
as√≠
como
√∫tiles
frag-


mentos
de
c√≥digo
Java
.


Tarea
4
:
servidor
proxy
web


En
esta
pr√°ctica
de
laboratorio
tendr√°
que
desarrollar
un
servidor
proxy
web
simple
,
que


tambi√©n
sea
capaz
de
almacenar
en
cach√©
p√°ginas
web
.
Este
servidor
aceptar√°
un
mensaje


GET
de
un
navegador
,
lo
reenviar√°
al
servidor
web
de
destino
,
recibir√°
el
mensaje
de
res-


puesta
HTTP
del
servidor
de
destino
y
reenviar√°
ese
mensaje
de
respuesta
HTTP
al
navega-


dor
.
Se
trata
de
un
servidor
proxy
muy
sencillo
;
basta
con
que
comprenda
solicitudes
GET


simples
.
Sin
embargo
,
el
servidor
podr√°
manejar
toda
clase
de
objetos
,
no
s√≥lo
p√°ginas


HTML
,
incluyendo
im√°genes
.
En
el
sitio
web
del
libro
,
http://www
.awl.com
/
kurose-ross
,


puede
encontrar
todos
los
detalles
de
esta
tarea
,
as√≠
como
√∫tiles
fragmentos
de
c√≥digo
Java
.


Pr√°cticas
de
laboratorio
con
Wireshark


Pr√°ctica
de
laboratorio
con
Wireshark
:
HTTP


En
la
pr√°ctica
de
laboratorio
1
nos
hemos
familiarizado
con
el
husmeador
de
paquetes
(
snif-


fer
)
Wireshark
,
as√≠
que
ya
estamos
preparados
para
utilizar
Wireshark
e
investigar
el
funcio-


PR√ÅCTICAS
DE
LABORATORIO
CON
WIRESHARK
181


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
181182
CAP√çTULO
2
‚Ä¢
LA
CAPA
DE
APLICACI√ìN


namiento
de
los
protocolos
.
En
esta
pr√°ctica
de
laboratorio
exploraremos
varios
aspectos
del


protocolo
HTTP
:
la
interacci√≥n
b√°sica
GET
/
respuesta
,
los
formatos
de
los
mensajes
HTTP
,


la
recuperaci√≥n
de
archivos
HTML
de
gran
tama√±o
,
la
recuperaci√≥n
de
archivos
HTML
con


direcciones
URL
incrustadas
,
las
conexiones
persistentes
y
no
persistentes
,
y
la
autentica-


ci√≥n
y
la
seguridad
de
HTTP
.


Al
igual
que
todas
las
pr√°cticas
de
laboratorio
con
Wireshark
,
la
descripci√≥n
completa


de
esta
pr√°ctica
se
encuentra
en
el
sitio
web
http://www.awl.com/kurose-ross
.


Pr√°ctica
de
laboratorio
con
Wireshark
:
DNS


En
esta
pr√°ctica
de
laboratorio
echaremos
un
r√°pido
vistazo
al
lado
del
cliente
de
DNS
,
el


protocolo
que
traduce
los
nombres
de
host
Internet
en
direcciones
IP
.
Como
hemos
visto
en


la
Secci√≥n
2.5
,
el
papel
del
cliente
en
el
protocolo
DNS
es
relativamente
simple
:
un
cliente


env√≠a
una
consulta
a
su
servidor
DNS
local
y
recibe
una
respuesta
.
Sin
embargo
,
son
muchas


las
cosas
que
suceden
por
debajo
,
invisibles
para
los
clientes
DNS
,
ya
que
los
servidores


DNS
jer√°rquicos
se
comunican
entre
s√≠
de
forma
recursiva
o
iterativa
para
resolver
la
con-


sulta
DNS
del
cliente
.
No
obstante
,
desde
el
punto
de
vista
del
cliente
DNS
,
el
protocolo
es


muy
simple
:
se
plantea
una
consulta
al
servidor
DNS
local
y
dicho
servidor
devuelve
una


respuesta
.
En
esta
pr√°ctica
de
laboratorio
vamos
a
observar
al
protocolo
DNS
en
acci√≥n
.


La
descripci√≥n
completa
de
esta
pr√°ctica
de
laboratorio
est√°
disponible
en
el
sitio
web


del
libro
,
http://www.awl.com/kurose-ross
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
182183


¬ø
C√≥mo
se
le
ocurri√≥
la
idea
de
desarrollar
BitTorrent
?


Ten√≠a
bastante
experiencia
laboral
en
el
campo
de
las
redes
(
protocolos
por
encima
de
TCP
/
UDP
)
y
la


implementaci√≥n
de
aplicaciones
para
comunidades
de
usuarios
me
parec√≠a
el
problema
no
resuelto
m√°s


interesante
que
hab√≠a
planteado
en
ese
momento
,
as√≠
que
decid√≠
dedicarme
a
√©l
.
 

El
c√°lculo
fundamental
en
el
que
se
basa
BitTorrent
es
de
una
naturaleza
muy
trivial
:
hay
una
gran


cantidad
de
capacidad
distribuida
entre
todas
las
computadoras
del
mundo
.
Son
muchas
las
personas


que
tambi√©n
se
fijaron
en
esto
;
pero
llevar
a
cabo
una
implementaci√≥n
que
pudiera
gestionar
adecua-


damente
los
aspectos
log√≠sticos
implicados
en
este
problema
ya
es
algo
completamente
distinto
.


¬ø
Cu√°les
fueron
los
aspectos
m√°s
complicados
del
desarrollo
de
BitTorrent
?


La
parte
fundamental
era
acertar
con
el
dise√±o
global
y
con
los
aspectos
comunitarios
del
protocolo
.


Una
vez
resuelto
ese
aspecto
conceptual
,
el
llevarlo
a
la
pr√°ctica
era
una
‚Äú
simple
cuesti√≥n
de
progra-


maci√≥n
‚Äù
.
En
t√©rminos
de
implementaci√≥n
,
la
parte
m√°s
dif√≠cil
con
mucha
diferencia
fue
implementar


un
sistema
fiable
.
Cuando
se
est√°
tratando
con
pares
(
peers
)
que
no
son
de
confianza
,
es
necesario
asu-


mir
que
cualquiera
de
ellos
puede
hacer
cualquier
cosa
en
cualquier
momento
,
y
es
preciso
definir


alg√∫n
tipo
de
comportamiento
para
todos
los
casos
l√≠mite
.
Tuve
que
continuar
rescribiendo
amplias
sec-


ciones
de
BitTorrent
cuando
lo
estaba
creando
,
a
medida
que
surg√≠an
nuevos
problemas
y
el
dise√±o
glo-


bal
iba
clarific√°ndose
.


Inicialmente
,
¬ø
c√≥mo
descubri√≥
la
gente
BitTorrent
?


En
general
,
la
gente
descubri√≥
BitTorrent
al
dedicarse
a
realizar
descargas
.
Hab√≠a
alg√∫n
tipo
de
conte-


nido
que
deseaban
y
ese
contenido
s√≥lo
estaba
disponible
utilizando
BitTorrent
,
as√≠
que
lo
descargaban


de
esa
forma
.
Los
editores
a
menudo
decid√≠an
utilizar
BitTorrent
simplemente
porque
no
dispon√≠an
del


ancho
de
banda
necesario
para
distribuir
su
contenido
de
ninguna
otra
forma
.


Bram
Cohen


Bram
Cohen
es
Director
Cient√≠fico
y
co-fundador
de
BitTorrent
,
Inc
.
,


as√≠
como
el
creador
del
protocolo
de
distribuci√≥n
de
archivos
P2P


BitTorrent
.
Tambi√©n
es
el
co-fundador
de
CodeCon
y
co-autor
de


Codeville
.
Antes
de
la
creaci√≥n
de
BitTorrent
,
Bram
trabajaba
en


MojoNation
.
MojoNation
permit√≠a
a
los
usuarios
descomponer


archivos
confidenciales
en
fragmentos
cifrados
y
distribuir
esos


fragmentos
a
otras
computadoras
en
las
que
se
estuviera
ejecutando


el
software
de
MojoNation
.
Este
concepto
fue
el
que
inspir√≥
a
Bram


el
desarrollo
de
BitTorrent
.
Antes
de
MojoNation
,
Bram
ya
hab√≠a


estado
inmerso
en
el
mundo
de
las
punto
com
,
trabajando
para


varias
empresas
de
Internet
a
mediados
y
finales
de
la
d√©cada
de


1990
.
Bram
creci√≥
en
Nueva
York
,
se
gradu√≥
en
la
Escuela


Superior
Stuyvesant
y
curs√≥
sus
estudios
en
la
Universidad
de


B√∫falo
.


ENTREVISTA
CON
..
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
183184


¬ø
Podr√≠a
decirnos
qu√©
piensa
acerca
de
las
demandas
legales
planteadas
por
algunas
organizacio-


nes
contra
las
personas
que
utilizan
programas
de
compartici√≥n
de
archivos
como
BitTorrent
,
con


el
fin
de
distribuir
pel√≠culas
y
m√∫sica
?
¬ø
Alguna
vez
le
han
demandado
por
desarrollar
tecnolog√≠as


con
las
que
se
distribuye
ilegalmente
material
sujeto
a
derechos
de
autor
?


La
infracci√≥n
de
los
derechos
de
autor
es
ilegal
,
la
tecnolog√≠a
no
lo
es
.
Nunca
me
ha
demandado
nadie
,


porque
yo
no
he
estado
involucrado
en
ning√∫n
tipo
de
actividad
que
infrinja
los
derechos
de
autor
.
Si


lo
que
te
interesa
es
desarrollar
tecnolog√≠a
,
debes
limitarte
a
los
aspectos
tecnol√≥gicos
.


¬ø
Piensa
que
pueden
aparecer
en
un
futuro
pr√≥ximo
otros
sistemas
de
distribuci√≥n
de
archivos
que


sustituyan
a
BitTorrent
?
Por
ejemplo
,
¬ø
podr√≠a
Microsoft
incluir
su
propio
protocolo
propietario
de


distribuci√≥n
de
archivos
en
una
futura
versi√≥n
de
alg√∫n
sistema
operativo
?


Puede
que
existan
otros
protocolos
comunes
en
el
futuro
,
pero
los
principios
fundamentales
de
c√≥mo


compartir
datos
,
determinados
en
el
protocolo
BitTorrent
,
es
poco
probable
que
cambien
.
La
forma
m√°s


probable
de
que
se
produzca
un
cambio
fundamental
ser√≠a
si
se
produjera
una
modificaci√≥n
significa-


tiva
de
la
estructura
global
de
Internet
,
debida
a
la
variaci√≥n
radical
de
las
relaciones
entre
algunas
de


las
constantes
fundamentales
,
a
medida
que
se
incrementen
las
velocidades
.
Pero
las
predicciones
para


los
pr√≥ximos
a√±os
lo
√∫nico
que
hacen
es
reforzar
a√∫n
m√°s
el
modelo
actual
.


Hablando
en
t√©rminos
m√°s
generales
,
¬ø
a
d√≥nde
cree
que
se
dirige
Internet
?
¬ø
Cu√°les
cree
que
son


o
que
ser√°n
los
desaf√≠os
tecnol√≥gicos
m√°s
importantes
?
¬ø
Puede
ver
alguna
nueva
‚Äú
aplicaci√≥n


estrella
‚Äù
en
el
horizonte
?


Internet
,
y
la
tecnolog√≠a
inform√°tica
en
general
,
est√°
haci√©ndose
cada
vez
m√°s
ubicua
.
El
iPod
nano


puede
ser
uno
de
los
grandes
ganadores
,
especialmente
a
medida
que
vayan
bajando
los
precios
.
El


desaf√≠o
tecnol√≥gico
actual
m√°s
interesante
es
el
de
recopilar
la
mayor
cantidad
posible
de
datos
de


todos
los
dispositivos
conectados
y
hacer
que
esos
datos
est√©n
disponibles
de
una
forma
accesible
y


√∫til
.
Por
ejemplo
,
casi
todos
los
dispositivos
port√°tiles
podr√≠an
incluir
un
mecanismo
GPS
,
y
todos
los


objetos
que
poseemos
,
incluyendo
la
ropa
,
los
juguetes
,
los
electrodom√©sticos
y
los
muebles
,
podr√≠an


decirnos
d√≥nde
est√°n
cuando
los
perdemos
y
proporcionarnos
una
informaci√≥n
completa
de
su
histo-


rial
,
incluyendo
las
operaciones
de
mantenimiento
necesarias
,
la
utilidad
futura
esperada
,
la
detecci√≥n


de
malos
usos
,
etc.
No
s√≥lo
podr√≠amos
obtener
informaci√≥n
acerca
de
nuestras
pertenencias
,
sino
tam-


bi√©n
acerca
de
,
por
ejemplo
,
el
ciclo
de
vida
general
de
un
producto
concreto
;
esta
informaci√≥n
podr√≠a


recopilarse
de
forma
muy
precisa
y
la
coordinaci√≥n
con
otras
personas
ser√≠a
mucho
m√°s
f√°cil
,
lo
que


nos
permitir√≠a
ir
m√°s
all√°
de
esa
mejora
tan
simple
,
pero
tan
fundamental
,
derivada
del
hecho
de
que


ahora
las
personas
pueden
localizarse
f√°cilmente
cuando
todas
ellas
disponen
de
tel√©fonos
m√≥viles
.


¬ø
Qui√©n
le
ha
servido
de
inspiraci√≥n
profesionalmente
?
¬ø
De
qu√©
manera
?


No
me
viene
a
la
mente
ning√∫n
caso
concreto
,
pero
he
seguido
muy
de
cerca
la
mitolog√≠a
general
de


las
empresas
de
nueva
creaci√≥n
en
Silicon
Valley
.


¬ø
Qu√©
consejos
les
dar√≠a
a
los
estudiantes
que
se
inician
en
el
campo
de
las
redes
/
Internet
?


Lo
que
les
dir√≠a
es
que
encuentren
un
tema
que
no
sea
por
el
momento
de
demasiada
actualidad
pero


en
el
que
crean
que
se
pueden
efectuar
desarrollos
atractivos
y
que
ellos
encuentren
personalmente


interesantes
.
Y
que
comiencen
a
trabajar
en
eso
.
Tambi√©n
deben
tratar
de
adquirir
experiencia
profe-


sional
en
el
campo
en
el
que
deseen
trabajar
.
La
experiencia
del
mundo
real
nos
ense√±a
qu√©
es
impor-


tante
en
ese
mundo
y
eso
es
algo
que
casi
nunca
se
puede
apreciar
de
forma
objetiva
cuando
se
miran


las
cosas
desde
dentro
del
mundo
acad√©mico
.


M02_KURO9675_05_SE_CH02.qxd
 
22/3/10
 
08:58
 
P√°gina
184CAP√çTULO
3


La
capa
de


transporte


Entre
las
capas
de
aplicaci√≥n
y
de
red
se
encuentra
la
capa
de
transporte
,
una
pieza
funda-


mental
de
la
arquitectura
de
red
en
capas
.
Desempe√±a
el
papel
cr√≠tico
de
proporcionar
direc-


tamente
servicios
de
comunicaci√≥n
a
los
procesos
de
aplicaci√≥n
que
se
ejecutan
en
hosts


diferentes
.
El
m√©todo
did√°ctico
que
vamos
a
aplicar
a
lo
largo
de
este
cap√≠tulo
va
a
consistir


en
alternar
las
explicaciones
sobre
los
principios
de
la
capa
de
transporte
con
explicaciones


acerca
de
c√≥mo
estos
principios
se
implementan
en
los
protocolos
existentes
;
como
siempre
,


haremos
un
especial
hincapi√©
en
los
protocolos
de
Internet
,
en
particular
en
los
protocolos


de
transporte
TCP
y
UDP
.


Comenzaremos
explicando
la
relaci√≥n
existente
entre
las
capas
de
transporte
y
de
red
.


Para
ello
,
examinaremos
la
primera
funci√≥n
cr√≠tica
de
la
capa
de
transporte
:
ampliar
el
servi-


cio
de
entrega
de
la
capa
de
red
entre
dos
sistemas
terminales
a
un
servicio
de
entrega
entre


dos
procesos
de
la
capa
de
aplicaci√≥n
que
se
ejecutan
en
los
sistemas
terminales
.
Ilustrare-


mos
esta
funci√≥n
con
el
protocolo
de
transporte
sin
conexi√≥n
de
Internet
,
UDP
.


Ac
o
n
t
i
n
u
a
c
i
√≥
n
,
 
v
o
l
v
e
r
e
m
o
s
 
a
 
l
o
s
 
p
r
i
n
c
i
p
i
o
s
 
y
 
a
f
r
o
n
t
a
r
e
m
o
s
 
u
n
o
 
d
e
 
l
o
s
 
p
r
o
b
l
e
m
a
s
 
m
√°
s


importantes
de
las
redes
de
computadoras
:
c√≥mo
dos
entidades
pueden
comunicarse
de


forma
fiable
a
trav√©s
de
un
medio
que
puede
perder
o
corromper
los
datos
.
A
trav√©s
de
una


serie
de
escenarios
cada
vez
m√°s
complejos
(
¬°
y
realistas
!
)
,
construiremos
un
conjunto
de
t√©c-


nicas
que
estos
protocolos
de
transporte
emplean
para
resolver
este
problema
.
Despu√©s
,


mostraremos
c√≥mo
esos
principios
est√°n
integrados
en
TCP
,
el
protocolo
de
transporte
orien-


tado
a
la
conexi√≥n
de
Internet
.


Luego
pasaremos
al
segundo
problema
m√°s
importante
de
las
redes
:
controlar
la
velocidad


de
transmisi√≥n
de
las
entidades
de
la
capa
de
transporte
con
el
fin
de
evitar
,
o
recuperarse
de
,
las


congestiones
que
tienen
lugar
dentro
de
la
red
.
Consideraremos
las
causas
y
las
consecuencias


de
la
congesti√≥n
,
as√≠
como
las
t√©cnicas
de
control
de
congesti√≥n
m√°s
com√∫nmente
utilizadas
.


Una
vez
que
haya
entendido
los
problemas
que
hay
detr√°s
de
los
mecanismos
de
control
de


congesti√≥n
,
estudiaremos
el
m√©todo
que
aplica
TCP
para
controlar
la
congesti√≥n
.


185


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
1853.1
La
capa
de
transporte
y
sus
servicios


En
los
dos
cap√≠tulos
anteriores
hemos
visto
por
encima
cu√°l
es
la
funci√≥n
de
la
capa
de
trans-


porte
,
as√≠
como
los
servicios
que
proporciona
.
Repasemos
r√°pidamente
lo
que
ya
sabemos


acerca
de
la
capa
de
transporte
.


Un
protocolo
de
la
capa
de
transporte
proporciona
una
comunicaci√≥n
l√≥gica
entre
pro-


cesos
de
aplicaci√≥n
que
se
ejecutan
en
hosts
diferentes
.
Por
comunicaci√≥n
l√≥gica
queremos


decir
que
,
desde
la
perspectiva
de
la
aplicaci√≥n
,
es
como
si
los
hosts
que
ejecutan
los
proce-


sos
estuvieran
conectados
directamente
;
en
realidad
,
los
hosts
pueden
encontrarse
en
puntos


opuestos
del
planeta
,
conectados
mediante
numerosos
routers
y
a
trav√©s
de
un
amplio
rango


de
tipos
de
enlace
.
Los
procesos
de
aplicaci√≥n
utilizan
la
comunicaci√≥n
l√≥gica
proporcio-


nada
por
la
capa
de
transporte
para
enviarse
mensajes
entre
s√≠
,
sin
preocuparse
por
los
deta-


lles
de
la
infraestructura
f√≠sica
utilizada
para
transportar
estos
mensajes
.
La
Figura
3.1
ilustra


el
concepto
de
comunicaci√≥n
l√≥gica
.


Como
se
muestra
en
la
Figura
3.1
,
los
protocolos
de
la
capa
de
transporte
est√°n
imple-


mentados
en
los
sistemas
terminales
,
pero
no
en
los
routers
de
la
red
.
En
el
lado
emisor
,
la


capa
de
transporte
convierte
los
mensajes
que
recibe
procedentes
de
un
proceso
de
aplica-


ci√≥n
emisor
en
paquetes
de
la
capa
de
transporte
,
conocidos
como
segmentos
de
la
capa
de


transporte
en
la
terminolog√≠a
de
Internet
.
Muy
posiblemente
,
esto
se
hace
dividiendo
los


mensajes
de
la
aplicaci√≥n
en
fragmentos
m√°s
peque√±os
y
a√±adiendo
una
cabecera
de
la
capa


de
transporte
a
cada
fragmento
,
con
el
fin
de
crear
el
segmento
de
la
capa
de
transporte
.
A


continuaci√≥n
,
la
capa
de
transporte
pasa
el
segmento
a
la
capa
de
red
del
sistema
terminal


emisor
,
donde
el
segmento
se
encapsula
dentro
de
un
paquete
de
la
capa
de
red
(
un
data-


grama
)
y
se
env√≠a
al
destino
.
Es
importante
destacar
que
los
routers
de
la
red
s√≥lo
act√∫an


sobre
los
campos
correspondientes
a
la
capa
de
red
del
datagrama
;
es
decir
,
no
examinan
los


campos
del
segmento
de
la
capa
de
transporte
encapsulado
en
el
datagrama
.
En
el
lado


receptor
,
la
capa
de
red
extrae
el
segmento
de
la
capa
de
transporte
del
datagrama
y
lo
sube


a
la
capa
de
transporte
.
A
continuaci√≥n
,
esta
capa
procesa
el
segmento
recibido
,
poniendo


los
datos
del
segmento
a
disposici√≥n
de
la
aplicaci√≥n
de
recepci√≥n
.


Para
las
aplicaciones
de
red
puede
haber
m√°s
de
un
protocolo
de
la
capa
de
transporte


disponible
.
Por
ejemplo
,
Internet
tiene
dos
protocolos
:
TCP
y
UDP
.
Cada
uno
de
estos
pro-


tocolos
proporciona
un
conjunto
diferente
de
servicios
para
la
capa
de
transporte
a
la
aplica-


ci√≥n
que
lo
haya
invocado
.


3.1.1
Relaciones
entre
las
capas
de
transporte
y
de
red


Recuerde
que
la
capa
de
transporte
se
encuentra
justo
encima
de
la
capa
de
red
dentro
de
la


pila
de
protocolos
.
Mientras
que
un
protocolo
de
la
capa
de
transporte
proporciona
una


comunicaci√≥n
l√≥gica
entre
procesos
que
se
ejecutan
en
hosts
diferentes
,
un
protocolo
de
la


capa
de
red
proporciona
una
comunicaci√≥n
l√≥gica
entre
hosts
.
E
s
t
a
 
d
i
s
t
i
n
c
i
√≥
n
 
e
s
 
s
u
t
i
l
,
 
p
e
r
o


importante
.
Examinemos
esta
distinci√≥n
con
la
ayuda
de
una
analog√≠a
.


Considere
dos
viviendas
,
una
situada
en
la
costa
este
de
Estados
Unidos
y
otra
en
la


costa
oeste
,
y
que
en
cada
hogar
viven
una
docena
de
ni√±os
.
Los
ni√±os
de
la
costa
este
son


primos
de
los
ni√±os
de
la
costa
oeste
.
A
todos
los
ni√±os
les
gusta
escribirse
,
y
cada
ni√±o


escribe
a
todos
sus
primos
todas
las
semanas
,
enviando
una
carta
a
trav√©s
del
servicio
postal


ordinario
para
cada
uno
de
ellos
y
empleando
un
sobre
para
cada
uno
.
As√≠
,
cada
casa
env√≠a


144
cartas
a
la
otra
casa
cada
semana
(
estos
ni√±os
podr√≠an
ahorrar
mucho
dinero
si
utilizaran


186
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
1863.1
‚Ä¢
LA
CAPA
DE
TRANSPORTE
Y
SUS
SERVICIOS
187


ISP
nacional


o
globalRed


m√≥vil


ISP
local


o
regional


Red
empresarial


Red
dom√©sticaTransporte
terminal
a
terminal
l√≥gicoRed


Enlace
de
datos


F√≠sica


Aplicaci√≥n


Transporte


Red


Enlace
de
datos


F√≠sica


Aplicaci√≥n


Transporte


Red


Enlace
de
datos


F√≠sica


Red


Enlace
de
datos


F√≠sica


Red


Enlace
de
datos


F√≠sica


Red


Enlace
de
datos


F√≠sica


Red


Enlace
de
datos


F√≠sica


Figura
3.1
‚Ä¢
La
capa
de
transporte
proporciona
una
comunicaci√≥n
l√≥gica
en


lugar
de
f√≠sica
entre
los
procesos
de
aplicaci√≥n
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
187el
correo
electr√≥nico
)
.
En
cada
uno
de
los
hogares
,
hay
un
ni√±o
(
Ann
en
la
costa
oeste
y
Bill


en
la
costa
este
)
responsable
de
recoger
y
distribuir
el
correo
.
Todas
las
semanas
,
Ann
visita


a
sus
hermanos
y
hermanas
,
les
recoge
el
correo
y
lo
entrega
a
la
persona
del
servicio
postal


que
pasa
a
diario
por
su
casa
.
Cuando
las
cartas
llegan
al
hogar
de
la
costa
oeste
,
Ann
tam-


bi√©n
se
ocupa
de
distribuir
el
correo
al
resto
de
sus
hermanos
y
hermanas
.
Bill
hace
el
mismo


trabajo
que
Ann
en
la
costa
este
.


En
este
ejemplo
,
el
servicio
postal
proporciona
una
comunicaci√≥n
l√≥gica
entre
las
dos


casas
(
el
servicio
postal
lleva
el
correo
de
una
casa
a
la
otra
,
no
de
una
persona
a
otra
)
.
Por


otro
lado
,
Ann
y
Bill
proporcionan
una
comunicaci√≥n
l√≥gica
entre
los
primos
(
recogen
el


correo
y
se
lo
entregan
a
sus
hermanos
)
.
Observe
que
desde
la
perspectiva
de
los
primos
,


Ann
y
Bill
son
el
servicio
de
correo
,
aun
siendo
ambos
solamente
una
parte
(
el
sistema
ter-


minal
)
del
proceso
de
entrega
terminal
a
terminal
.
Este
ejemplo
dom√©stico
es
una
sencilla


analog√≠a
que
nos
permite
explicar
c√≥mo
se
relaciona
la
capa
de
transporte
con
la
capa
de
red
:


mensajes
de
la
aplicaci√≥n
=
las
cartas
introducidas
en
los
sobres


procesos
=
los
primos


hosts
(
tambi√©n
denominados
sistemas
terminales
)
=
las
casas


protocolo
de
la
capa
de
transporte
=
Ann
y
Bill


protocolo
de
la
capa
de
red
=
el
servicio
postal
(
incluyendo
a
los
carteros
)


Continuando
con
esta
analog√≠a
,
f√≠jese
en
que
Ann
y
Bill
hacen
su
trabajo
dentro
de
sus


respectivas
casas
;
es
decir
,
no
est√°n
implicados
,
por
ejemplo
,
en
el
proceso
de
ordenaci√≥n


del
correo
en
una
oficina
de
correos
intermedia
,
ni
tampoco
trasladan
el
correo
de
una
ofi-


cina
a
otra
.
De
manera
similar
,
los
protocolos
de
la
capa
de
transporte
residen
en
los
siste-


mas
terminales
.
Dentro
de
un
sistema
terminal
,
el
protocolo
de
transporte
lleva
los
mensajes


desde
los
procesos
de
la
aplicaci√≥n
a
la
frontera
de
la
red
(
es
decir
,
a
la
capa
de
red
)
y
vice-


versa
,
pero
no
tiene
nada
que
ver
con
c√≥mo
se
transmiten
los
mensajes
dentro
del
n√∫cleo
de


la
red
.
De
hecho
,
como
se
ilustra
en
la
Figura
3.1
,
los
routers
intermedios
ni
act√∫an
sobre
la


informaci√≥n
que
la
capa
de
transporte
pueda
a√±adir
a
los
mensajes
de
la
aplicaci√≥n
ni
tam-


poco
la
reconocen
.


Suponga
ahora
que
Ann
y
Bill
se
van
de
vacaciones
y
que
otra
pareja
de
primos
,
por


ejemplo
,
Susan
y
Harvey
,
les
sustituyen
y
son
los
que
recogen
y
reparten
el
correo
en
sus


respectivas
casas
.
Lamentablemente
para
las
dos
familias
,
Susan
y
Harvey
no
recogen
y


reparten
el
correo
de
la
misma
forma
que
lo
hac√≠an
Ann
y
Bill
.
Al
ser
m√°s
peque√±os
,
Susan


y
Harvey
recogen
y
entregan
el
correo
menos
frecuentemente
y
,
ocasionalmente
,
pierden


algunas
cartas
(
que
a
veces
se
come
el
perro
)
.
Por
tanto
,
la
pareja
de
primos
Susan
y
Harvey


no
proporcionan
el
mismo
conjunto
de
servicios
(
es
decir
,
el
mismo
modelo
de
servicio
)
que


Ann
y
Bill
.
De
forma
an√°loga
,
una
red
de
computadoras
puede
emplear
distintos
protocolos


de
transporte
,
ofreciendo
cada
uno
de
ellos
un
modelo
de
servicio
distinto
a
las
aplicaciones
.


Los
posibles
servicios
que
Ann
y
Bill
pueden
proporcionar
est√°n
evidentemente
restrin-


gidos
por
los
posibles
servicios
que
el
servicio
postal
suministra
.
Por
ejemplo
,
si
el
servicio


postal
no
especifica
el
tiempo
m√°ximo
que
se
puede
tardar
en
entregar
el
correo
entre
ambos


hogares
(
por
ejemplo
,
tres
d√≠as
)
,
entonces
Ann
y
Bill
no
tienen
ninguna
forma
de
garantizar


un
retardo
m√°ximo
en
la
entrega
del
correo
entre
cualquier
pareja
de
primos
.
Del
mismo


modo
,
los
servicios
que
un
protocolo
de
transporte
puede
proporcionar
a
menudo
est√°n
res-


tringidos
por
el
modelo
de
servicio
del
protocolo
de
la
capa
de
red
subyacente
.
Si
el
proto-


colo
de
la
capa
de
red
no
proporciona
garant√≠as
acerca
del
retardo
ni
del
ancho
de
banda
para


los
segmentos
de
la
capa
de
transporte
enviados
entre
hosts
,
entonces
el
protocolo
de
la
capa


188
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
188de
transporte
no
puede
proporcionar
ninguna
garant√≠a
acerca
del
retardo
o
del
ancho
de


banda
a
los
mensajes
de
aplicaci√≥n
enviados
entre
procesos
.


No
obstante
,
el
protocolo
de
transporte
puede
ofrecer
ciertos
servicios
incluso
cuando


el
protocolo
de
red
subyacente
no
ofrezca
el
servicio
correspondiente
en
la
capa
de
red
.
Por


ejemplo
,
como
veremos
m√°s
adelante
en
el
cap√≠tulo
,
un
protocolo
de
transporte
puede
ofre-


cer
un
servicio
de
transferencia
de
datos
fiable
a
una
aplicaci√≥n
,
incluso
si
el
protocolo
de


red
subyacente
no
es
fiable
;
es
decir
,
incluso
si
el
protocolo
de
red
pierde
,
altera
o
duplica


paquetes
.
Otro
ejemplo
,
que
examinaremos
en
el
Cap√≠tulo
8
cuando
hablemos
de
la
seguri-


dad
de
la
red
,
es
que
un
protocolo
de
transporte
puede
emplear
mecanismos
de
cifrado
para


garantizar
que
los
mensajes
de
una
aplicaci√≥n
no
sean
le√≠dos
por
intrusos
,
incluso
aunque
la


capa
de
red
no
pueda
garantizar
la
privacidad
de
los
segmentos
de
la
capa
de
transporte
.


3.1.2
La
capa
de
transporte
en
Internet


Recuerde
que
Internet
y
,
de
forma
m√°s
general
,
las
redes
TCP
/
IP
,
ponen
a
disposici√≥n
de
la


capa
de
aplicaci√≥n
dos
protocolos
de
la
capa
de
transporte
diferentes
.
Uno
de
estos
proto-


colos
es
el
Protocolo
de
datagramas
de
usuario
(
UDP
,
User
Datagram
Protocol
)
,
que
pro-


porciona
un
servicio
sin
conexi√≥n
no
fiable
a
la
aplicaci√≥n
que
le
invoca
.
El
segundo
de


estos
protocolos
es
el
Protocolo
de
control
de
transmisi√≥n
(
TCP
,
Transmission
Control


Protocol
)
,
que
proporciona
a
la
aplicaci√≥n
que
le
invoca
un
servicio
orientado
a
la
cone-


xi√≥n
fiable
.
Al
dise√±ar
una
aplicaci√≥n
de
red
,
el
desarrollador
tiene
que
especificar
el
uso


de
uno
de
estos
dos
protocolos
de
transporte
.
Como
hemos
visto
en
las
Secciones
2.7
y
2.8
,


el
desarrollador
de
la
aplicaci√≥n
elige
entre
UDP
y
TCP
cuando
crea
los
sockets
.


Para
simplificar
la
terminolog√≠a
,
en
el
contexto
de
Internet
nos
referiremos
a
los
paque-


tes
de
la
capa
de
transporte
como
segmentos
.
No
obstante
,
tenemos
que
decir
que
,
en
textos


dedicados
a
Internet
,
como
por
ejemplo
los
RFC
,
tambi√©n
se
emplea
el
t√©rmino
segmento


para
hacer
referencia
a
los
paquetes
de
la
capa
de
transporte
en
el
caso
de
TCP
,
pero
a


menudo
a
los
paquetes
de
UDP
se
les
denomina
datagrama
.
Pero
resulta
que
estos
mismos


textos
dedicados
a
Internet
tambi√©n
utilizan
el
t√©rmino
datagrama
para
referirse
a
los


paquetes
de
la
capa
de
red
.
Por
tanto
,
pensamos
que
en
un
libro
de
introducci√≥n
a
las
redes


de
computadoras
como
√©ste
,
resultar√°
menos
confuso
hablar
de
segmentos
tanto
para
refe-


rirse
a
los
paquetes
TCP
como
UDP
,
y
reservar
el
t√©rmino
datagrama
para
los
paquetes
de
la


capa
de
red
.


Antes
de
continuar
con
esta
breve
introducci√≥n
a
los
protocolos
UDP
y
TCP
,
nos
ser√°
√∫til


comentar
algunas
cosas
acerca
de
la
capa
de
red
de
Internet
(
en
el
Cap√≠tulo
4
examinaremos


en
detalle
la
capa
de
red
)
.
El
protocolo
de
la
capa
de
red
de
Internet
es
el
protocolo
IP
(
Inter-


net
Protocol
)
.
IP
proporciona
una
comunicaci√≥n
l√≥gica
entre
hosts
.
El
modelo
de
servicio
de


IP
es
un
servicio
de
entrega
de
mejor
esfuerzo
(
best
effort
)
.
Esto
quiere
decir
que
IP
hace


todo
lo
que
puede
por
entregar
los
segmentos
entre
los
hosts
que
se
est√°n
comunicando
,
pero


no
garantiza
la
entrega
.
En
particular
,
no
garantiza
la
entrega
de
los
segmentos
,
no
garantiza


que
los
segmentos
se
entreguen
en
orden
y
no
garantiza
la
integridad
de
los
datos
contenidos


en
los
segmentos
.
Por
estas
razones
,
se
dice
que
IP
es
un
servicio
no
fiable
.
Adem√°s
,
sabe-


mos
que
todos
los
hosts
tienen
al
menos
una
direcci√≥n
de
capa
de
red
,
que
se
conoce
como


direcci√≥n
IP
.
En
el
Cap√≠tulo
4
se
estudia
en
detalle
el
direccionamiento
IP
,
pero
por
el


momento
lo
√∫nico
que
necesitamos
saber
es
que
todo
host
tiene
una
direcci√≥n
IP
asociada
.


Despu√©s
de
haber
echado
una
ojeada
al
modelo
de
servicio
de
IP
,
haremos
un
breve


resumen
de
los
modelos
de
servicio
proporcionados
por
UDP
y
TCP
.
La
responsabilidad


3.1
‚Ä¢
LA
CAPA
DE
TRANSPORTE
Y
SUS
SERVICIOS
189


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
189principal
de
UDP
y
TCP
es
ampliar
el
servicio
de
entrega
de
IP
entre
dos
sistemas
termina-


les
a
un
servicio
de
entrega
entre
dos
procesos
que
est√©n
ejecut√°ndose
en
los
sistemas
termi-


nales
.
Extender
la
entrega
host
a
host
a
una
entrega
proceso
a
proceso
es
lo
que
se
denomina


multiplexaci√≥n
y
demultiplexaci√≥n
de
la
capa
de
transporte
,
tema
que
desarrollaremos


en
la
siguiente
secci√≥n
.
UDP
y
TCP
tambi√©n
proporcionan
servicios
de
comprobaci√≥n
de
la


integridad
de
los
datos
al
incluir
campos
de
detecci√≥n
de
errores
en
las
cabeceras
de
sus
seg-


mentos
.
Estos
dos
servicios
de
la
capa
de
transporte
(
entrega
de
datos
proceso
a
proceso
y


comprobaci√≥n
de
errores
)
son
los
dos
√∫nicos
servicios
que
ofrece
UDP
.
En
particular
,
al


igual
que
IP
,
UDP
es
un
servicio
no
fiable
,
que
no
garantiza
que
los
datos
enviados
por
un


proceso
lleguen
intactos
(
¬°
o
que
ni
siquiera
lleguen
!
)
al
proceso
de
destino
.
En
la
Secci√≥n


3.3
se
aborda
en
detalle
el
protocolo
UDP
.


TCP
,
por
el
contrario
,
ofrece
a
las
aplicaciones
varios
servicios
adicionales
.
El
primero


y
m√°s
importante
es
que
proporciona
una
transferencia
de
datos
fiable
.
Utilizando
t√©cnicas


de
control
de
flujo
,
n√∫meros
de
secuencia
,
mensajes
de
reconocimiento
y
temporizadores


(
t√©cnicas
que
estudiaremos
en
detalle
en
este
cap√≠tulo
)
,
TCP
garantiza
que
los
datos
transmi-


tidos
por
el
proceso
emisor
sean
entregados
al
proceso
receptor
,
correctamente
y
en
orden
.


De
este
modo
,
TCP
convierte
el
servicio
no
fiable
de
IP
entre
sistemas
terminales
en
un
ser-


vicio
de
transporte
de
datos
fiable
entre
procesos
.
TCP
tambi√©n
proporciona
mecanismos
de


control
de
congesti√≥n
.
El
control
de
congesti√≥n
no
es
tanto
un
servicio
proporcionado
a
la


aplicaci√≥n
invocante
,
cuanto
un
servicio
que
se
presta
a
Internet
como
un
todo
,
un
servicio


para
el
bien
com√∫n
.
En
otras
palabras
,
los
mecanismos
de
control
de
congesti√≥n
de
TCP
evi-


tan
que
cualquier
conexi√≥n
TCP
inunde
con
una
cantidad
de
tr√°fico
excesiva
los
enlaces
y


routers
existentes
entre
los
hosts
que
est√°n
comunic√°ndose
.
TCP
se
esfuerza
en
proporcionar


a
cada
conexi√≥n
que
atraviesa
un
enlace
congestionado
la
misma
cuota
de
ancho
de
banda


del
enlace
.
Esto
se
consigue
regulando
la
velocidad
a
la
que
los
lados
emisores
de
las
cone-


xiones
TCP
pueden
enviar
tr√°fico
a
la
red
.
El
tr√°fico
UDP
,
por
el
contrario
,
no
est√°
regulado
.


Una
aplicaci√≥n
que
emplee
el
protocolo
de
transporte
UDP
puede
enviar
los
datos
a
la
velo-


cidad
que
le
parezca
,
durante
todo
el
tiempo
que
quiera
.


Un
protocolo
que
proporciona
una
transferencia
de
datos
fiable
y
mecanismos
de
con-


trol
de
congesti√≥n
necesariamente
es
un
protocolo
complejo
.
Vamos
a
necesitar
varias
sec-


ciones
de
este
cap√≠tulo
para
examinar
los
principios
de
la
transferencia
de
datos
fiable
y
el


control
de
congesti√≥n
,
adem√°s
de
otras
secciones
adicionales
dedicadas
a
cubrir
el
propio


protocolo
TCP
.
Estos
temas
se
tratan
en
las
Secciones
3.4
a
3.8
.
El
m√©todo
de
trabajo
que


hemos
adoptado
en
este
cap√≠tulo
es
el
de
alternar
entre
los
principios
b√°sicos
y
el
protocolo


TCP
.
Por
ejemplo
,
en
primer
lugar
veremos
en
qu√©
consiste
en
general
una
transferencia
de


datos
fiable
y
luego
veremos
espec√≠ficamente
c√≥mo
TCP
proporciona
ese
servicio
de
trans-


ferencia
de
datos
fiable
.
De
forma
similar
,
primero
definiremos
de
forma
general
en
qu√©


consiste
el
mecanismo
de
control
de
congesti√≥n
y
luego
veremos
c√≥mo
lo
hace
TCP
.
Pero


antes
de
entrar
en
estos
temas
,
veamos
qu√©
es
la
multiplexaci√≥n
y
la
demultiplexaci√≥n
de
la


capa
de
transporte
.


3.2
Multiplexaci√≥n
y
demultiplexaci√≥n


En
esta
secci√≥n
vamos
a
estudiar
la
multiplexaci√≥n
y
demultiplexaci√≥n
de
la
capa
de
trans-


porte
;
es
decir
,
la
ampliaci√≥n
del
servicio
de
entrega
host
a
host
proporcionado
por
la
capa


de
red
a
un
servicio
de
entrega
proceso
a
proceso
para
las
aplicaciones
que
se
ejecutan
en


190
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
190Figura
3.2
‚Ä¢
Multiplexaci√≥n
y
demultiplexaci√≥n
en
la
capa
de
transporte
.


los
hosts
.
Con
el
fin
de
centrar
la
explicaci√≥n
,
vamos
a
ver
este
servicio
b√°sico
de
la
capa
de


transporte
en
el
contexto
de
Internet
.
Sin
embargo
,
hay
que
destacar
que
un
servicio
de
mul-


tiplexaci√≥n
/
demultiplexaci√≥n
es
necesario
en
todas
las
redes
de
computadoras
.


En
el
host
de
destino
,
la
capa
de
transporte
recibe
segmentos
procedentes
de
la
capa
de


red
que
tiene
justo
debajo
.
La
capa
de
transporte
tiene
la
responsabilidad
de
entregar
los


datos
contenidos
en
estos
segmentos
al
proceso
de
la
aplicaci√≥n
apropiada
que
est√°
ejecu-


t√°ndose
en
el
host
.
Veamos
un
ejemplo
.
Suponga
que
est√°
sentado
frente
a
su
computadora
y


que
est√°
descargando
p√°ginas
web
a
la
vez
que
ejecuta
una
sesi√≥n
FTP
y
dos
sesiones
Tel-


net
.
Por
tanto
,
tiene
cuatro
procesos
de
aplicaci√≥n
de
red
en
ejecuci√≥n
:
dos
procesos
Telnet
,


un
proceso
FTP
y
un
proceso
HTTP
.
Cuando
la
capa
de
transporte
de
su
computadora
recibe


datos
procedentes
de
la
capa
de
red
,
tiene
que
dirigir
los
datos
recibidos
a
uno
de
estos
cua-


tro
procesos
.
Veamos
c√≥mo
hace
esto
.


En
primer
lugar
,
recordemos
de
las
Secciones
2.7
y
2.8
que
un
proceso
(
como
parte
de


una
aplicaci√≥n
de
red
)
puede
tener
uno
o
m√°s
sockets
,
puertas
por
las
que
pasan
los
datos


de
la
red
al
proceso
,
y
viceversa
.
Por
tanto
,
como
se
muestra
en
la
Figura
3.2
,
la
capa
de


transporte
del
host
receptor
realmente
no
entrega
los
datos
directamente
a
un
proceso
,
sino
a


un
socket
intermedio
.
Dado
que
en
cualquier
instante
puede
haber
m√°s
de
un
socket
en
el


host
receptor
,
cada
socket
tiene
asociado
un
identificador
√∫nico
.
El
formato
de
este
identifi-


cador
depende
de
si
se
trata
de
un
socket
UDP
o
de
un
socket
TCP
,
como
vamos
a
ver
a
con-


tinuaci√≥n
.


Veamos
ahora
c√≥mo
un
host
receptor
dirige
un
segmento
de
entrada
de
la
capa
de
trans-


porte
al
socket
apropiado
.
Cada
segmento
de
la
capa
de
transporte
contiene
un
conjunto
de


campos
destinados
a
este
prop√≥sito
.
En
el
extremo
receptor
,
la
capa
de
transporte
examina


estos
campos
para
identificar
el
socket
receptor
y
,
a
continuaci√≥n
,
env√≠a
el
segmento
a
dicho


socket
.
Esta
tarea
de
entregar
los
datos
contenidos
en
un
segmento
de
la
capa
de
transporte


al
socket
correcto
es
lo
que
se
denomina
demultiplexaci√≥n
.
La
tarea
de
reunir
los
fragmen-


tos
de
datos
en
el
host
de
origen
desde
los
diferentes
sockets
,
encapsulando
cada
frag-


mento
de
datos
con
la
informaci√≥n
de
cabecera
(
la
cual
se
utilizar√°
despu√©s
en
el
proceso
de


3.2
‚Ä¢
MULTIPLEXACI√ìN
Y
DEMULTIPLEXACI√ìN
191


Red


Clave
:


Proceso
Socket


Enlace
de
datos


F√≠sica


Transporte


Aplicaci√≥n


Red


Aplicaci√≥n


Enlace
de
datos


F√≠sica


Transporte


Red


Enlace
de
datos


F√≠sica


Transporte


P3
P2P1
P4
Aplicaci√≥n


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
191Figura
3.3
‚Ä¢
Los
campos
n√∫mero
de
puerto
de
origen
y
de
destino
en
un


segmento
de
la
capa
de
transporte
.


demultiplexaci√≥n
)
para
crear
los
segmentos
y
pasarlos
a
la
capa
de
red
es
lo
que
se
deno-


mina
multiplexaci√≥n
.
Observe
que
la
capa
de
transporte
del
host
intermedio
de
la
Figura


3.2
tiene
que
demultiplexar
los
segmentos
que
llegan
de
la
capa
de
red
inferior
para
entre-


g√°rselos
a
los
procesos
P
1
o
P2
de
la
capa
superior
;
esto
se
hace
dirigiendo
los
datos
del
seg-


mento
entrante
al
correspondiente
socket
del
proceso
.
La
capa
de
transporte
del
host


intermedio
tambi√©n
tiene
que
recopilar
los
datos
salientes
desde
estos
sockets
,
construir
los


segmentos
de
la
capa
de
transporte
y
pasar
dichos
segmentos
a
la
capa
de
red
.
Aunque


hemos
presentado
la
multiplexaci√≥n
y
la
demultiplexaci√≥n
en
el
contexto
de
los
protocolos


de
transporte
de
Internet
,
es
importante
darse
cuenta
de
que
esas
t√©cnicas
son
necesarias


siempre
que
 
un
√∫nico
protocolo
en
una
capa
(
en
la
capa
de
transporte
o
cualquier
otra
)
sea


utilizado
por
varios
protocolos
de
la
capa
inmediatamente
superior
.


Para
ilustrar
la
tarea
de
demultiplexaci√≥n
,
recordemos
la
analog√≠a
dom√©stica
de
la
sec-


cion
anterior
.
Cada
uno
de
los
ni√±os
est√°
identificado
por
su
nombre
.
Cuando
Bill
recibe
un


lote
de
cartas
del
servicio
de
correos
,
lleva
a
cabo
una
operaci√≥n
de
demultiplexaci√≥n
al


determinar
a
qui√©n
van
dirigidas
las
cartas
y
luego
las
entrega
en
mano
a
sus
hermanos
.
Ann


lleva
a
cabo
una
operaci√≥n
de
multiplexaci√≥n
al
recopilar
las
cartas
de
sus
hermanos
y
entre-


gar
todas
las
cartas
al
cartero
.


Ahora
que
ya
entendemos
las
funciones
de
multiplexaci√≥n
y
demultiplexaci√≥n
de
la


capa
de
transporte
,
vamos
a
examinar
c√≥mo
se
hace
esto
realmente
en
un
host
.
Bas√°ndonos


en
las
explicaciones
anteriores
,
sabemos
que
la
operaci√≥n
de
multiplexaci√≥n
que
se
lleva
a


cabo
en
la
capa
de
transporte
requiere
(
1
)
que
los
sockets
tengan
identificadores
√∫nicos
y


(
2
)
que
cada
segmento
tenga
campos
especiales
que
indiquen
el
socket
al
que
tiene
que


entregarse
el
segmento
.
Estos
campos
especiales
,
mostrados
en
la
Figura
3.3
,
son
el
campo


n√∫mero
de
puerto
de
origen
y
el
campo
n√∫mero
de
puerto
de
destino
.
(
Los
segmentos


UDP
y
TCP
contienen
adem√°s
otros
campos
,
como
veremos
en
las
siguientes
secciones
del


cap√≠tulo
.
)
Cada
n√∫mero
de
puerto
es
un
n√∫mero
de
16
bits
comprendido
en
el
rango
de
0
a


65535
.
Los
n√∫meros
de
puerto
pertenecientes
al
rango
de
0
a
1023
se
conocen
como


n√∫meros
de
puertos
bien
conocidos
y
son
restringidos
,
lo
que
significa
que
est√°n
reserva-


dos
para
ser
empleados
por
los
protocolos
de
aplicaci√≥n
bien
conocidos
,
como
por
ejemplo


HTTP
(
que
utiliza
el
n√∫mero
de
puerto
80
)
y
FTP
(
que
utiliza
el
n√∫mero
de
puerto
21
)
.


Puede
encontrar
la
lista
de
n√∫meros
de
puerto
bien
conocidos
en
el
documento
RFC
1700
y


su
actualizaci√≥n
en
la
direcci√≥n
http://www.iana.org
[
RFC
3232
]
.
Al
desarrollar
una
nueva


N¬∫
de
puerto


de
origen


32
bits


N¬∫
de
puerto


de
destino


Otros
campos
de
cabecera


Datos
de


la
aplicaci√≥n


(
mensaje
)


192
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
192aplicaci√≥n
(
como
las
aplicaciones
desarrolladas
en
las
Secciones
2.7
y
2.8
)
,
es
necesario


asignar
un
n√∫mero
de
puerto
a
la
aplicaci√≥n
.


Ahora
ya
deber√≠a
estar
claro
c√≥mo
la
capa
de
transporte
podr√≠a
implementar
el
servicio


de
demultiplexaci√≥n
:
cada
socket
del
host
se
puede
asignar
a
un
n√∫mero
de
puerto
y
,
al
llegar


un
segmento
al
host
,
la
capa
de
transporte
examina
el
n√∫mero
de
puerto
de
destino
contenido


en
el
segmento
y
lo
env√≠a
al
socket
correspondiente
.
A
continuaci√≥n
,
los
datos
del
segmento


pasan
a
trav√©s
del
socket
y
se
entregan
al
proceso
asociado
.
Como
veremos
,
esto
es
b√°sica-


mente
lo
que
hace
UDP
.
Sin
embargo
,
tambi√©n
comprobaremos
que
la
tarea
de
multiplexa-


ci√≥n
/
demultiplexaci√≥n
en
TCP
es
m√°s
sutil
.


Multiplexaci√≥n
y
demultiplexaci√≥n
sin
conexi√≥n


Recordemos
de
la
Secci√≥n
2.8
que
un
programa
Java
que
se
ejecuta
en
un
host
puede
crear


un
socket
UDP
mediante
la
l√≠nea
de
c√≥digo
:


DatagramSocket
miSocket
=
new
DatagramSocket
(
)
;


Cuando
se
crea
un
socket
UDP
de
este
modo
,
la
capa
de
transporte
asigna
autom√°ticamente


un
n√∫mero
de
puerto
al
socket
.
En
particular
,
la
capa
de
transporte
asigna
un
n√∫mero
de


puerto
comprendido
en
el
rango
de
1024
a
65535
que
actualmente
no
est√©
siendo
utilizado


en
ese
host
por
ning√∫n
otro
puerto
UDP
.
Alternativamente
,
un
programa
Java
podr√≠a
crear


un
socket
ejecutando
la
l√≠nea
de
c√≥digo
:


DatagramSocket
miSocket
=
new
DatagramSocket(19157
)
;


En
este
caso
,
la
aplicaci√≥n
asigna
un
n√∫mero
de
puerto
espec√≠fico
,
por
ejemplo
,
el
19157
,
al


socket
UDP
.
Si
el
desarrollador
de
la
aplicaci√≥n
que
escribe
el
c√≥digo
estuviera
implemen-


tando
el
lado
del
servidor
de
un
‚Äú
protocolo
bien
conocido
‚Äù
,
entonces
tendr√≠a
que
asignar
el


correspondiente
n√∫mero
de
puerto
bien
conocido
.
Normalmente
,
el
lado
del
cliente
de
la


aplicaci√≥n
permite
a
la
capa
de
transporte
asignar
de
forma
autom√°tica
(
y
transparente
)
el


n√∫mero
de
puerto
,
mientras
que
el
lado
de
servidor
de
la
aplicaci√≥n
asigna
un
n√∫mero
de


puerto
espec√≠fico
.


Una
vez
asignados
los
n√∫meros
de
puerto
a
los
sockets
UDP
,
podemos
describir
de


forma
precisa
las
tareas
de
multiplexaci√≥n
y
demultiplexaci√≥n
en
UDP
.
Suponga
que
un
pro-


ceso
del
host
A
,
con
el
puerto
UDP
19157
,
desea
enviar
un
fragmento
de
datos
de
una
apli-


caci√≥n
a
un
proceso
con
el
puerto
UDP
46428
en
el
host
B.
La
capa
de
transporte
del
host
A


crea
un
segmento
de
la
capa
de
transporte
que
incluye
los
datos
de
aplicaci√≥n
,
el
n√∫mero
de


puerto
de
origen
(
19157
)
,
el
n√∫mero
de
puerto
de
destino
(
46428
)
y
otros
dos
valores
(
que


veremos
m√°s
adelante
,
pero
que
por
el
momento
no
son
importantes
para
el
tema
que
nos


ocupa
)
.
La
capa
de
transporte
pasa
a
continuaci√≥n
el
segmento
resultante
a
la
capa
de
red
.


La
capa
de
red
encapsula
el
segmento
en
un
datagrama
IP
y
hace
el
m√°ximo
esfuerzo
por


entregar
el
segmento
al
host
receptor
.
Si
el
segmento
llega
al
host
receptor
B
,
la
capa
de


transporte
del
mismo
examina
el
n√∫mero
de
puerto
de
destino
especificado
en
el
segmento


(
46428
)
y
entrega
el
segmento
a
su
socket
identificado
por
el
puerto
46428
.
Observe
que
el


host
B
podr√≠a
estar
ejecutando
varios
procesos
,
cada
uno
de
ellos
con
su
propio
socket
UDP


y
n√∫mero
de
puerto
asociado
.
A
medida
que
los
segmentos
UDP
llegan
de
la
red
,
el
host
B


dirige
(
demultiplexa
)
cada
segmento
al
socket
apropiado
examinando
el
n√∫mero
de
puerto


de
destino
del
segmento
.


3.2
‚Ä¢
MULTIPLEXACI√ìN
Y
DEMULTIPLEXACI√ìN
193


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
193Figura
3.4
‚Ä¢
Inversi√≥n
de
los
n√∫meros
de
puerto
de
origen
y
de
destino
.


Es
importante
observar
que
un
socket
UDP
queda
completamente
identificado
por
una


tupla
que
consta
de
una
direcci√≥n
IP
de
destino
y
un
n√∫mero
de
puerto
de
destino
.
En
conse-


cuencia
,
si
dos
segmentos
UDP
tienen
diferentes
direcciones
IP
y
/
o
n√∫meros
de
puerto
de


origen
,
pero
la
misma
direcci√≥n
IP
de
destino
y
el
mismo
n√∫mero
puerto
de
destino
,
enton-


ces
los
dos
segmentos
se
enviar√°n
al
mismo
proceso
de
destino
a
trav√©s
del
mismo
socket
de


destino
.


Es
posible
que
se
est√©
preguntando
en
este
momento
cu√°l
es
el
prop√≥sito
del
n√∫mero
de


puerto
de
origen
.
Como
se
muestra
en
la
Figura
3.4
,
en
el
segmento
A
a
B
,
el
n√∫mero


de
puerto
de
origen
forma
parte
de
una
‚Äú
direcci√≥n
de
retorno
‚Äù
;
es
decir
,
si
B
desea
devolver


un
segmento
a
A
,
el
puerto
de
destino
en
el
segmento
de
B
a
A
tomar√°
su
valor
del
valor
del


puerto
de
origen
del
segmento
de
A
a
B.
(
La
direcci√≥n
de
retorno
completa
es
el
n√∫mero
de


puerto
de
origen
y
la
direcci√≥n
IP
de
A.
)
Por
ejemplo
,
recuerde
el
programa
de
servidor
UDP


estudiado
en
la
Secci√≥n
2.8
.
En
UDPServer.java
,
el
servidor
utiliza
un
m√©todo
para


extraer
el
n√∫mero
de
puerto
de
origen
del
segmento
que
recibe
del
cliente
;
a
continuaci√≥n
,


env√≠a
un
segmento
nuevo
al
cliente
,
utilizando
como
n√∫mero
de
puerto
de
destino
el
n√∫mero


de
puerto
de
origen
extra√≠do
del
segmento
recibido
.


Multiplexaci√≥n
y
demultiplexaci√≥n
orientadas
a
la
conexi√≥n


Para
entender
la
demultiplexaci√≥n
TCP
,
tenemos
que
tener
en
cuenta
los
sockets
TCP
y
el


establecimiento
de
las
conexiones
TCP
.
Una
sutil
diferencia
entre
un
socket
TCP
y
un
soc-


ket
UDP
es
que
el
primero
queda
identificado
por
una
tupla
de
cuatro
elementos
:
direcci√≥n


IP
de
origen
,
n√∫mero
de
puerto
de
origen
,
direcci√≥n
IP
de
destino
,
n√∫mero
de
puerto
de
des-


tino
.
Por
tanto
,
cuando
un
segmento
TCP
llega
a
un
host
procedente
de
la
red
,
el
host
emplea


los
cuatro
valores
para
dirigir
(
demultiplexar
)
el
segmento
al
socket
apropiado
.
En
particu-


lar
,
y
al
contrario
de
lo
que
ocurre
con
UDP
,
dos
segmentos
TCP
entrantes
con
direcciones


IP
de
origen
o
n√∫meros
de
puerto
de
origen
diferentes
(
con
la
excepci√≥n
de
un
segmento


TCP
que
transporte
la
solicitud
original
de
establecimiento
de
conexi√≥n
)
ser√°n
dirigidos
a


Host
A


Proceso
cliente


Socket


Servidor
B


puerto
de


origen
:
19157


puerto
de


destino
:
46428


puerto
de


origen
:
46428


puerto
de


destino
:
19157


194
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
194dos
sockets
distintos
.
Con
el
fin
de
profundizar
un
poco
,
consideremos
de
nuevo
el
ejemplo


de
programaci√≥n
cliente-servidor
TCP
de
la
Secci√≥n
2.7
:


‚Ä¢L
a
 
a
p
l
i
c
a
c
i
√≥
n
 
d
e
 
s
e
r
v
i
d
o
r
 
T
C
P
t
i
e
n
e
 
u
n
 
‚Äú
s
o
c
k
e
t
 
d
e
 
a
c
o
g
i
d
a
‚Äù
,
 
q
u
e
 
e
s
t
√°
 
a
 
l
a
 
e
s
p
e
r
a
 
d
e
 
l
a
s


solicitudes
de
establecimiento
de
conexi√≥n
procedentes
de
los
clientes
TCP
en
el
puerto


6789
(
v√©ase
la
Figura
 
2.29
)
.


‚Ä¢E
l
 
c
l
i
e
n
t
e
 
T
C
P
g
e
n
e
r
a
 
u
n
 
s
e
g
m
e
n
t
o
 
d
e
 
e
s
t
a
b
l
e
c
i
m
i
e
n
t
o
 
d
e
 
c
o
n
e
x
i
√≥
n
 
c
o
n
 
l
a
 
l
√≠
n
e
a
 
d
e


c√≥digo
:


Socket
socketCliente
=
new
Socket(‚ÄúnombreHostServidor
‚Äù
,
6789
)
;


‚Ä¢U
n
a
 
s
o
l
i
c
i
t
u
d
 
d
e
 
e
s
t
a
b
l
e
c
i
m
i
e
n
t
o
 
d
e
 
c
o
n
e
x
i
√≥
n
 
n
o
 
e
s
 
n
a
d
a
 
m
√°
s
 
q
u
e
 
u
n
 
s
e
g
m
e
n
t
o
 
T
C
P
c
o
n


el
n√∫mero
de
puerto
de
destino
6789
y
un
conjunto
especial
de
bits
de
establecimiento
de


conexi√≥n
en
la
cabecera
TCP
(
que
veremos
en
la
Secci√≥n
3.5
)
.
El
segmento
tambi√©n


incluye
un
n√∫mero
de
puerto
de
origen
,
que
habr√°
sido
seleccionado
por
el
cliente
.
La


l√≠nea
de
c√≥digo
anterior
tambi√©n
crea
un
socket
TCP
para
el
proceso
cliente
a
trav√©s
del


cual
los
datos
pueden
entrar
y
salir
del
proceso
cliente
.


‚Ä¢C
u
a
n
d
o
 
e
l
 
s
i
s
t
e
m
a
 
o
p
e
r
a
t
i
v
o
 
d
e
l
 
h
o
s
t
 
q
u
e
 
e
s
t
√°
 
e
j
e
c
u
t
a
n
d
o
 
e
l
 
p
r
o
c
e
s
o
 
s
e
r
v
i
d
o
r
 
r
e
c
i
b
e
 
e
l


segmento
de
entrada
de
solicitud
de
conexi√≥n
con
el
puerto
de
destino
6789
,
localiza
el


proceso
de
servidor
que
est√°
esperando
para
aceptar
una
conexi√≥n
en
el
n√∫mero
de
puerto


6789
.
El
proceso
de
servidor
crea
entonces
un
nuevo
socket
:


Socket
socketConexion
=
socketAcogida.accept
(
)
;


‚Ä¢A
d
e
m
√°
s
,
 
l
a
 
c
a
p
a
 
d
e
 
t
r
a
n
s
p
o
r
t
e
 
e
n
 
e
l
 
s
e
r
v
i
d
o
r
 
t
o
m
a
 
n
o
t
a
 
d
e
 
l
o
s
 
c
u
a
t
r
o
 
v
a
l
o
r
e
s
 
s
i
g
u
i
e
n
t
e
s


contenidos
en
el
segmento
de
solicitud
de
conexi√≥n
:
(
1
)
el
n√∫mero
de
puerto
de
origen
en


el
segmento
,
(
2
)
la
direcci√≥n
IP
del
host
de
origen
,
(
3
)
el
n√∫mero
de
puerto
de
destino
en


el
segmento
y
(
4
)
su
propia
direcci√≥n
IP
.
El
socket
de
conexi√≥n
reci√©n
creado
queda
iden-


tificado
por
estos
cuatro
valores
;
as√≠
,
todos
los
segmentos
que
lleguen
despu√©s
y
cuyo


puerto
de
origen
,
direcci√≥n
IP
de
origen
,
puerto
de
destino
y
direcci√≥n
IP
de
destino
se


correspondan
con
estos
cuatro
valores
ser√°n
enviados
a
este
socket
.
Una
vez
establecida


la
conexi√≥n
TCP
,
el
cliente
y
el
servidor
podr√°n
enviarse
datos
entre
s√≠
.


El
host
servidor
puede
dar
soporte
a
muchos
sockets
TCP
simult√°neos
,
estando
cada


socket
asociado
a
un
proceso
y
con
cada
socket
identificado
por
su
tupla
de
cuatro
elemen-


tos
.
Cuando
un
segmento
TCP
llega
al
host
,
los
cuatro
campos
(
direcci√≥n
IP
de
origen
,


puerto
de
origen
,
direcci√≥n
IP
de
destino
y
puerto
de
destino
)
se
utilizan
para
dirigir
(
demul-


tiplexar
)
el
segmento
al
socket
apropiado
.


Esta
situaci√≥n
se
ilustra
en
la
Figura
3.5
,
en
la
que
el
host
C
inicia
dos
sesiones
HTTP


con
el
servidor
B
y
el
host
A
inicia
una
sesi√≥n
HTTP
tambi√©n
con
B.
Los
hosts
A
y
C
y
el


servidor
B
tienen
sus
propias
direcciones
IP
√∫nicas
(
A
,
C
y
B
,
respectivamente
)
.
El
host
C


asigna
dos
n√∫meros
de
puerto
de
origen
diferentes
(
26145
y
7532
)
a
sus
dos
conexiones


HTTP
.
Dado
que
el
host
A
est√°
seleccionando
los
n√∫meros
de
puerto
de
origen
independien-


temente
de
C
,
tambi√©n
puede
asignar
el
n√∫mero
de
puerto
de
origen
26145
a
su
conexi√≥n


HTTP
.
Pero
esto
no
es
un
problema
:
el
servidor
B
todav√≠a
podr√°
demultiplexar
correcta-


mente
las
dos
conexiones
con
el
mismo
n√∫mero
de
puerto
de
origen
,
ya
que
tienen
direccio-


nes
IP
de
origen
diferentes
.


3.2
‚Ä¢
MULTIPLEXACI√ìN
Y
DEMULTIPLEXACI√ìN
195


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
195Servidores
web
y
TCP


Antes
de
dar
por
terminada
esta
secci√≥n
,
es
interesante
comentar
algunas
cosas
acerca
de
los


servidores
web
y
de
c√≥mo
utilizan
los
n√∫meros
de
puerto
.
Considere
un
host
que
est√°
ejecu-


tando
un
servidor
web
,
como
por
ejemplo
un
servidor
web
Apache
en
el
puerto
80
.
Cuando


los
clientes
(
por
ejemplo
,
los
navegadores
)
env√≠an
segmentos
al
servidor
,
todos
los
segmen-


tos
tendr√°n
el
puerto
de
destino
80
.
En
particular
,
tanto
los
segmentos
para
el
estableci-


miento
de
la
conexi√≥n
inicial
como
los
segmentos
que
transportan
los
mensajes
de
solicitud


HTTP
utilizar√°n
como
puerto
de
destino
el
puerto
80
.
Como
acabamos
de
describir
,
el
servi-


dor
diferencia
los
segmentos
procedentes
de
los
distintos
clientes
mediante
las
direcciones


IP
de
origen
y
los
n√∫meros
de
puerto
de
origen
.


La
Figura
3.5
nos
muestra
un
servidor
web
que
genera
un
nuevo
proceso
para
cada


conexi√≥n
.
Como
se
muestra
en
esta
figura
,
cada
uno
de
estos
procesos
tiene
su
propio
socket


de
conexi√≥n
a
trav√©s
del
cual
llegan
las
solicitudes
HTTP
y
se
env√≠an
las
respuestas
HTTP
.


Sin
embargo
,
tambi√©n
hemos
mencionado
que
no
existe
siempre
una
correspondencia
uno
a


196
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


EXPLORACI√ìN
DE
PUERTOS


Hemos
visto
que
un
proceso
servidor
espera
pacientemente
en
un
puerto
abierto
a
ser


contactado
por
un
cliente
remoto
.
Algunos
puertos
est√°n
reservados
para
aplicaciones
bien


conocidas
(
como
por
ejemplo
servidores
web
,
FTP
,
DNS
y
SMTP
)
;
otros
puertos
,
por


convenio
,
son
utilizados
por
aplicaciones
populares
(
como
por
ejemplo
Microsoft
2000


SQL
Server
que
est√°
a
la
escucha
en
el
puerto
UDP
1434
)
.
Por
tanto
,
si
determinamos
que


un
puerto
est√°
abierto
en
un
host
,
podemos
ser
capaces
de
hacer
corresponder
dicho
puerto


a
una
aplicaci√≥n
espec√≠fica
que
se
ejecute
en
el
host
.
Esto
es
muy
√∫til
para
los
administrado-


res
de
sistemas
,
ya
que
suelen
estar
interesados
en
saber
qu√©
aplicaciones
de
red
est√°n
eje-


cut√°ndose
en
los
hosts
de
sus
redes
.
Pero
los
atacantes
,
con
el
fin
de
detectar
‚Äú
las
brechas


en
el
muro
‚Äù
,
tambi√©n
desean
saber
qu√©
puertos
est√°n
abiertos
en
los
hosts
objetivo
.
Si
se


localiza
un
host
que
est√°
ejecutando
una
aplicaci√≥n
con
un
defecto
de
seguridad
conocido


(
por
ejemplo
,
si
un
servidor
SQL
que
est√°
a
la
escucha
en
el
puerto
1434
fuera
objeto
de
un


desbordamiento
de
buffer
,
permitiendo
a
un
usuario
remoto
ejecutar
c√≥digo
arbitrario
en
el


host
vulnerable
,
un
defecto
explotado
por
el
gusano
Slammer
[
CERT
2003-04
]
)
,
entonces


dicho
host
estar√≠a
en
condiciones
para
recibir
un
ataque
.


Determinar
qu√©
aplicaciones
est√°n
a
la
escucha
en
qu√©
puertos
es
una
tarea
relativamente


f√°cil
.
Adem√°s
,
existen
numerosos
programas
de
dominio
p√∫blico
,
conocidos
como
esc√°neres


de
puertos
,
que
realizan
este
trabajo
.
Quiz√°
el
m√°s
ampliamente
utilizado
de
estos
progra-


mas
es
nmap
,
que
est√°
disponible
gratuitamente
en
http://insecure.org/nmap
y
se
incluye
en


la
mayor
parte
de
las
distribuciones
de
Linux
.
Para
TCP
,
nmap
explora
secuencialmente
los


puertos
buscando
puertos
que
acepten
conexiones
TCP
.
Para
UDP
,
nmap
tambi√©n
explora


secuencialmente
los
puertos
buscando
puertos
UDP
que
respondan
a
segmentos
UDP
transmiti-


dos
.
En
ambos
casos
,
nmap
devuelve
una
lista
de
puertos
abiertos
,
cerrados
o
inalcanzables
.


Un
host
que
ejecute
nmap
puede
tratar
de
explorar
cualquier
host
objetivo
situado
en
cual-


quier
lugar
de
Internet
.
En
la
Secci√≥n
3.5.6
volveremos
a
hablar
de
nmap
,
al
tratar
la
gesti√≥n


de
las
conexiones
TCP
.


SEGURIDAD


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
196uno
entre
los
sockets
de
conexi√≥n
y
los
procesos
.
De
hecho
,
los
servidores
web
actuales
de


altas
prestaciones
a
menudo
s√≥lo
utilizan
un
proceso
y
crean
una
nueva
hebra
con
un
nuevo


socket
de
conexi√≥n
para
cada
nueva
conexi√≥n
de
un
cliente
(
una
hebra
es
una
especie
de


subproceso
de
baja
complejidad
)
.
Si
realiz√≥
la
primera
tarea
de
programaci√≥n
del
Cap√≠tulo


2
,
habr√°
creado
un
servidor
web
que
hace
exactamente
esto
.
En
un
servidor
as√≠
,
en
cualquier


instante
puede
haber
muchos
sockets
de
conexi√≥n
(
con
distintos
identificadores
)
asociados


al
mismo
proceso
.


Si
el
cliente
y
el
servidor
est√°n
utilizando
HTTP
persistente
,
entonces
mientras
dure
la


conexi√≥n
persistente
el
cliente
y
el
servidor
intercambiar√°n
mensajes
HTTP
a
trav√©s
del


mismo
socket
de
servidor
.
Sin
embargo
,
si
el
cliente
y
el
servidor
emplean
HTTP
no
persis-


tente
,
entonces
se
crear√°
y
cerrar√°
una
nueva
conexi√≥n
TCP
para
cada
pareja
solicitud
/
res-


puesta
y
,
por
tanto
,
se
crear√°
(
y
luego
se
cerrar√°
)
un
nuevo
socket
para
cada
solicitud/


respuesta
.
Esta
creaci√≥n
y
cierre
de
sockets
tan
frecuente
puede
afectar
seriamente
al
rendi-


miento
de
un
servidor
web
ocupado
(
aunque
se
pueden
utilizar
una
serie
de
trucos
del
sis-


tema
operativo
para
mitigar
el
problema
)
.
Los
lectores
interesados
en
los
problemas
que
el


uso
de
HTTP
persistente
y
no
persistente
plantea
a
los
sistemas
operativos
pueden
consul-


tar
[
Nielsen
1997
;
Nahum
2002
]
.


Ahora
que
ya
hemos
visto
en
qu√©
consiste
la
multiplexaci√≥n
y
la
demultiplexaci√≥n
en
la


capa
de
transporte
,
podemos
pasar
a
tratar
uno
de
los
protocolos
de
transporte
de
Internet
:


UDP
.
En
la
siguiente
secci√≥n
veremos
que
UDP
a√±ade
algo
m√°s
al
protocolo
de
la
capa
de


red
que
un
servicio
de
multiplexaci√≥n
/
demultiplexaci√≥n
.


3.2
‚Ä¢
MULTIPLEXACI√ìN
Y
DEMULTIPLEXACI√ìN
197


puerto
de


origen
:
7532


puerto
de


destino
:
80


IP
de
origen
:


C


IP
de
destino
:


B


puerto
de


origen
:
26145


puerto
de


destino
:
80


IP
de
origen
:


C


IP
de
destino
:


B


puerto
de


origen
:
26145


puerto
de


destino
:
80


IP
de
origen
:


A


IP
de
destino
:


B


Procesos


HTTP


por
conexi√≥n


Demultiplexaci√≥n


en
la
capa
de


transporte


Servidor


web
B


Cliente
web


host
C


Cliente
web


host
A


Figura
3.5
‚Ä¢
Dos
clientes
utilizando
el
mismo
n√∫mero
de
puerto
de
destino
(
80
)


para
comunicarse
con
la
misma
aplicaci√≥n
de
servidor
web
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
1973.3
Transporte
sin
conexi√≥n
:
UDP


En
esta
secci√≥n
vamos
a
ocuparnos
de
UDP
,
vamos
a
ver
c√≥mo
funciona
y
qu√©
hace
.
Le


animamos
a
releer
la
Secci√≥n
2.1
,
en
la
que
se
incluye
una
introducci√≥n
al
modelo
de
ser-


vicio
de
UDP
y
la
Secci√≥n
2.8
,
en
la
que
se
explica
la
programaci√≥n
de
sockets
con
UDP
.


Para
iniciar
nuestro
an√°lisis
de
UDP
,
suponga
que
queremos
dise√±ar
un
protocolo
de


transporte
simple
y
poco
sofisticado
.
¬ø
C√≥mo
har√≠amos
esto
?
En
primer
lugar
,
podemos
con-


siderar
la
utilizaci√≥n
de
un
protocolo
de
transporte
vacuo
.
Es
decir
,
en
el
lado
emisor
,
tomar√°


los
mensajes
del
proceso
de
la
aplicaci√≥n
y
los
pasar√°
directamente
a
la
capa
de
red
;
en
el


lado
de
recepci√≥n
,
tomar√°
los
mensajes
procedentes
de
la
capa
de
red
y
los
pasar√°
directa-


mente
al
proceso
de
la
aplicaci√≥n
.
Pero
,
como
hemos
aprendido
en
la
secci√≥n
anterior
,
hay


algunas
cosas
m√≠nimas
que
tenemos
que
hacer
.
Como
m√≠nimo
,
la
capa
de
transporte
tiene


que
proporcionar
un
servicio
de
multiplexaci√≥n
/
demultiplexaci√≥n
que
permita
transferir
los


datos
entre
la
capa
de
red
y
el
proceso
de
la
capa
de
aplicaci√≥n
correcto
.


UDP
,
definido
en
el
documento
[
RFC
768
]
,
hace
casi
lo
m√≠nimo
que
un
protocolo
de


transporte
debe
hacer
.
Adem√°s
de
la
funci√≥n
de
multiplexaci√≥n
/
demultiplexaci√≥n
y
de
alg√∫n


mecanismo
de
comprobaci√≥n
de
errores
,
no
a√±ade
nada
a
IP
.
De
hecho
,
si
el
desarrollador
de


la
aplicaci√≥n
elige
UDP
en
lugar
de
TCP
,
entonces
pr√°cticamente
es
la
aplicaci√≥n
la
que
se


comunica
directamente
con
IP
.
 
UDP
toma
los
mensajes
procedentes
del
proceso
de
la
apli-


caci√≥n
,
asocia
los
campos
correspondientes
a
los
n√∫meros
de
puerto
de
origen
y
de
destino


para
proporcionar
el
servicio
de
multiplexaci√≥n
/
demultiplexaci√≥n
,
a√±ade
dos
campos
peque-


√±os
m√°s
y
pasa
el
segmento
resultante
a
la
capa
de
red
.
La
capa
de
red
encapsula
el
segmento


de
la
capa
de
transporte
en
un
datagrama
IP
y
luego
hace
el
mejor
esfuerzo
por
entregar
el


segmento
al
host
receptor
.
Si
el
segmento
llega
al
host
receptor
,
UDP
utiliza
el
n√∫mero
de


puerto
de
destino
para
entregar
los
datos
del
segmento
al
proceso
apropiado
de
la
capa
de


aplicaci√≥n
.
Observe
que
con
UDP
no
tiene
lugar
una
fase
de
establecimiento
de
la
conexi√≥n


entre
las
entidades
de
la
capa
de
transporte
emisora
y
receptora
previa
al
env√≠o
del
segmento
.


Por
esto
,
se
dice
que
UDP
es
un
protocolo
sin
conexi√≥n
.


DNS
es
un
ejemplo
de
un
protocolo
de
la
capa
de
aplicaci√≥n
que
habitualmente
utiliza


UDP
.
Cuando
la
aplicaci√≥n
DNS
de
un
host
desea
realizar
una
consulta
,
construye
un
men-


saje
de
consulta
DNS
y
lo
pasa
a
UDP
.
Sin
llevar
a
cabo
ning√∫n
proceso
para
establecer
una


conexi√≥n
con
la
entidad
UDP
que
se
ejecuta
en
el
sistema
terminal
de
destino
,
el
protocolo


UDP
del
lado
del
host
a√±ade
campos
de
cabecera
al
mensaje
y
pasa
el
segmento
resultante
a


la
capa
de
red
,
la
cual
encapsula
el
segmento
UDP
en
un
datagrama
y
lo
env√≠a
a
un
servidor


de
nombres
.
La
aplicaci√≥n
DNS
que
se
ejecuta
en
el
host
que
ha
hecho
la
consulta
espera


entonces
hasta
recibir
una
respuesta
a
su
consulta
.
Si
no
la
recibe
(
posiblemente
porque
la


red
subyacente
ha
perdido
la
consulta
o
la
respuesta
)
,
bien
intenta
enviar
la
consulta
a
otro


servidor
de
nombres
o
bien
informa
a
la
aplicaci√≥n
invocante
de
que
no
puede
obtener
una


respuesta
.


Es
posible
que
ahora
se
est√©
preguntando
por
qu√©
un
desarrollador
de
aplicaciones


podr√≠a
decidir
crear
una
aplicaci√≥n
sobre
UDP
en
lugar
de
sobre
TCP
.
¬ø
No
ser√≠a
preferible


emplear
siempre
TCP
,
puesto
que
proporciona
un
servicio
de
transferencia
de
datos
fiable
y


UDP
no
?
La
respuesta
es
no
,
ya
que
muchas
aplicaciones
est√°n
mejor
adaptadas
a
UDP
por


las
siguientes
razones
:


‚Ä¢
Mejor
control
en
el
nivel
de
aplicaci√≥n
sobre
qu√©
datos
se
env√≠an
y
cu√°ndo
.
Con
 
UDP
,


tan
pronto
como
un
proceso
de
la
capa
de
aplicaci√≥n
pasa
datos
a
UDP
,
UDP
los
empa-


198
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
198queta
en
un
segmento
UDP
e
inmediatamente
entrega
el
segmento
a
la
capa
de
red
.
Por


el
contrario
,
TCP
dispone
de
un
mecanismo
de
control
de
congesti√≥n
que
regula
el
flujo


del
emisor
TCP
de
la
capa
de
transporte
cuando
uno
o
m√°s
de
los
enlaces
existentes
entre


los
hosts
de
origen
y
de
destino
est√°n
excesivamente
congestionados
.
TCP
tambi√©n
con-


tinuar√°
reenviando
un
segmento
hasta
que
la
recepci√≥n
del
mismo
haya
sido
confirmada


por
el
destino
,
independientemente
de
cu√°nto
se
tarde
en
llevar
a
cabo
esta
entrega
fia-


ble
.
Puesto
que
las
aplicaciones
en
tiempo
real
suelen
requerir
una
velocidad
m√≠nima
de


transmisi√≥n
,
no
permiten
un
retardo
excesivo
en
la
transmisi√≥n
de
los
segmentos
y
pue-


den
tolerar
algunas
p√©rdidas
de
datos
,
el
modelo
de
servicio
de
TCP
no
se
adapta
dema-


siado
bien
a
las
necesidades
de
este
tipo
de
aplicaciones
.
Como
veremos
m√°s
adelante
,


estas
aplicaciones
pueden
utilizar
UDP
e
implementar
,
como
parte
de
la
aplicaci√≥n
,
cual-


quier
funcionalidad
adicional
que
sea
necesaria
m√°s
all√°
del
servicio
b√°sico
de
entrega


de
segmentos
de
UDP
.


‚Ä¢
Sin
establecimiento
de
la
conexi√≥n
.
Como
se
explicar√°
m√°s
adelante
,
TCP
lleva
a
cabo


un
proceso
de
establecimiento
de
la
conexi√≥n
en
tres
fases
antes
de
iniciar
la
transferen-


cia
de
datos
.
UDP
inicia
la
transmisi√≥n
sin
formalidades
preliminares
.
Por
tanto
,
 
UDP


no
a√±ade
ning√∫n
retardo
a
causa
del
establecimiento
de
una
conexi√≥n
.
Probablemente
,


√©sta
es
la
raz√≥n
principal
por
la
que
DNS
opera
sobre
UDP
y
no
sobre
TCP
(
DNS
ser√≠a


mucho
m√°s
lento
si
se
ejecutara
sobre
TCP
)
.
HTTP
utiliza
TCP
en
lugar
de
UDP
,
ya
que


la
fiabilidad
es
cr√≠tica
para
las
p√°ginas
web
con
texto
.
Pero
,
como
hemos
comentado
bre-


vemente
en
la
Secci√≥n
2.2
,
el
retardo
debido
al
establecimiento
de
la
conexi√≥n
TCP
en


HTTP
contribuye
de
forma
notable
a
los
retardos
asociados
con
la
descarga
de
documen-


tos
web
.


‚Ä¢
Sin
informaci√≥n
del
estado
de
la
conexi√≥n
.
TCP
mantiene
informaci√≥n
acerca
del
estado


de
la
conexi√≥n
en
los
sistemas
terminales
.
En
el
estado
de
la
conexi√≥n
se
incluye
infor-


maci√≥n
acerca
de
los
buffers
de
recepci√≥n
y
env√≠o
,
de
los
par√°metros
de
control
de
con-


gesti√≥n
y
de
los
par√°metros
relativos
al
n√∫mero
de
secuencia
y
de
reconocimiento
.
En
la


Secci√≥n
3.5
veremos
que
esta
informaci√≥n
de
estado
es
necesaria
para
implementar
el


servicio
fiable
de
transferencia
de
datos
y
proporcionar
los
mecanismos
de
control
de


congesti√≥n
de
TCP
.
Por
el
contrario
,
UDP
no
mantiene
informaci√≥n
del
estado
de
la
cone-


xi√≥n
y
no
controla
ninguno
de
estos
par√°metros
.
Por
esta
raz√≥n
,
un
servidor
dedicado
a


una
aplicaci√≥n
concreta
suele
poder
soportar
m√°s
clientes
activos
cuando
la
aplicaci√≥n
se


ejecuta
sobre
UDP
que
cuando
lo
hace
sobre
TCP
.


‚Ä¢
Poca
sobrecarga
debida
a
la
cabecera
de
los
paquetes
.
Los
segmentos
TCP
contienen


20
bytes
en
la
cabecera
de
cada
segmento
,
mientras
que
UDP
s√≥lo
requiere
8
bytes
.


La
tabla
de
la
Figura
3.6
enumera
aplicaciones
de
Internet
muy
populares
junto
con
los


protocolos
de
transporte
que
utilizan
.
Como
era
de
esperar
,
el
correo
electr√≥nico
,
el
acceso


remoto
a
terminales
,
la
Web
y
la
transferencia
de
archivos
se
ejecutan
sobre
TCP
,
ya
que


todas
estas
aplicaciones
necesitan
el
servicio
fiable
de
transferencia
de
datos
de
TCP
.
No


obstante
,
muchas
aplicaciones
importantes
se
ejecutan
sobre
UDP
en
lugar
de
sobre
TCP
.


UDP
se
utiliza
para
las
actualizaciones
de
las
tablas
de
enrutamiento
RIP
(
v√©ase
la
Secci√≥n


4.6.1
)
.
Puesto
que
las
actualizaciones
RIP
se
env√≠an
peri√≥dicamente
(
normalmente
cada


cinco
minutos
)
,
las
actualizaciones
perdidas
se
reemplazan
por
otras
m√°s
recientes
,
haciendo


in√∫tiles
las
actualizaciones
perdidas
ya
desactualizadas
.
UDP
tambi√©n
se
emplea
para
trans-


mitir
los
datos
de
administraci√≥n
de
la
red
(
SNMP
;
v√©ase
el
Cap√≠tulo
9
)
.
En
este
caso
,
 

3.3
‚Ä¢
TRANSPORTE
SIN
CONEXI√ìN
:
UDP
199


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
199Protocolo
de
la
Protocolo
de
transporte


Aplicaci√≥n
capa
de
aplicaci√≥n
subyacente


Correo
electr√≥nico
SMTP
TCP


Acceso
a
terminales
remotos
Telnet
TCP


Web
HTTP
TCP


Transferencia
de
archivos
FTP
TCP


Servidor
de
archivos
remoto
NFS
Normalmente
UDP


Flujos
multimedia
Normalmente
propietario
UDP
o
TCP


Telefon√≠a
por
Internet
Normalmente
propietario
UDP
o
TCP


Administraci√≥n
de
red
SNMP
Normalmente
UDP


Protocolo
de
enrutamiento
RIP
Normalmente
UDP


Traducci√≥n
de
nombres
DNS
Normalmente
UDP


Figura
3.6
‚Ä¢
Aplicaciones
de
Internet
populares
y
sus
protocolos
de
transporte


subyacentes
.


UDP
es
preferible
a
TCP
,
ya
que
las
aplicaciones
de
administraci√≥n
de
la
red
a
menudo
se


tienen
que
ejecutar
cuando
la
red
se
encuentra
en
un
estado
de
sobrecarga
(
precisamente
en


las
situaciones
en
las
que
es
dif√≠cil
realizar
transferencias
de
datos
fiables
y
con
control
de
la


congesti√≥n
)
.
Adem√°s
,
como
ya
hemos
mencionado
anteriormente
,
DNS
se
ejecuta
sobre


UDP
,
evitando
de
este
modo
los
retardos
de
establecimiento
de
la
conexi√≥n
TCP
.


Como
se
indica
en
la
Figura
3.6
,
actualmente
tanto
UDP
como
TCP
se
utilizan
con
apli-


caciones
multimedia
,
como
la
telefon√≠a
por
Internet
,
las
videoconferencias
en
tiempo
real
y


la
reproducci√≥n
de
flujos
de
v√≠deos
y
audios
almacenados
.
En
el
Cap√≠tulo
7
nos
ocuparemos


de
estas
aplicaciones
.
Por
el
momento
,
basta
con
mencionar
que
todas
estas
aplicaciones


toleran
la
p√©rdida
de
una
peque√±a
cantidad
de
paquetes
,
por
lo
que
una
transferencia
de


datos
fiable
no
es
absolutamente
cr√≠tica
para
que
la
aplicaci√≥n
funcione
correctamente
.
Ade-


m√°s
,
las
aplicaciones
en
tiempo
real
,
como
la
telefon√≠a
por
Internet
y
la
videoconferencia
,


responden
muy
mal
a
los
mecanismos
de
control
de
congesti√≥n
de
TCP
.
Por
estas
razones
,


los
desarrolladores
de
aplicaciones
multimedia
pueden
elegir
ejecutar
sus
aplicaciones
sobre


UDP
y
no
sobre
TCP
.
No
obstante
,
cada
vez
se
utiliza
m√°s
TCP
para
el
transporte
de
flujos


multimedia
.
Por
ejemplo
,
puede
leer
en
[
Sripanidkulchai
2004
]
que
casi
el
75%
de
los
flujos


multimedia
en
directo
y
a
la
carta
utilizan
TCP
.
Cuando
la
tasa
de
p√©rdidas
de
paquetes
es


baja
y
teniendo
en
cuenta
que
algunas
organizaciones
bloquean
el
tr√°fico
UDP
por
razones


de
seguridad
(
v√©ase
el
Cap√≠tulo
8)
,
TCP
se
est√°
convirtiendo
en
un
protocolo
cada
vez
m√°s


atractivo
para
el
transporte
de
flujos
multimedia
.


Aunque
hoy
en
d√≠a
es
com√∫n
emplear
UDP
para
ejecutar
las
aplicaciones
multimedia
,


contin√∫a
siendo
un
tema
controvertido
.
Como
ya
hemos
dicho
,
UDP
no
proporciona
meca-


nismos
de
control
de
congesti√≥n
,
y
estos
mecanismos
son
necesarios
para
impedir
que
la
red


entre
en
un
estado
de
congesti√≥n
en
el
que
se
realice
muy
poco
trabajo
√∫til
.
Si
todo
el
mundo


deseara
reproducir
flujos
de
v√≠deo
a
alta
velocidad
sin
utilizar
ning√∫n
mecanismo
de
control


200
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
200de
congesti√≥n
,
se
producir√≠a
tal
desbordamiento
de
paquetes
en
los
routers
que
muy
pocos


paquetes
UDP
lograr√≠an
recorrer
con
√©xito
la
ruta
entre
el
origen
y
el
destino
.
Adem√°s
,
las


altas
tasas
de
p√©rdidas
inducidas
por
los
emisores
UDP
no
controlados
har√≠an
que
los
emiso-


res
TCP
(
que
,
como
veremos
,
reducen
sus
velocidades
de
transmisi√≥n
para
hacer
frente
a
la


congesti√≥n
)
disminuyeran
dram√°ticamente
sus
velocidades
.
Por
tanto
,
la
ausencia
de
un


mecanismo
de
control
de
congesti√≥n
en
UDP
puede
dar
lugar
a
altas
tasas
de
p√©rdidas
entre


un
emisor
y
un
receptor
UDP
y
al
estrangulamiento
de
las
sesiones
TCP
,
lo
cual
es
un
pro-


blema
potencialmente
serio
[
Floyd
1999
]
.
Muchos
investigadores
han
propuesto
nuevos


mecanismos
para
forzar
a
todas
las
fuentes
de
datos
,
incluyendo
las
de
tipo
UDP
,
a
llevar
a


cabo
un
control
adaptativo
de
la
congesti√≥n
[
Mahdavi
1997
;
Floyd
2000
;
Kohler
2006
;
RFC


4340
]
.


Antes
de
pasar
a
examinar
la
estructura
de
los
segmentos
UDP
,
tenemos
que
comentar


que
es
posible
que
una
aplicaci√≥n
disponga
de
un
servicio
fiable
de
transferencia
de
datos


utilizando
UDP
.
Esto
puede
conseguirse
si
las
caracter√≠sticas
de
fiabilidad
se
incorporan
a
la


propia
aplicaci√≥n
(
por
ejemplo
,
a√±adiendo
mecanismos
de
reconocimiento
y
retransmisi√≥n
,


tales
como
los
que
vamos
a
ver
en
la
siguiente
secci√≥n
)
.
Pero
se
trata
de
una
tarea
nada
sen-


cilla
que
requiere
una
intensa
tarea
de
depuraci√≥n
de
las
aplicaciones
.
No
obstante
,
incorpo-


rar
los
mecanismos
de
fiabilidad
directamente
en
la
aplicaci√≥n
permite
que
ella
misma
‚Äú
selo


guise
y
se
lo
coma
‚Äù
.
Es
decir
,
los
procesos
de
aplicaci√≥n
pueden
comunicarse
de
forma
fia-


ble
sin
estar
sujetos
a
las
restricciones
de
la
velocidad
de
transmisi√≥n
impuestas
por
el
meca-


nismo
de
control
de
congesti√≥n
de
TCP
.


3.3.1
Estructura
de
los
segmentos
UDP


La
estructura
de
los
segmentos
UDP
,
mostrada
en
la
Figura
3.7
,
est√°
definida
en
el
docu-


mento
RFC
768
.
Los
datos
de
la
aplicaci√≥n
ocupan
el
campo
de
datos
del
segmento
UDP
.


Por
ejemplo
,
para
DNS
el
campo
de
datos
contiene
un
mensaje
de
consulta
o
un
mensaje
de


respuesta
.
En
el
caso
de
una
aplicaci√≥n
de
flujo
de
audio
,
las
muestras
del
audio
llenar√°n
el


campo
de
datos
.
La
cabecera
UDP
s√≥lo
tiene
cuatro
campos
,
y
cada
uno
de
ellos
tiene
una


longitud
de
dos
bytes
.
Como
se
ha
explicado
en
la
secci√≥n
anterior
,
los
n√∫meros
de
puerto


permiten
al
host
de
destino
pasar
los
datos
de
la
aplicaci√≥n
al
proceso
apropiado
que
est√°


ejecut√°ndose
en
el
sistema
terminal
de
destino
(
es
decir
,
realizar
la
funci√≥n
de
demultiplexa-


ci√≥n
)
.
El
host
receptor
utiliza
la
suma
de
comprobaci√≥n
para
detectar
si
se
han
introducido


errores
en
el
segmento
.
En
realidad
,
la
suma
de
comprobaci√≥n
tambi√©n
se
calcula
para
unos


pocos
campos
de
la
cabecera
IP
,
adem√°s
de
para
el
segmento
UDP
.
Pero
por
el
momento
no


vamos
a
tener
en
cuenta
este
detalle
para
ver
el
bosque
a
trav√©s
de
los
√°rboles
.
Veamos
ahora


c√≥mo
se
calcula
la
suma
de
comprobaci√≥n
.
En
la
Secci√≥n
5.2
se
describen
los
principios


b√°sicos
para
la
detecci√≥n
de
errores
.
El
campo
longitud
especifica
la
longitud
del
segmento


UDP
en
bytes
,
incluyendo
la
cabecera
.


3.3.2
Suma
de
comprobaci√≥n
de
UDP


La
suma
de
comprobaci√≥n
de
UDP
proporciona
un
mecanismo
de
detecci√≥n
de
errores
.
Es


decir
,
se
utiliza
para
determinar
si
los
bits
contenidos
en
el
segmento
UDP
han
sido
altera-


dos
seg√∫n
se
desplazaban
desde
el
origen
hasta
el
destino
(
por
ejemplo
,
a
causa
de
la
exis-


tencia
de
ruido
en
los
enlaces
o
mientras
estaban
almacenados
en
un
router
)
.
UDP
en
el
lado


del
emisor
calcula
el
complemento
a
1
de
la
suma
de
todas
las
palabras
de
16
bits
del
seg-


3.3
‚Ä¢
TRANSPORTE
SIN
CONEXI√ìN
:
UDP
201


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
201mento
,
acarreando
cualquier
desbordamiento
obtenido
durante
la
operaci√≥n
de
suma
sobre


el
bit
de
menor
peso
.
Este
resultado
se
almacena
en
el
campo
suma
de
comprobaci√≥n
del


segmento
UDP
.
He
aqu√≠
un
ejemplo
sencillo
de
c√°lculo
de
una
suma
de
comprobaci√≥n
.


Puede
obtener
informaci√≥n
detallada
acerca
de
una
implementaci√≥n
eficiente
del
c√°lculo
en


el
RFC
1071
,
as√≠
como
de
su
rendimiento
con
datos
reales
en
[
Stone
1998
;
Stone
2000
]
.
Por


ejemplo
,
suponga
que
tenemos
las
siguientes
tres
palabras
de
16
bits
:


0110011001100000


0101010101010101


1000111100001100


La
suma
de
las
dos
primeras
palabras
de
16
bits
es
:


0110011001100000


0101010101010101


1011101110110101


Sumando
la
tercera
palabra
a
la
suma
anterior
,
obtenemos
,


1011101110110101


1000111100001100


0100101011000010


Observe
que
en
esta
√∫ltima
suma
se
produce
un
desbordamiento
,
el
cual
se
acarrea
sobre


el
bit
de
menor
peso
.
El
complemento
a
1
se
obtiene
convirtiendo
todos
los
0
en
1
y


todos
los
1
en
0
.
Por
tanto
,
el
complemento
a
1
de
la
suma
0100101011000010
es


1011010100111101
,
que
es
la
suma
de
comprobaci√≥n
.
En
el
receptor
,
las
cuatro
palabras
de


16
bits
se
suman
,
incluyendo
la
suma
de
comprobaci√≥n
.
Si
no
se
han
introducido
errores
en


el
paquete
,
entonces
la
suma
en
el
receptor
tiene
que
ser
1
111111111111111
.
Si
uno
de
los


bits
es
un
0
,
entonces
sabemos
que
el
paquete
contiene
errores
.


Es
posible
que
se
est√©
preguntando
por
qu√©
UDP
proporciona
una
suma
de
comproba-


ci√≥n
,
cuando
muchos
protocolos
de
la
capa
de
enlace
(
incluyendo
el
popular
protocolo


Ethernet
)
tambi√©n
proporcionan
mecanismos
de
comprobaci√≥n
de
errores
.
La
raz√≥n
de
ello


es
que
no
existe
ninguna
garant√≠a
de
que
todos
los
enlaces
existentes
entre
el
origen
y
el
des-


202
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


N¬∫
de
puerto


de
origen


32
bits


N¬∫
de
puerto


de
destino


Longitud
Suma
de


comprobaci√≥n


Datos
de
la


aplicaci√≥n


(
mensaje
)


Figura
3.7
‚Ä¢
Estructura
de
un
segmento
UDP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
202tino
proporcionen
un
mecanismo
de
comprobaci√≥n
de
errores
;
es
decir
,
uno
de
los
enlaces


puede
utilizar
un
protocolo
de
la
capa
de
enlace
que
no
proporcione
comprobaci√≥n
de
erro-


res
.
Adem√°s
,
incluso
si
los
segmentos
se
transfieren
correctamente
a
trav√©s
del
enlace
,
es


posible
que
se
introduzcan
errores
de
bit
cuando
un
segmento
se
almacena
en
la
memoria
de


un
router
.
Dado
que
no
est√°n
garantizadas
ni
la
fiabilidad
enlace
a
enlace
,
ni
la
detecci√≥n
de


errores
durante
el
almacenamiento
en
memoria
,
UDP
tiene
que
proporcionar
un
mecanismo


de
detecci√≥n
de
errores
en
la
capa
de
transporte
,
terminal
a
terminal
,
si
el
servicio
de
trans-


ferencia
de
datos
terminal
a
terminal
ha
de
proporcionar
la
de
detecci√≥n
de
errores
.
Este
es


un
ejemplo
del
famoso
principio
terminal
a
terminal
del
dise√±o
de
sistemas
[
Saltzer


1984
]
,
que
establece
que
como
cierta
funcionalidad
(
en
este
caso
,
la
detecci√≥n
de
errores
)


debe
implementarse
terminal
a
terminal
,
‚Äú
las
funciones
incluidas
en
los
niveles
inferiores


pueden
ser
redundantes
o
escasamente
√∫tiles
si
se
comparan
con
el
coste
de
proporcionarlas


en
el
nivel
superior
‚Äù
.


Dado
que
IP
est√°
pensado
para
ejecutarse
sobre
pr√°cticamente
cualquier
protocolo
de
la


capa
2
,
resulta
√∫til
para
la
capa
de
transporte
proporcionar
un
mecanismo
de
comprobaci√≥n


de
errores
como
medida
de
seguridad
.
Aunque
UDP
proporciona
un
mecanismo
de
compro-


baci√≥n
de
errores
,
no
hace
nada
para
recuperarse
del
error
.
Algunas
implementaciones
de


UDP
simplemente
descartan
el
segmento
da√±ado
y
otras
lo
pasan
a
la
aplicaci√≥n
junto
con


una
advertencia
.


Hasta
aqu√≠
llega
nuestra
exposici√≥n
sobre
UDP
.
Pronto
veremos
que
TCP
ofrece
a
las


aplicaciones
un
servicio
de
transferencia
de
datos
fiable
,
as√≠
como
otros
servicios
que
UDP


no
proporciona
.
Naturalmente
,
TCP
tambi√©n
es
m√°s
complejo
que
UDP
.
Sin
embargo
,
antes


de
abordar
TCP
,
nos
resultar√°
√∫til
volver
unos
pasos
atr√°s
y
ocuparnos
primero
de
los
princi-


pios
que
subyacen
a
una
transferencia
de
datos
fiable
.


3.4
Principios
de
un
servicio
de
transferencia


de
datos
fiable


En
esta
secci√≥n
vamos
a
considerar
el
problema
de
la
transferencia
de
datos
fiable
en
un


contexto
 
general
.
Este
enfoque
es
conveniente
porque
el
problema
de
implementar
servi-


cios
de
transferencia
de
datos
fiables
no
s√≥lo
aparece
en
la
capa
de
transporte
,
sino
tambi√©n


en
la
capa
de
enlace
y
en
la
capa
de
aplicaci√≥n
.
El
problema
general
tiene
por
tanto
una
gran


relevancia
en
las
redes
de
computadoras
.
En
efecto
,
si
tuvi√©ramos
que
identificar
la
lista
de


los
diez
problemas
m√°s
importantes
que
afectan
a
las
redes
,
√©ste
ser√≠a
un
candidato
a
liderar


dicha
lista
.
En
la
siguiente
secci√≥n
examinaremos
TCP
y
,
en
concreto
,
mostraremos
que
TCP


aplica
muchos
de
los
principios
que
vamos
a
describir
.


La
Figura
3.8
ilustra
el
marco
de
trabajo
que
vamos
a
emplear
en
nuestro
estudio
sobre


la
transferencia
de
datos
fiable
.
La
abstracci√≥n
del
servicio
proporcionada
a
las
entidades
de


la
capa
superior
es
la
de
un
canal
fiable
a
trav√©s
del
cual
se
pueden
transferir
datos
.
Dispo-


niendo
de
un
canal
fiable
,
ninguno
de
los
bits
de
datos
transferidos
est√°
corrompido
(
cambia


de
0
a
1
,
o
viceversa
)
ni
se
pierde
,
y
todos
se
entregan
en
el
orden
en
que
fueron
enviados
.


√âste
es
precisamente
el
modelo
de
servicio
ofrecido
por
TCP
a
las
aplicaciones
de
Internet


que
lo
invocan
.


Es
la
responsabilidad
de
un
protocolo
de
transferencia
de
datos
fiableimplementar
esta


abstracci√≥n
del
servicio
.
Esta
tarea
es
complicada
por
el
hecho
de
que
la
capa
que
hay
por


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
203


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
203debajo
del
protocolo
de
transferencia
de
datos
puede
ser
no
fiable
.
Por
ejemplo
,
TCP
es
un


protocolo
de
transferencia
de
datos
fiable
que
se
implementa
encima
de
una
capa
de
red
ter-


minal
a
terminal
no
fiable
(
IP
)
.
De
forma
m√°s
general
,
la
capa
que
hay
debajo
de
los
dos
pun-


tos
terminales
que
se
comunican
de
forma
fiable
puede
ser
un
√∫nico
enlace
f√≠sico
(
como
en
el


caso
de
un
protocolo
de
transferencia
de
datos
a
nivel
de
enlace
)
o
una
interred
global
(
como


en
el
caso
de
un
protocolo
del
nivel
de
transporte
)
.
Para
nuestros
prop√≥sitos
,
sin
embargo
,


podemos
considerar
esta
capa
inferior
simplemente
como
un
canal
punto
a
punto
no
fiable
.


En
esta
secci√≥n
vamos
a
desarrollar
de
forma
incremental
los
lados
del
emisor
y
del


receptor
de
un
protocolo
de
transferencia
de
datos
fiable
,
considerando
modelos
cada
vez


m√°s
complejos
del
canal
subyacente
.
La
Figura
3.8(b
)
ilustra
las
interfaces
de
nuestro
proto-


colo
de
transferencia
de
datos
.
El
lado
emisor
del
protocolo
de
transferencia
de
datos
ser√°


invocado
desde
la
capa
superior
mediante
una
llamada
a
rdt_enviar
(
)
,
que
pasar√°
los


datos
que
haya
que
entregar
a
la
capa
superior
en
el
lado
receptor
.
Aqu√≠
rdthace
referencia


al
protocolo
de
transferencia
de
datos
fiable
(
reliable
data
transfer
)
y
_
enviar
indica
que


el
lado
emisor
de
rdtest√°
siendo
llamado
.
(
¬°
El
primer
paso
para
desarrollar
un
buen
proto-


colo
es
elegir
un
buen
nombre
!
)
En
el
lado
receptor
,
rdt_recibir
(
)
ser√°
llamado
cuando


llegue
un
paquete
desde
el
lado
receptor
del
canal
.
Cuando
el
protocolo
rdtdesea
suminis-


trar
datos
a
la
capa
superior
,
lo
har√°
llamando
a
entregar_datos
(
)
.
De
aqu√≠
en
adelante


204
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Canal
fiable


Canal
no
fiable


rdt_enviar
(
)


udt_enviar
(
)


Proceso


emisor


Proceso


receptor


entregar_datos


Capa
de


aplicaci√≥n


Capa
de


transporte


a.
Servicio
proporcionado


Capa


de
red


Clave
:


Datos
Paquete


b.
Implementaci√≥n
del
servicio


Protocolo
de


transferencia
de
datos


fiable
(
lado
emisor
)


Protocolo
de


transferencia
de
datos


fiable
(
lado
receptor
)


rdt_recibir
(
)


Figura
3.8
‚Ä¢
Transferencia
de
datos
fiable
:
modelo
del
servicio
e
implementaci√≥n


del
servicio
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
204utilizaremos
el
t√©rmino
‚Äú
paquete
‚Äù
en
lugar
de
‚Äú
segmento
‚Äù
de
la
capa
de
transporte
.
Puesto


que
la
teor√≠a
desarrollada
en
esta
secci√≥n
se
aplica
a
las
redes
de
computadoras
en
general
y


no
s√≥lo
a
la
capa
de
transporte
de
Internet
,
quiz√°
resulte
m√°s
apropiado
el
t√©rmino
gen√©rico


‚Äú
paquete
‚Äù
.


En
esta
secci√≥n
√∫nicamente
consideraremos
el
caso
de
la
transferencia
de
datos
unidi-


reccional
,
es
decir
,
los
datos
se
transfieren
desde
el
lado
emisor
al
receptor
.
El
caso
de
la


transferencia
de
datos
bidireccional
(
es
decir
,
full-duplex
)
conceptualmente
no
es
m√°s


dif√≠cil
,
pero
es
considerablemente
m√°s
tediosa
de
explicar
.
Aunque
s√≥lo
abordemos
la
trans-


ferencia
de
datos
unidireccional
,
tendremos
en
cuenta
que
los
lados
emisor
y
receptor
de


nuestro
protocolo
necesitan
transmitir
paquetes
en
ambas
direcciones
,
como
se
indica
en
la


Figura
 
3.8
.
Veremos
brevemente
que
,
adem√°s
de
intercambiar
paquetes
que
contengan
los


datos
que
van
a
transferirse
,
los
lados
emisor
y
receptor
de
rdttambi√©n
intercambian
paque-


tes
de
control
de
una
parte
a
otra
.
Ambos
lados
,
emisor
y
receptor
,
derdtenv√≠an
paquetes
al


otro
lado
haciendo
una
llamada
a
udt_enviar()(donde
udthace
referencia
a
una
transfe-


rencia
de
datos
no
fiable
[
unreliable
data
transfer
]
)
.


3.4.1
Construcci√≥n
de
un
protocolo
de


transferencia
de
datos
fiable


Ahora
vamos
a
ver
una
serie
de
protocolos
de
complejidad
creciente
,
hasta
llegar
a
un
proto-


colo
de
transferencia
de
datos
fiable
sin
defectos
.


Transferencia
de
datos
fiable
sobre
un
canal
totalmente
fiable
:
rdt1.0


En
primer
lugar
consideremos
el
caso
m√°s
simple
,
en
el
que
el
canal
subyacente
es
comple-


tamente
fiable
.
El
protocolo
en
s√≠
,
que
denominaremos
rdt1.0
,
es
trivial
.
En
la
Figura
3.9


se
muestran
las
definiciones
de
las
m√°quinas
de
estados
finitos
(
FSM
,
Finite-State


Machine
)
para
el
emisor
y
el
receptor
de
rdt1.0
.
La
m√°quina
de
estados
finitos
de
la


Figura
3.9(a
)
define
el
funcionamiento
del
emisor
,
mientras
que
la
FSM
de
la
Figura
3.9(b
)


define
el
funcionamiento
del
receptor
.
Es
importante
observar
que
existen
m√°quinas
de
esta-


dos
finitos
separadas
para
el
emisor
y
el
receptor
.
Cada
una
de
las
m√°quinas
de
esta
figura


tiene
s√≥lo
un
estado
.
Las
flechas
en
la
descripci√≥n
de
las
FSM
indican
la
transici√≥n
del
pro-


tocolo
de
un
estado
a
otro
.
Puesto
que
en
este
caso
cada
una
de
las
m√°quinas
de
la
Figura


3.9
s√≥lo
tiene
un
estado
,
necesariamente
una
transici√≥n
es
del
estado
a
s√≠
mismo
(
veremos


diagramas
m√°s
complicados
enseguida
)
.
El
suceso
que
provoca
la
transici√≥n
se
muestra


encima
de
la
l√≠nea
horizontal
que
etiqueta
la
transici√≥n
y
las
acciones
que
se
toman
cuando


tiene
lugar
el
suceso
se
indican
debajo
de
la
l√≠nea
horizontal
.
Cuando
no
se
lleve
a
cabo
nin-


guna
acci√≥n
al
ocurrir
un
suceso
,
o
cuando
no
se
produzca
un
suceso
y
se
realice
una
acci√≥n
,


utilizaremos
el
s√≠mbolo
 
por
debajo
o
por
encima
de
la
horizontal
,
respectivamente
,
para


indicar
de
manera
expl√≠cita
la
ausencia
de
una
acci√≥n
o
de
un
suceso
.
El
estado
inicial
de
la


m√°quina
FSM
est√°
indicado
mediante
la
l√≠nea
de
puntos
.
Aunque
las
m√°quinas
de
estados


finitos
de
la
Figura
3.9
tienen
un
√∫nico
estado
,
las
que
veremos
a
continuaci√≥n
tendr√°n
m√∫l-


tiples
,
por
lo
que
es
importante
identificar
el
estado
inicial
de
cada
m√°quina
FSM
.


El
lado
emisor
de
rdtsimplemente
acepta
datos
de
la
capa
superior
a
trav√©s
del
suceso


rdt_enviar(datos
)
,
crea
un
paquete
que
contiene
los
datos
(
mediante
la
acci√≥n
crear
_


paquete(datos
)
)
y
env√≠a
el
paquete
al
canal
.
En
la
pr√°ctica
,
el
suceso
rdt_enviar


(
datos
)
resultar√≠a
de
una
llamada
a
procedimiento
(
por
ejemplo
,
a
rdt_enviar
(
)
)
reali-


zada
por
la
aplicaci√≥n
de
la
capa
superior
.


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
205


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
205Figura
3.9
‚Ä¢
rdt1.0
:
protocolo
para
un
canal
totalmente
fiable
.


En
el
lado
receptor
,
rdt
recibe
un
paquete
del
canal
subyacente
a
trav√©s
del
suceso


rdt_recibir(paquete
)
,
extrae
los
datos
del
paquete
(
mediante
la
acci√≥n
extraer


(
paquete
,
datos
)
)
y
pasa
los
datos
a
la
capa
superior
(
mediante
la
acci√≥n
entregar
_


datos(datos
)
)
.
En
la
pr√°ctica
,
el
suceso
rdt_recibir(paquete
)
resultar√≠a
de
una
lla-


mada
a
procedimiento
(
por
ejemplo
,
a
rdt_recibir
(
)
)
desde
el
protocolo
de
la
capa
inferior
.


En
este
protocolo
tan
simple
no
existe
ninguna
diferencia
entre
una
unidad
de
datos
y


un
paquete
.
Adem√°s
,
todo
el
flujo
de
paquetes
va
del
emisor
al
receptor
,
ya
que
disponiendo


de
un
canal
totalmente
fiable
no
existe
la
necesidad
en
el
lado
receptor
de
proporcionar
nin-


guna
realimentaci√≥n
al
emisor
,
puesto
que
no
hay
nada
que
pueda
ser
incorrecto
.
Observe


que
tambi√©n
hemos
supuesto
que
el
receptor
pod√≠a
recibir
los
datos
tan
r√°pido
como
el
emi-


sor
los
enviara
.
Luego
tampoco
existe
la
necesidad
de
que
el
receptor
le
pida
al
emisor
que


vaya
m√°s
despacio
.


Transferencia
de
datos
fiable
sobre
un
canal
con
errores
de
bit
:
rdt2.0


Un
modelo
m√°s
realista
del
canal
subyacente
ser√≠a
uno
en
el
que
los
bits
de
un
paquete


pudieran
corromperse
.
Normalmente
,
tales
errores
de
bit
se
producen
en
los
componentes


f√≠sicos
de
una
red
cuando
un
paquete
se
transmite
,
se
propaga
o
accede
a
un
buffer
.
Por
el


momento
vamos
a
continuar
suponiendo
que
todos
los
paquetes
transmitidos
son
recibidos


(
aunque
sus
bits
pueden
estar
corrompidos
)
en
el
orden
en
que
se
enviaron
.


Antes
de
desarrollar
un
protocolo
que
permita
una
comunicaci√≥n
fiable
a
trav√©s
de
un


canal
as√≠
,
vamos
a
ver
c√≥mo
las
personas
se
enfrentan
a
esta
situaci√≥n
.
Imagine
c√≥mo
dicta-


r√≠a
un
mensaje
largo
a
trav√©s
del
tel√©fono
.
En
un
escenario
t√≠pico
,
la
persona
que
escucha
el


mensaje
podr√≠a
decir
‚Äú
De
acuerdo
‚Äù
despu√©s
de
cada
frase
que
escuche
,
comprenda
y
apunte
.


Si
la
persona
que
escucha
el
mensaje
no
oye
una
frase
,
le
pedir√°
que
la
repita
.
Este
proto-


colo
de
dictado
de
mensajes
utiliza
tanto
reconocimientos
positivos
(
‚Äú
De
acuerdo
‚Äù
)
como


reconocimientos
negativos
(
‚Äú
Por
favor
,
repita
‚Äù
)
.
Estos
mensajes
de
control
permiten
al


Esperar


una
llamada


de
arriba


a.
 
rdt1.0
:
lado
emisor


rdt_enviar(datos
)


paquete
=
crear_paquete(datos
)


udt_enviar(paquete
)


Esperar


una
llamada


de
abajo


b.
 
rdt1.0
:
lado
receptor


rdt_recibir(paquete
)


extraer(paquete
,
datos
)


entregar_datos(datos
)


206
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
206receptor
hacer
saber
al
emisor
qu√©
es
lo
que
ha
recibido
correctamente
y
qu√©
ha
recibido
con


errores
y
por
tanto
debe
repetir
.
En
una
red
de
computadoras
,
los
protocolos
de
transferencia


de
datos
fiables
basados
en
tales
retransmisiones
se
conocen
como
protocolos
ARQ


(
Automatic
Repeat
reQuest
,
Solicitud
autom√°tica
de
repetici√≥n
)
.


En
los
protocolos
ARQ
se
requieren
,
fundamentalmente
,
tres
capacidades
de
proto-


colo
adicionales
para
gestionar
la
presencia
de
errores
de
bit
:


‚Ä¢
Detecci√≥n
de
errores
.
En
primer
lugar
,
se
necesita
un
mecanismo
que
permita
al
receptor


detectar
que
se
han
producido
errores
de
bit
.
Recuerde
de
la
secci√≥n
anterior
que
UDP


utiliza
el
campo
de
suma
de
comprobaci√≥n
de
Internet
precisamente
para
este
prop√≥sito
.


En
el
Cap√≠tulo
5
,
examinaremos
t√©cnicas
de
detecci√≥n
y
correcci√≥n
de
errores
con
m√°s


detalle
;
estas
t√©cnicas
permiten
al
receptor
detectar
y
,
posiblemente
,
corregir
los
errores


de
bit
en
los
paquetes
.
Por
el
momento
,
s√≥lo
necesitamos
saber
que
estas
t√©cnicas
requie-


ren
que
el
emisor
env√≠e
al
receptor
bits
adicionales
(
junto
con
los
bits
de
los
datos
origi-


nales
que
se
desean
transferir
)
y
dichos
bits
tambi√©n
se
tendr√°n
en
cuenta
para
el
c√°lculo


de
la
suma
de
comprobaci√≥n
del
paquete
de
datos
rdt2.0
.


‚Ä¢
Realimentaci√≥n
del
receptor
.
Dado
que
el
emisor
y
el
receptor
normalmente
se
ejecutan


en
sistemas
terminales
diferentes
,
posiblemente
separados
por
miles
de
kil√≥metros
,
la


√∫nica
forma
de
que
el
emisor
sepa
lo
que
ocurre
en
el
receptor
(
en
este
caso
,
si
un


paquete
ha
sido
recibido
correctamente
o
no
)
es
que
el
receptor
env√≠e
expl√≠citamente


informaci√≥n
de
realimentaci√≥n
al
emisor
.
Las
respuestas
de
acuse
de
recibo
o
reconoci-


miento
positivo
(
ACK
)
y
reconocimiento
negativo
(
NAK
)
en
el
escenario
del
dictado
de


mensajes
son
ejemplos
de
esa
realimentaci√≥n
.
De
forma
similar
,
nuestro
protocolo


rdt2.0
enviar√°
paquetes
ACK
y
NAK
de
vuelta
desde
el
receptor
al
emisor
.
En
princi-


pio
,
estos
paquetes
s√≥lo
necesitan
tener
una
longitud
de
un
bit
;
por
ejemplo
,
un
valor
0


indicar√≠a
un
reconocimiento
negativo
(
NAK
)
y
un
valor
1
indicar√≠a
un
reconocimiento


positivo
(
ACK
)
.


‚Ä¢
Retransmisi√≥n
.
Una
paquete
que
se
recibe
con
errores
en
el
receptor
ser√°
retransmitido


por
el
emisor
.


La
Figura
3.10
muestra
la
representaci√≥n
de
la
m√°quina
de
estados
finitos
para
rdt2.0
,


un
protocolo
de
transferencia
de
datos
que
dispone
de
mecanismos
de
detecci√≥n
de
errores
y


paquetes
de
reconocimiento
positivo
y
negativo
.


El
lado
emisor
de
rdt2.0
tiene
dos
estados
.
En
el
estado
m√°s
a
la
izquierda
,
el
proto-


colo
del
lado
emisor
est√°
a
la
espera
de
datos
procedentes
de
la
capa
superior
.
Cuando
se


produce
el
suceso
rdt_enviar(datos
)
,
el
emisor
crear√°
un
paquete
(
pqtenv
)
conte-


niendo
los
datos
que
van
a
ser
transmitidos
,
junto
con
una
suma
de
comprobaci√≥n
del


paquete
(
como
se
ha
visto
en
la
Secci√≥n
3.3.2
,
por
ejemplo
,
para
el
caso
de
un
segmento


UDP
)
,
y
luego
el
paquete
se
env√≠a
mediante
la
operaci√≥n
udt_enviar(pqtenv
)
.
En
el


estado
m√°s
a
la
derecha
,
el
protocolo
del
emisor
est√°
a
la
espera
de
un
paquete
de
reconoci-


miento
positivo
ACK
o
negativo
NAK
procedente
del
receptor
.
Si
se
recibe
un
paquete
ACK


(
la
notaci√≥n
rdt_recibir(pqtrcb
)
&
&
esACK
(
pqtrcb
)
mostrada
en
la
Figura
3.10


corresponde
a
este
suceso
)
,
el
emisor
sabe
que
el
paquete
m√°s
recientemente
transmitido
ha


sido
recibido
correctamente
y
,
por
tanto
,
el
protocolo
vuelve
al
estado
de
espera
de
datos


procedentes
de
la
capa
superior
.
Si
se
recibe
un
reconocimiento
negativo
NAK
,
el
protocolo


retransmite
el
√∫ltimo
paquete
y
espera
a
recibir
un
mensaje
ACK
o
NAK
del
receptor
en
res-


puesta
al
paquete
de
datos
retransmitido
.
Es
importante
observar
que
cuando
el
emisor
est√°


en
el
estado
‚Äú
Esperar
ACK
o
NAK
‚Äù
,
no
puede
obtener
m√°s
datos
de
la
capa
superior
;
es


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
207


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
207Figura
3.10
‚Ä¢
rdt2.0
:
protocolo
para
un
canal
con
errores
de
bit
.


decir
,
el
suceso
rdt_enviar
(
)
no
puede
ocurrir
;
esto
s√≥lo
ocurrir√°
despu√©s
de
que
el
emi-


sor
reciba
un
ACK
y
salga
de
ese
estado
.
Por
tanto
,
el
emisor
no
enviar√°
ning√∫n
nuevo
frag-


mento
de
datos
hasta
estar
seguro
de
que
el
receptor
ha
recibido
correctamente
el
paquete


actual
.
Debido
a
este
comportamiento
,
los
protocolos
como
 
rdt2.0
se
conocen
como
pro-


tocolos
de
parada
y
espera
(
stop-and-wait
protocol
)
.


El
lado
receptor
de
la
m√°quina
de
estados
finitos
para
rdt2.0
tiene
un
√∫nico
estado
.


Cuando
llega
un
paquete
,
el
receptor
responde
con
un
reconocimiento
positivo
ACK
o
nega-


tivo
NAK
,
dependiendo
de
si
el
paquete
recibido
es
correcto
o
est√°
corrompido
.
En
la
Figura


3.10
,
la
notaci√≥n
rdt_recibir(pqtrcb
)
&
&
corrupto(pqtrcb)corresponde
al
suceso


en
el
que
se
ha
recibido
un
paquete
y
resulta
ser
err√≥neo
.


Puede
parecer
que
el
protocolo
rdt2.0
funciona
pero
,
lamentablemente
,
tiene
un


defecto
fatal
.
¬°
No
hemos
tenido
en
cuenta
la
posibilidad
de
que
el
paquete
ACK
o
NAK


pueda
estar
corrompido
!
(
Antes
de
continuar
,
deber√≠a
pararse
a
pensar
en
c√≥mo
se
podr√≠a


resolver
este
problema
.
)
Lamentablemente
,
este
descuido
no
es
tan
inocuo
como
puede
pare-


cer
.
Como
m√≠nimo
,
tendremos
que
a√±adir
bits
de
suma
de
comprobaci√≥n
a
los
paquetes


208
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Esperar


una
llamada


de
arriba


a.
 
rdt2.0
:
lado
emisor


b.
 
rdt2.0
:
lado
receptor


rdt_recibir(pqtrcb)&&corrupto(pqtrcb
)


pqtenv
=
crear_paquete(NAK
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&


esNAK(pqtrcb
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb)&&esACK(pqtrcb
)


Œõ


rdt_enviar(datos
)


pqtenv
=
crear_paquete(datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb)&&nocorrupto(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


pqtenv
=
crear_paquete(ACK
)


udt_enviar(pqtenv
)


Esperar


una
llamada


de
abajo


Esperar


ACK
o


NAK


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
208ACK
/
NAK
para
detectar
tales
errores
.
La
cuesti√≥n
m√°s
complicada
es
c√≥mo
puede
recupe-


rarse
el
protocolo
de
los
errores
en
los
paquetes
ACK
o
NAK
.
La
dificultad
est√°
en
que
si
un


paquete
ACK
o
NAK
est√°
corrompido
,
el
emisor
no
tiene
forma
de
saber
si
el
receptor
 
ha


recibido
o
no
correctamente
el
√∫ltimo
fragmento
de
datos
transmitido
.


Consideremos
ahora
tres
posibilidades
para
gestionar
los
paquetes
ACK
o
NAK
corrup-


tos
:


‚Ä¢P
a
r
a
 
a
b
o
r
d
a
r
 
l
a
 
p
r
i
m
e
r
a
 
p
o
s
i
b
i
l
i
d
a
d
,
 
v
e
a
m
o
s
 
l
o
 
q
u
e
 
p
o
d
r
√≠
a
 
h
a
c
e
r
 
u
n
a
 
p
e
r
s
o
n
a
 
e
n
 
e
l
 
e
s
c
e
-


nario
del
dictado
de
mensajes
.
Si
la
persona
que
est√°
dictando
el
mensaje
no
entiende
la


respuesta
‚Äú
De
acuerdo
‚Äù
o
‚Äú
Por
favor
,
repita
‚Äù
del
receptor
,
probablemente
dir√≠a
‚Äú
¬ø
C√≥mo


dice
?
‚Äù
(
lo
que
introduce
un
nuevo
tipo
de
paquete
del
emisor
al
receptor
en
nuestro
pro-


tocolo
)
.
A
continuaci√≥n
,
el
receptor
repetir√≠a
la
respuesta
.
¬ø
Pero
qu√©
ocurrir√≠a
si
el
‚Äú
C√≥mo


dice
‚Äù
est√°
corrompido
?
El
receptor
no
tendr√≠a
ni
idea
de
si
esa
frase
formaba
parte
del


dictado
o
era
una
solicitud
de
que
repitiera
la
√∫ltima
respuesta
,
por
lo
que
probablemente


responder√≠a
con
un
‚Äú
¬ø
C√≥mo
dice
usted
?
‚Äù
.
Y
,
a
su
vez
,
por
supuesto
,
dicha
respuesta
tam-


bi√©n
podr√≠a
verse
alterada
.
Evidentemente
,
el
problema
se
complica
.


‚Ä¢U
n
a
 
s
e
g
u
n
d
a
 
a
l
t
e
r
n
a
t
i
v
a
 
c
o
n
s
i
s
t
i
r
√≠
a
 
e
n
 
a
√±
a
d
i
r
 
l
o
s
 
s
u
f
i
c
i
e
n
t
e
s
 
b
i
t
s
 
d
e
 
s
u
m
a
 
d
e
 
c
o
m
p
r
o
b
a
-


ci√≥n
como
para
permitir
al
emisor
no
s√≥lo
detectar
,
sino
tambi√©n
recuperarse
de
los
erro-


res
de
bit
.
De
este
modo
se
resuelve
el
problema
inmediato
de
un
canal
que
puede


corromper
los
paquetes
de
datos
,
pero
no
perderlos
.


‚Ä¢U
n
 
t
e
r
c
e
r
 
m
√©
t
o
d
o
 
c
o
n
s
i
s
t
i
r
√≠
a
 
s
i
m
p
l
e
m
e
n
t
e
 
e
n
 
q
u
e
 
e
l
 
e
m
i
s
o
r
 
r
e
e
n
v
i
a
r
a
 
e
l
 
p
a
q
u
e
t
e
 
d
e
 
d
a
t
o
s


actual
al
recibir
un
paquete
ACK
o
NAK
alterado
.
Sin
embargo
,
este
m√©todo
introduce


paquetes
duplicados
en
el
canal
emisor-receptor
.
La
principal
dificultad
con
los
paque-


tes
duplicados
es
que
el
receptor
no
sabe
si
el
√∫ltimo
paquete
ACK
o
NAK
enviado
fue


recibido
correctamente
en
el
emisor
.
Por
tanto
,
a
priori
,
no
puede
saber
si
un
paquete


entrante
contiene
datos
nuevos
o
se
trata
de
una
retransmisi√≥n
.


Una
soluci√≥n
sencilla
a
este
nuevo
problema
(
y
que
ha
sido
adoptada
en
pr√°cticamente


todos
los
protocolos
de
transferencia
de
datos
existentes
,
incluido
TCP
)
consiste
en
a√±adir


un
nuevo
campo
al
paquete
de
datos
,
y
hacer
que
el
emisor
numere
sus
paquetes
de
datos


colocando
un
n√∫mero
de
secuencia
en
este
campo
.
Entonces
bastar√°
con
que
el
receptor


compruebe
ese
n√∫mero
de
secuencia
para
determinar
si
el
paquete
recibido
es
o
no
una


retransmisi√≥n
.
Para
el
caso
de
este
protocolo
de
parada
y
espera
simple
,
un
n√∫mero
de


secuencia
de
1
bit
ser√°
suficiente
,
ya
que
le
permitir√°
al
receptor
saber
si
el
emisor
est√°


retransmitiendo
el
paquete
previamente
transmitido
(
el
n√∫mero
de
secuencia
del
paquete


recibido
tiene
el
mismo
n√∫mero
de
secuencia
que
el
paquete
recibido
m√°s
recientemente
)
o


si
se
trata
de
un
paquete
nuevo
(
el
n√∫mero
de
secuencia
es
distinto
,
est√°
desplazado
‚Äú
hacia


adelante
‚Äù
en
aritm√©tica
de
m√≥dulo
2
)
.
Puesto
que
estamos
suponiendo
que
disponemos
de


un
canal
que
no
pierde
datos
,
los
paquetes
ACK
y
NAK
no
tienen
que
indicar
el
n√∫mero
de


secuencia
del
paquete
que
est√°n
confirmando
.
El
emisor
sabe
que
un
paquete
ACK
o
NAK


recibido
(
est√©
alterado
o
no
)
fue
generado
en
respuesta
a
su
paquete
de
datos
transmitido


m√°s
recientemente
.


Las
Figuras
3.11
y
3.12
muestran
la
descripci√≥n
de
la
m√°quina
de
estados
finitos
para


rdt2.1
,
nuestra
versi√≥n
revisada
de
rdt2.0
.
Ahora
las
m√°quinas
de
estados
finitos
de
los


lados
emisor
y
receptor
de
rdt2.1
tienen
el
doble
de
estados
que
antes
.
Esto
se
debe
a
que


ahora
el
estado
del
protocolo
tiene
que
reflejar
si
el
paquete
que
est√°
enviando
actualmente


el
emisor
o
el
que
est√°
esperando
el
receptor
tiene
que
incluir
un
n√∫mero
de
secuencia
igual


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
209


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
209210
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Esperar


llamada
0


de
arriba


rdt_recibir(pqtrcb
)
&
&


(
corrupto(pqtrcb)||


esNAK(pqtrcb
)
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&


(
corrupto(pqtrcb)||


esNAK(pqtrcb
)
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)


&
&
nocorrupto(pqtrcb
)


&
&
esACK(pqtrcb
)


rdt_recibir(pqtrcb
)


&
&
nocorrupto(pqtrcb
)


&
&
esACK(pqtrcb
)


Œõ
Œõ


rdt_enviar(datos
)


pqtenv
=
crear_paquete(0,datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_enviar(datos
)


pqtenv
=
crear_paquete(1,datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


Esperar


ACK
o


NAK
0


Esperar


ACK
o


NAK
1


Esperar

 
llamada
1


de
arriba


Figura
3.11
‚Ä¢
Lado
emisor
de
rdt2.1
.


rdt_recibir(pqtrcb
)
&
&
nocorrupto


(
pqtrcb
)
&
&
tiene_sec0(pqtrcb
)


pqtenv=
crear_paquete(ACK
,

            
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
corrupto(pqtrcb
)


pqtenv
=
crear_paquete(NAK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)

 
&
&
corrupto(pqtrcb
)


pqtenv
=
crear_paquete(NAK
,

            
sumacomprobacion
)


udt_enviar(pqtenv
)


pqtenv=
crear_paquete(ACK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)

  
&
&
tiene_sec1(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


pqtenv
=
crear_paquete(ACK
,
sumacomprobacion
)


udt
enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)

 
&
&
tiene_sec0(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


pqtenv=
crear_paquete(ACK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


Esperar


0
de


abajo


Esperar


1
de


abajo


rdt_recibir(pqtrcb
)
&
&

  
nocorrupto(pqtrcb
)
&
&

  
tiene_sec1(pqtrcb
)


Figura
3.12
‚Ä¢
Lado
receptor
de
rdt2.1
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
210a
0
o
a
1
.
Observe
que
las
acciones
en
aquellos
casos
en
los
que
un
paquete
con
un
n√∫mero


de
secuencia
de
0
est√°
siendo
enviado
o
es
esperado
son
im√°genes
especulares
de
aquellos


casos
en
los
que
el
n√∫mero
de
secuencia
del
paquete
es
1
;
las
√∫nicas
diferencias
se
encuen-


tran
en
la
gesti√≥n
del
n√∫mero
de
secuencia
.
 

En
el
protocolo
rdt2.1
,
el
receptor
env√≠a
tanto
respuestas
de
reconocimiento
positivo


como
negativo
al
emisor
.
Cuando
recibe
un
paquete
fuera
de
secuencia
,
el
receptor
env√≠a
un


paquete
ACK
para
el
paquete
que
ha
recibido
.
Cuando
recibe
un
paquete
corrompido
,
el


receptor
env√≠a
una
respuesta
de
reconocimiento
negativo
.
Podemos
conseguir
el
mismo


efecto
que
con
una
respuesta
NAK
si
,
en
lugar
de
enviar
una
NAK
,
enviamos
una
respuesta


de
reconocimiento
positivo
(
ACK
)
para
el
√∫ltimo
paquete
recibido
correctamente
.
Un
emi-


sor
que
recibe
dos
respuestas
ACK
para
el
mismo
paquete
(
es
decir
,
recibe
respuestas
ACK


duplicadas
)
sabe
que
el
receptor
no
ha
recibido
correctamente
el
paquete
que
sigue
al
que


est√°
siendo
reconocido
(
respuesta
ACK
)
dos
veces
.
Nuestro
protocolo
de
transferencia
de


datos
fiable
sin
respuestas
de
tipo
NAK
para
un
canal
con
errores
de
bit
es
rdt2.2
,
el
cual


se
ilustra
en
las
Figuras
3.13
y
3.14
.
Una
sutil
variaci√≥n
entre
los
protocolos
rtdt2.1
y


rdt2.2
es
que
ahora
el
receptor
tiene
que
incluir
el
n√∫mero
de
secuencia
del
paquete
que


est√°
siendo
confirmado
mediante
un
mensaje
ACK
(
lo
que
hace
incluyendo
el
argumento


ACK,0o
ACK,1en
crear_paquete
(
)
en
la
m√°quina
de
estados
finitos
de
recepci√≥n
)
,
y
el


emisor
tiene
que
comprobar
el
n√∫mero
de
secuencia
del
paquete
que
est√°
siendo
confirmado


por
el
mensaje
ACK
recibido
(
lo
que
se
hace
incluyendo
el
argumento
0o
1en
esACK
(
)
en


la
m√°quina
de
estados
finitos
del
emisor
)
.


Transferencia
de
datos
fiable
sobre
un
canal
con
p√©rdidas


y
errores
de
bit
:
rdt3.0


Suponga
ahora
que
adem√°s
de
bits
corrompidos
,
el
canal
subyacente
tambi√©n
puede
perder


paquetes
,
un
suceso
no
desconocido
en
las
redes
de
computadoras
de
hoy
en
d√≠a
(
incluyendo


Internet
)
.
Por
tanto
,
ahora
el
protocolo
tiene
que
preocuparse
por
dos
problemas
m√°s
:
c√≥mo


detectar
la
p√©rdida
de
paquetes
y
qu√©
hacer
cuando
se
pierde
un
paquete
.
El
uso
de
la
suma


de
comprobaci√≥n
(
cheksum
)
,
los
n√∫meros
de
secuencia
,
los
paquetes
ACK
y
la
retransmi-


si√≥n
de
paquetes
,
t√©cnicas
que
ya
hemos
desarrollado
en
el
protocolo
rdt2.2
,
nos
van
a
per-


mitir
abordar
este
√∫ltimo
problema
,
Para
tratar
el
primero
ser√°
necesario
a√±adir
un
nuevo


mecanismo
de
protocolo
.


Hay
disponibles
muchas
formas
de
abordar
la
p√©rdida
de
paquetes
(
varias
de
ellas
se


exploran
en
los
ejercicios
del
final
del
cap√≠tulo
)
.
Veamos
c√≥mo
el
emisor
puede
detectar
la


p√©rdida
de
paquetes
y
c√≥mo
puede
recuperarse
de
la
misma
.
Suponga
que
el
emisor
trans-


mite
un
paquete
de
datos
y
bien
el
propio
paquete
o
el
mensaje
ACK
del
receptor
para
ese


paquete
se
pierde
.
En
cualquiera
de
estos
dos
casos
,
al
emisor
no
le
llega
ninguna
respuesta


procedente
del
receptor
.
Si
el
emisor
est√°
dispuesto
a
esperar
el
tiempo
suficiente
como
para


estar
seguro
de
que
se
ha
perdido
un
paquete
,
simplemente
puede
retransmitirlo
.
Se
puede


comprobar
de
un
modo
sencillo
que
efectivamente
este
protocolo
funciona
.


Pero
,
¬ø
cu√°nto
tiempo
tiene
que
esperar
el
emisor
para
estar
seguro
de
que
se
ha
per-


dido
un
paquete
?
Es
evidente
que
el
emisor
tiene
que
esperar
al
menos
un
tiempo
igual
al


retardo
de
ida
y
vuelta
entre
el
emisor
y
el
receptor
(
lo
que
puede
incluir
el
almacenamiento


temporal
en
los
buffers
de
los
routers
intermedios
)
m√°s
una
cierta
cantidad
de
tiempo
que


ser√°
necesaria
para
procesar
un
paquete
en
el
receptor
.
En
muchas
redes
,
este
retardo


m√°ximo
del
caso
peor
es
muy
dif√≠cil
incluso
de
estimar
y
a√∫n
m√°s
de
conocer
con
preci-


si√≥n
.
Adem√°s
,
idealmente
,
el
protocolo
deber√≠a
recuperarse
de
la
p√©rdida
de
paquetes
tan


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
211


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
211212
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Esperar


llamada
0


de
abajo


rdt_recibir(pqtrcb
)


&
&
(
corrupto(pqtrcb
)


||esACK(pqtrcb,1
)
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)


&
&
(
corrupto(pqtrcb
)


||esACK(pqtrcb,0
)
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)


&
&
nocorrupto(pqtrcb
)


&
&
esACK(pqtrcb,0
)


rdt_recibir(pqtrcb
)


&
&
nocorrupto(pqtrcb
)


&
&
esACK(pqtrcb,1
)


rdt_enviar(datos
)


pqtenv
=
crear_paquete(0,datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_enviar(datos
)


pqtenv
=
crear_paquete(1,datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


Esperar


ACK
0


Esperar


ACK
1


Œõ
Œõ


Esperar


llamada
1


de
arriba


Figura
3.13
‚Ä¢
Lado
emisor
de
rdt2.2
.


Esperar


0
de
abajo


rdt_recibir(pqtrcb
)
&
&


(
corrupto(pqtrcb)||


tiene_sec0(pqtrcb
)
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&


(
corrupto(pqtrcb)||


tiene_sec1(pqtrcb
)
)


if(oncethru==1
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)


&
&
tiene_sec1(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


pqtenv
=
crear_paquete(ACK,1,sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)


&
&
tiene_sec0(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


pqtenv
=
crear_paquete(ACK,0,sumacomprobacion
)


udt_enviar(pqtenv
)


oncethru=1oncethru=0


Esperar


1
de
abajo


Œõ


Figura
3.14
‚Ä¢
Lado
receptor
de
rdt2.2
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
2123.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
213


pronto
como
fuera
posible
;
pero
si
espera
un
tiempo
igual
al
retardo
en
el
caso
peor
,
eso


significa
una
larga
espera
hasta
iniciar
el
mecanismo
de
recuperaci√≥n
de
errores
.
Por
tanto
,


el
m√©todo
que
se
adopta
en
la
pr√°ctica
es
que
el
emisor
seleccione
juiciosamente
un
inter-


valo
de
tiempo
tal
que
sea
probable
que
un
paquete
se
haya
perdido
,
aunque
no
sea
seguro


que
tal
p√©rdida
se
haya
producido
.
Si
dentro
de
ese
intervalo
de
tiempo
no
se
ha
recibido


un
ACK
,
el
paquete
se
retransmite
.
Observe
que
si
un
paquete
experimenta
un
retardo
par-


ticularmente
grande
,
el
emisor
puede
retransmitirlo
incluso
aunque
ni
el
paquete
de
datos


ni
su
correspondiente
ACK
se
hayan
perdido
.
Esto
introduce
la
posibilidad
de
que
existan


paquetes
de
datos
duplicados
en
el
canal
emisor-receptor
.
Afortunadamente
,
el
protocolo


rdt2.2
ya
dispone
de
la
funcionalidad
(
los
n√∫meros
de
secuencia
)
para
afrontar
la
exis-


tencia
de
paquetes
duplicados
.


Desde
el
punto
de
vista
del
emisor
,
la
retransmisi√≥n
es
la
soluci√≥n
para
todo
.
El
emisor


no
sabe
si
se
ha
perdido
un
paquete
de
datos
,
se
ha
perdido
un
mensaje
ACK
,
o
simplemente


el
paquete
o
el
ACK
est√°n
retardados
.
En
todos
los
casos
,
la
acci√≥n
es
la
misma
:
retransmi-


tir
.
La
implementaci√≥n
de
un
mecanismo
de
retransmisi√≥n
basado
en
el
tiempo
requiere
un


temporizador
de
cuenta
atr√°s
que
pueda
interrumpir
al
emisor
despu√©s
de
que
haya
trans-


currido
un
determinado
periodo
de
tiempo
.
Por
tanto
,
el
emisor
necesitar√°
poder
(
1
)
iniciar


el
temporizador
cada
vez
que
env√≠e
un
paquete
(
bien
por
primera
vez
o
en
una
retransmi-


si√≥n
)
,
(
2
)
responder
a
una
interrupci√≥n
del
temporizador
(
ejecutando
las
acciones
apropia-


das
)
y
(
3
)
detener
el
temporizador
.


Esperar


llamada
0


de
arriba


rdt_recibir(pqtrcb
)


&
&
(
corrupto(pqtrcb
)


||esACK(pqtrcb,1
)
)


fin_de_temporizaci√≥n


udt_enviar(pqtenv
)


iniciar_temporizador


rdt_recibir(pqtrcb
)


Œõrdt_recibir(pqtrcb
)


&
&
(
corrupto(pqtrcb
)


||esACK(pqtrcb,0
)
)


rdt_recibir(pqtrcb
)


&
&
nocorrupto(pqtrcb
)


&
&
esACK(pqtrcb,0
)


detener_temporizador


rdt_recibir(pqtrcb
)


&
&
nocorrupto(pqtrcb
)


&
&
esACK(pqtrcb,1
)


detener_temporizador


fin_de_temporizaci√≥n


udt_enviar(pqtenv
)


iniciar_temporizador


rdt_enviar(datos
)


pqtenv
=
crear_paquete(0,datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


iniciar_temporizador


rdt_enviar(datos
)


pqtenv
=
crear_paquete(1,datos
,
sumacomprobacion
)


udt_enviar(pqtenv
)


iniciar_temporizador


Esperar


ACK
0


Esperar


ACK
1


Œõ


Œõ


Esperar


llamada
1


de
arriba


rdt_recibir(pqtrcb
)


Œõ


Figura
3.15
‚Ä¢
Lado
emisor
de
rdt3.0
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
213La
Figura
3.15
muestra
la
m√°quina
de
estados
finitos
del
emisor
para
rdt3.0
,
un
pro-


tocolo
que
transfiere
datos
de
forma
fiable
a
trav√©s
de
un
canal
que
puede
corromper
o
per-


der
paquetes
;
en
los
problemas
de
repaso
,
se
le
pedir√°
que
defina
la
m√°quina
de
estados


finitos
del
receptor
para
rdt3.0
.
La
Figura
3.16
muestra
c√≥mo
opera
el
protocolo
cuando


214
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


recibir
pqt0


enviar
ACK0


recibir
pqt1


enviar
ACK1


recibir
pqt0


enviar
ACK0


Emisor
Receptor


a.
Operaci√≥n
sin
p√©rdidas


pqt0


ACK0


pqt1


pqt0


ACK1


ACK0


(
perdido
)
X


b.
Paquete

    
perdido


recibir
pqt0


enviar
ACK0


recibir
pqt1


enviar
ACK1


c.
ACK
perdido


enviar
pqt0


recibir
ACK0


enviar
pqt1


recibir
ACK1


enviar
pqt0


enviar
pqt0


recibir
ACK0


enviar
pqt1


fin
de


temporizaci√≥n


reenviar
pqt1


recibir
ACK1


enviar
pqt0


recibir
pqt0


enviar
ACK0


recibir
pqt1


(
detectar


duplicado
)


enviar
ACK1


enviar
pqt0


recibir
ACK0


enviar
pqt1


recibir
pqt0


enviar
ACK0


fin
de


temporizaci√≥n


reenviar
pqt1


recibir
pqt1


enviar
ACK1


d.
Fin
de
temporizaci√≥n
prematuro


recibir
ACK1


enviar
pqt0


recibir
ACK1


no
hacer
nada


recibir
pqt0


enviar
ACK0


recibir
pqt1


(
detectar
duplicado
)


enviar
ACK1


Emisor
Receptor
ReceptorEmisor


pqt0


ACK0


pqt1


ACK1


ACK1


ACK0


ACK1


ACK0


pqt1


pqt0


pqt0


pqt1


pqt1


pqt0


ACK1


ACK0


X


(
perdido
)


pqt1


recibir
pqt0


enviar
ACK0


enviar
pqt0


recibir
ACK0


enviar
pqt1


fin
de


temporizaci√≥n


reenviar
pqt1


recibir
ACK1


enviar
pqt0


recibir
pqt0


enviar
ACK0


recibir
pqt1


enviar
ACK1


Emisor
Receptor


pqt0


ACK0


pqt1


pkt0


ACK1


ACK0


Figura
3.16
‚Ä¢
Operaci√≥n
de
rdt3.0
,
el
protocolo
de
bit
alternante
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
214no
se
pierden
ni
se
retardan
los
paquetes
y
c√≥mo
gestiona
la
p√©rdida
de
paquetes
de
datos
.


En
la
Figura
3.16
,
el
tiempo
va
avanzando
desde
la
parte
superior
del
diagrama
hacia
la
parte


inferior
del
mismo
;
observe
que
el
instante
de
recepci√≥n
de
un
paquete
es
necesariamente


posterior
al
instante
de
env√≠o
de
un
paquete
como
consecuencia
de
los
retardos
de
transmi-


si√≥n
y
de
propagaci√≥n
.
En
las
Figuras
3.16(b)‚Äì(d
)
,
los
corchetes
en
el
lado
del
emisor
indi-


can
los
instantes
de
inicio
y
fin
del
temporizador
.
Algunos
de
los
aspectos
m√°s
sutiles
de
este


protocolo
se
ver√°n
en
los
ejercicios
incluidos
al
final
del
cap√≠tulo
.
Dado
que
los
n√∫meros
de


secuencia
de
los
paquetes
alternan
entre
0
y
1
,
el
protocolo
rdt3.0se
denomina
en
ocasio-


nes
protocolo
de
bit
alternante
.


Hasta
aqu√≠
hemos
ensamblado
los
elementos
clave
de
un
protocolo
de
transferencia
de


datos
.
Las
sumas
de
comprobaci√≥n
,
los
n√∫meros
de
secuencia
,
los
temporizadores
y
los


paquetes
de
reconocimiento
positivo
y
negativo
desempe√±an
un
papel
fundamental
y
nece-


sario
en
el
funcionamiento
del
protocolo
.
A
continuaci√≥n
vamos
a
trabajar
con
un
protocolo


de
transferencia
de
datos
fiable
.


3.4.2
Protocolo
de
transferencia
de
datos
fiable


con
procesamiento
en
cadena


El
protocolo
rdt3.0es
un
protocolo
funcionalmente
correcto
,
pero
es
muy
improbable
que


haya
alguien
a
quien
satisfaga
su
rendimiento
,
especialmente
en
las
redes
de
ata
velocidad


actuales
.
La
base
del
problema
del
rendimiento
de
rdt3.0se
encuentra
en
el
hecho
de
que
es


un
protocolo
de
parada
y
espera
.


Para
entender
el
impacto
sobre
el
rendimiento
de
este
comportamiento
de
parada
y


espera
,
vamos
a
considerar
un
caso
ideal
de
dos
hosts
,
uno
localizado
en
la
costa
oeste
de


Estados
Unidos
y
el
otro
en
la
costa
este
,
como
se
muestra
en
la
Figura
3.17
.
El
retardo


de
propagaci√≥n
de
ida
y
vuelta
,
RTT
,
a
la
velocidad
de
la
luz
entre
estos
dos
sistemas
termi-


nales
es
aproximadamente
igual
a
30
milisegundos
.
Suponga
que
est√°n
conectados
mediante


un
canal
cuya
velocidad
de
transmisi√≥n
,
R
,
es
de
1
Gbps
(
10
9
bits
por
segundo
)
.
Con
un


tama√±o
de
paquete
,
L
,
de
1.000
bytes
(
8.000
bits
)
por
paquete
,
incluyendo
los
campos
de


cabecera
y
los
datos
,
el
tiempo
necesario
para
transmitir
el
paquete
por
un
enlace
de
1
Gbps


es
:


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
215


Paquetes
de
datosPaquete
de
datos


Paquetes
ACK


a.
Funcionamiento
de
un
protocolo

    
de
parada
y
espera
.


b.
Funcionamiento
de
un
protocolo
con

    
procesamiento
en
cadena
.


Figura
3.17
‚Ä¢
Protocolo
de
parada
y
espera
y
protocolo
con
procesamiento
en


cadena
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
215216
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Primer
bit
del
primer
paquete


transmitido
,
t
=
0


√öltimo
bit
del
primer


paquete
transmitido
,
t
=
L
/
R


Primer
bit
del
primer
paquete


transmitido
,
t
=
0


√öltimo
bit
del
primer


paquete
transmitido
,
t
=
L
/
R


Llega
el
mensaje
ACK
,


env√≠a
el
siguiente
paquete
,


t
=
RTT
+
L
/
R


a.
Funcionamiento
de
un
protocolo
de
parada
y
espera
.


Emisor
Receptor


RTT


Llega
el
primer
bit
del
primer
paquete


Llega
el
√∫ltimo
bit
del
primer
paquete
,


env√≠o
del
mensaje
ACK


Llega
el
primer
bit
del
primer
paquete


Llega
el
√∫ltimo
bit
del
primer
paquete
,


env√≠o
del
mensaje
ACK


Llega
el
mensaje
ACK
,


env√≠a
el
siguiente
paquete
,


t
=
RTT
+
L
/
R


b.
Funcionamiento
con
procesamiento
en
cadena
.


Emisor
Receptor


RTT


Llega
el
√∫ltimo
bit
del
2¬∫
paquete
,


env√≠o
del
mensaje
ACK


Llega
el
√∫ltimo
bit
del
3


er

 
paquete
,


env√≠o
del
mensaje
ACK


Figura
3.18
‚Ä¢
Proceso
de
transmisi√≥n
con
un
protocolo
de
parada
y
espera


y
un
protocolo
con
procesamiento
en
cadena
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
216La
Figura
3.18(a
)
muestra
que
,
con
nuestro
protocolo
de
parada
y
espera
,
si
el
emisor


comienza
a
transmitir
el
paquete
en
el
instante
t
=
0
,
entonces
en
el
instante
t
=
L
/
R
=
8


microsegundos
el
√∫ltimo
bit
entra
en
el
canal
en
el
lado
del
emisor
.
El
paquete
entonces
tarda


15
milisegundos
en
atravesar
el
pa√≠s
,
emergiendo
el
√∫ltimo
bit
del
paquete
en
el
lado
del


receptor
en
el
instante
t
=
RTT/2
+
L
/
R
=
15,008
milisegundos
.
Con
el
fin
de
simplificar
,


vamos
a
suponer
que
los
paquetes
de
reconocimiento
ACK
son
extremadamente
peque√±os


(
por
lo
que
podemos
ignorar
su
tiempo
de
transmisi√≥n
)
y
que
el
receptor
puede
enviar
un


ACK
tan
pronto
como
ha
recibido
el
√∫ltimo
bit
de
un
paquete
de
datos
,
llegando
dicho
ACK


al
emisor
en
t
=
RTT
+
L
/
R
=
30,008
mseg
.
En
esta
situaci√≥n
,
ahora
el
emisor
puede
transmi-


tir
el
siguiente
mensaje
.
Por
tanto
,
en
30,008
milisegundos
,
el
emisor
ha
estado
transmi-


tiendo
durante
s√≥lo
0,008
milisegundos
.
Si
definimos
la
tasa
de
utilizaci√≥n
del
emisor
(
o
del


canal
)
como
la
fracci√≥n
de
tiempo
que
el
emisor
est√°
realmente
ocupado
enviando
bits
al


canal
,
el
an√°lisis
de
la
Figura
3.18(a
)
muestra
que
el
protocolo
de
parada
y
espera
tiene
una


tasa
de
utilizaci√≥n
del
emisor
,
Uemisor
,
bastante
mala
de


Uemisor


Es
decir
,
¬°
el
emisor
s√≥lo
est√°
ocupado
2,7
diezmil√©simas
del
tiempo
!
En
otras
palabras
,


el
emisor
s√≥lo
ha
podido
enviar
1.000
bytes
en
30,008
milisegundos
,
una
tasa
de
transferen-


cia
efectiva
de
s√≥lo
267
kbps
,
incluso
disponiendo
de
un
enlace
a
1
Gbps
.
Imagine
al
infeliz


administrador
de
la
red
que
ha
pagado
una
fortuna
por
un
enlace
con
una
capacidad
de
un


gigabit
para
obtener
una
tasa
de
transferencia
de
√∫nicamente
267
kilobits
por
segundo
.
√âste


es
un
ejemplo
gr√°fico
de
c√≥mo
los
protocolos
de
red
pueden
limitar
las
capacidades
propor-


cionadas
por
el
hardware
de
red
subyacente
.
Adem√°s
,
hemos
despreciado
los
tiempos
de


procesamiento
del
protocolo
de
la
capa
inferior
tanto
en
el
emisor
como
en
el
receptor
,
as√≠


como
los
retardos
de
procesamiento
y
de
cola
que
pueden
tener
lugar
en
cualquiera
de
los


routers
intermedios
existentes
entre
el
emisor
y
el
receptor
.
La
inclusi√≥n
de
estos
efectos


s√≥lo
servir√≠a
para
incrementar
el
retardo
y
acentuar
m√°s
su
p√©simo
rendimiento
.


La
soluci√≥n
a
este
problema
de
rendimiento
concreto
es
simple
:
en
lugar
de
operar
en
el


modo
parada
y
espera
,
el
emisor
podr√≠a
enviar
varios
paquetes
sin
esperar
a
los
mensajes
de


reconocimiento
,
como
se
ilustra
en
la
Figura
3.17(b
)
.
La
Figura
3.18(b
)
muestra
que
si
el


emisor
transmite
tres
paquetes
antes
de
tener
que
esperar
a
los
paquetes
de
reconocimiento
,


la
utilizaci√≥n
del
emisor
pr√°cticamente
se
triplica
.
Dado
que
los
muchos
paquetes
que
est√°n


en
tr√°nsito
entre
el
emisor
y
el
receptor
pueden
visualizarse
como
el
relleno
de
un
conducto


(
pipeline
)
,
esta
t√©cnica
se
conoce
como
pipelining
o
procesamiento
en
cadena
.
El
procesa-


miento
en
cadena
tiene
las
siguientes
consecuencias
en
los
protocolos
de
transferencia
de


datos
fiables
:


‚Ä¢E
l
 
r
a
n
g
o
 
d
e
 
l
o
s
 
n
√∫
m
e
r
o
s
 
d
e
 
s
e
c
u
e
n
c
i
a
 
t
i
e
n
e
 
q
u
e
 
i
n
c
r
e
m
e
n
t
a
r
s
e
,
 
d
a
d
o
 
q
u
e
 
c
a
d
a
 
p
a
q
u
e
t
e
 
e
n


tr√°nsito
(
sin
contar
las
retransmisiones
)
tiene
que
tener
un
n√∫mero
de
secuencia
√∫nico
y


pueden
coexistir
m√∫ltiples
paquetes
en
tr√°nsito
que
no
hayan
sido
confirmados
mediante


un
reconocimiento
.


‚Ä¢L
o
s
 
l
a
d
o
s
 
e
m
i
s
o
r
 
y
 
r
e
c
e
p
t
o
r
 
d
e
 
l
o
s
 
p
r
o
t
o
c
o
l
o
s
 
p
u
e
d
e
n
 
t
e
n
e
r
 
q
u
e
 
a
l
m
a
c
e
n
a
r
 
e
n
 
b
u
f
f
e
r
 
m
√°
s


de
un
paquete
.
Como
m√≠nimo
,
el
emisor
tendr√°
en
el
buffer
los
paquetes
que
han
sido


transmitidos
pero
que
todav√≠a
no
han
sido
reconocidos
.
Como
veremos
enseguida
,
tam-


bi√©n
puede
ser
necesario
almacenar
en
el
buffer
del
receptor
los
paquetes
recibidos


correctamente
.


L


RTT
L
R


R
           
0
,
008


,
,
30
008
0
00027


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
217


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
217‚Ä¢E
l
 
r
a
n
g
o
 
n
e
c
e
s
a
r
i
o
 
d
e
 
l
o
s
 
n
√∫
m
e
r
o
s
 
d
e
 
s
e
c
u
e
n
c
i
a
 
y
 
l
o
s
 
r
e
q
u
i
s
i
t
o
s
 
d
e
 
b
u
f
f
e
r
 
d
e
p
e
n
d
e
r
√°
n
 
d
e


la
forma
en
que
un
protocolo
de
transferencia
de
datos
responda
a
la
p√©rdida
de
paquetes


y
a
los
paquetes
corrompidos
o
excesivamente
retardados
.
Hay
disponibles
dos
m√©todos


b√°sicos
que
permiten
la
recuperaci√≥n
de
errores
mediante
procesamiento
en
cadena
:


Retroceder
N
y
la
repetici√≥n
selectiva
.


3.4.3
Retroceder
N
(
GBN
)


En
un
protocolo
GBN
(
Go-Back-N
,
Retroceder
N
)
,
el
emisor
puede
transmitir
varios


paquetes
(
si
est√°n
disponibles
)
sin
tener
que
esperar
a
que
sean
reconocidos
,
pero
est√°
res-


tringido
a
no
tener
m√°s
de
un
n√∫mero
m√°ximo
permitido
,
N
,
de
paquetes
no
reconocidos
en


el
canal
.
En
esta
secci√≥n
vamos
a
describir
el
protocolo
GBN
con
cierto
detalle
.
Pero
antes


de
seguir
leyendo
,
le
animamos
a
practicar
con
el
applet
GBN
(
¬°
un
applet
impresionante
!
)


disponible
en
el
sitio
web
del
libro
.


La
Figura
3.19
muestra
la
parte
correspondiente
al
emisor
del
rango
de
los
n√∫meros
de


secuencia
en
un
protocolo
GBN
.
Si
definimos
la
base
como
el
n√∫mero
de
secuencia
del


paquete
no
reconocido
m√°s
antiguo
y
signumseccomo
el
n√∫mero
de
secuencia
m√°s
peque√±o


no
utilizado
(
es
decir
,
el
n√∫mero
de
secuencia
del
siguiente
paquete
que
se
va
a
enviar
)
,
enton-


ces
se
pueden
identificar
los
cuatro
intervalos
en
rango
de
los
n√∫meros
de
secuencia
.
Los
n√∫me-


ros
de
secuencia
pertenecientes
al
intervalo
[
0,base-1]corresponden
a
paquetes
que
ya
han


sido
transmitidos
y
reconocidos
.
El
intervalo
[
base
,
signumsec-1]corresponde
a
paquetes


que
ya
han
sido
enviados
pero
todav√≠a
no
se
han
reconocido
.
Los
n√∫meros
de
secuencia
del


intervalo
[
signumsec
,
base+N-1
]
se
pueden
emplear
para
los
paquetes
que
pueden
ser


enviados
de
forma
inmediata
,
en
caso
de
que
lleguen
datos
procedentes
de
la
capa
superior
.
Y
,


por
√∫ltimo
,
los
n√∫meros
de
secuencia
mayores
o
iguales
que
base+Nno
pueden
ser
utilizados


hasta
que
un
paquete
no
reconocido
que
se
encuentre
actualmente
en
el
canal
sea
reconocido


(
espec√≠ficamente
,
el
paquete
cuyo
n√∫mero
de
secuencia
sea
igual
a
base
)
.


Como
sugiere
la
Figura
3.19
,
el
rango
de
los
n√∫meros
de
secuencia
permitidos
para
los


paquetes
transmitidos
pero
todav√≠a
no
reconocidos
puede
visualizarse
como
una
ventana
de


tama√±o
N
sobre
el
rango
de
los
n√∫meros
de
secuencia
.
Cuando
el
protocolo
opera
,
esta
ven-


tana
se
desplaza
hacia
adelante
sobre
el
espacio
de
los
n√∫meros
de
secuencia
.
Por
esta
raz√≥n
,


N
suele
denominarse
tama√±o
de
ventana
y
el
propio
protocolo
GBN
se
dice
que
es
un
pro-


tocolo
de
ventana
deslizante
.
Es
posible
que
se
est√©
preguntando
,
para
empezar
,
por
qu√©


debemos
limitar
a
N
el
n√∫mero
de
paquetes
no
reconocidos
en
circulaci√≥n
.
¬ø
Por
qu√©
no
per-


mitir
un
n√∫mero
ilimitado
de
tales
paquetes
?
En
la
Secci√≥n
3.5
veremos
que
el
control
de


218
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


base
signumsec


Tama√±o
de
ventana


N


Clave
:


Ya
reconocido


(
ACK
)


Enviado
,
todav√≠a


no
reconocido


(
ACK
)


Utilizable
,


todav√≠a
no
enviado


No
utilizable


Figure
3.19
‚Ä¢
N√∫meros
de
secuencia
en
el
emisor
en
el
protocolo
Retroceder
N.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
2183.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
219


flujo
es
una
de
las
razones
para
imponer
un
l√≠mite
en
el
emisor
.
En
la
Secci√≥n
3.7
examina-


remos
otra
raz√≥n
al
estudiar
el
mecanismo
de
control
de
congesti√≥n
de
TCP
.


En
la
pr√°ctica
,
el
n√∫mero
de
secuencia
de
un
paquete
se
incluye
en
un
campo
de


longitud
fija
de
la
cabecera
del
paquete
.
Si
k
es
el
n√∫mero
de
bits
contenido
en
el
campo
que


especifica
el
n√∫mero
de
secuencia
del
paquete
,
el
rango
de
los
n√∫meros
de
secuencia
ser√°


[
0,2k
‚Äì
1
]
.
Con
un
rango
finito
de
n√∫meros
de
secuencia
,
todas
las
operaciones
aritm√©ticas


que
impliquen
a
los
n√∫meros
de
secuencia
tendr√°n
que
efectuarse
utilizando
aritm√©tica
en


m√≥dulo
2k
.
(
Es
decir
,
el
espacio
de
n√∫meros
de
secuencia
puede
interpretarse
como
un
anillo


de
tama√±o
2
k
,
donde
el
n√∫mero
de
secuencia
2
k
‚Äì
1
va
seguido
por
el
n√∫mero
de
secuencia


0
.
)
Recuerde
que
el
protocolo
rdt3.0
dispone
de
un
n√∫mero
de
secuencia
de
1
bit
y
de
un


rango
de
n√∫meros
de
secuencia
de
[
0,1
]
.
Algunos
de
los
problemas
incluidos
al
final
del


cap√≠tulo
exploran
las
consecuencias
de
disponer
de
un
rango
finito
de
n√∫meros
de
secuen-


cia
.
En
la
Secci√≥n
3.5
veremos
que
TCP
utiliza
un
campo
para
el
n√∫mero
de
secuencia
de
32


bits
,
donde
los
n√∫meros
de
secuencia
cuentan
los
bytes
del
flujo
de
datos
,
en
lugar
de
los


paquetes
.


Las
Figuras
3.20
y
3.21
proporcionan
una
descripci√≥n
ampliada
de
la
m√°quina
de
esta-


dos
finitos
de
los
lados
emisor
y
receptor
de
un
protocolo
GBN
basado
en
paquetes
de
reco-


nocimiento
ACK
y
que
no
emplea
paquetes
de
reconocimiento
NAK
.
Nos
referiremos
a
esta


descripci√≥n
de
una
FSM
como
FSM
ampliada
,
ya
que
hemos
a√±adido
variables
(
similares
a


las
variables
de
un
lenguaje
de
programaci√≥n
)
para
basey
signumsec
,
y
operaciones
sobre


dichas
variables
y
acciones
condicionales
que
las
implican
.
Observe
que
la
especificaci√≥n


de
una
FSM
ampliada
empieza
a
asemejarse
a
una
especificaci√≥n
de
un
lenguaje
de
progra-


maci√≥n
.
[
Bochman
1984
]
proporciona
un
excelente
repaso
de
otras
ampliaciones
de
las
t√©c-


nicas
de
m√°quinas
de
estados
finitos
,
as√≠
como
de
t√©cnicas
basadas
en
lenguajes
de


programaci√≥n
para
la
especificaci√≥n
de
protocolos
.


El
emisor
del
protocolo
GBN
tiene
que
responder
a
tres
tipos
de
sucesos
:


‚Ä¢
Invocaci√≥n
desde
la
capa
superior
.
Cuando
se
llama
a
rdt_enviar
(
)
desde
la
capa


superior
,
lo
primero
que
hace
el
emisor
es
ver
si
la
ventana
est√°
llena
;
es
decir
,
si
hay
N


paquetes
no
reconocidos
en
circulaci√≥n
.
Si
la
ventana
no
est√°
llena
,
se
crea
y
se
env√≠a
un


paquete
y
se
actualizan
las
variables
de
la
forma
apropiada
.
Si
la
ventana
est√°
llena
,
el


emisor
simplemente
devuelve
los
datos
a
la
capa
superior
,
indicando
de
forma
impl√≠cita


que
la
ventana
est√°
llena
.
Probablemente
entonces
la
capa
superior
volver√°
a
intentarlo


m√°s
tarde
.
En
una
implementaci√≥n
real
,
muy
posiblemente
el
emisor
almacenar√≠a
en
el


buffer
estos
datos
(
pero
no
los
enviar√≠a
de
forma
inmediata
)
o
dispondr√≠a
de
un
meca-


nismo
de
sincronizaci√≥n
(
por
ejemplo
,
un
sem√°foro
o
un
indicador
)
que
permitir√≠a
a
la


capa
superior
llamar
a
rdt_enviar()s√≥lo
cuando
la
ventana
no
estuviera
llena
.


‚Ä¢
Recepci√≥n
de
un
mensaje
de
reconocimiento
ACK
.
En
nuestro
protocolo
GBN
,
un
reco-


nocimiento
de
un
paquete
con
un
n√∫mero
de
secuencia
n
implica
un
reconocimiento


acumulativo
,
lo
que
indica
que
todos
los
paquetes
con
un
n√∫mero
mayor
o
igual
que
n


han
sido
correctamente
recibidos
por
el
receptor
.
V
olveremos
sobre
este
tema
enseguida


al
examinar
el
lado
receptor
de
GBN
.


‚Ä¢
Un
suceso
de
fin
de
temporizaci√≥n
.
El
nombre
de
este
protocolo
,
‚Äú
Retroceder
N
‚Äù
,
se


deriva
del
comportamiento
del
emisor
en
presencia
de
paquetes
perdidos
o
muy
retarda-


dos
.
Como
en
los
protocolos
de
parada
y
espera
,
se
emplear√°
un
temporizador
para
recu-


perarse
de
la
p√©rdida
de
paquetes
de
datos
o
de
reconocimiento
de
paquetes
.
Si
se


produce
un
fin
de
temporizaci√≥n
,
el
emisor
reenv√≠a
todos
los
paquetes
que
haya
transmi-
 

M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
219Figura
3.20
‚Ä¢
Descripci√≥n
de
la
FSM
ampliada
del
lado
de
emisi√≥n
de
GBN
.


Figura
3.21
‚Ä¢
Descripci√≥n
de
la
FSM
ampliada
del
lado
receptor
de
GBN
.


tido
anteriormente
y
que
todav√≠a
no
hayan
sido
reconocidos
.
El
emisor
de
la
Figura
3.20


utiliza
un
√∫nico
temporizador
,
que
puede
interpretarse
como
un
temporizador
para
los


paquetes
transmitidos
pero
todav√≠a
no
reconocidos
.
Si
se
recibe
un
paquete
ACK
pero


existen
m√°s
paquetes
transmitidos
adicionales
no
reconocidos
,
entonces
se
reinicia
el
tem-


porizador
.
Si
no
hay
paquetes
no
reconocidos
en
circulaci√≥n
,
el
temporizador
se
detiene
.


rdt_recibir(pqtrcb
)

  
&
&
nocorrupto(pqtrcb
)

  
&
&
conNumSec(pqtrcb
,
numsecesperado
)


extract(pqtrcb
,
datos
)


entregar_datos(datos
)


pqtenv
=
crear_paquete(numsecesperado
,
ACK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


numsecesperado++


numsecesperado=1


pqtenv
=
crear_paquete(0,ACK
,
sumacomprobacion
)


por_defecto


udt_enviar(pqtenv
)


Esperar


220
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


rdt_enviar(datos
)


if(signumsec
<
base+N
)
{

   
pqtenv[signumsec]=crear_paquete(signumsec
,
datos
,
sumacomprobacion
)

   
udt_enviar(pqtenv[signumsec
]
)

   
if(base==signumsec
)

      
iniciar_temporizador

   
signumsec++

   
}


else

   
rechazar_datos(datos
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)


base
=
obtenernumack(pqtrcb)+1


If(base==signumsec
)

   
detener_temporizador


else

   
iniciar_temporizador


rdt_recibir(pqtrcb
)


&
&
corrupto(pqtrcb
)


base=1


signumsec=1


fin_de_temporizaci√≥n


iniciar_temporizador


udt_enviar(pqtenv[base
]
)


udt_enviar(pqtenv[base+1
]
)


...


udt_enviar(pqtenv[signumsec-1
]
)


Esperar


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
220Las
acciones
del
receptor
en
el
protocolo
GBN
tambi√©n
son
simples
.
Si
un
paquete
con


un
n√∫mero
de
secuencia
n
se
recibe
correctamente
y
en
orden
(
es
decir
,
los
√∫ltimos
datos


entregados
a
la
capa
superior
proceden
de
un
paquete
con
el
n√∫mero
de
secuencia
n
‚Äì
1
)
,
el


receptor
env√≠a
un
paquete
ACK
para
el
paquete
n
y
entrega
la
parte
de
los
datos
del
paquete


a
la
capa
superior
.
En
todos
los
restantes
casos
,
el
receptor
descarta
el
paquete
y
reenv√≠a
un


mensaje
ACK
para
el
paquete
recibido
en
orden
m√°s
recientemente
.
Observe
que
dado
que


los
paquetes
se
entregan
a
la
capa
superior
de
uno
en
uno
,
si
el
paquete
k
ha
sido
recibido
y


entregado
,
entonces
todos
los
paquetes
con
un
n√∫mero
de
secuencia
menor
que
k
tambi√©n


han
sido
entregados
.
Por
tanto
,
el
uso
de
confirmaciones
acumulativas
es
una
opci√≥n
natural


del
protocolo
GBN
.


En
nuestro
protocolo
GBN
,
el
receptor
descarta
los
paquetes
que
no
est√°n
en
orden
.


Aunque
puede
parecer
algo
tonto
y
una
p√©rdida
de
tiempo
descartar
un
paquete
recibido


correctamente
(
pero
desordenado
)
,
existe
una
justificaci√≥n
para
hacerlo
.
Recuerde
que
el


receptor
debe
entregar
los
datos
en
orden
a
la
capa
superior
.
Suponga
ahora
que
se
espera
el


paquete
n
,
pero
llega
el
paquete
n
+
1
.
Puesto
que
los
datos
tienen
que
ser
entregados
en


orden
,
el
receptor
podr√≠aguardar
en
el
buffer
el
paquete
n
+
1
y
luego
entregar
ese
paquete


a
la
capa
superior
despu√©s
de
haber
recibido
y
entregado
el
paquete
n.
Sin
embargo
,
si
se


pierde
el
paquete
n
,
tanto
√©l
como
el
paquete
n
+
1
ser√°n
retransmitidos
como
resultado
de
la


regla
de
retransmisi√≥n
del
protocolo
GBN
en
el
lado
de
emisi√≥n
.
Por
tanto
,
el
receptor
puede


simplemente
descartar
el
paquete
n
+
1
.
La
ventaja
de
este
m√©todo
es
la
simplicidad
del


almacenamiento
en
el
buffer
del
receptor
(
el
receptor
no
necesita
almacenar
en
el
buffer


ninguno
de
los
paquetes
entregados
desordenados
.
Por
tanto
,
mientras
el
emisor
tiene
que


mantener
los
l√≠mites
inferior
y
superior
de
su
ventana
y
la
posici√≥n
de
signumsecdentro
de


esa
ventana
,
el
√∫nico
fragmento
de
informaci√≥n
que
el
receptor
debe
mantener
es
el
n√∫mero


de
secuencia
del
siguiente
paquete
en
orden
.
Este
valor
se
almacena
en
la
variable
numsec-


esperado
,
como
se
muestra
en
la
m√°quina
de
estados
finitos
del
receptor
de
la
Figura
3.21
.


Por
supuesto
,
la
desventaja
de
descartar
un
paquete
correctamente
recibido
es
que
la
subsi-


guiente
retransmisi√≥n
de
dicho
paquete
puede
perderse
o
alterarse
y
,
por
tanto
,
ser
necesa-


rias
a√∫n
m√°s
retransmisiones
.


La
Figura
3.22
muestra
el
funcionamiento
del
protocolo
GBN
para
el
caso
de
un
tama√±o


de
ventana
de
cuatro
paquetes
.
A
causa
de
esta
limitaci√≥n
del
tama√±o
de
ventana
,
el
emisor


transmite
los
paquetes
0
a
3
,
pero
tiene
que
esperar
a
que
uno
o
m√°s
de
estos
paquetes
sean


reconocidos
antes
de
continuar
.
A
medida
que
se
reciben
los
sucesivos
paquetes
ACK
(
por


ejemplo
,
ACK0
y
ACK1
)
,
la
ventana
se
desplaza
hacia
adelante
y
el
emisor
puede
transmitir


un
nuevo
paquete
(
pqt4y
pqt5
,
respectivamente
)
.
En
el
lado
receptor
se
pierde
el
paquete


2
y
,
por
tanto
,
los
paquetes
3
,
4
y
5
no
se
reciben
en
el
orden
correcto
y
,
l√≥gicamente
,
se
des-


cartan
.


Antes
de
terminar
esta
exposici√≥n
acerca
de
GBN
,
merece
la
pena
destacar
que
una


implementaci√≥n
de
este
protocolo
en
una
pila
de
protocolos
tendr√≠a
probablemente
una


estructura
similar
a
la
de
la
m√°quina
de
estados
finitos
ampliada
de
la
Figura
3.20
.
Posible-


mente
,
la
implementaci√≥n
se
realizar√≠a
mediante
varios
procedimientos
que
implementasen


las
acciones
que
habr√≠a
que
realizar
en
respuesta
a
los
distintos
sucesos
que
pueden
produ-


cirse
.
En
una
programaci√≥n
basada
en
sucesos
,
los
diversos
procedimientos
son
llamados


(
invocados
)
por
otros
procedimientos
de
la
pila
de
protocolos
,
o
como
resultado
de
una
inte-


rrupci√≥n
.
En
el
emisor
,
estos
sucesos
podr√≠an
ser
(
1
)
una
llamada
de
una
entidad
de
la
capa


superior
para
invocar
rdt_enviar
(
)
,
(
2
)
una
interrupci√≥n
del
temporizador
y
(
3
)
una
lla-


mada
de
la
capa
inferior
para
invocar
rdt_recibir()cuando
llega
un
paquete
.
Los
ejerci-


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
221


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
221Figura
3.22
‚Ä¢
Funcionamiento
del
protocolo
GBN
(
Retroceder
N
)
.


cios
sobre
programaci√≥n
incluidos
al
final
del
cap√≠tulo
le
dar√°n
la
oportunidad
de
implemen-


tar
en
la
pr√°ctica
estas
rutinas
en
una
red
simulada
,
pero
realista
.


Observe
que
el
protocolo
GBN
incorpora
casi
todas
las
t√©cnicas
que
veremos
en
la
Sec-


ci√≥n
3.5
al
estudiar
los
componentes
del
servicio
de
transferencia
de
datos
fiable
de
TCP
.


Estas
t√©cnicas
incluyen
el
uso
de
n√∫meros
de
secuencia
,
reconocimientos
acumulativos
,


sumas
de
comprobaci√≥n
y
una
operaci√≥n
de
fin
de
temporizaci√≥n
/
retransmisi√≥n
.


3.4.4
Repetici√≥n
selectiva
(
SR
)


El
protocolo
GBN
permite
al
emisor
,
en
teor√≠a
,
‚Äú
llenar
el
conducto
‚Äù
mostrado
en
la
Figura


3.17
con
paquetes
,
evitando
as√≠
los
problemas
de
utilizaci√≥n
del
canal
que
hemos
visto
con


los
protocolos
de
parada
y
espera
.
Sin
embargo
,
hay
algunos
escenarios
en
los
que
el
propio


GBN
presenta
problemas
de
rendimiento
.
En
particular
,
cuando
el
tama√±o
de
la
ventana
y
el


Emisor
Receptor

 
enviar
pqt0

 
enviar
pqt1

 
enviar
pqt2


enviar
pqt3

  
(
esperar
)

 
recibir
ACK0


enviar
pqt4

 
recibir
ACK1


enviar
pqt5


enviar
pqt2


enviar
pqt3


enviar
pqt4


enviar
pqt5

        
fin
de


temporiz
.
pqt2


recibir
pqt0


enviar
ACK0


recibir
pqt1


enviar
ACK1


recibir
pqt3
,
descartar


enviar
ACK1


recibir
pqt4
,
descartar


enviar
ACK1


recibir
pqt5
,
descartar


enviar
ACK1


recibir
pqt2
,
entregar


enviar
ACK2


recibir
pqt3
,
entregar


enviar
ACK3


X


(
perdido
)


222
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
222producto
ancho
de
banda-retardo
son
grandes
puede
haber
muchos
paquetes
en
el
canal
.
En


este
caso
,
un
√∫nico
paquete
err√≥neo
podr√≠a
hacer
que
el
protocolo
GBN
retransmitiera
una


gran
cantidad
de
paquetes
,
muchos
de
ellos
de
forma
innecesaria
.
A
medida
que
la
probabi-


lidad
de
errores
en
el
canal
aumenta
,
el
canal
puede
comenzar
a
llenarse
con
estas
retransmi-


siones
innecesarias
.
En
nuestro
escenario
del
dictado
de
mensajes
,
imagine
que
si
cada
vez


que
se
altera
una
palabra
,
las
1.000
palabras
que
la
rodean
(
por
ejemplo
,
con
un
tama√±o
de


ventana
de
1.000
palabras
)
tuvieran
que
ser
repetidas
,
el
dictado
se
ralentizar√≠a
a
causa
de
la


repetici√≥n
de
palabras
.


Como
su
nombre
sugiere
,
los
protocolos
de
repetici√≥n
selectiva
evitan
las
retransmisio-


nes
innecesarias
haciendo
que
el
emisor
√∫nicamente
retransmita
aquellos
paquetes
que
se


sospeche
que
llegaron
al
receptor
con
error
(
es
decir
,
que
se
perdieron
o
estaban
corrompi-


dos
)
.
Esta
retransmisi√≥n
individualizada
y
necesaria
requerir√°
que
el
receptor
confirme


individualmente
qu√©
paquetes
ha
recibido
correctamente
.
De
nuevo
,
utilizaremos
una
ven-


tana
de
tama√±o
N
para
limitar
el
n√∫mero
de
paquetes
no
reconocidos
y
en
circulaci√≥n
en
el


canal
.
Sin
embargo
,
a
diferencia
de
GBN
,
el
emisor
ya
habr√°
recibido
mensajes
ACK
para


algunos
de
los
paquetes
de
la
ventana
.
En
la
Figura
3.23
se
muestra
el
espacio
de
n√∫meros


de
secuencia
del
lado
de
emisi√≥n
del
protocolo
SR
.
La
Figura
3.24
detalla
las
distintas
accio-


nes
que
lleva
a
cabo
el
emisor
del
protocolo
SR
.


El
receptor
de
SR
confirmar√°
que
un
paquete
se
ha
recibido
correctamente
tanto
si
se
ha


recibido
en
el
orden
correcto
como
si
no
.
Los
paquetes
no
recibidos
en
orden
se
almacena-


r√°n
en
el
buffer
hasta
que
se
reciban
los
paquetes
que
faltan
(
es
decir
,
los
paquetes
con


n√∫meros
de
secuencia
menores
)
,
momento
en
el
que
un
lote
de
paquetes
puede
entregarse
en


orden
a
la
capa
superior
.
En
la
Figura
3.25
se
enumeran
las
acciones
tomadas
por
el
receptor


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
223


base_emision
signumsec


Tama√±o
de
ventana


N


Clave
:


Clave
:


Ya
reconocido


Enviado
,
todav√≠a


no
reconocido


Utilizable
,


todav√≠a


no
enviado


No
utilizable


Desordenado


(
en
buffer
)
,
pero


ya
reconocido


Esperado
,
todav√≠a


no
recibido


Aceptable


(
dentro
de


la
ventana
)


No
utilizable


a.
 
N√∫meros
de
secuencia
en
el
emisor
.


b.
N√∫meros
de
secuencia
en
el
receptor
.


base_recepcion


Tama√±o
de
ventana


N


Figura
3.23
‚Ä¢
Espacios
de
n√∫meros
de
secuencia
del
lado
emisor
y
del
lado


receptor
en
el
protocolo
de
repetici√≥n
selectiva
(
SR
)
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
223de
SR
.
La
Figura
3.26
muestra
un
ejemplo
del
funcionamiento
de
SR
en
presencia
de
paque-


tes
perdidos
.
Observe
que
,
en
esta
figura
,
inicialmente
el
receptor
almacena
en
el
buffer
los


paquetes
3
,
4
y
5
,
y
luego
los
entrega
,
junto
con
el
paquete
2
,
a
la
capa
superior
una
vez
que


se
ha
recibido
dicho
paquete
2
.


Es
importante
observar
en
el
Paso
2
de
la
Figura
3.25
que
el
receptor
vuelve
a
recono-


cer
(
en
lugar
de
ignorar
)
los
paquetes
ya
recibidos
con
determinados
n√∫meros
de
secuencia


inferiores
al
n√∫mero
base
actual
de
la
ventana
.
Puede
comprobar
f√°cilmente
que
este
doble


reconocimiento
es
necesario
.
Por
ejemplo
,
dados
los
espacios
de
n√∫meros
de
secuencia
del


emisor
y
del
receptor
de
la
Figura
3.23
,
si
no
hay
ning√∫n
paquete
ACK
para
el
paquete


base_emision
propag√°ndose
desde
el
receptor
al
emisor
,
finalmente
el
emisor
retransmi-


tir√°
el
paquete
base_emision
,
incluso
aunque
est√©
claro
(
¬°
para
nosotros
,
pero
no
para
el


224
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


1
.
Datos
recibidos
de
la
capa
superior
.
Cuando
se
reciben
datos
de
la
capa
superior
,
el
emisor
de
SR
com-


prueba
el
siguiente
n√∫mero
de
secuencia
disponible
para
el
paquete
.
Si
el
n√∫mero
de
secuencia
se
encuen-


tra
dentro
de
la
ventana
del
emisor
,
los
datos
se
empaquetan
y
se
env√≠an
;
en
caso
contrario
,
bien
se


almacenan
en
el
buffer
o
bien
se
devuelven
a
la
capa
superior
para
ser
transmitidos
m√°s
tarde
,
como
en
el


caso
del
protocolo
GBN
.


2
.
Fin
de
temporizaci√≥n
.
D
e
 
n
u
e
v
o
,
 
s
e
 
e
m
p
l
e
a
n
 
t
e
m
p
o
r
i
z
a
d
o
r
e
s
 
c
o
n
t
r
a
 
l
a
 
p
√©
r
d
i
d
a
 
d
e
 
p
a
q
u
e
t
e
s
.
 
S
i
n
 
e
m
b
a
r
g
o
,


ahora
,
cada
paquete
debe
tener
su
propio
temporizador
l√≥gico
,
ya
que
s√≥lo
se
transmitir√°
un
paquete
al


producirse
el
fin
de
la
temporizaci√≥n
.
Se
puede
utilizar
un
mismo
temporizador
hardware
para
imitar
el


funcionamiento
de
varios
temporizadores
l√≥gicos
[
Varghese
1997
]
.


3
.
ACK
recibido
.
S
i
 
s
e
 
h
a
 
r
e
c
i
b
i
d
o
 
u
n
 
m
e
n
s
a
j
e
 
A
C
K
,
 
e
l
 
e
m
i
s
o
r
 
d
e
 
S
R
 
m
a
r
c
a
 
d
i
c
h
o
 
p
a
q
u
e
t
e
 
c
o
m
o
 
q
u
e
 
h
a
 
s
i
d
o


recibido
,
siempre
que
est√©
dentro
de
la
ventana
.
Si
el
n√∫mero
de
secuencia
del
paquete
es
igual
a


base_emision
,
se
hace
avanzar
la
base
de
la
ventana
,
situ√°ndola
en
el
paquete
no
reconocido
que
tenga


el
n√∫mero
de
secuencia
m√°s
bajo
.
Si
la
ventana
se
desplaza
y
hay
paquetes
que
no
han
sido
transmitidos


con
n√∫meros
de
secuencia
que
ahora
caen
dentro
de
la
ventana
,
entonces
esos
paquetes
se
transmiten
.


Figura
3.24
‚Ä¢
Sucesos
y
acciones
en
el
lado
emisor
del
protocolo
SR
.


1
.
Se
ha
recibido
correctamente
un
paquete
cuyo
n√∫mero
de
secuencia
pertenece
al
intervalo[base_recep-


cion
,
base_recepcion+N-1
]
.
En
este
caso
,
el
paquete
recibido
cae
dentro
de
la
ventana
del
receptor
y
se


devuelve
al
emisor
un
paquete
ACK
selectivo
.
Si
el
paquete
no
ha
sido
recibido
con
anterioridad
,
se
alma-


cena
en
el
buffer
.
Si
este
paquete
tiene
un
n√∫mero
de
secuencia
igual
a
la
base
de
la
ventana
de
recepci√≥n


(
base_recepcionen
la
Figura
3.22
)
,
entonces
este
paquete
y
cualquier
paquete
anteriormente
almacenado


en
el
buffer
y
numerado
consecutivamente
(
comenzando
por
base_recepcion
)
se
entregan
a
la
capa
supe-


rior
.
La
ventana
de
recepci√≥n
avanza
entonces
el
n√∫mero
de
paquetes
suministrados
entregados
a
la
capa


superior
.
Por
ejemplo
,
en
la
Figura
3.26
,
cuando
se
recibe
un
paquete
con
el
n√∫mero
de
secuencia


base_recepcion
=
2
,
√©ste
y
los
paquetes
3
,
4
y
5
pueden
entregarse
a
la
capa
superior
.


2
.
Se
ha
recibido
correctamente
un
paquete
cuyo
n√∫mero
de
secuencia
pertenece
al
intervalo
[
base_recep-


cion-N
,
base_recepcion
-1
]
.
En
este
caso
,
se
tiene
que
generar
un
mensaje
ACK
,
incluso
aunque


ese
paquete
haya
sido
reconocido
anteriormente
por
el
receptor
.


3
.
En
cualquier
otro
caso
.
Ignorar
el
paquete
.


Figura
3.25
‚Ä¢
Sucesos
y
acciones
en
el
lado
receptor
del
protocolo
SR
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
224emisor
!
)
que
el
receptor
ya
ha
recibido
dicho
paquete
.
Si
el
receptor
no
hubiera
confirmado


este
paquete
,
la
ventana
del
emisor
nunca
avanzar√≠a
.
Este
ejemplo
ilustra
un
aspecto
impor-


tante
de
los
protocolos
SR
(
y
de
otros
muchos
protocolos
)
.
El
emisor
y
el
receptor
no
siem-


pre
tienen
una
visi√≥n
id√©ntica
de
lo
que
se
ha
recibido
correctamente
y
de
lo
que
no
.
En
los


protocolos
SR
,
esto
significa
que
las
ventanas
del
emisor
y
del
receptor
no
siempre
coinci-


den
.


La
falta
de
sincronizaci√≥n
entre
las
ventanas
del
emisor
y
del
receptor
tiene
consecuen-


cias
importantes
cuando
nos
enfrentamos
con
la
realidad
de
un
rango
finito
de
n√∫meros
de


secuencia
.
Por
ejemplo
,
imagine
lo
que
ocurrir√≠a
con
un
rango
de
cuatro
n√∫meros
de
secuen-


cia
de
paquete
,
0
,
1
,
2
,
3
,
y
un
tama√±o
de
ventana
de
tres
.
Suponga
que
los
paquetes
0
a
2
se


transmiten
y
son
recibidos
correctamente
y
reconocidos
por
el
receptor
.
En
esta
situaci√≥n
,
la


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
225


pqt0
recibido
,
entregado
,
ACK0
enviado


0
1
2
3
4
5
6
7
8
9


pqt1
recibido
,
entregado
,
ACK1
enviado


0
1
2
3
4
5
6
7
8
9


pqt3
recibido
,
en
buffer
,
ACK3
enviado


0
1
2
3
4
5
6
7
8
9


pqt4
recibido
,
en
buffer
,
ACK4
enviado


0
1
2
3
4
5
6
7
8
9


pqt5
recibido
;
en
buffer
,
ACK5
enviado


0
1
2
3
4
5
6
7
8
9


pqt2
recibido
,
pqt2,pqt3,pqt4,pqt5


entregados
,
ACK2
enviado


0
1
2
3
4
5
6
7
8
9


pqt0
enviado


0
1
2
3
4
5
6
7
8
9


pqt1
enviado


0
1
2
3
4
5
6
7
8
9


pqt2
enviado


0
1
2
3
4
5
6
7
8
9


pqt3
enviado
,


ventana
completa


0
1
2
3
4
5
6
7
8
9


ACK0
recibido
,


pqt4
enviado


0
1
2
3
4
5
6
7
8
9


ACK1
recibido
,


pqt5
enviado


0
1
2
3
4
5
6
7
8
9


pqt2
FIN
TEMPOR
.
,


pqt2
reenviado


0
1
2
3
4
5
6
7
8
9


ACK3
recibido
,


no
se
env√≠a
nada


0
1
2
3
4
5
6
7
8
9


X


(
perdido
)


Emisor
Receptor


Figura
3.26
‚Ä¢
Funcionamiento
del
protocolo
SR
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
225ventana
del
receptor
se
encontrar√≠a
sobre
los
paquetes
cuarto
,
quinto
y
sexto
,
que
tienen
los


n√∫meros
de
secuencia
3
,
0
y
1
,
respectivamente
.
Ahora
consideremos
dos
escenarios
.
En
el


primero
,
mostrado
en
la
Figura
3.27(a
)
,
los
mensajes
ACK
para
los
tres
primeros
paquetes


se
pierden
y
el
emisor
los
retransmite
.
A
continuaci√≥n
,
el
receptor
recibe
un
paquete
con
el


n√∫mero
de
secuencia
0
,
una
copia
del
primer
paquete
enviado
.


226
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


pqt0


fin
de
temporizaci√≥n


retransmitir
paquete
0


0
1
2
3
0
1
2


pqt0


pqt1


pqt2


0
1
2
3
0
1
2


0
1
2
3
0
1
2


0
1
2
3
0
1
2


0
1
2
3
0
1
2ACK0


ACK1


ACK2x


0
1
2
3
0
1
2


0
1
2
3
0
1
2

  
Ventana
del
emisor


(
despu√©s
de
la
recepci√≥n
)


a.


b.

   
Ventana
del
receptor


(
despu√©s
de
la
recepci√≥n
)


recibir
paquete
con


el
n√∫mero
de
secuencia
0


0
1
2
3
0
1
2


0
1
2
3
0
1
2


0
1
2
3
0
1
2


0
1
2
3
0
1
2


0
1
2
3
0
1
2ACK0


ACK1


ACK2


0
1
2
3
0
1
2


0
1
2
3
0
1
2

  
Ventana
del
emisor


(
despu√©s
de
la
recepci√≥n
)

   
Ventana
del
receptor


(
despu√©s
de
la
recepci√≥n
)


recibir
paquete
con


el
n√∫mero
de
secuencia
0


0
1
2
3
0
1
2


x


x


x


pqt0


pqt1


pqt2


pqt3


pqt0


Figura
3.27
‚Ä¢
Dilema
del
receptor
de
los
protocolos
SR
con
ventanas


demasiado
grandes
:
¬ø
un
nuevo
paquete
o
una
retransmisi√≥n
?


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
226En
el
segundo
escenario
,
mostrado
en
la
Figura
3.27(b
)
,
los
mensajes
ACK
correspon-


dientes
a
los
tres
primeros
paquetes
se
entregan
correctamente
.
El
emisor
hace
avanzar
su


ventana
y
env√≠a
los
paquetes
cuarto
,
quinto
y
sexto
,
con
los
n√∫mero
de
secuencia
3
,
0
y
1
,


respectivamente
.
El
paquete
con
el
n√∫mero
de
secuencia
3
se
pierde
pero
llega
el
paquete


con
el
n√∫mero
de
secuencia
0
,
un
paquete
que
contiene
datos
nuevos
.


Examinemos
ahora
el
punto
de
vista
del
receptor
en
la
Figura
3.27
,
el
cual
tiene


delante
una
cortina
imaginaria
entre
el
emisor
y
el
receptor
,
ya
que
el
receptor
no
puede


‚Äú
ver
‚Äù
las
acciones
que
lleva
a
cabo
el
emisor
.
Todo
lo
que
ve
el
receptor
es
la
secuencia
de


mensajes
que
recibe
del
canal
y
que
√©l
env√≠a
al
mismo
.
En
lo
que
respecta
al
receptor
,
los


dos
escenarios
de
la
Figura
3.27
son
id√©nticos
.
No
hay
forma
de
diferenciar
la
retransmi-


si√≥n
del
primer
paquete
de
la
transmisi√≥n
inicial
del
quinto
paquete
.
Evidentemente
,
un


tama√±o
de
ventana
que
sea
una
unidad
menor
que
el
tama√±o
del
espacio
de
n√∫meros
de


secuencia
no
puede
funcionar
.
Entonces
,
¬ø
cu√°l
tiene
que
ser
el
tama√±o
de
la
ventana
?
Uno


de
los
problemas
incluidos
al
final
del
cap√≠tulo
le
pedir√°
que
demuestre
que
el
tama√±o
de
la


ventana
tiene
que
ser
menor
o
igual
que
la
mitad
del
tama√±o
del
espacio
de
n√∫meros
de


secuencia
en
los
protocolos
SR
.


En
el
sitio
web
de
acompa√±amiento
encontrar√°
un
applet
que
simula
el
funcionamiento


del
protocolo
SR
.
Intente
llevar
a
cabo
los
mismos
experimentos
que
realiz√≥
con
el
applet


de
GBN
.
¬ø
Coinciden
los
resultados
con
los
que
cabr√≠a
esperar
?


Con
esto
hemos
terminado
con
nuestra
exposici√≥n
sobre
los
protocolos
fiables
de
trans-


ferencia
de
datos
.
Hemos
visto
muchos
de
los
numerosos
mecanismos
b√°sicos
que
contribu-


yen
a
proporcionar
una
transferencia
de
datos
fiable
.
La
Tabla
3.1
resume
estos
mecanismos
.


Ahora
que
ya
hemos
visto
todos
estos
mecanismos
en
funcionamiento
y
que
hemos
adqui-


rido
una
‚Äú
visi√≥n
de
conjunto
‚Äù
,
le
animanos
a
que
repase
esta
secci√≥n
con
el
fin
de
ver
c√≥mo


estos
mecanismos
se
fueron
a√±adiendo
para
cubrir
los
modelos
cada
vez
m√°s
complejos
(
y


realistas
)
del
canal
que
conecta
al
emisor
y
el
receptor
,
o
para
mejorar
el
rendimiento
de
los


protocolos
.


Concluimos
esta
exposici√≥n
sobre
los
protocolos
de
transferencia
de
datos
fiables


haciendo
una
suposici√≥n
m√°s
sobre
el
modelo
del
canal
subyacente
.
Recuerde
que
hemos


supuesto
que
los
paquetes
no
se
pueden
reordenar
dentro
del
canal
existente
entre
el
emisor


y
el
receptor
.
Generalmente
,
esta
suposici√≥n
es
razonable
cuando
el
emisor
y
el
receptor


est√°n
conectados
simplemente
mediante
un
cable
f√≠sico
.
Sin
embargo
,
cuando
el
‚Äú
canal
‚Äù
que


los
conecta
es
una
red
puede
tener
lugar
la
reordenaci√≥n
de
paquetes
.
Una
manifestaci√≥n
de


la
reordenaci√≥n
de
paquetes
es
que
pueden
aparecer
copias
antiguas
de
un
paquete
con
un


n√∫mero
de
secuencia
o
de
reconocimiento
x
,
incluso
aunque
ni
la
ventana
del
emisor
ni
la


del
receptor
contengan
x.
Con
la
reordenaci√≥n
de
paquetes
,
puede
pensarse
en
el
canal
como


en
un
buffer
que
almacena
paquetes
y
que
espont√°neamente
puede
transmitirlos
en
cualquier


instante
futuro
.
Puesto
que
los
n√∫meros
de
secuencia
pueden
reutilizarse
,
hay
que
tener
cui-


dado
para
prevenir
la
aparici√≥n
de
esos
paquetes
duplicados
.
En
la
pr√°ctica
,
lo
que
se
hace


es
asegurarse
de
que
no
se
reutilice
un
n√∫mero
de
secuencia
hasta
que
el
emisor
est√©


‚Äú
seguro
‚Äù
de
que
los
paquetes
enviados
anteriormente
con
el
n√∫mero
de
secuencia
x
ya
no
se


encuentran
en
la
red
.
Esto
se
hace
suponiendo
que
un
paquete
no
puede
‚Äú
vivir
‚Äù
en
la
red


durante
m√°s
tiempo
que
un
cierto
periodo
temporal
m√°ximo
fijo
.
En
las
ampliaciones
de


TCP
para
redes
de
alta
velocidad
se
supone
un
tiempo
de
vida
m√°ximo
de
paquete
de
apro-


ximadamente
tres
minutos
[
RFC
1323
]
.
[
Sunshine
1978
]
describe
un
m√©todo
para
utilizar


n√∫meros
de
secuencia
tales
que
los
problemas
de
reordenaci√≥n
pueden
ser
eliminados
por


completo
.


3.4
‚Ä¢
PRINCIPIOS
DE
UN
SERVICIO
DE
TRANSFERENCIA
DE
DATOS
FIABLE
227


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
227Mecanismo
Uso
,
comentarios


Suma
de
comprobaci√≥n
Utilizada
para
detectar
errores
de
bit
en
un
paquete
transmitido
.


(
checksum
)


Temporizador
Se
emplea
para
detectar
el
fin
de
temporizaci√≥n
y
retransmitir
un
paquete
,
posiblemente
por-


que
el
paquete
(
o
su
mensaje
ACK
correspondiente
)
se
ha
perdido
en
el
canal
.
Puesto
que
se


puede
producir
un
fin
de
temporizaci√≥n
si
un
paquete
est√°
retardado
pero
no
perdido
(
fin
de


temporizaci√≥n
prematura
)
,
o
si
el
receptor
ha
recibido
un
paquete
pero
se
ha
perdido
el
corres-


pondiente
ACK
del
receptor
al
emisor
,
puede
ocurrir
que
el
receptor
reciba
copias
duplicadas
de


un
paquete
.


N√∫mero
de
secuencia
Se
emplea
para
numerar
secuencialmente
los
paquetes
de
datos
que
fluyen
del
emisor
hacia
el


receptor
.
Los
saltos
en
los
n√∫meros
de
secuencia
de
los
paquetes
recibidos
permiten
al
receptor


detectar
que
se
ha
perdido
un
paquete
.
Los
paquetes
con
n√∫meros
de
secuencia
duplicados
per-


miten
al
receptor
detectar
copias
duplicadas
de
un
paquete
.


Reconocimiento
(
ACK
)
El
receptor
utiliza
estos
paquetes
para
indicar
al
emisor
que
un
paquete
o
un
conjunto
de


paquetes
ha
sido
recibido
correctamente
.
Los
mensajes
de
reconocimiento
suelen
contener
el


n√∫mero
de
secuencia
del
paquete
o
los
paquetes
que
est√°n
confirmando
.
Dependiendo
del
pro-


tocolo
,
los
mensajes
de
reconocimiento
pueden
ser
individuales
o
acumulativos
.


Reconocimiento
negativo
El
receptor
utiliza
estos
paquetes
para
indicar
al
emisor
que
un
paquete
no
ha
sido
recibido


(
NAK
)
correctamente
.
Normalmente
,
los
mensajes
de
reconocimiento
negativo
contienen
el
n√∫mero


de
secuencia
de
dicho
paquete
err√≥neo
.


Ventana
,
procesamiento
El
emisor
puede
estar
restringido
para
enviar
√∫nicamente
paquetes
cuyo
n√∫mero
de
secuencia


en
cadena
caiga
dentro
de
un
rango
determinado
.
Permitiendo
que
se
transmitan
varios
paquetes
aunque


no
est√©n
todav√≠a
reconocidos
,
se
puede
incrementar
la
tasa
de
utilizaci√≥n
del
emisor
respecto


al
modo
de
operaci√≥n
de
los
protocolos
de
parada
y
espera
.
Veremos
brevemente
que
el
tama-


√±o
de
la
ventana
se
puede
establecer
bas√°ndose
en
la
capacidad
del
receptor
para
recibir
y


almacenar
en
buffer
los
mensajes
,
o
en
el
nivel
de
congesti√≥n
de
la
red
,
o
en
ambos
par√°me-


tros
.


Tabla
3.1
‚Ä¢
Resumen
de
los
mecanismos
para
la
transferencia
de
datos
fiable
y


su
uso
.


3.5
Transporte
orientado
a
la
conexi√≥n
:
TCP


Ahora
que
ya
hemos
visto
los
principios
b√°sicos
de
la
transferencia
de
datos
fiable
,
vamos
a


centrarnos
en
TCP
,
un
protocolo
de
la
capa
de
transporte
de
Internet
,
fiable
y
orientado
a
la


conexi√≥n
.
En
esta
secci√≥n
veremos
que
para
proporcionar
una
transferencia
de
datos
fiable
,


TCP
conf√≠a
en
muchos
de
los
principios
b√°sicos
expuestos
en
la
secci√≥n
anterior
,
incluyendo


los
mecanismos
de
detecci√≥n
de
errores
,
las
retransmisiones
,
los
reconocimientos
acumula-


tivos
,
los
temporizadores
y
los
campos
de
cabecera
para
los
n√∫meros
de
secuencia
y
de
reco-


nocimiento
.
El
protocolo
TCP
est√°
definido
en
los
documentos
RFC
793
,
RFC
1122
,
RFC


1323
,
RFC
2018
y
RFC
2581
.


228
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
228CASE
HISTORY


VINTON
CERF
,
ROBERT
KAHN
Y
TCP
/
IP


A
principios
de
la
d√©cada
de
1970
comenzaron
a
proliferar
las
redes
de
conmutaci√≥n
de


paquetes
,
siendo
ARPAnet
(
la
red
precursora
de
Internet
)
s√≥lo
una
m√°s
de
muchas
redes
.


Cada
una
de
estas
redes
utilizaba
su
propio
protocolo
.
Dos
investigadores
,
Vinton
Cerf
y


Robert
Kahn
,
se
dieron
cuenta
de
la
importancia
de
interconectar
estas
redes
e
inventaron
un


protocolo
inter-red
denominado
TCP
/
IP
(
Transmission
Control
Protocol
/
Internet
Protocol
)
.


Aunque
Cerf
y
Kahn
comenzaron
viendo
el
protocolo
como
una
sola
entidad
,
m√°s
tarde
la


dividieron
en
dos
partes
,
TCP
e
IP
,
que
operaban
por
separado
.
Cerf
y
Kahn
publicaron
un


informe
sobre
TCP
/
IP
en
mayo
de
1974
en
IEEE
Transactions
on
Communications
Technology


[
Cerf
1974
]
.


El
protocolo
TCP
/
IP
,
que
es
la
base
de
la
Internet
actual
,
fue
dise√±ado
antes
que
los
PC
y


las
estaciones
de
trabajo
,
antes
de
la
proliferaci√≥n
de
las
tecnolog√≠as
de
las
redes
Ethernet
y


otras
redes
de
√°rea
local
,
y
antes
que
la
Web
,
los
flujos
de
audio
y
los
chat
.
Cerf
y
Kahn
vie-


ron
la
necesidad
que
exist√≠a
de
un
protocolo
de
red
que
,
por
un
lado
,
proporcionara
un


amplio
soporte
para
las
aplicaciones
que
ya
estaban
definidas
y
que
,
por
otro
lado
,
permi-


tiera
interoperar
a
los
hosts
y
los
protocolos
de
la
capa
de
enlace
.


En
2004
,
Cerf
y
Kahn
recibieron
el
premio
Turing
Award
de
ACM
,
que
est√°
considerado


como
el
‚Äú
Premio
Nobel
de
la
Inform√°tica
‚Äù
por
su
trabajo
pionero
sobre
los
procesos
de
comu-


nicaci√≥n
entre
redes
,
incluyendo
el
dise√±o
y
la
implementaci√≥n
de
los
protocolos
b√°sicos
de


comunicaci√≥n
de
Internet
(
TCP
/
IP
)
y
por
su
liderazgo
en
el
mundo
de
las
redes
.


3.5.1
La
conexi√≥n
TCP


Se
dice
que
TCP
est√°
orientado
a
la
conexi√≥n
porque
antes
de
que
un
proceso
de
la
capa


aplicaci√≥n
pueda
comenzar
a
enviar
datos
a
otro
,
los
dos
procesos
deben
primero
‚Äú
estable-


cer
una
comunicaci√≥n
‚Äù
entre
ellos
;
es
decir
,
tienen
que
enviarse
ciertos
segmentos
prelimi-


nares
para
definir
los
par√°metros
de
la
transferencia
de
datos
que
van
a
llevar
a
cabo
a


continuaci√≥n
.
Como
parte
del
proceso
de
establecimiento
de
la
conexi√≥n
TCP
,
ambos
lados


de
la
misma
iniciar√°n
muchas
variables
de
estado
TCP
(
muchas
de
las
cuales
se
ver√°n
en


esta
secci√≥n
y
en
la
Secci√≥n
3.7
)
asociadas
con
la
conexi√≥n
TCP
.


La
‚Äú
conexi√≥n
‚Äù
TCP
no
es
un
circuito
terminal
a
terminal
con
multiplexaci√≥n
TDM
o


FDM
como
lo
es
una
red
de
conmutaci√≥n
de
circuitos
.
Ni
tampoco
es
un
circuito
virtual


(
v√©ase
el
Cap√≠tulo
1
)
,
ya
que
el
estado
de
la
conexi√≥n
reside
completamente
en
los
dos
siste-


mas
terminales
.
Dado
que
el
protocolo
TCP
se
ejecuta
√∫nicamente
en
los
sistemas
termina-


les
y
no
en
los
elementos
intermedios
de
la
red
(
routers
y
switches
de
la
capa
de
enlace
)
,
los


elementos
intermedios
de
la
red
no
mantienen
el
estado
de
la
conexi√≥n
TCP
.
De
hecho
,
los


routers
intermedios
son
completamente
inconscientes
de
las
conexiones
TCP
;
los
routers


ven
los
datagramas
,
no
las
conexiones
.


Una
conexi√≥n
TCP
proporciona
un
servicio
full-duplex
:
si
existe
una
conexi√≥n
TCP


entre
el
proceso
A
que
se
ejecuta
en
un
host
y
el
proceso
B
que
se
ejecuta
en
otro
host
,
enton-


ces
los
datos
de
la
capa
de
aplicaci√≥n
pueden
fluir
desde
el
proceso
A
al
proceso
B
en
el


mismo
instante
que
los
datos
de
la
capa
de
aplicaci√≥n
fluyen
del
proceso
B
al
proceso
A.


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
229


HISTORIA


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
229Una
conexi√≥n
TCP
casi
siempre
es
una
conexi√≥n
punto
a
punto
,
es
decir
,
entre
un
√∫nico


emisor
y
un
√∫nico
receptor
.
La
‚Äú
multidifusi√≥n
‚Äù
(
v√©ase
la
Secci√≥n
4.7
)
,
la
transferencia
de


datos
desde
un
emisor
a
muchos
receptores
en
una
√∫nica
operaci√≥n
,
no
es
posible
con
TCP
.


Con
TCP
,
dos
hosts
son
compa√±√≠a
y
tres
multitud
.


Veamos
ahora
c√≥mo
se
establece
una
conexi√≥n
TCP
.
Suponga
que
un
proceso
que
se


est√°
ejecutando
en
un
host
desea
iniciar
una
conexi√≥n
con
otro
proceso
que
se
ejecuta
en
otro


host
.
Recuerde
que
el
proceso
que
inicia
la
conexi√≥n
es
el
proceso
cliente
,
y
el
otro
proceso


es
el
proceso
servidor
.
El
proceso
de
la
aplicaci√≥n
cliente
informa
en
primer
lugar
a
la
capa


de
transporte
del
cliente
que
desea
establecer
una
conexi√≥n
con
un
proceso
del
servidor
.


Recuerde
que
en
la
Secci√≥n
2.7
,
hemos
visto
un
programa
cliente
en
Java
que
hac√≠a
esto
eje-


cutando
el
comando
:


Socket
socketCliente
=
new
Socket(‚Äúnombrehost
‚Äù
,
N√∫meroPuerto
)
;


donde
nombrehost
es
el
nombre
del
servidor
y
NumeroPuerto
identifica
al
proceso
del


servidor
.
La
capa
de
transporte
del
cliente
procede
entonces
a
establecer
una
conexi√≥n
TCP


con
el
TCP
del
servidor
.
Al
finalizar
esta
secci√≥n
veremos
en
detalle
el
procedimiento
de


establecimiento
de
la
conexi√≥n
.
Por
el
momento
,
nos
basta
con
saber
que
el
cliente
primero


env√≠a
un
segmento
TCP
especial
;
el
servidor
responde
con
un
segundo
segmento
TCP
espe-


cial
y
,
por
√∫ltimo
,
el
cliente
responde
de
nuevo
con
tercer
segmento
especial
.
Los
dos
prime-


ros
segmentos
no
transportan
ninguna
carga
√∫til
;
es
decir
,
no
transportan
datos
de
la
capa
de


aplicaci√≥n
;
el
tercero
de
estos
segmentos
es
el
que
puede
llevar
la
carga
√∫til
.
Puesto
que
los


tres
segmentos
son
intercambiados
entre
dos
hosts
,
este
procedimiento
de
establecimiento


de
la
conexi√≥n
suele
denominarse
acuerdo
en
tres
fases
.


Una
vez
que
se
ha
establecido
una
conexi√≥n
TCP
,
los
dos
procesos
de
aplicaci√≥n
pue-


den
enviarse
datos
el
uno
al
otro
.
Consideremos
la
transmisi√≥n
de
datos
desde
el
proceso


cliente
al
proceso
servidor
.
El
proceso
cliente
pasa
un
flujo
de
datos
a
trav√©s
del
socket
(
la


puerta
del
proceso
)
,
como
se
ha
descrito
en
la
Secci√≥n
2.7
.
Una
vez
que
los
datos
atravie-


san
la
puerta
,
se
encuentran
en
manos
del
protocolo
TCP
que
se
ejecuta
en
el
cliente
.


Como
se
muestra
en
la
Figura
3.28
,
TCP
dirige
estos
datos
al
buffer
de
emisi√≥n
de
la
cone-


xi√≥n
,
que
es
uno
de
los
buffers
que
se
definen
durante
el
proceso
inicial
del
acuerdo
en
tres


fases
.
De
vez
en
cuando
,
TCP
tomar√°
fragmentos
de
datos
del
buffer
de
emisi√≥n
.
La
especi-


ficaci√≥n
de
 
TCP
[
RFC
793
]
es
bastante
vaga
en
lo
que
respecta
a
especificar
cu√°ndo
TCP


debe
realmente
enviar
los
datos
almacenados
en
el
buffer
,
enunciando
que
TCP
‚Äú
debe
trans-


mitir
esos
datos
en
segmentos
seg√∫n
su
propia
conveniencia
‚Äù
.
La
cantidad
m√°xima
de
datos


que
pueden
cogerse
y
colocarse
en
un
segmento
est√°
limitada
por
el
tama√±o
m√°ximo
de


segmento
(
MSS
,
Maximum
Segment
Size
)
.
Normalmente
,
el
MSS
queda
determinado
en


primer
lugar
por
la
longitud
de
la
trama
m√°s
larga
de
la
capa
de
enlace
que
el
host
emisor


local
puede
enviar
[
que
es
la
unidad
m√°xima
de
transmisi√≥n
,
(
MTU
,
Maximum
Trans-


mission
Unit
)
]
,
y
luego
el
MSS
se
establece
de
manera
que
se
garantice
que
un
segmento


TCP
(
cuando
se
encapsula
en
un
datagrama
IP
)
se
ajuste
a
una
√∫nica
trama
de
la
capa
de


enlace
.
Valores
comunes
de
MTU
son
1.460
bytes
,
536
bytes
y
512
bytes
.
Tambi√©n
se
han


propuesto
m√©todos
para
descubrir
la
MTU
de
la
ruta
(
la
trama
m√°s
larga
de
la
capa
de
enlace


que
puede
enviarse
a
trav√©s
de
todos
los
enlaces
desde
el
origen
hasta
el
destino
)
[
RFC


1191
]
y
establecer
el
MSS
bas√°ndose
en
el
valor
de
la
MTU
de
la
ruta
.
Observe
que
el
MSS


es
la
cantidad
m√°xima
de
datos
de
la
capa
de
aplicaci√≥n
en
el
segmento
,
no
el
tama√±o


m√°ximo
del
segmento
TCP
incluyendo
las
cabeceras
.
Esta
terminolog√≠a
resulta
confusa
,


pero
tenemos
que
convivir
con
ella
,
porque
est√°
muy
extendida
.


230
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
230Figura
3.28
‚Ä¢
Buffers
de
emisi√≥n
y
recepci√≥n
de
TCP
.


TCP
empareja
cada
fragmento
de
datos
del
cliente
con
una
cabecera
TCP
,
formando


segmentos
TCP
.
Los
segmentos
se
pasan
a
la
capa
de
red
,
donde
son
encapsulados
por


separado
dentro
de
datagramas
IP
de
la
capa
de
red
.
Los
datagramas
IP
se
env√≠an
entonces
a


la
red
.
Cuando
TCP
recibe
un
segmento
en
el
otro
extremo
,
los
datos
del
mismo
se
colocan


en
el
buffer
de
recepci√≥n
de
la
conexi√≥n
TCP
,
como
se
muestra
en
la
Figura
 
Figure
3.28
.
La


aplicaci√≥n
lee
el
flujo
de
datos
de
este
buffer
.
Cada
lado
de
la
conexi√≥n
tiene
su
propio
buf-


fer
de
emisi√≥n
y
su
propio
buffer
de
recepci√≥n
(
puede
ver
el
applet
de
control
de
flujo
en


l√≠nea
en
http://www.awl.com/kurose-ross
,
que
proporciona
una
animaci√≥n
de
los
buffers
de


emisi√≥n
y
de
recepci√≥n
)
.


Por
tanto
,
una
conexi√≥n
TCP
consta
de
buffers
,
variables
y
un
socket
de
conexi√≥n
a
un


proceso
en
un
host
,
y
otro
conjunto
de
buffers
,
variables
y
un
socket
de
conexi√≥n
a
un
pro-


ceso
en
otro
host
.
Como
hemos
mencionado
anteriormente
,
no
se
asignan
ni
buffers
ni
varia-


bles
a
la
conexi√≥n
dentro
de
los
elementos
de
red
(
routers
,
switches
y
repetidores
)
existentes


entre
los
hosts
.


3.5.2
Estructura
del
segmento
TCP


Despu√©s
de
haber
visto
de
forma
breve
la
conexi√≥n
TCP
,
examinemos
la
estructura
de
un


segmento
TCP
.
El
segmento
TCP
consta
de
campos
de
cabecera
y
un
campo
de
datos
.
El


campo
de
datos
contiene
un
fragmento
de
los
datos
de
la
aplicaci√≥n
.
Como
hemos
men-


cionado
anteriormente
,
el
MSS
limita
el
tama√±o
m√°ximo
del
campo
de
datos
de
un
seg-


mento
.
Cuando
TCP
env√≠a
un
archivo
grande
,
como
por
ejemplo
una
imagen
como
parte
de


una
p√°gina
web
,
normalmente
divide
el
archivo
en
fragmentos
de
tama√±o
MSS
(
excepto
el


√∫ltimo
fragmento
,
que
normalmente
ser√°
m√°s
peque√±o
que
MSS
)
.
Sin
embargo
,
las
aplica-


ciones
interactivas
suelen
transmitir
fragmentos
de
datos
que
son
m√°s
peque√±os
que
el
MSS
;


por
ejemplo
,
en
las
aplicaciones
de
inicio
de
sesi√≥n
remoto
(
remote
login
)
como
 
Telnet
,
el


campo
de
datos
del
segmento
TCP
s√≥lo
tiene
un
byte
.
Puesto
que
habitualmente
la
cabecera


de
TCP
tiene
20
bytes
(
12
bytes
m√°s
que
la
cabecera
de
UDP
)
,
los
segmentos
enviados


mediante
Telnet
s√≥lo
pueden
tener
una
longitud
de
21
bytes
.


La
Figura
3.29
muestra
la
estructura
del
segmento
TCP
.
Al
igual
que
con
UDP
,
la
cabe-


cera
incluye
los
n√∫mero
de
puerto
de
origen
y
de
destino
,
que
se
utilizan
para
multiplexar


y
demultiplexar
los
datos
de
y
para
las
aplicaciones
de
la
capa
superior
.
Tambi√©n
,
al
igual


que
UDP
,
la
cabecera
incluye
un
campo
de
suma
de
comprobaci√≥n
.
La
cabecera
de
un
seg-


mento
TCP
tambi√©n
contiene
los
siguientes
campos
:


El
proceso


escribe
los
datos


El
proceso


lee
los
datos


Buffer
de


emisi√≥n


TCP


Socket


Buffer
de


recepci√≥n


TCP


Socket


Segmento
Segmento


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
231


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
231Figura
3.29
‚Ä¢
Estructura
del
segmento
TCP
.


‚Ä¢
El
campo
n√∫mero
de
secuencia
de
32
bits
y
el
campo
n√∫mero
de
reconocimiento
tam-


bi√©n
de
32
bits
son
utilizados
por
el
emisor
y
el
receptor
de
TCP
para
implementar
un
ser-


vicio
de
transferencia
de
datos
fiable
,
como
se
explica
m√°s
adelante
.


‚Ä¢
El
campo
ventana
de
recepci√≥n
de
16
bits
se
utiliza
para
el
control
de
flujo
.
Veremos
en


breve
que
se
emplea
para
indicar
el
n√∫mero
de
bytes
que
un
receptor
est√°
dispuesto
a


aceptar
.


‚Ä¢E
l
 
campo
longitud
de
cabecera
de
4
bits
especifica
la
longitud
de
la
cabecera
TCP
en


palabras
de
32
bits
.
La
cabecera
TCP
puede
tener
una
longitud
variable
a
causa
del


campo
opciones
de
TCP
(
normalmente
,
este
campo
est√°
vac√≠o
,
por
lo
que
la
longitud
de


una
cabecera
TCP
t√≠pica
es
de
20
bytes
)
.


‚Ä¢E
l
 
campo
opciones
es
opcional
y
de
longitud
variable
.
Se
utiliza
cuando
un
emisor
y
un


receptor
negocian
el
tama√±o
m√°ximo
de
segmento
(
MSS
)
o
como
un
factor
de
escala
de


la
ventana
en
las
redes
de
alta
velocidad
.
Tambi√©n
se
define
una
opci√≥n
de
marca
tempo-


ral
.
Consulte
los
documentos
RFC
854
y
RFC
1323
para
conocer
detalles
adicionales
.


‚Ä¢E
l
campo
indicador
tiene
6
bits
.
El
bit
ACK
se
utiliza
para
indicar
que
el
valor
trans-


portado
en
el
campo
de
reconocimiento
es
v√°lido
;
es
decir
,
el
segmento
contiene
un
reco-


nocimiento
para
un
segmento
que
ha
sido
recibido
correctamente
.
Los
bits
RST
,
SYN
y


FIN
se
utilizan
para
el
establecimiento
y
cierre
de
conexiones
,
como
veremos
al
final
de


esta
secci√≥n
.
La
activaci√≥n
del
bit
PSH
indica
que
el
receptor
deber√°
pasar
los
datos
a
la


capa
superior
de
forma
inmediata
.
Por
√∫ltimo
,
el
bit
URG
se
utiliza
para
indicar
que
hay


datos
en
este
segmento
que
la
entidad
de
la
capa
superior
del
lado
emisor
ha
marcado


como
‚Äú
urgentes
‚Äù
.
La
posici√≥n
de
este
√∫ltimo
byte
de
estos
datos
urgentes
se
indica


mediante
el
campo
puntero
de
datos
urgentes
de
16
bits
.
TCP
tiene
que
informar
a
la


N√∫mero
de
puerto
de
origen


Suma
de
comprobaci√≥n
Internet


Long
.


cabec
.


No


usado


URG


ACK


PSH


RST


SYN


FIN


32
bits


N√∫mero
de
puerto
de
destino


Ventana
de
recepci√≥n


Puntero
de
datos
Urgente


N√∫mero
de
secuencia


N√∫mero
de
reconocimiento


Opciones


Datos


232
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
232entidad
de
la
capa
superior
del
lado
receptor
si
existen
datos
urgentes
y
pasarle
un
pun-


tero
a
la
posici√≥n
donde
finalizan
los
datos
urgentes
.
En
la
pr√°ctica
,
PSH
,
URG
y
el
pun-


tero
a
datos
urgentes
no
se
utilizan
.
Sin
embargo
,
hemos
hablado
de
estos
campos
con
el


fin
de
proporcionar
al
lector
la
informaci√≥n
completa
.


N√∫meros
de
secuencia
y
n√∫meros
de
reconocimiento


Dos
de
los
campos
m√°s
importantes
de
la
cabecera
de
un
segmento
TCP
son
el
campo


n√∫mero
de
secuencia
y
el
campo
n√∫mero
de
reconocimiento
.
Estos
campos
son
una
parte


cr√≠tica
del
servicio
de
transferencia
de
datos
fiable
de
TCP
.
Pero
antes
de
ver
c√≥mo
se
utili-


zan
estos
campos
para
proporcionar
una
transferencia
de
datos
fiable
,
explicaremos
en
pri-


mer
lugar
lo
que
pone
exactamente
TCP
en
esos
campos
.


TCP
percibe
los
datos
como
un
flujo
de
bytes
no
estructurado
pero
ordenado
.
El
uso
que


hace
TCP
de
los
n√∫meros
de
secuencia
refleja
este
punto
de
vista
,
en
el
sentido
de
que
 
los


n√∫meros
de
secuencia
hacen
referencia
al
flujo
de
bytes
transmitido
y
no
a
la
serie
de
seg-


mentos
transmitidos
.
El
n√∫mero
de
secuencia
de
un
segmento
es
por
tanto
el
n√∫mero
del


primer
byte
del
segmento
dentro
del
flujo
de
bytes
.
Veamos
un
ejemplo
.
Suponga
que
un


proceso
del
host
A
desea
enviar
un
flujo
de
datos
a
un
proceso
del
host
B
a
trav√©s
de
una


conexi√≥n
TCP
.
El
protocolo
TCP
en
el
host
A
numerar√°
impl√≠citamente
cada
byte
del
flujo


de
datos
.
Suponga
tambi√©n
que
el
flujo
de
datos
consta
de
un
archivo
de
500.000
bytes
,
que


el
tama√±o
MSS
es
de
1.000
bytes
y
que
el
primer
byte
del
flujo
de
datos
est√°
numerado
como


0
.
Como
se
muestra
en
la
Figura
3.30
,
TCP
construye
500
segmentos
a
partir
del
flujo
de


datos
.
El
primer
segmento
tiene
asignado
el
n√∫mero
de
secuencia
0
,
el
segundo
segmento


tiene
asignado
el
n√∫mero
de
secuencia
1.000
,
el
tercero
tendr√°
asignado
el
n√∫mero
de


secuencia
2.000
,
etc.
Cada
n√∫mero
de
secuencia
se
inserta
en
el
campo
n√∫mero
de
secuencia


de
la
cabecera
del
segmento
TCP
apropiado
.


Consideremos
ahora
los
n√∫meros
de
reconocimiento
,
que
son
algo
m√°s
complicados


que
los
n√∫meros
de
secuencia
.
Recuerde
que
TCP
es
una
conexi√≥n
full-duplex
,
de
modo
que


el
host
A
puede
estar
recibiendo
datos
del
host
B
mientras
env√≠a
datos
al
host
B
(
como
parte


de
la
misma
conexi√≥n
TCP
)
.
Todos
los
segmentos
que
llegan
procedentes
del
host
B
tienen


un
n√∫mero
de
secuencia
para
los
datos
que
fluyen
de
B
a
A.
El
n√∫mero
de
reconocimiento


que
el
host
A
incluye
en
su
segmento
es
el
n√∫mero
de
secuencia
del
siguiente
byte
que
el
host


Ae
s
t
√°
 
e
s
p
e
r
a
n
d
o
 
d
e
l
 
h
o
s
t
 
B
.Veamos
algunos
ejemplos
para
comprender
qu√©
es
lo
que
ocu-


rre
aqu√≠
.
Suponga
que
el
host
A
ha
recibido
todos
los
bytes
numerados
de
0
a
535
proceden-


tes
de
B
y
suponga
tambi√©n
que
est√°
enviando
un
segmento
al
host
B.
El
host
A
est√°


esperando
al
536
y
todos
los
bytes
que
le
siguen
del
flujo
de
datos
del
host
B.
Por
tanto
,
el


host
A
incluye
536
en
el
campo
n√∫mero
de
reconocimiento
del
segmento
que
env√≠a
a
B.


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
233


01
1.000
1.999
499.999


Archivo


Datos
para
el
1er
segmento
Datos
para
el
2¬∫
segmento


Figura
3.30
‚Ä¢
Divisi√≥n
de
los
datos
del
archivo
en
segmentos
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
233Otro
ejemplo
:
suponga
que
el
host
A
ha
recibido
un
segmento
del
host
B
que
contiene


los
bytes
de
0
a
535
y
otro
segmento
que
contiene
los
bytes
de
900
a
1.000
.
Por
alguna


raz√≥n
,
el
host
A
no
ha
recibido
todav√≠a
los
bytes
de
536
a
899
.
En
este
ejemplo
,
el
host
A


est√°
esperando
el
byte
536
(
y
los
que
le
siguen
)
 
para
volver
a
crear
el
flujo
de
datos
de
B.


Por
tanto
,
el
siguiente
segmento
de
A
a
B
contendr√°
el
n√∫mero
536
en
el
campo
de
n√∫mero


de
reconocimiento
.
Dado
que
TCP
s√≥lo
confirma
los
bytes
hasta
el
primer
byte
que
falta
en


el
flujo
,
se
dice
que
TCP
proporciona
reconocimientos
acumulativos
.


Este
√∫ltimo
ejemplo
plantea
tambi√©n
un
problema
importante
aunque
sutil
.
El
host
A
ha


recibido
el
tercer
segmento
(
bytes
900
a
1.000
)
antes
de
recibir
el
segundo
segmento
(
bytes


536
a
899
)
.
Por
tanto
,
el
tercer
segmento
no
ha
llegado
en
orden
.
El
sutil
problema
es
el


siguiente
:
¬ø
qu√©
hace
un
host
cuando
no
recibe
los
segmentos
en
orden
a
trav√©s
de
una
cone-


xi√≥n
TCP
?
Curiosamente
,
los
RFC
dedicados
a
TCP
no
imponen
ninguna
regla
y
dejan
la


decisi√≥n
a
las
personas
que
programan
las
implementaciones
de
TCP
.
B√°sicamente
,
tenemos


dos
opciones
:
(
1
)
el
receptor
descarta
de
forma
inmediata
los
segmentos
que
no
han
llegado


en
orden
(
lo
que
,
como
hemos
anteriormente
,
puede
simplificar
el
dise√±o
del
receptor
)
o
(
2
)


el
receptor
mantiene
los
bytes
no
ordenados
y
espera
a
que
lleguen
los
bytes
que
faltan
con


el
fin
de
rellenar
los
huecos
.
Evidentemente
,
esta
√∫ltima
opci√≥n
es
m√°s
eficiente
en
t√©rminos


de
ancho
de
banda
de
la
red
,
y
es
el
m√©todo
que
se
utiliza
en
la
pr√°ctica
.


En
la
Figura
3.30
hemos
supuesto
que
el
n√∫mero
de
secuencia
inicial
era
cero
.
En
la


pr√°ctica
,
ambos
lados
de
una
conexi√≥n
TCP
eligen
aleatoriamente
un
n√∫mero
de
secuencia


inicial
.
Esto
se
hace
con
el
fin
de
minimizar
la
posibilidad
de
que
un
segmento
que
todav√≠a


est√°
presente
en
la
red
a
causa
de
una
conexi√≥n
anterior
que
ya
ha
terminado
entre
dos
hosts


pueda
ser
confundido
con
un
segmento
v√°lido
de
una
conexi√≥n
posterior
entre
esos
dos
mis-


mos
hosts
(
que
tambi√©n
est√©n
usando
los
mismos
n√∫meros
de
puerto
que
la
conexi√≥n
anti-


gua
)
[
Sunshine
1978
]
.


Telnet
:
caso
de
estudio
de
los
n√∫meros
de
secuencia
y
de
reconocimiento


Telnet
,
definido
en
el
documento
RFC
854
,
es
un
popular
protocolo
de
la
capa
de
aplicaci√≥n


utilizado
para
los
inicios
de
sesi√≥n
remotos
.
Se
ejecuta
sobre
TCP
y
est√°
dise√±ado
para
tra-


bajar
entre
cualquier
pareja
de
hosts
.
A
diferencia
de
las
aplicaciones
de
transferencia


masiva
de
datos
vistas
en
el
Cap√≠tulo
2
,
Telnet
es
una
aplicaci√≥n
interactiva
.
Vamos
a
ver


aqu√≠
un
ejemplo
,
ya
que
ilustra
muy
bien
los
n√∫meros
de
secuencia
y
de
reconocimiento
de


TCP
.
Debemos
mencionar
que
actualmente
muchos
usuarios
prefieren
utilizar
el
protocolo


SSH
en
lugar
de
Telnet
,
porque
los
datos
enviados
a
trav√©s
de
una
conexi√≥n
Telnet
(
¬°
inclui-


das
las
contrase√±as
!
)
no
est√°n
cifrados
,
lo
que
hace
que
Telnet
sea
vulnerable
a
los
ataques


de
personas
que
quieran
escuchar
la
conexi√≥n
(
como
veremos
en
la
Secci√≥n
8.7
)
.


Supongamos
que
el
host
A
inicia
una
sesi√≥n
Telnet
con
el
host
B.
Puesto
que
el
host
A


inicia
la
sesi√≥n
,
se
etiqueta
como
el
cliente
y
el
host
B
como
el
servidor
.
Cada
car√°cter


escrito
por
el
usuario
(
en
el
cliente
)
se
enviar√°
al
host
remoto
;
el
host
remoto
devolver√°
una


copia
de
cada
car√°cter
,
que
ser√°
mostrada
en
la
pantalla
del
usuario
Telnet
.
Este
‚Äú
eco
‚Äù
se


emplea
para
garantizar
que
los
caracteres
vistos
por
el
usuario
Telnet
ya
han
sido
recibidos
y


procesados
en
el
sitio
remoto
.
Por
tanto
,
cada
car√°cter
atraviesa
la
red
dos
veces
entre
el
ins-


tante
en
el
que
usuario
pulsa
una
tecla
y
el
instante
en
el
que
el
car√°cter
se
muestra
en
el


monitor
del
usuario
.


Suponga
ahora
que
el
usuario
escribe
una
√∫nica
letra
,
la
‚Äò
C
‚Äô
,
y
luego
se
va
a
por
un
caf√©
.


Examinemos
los
segmentos
TCP
que
est√°n
siendo
enviados
entre
el
cliente
y
el
servidor
.


Como
se
muestra
en
la
Figura
3.31
,
suponemos
que
los
n√∫meros
de
secuencia
iniciales
para


234
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
234el
cliente
y
el
servidor
son
,
respectivamente
,
42
y
79
.
Recuerde
que
el
n√∫mero
de
secuencia


de
un
segmento
es
el
n√∫mero
de
secuencia
del
primer
byte
del
campo
de
datos
.
Por
tanto
,
el


primer
segmento
enviado
por
el
cliente
tendr√°
el
n√∫mero
de
secuencia
42
y
el
primer
seg-


mento
enviado
desde
el
servidor
tendr√°
el
n√∫mero
de
secuencia
79
.
Recuerde
que
el
n√∫mero


de
reconocimiento
es
el
n√∫mero
de
secuencia
del
siguiente
byte
de
datos
que
el
host
est√°
espe-


rando
.
Cuando
ya
se
ha
establecido
una
conexi√≥n
TCP
pero
todav√≠a
no
se
enviado
ning√∫n


dato
,
el
cliente
est√°
esperando
la
llegada
del
byte
79
y
el
servidor
est√°
esperando
al
byte
42
.


Como
se
muestra
en
la
Figura
3.31
,
se
env√≠an
tres
segmentos
.
El
primer
segmento
se


transmite
desde
el
cliente
al
servidor
,
conteniendo
la
representaci√≥n
ASCII
de
1
byte
de
la


letra
‚Äò
C
‚Äô
en
su
campo
de
datos
.
Este
primer
segmento
tambi√©n
contiene
el
n√∫mero
42
en
su


campo
n√∫mero
de
secuencia
,
como
ya
hemos
descrito
.
Adem√°s
,
dado
que
el
cliente
todav√≠a


no
ha
recibido
ning√∫n
dato
procedente
del
servidor
,
este
primer
segmento
contendr√°
el


n√∫mero
79
en
su
campo
n√∫mero
de
reconocimiento
.


El
segundo
segmento
se
env√≠a
desde
el
servidor
al
cliente
y
adem√°s
sirve
a
un
doble


prop√≥sito
.
En
primer
lugar
,
proporciona
un
reconocimiento
de
los
datos
que
ha
recibido
el


servidor
.
Al
incluir
el
n√∫mero
43
en
el
campo
n√∫mero
de
reconocimiento
,
el
servidor
est√°


diciendo
al
cliente
que
ha
recibido
correctamente
todo
hasta
el
byte
42
y
ahora
est√°
espe-


rando
los
bytes
43
y
posteriores
.
El
segundo
prop√≥sito
de
este
segmento
es
devolver
el
eco


de
la
letra
‚Äò
C
‚Äô
.
Por
tanto
,
el
segundo
segmento
contiene
la
representaci√≥n
ASCII
de
la
letra


‚Äò
C
‚Äô
en
su
campo
de
datos
.
Este
segundo
segmento
tiene
el
n√∫mero
de
secuencia
79
,
el


n√∫mero
de
secuencia
inicial
del
flujo
de
datos
servidor-cliente
de
esta
conexi√≥n
TCP
,
ya
que


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
235


Tiempo
Tiempo


Host
A
Host
B


El
usuario


escribe
la


letra
'
C
'


Sec=42
,
ACK=79
,
datos='C
'


Sec=79
,
ACK=43
,
datos='C
'


Sec=43
,
ACK=80


El
host
reconoce
(
ACK
)


la
recepci√≥n
de
'
C
'
y


devuelve
un
eco
de
'
C
'


El
host


reconoce


(
ACK
)
la


recepci√≥n


del
eco


de
'
C
'


Figura
3.31
‚Ä¢
N√∫meros
de
secuencia
y
de
reconocimiento
en
una
aplica-


ci√≥n
Telnet
simple
sobre
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
235se
trata
del
primer
byte
de
datos
que
el
servidor
est√°
enviando
.
Observe
que
la
confirmaci√≥n


de
los
datos
enviados
desde
el
cliente
al
servidor
se
transporta
en
un
segmento
que
contiene


los
datos
enviados
del
servidor
al
cliente
;
se
dice
que
este
reconocimiento
est√°
superpuesto


al
segmento
de
datos
enviado
por
el
servidor
al
cliente
.


El
tercer
segmento
se
env√≠a
desde
el
cliente
al
servidor
.
Su
√∫nico
prop√≥sito
es
confirmar


los
datos
que
ha
recibido
procedentes
del
servidor
(
recuerde
que
el
segundo
segmento
con-


ten√≠a
datos
,
la
letra
‚Äò
C
‚Äô
,
del
servidor
para
el
cliente
)
.
Este
segmento
tiene
un
campo
de
datos


vac√≠o
(
es
decir
,
el
paquete
de
reconocimiento
no
va
superpuesto
a
los
datos
que
van
del


cliente
al
servidor
)
.
El
segmento
contiene
el
n√∫mero
80
en
el
campo
n√∫mero
de
reconoci-


miento
porque
el
cliente
ha
recibido
el
flujo
de
bytes
hasta
el
byte
con
el
n√∫mero
de
secuen-


cia
79
y
ahora
est√°
esperando
los
bytes
80
y
subsiguientes
.
Es
posible
que
le
parezca
extra√±o


que
este
segmento
tambi√©n
tenga
un
n√∫mero
de
secuencia
aunque
no
contenga
datos
pero
,


dado
que
los
segmentos
TCP
disponen
de
un
campo
n√∫mero
de
secuencia
,
es
necesario


incluir
siempre
en
ese
campo
un
valor
.
 

3.5.3
Estimaci√≥n
del
tiempo
de
ida
y
vuelta


y
fin
de
temporizaci√≥n


TCP
,
al
igual
que
nuestro
protocolo
rdt
de
la
Secci√≥n
3.4
,
utiliza
un
mecanismo
de
fin
de


temporizaci√≥n
/
retransmisi√≥n
para
recuperarse
de
la
p√©rdida
de
segmentos
.
Aunque
concep-


tualmente
esto
es
muy
simple
,
surgen
muchos
problemas
sutiles
al
implementar
dicho


mecanismo
en
un
protocolo
real
como
,
por
ejemplo
,
TCP
.
Quiz√°
la
cuesti√≥n
m√°s
obvia
es


la
longitud
de
los
intervalos
de
fin
de
temporizaci√≥n
.
Evidentemente
,
el
intervalo
de
fin
de


temporizaci√≥n
deber√≠a
ser
mayor
que
el
tiempo
de
ida
y
vuelta
(
RTT
)
de
la
conexi√≥n
;
es


decir
,
mayor
que
el
tiempo
que
transcurre
desde
que
se
env√≠a
un
segmento
hasta
que
se


recibe
su
reconocimiento
.
Si
fuera
de
otra
manera
,
se
enviar√≠an
retransmisiones
innecesa-


rias
.
Pero
,
¬ø
cu√°nto
mayor
?
y
,
¬ø
c√≥mo
se
deber√≠a
estimar
el
RTT
por
primera
vez
?
¬ø
Deber√≠a


asociarse
un
temporizador
con
cada
uno
de
los
segmentos
no
reconocidos
?
¬°
Demasiadas


preguntas
!
En
esta
secci√≥n
vamos
a
basar
nuestra
exposici√≥n
en
el
trabajo
sobre
TCP
de


[
Jacobson
1988
]
y
en
las
recomendaciones
actuales
del
IETF
para
gestionar
los
temporiza-


dores
TCP
[
RFC
2988
]
.


Estimaci√≥n
del
tiempo
de
ida
y
vuelta


Comencemos
nuestro
estudio
de
la
gesti√≥n
del
temporizador
TCP
viendo
c√≥mo
estima
TCP


el
tiempo
de
ida
y
vuelta
entre
el
emisor
y
el
receptor
.
Esto
se
lleva
a
cabo
de
la
siguiente


manera
:
el
RTT
de
muestra
,
expresado
como
RTTMuestra
,
para
un
segmento
es
la
cantidad


de
tiempo
que
transcurre
desde
que
se
env√≠a
el
segmento
(
es
decir
,
se
pasa
a
IP
)
hasta
que
se


recibe
el
correspondiente
paquete
de
reconocimiento
del
segmento
.
En
lugar
de
medir
RTT-


Muestra
para
cada
segmento
transmitido
,
la
mayor
parte
de
las
implementaciones
TCP


toman
s√≥lo
una
medida
de
RTTMuestra
cada
vez
.
Es
decir
,
en
cualquier
instante
,
RTT-


Muestrase
estima
a
partir
de
uno
solo
de
los
segmentos
transmitidos
pero
todav√≠a
no
reco-


nocidos
,
lo
que
nos
proporciona
un
nuevo
valor
de
RTTMuestra
aproximadamente
cada


RTT
segundos
.
Adem√°s
,
TCP
nunca
calcula
RTTMuestra
para
un
segmento
que
haya
sido


retransmitido
;
s√≥lo
mide
este
valor
para
los
segmentos
que
han
sido
transmitidos
una
vez
.


En
uno
de
los
problemas
incluidos
al
final
del
cap√≠tulo
se
le
pedir√°
que
explique
el
por
qu√©


de
este
comportamiento
.


236
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
236Obviamente
,
los
valores
de
RTTMuestra
fluctuar√°n
de
un
segmento
a
otro
a
causa
de


la
congesti√≥n
en
los
routers
y
a
la
variaci√≥n
de
la
carga
en
los
sistemas
terminales
.
A
causa


de
esta
fluctuaci√≥n
,
cualquier
valor
de
RTTMuestra
dado
puede
ser
at√≠pico
.
Con
el
fin
de


estimar
un
RTT
t√≠pico
,
es
natural
por
tanto
calcular
alg√∫n
tipo
de
promedio
de
los
valores
de


RTTMuestra
.
TCP
mantiene
un
valor
promedio
,
denominado
RTTEstimado
,
de
los
valores


RTTMuestra
.
Para
obtener
un
nuevo
valor
de
RTTMuestra
,
TCP
actualiza
RTTEstimado


seg√∫n
la
f√≥rmula
siguiente
:


RTTEstimado
=
(
1
‚Äì
/H9251
)
‚Ä¢
RTTEstimado
+
/H9251‚Ä¢
RTTMuestra


Hemos
escrito
esta
f√≥rmula
como
una
instrucci√≥n
de
un
lenguaje
de
programaci√≥n
(
el


nuevo
valor
de
RTTEstimado
es
una
combinaci√≥n
ponderada
del
valor
anterior
de
RTTEs-


timado
y
del
nuevo
valor
de
RTTMuestra
)
.
El
valor
recomendado
para
/H9251es
0,125
(
es


decir
,
1/8
)
[
RFC
2988
]
,
en
cuyo
caso
la
f√≥rmula
anterior
se
expresar√≠a
como
sigue
:


RTTEstimado
=
0,875
‚Ä¢
RTTEstimado
+
0,125
‚Ä¢
RTTMuestra


Observe
que
RTTEstimado
es
una
media
ponderada
de
los
valores
de
RTTMuestra
.


Como
se
examina
en
uno
de
los
problemas
de
repaso
incluidos
al
final
del
cap√≠tulo
,
esta


media
ponderada
asigna
un
mayor
peso
a
las
muestras
recientes
que
a
las
m√°s
antiguas
.
Esto


es
l√≥gico
,
ya
que
las
muestras
m√°s
recientes
reflejan
mejor
la
congesti√≥n
que
existe
actual-


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
237


PRINCIPLES
IN
PRACTICE


TCP
proporciona
un
servicio
de
transferencia
de
datos
fiable
utilizando
mensajes
de
reconoci-


miento
positivos
y
temporizadores
,
de
forma
muy
similar
a
como
hemos
visto
en
la
Secci√≥n
3.4
.


TCP
confirma
los
datos
que
ha
recibido
correctamente
y
retransmite
segmentos
cuando
√©stos
o


sus
correspondientes
reconocimientos
se
piensa
que
se
han
perdido
o
se
han
corrompido
.


Ciertas
versiones
de
TCP
tambi√©n
disponen
de
un
mecanismo
NAK
impl√≠cito
con
un
mecanismo


r√°pido
de
retransmisi√≥n
TCP
:
la
recepci√≥n
de
tres
ACK
duplicados
para
un
determinado
segmen-


to
sirve
como
un
NAK
impl√≠cito
para
el
siguiente
segmento
,
provocando
la
retransmisi√≥n
de


dicho
segmento
antes
del
fin
de
la
temporizaci√≥n
.
TCP
utiliza
secuencias
de
n√∫meros
para
permi-


tir
al
receptor
identificar
los
segmentos
perdidos
o
duplicados
.
Al
igual
que
en
el
caso
de
nuestro


protocolo
de
transferencia
de
datos
fiable
,
rdt3.0
,
TCP
no
puede
por
s√≠
mismo
saber
si
un


cierto
segmento
,
o
su
correspondiente
ACK
,
se
ha
perdido
,
est√°
corrompido
o
se
ha
retarda-


do
demasiado
.
En
el
emisor
,
la
respuesta
TCP
ser√°
la
misma
:
retransmitir
el
segmento
en
cues-


ti√≥n
.


TCP
tambi√©n
utiliza
el
procesamiento
en
cadena
,
permitiendo
al
emisor
tener
m√∫ltiples
seg-


mentos
transmitidos
pero
aun
no
reconocidos
en
cualquier
instante
.
Anteriormente
hemos
visto


que
el
procesamiento
en
cadena
puede
mejorar
enormemente
la
tasa
de
transferencia
de
una


sesi√≥n
cuando
la
relaci√≥n
entre
el
tama√±o
del
segmento
y
el
retardo
de
ida
y
vuelta
es
peque-


√±a
.
El
n√∫mero
espec√≠fico
de
segmentos
pendientes
no
reconocidos
que
un
emisor
puede
tener
se


determina
mediante
los
mecanismos
de
control
de
congesti√≥n
y
de
control
de
flujo
de
TCP
.


El
control
de
flujo
de
TCP
se
examina
al
final
de
esta
secci√≥n
y
el
mecanismo
de
control
de


congesti√≥n
en
la
Secci√≥n
3.7
.
Por
el
momento
,
basta
con
que
seamos
conscientes
de
que
el


emisor
TCP
utiliza
el
procesamiento
en
cadena
.


PR√ÅCTICA


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
237mente
en
la
red
.
En
estad√≠stica
,
una
media
como
√©sta
se
denomina
Media
m√≥vil
exponen-


cialmente
ponderada
(
EWMA
,
Exponential
Weighted
Moving
Average
)
.
El
t√©rmino


‚Äú
exponencial
‚Äù
aparece
en
EWMA
porque
el
peso
de
un
valor
dado
de
RTTMuestra
dismi-


nuye
exponencialmente
tan
r√°pido
como
tienen
lugar
las
actualizaciones
.
En
los
problemas


de
repaso
se
le
pedir√°
que
deduzca
el
t√©rmino
exponencial
en
RTTEstimado
.


La
Figura
3.32
muestra
los
valores
RTTMuestra
y
RTTEstimado
para
/H9251=
1/8
en
una


conexi√≥n
TCP
entre
gaia.cs.umass.edu
(
en
Amherst
,
Massachusetts
)
y
fantasia
.


eurecom.fr
(
en
el
sur
de
Francia
)
.
Evidentemente
,
las
variaciones
en
RTTMuestra
se


suavizan
en
el
c√°lculo
de
RTTEstimado
.


Adem√°s
de
tener
un
estimado
de
RTT
,
tambi√©n
es
importante
disponer
de
una
medida


de
la
variabilidad
de
RTT
.
 
[
RFC
2988
]
define
la
variaci√≥n
de
RTT
,
RTTDesv
,
como
una


estimaci√≥n
de
cu√°nto
se
desv√≠a
t√≠picamente
RTTMuestrade
RTTEstimado
:


RTTDesv
=
(
1
‚Äì
/H9252)‚Ä¢R
T
T
D
e
s
v
 
+
 
/H9252‚Ä¢|RTTMuestra
‚Äì
RTTEstimado|


Observe
que
RTTDesv
es
una
media
EWMA
de
la
diferencia
entre
RTTMuestra
y


RTTEstimado
.
Si
los
valores
de
RTTMuestrapresentan
una
peque√±a
fluctuaci√≥n
,
entonces


RTTDesv
ser√°
peque√±o
;
por
el
contrario
,
si
existe
una
gran
fluctuaci√≥n
,
RTTDesv
ser√°


grande
.
El
valor
recomendado
para
/H9252es
0,25
.


Definici√≥n
y
gesti√≥n
del
intervalo
de
fin
de
temporizaci√≥n


para
la
retransmisi√≥n


Dados
los
valores
de
RTTEstimado
y
RTTDesv
,
¬ø
qu√©
valor
deber√≠a
utilizarse
para
el
inter-


valo
de
fin
de
temporizaci√≥n
de
TCP
?
Evidentemente
,
el
intervalo
tendr√°
que
ser
mayor
o


238
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


RTT
(
milisegundos
)


150


200


250


300


350


100


1
8
15
22
29
36
43
50


Tiempo
(
segundos
)


RTT
muestreado


57
64
71
78
85
92
99
106


RTT
estimado


Figura
3.32
‚Ä¢
Muestreo
de
RTT
y
estimaci√≥n
de
RTT
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
238igual
que
RTTEstimado
,
o
se
producir√°n
retransmisiones
innecesarias
.
Pero
el
intervalo
de


fin
de
temporizaci√≥n
no
deber√≠a
ser
mucho
mayor
que
RTTEstimado
;
de
otra
manera
,
si
un


segmento
se
pierde
,
TCP
no
retransmitir√°
r√°pidamente
el
segmento
,
provocando
retardos


muy
largos
en
la
transferencia
de
datos
.
Por
tanto
,
es
deseable
hacer
el
intervalo
de
fin
de


temporizaci√≥n
igual
a
RTTEstimado
m√°s
un
cierto
margen
.
El
margen
deber√°
ser
m√°s


grande
cuando
la
fluctuaci√≥n
en
los
valores
de
RTTMuestra
sea
grande
y
m√°s
peque√±o


cuando
la
fluctuaci√≥n
sea
peque√±a
.
El
valor
de
RTTDesv
deber√°
entonces
tenerse
en
cuenta
.


Todas
estas
consideraciones
se
tienen
en
cuenta
en
el
m√©todo
TCP
para
determinar
el
inter-


valo
de
fin
de
temporizaci√≥n
de
las
retransmisiones
:


IntervaloFindeTemporizacion
=
RTTEstimado
+
4
‚Ä¢
RTTDesv


3.5.4
Transferencia
de
datos
fiable


Recuerde
que
el
servicio
de
la
capa
de
red
de
Internet
(
el
servicio
IP
)
no
es
fiable
.
IP
no


garantiza
la
entrega
de
los
datagramas
,
no
garantiza
la
entrega
en
orden
de
los
datagramas
y


no
garantiza
la
integridad
de
los
datos
contenidos
en
los
datagramas
.
Con
el
servicio
IP
,
los


datagramas
pueden
desbordar
los
buffers
de
los
routers
y
no
llegar
nunca
a
su
destino
,
pue-


den
llegar
desordenados
y
los
bits
de
un
datagrama
pueden
corromperse
(
bascular
de
0
a
1
,


y
viceversa
)
.
Puesto
que
los
segmentos
de
la
capa
de
transporte
son
transportados
a
trav√©s


de
la
red
por
los
datagramas
IP
,
estos
segmentos
de
la
capa
de
transporte
pueden
sufrir
tam-


bi√©n
estos
problemas
.


TCP
crea
un
servicio
de
transferencia
de
datos
fiable
sobre
el
servicio
de
mejor


esfuerzo
pero
no
fiable
de
IP
.
El
servicio
de
transferencia
de
datos
fiable
de
TCP
garantiza


que
el
flujo
de
datos
que
un
proceso
extrae
de
su
buffer
de
recepci√≥n
TCP
no
est√°
corrom-


pido
,
no
contiene
huecos
,
ni
duplicados
y
est√°
en
orden
;
es
decir
,
el
flujo
de
bytes
es
exacta-


mente
el
mismo
flujo
que
fue
enviado
por
el
sistema
terminal
existente
en
el
otro
extremo


de
la
conexi√≥n
.
La
forma
en
que
TCP
proporciona
una
transferencia
de
datos
fiable
implica


muchos
de
los
principios
que
hemos
estudiado
en
la
Secci√≥n
3.4
.


En
el
anterior
desarrollo
que
hemos
realizado
sobre
las
t√©cnicas
que
proporcionan
una


transferencia
de
datos
fiable
,
conceptualmente
era
f√°cil
suponer
que
cada
segmento
transmi-


tido
pero
aun
no
reconocido
ten√≠a
asociado
un
temporizador
individual
.
Aunque
esto
est√°


bien
en
teor√≠a
,
la
gesti√≥n
del
temporizador
puede
requerir
una
sobrecarga
considerable
.
Por


tanto
,
los
procedimientos
de
gesti√≥n
del
temporizador
TCP
recomendados
[
RFC
2988
]
utili-


zan
un
√∫nico
temporizador
de
retransmisi√≥n
,
incluso
aunque
haya
varios
segmentos
trans-


mitidos
y
a√∫n
no
reconocidos
.
El
protocolo
TCP
descrito
en
esta
secci√≥n
sigue
esta


recomendaci√≥n
de
emplear
un
√∫nico
temporizador
.


Ahora
vamos
a
ver
c√≥mo
proporciona
TCP
el
servicio
de
transferencia
de
datos
fiable


en
dos
pasos
incrementales
.
En
primer
lugar
,
vamos
a
presentar
una
descripci√≥n
extremada-


mente
simplificada
de
un
emisor
TCP
que
s√≥lo
emplea
los
fines
de
temporizaci√≥n
para
recu-


perarse
de
las
p√©rdidas
de
segmentos
;
a
continuaci√≥n
,
veremos
una
descripci√≥n
m√°s


completa
que
utiliza
los
mensajes
de
reconocimiento
duplicados
adem√°s
de
los
fines
de
tem-


porizaci√≥n
.
En
la
siguiente
exposici√≥n
suponemos
que
s√≥lo
se
est√°n
enviando
datos
en
una


sola
direcci√≥n
,
del
host
A
al
host
B
,
y
que
el
host
A
est√°
enviando
un
archivo
grande
.


La
Figura
3.33
presenta
una
descripci√≥n
simplificada
de
un
emisor
TCP
.
Vemos
que
hay


tres
sucesos
importantes
relacionados
con
la
transmisi√≥n
y
la
retransmisi√≥n
de
datos
en
el


emisor
TCP
:
los
datos
recibidos
desde
la
aplicaci√≥n
;
el
fin
de
temporizaci√≥n
del
temporiza-


dor
y
la
recepci√≥n
de
paquetes
ACK
.
Al
producirse
el
primero
de
los
sucesos
m√°s
importan-


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
239


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
239/
*
Suponga
que
el
emisor
no
est√°
restringido
por
los
mecanismos
de


control
de
flujo
o
de
control
de
congesti√≥n
de
TCP
,
que
el
tama√±o
de


los
datos
procedentes
de
la
capa
superior
es
menor
que
el
MSS
y
adem√°s


la
transferencia
de
datos
tiene
lugar
en
un
√∫nico
sentido
.
*
/


SigNumSec
=
NumeroSecuenciaInicial


BaseEmision
=
NumeroSecuenciaInicial


loop
(
siempre
)
{


switch(suceso
)


suceso
:
datos
recibidos
de
la
aplicaci√≥n
de
la
capa
superior


crear
segmento
TCP
con
n√∫mero
de
secuencia
SigNumSec


if
(
el
temporizador
no
se
est√°
ejecutando
actualmente
)


iniciar
temporizador


pasar
segmento
a
IP


SigNumSec
=
SigNumSec+longitud(datos
)


break
;


suceso
:
fin
de
temporizaci√≥n
del
temporizador


retransmitir
el
segmento
aun
no
reconocido
con


el
n√∫mero
de
secuencia
m√°s
peque√±o


iniciar
temporizador


break
;


suceso
:
ACK
recibido
,
con
valor
de
campo
ACK
igual
a
y


if
(
y
>
BaseEmision
)
{


BaseEmision
=
y


if
(
existen
actualmente
segmentos
aun
no
reconocidos
)


iniciar
temporizador


}


break
;


}
/
*
fin
del
bucle
siempre
*
/


Figura
3.33
‚Ä¢
Emisor
TCP
simplificado
.


tes
TCP
recibe
datos
de
la
aplicaci√≥n
,
encapsula
los
datos
en
un
segmento
y
pasa
el
seg-


mento
a
IP
.
Observe
que
cada
segmento
incluye
un
n√∫mero
de
secuencia
que
es
el
n√∫mero


del
primer
byte
de
datos
del
segmento
,
dentro
del
flujo
de
datos
,
como
se
ha
descrito
en
la


Secci√≥n
 
3.5.2
.
F√≠jese
tambi√©n
en
que
si
el
temporizador
no
est√°
ya
funcionando
para
alg√∫n


otro
segmento
,
TCP
lo
inicia
en
el
momento
de
pasar
el
segmento
a
IP
(
resulta
√∫til
pensar
en


el
temporizador
como
si
estuviera
asociado
con
el
segmento
no
reconocido
m√°s
antiguo
)
.
El


intervalo
de
caducidad
para
este
temporizador
es
IntervaloFindeTemporizacion
,
que


se
calcula
a
partir
de
RTTEstimado
y
RTTDesv
,
como
se
ha
descrito
en
la
Secci√≥n
3.5.3
.


El
segundo
suceso
importante
es
el
fin
de
temporizaci√≥n
.
TCP
responde
a
este
suceso


retransmitiendo
el
segmento
que
ha
causado
el
fin
de
la
temporizaci√≥n
y
,
a
continuaci√≥n
,
rei-


nicia
el
temporizador
.


El
tercer
suceso
importante
que
tiene
que
gestionar
el
emisor
TCP
es
la
llegada
de
un


segmento
de
reconocimiento
(
ACK
)
procedente
del
receptor
(
m√°s
espec√≠ficamente
,
un
seg-


240
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
240mento
que
contenga
un
valor
de
campo
ACK
v√°lido
)
.
Al
ocurrir
este
suceso
,
TCP
compara


el
valor
ACK
ycon
su
variable
BaseEmision
.
La
variable
de
estado
TCP
BaseEmisiones


el
n√∫mero
de
secuencia
del
byte
de
reconocimiento
m√°s
antiguo
.
(
Por
tanto
,
BaseEmi-


sion‚Äì1
es
el
n√∫mero
de
secuencia
del
√∫ltimo
byte
que
se
sabe
que
ha
sido
recibido
correc-


tamente
y
en
orden
en
el
receptor
)
.
Como
hemos
indicado
anteriormente
,
TCP
utiliza


reconocimientos
acumulativos
,
de
modo
que
y
confirma
la
recepci√≥n
de
todos
los
bytes


anteriores
al
n√∫mero
de
byte
y.
Si
y
>
BaseEmision
,
entonces
el
ACK
est√°
confirmando


uno
o
m√°s
de
los
segmentos
no
reconocidos
anteriores
.
As√≠
,
el
emisor
actualiza
su
variable


BaseEmision
y
reinicia
el
temporizador
si
actualmente
aun
existen
segmentos
no
recono-


cidos
.


Algunos
escenarios
interesantes


Acabamos
de
describir
una
versi√≥n
enormemente
simplificada
de
c√≥mo
TCP
proporciona


un
servicio
de
transferencia
de
datos
fiable
.
Pero
incluso
esta
versi√≥n
simplificada
tiene


sus
sutilezas
.
Con
el
fin
de
clarificar
c√≥mo
funciona
este
protocolo
,
vamos
a
analizar
algu-


nos
escenarios
interesantes
.
La
Figura
3.34
describe
el
primero
de
estos
escenarios
,
en
el


que
el
host
A
env√≠a
un
segmento
al
host
B.
Suponga
que
ese
segmento
tiene
el
n√∫mero
de


secuencia
92
y
contiene
8
bytes
de
datos
.
Despu√©s
de
enviar
este
segmento
,
el
host
A


espera
un
segmento
procedente
de
B
con
un
n√∫mero
de
reconocimiento
de
100
.
Aunque
el


segmento
de
A
se
recibe
en
B
,
el
paquete
de
reconocimiento
de
B
a
A
se
pierde
.
En
este


caso
,
se
produce
un
suceso
de
fin
de
temporizaci√≥n
y
el
host
A
retransmite
el
mismo
seg-


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
241


Tiempo
Tiempo


Host
A
Host
B


Fin
de


temporizaci√≥n


Sec=92
,
8
bytes
de
datos


Sec=92
,
8
bytes
de
datos


ACK=100


ACK=100


X


(
perdido
)


Figura
3.34
‚Ä¢
Retransmisi√≥n
debida
a
la
p√©rdida
de
un
paquete


de
reconocimiento
ACK
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
241mento
.
Por
supuesto
,
cuando
el
host
B
recibe
la
retransmisi√≥n
,
comprueba
que
de
acuerdo


con
el
n√∫mero
de
secuencia
el
segmento
contiene
datos
que
ya
hab√≠an
sido
recibidos
.
Por


tanto
,
TCP
en
el
host
B
descartar√°
los
bytes
del
segmento
retransmitido
.


En
el
segundo
escenario
,
mostrado
en
la
Figura
3.35
,
el
host
A
env√≠a
dos
segmentos


seguidos
.
El
primer
segmento
tiene
el
n√∫mero
de
secuencia
92
y
8
bytes
de
datos
,
y
el


segundo
segmento
tiene
el
n√∫mero
de
secuencia
100
y
20
bytes
de
datos
.
Suponga
que


ambos
segmentos
llegan
intactos
a
B
,
y
que
B
env√≠a
dos
mensajes
de
reconocimiento
sepa-


rados
para
cada
uno
de
estos
segmentos
.
El
primero
de
estos
mensajes
tiene
el
n√∫mero
de


reconocimiento
100
y
el
segundo
el
n√∫mero
120
.
Suponga
ahora
que
ninguno
de
estos
men-


sajes
llega
al
host
A
antes
de
que
tenga
lugar
el
fin
de
la
temporizaci√≥n
.
Cuando
se
produce


el
fin
de
temporizaci√≥n
,
el
host
A
reenv√≠a
el
primer
segmento
con
el
n√∫mero
de
secuencia
92


y
reinicia
el
temporizador
.
Siempre
y
cuando
el
ACK
correspondiente
al
segundo
segmento


llegue
antes
de
que
tenga
lugar
un
nuevo
fin
de
temporizaci√≥n
,
el
segundo
segmento
no
se


retransmitir√°
.


En
el
tercer
y
√∫ltimo
escenario
,
suponemos
que
el
host
A
env√≠a
los
dos
segmentos
del


mismo
modo
que
en
el
segundo
ejemplo
.
El
paquete
de
reconocimiento
del
primer
segmento


se
pierde
en
la
red
,
pero
justo
antes
de
que
se
produzca
el
fin
de
la
temporizaci√≥n
,
el
host
A


recibe
un
paquete
de
reconocimiento
con
el
n√∫mero
de
reconocimiento
120
.
Por
tanto
,
el


host
A
sabe
que
el
host
B
ha
recibido
todo
hasta
el
byte
119
;
por
tanto
,
el
host
A
no
reen-


v√≠a
ninguno
de
los
dos
segmentos
.
Este
escenario
se
ilustra
en
la
Figura
3.36
.


242
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Tiempo
Tiempo


Host
A
Host
B


intervalo
fin
de
temporizaci√≥n


para
sec
=
92


Sec=92
,
8
bytes
de
datos


Sec=100
,
20
bytes
de


datos


ACK=100


ACK=120


ACK=120


intervalo
fin
de
temporizaci√≥n


para
sec
=
92


Sec=92
,
8
bytes
de
datos


Figura
3.35
‚Ä¢
Segmento
100
no
retransmitido
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
242Duplicaci√≥n
del
intervalo
de
fin
de
temporizaci√≥n


Examinemos
ahora
algunas
de
las
modificaciones
que
aplican
la
mayor
parte
de
las
imple-


mentaciones
TCP
.
La
primera
de
ellas
est√°
relacionada
con
la
duraci√≥n
del
intervalo
de
fin


de
temporizaci√≥n
despu√©s
de
que
el
temporizador
ha
caducado
.
En
esta
modificaci√≥n
,


cuando
tiene
lugar
un
suceso
de
fin
de
temporizaci√≥n
TCP
retransmite
el
segmento
aun
no


reconocido
con
el
n√∫mero
de
secuencia
m√°s
peque√±o
,
como
se
ha
descrito
anteriormente
.


Pero
cada
vez
que
TCP
retransmite
,
define
el
siguiente
intervalo
de
fin
de
temporizaci√≥n


como
dos
veces
el
valor
anterior
,
en
lugar
de
obtenerlo
a
partir
de
los
√∫ltimos
valores
de


RTTEstimado
y
RTTDesv(como
se
ha
descrito
en
la
Secci√≥n
3.5.3
)
.
Por
ejemplo
,
suponga


que
el
IntervaloFindeTemporizaci√≥n
asociado
con
el
segmento
no
reconocido
m√°s


antiguo
es
0,75
segundos
cuando
el
temporizador
caduca
por
primera
vez
.
Entonces
TCP


retransmitir√°
este
segmento
y
establecer√°
el
nuevo
intervalo
en
1,5
segundos
.
Si
el
tempori-


zador
caduca
de
nuevo
1,5
segundos
m√°s
tarde
,
TCP
volver√°
a
retransmitir
este
segmento
,


estableciendo
el
intervalo
de
caducidad
en
3,0
segundos
.
Por
tanto
,
los
intervalos
crecen


exponencialmente
despu√©s
de
cada
retransmisi√≥n
.
Sin
embargo
,
cuando
el
temporizador
se


inicia
despu√©s
de
cualquiera
de
los
otros
dos
sucesos
(
es
decir
,
datos
recibidos
de
la
aplica-


ci√≥n
y
recepci√≥n
de
un
ACK
)
,
el
IntervaloFindeTemporizaci√≥n
se
obtiene
a
partir
de


los
valores
m√°s
recientes
de
RTTEstimadoy
RTTDesv
.


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
243


Tiempo
Tiempo


Host
A
Host
B


intervalo
fin
de
temporizaci√≥n


para
sec
=
92


sec=92
,
8
bytes
de


datos


sec=100
,
 
20
bytes
de
datosACK=100


ACK=120


X


(
perdido
)


Figura
3.36
‚Ä¢
Un
reconocimiento
acumulativo
evita
la
retransmisi√≥n
del
primer


segmento
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
243Esta
modificaci√≥n
proporciona
una
forma
limitada
de
control
de
congesti√≥n
(
en
la
Sec-


ci√≥n
3.7
estudiaremos
formas
m√°s
exhaustivas
de
realizar
el
control
de
congesti√≥n
en
TCP
)
.


La
caducidad
del
temporizador
est√°
causada
muy
probablemente
por
la
congesti√≥n
en
la


red
,
es
decir
,
llegan
demasiados
paquetes
a
una
(
o
m√°s
)
colas
de
router
a
lo
largo
de
la
ruta


entre
el
origen
y
el
destino
,
haciendo
que
los
paquetes
sean
descartados
y
/
o
sufran
largos


retardos
de
cola
.
Cuando
existe
congesti√≥n
,
si
los
or√≠genes
contin√∫an
retransmitiendo


paquetes
persistentemente
,
la
congesti√≥n
puede
empeorar
.
En
lugar
de
ello
,
TCP
act√∫a
de


forma
m√°s
diplom√°tica
,
haciendo
que
los
emisores
retransmitan
despu√©s
de
intervalos
cada


vez
m√°s
grandes
.
Cuando
estudiemos
CSMA
/
CD
en
el
Cap√≠tulo
5
,
veremos
que
una
idea


similar
se
emplea
en
Ethernet
.


Retransmisi√≥n
r√°pida


Uno
de
los
problemas
con
las
retransmisiones
generadas
por
los
sucesos
de
fin
de
tempori-


zaci√≥n
es
que
el
periodo
de
fin
de
temporizaci√≥n
puede
ser
relativamente
largo
.
Cuando
se


pierde
un
segmento
,
un
periodo
de
fin
de
temporizaci√≥n
largo
fuerza
al
emisor
a
retardar
el


reenv√≠o
del
paquete
perdido
,
aumentando
el
retardo
terminal
a
terminal
.
Afortunadamente
,


el
emisor
puede
a
menudo
detectar
la
p√©rdida
de
paquetes
antes
de
que
tenga
lugar
el
suceso


de
fin
de
temporizaci√≥n
,
observando
los
ACK
duplicados
.
Un
ACK
duplicado
es
un
ACK


que
vuelve
a
reconocer
un
segmento
para
el
que
el
emisor
ya
ha
recibido
un
reconocimiento


anterior
.
Para
comprender
la
respuesta
del
emisor
a
un
ACK
duplicado
,
tenemos
que
enten-


der
en
primer
lugar
por
qu√©
el
receptor
env√≠a
un
ACK
duplicado
.
La
Tabla
3.2
resume
la


pol√≠tica
de
generaci√≥n
de
mensajes
ACK
en
el
receptor
TCP
[
RFC
1122
,
RFC
2581
]
.


Cuando
un
receptor
TCP
recibe
un
segmento
con
un
n√∫mero
de
secuencia
que
es
mayor
que


el
siguiente
n√∫mero
de
secuencia
en
orden
esperado
,
detecta
un
hueco
en
el
flujo
de
datos
,


es
decir
,
detecta
que
falta
un
segmento
.
Este
hueco
podr√≠a
ser
el
resultado
de
segmentos
per-


didos
o
reordenados
dentro
de
la
red
.
Dado
que
TCP
no
utiliza
paquetes
NAK
,
el
receptor


no
puede
devolver
al
emisor
un
mensaje
de
reconocimiento
negativo
expl√≠cito
.
En
su
lugar
,


simplemente
vuelve
a
reconocer
(
es
decir
,
genera
un
ACK
duplicado
)
al
√∫ltimo
byte
de
datos


Suceso
Acci√≥n
del
receptor
TCP


Llegada
de
un
segmento
en
orden
con
el
n√∫mero
de
secuencia
ACK
retardado
.
Esperar
hasta
durante
500
milisegun-


esperado
.
Todos
los
datos
hasta
el
n√∫mero
de
secuencia
esperado
dos
la
llegada
de
otro
segmento
en
orden
.
Si
el


ya
han
sido
reconocidos
.
siguiente
segmento
en
orden
no
llega
en
este
 

intervalo
,
enviar
un
ACK
.


Llegada
de
un
segmento
en
orden
con
el
n√∫mero
de
secuencia
Enviar
inmediatamente
un
√∫nico
ACK
acumulativo
,


esperado
.
Hay
otro
segmento
en
orden
esperando
la
reconociendo
ambos
segmentos
ordenados
.


transmisi√≥n
de
un
ACK
.


Llegada
de
un
segmento
desordenado
con
un
n√∫mero
de
secuencia
Enviar
inmediatamente
un
ACK
duplicado
,
indicando


m√°s
alto
que
el
esperado
.
Se
detecta
un
hueco
.
el
n√∫mero
de
secuencia
del
siguiente
byte
esperado


(
que
es
el
l√≠mite
inferior
del
hueco
)
.


Llegada
de
un
segmento
que
completa
parcial
o
completamente
el
Enviar
inmediatamente
un
ACK
,
suponiendo
que
el


hueco
existente
en
los
datos
recibidos
.
segmento
comienza
en
el
l√≠mite
inferior
del
hueco
.


Tabla
3.2
‚Ä¢
Recomendaci√≥n
para
la
generaci√≥n
de
mensajes
ACK
en
TCP


[
RFC
1122
,
RFC
2581
]


244
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
244en
orden
que
ha
recibido
.
Observe
que
la
Tabla
3.2
contempla
el
caso
de
que
el
receptor
no


descarte
los
segmentos
que
no
llegan
en
orden
.


Puesto
que
un
emisor
suele
enviar
una
gran
n√∫mero
de
segmentos
seguidos
,
si
se
pierde


uno
de
ellos
,
probablemente
habr√°
muchos
ACK
duplicados
seguidos
.
Si
el
emisor
TCP


recibe
tres
ACK
duplicados
para
los
mismos
datos
,
toma
esto
como
una
indicaci√≥n
de
que
el


segmento
que
sigue
al
segmento
que
ha
sido
reconocido
tres
veces
se
ha
perdido
(
en
los
pro-


blemas
de
repaso
,
consideraremos
la
cuesti√≥n
de
por
qu√©
el
emisor
espera
tres
ACK
duplica-


dos
,
en
lugar
de
un
√∫nico
duplicado
)
.
En
el
caso
de
que
se
reciban
tres
ACK
duplicados
,
el


emisor
TCP
realiza
una
retransmisi√≥n
r√°pida
[
RFC
2581
]
,
reenviando
el
segmento
que


falta
antes
de
que
caduque
el
temporizador
de
dicho
segmento
.
Esto
se
muestra
en
la
Figura


3.37
,
en
la
que
se
pierde
el
segundo
segmento
y
luego
se
retransmite
antes
de
que
caduque


su
temporizador
.
Para
TCP
con
retransmisi√≥n
r√°pida
,
el
siguiente
fragmento
de
c√≥digo
reem-


plaza
al
suceso
de
recepci√≥n
de
un
ACK
de
la
Figura
3.33
:


suceso
:
ACK
recibido
,
con
un
valor
de
campo
ACK
de
y


if
(
y
>
BaseEmision
)
{


BaseEmision
=
y


if
(
existen
segmentos
pendientes
de
reconocimiento
)


iniciar
temporizador


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
245


Host
A
Host
B


sec=100
,
20
bytes
de
datosFin
de


temporizaci√≥n


Tiempo
Tiempo


X


sec=100
,
20
bytes
de
datos


sec=92
,
8
bytes
de
datos


sec=120
,
15
bytes
de
datos


sec=135
,
6
bytes
de
datos


sec=141
,
16
bytes
de
datos


ack=100


ack=100


ack=100


ack=100


Figura
3.37
‚Ä¢
Retransmisi√≥n
r√°pida
:
retransmisi√≥n
del
segmento
que
falta
antes


de
que
caduque
el
temporizador
del
segmento
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
245
}


else
{
/
*
un
ACK
duplicado
para
un
segmento
ya
reconocido
*
/


incrementar
el
n√∫mero
de
mensajes
ACK
duplicados


recibidos
para
y


if
(
n√∫mero
de
ACK
duplicados
recibidos
para
y==3
)


/
*
TCP
con
retransmisi√≥n
r√°pida
*
/


reenviar
el
segmento
con
n√∫mero
de
secuencia
y


}


break
;


Anteriormente
hemos
mencionado
que
surgen
muchos
problemas
sutiles
cuando
se


implementa
un
mecanismo
de
fin
de
temporizaci√≥n
/
retransmisi√≥n
en
un
protocolo
real
tal


como
TCP
.
Los
procedimientos
anteriores
,
que
se
han
desarrollado
como
resultado
de
m√°s


de
15
a√±os
de
experiencia
con
los
temporizadores
TCP
,
deber√≠an
convencerle
de
hasta
que


punto
son
sutiles
esos
problemas
.


Retroceder
N
o
Repetici√≥n
selectiva


Profundicemos
algo
m√°s
en
nuestro
estudio
del
mecanismo
de
recuperaci√≥n
de
errores
de


TCP
considerando
la
siguiente
cuesti√≥n
:
¬ø
Es
TCP
un
protocolo
GBN
o
un
protocolo
SR
?


Recuerde
que
los
reconocimientos
de
TCP
son
acumulativos
y
que
los
segmentos
correcta-


mente
recibidos
pero
no
en
orden
no
son
reconocidos
individualmente
por
el
receptor
.
En


consecuencia
,
como
se
muestra
en
la
Figura
3.33
(
v√©ase
tambi√©n
la
Figura
3.19
)
,
el
emisor


TCP
s√≥lo
necesita
mantener
el
n√∫mero
de
secuencia
m√°s
peque√±o
de
un
byte
transmitido


pero
no
reconocido
(
BaseEmision
)
y
el
n√∫mero
de
secuencia
del
siguiente
byte
que
va
a


enviar
(
SigNumSec
)
.
En
este
sentido
,
TCP
se
parece
mucho
a
un
protocolo
de
tipo
 
GBN
.


No
obstante
,
existen
algunas
diferencia
entre
TCP
y
Retroceder
N.
Muchas
implementacio-


nes
de
TCP
almacenan
en
buffer
los
segmentos
recibidos
correctamente
pero
no
en
orden


[
Stevens
1994
]
.
Considere
tambi√©n
lo
que
ocurre
cuando
el
emisor
env√≠a
una
secuencia
de


segmentos
1
,
2
,
.
.
.
,
N
,
y
todos
ellos
llegan
en
orden
y
sin
errores
al
receptor
.
Suponga
ade-


m√°s
que
el
paquete
de
reconocimiento
para
el
paquete
n
<
N
se
pierde
,
pero
los
N
‚Äì
1
paque-


tes
de
reconocimiento
restantes
llegan
al
emisor
antes
de
que
tengan
lugar
sus
respectivos


fines
de
temporizaci√≥n
.
En
este
ejemplo
,
GBN
retransmitir√≠a
no
s√≥lo
el
paquete
n
,
sino
tam-


bi√©n
todos
los
paquetes
subsiguientes
n
+
1
,
n
+
2
,
.
.
.
,
N.
Por
otro
lado
,
TCP
retransmitir√≠a


como
mucho
un
segmento
,
el
segmento
n.
Adem√°s
,
TCP
no
retransmitir√≠a
ni
siquiera
el
seg-


mento
n
si
el
reconocimiento
para
el
segmento
n
+
1
llega
antes
del
fin
de
temporizaci√≥n


correspondiente
al
segmento
n.


Una
modificaci√≥n
propuesta
para
TCP
es
lo
que
se
denomina
reconocimiento
selectivo


[
RFC
2018
]
,
que
permite
a
un
receptor
TCP
reconocer
segmentos
no
ordenados
de
forma


selectiva
,
en
lugar
de
s√≥lo
hacer
reconocimientos
acumulativos
del
√∫ltimo
segmento
reci-


bido
correctamente
y
en
orden
.
Cuando
se
combina
con
la
retransmisi√≥n
selectiva
(
salt√°n-


dose
la
retransmisi√≥n
de
segmentos
que
ya
han
sido
reconocidos
de
forma
selectiva
por
el


receptor
)
,
TCP
se
comporta
como
nuestro
protocolo
SR
selectivo
.
Por
tanto
,
el
mecanismo


de
recuperaci√≥n
de
errores
de
TCP
probablemente
es
mejor
considerarlo
como
un
h√≠brido
de


los
protocolos
GBN
y
SR
.


3.5.5
Control
de
flujo


Recuerde
que
los
hosts
situados
a
cada
lado
de
una
conexi√≥n
TCP
disponen
de
un
buffer
de


recepci√≥n
para
la
conexi√≥n
.
Cuando
la
conexi√≥n
TCP
recibe
bytes
que
son
correctos
y
en


246
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
246secuencia
,
coloca
los
datos
en
el
buffer
de
recepci√≥n
.
El
proceso
de
aplicaci√≥n
asociado
leer√°


los
datos
de
este
buffer
,
pero
no
necesariamente
en
el
instante
en
que
llegan
.
De
hecho
,
la


aplicaci√≥n
receptora
puede
estar
ocupada
con
alguna
otra
tarea
y
puede
incluso
no
leer
los


datos
hasta
mucho
tiempo
despu√©s
de
que
estos
hayan
llegado
.
Si
la
aplicaci√≥n
es
relativa-


mente
lenta
en
lo
que
respecta
a
la
lectura
de
los
datos
,
el
emisor
puede
f√°cilmente
desbor-


dar
el
buffer
de
recepci√≥n
de
la
conexi√≥n
enviando
muchos
datos
demasiado
r√°pidamente
.


TCP
proporciona
un
servicio
de
control
de
flujo
a
sus
aplicaciones
para
eliminar
la


posibilidad
de
que
el
emisor
desborde
el
buffer
del
receptor
.
El
control
de
flujo
es
por
tanto


un
servicio
de
adaptaci√≥n
de
velocidades
(
adapta
la
velocidad
a
la
que
el
emisor
est√°
trans-


mitiendo
frente
a
la
velocidad
a
la
que
la
aplicaci√≥n
receptora
est√°
leyendo
)
.
Como
hemos


mencionado
anteriormente
,
un
emisor
TCP
tambi√©n
puede
atascarse
debido
a
la
congesti√≥n


de
la
red
IP
;
esta
forma
de
control
del
emisor
se
define
como
un
mecanismo
de
control
de


congesti√≥n
,
un
tema
que
exploraremos
en
detalle
en
las
Secciones
3.6
y
3.7
.
Aunque
las


acciones
tomadas
por
los
controles
de
flujo
y
de
congesti√≥n
son
similares
(
regular
el
flujo


del
emisor
)
,
obviamente
se
toman
por
razones
diferentes
.
Lamentablemente
,
muchos
auto-


res
utilizan
los
t√©rminos
de
forma
indistinta
,
por
lo
que
los
lectores
conocedores
del
tema


deber√≠an
tratar
de
diferenciarlos
.
Examinemos
ahora
c√≥mo
proporciona
TCP
su
servicio
de


control
de
flujo
.
En
esta
secci√≥n
vamos
a
suponer
que
la
implementaci√≥n
de
TCP
es
tal
que


el
receptor
TCP
descarta
los
segmentos
que
no
llegan
en
orden
.


TCP
proporciona
un
servicio
de
control
de
flujo
teniendo
que
mantener
el
emisor
una


variable
conocida
como
ventana
de
recepci√≥n
.
Informalmente
,
la
ventana
de
recepci√≥n
se


emplea
para
proporcionar
al
emisor
una
idea
de
cu√°nto
espacio
libre
hay
disponible
en
el


buffer
del
receptor
.
Puesto
que
TCP
es
una
conexi√≥n
full-duplex
,
el
emisor
de
cada
lado
de


la
conexi√≥n
mantiene
una
ventana
de
recepci√≥n
diferente
.
Estudiemos
la
ventana
de
recep-


ci√≥n
en
el
contexto
de
una
operaci√≥n
de
transferencia
de
un
archivo
.
Suponga
que
el
host
A


est√°
enviando
un
archivo
grande
al
host
B
a
trav√©s
de
una
conexi√≥n
TCP
.
El
host
B
asigna


un
buffer
de
recepci√≥n
a
esta
conexi√≥n
;
designamos
al
tama√±o
de
este
buffer
como
Buffer-


Recepci√≥n
.
De
vez
en
cuando
,
el
proceso
de
aplicaci√≥n
del
host
B
lee
el
contenido
del
buf-


fer
.
Definimos
las
siguientes
variables
:


‚Ä¢
UltimoByteLeido
:
el
n√∫mero
del
√∫ltimo
byte
del
flujo
de
datos
del
buffer
le√≠do
por
el


proceso
de
aplicaci√≥n
del
host
B.


‚Ä¢
UltimoByteRecibido
:
el
n√∫mero
del
√∫ltimo
byte
del
flujo
de
datos
que
ha
llegado
pro-


cedente
de
la
red
y
que
se
ha
almacenado
en
el
buffer
de
recepci√≥n
del
host
B.


Puesto
que
en
TCP
no
est√°
permitido
desbordar
el
buffer
asignado
,
tenemos
que
:


UltimoByteRecibido
‚Äì
UltimoByteLeido
/H11349BufferRecepcion


La
ventana
de
recepci√≥n
se
hace
igual
a
la
cantidad
de
espacio
libre
disponible
en
el
buffer
:


VentanaRecepcion
=
BufferRecepcion
‚Äì
[
UltimoByteRecibido
‚Äì
UltimoByteLeido
]


Dado
que
el
espacio
libre
var√≠a
con
el
tiempo
,
VentanaRecepcion
es
una
variable
din√°-


mica
,
la
cual
se
ilustra
en
la
Figura
3.38
.


¬ø
C√≥mo
utiliza
la
conexi√≥n
la
variable
VentanaRecepcion
para
proporcionar
el
servi-


cio
de
control
de
flujo
?
El
host
B
dice
al
host
A
la
cantidad
de
espacio
disponible
que
hay
en


el
buffer
de
la
conexi√≥n
almacenando
el
valor
actual
de
VentanaRecepcion
en
el
campo


ventana
de
recepci√≥n
de
cada
segmento
que
env√≠a
a
A.
Inicialmente
,
el
host
B
establece
que


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
247


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
247VentanaRecepcion
=
BufferRecepcion
.
Observe
que
para
poder
implementar
este


mecanismo
,
el
host
B
tiene
que
controlar
diversas
variables
espec√≠ficas
de
la
conexi√≥n
.


As
u
 
v
e
z
,
 
e
l
 
h
o
s
t
 
Ac
o
n
t
r
o
l
a
 
d
o
s
 
v
a
r
i
a
b
l
e
s
,
 
UltimoByteEnviado
y
UltimoByteRe-


conocido
,
cuyos
significados
son
obvios
.
Observe
que
la
diferencia
entre
estas
dos
varia-


bles
,
UltimoByteEnviado
‚Äì
UltimoByteReconocido
,
es
la
cantidad
de
datos
no


reconocidos
que
el
host
A
ha
enviado
a
trav√©s
de
la
conexi√≥n
.
Haciendo
que
el
n√∫mero
de


datos
no
reconocidos
sea
inferior
al
valor
de
VentanaRecepcion
,
el
host
A
podr√°
asegu-


rarse
de
no
estar
desbordando
el
buffer
de
recepci√≥n
en
el
host
B.
Por
tanto
,
el
host
A
se
ase-


gura
,
a
todo
lo
largo
del
tiempo
de
vida
de
la
conexi√≥n
,
de
que
:


UltimoByteEnviado
‚Äì
UltimoByteReconocido
/H11349VentanaRecepcion


Existe
un
peque√±o
problema
t√©cnico
con
este
esquema
.
Para
ver
de
qu√©
se
trata
,


suponga
que
el
buffer
de
recepci√≥n
del
host
B
est√°
lleno
,
de
manera
que
VentanaRecep-


cion
=
0
.
Despu√©s
de
anunciar
al
host
A
que
VentanaRecepcion
=
0
,
suponga
tambi√©n


que
B
no
tiene
nada
que
enviar
a
A.
Veamos
qu√©
es
lo
que
ocurre
.
A
medida
que
el
proceso


de
aplicaci√≥n
del
host
B
vac√≠a
el
buffer
,
TCP
no
env√≠a
nuevos
segmentos
con
valores
nuevos


VentanaRecepcion
al
host
A
;
por
supuesto
,
TCP
env√≠a
un
segmento
al
host
A
s√≥lo
si


tiene
datos
que
enviar
o
si
tiene
que
enviar
un
paquete
de
reconocimiento
.
Por
tanto
,
el
host


An
u
n
c
a
 
e
s
 
i
n
f
o
r
m
a
d
o
 
d
e
 
q
u
e
 
h
a
y
 
a
l
g
o
 
d
e
 
e
s
p
a
c
i
o
 
e
n
 
e
l
 
b
u
f
f
e
r
 
d
e
 
r
e
c
e
p
c
i
√≥
n
 
d
e
l
 
h
o
s
t
 
B
 
(
e
l


host
A
est√°
bloqueado
y
no
puede
transmitir
m√°s
datos
)
.
Para
resolver
este
problema
,
la


especificaci√≥n
TCP
requiere
al
host
A
que
contin√∫e
enviando
segmentos
con
un
byte
de


datos
cuando
la
longitud
de
la
ventana
de
recepci√≥n
de
B
es
cero
.
Estos
segmentos
ser√°n


reconocidos
por
el
receptor
.
Finalmente
,
el
buffer
comenzar√°
a
vaciarse
y
los
ACK
conten-


dr√°n
un
valor
de
VentanaRecepciondistinto
de
cero
.


El
sitio
web
del
libro
en
http://www.awl.com/kurose-ross
proporciona
un
applet
Java


interactivo
que
ilustra
el
funcionamiento
de
la
ventana
de
recepci√≥n
de
TCP
.


Debemos
comentar
,
una
vez
que
hemos
descrito
el
servicio
de
control
de
flujo
de
TCP
,


que
UDP
no
proporciona
ning√∫n
mecanismo
de
control
de
flujo
.
Para
entender
esta
cuesti√≥n
,


consideremos
la
transmisi√≥n
de
una
serie
de
segmentos
UDP
desde
un
proceso
que
se
eje-


cuta
en
el
host
A
a
un
proceso
que
se
ejecuta
en
el
host
B.
En
una
implementaci√≥n
t√≠pica
de


UDP
,
el
protocolo
UDP
almacenar√°
los
segmentos
en
un
buffer
de
tama√±o
finito
que
‚Äú
pre-


248
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Proceso
de


aplicaci√≥n


Datos


desde
IP
Datos
TCP


en
buffer


VentanaRecepcion


BufferRecepcion


Espacio
libre


Figura
3.38
‚Ä¢
La
ventana
de
recepci√≥n
y
el
buffer
de
recepci√≥n


(
BufferRecepcion
)
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
248cede
‚Äù
al
correspondiente
socket
(
es
decir
,
la
puerta
de
entrada
al
proceso
)
.
El
proceso
lee
un


segmento
completo
del
buffer
cada
vez
.
Si
el
proceso
no
lee
los
segmentos
del
buffer
lo
sufi-


cientemente
r√°pido
,
√©ste
se
desbordar√°
y
los
segmentos
ser√°n
descartados
.


3.5.6
Gesti√≥n
de
la
conexi√≥n
TCP


En
esta
subsecci√≥n
vamos
a
ver
c√≥mo
se
establece
y
termina
una
conexi√≥n
TCP
.
Aunque
este


tema
no
parece
particularmente
emocionante
,
tiene
una
gran
importancia
,
porque
el
estable-


cimiento
de
una
conexi√≥n
TCP
puede
aumentar
significativamente
el
retardo
percibido
(
por


ejemplo
,
cuando
se
navega
por
la
Web
)
.
Adem√°s
,
muchos
de
los
ataques
de
red
m√°s
comu-


nes
,
incluyendo
el
incre√≠blemente
popular
ataque
por
inundaci√≥n
SYN
,
explotan
las
vulne-


rabilidades
de
la
gesti√≥n
de
una
conexi√≥n
TCP
.
En
primer
lugar
,
veamos
c√≥mo
se
establece


una
conexi√≥n
TCP
.
Suponga
que
hay
un
proceso
en
ejecuci√≥n
en
un
host
(
cliente
)
que
desea


iniciar
una
conexi√≥n
con
otro
proceso
que
se
ejecuta
en
otro
host
(
servidor
)
.
El
proceso
de


aplicaci√≥n
cliente
informa
en
primer
lugar
al
cliente
TCP
que
desea
establecer
una
conexi√≥n


con
un
proceso
servidor
.
A
continuaci√≥n
,
el
protocolo
TCP
en
el
cliente
establece
una
cone-


xi√≥n
TCP
con
el
protocolo
TCP
en
el
servidor
de
la
siguiente
manera
:


‚Ä¢
Paso
1
.
En
primer
lugar
,
TCP
del
lado
del
cliente
env√≠a
un
segmento
TCP
especial
al
TCP


del
lado
servidor
.
Este
segmento
especial
no
contiene
datos
de
la
capa
de
aplicaci√≥n
.
Pero


uno
de
los
bits
indicadores
de
la
cabecera
del
segmento
(
v√©ase
la
Figura
3.29
)
,
el


bit
SYN
,
se
pone
a
1
.
Por
esta
raz√≥n
,
este
segmento
especial
se
referencia
como
un
seg-


mento
SYN
.
Adem√°s
,
el
cliente
selecciona
de
forma
aleatoria
un
n√∫mero
de
secuencia


inicial
(
cliente_nsi
)
y
lo
coloca
en
el
campo
n√∫mero
de
secuencia
del
segmento
TCP


inicial
SYN
.
Este
segmento
se
encapsula
dentro
de
un
datagrama
IP
y
se
env√≠a
al
servi-


dor
.
Es
importante
que
esta
elecci√≥n
aleatoria
del
valor
de
cliente_nsi
se
haga
apro-


piadamente
con
el
fin
de
evitar
ciertos
ataques
de
seguridad
[
CERT
2001-09
]
.


‚Ä¢
Paso
2
.
Una
vez
que
el
datagrama
IP
que
contiene
el
segmento
SYN
TCP
llega
al
host


servidor
(
¬°
suponiendo
que
llega
!
)
,
el
servidor
extrae
dicho
segmento
SYN
del
data-


grama
,
asigna
los
buffers
y
variables
TCP
a
la
conexi√≥n
y
env√≠a
un
segmento
de
cone-


xi√≥n
concedida
al
cliente
TCP
.
(
Veremos
en
el
Cap√≠tulo
8
que
la
asignaci√≥n
de
estos


buffers
y
variables
antes
de
completar
el
tercer
paso
del
proceso
de
acuerdo
en
tres
fases


hace
que
TCP
sea
vulnerable
a
un
ataque
de
denegaci√≥n
de
servicio
,
conocido
como
ata-


que
por
inundaci√≥n
SYN
.
)
Este
segmento
de
conexi√≥n
concedida
tampoco
contiene


datos
de
la
capa
de
aplicaci√≥n
.
Sin
embargo
,
contiene
tres
fragmentos
de
informaci√≥n


importantes
de
la
cabecera
del
segmento
.
El
primero
,
el
bit
SYN
se
pone
a
1
.
El


segundo
,
el
campo
reconocimiento
de
la
cabecera
del
segmento
TCP
se
hace
igual
a


cliente_nsi+1
.
Por
√∫ltimo
,
el
servidor
elige
su
propio
n√∫mero
de
secuencia
inicial


(
servidor_nsi
)
y
almacena
este
valor
en
el
campo
n√∫mero
de
secuencia
de
la
cabe-


cera
del
segmento
TCP
.
Este
segmento
de
conexi√≥n
concedida
est√°
diciendo
,
en
efecto
,


‚Äú
He
recibido
tu
paquete
SYN
para
iniciar
una
conexi√≥n
con
tu
n√∫mero
de
secuencia
ini-


cial
,
cliente_nsi
.
Estoy
de
acuerdo
con
establecer
esta
conexi√≥n
.
Mi
n√∫mero
de


secuencia
inicial
es
servidor_nsi
‚Äù
.
El
segmento
de
conexi√≥n
concedida
se
conoce


como
segmento
SYNACK
.


‚Ä¢
Paso
3
.
Al
recibir
el
segmento
SYNACK
,
el
cliente
tambi√©n
asigna
buffers
y
variables
a


la
conexi√≥n
.
El
host
cliente
env√≠a
entonces
al
servidor
otro
segmento
;
este
√∫ltimo
seg-


mento
confirma
el
segmento
de
conexi√≥n
concedida
del
servidor
(
el
cliente
hace
esto


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
249


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
249almacenando
el
valor
servidor_nsi+1
en
el
campo
de
reconocimiento
de
la
cabecera


del
segmento
TCP
)
.
El
bit
SYN
se
pone
a
cero
,
ya
que
la
conexi√≥n
est√°
establecida
.
Esta


tercera
etapa
del
proceso
de
acuerdo
en
tres
fases
puede
transportar
datos
del
cliente
al


servidor
dentra
de
la
carga
√∫til
del
segmento
.


Una
vez
completados
estos
tres
pasos
,
los
hosts
cliente
y
servidor
pueden
enviarse
seg-


mentos
que
contengan
datos
el
uno
al
otro
.
En
cada
uno
de
estos
segmentos
futuros
,
el
valor


del
bit
SYN
ser√°
cero
.
Observe
que
con
el
fin
de
establecer
la
conexi√≥n
se
env√≠an
tres
paque-


tes
entre
los
dos
hosts
,
como
se
ilustra
en
la
Figura
3.39
.
Por
ello
,
este
procedimiento
de


establecimiento
de
la
conexi√≥n
suele
denominarse
proceso
de
acuerdo
en
tres
fases
.
En
los


problemas
de
repaso
se
exploran
varios
aspectos
de
este
proceso
de
TCP
(
¬ø
Por
qu√©
se
nece-


sitan
los
n√∫meros
de
secuencia
iniciales
?
¬ø
Por
qu√©
se
necesita
un
proceso
de
acuerdo
en
tres


fases
en
lugar
de
uno
en
dos
fases
?
)
.
Es
interesante
observar
que
un
escalador
y
la
persona


que
le
asegura
(
que
se
encuentra
por
debajo
del
escalador
y
cuya
tarea
es
sostener
la
cuerda


de
seguridad
del
mismo
)
utilizan
un
protocolo
de
comunicaciones
con
un
proceso
de


acuerdo
en
tres
fases
que
es
id√©ntico
al
de
TCP
,
para
garantizar
que
ambas
partes
est√©n
pre-


paradas
antes
de
que
el
escalador
inicie
el
ascenso
.


Todo
lo
bueno
se
termina
y
esto
es
aplicable
tambi√©n
a
una
conexi√≥n
TCP
.
Cualquiera


de
los
dos
procesos
participantes
en
una
conexi√≥n
TCP
pueden
dar
por
teminada
dicha
cone-


xi√≥n
.
Cuando
una
conexi√≥n
se
termina
,
los
‚Äú
recursos
‚Äù
(
es
decir
,
los
buffers
y
las
variables
)


de
los
hosts
se
liberan
.
Por
ejemplo
,
suponga
que
el
cliente
decide
cerrar
la
conexi√≥n
,
como


se
muestra
en
la
Figura
3.40
.
El
proceso
de
la
aplicaci√≥n
cliente
ejecuta
un
comando
de
cie-


rre
.
Esto
hace
que
el
cliente
TCP
env√≠e
un
segmento
especial
TCP
al
proceso
servidor
.
El


250
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Tiempo
Tiempo


Host
cliente


Solicitud
de


conexi√≥n


Conexi√≥n


concedida


Host
servidor


SYN=1
,
sec
=
cliente_nsi


SYN=1
,
sec
=
servidor_nsi
,


ack
=
cliente_nsi+1


SYN=0
,
sec
=
cliente_nsi+1
,


ack
=
servidor_nsi+1ACK


Figura
3.39
‚Ä¢
El
proceso
de
acuerdo
en
tres
fases
de
TCP
:


intercambio
de
segmentos
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
250segmento
especial
contiene
un
bit
indicador
en
la
cabecera
del
segmento
,
el
bit
FIN
(
v√©ase


la
Figura
3.29
)
,
puesto
a
1
.
Cuando
el
servidor
recibe
este
segmento
,
devuelve
al
cliente
un


segmento
de
reconocimiento
.
El
servidor
entonces
env√≠a
su
propio
segmento
de
descone-


xi√≥n
,
que
tiene
el
bit
FIN
puesto
a
1
.
Por
√∫ltimo
,
el
cliente
reconoce
el
segmento
de
desco-


nexi√≥n
del
servidor
.
En
esta
situaci√≥n
,
los
recursos
de
ambos
hosts
quedan
liberados
.


Mientras
se
mantiene
una
conexi√≥n
TCP
,
el
protocolo
TCP
que
se
ejecuta
en
cada
host


realiza
transiciones
a
trav√©s
de
los
diversos
estados
TCP
.
La
Figura
3.41
ilustra
una
secuen-


cia
t√≠pica
de
los
estados
TCP
visitados
por
el
cliente
TCP
,
el
cual
se
inicia
en
el
estado
CLO-


SED
(
cerrado
)
.
La
aplicaci√≥n
en
el
lado
del
cliente
inicia
una
nueva
conexi√≥n
(
creando
un


objeto
Socket
en
nuestros
ejemplos
de
Java
del
Cap√≠tulo
2
)
.
Esto
hace
que
TCP
en
el
cliente


env√≠e
un
segmento
SYN
a
TCP
en
el
servidor
.
Despu√©s
de
haber
enviado
el
segmento
SYN
,


el
cliente
TCP
entra
en
el
estado
SYN_SENT
(
SYN_enviado
)
.
Mientras
se
encuentra
en
este


estado
,
el
cliente
TCP
espera
un
segmento
procedente
del
TCP
servidor
que
incluya
un
reco-


nocimiento
del
segmento
anterior
del
cliente
y
que
tenga
el
bit
SYN
puesto
a
1
.
Una
vez


recibido
ese
segmento
,
el
cliente
TCP
entra
en
el
estado
ESTABLISHED
(
establecido
)
.


Mientras
est√°
en
este
√∫ltimo
estado
,
el
cliente
TCP
puede
enviar
y
recibir
segmentos
TCP


que
contengan
datos
de
carga
√∫til
(
es
decir
,
datos
generados
por
la
aplicaci√≥n
)
.


Suponga
que
la
aplicaci√≥n
cliente
decide
cerrar
la
conexi√≥n
(
tenga
en
cuenta
que
el
ser-


vidor
tambi√©n
podr√≠a
decidir
cerrar
la
conexi√≥n
)
.
As√≠
,
el
cliente
TCP
env√≠a
un
segmento


TCP
con
el
bit
FIN
puesto
a
1
y
entra
en
el
estado
FIN_WAIT_1
(
FIN_espera_1
)
.
En
este


estado
,
el
cliente
TCP
queda
a
la
espera
de
un
segmento
TCP
procedente
del
servidor
que


contenga
un
mensaje
de
reconocimiento
.
Cuando
lo
recibe
,
el
cliente
TCP
pasa
al
estado


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
251


Tiempo
Tiempo


Cliente


Cerrar


Cerrar


Servidor


FIN


ACK


ACK


FIN


Cerrado


Tiempo
de
espera


Figura
3.40
‚Ä¢
Cierre
de
una
conexi√≥n
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
251FIN_WAIT_2
.
En
este
estado
,
el
cliente
espera
a
recibir
otro
segmento
del
servidor
con
el


bit
FIN
puesto
a
1
;
una
vez
recibido
,
el
cliente
TCP
reconoce
el
segmento
del
servidor
y
pasa


al
estado
TIME_WAIT
,
en
el
que
puede
reenviar
al
cliente
TCP
el
reconocimiento
final
en


caso
de
que
el
paquete
ACK
se
pierda
.
El
tiempo
invertido
en
el
estado
TIME_WAIT
es


dependiente
de
la
aplicaci√≥n
,
siendo
sus
valores
t√≠picos
30
segundos
,
1
minuto
y
2
minutos
.


Despu√©s
de
este
tiempo
de
espera
,
la
conexi√≥n
se
cierra
y
todos
los
recursos
del
lado
del


cliente
(
incluyendo
los
n√∫meros
de
puerto
)
son
liberados
.


La
Figura
3.42
ilustra
la
serie
de
estados
que
visita
normalmente
el
TCP
del
lado
del


servidor
,
suponiendo
que
el
cliente
inicia
el
cierre
de
la
conexi√≥n
.
Las
transiciones
se
expli-


can
por
s√≠
mismas
.
En
estos
dos
diagramas
de
transiciones
de
estados
√∫nicamente
hemos


mostrado
c√≥mo
se
establece
y
termina
normalmente
una
conexi√≥n
TCP
.
No
hemos
descrito


lo
que
ocurre
en
determinados
escenarios
problem√°ticos
;
por
ejemplo
,
cuando
ambos
lados


de
una
conexi√≥n
desean
iniciar
o
terminar
al
mismo
tiempo
la
conexi√≥n
.
Si
est√°
interesado


en
este
tema
y
en
otros
algo
m√°s
avanzados
sobre
TCP
,
le
animamos
a
consultar
el
exhaus-


tivo
libro
de
[
Stevens
1994
]
.


Hasta
aqu√≠
,
hemos
supuesto
que
tanto
el
cliente
como
el
servidor
est√°n
preparados
para


comunicarse
;
es
decir
,
que
el
servidor
est√°
escuchando
en
el
puerto
al
que
el
cliente
env√≠a
su


segmento
SYN
.
Consideremos
lo
que
ocurre
cuando
un
host
recibe
un
segmento
TCP
cuyo


n√∫mero
de
puerto
o
cuya
direcci√≥n
IP
de
origen
no
se
corresponde
con
ninguno
de
los
soc-


kets
activos
en
el
host
.
Por
ejemplo
,
suponga
que
un
host
recibe
un
paquete
TCP
SYN
cuyo


puerto
de
destino
es
el
n√∫mero
80
,
pero
el
host
no
est√°
aceptando
conexiones
en
dicho
puerto


(
es
decir
,
no
est√°
ejecutando
un
servidor
web
en
el
puerto
80
)
.
Entonces
,
el
host
enviar√°
al


origen
un
segmento
especial
de
reinicio
.
Este
segmento
TCP
tiene
el
bit
indicador
RST


(
v√©ase
la
Secci√≥n
3.5.2
)
puesto
a
1
.
Por
tanto
,
cuando
un
host
env√≠a
un
segmento
de
reinicio
,


252
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Figura
3.41
‚Ä¢
Secuencia
t√≠pica
de
estados
TCP
visitados
por
un
cliente
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
252le
est√°
diciendo
al
emisor
‚Äú
No
tengo
un
socket
para
ese
segmento
.
Por
favor
,
no
reenvies
el


segmento
.
‚Äù
Cuando
un
host
recibe
un
paquete
UDP
en
el
que
el
n√∫mero
de
puerto
de
destino


no
se
corresponde
con
un
socket
UDP
activo
,
el
host
env√≠a
un
datagrama
ICMP
especial
,


como
se
explica
en
el
Cap√≠tulo
4
.


Ahora
que
ya
tenemos
unos
buenos
conocimientos
sobre
c√≥mo
se
gestiona
una
cone-


xi√≥n
TCP
,
vamos
a
volver
sobre
la
herramienta
de
exploraci√≥n
de
puertos
nmap
y
vamos
a


ver
m√°s
detalladamente
c√≥mo
funciona
.
Para
explorar
un
puerto
TCP
espec√≠fico
,
por
ejem-


plo
,
el
puerto
6789
,
en
un
host
objetivo
,
nmapenviar√°
un
segmento
TCP
SYN
con
el
puerto


de
destino
6789
a
dicho
host
.
Pueden
obtenerse
entonces
tres
posibles
resultados
:


‚Ä¢
El
host
de
origen
recibe
un
segmento
TCP
SYNACK
del
host
objetivo
.
Dado
que
esto
sig-


nifica
que
hay
una
aplicaci√≥n
ejecut√°ndose
con
TCP
en
el
puerto
6789
del
host
objetivo
,


nmapdevuelve
‚Äú
open
‚Äù
(
puerto
abierto
)
.


‚Ä¢
El
host
de
origen
recibe
un
segmento
TCP
RST
procedente
desde
el
host
objetivo
.
Esto


significa
que
el
segmento
SYN
ha
alcanzado
el
host
objetivo
,
pero
√©ste
no
est√°
ejecu-


tando
una
aplicaci√≥n
con
TCP
en
el
puerto
6789
.
Pero
el
atacante
sabr√°
como
m√≠nimo


que
el
segmento
destinado
al
puerto
6789
del
host
no
est√°
bloqueado
por
ning√∫n
corta-


fuegos
existente
en
la
ruta
entre
los
hosts
de
origen
y
de
destino
.
(
Los
cortafuegos
se


estudian
en
el
Cap√≠tulo
8
.
)


‚Ä¢
El
origen
no
recibe
nada
.
Probablemente
,
esto
significa
que
el
segmento
SYN
fue
blo-


queado
por
un
cortafuegos
intermedio
y
nunca
lleg√≥
al
host
objetivo
.


nmap
es
una
potente
herramienta
que
puede
detectar
‚Äú
las
brechas
en
el
muro
‚Äù
,
no
s√≥lo


en
lo
relativo
a
los
puertos
TCP
abiertos
,
sino
tambi√©n
a
los
puertos
UDP
abiertos
,
a
los
cor-


tafuegos
y
sus
configuraciones
e
incluso
,
a
las
versiones
de
aplicaciones
y
sistemas
operati-


vos
.
La
mayor
parte
de
esta
tarea
se
lleva
a
cabo
manipulando
los
segmentos
de
gesti√≥n
de


3.5
‚Ä¢
TRANSPORTE
ORIENTADO
A
LA
CONEXI√ìN
253


Figura
3.42
‚Ä¢
Secuencia
t√≠pica
de
estados
TCP
visitados
por
un
servidor
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
253254
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


FOCUS
ON
SECURITY


EL
ATAQUE
POR
INUNDACI√ìN
SYN


Hemos
visto
el
proceso
de
acuerdo
en
tres
fases
de
TCP
en
el
que
un
servidor
asigna
e


inicializa
los
buffers
y
variables
de
una
conexi√≥n
en
respuesta
a
la
recepci√≥n
de
un


segmento
SYN
.
A
continuaci√≥n
,
el
servidor
env√≠a
como
respuesta
un
segmento
SYNACK
y


espera
al
correspondiente
segmento
de
reconocimiento
(
ACK
)
procedente
del
cliente
,
el
ter-


cer
y
√∫ltimo
paso
del
proceso
de
acuerdo
antes
de
que
la
conexi√≥n
quede
completamente


establecida
.
Si
el
cliente
no
env√≠a
un
segmento
ACK
para
completar
el
tercero
de
los
pasos


del
proceso
de
acuerdo
en
tres
fases
,
al
final
(
a
menudo
despu√©s
de
un
minuto
o
m√°s
)
el
ser-


vidor
terminar√°
la
conexi√≥n
semiabierta
y
reclamar√°
los
recursos
asignados
.


Este
protocolo
de
gesti√≥n
de
la
conexi√≥n
TCP
establece
la
base
para
un
ataque
DoS
cl√°-


sico
,
conocido
como
ataque
por
inundaci√≥n
SYN
.
En
este
ataque
,
los
malos
env√≠an
un


gran
n√∫mero
de
segmentos
SYN
TCP
,
sin
completar
el
tercer
paso
del
proceso
de
acuerdo
.
El


ataque
se
puede
amplificar
enviando
segmentos
SYN
desde
varios
or√≠genes
,
creando
un
ata-


que
por
inundaci√≥n
SYN
DDoS
(
Distributed
Denial
of
Service
,
Servicio
de
denegaci√≥n
distri-


buido
)
.
Con
esta
gran
cantidad
de
segmentos
SYN
,
los
recursos
de
conexi√≥n
del
servidor


pueden
agotarse
r√°pidamente
a
medida
que
se
van
asignando
(
¬°
aunque
nunca
se
utilizan
!
)
a


conexiones
semiabiertas
.
Con
los
recursos
del
servidor
agotados
,
se
niega
el
servicio
a
los


clientes
leg√≠timos
.
Estos
ataques
por
inundaci√≥n
SYN
[
CERT
SYN
1996
]
se
encuentran
entre


los
primeros
ataques
DoS
documentados
por
el
CERT
[
CERT
2009
]
.


La
inundaci√≥n
con
segmentos
SYN
es
un
ataque
potencialmente
devastador
.
Afortunada-


mente
,
existe
una
defensa
efectiva
,
denominada
cookies
SYN
[
Skoudis
2006
;
Cisco
SYN


2009
;
Bernstein
2009
]
,
actualmente
implantada
en
la
mayor√≠a
de
los
principales
sistemas


operativos
.
Las
cookies
SYN
funcionan
del
siguiente
modo
:


o
 
Cuando
el
servidor
recibe
un
segmento
SYN
,
no
sabe
si
ese
segmento
procede
de
un


usuario
leg√≠timo
o
forma
parte
de
un
ataque
por
inundaci√≥n
SYN
.
Por
tanto
,
el
servidor


no
crea
una
conexi√≥n
semiabierta
TCP
para
ese
segmento
SYN
.
En
su
lugar
,
el
servidor


crea
un
n√∫mero
de
secuencia
TCP
inicial
que
es
una
funci√≥n
compleja
(
una
funci√≥n
hash
)


de
las
direcciones
IP
de
origen
y
de
destino
y
los
n√∫meros
de
puerto
del
segmento
SYN
,


as√≠
como
de
un
n√∫mero
secreto
que
√∫nicamente
conoce
el
servidor
.
(
El
servidor
utiliza
el


mismo
n√∫mero
secreto
para
un
gran
n√∫mero
de
conexiones
.
)
Este
n√∫mero
de
secuencia
ini-


cial
cuidadosamente
confeccionado
se
denomina
‚Äú
cookie
‚Äù
.
El
servidor
tiene
entonces
que


enviar
un
paquete
SYNACK
con
este
n√∫mero
de
secuencia
inicial
especial
.
Es
importante


que
el
servidor
no
recuerde
la
cookie
ni
ninguna
otra
informaci√≥n
de
estado
correspon-


diente
al
paquete
SYN
.


o
 
Si
el
cliente
es
leg√≠timo
,
entonces
devolver√°
un
segmento
ACK
.
El
servidor
,
al
recibir
este


ACK
,
tiene
que
verificar
que
corresponde
a
alg√∫n
SYN
enviado
anteriormente
.
¬ø
C√≥mo
se


hace
esto
si
el
servidor
no
mantiene
memoria
acerca
de
los
segmentos
SYN
?
Como
ya


habr√°
imaginado
,
se
hace
utilizando
la
cookie
.
Concretamente
,
para
un
segmento
ACK


leg√≠timo
,
el
valor
contenido
en
el
campo
de
reconocimiento
es
igual
al
n√∫mero
de


secuencia
del
segmento
SYNACK
m√°s
uno
(
v√©ase
la
Figura
3.39
)
.
A
continuaci√≥n
,
el


servidor
ejecuta
la
misma
funci√≥n
utilizando
los
mismos
campos
en
el
segmento
ACK
y


SEGURIDAD


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
254la
conexi√≥n
TCP
[
Skoudis
2006
]
.
Si
se
encuentra
cerca
de
una
m√°quina
Linux
,
puede
reali-


zar
algunas
pruebas
directamente
con
nmap
,
simplemente
escribiendo
‚Äú
nmap
‚Äù
en
la
l√≠nea
de


comandos
.
Puede
descargar
nmap
para
otros
sistemas
operativos
en
la
direcci√≥n
http://inse-


cure.org/nmap
.


Con
esto
completamos
nuestra
introducci√≥n
a
los
mecanismos
de
control
de
errores
y


de
control
de
flujo
de
TCP
.
En
la
Secci√≥n
3.7
,
volveremos
sobre
TCP
y
estudiaremos
m√°s


detalladamente
el
control
de
congesti√≥n
de
TCP
.
Sin
embargo
,
antes
de
eso
,
vamos
a
dar
un


paso
atr√°s
y
vamos
a
examinar
los
problemas
de
control
de
congesti√≥n
en
un
contexto
m√°s


amplio
.


3.6
Principios
del
control
de
congesti√≥n


En
la
secci√≥n
anterior
hemos
examinado
tanto
los
principios
generales
como
los
espec√≠fi-


cos
de
los
mecanismos
de
TCP
utilizados
para
proporcionar
un
servicio
de
transferencia


de
datos
fiable
en
lo
que
se
refiere
a
la
p√©rdida
de
paquetes
.
Anteriormente
hab√≠amos
men-


cionado
que
,
en
la
pr√°ctica
,
tales
p√©rdidas
son
normalmente
el
resultado
de
un
desborda-


miento
de
los
buffers
de
los
routers
a
medida
que
la
red
se
va
congestionando
.
La


retransmisi√≥n
de
paquetes
por
tanto
se
ocupa
de
un
s√≠ntoma
de
la
congesti√≥n
de
red
(
la


p√©rdida
de
un
segmento
espec√≠fico
de
la
capa
de
transporte
)
pero
no
se
ocupa
de
la
causa


de
esa
congesti√≥n
de
la
red
(
demasiados
emisores
intentando
transmitir
datos
a
una
velo-


cidad
demasiado
alta
)
.
Para
tratar
la
causa
de
la
congesti√≥n
de
la
red
son
necesarios
meca-


nismos
que
regulen
el
flujo
de
los
emisores
en
cuanto
la
congesti√≥n
de
red
aparezca
.


En
esta
secci√≥n
consideraremos
el
problema
del
control
de
congesti√≥n
en
un
contexto


general
,
con
el
fin
de
comprender
por
qu√©
la
congesti√≥n
es
algo
negativo
,
c√≥mo
la
conges-


3.6
‚Ä¢
PRINCIPIOS
DEL
CONTROL
DE
CONGESTI√ìN
255


el
n√∫mero
secreto
.
Si
el
resultado
de
la
funci√≥n
m√°s
uno
es
igual
que
el
n√∫mero
de
reco-


nocimiento
,
el
servidor
concluye
que
el
ACK
se
corresponde
con
un
segmento
SYN
ante-


rior
y
,
por
tanto
,
lo
valida
.
A
continuaci√≥n
,
el
servidor
crea
una
conexi√≥n
completamente


abierta
junto
con
un
socket
.


o
 
Por
el
contrario
,
si
el
cliente
no
devuelve
un
segmento
ACK
,
entonces
el
segmento
SYN


original
no
causa
ning√∫n
da√±o
al
servidor
,
ya
que
√©ste
no
le
ha
asignado
ning√∫n
recurso
.


Las
cookies
SYN
eliminan
de
forma
efectiva
la
amenaza
de
un
ataque
por
inundaci√≥n


SYN
.
Una
variaci√≥n
de
esta
clase
de
ataque
es
que
el
cliente
malicioso
devuelva
un
segmento


ACK
v√°lido
para
cada
segmento
SYNACK
que
el
servidor
genera
.
Esto
har√°
que
el
servidor


establezca
conexiones
TCP
completamente
abiertas
,
incluso
aunque
su
sistema
operativo


emplee
cookies
SYN
.
Si
decenas
de
miles
de
clientes
est√°n
siendo
utilizados
(
ataque
DDoS
)
,


teniendo
cada
uno
una
direcci√≥n
IP
distinta
,
entonces
ser√°
dif√≠cil
para
el
servidor
diferenciar


entre
los
or√≠genes
leg√≠timos
y
los
maliciosos
.
Por
tanto
,
contra
este
‚Äú
ataque
que
completa
el


proceso
de
acuerdo
‚Äù
puede
ser
m√°s
dif√≠cil
defenderse
que
contra
un
ataque
cl√°sico
por
inun-


daci√≥n
SYN
.


SEGURIDAD


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
255ti√≥n
de
la
red
se
manifiesta
en
el
rendimiento
ofrecido
a
las
aplicaciones
de
la
capa
superior


y
c√≥mo
pueden
aplicarse
diversos
m√©todos
para
evitar
la
congesti√≥n
de
la
red
o
reaccionar


ante
la
misma
.
Este
estudio
de
car√°cter
general
del
control
de
la
congesti√≥n
es
apropiado


porque
,
puesto
que
junto
con
la
transferencia
de
datos
fiable
,
se
encuentra
al
principio
de
la


lista
de
los
diez
problemas
m√°s
importantes
de
las
redes
.
Concluiremos
esta
secci√≥n
con
una


exposici√≥n
acerca
del
control
de
congesti√≥n
en
el
servicio
ABR
(
Available
Bit-Rate
,
veloci-


dad
de
bit
disponible
)
de
las
redes
ATM
(
Asynchronous
Transfer
Mode
,
Modo
de
trans-


ferencia
as√≠ncrono
)
.
En
la
siguiente
secci√≥n
se
lleva
a
cabo
un
estudio
detallado
sobre
el


algoritmo
de
control
de
congesti√≥n
de
TCP
.


3.6.1
Las
causas
y
los
costes
de
la
congesti√≥n


Iniciemos
este
estudio
sobre
el
control
de
congesti√≥n
examinando
tres
escenarios
con
una


complejidad
creciente
en
los
que
se
produce
congesti√≥n
.
En
cada
caso
,
veremos
en
primer


lugar
por
qu√©
se
produce
la
congesti√≥n
y
el
coste
de
la
misma
(
en
t√©rminos
de
recursos
no


utilizados
por
completo
y
del
bajo
rendimiento
ofrecido
a
los
sistemas
terminales
)
.
Todav√≠a


no
vamos
a
entrar
a
ver
c√≥mo
reaccionar
ante
una
congesti√≥n
,
o
c√≥mo
evitarla
,
simplemente


vamos
a
poner
el
foco
sobre
la
cuesti√≥n
m√°s
simple
de
comprender
:
qu√©
ocurre
cuando
los


hosts
incrementan
su
velocidad
de
transmisi√≥n
y
la
red
comienza
a
congestionarse
.


Escenario
1
:
dos
emisores
,
un
router
con
buffers
de
capacidad
ilimitada


Veamos
el
escenario
de
congesti√≥n
m√°s
simple
posible
:
dos
hosts
(
A
y
B
)
,
cada
uno
de
los


cuales
dispone
de
una
conexi√≥n
que
comparte
un
√∫nico
salto
entre
el
origen
y
el
destino
,


como
se
muestra
en
la
Figura
3.43
.


Supongamos
que
la
aplicaci√≥n
del
host
A
est√°
enviando
datos
a
la
conexi√≥n
(
por
ejem-


plo
,
est√°
pasando
datos
al
protocolo
de
la
capa
de
transporte
a
trav√©s
de
un
socket
)
a
una


velocidad
media
de
/H9261
in
bytes
/
segundo
.
Estos
datos
son
originales
en
el
sentido
de
que
cada


unidad
de
datos
se
env√≠a
s√≥lo
una
vez
al
socket
.
El
protocolo
del
nivel
de
transporte
subya-


cente
es
un
protocolo
simple
.
Los
datos
se
encapsulan
y
se
env√≠an
;
no
existe
un
mecanismo


256
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Host
B


Buffers
del
enlace
de
salida


compartidos
no
limitados


Host
A
Host
DHost
C


Figura
3.43
‚Ä¢
Escenario
de
congesti√≥n
1
:
dos
conexiones
que
comparten
un


√∫nico
salto
con
buffers
de
capacidad
ilimitada
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
256de
recuperaci√≥n
de
errores
(
como
por
ejemplo
,
las
retransmisiones
)
,
ni
se
realiza
un
control


de
flujo
ni
un
control
de
congesti√≥n
.
Ignorando
la
sobrecarga
adicional
debida
a
la
adici√≥n


de
la
informaci√≥n
de
cabecera
de
las
capas
de
transporte
e
inferiores
,
la
velocidad
a
la
que
el


host
A
entrega
tr√°fico
al
router
en
este
primer
escenario
es
por
tanto
/H9261
in
bytes
/
segundo
.
El


host
B
opera
de
forma
similar
,
y
suponemos
,
con
el
fin
de
simplificar
,
que
tambi√©n
est√°


enviando
datos
a
una
velocidad
de
/H9261
in
bytes
/
segundo
.
Los
paquetes
que
salen
de
los
hosts
A


y
B
atraviesan
un
router
y
un
enlace
de
salida
compartido
de
capacidad
R.
El
router
tiene


buffers
que
le
permiten
almacenar
paquetes
entrantes
cuando
la
tasa
de
llegada
de
paquetes


excede
la
capacidad
del
enlace
de
salida
.
En
este
primer
escenario
,
suponemos
que
el
router


tiene
un
buffer
con
una
cantidad
de
espacio
infinita
.


La
Figura
3.44
muestra
el
rendimiento
de
la
conexi√≥n
del
host
A
en
este
primer
escena-


rio
.
La
gr√°fica
de
la
izquierda
muestra
la
tasa
de
transferencia
por
conexi√≥n
(
n√∫mero
de


bytes
por
segundo
en
el
receptor
)
como
una
funci√≥n
de
la
velocidad
de
transmisi√≥n
de
la


conexi√≥n
.
Para
una
velocidad
de
transmisi√≥n
comprendida
entre
0
y
R/2
,
la
tasa
de
transfe-


rencia
en
el
receptor
es
igual
a
la
velocidad
de
transmisi√≥n
en
el
emisor
(
todo
lo
que
env√≠a


el
emisor
es
recibido
en
el
receptor
con
un
retardo
finito
)
.
Sin
embargo
,
cuando
la
veloci-


dad
de
transmisi√≥n
es
mayor
que
R/2
,
la
tasa
de
transferencia
es
de
s√≥lo
R/2
.
Este
l√≠mite


superior
de
la
tasa
de
transferencia
es
una
consecuencia
de
compartir
entre
dos
conexiones


la
capacidad
del
enlace
.
El
enlace
simplemente
no
puede
proporcionar
paquetes
a
un
recep-


tor
a
una
velocidad
de
r√©gimen
permanente
que
sea
mayor
que
R/2
.
Independientemente
de


lo
altas
que
sean
las
velocidades
de
transmisi√≥n
de
los
hosts
A
y
B
,
nunca
ver√°n
una
tasa
de


transferencia
mayor
que
R/2
.


Alcanzar
una
tasa
de
transferencia
por
conexi√≥n
de
R/2
podr√≠a
realmente
parecer
algo


positivo
,
porque
el
enlace
se
utiliza
completamente
en
suministrar
paquetes
a
sus
destinos
.


Sin
embargo
,
la
gr√°fica
de
la
derecha
de
la
Figura
3.44
muestra
la
consecuencia
de
operar


cerca
de
la
capacidad
del
enlace
.
A
medida
que
la
velocidad
de
transmisi√≥n
se
aproxima
a


R/2
(
desde
la
izquierda
)
,
el
retardo
medio
se
hace
cada
vez
m√°s
grande
.
Cuando
la
velocidad


de
transmisi√≥n
excede
de
R/2
,
el
n√∫mero
medio
de
paquetes
en
cola
en
el
router
no
est√°
limi-


tado
y
el
retardo
medio
entre
el
origen
y
el
destino
se
hace
infinito
(
suponiendo
que
las
cone-


xiones
operan
a
esas
velocidades
de
transmisi√≥n
durante
un
periodo
de
tiempo
infinito
y
que


existe
una
cantidad
infinita
de
espacio
disponible
en
el
buffer
)
.
Por
tanto
,
aunque
operar
a


3.6
‚Ä¢
PRINCIPIOS
DEL
CONTROL
DE
CONGESTI√ìN
257


R/2


R/2


Retardo


R/2


a.
b.


Figura
3.44
‚Ä¢
Escenario
de
congesti√≥n1
:
tasa
de
transferencia
y
retardo


en
funci√≥n
de
la
velocidad
de
transmisi√≥n
del
host
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
257una
tasa
de
transferencia
agregada
pr√≥xima
a
R
puede
ser
ideal
desde
el
punto
de
vista
de
la


tasa
de
transferencia
,
no
es
ideal
en
absoluto
desde
el
punto
de
vista
del
retardo
.
Incluso
en


este
escenario
(
extremadamente
)
idealizado
,
ya
hemos
encontrado
uno
de
los
costes
de
una


red
congestionada
:
los
grandes
retardos
de
cola
experimentados
cuando
la
tasa
de
llegada


de
los
paquetes
se
aproxima
a
la
capacidad
del
enlace
.


Escenario
2
:
dos
emisores
y
un
router
con
buffers
finitos


Ahora
vamos
a
modificar
ligeramente
el
escenario
1
de
dos
formas
(
v√©ase
la
Figura
3.45
)
.


En
primer
lugar
,
suponemos
que
el
espacio
disponible
en
los
buffers
del
router
es
finito
.


Una
consecuencia
de
esta
suposici√≥n
aplicable
en
la
pr√°ctica
es
que
los
paquetes
ser√°n
des-


cartados
cuando
lleguen
a
un
buffer
que
ya
est√©
lleno
.
En
segundo
lugar
,
suponemos
que


cada
conexi√≥n
es
fiable
.
Si
un
paquete
que
contiene
un
segmento
de
la
capa
de
transporte


se
descarta
en
el
router
,
el
emisor
tendr√°
que
retransmitirlo
.
Dado
que
los
paquetes
pueden


retransmitirse
,
ahora
tenemos
que
ser
m√°s
cuidadosos
al
utilizar
el
t√©rmino
velocidad
de


transmisi√≥n
.
Espec√≠ficamente
,
vamos
a
designar
la
velocidad
a
la
que
la
aplicaci√≥n
env√≠a


los
datos
originales
al
socket
como
/H9261
in
bytes
/
segundo
.
La
velocidad
a
la
que
la
capa
de


transporte
env√≠a
segmentos
(
que
contienen
los
datos
originales
y
los
datos
retransmitidos
)
a


la
red
la
denotaremos
como
/H9261
/
H11032
in
bytes
/
segundo
.
En
ocasiones
,
/H9261
/
H11032
in
se
denomina
carga
ofre-


cida
a
la
red
.


El
rendimiento
de
este
segundo
escenario
depender√°
en
gran
medida
de
c√≥mo
se


realicen
las
retransmisiones
.
En
primer
lugar
,
considere
el
caso
no
realista
en
el
que
el


host
A
es
capaz
de
determinar
de
alguna
manera
(
m√°gicamente
)
si
el
buffer
en
el
router


est√°
libre
o
lleno
y
enviar
entonces
un
paquete
s√≥lo
cuando
el
buffer
est√©
libre
.
En
este


caso
no
se
producir√≠a
ninguna
p√©rdida
,
/H9261
in
ser√≠a
igual
a
/H9261
/
H11032
in
y
la
tasa
de
transferencia
de
la


conexi√≥n
ser√≠a
igual
a
/H9261
in
.
Este
caso
se
muestra
en
la
Figura
3.46(a
)
.
Desde
el
punto
de
vista


258
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Buffers
del
enlace
de
salida
compartidos


y
con
capacidad
finita


Host
BHost
A
Host
DHost
C


Œªout


Œªin
:
datos
orirginales


Œª‚Äôin
:
datos
originales
m√°s
datos
retransmitidos


Figura
3.45
‚Ä¢
Escenario
2
:
dos
hosts
(
con
retransmisi√≥n
)
y
un
router
con
buffers


con
capacidad
finita
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
258de
la
tasa
de
transferencia
,
el
rendimiento
es
ideal
:
todo
lo
que
se
env√≠a
,
se
recibe
.
Observe


que
,
en
este
escenario
,
la
velocidad
media
de
transmisi√≥n
de
host
no
puede
ser
mayor
que


R/2
,
ya
que
se
supone
que
nunca
tiene
lugar
una
p√©rdida
de
paquetes
.


Consideremos
ahora
un
caso
algo
m√°s
realista
en
el
que
el
emisor
s√≥lo
retransmite


cuando
sabe
con
seguridad
que
un
paquete
se
ha
perdido
.
De
nuevo
,
esta
es
una
suposici√≥n


un
poco
exagerada
;
sin
embargo
,
es
posible
que
el
host
emisor
tenga
fijado
su
intervalo
de


fin
de
temporizaci√≥n
en
un
valor
lo
suficientemente
grande
como
para
garantizar
que
un


paquete
que
no
ha
sido
reconocido
es
un
paquete
que
se
ha
perdido
.
En
este
caso
,
el
rendi-


miento
puede
ser
similar
al
mostrado
en
la
Figura
3.46(b
)
.
Para
apreciar
lo
que
est√°
ocu-


rriendo
aqu√≠
,
considere
el
caso
en
el
que
la
carga
ofrecida
,
/H9261
/
H11032
in
(
la
velocidad
de
transmisi√≥n


de
los
datos
originales
m√°s
la
de
las
retransmisiones
)
,
es
igual
a
R/2
.
Seg√∫n
la
Figura


3.46(b
)
,
para
este
valor
de
la
carga
ofrecida
la
velocidad
a
la
que
los
datos
son
suministrados


a
la
aplicaci√≥n
del
receptor
es
R/3
.
Por
tanto
,
de
las
0,5
R
unidades
de
datos
transmitidos
,


0,333R
bytes
/
segundo
(
como
media
)
son
datos
originales
y
0,166
R
bytes
/
segundo
(
como


media
)
son
datos
retransmitidos
.
Tenemos
aqu√≠
por
tanto
otro
de
los
costes
de
una
red
con-


gestionada
:
el
emisor
tiene
que
realizar
retransmisiones
para
poder
compensar
los
paque-


tes
descartados
(
perdidos
)
a
causa
de
un
desbordamiento
de
buffer
.


Por
√∫ltimo
,
considere
el
caso
en
el
que
el
emisor
puede
alcanzar
el
fin
de
la
temporiza-


ci√≥n
de
forma
prematura
y
retransmitir
un
paquete
que
ha
sido
retardado
en
la
cola
pero


que
todav√≠a
no
se
ha
perdido
.
En
este
caso
,
tanto
el
paquete
de
datos
original
como
la


retransmisi√≥n
pueden
llegar
al
receptor
.
Por
supuesto
,
el
receptor
necesitar√°
s√≥lo
una
copia


de
este
paquete
y
descartar√°
la
retransmisi√≥n
.
En
este
caso
,
el
trabajo
realizado
por
el
rou-


ter
al
reenviar
la
copia
retransmitida
del
paquete
original
se
desperdicia
,
ya
que
el
receptor


ya
hab√≠a
recibido
la
copia
original
de
ese
paquete
.
El
router
podr√≠a
haber
hecho
un
mejor


uso
de
la
capacidad
de
transmisi√≥n
del
enlace
enviando
en
su
lugar
un
paquete
distinto
.
Por


tanto
,
tenemos
aqu√≠
otro
de
los
costes
de
una
red
congestionada
:
las
retransmisiones
inne-


cesarias
del
emisor
causadas
por
retardos
largos
pueden
llevar
a
que
un
router
utilice
el


ancho
de
banda
del
enlace
para
reenviar
copias
innecesarias
de
un
paquete
.
La
Figura


3.46
(
c
)
muestra
la
tasa
de
transferencia
en
funci√≥n
de
la
carga
ofrecida
cuando
se
supone


que
el
router
reenv√≠a
cada
paquete
dos
veces
(
como
media
)
.
Dado
que
cada
paquete
se


reenv√≠a
dos
veces
,
la
tasa
de
transferencia
tendr√°
un
valor
asint√≥tico
de
R/4
cuando
la
carga


ofrecida
se
aproxime
a
R/2
.


3.6
‚Ä¢
PRINCIPIOS
DEL
CONTROL
DE
CONGESTI√ìN
259


R/2


R/2
R/2


Œªout


a.
b.


R/2Œªout


R/3


R/2


R/2


ŒªoutR/4


c.


Œª‚Äôin
Œª‚Äôin
Œª‚Äôin


Figura
3.46
‚Ä¢
Escenario
2
:
rendimiento
con
buffers
de
capacidad
finita
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
259Escenario
3
:
cuatro
emisores
,
routers
con
buffers
de
capacidad
finita
y


rutas
con
m√∫ltiples
saltos


En
este
√∫ltimo
escenario
dedicado
a
la
congesti√≥n
de
red
tenemos
cuatro
hosts
que
transmi-


ten
paquetes
a
trav√©s
de
rutas
solapadas
con
dos
saltos
,
como
se
muestra
en
la
Figura
3.47
.


De
nuevo
suponemos
que
cada
host
utiliza
un
mecanismo
de
fin
de
temporizaci√≥n
/
retrans-


misi√≥n
para
implementar
un
servicio
de
transferencia
de
datos
fiable
,
que
todos
los
hosts
tie-


nen
el
mismo
valor
de
/H9261
in
y
que
todos
los
enlaces
de
router
tienen
una
capacidad
de
R


bytes
/
segundo
.


Consideremos
la
conexi√≥n
del
host
A
al
host
C
pasando
a
trav√©s
de
los
routers
R1
y
R2
.


La
conexi√≥n
A‚ÄìC
comparte
el
router
R1
con
la
conexi√≥n
D‚ÄìB
y
comparte
el
router
R2
con


la
conexi√≥n
B‚ÄìD.
Para
valores
extremadamente
peque√±os
de
/H9261
in
,
es
raro
que
el
buffer
se
des-


borde
(
como
en
los
dos
escenarios
de
congesti√≥n
anteriores
)
,
y
la
tasa
de
transferencia
es


aproximadamente
igual
a
la
carga
ofrecida
.
Para
valores
ligeramente
m√°s
grandes
de
/H9261
in
,
la


correspondiente
tasa
de
transferencia
es
tambi√©n
m√°s
grande
,
ya
que
se
est√°n
transmitiendo


m√°s
datos
originales
por
la
red
y
entreg√°ndose
en
su
destino
,
y
los
desbordamientos
siguen


siendo
raros
.
Por
tanto
,
para
valores
peque√±os
de
/H9261
in
,
un
incremento
de
 
/H9261
in
da
lugar
a
un


incremento
de
/H9261out
.


260
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Host
BHost
A


R1


R4
R2


R3


Host
CHost
D

 
Buffers
del
enlace
de
salida


compartidos
y
finitos


Œªin
:
datos
originales


Œª‚Äôin
:
datos
originales

        
m√°s
datos

        
retransmitidos


Œªout


Figura
3.47
‚Ä¢
Cuatro
emisores
,
routers
con
buffers
finitos
y
rutas
con
varios
saltos
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
260Una
vez
considerado
el
caso
de
tr√°fico
extremadamente
bajo
,
pasemos
a
examinar
el


caso
en
que
/H9261
in
(
y
por
tanto
/H9261
/
H11032
in
)
es
extremadamente
grande
.
Sea
el
router
R2
.
El
tr√°fico
de


A‚ÄìC
que
llega
al
router
R2
(
el
que
llega
a
R2
despu√©s
de
ser
reenviado
desde
R1
)
puede


tener
una
velocidad
de
llegada
a
R2
que
es
como
m√°ximo
R
,
la
capacidad
del
enlace
de
R1
a


R2
,
independientemente
del
valor
de
/H9261
in
.
Si
/H9261
/
H11032
in
es
extremadamente
grande
en
todas
las
cone-


xiones
(
incluyendo
la
conexi√≥n
B‚ÄìD
)
,
entonces
la
velocidad
de
llegada
del
tr√°fico
de
B‚ÄìD
a


R2
puede
ser
mucho
mayor
que
la
del
tr√°fico
de
A‚ÄìC.
Puesto
que
los
tr√°ficos
de
A‚ÄìC
y
B‚ÄìD


tienen
que
competir
en
el
router
R2
por
el
espacio
limitado
disponible
en
el
buffer
,
la
canti-


dad
de
tr√°fico
de
A‚ÄìC
que
consiga
atravesar
con
√©xito
R2
(
es
decir
,
que
no
se
pierda
por
des-


bordamiento
del
buffer
)
ser√°
cada
vez
menor
a
medida
que
la
carga
ofrecida
por
la
conexi√≥n


B‚ÄìD
aumente
.
En
el
l√≠mite
,
a
medida
que
la
carga
ofrecida
se
aproxima
a
infinito
,
un
buffer


vac√≠o
de
R2
es
llenado
de
forma
inmediata
por
un
paquete
de
B‚ÄìD
y
la
tasa
de
transferencia


de
la
conexi√≥n
A‚ÄìC
en
R2
tiende
a
cero
.
Esto
,
a
su
vez
,
implica
que
la
tasa
de
transferencia


terminal
a
terminal
de
A‚ÄìC
tiende
a
cero
en
el
l√≠mite
correspondiente
a
una
situaci√≥n
de
tr√°-


fico
intenso
.
Estas
consideraciones
dan
lugar
a
la
relaci√≥n
de
compromiso
entre
la
carga


ofrecida
y
la
tasa
de
transferencia
que
se
muestra
en
la
Figura
3.48
.


La
raz√≥n
del
eventual
decrecimiento
de
la
tasa
de
transferencia
al
aumentar
la
carga


ofrecida
es
evidente
cuando
se
considera
la
cantidad
de
trabajo
desperdiciado
realizado
por


la
red
.
En
el
escenario
descrito
anteriormente
en
el
que
hab√≠a
una
gran
cantidad
de
tr√°fico
,


cuando
un
paquete
se
descartaba
en
un
router
de
segundo
salto
,
el
trabajo
realizado
por
el


router
del
primer
salto
al
encaminar
un
paquete
al
router
del
segundo
salto
terminaba
siendo


‚Äú
desperdiciado
‚Äù
.
Para
eso
,
hubiera
dado
igual
que
el
primer
router
simplemente
hubiera
des-


cartado
dicho
paquete
y
hubiera
permanecido
inactivo
,
porque
de
todos
modos
el
paquete


no
llegar√≠a
a
su
destino
.
A√∫n
m√°s
,
la
capacidad
de
transmisi√≥n
utilizada
en
el
primer
router


para
encaminar
el
paquete
al
segundo
router
podr√≠a
haber
sido
mejor
aprovechada
si
se


hubiera
empleado
para
transmitir
un
paquete
diferente
(
por
ejemplo
,
al
seleccionar
un


paquete
para
transmitirlo
,
puede
resultar
mejor
para
un
router
dar
la
prioridad
a
los
paquetes


que
ya
hayan
pasado
por
varios
routers
anteriormente
)
.
Por
tanto
,
aqu√≠
nos
encontramos
con


otro
de
los
costes
de
descartar
un
paquete
a
causa
de
la
congesti√≥n
de
la
red
:
cuando
un


paquete
se
descarta
a
lo
largo
de
una
ruta
,
la
capacidad
de
transmisi√≥n
empleada
en
cada


uno
de
los
enlaces
anteriores
para
encaminar
dicho
paquete
hasta
el
punto
en
el
que
se
ha


descartado
termina
por
desperdiciarse
.


3.6
‚Ä¢
PRINCIPIOS
DEL
CONTROL
DE
CONGESTI√ìN
261


R/2Œªout


Œª‚Äôin


Figura
3.48
‚Ä¢
Escenario
3
:
rendimiento
con
buffers
finitos
y
rutas
multisalto
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
2613.6.2
M√©todos
para
controlar
la
congesti√≥n


En
la
Secci√≥n
3.7
examinaremos
en
gran
detalle
el
m√©todo
espec√≠fico
de
TCP
para
controlar


la
congesti√≥n
.
Ahora
,
vamos
a
identificar
los
dos
m√©todos
m√°s
comunes
de
control
de
con-


gesti√≥n
que
se
utilizan
en
la
pr√°ctica
y
abordaremos
las
arquitecturas
de
red
espec√≠ficas
y
los


protocolos
de
control
de
congesti√≥n
que
se
integran
en
estos
m√©todos
.


En
el
nivel
m√°s
general
,
podemos
diferenciar
entre
las
t√©cnicas
de
control
de
congesti√≥n


bas√°ndonos
en
si
la
capa
de
red
proporciona
alguna
ayuda
expl√≠cita
a
la
capa
de
transporte


con
prop√≥sitos
de
controlar
la
congesti√≥n
:


‚Ä¢
Control
de
congesti√≥n
terminal
a
terminal
.
En
este
m√©todo
,
la
capa
de
red
no
propor-


ciona
soporte
expl√≠cito
a
la
capa
de
transporte
para
prop√≥sitos
de
control
de
congesti√≥n
.


Incluso
la
presencia
de
congesti√≥n
en
la
red
tiene
que
ser
inferida
por
los
sistemas
termi-


nales
bas√°ndose
√∫nicamente
en
el
comportamiento
observado
de
la
red
(
por
ejemplo
,
la


p√©rdida
de
paquetes
y
los
retardos
)
.
En
la
Secci√≥n
3.7
veremos
que
TCP
tiene
que
aplicar


necesariamente
este
m√©todo
de
control
de
congesti√≥n
terminal
a
terminal
,
ya
que
la
capa


IP
no
proporciona
ninguna
realimentaci√≥n
a
los
sistemas
terminales
relativa
a
la
conges-


ti√≥n
de
la
red
.
La
p√©rdida
de
segmentos
TCP
(
indicada
por
un
fin
de
temporizaci√≥n
o
por


un
triple
paquete
ACK
duplicado
)
se
toma
como
indicaci√≥n
de
que
existe
congesti√≥n
en


la
red
,
por
lo
que
TCP
reduce
el
tama√±o
de
su
ventana
en
consecuencia
.
Tambi√©n
vere-


mos
una
propuesta
m√°s
reciente
para
abordar
el
control
de
congesti√≥n
de
TCP
que
utiliza


valores
de
retardo
de
ida
y
vuelta
crecientes
como
indicadores
de
que
existe
una
mayor


congesti√≥n
de
red
.


‚Ä¢
Control
de
congesti√≥n
asistido
por
la
red
.
En
este
m√©todo
de
control
de
congesti√≥n
,
los


componentes
de
la
capa
de
red
(
es
decir
,
los
routers
)
proporcionan
una
realimentaci√≥n


expl√≠cita
al
emisor
informando
del
estado
de
congesti√≥n
en
la
red
.
Esta
realimenta-


ci√≥n
puede
ser
tan
simple
como
un
√∫nico
bit
que
indica
que
existe
congesti√≥n
en
un


enlace
.
Este
m√©todo
se
aplic√≥
en
las
tempranas
arquitecturas
SNA
de
IBM
[
Schwartz


1982
]
y
DECnet
de
DEC
[
Jain
1989
;
Ramakrishnan
1990
]
,
fue
propuesto
recientemente


para
las
redes
TCP
/
IP
[
Floyd
TCP
1994
;
RFC
3168
]
y
se
utiliza
tambi√©n
en
el
mecanismo


de
control
de
congesti√≥n
de
ABR
(
Available
bit-rate
)
en
las
redes
ATM
,
como
hemos


mencionado
anteriormente
.
Tambi√©n
es
posible
proporcionar
una
realimentaci√≥n
de
red


m√°s
sofisticada
.
Por
ejemplo
,
una
forma
del
mecanismo
de
control
de
congesti√≥n
de
ABR


en
las
redes
ATM
que
estudiaremos
enseguida
permite
a
un
router
informar
expl√≠cita-


mente
al
emisor
de
la
velocidad
de
transmisi√≥n
que
el
router
puede
soportar
en
un
enlace


saliente
.
El
protocolo
XCP
[
Katabi
2002
]
proporciona
a
cada
origen
,
en
la
cabecera
del


paquete
,
informaci√≥n
de
realimentaci√≥n
calculada
por
el
router
,
indicando
c√≥mo
dicho


origen
debe
incrementar
o
disminuir
su
velocidad
de
transmisi√≥n
.


En
el
mecanismo
de
control
de
congesti√≥n
asistido
por
la
red
,
la
informaci√≥n
acerca
de
la


congesti√≥n
suele
ser
realimentada
de
la
red
al
emisor
de
una
de
dos
formas
,
como
se
ve
en


la
Figura
3.49
.
La
realimentaci√≥n
directa
puede
hacerse
desde
un
router
de
la
red
al
emisor
.


Esta
forma
de
notificaci√≥n
,
normalmente
,
toma
la
forma
de
un
paquete
de
asfixia
o
bloqueo


(
choke
packet
)
(
que
esencialmente
dice
‚Äú
¬°
Estoy
congestionada
!
‚Äù
)
.
La
segunda
forma
de
noti-


ficaci√≥n
tiene
lugar
cuando
un
router
marca
/
actualiza
un
campo
de
un
paquete
que
se
trans-


mite
del
emisor
al
receptor
para
indicar
que
existe
congesti√≥n
.
Despu√©s
de
recibir
un
paquete


marcado
,
el
receptor
notifica
al
emisor
la
existencia
de
congesti√≥n
.
Observe
que
esta
√∫ltima


forma
de
notificaci√≥n
tarda
al
menos
un
periodo
igual
al
tiempo
de
ida
y
vuelta
completo
.


262
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
2623.6.3
Ejemplo
de
control
de
congestion
asistido
por
la
red
:


control
de
congesti√≥n
en
el
servicio
ABR
de
las
redes
ATM


Vamos
a
terminar
esta
secci√≥n
con
un
breve
estudio
del
algoritmo
de
control
de
congesti√≥n


del
servicio
ABR
de
las
redes
ATM
,
un
protocolo
que
aplica
un
mecanismo
de
control
de


congesti√≥n
asistido
por
la
red
.
Tenemos
que
decir
que
nuestro
objetivo
en
este
caso
no
es


describir
en
detalle
los
aspectos
de
la
arquitectura
ATM
,
sino
ilustrar
un
protocolo
que


aplica
un
m√©todo
marcadamente
diferente
al
mecanismo
de
control
de
congesti√≥n
utilizado


por
el
protocolo
TCP
de
Internet
.
De
hecho
,
s√≥lo
abordaremos
unos
pocos
aspectos
de
la


arquitectura
ATM
que
son
necesarios
para
comprender
el
control
de
congesti√≥n
del
servicio


ABR
.


Fundamentalmente
,
ATM
emplea
para
la
conmutaci√≥n
de
paquetes
una
t√©cnica
basada


en
circuitos
virtuales
(
VC
,
Virtual
Circuit
)
.
Recuerde
del
Cap√≠tulo
1
que
esto
significa
que


cada
dispositivo
de
conmutaci√≥n
a
lo
largo
de
la
ruta
mantiene
el
estado
del
circuito
virtual


existente
entre
el
origen
y
el
destino
.
El
tener
informaci√≥n
del
estado
de
cada
VC
permite
a


un
dispositivo
de
conmutaci√≥n
conocer
el
comportamiento
de
cada
emisor
individual
(
por


ejemplo
,
conocer
su
velocidad
media
de
transmisi√≥n
)
y
llevar
a
cabo
acciones
para
el
con-


trol
de
congesti√≥n
espec√≠ficas
para
cada
origen
(
tales
como
indicar
expl√≠citamente
al
emisor


que
debe
reducir
su
velocidad
cuando
el
conmutador
comienza
a
congestionarse
)
.
La
infor-


maci√≥n
del
estado
de
cada
VC
conservada
en
los
conmutadores
de
la
red
hace
que
las
redes


ATM
est√©n
idealmente
adaptadas
para
realizar
un
control
de
congesti√≥n
asistido
por
la
red
.


ABR
ha
sido
dise√±ado
como
un
servicio
de
transferencia
de
datos
el√°stico
de
una
forma


que
recuerda
a
TCP
.
Cuando
la
red
est√°
poco
cargada
,
el
servicio
ABR
deber√≠a
poder
apro-


vecharse
del
ancho
de
banda
de
reserva
disponible
;
si
la
red
est√°
congestionada
,
el
servicio


ABR
deber√≠a
reducir
su
velocidad
de
transmisi√≥n
a
un
valor
m√≠nimo
predeterminado
.
Puede


encontrar
un
tutorial
detallado
sobre
la
gesti√≥n
de
tr√°fico
y
el
control
de
congesti√≥n
del
ser-


vicio
ABR
en
redes
ATM
en
[
Jain
1996
]
.


La
Figura
3.50
muestra
el
marco
de
trabajo
del
mecanismo
de
control
de
congesti√≥n
del


servicio
ABR
en
las
redes
ATM
.
En
esta
exposici√≥n
,
hemos
adoptado
la
terminolog√≠a
de


3.6
‚Ä¢
PRINCIPIOS
DEL
CONTROL
DE
CONGESTI√ìN
263


Host
A


Realimentaci√≥n
de
red
a
trav√©s
del
receptor


Realimentaci√≥n


de
red
directa


Host
B


Figura
3.49
‚Ä¢
Dos
formas
de
realimentaci√≥n
de
la
informaci√≥n
asistido
por
la


red
acerca
de
la
congesti√≥n
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
263ATM
(
por
ejemplo
,
utilizando
el
t√©rmino
dispositivo
de
conmutaci√≥n
en
lugar
de
router
y
el


t√©rmino
celda
en
lugar
de
paquete
)
.
Con
el
servicio
ABR
de
ATM
,
las
celdas
de
datos
se


transmiten
desde
un
origen
a
un
destino
a
trav√©s
de
una
serie
de
dispositivos
de
conmuta-


ci√≥n
intermedios
.
Intercaladas
con
las
celdas
de
datos
se
encuentran
las
celdas
de
gesti√≥n


de
recursos
(
celdas
RM
,
Resource-Management
)
;
estas
celdas
RM
se
pueden
utilizar
para


transportar
informaci√≥n
relativa
al
control
de
congesti√≥n
entre
los
hosts
y
los
dispositivos
de


conmutaci√≥n
.
Cuando
una
celda
RM
llega
a
un
destino
,
ser√°
enviada
de
vuelta
al
emisor


(
posiblemente
despu√©s
de
que
el
destino
haya
modificado
los
contenidos
de
la
celda
RM
)
.


Un
dispositivo
de
conmutaci√≥n
tambi√©n
puede
generar
una
celda
RM
propia
y
enviarla


directamente
a
un
origen
.
Las
celdas
RM
pueden
por
tanto
emplearse
para
proporcionar


tanto
realimentaci√≥n
directa
de
la
red
como
a
trav√©s
del
receptor
,
como
se
muestra
en
la


Figura
3.50
.


El
mecanismo
de
control
de
congesti√≥n
del
servicio
ABR
de
ATM
es
un
m√©todo
basado


en
la
velocidad
.
Es
decir
,
el
emisor
calcula
de
forma
expl√≠cita
una
velocidad
m√°xima
a
la


que
puede
transmitir
y
se
autorregula
de
acuerdo
con
ello
.
ABR
proporciona
tres
mecanis-


mos
para
se√±alizar
la
informaci√≥n
relativa
a
la
congesti√≥n
transmitida
desde
los
dispositivos


de
conmutaci√≥n
al
receptor
:


‚Ä¢
Bit
EFCI
.
Cada
celda
de
datos
contiene
un
bit
EFCI
(
Explicit
Forward
Congestion


Indication
,
Indicaci√≥n
de
congesti√≥n
expl√≠cita
directa
)
.
Un
dispositivo
de
conmutaci√≥n


de
la
red
congestionado
puede
poner
el
bit
EFCI
de
una
celda
de
datos
a
1
para
indicar


que
existe
congesti√≥n
al
host
de
destino
,
el
cual
debe
comprobar
el
bit
EFCI
de
todas
las


celdas
de
datos
recibidas
.
Cuando
llega
una
celda
RM
al
destino
,
si
la
celda
de
datos
reci-


bida
m√°s
recientemente
ten√≠a
el
bit
EFCI
a
1
,
entonces
el
destino
pone
el
bit
de
indica-


ci√≥n
de
congesti√≥n
(
el
bit
CI
)
de
la
celda
RM
a
1
y
devuelve
la
celda
RM
al
emisor
.


Utilizando
el
bit
EFCI
de
las
celdas
de
datos
y
el
bit
CI
de
la
celda
RM
,
es
posible
notifi-


car
a
un
emisor
que
existe
congesti√≥n
en
un
dispositivo
de
conmutaci√≥n
de
la
red
.


‚Ä¢
Bits
CI
y
NI
.
Como
hemos
mencionado
anteriormente
,
las
celdas
RM
que
se
transmi-


ten
del
emisor
al
receptor
est√°n
intercaladas
con
celdas
de
datos
.
La
tasa
de
intercalado


de
las
celdas
RM
es
un
par√°metro
ajustable
,
siendo
el
valor
predeterminado
una
celda


RM
cada
32
celdas
de
datos
.
Estas
celdas
RM
disponen
de
un
bit
indicativo
de
la
con-


264
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Origen
Destino


Dispositivo
de


conmutaci√≥n


Dispositivo
de


conmutaci√≥n


Clave
:


Celdas
RM
Celdas
de
datos


Figura
3.50
‚Ä¢
Mecanismo
de
control
de
congesti√≥n
del
servicio
ABR
de
ATM
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
264gesti√≥n
(
CI
,
Congestion
Indication
)
y
de
un
bit
de
no
incremento
(
NI
,
No
Increase
)


que
un
dispositivo
de
conmutaci√≥n
de
la
red
congestionado
puede
configurar
.
Espec√≠fi-


camente
,
un
dispositivo
de
conmutaci√≥n
puede
poner
el
bit
NI
de
una
celda
RM
que
le


atraviese
a
1
en
condiciones
de
congesti√≥n
leve
y
poner
a
1
el
bit
CI
bajo
condiciones


de
congesti√≥n
severa
.
Cuando
un
host
de
destino
recibe
una
celda
RM
,
devuelve
dicha


celda
RM
al
emisor
con
sus
bits
CI
y
NI
intactos
(
excepto
cuando
el
host
de
destino


pone
el
bit
CI
a
1
como
resultado
del
mecanismo
EFCI
descrito
anteriormente
)
.


‚Ä¢
Configuraci√≥n
de
ER
.
Cada
celda
RM
tambi√©n
contiene
un
campo
ER
(
Explicit
Rate
,


velocidad
expl√≠cita
)
de
2
bytes
.
Un
dispositivo
de
conmutaci√≥n
congestionado
puede


reducir
el
valor
contenido
en
el
campo
ER
de
una
celda
RM
que
le
atraviese
.
De
esta


forma
,
el
campo
ER
establecer√°
la
velocidad
m√≠nima
soportable
de
todos
los
dispositivos


de
conmutaci√≥n
existentes
en
la
ruta
del
origen
al
destino
.


Un
emisor
ABR
de
una
red
ATM
ajusta
la
velocidad
a
la
que
puede
enviar
las
celdas
en


funci√≥n
de
los
valores
de
CI
,
NI
y
ER
contenidos
en
las
celdas
RM
devueltas
.
Las
reglas


para
llevar
a
cabo
este
ajuste
de
velocidad
son
bastante
complejas
y
algo
tediosas
.
El
lector


interesado
en
este
tema
puede
consultar
[
Jain
1996
]
para
conocer
los
detalles
.


3.7
Mecanismo
de
control
de
congesti√≥n
de
TCP


En
esta
secci√≥n
vamos
a
continuar
con
nuestro
estudio
de
TCP
.
Como
hemos
visto
en
la
Sec-


ci√≥n
3.5
,
TCP
proporciona
un
servicio
de
transporte
fiable
entre
dos
procesos
que
se
ejecu-


tan
en
hosts
diferentes
.
Otro
componente
clave
de
TCP
es
su
mecanismo
de
control
de


congesti√≥n
.
Como
hemos
mencionado
en
la
secci√≥n
anterior
,
TCP
tiene
que
utilizar
un
con-


trol
de
congesti√≥n
terminal
a
terminal
en
lugar
de
un
control
de
congesti√≥n
asistido
por
la


red
,
ya
que
la
capa
IP
no
proporciona
una
realimentaci√≥n
expl√≠cita
a
los
sistemas
terminales


en
lo
tocante
a
la
congesti√≥n
de
la
red
.


El
m√©todo
empleado
por
TCP
consiste
en
que
cada
emisor
limite
la
velocidad
a
la
que


transmite
el
tr√°fico
a
trav√©s
de
su
conexi√≥n
en
funci√≥n
de
la
congesti√≥n
de
red
percibida
.
Si


un
emisor
TCP
percibe
que
en
la
ruta
entre
√©l
mismo
y
el
destino
apenas
existe
congesti√≥n
,


entonces
incrementar√°
su
velocidad
de
transmisi√≥n
;
por
el
contario
,
si
el
emisor
percibe
que


existe
congesti√≥n
a
lo
largo
de
la
ruta
,
entonces
reducir√°
su
velocidad
de
transmisi√≥n
.
Pero


este
m√©todo
plantea
tres
cuestiones
.
En
primer
lugar
,
¬ø
c√≥mo
limita
el
emisor
TCP
la
veloci-


dad
a
la
que
env√≠a
el
tr√°fico
a
trav√©s
de
su
conexi√≥n
?
En
segundo
lugar
,
¬ø
c√≥mo
percibe
el


emisor
TCP
que
existe
congesti√≥n
en
la
ruta
entre
√©l
mismo
y
el
destino
?
Y
,
tercero
,
¬ø
qu√©


algoritmo
deber√°
emplear
el
emisor
para
variar
su
velocidad
de
transmisi√≥n
en
funci√≥n
de
la


congesti√≥n
percibida
terminal
a
terminal
?


Examinemos
en
primer
lugar
c√≥mo
un
emisor
TCP
limita
la
velocidad
a
la
que
env√≠a
el


tr√°fico
a
trav√©s
de
su
conexi√≥n
.
En
la
Secci√≥n
3.5
,
hemos
visto
que
cada
lado
de
una
cone-


xi√≥n
TCP
consta
de
un
buffer
de
recepci√≥n
,
un
buffer
de
transmisi√≥n
y
varias
variables


(
UltimoByteLeido
,
VentanaRecepcion
,
etc.
)
.
El
mecanismo
de
control
de
congesti√≥n


de
TCP
que
opera
en
el
emisor
hace
un
seguimiento
de
una
variable
adicional
,
la
ventana


de
congesti√≥n
.
Esta
ventana
,
indicada
como
VentanaCongestion
,
impone
una
restricci√≥n


sobre
la
velocidad
a
la
que
el
emisor
 
TCP
puede
enviar
tr√°fico
a
la
red
.
Espec√≠ficamente
,
la


cantidad
de
datos
no
reconocidos
en
un
emisor
no
puede
exceder
el
m√≠nimo
de
entre
Ven-


tanaCongestiony
VentanaRecepcion
,
es
decir
:


3.7
‚Ä¢
MECANISMO
DE
CONTROL
DE
CONGESTI√ìN
DE
TCP
265


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
265UltimoByteLeido
‚Äì
UltimoByteReconocido
/H11349


m√≠n{VentanaCongesti√≥n
,
VentanaRecepcion
}


Con
el
fin
de
centrarnos
en
el
mecanismo
de
control
de
congesti√≥n
(
en
oposici√≥n
al
control


de
flujo
)
,
vamos
a
suponer
que
el
buffer
de
recepci√≥n
TCP
es
tan
grande
que
la
restricci√≥n


de
la
ventana
de
recepci√≥n
puede
ignorarse
;
por
tanto
,
la
cantidad
de
datos
no
reconocidos


por
el
emisor
queda
limitada
√∫nicamente
por
VentanaCongestion
.
Supondremos
tambi√©n


que
el
emisor
siempre
tiene
datos
que
enviar
;
es
decir
,
todos
los
segmentos
de
la
ventana
de


congesti√≥n
son
enviados
.


La
restricci√≥n
anterior
limita
la
cantidad
de
datos
no
reconocidos
por
el
emisor
y
,
por


tanto
,
limita
de
manera
indirecta
la
velocidad
de
transmisi√≥n
del
emisor
.
Para
comprender


esto
imagine
una
conexi√≥n
en
la
que
tanto
la
p√©rdida
de
paquetes
como
los
retardos
de
trans-


misi√≥n
sean
despreciables
.
En
esta
situaci√≥n
,
lo
que
ocurre
a
grandes
rasgos
es
lo
siguiente
:


al
inicio
de
cada
periodo
RTT
,
la
restricci√≥n
permite
al
emisor
enviar
ventanacongestion


bytes
de
datos
a
trav√©s
de
la
conexi√≥n
;
al
final
del
periodo
RTT
,
el
emisor
recibe
los
paque-


tes
ACK
correspondientes
a
los
datos
.
Por
tanto
,
la
velocidad
de
transmisi√≥n
del
emisor
es


aproximadamente
igual
a
VentanaCongestion
/
RTT
bytes
/
segundo
.
Ajustando
el
valor
de
la


ventana
de
congesti√≥n
,
el
emisor
puede
ajustar
la
velocidad
a
la
que
transmite
los
datos
a


trav√©s
de
su
conexi√≥n
.


Veamos
ahora
c√≥mo
percibe
un
emisor
TCP
que
existe
congesti√≥n
en
la
ruta
entre
√©l


mismo
y
el
destino
.
Definamos
un
‚Äú
suceso
de
p√©rdida
‚Äù
en
un
emisor
TCP
como
el
hecho
de


que
se
produzca
un
fin
de
temporizaci√≥n
o
se
reciban
tres
paquetes
ACK
duplicados
proce-


dentes
del
receptor
(
recuerde
la
exposici√≥n
de
la
Secci√≥n
3.5.4
sobre
el
suceso
de
fin
de


temporizaci√≥n
mostrado
en
la
Figura
3.33
y
la
subsiguiente
modificaci√≥n
para
incluir
la


retransmisi√≥n
r√°pida
a
causa
de
la
recepci√≥n
de
tres
paquetes
ACK
duplicados
)
.
Cuando


existe
una
congesti√≥n
severa
,
entonces
uno
o
m√°s
de
los
buffers
de
los
routers
existentes
a
lo


largo
de
la
ruta
pueden
desbordarse
,
dando
lugar
a
que
un
datagrama
(
que
contenga
un
seg-


mento
TCP
)
sea
descartado
.
A
su
vez
,
el
datagrama
descartado
da
lugar
a
un
suceso
de
p√©r-


dida
en
el
emisor
(
debido
a
un
fin
de
temporizaci√≥n
o
a
la
recepci√≥n
de
tres
paquetes
ACK


duplicados
)
,
el
cual
lo
interpreta
como
una
indicaci√≥n
de
que
existe
congesti√≥n
en
la
ruta


entre
el
emisor
y
el
receptor
.


Ahora
que
ya
hemos
visto
c√≥mo
se
detecta
la
existencia
de
congesti√≥n
en
la
red
,
vamos


a
considerar
el
mejor
de
los
casos
,
cuando
no
existe
congesti√≥n
en
la
red
,
es
decir
,
cuando


no
se
producen
p√©rdidas
de
paquetes
.
En
este
caso
,
el
emisor
TCP
recibir√°
los
paquetes
de


reconocimiento
ACK
correspondientes
a
los
segmentos
anteriormente
no
reconocidos
.


Como
veremos
,
TCP
interpretar√°
la
llegada
de
estos
paquetes
ACK
como
una
indicaci√≥n
de


que
todo
est√°
bien
(
es
decir
,
que
los
segmentos
que
est√°n
siendo
transmitidos
a
trav√©s
de
la


red
est√°n
siendo
entregados
correctamente
al
destino
)
y
emplear√°
esos
paquetes
de
reconoci-


miento
para
incrementar
el
tama√±o
de
la
ventana
de
congesti√≥n
(
y
,
por
tanto
,
la
velocidad
de


transmisi√≥n
)
.
Observe
que
si
la
velocidad
de
llegada
de
los
paquetes
ACK
es
lenta
,
porque


por
ejemplo
la
ruta
terminal
a
terminal
presenta
un
retardo
grande
o
contiene
un
enlace
con


un
ancho
de
banda
peque√±o
,
entonces
el
tama√±o
de
la
ventana
de
congesti√≥n
se
incremen-


tar√°
a
una
velocidad
relativamente
lenta
.
Por
el
contrario
,
si
la
velocidad
de
llegada
de
los


paquetes
de
reconocimiento
es
alta
,
entonces
el
tama√±o
de
la
ventana
de
congesti√≥n
se
incre-


mentar√°
m√°s
r√°pidamente
.
Puesto
que
TCP
utiliza
los
paquetes
de
reconocimiento
para
pro-


vocar
(
o
temporizar
)
sus
incrementos
del
tama√±o
de
la
ventana
de
congesti√≥n
,
se
dice
que


TCP
es
auto-temporizado
.


266
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
266Conocido
el
mecanismo
de
ajuste
del
valor
de
VentanaCongestion
para
controlar
la


velocidad
de
transmisi√≥n
,
la
cuesti√≥n
cr√≠tica
que
nos
queda
es
:
¬ø
c√≥mo
deber√≠a
un
emisor
TCP


determinar
su
velocidad
de
transmisi√≥n
?
Si
los
emisores
TCP
de
forma
colectiva
transmiten


a
velocidades
demasiado
altas
pueden
congestionar
la
red
,
llev√°ndola
al
tipo
de
colapso
de


congesti√≥n
que
hemos
visto
en
la
Figura
3.48
.
De
hecho
,
la
versi√≥n
de
TCP
que
vamos
a


estudiar
a
continuaci√≥n
fue
desarrollada
en
respuesta
al
colapso
de
congesti√≥n
observado
en


Internet
[
Jacobson
1988
]
en
las
versiones
anteriores
de
TCP
.
Sin
embargo
,
si
los
emisores


TCP
son
demasiado
cautelosos
y
transmiten
la
informaci√≥n
muy
lentamente
,
podr√≠an
infrau-


tilizar
el
ancho
de
banda
de
la
red
;
es
decir
,
los
emisores
TCP
podr√≠an
transmitir
a
velocida-


des
m√°s
altas
sin
llegar
a
congestionar
la
red
.
Entonces
,
¬ø
c√≥mo
pueden
determinar
los


emisores
TCP
sus
velocidades
de
transmisi√≥n
de
manera
que
no
congestionen
la
red
a
la
vez


que
hacen
uso
del
todo
el
ancho
de
banda
disponible
?
¬ø
Est√°n
los
emisores
TCP
expl√≠cita-


mente
coordinados
,
o
existe
un
m√©todo
distribuido
en
el
que
dichos
emisores
TCP
puedan


establecer
sus
velocidades
de
transmisi√≥n
bas√°ndose
√∫nicamente
en
la
informaci√≥n
local
?


TCP
responde
a
estas
preguntas
bas√°ndose
en
los
siguientes
principios
:


‚Ä¢
Un
segmento
perdido
implica
congesti√≥n
y
,
por
tanto
,
la
velocidad
del
emisor
TCP
debe


reducirse
cuando
se
pierde
un
segmento
.
Recuerde
que
en
la
Secci√≥n
3.5.4
hemos
visto


que
un
suceso
de
fin
de
temporizaci√≥n
o
la
recepci√≥n
de
cuatro
paquetes
de
reconoci-


miento
para
un
segmento
dado
(
el
paquete
ACK
original
y
los
tres
duplicados
)
se
inter-


preta
como
una
indicaci√≥n
impl√≠cita
de
que
se
ha
producido
un
‚Äú
suceso
de
p√©rdida
‚Äù
del


segmento
que
sigue
al
segmento
que
ha
sido
reconocido
cuatro
veces
,
activando
el
pro-


ceso
de
retransmisi√≥n
del
segmento
perdido
.
Desde
el
punto
de
vista
del
mecanismo
de


control
de
congesti√≥n
,
la
cuesti√≥n
es
c√≥mo
el
emisor
TCP
debe
disminuir
el
tama√±o
de
su


ventana
de
congesti√≥n
y
,
por
tanto
,
su
velocidad
de
transmisi√≥n
,
en
respuesta
a
este


suceso
de
p√©rdida
inferido
.


‚Ä¢
Un
segmento
que
ha
sido
reconocido
indica
que
la
red
est√°
entregando
los
segmentos
del


emisor
al
receptor
y
,
por
tanto
,
la
velocidad
de
transmisi√≥n
del
emisor
puede
incremen-


tarse
cuando
llega
un
paquete
ACK
correspondiente
a
un
segmento
que
todav√≠a
no
hab√≠a


sido
reconocido
.
La
llegada
de
paquetes
de
reconocimiento
se
interpreta
como
una
indi-


caci√≥n
impl√≠cita
de
que
todo
funciona
bien
(
los
segmentos
est√°n
siendo
entregados


correctamente
del
emisor
al
receptor
y
la
red
por
tanto
no
est√°
congestionada
)
.
Luego
se


puede
aumentar
el
tama√±o
de
la
ventana
de
congesti√≥n
.


‚Ä¢
Tanteo
del
ancho
de
banda
.
Puesto
que
los
paquetes
ACK
indican
que
la
ruta
entre
el
ori-


gen
y
el
destino
est√°
libre
de
congesti√≥n
y
la
p√©rdida
de
paquetes
indica
que
hay
una
ruta


congestionada
,
la
estrategia
de
TCP
para
ajustar
su
velocidad
de
transmisi√≥n
consiste
en


incrementar
su
velocidad
en
respuesta
a
la
llegada
de
paquetes
ACK
hasta
que
se
pro-


duce
una
p√©rdida
,
momento
en
el
que
reduce
la
velocidad
de
transmisi√≥n
.
El
emisor
TCP


incrementa
entonces
su
velocidad
de
transmisi√≥n
para
tantear
la
velocidad
a
la
que
de


nuevo
aparece
congesti√≥n
,
retrocede
a
partir
de
ese
punto
y
comienza
de
nuevo
a
tantear


para
ver
si
ha
variado
la
velocidad
a
la
que
comienza
de
nuevo
a
producirse
congesti√≥n
.


El
comportamiento
del
emisor
TCP
es
quiz√°
similar
a
la
del
ni√±o
que
pide
(
y
consigue
)


una
y
otra
vez
golosinas
hasta
que
se
le
dice
‚Äú
¬°
No
!
‚Äù
,
momento
en
el
que
da
marcha
atr√°s
,


pero
enseguida
comienza
otra
vez
a
pedir
m√°s
golosinas
.
Observe
que
la
red
no
propor-


ciona
una
indicaci√≥n
expl√≠cita
del
estado
de
congesti√≥n
(
los
paquetes
ACK
y
las
p√©rdidas


se
utilizan
como
indicadores
impl√≠citos
)
y
que
cada
emisor
TCP
reacciona
a
la
informa-


ci√≥n
local
de
forma
as√≠ncrona
con
respecto
a
otros
emisores
TCP
.


3.7
‚Ä¢
MECANISMO
DE
CONTROL
DE
CONGESTI√ìN
DE
TCP
267


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
267Ahora
que
ya
conocemos
los
fundamentos
del
mecanismo
de
control
de
congesti√≥n
de
TCP
,


estamos
en
condiciones
de
pasar
a
estudiar
los
detalles
del
famoso
algoritmo
de
control
de


congesti√≥n
de
TCP
,
que
fue
descrito
por
primera
vez
en
el
libro
de
[
Jacobson
1988
]
y
que


est√°
estandarizado
en
el
documento
[
RFC
2581
]
.
El
algoritmo
consta
de
tres
componentes


principales
:
(
1
)
arranque
lento
(
slow
start
)
,
(
2
)
evitaci√≥n
de
la
congesti√≥n
(
congestion
avoi-


dance
)
y
(
3
)
recuperaci√≥n
r√°pida
(
fast
recovery
)
.
Los
dos
primeros
componentes
son
obliga-


torios
en
TCP
,
diferenci√°ndose
en
la
forma
en
que
aumentan
el
tama√±o
de
la
ventana
de


congesti√≥n
en
respuesta
a
los
paquetes
ACK
recibidos
.
Vamos
a
ver
brevemente
que
el


arranque
lento
incrementa
el
tama√±o
de
la
ventana
de
congesti√≥n
m√°s
r√°pidamente
(
¬°
contra-


riamente
a
lo
que
indica
su
nombre
!
)
que
la
evitaci√≥n
de
la
congesti√≥n
.
El
componente
recu-


peraci√≥n
r√°pida
es
recomendable
,
aunque
no
obligatorio
,
para
los
emisores
TCP
.


Arranque
lento


Cuando
se
inicia
una
conexi√≥n
TCP
,
el
valor
de
la
ventana
de
congesti√≥n
(
VentanaCon-


gestion
)
normalmente
se
inicializa
con
un
valor
peque√±o
igual
a
1
MSS
(
tama√±o
m√°ximo


de
segmento
)
[
RFC
3390
]
,
que
da
como
resultado
una
velocidad
de
transmisi√≥n
inicial
apro-


ximadamente
igual
a
MSS
/
RTT
.
Por
ejemplo
,
si
MSS
=
500
bytes
y
RTT
=
200
milisegun-


dos
,
la
velocidad
de
transmisi√≥n
inicial
ser√°
aproximadamente
de
20
kbps
.
Puesto
que
el


ancho
de
banda
disponible
para
el
emisor
TCP
puede
ser
mucho
m√°s
grande
que
el
valor
de


MSS/
RTT
,
al
emisor
TCP
le
gustar√≠a
poder
determinar
r√°pidamente
la
cantidad
de
ancho


de
banda
disponible
.
Por
tanto
,
en
el
estado
de
arranque
lento
,
el
valor
de
VentanaCon-


268
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Host
A
Host
B


un
segmento


dos
segmentos


cuatro
segmentos


RTT


Tiempo
Tiempo


Figura
3.51
‚Ä¢
Fase
de
arranque
lento
de
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
268gestion
se
establece
en
1
MSS
y
se
incrementa
1
MSS
cada
vez
que
se
produce
el
primer


reconocimiento
de
un
segmento
transmitido
.
En
el
ejemplo
de
la
Figura
3.51
,
TCP
env√≠a
el


primer
segmento
a
la
red
y
espera
el
correspondiente
paquete
ACK
.
Cuando
llega
dicho


paquete
de
reconocimiento
,
el
emisor
TCP
incrementa
el
tama√±o
de
la
ventana
de
conges-


ti√≥n
en
1
MSS
y
transmite
dos
segmentos
de
tama√±o
m√°ximo
.
Estos
segmentos
son
entonces


reconocidos
y
el
emisor
incrementa
el
tama√±o
de
la
ventana
de
congesti√≥n
en
1
MSS
por


cada
uno
de
los
segmentos
de
reconocimiento
,
generando
as√≠
una
ventana
de
congesti√≥n
de


4
MSS
,
etc.
Este
proceso
hace
que
la
velocidad
de
transmisi√≥n
se
duplique
en
cada
periodo


RTT
.
Por
tanto
,
la
velocidad
de
transmisi√≥n
inicial
de
TCP
es
baja
,
pero
crece
exponencial-


mente
durante
esa
fase
de
arranque
lento
.


Pero
,
¬ø
cu√°ndo
debe
finalizar
este
crecimiento
exponencial
?
El
algoritmo
del
arranque


lento
proporciona
varias
respuestas
a
esta
cuesti√≥n
.
En
primer
lugar
,
si
se
produce
un
suceso


de
p√©rdida
de
paquete
(
es
decir
,
si
hay
congesti√≥n
)
se√±alado
por
un
fin
de
temporizaci√≥n
,
el


emisor
TCP
establece
el
valor
de
VentanaCongestion
en
1
e
inicia
de
nuevo
un
proceso


de
arranque
lento
.
Tambi√©n
define
el
valor
de
una
segunda
variable
de
estado
que
establece


el
umbral
del
arranque
lento
y
que
denominaremos
umbralen
VentanaCongestion/2
,
la


mitad
del
valor
del
tama√±o
de
la
ventana
de
congesti√≥n
cuando
se
ha
detectado
que
existe


congesti√≥n
.
La
segunda
forma
en
la
que
la
fase
de
arranque
lento
puede
terminar
est√°
direc-


tamente
ligada
al
valor
de
umbral
.
Dado
que
umbrales
igual
a
la
mitad
del
valor
que
Ven-


tanaCongestion
ten√≠a
cuando
se
detect√≥
congesti√≥n
por
√∫ltima
vez
,
puede
resultar
algo


imprudente
continuar
duplicando
el
valor
de
VentanaCongestion
cuando
se
alcanza
o


sobrepasa
el
valor
de
umbral
.
Por
tanto
,
cuando
el
valor
de
VentanaCongestion
es
igual


a
umbral
,
la
fase
de
arranque
lento
termina
y
las
transacciones
TCP
pasan
al
modo
de
evita-


ci√≥n
de
la
congesti√≥n
.
Como
veremos
,
TCP
incrementa
con
m√°s
cautela
el
valor
de
Venta-


naCongestion
cuando
est√°
en
el
modo
de
evitaci√≥n
de
la
congesti√≥n
.
La
√∫ltima
forma
en


la
que
puede
terminar
la
fase
de
arranque
lento
es
si
se
detectan
tres
paquetes
ACK
duplica-


dos
,
en
cuyo
caso
TCP
realiza
una
retransmisi√≥n
r√°pida
(
v√©ase
la
Secci√≥n
3.5.4
)
y
entra
en


el
estado
de
recuperaci√≥n
r√°pida
,
que
veremos
m√°s
adelante
.
El
comportamiento
de
TCP
en


la
fase
de
arranque
lento
se
resume
en
la
descripci√≥n
de
la
FSM
del
control
de
congesti√≥n
de


TCP
de
la
Figura
3.52
.
El
algoritmo
de
arranque
lento
tiene
sus
ra√≠ces
en
[
Jacobson
1988
]
;


en
[
Jain
1986
]
se
propon√≠a
,
de
forma
independiente
,
un
m√©todo
similar
al
algoritmo
de


arranque
lento
.


Evitaci√≥n
de
la
congesti√≥n


Al
entrar
en
el
estado
de
evitaci√≥n
de
la
congesti√≥n
,
el
valor
de
VentanaCongestion
es


aproximadamente
igual
a
la
mitad
de
su
valor
en
el
momento
en
que
se
detect√≥
congesti√≥n


por
√∫ltima
vez
(
podemos
estar
,
por
tanto
,
al
borde
de
la
congesti√≥n
)
.
En
consecuencia
,
en


lugar
de
duplicar
el
valor
de
VentanaCongestion
para
cada
RTT
,
TCP
adopta
un
m√©todo


m√°s
conservador
e
incrementa
el
valor
de
VentanaCongestionsolamente
en
un
MSS
cada


RTT
[
RFC
2581
]
.
Esto
puede
llevarse
a
cabo
de
varias
maneras
.
Un
m√©todo
habitual
con-


siste
en
que
un
emisor
TCP
aumenta
el
valor
de
VentanaCongestion
en
MSS
bytes


(
MSS
/
VentanaCongestion
)
cuando
llega
un
nuevo
paquete
de
reconocimiento
.
Por
ejem-


plo
,
si
MSS
es
igual
a
1.460
bytes
y
VentanaCongestion
es
igual
a
14.600
bytes
,
enton-


ces
se
enviar√°n
10
segmentos
en
un
RTT
.
Cada
ACK
que
llega
(
suponiendo
un
ACK
por


segmento
)
incrementa
el
tama√±o
de
la
ventana
de
congesti√≥n
en
1/10
MSS
y
,
por
tanto
,
el


valor
del
tama√±o
de
la
ventana
de
congesti√≥n
habr√°
aumentado
en
un
MSS
despu√©s
de
los


ACK
correspondientes
a
los
10
segmentos
que
hayan
sido
recibidos
.
 

3.7
‚Ä¢
MECANISMO
DE
CONTROL
DE
CONGESTI√ìN
DE
TCP
269


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
269Pero
,
¬ø
en
qu√©
momento
deber√≠a
detenerse
el
crecimiento
lineal
(
1
MSS
por
RTT
)
en
el


modo
de
evitaci√≥n
de
la
congesti√≥n
?
El
algoritmo
de
evitaci√≥n
de
la
congesti√≥n
de
TCP
se


comporta
del
mismo
modo
que
cuando
tiene
lugar
un
fin
de
temporizaci√≥n
.
Como
en
el
caso


del
modo
de
arranque
lento
,
el
valor
de
VentanaCongestion
se
fija
en
1
MSS
y
el
valor


de
umbral
se
actualiza
haci√©ndose
igual
a
la
mitad
del
valor
de
VentanaCongestion


cuando
se
produce
un
suceso
de
p√©rdida
de
paquete
.
Sin
embargo
,
recuerde
que
tambi√©n


puede
detectarse
una
p√©rdida
de
paquete
a
causa
de
la
llegada
de
tres
ACK
duplicados
.
En


este
caso
,
la
red
contin√∫a
entregando
segmentos
del
emisor
al
receptor
(
como
se√±ala
la


recepci√≥n
de
paquetes
ACK
duplicados
)
.
Por
tanto
,
el
comportamiento
de
TCP
ante
este
tipo


de
p√©rdida
deber√≠a
ser
menos
dr√°stico
que
ante
una
p√©rdida
de
paquete
indicada
por
un
fin


de
temporizaci√≥n
:
TCP
divide
entre
dos
el
valor
de
VentanaCongestion
(
a√±adiendo
3


MSS
como
forma
de
tener
en
cuenta
los
tres
ACK
duplicados
que
se
han
recibido
)
y
confi-


gura
el
valor
de
umbral
para
que
sea
igual
a
la
mitad
del
valor
que
VentanaCongestion


ten√≠a
cuando
se
recibieron
los
tres
ACK
duplicados
.
A
continuaci√≥n
,
se
entra
en
el
estado
de


recuperaci√≥n
r√°pida
.


270
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Arranque


lento


ACK
duplicado


contadorACKdupl++


ACK
duplicado


contadorACKdupl++


fin_de
_


temporizaci√≥n


umbral
=
VC/2


VC=1
MSS


contadorACKdupl=0


VC=1
MSS


umbral=64
KB


contadorACKdupl=0


fin_de_temporizaci√≥n


umbral
=
VC/2


VC=1


contadorACKdupl=0


fin
de
temporizaci√≥n


umbral
=
VC/2


VC=1
MSS


contadorACKdupl=0


VC‚â•
umbral


Evitaci√≥n
de


la
congesti√≥n


Recuperaci√≥n


r√°pida


ACK
nuevo


VC
=
VC+MSS
‚Ä¢(MSS
/
VC
)


contadorACKdupl=0


transmitir
segmento(s
)
nuevos(s
)


cuando
sea
posible


ACK
nuevo


VC
=
VC+MSS


contadorACKdupl=0


transmitir
segmento(s
)
nuevos(s
)
cuando
sea
posible


retransmitir
segmento
que
falta


retransmitir
segmento
que
falta
contadorACKdupl==3


umbral
=
VC/2


VC
=
umbral+3


retransmitir
segmento
que
falta


ACK
duplicado


VC
=
VC+MSS


transmitir
segmento(s
)
nuevos(s
)
cuando
sea
posible


contadorACKdupl==3


umbral
=
VC/2


VC
=
umbral+3


retransmitir
segmento
que
falta


retransmitir
segmento
que
falta


ACK
nuevo


VC
=
umbral


contadorACKdupl=0


Œõ


Clave
:


VC
=
VentanaCongestion


Figura
3.52
‚Ä¢
Descripci√≥n
de
la
m√°quina
de
estados
finitos
del
mecanismo
de


control
de
congesti√≥n
de
TCP
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
270Recuperaci√≥n
r√°pida


En
la
fase
de
recuperaci√≥n
r√°pida
,
el
valor
de
VentanaCongestion
se
incrementa
en
1


MSS
por
cada
ACK
duplicado
recibido
correspondiente
al
segmento
que
falta
y
que
ha
cau-


sado
que
TCP
entre
en
el
estado
de
recuperaci√≥n
r√°pida
.
Cuando
llega
un
ACK
para
el
seg-


mento
que
falta
,
TCP
entra
de
nuevo
en
el
estado
de
evitaci√≥n
de
la
congesti√≥n
despu√©s
de


disminuir
el
valor
de
VentanaCongestion
.
Si
se
produce
un
fin
de
temporizaci√≥n
,
el


mecanismo
de
recuperaci√≥n
r√°pida
efect√∫a
una
transici√≥n
al
estado
de
arranque
lento
des-


pu√©s
de
realizar
las
mismas
acciones
que
en
los
modos
de
arranque
lento
y
de
evitaci√≥n
de


la
congesti√≥n
:
el
valor
de
VentanaCongestion
se
establece
en
1
MSS
y
el
valor
de


umbral
se
hace
igual
a
la
mitad
del
valor
que
ten√≠a
VentanaCongestion
cuando
tuvo


lugar
el
suceso
de
p√©rdida
.


El
mecanismo
de
recuperaci√≥n
r√°pida
es
un
componente
de
TCP
recomendado
,
aunque


no
obligatorio
[
RFC
2581
]
.
Es
interesante
resaltar
que
una
versi√≥n
anterior
de
TCP
,
cono-


cida
como
TCP
Tahoe
,
establece
incondicionalmente
el
tama√±o
de
la
ventana
de
congesti√≥n


en
1
MSS
y
entra
en
el
estado
de
arranque
lento
despu√©s
de
un
suceso
de
p√©rdida
indicado


por
un
fin
de
temporizaci√≥n
o
por
la
recepci√≥n
de
tres
ACK
duplicados
.
La
versi√≥n
m√°s


reciente
de
TCP
,
TCP
Reno
,
incorpora
la
recuperaci√≥n
r√°pida
.
 

La
Figura
3.53
ilustra
la
evoluci√≥n
de
la
ventana
de
congesti√≥n
de
TCP
para
Reno
y


Tahoe
.
En
esta
figura
,
inicialmente
el
umbral
es
igual
a
8
MSS
.
Durante
los
ocho
primeros


ciclos
de
transmisi√≥n
,
Tahoe
y
Reno
realizan
acciones
id√©nticas
.
La
ventana
de
congesti√≥n


crece
r√°pidamente
de
forma
exponencial
durante
la
fase
de
arranque
lento
y
alcanza
el


umbral
en
el
cuarto
ciclo
de
transmisi√≥n
.
A
continuaci√≥n
,
la
ventana
de
congesti√≥n
crece


linealmente
hasta
que
se
produce
un
suceso
de
tres
ACK
duplicados
,
justo
despu√©s
del


octavo
ciclo
de
transmisi√≥n
.
Observe
que
el
tama√±o
de
la
ventana
de
congesti√≥n
es
igual
a


12
‚Ä¢
MSS
cuando
se
produce
el
suceso
de
p√©rdida
.
El
valor
de
umbral
se
hace
entonces


igual
a
0,5
‚Ä¢
VentanaCongestion
=
6
‚Ä¢
MSS
.
En
TCP
Reno
,
el
tama√±o
de
la
ventana
de


congesti√≥n
es
puesto
a
VentanaCongestion=
6
‚Ä¢
MSS
y
luego
crece
linealmente
.
En
TCP


Tahoe
,
la
ventana
de
congesti√≥n
es
igual
a
1
MSS
y
crece
exponencialmente
hasta
que


alcanza
el
valor
de
umbral
,
punto
a
partir
del
cual
crece
linealmente
.
 

La
Figura
3.52
presenta
la
descripci√≥n
completa
de
la
m√°quina
de
estados
finitos
de
los


algoritmos
del
mecanismo
de
control
de
congesti√≥n
de
TCP
:
arranque
lento
,
evitaci√≥n
de
la


congesti√≥n
y
recuperaci√≥n
r√°pida
.
En
la
figura
tambi√©n
se
indica
d√≥nde
pueden
producirse


3.7
‚Ä¢
MECANISMO
DE
CONTROL
DE
CONGESTI√ìN
DE
TCP
271


0


102
3
4
5
6
7
8


TCP
Tahoe


umbral


umbral


Ventana
de
congesti√≥n


(
en
segmentos
)


91
0
1
1
1
2
1
3
1
4
1
5


2


4


6


8


10


12


14


TCP
Reno


Figura
3.53
‚Ä¢
Evoluci√≥n
de
la
ventana
de
congesti√≥n
de
TCP
(
Tahoe
y
Reno
)
.


Ciclo
de
transmisi√≥n


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
271transmisiones
de
nuevos
segmentos
y
d√≥nde
retransmisiones
de
segmentos
.
Aunque
es


importante
diferenciar
entre
las
retransmisiones
/
control
de
errores
de
TCP
y
el
control
de


congesti√≥n
de
TCP
,
tambi√©n
lo
es
apreciar
c√≥mo
estos
dos
aspectos
de
TCP
est√°n
estrecha-


mente
vinculados
.


Control
de
congesti√≥n
de
TCP
:
retrospectiva


Una
vez
vistos
los
detalles
de
las
fases
de
arranque
lento
,
de
evitaci√≥n
de
la
congesti√≥n
y
de


recuperaci√≥n
r√°pida
,
merece
la
pena
retroceder
un
poco
para
clarificar
las
cosas
.
Ignorando


la
fase
inicial
de
arranque
lento
en
la
que
se
establece
la
conexi√≥n
y
suponiendo
que
las
p√©r-


didas
est√°n
indicadas
por
la
recepci√≥n
de
tres
ACK
duplicados
en
lugar
de
por
fines
de
tem-


porizaci√≥n
,
el
control
de
congesti√≥n
de
TCP
consiste
en
un
crecimiento
lineal
(
aditivo
)
de


VentanaCongestiona
raz√≥n
de
1
MSS
por
RTT
,
seguido
de
un
decrecimiento
multiplica-


tivo
(
divisi√≥n
entre
dos
)
del
tama√±o
de
la
ventana
,
VentanaCongestion
,
cuando
se
reci-


ben
tres
ACK
duplicados
.
Por
esta
raz√≥n
,
suele
decirse
que
el
control
de
congesti√≥n
de
TCP


es
una
forma
de
crecimiento
aditivo
y
decrecimiento
multiplicativo
(
AIMD
,
Additive-


Increase
,
Multiplicative-Decrease
)
de
control
de
congesti√≥n
.
El
control
de
congesti√≥n


AIMD
presenta
un
comportamiento
en
forma
de
‚Äú
diente
de
sierra
‚Äù
,
como
se
muestra
en
la


Figura
3.54
,
lo
que
tambi√©n
ilustra
nuestra
anterior
intuici√≥n
de
que
TCP
‚Äú
va
tanteando
‚Äù
el


ancho
de
banda
.
(
TCP
aumenta
linealmente
el
tama√±o
de
su
ventana
de
congesti√≥n
,
y
por


tanto
su
velocidad
de
transmisi√≥n
,
hasta
que
tiene
lugar
la
recepci√≥n
de
tres
ACK
duplica-


dos
.
A
continuaci√≥n
,
divide
entre
dos
su
ventana
de
congesti√≥n
,
pero
vuelve
despu√©s
a
cre-


cer
linealmente
,
tanteando
para
ver
si
hay
disponible
ancho
de
banda
adicional
.
)


Como
hemos
mencionado
anteriormente
,
la
mayor
parte
de
las
implementaciones
TCP


actuales
emplean
el
algoritmo
Reno
[
Padhye
2001
]
.
Se
han
propuesto
muchas
variantes
del


algoritmo
Reno
[
RFC
3782
;
RFC
2018
]
.
El
algoritmo
TCP
Vegas
[
Brakmo
1995
;
Ahn
1995
]


intenta
evitar
la
congesti√≥n
manteniendo
una
buena
tasa
de
transferencia
.
La
idea
b√°sica
del


algoritmo
Vegas
es
(
1
)
detectar
la
congesti√≥n
en
los
routers
existentes
entre
el
origen
y
el


destino
antes
de
que
se
pierda
un
paquete
y
(
2
)
reducir
la
velocidad
linealmente
cuando
se


detecta
una
p√©rdida
inminente
de
paquetes
.
La
p√©rdida
inminente
de
un
paquete
se
predice


observando
el
RTT
.
Cuanto
mayor
es
el
RTT
de
los
paquetes
,
mayor
es
la
congesti√≥n
en
los


272
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


24
K


16
K


8
K


Tiempo


Ventana
de
congesti√≥n


Figura
3.54
‚Ä¢
Control
de
congesti√≥n
con
crecimiento
aditivo
y
decrecimiento


multiplicativo
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
272routers
.
Linux
soporta
una
serie
de
algoritmos
de
control
de
congesti√≥n
(
incluyendo
TCP


Reno
y
TCP
Vegas
)
y
permite
a
un
administrador
del
sistema
configurar
la
versi√≥n
de
TCP


que
se
va
a
utilizar
.
La
versi√≥n
predeterminada
de
TCP
en
la
versi√≥n
de
Linux
2.6.18
es


CUBIC
[
Ha
2008
]
,
una
versi√≥n
de
TCP
desarrollada
para
aplicaciones
de
gran
ancho
de


banda
.


El
algoritmo
AIMD
de
TCP
fue
desarrollado
bas√°ndose
en
un
enorme
trabajo
de
inge-


nier√≠a
y
de
experimentaci√≥n
con
los
mecanismos
de
control
de
congesti√≥n
en
redes
reales
.


Diez
a√±os
despu√©s
del
desarrollo
de
TCP
,
los
an√°lisis
te√≥ricos
mostraron
que
el
algoritmo
de


control
de
congesti√≥n
de
TCP
sirve
como
un
algoritmo
de
optimizaci√≥n
as√≠ncrona
distri-


buido
que
da
como
resultado
la
optimizaci√≥n
simult√°nea
de
diversos
aspectos
importantes
,


tanto
de
las
prestaciones
proporcionadas
al
usuario
como
del
rendimiento
de
la
red
[
Kelly


1998
]
.
Desde
entonces
se
han
desarrollado
muchos
aspectos
te√≥ricos
del
control
de
conges-


ti√≥n
[
Srikant
2004
]
.


Descripci√≥n
macrosc√≥pica
de
la
tasa
de
transferencia
de
TCP


Visto
el
comportamiento
en
diente
de
sierra
de
TCP
,
resulta
natural
preguntarse
cu√°l
es
la


tasa
de
transferencia
media
(
es
decir
,
la
velocidad
media
)
de
una
conexi√≥n
TCP
de
larga
dura-


ci√≥n
.
En
este
an√°lisis
vamos
a
ignorar
las
fases
de
arranque
lento
que
tienen
lugar
despu√©s
de


producirse
un
fin
de
temporizaci√≥n
(
estas
fases
normalmente
son
muy
cortas
,
ya
que
el
emi-


sor
sale
de
ellas
r√°pidamente
de
forma
exponencial
)
.
Durante
un
intervalo
concreto
de
ida
y


vuelta
,
la
velocidad
a
la
que
TCP
env√≠a
datos
es
funci√≥n
del
tama√±o
de
la
ventana
de
conges-


ti√≥n
y
del
RTT
actual
.
Cuando
el
tama√±o
de
la
ventana
es
w
bytes
y
el
tiempo
actual
de
ida
y


vuelta
es
RTT
segundos
,
entonces
la
velocidad
de
transmisi√≥n
de
TCP
es
aproximadamente


igual
a
w
/
RTT
.
TCP
comprueba
entonces
si
hay
ancho
de
banda
adicional
incrementando
w


en
1
MSS
cada
RTT
hasta
que
se
produce
una
p√©rdida
.
Sea
W
el
valor
de
w
cuando
se
pro-


duce
una
p√©rdida
.
Suponiendo
que
RTT
y
W
son
aproximadamente
constantes
mientras
dura


la
conexi√≥n
,
la
velocidad
de
transmisi√≥n
de
TCP
var√≠a
entre
W/(2
¬∑
RTT
)
y
W
/
RTT
.


Estas
suposiciones
nos
llevan
a
un
modelo
macrosc√≥pico
extremadamente
simplificado


del
comportamiento
en
r√©gimen
permanente
de
TCP
.
La
red
descarta
un
paquete
de
la
cone-


xi√≥n
cuando
la
velocidad
aumenta
hasta
W
/
RTT
;
la
velocidad
entonces
se
reduce
a
la
mitad


y
luego
aumenta
MSS
/
RTT
cada
RTT
hasta
que
de
nuevo
alcanza
el
valor
W
/
RTT
.
Este
pro-


ceso
se
repite
una
y
otra
vez
.
Puesto
que
la
tasa
de
transferencia
(
es
decir
,
la
velocidad
)
de


TCP
aumenta
linealmente
entre
los
dos
valores
extremos
,
tenemos


Utilizando
este
modelo
altamente
idealizado
para
la
din√°mica
del
r√©gimen
permanente


de
TCP
,
tambi√©n
podemos
deducir
una
expresi√≥n
interesante
que
relaciona
la
tasa
de
p√©rdi-


das
de
una
conexi√≥n
con
su
ancho
de
banda
disponible
[
Mahdavi
1997
]
.
Dejamos
esta


demostraci√≥n
para
los
problemas
de
repaso
.
Un
modelo
m√°s
sofisticado
que
,
seg√∫n
se
ha


comprobado
,
concuerda
emp√≠ricamente
con
los
datos
medidos
es
el
que
se
describe
en


[
Padhye
2000
]
.


El
futuro
de
TCP


Es
importante
darse
cuenta
de
que
el
control
de
congesti√≥n
de
TCP
ha
ido
evolucionando
a


lo
largo
de
los
a√±os
y
todav√≠a
sigue
evolucionando
.
Puede
leer
un
resumen
sobre
el
meca-


tasa
de
transferencia
media
de
una
conexi√≥n
=
0
75
,
 
W


RTT


3.7
‚Ä¢
MECANISMO
DE
CONTROL
DE
CONGESTI√ìN
DE
TCP
273


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
273nismo
del
control
de
congesti√≥n
de
TCP
realizado
a
finales
de
la
d√©cada
de
1990
en
[
RFC


2581
]
;
si
desea
ver
una
exposici√≥n
acerca
de
otros
desarrollos
sobre
el
control
de
congesti√≥n


de
TCP
,
consulte
[
Floyd
2001
]
.
Lo
que
era
bueno
para
Internet
cuando
la
mayor√≠a
de
las


conexiones
TCP
transportaban
tr√°fico
SMTP
,
FTP
y
Telnet
no
es
necesariamente
bueno
para


la
Internet
actual
,
en
la
que
domina
HTTP
,
o
para
una
futura
Internet
que
proporcione
servi-


cios
que
hoy
ni
siquiera
podemos
imaginar
.


La
necesidad
de
una
evoluci√≥n
continua
de
TCP
puede
ilustrarse
considerando
las
cone-


xiones
TCP
de
alta
velocidad
necesarias
para
las
aplicaciones
de
computaci√≥n
reticular


(
grid-computing
)
[
Foster
2002
]
.
Por
ejemplo
,
considere
una
conexi√≥n
TCP
con
segmentos


de
1.500
bytes
y
un
RTT
de
100
milisegundos
y
suponga
que
deseamos
enviar
datos
a
trav√©s


de
esta
conexi√≥n
a
10
Gbps
.
Siguiendo
el
documento
[
RFC
3649
]
,
observamos
que
utilizar


la
f√≥rmula
anterior
para
la
tasa
de
transferencia
de
TCP
,
con
el
fin
de
alcanzar
una
tasa
de


transferencia
de
10
Gbps
,
nos
dar√≠a
un
tama√±o
medio
de
la
ventana
de
congesti√≥n
de
83.333


segmentos
,
que
son
muchos
segmentos
,
lo
que
despierta
el
temor
a
que
uno
de
esos
83.333


segmentos
en
tr√°nsito
pueda
perderse
.
¬ø
Qu√©
ocurrir√≠a
si
se
produjeran
p√©rdidas
?
O
,
dicho
de


otra
manera
,
¬ø
qu√©
fracci√≥n
de
los
segmentos
transmitidos
podr√≠a
perderse
que
permitiera
al


algoritmo
de
control
de
congesti√≥n
de
TCP
de
la
Figura
3.52
alcanzar
la
velocidad
deseada


de
10
Gbps
?
En
las
cuestiones
de
repaso
de
este
cap√≠tulo
,
mostraremos
c√≥mo
derivar
una


f√≥rmula
que
expresa
la
tasa
de
transferencia
de
una
conexi√≥n
TCP
en
funci√≥n
de
la
tasa
de


p√©rdidas
(
L
)
,
el
tiempo
de
ida
y
vuelta
(
RTT
)
y
el
tama√±o
m√°ximo
de
segmento
(
MSS
):


Con
esta
f√≥rmula
,
podemos
ver
que
para
alcanzar
una
tasa
de
transferencia
de
10
Gbps
,
el


actual
algoritmo
de
control
de
congesti√≥n
de
TCP
s√≥lo
puede
tolerar
una
probabilidad
de


p√©rdida
de
segmentos
de
2
¬∑
10
‚Äì
10
(
o
,
lo
que
es
equivalente
,
un
suceso
de
p√©rdida
por
cada


5.000.000.000
segmentos
)
,
lo
cual
es
una
tasa
muy
baja
.
Esta
observaci√≥n
ha
llevado
a
una


serie
de
investigadores
a
buscar
nuevas
versiones
de
TCP
que
est√©n
dise√±adas
espec√≠fica-


mente
para
estos
entornos
de
alta
velocidad
;
consulte
[
Jin
2004
;
RFC
3649
;
Kelly
2003
;
Ha


2008
]
para
obtener
informaci√≥n
sobre
estos
trabajos
.


3.7.1
Equidad


Considere
ahora
K
conexiones
TCP
,
cada
una
de
ellas
con
una
ruta
terminal
a
terminal
dife-


rente
,
pero
atravesando
todas
ellas
un
enlace
de
cuello
de
botella
con
una
velocidad
de
trans-


misi√≥n
de
R
bps
(
con
enlace
de
cuello
de
botella
queremos
decir
que
,
para
cada
conexi√≥n
,


todos
los
restantes
enlaces
existentes
a
lo
largo
de
la
ruta
de
la
conexi√≥n
no
est√°n
congestio-


nados
y
tienen
una
capacidad
de
transmisi√≥n
grande
comparada
con
la
capacidad
de
trans-


misi√≥n
del
enlace
de
cuello
de
botella
)
.
Suponga
que
cada
conexi√≥n
est√°
transfiriendo
un


archivo
de
gran
tama√±o
y
que
no
existe
tr√°fico
UDP
atravesando
el
enlace
de
cuello
de
bote-


lla
.
Se
dice
que
un
mecanismo
de
control
de
congesti√≥n
es
equitativo
si
la
velocidad
media


de
transmisi√≥n
de
cada
conexi√≥n
es
aproximadamente
igual
a
R
/
K
;
es
decir
,
cada
conexi√≥n


obtiene
la
misma
cuota
del
ancho
de
banda
del
enlace
.


¬ø
Es
el
algoritmo
AIMD
de
TCP
equitativo
,
teniendo
en
cuenta
que
diferentes
conexio-


nes
TCP
pueden
iniciarse
en
instantes
distintos
y
,
por
tanto
,
pueden
tener
distintos
tama√±os


de
ventana
en
un
instante
determinado
?
[
Chiu
1989
]
proporciona
una
explicaci√≥n
elegante
e


intuitiva
de
por
qu√©
el
control
de
congesti√≥n
de
TCP
converge
para
proporcionar
la
misma


tasa
de
transferencia
media
de
una
conexi√≥n
 
=
 12
2
,
MSS


RTT
L
 
 

274
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
274cuota
de
ancho
de
banda
de
un
enlace
de
cuello
de
botella
a
las
conexiones
TCP
que
compi-


ten
por
el
ancho
de
banda
.


Consideremos
el
caso
simple
de
dos
conexiones
TCP
que
comparten
un
mismo
enlace
,


cuya
velocidad
de
transmisi√≥n
es
R
,
como
se
muestra
en
la
Figura
3.55
.
Suponemos
que
las


dos
conexiones
tienen
el
mismo
MSS
y
el
mismo
RTT
(
por
lo
que
si
tienen
el
mismo
tama√±o


de
ventana
de
congesti√≥n
,
entonces
tienen
la
misma
tasa
de
transferencia
)
.
Adem√°s
,
tienen


que
enviar
una
gran
cantidad
de
datos
y
ninguna
otra
conexi√≥n
TCP
ni
datagrama
UDP
atra-


viesan
este
enlace
compartido
.
Asimismo
,
vamos
a
ignorar
la
fase
de
arranque
lento
de
TCP


y
vamos
a
suponer
que
las
conexiones
TCP
est√°n
operando
en
el
modo
de
evitaci√≥n
de
la


congesti√≥n
(
AIMD
)
durante
todo
el
tiempo
.


La
gr√°fica
de
la
Figura
3.56
muestra
la
tasa
de
transferencia
de
las
dos
conexiones
TCP
.


Si
TCP
est√°
dise√±ado
para
que
las
dos
conexiones
compartan
equitativamente
el
ancho
de


banda
del
enlace
,
entonces
la
tasa
de
transferencia
alcanzada
deber√≠a
caer
a
lo
largo
de
la


3.7
‚Ä¢
MECANISMO
DE
CONTROL
DE
CONGESTI√ìN
DE
TCP
275


R


R


Cuota
equitativa


de
ancho
de
banda


Tasa
de
transferencia
de
la
conexi√≥n
1


Tasa
de
transferencia
de
la
conexi√≥n
2


D


B


C


A


L√≠nea
de
utilizaci√≥n


del
ancho
de
banda


completo


Figura
3.56
‚Ä¢
Tasa
de
transferencia
alcanzada
por
las
conexiones
TCP
1
y
2
.


Figura
3.55
‚Ä¢
Dos
conexiones
TCP
que
comparten
un
mismo
enlace
de
cuello


de
botella
.


Conexi√≥n
TCP
2


Conexi√≥n
TCP
1


Router
cuello
de


botella
de
capacidad
R


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
275flecha
que
sale
del
origen
con
un
√°ngulo
de
45
grados
(
cuota
equitativa
de
ancho
de
banda
)
.


Idealmente
,
la
suma
de
las
dos
tasas
de
transferencia
tiene
que
ser
igual
a
R
(
evidentemente
,


que
cada
conexi√≥n
reciba
una
cuota
equitativa
de
la
capacidad
del
enlace
,
pero
igual
a
cero
,


no
es
una
situaci√≥n
deseable
)
.
Por
tanto
,
el
objetivo
deber√≠a
ser
que
las
tasas
de
transferencia


alcanzadas
se
encuentren
en
alg√∫n
punto
pr√≥ximo
a
la
intersecci√≥n
de
la
l√≠nea
de
cuota
equi-


tativa
de
ancho
de
banda
con
la
l√≠nea
de
utilizaci√≥n
del
ancho
de
banda
completo
mostradas


en
la
Figura
3.56
.


Suponga
que
los
tama√±os
de
ventana
de
TCP
son
tales
que
,
en
un
instante
determinado
,


las
conexiones
1
y
2
alcanzan
las
tasas
de
transferencia
indicadas
por
el
punto
A
de
la


Figura
3.56
.
Puesto
que
la
cantidad
de
ancho
de
banda
del
enlace
conjunto
consumido
por


las
dos
conexiones
es
menor
que
R
,
no
se
producir√°
ninguna
p√©rdida
y
ambas
conexiones


incrementar√°n
sus
tama√±os
de
ventana
en
1
MSS
por
RTT
como
resultado
del
algoritmo


de
evitaci√≥n
de
la
congesti√≥n
de
TCP
.
Por
tanto
,
la
tasa
de
transferencia
conjunta
de
las


dos
conexiones
sigue
la
l√≠nea
de
45
grados
(
incremento
equitativo
para
ambas
conexiones
)


partiendo
del
punto
A.
Finalmente
,
el
ancho
de
banda
del
enlace
consumido
conjuntamente


por
las
dos
conexiones
ser√°
mayor
que
R
,
por
lo
que
terminar√°
produci√©ndose
una
p√©rdida


de
paquetes
.
Suponga
que
las
conexiones
1
y
2
experimentan
una
p√©rdida
de
paquetes


cuando
alcanzan
las
tasas
de
transferencia
indicadas
por
el
punto
B.
Entonces
las
conexio-


nes
1
y
2
reducen
el
tama√±o
de
sus
ventanas
en
un
factor
de
dos
.
Las
tasas
de
transferencia


resultantes
se
encuentran
por
tanto
en
el
punto
C
,
a
medio
camino
de
un
vector
que


comienza
en
B
y
termina
en
el
origen
.
Puesto
que
el
ancho
de
banda
conjunto
utilizado
es


menor
que
R
en
el
punto
C
,
de
nuevo
las
dos
conexiones
incrementan
sus
tasas
de
transfe-


rencia
a
lo
largo
de
la
l√≠nea
de
45
grados
partiendo
de
C.
Finalmente
,
terminar√°
por
produ-


cirse
de
nuevo
una
p√©rdida
de
paquetes
,
por
ejemplo
,
en
el
punto
D
,
y
las
dos
conexiones


otra
vez
reducir√°n
el
tama√±o
de
sus
ventanas
en
un
factor
de
dos
,
y
as√≠
sucesivamente
.


Compruebe
que
el
ancho
de
banda
alcanzado
por
ambas
conexiones
fluct√∫a
a
lo
largo
de
la


l√≠nea
que
indica
una
cuota
equitativa
del
ancho
de
banda
.
Compruebe
tambi√©n
que
las
dos


conexiones
terminar√°n
convergiendo
a
este
comportamiento
,
independientemente
de
su


posici√≥n
inicial
dentro
de
ese
espacio
bidimensional
.
Aunque
en
este
escenario
se
han


hecho
una
serie
de
suposiciones
ideales
,
permite
proporcionar
una
idea
intuitiva
de
por
qu√©


TCP
hace
que
el
ancho
de
banda
se
reparta
de
forma
equitativa
entre
las
conexiones
.


En
este
escenario
ideal
hemos
supuesto
que
s√≥lo
las
conexiones
TCP
atraviesan
el


enlace
de
cuello
de
botella
,
que
las
conexiones
tienen
el
mismo
valor
de
RTT
y
que
s√≥lo
hay


una
conexi√≥n
TCP
asociada
con
cada
pareja
origen-destino
.
En
la
pr√°ctica
,
estas
condicio-


nes
normalmente
no
se
dan
y
las
aplicaciones
cliente-servidor
pueden
por
tanto
obtener
cuo-


tas
desiguales
del
ancho
de
banda
del
enlace
.
En
particular
,
se
ha
demostrado
que
cuando


varias
conexiones
comparten
un
cuello
de
botella
com√∫n
,
aquellas
sesiones
con
un
valor
de


RTT
menor
son
capaces
de
apropiarse
m√°s
r√°pidamente
del
ancho
de
banda
disponible
en
el


enlace
,
a
medida
que
√©ste
va
liber√°ndose
(
es
decir
,
abren
m√°s
r√°pidamente
sus
ventanas
de


congesti√≥n
)
y
por
tanto
disfrutan
de
una
tasa
de
transferencia
m√°s
alta
que
aquellas
conexio-


nes
cuyo
valor
de
RTT
es
m√°s
grande
[
Lakshman
1997
]
.


Equidad
en
UDP


Acabamos
de
ver
c√≥mo
el
control
de
congesti√≥n
de
TCP
regula
la
velocidad
de
transmisi√≥n


de
una
aplicaci√≥n
mediante
el
mecanismo
de
la
ventana
de
congesti√≥n
.
Muchas
aplicaciones


multimedia
,
como
las
videoconferencias
y
la
telefon√≠a
por
Internet
,
a
menudo
no
se
ejecutan


sobre
TCP
precisamente
por
esta
raz√≥n
(
no
desean
que
su
velocidad
de
transmisi√≥n
se


276
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
276regule
,
incluso
aunque
la
red
est√©
muy
congestionada
)
.
En
lugar
de
ello
,
estas
aplicaciones


prefieren
ejecutarse
sobre
UDP
,
que
no
incorpora
un
mecanismo
de
control
de
la
congesti√≥n
.


Al
ejecutarse
sobre
UDP
,
las
aplicaciones
pueden
entregar
a
la
red
sus
datos
de
audio
y
de


v√≠deo
a
una
velocidad
constante
y
,
ocasionalmente
,
perder
paquetes
,
en
lugar
de
reducir
sus


velocidades
a
niveles
‚Äú
equitativos
‚Äù
y
no
perder
ning√∫n
paquete
.
Desde
la
perspectiva
de


TCP
,
las
aplicaciones
multimedia
que
se
ejecutan
sobre
UDP
no
son
equitativas
(
no
coope-


ran
con
las
dem√°s
conexiones
ni
ajustan
sus
velocidades
de
transmisi√≥n
apropiadamente
)
.


Dado
que
el
control
de
congesti√≥n
de
TCP
disminuye
la
velocidad
de
transmisi√≥n
para
hacer


frente
a
un
aumento
de
la
congesti√≥n
(
y
de
las
p√©rdidas
)
y
los
or√≠genes
de
datos
UDP
no
lo


hacen
,
puede
darse
el
caso
de
que
esos
or√≠genes
UDP
terminen
por
expulsar
al
tr√°fico
TCP
.


Un
√°rea
actual
de
investigaci√≥n
es
el
desarrollo
de
mecanismos
de
control
de
congesti√≥n


para
Internet
que
impidan
que
el
tr√°fico
UDP
termine
por
reducir
a
cero
la
tasa
de
transfe-


rencia
de
Internet
[
Floyd
1999
;
Floyd
2000
;
Kohler
2006
]
.


Equidad
y
conexiones
TCP
en
paralelo


Pero
aunque
se
pudiera
forzar
al
tr√°fico
UDP
a
comportarse
equitativamente
,
el
problema


de
la
equidad
todav√≠a
no
estar√≠a
completamente
resuelto
.
Esto
es
porque
no
hay
nada
que


impida
a
una
aplicaci√≥n
basada
en
TCP
utilizar
varias
conexiones
en
paralelo
.
Por
ejemplo
,


los
navegadores
web
a
menudo
utilizan
varias
conexiones
TCP
en
paralelo
para
transferir


los
distintos
objetos
contenidos
en
una
p√°gina
web
(
en
la
mayor√≠a
de
los
navegadores


puede
configurarse
el
n√∫mero
exacto
de
conexiones
m√∫ltiples
)
.
Cuando
una
aplicaci√≥n


emplea
varias
conexiones
en
paralelo
obtiene
una
fracci√≥n
grande
del
ancho
de
banda
de


un
enlace
congestionado
.
Por
ejemplo
,
considere
un
enlace
cuya
velocidad
es
R
que
soporta


nueve
aplicaciones
entrantes
cliente-servidor
,
utilizando
cada
una
de
las
aplicaciones
una


conexi√≥n
TCP
.
Si
llega
una
nueva
aplicaci√≥n
y
tambi√©n
emplea
una
conexi√≥n
TCP
,
enton-


ces
cada
conexi√≥n
tendr√°
aproximadamente
la
misma
velocidad
de
transmisi√≥n
de
R/10
.


Pero
si
esa
nueva
aplicaci√≥n
utiliza
11
conexiones
TCP
en
paralelo
,
entonces
la
nueva
apli-


caci√≥n
obtendr√°
una
cuota
no
equitativa
de
m√°s
de
R/2
.
Dado
que
el
tr√°fico
web
es
el
domi-


nante
en
Internet
,
las
conexiones
m√∫ltiples
en
paralelo
resultan
bastante
comunes
.


3.8
Resumen


Hemos
comenzado
este
cap√≠tulo
estudiando
los
servicios
que
un
protocolo
de
la
capa
de


transporte
puede
proporcionar
a
las
aplicaciones
de
red
.
En
uno
de
los
extremos
,
el
proto-


colo
de
capa
de
transporte
puede
ser
muy
simple
y
ofrecer
un
servicio
poco
sofisticado
a
las


aplicaciones
,
poniendo
a
su
disposici√≥n
√∫nicamente
una
funci√≥n
de
multiplexaci√≥n
/
demulti-


plexaci√≥n
para
los
procesos
que
se
est√°n
comunicando
.
El
protocolo
UDP
de
Internet
es
un


ejemplo
de
ese
tipo
de
protocolo
de
la
capa
de
transporte
poco
sofisticados
.
En
el
otro


extremo
,
un
protocolo
de
la
capa
de
transporte
puede
proporcionar
a
las
aplicaciones
diver-


sos
tipos
de
garant√≠as
,
como
por
ejemplo
la
de
entrega
fiable
de
los
datos
,
garant√≠as
sobre


los
retardos
y
garant√≠as
concernientes
al
ancho
de
banda
.
De
todos
modos
,
los
servicios
que


un
protocolo
de
transporte
puede
proporcionar
est√°n
a
menudo
restringidos
por
el
modelo


de
servicio
del
protocolo
subyacente
de
la
capa
de
red
.
Si
el
protocolo
de
la
capa
de
red
no


puede
proporcionar
garant√≠as
sobre
los
retardos
o
de
ancho
de
banda
a
los
segmentos
de
la


capa
de
transporte
,
entonces
el
protocolo
de
la
capa
de
transporte
no
puede
proporcionar


garant√≠as
de
retardo
ni
de
ancho
de
banda
a
los
mensajes
intercambiados
por
los
procesos
.


3.8
‚Ä¢
RESUMEN
277


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
277En
la
Secci√≥n
3.4
hemos
visto
que
un
protocolo
de
la
capa
de
transporte
puede


proporcionar
una
transferencia
fiable
de
los
datos
incluso
aunque
el
protocolo
de
red
subya-


cente
sea
no
fiable
.
All√≠
vimos
que
que
son
muchas
las
sutilezas
implicadas
en
la
provisi√≥n


de
una
transferencia
fiable
de
los
datos
,
pero
que
dicha
tarea
puede
llevarse
a
cabo
combi-


nando
cuidadosamente
los
paquetes
de
reconocimiento
,
los
temporizadores
,
las
retransmi-


siones
y
los
n√∫meros
de
secuencia
.


Aunque
hemos
hablado
de
la
transferencia
fiable
de
los
datos
en
este
cap√≠tulo
,
debemos


tener
presente
que
esa
transferencia
fiable
puede
ser
proporcionada
por
los
protocolos
de
las


capas
de
enlace
,
de
red
,
de
transporte
o
de
aplicaci√≥n
.
Cualquiera
de
las
cuatro
capas
supe-


riores
de
la
pila
de
protocolos
puede
implementar
los
reconocimientos
,
los
temporizadores
,


las
retransmisiones
y
los
n√∫meros
de
secuencia
,
proporcionando
as√≠
un
servicio
de
transfe-


rencia
de
datos
fiable
a
la
capa
que
tiene
por
encima
.
De
hecho
,
a
lo
largo
de
los
a√±os
,
los


ingenieros
e
inform√°ticos
han
dise√±ado
e
implementado
de
manera
independiente
protoco-


los
de
las
capas
de
enlace
,
de
red
,
de
transporte
y
de
aplicaci√≥n
que
proporcionan
una
trans-


ferencia
de
datos
fiable
(
aunque
muchos
de
estos
protocolos
han
desaparecido


silenciosamente
de
la
escena
)
.


En
la
Secci√≥n
3.5
hemos
examinado
en
detalle
TCP
,
el
protocolo
fiable
y
orientado
a
la


conexi√≥n
de
la
capa
de
transporte
de
Internet
.
Hemos
visto
que
TCP
es
bastante
complejo
,


incluyendo
t√©cnicas
de
gesti√≥n
de
la
conexi√≥n
,
de
control
de
flujo
y
de
estimaci√≥n
del
tiempo


de
ida
y
vuelta
,
adem√°s
de
una
transferencia
fiable
de
los
datos
.
De
hecho
,
TCP
es
bastante


m√°s
complejo
de
lo
que
nuestra
descripci√≥n
deja
entrever
;
hemos
dejado
fuera
de
nuestra


exposici√≥n
,
intencionadamente
,
diversos
parches
,
correcciones
y
mejoras
de
TCP
que
est√°n


ampliamente
implementadas
en
distintas
versiones
de
dicho
protocolo
.
De
todos
modos
,


todas
estas
complejidades
est√°n
ocultas
a
ojos
de
la
aplicaci√≥n
de
red
.
Si
el
cliente
en
un
host


quiere
enviar
datos
de
forma
fiable
a
un
servidor
implementado
en
otro
host
,
se
limita
a
abrir


un
socket
TCP
con
el
servidor
y
a
bombear
datos
a
trav√©s
de
dicho
socket
.
Afortunadamente
,


la
aplicaci√≥n
cliente-servidor
es
completamente
inconsciente
de
toda
la
complejidad
de
TCP
.


En
la
Secci√≥n
3.6
hemos
examinado
el
control
de
congesti√≥n
desde
una
perspectiva


amplia
,
mientras
que
en
la
Secci√≥n
3.7
hemos
mostrado
c√≥mo
se
implementa
ese
mecanismo


de
control
de
congesti√≥n
en
TCP
.
All√≠
vimos
que
el
control
de
congesti√≥n
es
obligatorio


parala
buena
saluda
de
la
red
.
Sin
√©l
,
la
red
puede
colapsarse
f√°cilmente
,
sin
que
al
final
pue-


dan
transportarse
datos
de
terminal
a
terminal
.
En
la
Secci√≥n
3.7
vimos
que
TCP
implementa


un
mecanismo
de
control
de
congesti√≥n
terminal
a
terminal
que
incrementa
de
forma
aditiva


su
tasa
de
transmisi√≥n
cuando
se
eval√∫a
que
la
ruta
seguida
por
la
conexi√≥n
TCP
est√°
libre


de
congesti√≥n
,
mientras
que
esa
tasa
de
transmisi√≥n
se
reduce
multiplicativamente
cuando


se
producen
p√©rdidas
de
datos
.
Este
mecanismo
tambi√©n
trata
de
proporcionar
a
cada
cone-


xi√≥n
TCP
que
pasa
a
trav√©s
de
un
enlace
congestionado
una
parte
equitativa
del
ancho
de


banda
del
enlace
.
Tambi√©n
hemos
examinado
con
cierta
profundidad
el
impacto
que
el
esta-


blecimiento
de
la
conexi√≥n
TCP
y
el
lento
arranque
de
la
misma
tienen
sobre
la
latencia
.


Hemos
observado
que
,
en
muchos
casos
importantes
,
el
establecimiento
de
la
conexi√≥n
y
el


arranque
lento
contribuyen
significativamente
al
retardo
terminal
a
terminal
.
Conviene


recalcar
una
vez
m√°s
que
,
aunque
el
control
de
congesti√≥n
de
TCP
ha
ido
evolucionando
a


lo
largo
de
los
a√±os
,
contin√∫a
siendo
un
√°rea
intensiva
de
investigaci√≥n
y
es
probable
que


contin√∫e
evolucionando
en
los
pr√≥ximos
a√±os
.


El
an√°lisis
realizado
en
este
cap√≠tulo
acerca
de
los
protocolos
espec√≠ficos
de
trans-


porte
en
Internet
se
ha
centrado
en
UDP
y
TCP
,
que
son
los
dos
‚Äú
caballos
de
batalla
‚Äù
de


la
capa
de
transporte
de
Internet
.
Sin
embar
go
,
dos
d√©cadas
de
experiencia
con
estos
dos


278
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
278protocolos
han
permitido
identificar
una
serie
de
casos
en
los
que
ninguno
de
los
dos


resulta
ideal
.
Los
investigadores
han
dedicado
,
por
tanto
,
grandes
esfuerzos
al
desarro-


llo
de
protocolos
adicionales
de
la
capa
de
transporte
,
varios
de
los
cuales
son
actual-


mente
est√°ndares
propuestos
por
IETF
.


El
Protocolo
de
control
de
congesti√≥n
para
datagramas
(
DCCP
,
Datagram
Congestion


Control
Protocol
)
[
RFC
4340
]
proporciona
un
servicio
no
fiable
con
baja
carga
administra-


tiva
y
orientado
a
mensajes
,
similar
a
UDP
,
pero
que
cuenta
con
un
tipo
de
control
de
con-


gesti√≥n
seleccionado
por
la
aplicaci√≥n
y
que
es
compatible
con
TCP
.
Si
una
aplicaci√≥n


necesita
una
transferencia
de
datos
fiable
o
semi-fiable
,
entonces
el
control
de
congesti√≥n


ser√≠a
implementado
dentro
de
la
propia
aplicaci√≥n
,
quiz√°
utilizando
los
mecanismos
que


hemos
estudiado
en
la
Secci√≥n
3.4
.
DCCP
est√°
previsto
para
utilizarlo
en
aplicaciones
tales


como
los
flujos
multimedia
(
v√©ase
el
Cap√≠tulo
7
)
que
pueden
jugar
con
los
compromisos


existentes
entre
los
requisitos
de
temporizaci√≥n
y
de
fiabilidad
en
la
entrega
de
datos
,
pero


que
quieran
a
la
vez
poder
responder
a
situaciones
de
congesti√≥n
en
la
red
.


El
Protocolo
de
transmisi√≥n
para
control
de
flujos
(
SCTP
,
Stream
Control
Transmission


Protocol
)
[
RFC
2960
,
RFC
3286
]
es
un
protocolo
fiable
orientado
a
mensajes
,
que
permite


multiplexar
diferentes
‚Äú
flujos
‚Äù
de
nivel
de
aplicaci√≥n
a
trav√©s
de
una
√∫nica
conexi√≥n
SCTP


(
una
t√©cnica
conocida
con
el
nombre
de
‚Äú
multi-streaming
‚Äù
)
.
Desde
el
punto
de
vista
de
la


fiabilidad
,
los
diferentes
flujos
que
comparten
la
conexi√≥n
se
gestionan
de
forma
separada
,


de
modo
que
la
p√©rdida
de
paquetes
en
uno
de
los
flujos
no
afecte
a
la
entrega
de
los
datos


en
los
otros
.
SCTP
tambi√©n
permite
transferir
datos
a
trav√©s
de
dos
rutas
de
salida
cuando
un


host
est√°
conectado
a
dos
o
m√°s
redes
;
tambi√©n
existe
la
posibilidad
de
la
entrega
opcional


de
datos
fuera
de
orden
,
as√≠
como
otra
serie
de
caracter√≠sticas
interesantes
.
Los
algorit-


mos
de
control
de
flujo
y
de
control
de
congesti√≥n
de
SCTP
son
pr√°cticamente
los
mismos


que
en
TCP
.


El
protocolo
de
Control
de
tasa
compatible
con
TCP
(
TFRC
,
TCP-Friendly
Rate
Con-


trol
)
[
RFC
5348
]
es
un
protocolo
de
control
de
congesti√≥n
m√°s
que
un
protocolo
completo


de
la
capa
de
transporte
.
TFRC
especifica
un
mecanismo
de
control
de
congesti√≥n
que


podr√≠a
ser
utilizado
en
alg√∫n
otro
protocolo
de
transporte
,
como
DCCP
(
de
hecho
,
uno
de


los
dos
protocolos
seleccionables
por
la
aplicaci√≥n
existentes
en
DCCP
es
TFRC
)
.
El
obje-


tivo
de
TFRC
es
suavizar
el
comportamiento
t√≠pico
en
‚Äú
diente
de
sierra
‚Äù
(
v√©ase
la
Figura


3.54
)
que
se
experimenta
en
el
control
de
congesti√≥n
de
TCP
,
al
mismo
tiempo
que
se
man-


tiene
una
tasa
de
transmisi√≥n
a
largo
plazo
‚Äú
razonablemente
‚Äù
pr√≥xima
a
la
TCP
.
Con
una


tasa
de
transmisi√≥n
de
perfil
m√°s
suave
que
TCP
,
TFRC
est√°
bien
adaptado
a
aplicaciones


multimedia
tales
como
la
telefon√≠a
IP
o
los
flujos
multimedia
,
en
donde
es
importante
man-


tener
ese
perfil
suave
de
la
tasa
de
transmisi√≥n
.
TFRC
es
un
protocolo
‚Äú
basado
en
ecuacio-


nes
‚Äù
que
utiliza
la
tasa
medida
de
p√©rdida
de
paquetes
como
entrada
para
una
ecuaci√≥n


[
Padhye
2000
]
que
permite
estimar
cu√°l
ser√≠a
la
tasa
de
transferencia
TCP
si
una
sesi√≥n
TCP


experimentara
dicha
tasa
de
p√©rdidas
.
Entonces
,
dicha
tasa
de
transferencia
se
adopta
como


objetivo
de
tasa
de
transmisi√≥n
para
TFRC
.


S√≥lo
el
futuro
nos
dir√°
si
DCCP
,
SCTP
o
TFRC
ser√°n
adoptados
ampliamente
o
no
.
Aun-


que
estos
protocolos
proporcionan
claramente
una
serie
de
capacidades
mejoradas
respecto
a


TCP
y
UDP
,
estos
dos
protocolos
han
demostrado
ser
a
lo
largo
de
los
a√±os
‚Äú
lo
suficientemente


buenos
‚Äù
.
El
que
un
‚Äú
mejor
‚Äù
protocolos
termine
venciendo
a
otro
que
es
‚Äú
suficientemente


bueno
‚Äù
depender√°
de
una
compleja
mezcla
de
aspectos
t√©cnicos
,
sociales
y
empresariales
.


En
el
Cap√≠tulo
1
hemos
visto
que
una
red
de
computadoras
puede
dividirse
entre
lo
que


se
denomina
la
‚Äú
frontera
de
la
red
‚Äù
y
el
‚Äú
n√∫cleo
de
la
red
‚Äù
.
La
frontera
de
la
red
cubre
todo


3.8
‚Ä¢
RESUMEN
279


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
279lo
que
sucede
en
los
sistemas
terminales
.
Habiendo
ya
cubierto
la
capa
de
aplicaci√≥n
y
la


capa
de
transporte
,
nuestro
an√°lisis
de
la
frontera
de
la
red
est√°
completo
,
as√≠
que
ha
llegado


el
momento
de
explorar
el
n√∫cleo
de
la
red
.
Comenzaremos
nuestro
viaje
en
el
siguiente


cap√≠tulo
,
donde
analizaremos
la
capa
red
,
y
seguiremos
en
el
Cap√≠tulo
5
dedicado
a
la
capa


de
enlace
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
3
Cuestiones
de
repaso


SECCIONES
3.1‚Äì3.3


R1
.
Suponga
que
la
capa
de
red
proporciona
el
siguiente
servicio
:
la
capa
de
red
del
host


de
origen
acepta
un
segmento
con
un
tama√±o
m√°ximo
de
1.200
bytes
y
una
direcci√≥n


de
host
de
destino
de
la
capa
de
transporte
.
La
capa
de
red
garantiza
la
entrega
del
seg-


mento
a
la
capa
de
transporte
en
el
host
de
destino
.
Suponga
que
en
el
host
de
destino


pueden
ejecutarse
muchos
procesos
de
aplicaciones
de
red
.


a.
Dise√±e
el
protocolo
de
la
capa
de
transporte
m√°s
simple
posible
que
entregue
los


datos
de
la
aplicaci√≥n
al
proceso
deseado
en
el
host
de
destino
.
Suponga
que
el
sis-


tema
operativo
del
host
de
destino
ha
asignado
un
n√∫mero
de
puerto
de
4
bytes
a


cada
proceso
de
aplicaci√≥n
en
ejecuci√≥n
.


b.
Modifique
este
protocolo
de
manera
que
proporcione
una
‚Äú
direcci√≥n
de
retorno
‚Äù
al


proceso
de
destino
.


c.
En
sus
protocolos
,
¬ø
la
capa
de
transporte
‚Äú
tiene
que
hacer
algo
‚Äù
en
el
n√∫cleo
de
la


red
de
computadoras
?


R2
.
Imagine
una
sociedad
en
la
que
todo
el
mundo
perteneciera
a
una
familia
de
seis


miembros
,
todas
las
familias
vivieran
en
su
propia
casa
,
cada
casa
tuviera
una
direc-


ci√≥n
√∫nica
y
cada
persona
de
cada
casa
tuviera
un
nombre
√∫nico
.
Imagine
que
esa


sociedad
dispone
de
un
servicio
de
correos
que
transporta
las
cartas
desde
una


vivienda
de
origen
hasta
una
vivienda
de
destino
.
El
servicio
de
correos
requiere
que


(
i
)
la
carta
se
introduzca
en
un
sobre
y
que
(
ii
)
la
direcci√≥n
de
la
casa
de
destino
(
y


nada
m√°s
)
est√©
claramente
escrita
en
el
sobre
.
Suponga
tambi√©n
que
en
cada
familia


hay
un
delegado
que
tiene
asignada
la
tarea
de
recoger
y
distribuir
las
cartas
a
los
res-


tantes
miembros
de
la
familia
.
Las
cartas
no
necesariamente
proporcionan
una
indica-


ci√≥n
acerca
de
los
destinatarios
.


a.
Partiendo
de
la
soluci√≥n
del
Problema
R1
,
describa
un
protocolo
que
el
delegado


de
la
familia
pueda
utilizar
para
entregar
las
cartas
de
un
miembro
de
la
familia


emisora
a
un
miembro
de
la
familia
receptora
.


b.
En
su
protocolo
,
¬ø
el
servicio
de
correos
tienen
que
abrir
el
sobre
y
examinar
la
carta


para
proporcionar
este
servicio
?


R3
.
Considere
una
conexi√≥n
TCP
entre
el
host
A
y
el
host
B.
Suponga
que
los
segmentos


TCP
que
viajan
del
host
A
al
host
B
tienen
un
n√∫mero
de
puerto
de
origen
x
y
un


n√∫mero
de
puerto
de
destino
y.
¬ø
Cu√°les
son
los
n√∫meros
de
puerto
de
origen
y
de
des-


tino
para
los
segmentos
que
viajan
del
host
B
al
host
A
?


280
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
280R4
.
Describa
por
qu√©
un
desarrollador
de
aplicaciones
puede
decidir
ejecutar
una
aplica-


ci√≥n
sobre
UDP
en
lugar
de
sobre
TCP
.


R5
.
¬ø
Por
qu√©
raz√≥n
el
tr√°fico
de
voz
y
de
v√≠deo
suele
enviarse
sobre
TCP
en
lugar
de
sobre


UDP
en
la
Internet
de
hoy
d√≠a
?
(
Sugerencia
:
la
respuesta
que
estamos
buscando
no


tiene
nada
que
ver
con
el
mecanismo
de
control
de
congesti√≥n
de
TCP
.
)


R6
.
¬ø
Es
posible
que
una
aplicaci√≥n
disfrute
de
una
transferencia
de
datos
fiable
incluso
si


se
ejecuta
sobre
UDP
?
En
caso
afirmativo
,
explique
c√≥mo
.


R7
.
Sea
un
proceso
del
host
C
que
tiene
un
socket
UDP
con
el
n√∫mero
de
puerto
6789
.


Suponga
tambi√©n
que
los
hosts
A
y
B
env√≠an
cada
uno
de
ellos
un
segmento
UDP
al


host
C
con
el
n√∫mero
de
puerto
de
destino
6789
.
¬ø
Ser√°n
dirigidos
ambos
segmentos
al


mismo
socket
del
host
C
?
En
caso
afirmativo
,
¬ø
c√≥mo
sabr√°
el
proceso
del
host
C
que


estos
dos
segmentos
proceden
de
dos
hosts
distintos
?


R8
.
Suponga
que
un
servidor
web
se
ejecuta
en
el
puerto
80
del
host
C.
Suponga
tambi√©n


que
este
servidor
web
utiliza
conexiones
persistentes
y
que
actualmente
est√°
reci-


biendo
solicitudes
de
dos
hosts
diferentes
,
A
y
B.
¬ø
Est√°n
siendo
enviadas
todas
las


solicitudes
al
mismo
socket
del
host
C
?
Si
est√°n
siendo
pasadas
a
trav√©s
de
sockets


diferentes
,
¬ø
utilizan
ambos
sockets
el
puerto
80
?
Explique
y
justifique
su
respuesta
.


SECCI√ìN
3.4


R9
.
En
los
protocolos
rdt
estudiados
,
¬ø
por
qu√©
necesit√°bamos
introducir
n√∫meros
de


secuencia
?


R10
.
En
los
protocolos
rdt
estudiados
,
¬ø
por
qu√©
necesit√°bamos
introducir
temporizadores
?


R11
.
Suponga
que
el
retardo
de
ida
y
vuelta
entre
el
emisor
y
el
receptor
es
constante
y


conocido
por
el
emisor
.
¬ø
Se
necesitar√≠a
en
este
caso
un
temporizador
en
el
protocolo


rdt3.0
,
suponiendo
que
los
paquetes
pueden
perderse
?
Explique
su
respuesta
.


R12
.
Visite
el
applet
de
Java
Go-Back-N
en
el
sitio
web
del
libro
.


a.
Haga
que
el
emisor
env√≠e
cinco
paquetes
y
luego
detenga
la
animaci√≥n
antes
de
que


cualquiera
de
los
cinco
paquetes
alcance
su
destino
.
A
continuaci√≥n
,
elimine
el
pri-


mer
paquete
y
reanude
la
animaci√≥n
.
Describa
lo
que
ocurre
.


b.
Repita
el
experimento
,
pero
ahora
deje
que
el
primer
paquete
alcance
su
destino
y


elimine
el
primer
paquete
de
reconocimiento
.
Describa
lo
que
ocurre
.


c.
Para
terminar
,
pruebe
a
enviar
seis
paquetes
.
¬ø
Qu√©
ocurre
?


R13
.
Repita
el
problema
R12
,
pero
ahora
utilizando
el
applet
de
Java
con
repetici√≥n
selec-


tiva
(
SR
)
.
¬ø
En
qu√©
se
diferencian
los
protocolos
SR
y
GBN
?


SECCI√ìN
3.5


R14
.
¬ø
Verdadero
o
falso
?


a.
El
host
A
est√°
enviando
al
host
B
un
archivo
de
gran
tama√±o
a
trav√©s
de
una
cone-


xi√≥n
TCP
.
Suponga
que
el
host
B
no
tiene
datos
que
enviar
al
host
A.
El
host
B
no


enviar√°
paquetes
de
reconocimiento
al
host
A
porque
el
host
B
no
puede
superpo-


ner
esos
reconocimientos
sobre
los
datos
.
 

PROBLEMAS
Y
CUESTIONES
DE
REPASO
281


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
281b
.
El
tama√±o
de
la
ventana
de
recepci√≥n
de
TCP
nunca
var√≠a
mientras
dura
la
cone-


xi√≥n
.


c.
Suponga
que
el
host
A
est√°
enviando
al
host
B
un
archivo
de
gran
tama√±o
a
trav√©s


de
una
conexi√≥n
TCP
.
El
n√∫mero
de
bytes
no
reconocidos
que
A
env√≠a
no
puede


exceder
el
tama√±o
del
buffer
del
receptor
.


d.
Suponga
que
el
host
A
est√°
enviando
al
host
B
un
archivo
de
gran
tama√±o
a
trav√©s


de
una
conexi√≥n
TCP
.
Si
el
n√∫mero
de
secuencia
de
un
segmento
en
esta
conexi√≥n


es
m
,
entonces
el
n√∫mero
de
secuencia
del
siguiente
segmento
necesariamente
tiene


que
ser
m
+
1
.


e.
El
segmento
TCP
contiene
un
campo
en
su
cabecera
para
VentanaRecepcion
.


f.
Suponga
que
el
√∫ltimo
RTTMuestraen
una
conexi√≥n
TCP
es
igual
a
1
segundo
.
El


valor
actual
del
IntervaloFinDeTemporizaci√≥n
para
la
conexi√≥n
ser√°
necesa-


riamente
 
1
segundo
.


g.
Suponga
que
el
host
A
env√≠a
al
host
B
un
segmento
con
el
n√∫mero
de
secuencia
38


y
4
bytes
de
datos
a
trav√©s
de
una
conexi√≥n
TCP
.
En
este
mismo
segmento
el


n√∫mero
de
reconocimiento
necesariamente
tiene
que
ser
42
.


R15
.
Suponga
que
el
host
A
env√≠a
dos
segmentos
TCP
seguidos
al
host
B
a
trav√©s
de
una


conexi√≥n
TCP
.
El
primer
segmento
tiene
el
n√∫mero
de
secuencia
90
y
el
segundo
tiene


el
n√∫mero
de
secuencia
110
.


a.
¬ø
Cu√°ntos
datos
hay
en
el
primer
segmento
?


b.
Suponga
que
el
primer
segmento
se
pierde
pero
el
segundo
llega
a
B.
En
el
paquete


de
reconocimiento
que
el
host
B
env√≠a
al
host
A
,
¬ø
cu√°l
ser√°
el
n√∫mero
de
reconoci-


miento
?


R16
.
Considere
el
ejemplo
de
la
conexi√≥n
Telnet
de
la
Secci√≥n
3.5
.
Unos
pocos
segundos


despu√©s
de
que
el
usuario
escriba
la
letra
‚Äò
C
‚Äô
,
escribe
la
letra
‚Äò
R
‚Äô
.
Despu√©s
de
escribir


la
letra
‚Äò
R
‚Äô
,
¬ø
cu√°ntos
segmentos
se
env√≠an
y
qu√©
valores
se
almacenan
en
los
campos


n√∫mero
de
secuencia
y
n√∫mero
de
reconocimiento
de
los
segmentos
?


SECCI√ìN
3.7


R17
.
Suponga
que
existen
dos
conexiones
TCP
en
un
cierto
enlace
de
cuello
de
botella
con


una
velocidad
de
R
bps
.
Ambas
conexiones
tienen
que
enviar
un
archivo
de
gran


tama√±o
(
en
la
misma
direcci√≥n
a
trav√©s
del
enlace
de
cuello
de
botella
)
.
Las
transmi-


siones
de
los
archivos
se
inician
en
el
mismo
instante
.
¬ø
Qu√©
velocidad
de
transmisi√≥n


podr√≠a
proporcionar
TCP
a
cada
una
de
las
conexiones
?


R18
.
¬ø
Verdadero
o
falso
?
En
el
control
de
congesti√≥n
de
TCP
,
si
el
temporizador
del
emisor


caduca
,
el
valor
de
umbralse
hace
igual
a
la
mitad
de
su
valor
anterior
.


Problemas


P1
.
Suponga
que
el
cliente
A
inicia
una
sesi√≥n
Telnet
con
el
servidor
S.
Aproximadamente


en
el
mismo
instante
,
el
cliente
B
tambi√©n
inicia
una
sesi√≥n
Telnet
con
el
servidor
S.


Proporcione
los
posibles
n√∫meros
de
puerto
de
origen
y
de
destino
para
:


282
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
282a
.
Los
segmentos
enviados
de
A
a
S.


b.
Los
segmentos
enviados
de
B
a
S.


c.
Los
segmentos
enviados
de
S
a
A.


d.
Los
segmento
enviados
de
S
a
B.


e.
Si
A
y
B
son
hosts
diferentes
,
¬ø
es
posible
que
el
n√∫mero
de
puerto
de
origen
en
los


segmentos
que
van
de
A
a
S
sea
el
mismo
que
en
los
segmentos
que
van
de
B
a
S
?


f.
¬ø
Qu√©
ocurre
si
A
y
B
son
el
mismo
host
?


P2
.
Considere
la
Figura
3.5
.
¬ø
Cu√°les
son
los
valores
de
los
puertos
de
origen
y
de
destino


en
los
segmentos
que
fluyen
desde
el
servidor
de
vuelta
a
los
procesos
cliente
?
¬ø
Cu√°-


les
son
las
direcciones
IP
de
los
datagramas
de
la
capa
de
red
que
transportan
los
seg-


mentos
de
la
capa
de
transporte
?


P3
.
UDP
y
TCP
utilizan
el
complemento
a
1
para
calcular
sus
sumas
de
comprobaci√≥n
.


Suponga
 
que
tiene
los
tres
bytes
de
8
bits
siguientes
:
01010011
,
01010100
,
01110100
.


¬ø
Cu√°l
es
el
complemento
a
1
de
la
suma
de
estos
bytes
?
(
Observe
que
aunque
UDP
y


TCP
utilizan
palabras
de
16
bits
para
calcular
la
suma
de
comprobaci√≥n
,
en
este
pro-


blema
le
pedimos
que
considere
sumas
de
8
bits
)
.
Explique
c√≥mo
funciona
.
¬ø
Por
qu√©


UDP
utiliza
el
complemento
a
1
de
la
suma
;
es
decir
,
por
qu√©
no
simplemente
emplea


la
suma
?
Con
el
esquema
del
complemento
a
1
,
¬ø
c√≥mo
detecta
el
receptor
los
errores
?


¬ø
Es
posible
que
un
error
de
un
solo
bit
no
sea
detectado
?
¬ø
Qu√©
ocurre
si
hay
2
bits


err√≥neos
?


P4
.
a.
Suponga
que
tiene
los
2
bytes
siguientes
:
01011100
y
01010110
.
¬ø
Cu√°l
es
el
com-


plemento
a
1
de
la
suma
de
estos
2
bytes
?


b.
Suponga
que
tiene
los
2
bytes
siguientes
:
11011010
y
00110110
.
¬ø
Cu√°l
es
el
com-


plemento
a
1
de
la
suma
de
estos
2
bytes
?


c.
Para
los
bytes
del
apartado
(
a
)
,
proporcione
un
ejemplo
en
el
que
un
bit
cambie
de


valor
en
cada
uno
de
los
2
bytes
y
a√∫n
as√≠
el
complemento
a
1
no
var√≠e
.


P5
.
Suponga
que
el
receptor
UDP
calcula
la
suma
de
comprobaci√≥n
de
Internet
para
el


segmento
UDP
recibido
y
comprueba
que
se
corresponde
con
el
valor
almacenado
en


el
campo
de
suma
de
comprobaci√≥n
.
¬ø
Puede
el
receptor
estar
completamente
seguro


de
que
no
hay
ning√∫n
bit
err√≥neo
?
Explique
su
respuesta
.


P6
.
Recuerde
el
motivo
de
corregir
el
protocolo
rdt2.1
.
Demuestre
que
el
receptor
mos-


trado
en
la
Figura
3.57
y
el
emisor
mostrado
en
la
Figura
3.11
pueden
llegar
a
entrar


en
un
estado
de
bloqueo
tal
que
cada
uno
de
ellos
est√©
esperando
a
que
se
produzca
un


suceso
que
no
ocurrir√°
nunca
.


P7
.
En
el
protocolo
rdt3.0
,
los
paquetes
ACK
que
fluyen
del
receptor
al
emisor
no
tie-


nen
n√∫meros
de
secuencia
(
aunque
tienen
un
campo
ACK
que
contiene
el
n√∫mero
de


secuencia
del
paquete
que
est√°n
reconociendo
)
.
¬ø
Por
qu√©
estos
paquetes
ACK
no


requieren
n√∫meros
de
secuencia
?


P8
.
Dibuje
la
m√°quina
de
estados
finitos
correspondiente
al
lado
receptor
del
protocolo


rdt3.0
.


PROBLEMAS
283


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
283P9
.
Dibuje
un
esquema
que
muestre
la
operaci√≥n
del
protocolo
rdt3.0cuando
los
paque-


tes
de
datos
y
los
paquetes
de
reconocimiento
est√°n
corrompidos
.
Utilice
un
esquema


similar
al
mostrado
en
la
Figura
3.16
.


P10
.
Sea
un
canal
que
puede
perder
paquetes
pero
del
que
se
conoce
su
retardo
m√°ximo
.


Modifique
el
protocolo
rdt2.1
para
incluir
los
fines
de
temporizaci√≥n
y
las
retrans-


misiones
del
emisor
.
Argumente
de
manera
informal
por
qu√©
su
protocolo
puede


comunicarse
correctamente
a
trav√©s
de
este
canal
.


P11
.
El
lado
del
emisor
de
rdt3.0
simplemente
ignora
(
es
decir
,
no
realiza
ninguna


acci√≥n
)
todos
los
paquetes
recibidos
que
contienen
un
error
o
que
presentan
un
valor


err√≥neo
en
el
campo
n√∫mero
de
reconocimiento
(
acknum
)
de
un
paquete
de
reconoci-


miento
.
Suponga
que
,
en
tales
circunstancias
,
rdt3.0
simplemente
retransmite
el


paquete
de
datos
actual
.
¬ø
Funcionar√≠a
en
estas
condiciones
el
protocolo
?
(
Sugerencia
:


piense
en
lo
que
ocurrir√≠a
si
s√≥lo
hubiera
errores
de
bit
;
no
se
producen
p√©rdidas
de


paquetes
pero
s√≠
pueden
ocurrir
sucesos
de
fin
prematuro
de
la
temporizaci√≥n
.
Consi-


dere
cu√°ntas
veces
se
env√≠a
el
paquete
n
,
cuando
n
tiende
a
infinito
.
)


P12
.
Considere
el
protocolo
rdt
3.0
.
Dibuje
un
diagrama
que
muestre
que
si
la
cone-


xi√≥n
de
red
entre
el
emisor
y
el
receptor
puede
reordenar
los
mensajes
(
es
decir
,
que


dos
mensajes
que
se
propagan
por
el
medio
f√≠sico
existente
entre
el
emisor
y
el


receptor
pueden
ser
reordenados
)
,
entonces
el
protocolo
de
bit
alternante
no
fun-


cionar√°
correctamente
(
aseg√∫rese
de
identificar
claramente
el
sentido
en
el
que
no


funcionar√°
correctamente
)
.
En
el
diagrama
debe
colocar
el
emisor
a
la
izquierda
y


el
receptor
a
la
derecha
,
con
el
eje
de
tiempos
en
la
parte
inferior
de
la
p√°gina


284
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


Esperar
0


de
la
capa


inferior


rdt_recibir(pqtrcb
)
&
&


(
corrupto(pqtrcb)||


tiene_sec0(pqtrcb
)
)
)


calcular
sumacomprobacion


crear_paquete(pqtenv
,

    
NAK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&


(
corrupto(pqtrcb)||


tiene_sec1(pqtrcb
)
)
)


calcular
sumacomprobacion


crear_paquete(pqtenv
,
NAK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)


&
&
tiene_sec1(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


calcular
sumacomprobacion


crear_paquete(pqtenv
,
ACK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


rdt_recibir(pqtrcb
)
&
&
nocorrupto(pqtrcb
)


&
&
tiene_sec0(pqtrcb
)


extraer(pqtrcb
,
datos
)


entregar_datos(datos
)


calcular
sumacomprobacion


crear_paquete(pqtenv
,
ACK
,
sumacomprobacion
)


udt_enviar(pqtenv
)


Esperar
1


de
la
capa


inferior


Figura
3.57
‚Ä¢
Un
receptor
incorrecto
para
el
protocolo
rdt2.1
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
284y
deber√°
mostrar
el
intercambio
de
los
mensajes
de
datos
(
D
)
y
de
reconocimiento


(
A
)
.
No
olvide
indicar
el
n√∫mero
de
secuencia
asociado
con
cualquier
segmento
de


datos
o
de
reconocimiento
.


P13
.
Considere
un
protocolo
de
transferencia
de
datos
fiable
que
s√≥lo
utiliza
paquetes
de


reconocimiento
negativo
.
Imagine
que
el
emisor
env√≠a
datos
con
muy
poca
frecuen-


cia
.
¬ø
Ser√≠a
preferible
un
protocolo
con
solo
emplea
paquetes
NAK
a
uno
que
utilice


paquetes
ACK
?
¬ø
Por
qu√©
?
Suponga
ahora
que
el
emisor
tiene
muchos
datos
que
trans-


mitir
y
que
la
conexi√≥n
terminal
a
terminal
experimenta
muy
pocas
p√©rdidas
.
En
este


segundo
caso
,
¬ø
ser√≠a
preferible
un
protocolo
que
s√≥lo
emplee
paquetes
NAK
a
otro


que
utilice
paquetes
ACK
?
¬ø
Por
qu√©
?


P14
.
Considere
el
ejemplo
mostrado
en
la
Figura
3.17
.
¬ø
Cu√°l
tiene
que
ser
el
tama√±o
de
la


ventana
para
que
la
tasa
de
utilizaci√≥n
del
canal
sea
mayor
del
95
por
ciento
?
Suponga


que
el
tama√±o
de
un
paquete
es
de
1.500
bytes
,
incluyendo
tanto
los
campos
de
cabe-


cera
como
los
datos
.


P15
.
Suponga
que
una
aplicaci√≥n
utiliza
el
protocolo
rdt3.0
como
su
protocolo
de
la
capa


de
transporte
.
Como
el
protocolo
de
parada
y
espera
tiene
una
tasa
de
utilizaci√≥n
del


canal
muy
baja
(
como
se
ha
demostrado
en
el
ejemplo
de
conexi√≥n
que
atraviesa
el


pa√≠s
de
costa
a
costa
)
,
los
dise√±adores
de
esta
aplicaci√≥n
permiten
al
receptor
devolver


una
serie
(
m√°s
de
dos
)
de
ACK
0
y
ACK
1
alternantes
incluso
si
los
correspondientes


datos
no
han
llegado
al
receptor
.
¬ø
Deber√≠a
este
dise√±o
aumentar
la
tasa
de
utilizaci√≥n


del
canal
?
¬ø
Por
qu√©
?
¬ø
Existe
alg√∫n
problema
potencial
con
esta
t√©cnica
?
Explique
su


respuesta
.
 

P16
.
En
el
protocolo
SR
gen√©rico
que
hemos
estudiado
en
la
Secci√≥n
3.4.4
,
el
emisor
trans-


mite
un
mensaje
tan
pronto
como
est√°
disponible
(
si
se
encuentra
dentro
de
la
ventana
)


sin
esperar
a
recibir
un
paquete
de
reconocimiento
.
Suponga
ahora
que
deseamos
dis-


poner
de
un
protocolo
SR
que
env√≠e
mensajes
de
dos
en
dos
.
Es
decir
,
el
emisor


enviar√°
una
pareja
de
mensajes
y
enviar√°
la
siguiente
pareja
de
mensajes
solo
cuando


sepa
que
los
dos
mensajes
de
la
primera
pareja
se
han
recibido
correctamente
.


Suponga
que
el
canal
puede
perder
mensajes
pero
no
corromperlos
ni
tampoco
reorde-


narlos
.
Dise√±e
un
protocolo
de
control
de
errores
para
un
servicio
de
transferencia
de


mensajes
fiable
y
unidireccional
.
Proporcione
una
descripci√≥n
de
las
m√°quinas
de


estados
finitos
del
emisor
y
del
receptor
.
Describa
el
formato
de
los
paquetes
inter-


cambiados
por
el
emisor
y
el
receptor
.
Si
utiliza
alguna
llamada
a
procedimiento
dis-


tinta
de
las
empleadas
en
la
Secci√≥n
3.4
(
por
ejemplo
,
udt_enviar
(
)
,
iniciar
_


temporizador
(
)
,
rdt_recibir
(
)
,
etc.
)
,
defina
claramente
las
acciones
que
reali-


zan
.
Proporcione
un
ejemplo
(
una
gr√°fica
temporal
del
emisor
y
del
receptor
)
que


muestre
c√≥mo
este
protocolo
se
recupera
de
la
p√©rdida
de
paquetes
.


P17
.
Considere
un
escenario
en
el
que
el
host
A
desea
enviar
simult√°neamente
paquetes
a


los
hosts
B
y
C.
El
host
A
est√°
conectado
a
B
y
C
a
trav√©s
de
un
canal
de
multidifusi√≥n


(
broadcast
)
(
un
paquete
enviado
por
A
es
transportado
por
el
canal
tanto
a
B
como
a


C
)
.
Suponga
que
el
canal
de
multidifusi√≥n
que
conecta
A
,
B
y
C
puede
perder
y


corromper
de
manera
independiente
los
paquetes
(
es
decir
,
puede
ocurrir
,
por
ejemplo
,


que
un
paquete
enviado
desde
A
llegue
correctamente
a
B
,
pero
no
a
C
)
.
Dise√±e
un


protocolo
de
control
de
errores
similar
a
un
protocolo
de
parada
y
espera
que
permita


PROBLEMAS
285


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
285transferir
paquetes
de
forma
fiable
de
A
a
B
y
C
,
de
manera
que
A
no
obtendr√°
nuevos


datos
de
la
capa
superior
hasta
que
separa
que
tanto
B
como
C
han
recibido
correcta-


mente
el
paquete
actual
.
Proporcione
las
descripciones
de
las
m√°quinas
de
estados


finitos
de
A
y
C.
(
Sugerencia
:
la
FSM
de
B
ser√°
pr√°cticamente
la
misma
que
la
de
C.
)


Proporcione
tambi√©n
una
descripci√≥n
del
formato
o
formatos
de
paquete
utilizados
.


P18
.
Considere
un
escenario
en
el
que
el
host
A
y
el
host
B
desean
enviar
mensajes
al
host


C.
Los
hosts
A
y
C
est√°n
conectados
mediante
un
canal
que
puede
perder
y
corromper


(
pero
no
reordenar
)
los
mensajes
.
Los
hosts
B
y
C
est√°n
conectados
a
trav√©s
de
otro


canal
(
independiente
del
canal
que
conecta
a
A
y
C
)
que
tiene
las
mismas
propiedades
.


La
capa
de
transporte
del
host
C
tiene
que
alternar
la
entrega
de
los
mensajes
que
A
y


B
tienen
que
pasar
a
la
capa
superior
(
es
decir
,
primero
entrega
los
datos
de
un
paquete


de
A
y
luego
los
datos
de
un
paquete
de
B
,
y
as√≠
sucesivamente
)
.
Dise√±e
un
protocolo


de
control
de
errores
de
tipo
parada
y
espera
para
transferir
de
forma
fiable
los
paque-


tes
de
A
y
B
a
C
,
con
una
entrega
alternante
en
el
host
C
,
como
hemos
descrito
ante-


riormente
.
Proporcione
las
descripciones
de
las
FSM
de
A
y
C.
(
Sugerencia
:
la
FSM


de
B
ser√°
pr√°cticamente
la
misma
que
la
de
A.
)
Proporcione
tambi√©n
una
descripci√≥n


del
formato
o
formatos
de
paquete
utilizados
.


P19
.
Sea
un
protocolo
GBN
con
una
ventana
de
emisor
de
3
y
un
rango
de
n√∫meros
de


secuencia
de
1.024
.
Suponga
que
en
el
instante
t
el
siguiente
paquete
en
orden
que
el


receptor
est√°
esperando
tiene
el
n√∫mero
de
secuencia
k.
Suponga
que
el
medio
de


transmisi√≥n
no
reordena
los
mensajes
.
Responda
a
las
siguientes
cuestiones
:


a.
¬ø
Cu√°les
son
los
posibles
conjuntos
de
n√∫meros
de
secuencia
que
pueden
estar
den-


tro
de
la
ventana
del
emisor
en
el
instante
t
?
Justifique
su
respuesta
.


b.
¬ø
Cu√°les
son
todos
los
valores
posibles
del
campo
ACK
en
todos
los
posibles
men-


sajes
que
est√°n
actualmente
propag√°ndose
de
vuelta
al
emisor
en
el
instante
t
?
Jus-


tifique
su
respuesta
.


P20
.
Suponga
que
tenemos
dos
entidades
de
red
,
A
y
B.
B
tiene
que
enviar
a
A
un
conjunto


de
mensajes
de
datos
,
cumpliendo
los
siguientes
convenios
.
Cuando
A
recibe
una
soli-


citud
de
la
capa
superior
para
obtener
el
siguiente
mensaje
de
datos
(
D
)
de
B
,
A
tiene


que
enviar
un
mensaje
de
solicitud
(
R
)
a
B
a
trav√©s
del
canal
que
va
de
A
a
B.
S√≥lo


cuando
B
recibe
un
mensaje
R
puede
devolver
un
mensaje
de
datos
(
D
)
a
A
a
trav√©s


del
canal
de
B
a
A.
A
tiene
que
entregar
exactamente
una
copia
de
cada
mensaje
D
a
la


capa
superior
.
Los
mensajes
R
se
pueden
perder
(
pero
no
corromper
)
en
el
canal
de
A


a
B
;
los
mensajes
D
,
una
vez
enviados
,
siempre
son
correctamente
entregados
.
El


retardo
a
lo
largo
de
ambos
canales
es
desconocido
y
variable
.


Dise√±e
(
proporcione
una
descripci√≥n
de
la
FSM
de
)
un
protocolo
que
incorpore
los


mecanismos
apropiados
para
compensar
las
p√©rdidas
del
canal
de
A
a
B
e
implemente


el
paso
de
los
mensajes
a
la
capa
superior
de
la
entidad
A
,
como
se
ha
explicado
ante-


riormente
.
Utilice
s√≥lo
aquellos
mecanismos
que
sean
absolutamente
necesarios
.


P21
.
Considere
los
protocolos
GBN
y
SR
.
Suponga
que
el
tama√±o
del
espacio
de
n√∫meros


de
secuencia
es
k.
¬ø
Cu√°l
es
la
m√°xima
v
entana
de
emisor
permitida
que
evitar√°
la


ocurrencia
de
problemas
como
los
indicados
en
la
Figura
3.27
para
cada
uno
de


estos
protocolos
?


286
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
286P22
.
Responda
verdadero
o
falso
a
las
siguientes
preguntas
y
justifique
brevemente
sus
res-


puestas
:


a.
Con
el
protocolo
SR
,
el
emisor
puede
recibir
un
ACK
para
un
paquete
que
se


encuentra
fuera
de
su
ventana
actual
.


b.
Con
GBN
,
el
emisor
puede
recibir
un
ACK
para
un
paquete
que
se
encuentra
fuera


de
su
ventana
actual
.


c.
El
protocolo
de
bit
alternante
es
igual
que
el
protocolo
SR
pero
con
un
tama√±o
de


ventana
en
el
emisor
y
en
el
receptor
igual
a
1
.


d.
El
protocolo
de
bit
alternante
es
igual
que
el
protocolo
GBN
pero
con
un
tama√±o


de
ventana
en
el
emisor
y
en
el
receptor
igual
a
1
.


P23
.
Hemos
dicho
que
una
aplicaci√≥n
puede
elegir
UDP
como
protocolo
de
transporte
por-


que
UDP
ofrece
a
la
aplicaci√≥n
un
mayor
grado
de
control
(
que
TCP
)
en
lo
relativo
a


qu√©
datos
se
env√≠an
en
un
segmento
y
cu√°ndo
.


a.
¬ø
Por
qu√©
una
aplicaci√≥n
tiene
m√°s
control
sobre
qu√©
datos
se
env√≠an
en
un
segmento
?


b.
¬ø
Por
qu√©
una
aplicaci√≥n
tiene
m√°s
control
sobre
cu√°ndo
se
env√≠a
el
segmento
?


P24
.
Se
desea
transferir
un
archivo
de
gran
tama√±o
de
L
bytes
del
host
A
al
host
B.
Suponga


un
MSS
de
536
bytes
.


a.
¬ø
Cu√°l
es
el
valor
m√°ximo
de
L
tal
que
los
n√∫meros
de
secuencia
de
TCP
no
se
ago-


ten
?
Recuerde
que
el
campo
n√∫mero
de
secuencia
de
TCP
tiene
4
bytes
.


b.
Para
el
valor
de
L
que
haya
obtenido
en
el
apartado
(
a
)
,
calcule
el
tiempo
que
tarda


en
transmitirse
el
archivo
.
Suponga
que
a
cada
segmento
se
a√±ade
un
total
de
66


bytes
para
la
cabecera
de
la
capa
de
transporte
,
de
red
y
de
enlace
de
datos
antes
de


enviar
el
paquete
resultante
a
trav√©s
de
un
enlace
a
155
Mbps
.
Ignore
el
control
de


flujo
y
el
control
de
congesti√≥n
de
modo
que
A
pueda
bombear
los
segmentos


seguidos
y
de
forma
continuada
.


P25
.
Los
hosts
A
y
B
est√°n
comunic√°ndose
a
trav√©s
de
una
conexi√≥n
TCP
y
el
host
B
ya
ha


recibido
de
A
todos
los
bytes
hasta
el
byte
126
.
Suponga
que
a
continuaci√≥n
el
host
A


env√≠a
dos
segmentos
seguidos
al
host
B.
El
primer
y
el
segundo
segmentos
contienen
,


respectivamente
,
70
y
50
bytes
de
datos
.
En
el
primer
segmento
,
el
n√∫mero
de
secuen-


cia
es
127
,
el
n√∫mero
del
puerto
de
origen
es
302
y
el
n√∫mero
de
puerto
de
destino
es


80
.
El
host
B
env√≠a
un
paquete
de
reconocimiento
cuando
recibe
un
segmento
del
host


A.


a.
En
el
segundo
segmento
enviado
del
host
A
al
B
,
¬ø
Cu√°les
son
el
n√∫mero
de
secuen-


cia
,
el
n√∫mero
del
puerto
de
origen
y
el
n√∫mero
del
puerto
de
destino
?


b.
Si
el
primer
segmento
llega
antes
que
el
segundo
segmento
,
¬ø
cu√°l
es
el
n√∫mero
de


reconocimiento
,
el
n√∫mero
del
puerto
de
origen
y
el
n√∫mero
del
puerto
de
destino


en
el
ACK
correspondiente
al
primer
segmento
?


c.
Si
el
segundo
segmento
llega
antes
que
el
primero
,
¬ø
cu√°l
es
el
n√∫mero
de
recono-


cimiento
en
el
ACK
correspondiente
al
primer
segmento
?


d.
Suponga
que
los
dos
segmentos
enviados
por
A
llegan
en
orden
a
B.
El
primer


paquete
de
reconocimiento
se
pierde
y
el
segundo
llega
despu√©s
de
transcurrido
el


primer
intervalo
de
fin
de
temporizaci√≥n
.
Dibuje
un
diagrama
de
temporizaci√≥n
que


PROBLEMAS
287


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
287muestre
estos
segmentos
y
todos
los
restantes
segmentos
y
paquetes
de
reconoci-


miento
enviados
.
(
Suponga
que
no
se
producen
p√©rdidas
de
paquetes
adicionales
.
)


para
cada
uno
de
los
segmentos
que
incluya
en
su
diagrama
,
especifique
el
n√∫mero


de
secuencia
y
el
n√∫mero
de
bytes
de
datos
;
para
cada
uno
de
los
paquetes
de
reco-


nocimiento
que
a√±ada
,
proporcione
el
n√∫mero
de
reconocimiento
.


P26
.
Los
hosts
A
y
B
est√°n
directamente
conectados
mediante
un
enlace
a
100
Mbps
.
Existe


una
conexi√≥n
TCP
entre
los
dos
hosts
y
el
host
A
est√°
transfiriendo
al
host
B
una


archivo
de
gran
tama√±o
a
trav√©s
de
esta
conexi√≥n
.
El
host
A
puede
enviar
sus
datos
de


la
capa
de
aplicaci√≥n
a
su
socket
TCP
a
una
velocidad
tan
alta
como
120
Mbps
pero
el


host
B
s√≥lo
puede
leer
los
datos
almacenados
en
su
buffer
de
recepci√≥n
TCP
a
una


velocidad
m√°xima
de
60
Mbps
.
Describa
el
efecto
del
control
de
flujo
de
TCP
.


P27
.
En
la
Secci√≥n
3.5.6
se
han
estudiado
las
cookies
SYN
.


a.
¬ø
Por
qu√©
es
necesario
que
el
servidor
utilice
un
n√∫mero
de
secuencia
inicial
espe-


cial
en
SYNACK
?


b.
Suponga
que
un
atacante
sabe
que
un
host
objetivo
utiliza
cookies
SYN
.
¬ø
Puede
el


atacante
crear
conexiones
semi-abiertas
o
completamente
abiertas
enviando
sim-


plemente
un
paquete
ACK
al
host
objetivo
?
¬ø
Por
qu√©
?


c.
Suponga
que
un
atacante
recopila
una
gran
cantidad
de
n√∫meros
de
secuencia
ini-


ciales
enviados
por
el
servidor
.
¬ø
Puede
el
atacante
hacer
que
el
servidor
cree


muchas
conexiones
completamente
abiertas
enviando
paquetes
ACK
con
esos


n√∫meros
de
secuencia
iniciales
?
¬ø
Por
qu√©
?


P28
.
Considere
la
red
mostrada
en
el
escenario
2
de
la
Secci√≥n
3.6.1
.
Suponga
que
ambos


hosts
emisores
A
y
B
tienen
definidos
valores
de
fin
de
temporizaci√≥n
fijos
.


a.
Demuestre
que
aumentar
el
tama√±o
del
buffer
finito
del
router
puede
llegar
a
hacer


que
se
reduzca
la
tasa
de
transferencia
(
/H9261out
)
.


b.
Suponga
ahora
que
ambos
hosts
ajustan
din√°micamente
su
valores
de
fin
de
tempo-


rizaci√≥n
(
como
lo
hace
TCP
)
bas√°ndose
en
el
retardo
del
buffer
del
router
.
¬ø
Incre-


mentar
el
tama√±o
del
buffer
ayudar√≠a
a
incrementar
la
tasa
de
transferencia
?
¬ø
Por


qu√©
?


P29
.
Considere
el
procedimiento
de
TCP
para
estimar
RTT
.
Suponga
que
/H9251=
0,1
.
Sea
RTT-


Muestra1
la
muestra
de
RTT
m√°s
reciente
,
RTTMuestra2
la
siguiente
muestra
de


RTT
m√°s
reciente
,
y
as√≠
sucesivamente
.


a.
Para
una
conexi√≥n
TCP
determinada
,
suponga
que
han
sido
devueltos
cuatro


paquetes
de
reconocimiento
con
las
correspondientes
muestras
de
RTT
,
RTTMues-


tra4
,
RTTMuestra3
,
RTTMuestra2
y
RTTMuestra1
.
Exprese
RTTEstimado
en


funci√≥n
de
las
cuatro
muestras
de
RTT
.


b.
Generalize
la
f√≥rmula
para
n
muestras
de
RTT
.


c.
En
la
f√≥rmula
del
apartado
(
b
)
,
considere
que
n
tiende
a
infinito
.
Explique
por
qu√©


este
procedimiento
de
c√°lculo
del
promedio
se
conoce
como
media
m√≥vil
exponen-


cial
.


288
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


P30
.
En
la
Secci√≥n
3.5.3
,
se
ha
estudiado
la
estimaci√≥n
de
RTT
en
TCP
.
¬ø
Por
qu√©
cree
que


TCP
evita
medir
RTTMuestrapara
los
segmentos
retransmitidos
?


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
288P31
.
¬ø
Cu√°l
es
la
relaci√≥n
entre
la
variable
EnviarBase
de
la
Secci√≥n
3.5.4
y
la
variable


UltimoByteRecibidode
la
Secci√≥n
3.5.5
?


P32
.
¬ø
Cu√°l
es
la
relaci√≥n
entre
la
variable
UltimoByteRecibido
de
la
Secci√≥n
3.5.5
y
la


variable
yde
la
Secci√≥n
3.5.4
?


P33
.
En
la
Secci√≥n
3.5.4
hemos
visto
que
TCP
espera
hasta
que
ha
recibido
tres
ACK
dupli-


cados
antes
de
realizar
una
retransmisi√≥n
r√°pida
.
¬ø
Por
qu√©
cree
que
los
dise√±adores
de


TCP
han
decidido
no
realizar
una
retransmisi√≥n
r√°pida
despu√©s
de
recibir
el
primer


ACK
duplicado
correspondiente
a
un
segmento
?


P34
.
Compare
GBN
,
SR
y
TCP
(
sin
paquetes
ACK
retardados
)
.
Suponga
que
los
valores
de


fin
de
temporizaci√≥n
de
los
tres
protocolos
son
los
suficientemente
grandes
como
para


que
5
segmentos
de
datos
consecutivos
y
sus
correspondientes
ACK
puedan
ser
reci-


bidos
(
si
no
se
producen
p√©rdidas
en
el
canal
)
por
el
host
receptor
(
host
B
)
y
el
host


emisor
host
(
host
A
)
,
respectivamente
.
Suponga
que
el
host
A
env√≠a
5
segmentos
de


datos
al
host
B
y
que
el
segundo
segmento
(
enviado
desde
A
)
se
pierde
.
Al
final
,
los
5


segmentos
de
datos
han
sido
recibidos
correctamente
por
el
host
B.


a.
¬ø
Cu√°ntos
segmentos
ha
enviado
en
total
el
host
A
y
cuantos
ACK
ha
enviado
en


total
el
host
B
?
¬ø
Cu√°les
son
sus
n√∫meros
de
secuencia
?
Responda
a
esta
pregunta


para
los
tres
protocolos
.


b.
Si
los
valores
de
fin
de
temporizaci√≥n
para
los
tres
protocolos
son
mucho
mayores


que
5
RTT
,
¬ø
qu√©
protocolo
entregar√°
correctamente
los
cinco
segmentos
de
datos


en
el
menor
intervalo
de
tiempo
?


P35
.
En
la
descripci√≥n
de
TCP
de
la
Figura
3.53
,
el
valor
del
umbral
se
define
como


umbral
=
VentanaCongestion/2
en
varios
sitios
y
el
valor
de
umbral
se
hace


igual
a
la
mitad
del
tama√±o
de
la
ventana
cuando
se
produce
un
suceso
de
p√©rdida
.


¬ø
Tiene
que
ser
la
velocidad
a
la
que
el
emisor
est√°
transmitiendo
cuando
se
produce


un
suceso
de
p√©rdida
aproximadamente
igual
a
VentanaCongestion
segmentos


por
RTT
?
Explique
su
respuesta
.
Si
su
respuesta
es
no
,
¬ø
puede
sugerir
una
forma


diferente
en
la
que
se
podr√≠a
fijar
el
valor
de
umbral
?


P36
.
Considere
la
Figura
3.46(b
)
.
Si
/H9261
/
H11032
in
aumenta
por
encima
de
R/2
,
¬ø
puede
/H9261out
incremen-


tarse
por
encima
de
R/3
?
Explique
su
respuesta
.
Considere
ahora
la
Figura
3.46(c
)
.
Si


/H9261
/
H11032
in
aumenta
por
encima
de
R/2
,
¬ø
puede
/H9261out
aumentar
por
encima
de
R/4
suponiendo


que
un
paquete
ser√°
reenviado
dos
veces
como
media
desde
el
router
al
receptor
?


Explique
su
respuesta
.


P37
.
Considere
la
Figura
3.58
.


Suponiendo
que
TCP
Reno
es
el
protocolo
que
presenta
el
comportamiento
mostrado


en
la
figura
,
responda
a
las
siguientes
preguntas
.
En
todos
los
casos
,
deber√°
proporcio-


nar
una
breve
explicaci√≥n
que
justifique
su
respuesta
.


a.
Identifique
los
intervalos
de
tiempo
cuando
TCP
est√°
operando
en
el
modo
de


arranque
lento
.


b.
Identifique
los
intervalos
de
tiempo
cuando
TCP
est√°
operando
en
el
modo
de
evi-


taci√≥n
de
la
congesti√≥n
.


PROBLEMAS
289


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
289c
.
Despu√©s
del
ciclo
de
transmisi√≥n
16
,
¬ø
se
detecta
la
p√©rdida
de
segmento
mediante


tres
ACK
duplicados
o
mediante
un
fin
de
temporizaci√≥n
?


d.
Despu√©s
del
ciclo
de
transmisi√≥n
22
,
¬ø
se
detecta
la
p√©rdida
de
segmento
mediante


tres
ACK
duplicados
o
mediante
un
fin
de
temporizaci√≥n
?


e.
¬ø
Cu√°l
es
el
valor
inicial
de
umbralen
el
primer
ciclo
de
transmisi√≥n
?


f.
¬ø
Cu√°l
es
el
valor
de
umbraltranscurridos
18
ciclos
de
transmisi√≥n
?


g.
¬ø
Cu√°l
es
el
valor
de
umbraltranscurridos
24
ciclos
de
transmisi√≥n
?


h.
¬ø
Durante
cu√°l
ciclo
de
transmisi√≥n
se
env√≠a
el
segmento
70
?


i.
Suponiendo
que
se
detecta
una
p√©rdida
de
paquete
despu√©s
del
ciclo
de
transmisi√≥n


26
a
causa
de
la
recepci√≥n
de
un
triple
ACK
duplicado
,
¬ø
cu√°les
ser√°n
los
valores


del
tama√±o
de
la
ventana
de
congesti√≥n
y
de
umbral
?


j.
Suponga
que
se
utiliza
TCP
Tahoe
(
en
lugar
de
TCP
Reno
)
y
que
se
han
recibido


triples
ACK
duplicados
en
el
ciclo
de
transmisi√≥n
16
.
¬ø
Cu√°les
ser√°n
los
valores
del


tama√±o
de
la
ventana
de
congesti√≥n
y
de
umbralen
el
ciclo
de
transmisi√≥n
19
?
 

k.
Suponga
otra
vez
que
se
utiliza
TCP
Tahoe
y
que
se
produce
un
suceso
de
fin
de


temporizaci√≥n
en
el
ciclo
de
transmisi√≥n
22
.
¬ø
Cu√°ntos
paquetes
han
sido
enviados


entre
los
ciclos
de
transmisi√≥n
17
a
22
,
ambos
inclusive
?


P38
.
Utilice
la
Figura
3.56
,
que
ilustra
la
convergencia
del
algoritmo
AIMD
de
TCP
.


Suponga
que
en
lugar
de
un
decrecimiento
multiplicativo
,
TCP
disminuye
el
tama√±o


de
la
ventana
en
una
cantidad
constante
.
¬ø
Converger√≠a
el
algoritmo
AIAD
resultante


hacia
un
algoritmo
de
cuota
equitativa
?
Justifique
su
respuesta
utilizando
un
diagrama


similar
al
de
la
Figura
3.56
.


P39
.
En
la
Secci√≥n
3.5.4
,
hemos
explicado
que
el
intervalo
de
fin
de
temporizaci√≥n
se


duplica
despu√©s
de
un
suceso
de
fin
de
temporizaci√≥n
.
Este
mecanismos
es
una
forma


290
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


0


0
2
4
6
8
10
12


Ciclo
de
transmisi√≥n


14
16
18
20
22
24
26


5


10


15


20


25


Tama√±o
de
la
ventana
de
congesti√≥n
(
segmentos
)


30


35


40


45


Figura
3.58
‚Ä¢
Tama√±o
de
ventana
de
TCP
en
funci√≥n
del
tiempo
.


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
290de
control
de
congesti√≥n
.
¬ø
Por
qu√©
TCP
necesita
un
mecanismo
de
control
de
conges-


ti√≥n
basado
en
ventana
(
como
hemos
estudiado
en
la
Secci√≥n
3.7
)
adem√°s
de
un


mecanismo
de
duplicaci√≥n
del
intervalo
de
fin
de
temporizaci√≥n
?


P40
.
El
host
A
est√°
enviando
un
archivo
de
gran
tama√±o
al
host
B
a
trav√©s
de
una
conexi√≥n


TCP
.
En
esta
conexi√≥n
nunca
se
pierden
paquetes
y
los
temporizadores
nunca
cadu-


can
.
La
velocidad
de
transmisi√≥n
del
enlace
que
conecta
el
host
A
con
Internet
es
R


bps
.
Suponga
que
el
proceso
del
host
A
es
capaz
de
enviar
datos
a
su
socket
TCP
a
una


velocidad
de
S
bps
,
donde
S
=
10
¬∑
R.
Suponga
tambi√©n
que
el
buffer
de
recepci√≥n
de


TCP
es
lo
suficientemente
grande
como
para
almacenar
el
archivo
completo
y
que
el


buffer
emisor
s√≥lo
puede
almacenar
un
porcentaje
del
archivo
.
¬ø
Qu√©
impide
al
proceso


del
host
A
pasar
datos
de
forma
continua
a
su
socket
TCP
a
una
velocidad
de
S
bps
?


¬ø
El
mecanismo
de
control
de
flujo
de
TCP
,
el
mecanismo
de
control
de
congesti√≥n
de


TCP
o
alguna
otra
cosa
?
Razone
su
respuesta
.


P41
.
Se
env√≠a
un
archivo
de
gran
tama√±o
de
un
host
a
otro
a
trav√©s
de
una
conexi√≥n
TCP


sin
p√©rdidas
.


a.
Suponga
que
TCP
utiliza
el
algoritmo
AIMD
para
su
control
de
congesti√≥n
sin
fase


de
arranque
lento
.
Suponiendo
que
VentanaCongestion
aumenta
1
MSS
cada


vez
que
se
recibe
un
lote
de
paquetes
ACK
y
suponiendo
que
los
intervalos
RTT


son
aproximadamente
constantes
,
¬ø
Cu√°nto
tiempo
tarda
VentanaCongestion
en


aumentar
de
5
MSS
a
11
MSS
(
si
no
se
producen
sucesos
de
p√©rdida
de
paquetes
)
?


b.
¬ø
Cu√°l
es
la
tasa
de
transferencia
media
(
en
funci√≥n
de
MSS
y
RTT
)
para
esta
cone-


xi√≥n
hasta
llegar
al
periodo
RTT
n√∫mero
6
?


P42
.
Recuerde
la
descripci√≥n
macrosc√≥pica
de
la
tasa
de
transferencia
de
TCP
.
En
el


periodo
de
tiempo
que
va
desde
que
la
velocidad
de
la
conexi√≥n
var√≠a
entre
W/(2
¬∑


RTT
)
y
W
/
RTT
,
s√≥lo
se
pierde
un
paquete
(
justo
al
final
del
periodo
)
.


a.
Demuestre
que
la
tasa
de
p√©rdidas
(
fracci√≥n
de
paquetes
perdidos
)
es
igual
a
:


b.
Utilice
el
resultado
anterior
para
demostrar
que
si
una
conexi√≥n
tiene
una
tasa
de


p√©rdidas
igual
a
L
,
entonces
su
tasa
promedio
es
aproximadamente
igual
a


P43
.
Considere
una
√∫nica
conexi√≥n
TCP
(
Reno
)
que
emplea
un
enlace
a
10Mbps
que
no


almacena
en
buffer
ning√∫n
dato
.
Suponga
que
este
enlace
es
el
√∫nico
enlace
conges-


tionado
entre
los
hosts
emisor
y
receptor
.
Suponga
tambi√©n
que
el
emisor
TCP
tiene


que
enviar
al
receptor
un
archivo
de
gran
tama√±o
y
que
el
buffer
de
recepci√≥n
del


receptor
es
mucho
m√°s
grande
que
la
ventana
de
congesti√≥n
.
Haremos
adem√°s
las


siguientes
suposiciones
:
el
tama√±o
de
segmento
TCP
es
de
1.500
bytes
,
el
retardo
de


propagaci√≥n
de
ida
y
vuelta
de
esta
conexi√≥n
es
igual
a
100
milisegundos
y
esta
cone-


xi√≥n
TCP
siempre
se
encuentra
en
la
fase
de
evitaci√≥n
de
la
congesti√≥n
,
es
decir
,
igno-


ramos
la
fase
de
arranque
lento
.


 
 1
22
,
MSS


RTT
L


L


WW


=
         
=


+

 
tasa
de
p√©rdidas
  
1


3


8


3


4

 
2


PROBLEMAS
291


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
291a
.
¬ø
Cu√°l
es
el
tama√±o
m√°ximo
de
ventana
(
en
segmentos
)
que
esta
conexi√≥n
TCP


puede
alcanzar
?


b.
¬ø
Cu√°les
son
el
tama√±o
medio
de
ventana
(
en
segmentos
)
y
la
tasa
de
transferencia


media
(
en
bps
)
de
esta
conexi√≥n
TCP
?


c.
¬ø
Cu√°nto
tiempo
tarda
esta
conexi√≥n
TCP
en
alcanzar
de
nuevo
su
tama√±o
de
ven-


tana
m√°ximo
despu√©s
de
recuperarse
de
una
p√©rdida
de
paquete
?


P44
.
Continuando
con
el
escenario
descrito
en
el
problema
anterior
,
suponga
que
el
enlace


a
10Mbps
puede
almacenar
en
buffer
un
n√∫mero
finito
de
segmentos
.
Razone
por
qu√©


para
que
el
enlace
est√©
siempre
ocupado
enviando
datos
,
deber√≠amos
seleccionar
un


tama√±o
de
buffer
que
sea
al
menos
igual
al
producto
de
la
velocidad
del
enlace
C
y
el


retardo
de
propagaci√≥n
de
ida
y
vuelta
entre
el
emisor
y
el
receptor
.


P45
.
Repita
el
Problema
43
,
pero
sustituyendo
el
enlace
a
10
Mbps
por
un
enlace
a
10


Gbps
.
Observe
que
en
la
respuesta
al
apartado
(
c
)
habr√°
demostrado
que
se
tarda


mucho
tiempo
en
que
el
tama√±o
de
la
ventana
de
congesti√≥n
alcance
su
m√°ximo
des-


pu√©s
de
recuperarse
de
una
p√©rdida
de
paquete
.
Dise√±e
una
soluci√≥n
que
resuelva
este


problema
.
  

P46
.
Sea
T
(
medido
en
RTT
)
el
intervalo
de
tiempo
que
una
conexi√≥n
TCP
tarda
en
aumen-


tar
el
tama√±o
de
su
ventana
de
congesti√≥n
de
W/2
a
W
,
donde
W
es
el
tama√±o
m√°ximo


de
la
ventana
de
congesti√≥n
.
Demuestre
que
T
es
una
funci√≥n
de
la
tasa
de
transferen-


cia
media
de
TCP
.
  

P47
.
Considere
un
algoritmo
AIMD
de
TCP
simplificado
en
el
que
el
tama√±o
de
la
ventana


de
congesti√≥n
se
mide
en
n√∫mero
de
segmentos
,
no
en
bytes
.
En
la
fase
de
incremento


aditivo
,
el
tama√±o
de
la
ventana
de
congesti√≥n
se
incrementa
en
un
segmento
cada


RTT
.
En
la
fase
de
decrecimiento
multiplicativo
,
el
tama√±o
de
la
ventana
de
conges-


ti√≥n
se
reduce
a
la
mitad
(
si
el
resultado
no
es
un
entero
,
redondee
al
entero
m√°s


pr√≥ximo
)
.
Suponga
que
dos
conexiones
TCP
,
C1
y
C2
,
comparten
un
enlace
congestio-


nado
cuya
velocidad
es
de
30
segmentos
por
segundo
.
Suponemos
que
tanto
C
1
como


C2
est√°n
en
l
fase
de
evitaci√≥n
de
la
congesti√≥n
.
El
intervalo
RTT
de
la
conexi√≥n
C
1es


igual
a
100
milisegundos
y
el
de
la
conexi√≥n
C2
es
igual
a
200
milisegundos
.
Supone-


mos
que
cuando
la
velocidad
de
los
datos
en
el
enlace
excede
la
velocidad
del
enlace
,


todas
las
conexiones
TCP
experimentan
p√©rdidas
de
segmentos
de
datos
.
 

a.
Si
en
el
instante
t0
el
tama√±o
de
la
ventana
de
congesti√≥n
de
ambas
conexiones
,
C
1


y
C2
,
es
de
10
segmentos
,
¬ø
cu√°les
ser√°n
los
tama√±os
de
dichas
ventanas
de
conges-


ti√≥n
despu√©s
de
transcurridos
2200
milisegundos
?


b.
¬ø
Obtendr√°n
estas
dos
conexiones
,
a
largo
plazo
,
la
misma
cuota
de
ancho
de
banda


del
enlace
congestionado
?
Explique
su
respuesta
.
 

P48
.
Contin√∫e
con
la
red
descrita
en
el
problema
anterior
,
pero
ahora
suponga
que
las
dos


conexiones
TCP
,
C1
y
C2
,
tienen
el
mismo
intervalo
RTT
de
100
milisegundos
.


Suponga
que
en
el
instante
t
0
,
el
tama√±o
de
la
ventana
de
congesti√≥n
de
C1
es
de
15


segmentos
pero
el
tama√±o
de
la
ventana
de
congesti√≥n
de
C2
es
igual
a
10
segmentos
.


a.
¬ø
Cu√°les
ser√°n
los
tama√±os
de
las
ventanas
de
congesti√≥n
despu√©s
de
transcurridos


2200
milisegundos
?


292
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
292b
.
¬ø
Obtendr√°n
estas
dos
conexiones
,
a
largo
plazo
,
la
misma
cuota
de
ancho
de
banda


del
enlace
congestionado
?


c.
Decimos
que
dos
conexiones
est√°n
sincronizadas
si
ambas
conexiones
alcanzan
su


tama√±o
de
ventana
m√°ximo
al
mismo
tiempo
y
alcanzan
su
tama√±o
m√≠nimo
de


ventana
tambi√©n
al
mismo
tiempo
.
¬ø
Terminar√°n
con
el
tiempo
sincroniz√°ndose


estas
dos
conexiones
?
En
caso
afirmativo
,
¬ø
cu√°les
son
sus
tama√±os
m√°ximos
de


ventana
?


d.
¬ø
Ayudar√°
esta
sincronizaci√≥n
a
mejorar
la
tasa
de
utilizaci√≥n
del
enlace
compar-


tido
?
¬ø
Por
qu√©
?
Esboce
alguna
idea
para
evitar
esta
sincronizaci√≥n
.


P49
.
Veamos
una
modificaci√≥n
del
algoritmo
de
control
de
congesti√≥n
de
TCP
.
En
lugar
de


utilizar
un
incremento
aditivo
podemos
emplear
un
incremento
multiplicativo
.
Un


emisor
TCP
incrementa
su
tama√±o
de
ventana
seg√∫n
una
constante
peque√±a
positiva


a
(
0
<
a
<
1
)
cuando
recibe
un
ACK
v√°lido
.
Halle
la
relaci√≥n
funcional
existente
entre


la
tasa
de
p√©rdidas
L
y
el
tama√±o
m√°ximo
de
la
ventana
de
congesti√≥n
W.
Demuestre


que
para
esta
conexi√≥n
TCP
modificada
,
independientemente
de
la
tasa
media
de


transferencia
de
TCP
,
una
conexi√≥n
TCP
siempre
invierte
la
misma
cantidad
de
tiempo


en
incrementar
el
tama√±o
de
su
ventana
de
congesti√≥n
de
W/2
a
W.
 

P50
.
En
nuestra
exposici√≥n
sobre
el
futuro
de
TCP
de
la
Secci√≥n
3.7
hemos
destacado
que


para
alcanzar
una
tasa
de
transferencia
de
10
Gbps
,
TCP
s√≥lo
podr√≠a
tolerar
una
proba-


bilidad
de
p√©rdida
de
segmentos
de
2
¬∑
10
-10
(
o
lo
que
es
equivalente
,
un
suceso
de


p√©rdida
por
cada
5.000.000.000
segmentos
)
.
Indique
de
d√≥nde
se
obtienen
los
valores


2
¬∑
10
-10
y
1
por
cada
5.000.000
para
los
valores
de
RTT
y
MSS
dados
en
la
Secci√≥n


3.7
.
Si
TCP
tuviera
que
dar
soporte
a
una
conexi√≥n
a
100
Gbps
,
¬ø
qu√©
tasa
de
p√©rdidas


ser√≠a
tolerable
?


P51
.
En
nuestra
exposici√≥n
sobre
el
control
de
congesti√≥n
de
TCP
de
la
Secci√≥n
3.7
,
impl√≠-


citamente
hemos
supuesto
que
el
emisor
TCP
siempre
tiene
datos
que
enviar
.
Consi-


deremos
ahora
el
caso
en
que
el
emisor
TCP
env√≠a
una
gran
cantidad
de
datos
y
luego


en
el
instante
t1
se
queda
inactivo
(
puesto
que
no
tiene
m√°s
datos
que
enviar
)
.
TCP


permanece
inactivo
durante
un
periodo
de
tiempo
relativamente
largo
y
en
el
instante


t2
quiere
enviar
m√°s
datos
.
¬ø
Cu√°les
son
las
ventajas
y
las
desventajas
de
que
TCP


tengan
que
utilizar
los
valores
de
VentanaCongestion
y
umbral
de
t1
cuando


comienza
a
enviar
datos
en
el
instante
t2
?
¬ø
Qu√©
alternativa
recomendar√≠a
?
¬ø
Por
qu√©
?


P52
.
En
este
problema
vamos
a
investigar
si
UDP
o
TCP
proporcionan
un
cierto
grado
de


autenticaci√≥n
del
punto
terminal
.


a.
Considere
un
servidor
que
recibe
una
solicitud
dentro
de
un
paquete
UDP
y
res-


ponde
a
la
misma
dentro
de
un
paquete
UDP
(
por
ejemplo
,
como
en
el
caso
de
un


servidor
DNS
)
.
Si
un
cliente
con
la
direcci√≥n
IP
X
suplanta
su
direcci√≥n
con
la


direcci√≥n
Y
,
¬ø
A
d√≥nde
enviar√°
el
servidor
su
respuesta
?


b.
Suponga
que
un
servidor
recibe
un
SYN
con
la
direcci√≥n
IP
de
origen
Y
,
y
despu√©s


de
responder
con
un
SYNACK
,
recibe
un
ACK
con
la
direcci√≥n
IP
de
origen
Y
y


con
el
n√∫mero
de
reconocimiento
correcto
.
Suponiendo
que
el
servidor
elige
un


n√∫mero
de
secuencia
inicial
aleatorio
y
que
no
existe
ning√∫n
atacante
interpuesto


(
man-in-the-middle
)
,
¬ø
puede
el
servidor
estar
seguro
de
que
el
cliente
est√°
en
la


direcci√≥n
Y
(
y
no
en
alguna
otra
direcci√≥n
X
que
est√©
intentando
suplantar
a
Y
)
?


PROBLEMAS
293


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
293P53
.
En
este
problema
,
vamos
a
considerar
el
retardo
introducido
por
la
fase
de
arranque


lento
de
TCP
.
Se
tiene
un
cliente
y
un
servidor
web
directamente
conectados
mediante


un
enlace
a
velocidad
R.
Suponga
que
el
cliente
desea
extraer
un
objeto
cuyo
tama√±o


es
exactamente
igual
a
15
S
,
donde
S
es
el
tama√±o
m√°ximo
de
segmento
 
(
MSS
)
.
Sea


RTT
el
tiempo
de
transmisi√≥n
de
ida
y
vuelta
entre
el
cliente
y
el
servidor
(
suponemos


que
es
constante
)
.
Ignorando
las
cabeceras
del
protocolo
,
determine
el
tiempo
necesa-


rio
para
recuperar
el
objeto
(
incluyendo
el
tiempo
de
establecimiento
de
la
conexi√≥n


TCP
)
si


a.
4
S
/
R
>
S
/
R
+
RTT
>
2S
/
R


b.
S
/
R
+
RTT
>
4
S
/
R


c.
S
/
R
>
RTT
.


Preguntas
para
la
discusi√≥n


D1
.
¬ø
Qu√©
es
el
secuestro
de
una
conexi√≥n
TCP
?
¬ø
C√≥mo
se
puede
hacer
?


D2
.
En
la
Secci√≥n
3.7
hemos
dicho
que
una
aplicaci√≥n
cliente-servidor
puede
crear
‚Äú
de


forma
no
equitativa
‚Äù
muchas
conexiones
simult√°neas
en
paralelo
.
¬ø
Qu√©
se
puede
hacer


para
que
Internet
sea
realmente
una
red
equitativa
?


D3
.
Consulte
la
literatura
de
investigaci√≥n
para
ver
a
qu√©
se
refiere
el
concepto
de


orientado
a
TCP
(
TCP
friendly
)
.
Lea
tambi√©n
la
entrevista
a
Sally
Floyd
al
final
del


cap√≠tulo
.
Describa
en
una
p√°gina
el
concepto
de
orientaci√≥n
a
TCP
.


D4
.
Al
final
de
la
Secci√≥n
3.7.1
hemos
abordado
el
hecho
de
que
una
aplicaci√≥n
puede


abrir
varias
conexiones
TCP
y
conseguir
una
tasa
de
transferencia
m√°s
alta
(
o
lo
que


es
lo
mismo
,
una
velocidad
de
transferencia
de
datos
m√°s
r√°pida
)
.
¬ø
Qu√©
ocurrir√≠a
si


todas
las
aplicaciones
intentaran
mejorar
su
rendimiento
utilizando
varias
conexiones
?


¬ø
Cu√°les
son
algunas
de
las
dificultades
derivadas
de
hacer
que
un
elemento
de
red


determine
si
una
aplicaci√≥n
est√°
utilizando
varias
conexiones
TCP
?


D5
.
Adem√°s
de
la
exploraci√≥n
de
puertos
TCP
y
UDP
,
¬ø
de
qu√©
funcionalidad
dispone


nmap
?
Recopile
trazas
de
los
intercambios
de
paquetes
de
nmap
mediante
Ethereal
(
o


cualquier
otro
analizador
de
paquetes
,
sniffer
)
.
Utilice
las
trazas
para
explicar
c√≥mo


operan
algunas
de
las
funcionalidades
avanzadas
.


D6
.
En
la
descripci√≥n
de
TCP
proporcionada
en
la
Figura
3.53
,
el
valor
inicial
de
Venta-


naCongestiones
1
.
Consulte
los
libros
disponibles
y
el
RFC
de
Internet
y
comente


algunas
de
las
t√©cnicas
alternativas
que
se
han
propuesto
para
establecer
el
valor
ini-


cial
de
VentanaCongestion
.


D7
.
Consulte
la
documentaci√≥n
disponible
sobre
SCTP
[
RFC
2960
,
RFC
3286
]
.
¬ø
Cu√°les


son
las
aplicaciones
que
los
dise√±adores
prev√©n
para
SCTP
?
¬ø
Qu√©
funcionalidades
de


SCTP
se
a√±adieron
para
satisfacer
las
necesidades
de
esas
aplicaciones
?


294
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
294Tareas
de
programaci√≥n


Implementaci√≥n
de
un
protocolo
de
transporte
fiable


En
esta
tarea
de
programaci√≥n
tendr√°
que
escribir
el
c√≥digo
para
la
capa
de
transporte
del


emisor
y
el
receptor
con
el
fin
de
implementar
un
protocolo
de
transferencia
de
datos
fiable


simple
.
Hay
disponibles
dos
versiones
de
esta
pr√°ctica
de
laboratorio
:
la
versi√≥n
del
proto-


colo
de
bit
alternante
y
la
versi√≥n
del
protocolo
GBN
.
Esta
pr√°ctica
de
laboratorio
le
resul-


tar√°
entretenida
y
su
implementaci√≥n
diferir√°
muy
poco
de
lo
que
se
necesita
en
una


situaci√≥n
real
.


Puesto
que
probablemente
no
dispone
de
m√°quinas
aut√≥nomas
(
con
un
sistema
opera-


tivo
que
pueda
modificar
)
,
su
c√≥digo
tendr√°
que
ejecutarse
en
un
entorno
simulado
hard-


ware
/
software
.
Sin
embargo
,
la
interfaz
de
programaci√≥n
proporcionada
a
sus
rutinas
(
el


c√≥digo
que
efectuar√°
las
llamadas
a
sus
entidades
desde
las
capas
superior
e
inferior
)
es


muy
similar
a
la
que
se
utiliza
en
un
entorno
UNIX
real
.
(
De
hecho
,
las
interfaces
soft-


ware
descritas
en
esta
tarea
de
programaci√≥n
son
mucho
m√°s
realistas
que
los
emisores
y


receptores
con
bucles
infinitos
que
se
describen
en
muchos
textos
.
)
Tambi√©n
se
simula
el


arranque
y
la
detenci√≥n
de
temporizadores
,
y
las
interrupciones
de
los
temporizadores


har√°n
que
se
active
su
rutina
de
tratamiento
de
temporizadores
.


La
tarea
completa
de
laboratorio
,
as√≠
como
el
c√≥digo
que
tendr√°
que
compilar
con
su


propio
c√≥digo
est√°
disponible
en
el
sitio
web
del
libro
en
http://www.awl.com/kurose-ross
.


Pr√°ctica
de
laboratorio
con
Wireshark
:


exploraci√≥n
de
TCP


En
esta
pr√°ctica
de
laboratorio
tendr√°
que
utilizar
su
navegador
web
para
acceder
a
un


archivo
almacenado
en
un
servidor
web
.
Como
en
las
pr√°cticas
de
laboratorio
con
Wires-


hark
anteriores
,
tendr√°
que
utilizar
Wireshark
para
capturar
los
paquetes
que
lleguen
a
su


computadora
.
A
diferencia
de
las
pr√°cticas
anteriores
,
tambi√©n
podr√°
descargar
una
traza
de


paquetes
(
que
Wireshark
puede
leer
)
del
servidor
web
del
que
haya
descargado
el
archivo
.


En
esta
traza
del
servidor
encontrar√°
los
paquetes
que
fueron
generados
a
causa
de
su
propio


acceso
al
servidor
web
.
Analizar√°
las
trazas
del
lado
del
cliente
y
de
lado
del
servidor
para


explorar
los
aspectos
de
TCP
.
En
particular
,
tendr√°
que
evaluar
el
rendimiento
de
la
cone-


xi√≥n
TCP
entre
su
computadora
y
el
servidor
web
.
Tendr√°
que
trazar
el
comportamiento
de


la
ventana
de
TCP
e
inferir√°
la
p√©rdida
de
paquetes
,
las
retransmisiones
,
el
comportamiento


del
control
de
flujo
y
del
control
de
congesti√≥n
y
el
tiempo
de
ida
y
vuelta
estimado
.


Como
con
el
resto
de
las
pr√°cticas
de
laboratorio
con
Wireshark
,
la
descripci√≥n
com-


pleta
de
esta
pr√°ctica
est√°
disponible
en
el
sitio
web
del
libro
en
http://www.awl.com/kurose-


ross
.


TAREAS
DE
PROGRAMACI√ìN
295


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
295Pr√°ctica
de
laboratorio
con
Wireshark
:


exploraci√≥n
de
UDP


En
esta
corta
pr√°ctica
de
laboratorio
,
realizar√°
una
captura
y
un
an√°lisis
de
paquetes
de
su


aplicaci√≥n
favorita
que
utilice
UDP
(
por
ejemplo
,
DNS
o
una
aplicaci√≥n
multimedia
como


Skype
)
.
Como
hemos
visto
en
la
Secci√≥n
3.3
,
UDP
es
un
protocolo
de
transporte
simple
.
En


esta
pr√°ctica
de
laboratorio
tendr√°
que
investigar
los
campos
de
cabecera
del
segmento
UDP
,


as√≠
como
el
c√°lculo
de
la
suma
de
comprobaci√≥n
.


Al
igual
que
con
todas
las
dem√°s
pr√°cticas
de
laboratorio
de
Wireshark
,
la
descripci√≥n


completa
de
la
pr√°ctica
est√°
disponible
en
el
sitio
web
del
libro
en
http://www.awl.com/


kurose-ross
.


296
CAP√çTULO
3
‚Ä¢
LA
CAPA
DE
TRANSPORTE


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
296297


¬ø
Por
qu√©
decidi√≥
estudiar
Ciencias
de
la
Computaci√≥n
?


Despu√©s
de
obtener
mi
grado
en
Sociolog√≠a
,
tuve
que
decidir
c√≥mo
ganarme
la
vida
y
acab√©
obtenien-


do
un
certificado
de
estudios
de
dos
a√±os
en
electr√≥nica
en
un
centro
local
de
formaci√≥n
,
despu√©s
de


lo
cual
pas√©
diez
a√±os
trabajando
en
el
campo
de
la
electr√≥nica
y
de
la
inform√°tica
.
Esto
incluy√≥
ocho


a√±os
como
ingeniero
de
sistemas
de
computadoras
para
los
equipos
que
controlaban
los
trenes
de
Bay


Area
Rapid
Transit
.
Despu√©s
,
decid√≠
aprender
algo
m√°s
de
inform√°tica
formal
y
curs√©
la
licenciatura
en


el
Departamento
de
Ciencias
de
la
Computaci√≥n
de
UC
Berkeley
.


¬ø
Por
qu√©
decidi√≥
especializarse
en
redes
?


Durante
la
licenciatura
comenc√©
a
interesarme
por
la
inform√°tica
te√≥rica
.
Primero
trabaj√©
en
el
an√°li-


sis
probabil√≠stico
de
algoritmos
y
luego
en
la
teor√≠a
computacional
del
aprendizaje
.
Tambi√©n
estaba
tra-


bajando
en
LBL
(
Lawrence
Berkeley
Laboratory
)
un
d√≠a
al
mes
y
mi
despacho
estaba
muy
pr√≥xima
a


la
de
Van
Jacobson
,
que
por
aquel
entonces
estaba
trabajando
en
algoritmos
de
control
de
congesti√≥n


para
TCP
.
Van
me
pregunt√≥
si
me
gustar√≠a
trabajar
durante
el
verano
analizando
una
serie
de
algorit-


mos
para
un
problema
de
red
que
implicaba
la
sincronizaci√≥n
no
deseada
de
mensajes
peri√≥dicos
de


enrutamiento
.
Me
pareci√≥
interesante
y
a
eso
es
a
lo
que
me
dediqu√©
durante
el
verano
.


Despu√©s
de
terminar
mi
tesis
doctoral
,
Van
me
ofreci√≥
un
trabajo
a
tiempo
completo
para
conti-


nuar
con
las
investigaciones
en
el
campo
de
las
redes
.
Yo
no
ten√≠a
planeado
pasarme
tantos
a√±os
tra-


bajando
en
el
teme
de
redes
,
pero
para
m√≠
la
investigaci√≥n
en
el
campo
de
las
redes
es
m√°s
gratifican-


te
que
la
inform√°tica
te√≥rica
.
Me
siento
m√°s
satisfecha
trabajando
en
el
mundo
de
la
ciencia
aplicada
,


en
el
que
las
consecuencias
de
mi
trabajo
son
m√°s
tangibles
.


¬ø
Cu√°l
fue
su
primer
trabajo
en
la
industria
inform√°tica
?
¬ø
A
qu√©
se
dedicaba
?


Mi
primer
empleo
fue
en
BART
(
Bay
Area
Rapid
Transit
)
,
de
1975
a
1982
,
trabajando
en
las
compu-


tadoras
que
controlan
los
trenes
de
BART
.
Comenc√©
como
t√©cnico
,
manteniendo
t
reparando
los
diver-


sos
sistemas
de
computadoras
distribuidos
que
est√°n
implicados
en
el
control
del
sistema
BART
.


Esto
inclu√≠a
un
sistema
central
de
computadoras
y
un
sistema
distribuido
de
minicomputadoras


para
el
control
del
movimiento
de
los
trenes
,
un
sistema
de
computadoras
DEC
para
la
visualizaci√≥n


de
anuncios
y
de
los
destinos
de
los
trenes
en
los
paneles
de
nuncios
y
un
sistema
de
computadoras


Modcomp
para
recopilar
informaci√≥n
de
los
tornos
de
entrada
a
las
estaciones
.
Mis
√∫ltimos
a√±os
en


Sally
Floyd


Sally
Floyd
es
investigadora
en
el
Centro
ICSI
para
investigaci√≥n
sobre


Internet
,
un
instituto
dedicado
a
los
temas
de
Internet
y
de
la
comunicaci√≥n


por
red
.
Es
bastante
conocida
en
el
sector
por
sus
trabajos
en
el
dise√±o
de


protocolos
de
Internet
,
en
particular
los
relativos
a
las
comunicaciones


multicast
fiables
,
al
control
de
congesti√≥n
(
TCP
)
,
a
la
planificaci√≥n
de


paquetes
(
RED
)
y
al
an√°lisis
de
protocolos
.
Sally
se
gradu√≥
en
Sociolog√≠a


en
la
universidad
de
California
,
Berkeley
,
y
se
licenci√≥n
y
doctor√≥
en


Ciencias
de
la
Computaci√≥n
en
la
misma
universidad
.


UNA
ENTREVISTA
CON
...


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
297BART
los
pas√©
trabajando
en
un
proyecto
conjunto
BART
/
LBLpara
dise√±ar
el
sustituto
del
ya
bastan-


te
antiguo
sistema
de
computadoras
de
control
de
trenes
de
BART
.


¬ø
Cu√°l
es
la
parte
m√°s
atractiva
de
su
trabajo
?


La
tarea
de
investigaci√≥n
es
la
que
m√°s
atrae
.
Uno
de
los
problemas
de
investigaci√≥n
incluye
explorar


los
problemas
futuros
relacionados
con
el
control
de
congesti√≥n
,
para
aplicaciones
tales
como
los
flu-


jos
multimedia
.
Un
segundo
tema
es
el
de
resolver
los
impedimentos
existentes
en
las
redes
para
poder


implementar
una
comunicaci√≥n
m√°s
expl√≠cita
entre
los
routers
y
los
nodos
terminales
.
Estos
impedi-


mentos
pueden
incluir
los
t√∫neles
IP
y
las
rutas
MPLS
,
la
existencia
de
routers
o
equipos
intermedios


que
eliminan
paquetes
que
contienen
opciones
IP
,
la
existencia
de
redes
complejas
de
la
capa
2
y
las


potenciales
debilidades
que
hacen
posibles
los
ataques
a
la
red
.
Un
tercer
tema
bastante
activo
consis-


te
en
explorar
c√≥mo
la
elecci√≥n
de
modelos
de
escenarios
para
el
an√°lisis
,
la
simulaci√≥n
y
la
experi-


mentaci√≥n
afecta
a
nuestra
evaluaci√≥n
del
rendimiento
de
los
mecanismos
del
control
de
congesti√≥n
.


Puede
encontrar
m√°s
informaci√≥n
acerca
de
estos
temas
en
las
p√°ginas
web
dedicadas
a
DCCP
,
Quick-


Start
y
TMRG
,
a
las
que
puede
acceder
a
trav√©s
de
la
direcci√≥n
http://www.icir.org/floyd
.


¬ø
Cu√°l
prev√©
que
sea
el
futuro
de
las
redes
y
de
Internet
?


Una
posibilidad
es
que
las
congestiones
t√≠picas
con
las
que
se
encuentra
el
tr√°fico
de
Internet
pasen
a


ser
menos
problem√°ticas
a
medida
que
el
ancho
de
banda
disponible
se
incremente
a
un
ritmo
m√°s
r√°pi-


do
que
la
demanda
.
La
tendencia
que
preveo
es
hacia
un
nivel
de
congesti√≥n
menos
severo
,
aunque


tampoco
es
imposible
que
a
medio
plazo
nos
encontremos
con
un
futuro
de
congesti√≥n
creciente
,
con


ocasionales
colapsos
debidos
a
la
congesti√≥n
.


El
futuro
de
la
propia
Internet
o
de
la
arquitectura
Internet
no
lo
tengo
nada
claro
.
Hay
muchos


factores
que
contribuyen
a
la
r√°pida
evoluci√≥n
de
Internet
,
as√≠
que
resulta
dif√≠cil
predecir
c√≥mo
ser√°
la


evoluci√≥n
de
la
red
o
de
la
arquitectura
de
red
,
o
incluso
predecir
si
esta
evoluci√≥n
tendr√°
√©xito
a
la


hora
de
evitar
los
numerosos
problemas
potenciales
que
se
ir√°n
presentando
a
lo
largo
del
camino
.


Una
tendencia
negativa
bien
conocida
es
la
creciente
dificultad
de
realizar
cambios
en
la
arqui-


tectura
de
Internet
.
La
arquitectura
de
Internet
ya
no
es
un
todo
coherente
,
y
los
diversos
componentes


como
protocolos
de
transporte
,
mecanismos
de
enrutamiento
,
cortafuegos
,
equilibradores
de
carga
,


mecanismos
de
seguridad
,
etc.
,
en
ocasiones
trabajan
teniendo
objetivos
contrapuestos
.


¬ø
Qu√©
personas
le
han
inspirado
profesionalmente
?


Richard
Karp
,
mi
director
de
tesis
doctoral
,
me
ense√±o
lo
fundamental
de
c√≥mo
se
lleva
a
cabo
una


investigaci√≥n
,
mientras
que
Van
Jacobson
,
mi
‚Äú
jefe
de
grupo
‚Äù
en
LBL
,
es
el
responsable
de
que
en
m√≠


se
desarrollara
un
inter√©s
por
las
redes
,
as√≠
como
de
mi
comprensi√≥n
acerca
de
la
infraestructura


Internet
.
Dave
Clark
tambi√©n
me
ha
servido
de
inspiraci√≥n
,
gracias
a
su
clara
visi√≥n
de
la
arquitectura


de
Internet
y
a
su
papel
en
el
desarrollo
de
esa
arquitectura
mediante
sus
investigaciones
,
escritos
y
par-


ticipaci√≥n
en
el
IETF
y
otros
foros
de
car√°cter
p√∫blico
.
Deborah
Estrin
tambi√©n
ha
sido
una
fuente
de


inspiraci√≥n
gracias
a
su
capacidad
de
concentraci√≥n
a
a
su
efectividad
,
as√≠
como
a
su
habilidad
para


tomar
decisiones
meditadas
acerca
de
en
qu√©
va
a
trabajar
y
por
qu√©
.


Una
de
las
razones
de
haber
disfrutado
trabajando
en
el
√°rea
de
la
investigaci√≥n
acerca
de
las
redes


es
,
precisamente
,
que
existen
muchas
personas
en
este
sector
a
las
que
aprecio
,
respeto
y
admiro
.
Son


inteligentes
,
trabajan
duro
,
est√°n
muy
comprometidas
con
el
desarrollo
de
Internet
y
pueden
ser
una


excelente
compa√±√≠a
a
la
hora
de
ir
a
tomar
una
cerveza
o
de
mantener
una
discusi√≥n
amistosa
despu√©s


de
un
d√≠a
de
reuniones
.


298


M03_KURO9675_05_SE_CH03.qxd
 
22/3/10
 
09:17
 
P√°gina
298CAP√çTULO
4


La
capa


de
red


299


Hemos
estudiado
en
el
cap√≠tulo
anterior
que
la
capa
de
transporte
proporciona
varias
formas


de
comunicaci√≥n
proceso
a
proceso
bas√°ndose
en
el
servicio
de
comunicaci√≥n
host
a
host
de


la
capa
de
red
.
Tambi√©n
hemos
visto
que
la
capa
de
transporte
lleva
a
cabo
esta
tarea
sin


saber
c√≥mo
la
capa
de
red
implementa
realmente
este
servicio
.
As√≠
que
es
posible
que
se
est√©


preguntando
,
¬ø
cu√°l
es
el
mecanismo
subyacente
al
servicio
de
comunicaci√≥n
de
host
a
host


que
lo
hace
funcionar
?


En
este
cap√≠tulo
vamos
a
ver
exactamente
c√≥mo
la
capa
de
red
implementa
el
servicio


de
comunicaci√≥n
host
a
host
.
Veremos
que
,
a
diferencia
de
la
capa
de
transporte
,
existe
un


componente
de
la
capa
de
red
en
todos
y
cada
uno
de
los
hosts
y
routers
de
la
red
.
Por
esta


raz√≥n
,
los
protocolos
de
la
capa
de
red
se
encuentran
entre
los
m√°s
desafiantes
(
y
,
por
tanto
,


entre
los
m√°s
interesantes
)
de
la
pila
de
protocolos
.


La
capa
de
red
tambi√©n
es
una
de
las
capas
m√°s
complejas
de
la
pila
de
protocolos
y
,


por
tanto
,
ser√°n
muchas
las
cuestiones
que
vamos
a
tener
que
abordar
.
Comenzaremos
nues-


tro
estudio
con
una
introducci√≥n
a
la
capa
de
red
y
a
los
servicios
que
puede
proporcionar
.
A


continuaci√≥n
,
volveremos
sobre
las
dos
t√©cnicas
empleadas
en
la
estructuraci√≥n
del
servicio


de
entrega
de
paquetes
de
la
capa
de
red
(
los
datagramas
y
el
modelo
de
circuito
virtual
)
,
de


las
que
hablamos
por
primera
vez
en
el
Cap√≠tulo
1
.
Asimismo
,
veremos
el
papel
fundamen-


tal
que
desempe√±a
el
direccionamiento
en
la
entrega
de
paquetes
a
un
host
de
destino
.


En
este
cap√≠tulo
haremos
una
importante
distinci√≥n
entre
las
funciones
de
reenv√≠o
(
for-


warding
)
y
de
enrutamiento
(
routing
)
de
la
capa
de
red
.
El
reenv√≠o
implica
la
transferencia


de
un
paquete
desde
un
enlace
de
entrada
a
un
enlace
de
salida
dentro
de
un
mismo
router
.


El
enrutamiento
implica
a
todos
los
routers
de
una
red
,
cuyas
interacciones
colectivas


mediante
los
protocolos
de
enrutamiento
determinan
las
rutas
que
seguir√°n
los
paquetes
en


sus
viajes
desde
el
origen
hasta
el
destino
.
√âsta
es
una
importante
distinci√≥n
que
deber√°
tener


presente
a
medida
que
avancemos
en
este
cap√≠tulo
.


Con
el
fin
de
profundizar
en
nuestros
conocimientos
acerca
del
reenv√≠o
de
paquetes
,


vamos
a
echar
un
vistazo
al
‚Äú
interior
‚Äù
de
un
router
(
a
su
organizaci√≥n
y
su
arquitectura
hard-


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
299ware
)
.
A
continuaci√≥n
,
nos
ocuparemos
del
reenv√≠o
de
paquetes
en
Internet
,
junto
con
el


c√©lebre
Protocolo
de
Internet
(
IP
)
.
Estudiaremos
el
direccionamiento
de
la
capa
de
red
y
el


formato
de
los
datagramas
IPv4
.
Despu√©s
,
exploraremos
la
Traducci√≥n
de
direcciones
de
red


(
NAT
,
Network
Address
Translation
)
,
la
fragmentaci√≥n
de
datagramas
,
el
Protocolo
de
men-


sajes
de
control
de
Internet
(
ICMP
,
Internet
Control
Message
Protocol
)
e
IPv6
.


Despu√©s
volveremos
a
poner
nuestra
atenci√≥n
en
la
funci√≥n
de
enrutamiento
de
la
capa


de
red
.
Veremos
que
el
trabajo
de
un
protocolo
de
enrutamiento
es
determinar
las
mejores


rutas
que
van
de
los
emisores
a
los
receptores
.
En
primer
lugar
,
estudiaremos
la
teor√≠a
de
los


algoritmos
de
enrutamiento
,
concentr√°ndonos
en
las
dos
clases
de
algoritmos
m√°s
importan-


tes
:
el
algoritmo
de
estado
de
enlaces
y
el
algoritmo
de
vector
de
distancias
.
Dado
que
la


complejidad
de
los
algoritmos
de
enrutamiento
crece
considerablemente
a
medida
que


aumenta
el
n√∫mero
de
routers
de
red
,
las
t√©cnicas
de
enrutamiento
jer√°rquico
tambi√©n
ser√°n


de
nuestro
inter√©s
.
A
continuaci√≥n
,
veremos
c√≥mo
llevar
la
teor√≠a
a
la
pr√°ctica
al
ocuparnos


de
los
protocolos
de
enrutamiento
internos
de
los
sistemas
aut√≥nomos
de
Internet
(
RIP
,


OSPF
e
IS-IS
)
y
de
su
protocolo
de
enrutamiento
entre
sistemas
aut√≥nomos
,
BGP
.
Termina-


remos
este
cap√≠tulo
con
una
exposici√≥n
acerca
del
enrutamiento
por
difusi√≥n
(
broadcast
)
y


por
multidifusi√≥n
(
multicast
)
.


En
resumen
,
este
cap√≠tulo
consta
de
tres
grandes
partes
.
La
primera
abarca
las
Seccio-


nes
4.1
y
4.2
y
se
ocupa
de
las
funciones
y
servicios
de
la
capa
de
red
.
La
segunda
parte


abarca
las
Secciones
4.3
y
4.4
y
cubre
la
funci√≥n
de
reenv√≠o
y
,
por
√∫ltimo
,
la
tercera
parte


que
consta
de
las
Secciones
4.5
a
4.7
se
ocupa
del
enrutamiento
.


4.1
Introducci√≥n


La
Figura
4.1
muestra
una
red
simple
formada
por
dos
hosts
,
H1
y
H2
,
y
varios
routers
en
la


ruta
que
va
de
H1
a
H2
.
Supongamos
que
H1
est√°
enviando
informaci√≥n
a
H2
;
veamos
enton-


ces
el
papel
de
la
capa
de
red
en
estos
hosts
y
en
los
routers
intervinientes
.
La
capa
de
red
en


H1
toma
segmentos
de
la
capa
de
transporte
en
H1
,
encapsula
cada
segmento
en
un
data-


grama
(
es
decir
,
un
paquete
de
la
capa
de
red
)
y
,
a
continuaci√≥n
,
env√≠a
los
datagramas
al
rou-


ter
m√°s
pr√≥ximo
,
R1
.
En
el
host
de
recepci√≥n
,
H2
,
la
capa
de
red
recibe
los
datagramas
de
su


router
m√°s
pr√≥ximo
R2
,
extrae
los
segmentos
de
la
capa
de
transporte
y
los
entrega
a
la
capa


de
transporte
de
H2
.
La
funci√≥n
principal
de
los
routers
es
reenviar
los
datagramas
desde
los


enlaces
de
entrada
a
los
enlaces
de
salida
.
Observe
que
los
routers
de
la
Figura
4.1
se
ilustran


con
una
pila
de
protocolos
truncada
,
es
decir
,
sin
capas
por
encima
de
la
capa
de
red
,
porque


(
excepto
para
prop√≥sitos
de
control
)
los
routers
no
ejecutan
protocolos
de
la
capa
de
trans-


porte
ni
de
la
capa
de
aplicaci√≥n
como
los
que
hemos
examinado
en
los
Cap√≠tulos
2
y
3
.


4.1.1
Reenv√≠o
y
enrutamiento


La
funci√≥n
de
la
capa
de
red
es
por
tanto
tremendamente
simple
:
transporta
paquetes
desde


un
host
emisor
a
un
host
receptor
.
En
la
realizaci√≥n
de
esta
tarea
podemos
identificar
dos


importantes
funciones
de
la
capa
de
red
:


‚Ä¢
Reenv√≠o
(
forwarding
)
.
Cuando
un
paquete
llega
al
enlace
de
entrada
de
un
router
,
√©ste


tiene
que
pasar
el
paquete
al
enlace
de
salida
apropiado
.
Por
ejemplo
,
un
paquete
que
llega


procedente
de
H1
al
router
R1
debe
ser
reenviado
al
siguiente
router
de
la
ruta
hacia
H2
.


300
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3004.1
‚Ä¢
INTRODUCCI√ìN
301


Figura
4.1
‚Ä¢
La
capa
de
red
.


En
la
Secci√≥n
4.3
,
miraremos
dentro
de
un
router
y
examinaremos
c√≥mo
se
reenv√≠a
real-


mente
un
paquete
desde
un
enlace
de
entrada
de
un
router
a
uno
de
sus
enlaces
de
salida
.


‚Ä¢
Enrutamiento
(
routing
)
.
La
capa
de
red
tiene
que
determinar
la
ruta
o
camino
que
deben


seguir
los
paquetes
a
medida
que
fluyen
de
un
emisor
a
un
receptor
.
Los
algoritmos
que


calculan
estas
rutas
se
conocen
como
algoritmos
de
enrutamiento
.
Un
algoritmo
de


enrutamiento
debe
determinar
,
por
ejemplo
,
la
ruta
por
la
que
fluir√°n
los
paquetes
para
ir


de
H1
a
H2
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
301Am
e
n
u
d
o
,
 
l
o
s
 
a
u
t
o
r
e
s
 
q
u
e
 
h
a
b
l
a
n
 
a
c
e
r
c
a
 
d
e
 
l
a
 
c
a
p
a
 
d
e
 
r
e
d
 
e
m
p
l
e
a
n
 
d
e
 
f
o
r
m
a
 
i
n
d
i
s
t
i
n
t
a


los
t√©rminos
reenv√≠oy
enrutamiento
.
Sin
embargo
,
en
este
libro
utilizaremos
estos
t√©rminos


de
manera
m√°s
precisa
.
El
reenv√≠ohace
referencia
a
la
acci√≥n
local
que
realiza
un
router
al


transferir
un
paquete
desde
una
interfaz
de
un
enlace
de
entrada
a
una
interfaz
del
enlace
de


salida
apropiada
.
El
enrutamiento
hace
referencia
al
proceso
que
realiza
la
red
en
conjunto


para
determinar
las
rutas
terminal
a
terminal
que
los
paquetes
siguen
desde
el
origen
al
des-


tino
.
Veamos
una
analog√≠a
.
Recuerde
el
viaje
desde
Pensilvania
a
Florida
que
realiz√≥
nues-


tro
viajero
de
la
Secci√≥n
1.3.2
.
Durante
ese
viaje
,
nuestro
conductor
atraves√≥
muchas


intersecciones
en
su
camino
a
Florida
.
Podemos
pensar
en
el
reenv√≠o
como
en
el
proceso
de


atravesar
una
intersecci√≥n
:
un
coche
entra
en
una
intersecci√≥n
viniendo
por
una
carretera
y


determina
qu√©
otra
carretera
tomar
para
salir
de
la
intersecci√≥n
.
Podemos
pensar
en
el
enru-


tamiento
como
en
el
proceso
de
planificaci√≥n
del
viaje
desde
Pensilvania
hasta
Florida
:


antes
de
iniciar
el
viaje
,
el
conductor
consulta
un
mapa
y
elige
uno
de
los
muchos
posibles


caminos
,
estando
cada
uno
de
ellos
definido
por
una
serie
de
tramos
de
carretera
que
se


conectan
en
las
intersecciones
.


Todo
router
tiene
una
tabla
de
reenv√≠o
.
Un
router
reenv√≠a
un
paquete
examinando
el


valor
de
un
campo
de
la
cabecera
del
paquete
entrante
y
utilizando
despu√©s
ese
valor
para


indexarlo
dentro
de
la
tabla
de
reenv√≠o
del
router
.
El
resultado
de
la
tabla
de
reenv√≠o
indica
a


cu√°l
de
las
interfaces
del
enlace
de
salida
del
router
ser√°
reenviado
el
paquete
.
Dependiendo


del
protocolo
de
la
capa
de
red
,
este
valor
de
la
cabecera
del
paquete
podr√≠a
ser
la
direcci√≥n


de
destino
del
paquete
o
una
indicaci√≥n
de
la
conexi√≥n
a
la
que
pertenece
el
paquete
.
La


Figura
4.2
proporciona
un
ejemplo
.
En
esta
figura
,
un
paquete
con
un
valor
de
campo
de


cabecera
de
0111
llega
a
un
router
.
El
router
busca
en
su
tabla
de
reenv√≠o
y
determina
que
la


interfaz
del
enlace
de
salida
para
este
paquete
es
la
interfaz
2
.
Despu√©s
,
el
router
reenv√≠a


internamente
el
paquete
a
la
interfaz
2
.
En
la
Secci√≥n
4.3
veremos
c√≥mo
el
router
hace
esto


y
examinaremos
la
funci√≥n
de
reenv√≠o
con
m√°s
detalle
.


Por
el
momento
,
vamos
a
ver
c√≥mo
est√°n
configuradas
las
tablas
de
reenv√≠o
en
los
rou-


ters
.
Esta
cuesti√≥n
es
crucial
,
ya
que
expone
la
importante
relaci√≥n
existente
entre
el
enruta-


miento
y
el
reenv√≠o
.
Como
se
muestra
en
la
Figura
4.2
,
el
algoritmo
de
enrutamiento


determina
los
valores
que
se
introducen
en
las
tablas
de
reenv√≠o
de
los
routers
.
El
algoritmo


de
enrutamiento
puede
estar
centralizado
(
por
ejemplo
,
con
un
algoritmo
que
se
ejecute
en


un
sitio
central
y
que
descargue
la
informaci√≥n
de
enrutamiento
en
cada
router
)
o
descentra-


lizado
(
esto
es
,
con
un
componente
del
algoritmo
de
enrutamiento
distribuido
ejecut√°ndose


en
cada
router
)
.
En
cualquier
caso
,
un
router
recibe
mensajes
del
protocolo
de
enrutamiento


que
utiliza
para
configurar
su
tabla
de
reenv√≠o
.
La
diferencia
en
los
prop√≥sitos
de
las
funcio-


nes
de
reenv√≠o
y
de
enrutamiento
puede
ilustrarse
bastante
claramente
considerando
el
caso


hipot√©tico
(
y
nada
realista
,
pero
t√©cnicamente
factible
)
de
una
red
en
la
que
todas
las
tablas


de
reenv√≠o
fueran
configuradas
directamente
por
operadores
de
red
humanos
que
estuvieran


f√≠sicamente
presentes
en
los
routers
.
En
este
caso
,
¬°
no
se
necesitar√≠an
protocolos
de
enruta-


miento
!
Por
supuesto
,
los
operadores
humanos
tendr√≠an
que
interactuar
entre
s√≠
para
garanti-


zar
que
las
tablas
de
reenv√≠o
estuvieran
configuradas
de
tal
forma
que
los
paquetes
llegaran


a
sus
destinos
.
Probablemente
tambi√©n
,
si
esta
configuraci√≥n
la
hicieran
personas
ser√≠a
m√°s


propensa
a
errores
y
mucho
m√°s
lenta
en
responder
a
los
cambios
en
la
topolog√≠a
de
la
red


que
un
protocolo
de
enrutamiento
.
Por
tanto
,
tenemos
suerte
de
que
todas
las
redes
dispon-


gan
tanto
de
la
funci√≥n
de
reenv√≠o
como
de
la
de
enrutamiento
.


Continuando
con
las
cuestiones
terminol√≥gicas
,
merece
la
pena
comentar
que
hay
otros


dos
t√©rminos
que
se
emplean
indistintamente
,
pero
que
nosotros
emplearemos
con
cuidado
.


302
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
302Reservaremos
el
t√©rmino
conmutador
de
paquetes
para
referirnos
a
un
dispositivo
de
con-


mutaci√≥n
de
paquetes
general
que
transfiere
un
paquete
desde
la
interfaz
del
enlace
de


entrada
a
la
interfaz
del
enlace
de
salida
,
de
acuerdo
con
el
valor
almacenado
en
un
campo


de
la
cabecera
del
paquete
.
Algunos
conmutadores
de
paquetes
,
denominados
conmutado-


res
de
la
capa
de
enlace
o
switches
(
que
se
examinan
en
el
Cap√≠tulo
5
)
,
basan
su
decisi√≥n


de
reenv√≠o
en
el
valor
almacenado
en
el
campo
de
la
capa
de
enlace
.
Otros
dispositivos
de


conmutaci√≥n
de
paquetes
,
conocidos
como
routers
,
basan
su
decisi√≥n
de
reenv√≠o
en
el
valor


almacenado
en
el
campo
de
la
capa
de
red
(
con
el
fin
de
apreciar
esta
importante
distinci√≥n
,


le
invitamos
a
que
repase
la
Secci√≥n
1.5.2
,
en
la
que
se
abordaron
los
datagramas
de
la
capa


de
red
y
las
tramas
de
la
capa
de
enlace
y
sus
relaciones
)
.
Puesto
que
este
cap√≠tulo
est√°
dedi-


cado
a
la
capa
de
red
,
utilizaremos
el
t√©rmino
router
en
lugar
de
dispositivo
de
conmutaci√≥n


de
paquetes
.
Emplearemos
tambi√©n
el
t√©rmino
router
cuando
hablemos
,
en
breve
,
de
los


conmutadores
de
paquetes
en
las
redes
de
circuitos
virtuales
.


Configuraci√≥n
de
la
conexi√≥n


Acabamos
de
decir
que
la
capa
de
red
realiza
dos
importantes
funciones
:
reenv√≠o
y
enruta-


miento
.
Pero
enseguida
vamos
a
ver
que
en
algunas
redes
de
computadoras
se
lleva
a
cabo


una
tercera
funci√≥n
de
la
capa
de
red
importante
:
la
configuraci√≥n
de
la
conexi√≥n
.


Recuerde
que
hemos
visto
que
en
TCP
era
necesario
llevar
a
cabo
un
proceso
de
acuerdo
en


tres
fases
antes
de
que
los
datos
pudieran
transferirse
del
emisor
al
receptor
.
Este
proceso


4.1
‚Ä¢
INTRODUCCI√ìN
303


Figura
4.2
‚Ä¢
Los
algoritmos
de
enrutamiento
determinan
los
valores
almacenados


en
la
tablas
de
reenv√≠o
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
303permit√≠a
al
emisor
y
al
receptor
configurar
la
informaci√≥n
de
estado
necesaria
(
por
ejemplo
,


el
n√∫mero
de
secuencia
y
el
tama√±o
de
la
ventana
de
control
de
flujo
)
.
De
forma
an√°loga
,


algunas
arquitecturas
de
la
capa
de
red
(
como
por
ejemplo
ATM
y
frame-relay
,
pero
no
Inter-


net
)
,
requieren
que
los
routers
a
lo
largo
de
la
ruta
seleccionada
desde
el
origen
al
destino


negocien
entre
s√≠
para
configurar
el
estado
,
antes
de
que
puedan
comenzar
a
fluir
los
paque-


tes
de
datos
de
la
capa
de
red
correspondientes
a
una
determinada
conexi√≥n
entre
el
origen
y


el
destino
.
En
la
capa
de
red
,
este
proceso
se
conoce
como
configuraci√≥n
de
la
conexi√≥n
,
la


cual
estudiaremos
en
la
Secci√≥n
4.2
.


4.1.2
Modelos
de
servicio
de
red


Antes
de
profundizar
en
la
capa
de
red
,
consideremos
desde
un
punto
de
vista
amplio
los


distintos
tipos
de
servicio
que
puede
ofrecer
esta
capa
.
Cuando
la
capa
de
transporte
de
un


host
emisor
transmite
un
paquete
a
la
red
(
es
decir
,
lo
pasa
a
la
capa
de
red
del
host
emisor
)
,


¬ø
puede
la
capa
de
transporte
contar
con
la
capa
de
red
para
entregar
el
paquete
al
destino
?


Cuando
se
env√≠an
varios
paquetes
,
¬ø
se
entregan
a
la
capa
de
transporte
del
host
receptor
en


el
orden
en
que
fueron
enviados
?
¬ø
El
intervalo
de
tiempo
entre
el
env√≠o
de
dos
transmisio-


nes
de
paquetes
secuenciales
ser√°
el
mismo
que
el
intervalo
entre
sus
respectivas
recepcio-


nes
?
¬ø
Realimentar√°
la
red
informaci√≥n
acerca
de
la
congesti√≥n
de
la
misma
?
¬ø
Cu√°l
es
la


visi√≥n
abstracta
(
las
propiedades
)
del
canal
que
conecta
la
capa
de
transporte
en
los
hosts


emisor
y
receptor
?
Las
respuestas
a
estas
y
otras
preguntas
est√°n
determinadas
por
el
modelo


de
servicio
proporcionado
por
la
capa
de
red
.
El
modelo
de
servicio
de
red
define
las
carac-


ter√≠sticas
del
transporte
terminal
a
terminal
de
los
paquetes
entre
los
sistemas
terminales


emisor
y
receptor
.


Consideremos
ahora
algunos
de
los
posibles
servicios
que
podr√≠a
proporcionar
la
capa


de
red
.
En
el
host
emisor
,
cuando
la
capa
de
transporte
pasa
un
paquete
a
la
capa
de
red
,


entre
los
servicios
espec√≠ficos
que
la
capa
de
red
podr√≠a
proporcionar
se
incluyen
:


‚Ä¢
Entrega
garantizada
.
Este
servicio
garantiza
que
el
paquete
terminar√°
por
llegar
a
su
des-


tino
.
 

‚Ä¢
Entrega
garantizada
con
retardo
limitado
.
Este
servicio
no
s√≥lo
garantiza
la
entrega
del


paquete
,
sino
que
dicha
entrega
tendr√°
un
l√≠mite
de
retardo
especificado
de
host
a
host


(
por
ejemplo
,
de
100
milisegundos
)
.


Adem√°s
,
a
un
flujo
de
paquetes
entre
un
origen
y
un
destino
dados
podr√≠an
ofrec√©rsele
los


siguientes
servicios
:


‚Ä¢
Entrega
de
los
paquetes
en
orden
.
Este
servicio
garantiza
que
los
paquetes
llegan
al
des-


tino
en
el
orden
en
que
fueron
enviados
.


‚Ä¢
Ancho
de
banda
m√≠nimo
garantizado
.
Este
servicio
de
la
capa
de
red
emula
el
comporta-


miento
de
un
enlace
de
transmisi√≥n
con
una
velocidad
de
bit
espec√≠fica
(
por
ejemplo
,
de
1


Mbps
)
entre
los
hosts
emisor
y
receptor
(
incluso
aunque
la
ruta
terminal
a
terminal
real


pueda
atravesar
varios
enlaces
f√≠sicos
)
.
Mientras
que
el
host
emisor
transmita
los
bits


(
como
parte
de
los
paquetes
)
a
una
velocidad
inferior
a
la
velocidad
de
bit
especificada
,
no


se
perder√°
ning√∫n
paquete
y
todos
los
paquetes
llegar√°n
dentro
de
un
intervalo
de
retardo


host
a
host
pre-especificado
(
por
ejemplo
,
en
40
milisegundos
.
)


‚Ä¢
Fluctuaci√≥n
m√°xima
garantizada
.
Este
servicio
garantiza
que
el
intervalo
de
tiempo
trans-


currido
entre
la
transmisi√≥n
de
dos
paquetes
sucesivos
en
el
emisor
es
igual
al
intervalo
de


304
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
304tiempo
que
transcurre
entre
su
respectiva
recepci√≥n
en
el
destino
(
es
decir
,
que
la
sepa-


raci√≥n
entre
paquetes
no
variar√°
en
una
cantidad
mayor
que
un
cierto
valor
especificado
)
.


‚Ä¢
Servicios
de
seguridad
.
Utilizando
una
clave
secreta
de
sesi√≥n
s√≥lo
conocida
por
un
host


de
origen
y
un
host
de
destino
,
la
capa
de
red
del
host
de
origen
puede
cifrar
la
carga
√∫til


de
todos
los
datagramas
que
est√°n
siendo
enviados
al
host
de
destino
.
La
capa
de
red
en


el
host
de
destino
ser√°
entonces
responsable
de
descifrar
la
carga
√∫til
.
Con
un
servicio
as√≠
,


se
proporcionar√°
confidencialidad
a
todos
los
segmentos
de
la
capa
de
transporte
(
TCP
y


UDP
)
entre
los
hosts
de
origen
y
de
destino
.
Adem√°s
de
la
confidencialidad
,
la
capa
de


red
podr√≠a
ofrecer
servicios
de
integridad
de
los
datos
y
de
autenticaci√≥n
del
origen
.


Esta
lista
s√≥lo
es
una
lista
parcial
de
los
servicios
que
la
capa
de
red
podr√≠a
proporcionar


(
existen
incontables
posibles
variaciones
)
.


La
capa
de
red
de
Internet
proporciona
un
√∫nico
servicio
conocido
como
servicio
de


mejor
esfuerzo
(
best-effort
service
)
.
De
acuerdo
con
la
Tabla
4.1
,
podr√≠a
parecer
que
al


decir
servicio
de
mejor
esfuerzo
estamos
utilizando
un
eufemismo
por
no
decir
que
no
pro-


porciona
ning√∫n
servicio
en
absoluto
.
Con
un
servicio
de
mejor
esfuerzo
,
la
temporizaci√≥n


relativa
entre
paquetes
no
est√°
garantizada
,
tampoco
est√°
garantizado
que
los
paquetes
se


reciban
en
el
orden
que
fueron
emitidos
y
tampoco
se
garantiza
la
entrega
de
los
paquetes


transmitidos
.
Por
tanto
,
teniendo
en
cuenta
esta
definici√≥n
,
una
red
que
no
entregara
los


paquetes
al
destino
satisfar√≠a
la
definici√≥n
de
servicio
de
entrega
de
mejor
esfuerzo
.
Sin


embargo
,
como
veremos
enseguida
,
existen
algunas
razones
v√°lidas
para
usar
tal
modelo


minimalista
de
servicio
de
la
capa
de
red
.
En
el
Cap√≠tulo
7
veremos
algunos
modelos
de
ser-


vicio
de
Internet
adicionales
,
que
todav√≠a
est√°n
evolucionando
.


Otras
arquitecturas
de
red
han
definido
e
implementado
modelos
de
servicio
que
van


m√°s
all√°
que
el
servicio
de
mejor
esfuerzo
de
Internet
.
Por
ejemplo
,
la
arquitectura
de
red


ATM
 
[
MFA
Forum
2009
,
Black
1995
]
proporciona
varios
modelos
de
servicio
,
lo
que
sig-


nifica
que
diferentes
conexiones
pueden
ofrecer
distintas
clases
de
servicio
dentro
de
la


misma
red
.
Una
exposici√≥n
acerca
de
c√≥mo
una
red
ATM
proporciona
tales
servicios
queda


fuera
del
√°mbito
de
este
libro
:
nuestro
fin
aqu√≠
es
√∫nicamente
destacar
que
existen
alternati-


vas
al
modelo
de
mejor
esfuerzo
de
Internet
.
Dos
de
los
modelos
de
servicio
de
ATM
m√°s


importantes
son
el
el
servicio
CBR
(
Constant
Bit
Rate
,
tasa
de
bit
constante
)
y
el
servicio


ABR
(
Available
Bit
Rate
,
tasa
de
bit
disponible
):


Arquitectura
Modelo
de
Garant√≠a
de
G
arant√≠a
Indicaci√≥n
de


de
red
servicio
ancho
de
banda
sin
p√©rdidas
Orden
Temporizaci√≥n
congesti√≥n


Internet
Mejor
Ninguna
Ninguna
Posible
No
se
Ninguna


esfuerzo
cualquier
mantiene


orden


ATM
CBR
Velocidad
S√≠
En
orden
Se
No
se


constante
mantiene
produce


garantizada
congesti√≥n


ATM
ABR
M√≠nimo
Ninguna
En
orden
No
se
S√≠


garantizado
mantiene


Tabla
4.1
‚Ä¢
Modelos
de
servicio
de
Internet
,
y
CBR
y
ABR
de
redes
ATM
.


4.1
‚Ä¢
INTRODUCCI√ìN
305


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
305‚Ä¢
Servicio
CBR
de
las
redes
ATM.Este
fue
el
primer
modelo
de
servicio
de
las
redes
ATM


en
ser
estandarizado
,
lo
que
refleja
el
temprano
inter√©s
de
las
compa√±√≠as
telef√≥nicas
en
la


tecnolog√≠a
ATM
y
la
adecuaci√≥n
del
servicio
CBR
para
el
transporte
de
tr√°fico
de
audio
y


v√≠deo
en
tiempo
real
con
una
tasa
de
bit
constante
.
El
objetivo
del
servicio
CBR
es
con-


ceptualmente
simple
:
proporcionar
un
flujo
de
paquetes
(
conocido
como
celdas
en
la
ter-


minolog√≠a
ATM
)
mediante
un
conducto
virtual
cuyas
propiedades
son
las
mismas
que
si


existiera
un
enlace
de
transmisi√≥n
de
ancho
de
banda
fijo
dedicado
entre
los
hosts
emisor


y
receptor
.
Con
el
servicio
CBR
,
un
flujo
de
celdas
ATM
se
transporta
a
trav√©s
de
la
red


de
tal
forma
que
se
garantiza
que
el
retardo
terminal
a
terminal
de
una
celda
,
la
variabili-


dad
del
retardo
terminal
a
terminal
de
una
celda
(
es
decir
,
el
jitter
o
fluctuaci√≥n
entre
cel-


das
)
y
la
fracci√≥n
de
celdas
que
se
pierden
o
que
se
entregan
tarde
sean
todos
ellos


menores
que
una
serie
de
valores
previamente
especificados
.
El
host
emisor
y
la
red


ATM
acuerdan
estos
valores
cuando
la
conexi√≥n
CBR
se
establece
por
primera
vez
.


‚Ä¢
Servicio
ABR
de
las
redes
ATM
.
Dado
que
Internet
ofrece
lo
que
se
denomina
un
servi-


cio
de
mejor
esfuerzo
,
el
servicio
ABR
de
ATM
puede
caracterizarse
mejor
como
un
ser-


vicio
ligeramente
superior
al
de
mejor
esfuerzo
.
Como
con
el
modelo
de
servicio
de


Internet
,
las
celdas
se
pueden
perder
con
un
servicio
ABR
.
Sin
embargo
,
a
diferencia
de


Internet
,
las
celdas
no
se
pueden
reordenar
(
aunque
pueden
perderse
)
y
est√°
garantizada


la
velocidad
m√≠nima
de
transmisi√≥n
de
celda
(
MCR
,
Minimum
Cell
transmission
Rate
)


de
una
conexi√≥n
utilizando
el
servicio
ABR
.
Si
la
red
tiene
los
suficientes
recursos
libres


en
un
instante
determinado
,
un
emisor
tambi√©n
puede
ser
capaz
de
enviar
con
√©xito
cel-


das
a
una
velocidad
mayor
que
la
m√≠nima
(
MCR
)
.
Adicionalmente
,
como
hemos
visto
en


la
Secci√≥n
3.6
,
el
servicio
ABR
de
las
redes
ATM
puede
proporcionar
una
realimenta-


ci√≥n
al
emisor
(
en
t√©rminos
de
bit
de
notificaci√≥n
de
congesti√≥n
,
o
una
velocidad


expl√≠cita
a
la
que
enviar
)
que
controla
el
modo
en
que
el
emisor
ajusta
su
velocidad


entre
la
MCR
y
un
cierto
valor
m√°ximo
de
velocidad
de
celda
.


4.2
Redes
de
circuitos
virtuales
y
de
datagramas


Recuerde
del
Cap√≠tulo
3
que
la
capa
de
transporte
puede
ofrecer
a
las
aplicaciones
un
servi-


cio
sin
conexi√≥n
o
un
servicio
orientado
a
la
conexi√≥n
.
Por
ejemplo
,
la
capa
de
transporte
de


Internet
proporciona
a
cada
aplicaci√≥n
la
posibilidad
de
elegir
entre
dos
servicios
:
UDP
,
un


servicio
sin
conexi√≥n
;
o
TCP
,
un
servicio
orientado
a
la
conexi√≥n
.
De
forma
similar
,
una


capa
de
red
tambi√©n
puede
proporcionar
un
servicio
sin
conexi√≥n
o
un
servicio
con
cone-


xi√≥n
.
Estos
servicios
de
la
capa
de
red
con
y
sin
conexi√≥n
son
paralelos
en
muchos
sentidos


a
los
servicios
de
la
capa
de
transporte
orientados
a
la
conexi√≥n
y
sin
conexi√≥n
.
Por
ejemplo
,


un
servicio
de
la
capa
de
red
orientado
a
la
conexi√≥n
comienza
con
un
proceso
de
acuerdo


entre
los
hosts
de
origen
y
de
destino
;
y
un
servicio
de
la
capa
de
red
sin
conexi√≥n
no
realiza


ninguna
tarea
preliminar
de
acuerdo
.


Aunque
los
servicios
con
y
sin
conexi√≥n
de
la
capa
de
red
presentan
algunos
paralelis-


mos
con
los
correspondientes
servicios
de
la
capa
de
transporte
,
tambi√©n
presentan
diferen-


cias
importantes
:


‚Ä¢E
n
 
l
a
 
c
a
p
a
 
d
e
 
r
e
d
,
 
e
s
t
o
s
 
s
e
r
v
i
c
i
o
s
 
s
o
n
 
s
e
r
v
i
c
i
o
s
 
h
o
s
t
 
a
 
h
o
s
t
 
p
r
o
p
o
r
c
i
o
n
a
d
o
s
 
p
o
r
 
l
a
 
c
a
p
a
 
d
e


red
a
la
capa
de
transporte
.
En
la
capa
de
transporte
,
estos
servicios
son
servicios
proceso


a
proceso
proporcionados
por
la
capa
de
transporte
a
la
capa
de
aplicaci√≥n
.


306
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
306‚Ä¢
En
las
principales
arquitecturas
de
redes
de
computadoras
utilizadas
hasta
la
fecha
(
Inter-


net
,
ATM
,
frame
relay
,
etc.
)
,
la
capa
de
red
proporciona
bien
un
servicio
sin
conexi√≥n


host
a
host
o
un
servicio
orientado
a
la
conexi√≥n
host
a
host
,
pero
no
ambos
.
Las
redes
de


computadoras
que
s√≥lo
proporcionan
un
servicio
de
conexi√≥n
en
la
capa
de
red
se
cono-


cen
como
redes
de
circuitos
virtuales
(
VC
)
;
las
redes
que
s√≥lo
proporcionan
un
servicio


sin
conexi√≥n
en
la
capa
de
red
se
denominan
redes
de
datagramas
.


‚Ä¢L
a
s
 
i
m
p
l
e
m
e
n
t
a
c
i
o
n
e
s
 
d
e
l
 
s
e
r
v
i
c
i
o
 
o
r
i
e
n
t
a
d
o
 
a
 
l
a
 
c
o
n
e
x
i
√≥
n
 
e
n
 
l
a
 
c
a
p
a
 
d
e
 
t
r
a
n
s
p
o
r
t
e
 
y
 
e
l


servicio
con
conexi√≥n
de
la
capa
de
red
son
fundamentalmente
distintos
.
Sabemos
del


cap√≠tulo
anterior
que
el
servicio
de
la
capa
de
transporte
orientado
a
la
conexi√≥n
se
imple-


menta
en
la
frontera
de
la
red
en
los
sistemas
terminales
;
enseguida
veremos
que
el
servi-


cio
de
conexi√≥n
de
la
capa
de
red
se
implementa
en
los
routers
del
n√∫cleo
de
la
red
,
as√≠


como
en
los
sistemas
terminales
.


Las
redes
de
circuitos
virtuales
y
de
datagramas
son
dos
clases
fundamentales
de
redes
de


computadoras
.
Utilizan
informaci√≥n
muy
diferente
a
la
hora
de
tomar
decisiones
de
reenv√≠o
.


Veamos
a
continuaci√≥n
sus
implementaciones
.


4.2.1
Redes
de
circuitos
virtuales


Hemos
estudiado
que
Internet
es
una
red
de
datagramas
.
Sin
embargo
,
muchas
arquitecturas


de
red
alternativas
(
incluyendo
las
de
ATM
y
frame
relay
)
son
redes
de
circuitos
virtuales
y
,


por
tanto
,
utilizan
conexiones
en
la
capa
de
red
.
Estas
conexiones
de
la
capa
de
red
se
deno-


minan
circuitos
virtuales
(
VC
)
.
Veamos
ahora
c√≥mo
se
puede
implementar
un
servicio
VC


en
una
red
de
computadoras
.


Un
circuito
virtual
consta
de
(
1
)
una
ruta
(
es
decir
,
una
serie
de
enlaces
y
routers
)
entre


los
hosts
de
origen
y
de
destino
,
(
2
)
n√∫meros
de
VC
,
un
n√∫mero
para
cada
enlace
a
lo
largo


de
la
ruta
y
(
3
)
entradas
en
la
tabla
de
reenv√≠o
de
cada
router
existente
a
lo
largo
de
la
ruta
.


Un
paquete
que
pertenece
a
un
circuito
virtual
transportar√°
un
n√∫mero
de
VC
en
su
cabe-


cera
.
Dado
que
un
circuito
virtual
puede
tener
un
n√∫mero
de
VC
diferente
en
cada
enlace
,


cada
router
interviniente
tiene
que
sustituir
el
n√∫mero
de
VC
de
cada
paquete
que
le
atra-


viesa
por
un
nuevo
n√∫mero
de
VC
.
Este
nuevo
n√∫mero
de
VC
se
obtiene
de
la
tabla
de
reen-


v√≠o
.


Para
ilustrar
este
concepto
,
considere
la
red
mostrada
en
la
Figura
4.3
.
Los
n√∫meros
que


hay
junto
a
los
enlaces
de
R1
en
esta
figura
son
los
n√∫meros
de
interfaz
de
enlace
.
Suponga


que
el
host
A
solicita
a
la
red
que
establezca
un
VC
entre
√©l
mismo
y
el
host
B.
Suponga
tam-


bi√©n
que
la
red
elige
el
camino
A-R1-R2-B
y
asigna
los
n√∫meros
de
VC
12
,
22
y
32
a
los


4.2
‚Ä¢
REDES
DE
CIRCUITOS
VIRTUALES
Y
DE
DATAGRAMAS
307


Figura
4.3
‚Ä¢
Una
red
simple
de
circuitos
virtuales
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
307tres
enlaces
de
ese
camino
para
este
circuito
virtual
.
En
este
caso
,
cuando
un
paquete
en
este


circuito
virtual
abandona
el
host
A
,
el
valor
almacenado
en
el
campo
n√∫mero
de
VC
de
la


cabecera
del
paquete
es
12
;
cuando
sale
de
R1
,
el
valor
es
22
;
y
cuando
sale
de
R2
,
es
32
.


¬ø
C√≥mo
determina
el
router
el
n√∫mero
de
VC
de
sustituci√≥n
para
un
paquete
que
le
atra-


viesa
?
En
una
red
de
circuitos
virtuales
,
la
tabla
de
reenv√≠o
de
cada
router
incluye
la
traduc-


ci√≥n
del
n√∫mero
de
VC
;
por
ejemplo
,
la
tabla
de
reenv√≠o
de
R1
ser√≠a
similar
a
la
siguiente
:


Interfaz
de
entrada
N¬∫
de
VC
de
entrada
Interfaz
de
salida
N¬∫
de
VC
salida


11
222
2


26
311
8


37
2
1
7


19
738
7


...
...
...
...


Cuando
se
configura
un
n√∫mero
de
VC
nuevo
en
un
router
,
se
a√±ade
una
entrada
a
la


tabla
de
reenv√≠o
.
De
forma
similar
,
cuando
un
VC
termina
,
las
entradas
apropiadas
de
cada


tabla
a
lo
largo
de
la
ruta
se
eliminan
.


Es
posible
que
se
est√©
preguntando
por
qu√©
un
paquete
no
mantiene
el
mismo
n√∫mero


de
VC
en
cada
uno
de
los
enlaces
de
su
ruta
.
La
raz√≥n
es
doble
.
En
primer
lugar
,
reemplazar


el
n√∫mero
en
cada
enlace
reduce
la
longitud
del
campo
n√∫mero
de
VC
de
la
cabecera
del


paquete
.
La
segunda
raz√≥n
,
y
m√°s
importante
,
es
que
la
configuraci√≥n
del
VC
se
simplifica


considerablemente
permitiendo
un
n√∫mero
de
VC
diferente
en
cada
enlace
a
lo
largo
de
la


ruta
del
circuito
virtual
.
Espec√≠ficamente
,
con
m√∫ltiples
n√∫meros
de
VC
,
cada
enlace
de
la


ruta
puede
elegir
un
n√∫mero
de
VC
,
independientemente
de
los
n√∫meros
de
VC
elegidos
en


los
restantes
enlaces
a
lo
largo
de
la
ruta
.
Si
se
precisara
un
n√∫mero
de
VC
com√∫n
para
todos


los
enlaces
de
la
ruta
,
los
routers
tendr√≠an
que
intercambiar
y
procesar
un
n√∫mero
sustancial


de
mensajes
para
acordar
un
n√∫mero
de
VC
com√∫n
(
por
ejemplo
,
uno
que
no
estuviera


siendo
utilizado
por
cualquier
otro
VC
existente
en
esos
routers
)
que
utilizar
en
una
cone-


xi√≥n
.


En
una
red
de
circuitos
virtuales
,
los
routers
de
la
red
tienen
que
mantener
informaci√≥n


de
estado
de
la
conexi√≥n
para
las
conexiones
activas
.
Espec√≠ficamente
,
cada
vez
que
se


establece
una
conexi√≥n
nueva
en
un
router
,
tiene
que
a√±adirse
una
nueva
entrada
de
cone-


xi√≥n
a
la
tabla
de
reenv√≠o
del
router
;
y
cada
vez
que
una
conexi√≥n
se
libera
,
la
entrada
debe


borrarse
de
la
tabla
.
Observe
que
incluso
si
no
existe
un
mecanismo
de
traducci√≥n
de
los


n√∫meros
de
VC
,
seguir√°
siendo
necesario
mantener
informaci√≥n
del
estado
de
la
conexi√≥n


que
permita
asociar
los
n√∫meros
de
VC
con
los
n√∫meros
de
las
interfaces
de
salida
.
El
pro-


blema
de
si
un
router
mantiene
o
no
la
informaci√≥n
del
estado
de
la
conexi√≥n
para
cada
cone-


xi√≥n
activa
es
crucial
,
y
volveremos
repetidamente
sobre
esta
cuesti√≥n
a
lo
largo
del
libro
.


En
un
circuito
virtual
existen
tres
fases
identificables
:


‚Ä¢
Configuraci√≥n
del
VC
.
Durante
la
fase
de
configuraci√≥n
,
la
capa
de
transporte
del
emisor


contacta
con
la
capa
de
red
,
especifica
la
direcci√≥n
del
receptor
y
espera
a
que
la
red
con-


figure
el
circuito
virtual
.
La
capa
de
red
determina
la
ruta
entre
el
emisor
y
el
receptor
;
es


decir
,
la
serie
de
enlaces
y
routers
a
trav√©s
de
los
que
todos
los
paquetes
del
VC
tendr√°n


que
viajar
.
La
capa
de
red
tambi√©n
determina
el
n√∫mero
de
VC
para
cada
enlace
de
la


308
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3084.2
‚Ä¢
REDES
DE
CIRCUITOS
VIRTUALES
Y
DE
DATAGRAMAS
309


ruta
.
Por
√∫ltimo
,
la
capa
de
red
a√±ade
una
entrada
a
la
tabla
de
reenv√≠o
de
cada
router


existente
a
lo
largo
de
la
ruta
.
Durante
la
configuraci√≥n
del
VC
,
la
capa
de
red
tambi√©n


puede
reservar
recursos
(
por
ejemplo
,
ancho
de
banda
)
a
lo
largo
de
la
ruta
del
VC
.


‚Ä¢
Transferencia
de
datos
.
Como
se
muestra
en
la
Figura
4.4
,
una
vez
que
se
ha
establecido


el
circuito
virtual
,
los
paquetes
pueden
comenzar
a
fluir
a
lo
largo
del
mismo
.


‚Ä¢
Terminaci√≥n
del
VC
.
Esta
fase
se
inicia
cuando
el
emisor
(
o
el
receptor
)
informa
a
la
capa


de
red
de
su
deseo
de
terminar
el
circuito
virtual
.
Normalmente
,
la
capa
de
red
informar√°


al
sistema
terminal
del
otro
lado
de
la
red
de
la
terminaci√≥n
de
la
llamada
y
actualizar√°


las
tablas
de
reenv√≠o
de
cada
uno
de
los
routers
de
la
ruta
,
para
indicar
que
ese
circuito


virtual
ya
no
existe
.


Existe
una
sutil
pero
importante
distinci√≥n
entre
la
configuraci√≥n
del
VC
en
la
capa
de


red
y
la
configuraci√≥n
de
la
conexi√≥n
en
la
capa
de
transporte
(
por
ejemplo
,
el
proceso
de


acuerdo
en
tres
fases
de
TCP
que
hemos
estudiado
en
el
Cap√≠tulo
3
)
.
La
configuraci√≥n
de
la


conexi√≥n
en
la
capa
de
transporte
s√≥lo
implica
a
los
dos
sistemas
terminales
.
Durante
la
con-


figuraci√≥n
de
la
conexi√≥n
de
la
capa
de
transporte
,
los
dos
sistemas
terminales
solos
determi-


nan
los
par√°metros
(
por
ejemplo
,
el
n√∫mero
de
secuencia
inicial
y
el
tama√±o
de
la
ventana
de


control
de
flujo
)
de
su
conexi√≥n
de
la
capa
de
transporte
.
Aunque
los
dos
sistemas
terminales


son
conscientes
de
la
conexi√≥n
de
la
capa
de
transporte
,
los
routers
de
la
red
la
ignoran
por


completo
.
Por
el
contrario
,
en
la
capa
de
red
de
un
circuito
virtual
los
routers
existentes
a
lo


largo
de
la
ruta
entre
los
dos
sistemas
terminales
est√°n
implicados
en
la
configuraci√≥n
del


VC
y
cada
router
es
completamente
consciente
de
todos
los
VC
que
pasan
a
trav√©s
de
√©l
.


Los
mensajes
que
los
sistemas
terminales
env√≠an
a
la
red
para
iniciar
o
terminar
un
VC


y
los
mensajes
pasados
entre
los
routers
para
configurar
el
VC
(
es
decir
,
para
modificar
el


estado
de
conexi√≥n
en
las
tablas
de
los
routers
)
se
conocen
como
mensajes
de
se√±alizaci√≥n


y
los
protocolos
empleados
para
intercambiar
estos
mensajes
a
menudo
se
denominan
pro-


tocolos
de
se√±alizaci√≥n
.
En
la
Figura
4.4
se
muestra
gr√°ficamente
la
configuraci√≥n
del
VC
.


En
este
libro
no
vamos
a
estudiar
los
protocolos
de
se√±alizaci√≥n
de
los
circuitos
virtuales
;


puede
consultar
[
Black
1997
]
para
ver
una
exposici√≥n
general
sobre
la
se√±alizaci√≥n
en
las


redes
orientadas
a
la
conexi√≥n
y
[
ITU-T
Q.2931
1994
]
para
ver
la
especificaci√≥n
del
proto-


colo
de
se√±alizaci√≥n
Q.2931
de
ATM
.


Red
Se
inicia
el
flujo


Figura
4.4
‚Ä¢
Configuraci√≥n
del
circuito
virtual
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3094.2.2
Redes
de
datagramas


En
una
red
de
datagramas
,
cada
vez
que
un
sistema
terminal
desea
enviar
un
paquete


marca
el
paquete
con
la
direcci√≥n
del
sistema
terminal
de
destino
y
luego
introduce
el


paquete
en
la
red
.
Como
se
muestra
en
la
Figura
4.5
,
esto
se
hace
sin
configurar
ning√∫n
cir-


cuito
virtual
.
Los
routers
de
una
red
de
datagramas
no
mantienen
ninguna
informaci√≥n
de


estado
acerca
de
los
circuitos
virtuales
(
¬°
porque
no
existe
ning√∫n
circuito
virtual
!
)
.


Cuando
un
paquete
se
transmite
desde
un
origen
a
un
destino
pasa
a
trav√©s
de
una
serie


de
routers
.
Cada
uno
de
estos
routers
utiliza
la
direcci√≥n
de
destino
del
paquete
para
reen-


viar
dicho
paquete
.
Espec√≠ficamente
,
cada
router
tiene
una
tabla
de
reenv√≠o
que
asigna
direc-


ciones
de
destino
a
interfaces
de
enlace
;
cuando
un
paquete
llega
a
un
router
,
√©ste
utiliza
la


direcci√≥n
de
destino
del
paquete
para
buscar
la
interfaz
del
enlace
de
salida
apropiado
en
la


tabla
de
reenv√≠o
.
Despu√©s
,
el
router
reenv√≠a
intencionadamente
el
paquete
a
esa
interfaz
del


enlace
de
salida
.


Profundicemos
algo
m√°s
en
la
operaci√≥n
de
b√∫squeda
mediante
un
ejemplo
concreto
.


Suponga
que
todas
las
direcciones
de
destino
tienen
una
longitud
de
32
bits
(
que
es
la
longi-


tud
de
la
direcci√≥n
de
destino
de
un
datagrama
IP
)
.
Una
implementaci√≥n
por
fuerza
bruta
de


la
tabla
de
reenv√≠o
tendr√≠a
una
entrada
para
cada
una
de
las
posibles
direcciones
de
destino
.


Dado
que
existen
m√°s
de
4.000
millones
de
posibles
direcciones
,
esta
opci√≥n
est√°
totalmente


fuera
de
lugar
(
requerir√≠a
una
tabla
de
reenv√≠o
enormemente
grande
)
.


Supongamos
ahora
que
nuestro
router
tiene
cuatro
enlaces
,
numerados
de
0
a
3
,
y
que


los
paquetes
deben
ser
reenviados
a
las
interfaces
de
enlace
como
sigue
:


Rango
de
direcciones
de
destino
Interfaz
de
enlace


11001000
00010111
00010000
00000000


hasta
0


11001000
00010111
00010111
11111111


11001000
00010111
00011000
00000000


hasta
1


11001000
00010111
00011000
11111111


11001000
00010111
00011001
00000000


hasta
2


11001000
00010111
00011111
11111111


en
otro
caso
3


Evidentemente
,
para
este
ejemplo
no
es
necesario
disponer
de
4.000
millones
de
entradas
en


la
tabla
de
reenv√≠o
del
router
.
Podr√≠amos
,
por
ejemplo
,
tener
la
siguiente
tabla
de
reenv√≠o


con
s√≥lo
cuatro
entradas
:


Coincidencia
de
prefijo
Interfaz
de
enlace


11001000
00010111
00010
0


11001000
00010111
00011000
1


11001000
00010111
00011
2


en
otro
caso
3


310
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
310Con
este
tipo
de
tabla
de
reenv√≠o
,
el
router
busca
la
coincidencia
de
un
prefijo
de
la
direc-


ci√≥n
de
destino
del
paquete
con
las
entradas
de
la
tabla
;
si
existe
una
coincidencia
,
el
router


reenv√≠a
el
paquete
a
un
enlace
asociado
con
esa
coincidencia
.
Por
ejemplo
,
suponga
que
la


direcci√≥n
de
destino
del
paquete
es
11001000
00010111
00010110
10100001
;
puesto
que
el


prefijo
de
21
bits
de
esta
direcci√≥n
coincide
con
la
primera
entrada
de
la
tabla
,
el
router
reen-


v√≠a
el
paquete
a
la
interfaz
de
enlace
0
.
Si
un
prefijo
no
se
corresponde
con
ninguna
de
las


tres
primeras
entradas
,
entonces
el
router
reenv√≠a
el
paquete
a
la
interfaz
3
.
Aunque
este


m√©todo
puede
parecer
bastante
simple
,
esconde
una
importante
sutileza
.
Es
posible
que
se


haya
dado
cuenta
de
que
la
direcci√≥n
de
destino
puede
corresponderse
con
m√°s
de
una


entrada
.
Por
ejemplo
,
los
primeros
24
bits
de
la
direcci√≥n
11001000
00010111
00011000


10101010
coinciden
con
la
segunda
entrada
de
la
tabla
y
los
primeros
21
bits
con
la
tercera


entrada
de
la
tabla
.
Cuando
existen
varias
coincidencias
,
el
router
aplica
la
regla
de
coinci-


dencia
con
el
prefijo
m√°s
largo
;
es
decir
,
busca
la
entrada
m√°s
larga
de
la
tabla
con
la
que


exista
una
coincidencia
y
reenv√≠a
el
paquete
a
la
interfaz
de
enlace
asociada
con
el
prefijo


m√°s
largo
.
Cuando
estudiemos
con
m√°s
detalle
,
en
la
Secci√≥n
4.4
,
el
direccionamiento
de


Internet
veremos
por
qu√©
se
utiliza
esta
regla
de
coincidencia
con
el
prefijo
m√°s
largo
.


Aunque
los
routers
en
las
redes
de
datagramas
no
mantienen
informaci√≥n
del
estado
de


la
conexi√≥n
,
s√≠
mantienen
informaci√≥n
del
estado
de
reenv√≠o
en
sus
tablas
de
reenv√≠o
.
Sin


embargo
,
la
escala
de
tiempo
a
la
que
esta
informaci√≥n
del
estado
de
reenv√≠o
cambia
es
rela-


tivamente
lenta
.
De
hecho
,
en
una
red
de
datagramas
las
tablas
de
reenv√≠o
son
modificadas


por
los
algoritmos
de
enrutamiento
,
que
normalmente
actualizan
una
tabla
de
reenv√≠o
en


intervalos
aproximados
de
entre
uno
y
cinco
minutos
.
En
una
red
de
circuitos
virtuales
,
la


tabla
de
reenv√≠o
de
un
router
se
modifica
cada
vez
que
se
configura
una
nueva
conexi√≥n
a


trav√©s
del
router
o
cuando
una
conexi√≥n
existente
en
el
router
se
termina
.
Este
proceso
puede


tener
lugar
con
una
escala
de
tiempo
del
orden
de
microsegundos
en
un
router
troncal
de


nivel
1
.


Puesto
que
las
tablas
de
reenv√≠o
en
las
redes
de
datagramas
pueden
ser
modificadas
en


cualquier
instante
,
una
serie
de
paquetes
enviados
desde
un
sistema
terminal
a
otro
puede


seguir
caminos
distintos
a
trav√©s
de
la
red
y
pueden
llegar
desordenados
.
[
Paxson
1997
]
y


[
Jaiswal
2003
]
presentan
estudios
interesantes
de
medici√≥n
para
la
reordenaci√≥n
de
paquetes


y
otros
fen√≥menos
de
Internet
.


4.2
‚Ä¢
REDES
DE
CIRCUITOS
VIRTUALES
Y
DE
DATAGRAMAS
311


Figura
4.5
‚Ä¢
Red
de
datagramas
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3114.2.3
Or√≠genes
de
las
redes
de
circuitos
virtuales
y
de
datagramas


La
evoluci√≥n
de
las
redes
de
datagramas
y
de
circuitos
virtuales
refleja
sus
or√≠genes
.
La
idea


de
un
circuito
virtual
como
principio
de
organizaci√≥n
central
tiene
sus
ra√≠ces
en
el
mundo
de


la
telefon√≠a
,
que
utiliza
circuitos
reales
.
Al
mantenerse
la
configuraci√≥n
y
el
estado
de
las


llamadas
en
los
routers
de
la
red
,
una
red
de
circuitos
virtuales
es
indiscutiblemente
m√°s


compleja
que
una
red
de
datagramas
(
aunque
puede
consultar
[
Molinero-Fern√°ndez
2002
]


para
ver
una
interesante
comparaci√≥n
de
la
complejidad
de
las
redes
de
circuitos
y
las
redes


de
conmutaci√≥n
de
paquetes
)
.
Esto
tambi√©n
se
debe
a
su
herencia
del
campo
de
la
telefon√≠a
.


Las
redes
telef√≥nicas
,
por
necesidad
,
manten√≠an
la
complejidad
dentro
de
la
red
,
ya
que
esta-


ban
conectadas
a
dispositivos
terminales
no
inteligentes
,
como
los
tel√©fonos
de
disco
.
Para


aquellos
que
sean
demasiado
j√≥venes
como
para
saberlo
,
un
tel√©fono
de
disco
es
un
tel√©fono


anal√≥gico
sin
teclas
,
y
con
s√≥lo
un
dial
.


Por
otro
lado
,
Internet
,
como
red
de
datagramas
,
creci√≥
a
partir
de
la
necesidad
de


conectar
computadoras
entre
s√≠
.
Con
dispositivos
terminales
sofisticados
,
los
arquitectos
de


Internet
prefirieron
hacer
que
el
modelo
de
servicio
de
la
capa
de
red
fuera
lo
m√°s
simple


posible
.
Como
ya
hemos
visto
en
los
Cap√≠tulos
2
y
3
,
las
funcionalidades
adicionales
,
como


por
ejemplo
la
entrega
de
los
datos
en
orden
,
la
transferencia
de
datos
fiable
,
el
control
de


congesti√≥n
y
la
resoluci√≥n
de
nombres
DNS
,
se
implementan
en
una
capa
m√°s
alta
en
los


sistemas
terminales
.
Esto
invierte
el
modelo
de
las
redes
de
telefon√≠a
,
lo
que
tiene
algunas


consecuencias
interesantes
:


‚Ä¢P
u
e
s
t
o
 
q
u
e
 
e
l
 
m
o
d
e
l
o
 
d
e
 
s
e
r
v
i
c
i
o
 
d
e
 
l
a
 
c
a
p
a
 
d
e
 
r
e
d
 
d
e
 
I
n
t
e
r
n
e
t
 
p
r
o
p
o
r
c
i
o
n
a
 
u
n
a
s
 
g
a
r
a
n
t
√≠
a
s


de
servicio
m√≠nimas
(
¬°
ninguna
!
)
,
impone
unos
requisitos
m√≠nimos
a
la
capa
de
red
.
Esto


hace
que
sea
m√°s
f√°cil
interconectar
redes
que
utilizan
tecnolog√≠as
de
la
capa
de
enlace


muy
diferentes
(
por
ejemplo
,
conexi√≥n
v√≠a
sat√©lite
,
Ethernet
,
fibra
o
radio
)
y
que
presen-


tan
caracter√≠sticas
de
p√©rdidas
y
velocidades
de
transmisi√≥n
muy
distintas
.
Veremos
en


detalle
la
interconexi√≥n
de
redes
IP
en
la
Secci√≥n
4.4
.


‚Ä¢C
o
m
o
 
h
e
m
o
s
 
v
i
s
t
o
 
e
n
 
e
l
 
C
a
p
√≠
t
u
l
o
 
2
,
 
l
a
s
 
a
p
l
i
c
a
c
i
o
n
e
s
 
t
a
l
e
s
 
c
o
m
o
 
e
l
 
c
o
r
r
e
o
 
e
l
e
c
t
r
√≥
n
i
c
o
,
 
l
a


Web
e
incluso
un
servicio
como
el
de
DNS
(
centralizado
en
la
capa
de
red
)
se
implemen-


tan
en
hosts
(
servidores
)
situados
en
la
frontera
de
la
red
.
La
capacidad
de
a√±adir
un


nuevo
servicio
simplemente
conectando
un
host
a
la
red
y
definiendo
un
nuevo
protocolo


de
la
capa
de
aplicaci√≥n
(
como
HTTP
)
ha
permitido
a
las
nuevas
aplicaciones
como
la


Web
implantarse
en
Internet
en
un
periodo
de
tiempo
extremadamente
corto
.


Como
veremos
en
el
Cap√≠tulo
7
,
existe
un
debate
importante
en
la
comunidad
de
Inter-


net
acerca
de
c√≥mo
deber√≠a
evolucionar
la
arquitectura
de
la
capa
de
red
de
Internet
para
dar


soporte
a
los
servicios
en
tiempo
real
,
como
por
ejemplo
multimedia
.
En
[
Crowcroft
1995
]


puede
encontrar
una
interesante
comparaci√≥n
de
la
arquitectura
de
red
de
ATM
,
orientada
a


circuitos
virtuales
,
y
de
una
arquitectura
propuesta
para
la
Internet
de
siguiente
generaci√≥n
.


4.3
El
interior
de
un
router


Ahora
que
ya
hemos
visto
una
introducci√≥n
a
las
funciones
y
servicios
de
la
capa
de
red
,


vamos
a
prestar
atenci√≥n
a
la
funci√≥n
de
reenv√≠o
de
la
capa
de
red
:
la
transferencia
real
de


paquetes
desde
los
enlaces
de
entrada
de
un
router
a
los
apropiados
enlaces
de
salida
.
Ya


hemos
hablado
brevemente
de
algunos
de
los
problemas
de
la
funci√≥n
de
reenv√≠o
en
la
Sec-


312
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
312ci√≥n
4.2
;
en
concreto
,
del
direccionamiento
y
de
la
coincidencia
con
el
prefijo
m√°s
largo
.
En


esta
secci√≥n
veremos
arquitecturas
de
router
espec√≠ficas
para
la
transferencia
de
paquetes


desde
los
enlaces
de
entrada
a
los
enlaces
de
salida
.
Nuestra
exposici√≥n
va
a
ser
necesaria-


mente
breve
,
ya
que
se
necesitar√≠a
un
curso
completo
para
cubrir
en
profundidad
el
dise√±o


de
un
router
.
En
consecuencia
,
haremos
un
esfuerzo
especial
en
esta
secci√≥n
para
proporcio-


nar
referencias
a
textos
que
abordan
este
tema
con
m√°s
detalle
.
Ya
hemos
comentado
que
los


profesionales
e
investigadores
dedicados
al
mundo
de
las
redes
de
computadoras
suelen


emplear
indistintamente
los
t√©rminos
reenv√≠oy
conmutaci√≥n
,
por
lo
que
nosotros
utilizare-


mos
ambos
t√©rminos
en
el
libro
.


En
la
Figura
4.6
se
muestra
un
esquema
general
de
la
arquitectura
de
un
router
gen√©-


rico
.
En
un
router
,
podemos
identificar
los
cuatro
componentes
siguientes
:


‚Ä¢
Puertos
de
entrada
.
El
puerto
de
entrada
realiza
varias
funciones
.
Lleva
a
cabo
las
fun-


ciones
de
la
capa
f√≠sica
(
representadas
por
el
recuadro
situado
m√°s
a
la
izquierda
del


puerto
de
entrada
y
el
recuadro
m√°s
a
la
derecha
del
puerto
de
salida
en
la
Figura
4.6
)


consistentes
en
la
terminaci√≥n
de
un
enlace
f√≠sico
de
entrada
a
un
router
.
Realiza
las
fun-


ciones
de
la
capa
de
enlace
de
datos
(
representadas
por
los
recuadros
centrales
de
los


puertos
de
entrada
y
de
salida
)
necesarias
para
interoperar
con
las
funciones
de
la
capa


de
enlace
de
datos
en
el
lado
remoto
del
enlace
de
entrada
.
Tambi√©n
realiza
una
funci√≥n


de
b√∫squeda
y
reenv√≠o
(
el
recuadro
m√°s
a
la
derecha
del
puerto
de
entrada
y
el
recuadro


m√°s
a
la
izquierda
del
puerto
de
salida
)
de
modo
que
un
paquete
reenviado
dentro
del


entramado
de
conmutaci√≥n
del
router
emerge
en
el
puerto
de
salida
apropiado
.
Los


paquetes
de
control
(
por
ejemplo
,
paquetes
que
transportan
la
informaci√≥n
del
protocolo


de
enrutamiento
)
son
reenviados
desde
un
puerto
de
entrada
al
procesador
de
enruta-


miento
.
En
la
pr√°ctica
,
suelen
agruparse
varios
puertos
en
una
√∫nica
tarjeta
de
l√≠nea


(
line
card
)
dentro
del
router
.


‚Ä¢
Entramado
de
conmutaci√≥n
.
El
entramado
de
conmutaci√≥n
conecta
los
puertos
de


entrada
del
router
a
sus
puertos
de
salida
.
Este
entramado
de
conmutaci√≥n
est√°
completa-


mente
contenido
dentro
del
router
:
¬°
una
red
dentro
de
un
router
de
red
!


4.3
‚Ä¢
EL
INTERIOR
DE
UN
ROUTER
313


Figura
4.6
‚Ä¢
Arquitectura
de
un
router
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
313‚Ä¢
Puertos
de
salida
.
Un
puerto
de
salida
almacena
los
paquetes
que
le
han
sido
reenviados


a
trav√©s
del
entramado
de
conmutaci√≥n
y
los
transmite
al
enlace
de
salida
.
As√≠
,
el
puerto


de
salida
lleva
a
cabo
la
funci√≥n
inversa
de
la
capa
f√≠sica
y
de
la
capa
de
enlace
de
datos


que
el
puerto
de
entrada
.
Cuando
un
enlace
es
bidireccional
(
es
decir
,
transporta
tr√°fico


en
ambas
direcciones
)
,
un
puerto
de
salida
del
enlace
normalmente
estar√°
emparejado


con
otro
puerto
de
entrada
de
dicho
enlace
en
la
misma
tarjeta
de
l√≠nea
.


‚Ä¢
Procesador
de
enrutamiento
.
El
procesador
de
enrutamiento
ejecuta
los
protocolos
de


enrutamiento
(
por
ejemplo
,
los
protocolos
que
se
estudian
en
la
Secci√≥n
4.6
)
,
mantiene
la


informaci√≥n
de
enrutamiento
y
las
tablas
de
reenv√≠o
y
realiza
funciones
de
gesti√≥n
de
red


(
v√©ase
el
Cap√≠tulo
9
)
dentro
del
router
.


En
las
siguientes
subsecciones
veremos
los
puertos
de
entrada
,
el
entramado
de
conmu-


taci√≥n
y
los
puertos
de
salida
en
m√°s
detalle
.
[
Chuang
2005
;
Keslassy
2003
;
Chao
2001
;
Tur-


ner
1988
;
Giacopelli
1990
;
McKeown
1997a
;
Partridge
1998
]
proporcionan
informaci√≥n


acerca
de
algunas
arquitecturas
de
router
espec√≠ficas
.
[
McKeown
1997b
]
proporciona
una


introducci√≥n
particularmente
f√°cil
de
comprender
de
las
arquitecturas
de
router
actuales
,
uti-


lizando
el
router
12000
de
Cisco
como
ejemplo
.
Para
concretar
,
en
la
siguiente
exposici√≥n


suponemos
que
la
red
de
computadoras
es
una
red
de
paquetes
y
que
las
decisiones
de
reen-


v√≠o
est√°n
basadas
en
la
direcci√≥n
de
los
paquetes
(
en
lugar
de
en
un
n√∫mero
de
VC
de
una


red
de
circuitos
virtuales
)
.
No
obstante
,
los
conceptos
y
t√©cnicas
son
similares
para
una
red


de
circuitos
virtuales
.


4.3.1
Puertos
de
entrada


En
la
Figura
4.7
se
muestra
un
esquema
detallado
de
la
funcionalidad
de
un
puerto
de


entrada
.
Como
hemos
comentado
anteriormente
,
la
funci√≥n
de
terminaci√≥n
de
l√≠nea
y
el
pro-


cesamiento
de
enlace
de
datos
del
puerto
de
entrada
implementan
las
capas
f√≠sica
y
de
enlace


de
datos
asociadas
con
un
enlace
individual
de
entrada
al
router
.
El
m√≥dulo
de
b√∫squeda/


reenv√≠o
del
puerto
de
entrada
resulta
crucial
para
la
funci√≥n
de
reenv√≠o
del
router
.
En


muchos
routers
,
es
aqu√≠
donde
el
router
determina
el
puerto
de
salida
al
que
ser√°
reenviado


un
paquete
entrante
a
trav√©s
del
entramado
de
conmutaci√≥n
.
La
elecci√≥n
del
puerto
de
salida


se
lleva
a
cabo
utilizando
la
informaci√≥n
almacenada
en
la
tabla
de
reenv√≠o
.
Aunque
el
pro-


cesador
de
enrutamiento
calcula
la
tabla
de
reenv√≠o
,
suele
almacenarse
una
copia
 
de
la


misma
en
cada
puerto
de
entrada
,
la
cual
es
actualizada
seg√∫n
sea
necesario
por
el
procesa-


dor
de
enrutamiento
.
Con
las
copias
locales
de
la
tabla
de
reenv√≠o
,
la
decisi√≥n
de
reenv√≠o


puede
tomarse
localmente
en
cada
puerto
de
entrada
sin
invocar
al
procesador
de
enruta-


314
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.7
‚Ä¢
Procesamiento
en
el
puerto
de
entrada
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
314miento
centralizado
.
Tales
reenv√≠os
descentralizados
evitan
que
se
formen
cuellos
de
botella


en
el
procesamiento
de
reenv√≠os
en
un
√∫nico
punto
dentro
del
router
.


En
los
routers
con
capacidades
de
procesamiento
limitadas
en
el
puerto
de
entrada
,
√©ste


puede
simplemente
reenviar
el
paquete
al
procesador
de
enrutamiento
centralizado
,
el
cual


entonces
har√°
una
b√∫squeda
en
la
tabla
de
reenv√≠o
y
transmite
el
paquete
al
puerto
de
salida


apropiado
.
√âsta
es
la
t√©cnica
que
se
aplica
cuando
una
estaci√≥n
de
trabajo
o
un
servidor
se


emplea
como
un
router
;
en
este
caso
,
el
procesador
de
enrutamiento
es
realmente
la
CPU
de


la
estaci√≥n
de
trabajo
y
el
puerto
de
entrada
es
una
tarjeta
de
interfaz
de
red
(
por
ejemplo
,


una
tarjeta
Ethernet
)
.


Disponiendo
de
una
tabla
de
reenv√≠o
,
la
operaci√≥n
de
b√∫squeda
resulta
conceptualmente


simple
:
basta
con
recorrer
la
tabla
de
reenv√≠o
hasta
localizar
la
coincidencia
con
el
prefijo


m√°s
largo
,
como
se
ha
descrito
en
la
Secci√≥n
4.2.2
.
Sin
embargo
,
en
la
pr√°ctica
,
las
cosas


no
son
tan
sencillas
.
Quiz√°
el
factor
m√°s
importante
que
lo
complica
es
que
los
routers


troncales
tienen
que
operar
a
velocidades
altas
,
realizando
millones
de
b√∫squedas
por


segundo
.
De
hecho
,
es
deseable
que
el
procesamiento
en
el
puerto
de
entrada
pueda
rea-


lizarse
a
la
velocidad
de
l√≠nea
,
es
decir
,
de
manera
que
una
b√∫squeda
se
lleve
a
cabo
en


menos
tiempo
que
el
necesario
para
recibir
un
paquete
a
trav√©s
del
puerto
de
entrada
.
En
este


4.3
‚Ä¢
EL
INTERIOR
DE
UN
ROUTER
315


CISCO
SYSTEMS
:
DOMINIO
DEL
N√öCLEO
DE
LA
RED


En
el
momento
de
escribir
esto
(
octubre
de
2008
)
,
Cisco
emplea
a
m√°s
de
65.000
personas
.


Actualmente
,
Cisco
domina
el
mercado
de
los
routers
de
Internet
y
en
los
√∫ltimos
a√±os
ha


entrado
en
el
mercado
de
la
telefon√≠a
por
Internet
,
donde
compite
con
empresas
l√≠deres
dedi-


cadas
a
equipos
de
telefon√≠a
como
Lucent
,
Alcatel
,
Nortel
y
Siemens
.
¬ø
C√≥mo
naci√≥
este


monstruo
de
empresa
dedicada
a
las
redes
?
Todo
empez√≥
en
1984
en
el
cuarto
de
estar
de


un
apartamento
en
Silicon
Valley
.


Len
Bosak
y
su
esposa
Sandy
Lerner
estaban
trabajando
en
la
Universidad
de
Stanford


cuando
tuvieron
la
idea
de
crear
y
vender
routers
Internet
a
instituciones
acad√©micas
y
de


investigaci√≥n
.
Sandy
Lerner
invent√≥
el
nombre
de
Cisco
(
una
abreviatura
de
San
Francisco
)
,
y


tambi√©n
dise√±√≥
el
logotipo
del
puente
que
identifica
a
la
empresa
.
Sus
oficinas
corporativas


estaban
en
su
cuarto
de
estar
y
financiaron
el
proyecto
con
tarjetas
de
cr√©dito
y
trabajos
de


consultor√≠a
en
horas
libres
.
A
finales
de
1986
,
los
ingresos
de
Cisco
alcanzaban
los
250.000


d√≥lares
mensuales
.
A
finales
de
1987
,
Cisco
logr√≥
atraer
inversores
de
capital
riesgo
:


2
millones
de
d√≥lares
de
Sequoia
Capital
a
cambio
de
una
tercera
parte
de
la
compa√±√≠a
.
A
lo


largo
de
los
a√±os
siguientes
,
Cisco
continu√≥
creciendo
y
consiguiendo
cada
vez
una
mayor


cuota
de
mercado
.
Al
mismo
tiempo
,
las
relaciones
entre
Bosak
/
Lerner
y
la
direcci√≥n
de
Cisco


comenzaron
a
tensarse
.
Cisco
empez√≥
a
cotizar
en
bolsa
en
1990
;
ese
mismo
a√±o
,
Lerner
y


Bosak
dejaban
la
compa√±√≠a
.


A
lo
largo
de
los
a√±os
,
Cisco
se
ha
expandido
m√°s
all√°
del
mercado
de
los
routers
,
y
vende


servicios
y
productos
de
seguridad
,
inal√°mbricos
y
de
voz
sobre
IP
.
Sin
embargo
,
Cisco
se


enfrenta
a
una
creciente
competencia
internacional
,
que
incluye
a
Huawei
,
una
compa√±√≠a


china
de
r√°pido
crecimiento
dedicada
al
mercado
de
las
redes
.
Otras
empresas
competidoras


de
Cisco
en
el
campo
de
los
routers
y
de
las
redes
Ethernet
conmutadas
son
Alcatel-Lucent
y


Juniper
.


HISTORIA


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
315caso
,
el
procesamiento
de
entrada
de
un
paquete
recibido
puede
completarse
antes
de
que
se


concluya
la
siguiente
operaci√≥n
de
recepci√≥n
.
Para
hacerse
una
idea
de
los
requisitos
de
ren-


dimiento
de
una
b√∫squeda
,
considere
que
un
enlace
OC-48
opera
a
2,5
Gbps
.
Con
paquetes


cuya
longitud
es
de
256
bytes
,
esto
implica
una
velocidad
de
b√∫squeda
de
aproximadamente


1
mill√≥n
de
b√∫squedas
por
segundo
.


Debido
a
la
necesidad
actual
de
operar
a
velocidades
de
enlace
altas
,
una
b√∫squeda


lineal
a
trav√©s
de
una
tabla
de
reenv√≠o
grande
es
imposible
.
Una
t√©cnica
m√°s
razonable
con-


siste
en
almacenar
las
entradas
de
la
tabla
de
reenv√≠o
en
una
estructura
de
datos
en
√°rbol
.


Cada
nivel
del
√°rbol
puede
interpretarse
como
el
correspondiente
a
un
bit
de
la
direcci√≥n
de


destino
.
Para
buscar
una
direcci√≥n
,
simplemente
se
comienza
por
el
nodo
ra√≠z
del
√°rbol
.


Si
el
primer
bit
de
la
direcci√≥n
es
cero
,
entonces
el
sub√°rbol
de
la
izquierda
contendr√°
la


entrada
de
la
tabla
de
reenv√≠o
correspondiente
a
la
direcci√≥n
de
destino
;
en
cualquier
otro


caso
,
se
encontrar√°
en
el
sub√°rbol
de
la
derecha
.
A
continuaci√≥n
,
se
recorre
el
sub√°rbol


apropiado
utilizando
los
restantes
bits
de
la
direcci√≥n
(
si
el
siguiente
bit
es
cero
,
se
elegir√°


el
sub√°rbol
izquierdo
del
sub√°rbol
inicial
;
en
otro
caso
,
se
seleccionar√°
el
sub√°rbol
derecho


del
sub√°rbol
inicial
)
.
De
esta
forma
,
es
posible
buscar
la
entrada
de
la
tabla
de
reenv√≠o
en


N
pasos
,
siendo
N
el
n√∫mero
de
bits
de
la
direcci√≥n
(
observe
que
se
trata
de
una
b√∫squeda


binaria
en
un
espacio
de
direcciones
de
tama√±o
2
N
)
.
En
[
Srinivasan
1999
]
se
describe
una


mejora
de
las
t√©cnicas
de
b√∫squeda
binaria
y
puede
encontrar
un
estudio
general
de
los
algo-


ritmos
de
clasificaci√≥n
de
paquetes
en
[
Gupta
2001
]
.


Pero
incluso
con
N
=
32
pasos
(
por
ejemplo
,
para
una
direcci√≥n
IP
de
32
bits
)
,
la
veloci-


dad
en
una
b√∫squeda
binaria
no
es
lo
suficientemente
r√°pida
para
los
requisitos
de
enruta-


miento
de
una
red
troncal
actual
.
Por
ejemplo
,
suponiendo
un
acceso
a
memoria
en
cada


paso
,
se
podr√≠an
realizar
menos
de
un
mill√≥n
de
b√∫squedas
de
direcciones
por
segundo
con


un
tiempo
de
acceso
a
memoria
de
40
ns
.
Por
tanto
,
ha
sido
necesario
explorar
otras
t√©cnicas


con
el
fin
de
incrementar
las
velocidades
de
b√∫squeda
.
Las
memorias
direccionables
por


contenido
(
CAM
,
Content
Addressable
Memory
)
permiten
acceder
a
la
memoria
mediante


una
direcci√≥n
IP
de
32
bits
,
devolviendo
la
memoria
el
contenido
de
la
correspondiente


entrada
de
la
tabla
de
reenv√≠o
en
un
tiempo
pr√°cticamente
constante
.
Los
routers
de
la
serie


8500
de
Cisco
utilizan
una
CAM
de
64k
para
cada
puerto
de
entrada
.


Otra
t√©cnica
que
permite
acelerar
las
b√∫squedas
consiste
en
mantener
las
entradas
de
la


tabla
de
reenv√≠o
a
las
que
se
ha
accedido
recientemente
en
una
cach√©
[
Feldmeier
1988
]
.
En


este
caso
,
el
problema
se
encuentra
en
el
tama√±o
potencial
de
la
cach√©
.
Se
han
propuesto


tambi√©n
estructuras
de
datos
r√°pidas
,
que
permiten
localizar
las
entradas
de
la
tabla
de
reen-


v√≠o
en
log(N
)
pasos
[
Waldvogel
1997
]
,
o
que
comprimen
las
tablas
de
reenv√≠o
en
formas
ori-


ginales
[
Brodnik
1997
]
.
En
[
Gupta
1998
]
se
expone
una
t√©cnica
hardware
de
b√∫squeda
que


est√°
optimizada
para
el
caso
com√∫n
en
el
que
las
direcciones
que
tienen
que
localizarse
tie-


nen
24
o
menos
bits
significativos
.
Para
ver
un
estudio
y
una
taxonom√≠a
de
los
algoritmos


de
b√∫squeda
de
direcciones
IP
de
alta
velocidad
,
consulte
[
Ruiz-S√°nchez
2001
]
.


Una
vez
que
se
ha
determinado
el
puerto
de
salida
para
un
paquete
mediante
una
b√∫s-


queda
,
el
paquete
puede
ser
reenviado
hacia
el
entramado
de
conmutaci√≥n
.
Sin
embargo
,
un


paquete
puede
ver
temporalmente
bloqueada
su
entrada
en
el
entramado
de
conmutaci√≥n


(
porque
los
paquetes
de
otros
puertos
de
entrada
pueden
estar
utilizando
en
este
momento


dicho
entramado
)
.
En
ese
caso
,
el
paquete
bloqueado
deber√°
ponerse
en
cola
en
el
puerto
de


entrada
y
planificarse
para
cruzar
el
entramado
de
conmutaci√≥n
en
un
momento
posterior
.


En
la
Secci√≥n
4.3.4
veremos
m√°s
en
detalle
el
proceso
de
bloqueo
,
puesta
en
cola
y
planifi-


caci√≥n
de
los
paquetes
(
tanto
en
los
puertos
de
entrada
como
de
salida
)
dentro
de
un
router
.


316
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3164.3.2
Entramado
de
conmutaci√≥n


El
entramado
de
conmutaci√≥n
se
encuentra
en
el
coraz√≥n
de
un
router
.
Es
a
trav√©s
de
este


entramado
donde
los
paquetes
son
realmente
conmutados
(
es
decir
,
reenviados
)
desde
un


puerto
de
entrada
a
un
puerto
de
salida
.
La
conmutaci√≥n
puede
llevarse
a
cabo
de
varias
for-


mas
,
como
se
muestra
en
la
Figura
4.8
:


‚Ä¢
Conmutaci√≥n
v√≠a
memoria
.
Los
primeros
routers
m√°s
simples
eran
computadoras
tradi-


cionales
en
las
que
la
conmutaci√≥n
entre
los
puertos
de
entrada
y
de
salida
se
realizaba


bajo
el
control
directo
de
la
CPU
(
procesador
de
enrutamiento
)
.
Los
puertos
de
entrada
y


de
salida
funcionaban
como
dispositivos
de
E
/
S
tradicionales
en
un
sistema
operativo
tra-


dicional
.
El
puerto
de
entrada
al
que
llegaba
un
paquete
enviaba
una
se√±al
en
primer


lugar
al
procesador
de
enrutamiento
mediante
una
interrupci√≥n
.
A
continuaci√≥n
,
el


paquete
se
copiaba
desde
el
puerto
entrada
en
la
memoria
del
procesador
.
Despu√©s
,
el


procesador
de
enrutamiento
extra√≠a
la
direcci√≥n
de
destino
de
la
cabecera
,
buscaba
en
la


tabla
de
reenv√≠o
el
puerto
de
salida
apropiado
y
copiaba
el
paquete
en
los
buffers
del


puerto
de
salida
.
Observe
que
si
el
ancho
de
banda
de
la
memoria
es
tal
que
pueden
escri-


birse
en
,
o
leerse
de
,
la
memoria
B
paquetes
por
segundo
,
entonces
la
tasa
de
transferen-


cia
global
de
reenv√≠o
(
la
velocidad
total
a
la
que
los
paquetes
se
transfieren
desde
los


puertos
de
entrada
a
los
de
salida
)
tiene
que
ser
menor
que
B/2
.


Muchos
routers
modernos
tambi√©n
realizan
la
conmutaci√≥n
v√≠a
memoria
.
Sin
embargo
,


una
diferencia
importante
con
los
primeros
routers
es
que
los
procesadores
de
las
tarjetas


4.3
‚Ä¢
EL
INTERIOR
DE
UN
ROUTER
317


Figura
4.8
‚Ä¢
Tres
t√©cnicas
de
conmutaci√≥n
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
317de
l√≠nea
de
entrada
se
encargan
de
realizar
la
b√∫squeda
de
la
direcci√≥n
de
destino
y
de


almacenar
el
paquete
en
la
posici√≥n
de
memoria
adecuada
.
De
alguna
forma
,
los
routers


que
conmutan
v√≠a
memoria
se
parecen
mucho
a
los
multiprocesadores
de
memoria
com-


partida
,
encarg√°ndose
los
procesadores
de
una
tarjeta
de
l√≠nea
de
conmutar
los
paquetes


hacia
la
memoria
del
puerto
de
salida
apropiado
.
Los
dispositivos
de
conmutaci√≥n
(
swit-


ches
)
de
la
serie
Catalyst
8500
de
Cisco
[
Cisco
8500
2009
]
reenv√≠an
los
paquetes


mediante
una
memoria
compartida
.
Puede
encontrar
un
modelo
abstracto
para
el
estu-


dio
de
las
propiedades
de
la
conmutaci√≥n
basada
en
memoria
y
una
comparaci√≥n
con


otros
m√©todos
de
conmutaci√≥n
en
[
Iyer
2002
]
.


‚Ä¢
Conmutaci√≥n
v√≠a
bus
.
Con
esta
t√©cnica
,
el
puerto
de
entrada
transfiere
directamente
un


paquete
al
puerto
de
salida
a
trav√©s
de
un
bus
compartido
sin
intervenci√≥n
del
procesa-


dor
de
enrutamiento
(
observe
que
con
la
conmutaci√≥n
v√≠a
memoria
,
el
paquete
tambi√©n


ten√≠a
que
atravesar
el
bus
del
sistema
para
ir
y
venir
de
la
memoria
)
.
Aunque
el
proce-


sador
de
enrutamiento
no
est√°
implicado
en
la
transferencia
del
bus
,
puesto
que
se
trata


de
un
bus
compartido
,
s√≥lo
es
posible
transferir
un
paquete
cada
vez
a
trav√©s
del
bus
.


Un
paquete
que
llega
a
un
puerto
de
entrada
y
se
encuentra
con
que
el
bus
est√°
ocupado


con
la
transferencia
de
otro
paquete
queda
bloqueado
y
no
se
le
permite
atravesar
el


entramado
de
conmutaci√≥n
,
poni√©ndose
en
cola
en
el
puerto
de
entrada
.
Puesto
que


todos
los
paquetes
tienen
que
atravesar
el
√∫nico
bus
,
el
ancho
de
banda
de
conmuta-


ci√≥n
del
router
est√°
limitado
por
la
velocidad
del
bus
.


Puesto
que
con
la
tecnolog√≠a
actual
es
posible
disponer
de
anchos
de
banda
de
bus
de


aproximadamente
1
Gbps
,
la
conmutaci√≥n
v√≠a
bus
suele
ser
suficiente
para
routers
que


operan
en
redes
de
acceso
y
empresariales
(
como
por
ejemplo
,
redes
locales
y
corporati-


vas
)
.
La
conmutaci√≥n
basada
en
bus
ha
sido
adoptada
en
bastantes
routers
actuales
,
inclu-


yendo
los
Cisco
5600
[
Cisco
Switches
2009
]
,
que
conmutan
los
paquetes
sobre
un
bus


de
tipo
backplane
de
32
Gbps
.


‚Ä¢
Conmutaci√≥n
v√≠a
una
red
de
interconexi√≥n
.
Una
forma
de
soslayar
la
limitaci√≥n
del
ancho


de
banda
de
un
√∫nico
bus
compartido
consiste
en
emplear
una
red
de
interconexi√≥n
m√°s


sofisticada
,
como
las
que
se
han
empleado
en
el
pasado
para
interconectar
procesadores


en
una
arquitectura
de
computadora
multiprocesador
.
Un
conmutador
de
malla
(
crossbar


switch
)
es
una
red
de
interconexi√≥n
que
consta
de
2
n
buses
que
conectan
n
puertos
de


entrada
a
n
puertos
de
salida
,
como
se
muestra
en
la
Figura
4.8
.
Un
paquete
que
llega
a


un
puerto
de
entrada
viaja
a
lo
largo
del
bus
horizontal
conectado
al
puerto
de
entrada


hasta
intersectar
con
el
bus
vertical
que
le
dirige
al
puerto
de
salida
deseado
.
Si
este
bus


vertical
est√°
libre
,
el
paquete
se
transfiere
al
puerto
de
salida
.
Si
el
bus
vertical
est√°
siendo


utilizado
para
transferir
un
paquete
procedente
de
otro
puerto
de
entrada
a
este
mismo


puerto
de
salida
,
el
paquete
entrante
quedar√°
bloqueado
y
en
cola
en
el
puerto
de
entrada
.


Los
entramados
de
conmutaci√≥n
Delta
y
Omega
tambi√©n
han
sido
propuestos
como
una


red
de
interconexi√≥n
entre
los
puertos
de
entrada
y
de
salida
.
Consulte
[
Tobagi
1990
]


para
ver
un
estudio
sobre
las
arquitecturas
de
los
conmutadores
.
Los
conmutadores
o


switches
de
la
familia
12000
de
Cisco
[
Cisco
12000
2009
]
utilizan
una
red
de
intercone-


xi√≥n
,
proporcionando
60
Gbps
en
el
entramado
de
conmutaci√≥n
.
Una
tendencia
en
el


dise√±o
de
redes
de
interconexi√≥n
[
Keshav
1998
]
es
la
de
fragmentar
un
paquete
IP
de
lon-


gitud
variable
en
celdas
de
longitud
fija
,
y
despu√©s
etiquetar
y
conmutar
dichas
celdas
a


trav√©s
de
la
red
de
interconexi√≥n
.
Estas
celdas
son
reensambladas
despu√©s
para
volver
a


formar
el
paquete
original
en
el
puerto
de
salida
.
Las
celdas
de
longitud
fija
y
las
etique-


318
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
318tas
internas
pueden
simplificar
y
acelerar
considerablemente
la
conmutaci√≥n
del
paquete


a
trav√©s
de
la
red
de
interconexi√≥n
.


4.3.3
Puertos
de
salida


El
procesamiento
en
los
puertos
de
salida
,
como
se
muestra
en
la
Figura
4.9
,
toma
los
paque-


tes
que
hayan
sido
almacenados
en
la
memoria
del
puerto
de
salida
y
los
transmite
a
trav√©s


del
enlace
de
salida
.
El
procesamiento
del
protocolo
de
enlace
de
datos
y
la
terminaci√≥n
de


l√≠nea
son
funcionalidades
de
las
capas
f√≠sica
y
de
enlace
del
lado
emisor
que
interact√∫an
con


el
puerto
de
entrada
en
el
otro
extremo
del
enlace
de
salida
,
como
se
ha
visto
en
la
Secci√≥n


4.3.1
.
La
funcionalidad
de
gesti√≥n
de
la
cola
y
de
buffer
es
necesaria
cuando
el
entramado


de
conmutaci√≥n
suministra
paquetes
al
puerto
de
salida
a
una
velocidad
mayor
que
la
velo-


cidad
del
enlace
de
salida
;
m√°s
adelante
veremos
la
gesti√≥n
de
la
cola
en
los
puertos
de


salida
.


4.3.4
¬ø
D√≥nde
se
crean
colas
?


Si
nos
fijamos
en
la
funcionalidad
de
los
puertos
de
entrada
y
de
salida
,
y
en
las
configura-


ciones
mostradas
en
la
Figura
4.8
,
es
evidente
que
pueden
formarse
colas
de
paquetes
en
los


puertos
de
entrada
y
en
los
puertos
de
salida
.
Es
importante
estudiar
estas
colas
con
un
poco


m√°s
de
detalle
,
ya
que
a
medida
que
estas
colas
crecen
,
el
espacio
disponible
en
el
buffer


del
router
terminar√°
agot√°ndose
y
se
producir√°
una
p√©rdida
de
paquetes
.
Recuerde
que
en


nuestras
explicaciones
anteriores
hemos
dicho
que
los
paquetes
se
perd√≠an
dentro
de
la
red
o


eran
descartados
por
un
router
.
Por
tanto
,
es
en
estas
colas
de
los
routers
donde
los
paquetes


realmente
se
descartan
y
se
pierden
.
El
lugar
en
el
que
se
pierde
el
paquete
(
en
las
colas
del


puerto
de
entrada
o
en
las
colas
del
puerto
de
salida
)
depender√°
de
la
carga
de
tr√°fico
,
de
la


velocidad
relativa
del
entramado
de
conmutaci√≥n
y
de
la
velocidad
de
l√≠nea
,
como
veremos


enseguida
.


Suponga
que
las
velocidades
de
l√≠nea
de
entrada
y
las
velocidades
de
l√≠nea
de
salida
son


todas
ellas
id√©nticas
y
que
existen
n
puertos
de
entrada
y
n
puertos
de
salida
.
Definimos
la


velocidad
del
entramado
de
conmutaci√≥n
como
la
velocidad
a
la
que
dicho
entramado


puede
mover
los
paquetes
desde
los
puertos
de
entrada
hasta
los
puertos
de
salida
.
Si
la
velo-


cidad
del
entramado
de
conmutaci√≥n
es
al
menos
n
veces
mayor
que
la
velocidad
de
l√≠nea
de


entrada
,
entonces
nunca
habr√°
colas
en
los
puertos
de
entrada
.
Esto
es
as√≠
,
porque
incluso
en


el
caso
peor
,
en
el
que
las
n
l√≠neas
de
entrada
est√©n
recibiendo
paquetes
,
el
conmutador
podr√°


transferir
n
paquetes
desde
el
puerto
de
entrada
al
de
salida
en
el
tiempo
que
tarda
cada
uno


de
los
n
puertos
de
entrada
en
recibir
(
simult√°neamente
)
un
√∫nico
paquete
.
¬ø
Pero
,
qu√©
puede


4.3
‚Ä¢
EL
INTERIOR
DE
UN
ROUTER
319


Figura
4.9
‚Ä¢
Procesamiento
del
puerto
de
salida
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
319ocurrir
en
los
puertos
de
salida
?
Supongamos
adem√°s
que
la
estructura
de
conmutaci√≥n
es
al


menos
n
veces
tan
r√°pida
como
las
velocidades
de
l√≠nea
.
En
el
caso
peor
,
los
paquetes
entran-


tes
por
cada
uno
de
los
n
puertos
de
entrada
estar√°n
destinados
al
mismo
puerto
de
salida
.
En


dicho
caso
,
durante
el
tiempo
que
se
tarda
en
recibir
(
o
enviar
)
un
√∫nico
paquete
,
llegar√°n
n


paquetes
a
este
puerto
de
salida
.
Dado
que
el
puerto
de
salida
s√≥lo
puede
transmitir
un
√∫nico


paquete
en
una
unidad
de
tiempo
(
el
tiempo
de
transmisi√≥n
de
paquete
)
,
los
n
paquetes


entrantes
se
pondr√°n
en
cola
(
a
esperar
)
para
poder
ser
transmitidos
por
el
enlace
de
salida
.
A


continuaci√≥n
,
posiblemente
puedan
llegar
n
paquetes
m√°s
en
el
tiempo
que
se
tarda
en
trans-


mitir
uno
solo
de
los
n
paquetes
que
previamente
se
han
introducido
en
la
cola
,
y
as√≠
sucesi-


vamente
.
Finalmente
,
el
n√∫mero
de
paquetes
en
cola
podr√≠a
crecer
lo
suficiente
como
para


agotar
el
espacio
de
memoria
en
el
puerto
de
salida
,
en
cuyo
caso
los
paquetes
ser√°n
descarta-


dos
.


La
cola
del
puerto
de
salida
se
muestra
en
la
Figura
4.10
.
En
el
instante
t
ha
llegado
un


paquete
a
cada
uno
de
los
puertos
de
entrada
,
y
todos
ellos
est√°n
destinados
al
puerto
de


salida
situado
m√°s
arriba
.
Suponiendo
velocidades
de
l√≠nea
id√©nticas
y
un
conmutador
ope-


rando
a
tres
veces
la
velocidad
de
l√≠nea
,
una
unidad
de
tiempo
despu√©s
(
es
decir
,
en
el
tiempo


que
se
necesita
para
recibir
o
enviar
un
paquete
)
los
tres
paquetes
originales
habr√°n
sido


transferidos
al
puerto
de
salida
y
estar√°n
en
cola
esperando
a
ser
transmitidos
.
En
la


siguiente
unidad
de
tiempo
,
uno
de
estos
tres
paquetes
habr√°
sido
transmitido
a
trav√©s
del


enlace
de
salida
.
En
nuestro
ejemplo
,
llegan
dos
nuevos
paquetes
a
la
entrada
del
dispositivo


de
conmutaci√≥n
y
uno
de
estos
paquetes
tambi√©n
tiene
como
destino
el
puerto
de
salida
de


m√°s
arriba
.


320
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.10
‚Ä¢
Puesta
en
cola
en
el
puerto
de
salida
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
320Dado
que
los
buffers
de
los
routers
son
necesarios
para
absorber
las
fluctuaciones
de
la


carga
de
tr√°fico
,
es
natural
plantearse
qu√©
espacio
de
buffer
ser√°
necesario
.
Durante
muchos


a√±os
,
la
regla
heur√≠stica
[
RFC
3439
]
que
se
empleaba
para
determinar
el
tama√±o
del
buffer


era
que
la
cantidad
de
espacio
de
buffer
(
B
)
deb√≠a
ser
igual
al
valor
medio
del
tiempo
de
ida


y
vuelta
(
RTT
,
digamos
250
milisegundos
)
por
la
capacidad
del
enlace
(
C
)
.
Este
resultado


est√°
basado
en
el
an√°lisis
de
la
din√°mica
de
colas
de
un
n√∫mero
relativamente
peque√±o
de


flujos
  
TCP
[
Villamizar
1994
]
.
Por
tanto
,
un
enlace
a
10
Gbps
con
un
RTT
de
250
milise-


gundos
 
necesitar√≠a
un
espacio
de
buffer
igual
a
B
=
RTT
¬∑
C
=
2,5
Gbits
.
Sin
embargo
,


recientes
esfuerzos
te√≥ricos
y
experimentales
[
Appenzeller
2004
]
sugieren
que
cuando


existe
un
n√∫mero
grande
de
flujos
TCP
(
N
)
atravesando
un
enlace
,
la
cantidad
de
espacio
en


buffer
necesaria
es
B
=
RTT
 
C/ 
N
‚Äî
.
Con
una
gran
cantidad
de
flujos
atravesando
los
enla-


ces
de
router
troncales
(
v√©ase
por
ejemplo
[
Fraleigh
2003
]
)
,
el
valor
de
N
puede
ser
grande
,


con
lo
que
la
reducci√≥n
del
tama√±o
de
buffer
necesario
se
hace
bastante
significativa
.


[
Appenzellar
2004
;
Wischik
2005
;
Beheshti
2008
]
proporcionan
una
serie
de
estudios
com-


prensibles
acerca
del
problema
del
tama√±o
del
buffer
desde
los
puntos
de
vista
te√≥rico
,
de


implementaci√≥n
y
operacional
.


Una
consecuencia
de
las
colas
de
los
puertos
de
salida
es
que
un
planificador
de


paquetes
en
dicho
puerto
deber√°
elegir
un
paquete
de
entre
aquellos
que
est√°n
en
cola
espe-


rando
a
ser
transmitidos
.
Esta
selecci√≥n
podr√≠a
llevarse
a
cabo
bas√°ndose
en
algo
simple
,


como
por
ejemplo
una
planificaci√≥n
FCFS
(
First-Come-First-Served
,
el
primero
que
llega


es
el
primero
que
se
sirve
)
,
o
en
una
planificaci√≥n
m√°s
sofisticada
,
como
por
ejemplo
las


colas
ponderadas
equitativas
(
WFQ
,
Weighted
Fair
Queuing
)
,
que
comparten
el
enlace
de


salida
equitativamente
entre
las
distintas
conexiones
terminal
a
terminal
que
tienen
paquetes


en
cola
esperando
a
ser
transmitidos
.
La
planificaci√≥n
de
paquetes
desempe√±a
un
papel
fun-


damental
en
proporcionar
las
garant√≠as
de
la
calidad
del
servicio
.
En
el
Cap√≠tulo
7
se
cubre


ampliamente
la
planificaci√≥n
de
paquetes
.
Puede
encontrar
una
exposici√≥n
sobre
las
disci-


plinas
de
planificaci√≥n
de
paquetes
en
los
puertos
de
salida
en
[
Cisco
Queue
2009
]
.


De
forma
similar
,
si
no
hay
disponible
bastante
memoria
para
almacenar
en
buffer
un


paquete
entrante
,
tiene
que
tomarse
la
decisi√≥n
bien
de
descartar
dicho
paquete
(
una
pol√≠tica


conocida
como
drop-tail
o
eliminaci√≥n
del
√∫ltimo
)
o
bien
de
eliminar
uno
o
m√°s
paquetes


de
los
que
ya
est√°n
en
cola
para
hacer
sitio
al
paquete
que
acaba
de
llegar
.
En
algunos
casos
,


puede
ser
una
ventaja
descartar
(
o
marcar
la
cabecera
de
)
un
paquete
antes
de
que
el
buffer


est√©
lleno
,
con
el
fin
de
proporcionar
una
indicaci√≥n
de
congesti√≥n
al
emisor
.
En
[
Labrador


1999
,
Hollot
2002
]
se
proponen
y
analizan
una
serie
de
pol√≠ticas
para
descartar
y
marcar


paquetes
,
que
colectivamente
se
conocen
como
algoritmos
AQM
(
Active
Queue
Manage-


ment
,
Gesti√≥n
activa
de
colas
)
.
Uno
de
los
algoritmos
AQM
m√°s
ampliamente
estudiados


e
implementados
es
el
algoritmo
RED
(
Random
Early
Detection
,
Detecci√≥n
aleatoria
tem-


prana
)
.
Con
RED
se
mantiene
una
media
ponderada
de
la
longitud
de
la
cola
de
salida
.
Si
la


longitud
media
de
la
cola
es
menor
que
un
umbral
m√≠nimo
,
minth
,
cuando
llega
un
paquete


√©ste
es
admitido
en
la
cola
.
Inversamente
,
si
la
cola
est√°
llena
o
la
longitud
media
de
la


misma
es
mayor
que
un
umbral
m√°ximo
,
maxth
,
cuando
llega
un
paquete
√©ste
se
marca
o
se


descarta
.
Por
√∫ltimo
,
si
llega
un
paquete
y
la
longitud
media
de
la
cola
se
encuentra
dentro


del
intervalo
[
minth
,
maxth
]
,
el
paquete
se
marca
o
se
descarta
con
una
probabilidad
que
nor-


malmente
es
una
funci√≥n
de
la
longitud
media
de
la
cola
,
de
minth
y
de
maxth
.
Se
han
 
pro-


puesto
diversas
funciones
probabil√≠sticas
de
marcado
/
descarte
y
varias
versiones
de
RED


han
sido
modeladas
anal√≠ticamente
,
simuladas
y
/
o
implementadas
.
[
Christiansen
2001
]
y


[
Floyd
2009
]
proporcionan
panor√°micas
y
referencias
a
lecturas
adicionales
.


4.3
‚Ä¢
EL
INTERIOR
DE
UN
ROUTER
321


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
321Si
el
entramado
de
conmutaci√≥n
no
es
lo
suficiente
r√°pido
(
respecto
a
las
velocida-


des
de
l√≠nea
de
entrada
)
como
para
transferir
todos
los
paquetes
que
le
llegan
sin
producir


retardos
,
entonces
tambi√©n
pueden
crearse
colas
de
paquetes
en
los
puertos
de
entrada
,
ya


que
los
paquetes
se
ir√°n
a√±adiendo
a
las
colas
de
los
puertos
de
entrada
con
el
fin
de
esperar


su
turno
para
ser
transferidos
a
trav√©s
del
entramado
de
conmutaci√≥n
hacia
el
puerto
de


salida
.
Para
ilustrar
una
importante
consecuencia
de
estas
colas
,
considere
una
estructura
de


conmutadores
en
malla
y
suponga
que
(
1
)
todas
las
velocidades
de
l√≠nea
son
id√©nticas
,
(
2
)


que
un
paquete
puede
ser
transferido
desde
cualquier
puerto
de
entrada
a
un
puerto
de
salida


dado
en
el
mismo
intervalo
de
tiempo
que
tarda
un
paquete
en
ser
recibido
a
trav√©s
de
un


enlace
de
entrada
y
(
3
)
que
los
paquetes
pasan
de
una
cola
de
entrada
dada
a
la
cola
de


salida
deseada
siguiendo
una
planificaci√≥n
FCFS
.
M√∫ltiples
paquetes
pueden
ser
transferi-


dos
en
paralelo
,
siempre
y
cuando
sus
puertos
de
salida
sean
diferentes
.
Sin
embargo
,
si
dos


paquetes
situados
en
primer
lugar
de
dos
colas
de
entrada
est√°n
ambos
destinados
a
la


misma
cola
de
salida
,
entonces
uno
de
los
paquetes
quedar√°
bloqueado
y
tendr√°
que
esperar


en
la
cola
de
entrada
(
el
entramado
de
conmutaci√≥n
s√≥lo
puede
transferir
un
paquete
a
un


determinado
puerto
de
salida
cada
vez
)
.


La
Figura
4.11
muestra
un
ejemplo
en
el
que
dos
paquetes
(
los
m√°s
oscuros
)
se
encuen-


tran
al
frente
de
sus
respectivas
colas
de
entrada
y
ambos
est√°n
destinados
al
mismo
puerto


de
salida
(
el
de
m√°s
arriba
)
.
Suponga
que
el
entramado
de
conmutaci√≥n
elige
transferir
el


322
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.11
‚Ä¢
Bloqueo
HOL
en
una
cola
de
entrada
de
un
conmutador
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
322paquete
de
la
cabecera
de
la
cola
superior
izquierda
.
En
este
caso
,
el
paquete
m√°s
oscuro
de


la
cola
inferior
izquierda
tendr√°
que
esperar
.
Pero
no
s√≥lo
este
paquete
m√°s
oscuro
tiene
que


esperar
,
sino
tambi√©n
el
paquete
sombreado
m√°s
claro
que
est√°
en
la
cola
detr√°s
del
paquete


de
la
cola
inferior
izquierda
,
incluso
aunque
no
exista
contenci√≥n
para
el
puerto
de
salida


intermedio
(
que
es
el
destino
del
paquete
m√°s
claro
)
.
Este
fen√≥meno
se
conoce
como


bloqueo
HOL
(
Head-of-the-line
,
Cabeza
de
la
l√≠nea
)
en
un
conmutador
con
cola
de


entrada
(
un
paquete
que
se
encuentra
en
una
cola
de
entrada
tiene
que
esperar
a
ser
transfe-


rido
a
trav√©s
del
entramado
de
conmutaci√≥n
,
aunque
su
puerto
de
salida
est√©
libre
,
porque


est√°
bloqueado
por
otro
paquete
que
se
encuentra
en
la
cabeza
de
la
l√≠nea
)
.
[
Karol
1987
]


demuestra
que
,
a
causa
del
bloqueo
HOL
,
la
cola
de
entrada
crecer√°
hasta
una
longitud
ili-


mitada
(
informalmente
,
esto
es
equivalente
a
decir
que
se
producir√°
una
p√©rdida
de
paquetes


significativa
)
bajo
ciertas
suposiciones
,
en
cuanto
la
tasa
de
llegada
de
paquetes
a
trav√©s
de


los
enlaces
de
entrada
alcance
el
58
por
ciento
de
su
capacidad
.
En
[
McKeown
1997b
]
se


exponen
una
serie
de
soluciones
para
el
bloqueo
HOL
.


4.4
Protocolo
de
Internet
(
IP
):
reenv√≠o
y


direccionamiento
en
Internet


Hasta
aqu√≠
no
hemos
hecho
referencia
a
ninguna
red
de
computadoras
espec√≠fica
al
hablar


del
reenv√≠o
y
el
direccionamiento
de
la
capa
de
red
.
En
esta
secci√≥n
vamos
a
fijar
nuestra


atenci√≥n
en
c√≥mo
se
llevan
a
cabo
las
tareas
de
reenv√≠o
y
direccionamiento
en
Internet
.


Veremos
que
tanto
el
reenv√≠o
como
el
direccionamiento
en
Internet
son
componentes


importantes
del
Protocolo
de
Internet
(
IP
)
.
Actualmente
hay
dos
versiones
en
uso
de
IP
.
En


primer
lugar
,
examinaremos
el
ampliamente
utilizado
protocolo
IP
versi√≥n
4
,
que
habitual-


mente
se
denomina
IPv4
[
RFC
791
]
.
Al
final
de
la
secci√≥n
,
abordaremos
la
versi√≥n
6
de
IP


[
RFC
2460
;
RFC
4291
]
,
protocolo
propuesto
para
sustituir
a
IPv4
.


Pero
antes
de
entrar
de
lleno
en
IP
,
demos
un
paso
atr√°s
y
consideremos
los
componen-


tes
que
forman
la
capa
de
red
de
Internet
.
Como
se
muestra
en
la
Figura
4.12
,
la
capa
de
red


de
Internet
tiene
tres
componentes
principales
.
El
primero
de
ellos
es
el
protocolo
IP
,
que
es


el
tema
de
esta
secci√≥n
.
El
segundo
es
el
componente
de
enrutamiento
,
el
cual
determina
la


ruta
que
sigue
un
datagrama
desde
el
origen
al
destino
.
Hemos
mencionado
anteriormente


que
los
protocolos
de
enrutamiento
calculan
las
tablas
de
reenv√≠o
que
se
utilizan
para
trans-


mitir
los
paquetes
a
trav√©s
de
la
red
.
Estudiaremos
los
protocolos
de
enrutamiento
de
Inter-


net
en
la
Secci√≥n
4.6
.
El
√∫ltimo
componente
de
la
capa
de
red
es
una
facilidad
que
permite


informar
de
la
existencia
de
errores
en
los
datagramas
y
contesta
a
las
solicitudes
de
deter-


minada
informaci√≥n
de
la
capa
de
red
.
En
la
Secci√≥n
4.4.3
abordaremos
el
protocolo
de


informaci√≥n
de
control
y
de
errores
de
la
capa
de
red
de
Internet
,
el
protocolo
ICMP
(
Inter-


net
Control
Message
Protocol
)
.


4.4.1
Formato
de
los
datagramas


Recuerde
que
nos
referiremos
a
los
paquetes
de
la
capa
de
red
como
datagramas
.
Iniciamos


nuestro
estudio
del
protocolo
IP
con
una
introducci√≥n
a
la
sintaxis
y
la
sem√°ntica
del
data-


grama
de
IPv4
.
Es
posible
que
est√©
pensando
que
no
puede
haber
nada
m√°s
√°rido
que
la
sin-


taxis
y
la
sem√°ntica
de
los
bits
de
un
paquete
.
Sin
embargo
,
los
datagramas
desempe√±an
un


papel
central
en
Internet
:
todos
los
estudiantes
y
profesionales
de
las
redes
necesitan
com-


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
323


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
323prenderlos
y
dominarlos
.
El
formato
de
los
datagramas
de
IPv4
se
muestra
en
la
Figura


4.13
.
Los
campos
clave
de
los
datagramas
de
IPv4
son
los
siguientes
:


‚Ä¢
N√∫mero
de
versi√≥n
.
Estos
4
bits
especifican
la
versi√≥n
del
protocolo
IP
del
datagrama
.
A


partir
del
n√∫mero
de
versi√≥n
el
router
puede
determinar
c√≥mo
interpretar
el
resto
del


datagrama
IP
.
Las
distintas
versiones
de
IP
utilizan
distintos
formatos
de
datagrama
.
El


formato
de
datagrama
de
la
versi√≥n
actual
de
IP
,
IPv4
,
es
el
mostrado
en
la
Figura
4.13
.


324
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


‚Äú
√±
li
i√≥
‚Äù
d


‚Äú
se√±alizaci√≥n
‚Äù
de
router


Figura
4.12
‚Ä¢
Capa
de
red
de
Internet
.


Figura
4.13
‚Ä¢
Formato
de
los
datagramas
de
IPv4
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
324Al
final
de
la
secci√≥n
veremos
el
formato
de
datagrama
correspondiente
a
la
nueva
ver-


si√≥n
de
IP
(
IPv6
)
.


‚Ä¢
Longitud
de
cabecera
.
Puesto
que
un
datagrama
IPv4
puede
contener
un
n√∫mero
varia-


ble
de
opciones
(
las
que
se
incluyen
en
la
cabecera
del
datagrama
IPv4
)
,
estos
4
bits
son


necesarios
para
determinar
d√≥nde
comienzan
realmente
los
datos
del
datagrama
IP
.
La


mayor√≠a
de
los
datagramas
IP
no
contienen
opciones
,
por
lo
que
el
datagrama
IP
t√≠pico


tiene
una
cabecera
de
20
bytes
.


‚Ä¢
Tipo
de
servicio
.
Los
bits
del
tipo
de
servicio
(
TOS
,
Type
of
service
)
se
incluyeron
en
la


cabecera
de
IPv4
con
el
fin
de
poder
diferenciar
entre
distintos
tipos
de
datagramas
IP


(
por
ejemplo
,
datagramas
que
requieran
en
particular
un
bajo
retardo
,
una
alta
tasa
de


transferencia
o
una
entrega
fiable
)
.
Por
ejemplo
,
puede
resultar
√∫til
diferenciar
datagra-


mas
en
tiempo
real
(
como
los
utilizados
en
aplicaciones
de
telefon√≠a
IP
)
del
tr√°fico
que


no
es
en
tiempo
real
(
como
por
ejemplo
el
tr√°fico
FTP
)
.
El
nivel
espec√≠fico
de
servicio


que
se
proporcione
es
una
pol√≠tica
que
determinar√°
el
administrador
del
router
.
Estudia-


remos
en
detalle
el
tema
de
los
servicios
diferenciados
en
el
Cap√≠tulo
7
.


‚Ä¢
Longitud
del
datagrama
.
Es
la
longitud
total
del
datagrama
IP
(
la
cabecera
m√°s
lo
datos
)


en
bytes
.
Puesto
que
este
campo
tiene
una
longitud
de
16
bits
,
el
tama√±o
m√°ximo
te√≥rico


del
datagrama
IP
es
de
65.535
bytes
.
Sin
embargo
,
los
datagramas
rara
vez
tienen
una


longitud
mayor
de
1.500
bytes
.


‚Ä¢
Identificador
,
indicadores
,
desplazamiento
de
fragmentaci√≥n
.
Estos
tres
campos
tienen


que
ver
con
lo
que
se
denomina
fragmentaci√≥n
IP
,
un
tema
que
estudiaremos
en
profun-


didad
enseguida
.
Es
interesante
comentar
que
la
nueva
versi√≥n
de
IP
,
IPv6
,
no
permite
la


fragmentaci√≥n
en
los
routers
.


‚Ä¢
Tiempo
de
vida
.
El
campo
Tiempo
de
vida
(
TTL
,
Time-To-Live
)
se
incluye
con
el
fin
de


garantizar
que
los
datagramas
no
estar√°n
eternamente
en
circulaci√≥n
a
trav√©s
de
la
red


(
debido
,
por
ejemplo
,
a
un
bucle
de
enrutamiento
de
larga
duraci√≥n
)
.
Este
campo
se


decrementa
en
una
unidad
cada
vez
que
un
router
procesa
un
datagrama
.
Si
el
campo


TTL
alcanza
el
valor
0
,
el
datagrama
tiene
que
ser
descartado
.


‚Ä¢
Protocolo
.
Este
campo
s√≥lo
se
emplea
cuando
un
datagrama
IP
alcanza
su
destino
final
.


El
valor
de
este
campo
indica
el
protocolo
espec√≠fico
de
la
capa
de
transporte
al
que
se


pasar√°n
los
datos
contenidos
en
ese
datagrama
IP
.
Por
ejemplo
,
un
valor
de
6
indica
que


los
datos
se
pasan
a
TCP
,
mientras
que
un
valor
igual
a
17
indica
que
los
datos
se
pasan
a


UDP
.
Puede
obtener
una
lista
de
todos
los
valores
posibles
en
[
IANA
Protocol
Numbers


2009
]
.
Observe
que
el
n√∫mero
de
protocolo
especificado
en
el
datagrama
IP
desempe√±a


un
papel
an√°logo
al
del
campo
que
almacena
el
n√∫mero
de
puerto
de
un
segmento
de
la


capa
de
transporte
.
El
n√∫mero
de
protocolo
es
el
elemento
que
enlaza
las
capas
de
red
y


de
transporte
,
mientras
que
el
n√∫mero
de
puerto
es
el
componente
que
enlaza
las
capas


de
transporte
y
de
aplicaci√≥n
.
En
el
Cap√≠tulo
5
veremos
que
la
trama
de
la
capa
de
enlace


tambi√©n
contiene
un
campo
especial
que
enlaza
la
capa
de
enlace
con
la
capa
de
red
.


‚Ä¢
Suma
de
comprobaci√≥n
de
cabecera
.
La
suma
de
comprobaci√≥n
de
cabecera
ayuda
a
los


routers
a
detectar
errores
de
bit
en
un
datagrama
IP
recibido
.
Esta
suma
de
comprobaci√≥n


se
calcula
tratando
cada
pareja
de
2
bytes
de
la
cabecera
como
un
n√∫mero
y
sumando


dichos
n√∫meros
utilizando
aritm√©tica
de
complemento
a
1
.
Como
se
ha
visto
en
la


Secci√≥n
3.3
,
el
complemento
a
1
de
esta
suma
,
conocida
como
suma
de
comprobaci√≥n


Internet
,
se
almacena
en
el
campo
Suma
de
comprobaci√≥n
.
Un
router
calcula
la
suma
de


comprobaci√≥n
de
cabecera
para
cada
datagrama
IP
recibido
y
detecta
una
condici√≥n


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
325


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
325de
error
si
la
suma
de
comprobaci√≥n
incluida
en
la
cabecera
del
datagrama
no
coincide


con
la
suma
de
comprobaci√≥n
calculada
.
Normalmente
,
los
routers
descartan
los
datagra-


mas
en
los
que
se
ha
detectado
que
existe
un
error
.
Observe
que
la
suma
de
comproba-


ci√≥n
tiene
que
volver
a
calcularse
y
almacenarse
en
cada
router
,
ya
que
el
campo
TTL
y
,


posiblemente
,
tambi√©n
el
campo
de
opciones
pueden
cambiar
.
Una
interesante
exposi-


ci√≥n
acerca
de
algoritmos
r√°pidos
para
el
c√°lculo
de
la
suma
de
comprobaci√≥n
Internet


puede
verse
en
[
RFC
1071
]
.
Una
cuesti√≥n
que
suele
plantearse
en
este
punto
es
¬ø
por
qu√©


TCP
/
IP
lleva
a
cabo
una
comprobaci√≥n
de
errores
tanto
en
la
capa
de
transporte
como
en


la
capa
de
red
?
Existen
varias
razones
para
esta
redundancia
.
En
primer
lugar
,
f√≠jese
en


que
en
la
capa
IP
s√≥lo
se
calcula
la
suma
de
comprobaci√≥n
para
la
cabecera
IP
,
mientras


que
la
suma
de
comprobaci√≥n
TCP
/
UDP
se
calcula
sobre
el
segmento
TCP
/
UDP
com-


pleto
.
En
segundo
lugar
,
TCP
/
UDP
e
IP
no
necesariamente
tienen
que
pertenecer
a
la


misma
pila
de
protocolos
.
En
principio
,
TCP
puede
ejecutarse
sobre
un
protocolo
dife-


rente
(
por
ejemplo
,
ATM
)
e
IP
puede
transportar
datos
que
no
se
pasar√°n
a
TCP
/
UDP
.


‚Ä¢
Direcciones
IP
de
origen
y
de
destino
.
Cuando
un
origen
crea
un
datagrama
,
inserta
su


direcci√≥n
IP
en
el
campo
de
direcci√≥n
IP
de
origen
e
inserta
la
direcci√≥n
del
destino
final


en
el
campo
de
direcci√≥n
IP
de
destino
.
A
menudo
el
host
de
origen
determina
la
direc-


ci√≥n
de
destino
mediante
una
b√∫squeda
DNS
,
como
se
ha
explicado
en
el
Cap√≠tulo
2
.
En


la
Secci√≥n
4.4.2
veremos
en
detalle
el
direccionamiento
IP
.


‚Ä¢
Opciones
.
El
campo
de
opciones
permite
ampliar
una
cabecera
IP
.
La
idea
original
era


que
las
opciones
de
cabecera
rara
vez
se
emplearan
:
de
ah√≠
la
decisi√≥n
de
ahorrar
recur-


sos
no
incluyendo
la
informaci√≥n
de
los
campos
opcionales
en
la
cabecera
de
todos
los


datagramas
.
Sin
embargo
,
la
mera
existencia
de
opciones
complica
las
cosas
,
ya
que
las


cabeceras
de
datagrama
pueden
tener
una
longitud
variable
,
por
lo
que
no
puede
determi-


narse
a
priori
d√≥nde
comenzar√°
el
campo
de
datos
.
Adem√°s
,
dado
que
algunos
datagra-


mas
pueden
requerir
el
procesamiento
de
opciones
y
otros
no
,
la
cantidad
de
tiempo


necesario
para
procesar
un
datagrama
IP
en
un
router
puede
variar
enormemente
.
Estas


consideraciones
cobran
una
particular
importancia
en
el
procesamiento
IP
realizado
en


los
hosts
y
routers
de
altas
prestaciones
.
Por
estas
razones
y
otras
,
las
opciones
IP
fueron


eliminadas
en
la
cabecera
de
IPv6
,
como
veremos
en
la
Secci√≥n
4.4.4
.


‚Ä¢
Datos
(
carga
√∫til
)
.
Finalmente
,
llegamos
al
√∫ltimo
campo
y
m√°s
importante
:
¬°
la
raz√≥n
de


ser
del
datagrama
!
En
la
mayor√≠a
de
las
circunstancias
,
el
campo
de
datos
del
data-


grama
IP
contiene
el
segmento
de
la
capa
de
transporte
(
TCP
o
UDP
)
que
va
a
entre-


garse
al
destino
.
Sin
embargo
,
el
campo
de
datos
puede
transportar
otros
tipos
de


datos
,
como
por
ejemplo
mensajes
ICMP
(
que
veremos
en
la
Secci√≥n
4.4.3
)
.


Observe
que
un
datagrama
IP
tiene
un
total
de
20
bytes
de
cabecera
(
suponiendo
que
no
con-


tienen
opciones
)
.
Si
el
datagrama
transporta
un
segmento
TCP
,
entonces
cada
datagrama
(
no


fragmentado
)
transporta
un
total
de
40
bytes
de
cabecera
(
20
bytes
de
la
cabecera
IP
m√°s
20


bytes
de
la
cabecera
TCP
)
junto
con
el
mensaje
de
la
capa
de
aplicaci√≥n
.


Fragmentaci√≥n
del
datagrama
IP


En
el
Cap√≠tulo
5
veremos
que
no
todos
los
protocolos
de
la
capa
de
enlace
pueden
transpor-


tar
paquetes
de
la
capa
de
red
del
mismo
tama√±o
.
Algunos
protocolos
pueden
transportar


datagramas
grandes
,
mientras
que
otros
s√≥lo
transportan
datagramas
peque√±os
.
Por
ejemplo
,


las
tramas
Ethernet
pueden
transportar
hasta
1.500
bytes
de
datos
,
mientras
que
las
tramas


326
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
326para
otros
enlaces
de
√°rea
extensa
no
pueden
transportar
m√°s
de
576
bytes
.
La
cantidad


m√°xima
de
datos
que
una
trama
de
la
capa
de
enlace
puede
transportar
se
conoce
como
uni-


dad
m√°xima
de
transmisi√≥n
(
MTU
,
Maximum
Transmission
Unit
)
.
Puesto
que
cada
data-


grama
IP
se
encapsula
dentro
de
una
trama
de
la
capa
de
enlace
para
ir
de
un
router
al


siguiente
,
la
MTU
del
protocolo
de
la
capa
de
enlace
impone
un
l√≠mite
estricto
a
la
longitud


de
un
datagrama
IP
.
Esta
limitaci√≥n
del
tama√±o
de
un
datagrama
IP
no
supone
un
problema


importante
.
Lo
que
realmente
es
un
problema
es
que
cada
uno
de
los
enlaces
existentes
a
lo


largo
de
la
ruta
entre
el
emisor
y
el
destino
pueden
utilizar
diferentes
protocolos
de
la
capa


de
enlace
y
cada
uno
de
estos
protocolos
puede
utilizar
una
MTU
diferente
.


Con
el
fin
de
comprender
mejor
la
cuesti√≥n
de
reenv√≠o
,
imagine
que
usted
es
un
router


que
interconecta
varios
enlaces
,
que
ejecutan
distintos
protocolos
de
la
capa
de
enlace
con


MTU
diferentes
.
Suponga
que
recibe
un
datagrama
IP
procedente
de
un
enlace
.
Comprueba


su
tabla
de
reenv√≠o
para
determinar
el
enlace
de
salida
y
ese
enlace
de
salida
tiene
una
MTU


que
es
menor
que
la
longitud
del
datagrama
IP
.
Lo
que
nos
lleva
a
plantearnos
la
pregunta
de


c√≥mo
meter
ese
datagrama
IP
sobredimensionado
en
el
campo
de
carga
√∫til
de
la
trama
de
la


capa
de
enlace
.
La
soluci√≥n
consiste
en
fragmentar
los
datos
del
datagrama
IP
en
dos
o
m√°s


datagramas
IP
m√°s
peque√±os
,
encapsular
cada
uno
de
los
datagramas
IP
m√°s
peque√±os
en
una


trama
de
la
capa
de
enlace
distinta
y
enviar
dichas
tramas
a
trav√©s
del
enlace
de
salida
.
Cada


uno
de
estos
datagramas
m√°s
peque√±os
se
conocen
como
fragmentos
.


Los
fragmentos
tienen
que
ser
reensamblados
antes
de
llegar
a
la
capa
de
transporte
del


destino
.
De
hecho
,
tanto
TCP
como
UDP
est√°n
esperando
recibir
segmentos
completos
no


fragmentos
de
la
capa
de
red
.
Los
dise√±adores
de
IPv4
pensaron
que
reensamblar
los
data-


gramas
en
los
routers
a√±adir√≠a
una
complejidad
significativa
al
protocolo
y
reducir√≠a
su
ren-


dimiento
.
(
Si
usted
fuera
un
router
,
¬ø
querr√≠a
reensamblar
fragmentos
adem√°s
de
todo
lo
que


ya
tiene
que
hacer
?
)
Siguiendo
el
principio
de
mantener
el
n√∫cleo
de
la
red
simple
,
los
dise-


√±adores
de
IPv4
decidieron
dar
el
trabajo
de
reensamblar
los
datagramas
a
los
sistemas
ter-


minales
en
lugar
de
a
los
routers
de
red
.


Cuando
un
host
de
destino
recibe
una
serie
de
datagramas
procedentes
del
mismo
ori-


gen
,
tiene
que
determinar
si
alguno
de
esos
datagramas
son
fragmentos
de
alg√∫n
otro
data-


grama
original
m√°s
grande
.
Si
algunos
datagramas
son
fragmentos
,
tiene
que
determinar


adem√°s
cu√°ndo
ha
recibido
el
√∫ltimo
fragmento
y
c√≥mo
debe
ensamblar
los
fragmentos


que
ha
recibido
para
formar
el
datagrama
original
.
Para
que
el
host
de
destino
pueda
lle-


var
a
cabo
estas
tareas
de
reensamblado
,
los
dise√±adores
de
IP
(
versi√≥n
4
)
incluyeron
los


campos
identificaci√≥n
,
indicador
y
desplazamiento
de
fragmentaci√≥n
en
la
cabecera
del


datagrama
IP
.
Cuando
se
crea
un
datagrama
,
el
host
emisor
marca
el
datagrama
con
un


n√∫mero
de
identificaci√≥n
,
as√≠
como
con
las
direcciones
de
origen
y
de
destino
.
Normal-


mente
,
el
host
emisor
incrementa
el
n√∫mero
de
identificaci√≥n
para
cada
datagrama
que


env√≠a
.
Cuando
un
router
necesita
fragmentar
un
datagrama
,
cada
datagrama
resultante
(
es


decir
,
cada
fragmento
)
se
marca
con
la
direcci√≥n
de
origen
,
la
direcci√≥n
de
destino
y
el


n√∫mero
de
identificaci√≥n
del
datagrama
original
.
Cuando
el
destino
recibe
una
serie
de


datagramas
procedentes
del
mismo
host
emisor
,
puede
examinar
los
n√∫meros
de
identifi-


caci√≥n
de
los
datagramas
para
determinar
cu√°les
de
ellos
son
fragmentos
de
un
mismo


datagrama
m√°s
largo
.
Puesto
que
IP
es
un
servicio
no
fiable
,
es
posible
que
uno
o
m√°s
de


los
fragmentos
nunca
lleguen
a
su
destino
.
Por
esta
raz√≥n
,
con
el
fin
de
que
el
host
de
des-


tino
est√©
absolutamente
seguro
de
que
ha
recibido
el
√∫ltimo
fragmento
del
datagrama
ori-


ginal
,
el
√∫ltimo
fragmento
tiene
un
bit
indicador
puesto
a
0
,
mientras
que
los
dem√°s


fragmentos
tienen
el
bit
indicador
puesto
a
1
.
Adem√°s
,
para
que
el
host
de
destino
deter-


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
327


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
327mine
si
falta
un
fragmento
(
y
tambi√©n
para
que
pueda
reensamblar
los
fragmentos
en
el


orden
apropiado
)
,
se
utiliza
el
campo
desplazamiento
para
especificar
en
qu√©
posici√≥n


dentro
del
datagrama
IP
original
encaja
el
fragmento
.


La
Figura
4.14
ilustra
un
ejemplo
.
Un
datagrama
de
4.000
bytes
(
20
bytes
de
cabecera


IP
m√°s
3.980
bytes
de
carga
√∫til
IP
)
llega
a
un
router
y
tienen
que
ser
reenviado
a
un
enlace


con
una
MTU
de
1.500
bytes
.
Esto
implica
que
los
3.980
bytes
de
datos
del
datagrama
ori-


ginal
tienen
que
ser
alojados
en
tres
fragmentos
distintos
(
cada
uno
de
los
cuales
tambi√©n
es


un
datagrama
IP
)
.
Suponga
que
el
datagrama
original
est√°
marcado
con
el
n√∫mero
de
identi-


ficaci√≥n
777
.
Las
caracter√≠sticas
de
los
tres
fragmentos
se
muestran
en
la
Tabla
4.2
.
Los


valores
de
esta
tabla
reflejan
el
requisito
de
que
la
cantidad
de
datos
√∫tiles
originales
de


todos
los
fragmentos
,
excepto
del
√∫ltimo
,
tiene
que
ser
un
m√∫ltiplo
de
8
bytes
,
y
que
el
valor


del
desplazamiento
debe
especificarse
en
unidades
de
fragmentos
de
8
bytes
.


En
el
destino
,
la
carga
√∫til
del
datagrama
se
pasa
a
la
capa
de
transporte
s√≥lo
despu√©s
de


que
la
capa
IP
haya
reconstruido
completamente
el
datagrama
IP
original
.
Si
uno
o
m√°s


de
los
fragmentos
no
llegan
al
destino
,
el
datagrama
incompleto
se
descarta
y
no
se
pasa
a
la


capa
de
transporte
.
Pero
,
como
hemos
visto
en
el
cap√≠tulo
anterior
,
si
se
est√°
utilizando
TCP


en
la
capa
de
transporte
,
entonces
TCP
se
recuperar√°
de
esta
p√©rdida
haciendo
que
el
origen


retransmita
los
datos
del
datagrama
original
.


Acabamos
de
ver
que
la
fragmentaci√≥n
IP
desempe√±a
un
papel
importante
en
el
ensam-


blado
de
las
muchas
y
dispares
tecnolog√≠as
de
la
capa
de
enlace
.
Pero
la
fragmentaci√≥n
tam-


bi√©n
tiene
sus
costes
.
En
primer
lugar
,
a√±ade
complejidad
a
los
routers
y
sistemas
terminales
,


que
tienen
que
ser
dise√±ados
para
acomodar
la
fragmentaci√≥n
y
el
reensamblado
de
los
data


328
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.14
‚Ä¢
Fragmentaci√≥n
y
reensamblado
IP
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
328Fragmento
Bytes
ID
Desplazamiento
Indicador


Primer
fragmento
1.480
bytes
en
el
Identificaci√≥n
 
777
Desplaz
.
 
0
(
significa
que
Indicador
 
1


campo
de
datos
del
los
datos
deben
insertarse
(
hay
m√°s


datagrama
IP
comenzando
en
el
byte
0
)
fragmentos
)


Segundo
fragmento
1.480
bytes
Identificaci√≥n
 
777
Desplaz
.
 
185
(
significa
que
Indicador
 
1


de
datos
los
datos
deben
insertarse
(
hay
m√°s


comenzando
en
el
byte
fragmentos
)


1.480
.
Observe
que


185
¬∑
8
 
1.480
)


Tercer
fragmento
1.020
bytes
Identificaci√≥n
 
777
Desplaz
.
 
370
(
significa
que
Indicador
 
0


(
 
3.980‚Äì1.480
los
datos
deben
insertarse
(
es
el
√∫ltimo


‚Äì
1.480)de
datos
comenzando
en
el
byte
fragmento
)


2.960
.
Observe
que


370
¬∑
8
 
2.960
)


Tabla
4.2
‚Ä¢
Fragmentos
IP
.


gramas
.
En
segundo
lugar
,
la
fragmentaci√≥n
se
puede
utilizar
para
crear
ataques
DoS
letales
,


en
los
que
el
atacante
env√≠a
una
serie
de
fragmentos
extra√±os
e
inesperados
.
Un
ejemplo
cl√°-


sico
es
el
ataque
Jolt2
,
en
el
que
el
atacante
env√≠a
un
flujo
de
fragmentos
peque√±os
al
host


objetivo
,
ninguno
de
los
cuales
tiene
un
desplazamiento
igual
a
cero
.
El
host
objetivo
puede


colapsar
al
intentar
reconstruir
datagramas
a
partir
de
los
paquetes
degenerados
.
Otro
tipo


de
ataque
env√≠a
fragmentos
IP
solapados
,
es
decir
,
fragmentos
cuyos
valores
de
desplaza-


miento
se
han
establecido
de
modo
que
los
fragmentos
no
se
alinean
apropiadamente
.
Los


sistemas
operativos
vulnerables
,
que
no
saben
qu√©
hacer
con
esos
fragmentos
solapados
,


pueden
dejar
de
funcionar
[
Skoudis
2006
]
.
Como
veremos
al
final
de
esta
secci√≥n
,
la
nueva


versi√≥n
del
protocolo
IP
,
IPv6
,
no
admite
la
fragmentaci√≥n
,
simplificando
el
procesamiento


de
paquetes
IP
y
haciendo
que
IP
sea
menos
vulnerable
a
los
ataques
.


En
el
sitio
web
del
libro
proporcionamos
un
applet
de
Java
que
genera
fragmentos
.
No


tiene
m√°s
que
proporcionar
el
tama√±o
del
datagrama
de
entrada
,
la
MTU
y
la
identificaci√≥n


del
datagrama
de
entrada
y
el
applet
genera
autom√°ticamente
los
fragmentos
.
Visite
el
sitio


http://
www.awl.com/kurose-ross
.


4.4.2
Direccionamiento
IPv4


Ahora
vamos
a
ocuparnos
del
direccionamiento
IPv4
.
Aunque
puede
que
piense
que
el


direccionamiento
es
un
tema
sencillo
,
tenemos
la
esperanza
de
que
al
terminar
este
cap√≠tulo


se
haya
convencido
de
que
el
direccionamiento
en
Internet
no
s√≥lo
es
un
tema
interesante
y


sutil
,
sino
que
tambi√©n
tiene
una
gran
importancia
para
Internet
.
Tanto
[
3Com
Addressing


2009
]
como
el
primer
cap√≠tulo
de
[
Stewart
1999
]
proporcionan
un
excelente
tratamiento
del


direccionamiento
IPv4
.


Sin
embargo
,
antes
de
abordar
el
direccionamiento
IP
,
necesitamos
dedicar
unas
pocas


palabras
a
c√≥mo
los
hosts
y
los
routers
est√°n
conectados
en
la
red
.
Normalmente
,
un
host


dispone
de
un
√∫nico
enlace
hacia
la
red
;
cuando
IP
en
el
host
desea
enviar
un
datagrama
,
lo


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
329


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
329hace
a
trav√©s
de
este
enlace
.
El
l√≠mite
entre
el
host
y
el
enlace
f√≠sico
se
denomina
interfaz
.


Consideremos
a
continuaci√≥n
un
router
y
sus
interfaces
.
Puesto
que
la
tarea
de
un
router


consiste
en
recibir
un
datagrama
por
un
enlace
y
reenviarlo
a
alg√∫n
otro
enlace
,
un
router


necesariamente
est√°
conectado
a
dos
o
m√°s
enlaces
.
El
l√≠mite
entre
el
router
y
cualquiera
de


sus
enlaces
tambi√©n
se
conoce
como
interfaz
.
Por
tanto
,
un
router
tiene
varias
interfaces
,
una


para
cada
uno
de
los
enlaces
.
Puesto
que
todos
los
hosts
y
todos
los
routers
son
capaces
de


enviar
y
recibir
datagramas
IP
,
IP
requiere
que
cada
interfaz
de
host
y
de
router
tenga
su
pro-


pia
direcci√≥n
IP
.
Por
tanto
,
t√©cnicamente
,
una
direcci√≥n
IP
est√°
asociada
con
una
interfaz
,
en


lugar
de
con
el
host
o
con
el
router
que
contiene
dicha
interfaz
.


Las
direcciones
IP
tienen
una
longitud
de
32
bits
(
lo
que
equivale
a
4
bytes
)
,
por
lo
que


existen
un
total
de
2
32
direcciones
IP
posibles
.
Aproximando
2
10
a
103
,
es
f√°cil
ver
que
hay


unos
4.000
millones
direcciones
IP
posibles
.
Estas
direcciones
normalmente
se
expresan
uti-


lizando
la
notaci√≥n
decimal
con
punto
,
en
la
que
cada
byte
de
la
direcci√≥n
se
escribe
en


formato
decimal
y
separada
mediante
un
punto
del
resto
de
los
bytes
de
la
direcci√≥n
.
Por


ejemplo
,
considere
la
direcci√≥n
IP
193.32.216.9
.
El
193
es
el
n√∫mero
decimal
equivalente


a
los
8
primeros
bits
de
la
direcci√≥n
;
el
32
es
el
equivalente
decimal
de
los
segundos
8
bits


de
la
direcci√≥n
,
y
as√≠
sucesivamente
.
Por
tanto
,
la
direcci√≥n
193.32.216.9
en
notaci√≥n
bina-


ria
se
expresa
como
sigue
:


11000001
00100000
11011000
00001001


Cada
una
de
las
interfaces
de
un
host
o
de
un
router
de
Internet
tiene
que
tener
asociada
una


direcci√≥n
IP
que
es
globalmente
√∫nica
(
excepto
en
el
caso
de
las
interfaces
utilizadas
para


NAT
,
que
veremos
al
final
de
esta
secci√≥n
)
.
No
obstante
,
estas
direcciones
no
se
pueden
ele-


gir
a
tontas
y
a
locas
.
Una
parte
de
la
direcci√≥n
IP
de
una
interfaz
estar√°
determinada
por
la


subred
a
la
que
est√°
conectada
.


La
Figura
4.15
proporciona
un
ejemplo
de
las
interfaces
y
del
direccionamiento
IP
.
En


esta
figura
,
se
utiliza
un
router
(
con
tres
interfaces
)
para
interconectar
siete
hosts
.
Echemos


330
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.15
‚Ä¢
Subredes
y
direcciones
de
las
interfaces
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3304.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
331


un
vistazo
a
las
direcciones
IP
asignadas
a
las
interfaces
de
los
hosts
y
del
router
;
hay
varios


puntos
que
merece
la
pena
destacar
.
Los
tres
hosts
de
la
parte
superior
izquierda
de
la
Figura


4.15
y
la
interfaz
del
router
a
la
que
est√°n
conectados
,
todos
ellos
tienen
una
direcci√≥n
IP


con
el
formato
223.1.1.xxx
.
Es
decir
,
los
24
bits
m√°s
a
la
izquierda
de
la
direcci√≥n
IP
de


todos
ellos
son
iguales
.
Adem√°s
,
las
cuatro
interfaces
est√°n
interconectadas
mediante
una
red


que
no
contiene
routers
.
(
Esta
red
podr√≠a
ser
,
por
ejemplo
una
LAN
Ethernet
,
en
cuyo
caso


las
interfaces
estar√≠an
interconectadas
mediante
un
hub
Ethernet
o
un
switch
Ethernet
;
v√©ase


el
Cap√≠tulo
5
.
)
En
t√©rminos
de
IP
,
esta
red
que
interconecta
tres
interfaces
de
host
y
una


interfaz
de
router
forma
una
subred
[
RFC
950
]
.
(
Una
subred
tambi√©n
se
conoce
como


red
IP
o
simplemente
red
en
la
literatura
dedicada
a
Internet
.
)
El
direccionamiento
IP
asigna


una
direcci√≥n
a
esta
subred
:
223.1.1.0/24
,
donde
la
notaci√≥n
/24
,
que
en
ocasiones
se
deno-


mina
m√°scara
de
subred
,
indica
que
los
24
bits
m√°s
a
la
izquierda
de
la
magnitud
de
32


bits
define
la
direcci√≥n
de
subred
.
Por
tanto
,
la
subred
223.1.1.0/24
consta
de
las
tres


interfaces
de
host
(
223.1.1.1
,
223.1.1.2
y
223.1.1.3
)
y
de
la
interfaz
del
router
(
223.1.1.4
)
.


Cualquier
host
adicional
conectado
a
la
subred
223.1.1.0/24
requerir√≠a
una
direcci√≥n
de
la


forma
223.1.1.xxx
.
En
la
Figura
4.15
se
muestran
otras
dos
subredes
adicionales
:
la
red


223.1.2.0/24
y
la
subred
223.1.3.0/24
.
La
Figura
4.16
ilustra
las
tres
subredes
IP
presentes


en
la
Figura
4.15
.


La
definici√≥n
IP
de
una
subred
no
est√°
restringida
a
los
segmentos
Ethernet
que
conec-


tan
varios
hosts
a
una
interfaz
de
un
router
.
Profundicemos
un
poco
en
esta
cuesti√≥n
.
Consi-


dere
la
Figura
4.17
,
que
muestra
tres
routers
interconectados
entre
s√≠
mediante
enlaces
punto


a
punto
.
Cada
router
tiene
tres
interfaces
,
una
para
cada
enlace
punto
a
punto
y
una
para
el


enlace
de
difusi√≥n
que
conecta
directamente
el
router
a
una
pareja
de
hosts
.
¬ø
Qu√©
subredes


hay
presentes
aqu√≠
?
Hay
tres
:
223.1.1.0/24
,
223.1.2.0/24
y
223.1.3.0/24
,
y
son
similares
a


las
subredes
de
la
Figura
4.15
.
Pero
f√≠jese
en
que
,
en
este
ejemplo
,
tambi√©n
existen
tres


subredes
adicionales
:
una
subred
,
223.1.9.0/24
,
para
las
interfaces
que
conectan
los
routers


R1
y
R2
;
otra
subred
,
223.1.8.0/24
,
para
las
interfaces
que
conectan
los
routers
R2
y
R3
;
y


Figura
4.16
‚Ä¢
Direcciones
de
subred
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
331una
tercera
subred
,
223.1.7.0/24
,
para
las
interfaces
que
conectan
los
routers
R3
y
R1
.
En
un


sistema
interconectado
general
de
routers
y
hosts
,
podemos
utilizar
la
siguiente
receta
para


definir
las
subredes
existentes
en
el
sistema
:


Para
determinar
las
subredes
,
desconecte
cada
interfaz
de
su
host
o
router
,
creando


islas
de
redes
aisladas
,
con
interfaces
que
acaban
en
los
puntos
terminales
de
las
redes


aisladas
.
Cada
una
de
estas
redes
aisladas
se
dice
que
es
una
subred
.


Si
aplicamos
este
procedimiento
al
sistema
interconectado
de
la
Figura
4.17
,
obtenemos
seis


islas
o
subredes
.


Ap
a
r
t
i
r
 
d
e
 
l
a
 
e
x
p
o
s
i
c
i
√≥
n
 
a
n
t
e
r
i
o
r
,
 
e
s
t
√°
 
c
l
a
r
o
 
q
u
e
 
u
n
a
 
o
r
g
a
n
i
z
a
c
i
√≥
n
 
(
c
o
m
o
 
p
o
r
 
e
j
e
m
p
l
o


una
empresa
o
una
instituci√≥n
acad√©mica
)
con
m√∫ltiples
segmentos
Ethernet
y
enlaces
punto


a
punto
tendr√°
varias
subredes
,
teniendo
todos
los
dispositivos
de
una
subred
dada
la
misma


direcci√≥n
de
subred
.
En
principio
,
las
distintas
subredes
podr√≠an
tener
direcciones
de
subred


bastante
diferentes
.
Sin
embargo
,
en
la
pr√°ctica
,
sus
direcciones
de
subred
a
menudo
tienen


mucho
en
com√∫n
.
Para
entender
por
qu√©
,
veamos
c√≥mo
se
gestiona
el
direccionamiento
en


la
Internet
global
.


La
estrategia
de
asignaci√≥n
de
direcciones
en
Internet
se
conoce
como
Enrutamiento


entre
dominios
sin
clase
(
CIDR
,
Classless
Interdomain
Routing
)
[
RFC
4632
]
.
CIDR


generaliza
la
noci√≥n
de
direccionamiento
de
subred
.
Al
igual
que
sucede
con
las
subredes


IP
,
la
direcci√≥n
IP
de
32
bits
se
divide
en
dos
partes
y
de
nuevo
se
expresa
en
notaci√≥n
deci-


mal
con
punto
como
a.b.c.d
/
x
,
donde
x
indica
el
n√∫mero
de
bits
de
la
primera
parte
de
la


direcci√≥n
.


332
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.17
‚Ä¢
Tres
routers
que
interconectan
seis
subredes
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
332Los
x
bits
m√°s
significativos
de
una
direcci√≥n
en
el
formato
a.b.c.d
/
x
constituyen
la


parte
de
red
de
la
direcci√≥n
IP
y
a
menudo
se
hace
referencia
a
ellos
como
el
prefijo
(
o


prefijo
de
red)d
e
 
l
a
 
d
i
r
e
c
c
i
√≥
n
.
 
N
o
r
m
a
l
m
e
n
t
e
,
 
u
n
a
 
o
r
g
a
n
i
z
a
c
i
√≥
n
 
t
i
e
n
e
 
a
s
i
g
n
a
d
o
 
u
n
 
b
l
o
q
u
e


de
direciones
contiguas
;
es
decir
,
un
rango
de
direcciones
con
un
prefijo
com√∫n
(
v√©anse


los
principios
en
el
recuadro
Pr√°ctica
)
.
En
este
caso
,
las
direcciones
IP
de
los
dispositi-


vos
que
se
encuentran
dentro
de
la
organizaci√≥n
compartir√°n
el
mismo
prefijo
.
Cuando


estudiemos
el
protocolo
de
enrutamiento
BGP
de
Internet
en
la
Secci√≥n
4.6
,
veremos
que


los
routers
externos
a
la
red
de
la
organizaci√≥n
s√≥lo
tienen
en
cuenta
estos
x
primeros
bits


del
prefijo
.
Es
decir
,
cuando
un
router
externo
a
la
organizaci√≥n
reenv√≠a
un
datagrama


cuya
direcci√≥n
de
destino
est√°
dentro
de
la
organizaci√≥n
,
√∫nicamente
necesita
tener
en


cuenta
los
primeros
x
bits
de
la
direcci√≥n
.
Esto
reduce
considerablemente
el
tama√±o
de
la


tabla
de
reenv√≠o
de
los
routers
,
ya
que
una
√∫nica
entrada
con
el
formato
a.b.c.d
/
x
bastar√°


para
reenviar
paquetes
a
cualquier
destino
dentro
de
la
organizaci√≥n
.


Los
32-x
bits
restantes
de
una
direcci√≥n
pueden
emplearse
para
diferenciar
los
disposi-


tivos
internos
de
la
organizaci√≥n
,
teniendo
todos
ellos
el
mismo
prefijo
de
red
.
Estos
son
los


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
333


PRINCIPLES
IN
PRACTICE


Este
ejemplo
de
un
ISP
que
conecta
a
ocho
organizaciones
a
Internet
ilustra
c√≥mo
la
asignaci√≥n


cuidadosa
de
direcciones
CIDR
facilita
el
enrutamiento
.
Suponga
,
como
se
muestra
en
la
Figura


4.18
,
que
el
ISP
(
al
que
llamaremos
ISP
A
)
anuncia
al
mundo
exterior
que
enviar√°
cualquier
data-


grama
cuyos
primeros
20
bits
de
direcci√≥n
se
correspondan
con
200.23.16.0/20
.
El
resto
del


mundo
no
necesita
saber
que
dentro
del
bloque
de
direcciones
200.23.16.0/20
existen
en
reali-


dad
ocho
organizaciones
,
cada
una
con
sus
propias
subredes
.
Esta
capacidad
de
emplear
un


mismo
prefijo
para
anunciar
m√∫ltiples
redes
suele
denominarse
agregaci√≥n
de
direcciones


(
o
agregaci√≥n
de
rutas
,
o
tambi√©n
resumen
de
rutas
)
.


La
t√©cnica
de
agregaci√≥n
de
direcciones
funciona
extraordinariamente
bien
cuando
las
direc-


ciones
se
asignan
en
bloques
a
los
ISP
y
√©stos
las
asignan
en
bloque
a
las
organizaciones


cliente
.
Pero
,
¬ø
qu√©
ocurre
si
las
direcciones
no
est√°n
asignadas
de
esa
forma
jer√°rquica
?
¬ø
Qu√©


ocurrir√≠a
,
por
ejemplo
,
si
el
ISP
A
adquiere
el
ISP
B
y
luego
hace
que
la
Organizaci√≥n
1
se


conecte
a
Internet
a
trav√©s
del
ISP
B
subsidario
?
Como
se
muestra
en
la
Figura
4.18
,
el
ISP
B


subsidario
posee
el
bloque
de
direcciones
199.31.0.0/16
,
pero
las
direcciones
IP
de
la


Organizaci√≥n
1
lamentablemente
no
pertenecen
a
este
bloque
de
direcciones
.
¬ø
Qu√©
habr√≠a
que


hacer
en
este
caso
?
Realmente
,
la
Organizaci√≥n
1
podr√≠a
renumerar
todos
sus
routers
y
hosts


para
disponer
de
direcciones
contenidas
en
el
bloque
de
direcciones
del
ISP
B.
Pero
√©sta
es
una


soluci√≥n
costosa
y
la
Organizaci√≥n
1
podr√≠a
ser
reasignada
en
el
futuro
a
otro
ISP
subsidiario
.


La
soluci√≥n
que
normalmente
adoptar√°
la
Organizaci√≥n
1
ser√°
mantener
sus
direcciones
en


200.23.18.0/23
.
En
este
caso
,
como
se
muestra
en
la
Figura
4.19
,
el
ISP
A
contin√∫a
anuncian-


do
el
bloque
de
direcciones
200.23.16.0/20
y
el
ISP
B
contin√∫a
anunciando
el
bloque


199.31.0.0/16
.
Sin
embargo
,
el
ISP
B
ahora
tambi√©n
anuncia
el
bloque
de
direcciones
de
la


Organizaci√≥n
1
,
200.23.18.0/23
.
Cuando
otros
routers
de
Internet
vean
los
bloques
de
direc-


ciones
200.23.16.0/20
(
del
ISP
A
)
y
200.23.18.0/23
(
del
ISP
B
)
y
deseen
enrutar
hacia
una


direcci√≥n
contenida
en
el
bloque
200.23.18.0/23
,
utilizar√°n
la
regla
de
coincidencia
con
el


prefijo
m√°s
largo
(
v√©ase
la
Secci√≥n
4.2.2
)
y
lo
enviar√°n
hacia
el
ISP
B
,
ya
que
anuncia
el
prefijo


de
direcci√≥n
m√°s
largo
(
m√°s
espec√≠fico
)
que
se
corresponde
con
la
direcci√≥n
de
destino
.


PR√ÅCTICA


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
333bits
que
habr√°
que
considerar
para
reenviar
paquetes
en
los
routers
internos
de
la
organiza-


ci√≥n
.
Estos
bits
de
menor
peso
pueden
tener
(
o
no
)
una
estructura
en
subred
adicional
,
como


la
que
hemos
visto
anteriormente
.
Por
ejemplo
,
suponga
que
los
21
primeros
bits
de
la
direc-


ci√≥n
CIDR
a.b.c.d/21
especifican
el
prefijo
de
red
de
la
organizaci√≥n
y
son
comunes
a
las


direcciones
IP
de
todos
los
dispositivos
de
dicha
organizaci√≥n
.
Los
restantes
11
bits
iden-


tifican
entonces
a
los
hosts
espec√≠ficos
de
la
organizaci√≥n
.
La
estructura
interna
de
la
orga-


nizaci√≥n
puede
ser
tal
que
estos
11
bits
de
m√°s
a
la
derecha
se
empleen
para
dividir
en


334
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.18
‚Ä¢
Agregaci√≥n
de
rutas
y
direccionamiento
jer√°rquicos
.


Figura
4.19
‚Ä¢
El
ISP
B
tiene
una
ruta
m√°s
espec√≠fica
hacia
la
Organizaci√≥n
1
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
334subredes
la
organizaci√≥n
,
como
hemos
viso
anteriormente
.
Por
ejemplo
,
a.b.c.d/24
podr√≠a


hacer
referencia
a
una
subred
espec√≠fica
de
la
organizaci√≥n
.


Antes
de
que
se
adoptara
el
enrutamiento
CIDR
,
la
parte
de
red
de
una
direcci√≥n
IP


estaba
restringida
a
longitudes
de
8
,
16
o
24
bits
,
un
esquema
de
direccionamiento
conocido


como
direccionamiento
con
clases
,
ya
que
las
subredes
con
direcciones
de
8
,
16
y
24
bits


se
conoc√≠an
,
respectivamente
,
como
redes
de
clase
A
,
B
y
C.
El
requisito
de
que
la
parte
de


subred
de
una
direcci√≥n
IP
tuviera
exactamente
una
longitud
de
1
,
2
o
3
bytes
se
volvi√≥
pro-


blem√°tico
a
la
hora
de
dar
soporte
al
r√°pido
crecimiento
de
n√∫mero
de
organizaciones
con


subredes
de
tama√±o
medio
y
peque√±o
.
Una
subred
de
clase
C
(
/24
)
s√≥lo
puede
acomodar


hasta
28
‚Äì
2
=
254
hosts
(
dos
de
las
28
=
256
direcciones
est√°n
reservadas
para
usos
especia-


les
)
,
que
son
muy
pocos
para
muchas
organizaciones
.
Sin
embargo
,
una
subred
de
clase
B


(
/16
)
,
que
puede
dar
soporte
a
65.634
hosts
,
era
demasiado
grande
.
Con
el
direccionamiento


con
clases
,
una
organizaci√≥n
con
,
por
ejemplo
,
2.000
hosts
,
era
asignada
normalmente
a
una


direcci√≥n
de
subred
de
clase
B
(
/16
)
.
Esto
llev√≥
a
un
r√°pido
agotamiento
del
espacio
de


direcciones
de
clase
B
y
a
una
pobre
utilizaci√≥n
del
espacio
de
direcciones
asignado
.
Por


ejemplo
,
la
organizaci√≥n
que
empleaba
una
direcci√≥n
de
clase
B
para
sus
2.000
hosts
ten√≠a


asignado
espacio
suficiente
para
hasta
65.534
interfaces
,
dejando
bloqueadas
m√°s
de
63.000


direcciones
que
no
pod√≠an
ser
utilizadas
por
otras
organizaciones
.


Ser√≠amos
negligentes
si
no
mencion√°ramos
que
existe
otro
tipo
de
direcci√≥n
IP
,
la
direc-


ci√≥n
IP
de
difusi√≥n
255.255.255.255
.
Cuando
un
host
env√≠a
un
datagrama
cuya
direcci√≥n
de


destino
es
255.255.255.255
,
el
mensaje
se
entrega
a
todos
los
hosts
existentes
en
la
misma


subred
.
Opcionalmente
,
los
routers
tambi√©n
reenv√≠an
el
mensaje
a
las
subredes
vecinas
(
aun-


que
habitualmente
no
lo
hacen
)
.


Ahora
que
hemos
estudiado
en
detalle
el
direccionamiento
IP
,
necesitamos
saber
c√≥mo


los
hosts
y
las
subredes
obtienen
sus
direcciones
.
Comenzaremos
viendo
c√≥mo
una
organi-


zaci√≥n
obtiene
un
bloque
de
direcciones
para
sus
dispositivos
,
y
luego
veremos
c√≥mo
se


asigna
una
direcci√≥n
del
bloque
de
direcciones
de
la
organizaci√≥n
a
un
dispositivo
(
por


ejemplo
,
a
un
host
)
.


C√≥mo
obtener
un
bloque
de
direcciones


Para
obtener
un
bloque
de
direcciones
IP
que
pueda
ser
utilizado
dentro
de
la
subred
de
una


organizaci√≥n
,
un
administrador
de
red
tiene
que
contactar
en
primer
lugar
con
su
ISP
,
el
cual


le
proporcionar√°
direcciones
extraidas
de
un
bloque
de
direcciones
mayor
que
ya
habr√°
sido


asignado
al
ISP
.
Por
ejemplo
,
al
ISP
pueden
haberle
asignado
el
bloque
de
direcciones


200.23.16.0/20
.
A
su
vez
,
el
ISP
podr√≠a
dividir
su
bloque
de
direcciones
en
ocho
bloques
de


direcciones
contiguos
del
mismo
tama√±o
y
asignar
cada
uno
de
estos
bloques
de
direcciones


a
hasta
ocho
organizaciones
a
las
que
puede
prestar
servicio
,
como
se
muestra
a
continua-


ci√≥n
(
hemos
subrayado
la
parte
de
subred
de
estas
direcciones
)
.


Bloque
del
ISP
200.23.16.0/20
1
1001000
 
00010111
 
00010000
 
00000000


Organizaci√≥n
0
200.23.16.0/23
1
1001000
 
00010111
 
00010000
 
00000000


Organizaci√≥n
1
200.23.18.0/23
1
1001000
 
00010111
 
00010010
 
00000000


Organizaci√≥n
2
200.23.20.0/23
1
1001000
 
00010111
 
00010100
 
00000000


.
.
.
.
.
.
.
.
.


Organizaci√≥n
7
200.23.30.0/23
1
1001000
 
00010111
 
00011110
 
00000000


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
335


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
335Obtener
un
conjunto
de
direcciones
de
un
ISP
es
una
forma
de
conseguir
un
bloque
de


direcciones
,
pero
no
es
la
√∫nica
forma
.
Evidentemente
,
tambi√©n
debe
existir
una
forma
para


el
propio
ISP
de
obtener
un
bloque
de
direcciones
.
¬ø
Existe
una
entidad
autoritativa
global


cuya
responsabilidad
√∫ltima
sea
gestionar
el
espacio
de
direcciones
IP
y
asignar
bloques
de


direcciones
a
los
ISP
y
otras
organizaciones
?
¬°
Por
supuesto
que
existe
!
Las
direcciones
IP


son
gestionadas
por
la
entidad
ICANN
(
Internet
Corporation
for
Assigned
Names
and
Num-


bers
,
Corporaci√≥n
de
Internet
para
los
n√∫meros
y
nombres
asignados
)
[
ICANN
2009
]
,


bas√°ndose
en
las
directrices
establecidas
en
[
RFC
2050
]
.
El
papel
de
la
organizaci√≥n
sin


√°nimo
de
lucro
ICANN
[
NTIA
1998
]
no
es
s√≥lo
el
de
asignar
direcciones
IP
,
sino
tambi√©n


gestionar
los
servidores
ra√≠z
DNS
.
Tambi√©n
tiene
el
pol√©mico
trabajo
de
asignar
nombres
de


dominio
y
de
resolver
las
disputas
por
dichos
nombres
.
La
organizaci√≥n
ICANN
asigna


direcciones
a
los
registros
regionales
de
Internet
(
por
ejemplo
,
ARIN
,
RIPE
,
APNIC
y
LAC-


NIC
,
que
forman
la
Organizaci√≥n
de
Soporte
de
Direcciones
de
ICANN
[
ASO-ICANN


2009
]
)
,
y
gestionan
la
asignaci√≥n
/
administraci√≥n
de
direcciones
dentro
de
sus
regiones
.


C√≥mo
obtener
una
direcci√≥n
de
host
:
Protocolo
de
configuraci√≥n


din√°mica
de
host


Una
vez
que
una
organizaci√≥n
ha
obtenido
un
bloque
de
direcciones
,
puede
asignar
direc-


ciones
IP
individuales
a
las
interfaces
de
sus
hosts
y
routers
.
Normalmente
,
un
administra-


dor
de
sistemas
configura
manualmente
las
direcciones
IP
de
un
router
(
a
menudo
de
forma


remota
mediante
una
herramienta
de
gesti√≥n
de
red
)
.
Las
direcciones
de
host
tambi√©n
se


pueden
configurar
manualmente
,
pero
frecuentemente
ahora
esta
tarea
se
lleva
cabo
uti-


lizando
el
Protocolo
de
configuraci√≥n
din√°mica
de
host
(
DHCP
,
Dynamic
Host
Confi-


guration
Protocol
)
[
RFC
2131
]
.
DHCP
permite
a
un
host
obtener
(
permite
que
se
le
asigne
)


autom√°ticamente
una
direcci√≥n
IP
.
Un
administrador
de
red
puede
configurar
DHCP
de


modo
que
un
host
dado
reciba
la
misma
direcci√≥n
IP
cada
vez
que
se
conecte
a
la
red
,
o
un


host
puede
ser
asignado
a
una
direcci√≥n
IP
temporal
que
ser√°
diferente
cada
vez
que
el
host


se
conecte
a
la
red
.
Adem√°s
de
la
asignaci√≥n
de
direcciones
IP
a
los
hosts
,
DHCP
tambi√©n


permite
que
un
host
obtenga
informaci√≥n
adicional
,
como
por
ejemplo
su
m√°scara
de


subred
,
la
direcci√≥n
del
router
del
primer
salto
[
a
menudo
denominado
router
de
pasarela


(
gateway
)
predeterminado
]
y
la
direcci√≥n
de
su
servidor
DNS
local
.


Gracias
a
la
capacidad
de
DHCP
de
automatizar
el
proceso
de
conexi√≥n
de
un
host
a
una


red
,
a
menudo
se
dice
que
es
un
protocolo
plug-and-play
.
Esta
capacidad
le
hace
muy
atrac-


tivo
para
el
administrador
de
la
red
que
en
otro
caso
tendr√≠a
que
realizar
estas
tareas


¬°
manualmente
!
DHCP
tambi√©n
disfruta
de
un
amplio
uso
en
las
redes
de
acceso
a
Internet


residenciales
y
en
las
redes
LAN
inal√°mbricas
,
en
las
que
los
hosts
se
unen
a
la
red
y
salen


de
ella
frecuentemente
.
Considere
,
por
ejemplo
,
un
estudiante
que
traslada
una
computadora


port√°til
desde
su
casa
a
la
biblioteca
y
luego
a
clase
.
Probablemente
,
en
cada
localizaci√≥n
el


estudiante
se
conectar√°
a
una
subred
y
,
por
tanto
,
necesitar√°
una
nueva
direcci√≥n
IP
en
cada


lugar
.
DHCP
est√°
idealmente
adaptado
para
estas
situaciones
,
ya
que
existen
muchos
usua-


rios
que
van
y
vienen
,
y
que
necesitan
direcciones
s√≥lo
durante
un
periodo
de
tiempo
limi-


tado
.
Del
mismo
modo
,
DHCP
resulta
√∫til
en
las
redes
de
acceso
de
los
ISP
que
trabajan
en


el
mercado
residencial
.
Considere
por
ejemplo
un
ISP
residencial
que
tiene
2.000
clientes
,


pero
no
m√°s
de
400
clientes
est√°n
en
l√≠nea
al
mismo
tiempo
.
En
este
caso
,
en
lugar
de
nece-


sitar
un
bloque
de
2.048
direcciones
,
un
servidor
DHCP
que
asigne
direcciones
de
forma


din√°mica
s√≥lo
necesitar√°
un
bloque
de
512
direcciones
(
por
ejemplo
,
un
bloque
con
el
for-


336
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3364.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
337


mato
de
direcci√≥n
a.b.c.d/23
)
.
A
medida
que
los
hosts
se
unen
a
la
red
y
salen
de
ella
,
el
ser-


vidor
DHCP
necesita
actualizar
su
lista
de
direcciones
IP
disponibles
.
Cada
vez
que
un
host


se
une
a
la
red
,
el
servidor
DHCP
asigna
una
direcci√≥n
arbitraria
de
su
conjunto
actual
de


direcciones
disponibles
;
cada
vez
que
un
host
abandona
la
red
,
su
direcci√≥n
es
devuelta
al


conjunto
.


DHCP
es
un
protocolo
cliente-servidor
.
Normalmente
,
un
cliente
es
un
host
reci√©n
lle-


gado
que
desea
obtener
informaci√≥n
de
configuraci√≥n
de
la
red
,
incluyendo
una
direcci√≥n
IP


para
s√≠
mismo
.
En
el
caso
m√°s
simple
,
cada
subred
(
en
el
sentido
de
direccionamiento
mos-


trado
en
la
Figura
4.17
)
tendr√°
un
servidor
DHCP
.
Si
en
la
subred
no
hay
ning√∫n
servidor
,
es


necesario
un
agente
de
retransmisi√≥n
DHCP
(
normalmente
un
router
)
que
conozca
la
direc-


ci√≥n
de
un
servidor
DHCP
para
dicha
red
.
La
Figura
4.20
muestra
un
servidor
DHCP
conec-


tado
a
la
subred
223.1.2/24
,
con
el
router
actuando
como
agente
de
retransmisi√≥n
para
los


clientes
reci√©n
llegados
que
se
conectan
a
las
subredes
223.1.1/24
y
223.1.3/24
.
En
la


siguiente
exposici√≥n
,
supondremos
que
hay
disponible
un
servidor
DHCP
en
la
subred
.


Para
un
host
reci√©n
llegado
a
una
red
,
el
protocolo
DHCP
es
un
proceso
de
cuatro
pasos
,


como
se
muestra
en
la
Figura
4.21
para
la
configuraci√≥n
de
red
mostrada
en
la
Figura
4.20
.


En
esta
figura
,
sudirI
(
‚Äú
su
direcci√≥n
Internet
‚Äù
)
indica
la
direcci√≥n
que
se
asigna
al
cliente


que
acaba
de
llegar
.
Los
cuatro
pasos
son
los
siguientes
:


‚Ä¢
Descubrimiento
del
servidor
DHCP
.
La
primera
tarea
de
un
host
reci√©n
llegado
es


encontrar
un
servidor
DHCP
con
el
que
interactuar
.
Esto
se
hace
mediante
un
mensaje


de
descubrimiento
DHCP
,
que
env√≠a
un
cliente
dentro
de
un
paquete
UDP
al
puerto


Figura
4.20
‚Ä¢
Escenario
cliente-servidor
DHCP
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
33767
.
El
paquete
UDP
se
encapsula
en
un
datagrama
IP
.
Pero
,
¬ø
a
qui√©n
deber√≠a
enviarse


este
datagrama
?
El
host
ni
siquiera
conoce
la
direcci√≥n
IP
de
la
red
a
la
que
se
est√°


conectando
,
y
mucho
menos
la
direcci√≥n
de
un
servidor
DHCP
de
esa
red
.
En
esta
situa-


ci√≥n
,
el
cliente
DHCP
crea
un
datagrama
IP
que
contiene
su
mensaje
de
descubrimiento


DHCP
junto
con
la
direcci√≥n
IP
de
difusi√≥n
255.255.255.255
y
una
direcci√≥n
IP
de
ori-


gen
de
‚Äú
este
host
‚Äù
igual
a
0.0.0.0
.
El
cliente
DHCP
pasa
el
datagrama
IP
a
la
capa
de


enlace
,
la
cual
difunde
esta
trama
a
todos
los
nodos
conectados
a
la
subred
(
en
la
Sec-


ci√≥n
5.4
estudiaremos
en
detalle
el
proceso
de
difusi√≥n
de
la
capa
de
enlace
)
.


‚Ä¢
Oferta(s
)
del
servidor
DHCP
.
Un
servidor
DHCP
que
recibe
un
mensaje
de
descubri-


miento
DHCP
responde
al
cliente
con
un
mensaje
de
oferta
DHCP
,
que
se
difunde
a


todos
los
nodos
de
la
subred
utilizando
de
nuevo
la
direcci√≥n
IP
de
difusi√≥n
255.255
.


255.255
(
es
posible
que
se
pregunte
por
qu√©
la
respuesta
de
este
servidor
tambi√©n
debe


difundirse
)
.
Puesto
que
en
la
subred
pueden
existir
varios
servidores
DHCP
,
el
cliente


puede
encontrarse
en
la
situaci√≥n
envidiable
de
poder
elegir
entre
varias
ofertas
.
Cada


mensaje
de
oferta
de
servidor
contiene
el
ID
de
transacci√≥n
del
mensaje
de
descubri-


338
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


segundos


segundos


3.600
segundos


Figura
4.21
‚Ä¢
Interacci√≥n
cliente-servidor
DHCP
.


Cliente


que
llega


Servidor
DHCP


223.1.2.5


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
338miento
recibido
,
la
direcci√≥n
IP
propuesta
para
el
cliente
,
la
m√°scara
de
red
y
el
tiempo


de
arrendamiento
de
la
direcci√≥n
IP
(
el
tiempo
durante
el
que
la
direcci√≥n
IP
ser√°


v√°lida
)
.
Es
habitual
que
el
servidor
defina
un
tiempo
de
arrendamiento
de
varias
horas
o


d√≠as
[
Droms
2002
]
.


‚Ä¢
Solicitud
DHCP
.El
cliente
reci√©n
llegado
seleccionar√°
de
entre
las
ofertas
de
servidor
y


responder√°
a
la
oferta
seleccionada
con
un
mensaje
de
solicitud
DHCP
,
devolviendo


los
par√°metros
de
configuraci√≥n
.


‚Ä¢
ACK
DHCP
.El
servidor
contesta
al
mensaje
de
solicitud
DHCP
con
un
mensaje
ACK


DHCP
,
que
confirma
los
par√°metros
solicitados
.


Una
vez
que
el
cliente
recibe
el
mensaje
de
reconocimiento
(
ACK
)
DHCP
,
la
interac-


ci√≥n
se
completa
y
el
cliente
puede
utilizar
la
direcci√≥n
IP
asignada
por
DHCP
durante
el


tiempo
de
arrendamiento
.
Dado
que
un
cliente
puede
desear
utilizar
su
direcci√≥n
durante


m√°s
tiempo
del
arrendado
,
DHCP
tambi√©n
proporciona
un
mecanismo
que
permite
a
un


cliente
renovar
su
tiempo
de
arrendamiento
de
una
direcci√≥n
IP
.


El
valor
de
la
capacidad
plug-and-play
de
DHCP
es
claro
,
considerando
el
hecho
de
que


una
alternativa
ser√≠a
configurar
manualmente
la
direcci√≥n
IP
de
un
host
.
Recuerde
al
estu-


diante
que
va
de
la
clase
a
la
biblioteca
y
luego
a
su
dormitorio
con
el
port√°til
,
uni√©ndose
a


una
nueva
subred
y
que
obtiene
as√≠
una
nueva
direcci√≥n
IP
en
cada
ubicaci√≥n
.
Ser√≠a
inimagi-


nable
que
un
administrador
de
sistemas
tuviera
que
reconfigurar
las
computadoras
port√°tiles


en
cada
ubicaci√≥n
,
y
pocos
estudiantes
(
excepto
aquellos
que
asisten
a
clases
de
redes
)
son


lo
suficientemente
expertos
como
para
poder
configurar
manualmente
sus
port√°tiles
.
Sin


embargo
,
en
lo
que
respecta
a
la
movilidad
,
DHCP
presenta
tambi√©n
algunas
deficiencias
.


Puesto
que
se
obtiene
una
nueva
direcci√≥n
IP
de
DHCP
cada
vez
que
un
nodo
se
conecta
a


una
nueva
subred
,
una
conexi√≥n
TCP
con
una
aplicaci√≥n
remota
no
podr√≠a
mantenerse
como


un
nodo
m√≥vil
entre
subredes
.
En
el
Cap√≠tulo
6
examinaremos
la
infraestructura
de
IP
m√≥vil
,


una
extensi√≥n
reciente
de
la
infraestructura
IP
que
permite
a
un
nodo
m√≥vil
utilizar
una


direcci√≥n
permanente
seg√∫n
se
va
desplazado
entre
subredes
.
Puede
encontrar
informaci√≥n


adicional
sobre
DHCP
en
[
Droms
2002
]
y
[
dhc
2009
]
.
En
Internet
Systems
Consortium
[
ISC


2009
]
hay
disponible
una
implementaci√≥n
de
referencia
de
c√≥digo
fuente
abierto
para


DHCP
.


Traducci√≥n
de
direcciones
de
red
(
NAT
)


Despu√©s
de
haber
estudiado
las
direcciones
de
Internet
y
el
formato
de
los
datagramas
IPv4
,


somos
completamente
conscientes
de
que
todo
dispositivo
IP
necesita
una
direcci√≥n
IP
.
Con


la
proliferaci√≥n
de
las
subredes
dom√©sticas
y
de
oficina
peque√±a
(
SOHO
,
Small
Office
,


Home
Office
)
,
podr√≠a
parecer
que
esto
implica
que
,
cuando
una
red
SOHO
desea
instalar
una


LAN
para
conectar
varias
m√°quinas
,
el
ISP
deber√≠a
asignar
un
rango
de
direcciones
para


cubrir
todas
las
m√°quinas
de
la
red
SOHO
.
Si
la
subred
creciera
(
por
ejemplo
,
porque
los


ni√±os
en
casa
no
s√≥lo
disponen
ya
de
sus
propias
computadoras
,
sino
que
tambi√©n
tienen
dis-


positivos
PDA
,
tel√©fonos
IP
y
Game
Boys
conectadas
en
red
)
,
habr√≠a
que
asignar
un
bloque


de
direcciones
enorme
.
Pero
¬ø
qu√©
ocurre
si
el
ISP
ya
ha
asignado
las
porciones
adyacentes


al
rango
de
direcciones
actualmente
en
uso
de
la
red
SOHO
?
¬ø
Y
qu√©
persona
normal
querr√≠a


(
o
necesitar√≠a
)
saber
c√≥mo
gestionar
las
direcciones
IP
de
la
red
de
su
casa
?
Afortunada-


mente
,
existe
una
forma
m√°s
simple
de
asignar
direcciones
que
ha
encontrado
un
uso
cada


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
339


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
339vez
m√°s
amplio
en
escenarios
de
este
tipo
:
la
traducci√≥n
de
direcciones
de
red
(
NAT
,
Net-


work
Address
Translation
)
[
RFC
2663
;
RFC
3022
]
.


La
Figura
4.22
muestra
el
funcionamiento
de
un
router
NAT
.
Este
router
,
que
se
encuen-


tra
en
una
vivienda
,
tiene
una
interfaz
que
es
parte
de
la
red
dom√©stica
situada
en
la
parte


derecha
de
la
Figura
4.22
.
El
direccionamiento
dentro
de
la
red
dom√©stica
es
exactamente


como
hemos
visto
anteriormente
(
las
cuatro
interfaces
de
la
red
tienen
la
misma
direcci√≥n


de
subred
10.0.0/24
)
.
El
espacio
de
direcciones
10.0.0.0/8
corresponde
a
una
de
las
tres
par-


tes
del
espacio
de
direcciones
IP
que
est√°
reservado
en
[
RFC
1918
]
para
una
red
privada
o


para
un
√°mbito
con
direcciones
privadas
,
como
la
red
dom√©stica
de
la
Figura
4.22
.
Un


√°mbito
con
direcciones
privadas
hace
referencia
a
una
red
cuyas
direcciones
s√≥lo
tienen
sig-


nificado
para
los
dispositivos
internos
de
dicha
red
.
Veamos
por
qu√©
esto
es
importante
.


Considere
el
hecho
de
que
existen
cientos
de
miles
de
redes
dom√©sticas
y
que
muchas
utili-


zan
el
mismo
espacio
de
direcciones
,
10.0.0.0/24
.
Los
dispositivos
de
una
red
dom√©stica


dada
pueden
enviarse
paquetes
entre
s√≠
utilizando
el
direccionamiento
10.0.0.0/24
.
Sin


embargo
,
los
paquetes
reenviados
hacia
fuera
de
la
red
dom√©stica
,
hacia
Internet
,
evidente-


mente
no
pueden
utilizar
estas
direcciones
(
ni
como
direcci√≥n
de
origen
ni
como
direcci√≥n


de
destino
)
,
porque
existen
cientos
de
miles
de
redes
que
emplean
ese
bloque
de
direccio-


nes
.
Es
decir
,
las
direcciones
10.0.0.0/24
s√≥lo
tienen
significado
dentro
de
una
red
dom√©s-


tica
dada
.
Pero
si
las
direcciones
privadas
s√≥lo
tienen
significado
dentro
de
la
red
,
¬ø
c√≥mo
se


direccionan
los
paquetes
cuando
se
env√≠an
a
Internet
o
se
reciben
de
Internet
,
donde
necesa-


riamente
las
direcciones
tienen
que
ser
√∫nicas
?
Para
entender
esto
hay
que
comprender


c√≥mo
funciona
NAT
.


El
router
NATno
parece
un
router
a
ojos
del
mundo
exterior
.
En
su
lugar
,
el
router
NAT


se
comporta
de
cara
al
exterior
como
un
√∫nico
dispositivo
con
una
direcci√≥n
IP
√∫nica
.
En
la


Figura
4.22
,
todo
el
tr√°fico
que
sale
del
router
dom√©stico
hacia
Internet
tiene
una
direcci√≥n


IP
de
origen
igual
a
138.76.29.7
,
y
todo
el
tr√°fico
que
entra
en
√©l
tienen
que
tener
la
direc-


ci√≥n
de
destino
138.76.29.7
.
En
resumen
,
el
router
NAT
oculta
los
detalles
de
la
red
dom√©s-


tica
al
mundo
exterior
.
(
Como
nota
al
margen
,
posiblemente
se
est√©
preguntando
d√≥nde


obtienen
las
computadoras
de
la
red
dom√©stica
sus
direcciones
y
d√≥nde
obtiene
el
router
su


direcci√≥n
IP
√∫nica
.
A
menudo
,
la
respuesta
a
ambas
preguntas
es
la
misma
:
¬°
DHCP
!
El
rou-


ter
obtiene
su
direcci√≥n
del
servidor
DHCP
del
ISP
y
el
router
ejecuta
un
servidor
DHCP


para
proporcionar
direcciones
a
las
computadoras
,
dentro
del
espacio
de
direcciones
de
la


red
dom√©stica
controlada
por
el
router
NAT-DHCP
.
)


Si
todos
los
datagramas
que
llegan
al
router
NAT
procedentes
de
la
WAN
tienen
la


misma
direcci√≥n
IP
de
destino
(
espec√≠ficamente
,
la
de
la
interfaz
WAN
del
router
NAT
)
,


entonces
¬ø
c√≥mo
sabe
el
router
a
qu√©
host
interno
deber√≠a
reenviar
un
datagrama
dado
?
El


truco
consiste
en
utilizar
una
tabla
de
traducciones
NAT
almacenada
en
el
router
NAT
,
e


incluir
los
n√∫meros
de
puerto
,
as√≠
como
las
direcciones
IP
en
las
entradas
de
la
tabla
.


Considere
el
ejemplo
de
la
Figura
4.22
.
Suponga
que
un
usuario
de
una
red
dom√©stica


que
utiliza
el
host
con
la
direcci√≥n
10.0.0.1
solicita
una
p√°gina
web
almacenada
en
un
ser-


vidor
web
(
puerto
80
)
con
la
direcci√≥n
IP
128.119.40.186
.
El
host
10.0.0.1
asigna
el


n√∫mero
de
puerto
de
origen
(
arbitrario
)
3345
y
env√≠a
el
datagrama
a
la
LAN
.
El
router
NAT


recibe
el
datagrama
,
genera
un
nuevo
n√∫mero
de
puerto
de
origen
,
5001
,
para
el
datagrama
,


sustituye
la
direcci√≥n
IP
de
origen
por
su
direcci√≥n
IP
de
la
red
WAN
138.76.29.7
,
y
susti-


tuye
el
n√∫mero
de
puerto
de
origen
original
3345
por
el
nuevo
n√∫mero
de
puerto
de
origen


5001
.
Al
generar
un
nuevo
n√∫mero
de
puerto
de
origen
,
el
router
NAT
puede
seleccionar


cualquier
n√∫mero
de
puerto
de
origen
que
actualmente
no
se
encuentre
en
la
tabla
de
tra-


340
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
340ducciones
 
NAT
.
(
Observe
que
,
puesto
que
la
longitud
del
campo
n√∫mero
de
puerto
es
16


bits
,
el
protocolo
NAT
puede
dar
soporte
a
60.000
conexiones
simult√°neas
utilizando
la


√∫nica
direcci√≥n
IP
WAN
del
router
.
)
En
el
router
,
NAT
tambi√©n
a√±ade
una
entrada
a
su
tabla


de
traducciones
.
El
servidor
web
,
que
afortunadamente
no
es
consciente
de
que
el
data-


grama
entrante
 
que
contiene
la
solicitud
HTTP
ha
sido
manipulado
por
el
router
NAT
,
res-


ponde
con
un
datagrama
cuya
direcci√≥n
de
destino
es
la
direcci√≥n
IP
del
router
NAT
y
cuyo


n√∫mero
de
puerto
de
destino
es
5001
.
Cuando
este
datagrama
llega
al
router
NAT
,
√©ste


indexa
la
tabla
de
traducciones
NAT
utilizando
la
direcci√≥n
IP
de
destino
y
el
n√∫mero
de


puerto
de
destino
para
obtener
la
direcci√≥n
IP
(
10.0.0.1
)
y
el
n√∫mero
de
puerto
de
destino


(
3345
)
apropiados
para
el
navegador
de
la
red
dom√©stica
.
A
continuaci√≥n
,
el
router
rees-


cribe
la
direcci√≥n
de
destino
y
el
n√∫mero
de
puerto
de
destino
del
datagrama
y
lo
reenv√≠a
a


la
red
dom√©stica
.


NAT
ha
disfrutado
de
una
gran
difusi√≥n
en
los
√∫ltimos
a√±os
,
aunque
tambi√©n
tene-


mos
que
decir
que
muchos
puristas
de
la
comunidad
IETF
ponen
bastantes
objeciones
a


NAT
.
En
primer
lugar
,
argumentan
que
los
n√∫meros
de
puerto
deben
emplearse
para


direccionar
procesos
,
no
para
direccionar
hosts
.
(
De
hecho
,
esta
violaci√≥n
puede
causar


problemas
en
los
servidores
en
ejecuci√≥n
en
la
red
dom√©stica
,
ya
que
,
como
hemos
visto


en
el
Cap√≠tulo
2
,
los
procesos
de
servidor
est√°n
a
la
espera
de
las
solicitudes
entrantes
en


los
puertos
bien
conocidos
.
)
En
segundo
lugar
,
argumentan
que
los
routers
est√°n
pensa-


dos
para
procesar
paquetes
s√≥lo
hasta
la
capa
3
.
En
tercer
lugar
,
opinan
que
el
protocolo


NAT
viola
lo
que
se
ha
venido
a
denominar
el
enfoque
terminal
a
terminal
,
es
decir
,
que


los
hosts
deben
comunicarse
directamente
entre
s√≠
,
sin
que
los
nodos
intermedios
modifi-


quen
las
direcciones
IP
y
los
n√∫meros
de
puerto
.
Y
en
cuarto
lugar
,
creen
que
deber√≠a
uti-


lizarse
IPv6
(
v√©ase
la
Secci√≥n
4.4.4
)
para
resolver
la
carest√≠a
de
direcciones
IP
,
en
lugar
de


parchear
el
problema
con
una
soluci√≥n
milagrosa
como
NAT
.
Pero
,
guste
o
no
,
NAT
se
ha


convertido
en
un
componente
importante
de
Internet
.


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
341


Figura
4.22
‚Ä¢
Traducci√≥n
de
direcciones
de
red
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
341Otro
problema
m√°s
importante
de
NAT
es
que
interfiere
con
las
aplicaciones
P2P
,
inclu-


yendo
las
aplicaciones
de
compartici√≥n
de
archivos
P2P
y
las
aplicaciones
de
voz
sobre
IP


P2P.
Recuerde
del
Cap√≠tulo
2
que
,
en
una
aplicaci√≥n
P2P
,
cualquier
par
A
participante
debe-


r√≠a
poder
iniciar
una
conexi√≥n
TCP
con
cualquier
otro
par
B
participante
.
La
esencia
del
pro-


blema
es
que
si
el
par
B
est√°
situado
detr√°s
de
un
traductor
NAT
no
puede
actuar
como
un


servidor
y
aceptar
conexiones
TCP
.
Como
veremos
en
los
problemas
de
repaso
,
este
pro-


blema
de
NAT
puede
soslayarse
si
el
par
A
no
est√°
situado
detr√°s
de
un
traductor
NAT
.
En


este
caso
,
el
par
A
puede
contactar
primero
al
par
B
a
trav√©s
de
un
par
C
intermedio
,
que
no


est√©
situado
detr√°s
de
un
traductor
NAT
y
con
el
que
B
tenga
establecida
una
conexi√≥n
TCP


activa
.
El
par
A
puede
entonces
pedir
al
par
B
,
a
trav√©s
de
C
,
que
inicie
una
conexi√≥n


TCP
directamente
con
el
par
A.
Una
vez
que
la
conexi√≥n
TCP
directa
P2P
se
ha
establecido


entre
los
pares
A
y
B
,
√©stos
podr√°n
intercambiar
mensajes
o
archivos
.
Esta
t√©cnica
,
conocida


con
el
nombre
de
inversi√≥n
de
la
conexi√≥n
(
connection
reversal
)
,
es
utilizada
por
muchas


aplicaciones
P2P
para
NAT
transversal
(
NAT
Traversal
)
.
Si
tanto
el
par
A
como
el
par
B


utilizan
NAT
,
la
situaci√≥n
es
un
poco
m√°s
compleja
,
pero
puede
solventarse
utilizando
re-


transmisores
de
aplicaci√≥n
,
como
hemos
visto
con
los
retransmisores
Skype
en
el
Cap√≠tulo
2
.


UPnP


El
mecanismo
de
NAT
transversal
es
proporcionado
cada
vez
m√°s
frecuentemente
por
Uni-


versal
Plug
and
Play
(
UPnP
)
,
que
es
un
protocolo
que
permite
a
un
host
descubrir
y
configu-


rar
un
traductor
NAT
pr√≥ximo
[
UPnP
Forum
2009
]
.
UPnP
requiere
que
tanto
el
host
como
el


traductor
NAT
sean
compatibles
con
UPnP.
Con
UPnP
,
una
aplicaci√≥n
que
se
ejecuta
en
un


host
puede
solicitar
una
correspondencia
NAT
entre
su
tupla
(
direcci√≥n
IP
privada
,
n√∫mero


de
puerto
privado
)
y
la
tupla
(
direcci√≥n
IP
p√∫blica
,
n√∫mero
de
puerto
p√∫blico
)
para
alg√∫n


n√∫mero
de
puerto
p√∫blico
solicitado
.
Si
el
traductor
NAT
acepta
la
solicitud
y
crea
la
corres-


pondencia
,
entonces
los
nodos
del
exterior
pueden
iniciar
conexiones
TCP
con
(
direcci√≥n


IP
privada
,
n√∫mero
de
puerto
privado
)
.
Adem√°s
,
UPnP
permite
a
la
aplicaci√≥n
conocer
el


valor
de
(
direcci√≥n
IP
p√∫blica
,
n√∫mero
de
puerto
p√∫blico
)
,
de
manera
que
la
aplicaci√≥n


pueda
anunciarse
al
mundo
exterior
.


Por
ejemplo
,
suponga
que
su
host
,
situado
detr√°s
de
un
traductor
NAT
compatible
con


UPnP
,
tiene
la
direcci√≥n
privada
10.0.0.1
y
est√°
ejecutando
BitTorrent
en
el
puerto
3345
.


Suponga
tambi√©n
que
la
direcci√≥n
IP
p√∫blica
del
traductor
NA
T
es
138.76.29.7
.
Natural-


mente
,
su
aplicaci√≥n
BitTorrent
desea
poder
aceptar
conexiones
de
otros
hosts
,
para
poder


intercambiar
fragmentos
con
ellos
.
En
esta
situaci√≥n
,
la
aplicaci√≥n
BitTorrent
de
su
host
pide


al
traductor
NAT
que
cree
un
‚Äú
t√∫nel
‚Äù
que
asigne
(
10.0.0.1
,
3345
)
a
(
138.76.29.7
,
5001
)
.
(
La


aplicaci√≥n
elige
el
n√∫mero
de
puerto
p√∫blico
5001
.
)
La
aplicaci√≥n
BitTorrent
de
su
host


podr√≠a
tambi√©n
anunciar
a
su
tracker
que
est√°
disponible
en
(
138.76.29.7
,
5001
)
.
De
esta


manera
,
un
host
externo
que
est√©
ejecutando
BitTorrent
puede
contactar
con
el
tracker
y


determinar
que
su
aplicaci√≥n
BitTorrent
est√°
ejecut√°ndose
en
(
138.76.29.7
,
5001
)
.
El
host


externo
puede
enviar
un
paquete
SYN
TCP
a
(
138.76.29.7
,
5001
)
.
Cuando
el
traductor


NAT
recibe
el
paquete
SYN
,
cambiar√°
la
direcci√≥n
IP
de
destino
y
el
n√∫mero
de
puerto
del


paquete
a
(
10.0.0.1
,
3345
)
y
lo
reenviar√°
a
trav√©s
de
NAT
.


En
resumen
,
UPnP
permite
a
hosts
externos
iniciar
sesiones
de
comunicaci√≥n
con


hosts
conectados
a
trav√©s
de
un
traductor
NAT
utilizando
TCP
o
UDP
.
NAT
ha
sido


durante
mucho
tiempo
un
aut√©ntico
quebradero
de
cabeza
para
las
aplicaciones
P2P
;


UPnP
,
que
proporciona
una
soluci√≥n
efectiva
y
robusta
de
NAT
transversal
,
puede
ser
su


salvador
.
Esta
exposici√≥n
acerca
de
NAT
y
UPnP
ha
sido
necesariamente
breve
,
por
lo


que
si
desea
saber
m√°s
acerca
de
NAT
,
consulte
[
Huston
2004
,
Cisco
NAT
2009
]
.


342
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3424.4.3
Protocolo
de
mensajes
de
control
de
Internet
(
ICMP
)


Recuerde
que
la
capa
de
red
de
Internet
tiene
tres
componentes
principales
:
el
protocolo
IP
,


estudiado
en
la
secci√≥n
anterior
;
los
protocolos
de
enrutamiento
de
Internet
(
incluyendo
RIP
,


OSPF
y
BGP
)
,
que
se
abordan
en
la
Secci√≥n
4.6
e
ICMP
,
que
es
el
objeto
de
esta
secci√≥n
.


Los
hosts
y
los
routers
utilizan
ICMP
,
especificado
en
[
RFC
792
]
,
para
intercambiarse


informaci√≥n
acerca
de
la
capa
de
red
.
El
uso
m√°s
t√≠pico
de
ICMP
es
la
generaci√≥n
de
infor-


mes
de
error
.
Por
ejemplo
,
al
ejecutar
una
sesi√≥n
Telnet
,
FTP
o
HTTP
,
puede
encontrarse
con


un
mensaje
de
error
como
‚Äú
Red
de
destino
inalcanzable
‚Äù
.
Este
mensaje
tiene
su
origen
en


ICMP
.
En
alg√∫n
momento
,
un
router
IP
no
ha
podido
encontrar
una
ruta
hasta
el
host
especi-


ficado
en
su
aplicaci√≥n
Telnet
,
FTP
o
HTTP
,
y
dicho
router
ha
creado
y
enviado
un
mensaje


ICMP
de
tipo
3
a
su
host
para
informarle
del
error
.


ICMP
a
menudo
se
considera
parte
de
IP
pero
,
en
sentido
arquitect√≥nico
,
se
encuentra


justo
encima
de
IP
,
ya
que
los
mensajes
ICMP
son
transportados
dentro
de
los
datagramas


IP
.
Es
decir
,
los
mensajes
ICMP
son
transportados
como
carga
√∫til
de
IP
,
al
igual
que
los
seg-


mentos
TCP
o
UDP
son
transportados
como
carga
√∫til
de
IP
.
De
forma
similar
,
cuando
un


host
recibe
un
datagrama
IP
con
ICMP
especificado
como
el
protocolo
de
la
capa
superior
,


demultiplexa
el
contenido
del
datagrama
para
ICMP
,
al
igual
que
demultiplexar√≠a
el
conte-


nido
de
un
datagrama
para
TCP
o
UDP
.


Los
mensajes
ICMP
tienen
un
campo
de
tipo
y
un
campo
de
c√≥digo
,
y
contienen
la


cabecera
y
los
8
primeros
bytes
del
datagrama
IP
que
ha
dado
lugar
a
la
generaci√≥n
del
men-


saje
ICMP
en
primer
lugar
(
de
modo
que
el
emisor
puede
determinar
qu√©
datagrama
ha
pro-


ducido
el
error
)
.
En
la
Figura
4.23
se
muestran
una
serie
de
tipos
de
mensajes
seleccionados
.


Observe
que
los
mensajes
ICMP
no
s√≥lo
se
emplean
para
indicar
condiciones
de
error
.


Tipo
ICMP
C√≥digo
Descripci√≥n


0
0
respuesta
de
eco
(
para
ping
)


3
0
red
de
destino
inalcanzable


3
1
host
de
destino
inalcanzable


3
2
protocolo
de
destino
inalcanzable


3
3
puerto
de
destino
inalcanzable


3
6
red
de
destino
desconocida


3
7
host
de
destino
desconocido


4
0
regulaci√≥n
del
origen
(
control
de
congesti√≥n
)


8
0
solicitud
de
eco


9
0
anuncio
de
router


10
0
descubrimiento
de
router


11
0
TTL
caducado


12
0
Cabecera
IP
err√≥nea


Figura
4.23
‚Ä¢
Tipos
de
mensajes
ICMP
.


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
343


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
343El
programa
bien
conocido
ping
env√≠a
un
mensaje
ICMP
de
tipo
8
y
c√≥digo
0
al
host


especificado
.
El
host
de
destino
,
al
ver
la
solicitud
de
eco
,
devuelve
una
respuesta
de
eco


ICMP
de
tipo
0
y
c√≥digo
0
.
La
mayor√≠a
de
las
implementaciones
de
TCP
/
IP
soportan
el
ser-


vidor
ping
directamente
en
el
sistema
operativo
;
es
decir
,
el
servidor
no
es
un
proceso
.
El


Cap√≠tulo
11
de
[
Stevens
1990
]
proporciona
el
c√≥digo
fuente
del
programa
cliente
ping
.


344
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


INSPECCI√ìN
DE
DATAGRAMAS
:
CORTAFUEGOS
Y


SISTEMAS
DE
DETECCI√ìN
DE
INTRUSIONES


Suponga
que
le
han
asignado
la
tarea
de
administrar
una
red
dom√©stica
,
departamental
,
univer-


sataria
o
corporativa
.
Los
atacantes
,
que
saben
cu√°l
es
el
rango
de
direcciones
IP
de
su
red
,


pueden
enviar
f√°cilmente
datagramas
IP
a
las
direcciones
de
ese
rango
.
Estos
datagramas
pue-


den
hacer
toda
clase
de
cosas
retorcidas
,
incluyendo
confeccionar
mapas
de
la
red
mediante


barridos
de
ping
y
escaneo
de
puertos
,
da√±ar
los
hosts
vulnerables
con
paquetes
err√≥neos
,
inun-


dar
los
servidores
con
una
enrome
cantidad
de
paquetes
ICMP
e
infectar
los
hosts
incluyendo


software
malicioso
en
los
paquetes
.
Como
administrador
de
la
red
,
¬ø
qu√©
har√°
con
todos
esos


malvados
capaces
de
enviar
paquetes
maliciosos
a
su
red
?
Hay
disponibles
dos
mecanismos
de


defensa
muy
populares
contra
los
ataques
de
paquetes
maliciosos
:
los
cortafuegos
y
los
sistemas


de
detecci√≥n
de
intrusiones
(
IDS
,
Intrusion
Detection
System
)
.


Como
administrador
de
la
red
,
en
primer
lugar
puede
probar
a
instalar
un
cortafuegos


entre
su
red
e
Internet
.
(
La
mayor√≠a
de
los
routers
actuales
de
acceso
disponen
de
cortafue-


gos
.
)
Los
cortafuegos
inspeccionan
los
campos
de
cabecera
de
los
segmentos
y
datagramas
,


denegando
el
acceso
a
la
red
interna
a
los
datagramas
sospechosos
.
Por
ejemplo
,
un
corta-


fuegos
puede
configurarse
para
bloquear
todos
los
paquetes
de
solicitud
de
eco
ICMP
,


impidiendo
as√≠
que
un
atacante
lleve
a
cabo
un
tradicional
barrido
de
ping
a
lo
largo
de
su


rango
de
direcciones
IP
.
Los
cortafuegos
tambi√©n
pueden
bloquear
paquetes
bas√°ndose
en


las
direcciones
IP
de
origen
y
de
destino
y
en
los
n√∫meros
de
puerto
.
Adem√°s
,
los
cortafue-


gos
se
pueden
configurar
para
controlar
las
conexiones
TCP
,
dejando
entrar
s√≥lo
a
los


datagramas
que
pertenecen
a
conexiones
aprobadas
.


Con
un
sistema
IDS
puede
proporcionarse
protecci√≥n
adicional
.
Un
IDS
,
colocado
normal-


mente
en
la
frontera
de
la
red
,
realiza
una
‚Äú
inspecci√≥n
profunda
de
los
paquetes
‚Äù
,
examinando


no
s√≥lo
los
campos
de
cabecera
sino
tambi√©n
las
cargas
√∫tiles
de
los
datagramas
(
incluyendo


los
datos
de
la
capa
de
aplicaci√≥n
)
.
Un
IDS
dispone
de
una
base
de
datos
de
signaturas
de


paquete
que
se
sabe
que
forman
parte
de
ataques
.
Esta
base
de
datos
se
actualiza
autom√°tica-


mente
cuando
se
descubren
nuevos
tipos
de
ataque
.
A
medida
que
los
paquetes
atraviesan
el


sistema
IDS
,
√©ste
intenta
encontrar
una
coincidencia
de
los
campos
de
cabecera
o
las
cargas


√∫tiles
con
las
signaturas
que
almacena
en
su
base
de
datos
.
Si
encuentra
una
coincidencia
,


genera
una
alerta
.
Un
sistema
de
prevenci√≥n
de
intrusiones
(
IPS
,
Intrusion
Prevention
System
)
es


similar
a
un
sistema
IDS
,
salvo
porque
adem√°s
de
generar
una
alerta
bloquea
los
paquetes
.
En


el
Cap√≠tulo
8
estudiaremos
los
cortafuegos
y
los
sistemas
IDS
en
detalle
.


¬ø
Pueden
los
cortafuegos
y
los
sistemas
IDS
proteger
completamente
a
la
red
frente
a
todos


los
ataques
?
Evidentemente
,
la
respuesta
es
no
,
ya
que
los
atacantes
encuentran
continua-


mente
nuevos
ataques
para
los
que
las
signaturas
todav√≠a
no
est√°n
disponibles
.
No
obstante
,


los
cortafuegos
y
los
IDS
tradicionales
basados
en
signaturas
son
√∫tiles
para
proteger
a
las


redes
de
los
ataques
conocidos
.


SEGURIDAD


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
344Observe
que
el
programa
cliente
necesita
poder
instruir
al
sistema
operativo
para
generar
un


mensaje
ICMP
de
tipo
8
y
c√≥digo
0
.


Otro
interesante
mensaje
ICMP
es
el
mensaje
de
regulaci√≥n
del
origen
.
Este
mensaje


rara
vez
se
emplea
en
la
pr√°ctica
.
Su
prop√≥sito
original
era
llevar
a
cabo
el
control
de
con-


gesti√≥n
(
permitir
a
un
router
congestionado
enviar
un
mensaje
ICMP
de
este
tipo
a
un
host


para
forzarle
a
reducir
su
velocidad
de
transmisi√≥n
)
.
Hemos
visto
en
el
Cap√≠tulo
3
que
TCP


dispone
de
su
propio
mecanismo
control
de
congesti√≥n
que
opera
en
la
capa
de
transporte
,


sin
utilizar
ninguna
realimentaci√≥n
de
la
capa
de
red
,
como
el
mensaje
ICMP
de
regulaci√≥n


del
origen
.


En
el
Cap√≠tulo
1
hemos
introducido
el
programa
Traceroute
,
el
cual
nos
permite
tra-


zar
una
ruta
desde
un
host
a
cualquier
otro
host
del
mundo
.
Cada
vez
m√°s
frecuentemente
,


Traceroute
se
implementa
con
mensajes
ICMP
.
Para
determinar
los
nombres
y
las
direccio-


nes
de
los
routers
existentes
entre
el
origen
y
el
destino
,
Tracerouteen
el
origen
env√≠a
una


serie
de
datagramas
IP
ordinarios
al
destino
.
Cada
uno
de
estos
datagramas
transporta
un


segmento
UDP
con
un
n√∫mero
de
puerto
UDP
poco
probable
.
El
primero
de
estos
datagra-


mas
tiene
un
TTL
de
1
,
el
segundo
de
2
,
el
tercero
de
3
,
y
as√≠
sucesivamente
.
El
origen
tam-


bi√©n
inicia
los
temporizadores
para
cada
uno
de
los
datagramas
.
Cuando
el
datagrama


n-√©simo
llega
al
router
n-√©simo
,
√©ste
observa
que
el
TTL
del
datagrama
acaba
de
caducar
.


De
acuerdo
con
las
reglas
del
protocolo
IP
,
el
router
descarta
el
datagrama
y
env√≠a
al
origen


un
mensaje
de
advertencia
ICMP
(
tipo
11
,
c√≥digo
0
)
.
Este
mensaje
de
advertencia
incluye
el


nombre
del
router
y
su
direcci√≥n
IP
.
Cuando
este
mensaje
ICMP
llega
de
vuelta
al
origen
,


√©ste
obtiene
el
tiempo
de
ida
y
vuelta
del
temporizador
,
y
el
nombre
y
la
direcci√≥n
IP
del


router
n-√©simo
del
propio
mensaje
ICMP
.


¬ø
C√≥mo
sabe
un
origen
Traceroutecu√°ndo
dejar
de
enviar
segmentos
UDP
?
Recuerde


que
el
origen
incrementa
el
valor
del
campo
TTL
cada
vez
que
env√≠a
un
datagrama
.
Por


tanto
,
uno
de
los
datagramas
terminar√°
recorriendo
el
camino
completo
hasta
el
host
de
des-


tino
.
Dado
que
ese
datagrama
contiene
un
segmento
UDP
con
un
n√∫mero
de
puerto
impro-


bable
,
el
host
de
destino
devuelve
al
origen
un
mensaje
ICMP
de
puerto
inalcanzable
(
tipo


3
,
c√≥digo
3
)
.
Cuando
el
host
de
origen
recibe
este
mensaje
ICMP
,
sabe
que
no
tiene
que


enviar
m√°s
paquetes
de
prueba
.
(
Realmente
,
el
programa
est√°ndar
Traceroute
env√≠a
con-


juntos
de
tres
paquetes
con
el
mismo
TTL
y
,
por
tanto
,
la
salida
de
Traceroute
propor-


ciona
tres
resultados
para
cada
TTL
.
)


De
esta
forma
,
el
host
de
origen
obtiene
el
n√∫mero
y
la
identidad
de
los
routers
que
exis-


ten
entre
√©l
y
el
host
de
destino
,
as√≠
como
el
tiempo
de
ida
y
vuelta
entre
los
dos
hosts
.


Observe
que
el
programa
cliente
Traceroute
tiene
que
poder
instruir
al
sistema
operativo


para
generar
los
datagramas
UDP
con
valores
TTL
espec√≠ficos
y
el
sistema
operativo
tam-


bi√©n
tiene
que
ser
capaz
de
notificarle
la
llegada
de
mensajes
ICMP
.
Ahora
que
sabe
c√≥mo


funciona
Traceroute
,
puede
volver
atr√°s
y
pr√°cticar
con
√©l
un
poco
m√°s
.


4.4.4
IPv6


Ap
r
i
n
c
i
p
i
o
s
 
d
e
 
l
a
 
d
√©
c
a
d
a
 
d
e
 
1
9
9
0
,
 
e
l
 
Internet
Engineering
Task
Force
comenz√≥
a
desarro-


llar
un
sucesor
para
el
protocolo
IPv4
.
La
principal
motivaci√≥n
de
esta
iniciativa
fue
que
se


dieron
cuenta
de
que
el
espacio
de
direcciones
IP
de
32
bits
estaba
comenzando
a
agotarse
,
a


causa
de
las
nuevas
subredes
y
nodos
IP
que
estaban
conect√°ndose
a
Internet
(
a
los
que
se


les
estaban
asignando
direcciones
IP
√∫nicas
)
a
una
velocidad
sobrecogedora
.
Para
responder


a
esta
necesidad
de
un
espacio
de
direcciones
IP
m√°s
grande
,
se
desarroll√≥
un
nuevo
proto-


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
345


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
345colo
IP
,
el
protocolo
IPv6
.
Los
dise√±adores
de
IPv6
tambi√©n
vieron
aqu√≠
la
oportunidad
de


ajustar
y
aumentar
otros
aspectos
de
IPv4
,
bas√°ndose
en
la
experiencia
acumulada
sobre
el


funcionamiento
de
IPv4
.


El
momento
en
que
todas
las
direcciones
IPv4
habr√≠an
sido
asignadas
(
y
por
tanto
nin-


guna
nueva
subred
podr√≠a
conectarse
a
Internet
)
fue
objeto
de
un
importante
debate
.
Las


estimaciones
de
los
dos
l√≠deres
del
grupo
de
trabajo
Address
Lifetime
Expectations
(
Expec-


tativas
del
tiempo
de
vida
de
las
direcciones
)
del
IETF
fueron
que
las
direcciones
comenza-


r√≠an
a
agotarse
en
2008
y
2018
,
respectivamente
[
Solensky
1996
]
.
Un
an√°lisis
m√°s
reciente


[
Huston
2008
]
sit√∫a
la
fecha
de
agotamiento
en
torno
a
2010
.
En
1996
,
el
Registro
ameri-


cano
de
n√∫meros
de
Internet
(
ARIN
,
American
Registry
for
Internet
Numbers
)
inform√≥
de


que
todas
las
direcciones
de
clase
A
IPv4
hab√≠an
sido
asignadas
,
el
62
por
ciento
de
las
direc-


ciones
de
clase
B
hab√≠an
sido
asignadas
y
el
37
por
ciento
de
las
direcciones
de
clase
C
tam-


bi√©n
hab√≠an
sido
asignadas
[
ARIN
1996
]
.
Si
desea
ver
un
informe
reciente
sobre
la


asignaci√≥n
del
espacio
de
direcciones
IPv4
,
consulte
[
Hain
2005
]
.
Aunque
estas
estimacio-


nes
y
datos
suger√≠an
que
quedaba
bastante
tiempo
para
que
el
espacio
de
direcciones
de


IPv4
se
agotara
,
se
dieron
cuenta
de
que
se
necesitar√≠a
un
tiempo
considerable
para
implan-


tar
una
nueva
tecnolog√≠a
a
tan
gran
escala
,
y
por
eso
se
comenz√≥
a
trabajar
en
IPng
(
Next


Generation
IP
,
IP
de
siguiente
generaci√≥n
)
[
Bradner
1996
;
RFC
1752
]
.
El
resultado
de
este


esfuerzo
fue
la
especificaci√≥n
de
la
versi√≥n
6
de
IP
(
IPv6
)
[
RFC
2460
]
.
(
Una
pregunta
que


se
plantea
a
menudo
es
qu√©
ocurri√≥
con
IPv5
.
Inicialmente
se
pens√≥
que
el
protocolo
ST-2
se


convertir√≠a
en
IPv5
,
pero
ST-2
fue
descartado
m√°s
tarde
en
favor
del
protocolo
RSVP
,
que


estudiaremos
en
el
Cap√≠tulo
7
.
)


Puede
encontrar
fuentes
de
informaci√≥n
excelentes
acerca
de
IPv6
en
[
Huitema
1998
,


IPv6
2009
]
.


Fomato
del
datagrama
IPv6


El
formato
del
datagrama
IPv6
se
muestra
en
la
Figura
4.24
.
Los
cambios
m√°s
importantes


introducidos
en
IPv6
son
evidentes
en
el
formato
de
su
datagrama
:


‚Ä¢
Capacidades
ampliadas
de
direccionamiento
.
IPv6
aumenta
el
tama√±o
de
la
direcci√≥n


IP
de
32
a
128
bits
.
De
esta
manera
,
se
asegura
que
el
mundo
no
se
quedar√°
sin
direccio-


346
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.24
‚Ä¢
Formato
del
datagrama
de
IPv6
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
346nes
IP
.
Ahora
,
cada
grano
de
arena
del
planeta
puede
tener
asignada
una
direcci√≥n
IP
.


Adem√°s
de
las
direcciones
de
unidifusi√≥n
y
de
multidifusi√≥n
,
IPv6
ha
introducido
un


nuevo
tipo
de
direcci√≥n
,
denominado
direcci√≥n
anycast
,
que
permite
entregar
un
data-


grama
a
uno
cualquiera
de
un
grupo
de
hosts
.
(
Esta
funcionalidad
podr√≠a
utilizarse
,
por


ejemplo
,
para
enviar
un
mensaje
GET
HTTP
al
m√°s
pr√≥ximo
de
una
serie
de
sitios
espejo


que
contengan
un
determinado
documento
.
)


‚Ä¢
Una
cabecera
de
40
bytes
simplificada
.
Como
se
ha
mencionado
anteriormente
,
algunos


de
los
campos
de
IPv4
se
han
eliminado
o
se
han
hecho
opcionales
.
La
cabecera
de
lon-


gitud
fija
de
40
bytes
permite
un
procesamiento
m√°s
r√°pido
del
datagrama
IP
.
Una
nueva


codificaci√≥n
de
las
opciones
permite
un
procesamiento
m√°s
flexible
de
las
mismas
.
 

‚Ä¢
Prioridad
y
etiquetado
del
flujo
.
IPv6
utiliza
una
definici√≥n
bastante
amplia
de
flujo
.
Los


documentos
RFC
1752
y
RFC
2460
establecen
que
esto
permite
‚Äú
etiquetar
los
paquetes


que
pertenecen
a
determinados
flujos
para
los
que
el
emisor
solicita
un
tratamiento
espe-


cial
,
como
un
servicio
en
tiempo
real
o
una
calidad
de
servicio
no
predeterminados
‚Äù
.
Por


ejemplo
,
la
transmisi√≥n
de
audio
y
de
v√≠deo
puede
posiblemente
tratarse
como
un
flujo
.


Por
el
contrario
,
aplicaciones
m√°s
tradicionales
,
como
la
transferencia
de
archivos
y
el


correo
electr√≥nico
,
no
se
pueden
tratar
como
flujos
.
Es
posible
que
el
tr√°fico
transpor-


tado
por
un
usuario
de
alta
prioridad
(
por
ejemplo
,
alguien
que
paga
por
obtener
un
mejor


servicio
para
su
tr√°fico
)
tenga
que
ser
tratado
como
un
flujo
.
Sin
embargo
,
lo
que
est√°


claro
es
que
los
dise√±adores
de
IPv6
prev√©n
la
eventual
necesidad
de
poder
diferenciar


entre
los
flujos
,
incluso
aunque
el
significado
exacto
de
flujo
no
haya
sido
determinado
.


La
cabecera
de
IPv6
tambi√©n
tiene
un
campo
de
8
bits
para
definir
la
clase
de
tr√°fico
.


Este
campo
,
como
el
campo
TOS
de
IPv4
,
se
puede
utilizar
para
dar
prioridad
a
determi-


nados
datagramas
de
un
flujo
,
o
se
puede
emplear
para
dar
prioridad
a
datagramas
de


ciertas
aplicaciones
(
por
ejemplo
,
ICMP
)
con
respecto
a
datagramas
de
otras
aplicacio-


nes
(
como
por
ejemplo
,
las
noticias
de
red
)
.


Como
se
ha
mencionado
anteriormente
,
la
comparaci√≥n
de
la
Figura
4.24
con
la
Figura


4.13
revela
la
estructura
m√°s
simple
y
estilizada
del
datagrama
de
IPv6
.
En
IPv6
se
definen


los
siguientes
campos
:


‚Ä¢
Versi√≥n
.
Este
campo
de
4
bits
identifica
el
n√∫mero
de
versi√≥n
IP
.
Nada
sorprendente-


mente
,
IPv6
transporta
un
valor
de
6
en
este
campo
.
Observe
que
incluir
en
este
campo


el
valor
4
no
implica
que
se
cree
un
datagrama
IPv4
v√°lido
.
Si
lo
hiciera
,
la
vida
ser√≠a


mucho
m√°s
simple
(
v√©ase
m√°s
adelante
la
exposici√≥n
sobre
la
transici√≥n
de
IPv4
a


IPv6
)
.


‚Ä¢
Clase
de
tr√°fico
.
Este
campo
de
8
bits
es
similar
en
esp√≠ritu
al
campo
TOS
que
hemos


visto
en
IPv4
.


‚Ä¢
Etiqueta
de
flujo
.
Como
hemos
mencionado
anteriormente
,
este
campo
de
20
bits
se
uti-


liza
para
identificar
un
flujo
de
datagramas
.


‚Ä¢
Longitud
de
la
carga
√∫til
.
Este
valor
de
16
bits
se
trata
como
un
entero
sin
signo
que
pro-


porciona
el
n√∫mero
de
bytes
del
datagrama
IPv6
incluidos
a
continuaci√≥n
de
la
cabecera


del
datagrama
,
que
es
de
40
bytes
y
tiene
longitud
fija
.


‚Ä¢
Siguiente
cabecera
.
Este
campo
identifica
el
protocolo
al
que
se
entregar√°
el
contenido


(
el
campo
de
datos
)
de
este
datagrama
(
por
ejemplo
,
a
TCP
o
UDP
)
.
El
campo
utiliza
los


mismos
valores
que
el
campo
de
protocolo
de
la
cabecera
de
IPv4
.


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
347


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
347‚Ä¢
L√≠mite
de
saltos
.
Cada
router
que
reenv√≠a
un
datagrama
decrementa
el
contenido
de
este


campo
en
una
unidad
.
Si
el
l√≠mite
de
saltos
alcanza
el
valor
cero
,
el
datagrama
se
des-


carta
.


‚Ä¢
Direcciones
de
origen
y
de
destino
.
Los
distintos
formatos
de
la
direcci√≥n
de
128
bits
de


IPv6
se
describen
en
el
documento
RFC
4291
.


‚Ä¢
Datos
.
√âsta
es
la
parte
de
la
carga
√∫til
del
datagrama
de
IPv6
.
Cuando
el
datagrama
lle-


gue
a
su
destino
,
la
carga
√∫til
se
extraer√°
del
datagrama
IP
y
se
pasar√°
al
protocolo
espe-


cificado
en
el
campo
Siguiente
cabecera
.


Hasta
aqu√≠
hemos
identificado
el
prop√≥sito
de
los
campos
incluidos
en
los
datagramas


de
IPv6
.
Comparando
el
formato
del
datagrama
de
IPv6
de
la
Figura
4.24
con
el
formato
del


datagrama
de
IPv4
que
hemos
visto
en
la
Figura
4.13
,
podemos
observar
que
varios
campos


del
datagrama
de
IPv4
ya
no
aparecen
en
IPv6
:


‚Ä¢
Fragmentaci√≥n
/
Reensamblado
.
IPv6
no
permite
ni
la
fragmentaci√≥n
ni
el
reensamblado


en
routers
intermedios
;
estas
operaciones
s√≥lo
pueden
ser
realizadas
por
el
origen
y
el


destino
.
Si
un
router
recibe
un
datagrama
IPv6
y
es
demasiado
largo
para
ser
reenviado


por
el
enlace
de
salida
,
el
router
simplemente
lo
descarta
y
env√≠a
de
vuelta
al
emisor
un


mensaje
de
error
ICMP
‚Äú
Paquete
demasiado
grande
‚Äù
(
v√©ase
m√°s
adelante
)
.
El
emisor


puede
entonces
reenviar
los
datos
utilizando
un
tama√±o
de
datagrama
IP
m√°s
peque√±o
.


La
fragmentaci√≥n
y
el
reensamblado
son
operaciones
que
consumen
tiempo
,
por
lo
que


eliminando
esta
funcionalidad
de
los
routers
e
incluy√©ndola
directamente
en
los
sistemas


terminales
se
acelera
considerablemente
el
reenv√≠o
IP
dentro
de
la
red
.


‚Ä¢
Suma
de
comprobaci√≥n
de
cabecera
.
Puesto
que
los
protocolos
de
la
capa
de
transporte


(
por
ejemplo
,
TCP
y
UDP
)
y
de
la
capa
de
enlace
de
datos
(
por
ejemplo
,
Ethernet
)
en
las


capas
de
Internet
realizan
sumas
de
comprobaci√≥n
,
los
dise√±adores
de
IP
probablemente


pensaron
que
esta
funcionalidad
ya
era
suficientemente
redundante
en
la
capa
de
red
y


pod√≠a
eliminarse
.
Una
vez
m√°s
,
el
procesamiento
r√°pido
de
los
paquetes
IP
era
la
preocu-


paci√≥n
principal
.
Recuerde
que
en
la
Secci√≥n
4.4.1
hemos
visto
que
dado
que
la
cabecera


de
IPv4
contiene
un
campo
TTL
(
similar
al
campo
l√≠mite
de
saltos
de
IPv6
)
,
la
suma
de


comprobaci√≥n
de
la
cabecera
de
IPv4
necesitaba
ser
recalculada
en
cada
router
.
Al
igual


que
la
fragmentaci√≥n
y
el
reensamblado
,
√©sta
tambi√©n
era
una
operaci√≥n
muy
costosa
en


IPv4
.


‚Ä¢
Opciones
.
La
cabecera
IP
est√°ndar
ya
no
incluye
un
campo
de
opciones
.
Sin
embargo
,


las
opciones
no
han
desaparecido
.
En
su
lugar
,
el
campo
de
opciones
es
una
de
las
po-


sibles
siguientes
cabeceras
apuntadas
desde
dentro
de
la
cabecera
IPv6
.
Es
decir
,
al


igual
que
las
cabeceras
de
los
protocolos
TCP
o
UDP
pueden
ser
la
siguiente
cabecera


dentro
de
un
paquete
IP
,
tambi√©n
puede
serlo
un
campo
de
opciones
.
La
eliminaci√≥n
del


campo
de
opciones
da
como
resultado
una
cabecera
IP
de
40
bytes
de
longitud
fija
.


Recuerde
que
en
la
Secci√≥n
4.4.3
hemos
visto
que
los
nodos
IP
utilizan
el
protocolo
ICMP


para
informar
de
condiciones
de
error
y
proporcionar
informaci√≥n
limitada
(
por
ejemplo
,
la


respuesta
de
eco
de
un
mensaje
ping
)
a
un
sistema
terminal
.
En
el
documento
RFC
4443
se


ha
definido
una
nueva
versi√≥n
de
ICMP
para
IPv6
.
Adem√°s
de
reorganizar
las
definiciones


de
tipos
y
c√≥digos
ICMP
existentes
,
ICMPv6
tambi√©n
a√±adi√≥
nuevos
tipos
y
c√≥digos
reque-


ridos
por
la
nueva
funcionalidad
de
IPv6
,
entre
los
que
se
incluyen
el
tipo
‚Äú
Paquete
dema-


siado
grande
‚Äù
y
el
c√≥digo
de
error
‚Äú
Opciones
IPv6
no
reconocidas
‚Äù
.
Adem√°s
,
ICMPv6


348
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
348incluye
la
funcionalidad
del
Protocolo
de
gesti√≥n
de
grupos
de
Internet
(
IGMP
,
Internet


Group
Management
Protocol
)
que
estudiaremos
en
la
Secci√≥n
4.7
.
IGMP
,
que
se
emplea


para
gestionar
el
modo
en
que
un
host
se
une
a
un
grupo
de
multidifusi√≥n
y
lo
abandona
,


anteriormente
era
un
protocolo
separado
de
ICMP
en
IPv4
.


Transici√≥n
de
IPv4
a
IPv6


Ahora
que
hemos
visto
los
detalles
t√©cnicos
de
IPv6
,
vamos
a
considerar
una
cuesti√≥n
pr√°c-


tica
:
¬ø
c√≥mo
va
a
hacer
Internet
,
que
est√°
basada
en
IPv4
,
la
transici√≥n
a
IPv6
?
El
problema


est√°
en
que
mientras
que
los
nuevos
sistemas
para
IPv6
pueden
ser
compatibles
en
sentido


descendente
,
es
decir
,
pueden
enviar
,
enrutar
y
recibir
datagramas
IPv4
,
los
sistemas
para


IPv4
ya
implantados
no
son
capaces
de
manejar
datagramas
de
IPv6
.
Existen
varias
posibles


soluciones
.


Una
opci√≥n
ser√≠a
declarar
un
d√≠a
D
(
una
fecha
y
hora
en
la
que
todas
las
m√°quinas


conectadas
a
Internet
se
apagaran
y
actualizaran
de
IPv4
a
IPv6
)
.
La
√∫ltima
transici√≥n


importante
de
una
tecnolog√≠a
a
otra
(
de
NCP
a
TCP
como
servicio
de
transporte
fiable
)
se


hizo
hace
casi
25
a√±os
.
Incluso
entonces
[
RFC
801
]
,
cuando
Internet
era
peque√±a
y
todav√≠a


era
administrada
por
un
n√∫mero
peque√±o
de
‚Äú
magos
‚Äù
,
se
dieron
cuenta
de
que
establecer
un


d√≠a
D
no
era
posible
,
por
lo
que
un
d√≠a
D
que
implique
a
cientos
de
millones
de
m√°quinas
y


a
millones
de
administradores
y
usuarios
de
red
es
a√∫n
m√°s
impensable
hoy
d√≠a
.
El
docu-


mento
RFC
4213
describe
dos
m√©todos
(
que
pueden
utilizarse
juntos
o
por
separado
)
para


integrar
de
forma
gradual
los
hosts
y
routers
IPv6
en
el
mundo
de
IPv4
(
por
supuesto
,
con
el


objetivo
a
largo
plazo
de
que
todos
los
nodos
IPv4
hagan
la
transici√≥n
a
IPv6
)
.


Probablemente
,
la
forma
m√°s
directa
de
introducir
nodos
IPv6
es
mediante
el
m√©todo


de
pila
dual
,
en
el
que
los
nodos
IPv6
tambi√©n
disponen
de
una
implementaci√≥n
IPv4
com-


pleta
.
Un
nodo
as√≠
,
conocido
como
nodo
IPv6
/
IPv4
en
el
RFC
4213
,
tiene
la
capacidad
de


enviar
y
recibir
tanto
datagramas
IPv4
como
IPv6
.
Al
interoperar
con
un
nodo
IPv4
,
un
nodo


IPv6
/
IPv4
puede
utilizar
datagramas
IPv4
;
y
al
interoperar
con
un
nodo
IPv6
,
puede
hablar


en
IPv6
.
Los
nodos
IPv6
/
IPv4
tienen
que
tener
direcciones
IPv6
e
IPv4
.
Adem√°s
,
tienen
que


ser
capaces
de
determinar
si
otro
nodo
es
un
nodo
IPv6
o
s√≥lo
IPv4
.
Este
problema
puede


resolverse
utilizando
DNS
(
v√©ase
el
Cap√≠tulo
2
)
,
que
puede
devolver
una
direcci√≥n
IPv6
si


el
nombre
del
nodo
que
se
est√°
resolviendo
es
IPv6
o
,
en
cualquier
otro
caso
,
devolver
una


direcci√≥n
IPv4
.
Por
supuesto
,
si
el
nodo
que
env√≠a
la
solicitud
DNS
es
un
nodo
exclusiva-


mente
IPv4
,
DNS
devuelve
una
direcci√≥n
IPv4
.


En
el
m√©todo
de
pila
dual
,
si
el
emisor
o
el
receptor
son
nodos
exclusivamente
IPv4


tiene
que
utilizarse
un
datagrama
IPv4
.
Como
resultado
,
es
posible
que
dos
nodos
IPv6
pue-


dan
terminar
envi√°ndose
entre
ellos
datagramas
IPv4
.
Esto
se
ilustra
en
la
Figura
4.25
.


Suponga
que
el
nodo
A
es
un
nodo
IPv6
y
desea
enviar
un
datagrama
IP
al
nodo
F
,
que
tam-


bi√©n
es
un
nodo
IPv6
.
Los
nodos
A
y
B
pueden
intercambiarse
un
datagrama
IPv6
.
Sin


embargo
,
el
nodo
B
tiene
que
crear
un
datagrama
IPv4
para
envi√°rselo
al
nodo
C.
Real-


mente
,
el
campo
de
datos
del
datagrama
IPv6
se
puede
copiar
en
el
campo
de
datos
del
data-


grama
IPv4
y
puede
establecer
la
correspondencia
apropiada
de
direcciones
.
Sin
embargo
,


al
hacer
la
conversi√≥n
de
IPv6
a
IPv4
,
habr√°
campos
espec√≠ficos
de
IPv6
en
el
datagrama


IPv6
(
por
ejemplo
,
el
campo
identificador
de
flujo
)
que
no
tienen
una
contrapartida
en
IPv4
.


La
informaci√≥n
de
estos
campos
se
pierde
.
Por
tanto
,
incluso
aunque
E
y
F
puedan
intercam-


biar
datagramas
IPv6
,
los
datagramas
IPv4
que
llegan
a
E
procedentes
de
D
no
contienen


todos
los
campos
que
hab√≠a
en
el
datagrama
IPv6
original
enviado
por
A.


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
349


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
349Una
alternativa
al
m√©todo
de
la
pila
dual
,
tambi√©n
incluida
en
el
RFC
4213
,
se
conoce


como
tunelizaci√≥n
.
La
tunelizaci√≥n
puede
resolver
el
problema
anteriormente
mencionado


permitiendo
,
por
ejemplo
,
que
E
reciba
los
datagramas
IPv6
originados
en
el
nodo
A.
La


idea
b√°sica
en
la
que
descansa
el
m√©todo
de
tunelizaci√≥n
es
la
siguiente
:
suponga
que
dos


nodos
IPv6
(
por
ejemplo
los
nodos
B
y
E
de
la
Figura
4.25
)
desean
interoperar
utilizando


datagramas
IPv6
pero
est√°n
conectados
entre
s√≠
a
trav√©s
de
routers
IPv4
.
Nos
referiremos
al


conjunto
de
routers
intermedios
IPv4
existentes
entre
los
dos
routers
IPv6
como
a
un
t√∫nel
,


como
se
ilustra
en
la
Figura
4.26
.
Mediante
la
tunelizaci√≥n
,
el
nodo
IPv6
del
lado
emisor
del


350
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.25
‚Ä¢
M√©todo
de
la
pila
dual
.


Figura
4.26
‚Ä¢
Tunelizaci√≥n
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
350t√∫nel
(
por
ejemplo
,
B
)
toma
el
datagrama
IPv6
completo
y
lo
incluye
en
el
campo
de
datos


(
carga
√∫til
)
de
un
datagrama
IPv4
.
Este
datagrama
IPv4
se
direcciona
entonces
hacia
el
nodo


IPv6
del
lado
receptor
del
t√∫nel
(
por
ejemplo
,
E
)
y
se
env√≠a
al
primer
nodo
del
t√∫nel
(
por


ejemplo
,
C
)
.
Los
routers
IPv4
existentes
en
el
t√∫nel
enrutan
este
datagrama
IPv4
entre
ellos


mismos
,
como
si
fuera
cualquier
otro
datagrama
,
siendo
totalmente
inconscientes
de
que
el


datagrama
IPv4
contiene
un
datagrama
IPv6
completo
.
El
nodo
IPv6
del
lado
de
recepci√≥n


del
t√∫nel
termina
recibiendo
el
datagrama
IPv4
(
¬°
es
el
destino
del
datagrama
IPv4
!
)
,
deter-


mina
que
el
datagrama
IPv4
contiene
un
datagrama
IPv6
,
extrae
el
datagrama
IPv6
y
,
a
con-


tinuaci√≥n
,
le
enruta
exactamente
igual
que
si
hubiera
recibido
el
datagrama
IPv6
desde
un


vecino
IPv6
directamente
conectado
.


Para
terminar
esta
secci√≥n
,
diremos
que
aunque
la
adopci√≥n
de
IPv6
inicialmente
fue


lenta
[
Lawton
2001
]
,
recientemente
est√°
empezando
a
tomar
impulso
.
Consulte
[
Huston


2008b
]
para
obtener
informaci√≥n
acerca
del
grado
de
implantaci√≥n
de
IPv6
en
2008
.
La


Office
of
Management
and
Budget
de
Estados
Unidos
ha
ordenado
que
los
routers
tronca-


les
de
las
redes
del
gobierno
sean
capaces
de
soportar
IPv6
a
mediados
de
2008
;
algunas


de
las
agencias
gubernamentales
han
cumplido
este
mandato
en
el
momento
de
escribir


este
libro
(
noviembre
de
2008
)
.
La
proliferaci√≥n
de
dispositivos
como
los
tel√©fonos
IP
y


otros
dispositivos
port√°tiles
proporciona
m√°s
motivos
para
una
implantaci√≥n
m√°s
extensa


de
IPv6
.
El
programa
europeo
Third
Generation
Partnership
Program
[
3GPP
2009
]
ha


especificado
IPv6
como
el
esquema
de
direccionamiento
est√°ndar
para
los
dispositivos


multimedia
m√≥viles
.
Aunque
IPv6
no
haya
sido
implantado
ampliamente
en
los
primeros


10
a√±os
de
su
corta
vida
,
evidentemente
hay
que
enjuiciar
su
√©xito
a
largo
plazo
.
El
sis-


tema
de
numeraci√≥n
telef√≥nico
actual
tard√≥
varias
d√©cadas
en
asentarse
,
pero
lleva
en
uso


casi
medio
siglo
y
sin
signos
de
desaparecer
.
De
forma
similar
,
la
adopci√≥n
de
IPv6
lle-


var√°
su
tiempo
,
pero
tambi√©n
esta
tecnolog√≠a
estar√°
despu√©s
mucho
tiempo
entre
nosotros
.


Brian
Carpenter
,
antiguo
jefe
del
Internet
Architecture
Board
[
IAB
2009
]
y
autor
de
varios


RFC
relativos
a
IPv6
,
dice
:
‚Äú
Siempre
he
visto
esto
como
un
proceso
de
15
a√±os
que


comenz√≥
en
1995
‚Äù
[
Lawton
2001
]
.
Por
lo
que
,
seg√∫n
las
fechas
de
Carpenter
,
estamos
al


final
del
proceso
inicial
de
implantaci√≥n
.


Una
lecci√≥n
importante
que
podemos
aprender
de
la
experiencia
de
IPv6
es
que
es


enormemente
complicado
cambiar
los
protocolos
de
la
capa
de
red
.
Desde
principios
de
la


d√©cada
de
1990
,
numerosos
protocolos
de
la
capa
de
red
nuevos
se
han
promulgado
como


la
siguiente
revoluci√≥n
m√°s
importante
de
Internet
,
pero
la
mayor√≠a
de
estos
procotolos
han


tenido
una
penetraci√≥n
limitada
hasta
la
fecha
.
Entre
estos
protocolos
se
incluyen
IPv6
,
los


protocolos
de
mutlidifusi√≥n
(
Secci√≥n
4.7
)
y
los
protocolos
de
reserva
de
recursos
(
Cap√≠tulo


7
)
.
De
hecho
,
la
introducci√≥n
de
nuevos
protocolos
en
la
capa
de
red
es
como
sustituir
los


cimientos
de
una
casa
(
es
dif√≠cil
de
hacer
sin
tirar
abajo
toda
la
casa
o
al
menos
reubicar


temporalmente
a
sus
habitantes
)
.
Por
otro
lado
,
Internet
ha
sido
testigo
de
la
r√°pida
implan-


taci√≥n
de
nuevos
protocolos
en
la
capa
de
aplicaci√≥n
.
Ejemplos
cl√°sicos
de
esto
son
,
por


supuesto
,
la
Web
,
la
mensajer√≠a
instant√°nea
y
la
compartici√≥n
de
archivos
P2P.
Otros
ejem-


plos
son
los
flujos
de
audio
y
de
v√≠deo
y
los
juegos
distribuidos
.
Introducir
protocolos
de
la


capa
de
aplicaci√≥n
nuevos
es
como
a√±adir
una
nueva
capa
de
pintura
a
las
paredes
de
una


casa
(
es
relativamente
f√°cil
de
hacer
y
,
si
se
elige
un
color
atractivo
,
otras
personas
del


vecindario
le
copiar√°n
)
.
En
resumen
,
en
el
futuro
podemos
esperar
ver
cambios
en
la
capa


de
red
de
Internet
,
pero
probablemente
esos
cambios
se
producir√°n
en
una
escala
temporal


mucho
m√°s
lenta
que
los
cambios
que
se
producir√°n
en
la
capa
de
aplicaci√≥n
.


4.4
‚Ä¢
PROTOCOLO
DE
INTERNET
(
IP
)
351


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3514.4.5
Una
breve
incursi√≥n
en
la
seguridad
IP


En
la
Secci√≥n
4.4.3
hemos
visto
en
detalle
IPv4
,
incluyendo
los
servicios
que
proporciona
y


c√≥mo
se
implementan
dichos
servicios
.
Es
posible
que
al
leer
la
secci√≥n
se
haya
dado
cuenta


de
que
no
hemos
mencionado
los
servicios
de
seguridad
.
De
hecho
,
IPv4
fue
dise√±ado
en


una
√©poca
(
en
la
d√©cada
de
1970
)
en
la
que
Internet
era
utilizada
principalmente
por
investi-


gadores
dedicados
a
las
redes
que
confiaban
unos
en
otros
.
Crear
una
red
de
computadoras


que
integrara
una
multitud
de
tecnolog√≠as
de
la
capa
de
enlace
ya
constitu√≠a
un
enorme
reto
,


sin
tener
adem√°s
que
preocuparse
por
la
seguridad
.


Pero
siendo
actualmente
la
seguridad
uno
de
los
problemas
m√°s
importantes
,
los
inves-


tigadores
de
Internet
han
tenido
que
dise√±ar
nuevos
protocolos
de
la
capa
de
red
que
propor-


cionen
una
amplia
variedad
de
servicios
de
seguridad
.
Uno
de
estos
protocolos
es
IPsec
,
uno


de
los
protocolos
de
la
capa
de
red
seguros
m√°s
populares
y
tambi√©n
ampliamente
imple-


mentado
en
las
redes
privadas
virtuales
(
VPN
,
Virtual
Private
Network
)
.
Aunque
IPsec
y
sus


fundamentos
criptogr√°ficos
se
cubren
con
cierto
detalle
en
el
Cap√≠tulo
8
,
proporcionamos
en


esta
secci√≥n
una
breve
introducci√≥n
de
car√°cter
general
a
los
servicios
IPsec
.


IPsec
ha
sido
dise√±ado
para
ser
compatible
hacia
abajo
con
IPv4
e
IPv6
.
En
concreto
,


para
recoger
los
beneficios
de
IPsec
,
no
necesitamos
sustituir
las
pilas
de
protocolos
de


todos
los
routers
y
hosts
de
Internet
.
Por
ejemplo
,
en
el
modo
transporte
(
uno
de
los
dos


‚Äú
modos
‚Äù
de
IPsec
)
,
si
dos
hosts
desean
comunicarse
de
forma
segura
,
basta
con
que
IPsec


est√©
disponible
en
esos
dos
hosts
.
Todos
los
dem√°s
routers
y
hosts
pueden
continuar
ejecu-


tando
IPv4
normal
y
corriente
.


Concretando
,
aqu√≠
vamos
a
centrarnos
en
el
modo
transporte
de
IPsec
.
En
este
modo
,


en
primer
lugar
,
dos
hosts
establecen
una
sesi√≥n
IPsec
entre
ellos
(
por
tanto
,
IPsec
es
un
pro-


tocolo
orientado
a
la
conexi√≥n
)
.
Una
vez
establecida
la
conexi√≥n
,
todos
los
segmentos
TCP


y
UDP
enviados
entre
los
dos
hosts
disfrutan
de
los
servicios
de
seguridad
proporcionados


por
IPsec
.
En
el
lado
emisor
,
la
capa
de
transporte
pasa
un
segmento
a
IPsec
.
A
continua-


ci√≥n
,
IPsec
cifra
el
segmento
,
a√±ade
al
segmento
campos
de
seguridad
adicionales
y
encap-


sula
la
carga
√∫til
resultante
en
un
datagrama
IP
ordinario
(
realmente
es
algo
m√°s
complicado


que
esto
como
veremos
en
el
Cap√≠tulo
8
.
)
El
host
emisor
env√≠a
entonces
el
datagrama
a


Internet
,
que
los
transporta
hasta
su
host
de
destino
,
donde
IPsec
descifra
el
segmento
y
pasa


el
segmento
no
cifrado
a
la
capa
de
transporte
.


Entre
los
servicios
proporcionados
en
una
sesi√≥n
IPsec
se
incluyen
:


‚Ä¢
Negociaci√≥n
criptogr√°fica
.
Mecanismos
que
permiten
a
los
dos
hosts
que
se
est√°n
comu-


nicando
acordar
las
claves
y
algoritmos
criptogr√°ficos
.


‚Ä¢
Cifrado
de
la
carga
√∫til
de
los
datagramas
IP
.
Cuando
el
host
emisor
recibe
un
segmento


de
la
capa
de
transporte
,
IPsec
cifra
la
carga
√∫til
.
La
carga
√∫til
s√≥lo
puede
ser
descifrada


por
IPsec
en
el
host
receptor
.


‚Ä¢
Integridad
de
los
datos
.
IPsec
permite
al
host
receptor
verificar
que
los
campos
de
cabe-


cera
del
datagrama
y
la
carga
√∫til
cifrada
no
han
sido
modificados
cuando
el
datagrama


estaba
en
la
ruta
entre
el
origen
y
el
destino
.


‚Ä¢
Autenticaci√≥n
del
origen
.
Cuando
un
host
recibe
un
datagrama
IPsec
de
un
origen
de


confianza
(
con
una
clave
segura
,
v√©ase
el
Cap√≠tulo
8)
,
el
host
est√°
seguro
de
que
la
direc-


ci√≥n
IP
de
origen
del
datagrama
es
el
origen
real
del
mismo
.


Cuando
dos
hosts
han
establecido
una
sesi√≥n
IPsec
entre
s√≠
,
todos
los
segmentos
TCP
y


UDP
enviados
entre
ellos
son
cifrados
y
autenticados
.
Por
tanto
,
IPsec
proporciona
una


352
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
352cobertura
a
todo
riesgo
,
garantizando
la
seguridad
de
todas
las
comunicaciones
entre
los
dos


hosts
para
todas
las
aplicaciones
de
red
.


Una
empresa
puede
utilizar
IPsec
para
comunicarse
de
forma
segura
a
trav√©s
de
la
red


Internet
p√∫blica
no
segura
.
Con
prop√≥sitos
ilustrativos
,
veamos
ahora
un
ejemplo
sencillo
.


Sea
una
empresa
con
una
gran
cantidad
de
personal
comercial
que
viaja
,
y
cada
comercial


posee
una
computadora
port√°til
.
Suponga
que
los
comerciales
necesitan
consultar
con
fre-


cuencia
informaci√≥n
confidencial
de
la
empresa
(
por
ejemplo
,
los
precios
y
datos
de
los
pro-


ductos
)
,
que
est√°
almacenada
en
un
servidor
situado
en
la
oficina
central
de
la
empresa
.


Suponga
que
los
comerciales
tambi√©n
necesitan
enviar
documentos
confidenciales
entre


ellos
.
¬ø
C√≥mo
puede
hacerse
esto
utilizando
IPsec
?
Como
habr√°
imaginado
,
instalamos


IPsec
en
el
servidor
y
en
todas
las
computadoras
port√°tiles
de
los
comerciales
.
Con
IPsec


instalado
en
estos
hosts
,
cuando
un
comercial
necesita
comunicarse
con
el
servidor
o
con


otro
comercial
,
la
sesi√≥n
de
comunicaci√≥n
ser√°
segura
.


4.5
Algoritmos
de
enrutamiento


Hasta
aqu√≠
nos
hemos
ocupado
principalmente
de
la
funci√≥n
de
reenv√≠o
de
la
capa
de
red
.


Hemos
visto
que
cuando
un
paquete
llega
a
un
router
,
√©ste
busca
en
la
tabla
de
reenv√≠o
y


determina
la
interfaz
de
enlace
a
la
que
tiene
que
dirigir
el
paquete
.
Tambi√©n
hemos
visto


que
los
algoritmos
de
enrutamiento
,
que
operan
en
los
routers
de
red
,
intercambian
y
calcu-


lan
la
informaci√≥n
que
se
utiliza
para
configurar
estas
tablas
de
reenv√≠o
.
En
la
Figura
4.2
se


ha
mostrado
la
relaci√≥n
existente
entre
los
algoritmos
de
enrutamiento
y
las
tablas
de
reen-


v√≠o
.
Una
vez
que
hemos
estudiado
con
cierta
profundidad
la
funci√≥n
de
reenv√≠o
,
vamos
a


pasar
al
otro
tema
central
de
este
cap√≠tulo
:
la
cr√≠tica
funci√≥n
de
enrutamiento
de
la
capa
de


red
.
Tanto
si
la
capa
de
red
proporciona
un
servicio
de
datagramas
(
en
cuyo
caso
diferentes


paquetes
intercambiados
entre
una
pareja
determinada
origen-destino
pueden
tomar
distin-


tas
rutas
)
como
un
servicio
de
circuito
virtual
(
en
cuyo
caso
todos
los
paquetes
intercambia-


dos
entre
un
origen
y
un
destino
dados
seguir√°n
la
misma
ruta
)
,
la
capa
de
red
tiene
que


determinar
la
ruta
que
seguir√°n
los
paquetes
desde
los
emisores
a
los
receptores
.
Veremos


que
el
trabajo
del
enrutamiento
consiste
en
determinar
buenas
rutas
desde
los
emisores
hasta


los
receptores
a
trav√©s
de
la
red
de
routers
.


Normalmente
,
un
host
est√°
conectado
directamente
a
un
router
,
el
router
predetermi-


nado
para
el
host
(
tambi√©n
denominado
router
del
primer
salto
para
el
host
)
.
Cuando
un


host
env√≠a
un
paquete
,
√©ste
se
transfiere
a
su
router
predeterminado
.
Nos
referiremos
al
rou-


ter
predeterminado
del
host
de
origen
como
router
de
origen
y
al
router
predeterminado
del


host
de
destino
como
router
de
destino
.
El
problema
de
enrutar
un
paquete
desde
el
host
de


origen
al
host
de
destino
,
evidentemente
,
se
reduce
al
problema
de
enrutar
el
paquete
desde


el
router
de
origen
al
router
de
destino
,
que
es
el
foco
de
esta
secci√≥n
.


El
prop√≥sito
de
un
algoritmo
de
enrutamiento
es
por
tanto
muy
simple
:
dado
un
con-


junto
de
routers
,
con
enlaces
que
conectan
dichos
routers
,
un
algoritmo
de
enrutamiento


determina
una
‚Äú
buena
‚Äù
ruta
desde
el
router
de
origen
al
router
de
destino
.
Normalmente
,
una


buena
ruta
es
aquella
que
tiene
el
coste
m√≠nimo
.
Sin
embargo
,
veremos
que
,
en
la
pr√°ctica
,


los
problemas
del
mundo
real
,
como
las
pol√≠ticas
utilizadas
(
por
ejemplo
,
una
regla
que
esta-


blezca
que
‚Äú
el
router
x
,
que
pertenece
a
la
organizaci√≥n
Y
,
no
deber√≠a
reenviar
ning√∫n


paquete
cuyo
origen
sea
la
red
de
la
organizaci√≥n
Z
‚Äù
)
,
tambi√©n
entran
en
juego
para
compli-


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
353


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
353car
los
conceptualmente
simples
y
elegantes
algoritmos
cuya
teor√≠a
subyace
a
las
pr√°cticas


de
enrutamiento
utilizadas
en
las
redes
actuales
.


Para
formular
los
problemas
de
enrutamiento
se
utilizan
grafos
.
Recuerde
que
un
grafo


G
=
(
N
,
E
)
es
un
conjunto
N
de
nodos
y
una
colecci√≥n
E
de
aristas
,
donde
cada
arista
es
una


pareja
de
nodos
de
N.
En
el
contexto
del
enrutamiento
de
la
capa
de
red
,
los
nodos
del
grafo


representan
los
routers
(
los
puntos
en
los
que
se
toman
las
decisiones
acerca
del
reenv√≠o
de


los
paquetes
)
y
las
aristas
que
conectan
estos
nodos
representan
los
enlaces
f√≠sicos
entre
los


routers
.
En
la
Figura
4.27
se
muestra
la
abstracci√≥n
de
grafo
de
una
red
de
computadoras
.
Si


desea
ver
algunos
grafos
que
representan
mapas
de
redes
reales
,
consulte
[
Dodge
2007
,


Cheswick
2000
]
;
para
ver
un
estudio
de
c√≥mo
diferentes
modelos
basados
en
grafos
permi-


ten
modelar
Internet
,
consulte
[
Zegura
1997
,
Faloutsos
1999
,
Li
2004
]
.


Como
se
muestra
en
la
Figura
4.27
,
una
arista
tambi√©n
tiene
un
valor
que
representa
su


coste
.
Normalmente
,
el
coste
de
una
arista
puede
reflejar
la
longitud
f√≠sica
del
enlace
corres-


pondiente
(
por
ejemplo
,
un
enlace
transoce√°nico
tendr√≠a
un
coste
mayor
que
un
enlace


terrestre
de
corto
alcance
)
,
la
velocidad
del
enlace
o
el
coste
monetario
asociado
con
el


enlace
.
Para
nuestros
prop√≥sitos
,
simplemente
utilizaremos
el
coste
del
enlace
como
algo


que
nos
viene
dado
,
sin
preocuparnos
por
c√≥mo
se
determina
.
Para
cualquier
arista
(
x
,
y
)
de


E
,
designamos
c(x
,
y
)
como
el
coste
de
la
arista
entre
los
nodos
x
e
y.
Si
el
par
(
x
,
y
)
no
perte-


nece
a
E
,
hacemos
c(x
,
y
)
=
/H11009
.
S√≥lo
vamos
a
considerar
los
grafos
no
dirigidos
(
es
decir
,
gra-


fos
cuyas
aristas
no
tienen
una
direcci√≥n
)
,
de
modo
que
la
arista
(
x
,
y
)
es
la
misma
que
la
arista


(
y
,
x
)
y
adem√°s
c(x
,
y
)
=
c(y
,
x
)
.
Adem√°s
,
un
nodo
y
se
dice
que
es
un
vecino
del
nodo
x
si
(
x
,
y
)


pertenece
a
E.


Dado
que
las
distintas
aristas
de
la
abstracci√≥n
de
grafo
tienen
costes
asignados
,
un


objetivo
natural
de
un
algoritmo
de
enrutamiento
es
identificar
las
rutas
de
coste
m√≠nimo


entre
los
or√≠genes
y
los
destinos
.
Con
el
fin
de
definir
este
problema
de
manera
m√°s
precisa
,


recuerde
que
una
ruta
en
un
grafo
G
=
(
N
,
E
)
es
una
secuencia
de
nodos
(
x1
,
x2
,
...
,
xp
)
tal
que


cada
una
de
las
parejas
(
x1,x2
)
,
(
x2,x3),
...
,(xp-1,xp
)
son
aristas
pertenecientes
a
E.
El
coste
de


una
ruta
(
x1,x2
,
...
,
xp
)
es
simplemente
la
suma
del
coste
de
todas
las
aristas
a
lo
largo
de
la


ruta
;
es
decir
,
c(x1,x2
)
+
c(x2,x3
)
+
...
+
c(xp-1,xp
)
.
Dados
dos
nodos
cualesquiera
x
e
y
,
nor-


malmente
existen
muchas
rutas
entre
los
dos
nodos
,
teniendo
cada
una
de
ellas
un
coste
.
Una


o
m√°s
de
estas
rutas
ser√°
una
ruta
de
coste
m√≠nimo
.
Por
tanto
,
el
problema
del
coste
m√≠nimo


est√°
claro
:
hallar
una
ruta
entre
el
origen
y
el
destino
que
tenga
el
coste
m√≠nimo
.
Por
ejem-


plo
,
en
la
Figura
4.27
la
ruta
de
coste
m√≠nimo
entre
el
nodo
de
origen
u
y
el
nodo
de
destino


354
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.27
‚Ä¢
Modelo
de
grafo
de
una
red
de
computadoras
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
354w
es
(
u
,
x
,
y
,
w
)
con
un
coste
de
ruta
igual
a
3
.
Observe
que
si
todas
las
aristas
del
grafo
tie-


nen
el
mismo
coste
,
la
ruta
de
coste
m√≠nimo
es
tambi√©n
la
ruta
m√°s
corta
(
es
decir
,
la
ruta


con
el
n√∫mero
m√≠nimo
de
enlaces
entre
el
origen
y
el
destino
)
.


Como
ejercicio
,
intente
encontrar
la
ruta
de
coste
m√≠nimo
desde
el
nodo
u
al
z
en
la


Figura
4.27
y
reflexione
sobre
c√≥mo
ha
calculado
esa
ruta
.
Si
es
usted
como
la
mayor
parte


de
la
gente
,
habr√°
determinado
la
ruta
de
u
a
z
examinando
la
Figura
4.27
,
trazando
unas


pocas
rutas
de
u
a
z
,
y
llegando
de
alguna
manera
al
convencimiento
de
que
la
ruta
que
ha


elegido
es
la
de
coste
m√≠nimo
de
entre
todas
las
posibles
rutas
(
¬ø
ha
comprobado
las
17
rutas


posibles
entre
u
y
z
?
¬°
Probablemente
no
!
)
.
Este
c√°lculo
es
un
ejemplo
de
un
algoritmo
de


enrutamiento
centralizado
(
el
algoritmo
de
enrutamiento
se
ejecut√≥
en
un
lugar
,
su
cerebro
,


que
dispone
de
la
informaci√≥n
completa
de
la
red
)
.
En
t√©rminos
generales
,
una
forma
de
cla-


sificar
los
algoritmos
de
enrutamiento
es
dependiendo
de
si
son
globales
o
descentralizados
.


‚Ä¢
Un
algoritmo
de
enrutamiento
global
calcula
la
ruta
de
coste
m√≠nimo
entre
un
origen
y


un
destino
utilizando
el
conocimiento
global
y
completo
acerca
de
la
red
.
Es
decir
,
el


algoritmo
toma
como
entradas
la
conectividad
entre
todos
los
nodos
y
todos
los
costes
de


enlace
.
Esto
requiere
por
tanto
que
el
algoritmo
de
alguna
forma
obtenga
esta
informa-


ci√≥n
antes
de
realizar
realmente
el
c√°lculo
.
El
c√°lculo
en
s√≠
puede
hacerse
en
un
sitio
(
un


algoritmo
de
enrutamiento
global
centralizado
)
o
replicarse
en
varios
sitios
.
La
caracte-


r√≠stica
distintiva
aqu√≠
,
sin
embargo
,
es
que
un
algoritmo
global
dispone
de
toda
la
infor-


maci√≥n
acerca
de
la
conectividad
y
de
los
costes
de
los
enlaces
.
En
la
pr√°ctica
,
los


algoritmos
con
informaci√≥n
de
estado
global
a
menudo
se
denominan
algoritmos
de


estado
de
enlaces
(
LS
,
Link-State
)
,
ya
que
el
algoritmo
tiene
que
ser
consciente
del


coste
de
cada
enlace
de
la
red
.
Estudiaremos
los
algoritmos
LS
en
la
Secci√≥n
4.5.1
.


‚Ä¢E
n
 
u
n
 
algoritmo
de
enrutamiento
descentralizado
,
el
c√°lculo
de
la
ruta
de
coste


m√≠nimo
se
realiza
de
manera
iterativa
y
distribuida
.
Ning√∫n
nodo
tiene
toda
la
informa-


ci√≥n
acerca
del
coste
de
todos
los
enlaces
de
la
red
.
En
lugar
de
ello
,
al
principio
,
cada


nodo
s√≥lo
conoce
los
costes
de
sus
propios
enlaces
directamente
conectados
.
Despu√©s
,
a


trav√©s
de
un
proceso
iterativo
de
c√°lculo
e
intercambio
de
informaci√≥n
con
sus
nodos


vecinos
(
es
decir
,
los
nodos
que
est√°n
en
el
otro
extremo
de
los
enlaces
a
los
que
√©l


mismo
est√°
conectado
)
,
cada
nodo
calcula
gradualmente
la
ruta
de
coste
m√≠nimo
hacia


un
destino
o
conjunto
de
destinos
.
El
algoritmo
de
enrutamiento
descentralizado
que


estudiaremos
m√°s
adelante
en
la
Secci√≥n
4.5.2
se
denomina
algoritmo
de
vector
de
dis-


tancias
(
DV
,
Distance-Vector
)
,
porque
cada
nodo
mantiene
un
vector
de
estimaciones
de


los
costes
(
distancias
)
a
todos
los
dem√°s
nodos
de
la
red
.


Una
segunda
forma
general
de
clasificar
los
algoritmos
de
enrutamiento
es
seg√∫n
sean


est√°ticos
o
din√°micos
.
En
los
algoritmos
de
enrutamiento
est√°tico
,
las
rutas
cambian
muy


lentamente
con
el
tiempo
,
con
frecuencia
como
resultado
de
una
intervenci√≥n
humana
(
por


ejemplo
,
una
persona
que
edita
manualmente
la
tabla
de
reenv√≠o
de
un
router
)
.
Los


algoritmos
de
enrutamiento
din√°mico
modifican
los
caminos
de
enrutamiento
a
medida


que
la
carga
de
tr√°fico
o
la
topolog√≠a
de
la
red
cambian
.
Un
algoritmo
din√°mico
puede
ejecu-


tarse
peri√≥dicamente
o
como
respuesta
directa
a
cambios
en
la
 
topolog√≠a
o
 
en
el
coste
de
los


enlaces
.
Aunque
los
algoritmos
din√°micos
responden
mejor
a
los
cambios
de
la
red
,
tambi√©n


son
m√°s
susceptibles
a
problemas
como
los
bucles
de
enrutamiento
y
a
la
oscilaci√≥n
de
rutas
.


Una
tercera
forma
de
clasificar
los
algoritmos
de
enrutamiento
es
seg√∫n
sean
sensibles


o
no
a
la
carga
.
En
un
algoritmo
sensible
a
la
carga
,
los
costes
de
enlace
var√≠an
de
forma


din√°mica
para
reflejar
el
nivel
actual
de
congesti√≥n
en
el
enlace
subyacente
.
Si
se
asocia
un


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
355


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
355coste
alto
con
un
enlace
que
actualmente
est√©
congestionado
,
el
algoritmo
de
enrutamiento


tender√°
a
elegir
rutas
que
eviten
tal
enlace
congestionado
.
Aunque
los
primeros
algoritmos


de
enrutamiento
de
ARPAnet
eran
sensibles
a
la
carga
[
McQuillan
1980
]
,
se
encontr√≥
una


serie
de
dificultades
[
Huitema
1998
]
.
Los
algoritmos
de
enrutamiento
actuales
de
Internet


(
como
RIP
,
OSPF
y
BGP
)
no
son
sensibles
a
la
carga
,
ya
que
el
coste
de
un
enlace
no
refleja


expl√≠citamente
su
nivel
actual
(
o
reciente
)
de
congesti√≥n
.


4.5.1
Algoritmo
de
enrutamiento
de
estado
de
enlaces
(
LS
)


Recuerde
que
en
un
algoritmo
de
estado
de
enlaces
,
la
topolog√≠a
de
la
red
y
el
coste
de
todos


los
enlaces
son
conocidos
;
es
decir
,
est√°n
disponibles
como
entradas
para
el
algoritmo
LS
.


En
la
pr√°ctica
,
esto
se
consigue
haciendo
que
cada
nodo
difunda
paquetes
del
estado
de
los


enlaces
a
todos
los
dem√°s
nodos
de
la
red
,
con
cada
paquete
de
estado
de
enlace
conteniendo


las
identidades
y
los
costes
de
sus
enlaces
conectados
.
En
la
pr√°ctica
(
por
ejemplo
,
con
el


protocolo
de
enrutamiento
OSPF
de
Internet
,
que
estudiaremos
en
la
Secci√≥n
4.6.1
)
,
esto


suele
conseguirse
mediante
un
algoritmo
de
difusi√≥n
de
estado
de
enlaces
[
Perlman
1999
]
.


Veremos
los
algoritmos
de
difusi√≥n
en
la
Secci√≥n
4.7
.
El
resultado
de
difundir
la
informa-


ci√≥n
de
los
nodos
es
que
todos
los
nodos
tienen
una
visi√≥n
completa
e
id√©ntica
de
la
red
.


Cada
nodo
puede
entonces
ejecutar
el
algoritmo
LS
y
calcular
el
mismo
conjunto
de
rutas


de
coste
m√≠nimo
que
cualquier
otro
nodo
.


El
algoritmo
de
enrutamiento
de
estado
de
enlaces
que
presentamos
a
continuaci√≥n
se


conoce
como
algoritmo
de
Dijkstra
,
en
honor
a
su
inventor
.
Un
algorimo
estrechamente


relacionado
es
el
algoritmo
de
Prim
;
consulte
[
Cormen
2001
]
para
ver
una
exposici√≥n
de


car√°cter
general
sobre
los
algoritmos
de
grafos
.
El
algoritmo
de
Dijkstra
calcula
la
ruta
de


coste
m√≠nimo
desde
un
nodo
(
el
origen
,
al
que
denominaremos
u
)
hasta
todos
los
dem√°s


nodos
de
la
red
.
El
algoritmo
de
Dijkstra
es
iterativo
y
tiene
la
propiedad
de
que
despu√©s
de


la
k-√©sima
iteraci√≥n
del
algoritmo
,
se
conocen
las
rutas
de
coste
m√≠nimo
hacia
k
nodos
de


destino
y
entre
las
rutas
de
coste
m√≠nimo
a
todos
los
nodos
de
destino
,
estas
k
rutas
tendr√°n


los
k
costes
m√°s
peque√±os
.
Definimos
la
siguiente
notaci√≥n
:


‚Ä¢
D(v
):
coste
de
la
ruta
de
coste
m√≠nimo
desde
el
nodo
de
origen
al
destino
v
,
para
esta
ite-


raci√≥n
del
algoritmo
.


‚Ä¢
p(v
):
nodo
anterior
(
vecino
de
v
)
a
lo
largo
de
la
ruta
de
coste
m√≠nimo
desde
el
origen


hasta
v.


‚Ä¢
N
/
H11032
:
subconjunto
de
nodos
;
v
pertenece
a
N
/
H11032si
la
ruta
de
coste
m√≠nimo
desde
el
origen


hasta
v
se
conoce
de
forma
definitiva
.


El
algoritmo
de
enrutamiento
global
consta
de
un
paso
de
inicializaci√≥n
seguido
de
un


bucle
.
El
n√∫mero
de
veces
que
se
ejecuta
el
bucle
es
igual
al
n√∫mero
de
nodos
de
la
red
.
Al


terminar
,
el
algoritmo
habr√°
calculado
las
rutas
m√°s
cortas
desde
el
nodo
de
origen
u
hasta


cualquier
otro
nodo
de
la
red
.


Algoritmo
de
estado
de
enlaces
(
LS
)
para
el
nodo
de
origen
u


1
Inicializaci√≥n
:


2N
‚Äô
 
=
 
{
u
}


3f
o
r
 
t
o
d
o
 
n
o
d
o
 
v


4i
f
 
v
 
e
s
 
u
n
 
v
e
c
i
n
o
 
d
e
 
u


356
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3565
then
D(v
)
=
c(u
,
v
)


6
else
D(v
)
=
/H11009


7


8
Bucle


9e
n
c
o
n
t
r
a
r
 
w
 
n
o
 
p
e
r
t
e
n
e
c
i
e
n
t
e
 
a
 
N
‚Äô
 
t
a
l
 
q
u
e
 
D
(
w
)
 
s
e
a
 
u
n
 
m
√≠
n
i
m
o


10
sumar
w
a
N
‚Äô


11
actualizar
D(v
)
para
cada
vecino
v
de
w
,
que
no
pertenezca
a
N
‚Äô
:


12
D(v
)
=
min
(
D(v
)
,
D(w
)
+
c(w
,
v
)
)


13
/
*
el
nuevo
coste
a
v
es
o
bien
el
antiguo
coste
a
v
o
el
coste


14
de
la
ruta
de
coste
m√≠nimo
a
w
m√°s
el
coste
desde
w
a
v
*
/


15
until
N‚Äô=
N


Por
ejemplo
,
considere
la
red
de
la
Figura
4.27
y
calcule
las
rutas
de
coste
m√≠nimo


desde
u
a
todos
los
destinos
posibles
.
En
la
Tabla
4.3
se
muestra
una
tabla
de
resumen
de
los


c√°lculos
del
algoritmo
,
donde
cada
l√≠nea
de
la
tabla
proporciona
los
valores
de
las
variables


del
algoritmo
al
final
de
la
iteraci√≥n
.
Veamos
en
detalle
los
primeros
pasos
.


‚Ä¢E
n
 
e
l
 
p
a
s
o
 
d
e
 
i
n
i
c
i
a
l
i
z
a
c
i
√≥
n
,
 
l
a
s
 
r
u
t
a
s
 
d
e
 
c
o
s
t
e
 
m
√≠
n
i
m
o
 
a
c
t
u
a
l
m
e
n
t
e
 
c
o
n
o
c
i
d
a
s
 
d
e
s
d
e
 
u
a


sus
vecinos
conectados
directamente
,
v
,
x
y
w
,
se
inicializan
a
2
,
1
y
5
,
respectivamente
.


En
particular
,
f√≠jese
en
que
el
coste
a
w
es
igual
a
5
(
aunque
pronto
veremos
que
,
de


hecho
,
no
existe
una
ruta
de
coste
m√°s
peque√±o
)
,
ya
que
√©ste
es
el
coste
del
enlace
directo


(
un
salto
)
de
u
a
w.
Los
costes
a
y
y
z
se
hacen
igual
a
infinito
porque
no
est√°n
directa-


mente
conectados
a
u.


‚Ä¢E
n
 
l
a
 
p
r
i
m
e
r
a
 
i
t
e
r
a
c
i
√≥
n
,
 
b
u
s
c
a
m
o
s
 
e
n
t
r
e
 
a
q
u
e
l
l
o
s
 
n
o
d
o
s
 
q
u
e
 
t
o
d
a
v
√≠
a
 
n
o
 
s
e
 
h
a
n
 
a
√±
a
d
i
d
o
 
a
l


conjunto
N
/
H11032y
localizamos
el
nodo
que
tiene
el
coste
m√≠nimo
despu√©s
de
finalizar
la
ite-


raci√≥n
previa
.
Dicho
nodo
es
x
,
con
un
coste
de
1
,
y
por
tanto
x
se
a√±ade
al
conjunto
N
/
H11032
.


La
l√≠nea
12
del
algoritmo
LS
se
ejecuta
entonces
para
actualizar
D(v
)
para
todos
los


nodos
v
,
proporcionando
los
resultados
mostrados
en
la
segunda
l√≠nea
(
Paso
1
)
de
la


Tabla
4.3
.
El
coste
de
la
ruta
a
v
no
var√≠a
.
Se
determina
que
el
coste
de
la
ruta
a
w
(
que


era
5
al
final
de
la
inicializaci√≥n
)
a
trav√©s
del
nodo
x
tiene
un
coste
de
4
.
As√≠
,
se
selec-


ciona
esta
ruta
de
coste
m√≠nimo
y
el
predecesor
de
w
a
lo
largo
de
la
ruta
m√°s
corta
desde


u
se
establece
en
x.
De
forma
similar
,
se
calcula
el
coste
a
y
(
a
trav√©s
de
x
)
y
se
obtiene


que
es
2
,
y
la
tabla
se
actualiza
de
acuerdo
con
ello
.


‚Ä¢E
n
 
l
a
 
s
e
g
u
n
d
a
 
i
t
e
r
a
c
i
√≥
n
,
 
s
e
 
d
e
t
e
r
m
i
n
a
 
q
u
e
 
l
o
s
 
n
o
d
o
s
 
v
e
y
tienen
las
rutas
de
coste
m√≠nimo


(
2
)
,
y
deshacemos
el
empate
arbitrariamente
,
a√±adiendo
y
al
conjunto
N
/
H11032
,
de
modo
que


ahora
N
/
H11032contiene
a
u
,
x
e
y.
E
l
 
c
o
s
t
e
 
d
e
 
l
o
s
 
r
e
s
t
a
n
t
e
s
 
n
o
d
o
s
 
q
u
e
 
t
o
d
a
v
√≠
a
 
n
o
 
p
e
r
t
e
n
e
c
e
n
 
a


N
/
H11032
,
es
decir
,
los
nodos
v
,
w
y
z
,
s
e
 
a
c
t
u
a
l
i
z
a
 
e
n
 
l
a
 
l
√≠
n
e
a
 
1
2
 
d
e
l
 
a
l
g
o
r
i
t
m
o
 
L
S
,
 
d
a
n
d
o
 
l
o
s


resultados
mostrados
en
la
tercera
fila
de
la
Tabla
4.3
.


‚Ä¢Y
a
s
√≠
 
s
u
c
e
s
i
v
a
m
e
n
t
e
.
 
.
 
.
 
.


Cuando
el
algoritmo
LS
termina
,
tenemos
para
cada
nodo
su
predecesor
a
lo
largo
de
la


ruta
de
coste
m√≠nimo
desde
el
nodo
de
origen
.
Para
cada
predecesor
,
tambi√©n
tenemos
su


predecesor
,
y
as√≠
de
este
modo
podemos
construir
la
ruta
completa
desde
el
origen
a
todos


los
destinos
.
La
tabla
de
reenv√≠o
de
un
nodo
,
por
ejemplo
,
del
nodo
u
,
puede
entonces


reconstruirse
a
partir
de
esta
informaci√≥n
almacenando
,
para
cada
destino
,
el
nodo
del


siguiente
salto
en
la
ruta
de
coste
m√≠nimo
desde
u
al
destino
.
La
Figura
4.28
muestra
las


rutas
de
coste
m√≠nimo
resultantes
y
la
tabla
de
reenv√≠o
de
u
para
la
red
de
la
Figura
4.27
.


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
357


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
357paso
N
‚Äô
D(v),p(v
)
D(w),p(w
)
D(x),p(x
)
D(y),p(y
)
D(z),p(z
)


0u
2,u
5,u
1,u
‚àû‚àû


1
ux
2,u
4,x
2,x
‚àû


2
uxy
2,u
3,y
4,y


3
uxyv
3,y
4,y


4
uxyvw
4,y


5
uxyvwz


Tabla
4.3
‚Ä¢
Ejecuci√≥n
del
algoritmo
de
estado
de
enlaces


para
la
red
de
la
Figura
 
4.27
.


¬ø
Cu√°l
es
la
complejidad
de
c√°lculo
de
este
algoritmo
?
Es
decir
,
dados
n
nodos
(
sin
con-


tar
el
origen
)
¬ø
en
el
caso
peor
,
cu√°ntos
c√°lculos
hay
que
realizar
para
determinar
las
rutas
de


coste
m√≠nimo
desde
el
origen
a
todos
los
destinos
?
En
la
primera
iteraci√≥n
,
tenemos
que
bus-


car
a
trav√©s
de
los
n
nodos
para
determinar
el
nodo
w
que
no
pertenece
a
N
/
H11032y
que
tiene
el


coste
m√≠nimo
.
En
la
segunda
iteraci√≥n
,
tenemos
que
comprobar
n
‚Äì
1
nodos
para
determinar


el
coste
m√≠nimo
;
en
la
tercera
iteraci√≥n
,
hay
que
comprobar
n
‚Äì
2
nodos
,
y
as√≠
sucesiva-


mente
.
En
general
,
el
n√∫mero
total
de
nodos
a
trav√©s
de
los
que
tenemos
que
buscar
teniendo


en
cuenta
todas
las
iteraciones
es
igual
a
n(n
+
1)/2
y
,
por
tanto
,
decimos
que
la
implementa-


ci√≥n
anterior
del
algoritmo
LS
tiene
,
en
el
caso
peor
,
una
complejidad
de
orden
n
al
cua-


drado
:
O(n2
)
.
(
Una
implementaci√≥n
m√°s
sofisticada
de
este
algoritmo
,
que
utiliza
una


estructura
de
datos
conocida
como
mont√≥n
(
heap
)
,
puede
calcular
el
m√≠nimo
en
la
l√≠nea
9
en


tiempo
logar√≠tmico
en
lugar
de
lineal
,
reduciendo
as√≠
la
complejidad
.
)


Antes
de
terminar
nuestro
estudio
del
algoritmo
LS
,
consideremos
una
patolog√≠a
que


puede
surgir
.
La
Figura
4.29
muestra
una
topolog√≠a
de
red
simple
donde
el
coste
de
cada


enlace
es
igual
a
la
carga
transportada
por
el
enlace
,
reflejando
,
por
ejemplo
,
el
retardo


experimentado
en
ese
enlace
.
En
este
ejemplo
,
los
costes
de
los
enlaces
no
son
sim√©tricos
;


es
decir
,
c(u
,
v
)
es
igual
a
c(v
,
u
)
s√≥lo
si
la
carga
transportada
en
ambas
direcciones
del
enlace


(
u
,
v
)
es
la
misma
.
En
este
ejemplo
,
el
nodo
z
origina
una
unidad
de
tr√°fico
destinada
a
w
,
el


nodo
x
tambi√©n
origina
una
unidad
de
tr√°fico
destinada
a
w
,
y
el
nodo
y
inyecta
una
cantidad


de
tr√°fico
igual
a
e
,
tambi√©n
destinado
a
w.
El
enrutamiento
inicial
se
muestra
en
la
Figura


4.29(a
)
con
los
costes
de
enlace
correspondientes
a
la
cantidad
de
tr√°fico
transportado
.


Cuando
se
vuelve
a
ejecutar
el
algoritmo
LS
,
el
nodo
y
determina
(
bas√°ndose
en
los


costes
de
enlace
mostrados
en
la
Figura
4.29(a
)
)
que
la
ruta
en
sentido
horario
a
w
tiene
un


358
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.28
‚Ä¢
Rutas
de
coste
m√≠nimo
y
tabla
de
reenv√≠o
para
el
nodo
u.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
358coste
de
1
,
mientras
que
la
ruta
en
sentido
antihorario
a
w
(
que
era
la
que
hab√≠a
estado
utili-


zando
)
tiene
un
coste
de
1
+
e.
Por
tanto
,
la
ruta
de
coste
m√≠nimo
de
y
a
w
ahora
va
en
sen-


tido
horario
.
De
forma
similar
,
x
determina
que
ahora
su
nueva
ruta
de
coste
m√≠nimo
a
w
va


en
sentido
horario
,
dando
como
resultado
los
costes
mostrados
en
la
Figura
4.29(b
)
.
Cuando


el
algoritmo
LS
se
ejecuta
otra
vez
,
los
nodos
x
,
y
y
z
detectan
una
ruta
de
coste
cero
a
w
en


el
sentido
antihorario
y
todos
ellos
env√≠an
su
tr√°fico
a
las
rutas
en
sentido
antihorario
.
La


siguiente
vez
que
se
ejecuta
el
algoritmo
LS
,
x
,
y
y
z
enrutan
su
tr√°fico
a
las
rutas
en
sentido


horario
.


¬ø
Qu√©
podemos
hacer
para
evitar
tales
oscilaciones
(
que
pueden
producirse
en
cualquier


algoritmo
que
utilice
una
m√©trica
de
enlace
basada
en
la
congesti√≥n
o
el
retardo
,
no
s√≥lo


en
un
algoritmo
LS
)
?
Una
soluci√≥n
ser√≠a
obligar
a
que
los
costes
de
enlace
no
dependie-


ran
de
la
cantidad
de
tr√°fico
transportado
(
una
soluci√≥n
inaceptable
,
ya
que
uno
de
los


objetivos
del
enrutamiento
es
evitar
los
enlaces
altamente
congestionados
;
por
ejemplo
,


los
enlaces
con
un
alto
retardo
)
.
Otra
soluci√≥n
consiste
en
garantizar
que
no
todos
los


routers
ejecuten
el
algoritmo
LS
al
mismo
tiempo
.
√âsta
parece
una
soluci√≥n
m√°s
razo-


nable
,
ya
que
podr√≠amos
esperar
que
,
aunque
los
routers
ejecuten
el
algoritmo
LS
con
la


misma
periodicidad
,
la
instancia
de
ejecuci√≥n
del
algoritmo
no
ser√≠a
la
misma
en
cada


uno
de
los
nodos
.
Es
interesante
ver
que
los
investigadores
han
comprobado
que
los
rou-


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
359


Figura
4.29
‚Ä¢
Oscilaciones
con
enrutamiento
sensible
a
la
congesti√≥n
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
359ters
de
Internet
pueden
auto-sincronizarse
entre
ellos
[
Floyd
Synchronization
1994
]
.
Es


decir
,
incluso
aunque
inicialmente
ejecuten
el
algoritmo
con
el
mismo
periodo
pero
en


distintos
instantes
de
tiempo
,
la
instancia
de
ejecuci√≥n
del
algoritmo
puede
llegar
a
sin-


cronizarse
en
los
routers
y
permanecer
sincronizada
.
Una
forma
de
evitar
tal
auto-sin-


cronizaci√≥n
es
que
cada
router
elija
aleatoriamente
el
instante
en
el
que
enviar
un


anuncio
de
enlace
.


Ahora
que
ya
hemos
estudiado
el
algoritmo
LS
,
vamos
a
abordar
otro
algoritmo
de


enrutamiento
importante
que
se
utiliza
actualmente
en
la
pr√°ctica
:
el
algoritmo
de
enruta-


miento
por
vector
de
distancias
.


4.5.2
Algoritmo
de
enrutamiento
por
vector
de
distancias
(
DV
)


Mientras
que
el
algoritmo
LS
es
un
algoritmo
que
emplea
informaci√≥n
global
,
el
algoritmo


por
vector
de
distancias
(
DV
)
es
iterativo
,
as√≠ncrono
y
distribuido
.
Es
distribuido
en
el


sentido
de
que
cada
nodo
recibe
informaci√≥n
de
uno
o
m√°s
de
sus
vecinos
directamente


conectados
,
realiza
un
c√°lculo
y
luego
distribuye
los
resultados
de
su
c√°lculo
de
vuelta
a


sus
vecinos
.
Es
iterativo
porque
este
proceso
contin√∫a
hasta
que
no
hay
disponible
m√°s


informacion
para
ser
intercambiada
entre
los
vecinos
.
(
Adem√°s
,
el
algoritmo
tambi√©n


finaliza
por
s√≠
mismo
,
es
decir
,
no
existe
ninguna
se√±al
que
indique
que
los
c√°lculos


deber√≠an
detenerse
;
simplemente
se
detienen
.
)
El
algoritmo
es
as√≠ncrono
,
en
el
sentido


de
que
no
requiere
que
todos
los
nodos
operen
sincronizados
entre
s√≠
.
Como
tendremos


oportunidad
de
ver
,
un
algoritmo
as√≠ncrono
,
iterativo
,
distribuido
y
que
finaliza
por
s√≠


mismo
es
mucho
m√°s
interesante
y
divertido
que
un
algoritmo
centralizado
.


Antes
de
presentar
el
algoritmo
de
vector
de
distancias
,
es
conveniente
que
veamos
una


relaci√≥n
importante
que
existe
entre
los
costes
de
las
rutas
de
coste
m√≠nimo
.
Sea
dx(y
)
el


coste
de
la
ruta
de
coste
m√≠nimo
desde
el
nodo
x
al
nodo
y.
Entonces
,
los
costes
m√≠nimos


est√°n
relacionados
mediante
la
conocida
ecuaci√≥n
de
Bellman-Ford
,


dx(y
)
=
m√≠nv{c(x
,
v
)
+
dv(y
)
}
,
(
4.1
)


donde
minv
se
calcula
para
todos
los
vecinos
de
x.
La
ecuaci√≥n
de
Bellman-Ford
es
bastante


intuitiva
.
De
hecho
,
despu√©s
de
viajar
de
x
a
v
,
si
tomamos
la
ruta
de
coste
m√≠nimo
de
v
a
y
,


el
coste
de
la
ruta
es
c(x
,
v
)
+
dv(y
)
.
Puesto
que
hay
que
comenzar
viajando
a
alg√∫n
vecino
v
,


el
coste
m√≠nimo
de
x
a
y
ser√°
el
m√≠nimo
de
c(x
,
v
)
+
dv(y
)
,
calculado
para
todos
los
vecinos
v.


Pero
para
aquellos
que
sean
esc√©pticos
en
cuanto
a
la
validez
de
la
ecuaci√≥n
,
vamos
a


comprobarla
para
el
nodo
de
origen
u
y
el
nodo
de
destino
z
de
la
Figura
4.27
.
El
nodo
de


origen
u
tiene
tres
vecinos
:
los
nodos
v
,
x
y
w.
Recorriendo
las
distintas
rutas
del
grafo
,
es


f√°cil
ver
que
dv(z
)
=
5
,
dx(z
)
=
3
y
dw(z
)
=
3
.
Introduciendo
estos
valores
en
la
Ecuaci√≥n
4.1
,


junto
con
los
costes
c(u
,
v
)
=
2
,
c(u
,
x
)
=
1
y
c(u
,
w
)
=
5
,
se
obtiene
du(z
)
=
m√≠n{2
+
5
,
5
+
3
,
1
+


3
}
=
4
,
que
obviamente
es
cierto
y
es
exactamente
lo
que
nos
proporciona
el
algoritmo
de


Dijskstra
para
la
misma
red
.
Esta
r√°pida
verificaci√≥n
deber√≠a
ayudarle
a
disipar
cualquier


duda
que
pueda
tener
.


La
ecuaci√≥n
de
Bellman-Ford
no
es
√∫nicamente
una
curiosidad
intelectual
;
realmente


tiene
una
importancia
pr√°ctica
significativa
.
En
concreto
,
la
soluci√≥n
de
la
ecuaci√≥n
de
Bell-


man-Ford
proporciona
las
entradas
de
la
tabla
de
reenv√≠o
del
nodo
x.
Para
ver
esto
,
sea
v
*


cualquier
nodo
vecino
que
alcanza
el
m√≠nimo
dado
por
la
Ecuaci√≥n
4.1
.
Entonces
,
si
el
nodo


x
desea
enviar
un
paquete
al
nodo
y
a
lo
largo
de
la
ruta
de
coste
m√≠nimo
,
deber√≠a
en
primer


lugar
reenviar
el
paquete
al
nodo
v
*
.
Por
tanto
,
la
tabla
de
reenv√≠o
del
nodo
x
especificar√≠a
el


360
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
360nodo
v
*
como
el
router
del
siguiente
salto
para
el
destino
final
y.
Otra
importante
contribu-


ci√≥n
pr√°ctica
de
la
ecuaci√≥n
de
Bellman-Ford
es
que
sugiere
la
forma
en
que
tendr√°
lugar
la


comunicaci√≥n
vecino
a
vecino
en
el
algoritmo
de
vector
de
distancias
.


La
idea
b√°sica
es
la
siguiente
:
cada
nodo
x
comienza
con
Dx(y
)
,
una
estimaci√≥n
del
coste


de
la
ruta
de
coste
m√≠nimo
desde
s√≠
mismo
al
nodo
y
,
para
todos
los
nodos
de
N.
Sea
Dx
=


[
Dx(y
):
y
perteneciente
a
N
]
el
vector
de
distancias
del
nodo
x
,
que
es
el
vector
de
coste
esti-


mado
desde
x
a
todos
los
dem√°s
nodos
y
pertenecientes
a
N.
Con
el
algoritmo
de
vector
de


distancias
,
cada
nodo
x
mantiene
la
siguiente
informaci√≥n
de
enrutamiento
:


‚Ä¢P
a
r
a
 
c
a
d
a
 
v
e
c
i
n
o
 
v
,
el
coste
c(x
,
v
)
desde
x
al
vecino
directamente
conectado
,
v.


‚Ä¢E
l
 
v
e
c
t
o
r
 
d
e
 
d
i
s
t
a
n
c
i
a
s
 
d
e
l
 
n
o
d
o
 
x
,
es
decir
,
Dx
=
[
Dx(y
):
y
perteneciente
a
N
]
,
que
con-


tiene
la
estimaci√≥n
que
x
hace
de
su
coste
hacia
todos
los
destinos
y
de
N.


‚Ä¢L
o
s
 
v
e
c
t
o
r
e
s
 
d
e
 
d
i
s
t
a
n
c
i
a
s
 
d
e
 
c
a
d
a
 
u
n
o
 
d
e
 
s
u
s
 
v
e
c
i
n
o
s
,
 
e
s
 
d
e
c
i
r
,
 
Dv
=
[
Dv(y
):
y
pertene-


ciente
a
N
]
para
cada
vecino
v
de
x.


En
el
algoritmo
as√≠ncrono
distribuido
,
de
vez
en
cuando
,
cada
nodo
env√≠a
una
copia
de
su


vector
de
distancias
a
cada
uno
de
sus
vecinos
.
Cuando
un
nodo
x
recibe
un
nuevo
vector
de


distancias
procedente
de
cualquiera
de
sus
vecinos
v
,
guarda
dicho
vector
de
v
y
luego
uti-


liza
la
ecuaci√≥n
de
Bellman-Ford
para
actualizar
su
propio
vector
de
distancias
como
sigue
:


Dx(y
)
 
m√≠nv{c(x
,
v
)
+
Dv(y
)
}
para
cada
nodo
y
de
N


Si
el
vector
de
distancias
del
nodo
x
ha
cambiado
como
resultado
de
este
paso
de
actualiza-


ci√≥n
,
entonces
el
nodo
x
enviar√°
su
vector
de
distancias
actualizado
a
cada
uno
de
sus
veci-


nos
,
lo
que
puede
a
su
vez
actualizar
sus
propios
vectores
distancia
.
De
forma
bastante


milagrosa
,
siempre
y
cuando
todos
los
nodos
contin√∫en
intercambiando
sus
vectores
distan-


cia
de
forma
as√≠ncrona
,
cada
coste
estimado
Dx(y
)
converge
a
dx(y
)
,
el
coste
real
de
la
ruta


de
coste
m√≠nimo
del
nodo
x
al
nodo
y
[
Bertsekas
1991
]
.


Algoritmo
por
vector
de
distancias
(
DV
)


En
cada
nodo
x
:


1
Inicializaci√≥n
:


2f
o
r
 
t
o
d
o
s
 
l
o
s
 
d
e
s
t
i
n
o
s
 
y
 
p
e
r
t
e
n
e
c
i
e
n
t
e
s
 
a
 
N
:


3D
x(y
)
=
c(x
,
y
)
/
*
si
y
no
es
un
vecino
,
entonces
c(x
,
y
)
=
/H11009*/


4f
o
r
 
c
a
d
a
 
v
e
c
i
n
o
 
w


5D
w(y
)
=
?
para
todos
los
destinos
y
pertenecientes
a
N


6f
o
r
 
c
a
d
a
 
v
e
c
i
n
o
 
w


7e
n
v
i
a
r
 
v
e
c
t
o
r
 
d
e
 
d
i
s
t
a
n
c
i
a
s
 
Dx
=
[
Dx(y
):
y
perteneciente
N
]
a
w


8


9
bucle


10
wait
(
hasta
ver
una
variaci√≥n
en
el
coste
de
enlace
de
un
vecino
w


11
o
hasta
recibir
un
vector
de
distancias
de
alg√∫n
vecino
w
)


12


13
for
cada
y
perteneciente
a
N
:


14
Dx(y
)
=
minv{c(x
,
v
)
+
Dv(y
)
}


15


16
if
Dx(y
)
var√≠a
para
cualquier
destino
y


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
361


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
36117
enviar
vector
de
distancia
Dx
=
[
Dx(y
):
y
perteneciente
N
]
a


18
todos
los
vecinos


19


20
forever


En
el
algoritmo
de
vector
de
distancias
,
un
nodo
x
actualiza
la
estimaci√≥n
de
su
vector


de
distancias
si
se
produce
un
cambio
en
el
coste
de
uno
de
sus
enlaces
directamente
conec-


tados
o
si
recibe
una
actualizaci√≥n
de
un
vector
de
distancias
de
alg√∫n
vecino
.
Pero
para


actualizar
su
propia
tabla
de
reenv√≠o
para
un
determinado
destino
y
,
lo
que
realmente
nece-


sita
saber
el
nodo
x
no
es
la
distancia
de
la
ruta
m√°s
corta
a
y
,
sino
el
nodo
vecino
v*(y
)
,
que


es
el
router
del
siguiente
salto
a
lo
largo
de
la
ruta
m√°s
corta
a
y.
Como
es
l√≥gico
,
el
router


del
siguiente
salto
v*(y
)
es
el
vecino
v
que
alcanza
el
m√≠nimo
en
la
l√≠nea
14
del
algoritmo


DV
.
(
Si
existen
varios
vecinos
v
que
alcanzan
el
m√≠nimo
,
entonces
v*(y
)
puede
ser
cual-


quiera
de
esos
vecinos
.
)
Por
tanto
,
en
la
l√≠neas
13‚Äì14
,
para
cada
destino
y
,
el
nodo
x
tambi√©n


determina
v*(y
)
y
actualiza
su
tabla
de
reenv√≠o
para
el
destino
y.


Recuerde
que
al
algoritmo
LS
es
un
algoritmo
global
en
el
sentido
de
que
requiere
que


cada
nodo
obtenga
en
primer
lugar
un
mapa
completo
de
la
red
antes
de
ejecutar
el
algo-


ritmo
de
Dijkstra
.
El
algoritmo
DV
es
un
algoritmo
descentralizado
y
no
utiliza
dicha
infor-


maci√≥n
global
.
De
hecho
,
la
√∫nica
informaci√≥n
que
tendr√°
un
nodo
es
el
coste
de
los
enlaces


a
los
vecinos
a
los
que
est√°
directamente
conectado
y
la
que
recibe
de
esos
vecinos
.
Cada


nodo
espera
una
actualizaci√≥n
de
cualquier
vecino
(
l√≠neas
10‚Äì11
)
,
calcula
su
nuevo
vector


de
distancias
cuando
recibe
una
actualizaci√≥n
(
l√≠nea
14
)
y
distribuye
su
nuevo
vector
de
dis-


tancias
a
sus
vecinos
(
l√≠neas
16‚Äì18
)
.
En
la
pr√°ctica
,
los
algoritmos
del
tipo
vector
de
distan-


cias
se
utilizan
en
muchos
protocolos
de
enrutamiento
,
entre
los
que
se
incluyen
RIP
y
BGP
,


ISO
IDRP
,
Novell
IPX
y
el
ARPAnet
original
.


La
Figura
4.30
ilustra
el
funcionamiento
del
algoritmo
DV
para
el
caso
de
la
red
simple


de
tres
nodos
mostrada
en
la
parte
superior
de
la
figura
.
El
funcionamiento
del
algoritmo
se


ilustra
para
el
caso
s√≠ncrono
,
donde
todos
los
nodos
reciben
simult√°neamente
vectores
dis-


tancia
de
sus
vecinos
,
calculan
sus
nuevos
vectores
distancia
e
informan
a
sus
vecinos
si
sus


vectores
de
distancias
han
cambiado
.
Despu√©s
de
estudiar
este
ejemplo
,
puede
comprobar


usted
mismo
que
el
algoritmo
tambi√©n
funciona
correctamente
en
el
modo
as√≠ncrono
,
es


decir
,
efectu√°ndose
c√°lculos
en
los
nodos
y
gener√°ndose
y
recibi√©ndose
actualizaciones
en


cualquier
instante
.


La
columna
m√°s
a
la
izquierda
de
la
figura
muestra
tres
tablas
de
enrutamiento
inicia-


les
para
cada
uno
de
los
tres
nodos
.
Por
ejemplo
,
la
tabla
de
la
esquina
superior
izquierda


corresponde
a
la
tabla
de
enrutamiento
inicial
del
nodo
x.
Dentro
de
una
tabla
de
enruta-


miento
concreta
,
cada
fila
es
un
vector
de
distancias
(
espec√≠ficamente
,
la
tabla
de
enruta-


miento
de
cada
nodo
incluye
su
propio
vector
de
distancias
y
el
de
cada
uno
de
sus
vecinos
)
.


Por
tanto
,
la
primera
fila
de
la
tabla
de
enrutamiento
inicial
del
nodo
x
es
Dx
=
[
Dx(x
)
,
Dx(y
)
,


Dx(z
)
]
=
[
0
,
2
,
7
]
.
La
segunda
y
tercera
filas
de
esta
tabla
son
los
vectores
distancia
recibidos


m√°s
recientemente
de
los
nodos
y
y
z
,
respectivamente
.
Puesto
que
durante
la
inicializaci√≥n


el
nodo
x
no
ha
recibido
nada
a√∫n
del
nodo
y
ni
del
z
,
las
entradas
de
la
segunda
y
de
la
ter-


cera
filas
se
inicializan
con
infinito
.


Despu√©s
de
la
inicializaci√≥n
,
cada
nodo
env√≠a
su
vector
de
distancias
a
cada
uno
de
sus


dos
vecinos
.
Esto
se
indica
en
la
Figura
4.30
mediante
las
flechas
que
salen
de
la
primera


columna
de
las
tablas
y
van
hasta
la
segunda
columna
.
Por
ejemplo
,
el
nodo
x
env√≠a
su
vec-


tor
de
distancias
Dx
=
[
0
,
2
,
7
]
a
los
nodos
y
y
z.
Despu√©s
de
recibir
las
actualizaciones
,
cada


nodo
recalcula
su
propio
vector
de
distancias
.
Por
ejemplo
,
el
nodo
x
calcula


362
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
362Dx(x
)
=
0


Dx(y
)
=
m√≠n{c(x
,
y
)
+
Dy(y
)
,
c(x
,
z
)
+
Dz(y
)
}
=
m√≠n{2
+
0
,
7
+
1
}
=
2


Dx(z
)
=
m√≠n{c(x
,
y
)
+
Dy(z
)
,
c(x
,
z
)
+
Dz(z
)
}
=
m√≠n{2
+
1
,
7
+
0
}
=
3


Por
tanto
,
la
segunda
columna
muestra
,
para
cada
nodo
,
el
nuevo
vector
de
distancias
del


nodo
junto
con
los
vectores
distancia
que
acaba
de
recibir
de
sus
vecinos
.
Observe
,
por


ejemplo
,
que
la
estimaci√≥n
del
nodo
x
para
el
coste
m√≠nimo
al
nodo
z
,
Dx(z
)
,
ha
cambiado
de


7
a
3
.
F√≠jese
tambi√©n
en
que
para
el
nodo
x
,
el
nodo
vecino
y
alcanza
el
m√≠nimo
en
la
l√≠nea


14
del
algoritmo
de
vector
de
distancias
;
luego
en
esa
etapa
del
algoritmo
tenemos
que
,
en


el
nodo
x
,
v*(y
)
=
y
y
v*(z
)
=
y.


Una
vez
que
los
nodos
recalculan
sus
vectores
distancia
,
env√≠an
de
nuevo
los
valores


actualizados
a
sus
vecinos
(
si
se
ha
producido
un
cambio
)
.
Esto
se
indica
en
la
Figura
4.30


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
363


Figura
4.30
‚Ä¢
Algoritmo
de
vector
de
distancias
(
DV
)
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
363mediante
las
flechas
que
van
desde
la
segunda
columna
a
la
tercera
columna
de
las
tablas
.


Observe
que
√∫nicamente
los
nodos
x
y
z
env√≠an
actualizaciones
:
el
vector
de
distancias
del


nodo
y
no
ha
cambiado
,
por
lo
que
no
env√≠a
ninguna
actualizaci√≥n
.
Despu√©s
de
recibir
las


actualizaciones
,
los
nodos
recalculan
sus
vectores
distancia
y
actualizan
sus
tablas
de
enru-


tamiento
,
lo
que
se
muestra
en
la
tercera
columna
.


El
proceso
de
recibir
vectores
distancia
actualizados
de
los
vecinos
,
recalcular
las
entra-


das
de
la
tabla
de
enrutamiento
e
informar
a
los
vecinos
de
los
costes
modificados
de
la
ruta


de
coste
m√≠nimo
hacia
un
destino
contin√∫a
hasta
que
ya
no
se
env√≠an
mensajes
de
actualiza-


ci√≥n
.
En
esta
situaci√≥n
,
puesto
que
no
se
env√≠an
mensajes
de
actualizaci√≥n
,
no
se
realizar√°n


m√°s
c√°lculos
de
la
tabla
de
enrutamiento
y
el
algoritmo
entrar√°
en
un
estado
de
reposo
;
es


decir
,
todos
los
nodos
se
encontrar√°n
a
la
espera
indicada
por
las
l√≠neas
10‚Äì11
del
algoritmo


del
vector
de
distancias
.
El
algoritmo
permanece
en
el
estado
de
reposo
hasta
que
el
coste
de


un
enlace
cambia
,
como
se
explica
a
continuaci√≥n
.


Algoritmo
de
vector
de
distancias
:
cambios
en
el
coste
de
los
enlaces


y
fallo
de
los
enlaces


Cuando
un
nodo
que
ejecuta
el
algoritmo
DV
detecta
un
cambio
en
el
coste
del
enlace
desde


s√≠
mismo
a
un
vecino
(
l√≠neas
10‚Äì11
)
,
actualiza
su
vector
de
distancias
(
l√≠neas
13‚Äì14
)
y
,
si


existe
un
cambio
en
el
coste
de
la
ruta
de
coste
m√≠nimo
,
informa
a
sus
vecinos
(
l√≠neas
16‚Äì18
)


de
su
nuevo
vector
de
distancias
.
La
Figura
4.31(a
)
ilustra
un
escenario
en
el
que
el
coste


del
enlace
de
y
a
x
cambia
de
4
a
1
.
Aqu√≠
vamos
a
centrarnos
√∫nicamente
en
las
entradas
de


la
tabla
de
distancias
de
y
y
z
al
destino
x.
El
algoritmo
de
vector
de
distancias
da
lugar
a
la


siguiente
secuencia
de
sucesos
:


‚Ä¢E
n
 
e
l
 
i
n
s
t
a
n
t
e
 
t0
,
y
detecta
el
cambio
en
el
coste
del
enlace
(
el
coste
ha
cambiado
de
4
a


1
)
,
actualiza
su
vector
de
distancias
e
informa
a
sus
vecinos
de
este
cambio
,
puesto
que


su
vector
de
distancias
ha
cambiado
.


‚Ä¢
En
el
instante
t1
,
z
recibe
la
actualizaci√≥n
de
y
y
actualiza
su
tabla
.
Calcula
el
nuevo
coste


m√≠nimo
a
x
(
ha
disminuido
de
un
coste
de
5
a
un
coste
de
2
)
y
env√≠a
su
nuevo
vector
de


distancias
a
sus
vecinos
.


‚Ä¢E
n
 
e
l
 
i
n
s
t
a
n
t
e
 
t2
,
y
recibe
la
actualizaci√≥n
de
z
y
actualiza
su
tabla
de
distancias
.
El
coste


m√≠nimo
de
y
no
cambia
y
,
por
tanto
,
y
no
env√≠a
ning√∫n
mensaje
a
z.
El
algoritmo
entra
en


el
estado
de
reposo
.


364
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.31
‚Ä¢
Cambios
en
el
coste
del
enlace
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
364As√≠
,
s√≥lo
se
han
necesitado
dos
iteraciones
para
que
el
algoritmo
DV
alcance
un
estado
de


reposo
.
Las
buenas
noticias
acerca
de
la
disminuci√≥n
del
coste
entre
x
e
y
se
han
propagado


r√°pidamente
a
trav√©s
de
la
red
.


Consideremos
ahora
lo
que
ocurre
cuando
el
coste
de
un
enlace
aumenta
.
Suponga
que


el
coste
del
enlace
entre
x
e
y
aumenta
de
4
a
60
,
como
se
muestra
en
la
Figura
4.31(b
)
.


1
.
Antes
de
que
el
coste
del
enlace
var√≠e
,
Dy(x
)
=
4
,
Dy(z
)
=
1
,
Dz(y
)
=
1
y
Dz(x
)
=
5
.
En
el


instante
t0
,
y
detecta
el
cambio
en
el
coste
del
enlace
(
el
coste
ha
variado
de
4
a
60
)
.
El


nodo
y
calcula
su
nueva
ruta
de
coste
m√≠nimo
a
x
,
obteniendo
un
coste
de
:


Dy(x
)
=
m√≠n{c(y
,
x
)
+
Dx(x
)
,
c(y
,
z
)
+
Dz(x
)
}
=
m√≠n{60
+
0
,
1
+
5
}
=
6


Por
supuesto
,
con
nuestra
visi√≥n
global
de
la
red
podemos
ver
que
este
nuevo
coste
a


trav√©s
de
z
es
err√≥neo
.
Pero
la
√∫nica
informaci√≥n
que
tiene
el
nodo
y
es
que
su
coste


directo
a
x
es
60
y
que
z
le
ha
dicho
a
y
que
z
podr√≠a
alcanzar
x
con
un
coste
de
5
.
Por


tanto
,
para
llegar
a
x
,
y
ahora
enrutar√≠a
a
trav√©s
de
z
,
confiando
plenamente
en
que
z


ser√°
capaz
de
llegar
hasta
x
con
un
coste
de
5
.
En
t1
tenemos
por
tanto
un
bucle
de


enrutamiento
(
para
llegar
a
x
,
y
enruta
a
trav√©s
de
z
,
y
z
enruta
a
trav√©s
de
y
)
.
Un
bucle


de
enrutamiento
es
como
un
agujero
negro
(
un
paquete
destinado
a
x
que
llega
a
y
o
z


en
t1
rebotar√°
entre
estos
dos
nodos
permanentemente
,
o
hasta
que
las
tablas
de
reen-


v√≠o
cambien
)
.


2
.
Dado
que
el
nodo
y
ha
calculado
un
nuevo
coste
m√≠nimo
a
x
,
informa
a
z
de
este
nuevo


vector
de
distancias
en
el
instante
t1
.


3
.
En
alg√∫n
momento
posterior
a
t1
,
z
recibe
un
nuevo
vector
de
distancias
de
y
,
que
indica


que
el
coste
m√≠nimo
de
y
a
x
es
6
.
z
sabe
que
puede
llegar
a
y
con
un
coste
de
1
y
,
por


tanto
,
calcula
un
nuevo
coste
m√≠nimo
a
x
de
Dz(x
)
=
min{50
+
0
,
1
+
6
}
=
7
.
Puesto
que


el
coste
m√≠nimo
de
z
a
x
ha
aumentado
,
entonces
informa
a
y
de
su
nuevo
vector
de
dis-


tancias
en
t2
.


4
.
De
forma
similar
,
despu√©s
de
recibir
el
nuevo
vector
de
distancias
de
z
,
y
determina


que
  
Dy(x
)
=
8
y
env√≠a
a
z
su
vector
de
distancias
.
El
nodo
z
determina
entonces
que


Dz(x
)
=
9
y
env√≠a
a
y
su
vector
de
distancias
,
y
as√≠
sucesivamente
.


¬ø
Durante
cu√°nto
tiempo
continuar√°
el
proceso
?
Puede
comprobar
por
s√≠
mismo
que
el
bucle


se
mantendr√°
durante
44
iteraciones
(
intercambios
de
mensajes
entre
y
y
z
)
,
hasta
que
z
final-


mente
calcule
que
el
coste
de
su
ruta
a
trav√©s
de
y
es
mayor
que
50
.
En
esta
situaci√≥n
,
z


(
¬°
finalmente
!
)
determinar√°
que
su
ruta
de
coste
m√≠nimo
a
x
es
a
trav√©s
de
su
conexi√≥n
directa


con
x.
El
nodo
y
entonces
enrutar√°
hacia
x
a
trav√©s
de
z.
Como
puede
ver
,
las
malas
noticias


acerca
del
aumento
del
coste
del
enlace
han
tardado
mucho
en
propagarse
.
¬ø
Qu√©
habr√≠a
ocu-


rrido
si
el
coste
del
enlace
c(y
,
x
)
hubiera
cambiado
de
4
a
10.000
y
el
coste
c(z
,
x
)
hubiera


sido
9.999
?
A
causa
de
los
escenarios
de
este
tipo
,
en
ocasiones
se
designa
a
este
problema


con
el
nombre
de
problema
de
la
cuenta
hasta
infinito
.


Algoritmo
de
vector
de
distancias
:
t√©cnica
de
la
inversa
envenenada


El
escenario
concreto
de
los
bucles
que
acabamos
de
describir
puede
evitarse
utilizando
una


t√©cnica
conocida
como
inversa
envenenada
(
poisoned
reverse
)
.
La
idea
es
simple
:
si
z


enruta
a
trav√©s
de
y
para
llegar
al
destino
x
,
entonces
z
anunciar√°
a
y
que
su
distancia
a
x
es


infinita
,
es
decir
,
z
anunciar√°
a
y
que
Dz(x
)
=
/H11009(incluso
aunque
z
sepa
que
,
en
realidad
,


Dz(x
)
=
5
)
.
z
mantendr√°
esta
peque√±a
mentira
destinada
a
y
mientras
contin√∫e
enrutando


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
365


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
365hacia
x
a
trav√©s
de
y.
Dado
que
y
cree
que
z
no
dispone
de
una
ruta
hacia
x
,
el
nodo
y
nunca


intentar√°
enrutar
hacia
x
a
trav√©s
de
z
,
siempre
que
z
contin√∫e
enrutando
hacia
x
a
trav√©s
de


y
(
y
mintiendo
acerca
de
ello
)
.


Veamos
ahora
c√≥mo
la
inversa
envenenada
resuelve
el
problema
concreto
del
bucle


encontrado
antes
en
la
Figura
4.31(b
)
.
Como
resultado
de
la
inversa
envenenada
,
la
tabla
de


distancias
de
y
indica
que
Dz(x
)
=
/H11009
.
Cuando
el
coste
del
enlace
(
x
,
y
)
cambia
de
4
a
60
en
el


instante
t0
,
y
actualiza
su
tabla
y
contin√∫a
enrutando
directamente
a
x
,
a
pesar
del
muy
alto


coste
de
60
,
e
informa
a
z
de
su
nuevo
coste
a
x
,
es
decir
,
Dy(x
)
=
60
.
Despu√©s
de
recibir
la


actualizaci√≥n
en
t1
,
z
cambia
inmediatamente
su
ruta
a
x
para
que
sea
a
trav√©s
del
enlace


directo
(
z
,
x
)
con
un
coste
de
50
.
Puesto
que
√©sta
es
la
nueva
ruta
de
coste
m√≠nimo
a
x
,
y
dado


que
la
ruta
ya
no
pasa
a
trav√©s
de
y
,
ahora
en
t2
,
z
informa
a
y
de
que
Dz(x
)
=
50
.
Despu√©s
de


recibir
la
actualizaci√≥n
de
z
,
y
actualiza
su
tabla
de
distancias
con
Dy(x
)
=
51
.
Adem√°s
,
dado


que
ahora
z
est√°
en
la
ruta
de
coste
m√≠nimo
de
y
a
x
,
el
nodo
y
envenena
la
ruta
inversa
de
z
a


x
,
informando
a
z
en
el
instante
t3
de
que
Dy(x
)
=
/H11009(aunque
y
sepa
que
,
en
realidad
,
Dy(x
)
=


51
)
.


¬ø
Resuelve
la
inversa
envenenada
el
problema
general
de
la
cuenta
hasta
infinito
?
No
.


Puede
comprobar
que
los
bucles
que
implican
a
tres
o
m√°s
nodos
(
en
lugar
de
simplemente


a
dos
nodos
vecinos
)
no
ser√°n
detectados
por
la
t√©cnica
de
la
inversa
envenenada
.


Comparaci√≥n
de
los
algoritmos
de
enrutamiento
LS
y
DV


Los
algoritmos
de
vector
de
distancias
y
de
estado
de
enlaces
utilizan
m√©todos
complemen-


tarios
para
el
c√°lculo
de
las
rutas
.
Con
el
algoritmo
de
vector
de
distancias
,
cada
nodo
s√≥lo


se
comunica
con
sus
vecinos
directamente
conectados
,
y
les
proporciona
sus
estimaciones


de
coste
m√≠nimo
desde
s√≠
mismo
a
todos
los
dem√°s
nodos
(
conocidos
)
de
la
red
.
En
el
algo-


ritmo
de
estado
de
enlaces
,
cada
nodo
se
comunica
con
todos
los
restantes
nodos
(
v√≠a
difu-


si√≥n
)
,
pero
s√≥lo
les
informa
de
los
costes
de
sus
enlaces
directamente
conectados
.
Vamos
a


terminar
este
estudio
sobre
los
algoritmos
de
estado
de
enlaces
y
de
vector
de
distancias


haciendo
una
r√°pida
comparaci√≥n
de
algunos
de
sus
atributos
.
Recuerde
que
N
es
el
con-


junto
de
nodos
(
routers
)
y
E
es
el
conjunto
de
aristas
(
enlaces
)
.


‚Ä¢
Complejidad
del
mensaje
.
Hemos
visto
que
el
algoritmo
LS
requiere
que
cada
nodo


conozca
el
coste
de
cada
enlace
de
la
red
.
Esto
requiere
el
env√≠o
de
O(|N|
|E|
)
mensajes
.


Adem√°s
,
cuando
el
coste
de
un
enlace
cambia
,
el
nuevo
coste
tiene
que
enviarse
a
todos


los
nodos
.
El
algoritmo
de
vector
de
distancias
requiere
intercambios
de
mensajes
entre


los
vecinos
directamente
conectados
en
cada
iteraci√≥n
.
Hemos
visto
que
el
tiempo
nece-


sario
para
que
el
algoritmo
converja
puede
depender
de
muchos
factores
.
Cuando
los
cos-


tes
de
los
enlaces
cambian
,
el
algoritmo
de
vector
de
distancias
propagar√°
los
resultados


del
coste
del
enlace
que
ha
cambiado
s√≥lo
si
el
nuevo
coste
de
enlace
da
lugar
a
una
ruta


de
coste
m√≠nimo
distinta
para
uno
de
los
nodos
conectados
a
dicho
enlace
.


‚Ä¢
Velocidad
de
convergencia
.
Hemos
visto
que
nuestra
implementaci√≥n
del
algoritmo
de


estado
de
enlaces
es
un
algoritmo
O(|N|
2
)
que
requiere
enviar
O(|N|
|E|
)
)
mensajes
.
El


algoritmo
de
vector
de
distancias
puede
converger
lentamente
y
pueden
aparecer
bucles


de
enrutamiento
mientras
est√°
convergiendo
.
Este
algoritmo
tambi√©n
sufre
el
problema


de
la
cuenta
hasta
infinito
.


‚Ä¢
Robustez
.
¬ø
Qu√©
puede
ocurrir
si
un
router
falla
,
funciona
mal
o
es
saboteado
?
Con
el


algoritmo
de
estado
de
enlaces
,
un
router
podr√≠a
difundir
un
coste
incorrecto
para
uno
de


sus
enlaces
conectados
(
pero
no
para
los
otros
)
.
Un
nodo
tambi√©n
podr√≠a
corromper
o
eli-


366
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3664.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
367


minar
cualquier
paquete
recibido
como
parte
de
un
mensaje
de
difusi√≥n
LS
.
Pero
,
con
el


algoritmo
LS
,
un
nodo
s√≥lo
calcula
su
propia
tabla
de
reenv√≠o
,
mientras
que
otros
nodos


realizan
c√°lculos
similares
por
s√≠
mismos
.
Esto
significa
que
los
c√°lculos
de
rutas
son


algo
independientes
en
LS
,
proporcionando
un
mayor
grado
de
robustez
.
Con
el
algo-


ritmo
de
vector
de
distancias
,
un
nodo
puede
anunciar
rutas
de
coste
m√≠nimo
incorrectas


a
cualquiera
o
a
todos
los
destinos
.
(
De
hecho
,
en
1997
,
un
router
que
funcionaba
mal
en


un
peque√±o
ISP
proporcion√≥
a
los
routers
troncales
nacionales
informaci√≥n
de
enruta-


miento
err√≥nea
.
Esto
hizo
que
otros
routers
inundaran
con
una
gran
cantidad
de
tr√°fico
al


router
que
funcionaba
mal
e
hizo
que
amplias
partes
de
Internet
estuvieran
desconecta-


das
durante
varias
horas
[
Neumann
1997
]
.
)
En
un
sentido
m√°s
general
,
observamos
que
,


en
cada
iteraci√≥n
,
los
c√°lculos
de
un
nodo
con
el
algoritmo
de
vector
de
distancias
se


pasan
a
sus
vecinos
y
luego
,
indirectamente
,
al
vecino
del
vecino
en
la
siguiente
itera-


ci√≥n
.
En
este
sentido
,
con
el
algoritmo
de
vector
de
distancias
,
un
c√°lculo
de
nodo
inco-


rrecto
puede
difundirse
a
trav√©s
de
toda
la
red
.


En
resumen
,
ning√∫n
algoritmo
es
el
ganador
evidente
;
de
hecho
,
ambos
algoritmos
se
utili-


zan
en
Internet
.


Otros
algoritmos
de
enrutamiento


Los
algoritmos
LS
y
DV
que
hemos
estudiado
no
s√≥lo
se
emplean
ampliamente
en
la
pr√°c-


tica
,
sino
que
adem√°s
son
pr√°cticamente
los
√∫nicos
algoritmos
de
enrutamiento
empleados


actualmente
en
Internet
.
No
obstante
,
los
investigadores
han
propuesto
muchos
algoritmos


de
enrutamiento
a
lo
largo
de
los
√∫ltimos
30
a√±os
,
desde
algunos
extremadamente
simples


hasta
otros
realmente
complejos
y
sofisticados
.
Una
clase
bastante
amplia
de
algoritmos
de


enrutamiento
est√°
basada
en
interpretar
el
tr√°fico
de
paquetes
como
una
serie
de
flujos
entre


los
or√≠genes
y
los
destinos
de
una
red
.
Con
este
m√©todo
,
el
problema
del
enrutamiento
puede


formularse
matem√°ticamente
como
un
problema
de
optimizaci√≥n
con
restricciones
,
cono-


cido
como
problema
de
flujo
en
una
red
[
Bertsekas
1991
]
.
Hay
otro
conjunto
m√°s
de
algo-


ritmos
de
enrutamiento
que
son
los
que
se
derivan
del
mundo
de
la
telefon√≠a
.
Estos


algoritmos
basados
en
la
conmutaci√≥n
de
circuitos
son
interesantes
para
las
redes
de


datos
de
conmutaci√≥n
de
paquetes
en
aquellos
casos
en
los
que
hay
que
reservar
recursos
en


cada
enlace
(
por
ejemplo
,
buffers
,
o
una
fracci√≥n
del
ancho
de
banda
del
enlace
)
para
cada


conexi√≥n
 
enrutada
a
trav√©s
del
enlace
.
Aunque
la
formulaci√≥n
del
problema
del
enruta-


miento
podr√≠a
parecer
bastante
diferente
de
la
formulaci√≥n
del
enrutamiento
de
coste


m√≠nimo
que
hemos
visto
en
este
cap√≠tulo
,
existen
un
gran
n√∫mero
de
similitudes
,
al
menos


en
lo
que
respecta
al
algoritmo
de
determinaci√≥n
de
la
ruta
(
algoritmo
de
enrutamiento
)
.


Consulte
[
Ash
1998
;
Ross
1995
;
Girard
1990
]
para
obtener
informaci√≥n
detallada
acerca
de


esta
√°rea
de
investigaci√≥n
.


4.5.3
Enrutamiento
jer√°rquico


En
nuestro
estudio
de
los
algoritmos
de
estado
de
enlaces
y
de
vector
de
distancias
,
hemos


visto
la
red
simplemente
como
una
colecci√≥n
de
routers
interconectados
.
Un
router
era
indis-


tinguible
de
otro
en
el
sentido
de
que
los
routers
ejecutaban
el
mismo
algoritmo
de
enruta-


miento
para
calcular
las
rutas
a
trav√©s
de
la
red
completa
.
En
la
pr√°ctica
,
este
modelo
y
la


imagen
de
un
conjunto
homog√©neo
de
routers
que
ejecutan
todos
ellos
el
mismo
algoritmo


de
enrutamiento
es
un
poco
simplista
por
al
menos
dos
razones
importantes
:


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
367‚Ä¢
Escala
.
Cuando
el
n√∫mero
de
routers
comienza
a
hacerse
grande
,
la
sobrecarga
impli-


cada
en
los
c√°lculos
,
el
almacenamiento
y
la
comunicaci√≥n
de
la
informaci√≥n
de
enruta-


miento
(
por
ejemplo
,
las
actualizaciones
o
los
cambios
en
las
rutas
de
coste
m√≠nimo
de


LS
)
se
hace
prohibitiva
.
Actualmente
,
Internet
consta
de
cientos
de
millones
de
hosts
.


Almacenar
la
informaci√≥n
de
enrutamiento
de
cada
uno
de
estos
hosts
evidentemente


requerir√≠a
enormes
cantidades
de
memoria
.
La
sobrecarga
requerida
para
difundir
las


actualizaciones
LS
entre
todos
los
routers
de
Internet
no
dejar√≠a
ancho
de
banda
disponi-


ble
para
la
transmisi√≥n
de
paquetes
de
datos
.
Seguramente
,
un
algoritmo
de
vector
de
dis-


tancias
que
iterara
entre
tal
enorme
cantidad
de
routers
nunca
llegar√≠a
a
converger
.


Evidentemente
,
es
preciso
hacer
algo
para
reducir
la
complejidad
del
c√°lculo
de
rutas
en


redes
tan
grandes
como
Internet
.


‚Ä¢
Autonom√≠a
administrativa
.
Aunque
los
investigadores
tienden
a
ignorar
problemas
tales


como
el
deseo
de
las
empresas
de
operar
sus
routers
a
su
antojo
(
por
ejemplo
,
emplear


cualquier
algoritmo
de
enrutamiento
que
elijan
)
o
de
ocultar
ciertos
aspectos
de
la
orga-


nizaci√≥n
interna
de
su
red
al
mundo
exterior
,
√©stas
son
consideraciones
extremadamente


importantes
.
Idealmente
,
una
organizaci√≥n
deber√≠a
poder
operar
y
administrar
su
red


como
deseara
,
siempre
que
sea
posible
conectar
su
red
a
otras
redes
externas
.


Estos
dos
problemas
pueden
resolverse
organizando
los
routers
en
sistemas
aut√≥nomos


(
AS
,
Autonomous
System
)
,
con
cada
AS
formado
por
un
grupo
de
routers
que
normalmente


se
encuentran
bajo
el
mismo
control
administrativo
(
por
ejemplo
,
operados
por
el
mismo


ISP
o
pertenecientes
a
la
misma
red
empresarial
)
.
Los
routers
de
un
mismo
AS
ejecutan


todos
ellos
el
mismo
algoritmo
de
enrutamiento
(
por
ejemplo
,
un
algoritmo
LS
o
DV
)
y
dis-


ponen
de
informaci√≥n
acerca
de
ellos
(
exactamente
como
en
el
caso
de
nuestro
modelo
ideal


de
la
secci√≥n
anterior
)
.
El
algoritmo
de
enrutamiento
que
se
ejecuta
dentro
de
un
sistema


aut√≥nomo
se
conoce
como
protocolo
de
enrutamiento
interno
del
sistema
aut√≥nomo
.
Por


supuesto
,
ser√°
necesario
conectar
los
sistemas
aut√≥nomos
entre
s√≠
y
,
luego
,
uno
o
m√°s
de
los


routers
de
un
sistema
aut√≥nomo
tendr√°
la
tarea
adicional
de
ser
responsables
del
reenv√≠o
de


paquetes
a
los
destinos
externos
al
sistema
aut√≥nomo
;
estos
routers
se
conocen
como


routers
gateway
(
o
de
pasarela
)
.


La
Figura
4.32
proporciona
un
ejemplo
simple
con
tres
sistemas
aut√≥nomos
:
AS1
,
AS2


y
AS3
.
En
esta
figura
,
las
l√≠neas
m√°s
gruesas
representan
las
conexiones
de
los
enlaces
direc-


tos
entre
parejas
de
routers
.
Las
l√≠neas
m√°s
finas
que
salen
de
los
routers
representan
subre-


des
que
est√°n
conectadas
directamente
a
los
routers
.
AS1
tiene
cuatro
routers
(
1a
,
1b
,
1c
y


1d
)
que
ejecutan
el
protocolo
de
enrutamiento
interno
del
sistema
aut√≥nomo
utilizado
dentro


de
AS1
.
Por
tanto
,
cada
uno
de
estos
cuatro
routers
sabe
c√≥mo
reenviar
paquetes
a
lo
largo


de
la
ruta
√≥ptima
a
cualquier
destino
dentro
de
AS1
.
De
forma
similar
,
los
sistemas
aut√≥no-


mos
AS2
y
AS3
tienen
tres
routers
.
Observe
que
el
protocolo
de
enrutamiento
interno
del


sistema
aut√≥nomo
en
los
sistemas
AS1
,
AS2
y
AS3
no
tiene
por
qu√©
ser
el
mismo
.
Observe


tambi√©n
que
los
routers
1b
,
1c
,
2a
y
3a
son
todos
ellos
routers
pasarela
.


Ahora
deber√≠a
estar
claro
c√≥mo
los
routers
de
un
sistema
aut√≥nomo
determinan
las
rutas


para
las
parejas
origen-destino
que
son
internas
al
AS
.
Pero
todav√≠a
nos
falta
una
pieza


importante
en
el
enrutamiento
terminal
a
terminal
.
¬ø
C√≥mo
sabe
un
router
de
un
AS
enrutar


un
paquete
cuyo
destino
se
encuentra
fuera
del
sistema
aut√≥nomo
?
Responder
a
esta
pre-


gunta
es
f√°cil
si
el
AS
s√≥lo
dispone
de
un
router
de
pasarela
para
conectarse
a
otro
sistema


aut√≥nomo
.
En
este
caso
,
puesto
que
el
algoritmo
de
enrutamiento
interno
del
sistema
aut√≥-


nomo
ha
determinado
la
ruta
de
coste
m√≠nimo
desde
cada
router
interno
al
router
de
pasa-


368
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
368rela
,
cada
router
interno
sabe
c√≥mo
debe
reenviar
el
paquete
.
El
router
de
pasarela
,
una
vez


que
ha
recibido
el
paquete
,
lo
reenv√≠a
al
enlace
que
conecta
con
el
exterior
del
AS
.
El
sis-


tema
aut√≥nomo
al
otro
lado
del
enlace
toma
entonces
la
responsabilidad
de
enrutar
el


paquete
a
su
destino
final
.
Por
ejemplo
,
suponga
que
el
router
2b
de
la
Figura
4.32
recibe
un


paquete
cuyo
destino
est√°
fuera
de
AS2
.
El
router
2b
reenviar√°
el
paquete
bien
al
router
2a
o


al
2c
,
tal
y
como
se
especifica
en
la
tabla
de
reenv√≠o
del
router
2b
,
que
ha
sido
configurada


por
el
protocolo
de
enrutamiento
interno
de
AS2
.
El
paquete
finalmente
llegar√°
al
router
de


pasarela
2a
,
el
cual
reenviar√°
el
paquete
a
1b
.
Una
vez
que
el
paquete
ha
abandonado
el
rou-


ter
2a
,
el
trabajo
que
AS2
ten√≠a
que
hacer
con
ese
paquete
est√°
hecho
.


Por
tanto
,
el
problema
es
f√°cil
cuando
el
sistema
aut√≥nomo
de
origen
s√≥lo
tiene
un


enlace
que
le
comunica
con
el
exterior
.
Pero
,
¬ø
qu√©
ocurre
si
el
AS
de
origen
tiene
dos
o
m√°s


enlaces
(
a
trav√©s
de
dos
o
m√°s
routers
de
pasarela
)
que
le
llevan
fuera
del
AS
?
Entonces
el


problema
de
saber
d√≥nde
reenviar
el
paquete
es
significativamente
m√°s
complicado
.
Por


ejemplo
,
considere
un
router
de
AS1
y
suponga
que
recibe
un
paquete
cuyo
destino
est√°
fuera


del
sistema
aut√≥nomo
.
Evidentemente
,
el
router
tiene
que
reenviar
el
paquete
a
uno
de
sus


dos
routers
de
pasarela
,
1b
o
1c
,
pero
¬ø
a
cu√°l
?
Para
resolver
este
problema
,
AS1
tiene
que
(
1
)


aprender
qu√©
destinos
son
alcanzables
a
trav√©s
de
AS2
y
qu√©
destinos
son
alcanzables
a
tra-


v√©s
de
AS3
y
(
2
)
propagar
esa
informaci√≥n
de
alcanzabilidad
a
todos
los
routers
de
AS1
,
de


manera
que
cada
router
pueda
configurar
su
tabla
de
reenv√≠o
para
gestionar
los
destinos


externos
al
AS
.
Estas
dos
tareas
(
obtener
la
informaci√≥n
de
alcanzabilidad
de
los
AS
vecinos


y
propagar
dicha
informaci√≥n
de
alcanzabilidad
a
todos
los
routers
internos
del
AS
)
son
rea-


lizadas
por
el
protocolo
de
enrutamiento
entre
sistemas
aut√≥nomos
.
Puesto
que
el
proto-


colo
de
enrutamiento
interno
del
sistema
aut√≥nomo
implica
la
comunicaci√≥n
entre
dos
AS
,


los
dos
AS
que
van
a
comunicarse
tienen
que
utilizar
el
mismo
protocolo
de
enrutamiento


interno
.
De
hecho
,
en
Internet
,
todos
los
sistemas
aut√≥nomos
ejecutan
el
mismo
protocolo
de


enrutamiento
interno
,
el
protocolo
BGP4
,
que
veremos
en
la
siguiente
secci√≥n
.
Como
se


muestra
en
la
Figura
4.32
,
cada
router
recibe
informaci√≥n
de
un
protocolo
de
enrutamiento


4.5
‚Ä¢
ALGORITMOS
DE
ENRUTAMIENTO
369


Figura
4.32
‚Ä¢
Ejemplo
de
sistemas
aut√≥nomos
interconectados
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
369interno
de
sistema
aut√≥nomo
y
de
un
protocolo
de
enrutamiento
entre
sistemas
aut√≥nomos
,
y


emplea
la
informaci√≥n
de
ambos
protocolos
para
configurar
su
tabla
de
reenv√≠o
.


Veamos
un
ejemplo
.
Considere
una
subred
x
(
identificada
por
su
direcci√≥n
CIDR
)
,
y


suponga
que
AS1
aprende
del
protocolo
de
enrutamiento
interno
del
AS
que
la
subred
x
es


alcanzable
desde
AS3
pero
no
desde
AS2
.
AS1
propaga
entonces
esta
informaci√≥n
a
todos


sus
routers
.
Cuando
el
router
1d
aprende
que
la
subred
x
es
alcanzable
desde
AS3
y
,
por


tanto
,
desde
el
router
de
pasarela
1c
,
determina
,
a
partir
de
la
informaci√≥n
proporcionada
por


el
protocolo
de
enrutamiento
interno
del
AS
,
la
interfaz
del
router
que
est√°
en
la
ruta
de
coste


m√≠nimo
desde
el
router
1d
hasta
el
router
de
pasarela
1c
.
Supongamos
que
se
trata
de
la


interfaz
I.
El
router
1d
puede
entonces
incluir
la
entrada
(
x
,
I
)
en
su
tabla
de
reenv√≠o
.
(
Este


ejemplo
,
y
otros
presentados
en
esta
secci√≥n
,
proporciona
s√≥lo
ideas
generales
,
pero
es


una
simplificaci√≥n
de
lo
que
realmente
ocurre
en
Internet
.
En
la
siguiente
secci√≥n
ofrece-


mos
una
descripci√≥n
m√°s
detallada
,
aunque
m√°s
compleja
,
al
abordar
el
protocolo
BGP
.
)


Siguiendo
con
el
ejemplo
anterior
,
supongamos
ahora
que
AS2
y
AS3
est√°n
conectados


a
otros
sistemas
aut√≥nomos
,
los
cuales
no
se
han
mostrado
en
el
diagrama
.
Suponga
tambi√©n


que
AS1
aprende
del
protocolo
de
enrutamiento
interno
que
la
subred
x
es
alcanzable
tanto


desde
AS2
,
a
trav√©s
del
router
de
pasarela
1b
,
como
desde
AS3
,
a
trav√©s
del
router
de
pasa-


rela
1c
.
AS1
tendr√≠a
entonces
que
propagar
esta
informaci√≥n
a
todos
sus
routers
,
incluyendo


al
router
1d
.
Para
configurar
su
tabla
de
reenv√≠o
,
el
router
1d
tendr√≠a
que
determinar
a
qu√©


router
de
pasarela
,
1b
o
1c
,
enviar√°
los
paquetes
cuyo
destino
sea
la
subred
x.
Un
m√©todo
,
que


es
el
que
se
suele
utilizar
en
la
pr√°ctica
,
consistir√≠a
 
en
utilizar
el
enrutamiento
de
la
patata


caliente
.
Con
este
tipo
de
enrutamiento
,
el
sistema
aut√≥nomo
suelta
el
paquete
(
la
patata


caliente
)
tan
r√°pido
como
sea
posible
(
de
forma
m√°s
precisa
,
de
la
forma
m√°s
barata
posible
)
.


Para
hacer
esto
,
el
router
env√≠a
el
paquete
al
router
de
pasarela
que
tiene
el
coste
m√°s
peque√±o


(
desde
el
router
de
origen
hasta
el
router
de
pasarela
)
de
entre
todos
los
routers
de
pasarela


que
cuentan
con
una
ruta
hasta
ese
destino
.
En
nuestro
ejemplo
,
el
enrutamiento
de
la
patata


caliente
,
que
se
ejecuta
en
1d
,
utilizar√≠a
la
informaci√≥n
del
protocolo
de
enrutamiento
interno


del
AS
para
determinar
los
costes
de
las
rutas
a
1b
y
1c
,
y
luego
seleccionar√≠a
la
ruta
con
el


coste
m√≠nimo
.
Una
vez
que
se
ha
elegido
la
ruta
,
el
router
1d
a√±ade
una
entrada
para
la
subred


x
en
su
tabla
de
reenv√≠o
.
La
Figura
4.33
resume
las
acciones
realizadas
en
el
router
1d
para


a√±adir
una
nueva
entrada
para
x
en
la
tabla
de
reenv√≠o
.


Cuando
un
sistema
aut√≥nomo
obtiene
informaci√≥n
acerca
de
un
destino
de
un
AS


vecino
,
puede
anunciar
esta
informaci√≥n
de
enrutamiento
a
algunos
de
sus
otros
sistemas


aut√≥nomos
vecinos
.
Por
ejemplo
,
suponga
que
AS1
aprende
de
AS2
que
la
subred
x
es
alcan-


zable
a
trav√©s
de
AS2
.
AS1
podr√≠a
entonces
comunicar
a
AS3
que
x
es
alcanzable
a
trav√©s
de


AS1
.
De
esta
forma
,
si
AS3
necesita
enrutar
un
paquete
destinado
a
x
,
AS3
reenviar√°
el


paquete
a
AS1
,
el
cual
a
su
vez
lo
reenviar√°
a
AS2
.
Como
veremos
al
estudiar
el
protocolo


370
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.33
‚Ä¢
Pasos
para
a√±adir
a
la
tabla
de
reenv√≠o
de
un
router
un
destino


externo
al
sistema
aut√≥nomo
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
370BGP
,
un
sistema
aut√≥nomo
tiene
bastante
flexibilidad
a
la
hora
de
decidir
qu√©
destinos
anun-


ciar
a
sus
sistemas
aut√≥nomos
vecinos
.
Se
trata
de
una
decisi√≥n
pol√≠tica
,
que
normalmente


depende
m√°s
de
cuestiones
econ√≥micas
que
de
cuestiones
t√©cnicas
.


Recuerde
de
la
Secci√≥n
1.5
que
Internet
est√°
formado
por
una
jerarqu√≠a
de
proveedores


ISP
interconectados
.
Luego
,
¬ø
cu√°l
es
la
relaci√≥n
entre
los
ISP
y
los
sistemas
aut√≥nomos
?


Podr√≠a
pensarse
que
los
routers
de
un
ISP
y
los
enlaces
que
los
interconectan
constituyen
un


sistema
aut√≥nomo
.
Aunque
√©ste
suele
ser
el
caso
,
muchos
ISP
dividen
su
red
en
varios
siste-


mas
aut√≥nomos
.
Por
ejemplo
,
algunos
ISP
de
nivel
1
utilizan
un
√∫nico
sistema
aut√≥nomo


para
toda
su
red
y
otros
dividen
su
red
en
decenas
de
sistemas
aut√≥nomos
interconectados
.


Resumiento
,
los
problemas
de
escala
y
autoridad
administrativa
se
resuelven
definiendo


sistemas
aut√≥nomos
.
Dentro
de
un
sistema
aut√≥nomo
,
todos
los
routers
ejecutan
el
mismo


protocolo
de
enrutamiento
interno
.
Entre
ellos
,
los
AS
ejecutan
el
mismo
protocolo
de
enru-


tamiento
entre
AS
.
El
problema
de
la
escala
se
resuelve
de
manera
que
un
router
interno
de


un
AS
s√≥lo
necesita
tener
informaci√≥n
acerca
de
los
routers
de
su
AS
.
El
problema
de
la


autoridad
administrativa
est√°
resuelto
,
ya
que
una
organizaci√≥n
puede
ejecutar
el
protocolo


de
enrutamiento
interno
de
sistema
aut√≥nomo
que
prefiera
;
sin
embargo
,
cada
pareja
de
sis-


temas
aut√≥nomos
conectados
deben
ejecutar
el
mismo
protocolo
de
enrutamiento
entre
sis-


temas
aut√≥nomos
,
con
el
fin
de
poder
intercambiar
informaci√≥n
de
alcanzabilidad
.


En
la
siguiente
secci√≥n
examinaremos
dos
protocolos
de
enrutamiento
internos
de
sis-


tema
aut√≥nomo
(
RIP
y
OSPF
)
y
el
protocolo
de
enrutamiento
entre
sistemas
aut√≥nomos


(
BGP
)
que
se
emplean
actualmente
en
Internet
.
Estos
casos
de
estudio
nos
permitir√°n
com-


pletar
adecuadamente
nuestro
an√°lisis
del
enrutamiento
jer√°rquico
.


4.6
Enrutamiento
en
Internet


Una
vez
estudiados
el
direccionamiento
en
Internet
y
el
protocolo
IP
,
vamos
a
pasar
a
los


protocolos
de
enrutamiento
de
Internet
;
su
trabajo
consiste
en
determinar
la
ruta
que
sigue


un
datagrama
entre
un
origen
y
un
destino
.
Veremos
que
los
protocolos
de
enrutamiento
de


Internet
se
basan
en
muchos
de
los
principios
que
hemos
aprendido
anteriormente
en
el
cap√≠-


tulo
.
Los
algoritmos
de
estado
de
enlaces
y
de
vector
de
distancias
estudiados
en
las
Seccio-


nes
4.5.1
y
4.5.2
,
y
el
concepto
de
sistema
aut√≥nomo
tratado
en
la
Secci√≥n
4.5.3
son


fundamentales
para
la
forma
en
que
se
lleva
a
cabo
el
enrutamiento
en
la
red
Internet
actual
.


Recuerde
de
la
Secci√≥n
4.5.3
que
un
sistema
aut√≥nomo
(
AS
)
es
una
colecci√≥n
de
rou-


ters
bajo
el
mismo
control
t√©cnico
y
administrativo
,
y
que
todos
ellos
ejecutan
el
mismo
pro-


tocolo
de
enrutamiento
para
comunicarse
entre
s√≠
.
Cada
sistema
aut√≥nomo
,
a
su
vez
,


normalmente
contiene
varias
subredes
(
entendiendo
el
t√©rmino
subred
en
el
sentido
,
muy


preciso
,
de
direccionamiento
,
tal
como
se
explica
en
la
Secci√≥n
4.4.2
)
.
 

4.6.1
Enrutamiento
interno
de
un
sistema


aut√≥nomo
de
Internet
:
RIP


Un
protocolo
de
enrutamiento
interno
de
un
AS
se
utiliza
para
determinar
c√≥mo
se
lleva
a


cabo
el
enrutamiento
dentro
de
un
sistema
aut√≥nomo
.
Los
protocolos
de
enrutamiento
inter-


nos
de
los
AS
se
conocen
tambi√©n
como
protocolos
de
pasarela
interior
.
Hist√≥ricamente
,


el
enrutamiento
dentro
de
los
sistemas
aut√≥nomos
de
Internet
se
ha
llevado
a
cabo
principal-


mente
con
dos
protocolos
de
enrutamiento
:
el
Protocolo
de
informaci√≥n
de
enrutamiento


4.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
371


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
371(RIP
,
Routing
Information
Protocol
)
y
el
protocolo
Primero
la
ruta
abierta
m√°s
corta


(
OSPF
,
Open
Shortest
Path
First
)
.
Un
protocolo
de
enrutamiento
estrechamente
relacio-


nado
con
OSPF
es
el
protocolo
IS-IS
[
RFC
1142
,
Perlman
1999
]
.
En
primer
lugar
,
vamos
a


ver
el
protocolo
RIP
y
luego
el
OSPF
.


RIP
fue
uno
de
los
primeros
protocolos
de
enrutamiento
de
Internet
internos
para
los


AS
y
todav√≠a
hoy
es
ampliamente
utilizado
.
Sus
or√≠genes
est√°n
en
la
arquitectura
XNS


(
Xerox
Network
Systems
,
Sistemas
de
red
Xerox
)
a
la
que
debe
su
nombre
.
La
extensa


implantaci√≥n
de
RIP
se
ha
debido
en
gran
parte
a
su
inclusi√≥n
en
1982
en
la
versi√≥n
BSD


(
Berkeley
Software
Distribution
)
de
UNIX
que
soportaba
TCP
/
IP
.
La
versi√≥n
1
de
RIP
est√°


definida
en
[
RFC
1058
]
,
y
la
versi√≥n
2
compatible
hacia
abajo
est√°
definida
en
[
RFC
2453
]
.


RIP
es
un
protocolo
de
vector
de
distancias
que
opera
de
una
forma
muy
parecida
al
pro-


tocolo
DV
ideal
que
hemos
examinado
en
la
Secci√≥n
4.5.2
.
La
versi√≥n
de
RIP
especificada


en
el
documento
RFC
1058
utiliza
como
m√©trica
de
coste
el
recuento
de
saltos
;
es
decir
,
cada


enlace
tiene
un
coste
de
1
.
En
el
algoritmo
de
vector
de
distancias
de
la
Secci√≥n
4.5.2
,
por


simplificar
,
los
costes
se
definieron
entre
parejas
de
routers
.
En
RIP
(
y
tambi√©n
en
OSPF
)
,


los
costes
se
definen
realmente
desde
el
router
de
origen
a
una
subred
de
destino
.
RIP
utiliza


el
t√©rmino
salto
(
hop
)
,
que
es
el
n√∫mero
de
subredes
que
se
atraviesan
al
seguir
la
ruta
m√°s


corta
desde
el
router
de
origen
hasta
la
subred
de
destino
,
incluyendo
esta
√∫ltima
.
La
Figura


4.34
ilustra
un
sistema
aut√≥nomo
con
seis
subredes
terminales
.
La
tabla
incluida
en
la
figu-


ra
indica
el
n√∫mero
de
saltos
desde
el
origen
A
a
cada
una
de
las
subredes
terminales
.


El
coste
m√°ximo
de
una
ruta
est√°
limitado
a
15
,
luego
el
uso
de
RIP
en
los
sistemas


aut√≥nomos
est√°
limitado
a
sistemas
aut√≥nomos
con
un
di√°metro
de
menos
de
15
saltos
.


Recuerde
que
en
los
protocolos
de
vector
de
distancias
,
los
routers
vecinos
intercambian


entre
s√≠
los
vectores
distancia
.
El
vector
de
distancias
para
cualquier
router
es
la
estimaci√≥n


actual
de
la
ruta
m√°s
corta
desde
dicho
router
a
las
subredes
del
AS
.
En
RIP
,
las
actualiza-


ciones
de
enrutamiento
son
intercambiadas
entre
los
vecinos
aproximadamente
cada
30


segundos
mediante
un
mensaje
de
respuesta
RIP
.
El
mensaje
de
respuesta
enviado
por
un


router
o
un
host
contiene
una
lista
de
hasta
25
subredes
de
destino
pertenecientes
al
sistema


aut√≥nomo
,
as√≠
como
la
distancia
desde
el
emisor
a
cada
una
de
esas
subredes
.
Los
mensajes


de
respuesta
se
conocen
como
anuncios
RIP
.


Veamos
un
ejemplo
simple
de
c√≥mo
funcionan
los
anuncios
RIP
.
Considere
la
parte
de


un
sistema
aut√≥nomo
mostrada
en
la
Figura
4.35
.
En
esta
figura
,
las
l√≠neas
que
conectan
los


routers
indican
subredes
.
S√≥lo
se
han
etiquetado
los
routers
(
A
,
B
,
C
y
D
)
y
las
subredes
(
w
,


x
,
y
y
z
)
.
Las
l√≠neas
de
puntos
indican
que
el
sistema
aut√≥nomo
contin√∫a
;
por
tanto
,
este
sis-


tema
aut√≥nomo
tiene
muchos
m√°s
routers
y
enlaces
que
los
mostrados
.


372
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.34
‚Ä¢
N√∫mero
de
saltos
desde
el
router
de
origen
A
a
varias
subredes
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
372Cada
router
mantiene
una
tabla
RIP
conocida
como
tabla
de
enrutamiento
.
La
tabla


de
enrutamiento
de
un
router
incluye
tanto
el
vector
de
distancias
del
router
como
la
tabla
de


reenv√≠o
del
mismo
.
La
Figura
4.36
muestra
la
tabla
de
enrutamiento
del
router
D.
Observe


que
esta
tabla
tiene
tres
columnas
.
La
primera
de
ellas
especifica
la
subred
de
destino
,
la


segunda
columna
detalla
la
identidad
del
siguiente
router
a
lo
largo
de
la
ruta
m√°s
corta
a
la


subred
de
destino
y
la
tercera
columna
especifica
el
n√∫mero
de
saltos
(
es
decir
,
el
n√∫mero
de


subredes
que
hay
que
atravesar
,
incluyendo
la
subred
de
destino
)
para
llegar
hasta
la
subred


de
destino
siguiendo
el
camino
m√°s
corto
.
En
este
ejemplo
,
la
tabla
indica
que
para
enviar


un
datagrama
desde
el
router
D
a
la
subred
de
destino
w
,
en
primer
lugar
el
datagrama
tiene


primero
que
reenviarse
al
router
vecino
A
;
la
tabla
tambi√©n
especifica
que
la
subred
de
des-


tino
w
est√°
a
dos
saltos
por
la
ruta
m√°s
corta
.
Del
mismo
modo
,
la
tabla
indica
que
la
subred


z
est√°
a
siete
saltos
,
pasando
por
el
router
B.
En
principio
,
una
tabla
de
enrutamiento
tendr√°


una
fila
para
cada
subred
que
forma
parte
del
sistema
aut√≥nomo
,
aunque
la
versi√≥n
2
de
RIP


permite
a√±adir
entradas
de
subred
utilizando
t√©cnicas
de
agregaci√≥n
de
rutas
similares
a
las


que
hemos
examinado
en
la
Secci√≥n
4.4
.
La
tabla
de
la
Figura
4.36
y
las
tablas
que
siguen


se
han
completado
parcialmente
.


Suponga
ahora
que
30
segundos
m√°s
tarde
,
el
router
D
recibe
del
router
A
el
anuncio


mostrado
en
la
Figura
4.37
.
Observe
que
este
anuncio
no
es
otra
cosa
que
la
informaci√≥n
de


la
tabla
de
enrutamiento
del
router
A.
Esta
informaci√≥n
indica
,
en
particular
,
que
la
subred
z


est√°
s√≥lo
a
cuatro
saltos
del
router
A.
El
router
D
,
una
vez
que
ha
recibido
este
anuncio
,
com-


bina
el
anuncio
(
Figura
4.37
)
con
la
tabla
de
enrutamiento
antigua
(
Figura
4.36
)
.
En
particu-


lar
,
D
ahora
sabe
que
existe
una
ruta
a
trav√©s
del
router
A
a
la
subred
z
que
es
m√°s
corta
que


la
ruta
a
trav√©s
del
router
B.
Por
tanto
,
D
actualiza
su
tabla
de
enrutamiento
para
tener
en


cuenta
la
nueva
ruta
m√°s
corta
,
como
se
muestra
en
la
Figura
4.38
.
Se
estar√°
preguntando
,
 

Subred
de
destino
Siguiente
router
N√∫mero
de
saltos
hasta
el
destino


wA
2


yB
2


zB
7


x
‚Äî
1


.
.
.
.
.
.
.
.
.
.
.
.


Figura
4.36
‚Ä¢
Tabla
de
enrutamiento
del
router
D
antes
de
recibir
un
anuncio
del


router
A.


4.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
373


Figura
4.35
‚Ä¢
Una
parte
de
un
sistema
aut√≥nomo
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
373Subred
de
destino
Siguiente
router
N√∫mero
de
saltos
hasta
el
destino


zC
4


w
‚Äî
1


x
‚Äî
1


.
.
.
.
.
.
.
.
.
.
.
.


Figura
4.37
‚Ä¢
Anuncio
del
router
A.


Subred
de
destino
Siguiente
router
N√∫mero
de
saltos
hasta
el
destino


wA
2


yB
2


zA
5


.
.
.
.
.
.
.
.
.
.
.
.


Figura
4.38
‚Ä¢
Tabla
de
enrutamiento
del
router
D
despu√©s
de
recibir
un
anuncio


del
router
A.


¬ø
c√≥mo
es
que
la
ruta
m√°s
corta
a
la
subred
z
se
ha
hecho
a√∫n
m√°s
peque√±a
?
Posiblemente
,
el


algoritmo
descentralizado
de
vector
de
distancias
se
encuentra
todav√≠a
en
el
proceso
de
con-


vergencia
(
v√©ase
la
Secci√≥n
4.5.2
)
,
o
quiz√°
se
han
a√±adido
enlaces
nuevos
y
/
o
routers
nue-


vos
al
sistema
aut√≥nomo
,
cambiando
por
tanto
las
rutas
m√°s
cortas
dentro
del
AS
.


Veamos
a
continuaci√≥n
algunos
de
los
aspectos
de
implementaci√≥n
de
RIP
.
Recuerde


que
los
routers
RIP
intercambian
anuncios
aproximadamente
cada
30
segundos
.
Si
un
router


no
tiene
noticias
de
su
vecino
al
menos
una
vez
cada
180
segundos
,
considera
que
ese
vecino


ya
no
es
alcanzable
;
es
decir
,
o
bien
ese
vecino
ha
muerto
o
el
enlace
que
le
conectaba
con


√©l
ha
fallado
.
Si
esto
ocurre
,
RIP
modifica
la
tabla
de
enrutamiento
local
y
luego
propaga


esta
informaci√≥n
enviando
anuncios
a
sus
routers
vecinos
(
a
aquellos
que
todav√≠a
son
alcan-


zables
)
.
Un
router
tambi√©n
puede
solicitar
informaci√≥n
a
sus
vecinos
,
mediante
un
mensaje


de
solicitud
RIP
,
acerca
del
coste
a
un
destino
dado
.
Los
routers
se
env√≠an
entre
s√≠
solicitu-


des
y
mensajes
de
respuesta
RIP
utilizando
UDP
en
el
n√∫mero
de
puerto
520
.
El
segmento


UDP
es
transportado
entre
los
routers
en
un
datagrama
IP
est√°ndar
.
El
hecho
de
que
RIP
uti-


lice
un
protocolo
de
la
capa
de
transporte
(
UDP
)
por
encima
de
un
protocolo
de
la
capa
de


red
(
IP
)
para
implementar
la
funcionalidad
de
la
capa
de
red
(
un
algoritmo
de
enrutamiento
)


puede
parecer
bastante
enrevesado
(
¬°
y
lo
es
!
)
.
Examinar
con
algo
m√°s
de
profundidad
c√≥mo


se
implementa
RIP
ayudar√°
a
clarificar
esta
cuesti√≥n
.


La
Figura
4.39
esboza
c√≥mo
se
implementa
RIP
normalmente
en
un
sistema
UNIX
;
por


ejemplo
,
en
una
estaci√≥n
de
trabajo
UNIX
que
act√∫a
como
router
.
Un
proceso
conocido


como
routed
ejecuta
RIP
,
es
decir
,
mantiene
la
informaci√≥n
de
enrutamiento
e
intercambia


mensajes
con
los
procesos
routed
que
se
ejecutan
en
los
routers
vecinos
.
Dado
que
RIP
se


implementa
como
un
proceso
de
la
capa
de
aplicaci√≥n
(
aunque
es
un
proceso
muy
especial
,


capaz
de
manipular
las
tablas
de
enrutamiento
dentro
del
kernel
de
UNIX
)
,
puede
enviar
y


recibir
mensajes
a
trav√©s
de
un
socket
est√°ndar
y
utilizar
un
protocolo
de
transporte
est√°n-


dar
.
Como
se
muestra
en
la
figura
,
RIP
se
implementa
como
un
protocolo
de
la
capa
de
apli-


caci√≥n
(
v√©ase
el
Cap√≠tulo
2
)
que
se
ejecuta
sobre
UDP
.


374
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
374Figura
4.39
‚Ä¢
Implementaci√≥n
de
RIP
mediante
el
demonio
routed
.


4.6.2
Enrutamiento
interno
de
un
AS
en
Internet
:
OSPF


Al
igual
que
RIP
,
el
enrutamiento
OSPF
se
utiliza
ampliamente
para
el
enrutamiento
interno


de
los
sistemas
aut√≥nomos
de
Internet
.
OSPF
y
su
pariente
pr√≥ximo
,
IS-IS
,
normalmente
se


implantan
en
los
ISP
de
nivel
superior
,
mientras
que
RIP
se
implanta
en
los
ISP
de
nivel


inferior
y
en
las
redes
empresariales
.
El
t√©rmino
‚Äú
Abierto
‚Äù
(
Open
)
de
OSPF
indica
que
la


especificaci√≥n
del
protocolo
de
enrutamiento
est√°
disponible
p√∫blicamente
(
por
ejemplo
,
en


oposici√≥n
al
protocolo
EIGRP
de
Cisco
)
.
La
versi√≥n
m√°s
reciente
de
OSPF
,
la
versi√≥n
2
,
est√°


definida
en
 
RFC
2328
,
un
documento
p√∫blico
.


OSPF
fue
concebido
como
el
sucesor
de
RIP
y
como
tal
ofrece
una
serie
de
funcionali-


dades
avanzadas
.
Sin
embargo
,
OSPF
es
b√°sicamente
un
protocolo
de
estado
de
enlaces
que


utiliza
la
t√©cnica
de
inundaci√≥n
de
informaci√≥n
de
estado
de
los
enlaces
y
el
algoritmo
de


c√°lculo
de
la
ruta
de
coste
m√≠nimo
de
Dijkstra
.
Con
OSPF
,
un
router
construye
un
mapa


topol√≥gico
completo
(
es
decir
,
un
grafo
)
del
sistema
aut√≥nomo
entero
.
A
continuaci√≥n
,
el


router
ejecuta
localmente
el
algoritmo
de
la
ruta
m√°s
corta
de
Dijkstra
para
determinar
un


√°rbol
de
rutas
m√°s
cortas
a
todas
las
subredes
,
con
√©l
mismo
como
nodo
ra√≠z
.
El
administra-


dor
de
la
red
configura
los
costes
de
los
enlaces
individuales
(
consulte
el
recuadro
Pr√°ctica
:


configuraci√≥n
de
los
pesos
de
los
enlaces
en
OSPF
)
.
El
administrador
puede
decidir
hacer


igual
a
1
el
coste
de
todos
los
enlaces
,
proporcionando
un
enrutamiento
de
n√∫mero
m√≠nimo


de
saltos
,
 
o
puede
definir
los
pesos
de
los
enlaces
para
que
sean
inversamente
proporciona-


les
a
la
capacidad
de
los
mismos
,
con
el
fin
de
disuadir
al
tr√°fico
de
utilizar
los
enlaces
con


peque√±o
ancho
de
banda
.
OSPF
no
establece
una
pol√≠tica
para
definir
el
peso
de
los
enlaces


(
esta
tarea
le
corresponde
al
administrador
de
la
red
)
,
sino
que
proporciona
mecanismos
(
el


protocolo
)
para
determinar
el
enrutamiento
de
coste
m√≠nimo
para
el
conjunto
dado
de
pesos


de
los
enlaces
.


Con
OSPF
,
un
router
difunde
la
informaci√≥n
de
enrutamiento
a
todos
los
dem√°s
routers


del
sistema
aut√≥nomo
,
no
s√≥lo
a
sus
routers
vecinos
.
Un
router
difunde
la
informaci√≥n
de


estado
de
los
enlaces
cuando
se
ha
producido
un
cambio
en
el
estado
de
un
enlace
(
por
ejem-


plo
,
un
cambio
en
el
coste
o
en
su
estado
activo
/
inactivo
,
up
/
down
)
.
Tambi√©n
difunde
peri√≥-


dicamente
el
estado
de
un
enlace
(
al
menos
una
vez
cada
30
minutos
)
,
incluso
aunque
el


estado
del
mismo
no
haya
cambiado
.
El
documento
RFC
2328
destaca
que
‚Äú
esta
actualiza-


ci√≥n
peri√≥dica
de
los
anuncios
del
estado
de
los
enlaces
a√±ade
robustez
al
algoritmo
LS
.
‚Äù


4.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
375


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
375Los
anuncios
OSPF
est√°n
contenidos
en
mensajes
OSPF
que
son
transportados
directamente


por
IP
,
siendo
el
n√∫mero
del
protocolo
de
la
capa
superior
para
OSPF
igual
a
89
.
As√≠
,
el
pro-


tocolo
OSPF
tiene
que
implementar
por
s√≠
mismo
funcionalidades
tales
como
la
de
transfe-


rencia
fiable
de
mensajes
y
la
de
env√≠o
de
mensajes
de
difusi√≥n
acerca
del
estado
de
los


enlaces
.
El
protocolo
OSPF
tambi√©n
comprueba
que
los
enlaces
est√©n
operativos
(
mediante


un
mensaje
HELLO
que
se
env√≠a
a
un
vecino
conectado
)
y
permite
al
router
OSPF
obtener


de
un
vecino
la
base
de
datos
de
estado
de
los
enlaces
de
toda
la
red
.


Algunas
de
las
funcionalidades
avanzadas
incluidas
en
OSPF
son
las
siguientes
:


‚Ä¢
Seguridad
.
Los
intercambios
entre
routers
OSPF
(
por
ejemplo
,
actualizaciones
de
estado


de
los
enlaces
)
pueden
ser
autenticados
.
Con
la
autenticaci√≥n
,
s√≥lo
pueden
participar
en


el
protocolo
OSPF
los
routers
de
confianza
del
sistema
aut√≥nomo
,
impidiendo
as√≠
que


intrusos
maliciosos
(
o
estudiantes
de
redes
que
apliquen
sus
conocimientos
reci√©n
adqui-


ridos
sin
permiso
)
inyecten
informaci√≥n
incorrecta
en
las
tablas
de
un
router
.
Por
defecto
,


los
paquetes
OSPF
entre
routers
no
son
autenticados
y
podr√≠an
ser
alterados
.
Pueden
con-


figurarse
dos
tipos
de
mecanismo
de
autenticaci√≥n
:
simple
y
MD5
(
consulte
el
Cap√≠tulo


8p
a
r
a
 
o
b
t
e
n
e
r
 
i
n
f
o
r
m
a
c
i
√≥
n
 
s
o
b
r
e
 
M
D
5
 
y
 
l
a
 
a
u
t
e
n
t
i
c
a
c
i
√≥
n
 
e
n
 
g
e
n
e
r
a
l
)
.
 
C
o
n
 
l
a
 
a
u
t
e
n
t
i
c
a
-


ci√≥n
simple
se
configura
la
misma
contrase√±a
en
todos
los
routers
.
Cuando
un
router


env√≠a
un
paquete
OSPF
,
incluye
la
contrase√±a
en
texto
legible
.
Evidentemente
,
la
auten-


ticaci√≥n
simple
no
es
muy
segura
.
La
autenticaci√≥n
MD5
est√°
basada
en
claves
secretas


compartidas
que
est√°n
configuradas
en
todos
los
routers
.
Para
cada
paquete
OSPF
que
se


env√≠a
,
el
router
calcula
el
hash
MD5
del
contenido
del
paquete
OSPF
,
al
que
se
a√±ade
la


clave
secreta
(
consulte
el
Cap√≠tulo
7
para
ver
una
explicaci√≥n
acerca
de
los
c√≥digos
de


autenticaci√≥n
de
mensajes
)
.
A
continuaci√≥n
,
el
router
incluye
el
valor
hash
resultante
en


el
paquete
OSPF
.
El
router
receptor
,
utilizando
la
clave
secreta
preconfigurada
,
calcular√°


un
hash
MD5
del
paquete
y
lo
comparar√°
con
el
valor
hash
que
transporta
el
paquete
,


verificando
de
este
modo
la
autenticidad
del
mismo
.
En
la
autenticaci√≥n
MD5
tambi√©n
se


utilizan
los
n√∫meros
de
secuencia
para
protegerse
frente
a
ataques
por
repetici√≥n
.
 

‚Ä¢
Varias
rutas
de
igual
coste
.
Cuando
varias
rutas
a
un
destino
tienen
el
mismo
coste
,


OSPF
permite
utilizar
varias
rutas
(
es
decir
,
no
es
necesario
elegir
una
misma
ruta
para


transportar
todo
el
tr√°fico
,
cuando
existen
varias
rutas
con
igual
coste
)
.


‚Ä¢
Soporte
integrado
para
enrutamiento
por
unidifusi√≥n
y
por
multidifusi√≥n
.
OSPF
multidi-


fusi√≥n
(
MOSPF
,
Multicast
OSPF
)
[
RFC
1584
]
a√±ade
extensiones
simples
a
OSPF
para


proporcionar
enrutamiento
por
multidifusi√≥n
(
un
tema
que
cubriremos
en
detalle
en
la


Secci√≥n
4.7.2
)
.
MOSPF
utiliza
la
base
de
datos
de
enlaces
OSPF
existente
y
a√±ade
un


nuevo
tipo
de
anuncio
de
estado
de
enlaces
al
mecanismo
de
difusi√≥n
existente
en
OSPF


para
difundir
el
estado
de
los
enlaces
.


‚Ä¢
Soporte
para
definir
una
jerarqu√≠a
dentro
de
un
mismo
dominio
de
enrutamiento
.
Quiz√°


el
avance
m√°s
significativo
de
OSPF
sea
la
capacidad
de
estructurar
los
sistemas
aut√≥no-


mos
de
forma
jer√°rquica
.
En
la
Secci√≥n
4.5.3
ya
hemos
visto
algunas
de
las
ventajas
de


las
estructuras
de
enrutamiento
jer√°rquicas
.
Veremos
la
implementaci√≥n
del
enrutamiento


jer√°rquico
OSPF
a
lo
largo
del
resto
de
esta
secci√≥n
.


Un
sistema
aut√≥nomo
OSPF
puede
configurarse
jer√°rquicamente
en
√°reas
.
Cada
√°rea


ejecuta
su
propio
algoritmo
de
enrutamiento
de
estado
de
enlaces
OSPF
,
con
cada
router
de


un
√°rea
difundiendo
su
estado
de
enlaces
a
todos
los
dem√°s
routers
de
ese
√°rea
.
Dentro
de


cada
√°rea
,
uno
o
m√°s
routers
de
frontera
de
√°rea
son
responsables
de
enrutar
los
paquetes


376
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
376fuera
del
√°rea
.
Por
√∫ltimo
,
una
√∫nica
√°rea
OSPF
del
sistema
aut√≥nomo
se
configura
para


actuar
como
√°rea
troncal
(
bakbone
)
.
La
funci√≥n
principal
del
√°rea
troncal
es
enrutar
el
tr√°-


fico
entre
las
dem√°s
√°reas
del
sistema
aut√≥nomo
.
El
√°rea
troncal
siempre
contiene
a
todos


los
routers
de
frontera
del
sistema
aut√≥nomo
y
tambi√©n
puede
contener
routers
que
no
sean


de
frontera
.
El
enrutamiento
entre
√°reas
dentro
del
sistema
aut√≥nomo
requiere
que
el
paquete


sea
enrutado
en
primer
lugar
a
un
router
de
frontera
del
√°rea
(
enrutamiento
dentro
del
√°rea
)


y
luego
a
trav√©s
del
√°rea
troncal
al
router
de
frontera
del
√°rea
en
que
se
encuentra
el
destino
,


para
enrutarse
por
√∫ltimo
hacia
el
destino
final
.


OSPF
es
un
protocolo
relativamente
complejo
,
por
lo
que
aqu√≠
lo
hemos
cubierto
breve-


mente
;
en
[
Huitema
1998
;
Moy
1998
;
RFC
2328
]
se
proporcionan
detalles
adicionales
.


4.6.3
Enrutamiento
entre
sistemas
aut√≥nomos
:
BGP


Acabamos
de
ver
c√≥mo
los
ISP
utilizan
los
protocolos
RIP
y
OSPF
para
determinar
las
rutas


√≥ptimas
para
las
parejas
origen-destino
que
se
encuentran
en
un
mismo
sistema
aut√≥nomo
.


4.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
377


CONFIGURACI√ìN
DE
LOS
PESOS
DE
LOS
ENLACES
EN
OSPF


En
nuestra
exposici√≥n
sobre
el
enrutamiento
de
estado
de
enlaces
hemos
supuesto
impl√≠citamente


que
los
pesos
de
los
enlaces
est√°n
definidos
,
que
se
est√°
ejecutando
un
algoritmo
de
enrutamiento


como
OSPF
y
que
el
tr√°fico
fluye
de
acuerdo
con
las
tablas
de
enrutamiento
calculadas
por
el


algoritmo
LS
.
En
t√©rminos
de
causa
y
efecto
,
los
pesos
de
los
enlaces
nos
vienen
dados
(
es
decir
,


se
conocen
de
antemano
)
y
dan
como
resultado
(
mediante
el
algoritmo
de
Dijkstra
)
las
rutas
que


minimizan
el
coste
global
.
Desde
este
punto
de
vista
,
los
pesos
de
los
enlaces
reflejan
el
coste
de


utilizar
un
enlace
(
por
ejemplo
,
si
los
pesos
son
inversamente
proporcionales
a
la
capacidad
,


entonces
los
enlaces
de
alta
capacidad
tendr√≠an
asociados
pesos
m√°s
peque√±os
y
,
por
tanto
,


ser√≠an
m√°s
atractivos
desde
el
punto
de
vista
del
enrutamiento
)
y
el
algoritmo
de
Disjkstra
sirve


para
minimizar
el
coste
global
.


En
la
pr√°ctica
,
la
relaci√≥n
causa-efecto
entre
el
peso
de
los
enlaces
y
las
rutas
puede
invertir-


se
,
cuando
los
operadores
de
red
configuran
los
pesos
de
los
enlaces
de
manera
que
se
obten-


gan
rutas
que
permitan
alcanzar
determinados
objetivos
de
ingenier√≠a
de
tr√°fico
[
Fortz
2000
,


Fortz
2002
]
.
Por
ejemplo
,
suponga
que
un
operador
de
red
tiene
una
estimaci√≥n
del
flujo
de
tr√°fi-


co
que
entra
en
la
red
por
cada
punto
de
entrada
y
que
sale
de
la
misma
por
cada
punto
de
sali-


da
.
El
operador
puede
entonces
implementar
un
enrutamiento
espec√≠fico
para
los
flujos
de


entrada-a-salida
que
minimice
la
tasa
m√°xima
de
utilizaci√≥n
de
los
enlaces
de
la
red
.
Pero
con
un


algoritmo
de
enrutamiento
como
OSPF
,
la
principal
herramienta
de
la
que
dispone
el
operador


para
optimizar
el
enrutamiento
de
los
flujos
a
trav√©s
de
la
red
son
los
pesos
de
los
enlaces
.
Por


tanto
,
para
alcanzar
el
objetivo
de
minimizar
la
tasa
m√°xima
de
utilizaci√≥n
de
los
enlaces
,
el
ope-


rador
tiene
que
encontrar
el
conjunto
de
pesos
de
los
enlaces
que
permita
alcanzar
este
objetivo
.


Esto
constituye
una
inversi√≥n
de
la
relaci√≥n
causa-efecto
:
el
enrutamiento
deseado
de
los
flujos
es


conocido
y
tienen
que
determinarse
los
pesos
de
los
enlaces
OSPF
,
de
manera
que
el
algoritmo


de
enrutamiento
OSPF
d√©
como
resultado
el
enrutamiento
de
flujos
deseado
.


PR√ÅCTICA


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
377Ahora
vamos
a
examinar
c√≥mo
se
determinan
las
rutas
para
parejas
origen-destino
que
se


encuentran
en
diferentes
sistemas
aut√≥nomos
.
La
versi√≥n
4
del
Protocolo
de
pasarela
de


frontera
(
BPG
,
Border
Gateway
Protocol
)
,
especificado
en
el
documento
RFC
4271
(
v√©ase


tambi√©n
[
RFC
4274
;
RFC
4276
]
)
,
es
actualmente
el
protocolo
de
enrutamiento
entre
siste-


mas
aut√≥nomos
est√°ndar
de
facto
en
Internet
.
Com√∫nmente
se
le
conoce
como
BGP4
o
sim-


plemente
como
BGP
.
Como
protocolo
de
enrutamiento
entre
sistemas
aut√≥nomos
(
v√©ase
la


Secci√≥n
4.5.3
)
,
BGP
proporciona
a
cada
sistema
aut√≥nomo
mecanismos
para
:


1
.
Obtener
informaci√≥n
acerca
de
la
alcanzabilidad
de
las
subredes
de
los
sistemas
aut√≥-


nomos
vecinos
.


2
.
Propagar
la
informaci√≥n
de
alcanzabilidad
a
todos
los
routers
internos
del
sistema
aut√≥-


nomo
.


3
.
Determinar
‚Äú
buenas
‚Äù
rutas
a
las
subredes
,
bas√°ndose
en
la
informaci√≥n
de
alcanzabili-


dad
y
en
la
pol√≠tica
del
sistema
aut√≥nomo
.


Lo
m√°s
importante
es
que
BGP
permite
a
cada
subred
anunciar
su
existencia
al
resto
de


Internet
.
Una
subred
vocifera
‚Äú
Existo
y
estoy
aqu√≠
‚Äù
,
y
BGP
garantiza
que
todos
los
sistemas


aut√≥nomos
de
Internet
sabr√°n
que
la
subred
existe
y
c√≥mo
llegar
a
ella
.
Si
no
fuera
por
BGP
,


las
subredes
estar√≠an
aisladas
,
resultando
desconocidas
para
el
resto
de
Internet
.


Fundamentos
de
BGP


BGP
es
extremadamente
complejo
;
se
han
dedicado
libros
completos
al
tema
y
todav√≠a
hay


muchas
cuestiones
que
no
se
comprenden
bien
[
Yannuzzi
2005
]
.
Adem√°s
,
incluso
despu√©s


de
haber
le√≠do
los
libros
y
documentos
RFC
,
es
posible
que
sea
dif√≠cil
dominar
completa-


mente
BGP
si
no
se
ha
practicado
con
√©l
durante
muchos
meses
(
por
no
decir
a√±os
)
como


dise√±ador
o
administrador
de
un
ISP
de
nivel
superior
.
No
obstante
,
dado
que
BGP
es
un


protocolo
absolutamente
cr√≠tico
en
Internet
(
b√°sicamente
,
es
el
protocolo
que
permite
unir


todos
los
componentes
)
,
necesitamos
adquirir
al
menos
unos
conocimientos
rudimentarios


acerca
de
c√≥mo
funciona
.
Comenzaremos
describiendo
c√≥mo
podr√≠a
funcionar
BGP
en
el


contexto
de
la
red
de
ejemplo
de
la
Figura
4.32
que
hemos
estudiado
anteriormente
.
En
esta


descripci√≥n
,
nos
basaremos
en
nuestra
exposici√≥n
acerca
del
enrutamiento
jer√°rquico
de
la


Secci√≥n
4.5.3
;
le
recomendamos
que
repase
dicho
material
.


En
BGP
,
las
parejas
de
routers
intercambian
informaci√≥n
de
enrutamiento
a
trav√©s
de


conexiones
TCP
semipermanentes
utilizando
el
puerto
179
.
Las
conexiones
TCP
semiper-


manentes
para
la
red
de
la
Figura
4.32
se
muestran
en
la
Figura
4.40
.
Normalmente
,
existe


una
conexi√≥n
TCP
BGP
para
cada
enlace
que
conecta
directamente
dos
routers
que
se


encuentran
en
dos
sistemas
aut√≥nomos
diferentes
;
as√≠
,
en
la
Figura
4.40
,
existe
una
cone-


xi√≥n
 
TCP
entre
los
routers
pasarela
3a
y
1c
,
y
otra
conexi√≥n
TCP
entre
los
routers
pasarela


1b
y
2a
.
Existen
tambi√©n
conexiones
TCP
BGP
semipermanentes
entre
los
routers
internos


de
un
sistema
aut√≥nomo
.
En
particular
,
la
Figura
4.40
muestra
una
configuraci√≥n
habitual
de


una
conexi√≥n
TCP
para
cada
pareja
de
routers
internos
de
un
sistema
aut√≥nomo
,
creando
una


malla
de
conexiones
TCP
dentro
de
cada
sistema
aut√≥nomo
.
Para
cada
conexi√≥n
TCP
,
los


dos
routers
situados
en
los
extremos
de
la
conexi√≥n
se
denominan
pares
BGP
y
la
conexi√≥n


TCP
junto
con
todos
los
mensajes
BGP
enviados
a
trav√©s
de
la
conexi√≥n
se
denomina
sesi√≥n


BGP
.
Adem√°s
,
una
sesi√≥n
BGP
que
abarca
dos
sistemas
aut√≥nomos
se
conoce
como
se-


si√≥n
externa
BGP
(
eBGP
)
y
una
sesi√≥n
BGP
entre
routers
de
un
mismo
sistema
aut√≥nomo


se
conoce
como
sesi√≥n
interna
BGP
(
iBGP
)
.
En
la
Figura
4.40
,
las
sesiones
eBGP
est√°n


378
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
378indicadas
mediante
l√≠neas
de
trazo
largo
y
las
sesiones
iBGP
mediante
l√≠neas
de
trazo
m√°s


corto
.
Observe
que
las
l√≠neas
de
sesi√≥n
BGP
de
la
Figura
4.40
no
siempre
corresponden
a


los
enlaces
f√≠sicos
de
la
Figura
4.32
.


BGP
permite
que
cada
sistema
aut√≥nomo
aprenda
qu√©
destinos
son
alcanzables
a
trav√©s


de
sus
sistemas
aut√≥nomos
vecinos
.
En
BGP
,
los
destinos
no
son
hosts
sino
prefijos
CIDR
,


representando
cada
prefijo
una
subred
o
una
colecci√≥n
de
subredes
.
As√≠
,
por
ejemplo
,
su-


ponga
que
hay
cuatro
subredes
conectadas
a
AS2
:
138.16.64/24
,
138.16.65/24
,
138.16.66/24
y


138.16.67/24
.
Entonces
AS2
podr√≠a
agrupar
los
prefijos
para
estas
cuatro
subredes
y
utilizar


BGP
para
anunciar
un
√∫nico
prefijo
138.16.64/22
a
AS1
.
Veamos
otro
ejemplo
;
suponga
que


s√≥lo
las
tres
primeras
de
esas
cuatro
subredes
est√°n
en
AS2
y
que
la
cuarta
subred
,


138.16.67/24
,
est√°
en
AS3
.
Luego
,
como
se
describe
en
el
recuadro
Pr√°ctica
de
la
Secci√≥n


4.4.2
,
dado
que
los
routers
utilizan
las
coincidencias
con
el
prefijo
m√°s
largo
para
reenviar


los
datagramas
,
AS3
podr√≠a
anunciar
a
AS1
el
prefijo
m√°s
espec√≠fico
138.16.67/24
y
AS2


todav√≠apodr√≠a
anunciar
a
AS1
el
prefijo
agregado
138.16.64/22
.


Examinemos
ahora
c√≥mo
BGP
distribuir√≠a
la
informaci√≥n
de
alcanzabilidad
de
prefijos


a
trav√©s
de
las
sesiones
BGP
mostradas
en
la
Figura
4.40
.
Como
es
l√≥gico
,
utilizando
la


sesi√≥n
eBGP
entre
los
routers
pasarela
3a
y
1c
,
AS3
env√≠a
a
AS1
la
lista
de
prefijos
que
son


alcanzables
desde
AS3
;
y
AS1
env√≠a
a
AS3
la
lista
de
prefijos
que
son
alcanzables
desde


AS1
.
De
forma
similar
,
AS1
y
AS2
intercambian
la
informaci√≥n
de
alcanzabilidad
a
trav√©s


de
sus
routers
pasarela
1b
y
2a
.
Tambi√©n
,
como
es
de
esperar
,
cuando
un
router
de
pasarela


(
en
cualquier
sistema
aut√≥nomo
)
recibe
prefijos
aprendidos
mediante
eBGP
,
el
router
de


pasarela
utiliza
sus
sesiones
iBGP
para
distribuir
los
prefijos
a
los
dem√°s
routers
del
sistema


aut√≥nomo
.
Por
tanto
,
todos
los
routers
de
AS1
aprenden
los
prefijos
de
AS3
,
incluyendo
al


router
de
pasarela
1b
.
Este
router
(
de
AS1
)
puede
por
tanto
volver
a
anunciar
los
prefijos
de


AS3
a
AS2
.
Cuando
un
router
(
de
pasarela
o
no
)
aprende
un
nuevo
prefijo
,
crea
una
entrada


para
el
mismo
en
su
tabla
de
reenv√≠o
,
como
se
ha
descrito
en
la
Secci√≥n
4.5.3
.


Atributos
de
ruta
y
rutas
BGP


Ahora
que
ya
tenemos
unos
conocimientos
b√°sicos
sobre
BGP
,
vamos
a
profundizar
un
poco


en
√©l
(
omitiendo
algunos
de
los
detalles
menos
importantes
)
.
En
BGP
,
un
sistema
aut√≥nomo


se
identifica
mediante
su
n√∫mero
de
sistema
aut√≥nomo
(
ASN
,
Autonomous
System
Num-


ber
)
globalmente
√∫nico
[
RFC
1930
]
.
(
T√©cnicamente
,
no
todos
los
sistemas
aut√≥nomos
tie-


4.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
379


Clave
:


Figura
4.40
‚Ä¢
Sesiones
eBGP
e
iBGP
.


Sesi√≥n
eBGP


Sesi√≥n
iBGP


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
379nen
un
ASN
.
En
concreto
,
un
sistema
aut√≥nomo
del
tipo
terminal
(
stub
AS
)
,
aqu√©l
que
s√≥lo


transporta
el
tr√°fico
para
el
que
es
origen
o
destino
,
normalmente
no
tendr√°
un
ASN
;
ignora-


remos
este
tecnicismo
en
nuestra
exposici√≥n
con
el
fin
de
ser
m√°s
claros
.
)
Los
n√∫meros
de


AS
,
al
igual
que
las
direcciones
IP
,
son
asignados
por
los
registros
regionales
de
la
ICANN


[
ICANN
2009
]
.


Cuando
un
router
anuncia
un
prefijo
en
una
sesi√≥n
BGP
,
incluye
con
el
prefijo
una
serie


de
atributos
BGP
.
En
la
jerga
de
BGP
,
un
prefijo
junto
con
sus
atributos
se
denomina
ruta
.


Por
tanto
,
los
pares
BGP
se
anuncian
rutas
entre
s√≠
.
Dos
de
los
atributos
m√°s
importantes
son


AS-PATH
y
NEXT-HOP
:


‚Ä¢
AS-P
ATH
.
Este
atributo
contiene
los
sistemas
aut√≥nomos
a
trav√©s
de
los
que
ha
pasado
el


anuncio
del
prefijo
.
Cuando
se
ha
pasado
un
prefijo
dentro
de
un
sistema
aut√≥nomo
,
el


sistema
a√±ade
su
ASN
al
atributo
AS-PATH
.
Por
ejemplo
,
considere
la
Figura
4.40
y


suponga
que
el
prefijo
138.16.64/24
se
anuncia
primero
desde
AS2
a
AS1
;
si
a
continua-


ci√≥n
AS1
anuncia
el
prefijo
a
AS3
,
el
valor
de
AS-PATH
ser√≠a
AS2
AS1
.
Los
routers
uti-


lizan
el
atributo
AS-PATH
para
detectar
e
impedir
los
bucles
de
anuncio
;
en
concreto
,
si


un
router
ve
que
su
sistema
aut√≥nomo
est√°
en
la
lista
de
rutas
,
rechazar√°
el
anuncio
.


Como
pronto
explicaremos
,
los
routers
tambi√©n
utilizan
el
atributo
AS-PATH
para
selec-


cionar
entre
varias
rutas
hacia
el
mismo
prefijo
.


‚Ä¢E
l
 
a
t
r
i
b
u
t
o
 
N
E
X
T
-
H
O
P
,
 
q
u
e
 
p
r
o
p
o
r
c
i
o
n
a
 
e
l
 
e
n
l
a
c
e
 
c
r
√≠
t
i
c
o
 
e
n
t
r
e
 
e
l
 
p
r
o
t
o
c
o
l
o
 
d
e
 
e
n
r
u
t
a
-


miento
interno
del
sistema
aut√≥nomo
y
el
protocolo
de
enrutamiento
entre
sistemas


aut√≥nomos
,
tiene
un
sutil
aunque
importante
uso
.
El
siguiente
salto
(
NEXT-HOP
)
es
la


interfaz
de
router
que
inicia
la
secuencia
de
sistemas
aut√≥nomos
(
AS-P
ATH
)
.
Para
com-


prender
el
uso
de
este
atributo
,
vamos
a
hacer
referencia
de
nuevo
a
la
Figura
4.40
.
Con-


sidere
lo
que
ocurre
cuando
el
router
de
pasarela
3a
de
AS3
anuncia
una
ruta
al
router


pasarela
1c
de
AS1
,
utilizando
una
sesi√≥n
eBGP
.
La
ruta
incluye
el
prefijo
anunciado
,


que
denominaremos
x
,
y
la
secuencia
de
sistemas
aut√≥nomos
(
AS-PATH
)
que
hay
que


seguir
para
alcanzar
ese
prefijo
.
Este
anuncio
tambi√©n
incluye
el
siguiente
salto
(
NEXT-


HOP
)
,
que
es
la
direcci√≥n
IP
de
la
interfaz
del
router
3a
que
lleva
a
1c
(
recuerde
que
un


router
tiene
m√∫ltiples
direcciones
IP
,
una
para
cada
una
de
sus
interfaces
.
)
Considere-


mos
ahora
lo
que
ocurre
cuando
el
router
1d
aprende
acerca
de
esta
ruta
gracias
a
iBGP
.


Despu√©s
de
aprender
esta
ruta
a
x
,
el
router
1d
puede
querer
reenviar
paquetes
a
x
a
lo


largo
de
la
ruta
,
es
decir
,
el
router
1d
puede
querer
incluir
la
entrada
(
x
,
l
)
en
su
tabla
de


reenv√≠o
,
donde
l
es
su
interfaz
que
inicia
la
ruta
de
coste
m√≠nimo
desde
1d
al
router
de


pasarela
1c
.
Para
determinar
l
,
1d
proporciona
la
direcci√≥n
IP
en
el
atributo
NEXT-HOP


a
su
m√≥dulo
de
enrutamiento
interno
del
sistema
aut√≥nomo
.
Observe
que
el
algoritmo


de
enrutamiento
interno
del
sistema
aut√≥nomo
ha
determinado
la
ruta
de
coste
m√≠nimo


a
todas
las
subredes
conectadas
a
los
routers
de
AS1
,
incluyendo
la
subred
para
el
enlace


entre
1c
y
3a
.
A
partir
de
esta
ruta
de
coste
m√≠nimo
desde
1d
a
la
subred
1c-3a
,
1d
deter-


mina
su
interfaz
de
router
l
que
da
comienzo
a
esta
ruta
y
luego
a√±ade
la
entrada
(
x
,
l
)
a


su
tabla
de
reenv√≠o
.
En
resumen
,
los
routers
utilizan
el
atributo
AS-PATH
para
configu-


rar
apropiadamente
sus
tablas
de
reenv√≠o
.


‚Ä¢L
a
 
F
i
g
u
r
a
4
.
4
1
i
l
u
s
t
r
a
 
o
t
r
a
 
s
i
t
u
a
c
i
√≥
n
 
e
n
 
l
a
 
q
u
e
 
s
e
 
n
e
c
e
s
i
t
a
 
e
l
 
a
t
r
i
b
u
t
o
 
A
S
-
P
A
T
H
.
 
E
n
 
e
s
t
a


figura
,
AS1
y
AS2
est√°n
conectados
mediante
dos
enlaces
entre
pares
.
Un
router
de
AS1


podr√≠a
aprender
dos
rutas
diferentes
hacia
el
mismo
prefijo
x.
Estas
dos
rutas
podr√≠an


seguir
la
misma
secuencia
de
sistemas
aut√≥nomos
(
AS-PATH
)
hasta
x
,
pero
podr√≠an
tener


distintos
valores
de
NEXT-HOP
,
correspondientes
a
los
diferentes
enlaces
entre
pares
.
Uti-


380
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
380lizando
los
valores
de
AS-PATH
y
el
algoritmo
de
enrutamiento
interno
del
sistema
aut√≥-


nomo
,
el
router
puede
determinar
el
coste
de
la
ruta
a
cada
enlace
entre
pares
y
luego
apli-


car
el
enrutamiento
de
la
patata
caliente
(
v√©ase
la
Secci√≥n
4.5.3
)
para
determinar
la


interfaz
apropiada
.


BGP
tambi√©n
incluye
atributos
que
permiten
a
los
routers
asignar
m√©tricas
de
preferen-


cia
a
las
rutas
y
un
atributo
que
indica
c√≥mo
se
insert√≥
el
prefijo
en
BGP
en
el
sistema
aut√≥-


nomo
de
origen
.
Para
obtener
m√°s
informaci√≥n
acerca
de
los
atributos
de
ruta
,
consulte


[
Griffin
2009
;
Stewart
1999
;
Halabi
2000
;
Feamster
2004
;
RFC
4271
]
.


Cuando
un
router
de
pasarela
recibe
un
anuncio
de
un
router
,
utiliza
su
pol√≠tica
de


importaci√≥n
para
decidir
si
aceptar
o
filtrar
la
ruta
y
si
debe
definir
determinados
atributos
,


como
por
ejemplo
las
m√©tricas
de
preferencia
del
router
.
La
pol√≠tica
de
importaci√≥n
puede


filtrar
una
ruta
porque
el
sistema
aut√≥nomo
puede
no
querer
enviar
tr√°fico
a
trav√©s
de
uno
de


los
sistemas
aut√≥nomos
contenidos
en
la
secuencia
AS-PATH
de
la
ruta
.
El
router
de
pasa-


rela
tambi√©n
puede
filtrar
una
ruta
porque
ya
disponga
de
una
ruta
preferible
hacia
el
mismo


prefijo
.


Selecci√≥n
de
la
ruta
BGP


Como
se
ha
descrito
anteriormente
en
esta
secci√≥n
,
BGP
utiliza
las
sesiones
eBGP
e
iBGP


para
distribuir
las
rutas
a
todos
los
routers
que
forman
los
sistemas
aut√≥nomos
.
A
partir
de


esta
distribuci√≥n
,
un
router
puede
aprender
acerca
de
m√°s
de
una
ruta
a
cualquier
prefijo
,
en


cuyo
caso
tendr√°
que
seleccionar
una
de
las
posibles
rutas
.
Las
entradas
para
este
proceso
de


selecci√≥n
de
ruta
es
el
conjunto
de
todas
las
rutas
que
han
sido
aprendidas
y
aceptadas
por
el


router
.
Si
existen
dos
o
m√°s
rutas
al
mismo
prefijo
,
entonces
BGP
invoca
secuencialmente
las


siguientes
reglas
de
eliminaci√≥n
hasta
quedarse
con
una
ruta
:


4.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
381


Figura
4.41
‚Ä¢
Los
atributos
NEXT-HOP
en
los
anuncios
se
utilizan
para


determinar
qu√©
enlace
entre
pares
utilizar
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
381‚Ä¢S
e
 
a
s
i
g
n
a
 
u
n
 
v
a
l
o
r
 
d
e
 
p
r
e
f
e
r
e
n
c
i
a
 
l
o
c
a
l
 
a
 
l
a
s
 
r
u
t
a
s
,
 
c
o
m
o
 
u
n
o
 
d
e
 
s
u
s
 
a
t
r
i
b
u
t
o
s
.
 
L
a
 
p
r
e
f
e
-


rencia
local
de
una
ruta
podr√≠a
haber
sido
definida
por
el
router
o
podr√≠a
haber
sido


aprendida
por
otro
router
perteneciente
al
mismo
sistema
aut√≥nomo
.
√âsta
es
una
decisi√≥n


pol√≠tica
que
se
deja
al
administrador
de
red
del
sistema
aut√≥nomo
(
en
breve
veremos
en


detalle
las
pol√≠ticas
de
BGP
)
.
Se
eligen
las
rutas
con
los
valores
de
preferencia
local
m√°s


altos
.


‚Ä¢D
e
 
l
a
s
 
r
u
t
a
s
 
q
u
e
 
q
u
e
d
a
n
 
(
t
o
d
a
s
 
e
l
l
a
s
 
c
o
n
 
e
l
 
m
i
s
m
o
 
v
a
l
o
r
 
d
e
 
p
r
e
f
e
r
e
n
c
i
a
 
l
o
c
a
l
)
,
 
s
e
 
s
e
l
e
c
-


ciona
la
ruta
con
el
camino
de
sistemas
aut√≥nomos
(
AS-PATH
)
m√°s
corto
.
Si
esta
regla


fuera
la
√∫nica
para
seleccionar
la
ruta
,
entonces
BGP
estar√≠a
aplicando
un
algoritmo
de


vector
de
distancias
para
determinar
la
ruta
,
siendo
la
m√©trica
de
distancia
utilizada
el


n√∫mero
de
saltos
entre
sistemas
aut√≥nomos
,
en
lugar
del
n√∫mero
de
saltos
entre
routers
.


‚Ä¢
De
las
restantes
rutas
(
todas
con
el
mismo
valor
de
preferencia
local
y
la
misma
longitud


de
AS-PATH
)
,
se
selecciona
la
ruta
con
el
router
del
siguiente
salto
(
NEXT-HOP
)
m√°s


pr√≥ximo
.
En
este
caso
,
m√°s
pr√≥ximo
quiere
decir
el
router
para
el
que
el
coste
de
la
ruta


de
coste
m√≠nimo
,
determinado
por
el
algoritmo
interno
del
sistema
aut√≥nomo
,
sea
m√°s


peque√±o
.
Como
se
ha
visto
en
la
Secci√≥n
4.5.3
,
este
proceso
se
conoce
como
enruta-


miento
de
la
patata
caliente
.


‚Ä¢
Si
todav√≠a
queda
m√°s
de
una
ruta
,
el
router
utiliza
los
identificadores
BGP
para
seleccio-


nar
la
ruta
;
consulte
[
Stewart
1999
]
.


Las
reglas
de
eliminaci√≥n
son
aun
m√°s
complejas
de
lo
que
acabamos
de
describir
.
Para
evi-


tar
tener
pesadillas
con
BGP
,
lo
mejor
es
estudiar
las
reglas
de
selecci√≥n
de
BGP
en
peque-


√±as
dosis
.
 

Pol√≠tica
de
enrutamiento


Vamos
a
ilustrar
algunos
de
los
conceptos
b√°sicos
de
la
pol√≠tica
de
enrutamiento
de
BGP
con


un
ejemplo
sencillo
.
La
Figura
4.42
muestra
seis
sistemas
aut√≥nomos
interconectados
:
A
,
B
,


C
,
W
,
X
e
Y
.
Es
importante
observar
que
A
,
B
,
C
,
W
,
X
e
Y
son
sistemas
aut√≥nomos
,
no
rou-


ters
.
Supongamos
que
los
sistemas
aut√≥nomos
W
,
X
e
Y
son
redes
terminales
(
stub
)
y
que
A
,


B
y
C
son
redes
troncales
de
los
proveedores
.
Supongamos
tambi√©n
que
A
,
B
y
C
est√°n
inter-


conectados
entre
s√≠
y
que
proporcionan
informaci√≥n
completa
sobre
BGP
a
sus
redes
cliente
.


Todo
el
tr√°fico
que
entra
en
una
red
terminal
tiene
que
estar
destinado
a
esa
red
,
y
todo
el


tr√°fico
que
sale
de
una
red
terminal
tiene
que
haber
sido
originado
en
esa
red
.
W
e
Y
son
cla-


ramente
redes
terminales
.
X
es
una
red
terminal
multiconectada
(
multihomed
)
,
ya
que


est√°
conectada
al
resto
de
la
red
a
trav√©s
de
dos
proveedores
diferentes
(
un
escenario
cada


382
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.42
‚Ä¢
Un
escenario
BGP
simple
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
3824.6
‚Ä¢
ENRUTAMIENTO
EN
INTERNET
383


PRINCIPLES
IN
PRACTICE


¬ø
POR
QU√â
LOS
SISTEMAS
AUT√ìNOMOS
DISPONEN
DE
DIFERENTES
PROTOCOLOS


DE
ENRUTAMIENTO
PARA
USO
INTERNO
Y
PARA
COMUNICARSE
ENTRE
ELLOS
?


Una
vez
estudiados
los
detalles
de
los
protocolos
de
enrutamiento
internos
y
para
comunicarse


entre
s√≠
utilizados
por
los
sistemas
aut√≥nomos
implantados
actualmente
en
Internet
,
vamos
a
con-


cluir
considerando
quiz√°
la
cuesti√≥n
m√°s
importante
que
podr√≠amos
plantearnos
acerca
de
estos


protocolos
(
esperamos
que
le
haya
surgido
esta
duda
a
lo
largo
del
cap√≠tulo
):
¬ø
por
qu√©
se
utilizan


protocolos
de
enrutamiento
distintos
dentro
de
los
sistemas
aut√≥nomos
y
para
comunicarse
entre


ellos
?


La
respuesta
a
esta
pregunta
se
encuentra
en
las
diferencias
entre
los
objetivos
de
enrutamien-


to
dentro
de
un
sistema
aut√≥nomo
y
entre
sistemas
aut√≥nomos
:
 

‚Ä¢
Pol√≠tica
.
Entre
sistemas
aut√≥nomos
,
prevalecen
las
pol√≠ticas
.
Puede
ser
importante
que
el
tr√°fico


originado
en
un
determinado
sistema
aut√≥nomo
no
pueda
atravesar
otro
sistema
aut√≥nomo


espec√≠fico
.
De
forma
similar
,
un
sistema
aut√≥nomo
dado
puede
desear
controlar
el
tr√°fico
de


tr√°nsito
transportado
entre
otros
sistemas
aut√≥nomos
que
pasa
a
su
trav√©s
.
Hemos
visto
que


BGP
transporta
atributos
de
ruta
y
permite
la
distribuci√≥n
controlada
de
informaci√≥n
de
enruta-


miento
,
de
manera
que
pueden
tomarse
ese
tipo
decisiones
de
enrutamiento
basadas
en
pol√≠ti-


cas
.
Dentro
de
un
sistema
aut√≥nomo
,
todo
est√°
bajo
el
mismo
control
administrativo
y
,
por


tanto
,
las
pol√≠ticas
desempe√±an
un
papel
mucho
menos
importante
en
la
elecci√≥n
de
rutas
den-


tro
del
sistema
aut√≥nomo
.


‚Ä¢
Escala
.
La
capacidad
de
un
algoritmo
de
enrutamiento
y
de
sus
estructuras
de
datos
para


ampliarse
,
con
el
fin
de
gestionar
el
enrutamiento
hacia
/
entre
una
gran
cantidad
de
redes
es


un
problema
cr√≠tico
en
el
enrutamiento
entre
sistemas
aut√≥nomos
.
Dentro
de
un
sistema
aut√≥no-


mo
,
la
escalabilidad
es
un
problema
menor
,
aunque
s√≥lo
sea
porque
si
un
dominio
adminis-


trativo
se
hace
demasiado
grande
,
siempre
es
posible
dividirlo
en
dos
sistemas
aut√≥nomos
y


realizar
el
enrutamiento
entre
los
dos
nuevos
sistemas
.
(
Recuerde
que
OSPF
permite
crear
una


jerarqu√≠a
dividiendo
un
sistema
aut√≥nomo
en
√°reas
.
)


‚Ä¢
Rendimiento
.
Puesto
que
el
enrutamiento
entre
sistemas
aut√≥nomos
est√°
muy
orientado
a
las


pol√≠ticas
,
la
calidad
(
por
ejemplo
,
el
rendimiento
)
de
las
rutas
utilizadas
suele
ser
una
cuesti√≥n


secundaria
(
es
decir
,
una
ruta
m√°s
larga
o
m√°s
costosa
que
satisfaga
determinados
criterios


pol√≠ticos
puede
muy
bien
emplearse
antes
que
una
ruta
m√°s
corta
,
pero
que
no
cumpla
dichos


criterios
)
.
De
hecho
,
hemos
visto
que
entre
sistemas
aut√≥nomos
no
existe
ni
siquiera
el
concepto


de
coste
asociado
con
las
rutas
(
salvo
por
el
recuento
de
saltos
entre
sistemas
aut√≥nomos
)
.


Sin
embargo
,
dentro
de
un
sistema
aut√≥nomo
,
tales
cuestiones
pol√≠ticas
tienen
una
importancia


menor
,
lo
que
permite
al
enrutamiento
centrarse
m√°s
en
el
nivel
de
rendimiento
que
se
puede


alcanzar
en
una
ruta
.


PR√ÅCTICA


vez
m√°s
com√∫n
en
la
pr√°ctica
)
.
Sin
embargo
,
al
igual
que
W
e
Y
,
X
tiene
la
caracter√≠sica
de


que
todo
el
tr√°fico
que
entra
/
sale
de
X
tiene
su
origen
/
destino
en
el
propio
X.
Pero
,
¬ø
c√≥mo


se
puede
implementar
el
comportamiento
de
esta
red
terminal
?
¬ø
C√≥mo
se
impedir√°
que
X


reenv√≠e
tr√°fico
entre
B
y
C
?
Esto
se
puede
conseguir
f√°cilmente
controlando
la
forma
en
que


son
anunciadas
las
rutas
BGP
.
En
concreto
,
X
operar√°
como
una
red
terminal
si
anuncia
(
a


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
383sus
vecinos
B
y
C
)
que
no
tiene
ninguna
ruta
a
ning√∫n
otro
destino
excepto
a
ella
misma
.
Es


decir
,
incluso
aunque
X
pueda
conocer
una
determinada
ruta
,
por
ejemplo
XCY
,
para
llegar


a
la
red
Y
,
no
anunciar√°
este
camino
a
B.
Puesto
que
B
no
es
consciente
de
que
X
dispone
de


un
camino
hasta
Y
,
B
nunca
reenviar√°
tr√°fico
destinado
a
Y
(
o
a
C
)
a
trav√©s
de
X.
Este
senci-


llo
ejemplo
ilustra
c√≥mo
se
puede
utilizar
una
pol√≠tica
selectiva
de
anuncio
de
rutas
para


implementar
las
relaciones
de
enrutamiento
cliente
/
proveedor
.


Ac
o
n
t
i
n
u
a
c
i
√≥
n
,
 
v
a
m
o
s
 
a
 
c
e
n
t
r
a
r
n
o
s
 
e
n
 
l
a
 
r
e
d
 
d
e
 
u
n
 
p
r
o
v
e
e
d
o
r
,
 
p
o
r
 
e
j
e
m
p
l
o
,
 
e
n
 
e
l
 
s
i
s
-


tema
aut√≥nomo
B.
Suponga
que
B
ha
aprendido
(
de
A
)
que
A
dispone
del
camino
AW
hacia


W.
B
puede
por
tanto
incluir
la
ruta
BAW
en
su
base
de
informaci√≥n
de
enrutamiento
.
Evi-


dentemente
,
B
tambi√©n
quiere
anunciar
la
ruta
BAW
a
su
cliente
,
X
,
por
lo
que
X
sabe
que


puede
llegar
a
W
a
trav√©s
de
B.
Pero
,
¬ø
deber√≠a
B
anunciar
la
ruta
BAW
a
C
?
Si
lo
hace
,


entonces
C
podr√≠a
enviar
tr√°fico
a
W
a
trav√©s
de
CBAW
.
Si
A
,
B
y
C
son
proveedores
tron-


cales
,
entonces
B
podr√≠a
pensar
,
con
raz√≥n
,
que
no
tendr√≠a
que
asumir
la
carga
(
¬°
y
el
coste
!
)


de
transportar
el
tr√°fico
en
tr√°nsito
entre
A
y
C.
B
puede
pensar
justamente
que
es
el
trabajo


(
¬°
y
el
coste
!
)
de
A
y
C
asegurarse
de
que
C
puede
enrutar
hacia
/
desde
los
clientes
de
A
a


trav√©s
de
una
conexi√≥n
directa
entre
A
y
C.
Actualmente
,
no
existe
ning√∫n
est√°ndar
oficial


que
gobierne
c√≥mo
los
ISP
troncales
deben
llevar
a
cabo
el
enrutamiento
entre
ellos
.
Sin


embargo
,
una
regla
heur√≠stica
seguida
por
los
ISP
comerciales
es
que
cualquier
tr√°fico
que


fluya
a
trav√©s
de
la
red
troncal
de
un
ISP
tiene
que
tener
su
origen
o
su
destino
(
o
ambos
)


en
una
red
que
sea
un
cliente
de
dicho
ISP
;
en
cualquier
otro
caso
,
el
tr√°fico
deber√°
ser


expulsado
de
la
red
del
ISP
.
Los
acuerdos
entre
pares
individuales
(
que
gobernar√≠an
cues-


tiones
como
las
mencionadas
m√°s
arriba
)
normalmente
son
negociados
entre
parejas
de


proveedores
ISP
y
suelen
ser
confidenciales
;
[
Huston
1999a
]
proporciona
una
interesante


informaci√≥n
acerca
de
los
acuerdos
entre
pares
.
Si
desea
ver
una
descripci√≥n
detallada
de


c√≥mo
las
pol√≠ticas
de
enrutamiento
reflejan
las
relaciones
comerciales
entre
los
ISP
,
con-


sulte
[
Gao
2001
;
Dmitiropoulos
2007
]
.
Para
ver
una
descripci√≥n
reciente
de
las
pol√≠ticas
de


enrutamiento
de
BGP
desde
el
punto
de
vista
de
un
ISP
,
consulte
[
Caesar
2005
]
.


Como
hemos
mencionado
anteriormente
,
BGP
es
el
est√°ndar
de
facto
para
el
enruta-


miento
entre
sistemas
aut√≥nomos
de
Internet
.
Para
ver
el
contenido
de
varias
tablas
de
enru-


tamiento
BGP
(
¬°
muy
grandes
!
)
extra√≠das
de
routers
de
los
ISP
de
nivel
1
,
consulte
http://


www.routeviews.org
.
Frecuentemente
,
las
tablas
de
enrutamiento
BGP
contienen
decenas


de
miles
de
prefijos
y
los
atributos
correspondientes
.
Puede
ver
estad√≠sticas
acerca
del


tama√±o
y
las
caracter√≠sticas
de
las
tablas
de
enrutamiento
BGP
en
[
Huston
2001
;
Meng


2005
;
Potaroo
2009
]
.


Con
esto
terminamos
nuestra
breve
introducci√≥n
al
protocolo
BGP
.
Debe
entender
que


BGP
es
importante
porque
desempe√±a
un
papel
central
en
Internet
.
Le
animamos
a
que
con-


sulte
las
siguientes
referencias
[
Griffin
2002
;
Stewart
1999
;
Labovitz
1997
;
Halabi
2000
;


Huitema
1998
;
Gao
2001
;
Feamster
2004
;
Caesar
2005
;
Li
2007
]
,
con
el
fin
de
aprender
m√°s


sobre
BGP
.


4.7
Enrutamiento
por
difusi√≥n
y
por
multidifusi√≥n


Hasta
aqu√≠
nos
hemos
centrado
en
los
protocolos
de
enrutamiento
que
soportan
las
comuni-


caciones
unicast
o
unidifusi√≥n
(
como
,
por
ejemplo
,
las
comunicaciones
punto
a
punto
)
,
en


las
que
un
√∫nico
nodo
de
origen
env√≠a
un
paquete
a
un
√∫nico
nodo
de
destino
.
En
esta
sec-


ci√≥n
,
vamos
a
ocuparnos
de
los
protocolos
de
enrutamiento
por
difusi√≥n
y
por
multidifusi√≥n
.


384
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
384En
el
enrutamiento
por
difusi√≥n
,
la
capa
de
red
proporciona
un
servicio
de
entrega
para
un


paquete
enviado
desde
un
nodo
de
origen
a
todos
los
dem√°s
nodos
de
la
red
;
el


enrutamiento
por
multidifusi√≥n
permite
a
un
√∫nico
nodo
de
origen
enviar
una
copia
de
un


paquete
a
un
subconjunto
de
los
restantes
nodos
de
la
red
.
En
la
Secci√≥n
4.7.1
abordaremos


los
algoritmos
de
enrutamiento
por
difusi√≥n
y
su
plasmaci√≥n
en
los
protocolos
de
enruta-


miento
.
En
la
Secci√≥n
4.7.2
examinaremos
el
enrutamiento
por
multidifusi√≥n
.


4.7.1
Algoritmos
de
enrutamiento
por
difusi√≥n


Quiz√°
la
forma
m√°s
directa
de
llevar
a
cabo
la
comunicaci√≥n
por
difusi√≥n
es
que
el
nodo


emisor
env√≠e
una
copia
distinta
del
paquete
a
cada
destino
,
como
se
muestra
en
la
Figura


4.43(a
)
.
Dados
N
nodos
de
destino
,
el
nodo
de
origen
simplemente
hace
N
copias
del


paquete
,
direcciona
cada
copia
a
un
destino
diferente
y
luego
transmite
las
N
copias
a
los
N


destinos
,
utilizando
el
enrutamiento
por
unidifusi√≥n
.
Este
m√©todo
de
unidifusi√≥n
por
N


v√≠aspara
llevar
a
cabo
la
difusi√≥n
es
simple
:
no
se
necesita
ning√∫n
nuevo
protocolo
de
enru-


tamiento
de
la
capa
de
red
,
ni
una
duplicaci√≥n
de
paquetes
ni
una
funcionalidad
de
reenv√≠o
.


Sin
embargo
,
este
m√©todo
presenta
varios
inconvenientes
.
El
primero
de
ellos
es
su
inefi-


ciencia
.
Si
el
nodo
de
origen
est√°
conectado
al
resto
de
la
red
a
trav√©s
de
un
√∫nico
enlace
,


entonces
N
copias
distintas
del
(
mismo
)
paquete
atravesar√°n
ese
mismo
enlace
.
Evidente-


mente
,
ser√≠a
m√°s
eficiente
enviar
s√≥lo
una
√∫nica
copia
del
paquete
a
trav√©s
del
primer
salto
y


que
luego
el
nodo
que
se
encuentra
en
el
otro
extremo
del
primer
salto
creara
y
reenviara
las


copias
adicionales
necesarias
.
Es
decir
,
ser√≠a
m√°s
eficiente
para
los
propios
nodos
de
la
red


(
en
lugar
de
s√≥lo
para
el
nodo
de
origen
)
crear
copias
duplicadas
de
un
paquete
.
Por
ejem-


plo
,
en
la
Figura
4.43(b
)
s√≥lo
una
√∫nica
copia
de
un
paquete
atraviesa
el
enlace
R1-R2
.
Des-


pu√©s
,
dicho
paquete
se
duplica
en
R2
,
envi√°ndose
una
√∫nica
copia
a
trav√©s
de
los
enlaces


R2-R3
y
R2-R4
.


Los
otros
inconvenientes
de
la
unidifusi√≥n
por
N
v√≠as
quiz√°
son
m√°s
sutiles
,
pero
no


menos
importantes
.
Una
suposici√≥n
impl√≠cita
de
la
unidifusi√≥n
por
N
v√≠as
es
que
los
recep-


tores
del
paquete
de
difusi√≥n
y
sus
direcciones
son
conocidas
por
el
emisor
.
Pero
,
¬ø
como


se
ha
obtenido
esta
informaci√≥n
?
Muy
probablemente
,
ser√°n
necesarios
mecanismos
de
pro-


tocolo
adicionales
(
tales
como
un
protocolo
de
pertenencia
al
dominio
de
difusi√≥n
o
de


registro
de
destinos
)
.
Esto
a√±adir√≠a
m√°s
sobrecarga
y
,
lo
que
es
m√°s
importante
,
una


complejidad
adicional
a
un
protocolo
que
inicialmente
parec√≠a
bastante
simple
.
Un


4.7
‚Ä¢
ENRUTAMIENTO
POR
DIFUSI√ìN
Y
POR
MULTIDIFUSI√ìN
385


Figura
4.43
‚Ä¢
Duplicaci√≥n
en
el
origen
frente
a
duplicaci√≥n
en
la
red
.


Creaci√≥n
/
transmisi√≥n
de
duplicado


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
385√∫ltimo
inconveniente
de
la
unidifusi√≥n
por
N
v√≠as
est√°
relacionado
con
los
prop√≥sitos
por


los
que
se
utiliza
la
difusi√≥n
.
En
la
Secci√≥n
4.5
vimos
que
los
protocolos
de
enrutamiento
de


estado
de
enlaces
utilizan
la
difusi√≥n
para
diseminar
la
informaci√≥n
de
estado
de
los
enlaces


que
se
utiliza
para
calcular
las
rutas
de
unidifusi√≥n
.
Evidentemente
,
en
aquellas
situaciones


en
las
que
se
emplea
la
difusi√≥n
para
crear
y
actualizar
rutas
de
unidifusi√≥n
,
no
ser√≠a
pru-


dente
(
por
decir
algo
)
basarse
en
la
infraestructura
de
enrutamiento
por
unidifusi√≥n
para
con-


seguir
la
comunicaci√≥n
por
difusi√≥n
.


Dados
los
diversos
inconvenientes
de
la
comunicaci√≥n
por
difusi√≥n
utilizando


unidifusi√≥n
por
N
v√≠as
,
est√°
claro
que
ser√°n
interesantes
m√©todos
en
los
que
los
propios


nodos
de
la
red
desempe√±en
un
papel
activo
en
la
duplicaci√≥n
y
el
reenv√≠o
de
los
paquetes
y


en
el
c√°lculo
de
las
rutas
de
difusi√≥n
.
Vamos
a
examinar
algunos
de
estos
m√©todos
y
de


nuevo
adoptaremos
la
notaci√≥n
de
grafos
presentada
en
la
Secci√≥n
4.5
.
Vamos
a
modelar
la


red
como
un
grafo
,
G
=
(
N
,
E
)
,
donde
N
es
un
conjunto
de
nodos
y
E
es
una
colecci√≥n
de


aristas
,
donde
cada
arista
es
un
par
de
nodos
de
N.
Vamos
a
ser
un
poco
permisivos
con
la


notaci√≥n
y
utilizaremos
N
para
hacer
referencia
tanto
al
conjunto
de
nodos
como
a
la
cardi-


nalidad
(
|N|
)
o
tama√±o
de
dicho
conjunto
,
cuando
no
exista
ambig√ºedad
.


Inundaci√≥n
no
controlada


La
t√©cnica
m√°s
obvia
para
llevar
a
cabo
la
difusi√≥n
es
mediante
un
m√©todo
de
inundaci√≥n


(
flooding
)
en
el
que
el
nodo
de
origen
env√≠a
una
copia
del
paquete
a
todos
sus
vecinos
.


Cuando
un
nodo
recibe
un
paquete
de
difusi√≥n
,
lo
duplica
y
lo
reenv√≠a
a
todos
sus
vecinos


(
excepto
al
vecino
del
que
ha
recibido
el
paquete
)
.
Evidentemente
,
si
el
grafo
est√°
conec-


tado
,
este
esquema
permitir√°
terminar
entregando
una
copia
del
paquete
de
difusi√≥n
a
todos


los
nodos
del
grafo
.
Aunque
este
esquema
es
sencillo
y
elegante
,
presenta
un
error
fatal


(
antes
de
leerlo
,
imagine
cu√°l
puede
ser
ese
error
fatal
):
si
el
grafo
presenta
ciclos
,
entonces


una
o
m√°s
copias
de
cada
paquete
de
difusi√≥n
podr√≠a
estar
dando
vueltas
indefinidamente
.


Por
ejemplo
,
en
la
Figura
4.43
,
R2
inundar√°
a
R3
,
R3
inundar√°
a
R4
,
R4
inundar√°
a
R2
y
R2


inundar√°
(
¬°
de
nuevo
!
)
a
R3
,
y
as√≠
sucesivamente
.
Este
sencillo
escenario
da
lugar
a
un
bucle


sin
fin
de
dos
paquetes
de
difusi√≥n
,
uno
en
el
sentido
de
las
agujas
del
reloj
y
otro
en
sentido


contrario
.
Pero
puede
darse
el
caso
de
un
error
a√∫n
m√°s
fatal
:
cuando
un
nodo
est√°
conec-


tado
a
m√°s
de
dos
nodos
,
crear√°
y
reenviar√°
m√∫ltiples
copias
del
paquete
de
difusi√≥n
,
que
a


su
vez
crear√°n
m√∫ltiples
copias
de
s√≠
mismos
(
en
otros
nodos
con
m√°s
de
dos
vecinos
)
,
y
as√≠


sucesivamente
.
Esta
tormenta
de
difusi√≥n
,
que
resulta
de
la
multiplicaci√≥n
sin
fin
de


paquetes
de
difusi√≥n
,
terminar√≠a
creando
tantos
paquetes
de
difusi√≥n
que
la
red
quedar√≠a
inu-


tilizada
.
Consulte
las
cuestiones
de
repaso
al
final
del
cap√≠tulo
para
ver
un
problema
que


analiza
la
velocidad
a
la
que
crece
una
tormenta
de
difusi√≥n
.


Inundaci√≥n
controlada


La
clave
para
evitar
una
tormenta
de
difusi√≥n
es
que
un
nodo
decida
juiciosamente


cu√°ndo
inundar
con
un
paquete
y
cu√°ndo
(
por
ejemplo
,
si
ya
ha
recibido
e
inundado
con


una
copia
anterior
del
paquete
)
no
realizar
tal
inundaci√≥n
.
En
la
pr√°ctica
,
esto
puede


hacerse
de
varias
formas
.


En
la
inundaci√≥n
controlada
por
el
n√∫mero
de
secuencia
,
un
nodo
de
origen
incluye


su
direcci√≥n
(
u
otro
identificador
√∫nico
)
,
as√≠
como
un
n√∫mero
de
secuencia
de
difusi√≥n
en


cada
paquete
de
difusi√≥n
,
y
a
continuaci√≥n
env√≠a
el
paquete
a
todos
sus
vecinos
.
Cada
nodo


mantiene
una
lista
de
la
direcci√≥n
de
origen
y
el
n√∫mero
de
secuencia
de
cada
paquete
de


386
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
386difusi√≥n
que
ya
ha
recibido
,
duplicado
y
reenviado
.
Cuando
un
nodo
recibe
un
paquete


de
difusi√≥n
,
primero
comprueba
si
el
paquete
est√°
en
la
lista
.
Si
lo
est√°
,
el
paquete
se
eli-


mina
;
en
caso
contrario
,
duplica
y
reenv√≠a
el
paquete
a
todos
sus
nodos
vecinos
(
excepto
al


nodo
del
que
acaba
de
recibir
el
paquete
)
.
El
protocolo
Gnutella
utiliza
la
inundaci√≥n
con-


trolada
por
n√∫mero
de
secuencia
para
difundir
las
consultas
de
difusi√≥n
a
lo
largo
de
su
red


solapada
.
(
En
Gnutella
,
la
duplicaci√≥n
y
reenv√≠o
de
mensajes
se
lleva
a
cabo
en
la
capa
de


aplicaci√≥n
en
lugar
de
en
la
capa
de
red
.
)


Un
segundo
m√©todo
de
inundaci√≥n
controlada
es
el
m√©todo
conocido
como
reenv√≠o
por


el
camino
inverso
(
RPF
,
Reverse
Path
Forwarding
)
[
Dalal
1978
]
,
en
ocasiones
tambi√©n


denominado
difusi√≥n
por
el
camino
inverso
(
RPB
,
Reverse
Path
Broadcast
)
.
La
idea
que


subyace
a
RPF
es
simple
,
e
incluso
elegante
.
Cuando
un
router
recibe
un
paquete
de
difu-


si√≥n
con
una
determinada
direcci√≥n
de
origen
,
transmite
el
paquete
a
todos
sus
enlaces
de


salida
(
excepto
al
enlace
por
el
que
ha
sido
recibido
)
s√≥lo
si
el
paquete
ha
llegado
a
trav√©s


del
enlace
que
pertenece
a
su
propia
ruta
de
unidifusi√≥n
m√°s
corta
que
le
conecta
con
el
ori-


gen
.
En
otro
caso
,
el
router
simplemente
descarta
el
paquete
entrante
sin
reenviarlo
a
nin-


guno
de
sus
enlaces
de
salida
.
Dicho
paquete
puede
ser
eliminado
porque
el
router
sabe
que


recibir√°
o
que
ya
ha
recibido
una
copia
de
ese
paquete
a
trav√©s
del
enlace
que
se
encuentra


en
su
propia
ruta
m√°s
corta
que
le
conecta
con
el
emisor
(
puede
comprobar
usted
mismo
que


esto
es
as√≠
y
que
no
se
producir√°n
bucles
ni
tormentas
de
difusi√≥n
.
)
Observe
que
RPF
no
uti-


liza
enrutamiento
de
unidifusi√≥n
para
entregar
realmente
un
paquete
a
un
destino
,
ni
requiere


que
un
router
conozca
la
ruta
completa
m√°s
corta
desde
s√≠
mismo
hasta
el
origen
.
RPF
s√≥lo


necesita
saber
cu√°l
es
el
siguiente
vecino
en
su
ruta
de
unidifusi√≥n
m√°s
corta
hacia
el
emi-


sor
;
utiliza
esta
identidad
del
vecino
s√≥lo
para
determinar
si
debe
inundar
o
no
un
paquete
de


difusi√≥n
recibido
.


La
Figura
4.44
ilustra
RPF
.
Suponga
que
los
enlaces
dibujados
mediante
l√≠neas
gruesas


representan
las
rutas
de
coste
m√≠nimo
desde
los
receptores
al
origen
(
A
)
.
Inicialmente
,
el


nodo
A
difunde
un
paquete
con
origen
en
A
a
los
nodos
C
y
B.
El
nodo
B
reenviar√°
el


paquete
con
origen
en
A
que
ha
recibido
de
A
(
ya
que
A
se
encuentra
en
la
ruta
de
coste


m√≠nimo
hacia
A
)
tanto
a
C
como
a
D.
B
ignorar√°
(
eliminar√°
,
sin
reenviar
)
cualquier
paquete


4.7
‚Ä¢
ENRUTAMIENTO
POR
DIFUSI√ìN
Y
POR
MULTIDIFUSI√ìN
387


Figura
4.44
‚Ä¢
Reenv√≠o
por
el
camino
inverso
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
387cuyo
origen
sea
A
recibido
de
cualquier
otro
nodo
(
por
ejemplo
,
de
los
routers
C
o
D
)
.
Con-


sideremos
ahora
el
nodo
C
,
el
cual
recibe
un
paquete
con
origen
en
A
directamente
de
A
,
as√≠


como
de
B.
Puesto
que
B
no
est√°
en
la
ruta
m√°s
corta
de
C
a
A
,
C
ignorar√°
los
paquetes
con


origen
en
A
recibidos
desde
B.
Por
el
contrario
,
cuando
C
reciba
un
paquete
con
origen
en
A


directamente
desde
A
,
reenviar√°
los
paquetes
a
los
nodos
B
,
E
y
F.


Difusi√≥n
por
√°rbol
de
recubrimiento


Aunque
la
inundaci√≥n
controlada
por
el
n√∫mero
de
secuencia
y
RPF
evitan
las
tormentas
de


difusi√≥n
,
no
evitan
completamente
la
transmisi√≥n
de
paquetes
de
difusi√≥n
redundantes
.
Por


ejemplo
,
en
la
Figura
4.45
,
los
nodos
B
,
C
,
D
,
E
y
F
reciben
uno
o
dos
paquetes
redundantes
.


Idealmente
,
cada
nodo
tendr√≠a
que
recibir
s√≥lo
una
copia
del
paquete
de
difusi√≥n
.
Exami-


nando
el
√°rbol
formado
por
los
nodos
conectados
por
las
l√≠neas
gruesas
de
la
Figura
 
4.45(a
)
,


puede
ver
que
si
los
paquetes
de
difusi√≥n
fueran
reenviados
s√≥lo
por
los
enlaces
de
este
√°rbol
,


todos
y
cada
uno
de
los
nodos
de
la
red
recibir√≠an
exactamente
una
copia
del
paquete
de
difu-


si√≥n
(
y
√©sta
es
exactamente
la
soluci√≥n
que
est√°bamos
buscando
)
.
Este
√°rbol
es
un
ejemplo
de


un
√°rbol
de
recubrimiento
(
spanning
tree
)
(
un
√°rbol
que
contiene
todos
y
cada
uno
de
los


nodos
de
un
grafo
)
.
De
manera
m√°s
formal
,
un
√°rbol
de
recubrimiento
de
un
grafo
G
=
(
N
,
E
)


es
un
grafo
G
/
H11032=
(
N
,
E
/
H11032
)
tal
que
E
/
H11032es
un
subconjunto
de
E
,
G
/
H11032est√°
conectado
,
G
/
H11032no
contiene


ciclos
y
G
/
H11032contiene
todos
los
nodos
originales
de
G.
Si
cada
enlace
tiene
un
coste
asociado
y


el
coste
de
un
√°rbol
es
la
suma
de
los
costes
de
los
enlaces
,
entonces
un
√°rbol
de
recubri-


miento
cuyo
coste
sea
el
m√≠nimo
de
todos
los
√°rboles
de
recubrimiento
del
grafo
se
dice
que


es
(
nada
sorprendentemente
)
un
√°rbol
de
recubrimiento
m√≠nimo
.


Luego
otro
m√©todo
que
permite
la
difusi√≥n
consiste
en
que
los
nodos
de
la
red
constru-


yan
en
primer
lugar
un
√°rbol
de
recubrimiento
.
Cuando
un
nodo
de
origen
desea
enviar
un


paquete
de
difusi√≥n
,
lo
env√≠a
a
trav√©s
de
todos
los
enlaces
incidentes
que
pertenecen
al
√°rbol


de
recubrimiento
.
Un
nodo
que
recibe
un
paquete
de
difusi√≥n
reenv√≠a
entonces
el
paquete
a


todos
sus
vecinos
del
√°rbol
de
recubrimiento
(
excepto
al
vecino
del
que
ha
recibido
el


paquete
)
.
El
√°rbol
de
recubrimiento
no
s√≥lo
elimina
los
paquetes
de
difusi√≥n
redundantes
,


sino
que
una
vez
que
se
ha
definido
,
puede
ser
utilizado
por
cualquier
nodo
para
iniciar
una


difusi√≥n
,
como
se
muestra
en
las
Figuras
4.45(a
)
y
4.45(b
)
.
Observe
que
un
nodo
no
nece-


388
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.45
‚Ä¢
Difusi√≥n
a
lo
largo
de
un
√°rbol
de
recubrimiento
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
388sita
ser
consciente
del
√°rbol
completo
;
simplemente
necesita
saber
cu√°les
de
sus
vecinos
en


G
son
tambi√©n
vecinos
dentro
del
√°rbol
de
recubrimiento
.


La
principal
complejidad
asociada
con
el
m√©todo
del
√°rbol
de
recubrimiento
es
la
crea-


ci√≥n
y
mantenimiento
del
√°rbol
de
recubrimiento
.
Se
han
desarrollado
muchos
algoritmos


distribuidos
de
√°rbol
de
recubrimiento
[
Gallager
1983
,
Gartner
2003
]
.
Aqu√≠
s√≥lo
vamos
a


considerar
un
algoritmo
simple
.
En
el
m√©todo
basado
en
un
nodo
centralpara
construir
un


√°rbol
de
recubrimiento
,
se
define
un
nodo
central
(
conocido
tambi√©n
como
un
punto
de
cita


o
rendezvous
o
n√∫cleo
)
.
A
continuaci√≥n
,
los
nodos
env√≠an
al
nodo
central
mensajes
de
uni-


difusi√≥n
de
uni√≥n
al
√°rbol
.
Los
mensajes
de
uni√≥n
al
√°rbol
se
reenv√≠an
hacia
el
nodo
central
,


utilizando
enrutamiento
por
unidifusi√≥n
,
hasta
que
llegan
a
un
nodo
que
ya
pertenece
al


√°rbol
de
recubrimiento
o
hasta
que
llegan
al
centro
.
En
ambos
casos
,
la
ruta
que
el
mensaje


de
uni√≥n
al
√°rbol
ha
seguido
define
la
rama
del
√°rbol
de
recubrimiento
que
va
desde
el
cen-


tro
hasta
el
nodo
arista
que
inici√≥
el
mensaje
de
uni√≥n
al
√°rbol
.
En
cierto
modo
,
es
como
si


esta
nueva
ruta
hubiera
sido
agregada
al
√°rbol
de
recubrimiento
existente
.


La
Figura
4.46
ilustra
la
construcci√≥n
de
un
√°rbol
de
recubrimiento
basado
en
un
no-


do
central
.
Suponga
que
se
selecciona
el
nodo
E
como
el
centro
del
√°rbol
.
Suponga
que
el


nodo
F
es
el
primero
que
se
une
al
√°rbol
y
reenv√≠a
un
mensaje
de
uni√≥n
al
√°rbol
a
E.
El
√∫nico


enlace
EF
se
convierte
en
el
√°rbol
de
recubrimiento
inicial
.
El
nodo
B
se
une
a
continuaci√≥n
al


√°rbol
de
recubrimiento
enviando
a
E
sus
mensajes
de
uni√≥n
al
√°rbol
.
Suponga
que
la
ruta
de


unidifusi√≥n
a
E
desde
B
es
a
trav√©s
de
D.
En
este
caso
,
el
mensaje
de
uni√≥n
al
√°rbol
da
lugar


a
la
ruta
BDE
que
se
agrega
al
√°rbol
de
recubrimiento
existente
.
A
continuaci√≥n
,
el
nodo
A


se
une
al
grupo
de
recubrimiento
reenviando
su
mensaje
de
uni√≥n
al
√°rbol
hacia
E.
Si
la


ruta
de
unidifusi√≥n
de
A
a
E
es
a
trav√©s
de
B
,
entonces
,
puesto
que
B
ya
est√°
unido
al
√°rbol


de
recubrimiento
,
la
llegada
del
mensaje
de
uni√≥n
al
√°rbol
procedente
de
A
hacia
B
har√°
que


el
enlace
AB
se
a√±ada
de
forma
inmediata
al
√°rbol
de
recubrimiento
.
El
nodo
C
se
une
a
con-


tinuaci√≥n
al
√°rbol
de
recubrimiento
reenviando
su
mensaje
de
uni√≥n
al
√°rbol
directamente
a


E.
Finalmente
,
dado
que
el
enrutamiento
por
unidifusi√≥n
de
G
a
E
tiene
que
hacerse
a
trav√©s


de
D
,
cuando
G
env√≠a
a
E
su
mensaje
de
uni√≥n
al
√°rbol
,
se
inserta
el
enlace
GD
en
el
√°rbol


de
recubrimiento
,
a
la
altura
del
nodo
D.


4.7
‚Ä¢
ENRUTAMIENTO
POR
DIFUSI√ìN
Y
POR
MULTIDIFUSI√ìN
389


Figura
4.46
‚Ä¢
Construcci√≥n
de
un
√°rbol
de
recubrimiento
basada


en
un
nodo
central
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
389Algoritmos
de
difusi√≥n
en
la
pr√°ctica


Los
protocolos
de
difusi√≥n
se
utilizan
en
la
pr√°ctica
tanto
en
la
capa
de
aplicaci√≥n
como
en


la
de
red
.
Gnutella
[
Gnutella
2009
]
utiliza
la
difusi√≥n
en
el
nivel
de
aplicaci√≥n
para
difundir


consultas
de
contenido
entre
los
pares
Gnutella
.
Aqu√≠
,
cada
enlace
entre
dos
pares
de
proce-


sos
distribuidos
de
nivel
de
aplicaci√≥n
dentro
de
la
red
Gnutella
es
realmente
una
conexi√≥n


TCP
.
Gnutella
utiliza
una
forma
de
inundaci√≥n
controlada
por
n√∫mero
de
secuencia
en
la


que
se
emplean
un
identificador
de
16
bits
y
un
descriptor
de
carga
√∫til
de
16
bits
(
que
iden-


tifica
el
tipo
de
mensaje
de
Gnutella
)
para
detectar
si
una
consulta
de
difusi√≥n
recibida
ha


sido
recibida
,
duplicada
y
reenviada
anteriormente
.
Gnutella
tambi√©n
emplea
un
campo
para


establecer
el
tiempo
de
vida
(
TTL
,
Time-To-Live
)
con
el
fin
de
limitar
el
n√∫mero
de
saltos
a


trav√©s
de
los
que
ser√°
reenviada
una
consulta
por
inundaci√≥n
.
Cuando
un
proceso
Gnutella


recibe
y
duplica
una
consulta
,
decrementa
el
campo
TTL
antes
de
reenviar
la
consulta
.
Por


tanto
,
una
consulta
Gnutella
por
inundaci√≥n
s√≥lo
alcanzar√°
a
aquellos
pares
que
est√©n
a
un


n√∫mero
dado
(
el
valor
inicial
de
TTL
)
de
saltos
(
en
el
nivel
de
aplicaci√≥n
)
con
respecto
al


iniciador
de
la
consulta
.
El
mecanismo
de
inundaci√≥n
de
Gnutella
se
denomina
a
veces


inundaci√≥n
de
√°mbito
limitado
.


Tambi√©n
se
utiliza
una
forma
de
inundaci√≥n
controlada
por
el
n√∫mero
de
secuencia
para


difundir
los
anuncios
de
estado
de
enlaces
(
LSA
,
Link-State
Advertisements
)
en
el
algoritmo


de
enrutamiento
OSPF
[
RFC
2328
,
Perlman
1999
]
y
en
el
algoritmo
de
enrutamiento
de
sis-


tema
intermedio
a
sistema
intermedio
(
IS-IS
,
Intermediate-System-to-Intermediate-System
)


[
RFC
1142
,
Perlman
1999
]
.
OSPF
utiliza
un
n√∫mero
de
secuencia
de
32
bits
as√≠
como
un


campo
de
antig√ºedad
de
16
bits
para
identificar
los
anuncios
LSA
.
Recuerde
que
un
nodo


OSPF
utiliza
la
comunicaci√≥n
por
difusi√≥n
para
enviar
peri√≥dicamente
los
LSA
a
sus
enla-


ces
conectados
,
cuando
el
coste
de
un
enlace
a
un
vecino
cambia
o
cuando
un
enlace
pasa
al


estado
activo
o
inactivo
.
Los
n√∫meros
de
secuencia
de
los
LSA
se
emplean
para
detectar


anuncios
LSA
duplicados
,
pero
tambi√©n
sirven
a
una
segunda
funci√≥n
importante
en
OSPF
.


Con
la
inundaci√≥n
,
es
posible
que
un
LSA
generado
por
el
origen
en
el
instante
t
llegue


despu√©s
que
un
LSA
m√°s
reciente
que
haya
sido
generado
por
el
mismo
origen
en
el
instante


t
+
 
.
Los
n√∫meros
de
secuencia
utilizados
por
el
nodo
de
origen
permiten
diferenciar
un


LSA
m√°s
antiguo
de
un
LSA
m√°s
reciente
.
El
campo
antig√ºedad
sirve
para
un
prop√≥sito


similar
al
que
sirve
un
valor
de
TTL
.
El
valor
inicial
del
campo
antig√ºedad
se
pone
a
cero
y


se
incrementa
en
cada
salto
a
medida
que
tiene
lugar
la
inundaci√≥n
y
tambi√©n
se
incrementa


mientras
se
encuentra
retenido
en
la
memoria
de
un
router
,
esperando
a
ser
reenviado
.
Aun-


que
aqu√≠
hemos
descrito
brevemente
el
algoritmo
de
inundaci√≥n
de
los
LSA
,
de
hecho
el


dise√±o
de
los
protocolos
de
difusi√≥n
LSA
puede
resultar
muy
complicado
.
[
RFC
789
;
Perl-


man
1999
]
describen
un
incidente
en
el
que
los
anuncios
LSA
incorrectamente
transmitidos


por
dos
routers
que
funcionaban
mal
dieron
lugar
a
que
una
versi√≥n
temprana
de
un
algo-


ritmo
de
inundaci√≥n
de
anuncios
LSA
provocara
la
ca√≠da
de
toda
la
red
ARPAnet
.


4.7.2
Multidifusi√≥n


Hemos
visto
en
la
secci√≥n
anterior
que
con
un
servicio
de
difusi√≥n
los
paquetes
son
sumi-


nistrados
a
todos
y
cada
uno
de
los
nodos
de
la
red
.
En
esta
secci√≥n
vamos
a
ocuparnos
del


servicio
de
multidifusi√≥n
(
multicast
)
,
en
el
que
un
paquete
de
multidifusi√≥n
se
entrega
a


s√≥lo
un
subconjunto
de
los
nodos
de
la
red
.
Una
serie
de
aplicaciones
de
red
emergentes


requiere
la
entrega
de
paquetes
procedentes
de
uno
o
m√°s
emisores
a
un
grupo
de
recepto-


390
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
390res
.
Estas
aplicaciones
incluyen
la
transferencia
masiva
de
datos
(
por
ejemplo
,
la
transferen-


cia
de
una
actualizaci√≥n
software
desde
el
desarrollador
a
los
usuarios
que
precisan
esa


actualizaci√≥n
)
,
los
flujos
multimedia
continuos
(
por
ejemplo
,
la
transferencia
de
audio
,


v√≠deo
y
texto
de
una
conferencia
en
vivo
a
un
conjunto
de
participantes
en
la
conferencia


geogr√°ficamente
distribuidos
)
,
las
aplicaciones
de
datos
compartidos
(
como
una
aplicaci√≥n


de
teleconferencia
o
de
pizarra
electr√≥nica
que
se
comparte
entre
muchos
participantes


distribuidos
)
,
los
alimentadores
de
datos
(
por
ejemplo
,
las
cotizaciones
de
bolsa
)
,
las
actua-


lizaciones
de
cach√©
Web
y
los
juegos
interactivos
(
por
ejemplo
,
los
entornos
virtuales
inte-


ractivos
distribuidos
o
los
juegos
multijugador
)
.


En
la
mutlidifusi√≥n
,
nos
enfrentamos
a
dos
problemas
:
c√≥mo
identificar
a
los
receptores


de
un
paquete
de
multidifusi√≥n
y
c√≥mo
dirigir
un
paquete
enviado
a
esos
receptores
.
En
el


caso
de
la
unidifusi√≥n
,
la
direcci√≥n
IP
del
receptor
(
el
destino
)
se
transporta
en
cada
data-


grama
IP
de
unidifusi√≥n
e
identifica
a
un
√∫nico
receptor
;
en
el
caso
de
la
comunicaci√≥n
por


difusi√≥n
,
todos
los
nodos
tienen
que
recibir
el
paquete
de
difusi√≥n
,
por
lo
que
no
se
necesita


ninguna
direcci√≥n
de
destino
.
Pero
en
el
caso
de
la
multidifusi√≥n
,
tenemos
varios
receptores
.


¬ø
Tiene
sentido
que
cada
paquete
de
multidifusi√≥n
transporte
las
direcciones
IP
de
todos
esos


receptores
?
Aunque
este
m√©todo
podr√≠a
ser
adecuado
para
un
n√∫mero
peque√±o
de
recep-


tores
,
no
se
escalar√≠a
bien
para
el
caso
de
cientos
o
miles
de
receptores
;
la
cantidad
de


informaci√≥n
de
direccionamiento
incluida
en
el
datagrama
eclipsar√≠a
a
los
datos
reales
trans-


portados
en
el
campo
de
carga
√∫til
del
paquete
.
Que
el
emisor
haga
una
identificaci√≥n
expl√≠-


cita
de
los
receptores
tambi√©n
requiere
que
conozca
las
identidades
y
direcciones
de
todos


los
receptores
.
Veremos
en
breve
que
existen
casos
en
los
que
este
requisito
puede
no
ser


deseable
.


Por
estas
razones
,
en
la
arquitectura
de
Internet
(
y
en
otras
arquitecturas
como
ATM


[
Black
1995
]
)
,
un
paquete
de
multidifusi√≥n
se
direcciona
utilizando
la
indirecci√≥n
de
direc-


ciones
.
Es
decir
,
se
utiliza
un
√∫nico
identificador
para
el
grupo
de
receptores
y
a
cada
uno
de


los
receptores
multidifusi√≥n
asociados
con
dicho
grupo
se
le
entrega
una
copia
del
paquete


que
se
ha
dirigido
al
grupo
utilizando
ese
identificador
.
En
Internet
,
el
identificador
√∫nico


que
representa
a
un
grupo
de
receptores
es
una
direcci√≥n
IP
de
multidifusi√≥n
de
clase
D.
El


grupo
de
receptores
asociados
con
una
direcci√≥n
de
clase
D
se
conoce
como
grupo
de
mul-


tidifusi√≥n
.
La
abstracci√≥n
de
grupo
de
multidifusi√≥n
se
ilustra
en
la
Figura
4.47
.
En
este


ejemplo
,
cuatro
hosts
(
de
los
que
entran
y
salen
las
flechas
)
est√°n
asociados
con
la
direcci√≥n


del
grupo
de
multidifusi√≥n
226.17.30.197
y
recibir√°n
todos
los
datagramas
dirigidos
a
esa


direcci√≥n
de
multidifusi√≥n
.
La
dificultad
que
todav√≠a
tenemos
que
superar
es
que
cada
host


tiene
una
direcci√≥n
IP
de
unidifusi√≥n
√∫nica
que
es
completamente
independiente
de
la
direc-


ci√≥n
del
grupo
de
multidifusi√≥n
en
el
que
participa
.


Aunque
la
abstracci√≥n
de
grupo
de
multidifusi√≥n
es
simple
,
plantea
un
mont√≥n
de
pre-


guntas
.
¬ø
C√≥mo
se
inicia
y
se
termina
un
grupo
?
¬ø
C√≥mo
se
elige
la
direcci√≥n
de
grupo
?


¬ø
C√≥mo
se
a√±aden
nuevos
hosts
al
grupo
(
sean
emisores
o
receptores
)
?
¬ø
Puede
alguien
unirse


a
un
grupo
(
y
enviar
al
grupo
y
recibir
del
grupo
)
o
la
pertenencia
al
grupo
est√°
restringida
,


y
si
lo
est√°
,
qui√©n
la
restringe
?
¬ø
Conocen
los
miembros
del
grupo
las
identidades
de
los
otros


miembros
del
grupo
como
parte
del
protocolo
de
la
capa
de
red
?
¬ø
C√≥mo
interoperan
los


nodos
de
la
red
entre
s√≠
para
entregar
un
datagrama
de
multidifusi√≥n
a
todos
los
miembros


del
grupo
?
En
Internet
,
las
respuestas
a
todas
estas
preguntas
implican
al
Protocolo
de
ges-


ti√≥n
de
grupos
de
Internet
(
IGMP
,
Internet
Group
Management
Protocol
)
[
RFC
3376
]
.
Por


tanto
,
a
continuaci√≥n
vamos
a
ver
brevemente
el
protocolo
IGMP
y
luego
volveremos
sobre


todas
estas
preguntas
.


4.7
‚Ä¢
ENRUTAMIENTO
POR
DIFUSI√ìN
Y
POR
MULTIDIFUSI√ìN
391


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
391Protocolo
de
gesti√≥n
de
grupos
de
Internet
(
IGMP
)


La
versi√≥n
3
del
protocolo
IGMP
[
RFC
3376
]
opera
entre
un
host
y
su
router
directamente


conectado
(
informalmente
,
podemos
pensar
en
el
router
directamente
conectado
como
en
el


router
del
primer
salto
que
un
host
ver√≠a
en
una
ruta
hacia
cualquier
host
que
se
encuentra


fuera
de
su
propia
red
local
,
o
el
router
del
√∫ltimo
salto
en
cualquier
ruta
a
dicho
host
)
,
como


se
muestra
en
la
Figura
4.48
.
La
Figura
4.48
muestra
tres
routers
multidifusi√≥n
de
primer


salto
,
cada
uno
de
ellos
conectado
a
sus
hosts
a
trav√©s
de
una
interfaz
local
de
salida
.
En
este


ejemplo
,
esta
interfaz
local
est√°
conectada
a
una
LAN
,
y
aunque
cada
LAN
tiene
varios


hosts
conectados
,
normalmente
como
m√°ximo
s√≥lo
unos
pocos
de
estos
hosts
pertenecer√°n
a


un
grupo
de
multidifusi√≥n
dado
en
cualquier
instante
determinado
.


IGMP
proporciona
los
medios
a
un
host
para
informar
a
su
router
conectado
de
que
una


aplicaci√≥n
que
se
ejecuta
en
el
host
desea
unirse
a
un
grupo
de
multidifusi√≥n
especificado
.


Puesto
que
el
√°mbito
de
la
interacci√≥n
IGMP
est√°
limitado
a
un
host
y
al
router
al
que
est√°


conectado
,
est√°
claro
que
se
requiere
otro
protocolo
para
coordinar
a
los
routers
multidifu-


si√≥n
(
incluyendo
a
los
routers
conectados
)
a
trav√©s
de
Internet
,
con
el
fin
de
enrutar
los
data-


gramas
de
multidifusi√≥n
hacia
sus
destinos
finales
.
Esta
√∫ltima
funcionalidad
se
consigue


mediante
algoritmos
de
enrutamiento
por
multidifusi√≥n
de
la
capa
de
red
,
tales
como
los
que


392
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.47
‚Ä¢
Grupo
de
multidifusi√≥n
:
un
datagrama
dirigido
al
grupo
se
entre-


ga
a
todos
los
miembros
del
grupo
de
multidifusi√≥n
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
392veremos
a
continuaci√≥n
.
Por
tanto
,
la
multidifusi√≥n
de
la
capa
de
red
en
Internet
tiene
dos


componentes
complementarios
:
IGMP
y
los
protocolos
de
enrutamiento
por
multidifusi√≥n
.


IGMP
s√≥lo
dispone
de
tres
tipos
de
mensajes
.
Al
igual
que
ICMP
,
los
mensajes
IGMP


son
transportados
(
encapsulados
)
dentro
de
un
datagrama
IP
,
con
un
n√∫mero
de
protocolo


IP
de
2
.
El
mensaje
membership_query
lo
env√≠a
un
router
a
todos
los
hosts
situados
en


una
interfaz
conectada
(
por
ejemplo
,
a
todos
los
hosts
de
una
red
de
√°rea
local
)
para
deter-


minar
el
conjunto
de
todos
los
grupos
de
multidifusi√≥n
a
los
que
han
unido
los
hosts
conec-


tados
a
trav√©s
de
dicha
interfaz
.
Los
hosts
responden
a
un
mensaje
membership_querycon


un
mensaje
IGMP
membership_report
.
Un
host
tambi√©n
puede
generar
mensajes
mem-


bership_report
cuando
una
aplicaci√≥n
se
une
por
primera
vez
a
un
grupo
de
multidifu-


si√≥n
sin
esperar
a
un
mensaje
membership_query
procedente
del
router
.
El
√∫ltimo
tipo
de


mensaje
IGMP
es
el
mensaje
leave_group
.
Curiosamente
,
este
mensaje
es
opcional
.
Pero


aunque
sea
opcional
,
¬ø
c√≥mo
detecta
un
router
cu√°ndo
un
host
abandona
el
grupo
de
multidi-


fusi√≥n
?
La
respuesta
a
esta
pregunta
es
que
el
router
infiere
que
un
host
ya
no
est√°
en
el


grupo
de
multidifusi√≥n
si
no
responde
a
un
mensaje
membership_query
con
la
direcci√≥n


de
un
determinado
grupo
.
Esto
es
un
ejemplo
de
lo
que
en
ocasiones
se
denomina
estado


fr√°gil
(
soft-state
)
en
un
protocolo
de
Internet
.
En
un
protocolo
de
estado
fr√°gil
,
el
estado


(
en
nuestro
caso
de
IGMP
,
el
hecho
de
que
existan
hosts
unidos
a
un
determinado
grupo
de


multidifusi√≥n
)
desaparece
debido
a
un
suceso
de
fin
de
temporizaci√≥n
(
en
este
caso
,


mediante
un
mensaje
membership_query
peri√≥dico
del
router
)
si
no
se
refresca
expl√≠cita-


mente
(
en
este
caso
,
mediante
un
mensaje
membership_report
procedente
de
un
host


conectado
)
.
Hay
quien
dice
que
los
protocolos
de
estado
fr√°gil
proporcionan
un
control
m√°s


simple
que
los
protocolos
de
estado
firme
(
hard-state
)
,
que
no
s√≥lo
requieren
que
el
estado


sea
expl√≠citamente
a√±adido
y
eliminado
,
sino
que
tambi√©n
necesitan
mecanismos
para
recu-


perarse
de
la
situaci√≥n
en
la
que
la
entidad
responsable
de
eliminar
el
estado
haya
terminado


de
forma
prematura
o
ha
fallado
.
Puede
encontrar
una
interesante
exposici√≥n
sobre
el
tema


del
estado
fr√°gil
en
[
Raman
1999
;
Ji
2003
;
Lui
2004
]
.


4.7
‚Ä¢
ENRUTAMIENTO
POR
DIFUSI√ìN
Y
POR
MULTIDIFUSI√ìN
393


Figura
4.48
‚Ä¢
Los
dos
componentes
de
la
multidifusi√≥n
de
la
capa
de
red
en


Internet
:
IGMP
y
los
protocolos
de
enrutamiento
por
multidifusi√≥n
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
393Algoritmo
de
enrutamiento
por
multidifusi√≥n


En
la
Figura
4.49
se
ilustra
el
problema
del
enrutamiento
por
multidifusi√≥n
.
Los
hosts


unidos
al
grupo
de
multidifusi√≥n
est√°n
bordeados
en
negro
,
as√≠
como
su
router
inmediata-


mente
conectado
.
Como
se
muestra
en
la
Figura
4.49
,
s√≥lo
un
subconjunto
de
routers
(
aque-


llos
con
hosts
conectados
que
est√°n
unidos
al
grupo
de
multidifusi√≥n
)
necesita
realmente


recibir
el
tr√°fico
multidifusi√≥n
.
En
la
Figura
4.49
,
s√≥lo
los
routers
A
,
B
,
E
y
F
tienen
que
reci-


bir
el
tr√°fico
de
multidifusi√≥n
.
Dado
que
ninguno
de
los
hosts
conectados
al
router
D
est√°


unido
al
grupo
de
multidifusi√≥n
y
puesto
que
el
router
C
no
tiene
hosts
conectados
,
ni
C
ni


D
necesitan
recibir
el
tr√°fico
del
grupo
de
multidifusi√≥n
.
El
objetivo
del
enrutamiento
por


mutlidifusi√≥n
es
,
por
tanto
,
encontrar
un
√°rbol
de
enlaces
que
conecte
todos
los
routers
que


tienen
hosts
conectados
que
pertenecen
al
grupo
de
multidifusi√≥n
.
Los
paquetes
de
multidi-


fusi√≥n
entonces
ser√°n
enrutados
a
lo
largo
de
este
√°rbol
desde
el
emisor
a
todos
los
hosts
que


pertenecen
al
√°rbol
de
multidifusi√≥n
.
Por
supuesto
,
el
√°rbol
puede
contener
routers
que
no


tengan
hosts
conectados
que
pertenezcan
al
grupo
de
multidifusi√≥n
(
por
ejemplo
,
en
la


Figura
4.49
es
imposible
conectar
los
routers
A
,
B
,
E
y
F
en
un
√°rbol
sin
implicar
bien
al
rou-


ter
C
o
al
router
D
)
.


En
la
pr√°ctica
,
se
han
adoptado
dos
m√©todos
para
determinar
el
√°rbol
de
enrutamiento


por
multidifusi√≥n
,
que
ya
hemos
estudiado
en
el
contexto
del
enrutamiento
por
difusi√≥n
y
,


por
tanto
,
aqu√≠
s√≥lo
lo
vamos
a
mencionar
de
pasada
.
Los
dos
m√©todos
difieren
dependiendo


de
si
se
utiliza
un
√∫nico
√°rbol
compartido
por
el
grupo
para
distribuir
el
tr√°fico
a
todos
los


emisores
del
grupo
,
o
si
se
construye
un
√°rbol
de
enrutamiento
espec√≠fico
del
origen
para


cada
emisor
individual
.


394
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


Figura
4.49
‚Ä¢
Hosts
multidifusi√≥n
,
sus
routers
conectados
y
otros
routers
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
394‚Ä¢
Enrutamiento
por
multidifusi√≥n
que
utiliza
un
√°rbol
compartido
por
el
grupo
.
Como
en


el
caso
de
la
difusi√≥n
mediante
√°rbol
de
recubrimiento
,
el
enrutamiento
por
multidifusi√≥n


sobre
un
√°rbol
compartido
por
el
grupo
est√°
basado
en
la
construcci√≥n
de
un
√°rbol
que


incluye
a
todos
los
routers
de
frontera
con
hosts
conectados
que
pertenecen
al
grupo
 
de


multidifusi√≥n
.
En
la
pr√°ctica
,
se
utiliza
el
m√©todo
basado
en
un
nodo
central
para


construir
el
√°rbol
de
enrutamiento
por
multidifusi√≥n
,
encarg√°ndose
aquellos
routers


de
frontera
que
tienen
hosts
conectados
pertenecientes
al
grupo
de
multidifusi√≥n
de


enviar
(
v√≠a
unidifusi√≥n
)
mensajes
de
uni√≥n
al
√°rbol
dirigidos
al
nodo
central
.
Como
en
el


caso
de
la
difusi√≥n
,
un
mensaje
de
uni√≥n
se
reenv√≠a
utilizando
el
enrutamiento
por
unidi-


fusi√≥n
hacia
el
nodo
central
,
hasta
que
o
bien
llega
a
un
router
que
ya
pertenece
al
√°rbol


de
multidifusi√≥n
o
bien
llega
al
nodo
central
.
Todos
los
routers
existentes
a
lo
largo
de


la
ruta
que
sigue
el
mensaje
de
uni√≥n
reenviar√°n
entonces
los
paquetes
de
multidifu-


si√≥n
recibidos
al
router
de
frontera
que
inici√≥
la
uni√≥n
al
grupo
de
multidifusi√≥n
.
Una


cuesti√≥n
cr√≠tica
en
el
enrutamiento
por
multidifusi√≥n
mediante
√°rbol
basado
en
un
nodo


central
es
el
proceso
utilizado
para
seleccionar
el
nodo
central
.
Puede
ver
una
serie
de


algoritmos
de
selecci√≥n
del
nodo
central
en
[
Wall
1980
;
Thaler
1997
;
Estrin
1997
]
.


‚Ä¢
Enrutamiento
por
multidifusi√≥n
utilizando
un
√°rbol
basado
en
el
origen
.
Mientras
que
el


enrutamiento
por
multidifusi√≥n
basado
en
√°rbol
compartido
por
el
grupo
construye
un


√∫nico
√°rbol
de
enrutamiento
compartido
para
enrutar
los
paquetes
de
todos
los
emisores
,


el
segundo
m√©todo
construye
un
√°rbol
de
enrutamiento
por
multidifusi√≥n
para
cada
ori-


gen
existente
en
el
grupo
multidifusi√≥n
.
En
la
pr√°ctica
,
se
utiliza
un
algoritmo
RPF
(
con


x
como
nodo
de
origen
)
para
construir
un
√°rbol
de
reenv√≠o
por
multidifusi√≥n
para
los


4.7
‚Ä¢
ENRUTAMIENTO
POR
DIFUSI√ìN
Y
POR
MULTIDIFUSI√ìN
395


Figura
4.50
‚Ä¢
Reenv√≠o
de
camino
inverso
para
el
caso
de
multidifusi√≥n
.


paquete
ser√°
reenviado


paquete
no
reenviado
m√°s
all√°
del
router
receptor


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
395datagramas
de
multidifusi√≥n
que
tienen
su
origen
en
x.
El
algoritmo
RPF
de
difusi√≥n
que


hemos
estudiado
anteriormente
requiere
ciertos
ajustes
para
utilizarlo
en
multidifusi√≥n
.


Veamos
por
qu√©
.
Considere
el
router
D
de
la
Figura
4.50
.
Con
el
algoritmo
RPF
de
difu-


si√≥n
,
los
paquetes
se
reenviar√≠an
al
router
G
,
incluso
aunque
el
router
G
no
tenga
hosts


conectados
que
est√©n
unidos
al
grupo
de
multidifusi√≥n
.
Aunque
esto
no
es
tan
malo
para


este
caso
en
que
s√≥lo
hay
un
router
(
G
)
por
debajo
de
D
,
imagine
lo
que
ocurrir√≠a
si
D


tuviera
miles
de
routers
colgando
de
√©l
en
el
√°rbol
.
Cada
uno
de
esos
miles
de
routers


recibir√≠a
paquetes
de
multidifusi√≥n
no
deseados
.
(
Este
escenario
no
es
tan
inveros√≠mil


como
pueda
parecer
.
La
MBone
inicial
[
Casner
1992
;
Macedonia
1994
]
,
la
primera
red


de
multidifusi√≥n
global
,
sufri√≥
precisamente
este
problema
en
sus
inicios
.
)
La
soluci√≥n
al


problema
de
la
recepci√≥n
de
paquetes
de
multidifusi√≥n
no
deseados
con
RPF
se
conoce


con
el
nombre
de
poda
(
pruning
)
.
Un
router
multidifusi√≥n
que
recibe
paquetes
de
multi-


difusi√≥n
y
que
no
tiene
hosts
conectados
unidos
a
dicho
grupo
enviar√°
un
mensaje
de


poda
a
su
router
inmediatamente
anterior
.
Si
un
router
recibe
mensajes
de
poda
proce-


dentes
de
cada
uno
de
los
routers
situados
por
debajo
,
puede
entonces
reenviar
hacia


arriba
un
mensaje
de
poda
.


Enrutamiento
por
multidifusi√≥n
en
Internet


El
primer
protocolo
de
enrutamiento
por
multidifusi√≥n
utilizado
en
Internet
fue
el
Protocolo


de
enrutamiento
por
multidifusi√≥n
por
vector
de
distancias
(
DVMRP
,
Distance-Vector


Multicast
Routing
Protocol
)
[
RFC
1075
]
.
DVMRP
implementa
√°rboles
basados
en
el
ori-


gen
,
con
reenv√≠o
de
camino
inverso
y
poda
.
DVMRP
utiliza
un
algoritmo
RPF
con
poda
,


como
hemos
visto
anteriormente
.
Quiz√°
el
protocolo
de
enrutamiento
por
multidifusi√≥n
de


Internet
m√°s
ampliamente
utilizado
sea
el
protocolo
de
enrutamiento
PIM
(
Protocol-Inde-


pendent
Multicast
,
Multidifusi√≥n
independiente
del
protocolo
)
,
que
reconoce
de
forma


expl√≠cita
dos
escenarios
de
distribuci√≥n
multidifusi√≥n
.
En
el
modo
denso
[
RFC
3973
]
,
los


miembros
del
grupo
de
multidifusi√≥n
est√°n
localizados
de
forma
densa
,
es
decir
,
muchos
o


la
mayor√≠a
de
los
routers
del
√°rea
necesitan
involucrarse
en
el
enrutamiento
de
los
datagra-


mas
de
multidifusi√≥n
.
El
modo
denso
del
protocolo
PIM
es
una
t√©cnica
de
reenv√≠o
de
camino


inverso
con
inundaci√≥n
y
poda
,
similar
en
esp√≠ritu
a
DVMRP
.


En
el
modo
disperso
[
RFC
4601
]
,
el
n√∫mero
de
routers
con
miembros
del
grupo
conec-


tados
es
menor
con
respecto
al
n√∫mero
total
de
routers
;
los
miembros
del
grupo
est√°n
tre-


mendamente
dispersos
.
El
modo
disperso
de
PIM
utiliza
puntos
de
cita
para
configurar
el


√°rbol
de
distribuci√≥n
de
multidifusi√≥n
.
En
la
multidifusi√≥n
espec√≠fica
del
origen
(
SSM
,


Source-Specific
Multicast
)
[
RFC
3569
,
RFC
4607
]
,
s√≥lo
un
emisor
puede
enviar
tr√°fico
al


√°rbol
de
multidifusi√≥n
,
simplificando
considerablemente
la
construcci√≥n
y
el
manteni-


miento
del
√°rbol
.


Cuando
se
emplean
los
protocolos
PIM
y
DVMP
dentro
de
un
dominio
,
el
operador
de


la
red
puede
configurar
routers
multidifusi√≥n
IP
dentro
del
dominio
,
de
la
misma
forma
que


pueden
configurarse
protocolos
de
enrutamiento
por
unidifusi√≥n
internos
al
dominio
,
como


RIP
,
IS-IS
y
OSPF
.
Pero
,
¬ø
qu√©
ocurre
cuando
se
necesitan
rutas
de
multidifusi√≥n
entre
los


distintos
dominios
?
 
¬ø
Existe
un
equivalente
multidifusi√≥n
del
protocolo
BGP
entre
domi-


nios
?
La
respuesta
es
(
literalmente
)
s√≠
.
[
RFC
4271
]
define
extensiones
multiprotocolo
a
BGP


para
permitirle
transportar
informaci√≥n
de
enrutamiento
para
otros
protocolos
,
incluyendo


informaci√≥n
de
multidifusi√≥n
.
El
Protocolo
de
descubrimiento
de
origen
de
multidifusi√≥n


(
MSDP
,
Multicast
Source
Discovery
Protocol
)
[
RFC
3618
,
RFC
4611
]
se
puede
utilizar
para


conectar
puntos
de
cita
situados
en
diferentes
dominios
PIM
en
modo
disperso
.
Puede


396
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
396encontrar
una
excelente
introducci√≥n
al
estado
actual
del
enrutamiento
por
multidifusi√≥n
en


Internet
en
[
RFC
5110
]
.


Terminamos
esta
exposici√≥n
indicando
que
a
la
comunicaci√≥n
IP
por
multidifusi√≥n


todav√≠a
le
queda
un
largo
camino
por
recorrer
.
Si
desea
ver
una
interesante
exposici√≥n


acerca
de
los
problemas
de
implantaci√≥n
y
del
modelo
de
servicio
de
multidifusi√≥n
de
Inter-


net
actual
,
consulte
[
Diot
2000
,
Sharma
2003
]
.
No
obstante
,
a
pesar
de
la
falta
de
una
amplia


implantaci√≥n
,
la
tecnolog√≠a
de
multidifusi√≥n
de
nivel
de
red
no
est√°
‚Äú
muerta
‚Äù
en
absoluto
.


El
tr√°fico
de
multidifusi√≥n
ha
estado
siendo
transportado
durante
muchos
a√±os
sobre
Inter-


net
2
y
sobre
las
redes
equivalentes
a
ella
[
Internet2
Multicast
2009
]
.
En
el
Reino
Unido
,
la


BBC
participa
en
pruebas
de
distribuci√≥n
de
contenido
mediante
IP
multidifusi√≥n
[
BBC


Multicast
2009
]
.
Al
mismo
tiempo
,
la
multidifusi√≥n
en
el
nivel
de
aplicaci√≥n
,
como
hemos


visto
con
PPLive
en
el
Cap√≠tulo
2
y
en
otros
sistemas
entre
pares
como
End
System
Multi-


cast
[
ESM
2007
]
,
proporcionan
distribuci√≥n
por
multidifusi√≥n
de
contenido
entre
pares
uti-


lizando
protocolos
de
multidifusi√≥n
de
la
capa
de
aplicaci√≥n
(
en
lugar
de
protocolos
de


multidifusi√≥n
de
la
capa
de
red
)
.
¬ø
Los
servicios
de
multidifusi√≥n
futuros
se
implementar√°n


principalmente
en
la
capa
de
red
(
en
el
n√∫cleo
de
la
red
)
o
en
la
capa
de
aplicaci√≥n
(
en
la


frontera
de
la
red
)
?
Aunque
el
entusiasmo
actual
por
la
distribuci√≥n
de
contenido
utilizando


protocolos
de
comunicaci√≥n
entre
pares
parece
inclinar
la
balanza
en
favor
de
las
t√©cnicas


de
multidifusi√≥n
de
la
capa
de
aplicaci√≥n
,
al
menos
durante
el
futuro
m√°s
cercano
,
contin√∫an


realiz√°ndose
avances
en
la
tecnolog√≠a
de
multidifusi√≥n
IP
y
,
en
ocasiones
,
las
carreras
las


ganan
los
que
son
m√°s
lentos
,
pero
m√°s
constantes
.


4.8
Resumen


En
este
cap√≠tulo
hemos
iniciado
nuestro
viaje
al
n√∫cleo
de
la
red
.
Hemos
visto
que
la
capa


de
red
implica
a
todos
y
cada
uno
de
los
hosts
y
routers
de
una
red
.
En
consecuencia
,
los
pro-


tocolos
de
la
capa
de
red
se
encuentran
entre
los
m√°s
complejos
de
la
pila
de
protocolos
.


Hemos
visto
que
un
router
puede
tener
que
procesar
millones
de
flujos
de
paquetes


entre
distintas
parejas
origen-destino
a
un
mismo
tiempo
.
Para
que
un
router
pueda
procesar


tal
cantidad
de
flujos
,
los
dise√±adores
de
redes
han
ido
aprendiendo
a
lo
largo
de
los
a√±os


que
las
tareas
que
debe
realizar
un
router
tienen
que
ser
tan
simples
como
sea
posible
.
Se


pueden
tomar
muchas
medidas
para
facilitar
el
trabajo
a
los
routers
,
incluyendo
el
uso
de


una
capa
de
red
de
datagramas
en
lugar
de
una
capa
de
red
de
circuitos
virtuales
;
la
utiliza-


ci√≥n
de
una
cabecera
simplificada
y
de
tama√±o
fijo
(
como
en
IPv6
)
,
la
eliminaci√≥n
de
la


fragmentaci√≥n
(
tambi√©n
en
IPv6
)
y
la
provisi√≥n
del
famoso
servicio
de
mejor
esfuerzo
.


Quiz√°
aqu√≠
lo
m√°s
importante
no
es
controlar
los
flujos
individuales
,
sino
basar
las
decisio-


nes
de
enrutamiento
√∫nicamente
en
las
direcciones
de
destino
estructuradas
de
forma
jer√°r-


quica
de
los
datagramas
.
Es
interesante
destacar
que
el
servicio
de
correos
ordinario
ha


estado
empleando
este
m√©todo
durante
muchos
a√±os
.


En
este
cap√≠tulo
tambi√©n
hemos
examinado
los
principios
en
que
se
basan
los
algorit-


mos
de
enrutamiento
.
Hemos
visto
c√≥mo
estos
algoritmos
representan
la
red
de
computado-


ras
mediante
un
grafo
con
nodos
y
enlaces
.
Con
esta
abstracci√≥n
,
podemos
aprovechar
la
rica


teor√≠a
de
c√°lculo
de
la
ruta
m√≠nima
en
los
grafos
,
que
ha
sido
desarrollada
a
lo
largo
de
los


√∫ltimos
40
a√±os
por
la
comunidad
cient√≠fica
dedicada
a
los
algoritmos
y
la
investigaci√≥n
de


operaciones
.
Hemos
visto
que
existen
dos
m√©todos
generales
:
un
m√©todo
centralizado
(
glo-


bal
)
,
en
el
que
cada
nodo
obtiene
un
mapa
completo
de
la
red
y
aplica
de
forma
indepen-


4.8
‚Ä¢
RESUMEN
397


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
397diente
un
algoritmo
de
enrutamiento
basado
en
la
ruta
m√°s
corta
;
y
un
m√©todo
descentrali-


zado
,
en
el
que
los
nodos
individuales
s√≥lo
disponen
de
una
imagen
parcial
de
la
red
com-


pleta
,
y
los
nodos
trabajan
conjuntamente
para
entregar
paquetes
a
lo
largo
de
las
rutas
m√°s


cortas
.
Tambi√©n
hemos
estudiado
c√≥mo
se
utiliza
la
jerarqu√≠a
para
afrontar
el
problema
del


escalado
,
dividiendo
las
redes
de
gran
tama√±o
en
dominios
administrativos
independientes


conocidos
como
sistemas
aut√≥nomos
(
AS
)
.
Cada
AS
enruta
de
forma
independiente
sus
data-


gramas
a
trav√©s
del
sistema
aut√≥nomo
,
al
igual
que
cada
naci√≥n
distribuye
de
forma
indepen-


diente
su
correo
postal
a
trav√©s
del
pa√≠s
.
Hemos
examinado
c√≥mo
los
m√©todos
centralizado
,


descentralizado
y
jer√°rquico
se
integran
en
los
principales
protocolos
de
enrutamiento
de


Internet
:
RIP
,
OSPF
y
BGP
.
Hemos
concluido
nuestro
estudio
sobre
los
algoritmos
de
enru-


tamiento
considerando
los
enrutamientos
por
difusi√≥n
y
por
multidifusi√≥n
.


Una
vez
completado
nuestro
estudio
sobre
la
capa
de
red
,
vamos
a
descender
un
esca-


l√≥n
m√°s
por
la
pila
de
protocolos
hasta
la
capa
de
enlace
.
Al
igual
que
la
capa
de
red
,
la
capa


de
enlace
tambi√©n
forma
parte
del
n√∫cleo
de
la
red
.
Pero
en
el
siguiente
cap√≠tulo
veremos


que
la
capa
de
enlace
tiene
la
tarea
mucho
m√°s
localizada
de
transferir
los
paquetes
entre


nodos
situados
en
un
mismo
enlace
o
LAN
.
Aunque
esta
tarea
puede
parecer
en
principio


trivial
comparada
con
las
tareas
que
desempe√±a
la
capa
de
red
,
veremos
que
la
capa
de


enlace
implica
una
serie
de
cuestiones
importantes
y
fascinantes
que
nos
mantendr√°n
ocupa-


dos
durante
bastante
tiempo
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
4
Cuestiones
de
repaso


SECCIONES
4.1‚Äì4.2


R1
.
Revisemos
parte
de
la
terminolog√≠a
utilizada
en
el
libro
.
Recuerde
que
el
nombre
que


recibe
un
paquete
de
la
capa
de
transporte
es
segmento
y
que
el
nombre
de
un
paquete


de
la
capa
de
enlace
es
trama
.
¬ø
Cu√°l
es
el
nombre
de
un
paquete
de
la
capa
de
red
?


Recuerde
que
tanto
los
routers
como
los
dispositivos
de
conmutaci√≥n
de
la
capa
de


enlace
se
denominan
conmutadores
de
paquetes
.
¬ø
Cu√°l
es
la
diferencia
fundamental


entre
un
router
y
un
dispositivo
de
conmutaci√≥n
de
la
capa
de
enlace
?
Recuerde
que


utilizamos
el
t√©rmino
routers
tanto
para
las
redes
de
datagramas
como
para
las
redes


de
circuitos
virtuales
.


R2
.
¬ø
Cu√°les
son
las
dos
funciones
m√°s
importantes
de
la
capa
de
red
en
una
red
de
data-


gramas
?
¬ø
Cu√°les
son
las
tres
funciones
m√°s
importantes
de
la
capa
de
red
en
una
red


de
circuitos
virtuales
?


R3
.
¬ø
Cu√°l
es
la
diferencia
entre
enrutamiento
y
reenv√≠o
?


R4
.
¬ø
Utilizan
los
routers
en
las
redes
de
datagramas
y
de
circuitos
virtuales
tablas
de
reen-


v√≠o
?
En
caso
afirmativo
,
describa
las
tablas
de
reenv√≠o
para
ambas
clases
de
redes
.


R5
.
Describa
algunos
servicios
hipot√©ticos
que
la
capa
de
red
pueda
proporcionar
a
un


cierto
paquete
.
Haga
lo
mismo
para
un
flujo
de
paquetes
.
¬ø
Algunos
de
sus
hipot√©ticos


398
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
398PROBLEMAS
Y
CUESTIONES
DE
REPASO
399


servicios
pueden
ser
proporcionados
por
la
capa
de
red
de
Internet
?
¬ø
Alguno
es
pro-


porcionado
por
el
modelo
de
servicio
CBR
de
las
redes
ATM
?
¬ø
Alguno
es
proporcio-


nado
por
el
modelo
de
servicio
ABR
de
las
redes
ATM
?


R6
.
Enumere
algunas
aplicaciones
que
podr√≠an
beneficiarse
del
modelo
de
servicio
CBR


de
las
redes
ATM
.


SECCI√ìN
4.3


R7
.
Explique
por
qu√©
cada
puerto
de
entrada
de
un
router
de
alta
velocidad
almacena
una


copia
de
la
tabla
de
reenv√≠o
.


R8
.
En
la
Secci√≥n
4.3
se
han
abordado
tres
tipos
de
entramados
de
conmutaci√≥n
.
Enumere


y
describa
brevemente
cada
uno
de
ellos
.


R9
.
Describa
c√≥mo
pueden
perderse
paquetes
en
los
puertos
de
entrada
.
Describa
c√≥mo


puede
eliminarse
la
p√©rdida
de
paquetes
en
los
puertos
de
entrada
(
sin
utilizar
buffers


de
capacidad
infinita
)
.


R10
.
Describa
c√≥mo
puede
producirse
una
p√©rdida
de
paquetes
en
los
puertos
de
salida
.


R11
.
¬ø
Qu√©
es
el
bloqueo
HOL
?
¬ø
Se
produce
en
los
puertos
de
entrada
o
en
los
puertos
de


salida
?


SECCI√ìN
4.4


R12
.
¬ø
Tienen
direcciones
IP
los
routers
?
En
caso
afirmativo
,
¬ø
cu√°ntas
?


R13
.
¬ø
Cu√°l
es
el
equivalente
binario
de
32
bits
de
la
direcci√≥n
IP
223.1.3.27
?


R14
.
V
isite
un
host
que
utilice
DHCP
para
obtener
su
direcci√≥n
IP
,
su
m√°scara
de
red
,
su


router
predeterminado
y
la
direcci√≥n
IP
de
su
servidor
DNS
local
.
Enumere
estos
valo-


res
.


R15
.
Suponga
que
hay
tres
routers
entre
un
host
de
origen
y
un
host
de
destino
.
Ignorando


la
fragmentaci√≥n
,
se
env√≠a
un
datagrama
IP
desde
el
host
de
origen
al
host
de
destino
.


¬ø
A
trav√©s
de
cu√°ntas
interfaces
pasar√°
?
¬ø
Cu√°ntas
tablas
de
reenv√≠o
indexar√°
para
trans-


portar
el
datagrama
desde
el
origen
al
destino
?


R16
.
Suponga
una
aplicaci√≥n
que
genera
fragmentos
de
40
bytes
de
datos
cada
20
milise-


gundos
y
cada
fragmento
se
encapsula
en
un
segmento
TCP
y
luego
en
un
datagrama


IP
.
¬ø
Qu√©
porcentaje
de
cada
datagrama
ser√°
informaci√≥n
administrativa
y
qu√©
porcen-


taje
ser√°
datos
de
aplicaci√≥n
?


R17
.
Suponga
que
el
host
A
env√≠a
al
host
B
un
segmento
TCP
encapsulado
en
un
datagrama


IP
.
Cuando
el
host
B
recibe
el
datagrama
,
¬ø
c√≥mo
sabe
la
capa
de
red
del
host
B
que


deber√≠a
pasar
el
segmento
(
es
decir
,
la
carga
√∫til
del
datagrama
)
a
TCP
en
lugar
de
a


UDP
o
a
cualquier
otro
protocolo
?


R18
.
Suponga
que
adquiere
un
router
inal√°mbrico
y
que
lo
conecta
a
su
m√≥dem
por
cable
.


Suponga
tambi√©n
que
su
ISP
asigna
din√°micamente
una
direcci√≥n
IP
a
su
dispositivo


conectado
(
es
decir
,
a
su
router
inal√°mbrico
)
.
Adem√°s
,
suponga
que
tiene
cinco
equi-


pos
PC
en
su
domicilio
que
utilizan
802.11
para
conectarse
de
forma
inal√°mbrica
a
su


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
399400
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


router
inal√°mbrico
.
¬ø
C√≥mo
se
asignan
las
direcciones
IP
a
los
cinco
PC
?
¬ø
Utiliza
NAT


el
router
inal√°mbrico
?
¬ø
Por
qu√©
?


R19
.
Compare
y
contraste
los
campos
de
cabecera
de
IPv4
e
IPv6
.
¬ø
Tienen
campos
en


com√∫n
?


R20
.
A
veces
se
dice
que
cuando
IPv6
tuneliza
a
trav√©s
de
los
routers
IPv4
,
IPv6
trata
los


t√∫neles
de
IPv4
como
protocolos
de
la
capa
de
enlace
.
¬ø
Est√°
de
acuerdo
con
esta
afir-


maci√≥n
?
¬ø
Por
qu√©
?


SECCI√ìN
4.5


R21
.
Compare
y
contraste
los
algoritmos
de
enrutamiento
de
estado
de
enlaces
y
de
vector


de
distancias
.


R22
.
Explique
c√≥mo
la
organizaci√≥n
jer√°rquica
de
Internet
ha
hecho
posible
el
escalar
la


red
a
millones
de
usuarios
.


R23
.
¬ø
Es
necesario
que
todos
los
sistemas
aut√≥nomos
utilicen
el
mismo
algoritmo
de
enru-


tamiento
interno
?
¬ø
Por
qu√©
?


SECCI√ìN
4.6


R24
.
Considere
la
Figura
4.37
.
Comenzando
con
la
tabla
original
en
D
,
suponga
que
D


recibe
de
A
el
siguiente
anuncio
:


Subred
de
destino
Siguiente
router
N√∫mero
de
saltos
al
destino


zC
1
0


w
‚Äî
1


x
‚Äî
1


.
.
.
.
.
.
.
.
.
.
.
.


¬ø
Cambiar√°
la
tabla
en
el
router
D
?
En
caso
afirmativo
,
¬ø
c√≥mo
?


R25
.
Compare
y
contraste
los
anuncios
utilizados
por
RIP
y
OSPF
.


R26
.
Rellene
el
espacio
en
blanco
.
Los
anuncios
RIP
normalmente
anuncian
el
n√∫mero


de
saltos
a
varios
destinos
.
Por
el
contrario
,
las
actualizaciones
BGP
anuncian


_
_
_
_
_
_
_
_
_
_
a
los
distintos
destinos
.


R27
.
¬ø
Por
qu√©
es
diferente
el
protocolo
de
enrutamiento
interno
de
un
AS
del
protocolo
de


enrutamiento
entre
sistemas
aut√≥nomos
de
Internet
?


R28
.
¬ø
Por
qu√©
no
son
tan
importantes
las
consideraciones
de
pol√≠ticas
en
los
protocolos
de


enrutamiento
internos
de
los
sistemas
aut√≥nomos
,
como
OSPF
y
RIP
,
como
lo
son


para
el
protocolo
de
enrutamiento
entre
sistemas
aut√≥nomos
BGP
?


R29
.
Defina
y
contraste
los
siguientes
t√©rminos
:
subred
,
prefijo
y
ruta
BGP
.


R30
.
¬ø
C√≥mo
utiliza
BGP
el
atributo
NEXT-HOP
?
¬ø
C√≥mo
utiliza
el
atributo
AS-PATH
?


R31
.
Describa
c√≥mo
un
administrador
de
red
de
un
ISP
de
nivel
superior
puede
implemen-


tar
ciertas
pol√≠ticas
al
configurar
BGP
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
400SECCI√ìN
4.7


R32
.
¬ø
Cu√°l
es
una
diferencia
importante
entre
la
implementaci√≥n
de
la
abstracci√≥n
de
la


difusi√≥n
mediante
varias
comunicaciones
por
unidifusi√≥n
y
una
√∫nica
red
(
router
)
que


soporte
difusi√≥n
?


R33
.
Para
cada
uno
de
los
tres
m√©todos
generales
que
hemos
estudiado
para
la
difusi√≥n


(
inundaci√≥n
no
controlada
,
inundaci√≥n
controlada
y
mediante
√°rbol
de
recubrimiento
)


indique
si
las
siguientes
afirmaciones
son
verdaderas
o
falsas
.
Puede
suponer
que
no


se
pierde
ning√∫n
paquete
por
desbordamiento
del
buffer
y
que
todos
los
paquetes
son


entregados
a
trav√©s
de
un
enlace
en
el
mismo
orden
en
que
fueron
 
enviados
.


a.
Un
nodo
puede
recibir
varias
copias
del
mismo
paquete
.


b.
Un
nodo
puede
reenviar
m√∫ltiples
copias
de
un
paquete
a
trav√©s
del
mismo


enlace
de
salida
.


R34
.
Cuando
un
host
se
une
a
un
grupo
de
multidifusi√≥n
,
¬ø
tiene
que
cambiar
su
direcci√≥n


IP
a
la
del
grupo
de
multidifusi√≥n
al
que
se
est√°
uniendo
?


R35
.
¬ø
Cu√°les
son
las
funciones
desempe√±adas
por
el
protocolo
IGMP
y
por
un
protocolo
de


enrutamiento
por
multidifusi√≥n
de
√°rea
extensa
?


R36
.
¬ø
Cu√°l
es
la
diferencia
entre
un
√°rbol
compartido
por
el
grupo
y
un
√°rbol
basado
en
un


origen
,
en
el
contexto
del
enrutamiento
por
multidifusi√≥n
?


Problemas


P1
.
En
este
problema
vamos
a
considerar
algunas
de
las
ventajas
y
de
los
inconvenientes


de
las
redes
de
circuitos
virtuales
y
de
datagramas
.


a.
Suponga
que
los
routers
est√°n
sujetos
a
condiciones
que
pueden
hacer
que
fallen


con
frecuencia
.
¬ø
Aconsejar√≠a
esto
una
arquitectura
de
datagramas
o
una
de
circui-


tos
virtuales
?
¬ø
Por
qu√©
?


b.
Suponga
que
un
nodo
de
origen
y
un
nodo
de
destino
requieren
que
una
cierta


capacidad
fija
est√©
siempre
disponible
en
todos
los
routers
de
la
ruta
entre
el
origen


y
el
destino
,
para
el
uso
exclusivo
del
tr√°fico
que
fluye
entre
dichos
nodos
de
ori-


gen
y
de
destino
.
¬ø
Aconsejar√≠a
esto
una
arquitectura
de
datagramas
o
una
de
circui-


tos
virtuales
?
¬ø
Por
qu√©
?


c.
Suponga
que
los
enlaces
y
routers
de
la
red
nunca
fallan
y
que
los
caminos
de
enru-


tamiento
utilizados
entre
todas
las
parejas
origen-destino
nunca
var√≠an
.
En
este


escenario
,
¬ø
qu√©
arquitectura
(
de
datagramas
o
de
circuitos
virtuales
)
tiene
m√°s


sobrecarga
de
tr√°fico
de
control
?
¬ø
Por
qu√©
?


P2
.
Considere
una
red
de
circuitos
virtuales
.
Suponga
que
el
n√∫mero
de
VC
es
un
campo


de
8
bits
.


a.
¬ø
Cu√°l
es
el
n√∫mero
m√°ximo
de
circuitos
virtuales
que
pueden
ser
transportados
a


trav√©s
de
un
enlace
?


b.
Suponga
que
un
nodo
central
determina
las
rutas
y
n√∫meros
de
VC
durante
la
con-


figuraci√≥n
de
la
conexi√≥n
.
Suponga
que
se
emplea
el
mismo
n√∫mero
de
VC
en
cada


PROBLEMAS
401


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
401enlace
a
lo
largo
del
camino
de
circuitos
virtuales
.
Describa
c√≥mo
puede
el
nodo


central
determinar
el
n√∫mero
de
VC
durante
la
configuraci√≥n
de
la
conexi√≥n
.
¬ø
Es


posible
que
haya
menos
circuitos
virtuales
activos
que
el
m√°ximo
determinado
en


el
apartado
(
a
)
y
que
,
a
pesar
de
ello
,
no
exista
ning√∫n
n√∫mero
VC
com√∫n
libre
?


c.
Suponga
que
est√°n
permitidos
diferentes
n√∫meros
de
VC
en
cada
uno
de
los
enla-


ces
que
forman
el
camino
de
un
circuito
virtual
.
Durante
la
configuraci√≥n
de
la


conexi√≥n
,
despu√©s
de
que
se
ha
determinado
un
camino
terminal
a
terminal
,
des-


criba
c√≥mo
pueden
los
enlaces
elegir
sus
n√∫meros
de
VC
y
configurar
sus
tablas
de


reenv√≠o
de
una
forma
descentralizada
,
sin
basarse
en
un
nodo
central
.


P3
.
Una
tabla
de
reenv√≠o
m√≠nima
en
una
red
de
circuitos
virtuales
tiene
cuatro
columnas
.


¬ø
Cu√°l
es
el
significado
de
los
valores
de
cada
una
de
las
columnas
?
Una
tabla
de
reen-


v√≠o
m√≠nima
en
una
red
de
datagramas
tiene
dos
columnas
.
¬ø
Cu√°l
es
el
significado
de


los
valores
de
cada
una
de
estas
columnas
?


P4
.
Utilice
la
red
mostrada
m√°s
abajo
.


a.
Suponga
que
se
trata
de
una
red
de
datagramas
.
Especifique
la
tabla
de
reenv√≠o
del


router
A
,
de
modo
que
todo
el
tr√°fico
destinado
al
host
H3
sea
reenv√≠ado
a
trav√©s


de
la
interfaz
3
.


b.
Suponga
que
se
trata
de
una
red
de
datagramas
.
¬ø
Puede
escribir
una
tabla
de
reen-


v√≠o
para
el
router
A
,
de
manera
que
todo
el
tr√°fico
de
H1
destinado
al
host
H3
sea


reenviado
a
trav√©s
de
la
interfaz
3
,
mientras
todo
el
tr√°fico
de
H2
destinado
al
host


H3
sea
reenviado
a
trav√©s
de
la
interfaz
4
?
(
Sugerencia
:
esta
pregunta
tiene
truco
.
)


c.
Ahora
suponga
que
se
trata
de
una
red
de
circuitos
virtuales
y
que
hay
una
llamada


activa
entre
H1
y
H3
,
y
otra
llamada
activa
entre
H2
y
H3
.
Escriba
la
tabla
de
reen-


v√≠o
del
router
A
,
de
modo
que
todo
el
tr√°fico
de
H1
destinado
al
host
H3
sea
reen-


viado
a
trav√©s
de
la
interfaz
3
,
mientras
todo
el
tr√°fico
de
H2
destinado
al
host
H3


sea
reenviado
a
trav√©s
de
la
interfaz
4
.
 

d.
Suponga
el
mismo
escenario
que
en
el
apartado
(
c
)
y
escriba
las
tablas
de
reenv√≠o


de
los
nodos
B
,
C
y
D.


P5
.
Considere
una
red
de
circuitos
virtuales
con
un
campo
de
2
bits
para
el
n√∫mero
de
VC
.


Suponga
que
la
red
desea
configurar
un
circuito
virtual
a
trav√©s
de
cuatro
enlaces
:
el


enlace
A
,
el
enlace
B
,
el
enlace
C
y
el
enlace
D.
Suponga
tambi√©n
que
cada
uno
de


estos
enlaces
actualmente
est√°
dando
soporte
a
otros
dos
circuitos
virtuales
y
que
los


n√∫meros
de
VC
de
los
mismos
son
los
siguientes
:


402
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
402Enlace
A
Enlace
B
Enlace
C
Enlace
D


00
01
10
11


01
10
11
00


Al
responder
a
las
siguientes
preguntas
,
tenga
en
cuenta
que
cada
uno
de
los
circuitos


virtuales
existentes
s√≥lo
puede
estar
atravesando
uno
de
los
cuatro
enlaces
:


a.
Si
se
requiere
que
cada
circuito
virtual
utilice
el
mismo
n√∫mero
de
VC
en
todos


los
enlaces
a
lo
largo
de
su
ruta
,
¬ø
qu√©
n√∫mero
de
VC
podr√≠a
asignarse
al
nuevo
cir-


cuito
virtual
?


b.
Si
se
permite
que
cada
circuito
virtual
tenga
n√∫meros
de
VC
distintos
en
los
diferen-


tes
enlaces
a
lo
largo
de
su
ruta
(
de
modo
que
las
tablas
de
reenv√≠o
tengan
que
llevar


a
cabo
una
traducci√≥n
de
n√∫mero
de
VC
)
,
¬ø
cu√°ntas
combinaciones
distintas
de
cua-


tro
n√∫meros
de
VC
(
una
para
cada
uno
de
los
cuatro
enlaces
)
podr√≠an
utilizarse
?


P6
.
En
el
texto
hemos
utilizado
los
t√©rminos
‚Äú
servicio
orientado
a
la
conexi√≥n
‚Äù
para
des-


cribir
un
servicio
de
la
capa
de
transporte
y
‚Äú
servicio
de
conexi√≥n
‚Äù
para
un
servicio
de


la
capa
de
red
.
¬ø
Por
qu√©
esas
sutiles
diferencias
en
la
terminolog√≠a
?


P7
.
En
la
Secci√≥n
4.3
hemos
mencionado
que
puede
no
existir
una
cola
de
entrada
si
el


entramado
de
conmutaci√≥n
es
n
veces
m√°s
r√°pido
que
las
velocidades
de
l√≠nea
de


entrada
,
suponiendo
que
las
n
l√≠neas
de
entrada
presentan
todas
la
misma
velocidad
de


l√≠nea
.
Explique
por
qu√©
esto
deber√≠a
ser
as√≠
.


P8
.
Considere
el
dispositivo
de
conmutaci√≥n
mostrado
m√°s
abajo
.
Suponga
que
todos
los


datagramas
tienen
la
misma
longitud
fija
,
que
el
dispositivo
opera
de
forma
s√≠ncrona
y


particionada
y
que
en
una
partici√≥n
temporal
se
puede
transferir
un
datagrama
desde


un
puerto
de
entrada
a
un
puerto
de
salida
.
El
entramado
de
conmutaci√≥n
emplea
una


estructura
de
malla
,
por
lo
que
,
como
m√°ximo
,
se
puede
transferir
un
datagrama
a
un


puerto
de
salida
determinado
en
una
partici√≥n
de
tiempo
,
pero
distintos
puertos
de


salida
pueden
recibir
datagramas
procedentes
de
distintos
puertos
de
entrada
en
una


misma
partici√≥n
de
tiempo
.
¬ø
Cu√°l
es
el
n√∫mero
m√≠nimo
de
particiones
de
tiempo
nece-


sarias
para
transferir
los
paquetes
mostrados
desde
los
puertos
de
entrada
a
sus
puer-


tos
de
salida
,
suponiendo
cualquier
orden
de
planificaci√≥n
de
la
cola
de
entrada
que


desee
(
es
decir
,
no
tiene
por
qu√©
existir
el
bloqueo
HOL
)
?
¬ø
Cu√°l
es
el
n√∫mero
m√°ximo


necesario
de
particiones
de
tiempo
,
suponiendo
el
orden
de
planificaci√≥n
de
caso
peor


que
pueda
imaginar
y
suponiendo
que
una
cola
de
entrada
no
vac√≠a
nunca
est√°
inac-


tiva
?


PROBLEMAS
403


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
403P9
.
Considere
una
red
de
datagramas
que
utiliza
direcciones
de
host
de
32
bits
.
Suponga


que
un
router
tiene
cuatro
enlaces
,
numerados
de
0
a
3
y
que
los
paquetes
son
reenvia-


dos
a
las
interfaces
de
los
enlaces
como
sigue
:


Rango
de
direcciones
de
destino
                                      
Interfaz
de
enlace


11100000
00000000
00000000
00000000


hasta
0


11100000
00111111
11111111
11111111


11100000
01000000
00000000
00000000


hasta
1


11100000
01000000
11111111
11111111


11100000
01000001
00000000
00000000


hasta
2


11100001
01111111
11111111
11111111


en
otro
caso
3


a.
Proporcione
una
tabla
de
reenv√≠o
con
cuatro
entradas
,
que
utilice
la
regla
de
coinci-


dencia
con
el
prefijo
m√°s
largo
y
que
reenv√≠e
los
paquetes
a
las
interfaces
de
enlace


correctas
.


b.
Describa
c√≥mo
determina
su
tabla
de
reenv√≠o
la
interfaz
de
enlace
apropiada
para


los
datagramas
con
las
siguientes
direcciones
de
destino
:


11001000
10010001
01010001
01010101


11100001
01000000
11000011
00111100


11100001
10000000
00010001
01110111


P10
.
Considere
una
red
de
datagramas
que
utiliza
direcciones
de
host
de
8
bits
.
Suponga
un


router
que
utiliza
las
coincidencias
con
el
prefijo
m√°s
largo
y
cuya
tabla
de
reenv√≠o
es


la
siguiente
:


Coincidencia
de
prefijo
Interfaz


00
0


010
1


011
2


10
2


11
3


Para
cada
una
de
las
cuatro
interfaces
,
proporcione
el
rango
asociado
de
direcciones


del
host
de
destino
y
el
n√∫mero
de
direcciones
contenidas
en
el
rango
.


P11
.
Considere
una
red
de
datagramas
que
utiliza
direcciones
de
host
de
8
bits
.
Suponga
un


router
que
utiliza
las
coincidencias
con
el
prefijo
m√°s
largo
y
cuya
tabla
de
reenv√≠o
es


la
siguiente
:


404
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
404Coincidencia
de
prefijo
Interfaz


10


10
1


111
2


en
otro
caso
3


Para
cada
una
de
las
cuatro
interfaces
,
proporcione
el
rango
asociado
de
direcciones


del
host
de
destino
y
el
n√∫mero
de
direcciones
contenidas
en
el
rango
.


P12
.
Sea
un
router
que
interconecta
tres
subredes
:
Subred
1
,
Subred
2
y
Subred
3
.
Suponga


que
se
requiere
que
todas
las
interfaces
de
cada
una
de
estas
tres
subredes
tengan
el


prefijo
223.1.17/24
.
Suponga
tambi√©n
que
se
requiere
que
la
Subred
1
admita
hasta


63
interfaces
,
la
Subred
2
tiene
que
admitir
hasta
95
interfaces
y
la
Subred
3
hasta
16


interfaces
.
Determine
tres
direcciones
de
red
(
de
la
forma
a.b.c.d
/
x
)
que
satisfagan


estas
restricciones
.


P13
.
En
la
Secci√≥n
4.2.2
se
ha
proporcionado
una
tabla
de
reenv√≠o
de
ejemplo
(
utilizando


la
coincidencia
con
el
prefijo
m√°s
largo
)
.
Vuelva
a
escribir
esta
tabla
de
reenv√≠o
utili-


zando
la
notaci√≥n
a.b.c.d
/
x
en
lugar
de
la
notaci√≥n
en
binario
.


P14
.
En
el
Problema
P9
se
le
ha
pedido
que
proporcione
una
tabla
de
reenv√≠o
(
utilizando
la


regla
de
coincidencia
con
el
prefijo
m√°s
largo
)
.
Escriba
de
nuevo
esta
tabla
de
reenv√≠o


utilizando
la
notaci√≥n
a.b.c.d
/
x
en
lugar
de
la
notaci√≥n
en
binario
.


P15
.
Considere
un
subred
cuyo
prefijo
es
128.119.40.128/26
.
Proporcione
un
ejemplo
de


una
direcci√≥n
IP
(
de
la
forma
xxx.xxx.xxx.xxx
)
que
pueda
ser
asignada
a
esta
red
.


Suponga
que
un
ISP
posee
el
bloque
de
direcciones
128.119.40.64/25
.
Suponga
que


desea
crear
cuatro
subredes
a
partir
de
este
bloque
de
direcciones
,
teniendo
cada
blo-


que
el
mismo
n√∫mero
de
direcciones
IP
.
¬ø
Cu√°les
ser√°n
los
prefijos
(
expresados
en
for-


mato
a.b.c.d
/
x
)
para
las
cuatro
subredes
?


P16
.
Considere
la
topolog√≠a
de
la
Figura
4.17
.
Denomine
a
las
tres
subredes
con
hosts


(
comenzando
en
el
sentido
horario
a
partir
de
las
12:00
)
como
redes
A
,
B
y
C.
Deno-


mine
a
las
subredes
que
no
tienen
hosts
como
redes
D
,
E
y
F.


a.
Asigne
direcciones
de
red
a
cada
una
de
estas
seis
subredes
,
teniendo
en
cuenta
las


siguientes
restricciones
:
todas
las
direcciones
tienen
que
ser
asignadas
a
partir
de


214.97.254/23
;
la
subred
A
tendr√°
que
disponer
de
las
direcciones
suficientes
como


para
dar
soporte
a
250
interfaces
;
la
subred
B
tendr√°
que
disponer
de
las
direcciones


suficientes
como
para
dar
soporte
a
120
interfaces
y
la
subred
C
tendr√°
que
disponer


de
las
direcciones
suficientes
como
para
dar
soporte
a
120
interfaces
.
Por
supuesto
,


las
subredes
D
,
E
y
F
deber√≠an
poder
dar
soporte
a
dos
interfaces
.
Para
cada
subred
,


la
asignaci√≥n
deber√≠a
hacerse
empleando
el
formato
a.b.c.d
/
x
o
a.b.c.d
/
x
‚Äì
e.f.g.h
/
y.


b.
Utilizando
su
respuesta
al
apartado
(
a
)
,
proporcione
las
tablas
de
reenv√≠o
(
utili-


zando
la
regla
de
coincidencia
con
el
prefijo
m√°s
largo
)
para
cada
uno
de
los
tres


routers
.


P17
.
Se
env√≠a
un
datagrama
de
2.400
bytes
por
un
enlace
que
tiene
una
MTU
de
700
bytes
.


Suponga
que
el
datagrama
original
est√°
marcado
con
el
n√∫mero
de
identificaci√≥n
422
.


PROBLEMAS
405


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
405¬øCu√°ntos
fragmentos
se
generan
?
¬ø
Cu√°les
son
los
valores
de
los
distintos
campos
de


los
datagramas
IP
generados
,
relacionados
con
la
fragmentaci√≥n
?


P18
.
Suponga
que
el
tama√±o
de
los
datagramas
est√°
limitado
a
1.500
bytes
(
incluyendo
la


cabecera
)
entre
el
host
A
y
el
host
de
destino
B.
Suponiendo
una
cabecera
IP
de
20


bytes
,
¬ø
cu√°ntos
datagramas
se
necesitar√≠an
para
enviar
un
archivo
MP3
de
5
millones


de
 
bytes
?
Explique
los
c√°lculos
que
haya
realizado
para
dar
una
respuesta
.


P19
.
Considere
la
red
de
la
Figura
4.22
.
Suponga
que
el
ISP
asigna
al
router
la
direcci√≥n


24.34.112.235
y
que
la
direcci√≥n
de
la
red
dom√©stica
es
192.168.1/24
.


a.
Asigne
direcciones
a
todas
las
interfaces
de
la
red
dom√©stica
.


b.
Suponga
que
cada
host
tiene
dos
conexiones
TCP
activas
,
todas
ellas
en
el
puerto


80
del
host
128.119.40.86
.
Proporcione
las
seis
entradas
correspondientes
de
la


tabla
de
traducciones
NAT
.


P20
.
Suponga
que
est√°
interesado
en
detectar
el
n√∫mero
de
hosts
que
hay
detr√°s
de
un
tra-


ductor
NAT
.
Observe
que
la
capa
IP
marca
secuencialmente
con
un
n√∫mero
de
identi-


ficaci√≥n
cada
paquete
IP
.
El
n√∫mero
de
identificaci√≥n
del
primer
paquete
IP
generado


por
un
host
es
un
n√∫mero
aleatorio
y
los
n√∫meros
de
identificaci√≥n
de
los
subsiguien-


tes
paquetes
IP
se
asignan
de
forma
secuencial
.
Suponga
que
todos
los
paquetes
IP


generados
por
los
hosts
que
hay
detr√°s
del
traductor
NAT
se
env√≠an
al
exterior
.


a.
Bas√°ndose
en
esta
observaci√≥n
y
suponiendo
que
puede
husmear
todos
los
paque-


tes
enviados
por
NAT
al
exterior
,
¬ø
puede
esbozar
una
t√©cnica
sencilla
para
detectar


el
n√∫mero
de
hosts
√∫nicos
que
hay
detr√°s
del
traductor
NAT
?
Justifique
su
res-


puesta
.


b.
Si
los
n√∫meros
de
identificaci√≥n
no
se
asignan
secuencialmente
sino
aleatoria-


mente
,
¬ø
servir√≠a
su
t√©cnica
?
Justifique
su
respuesta
.


P21
.
En
este
problema
se
explora
el
impacto
de
NAT
sobre
las
aplicaciones
P2P.
Suponga


que
un
par
cuyo
nombre
de
usuario
es
Arnold
descubre
mediante
una
consulta
que
otro


par
con
el
nombre
de
usuario
Bernard
tiene
un
archivo
que
desea
descargar
.
Suponga


tambi√©n
que
Bernard
y
Arnold
est√°n
detr√°s
de
un
traductor
NAT
.
Intente
deducir
una


t√©cnica
que
permita
a
Arnold
establecer
una
conexi√≥n
TCP
con
Bernard
sin
realizar


una
configuraci√≥n
NAT
espec√≠fica
de
la
aplicaci√≥n
.
Si
tiene
dificultades
para
definir


una
t√©cnica
as√≠
,
explique
por
qu√©
.


P22
.
En
la
Figura
4.27
,
enumere
la
rutas
de
y
a
u
que
no
contienen
ning√∫n
bucle
.


P23
.
Repita
el
Problema
P22
para
las
rutas
de
x
a
z
,
z
a
u
y
z
a
w.


P24
.
Considere
la
red
de
la
p√°gina
siguiente
.
Con
los
costes
de
enlace
indicados
,
utilice
el


algoritmo
de
la
ruta
m√°s
corta
de
Dijkstra
para
calcular
la
ruta
m√°s
corta
de
x
a
todos


los
nodos
de
la
red
.
Muestre
c√≥mo
funciona
el
algoritmo
calculando
una
tabla
similar


a
la
mostrada
en
la
Tabla
4.3
.


P25
.
Considere
la
red
del
Problema
P24
.
Utilizando
el
algoritmo
de
Dijkstra
y
utilizando


una
tabla
similar
a
la
Tabla
4.3
,
haga
lo
siguiente
:


a.
Calcule
la
ruta
m√°s
corta
desde
t
a
todos
los
dem√°s
nodos
de
la
red
.


b.
Calcule
la
ruta
m√°s
corta
desde
u
a
todos
los
dem√°s
nodos
de
la
red
.


406
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
406c
.
Calcule
la
ruta
m√°s
corta
desde
v
a
todos
los
dem√°s
nodos
de
la
red
.


d.
Calcule
la
ruta
m√°s
corta
desde
w
a
todos
los
dem√°s
nodos
de
la
red
.


e.
Calcule
la
ruta
m√°s
corta
desde
y
a
todos
los
dem√°s
nodos
de
la
red
.


f.
Calcule
la
ruta
m√°s
corta
desde
z
a
todos
los
dem√°s
nodos
de
la
red
.


P26
.
Utilice
la
red
que
se
muestra
a
continuaci√≥n
y
suponga
que
cada
nodo
inicialmente


conoce
los
costes
hasta
cada
uno
de
sus
vecinos
.
Utilizando
el
algoritmo
de
vector
de


distancias
,
especifique
las
entradas
de
la
tabla
de
distancias
para
el
nodo
z.


P27
.
Considere
una
topolog√≠a
general
(
es
decir
,
no
la
red
concreta
mostrada
m√°s
arriba
)
y


una
versi√≥n
s√≠ncrona
del
algoritmo
de
vector
de
distancias
.
Suponga
que
en
cada
itera-


ci√≥n
un
nodo
intercambia
sus
vectores
distancia
con
sus
vecinos
y
recibe
los
vectores


distancia
de
ellos
.
Suponiendo
que
el
algoritmo
se
inicia
con
cada
nodo
conociendo


s√≥lo
los
costes
de
sus
vecinos
inmediatos
,
¬ø
cu√°l
es
el
n√∫mero
m√°ximo
de
iteraciones


requerido
antes
de
que
el
algoritmo
distribuido
converja
?
Justifique
su
respuesta
.


P28
.
Considere
el
fragmento
de
red
mostrado
a
continuaci√≥n
.
x
s√≥lo
tiene
dos
vecinos


conectados
,
w
e
y.
w
tiene
una
ruta
de
coste
m√≠nimo
al
destino
u
(
no
mostrado
)
de
5
e


y
tiene
una
ruta
de
coste
m√≠nimo
a
u
de
6
.
Las
rutas
completas
desde
w
e
y
a
u
(
y
entre


w
e
y
)
no
se
muestran
.
Todos
los
costes
de
enlace
de
la
red
tienen
valores
enteros


estrictamente
positivos
.


PROBLEMAS
407


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
407a
.
Indique
el
vector
de
distancias
de
x
para
los
destinos
w
,
y
y
u.


b.
Indique
un
cambio
en
el
coste
del
enlace
para
c(x
,
w
)
o
c(x
,
y
)
tal
que
x
informe
a
sus


vecinos
de
una
nueva
ruta
de
coste
m√≠nimo
a
u
,
como
resultado
de
ejecutar
el
algo-


ritmo
de
vector
de
distancias
.


c.
Indique
un
cambio
en
el
coste
del
enlace
para
c(x
,
w
)
o
c(x
,
y
)
tal
que
x
no
informe
a


sus
vecinos
de
una
ruta
de
coste
m√≠nimo
a
u
,
como
resultado
de
ejecutar
el
algo-


ritmo
de
vector
de
distancias
.


P29
.
Considere
la
topolog√≠a
de
tres
nodos
mostrada
en
la
Figura
4.30
.
En
lugar
de
tener
los


costes
de
enlace
mostrados
en
dicha
figura
,
los
costes
de
enlace
son
c(x
,
y
)
=
3
,
c(y
,
z
)
=


6
,
c(z
,
x
)
=
4
.
Calcule
las
tablas
de
distancias
despu√©s
del
paso
de
inicializaci√≥n
y
des-


pu√©s
de
cada
iteraci√≥n
de
una
versi√≥n
s√≠ncrona
del
algoritmo
de
vector
de
distancias


(
como
hemos
hecho
anteriormente
al
explicar
la
Figura
4.30
)
.


P30
.
Considere
el
problema
de
la
cuenta
hasta
infinito
en
el
enrutamiento
por
vector
de
dis-


tancias
.
¬ø
Se
producir√°
dicho
problema
si
disminuimos
el
coste
de
un
enlace
?
¬ø
Por


qu√©
?
¬ø
Qu√©
ocurre
si
conectamos
dos
nodos
que
no
tienen
un
enlace
?


P31
.
Demuestre
que
al
aplicar
el
algoritmo
de
vector
de
distancias
en
la
Figura
4.30
,
cada


valor
del
vector
de
distancias
D(x
)
es
no
creciente
y
finalmente
se
estabilizar√°
en
un


n√∫mero
finito
de
pasos
.


P32
.
Considere
la
Figura
4.31
.
Suponga
que
existe
otro
router
w
,
conectado
a
los
routers
y


y
z.
Los
costes
de
todos
los
enlace
son
los
siguientes
:
c(x
,
y
)
=
4
,
c(x
,
z
)
=
50
,
c(y
,
w
)
=


1
,
c(z
,
w)=1
,
c(y
,
z
)
=
3
.
Suponga
que
se
utiliza
inversa
envenenada
en
el
algoritmo
de


enrutamiento
por
vector
de
distancias
.


a.
Cuando
el
enrutamiento
por
vector
de
distancias
se
estabiliza
,
los
routers
w
,
y
y
z


se
informan
de
sus
respectivas
distancias
a
x.
¬ø
Cu√°les
son
los
valores
de
esas
dis-


tancias
?


b.
Ahora
suponga
que
el
coste
del
enlace
entre
x
e
y
aumenta
a
60
.
¬ø
Se
producir√°
un


problema
de
cuenta
hasta
infinito
aunque
se
utilice
inversa
envenenada
?
¬ø
Por
qu√©
?


Si
existe
el
problema
de
cuenta
hasta
infinito
,
entonces
¬ø
cu√°ntas
iteraciones
ser√°n


necesarias
para
que
el
enrutamiento
por
vector
de
distancias
alcance
de
nuevo
un


estado
estable
?
Justifique
su
respuesta
.
 

c.
¬ø
C√≥mo
modificar√≠a
c(y
,
z
)
para
que
no
existiera
el
problema
de
cuenta
hasta
infinito


si
c(y
,
x
)
cambia
de
4
a
60
?


P33
.
Describa
c√≥mo
puede
detectarse
en
BGP
la
existencia
de
bucles
en
las
rutas
.


P34
.
¬ø
Un
router
BGP
elegir√°
siempre
la
ruta
sin
bucles
con
la
longitud
m√°s
corta
de
la


secuencia
AS-PATH
?
Justifique
su
respuesta
.


408
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
408P35
.
Considere
la
red
mostrada
a
continuaci√≥n
.
Suponga
que
los
sistemas
aut√≥nomos
AS3


y
AS2
est√°n
ejecutando
OSPF
como
protocolo
de
enrutamiento
interno
.
Suponga
que


AS1
y
AS4
est√°n
ejecutando
RIP
como
protocolo
de
enrutamiento
interno
.
Suponga


por
√∫ltimo
que
se
utilizan
sesiones
eBGP
y
iBGP
para
el
protocolo
de
enrutamiento


entre
sistemas
aut√≥nomos
.
Adem√°s
,
inicialmente
no
existe
enlace
f√≠sico
entre
AS2
y


AS4
.


a.
¬ø
De
qu√©
protocolo
de
enrutamiento
aprende
el
router
3c
acerca
del
prefijo
x
:
OSPF
,


RIP
,
eBGP
o
iBGP
?


b.
¬ø
De
qu√©
protocolo
de
enrutamiento
aprende
el
router
3a
acerca
de
x
?


c.
¬ø
De
qu√©
protocolo
de
enrutamiento
aprende
el
router
1c
acerca
de
x
?


d.
¬ø
De
qu√©
protocolo
de
enrutamiento
aprende
el
router
1d
acerca
de
x
?


P36
.
C
ontinuando
con
el
problema
anterior
,
una
vez
que
el
router
1d
aprende
acerca
de
x


incluir√°
una
entrada
(
x
,
I
)
en
su
tabla
de
reenv√≠o
.


a.
Para
esta
entrada
,
¬ø
I
ser√°
igual
a
I1
o
a
I2
?
Explique
por
qu√©
en
una
frase
.


b.
Ahora
suponga
que
existe
un
enlace
f√≠sico
entre
AS2
y
AS4
(
mostrado
mediante


una
l√≠nea
de
puntos
en
la
figura
)
.
Suponga
que
el
router
1d
aprende
que
x
es
accesi-


ble
a
trav√©s
de
AS2
y
de
AS3
.
¬ø
I
ser√°
igual
a
I1
o
a
I2
?
Explique
por
qu√©
en
una


frase
.


c.
Ahora
suponga
que
existe
otro
sistema
aut√≥nomo
AS5
,
que
conecta
la
ruta
entre


AS2
y
AS4
(
no
se
muestra
en
el
diagrama
)
.
Suponga
que
el
router
1d
aprende
que


x
es
accesible
a
trav√©s
de
AS2
AS5
AS4
,
as√≠
como
de
AS3
AS4
.
¬ø
I
ser√°
igual
a
I1
o


a
I2
?
Explique
por
qu√©
en
una
frase
.


P37
.
Considere
la
red
mostrada
en
la
primera
figura
de
la
p√°gina
siguiente
.
El
ISP
B
pro-


porciona
un
servicio
troncal
nacional
al
ISP
A
regional
.
El
ISP
C
ofrece
un
servicio


troncal
nacional
al
ISP
D
regional
.
Cada
ISP
consta
de
un
sistema
aut√≥nomo
.
Los


pares
B
y
C
se
comunican
entre
s√≠
por
dos
puntos
utilizando
BGP
.
Considere
el
tr√°-


fico
que
va
de
A
a
D.
B
preferir√≠a
manipular
dicho
tr√°fico
hacia
C
por
el
enlace
de
 

PROBLEMAS
409


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
409la
Costa
Oeste
(
de
modo
que
C
tendr√≠a
que
absorber
el
coste
de
transportar
el
tr√°-


fico
a
trav√©s
del
pa√≠s
)
,
mientras
que
C
preferir√≠a
obtener
ese
tr√°fico
a
trav√©s
del


enlace
con
B
de
la
Costa
Este
,
en
cuyo
caso
B
tendr√≠a
que
transportar
el
tr√°fico
a


trav√©s
del
pa√≠s
.
¬ø
Qu√©
mecanismo
BGP
podr√≠a
utilizar
C
para
que
B
llevara
el
tr√°-


fico
de
A-a-D
al
punto
de
contacto
de
la
Costa
Este
?
Para
responder
a
esta
pre-


gunta
,
tendr√°
que
ahondar
en
la
especificaci√≥n
de
BGP
.


P38
.
En
la
Figura
4.42
,
considere
la
informaci√≥n
de
rutas
que
llega
a
las
redes
terminales


(
stub
)
W
,
X
y
Y
.
Bas√°ndose
en
la
informaci√≥n
disponible
en
W
y
X
,
¬ø
cu√°les
son
sus


respectivas
im√°genes
de
la
topolog√≠a
de
la
red
?
Justifique
su
respuesta
.
La
imagen
de


la
topolog√≠a
en
Y
se
muestra
a
continuaci√≥n
.
 

P39
.
Considere
la
Figura
4.42
.
B
nunca
reenviar√≠a
tr√°fico
destinado
a
Y
a
trav√©s
de
X


bas√°ndose
en
el
enrutamiento
BGP
.
Pero
existen
algunas
aplicaciones
muy
populares


en
las
que
los
paquetes
de
datos
se
dirigen
primero
a
X
y
luego
fluyen
hacia
Y
.
Identi-


fique
una
de
tales
aplicaciones
y
describa
c√≥mo
los
paquetes
de
datos
siguen
una
ruta


que
no
ha
sido
determinada
por
el
enrutamiento
BGP
.


P40
.
En
la
Figura
4.42
,
suponga
que
existe
otra
red
terminal
V
que
es
un
cliente
del
ISP
A.


Suponga
que
B
y
C
tienen
una
relaci√≥n
de
pares
y
que
A
es
cliente
tanto
de
B
como
de


C.
Suponga
tambi√©n
que
A
preferir√≠a
que
el
tr√°fico
destinado
a
W
procediera
s√≥lo
de


B
,
y
que
el
tr√°fico
destinado
a
V
procediera
de
B
o
de
C.
¬ø
C√≥mo
podr√≠a
anunciar
A
sus


rutas
a
B
y
C
?
¬ø
Qu√©
rutas
del
sistema
aut√≥nomo
recibe
C
?


410
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
410P41
.
Considere
la
red
de
siete
nodos
(
con
los
nodos
etiquetados
de
t
a
z
)
del
Problema
P4
.


Demuestre
que
el
√°rbol
de
coste
m√≠nimo
con
ra√≠z
en
z
incluye
(
como
hosts
terminales
)


los
nodos
u
,
v
,
w
y
y.
Demuestre
informalmente
que
este
√°rbol
es
un
√°rbol
de
coste


m√≠nimo
.


P42
.
Considere
los
dos
m√©todos
b√°sicos
identificados
para
llevar
a
cabo
la
difusi√≥n
por


emulaci√≥n
de
unidifusi√≥n
y
basada
en
la
capa
de
red
(
es
decir
,
con
ayuda
de
los
rou-


ters
)
y
suponga
que
se
utiliza
la
difusi√≥n
por
√°rbol
de
recubrimiento
para
realizar
dicha


comunicaci√≥n
en
la
capa
de
red
.
Considere
un
√∫nico
emisor
y
32
receptores
.
Suponga


que
el
emisor
est√°
conectado
a
los
receptores
mediante
un
√°rbol
binario
de
routers
.


Para
esta
topolog√≠a
,
¬ø
cu√°l
es
el
coste
de
enviar
un
paquete
de
difusi√≥n
en
los
casos
de


difusi√≥n
por
emulaci√≥n
de
unidifusi√≥n
y
basada
en
la
capa
de
red
?
Aqu√≠
,
cada
vez


que
se
env√≠a
un
paquete
(
o
una
copia
de
un
paquete
)
a
trav√©s
de
un
√∫nico
enlace
se


a√±ade
una
unidad
de
coste
.
¬ø
Qu√©
topolog√≠a
de
interconexi√≥n
entre
el
emisor
,
los
recep-


tores
y
los
routers
har√°
que
se
diferencien
lo
m√°ximo
posible
el
coste
de
la
emulaci√≥n


de
unidifusi√≥n
y
el
de
la
verdadera
difusi√≥n
basada
en
la
capa
de
red
?
Puede
seleccio-


nar
tantos
routers
como
desee
.


P43
.
Considere
la
operaci√≥n
del
algoritmo
de
reenv√≠o
de
camino
inverso
(
RPF
)
utilizado
en


la
Figura
4.44
.
Utilizando
la
misma
topolog√≠a
,
determine
un
conjunto
de
rutas
desde


todos
los
nodos
al
nodo
de
origen
A
(
e
indique
estas
rutas
en
un
grafo
utilizando
l√≠neas


sombreadas
m√°s
gruesas
como
en
la
Figura
4.44
)
,
tal
que
si
esas
rutas
fueran
las
rutas


de
coste
m√≠nimo
,
entonces
el
nodo
B
recibir√≠a
una
copia
del
mensaje
de
difusi√≥n
de
A


procedente
de
los
nodos
A
,
C
y
D
bajo
RPF
.


P44
.
Considere
la
topolog√≠a
mostrada
en
la
Figura
4.44
.
Suponga
que
todos
los
enlaces
tie-


nen
un
coste
unitario
y
que
el
nodo
E
es
el
origen
de
las
comunicaciones
por
difusi√≥n
.


Utilizando
flechas
como
las
mostradas
en
la
Figura
4.44
,
indique
los
enlaces
por
los


que
se
reenviar√°n
los
paquetes
utilizando
RPF
y
los
enlaces
por
los
que
los
paquetes


no
ser√°n
reenviados
,
dado
que
el
nodo
E
es
el
origen
.


P45
.
Repita
el
Problema
P44
utilizando
el
grafo
del
Problema
P24
.
Suponga
que
z
es
el
ori-


gen
de
la
difusi√≥n
y
que
los
costes
de
los
enlaces
son
los
mostrados
en
el
Problema
P22
.


P46
.
Considere
la
topolog√≠a
mostrada
en
la
Figura
4.46
y
suponga
que
cada
enlace
tiene
un


coste
igual
a
la
unidad
.
Suponga
que
se
elige
el
nodo
C
como
el
nodo
central
de
un


algoritmo
de
enrutamiento
por
multidifusi√≥n
basado
en
un
nodo
central
.
Suponiendo


que
cada
router
conectado
utiliza
su
ruta
de
coste
m√≠nimo
hacia
el
nodo
C
para
enviar


mensajes
de
uni√≥n
a
C
,
dibuje
el
√°rbol
de
enrutamiento
basado
en
un
nodo
central


resultante
.
¬ø
Es
el
√°rbol
resultante
el
√°rbol
de
coste
m√≠nimo
?
Justifique
su
respuesta
.


P47
.
Repita
el
Problema
P46
utilizando
el
grafo
del
Problema
P24
.
Suponga
que
el
nodo


central
es
el
nodo
v.


P48
.
En
la
Secci√≥n
4.5.1
hemos
estudiado
el
algoritmo
de
enrutamiento
de
estado
de
enla-


ces
de
Dijkstra
para
calcular
las
rutas
de
unidifusi√≥n
que
son
,
individualmente
,
las


rutas
de
coste
m√≠nimo
desde
el
origen
hacia
todos
los
destinos
.
Podr√≠a
pensarse
que
la


uni√≥n
de
estas
rutas
dar√°
como
resultado
un
√°rbol
de
rutas
de
unidifusi√≥n
de
coste


m√≠nimo
(
o
un
√°rbol
de
rutas
de
unidifusi√≥n
m√°s
cortas
,
si
todos
los
costes
de
los
enla-


ces
son
id√©nticos
)
.
Construyendo
un
contraejemplo
,
demuestre
que
el
√°rbol
de
la
ruta


de
coste
m√≠nimo
no
siempre
es
igual
que
el
√°rbol
de
recubrimiento
m√≠nimo
.


PROBLEMAS
411


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
411P49
.
Considere
una
red
en
la
que
todos
los
nodos
est√°n
conectados
a
otros
tres
nodos
.
En


un
√∫nico
intervalo
de
tiempo
,
un
nodo
puede
recibir
todos
los
paquetes
de
difusi√≥n


transmitidos
desde
sus
vecinos
,
duplicar
los
paquetes
y
enviarlos
a
cada
uno
de
sus


vecinos
(
excepto
al
nodo
que
env√≠o
un
paquete
concreto
)
.
En
el
siguiente
intervalo
de


tiempo
,
los
nodos
vecinos
puede
recibir
,
duplicar
y
reenviar
estos
paquetes
,
y
as√≠
suce-


sivamente
.
Suponga
que
se
utiliza
la
t√©cnica
de
inundaci√≥n
no
controlada
para
propor-


cionar
comunicaci√≥n
por
difusi√≥n
en
una
red
as√≠
.
En
el
intervalo
de
tiempo
t
,
¬ø
cu√°ntas


copias
del
paquete
de
difusi√≥n
se
transmitir√°n
,
suponiendo
que
durante
el
intervalo
de


tiempo
1
el
nodo
de
origen
transmiti√≥
un
√∫nico
paquete
de
difusi√≥n
a
sus
tres
vecinos
?


P50
.
Hemos
visto
en
la
Secci√≥n
4.7
que
no
existe
ning√∫n
protocolo
de
la
capa
de
red
que
se


pueda
utilizar
para
identificar
a
los
hosts
que
participan
en
un
grupo
de
multidifusi√≥n
.


Sabiendo
esto
,
¬ø
c√≥mo
pueden
aprender
las
aplicaciones
de
multidifusi√≥n
las
identida-


des
de
los
hosts
que
est√°n
participando
en
un
grupo
de
multidifusi√≥n
?


P51
.
Dise√±e
(
proporcione
el
pseudoc√≥digo
)
para
un
protocolo
del
nivel
de
aplicaci√≥n
que


mantenga
las
direcciones
de
host
de
todos
los
host
participantes
en
un
grupo
de
multi-


difusi√≥n
.
Identifique
espec√≠ficamente
el
servicio
de
red
(
unidifusi√≥n
o
multidifusi√≥n
)


que
vaya
a
utilizar
su
protocolo
e
indique
si
su
protocolo
est√°
enviando
mensajes
en


banda
o
fuera
de
banda
(
con
respecto
al
flujo
de
datos
de
aplicaci√≥n
entre
los
partici-


pantes
del
grupo
de
multidifusi√≥n
)
y
por
qu√©
.


P52
.
¬ø
Cu√°l
es
el
tama√±o
del
espacio
de
direcciones
de
multidifusi√≥n
?
Suponga
ahora
que


dos
grupos
de
multidifusi√≥n
seleccionan
aleatoriamente
una
direcci√≥n
de
multidifu-


si√≥n
.
¬ø
Cu√°l
es
la
probabilidad
de
que
elijan
la
misma
direcci√≥n
?
Suponga
que
1.000


grupos
de
multidifusi√≥n
est√°n
activos
al
mismo
tiempo
y
seleccionan
sus
direcciones


de
grupo
de
multidifusi√≥n
aleatoriamente
.
¬ø
Cu√°l
es
la
probabilidad
de
que
interfieran


entre
s√≠
?


Preguntas
para
la
discusi√≥n


D1
.
Localice
tres
empresas
que
vendan
actualmente
routers
de
alta
velocidad
.
Compare


los
routers
m√°s
potentes
que
comercialicen
.
¬ø
C√≥mo
definir√≠a
‚Äú
m√°s
potente
‚Äù
?


D2
.
Utilice
el
servicio
whois
del
Registro
americano
de
n√∫meros
de
Internet
(
http://www
.


arin.net/whois
)
para
determinar
los
bloques
de
direcciones
IP
de
tres
universidades
.


¬ø
Puede
utilizarse
el
servicio
whois
para
determinar
con
certeza
la
ubicaci√≥n
geogr√°-


fica
de
una
direcci√≥n
IP
espec√≠fica
?


D3
.
¬ø
Es
posible
escribir
en
Java
el
programa
cliente
ping
(
utilizando
mensajes
ICMP
)
?


¬ø
Por
qu√©
?


D4
.
En
la
Secci√≥n
4.4
hemos
comentado
que
la
implantaci√≥n
de
IPv6
ha
sido
lenta
.
¬ø
Por


qu√©
ha
sido
lenta
?
¬ø
Qu√©
se
necesita
para
acelerar
su
implantaci√≥n
?


D5
.
Comente
algunos
de
los
problemas
que
NAT
crea
a
la
seguridad
IPsec
(
consulte
[
Phi-


fer
2000
]
)
.


D6
.
Estudie
el
protocolo
UPnP.
Describa
los
mensajes
que
utiliza
un
host
para
reconfigu-


rar
un
traductor
NAT
.


412
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
412D7
.
Suponga
que
los
sistemas
aut√≥nomos
X
y
Z
no
est√°n
directamente
conectados
,
pero


est√°n
conectados
a
trav√©s
del
sistema
aut√≥nomo
Y
.
Suponga
tambi√©n
que
X
tiene
un


acuerdo
de
comunicaci√≥n
entre
pares
con
Y
,
y
que
Y
tiene
un
acuerdo
similar
con
Z.


Por
√∫ltimo
,
suponga
que
Z
desea
transferir
todo
el
tr√°fico
de
Y
pero
no
el
de
X.
¬ø
Per-


mite
BGP
implementar
esta
pol√≠tica
a
Z
?


D8
.
En
la
Secci√≥n
4.7
hemos
identificado
una
serie
de
aplicaciones
de
multidifusi√≥n
.


¬ø
Cu√°les
de
estas
aplicaciones
est√°n
bien
adaptadas
para
el
modelo
minimalista
de
ser-


vicio
de
multidifusi√≥n
de
Internet
?
¬ø
Por
qu√©
?
¬ø
Qu√©
aplicaciones
no
est√°n
especial-


mente
bien
adaptadas
a
este
modelo
de
servicio
?


Tareas
de
programaci√≥n


En
esta
tarea
de
programaci√≥n
,
tendr√°
que
escribir
un
conjunto
‚Äú
distribuido
‚Äù
de
procedi-


mientos
que
implemente
un
enrutamiento
as√≠ncrono
distribuido
por
vector
de
distancias
para


la
red
que
se
muestra
m√°s
abajo
.


Tendr√°
que
escribir
las
siguientes
rutinas
que
se
‚Äú
ejecutar√°n
‚Äù
de
forma
as√≠ncrona
dentro


del
entorno
emulado
proporcionado
para
esta
tarea
.
Para
el
nodo
0
,
escribir√°
las
rutinas


siguientes
:


‚Ä¢
rtinit0
(
)
.
Se
llamar√°
a
esta
rutina
una
vez
al
principio
de
la
emulaci√≥n
.
rtinit0
(
)
no
tiene


argumentos
.
Debe
inicializar
su
tabla
de
distancias
en
el
nodo
0
para
reflejar
los
costes


directos
de
1
,
3
y
7
a
los
nodos
1
,
2
y
3
,
respectivamente
.
En
la
figura
de
encima
,
todos


los
enlaces
son
bidireccionales
y
los
costes
en
ambas
direcciones
son
id√©nticos
.
Despu√©s


de
inicializar
la
tabla
de
distancias
y
cualquier
otra
estructura
de
datos
que
necesiten
sus


rutinas
del
nodo
0
,
deber√°
entonces
enviar
a
sus
vecinos
directamente
conectados
(
en
este


caso
,
1
,
2
y
3
)
el
coste
de
sus
rutas
de
coste
m√≠nimo
a
los
dem√°s
nodos
de
la
red
.
La
infor-


maci√≥n
de
coste
m√≠nimo
se
env√≠a
a
los
nodos
vecinos
mediante
un
paquete
de
actualiza-


ci√≥n
de
enrutamiento
llamando
a
la
rutina
tolayer2
(
)
,
como
se
describe
en
la
tarea


completa
.
El
formato
del
paquete
de
actualizaci√≥n
de
enrutamiento
tambi√©n
est√°
descrito


en
la
tarea
completa
.


‚Ä¢
rtupdate0(struct
rtpkt
*
rcvdpkt
)
.
Se
llamar√°
a
esta
rutina
cuando
el
nodo
0
reciba
un


paquete
de
enrutamiento
que
le
haya
enviado
uno
de
sus
vecinos
directamente
conec-


tados
.
El
par√°metro
*
rcvdpkt
es
un
puntero
al
paquete
que
ha
recibido
.
rtupdate0
(
)
es
el


‚Äú
n√∫cleo
‚Äù
del
algoritmo
de
vector
de
distancias
.
Los
valores
recibidos
en
un
paquete


de
actualizaci√≥n
de
enrutamiento
procedente
de
alg√∫n
otro
nodo
i
contienen
los
costes


de
la
ruta
m√°s
corta
actual
de
i
hacia
todos
los
dem√°s
nodos
de
la
red
.
rtupdate0
(
)
utiliza


estos
valores
para
actualizar
su
propia
tabla
de
distancias
(
como
especifica
el
algoritmo


TAREAS
DE
PROGRAMACI√ìN
413


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
413de
vector
de
distancias
)
.
Si
su
propio
coste
m√≠nimo
a
otro
nodo
cambia
como
resultado


de
la
actualizaci√≥n
,
el
nodo
0
informa
de
este
cambio
del
coste
m√≠nimo
a
sus
vecinos


directamente
conectados
envi√°ndoles
un
paquete
de
enrutamiento
.
Recuerde
que
,
en
el


algoritmo
de
vector
de
distancias
,
s√≥lo
los
nodos
directamente
conectados
intercambia-


r√°n
paquetes
de
enrutamiento
.
Por
tanto
,
los
nodos
1
y
2
se
comunicar√°n
entre
s√≠
,
pero


los
nodos
1
y
3
no
lo
har√°n
.


Para
los
nodos
1
,
2
y
3
se
definen
rutinas
similares
.
Por
tanto
,
tendr√°
que
escribir
ocho
pro-


cedimientos
en
total
:
rtinit0
(
)
,
rtinit1
(
)
,
rtinit2
(
)
,
rtinit3
(
)
,
rtupdate0
(
)
,
rtupdate1
(
)
,
rtup-


date2
(
)
y
rtupdate3
(
)
.
Estas
rutinas
implementar√°n
conjuntamente
un
c√°lculo
as√≠ncrono
y


distribuido
de
las
tablas
de
distancias
para
la
topolog√≠a
y
los
costes
mostrados
en
la
figura


anterior
.


Puede
encontrar
todos
los
detalles
acerca
de
esta
tarea
de
programaci√≥n
,
as√≠
como
el


c√≥digo
C
que
tendr√°
que
crear
en
el
entorno
hardware
/
software
simulado
en
http:/
/www
.


awl.com/kurose-ross
.
Tambi√©n
hay
disponible
una
versi√≥n
Java
de
la
tarea
.


Pr√°cticas
de
laboratorio
con
Wireshark


En
el
sitio
web
del
libro
,
http://www.awl.com/kurose-ross
,
encontrar√°
dos
pr√°cticas
de
labo-


ratorio
con
Wireshark
.
La
primera
de
ellas
examina
el
funcionamiento
del
protocolo
IP
y
el


formato
del
datagrama
de
IP
en
concreto
.
La
segunda
se
ocupa
del
uso
del
protocolo
ICMP


en
los
comandos
ping
y
traceroute
.


414
CAP√çTULO
4
‚Ä¢
LA
CAPA
DE
RED


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
414415


¬ø
Qu√©
le
hizo
especializarse
en
el
campo
de
las
redes
?


Estaba
trabajando
como
programador
en
UCLA
a
finales
de
la
d√©cada
de
1960
.
Mi
trabajo
estaba
finan-


ciado
por
la
Agencia
de
Proyectos
de
Investigaci√≥n
Avanzada
de
Defensa
de
Estados
Unidos
(
que


entonces
se
llamada
ARPA
y
ahora
DARPA
)
.
Trabajaba
en
el
laboratorio
del
profesor
Leonard


Kleinrock
en
el
Centro
de
Medidas
de
Red
para
la
recientemente
creada
red
ARPAnet
.
El
primer
nodo


de
ARPAnet
fue
instalado
en
UCLA
el
1
de
septiembre
de
1969
.
Yo
era
responsable
de
programar
una


computadora
que
se
utilizaba
para
capturar
informaci√≥n
de
rendimiento
acerca
de
ARPAnet
y
de
devol-


ver
esa
informaci√≥n
para
compararla
con
los
modelos
matem√°ticos
y
las
predicciones
relativas
al
ren-


dimiento
de
la
red
.


Aa
l
g
u
n
o
s
 
o
t
r
o
s
 
e
s
t
u
d
i
a
n
t
e
s
 
y
 
a
 
m
i
 
m
i
s
m
o
 
n
o
s
 
e
n
c
a
r
g
a
r
o
n
 
t
r
a
b
a
j
a
r
 
e
n
 
l
o
s
 
d
e
n
o
m
i
n
a
d
o
s
 
p
r
o
t
o
-


colos
de
nivel
de
host
de
ARPAnet
,
es
decir
,
en
los
procedimientos
y
formatos
que
permitir√≠an
que


muchos
tipos
distintos
de
computadoras
interactuaran
entre
s√≠
a
trav√©s
de
la
red
.
Una
investigaci√≥n
fas-


cinante
en
un
mundo
nuevo
(
para
m√≠
)
de
la
comunicaci√≥n
y
la
computaci√≥n
distribuida
.


Cuando
dise√±√≥
el
protocolo
,
¬ø
se
imaginaba
que
IP
llegar√≠a
a
ser
tan
ubicuo
como
lo
es
hoy
d√≠a
?


Cuando
Bob
Kahn
y
yo
comenzamos
a
trabajar
en
el
tema
en
1973
,
creo
que
est√°bamos
muy
concen-


trados
en
el
tema
fundamental
:
c√≥mo
hacer
que
una
serie
de
redes
de
paquetes
heterog√©neas
interope-


raran
,
partiendo
del
supuesto
de
que
no
pod√≠amos
modificar
las
propias
redes
.
Intent√°bamos
encontrar


una
forma
de
poder
interconectar
un
conjunto
arbitrario
de
redes
de
paquetes
de
manera
transparente
,


de
modo
que
las
computadoras
pudieran
comunicarse
de
terminal
a
terminal
sin
necesidad
de
realizar


ninguna
traducci√≥n
intermedia
.
Creo
que
√©ramos
conscientes
de
que
est√°bamos
trabajando
con
una
tec-


nolog√≠a
potente
y
ampliable
,
pero
me
parece
que
no
ten√≠amos
una
imagen
clara
de
lo
que
pod√≠a
llegar


a
ser
nuestro
mundo
con
centenares
de
millones
de
computadoras
interconectadas
a
trav√©s
de
Internet
.


Vinton
G.
Cerf


Vinton
G.
Cerf
es
Vicepresidente
y
jefe
de
estrategia
de
Internet
de


Google
.
Ha
trabajado
durante
m√°s
de
16
a√±os
en
MCI
en
distintos


puestos
,
acabando
all√≠
su
carrera
profesional
como
Vicepresidente


senior
de
Estrategia
Tecnol√≥gica
.
Es
muy
conocido
por
haber
sido


co-dise√±ador
de
los
protocolos
TCP
/
IP
y
de
la
arquitectura
de


Internet
.
Durante
el
tiempo
que
trabaj√≥
,
entre
1976
y
1982
,
en
la


Agencia
de
Proyectos
de
Investigaci√≥n
Avanzada
de
Defensa


(
DARPA
,
Department
of
Defense
Advanced
Research
Projects


Agency
)
de
Estados
Unidos
desempe√±√≥
un
papel
crucial
dirigiendo


el
desarrollo
de
Internet
y
de
las
tecnolog√≠as
de
seguridad
y
de


empaquetado
de
datos
relacionadas
con
Internet
.
Recibi√≥
la


Medalla
Presidencial
de
la
Libertad
en
2005
y
la
Medalla


Nacional
de
Tecnolog√≠a
en
1997
.
Es
licenciado
en
Matem√°ticas


por
la
Universidad
de
Stanford
y
Doctor
en
Ciencias
de
la


Computaci√≥n
por
UCLA
.


ENTREVISTA
CON
...


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
415416


¬ø
Cu√°l
cree
que
ser√°
el
futuro
de
las
redes
y
de
Internet
?
¬ø
Cu√°les
cree
que
son
los
principales
desa-


f√≠os
/
obst√°culos
a
los
que
nos
enfrentaremos
?


Creo
que
la
propia
Internet
y
las
redes
en
general
continuar√°n
evolucionando
y
expandi√©ndose
.
Ya
exis-


ten
suficientes
evidencias
para
afirmar
que
pronto
habr√°
miles
de
millones
de
dispositivos
compatibles


con
Internet
,
incluyendo
equipos
tales
como
tel√©fonos
m√≥viles
,
frigor√≠ficos
,
asistentes
digitales
perso-


nales
(
PDA
)
,
servidores
dom√©sticos
,
televisiones
,
adem√°s
de
la
colecci√≥n
habitual
de
computadoras


port√°tiles
,
servidores
,
etc.
Entre
los
principales
desaf√≠os
se
incluyen
el
soporte
para
la
movilidad
,
la


capacidad
de
las
bater√≠as
,
la
capacidad
de
los
enlaces
de
acceso
a
la
red
y
la
capacidad
de
ampliar
el


n√∫cleo
√≥ptico
de
la
red
de
forma
ilimitada
.
El
dise√±o
de
una
extensi√≥n
interplanetaria
de
Internet
es
un


proyecto
en
el
que
estoy
profundamente
involucrado
en
el
Jet
Propulsion
Laboratory
.
Asimismo
,
nece-


sitaremos
hacer
la
transici√≥n
desde
IPv4
[
direcciones
de
32
bits
]
a
IPv6
[
direcciones
de
128
bits
]
.
¬°
Hay


una
larga
lista
de
desaf√≠os
!


¬ø
Qui√©n
le
ha
servido
de
inspiraci√≥n
profesionalmente
?


Mi
colega
Bob
Kahn
;
mi
director
de
tesis
,
Gerald
Estrin
;
mi
mejor
amigo
,
Steve
Crocker
(
nos
conoci-


mos
en
la
facultad
y
fue
√©l
el
que
me
introdujo
en
el
mundo
de
las
computadoras
1960
)
;
y
los
miles
de


ingenieros
que
hacen
que
Internet
contin√∫e
evolucionando
hoy
d√≠a
.


¬ø
Qu√©
consejo
le
dar√≠a
a
los
estudiantes
que
inician
su
andadura
en
el
campo
de
las


redes
/
Internet
?


Que
tienen
que
pensar
sin
tener
en
cuenta
las
limitaciones
de
los
sistemas
existentes
.
Deben
tratar
de


imaginar
qu√©
cosas
son
posibles
y
a
continuaci√≥n
ponerse
manos
a
la
obra
intentando
averiguar
c√≥mo


ir
hasta
all√≠
desde
el
estado
actual
de
las
cosas
.
Es
preciso
ser
capaz
de
so√±ar
:
media
docena
de
cole-


gas
y
yo
hemos
estado
trabajando
en
el
Jet
Propulsion
Laboratory
en
el
dise√±o
de
una
extensi√≥n
inter-


planetaria
de
la
Internet
terrestre
.
Puede
que
se
tarden
d√©cadas
en
implementar
esto
,
misi√≥n
a
misi√≥n
,


pero
parafraseando
un
conocido
dicho
:
‚Äú
El
hombre
debe
poder
llegar
m√°s
all√°
de
donde
su
mano
alcan-


za
;
¬ø
o
para
qu√©
son
los
cielos
si
no
?
‚Äù
.


M04_KURO9675_05_SE_CH04.qxd
 
22/3/10
 
09:29
 
P√°gina
416CAP√çTULO
5


La
capa
de
enlace


y
las
redes
de
√°rea


local


417


En
el
cap√≠tulo
anterior
hemos
visto
que
la
capa
de
red
proporciona
un
servicio
de
comunica-


ciones
entre
dos
hosts
.
Como
se
muestra
en
la
Figura
5.1
,
esta
ruta
de
comunicaci√≥n
est√°


compuesta
por
una
serie
de
enlaces
de
comunicaciones
,
que
comienzan
en
el
host
de
origen
,


pasan
a
trav√©s
de
una
serie
de
routers
y
terminan
en
el
host
de
destino
.
A
medida
que
conti-


nuamos
bajando
por
la
pila
de
protocolos
,
desde
la
capa
de
red
a
la
capa
de
enlace
,
surge
de


forma
natural
la
pregunta
de
c√≥mo
se
env√≠an
los
paquetes
a
trav√©s
de
los
enlaces
individua-


les
que
forman
la
ruta
de
comunicaci√≥n
de
terminal
a
terminal
.
¬ø
C√≥mo
se
encapsulan
los


datagramas
de
la
capa
de
red
en
las
tramas
de
la
capa
de
enlace
para
la
transmisi√≥n
a
trav√©s


de
un
enlace
individual
?
¬ø
Pueden
proporcionar
los
protocolos
de
la
capa
de
enlace
una
trans-


ferencia
de
datos
fiable
router
a
router
?
¬ø
Pueden
utilizarse
diferentes
protocolos
de
la
capa


de
enlace
en
los
distintos
enlaces
que
forman
la
ruta
de
comunicaciones
?
Responderemos
a


√©stas
y
otras
importantes
cuestiones
a
lo
largo
del
cap√≠tulo
.


Al
analizar
la
capa
de
enlace
,
nos
encontramos
con
que
hay
dos
tipos
de
canales
fun-


damentalmente
distintos
de
la
capa
de
enlace
.
El
primer
tipo
est√°
compuesto
por
los


canales
de
difusi√≥n
,
que
son
comunes
en
las
redes
de
√°rea
local
(
LAN
)
,
en
las
redes
LAN


inal√°mbricas
,
en
las
redes
por
sat√©lite
y
en
las
redes
de
acceso
h√≠bridas
de
fibra
y
cable
coa-


xial
(
HFC
)
.
En
un
canal
de
difusi√≥n
hay
muchos
hosts
conectados
a
un
mismo
canal
de


comunicaciones
,
por
lo
que
se
hace
necesario
utilizar
lo
que
se
denomina
un
protocolo
de


acceso
al
medio
para
coordinar
las
transmisiones
y
evitar
que
las
tramas
transmitidas
coli-


sionen
.
El
segundo
tipo
de
canal
de
la
capa
de
enlace
es
el
canal
de
comunicaciones
punto
a


punto
,
como
el
que
existe
entre
dos
routers
o
entre
un
m√≥dem
de
acceso
telef√≥nico
residen-


cial
y
el
router
de
un
ISP
.
La
coordinaci√≥n
del
acceso
a
un
enlace
punto
a
punto
es
trivial
,


pero
sigue
habiendo
problemas
importantes
relativos
al
entramado
,
a
la
transferencia
de


datos
fiable
,
a
la
detecci√≥n
de
errores
y
al
control
de
flujo
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
417En
este
cap√≠tulo
exploraremos
diversas
tecnolog√≠as
importantes
de
la
capa
de
enlace
.


Examinaremos
en
profundidad
Ethernet
,
que
es
con
mucho
la
tecnolog√≠a
de
LAN
cableada


m√°s
prevalente
.
Tambi√©n
examinaremos
el
Protocolo
punto
a
punto
(
PPP
,
Point-to-Point


Protocol
)
,
que
es
el
protocolo
preferido
para
los
hosts
residenciales
con
conexi√≥n
mediante


acceso
telef√≥nico
.
Aunque
WiFi
,
y
m√°s
en
general
las
redes
LAN
inal√°mbricas
,
es
un
tema


relacionado
con
la
capa
de
enlace
,
pospondremos
nuestro
estudio
de
este
importante
tema


hasta
el
Cap√≠tulo
6
,
que
est√°
dedicado
a
las
redes
de
computadoras
inal√°mbricas
y
a
la
movi-


lidad
.


418
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


ISP
nacional


o
global
Red


m√≥vil


ISP
local


o
regional


Red
empresarial


Red


dom√©stica
Red


F√≠sica


Enlace
de
datos


Red


F√≠sica


Enlace
de
datos


Red


F√≠sica


Enlace
de
datos


Red


F√≠sica


Enlace
de
datos


Red


F√≠sica


Enlace
de
datos


Red


F√≠sica


Aplicaci√≥n


Transporte


Enlace
de
datos


Red


F√≠sica


Aplicaci√≥n


Transporte


Enlace
de
datos


Host
de
origen


Host
de
destino


Figura
5.1
‚Ä¢
La
capa
de
enlace
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4185.1
‚Ä¢
CAPA
DE
ENLACE
:
INTRODUCCI√ìN
Y
SERVICIOS
419


5.1
Capa
de
enlace
:
introducci√≥n
y
servicios


Comencemos
proporcionando
alguna
terminolog√≠a
√∫til
.
En
este
cap√≠tulo
nos
resultar√°
con-


veniente
referirnos
a
los
hosts
y
los
routers
simplemente
como
nodos
ya
que
,
como
pronto


veremos
,
no
nos
va
a
preocupar
especialmente
si
un
determinado
nodo
es
un
router
o
un


host
.
Tambi√©n
nos
referimos
a
los
canales
de
comunicaci√≥n
que
conectan
nodos
adyacentes


a
lo
largo
de
la
ruta
de
comunicaciones
con
el
nombre
de
enlaces
.
Para
que
un
datagrama


pueda
ser
transferido
desde
el
host
de
origen
al
de
destino
,
debe
moverse
a
trav√©s
de
cada


uno
de
los
enlaces
individuales
que
forman
la
ruta
terminal
a
terminal
.
En
un
determinado


enlace
,
un
nodo
transmisor
encapsula
el
datagrama
en
una
trama
de
la
capa
de
enlace
y


transmite
la
trama
a
trav√©s
del
enlace
;
el
nodo
receptor
recibe
entonces
la
trama
y
extrae
el


datagrama
.


5.1.1
Servicios
proporcionados
por
la
capa
de
enlace


Para
transmitir
un
datagrama
a
trav√©s
de
un
enlace
individual
se
utiliza
un
protocolo
de
la


capa
de
enlace
.
El
protocolo
de
la
capa
de
enlace
define
el
formato
de
los
paquetes
inter-


cambiados
por
los
nodos
situados
en
los
extremos
del
enlace
,
as√≠
como
las
acciones
que


estos
nodos
llevan
a
cabo
cuando
se
env√≠an
y
reciben
los
paquetes
.
Recuerde
del
Cap√≠tulo
1


que
las
unidades
de
datos
intercambiadas
por
un
protocolo
de
la
capa
de
enlace
se
denomi-


nan
tramas
(
frames
)
,
y
que
cada
trama
de
la
capa
de
enlace
suele
encapsular
un
datagrama


de
la
capa
de
red
.
Como
pronto
veremos
,
las
acciones
que
el
protocolo
de
la
capa
de
enlace


lleva
a
cabo
a
la
hora
de
enviar
y
transmitir
tramas
incluye
la
detecci√≥n
de
errores
,
la
retrans-


misi√≥n
,
el
control
de
flujo
y
el
acceso
aleatorio
.
Como
ejemplos
de
protocolos
de
la
capa
de


enlace
podemos
citar
Ethernet
,
las
redes
LAN
inal√°mbricas
802.11
(
tambi√©n
denominadas


WiFi
)
,
token
ring
y
PPP
.
Hablaremos
en
detalle
de
muchos
de
estos
protocolos
en
la
segunda


mitad
de
este
cap√≠tulo
.


Mientras
que
la
capa
de
red
tiene
asignada
la
tarea
de
mover
los
segmentos
de
la
capa


de
transporte
terminal
a
terminal
desde
el
host
de
origen
al
host
de
destino
,
el
protocolo
de


la
capa
de
enlace
tiene
la
tarea
nodo
a
nodo
,
algo
m√°s
simple
,
de
mover
los
datagramas
de
la


capa
de
red
a
trav√©s
de
un
√∫nico
enlace
dentro
de
la
ruta
.
Una
caracter√≠stica
importante


de
la
capa
de
enlace
es
que
un
mismo
datagrama
puede
ser
transportado
por
diferentes
pro-


tocolos
de
la
capa
de
enlace
en
los
distintos
enlaces
que
forman
la
ruta
.
Por
ejemplo
,
un


datagrama
podr√≠a
ser
transportado
mediante
Ethernet
en
el
primer
enlace
,
mediante
PPP
en


el
√∫ltimo
enlace
y
mediante
un
protocolo
WAN
de
la
capa
de
enlace
en
los
enlaces
interme-


dios
.
Es
importante
observar
que
los
servicios
proporcionados
por
los
diferentes
protocolos


de
la
capa
de
enlace
a
lo
largo
de
una
ruta
terminal
a
terminal
pueden
ser
distintos
.
Por
ejem-


plo
,
algunos
protocolos
de
la
capa
de
enlace
proporcionan
una
entrega
fiable
,
mientras
que


otros
no
lo
hacen
.
Por
tanto
,
la
capa
de
red
debe
ser
capaz
de
realizar
su
trabajo
terminal
a


terminal
en
presencia
de
un
conjunto
heterog√©neo
de
servicios
individuales
de
la
capa
de


enlace
.


Para
poder
comprender
el
funcionamiento
de
la
capa
de
enlace
y
c√≥mo
√©sta
se
relaciona


con
la
capa
de
red
,
vamos
a
utilizar
una
analog√≠a
del
sector
del
transporte
.
Piense
en
una
agen-


cia
de
viajes
que
planifica
un
viaje
para
un
turista
que
quiere
ir
desde
Princeton
,
Nueva
Jer-


sey
,
a
Lausanne
,
Suiza
.
La
agencia
de
viajes
decide
que
lo
m√°s
conveniente
para
el
turista
es


tomar
una
limusina
en
Princeton
hasta
el
aeropuerto
JFK
,
luego
un
avi√≥n
desde
dicho
aero-


puerto
hasta
el
aeropuerto
de
Ginebra
y
,
finalmente
,
un
tren
desde
el
aeropuerto
de
Ginebra


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
419hasta
la
estaci√≥n
de
tren
de
Lausanne
.
Una
vez
que
la
agencia
de
viajes
hace
las
tres
reservas


es
responsabilidad
de
la
empresa
de
limousines
de
Princeton
llevar
al
turista
hasta
el
aero-


puerto
JFK
;
de
la
misma
forma
,
ser√°
responsabilidad
de
la
compa√±√≠a
a√©rea
transportar
al


turista
desde
el
aeropuerto
JFK
al
de
Ginebra
y
ser√°
responsabilidad
de
la
compa√±√≠a
ferrovia-


ria
Suiza
llevar
al
turista
desde
Ginebra
hasta
Lausanne
.
Cada
uno
de
estos
tres
segmentos


del
viaje
es
un
segmento
‚Äú
directo
‚Äù
entre
dos
ubicaciones
‚Äú
adyacentes
‚Äù
.
Observe
que
los
tres


segmentos
de
transporte
son
gestionados
por
diferentes
empresas
y
utilizan
modos
de
trans-


porte
completamente
distintos
(
limousine
,
avi√≥n
y
tren
)
.
Aunque
los
modos
de
transporte
son


diferentes
,
todos
ellos
proporcionan
el
servicio
b√°sico
de
transportar
pasajeros
desde
una


ubicaci√≥n
a
otra
adyacente
.
En
esta
analog√≠a
del
sector
del
transporte
,
el
turista
ser√≠a
un
da-


tagrama
,
cada
uno
de
los
segmentos
de
transporte
ser√≠a
un
enlace
de
comunicaciones
,
el


modo
de
transporte
ser√≠a
un
protocolo
de
la
capa
de
enlace
y
la
agencia
de
viajes
ser√≠a
un
pro-


tocolo
de
enrutamiento
.


Aunque
el
servicio
b√°sico
de
cualquier
capa
de
enlace
es
mover
un
datagrama
desde
un


nodo
hasta
otro
adyacente
a
trav√©s
de
un
√∫nico
enlace
de
comunicaciones
,
los
detalles
del


servicio
proporcionado
pueden
variar
de
un
protocolo
de
la
capa
de
enlace
a
otro
.
Entre
los


posibles
servicios
que
un
protocolo
de
la
capa
de
enlace
puede
ofrecer
se
incluyen
:


‚Ä¢
Entramado
.
Casi
todos
los
protocolos
de
la
capa
de
enlace
encapsulan
cada
datagrama
de


la
capa
de
red
dentro
de
una
trama
de
la
capa
de
enlace
antes
de
transmitirla
a
trav√©s
del


enlace
.
Una
trama
consta
de
un
campo
de
datos
,
en
el
que
se
inserta
el
datagrama
de
la


capa
de
red
,
y
de
una
serie
de
campos
de
cabecera
.
(
Una
trama
tambi√©n
puede
incluir
cam-


pos
de
cola
;
sin
embargo
,
utilizaremos
el
t√©rmino
campos
de
cabecera
para
referirnos
tanto


a
los
de
cabecera
como
a
los
de
cola
.
)
La
estructura
de
la
trama
est√°
especificada
por
el


protocolo
de
la
capa
de
enlace
.
Veremos
diferentes
formatos
de
trama
cuando
examine-


mos
una
serie
de
protocolos
espec√≠ficos
de
la
capa
de
enlace
en
la
segunda
mitad
de
este


cap√≠tulo
.


‚Ä¢
Acceso
al
enlace
.
Un
protocolo
de
control
de
acceso
al
medio
(
MAC
,
Medium
Access


Control
)
especifica
las
reglas
que
se
utilizan
para
transmitir
una
trama
a
trav√©s
del
enlace
.


Para
los
enlaces
punto
a
punto
que
tengan
un
√∫nico
emisor
en
un
extremo
del
enlace
y
un


√∫nico
receptor
en
el
otro
extremo
,
el
protocolo
MAC
es
muy
simple
(
o
no
existe
):
el
emi-


sor
puede
enviar
una
trama
siempre
que
el
enlace
est√©
inactivo
.
El
caso
m√°s
interesante


es
cuando
hay
varios
nodos
compartiendo
un
mismo
enlace
de
difusi√≥n
,
en
cuyo
caso
se


presenta
el
denominado
problema
del
acceso
m√∫ltiple
.
En
ese
caso
,
el
protocolo
 
MAC


sirve
para
coordinar
la
transmisi√≥n
de
las
tramas
de
los
m√∫ltiples
nodos
;
estudiaremos


los
protocolos
MAC
en
detalle
en
la
Secci√≥n
5.3
.


‚Ä¢
Entrega
fiable
.
Cuando
un
protocolo
de
la
capa
de
enlace
proporciona
un
servicio
de


entrega
fiable
,
garantiza
que
va
a
transportar
cada
datagrama
de
la
capa
de
red
a
trav√©s


del
enlace
sin
que
se
produzcan
errores
.
Recuerde
que
ciertos
protocolos
de
la
capa
de


transporte
(
como
TCP
)
tambi√©n
proporcionan
un
servicio
de
entrega
fiable
.
De
forma


similar
a
los
servicios
de
entrega
fiable
de
la
capa
de
transporte
,
el
servicio
de
entrega


fiable
de
la
capa
de
enlace
suele
implementarse
mediante
reconocimientos
y
retransmi-


siones
(
v√©ase
la
Secci√≥n
3.4
)
.
A
menudo
se
utiliza
un
servicio
de
entrega
fiable
de
la
capa


de
enlace
en
aquellos
enlaces
que
suelen
presentar
altas
tasas
de
error
,
como
por
ejemplo


en
los
enlaces
inal√°mbricos
,
con
el
objetivo
de
corregir
los
errores
localmente
(
en
el


enlace
en
el
que
se
producen
los
errores
)
,
en
lugar
de
obligar
a
que
un
protocolo
de
la


capa
de
transporte
o
de
la
de
aplicaci√≥n
realice
una
retransmisi√≥n
de
datos
terminal
a
ter-


420
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
420minal
.
Sin
embargo
,
la
entrega
fiable
en
la
capa
de
enlace
puede
considerarse
una
sobre-


carga
innecesaria
en
aquellos
enlaces
que
tengan
una
baja
tasa
de
errores
de
bit
,
inclu-


yendo
los
enlaces
de
fibra
,
los
coaxiales
y
muchos
enlaces
de
cobre
de
par
trenzado
.
Por


esta
raz√≥n
,
muchos
protocolos
de
la
capa
de
enlace
para
enlaces
cableados
no
proporcio-


nan
un
servicio
de
entrega
fiable
.


‚Ä¢
Control
de
flujo
.
Los
nodos
situados
en
cada
extremo
de
un
enlace
tienen
una
capacidad


limitada
de
almacenamiento
en
buffer
de
las
tramas
.
Esto
puede
ser
un
problema
cuando


el
nodo
receptor
puede
recibir
las
tramas
a
m√°s
velocidad
de
la
que
puede
procesarlas
.
Sin


un
control
de
flujo
,
el
buffer
del
receptor
puede
desbordarse
con
lo
que
las
tramas
se
per-


der√≠an
.
De
forma
similar
a
lo
que
sucede
en
la
capa
de
transporte
,
el
protocolo
de
la
capa


de
enlace
puede
proporcionar
un
mecanismo
de
control
de
flujo
para
evitar
que
el
nodo


emisor
al
otro
lado
del
enlace
abrume
al
nodo
receptor
situado
en
el
otro
extremo
.


‚Ä¢
Detecci√≥n
de
errores
.
El
hardware
de
la
capa
de
enlace
en
un
nodo
receptor
pudiera
lle-


gar
a
decidir
,
incorrectamente
,
que
un
bit
contenido
en
una
trama
es
cero
cuando
fue


transmitido
como
un
uno
,
y
viceversa
.
Dichos
errores
de
bit
se
introducen
debido
a
la


atenuaci√≥n
de
las
se√±ales
y
al
ruido
electromagn√©tico
.
Puesto
que
no
existe
ninguna


necesidad
de
reenviar
un
datagrama
que
contenga
un
error
,
muchos
protocolos
de
la


capa
de
enlace
proporcionan
un
mecanismo
para
detectar
dichos
errores
de
bit
.
Esto
se


lleva
a
cabo
haciendo
que
el
nodo
transmisor
incluya
bits
de
detecci√≥n
de
errores
en
la


trama
y
que
el
nodo
receptor
realice
una
comprobaci√≥n
de
errores
.
Recuerde
de
los


Cap√≠tulos
3
y
4
que
las
capas
de
transporte
y
de
red
de
Internet
tambi√©n
ofrecen
una


forma
limitada
de
detecci√≥n
de
errores
:
la
suma
de
comprobaci√≥n
de
Internet
.
La
detec-


ci√≥n
de
errores
en
la
capa
de
enlace
normalmente
es
m√°s
sofisticada
y
se
implementa
en


hardware
.


‚Ä¢
Correcci√≥n
de
errores
.
La
correcci√≥n
de
errores
es
similar
a
la
detecci√≥n
de
errores
,
salvo


porque
el
receptor
no
s√≥lo
detecta
si
hay
bits
err√≥neos
en
la
trama
,
sino
que
tambi√©n


determina
exactamente
en
qu√©
puntos
de
la
trama
se
han
producido
los
errores
(
y
luego


corrige
esos
errores
)
.
Algunos
protocolos
proporcionan
correcci√≥n
de
errores
en
la
capa


de
enlace
s√≥lo
para
la
cabecera
del
paquete
en
lugar
de
para
el
paquete
completo
.
Habla-


remos
de
la
detecci√≥n
y
correcci√≥n
de
errores
en
la
Secci√≥n
5.2
.


‚Ä¢
Semiduplex
y
full-duplex
.
Con
la
transmisi√≥n
full-duplex
,
los
nodos
de
ambos
extremos


de
un
enlace
pueden
transmitir
paquetes
al
mismo
tiempo
.
Sin
embargo
,
con
la
transmi-


si√≥n
semiduplex
un
mismo
nodo
no
puede
transmitir
y
recibir
al
mismo
tiempo
.


Como
hemos
indicado
anteriormente
,
muchos
de
los
servicios
proporcionados
por
la


capa
de
enlace
presentan
notables
paralelismos
con
los
servicios
proporcionados
en
la
capa


de
transporte
.
Por
ejemplo
,
tanto
la
capa
de
enlace
como
la
capa
de
transporte
pueden
pro-


porcionar
un
servicio
de
entrega
fiable
.
Aunque
los
mecanismos
utilizados
para
garantizar


una
entrega
fiable
en
las
dos
capas
son
similares
(
v√©ase
la
Secci√≥n
3.4
)
,
los
dos
servicios
de


entrega
fiable
no
son
id√©nticos
.
Un
protocolo
de
transporte
proporciona
una
entrega
fiable


de
segmentos
entre
dos
procesos
,
en
modo
terminal
a
terminal
;
un
protocolo
de
la
capa
de


enlace
fiable
proporciona
una
entrega
fiable
de
tramas
entre
dos
nodos
conectados
por


un
√∫nico
enlace
.
De
forma
similar
,
los
protocolos
de
la
capa
de
transporte
como
los
de
la


capa
de
enlace
pueden
proporcionar
servicios
de
control
de
flujo
y
de
detecci√≥n
de
errores
,


pero
de
nuevo
el
control
de
flujo
en
un
protocolo
de
la
capa
de
transporte
se
proporciona
en


modo
terminal
a
terminal
,
mientras
que
en
un
protocolo
de
la
capa
de
enlace
se
proporciona


entre
dos
nodos
adyacentes
.


5.1
‚Ä¢
CAPA
DE
ENLACE
:
INTRODUCCI√ìN
Y
SERVICIOS
421


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4215.1.2
¬ø
D√≥nde
se
implementa
la
capa
de
enlace
?


Antes
de
profundizar
en
los
detalles
de
la
capa
de
enlace
,
consideremos
la
cuesti√≥n
de


d√≥nde
se
implementa
esta
capa
.
Nos
centraremos
aqu√≠
en
un
sistema
terminal
,
puesto
que
ya


hemos
visto
en
el
Cap√≠tulo
4
c√≥mo
se
implementa
la
capa
de
enlace
en
una
tarjeta
de
l√≠nea


de
un
router
.
¬ø
C√≥mo
se
implementa
la
capa
de
enlace
de
un
host
,
por
hardware
o
por
soft-


ware
?
¬ø
Se
implementa
en
una
tarjeta
o
chip
separados
?
¬ø
C√≥mo
se
realiza
la
interfaz
con
el


resto
del
hardware
del
host
y
con
el
resto
de
los
componentes
del
sistema
operativo
?


La
Figura
5.2
muestra
la
arquitectura
t√≠pica
de
un
host
.
En
su
mayor
parte
,
la
capa
de


enlace
se
implementa
en
un
adaptador
de
red
,
tambi√©n
denominado
a
veces
Tarjeta
de


interfaz
de
red
(
NIC
,
Network
Interface
Card
)
.
El
coraz√≥n
de
la
tarjeta
adaptador
de
red


es
el
controlador
de
la
capa
de
enlace
,
que
normalmente
es
un
√∫nico
chip
de
prop√≥sito
espe-


cial
que
implementa
muchos
de
los
servicios
de
la
capa
de
enlace
(
entramado
,
acceso
al


enlace
,
control
de
flujo
,
detecci√≥n
de
errores
,
etc.
)
identificados
en
la
secci√≥n
anterior
.
Por


tanto
,
buena
parte
de
la
funcionalidad
del
controlador
de
la
capa
de
enlace
se
implementa


por
hardware
.
Por
ejemplo
,
el
controlador
8254x
de
Intel
[
Intel
2009
]
implementa
los
proto-


colos
Ethernet
que
estudiaremos
en
la
Secci√≥n
5.5
;
el
controlador
Atheros
AR5006
[
Atheros


2009
]
implementa
los
protocolos
WiFi
802.11
que
estudiaremos
en
la
Secci√≥n
6.3
.
Hasta


finales
de
la
d√©cada
de
1990
,
la
mayor√≠a
de
los
adaptadores
de
red
eran
tarjetas
f√≠sicamente


separadas
,
como
por
ejemplo
las
tarjetas
PCMCIA
o
una
tarjeta
insertable
que
pod√≠a
intro-


ducirse
en
una
ranura
de
tarjeta
PCI
del
PC
,
pero
los
adaptadores
de
red
se
suelen
integrar


cada
vez
m√°s
en
la
placa
base
del
host
,
utilizando
una
configuraci√≥n
que
se
denomina
‚Äú
LAN


sobre
placa
base
‚Äù
.


En
el
lado
emisor
,
el
controlador
toma
un
datagrama
que
haya
sido
creado
y
almace-


nado
en
la
memoria
del
host
por
las
capas
superiores
de
la
pila
de
protocolos
,
encapsula
ese


422
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


Host


Memoria


Bus
del
host


(
por
ejemplo
,
PCI
)


CPU


Controlador


Transmisi√≥n


f√≠sica


Adaptador
de
redEnlace


F√≠sica


Transporte


Red


Enlace


Aplicaci√≥n


Figura
5.2
‚Ä¢
Adaptador
de
red
:
su
relaci√≥n
con
otros
componentes
del
host
y


con
la
funcionalidad
de
la
pila
de
protocolos
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
422datagrama
en
una
trama
de
la
capa
de
enlace
(
rellenando
los
diversos
campos
de
la
trama
)
y


luego
transmite
la
trama
al
enlace
de
comunicaciones
,
de
acuerdo
con
el
protocolo
de
acceso


al
enlace
.
En
el
lado
receptor
,
un
controlador
recibe
la
trama
completa
y
extrae
el
datagrama


de
la
capa
de
red
.
Si
la
capa
de
enlace
realiza
detecci√≥n
de
errores
,
entonces
ser√°
el
controla-


dor
del
emisor
quien
se
encargue
de
configurar
los
bits
de
detecci√≥n
de
errores
en
la
cabe-


cera
de
la
trama
,
mientras
que
el
controlador
del
receptor
llevar√°
a
cabo
la
detecci√≥n
de


errores
.
Si
la
capa
de
enlace
realiza
control
de
flujo
,
entonces
los
controladores
del
emisor
y


del
receptor
intercambian
informaci√≥n
de
control
de
flujo
de
modo
que
el
emisor
env√≠e
las


tramas
a
una
velocidad
que
el
receptor
sea
capaz
de
aceptar
.


La
Figura
5.2
muestra
un
adaptador
de
red
conectado
a
un
bus
del
host
(
por
ejemplo
,


un
bus
PCI
o
PCI-X
)
,
de
modo
que
a
ojos
de
los
restantes
componentes
del
host
se
parece


bastante
a
cualquier
otro
dispositivo
de
E
/
S.
La
Figura
5.2
tambi√©n
muestra
que
,
mientras


que
la
mayor
parte
de
la
capa
de
enlace
est√°
implementada
en
el
hardware
de
la
tarjeta
de


interfaz
,
una
parte
de
esa
capa
se
implementa
en
un
software
que
se
ejecuta
en
la
CPU


del
host
.
Los
componentes
software
de
la
capa
de
enlace
,
normalmente
implementan
la
fun-


ci√≥n
de
m√°s
alto
nivel
de
esa
capa
,
como
por
ejemplo
la
recepci√≥n
del
datagrama
desde
la


capa
de
red
,
el
ensamblado
de
la
informaci√≥n
de
direccionamiento
de
la
capa
de
enlace
y


la
activaci√≥n
del
hardware
del
controlador
.
En
el
lado
receptor
,
el
software
de
la
capa
de


enlace
responde
a
las
interrupciones
procedentes
del
controlador
(
por
ejemplo
,
debidas
a


la
recepci√≥n
de
una
o
m√°s
tramas
)
,
se
encarga
de
gestionar
las
condiciones
de
error
y
pasa


el
datagrama
hacia
la
capa
de
red
.
Por
tanto
,
la
capa
de
enlace
es
una
combinaci√≥n
de


hardware
y
software
;
es
el
lugar
de
la
pila
de
protocolos
en
donde
el
software
se
encuentra


con
el
hardware
.
En
[
Intel
2009
]
puede
encontrar
una
introducci√≥n
comprensible
(
as√≠
como


una
descripci√≥n
detallada
)
del
controlador
8254
x
,
desde
el
punto
de
vista
del
programador


de
software
.


La
Figura
5.3
muestra
las
tarjetas
adaptadoras
de
emisi√≥n
y
recepci√≥n
.
Dado
que
la
fun-


cionalidad
principal
del
protocolo
de
la
capa
de
enlace
est√°
implementada
en
el
controlador
,


los
adaptadores
son
unidades
semi-aut√≥nomas
cuyo
trabajo
consiste
en
transferir
una
trama


de
un
adaptador
a
otro
.
Hay
diversos
investigadores
que
han
analizado
la
posibilidad
de
inte-


grar
m√°s
funcionalidad
(
adem√°s
del
procesamiento
de
la
capa
de
enlace
)
en
los
adaptadores


de
red
.
El
controlador
8254
x
,
por
ejemplo
,
puede
calcular
la
suma
de
comprobaci√≥n


TCP
/
UDP
y
la
suma
de
comprobaci√≥n
de
la
cabecera
IP
por
hardware
,
lo
que
significa
que


hay
funcionalidad
de
las
capas
de
red
y
de
transporte
que
est√°
implementada
en
el
controla-


dor
de
la
capa
de
enlace
.
Aunque
esto
pueda
parecer
una
sorprendente
violaci√≥n
del
princi-


pio
de
divisi√≥n
en
capas
,
la
ventaja
es
que
las
sumas
de
comprobaci√≥n
pueden
calcularse


5.1
‚Ä¢
CAPA
DE
ENLACE
:
INTRODUCCI√ìN
Y
SERVICIOS
423


Enlace
f√≠sico


Protocolo
de
la
capa
de
enlace


Trama


Datagrama


Tarjeta
adaptadoraTarjeta
adaptadora


Figura
5.3
‚Ä¢
Adaptadores
de
red
comunic√°ndose
:
un
datagrama
de
la
capa
de


red
encapsulado
en
una
trama
de
la
capa
de
enlace
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
423mucho
m√°s
r√°pidamente
mediante
hardware
que
mediante
software
,
tanto
que
uno
se
senti-


r√≠a
tentado
de
ignorar
esta
violaci√≥n
de
las
normas
.
[
Mogul
2003
]
proporciona
un
inte-


resante
an√°lisis
de
los
pros
y
contras
de
llevar
a
cabo
procesamiento
TCP
en
un


adaptador
.
[
Kim
2005
]
investiga
la
conveniencia
de
llevar
a
cabo
funcionalidades
de


capas
m√°s
altas
(
cach√©
HTTP
)
en
el
adaptador
.


5.2
T√©cnicas
de
detecci√≥n
y
correcci√≥n
de
errores


En
la
secci√≥n
anterior
hemos
indicado
que
la
detecci√≥n
y
correcci√≥n
de
errores
de
nivel


bit
(
la
detecci√≥n
y
correcci√≥n
de
los
bits
corruptos
en
una
trama
de
la
capa
de
enlace
enviada


desde
un
nodo
a
otro
nodo
vecino
f√≠sicamente
conectado
a
√©l
)
son
dos
servicios
ofrecidos
a


menudo
por
la
capa
de
enlace
.
Hemos
visto
en
el
Cap√≠tulo
3
que
en
la
capa
de
transporte
se


ofrecen
tambi√©n
a
menudo
los
servicios
de
detecci√≥n
y
correcci√≥n
de
errores
.
En
esta
sec-


ci√≥n
examinaremos
algunas
de
las
t√©cnicas
m√°s
simples
que
pueden
utilizarse
para
detectar


y
,
en
algunos
casos
,
corregir
dichos
errores
de
bit
.
Un
tratamiento
completo
de
la
teor√≠a
e


implementaci√≥n
de
estas
t√©cnicas
constituye
por
s√≠
mismo
el
tema
de
muchos
libros
de
texto


(
por
ejemplo
,
[
Schwartz
1980
]
o
[
Bertsekas
1991
]
)
,
pero
el
tratamiento
que
realizaremos


aqu√≠
es
necesariamente
breve
.
Nuestro
objetivo
es
desarrollar
simplemente
en
el
lector
una


percepci√≥n
intuitiva
de
las
capacidades
proporcionadas
por
las
t√©cnicas
de
detecci√≥n
y


correcci√≥n
de
errores
,
y
ver
c√≥mo
funcionan
unas
cuantas
t√©cnicas
simples
y
c√≥mo
se


emplean
en
la
pr√°ctica
dentro
de
la
capa
de
enlace
.


La
Figura
5.4
ilustra
la
configuraci√≥n
para
nuestro
an√°lisis
.
En
el
nodo
emisor
,
los
datos


que
hay
que
proteger
frente
a
los
errores
de
bit
,
D
,
se
complementan
con
una
serie
de
bits
de


detecci√≥n
y
correcci√≥n
de
errores
(
EDC
,
Error
Detection
Correction
)
.
Normalmente
,
los


datos
que
hay
que
proteger
incluyen
no
s√≥lo
el
datagrama
recibido
de
la
capa
de
red
para
su


transmisi√≥n
a
trav√©s
del
enlace
,
sino
tambi√©n
la
informaci√≥n
de
direccionamiento
de
la
capa


de
enlace
,
los
n√∫meros
de
secuencia
y
otros
campos
de
la
cabecera
de
la
trama
de
enlace
.


Tanto
D
como
EDC
se
env√≠an
hacia
el
nodo
receptor
en
una
trama
de
la
capa
de
enlace
.
En


el
nodo
receptor
,
se
recibe
una
secuencia
de
bits
formada
por
D 
y
EDC .
Observe
que
D 
y


EDC 
pueden
diferir
de
la
secuencias
D
y
EDC
originales
,
como
resultado
de
alteraciones


de
los
bits
sufridas
durante
el
tr√°nsito
.


El
desaf√≠o
para
el
receptor
consiste
en
determinar
si
D 
coincide
con
la
secuencia
D
ori-


ginal
,
teniendo
en
cuenta
que
lo
que
√∫nico
que
ha
recibido
son
las
secuencias
D 
y
EDC .
Es


importante
observar
las
palabras
exactas
utilizadas
en
el
s√≠mbolo
de
decisi√≥n
mostrado
en
la


Figura
5.4
(
lo
que
preguntamos
es
si
se
ha
detectado
un
error
,
no
si
se
ha
producido
un


error
)
.
Las
t√©cnicas
de
detecci√≥n
y
correcci√≥n
de
errores
permiten
al
receptor
detectar
en


ocasiones
,
pero
no
siempre
,
que
se
han
producido
errores
en
los
bits
.
Incluso
utilizando
bits


de
detecci√≥n
de
errores
pueden
seguir
existiendo
errores
de
bit
no
detectados
;
es
decir
,
el


receptor
podr√≠a
perfectamente
ser
inconsciente
de
que
la
informaci√≥n
recibida
contiene
erro-


res
en
los
bits
.
Como
consecuencia
,
el
receptor
podr√≠a
entregar
un
datagrama
corrupto
a
la


capa
de
red
,
o
no
ser
consciente
de
que
el
contenido
de
un
campo
de
la
cabecera
de
la
trama


se
ha
corrompido
.
Por
tanto
,
lo
que
intentaremos
ser√°
elegir
un
esquema
de
detecci√≥n
de


errores
que
haga
que
la
probabilidad
de
que
se
produzcan
estos
casos
sea
peque√±a
.
Por
regla


general
,
cuanto
m√°s
sofisticadas
son
las
t√©cnicas
de
detecci√≥n
y
correcci√≥n
de
errores
(
es


decir
,
cuanto
menor
sea
la
probabilidad
de
que
se
produzcan
errores
de
bit
que
no
sean


424
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
424detectados
)
,
mayores
son
los
recursos
adicionales
necesarios
:
har√°n
falta
m√°s
c√°lculos
para


obtener
y
transmitir
un
mayor
n√∫mero
de
bits
de
detecci√≥n
y
correcci√≥n
de
errores
.


Examinemos
ahora
tres
t√©cnicas
para
detectar
los
errores
en
los
datos
transmitidos
:


comprobaciones
de
paridad
(
para
ilustrar
las
ideas
b√°sicas
que
subyacen
a
las
t√©cnicas
de


detecci√≥n
y
correcci√≥n
de
errores
)
,
m√©todos
basados
en
suma
de
comprobaci√≥n
(
que
suelen


utilizarse
m√°s
en
la
capa
de
transporte
)
y
c√≥digos
de
redundancia
c√≠clica
(
que
normalmente


se
emplean
m√°s
en
el
adaptador
encargado
en
la
capa
de
enlace
)
.


5.2.1
Comprobaciones
de
paridad


Quiz√°
la
forma
m√°s
simple
de
detecci√≥n
de
errores
sea
el
uso
de
un
√∫nico
bit
de
paridad
.


Suponga
que
la
informaci√≥n
que
hay
que
enviar
,
D
en
la
Figura
5.5
,
tiene
d
bits
.
En
un


esquema
de
paridad
par
,
el
emisor
simplemente
incluye
un
bit
adicional
y
selecciona
su


valor
de
modo
que
el
n√∫mero
total
de
1s
en
los
d
+
1
bits
(
la
informaci√≥n
original
m√°s
un
bit


de
paridad
)
sea
par
.
En
los
esquemas
de
paridad
impar
,
el
valor
del
bit
de
paridad
se
selec-


ciona
de
modo
que
exista
un
n√∫mero
impar
de
1s
.
La
Figura
5.5
ilustra
un
esquema
de
pari-


dad
par
,
en
el
que
el
√∫nico
bit
de
paridad
se
almacena
en
un
campo
separado
.


La
operaci√≥n
del
receptor
tambi√©n
es
muy
simple
cuando
se
utiliza
un
√∫nico
bit
de
pari-


dad
.
El
receptor
s√≥lo
necesita
contar
el
n√∫mero
de
1s
dentro
de
los
d
+
1
bits
recibidos
.
Si
se


5.2
‚Ä¢
T√âCNICAS
DE
DETECCI√ìN
Y
CORRECCI√ìN
DE
ERRORES
425


EDC'D
'


Error
detectado


Datagrama


EDCD


d
bits
de
datos


Enlace
proclive
a
los
errores
de
bit


¬ø
Son


correctos


todos
los


bits
de
D
'
?


N


S


Datagrama


HI


Figura
5.4
‚Ä¢
Escenario
para
la
detecci√≥n
y
correcci√≥n
de
errores
.


0111000110101011
1


d
bits
de
datos


Bit
de


paridad


Figura
5.5
‚Ä¢
Paridad
par
de
un
bit
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
425est√°
utilizando
un
esquema
de
paridad
par
y
se
encuentra
un
n√∫mero
impar
de
bits
con
valor


1
,
el
receptor
sabr√°
que
se
ha
producido
al
menos
un
error
de
bit
.
De
forma
m√°s
precisa
,
sabr√°


que
se
ha
producido
un
n√∫mero
impar
de
errores
de
bit
.


Pero
,
¬ø
qu√©
sucede
si
se
produce
un
n√∫mero
par
de
errores
de
bit
?
Puede
comprobar


f√°cilmente
que
estoy
har√≠a
que
el
error
no
fuera
detectado
.
Si
la
probabilidad
de
que
se
pro-


duzcan
errores
en
los
bits
es
peque√±a
y
si
podemos
asumir
que
los
errores
que
se
producen


en
dos
bits
sucesivos
tienen
lugar
de
forma
independiente
,
la
probabilidad
de
que
se
produz-


can
m√∫ltiples
errores
de
bit
en
un
√∫nico
paquete
ser√°
extremadamente
peque√±a
.
En
estos


casos
,
podr√≠a
bastar
con
utilizar
un
√∫nico
bit
de
paridad
.
Sin
embargo
,
las
medidas
realiza-


das
muestran
que
los
errores
m√°s
que
tener
lugar
independientemente
,
suelen
agruparse
for-


mando
‚Äú
r√°fagas
‚Äù
.
En
condiciones
de
r√°fagas
de
error
,
la
probabilidad
de
que
se
produzcan


errores
no
detectados
en
una
trama
protegida
mediante
un
√∫nico
bit
de
paridad
puede
apro-


ximarse
al
50
por
ciento
[
Spragins
1991
]
.
Evidentemente
,
necesitamos
un
esquema
de
detec-


ci√≥n
de
errores
m√°s
robusto
(
y
,
afortunadamente
,
en
la
pr√°ctica
suelen
emplearse
esos
otros


esquemas
)
.
Pero
antes
de
examinar
los
esquemas
de
detecci√≥n
de
errores
utilizados
en
la


pr√°ctica
,
vamos
a
analizar
una
generalizaci√≥n
simple
del
mecanismo
de
un
√∫nico
bit
de
pari-


dad
;
esta
generalizaci√≥n
nos
permitir√°
comprender
mejor
las
t√©cnicas
de
correcci√≥n
de


errores
.


La
Figura
5.6
muestra
una
generalizaci√≥n
bidimensional
del
esquema
basado
en
un


√∫nico
bit
de
paridad
.
Aqu√≠
,
los
d
bits
de
D
se
dividen
en
i
filas
y
j
columnas
.
Para
cada
una


de
esas
filas
y
columnas
calculamos
un
valor
de
paridad
.
Los
i
+
j
+
1
bits
de
paridad
resul-


tantes
ser√°n
los
bits
de
detecci√≥n
de
errores
utilizados
en
la
trama
de
la
capa
de
enlace
.


Suponga
ahora
que
se
produce
un
√∫nico
error
de
bit
en
los
d
bits
de
informaci√≥n
origi-


nales
.
Con
este
esquema
de
paridad
bidimensional
,
detectaremos
el
error
en
la
paridad


tanto
de
la
columna
como
de
la
fila
que
contienen
el
bit
err√≥neo
.
De
este
modo
,
el
receptor


no
s√≥lo
podr√°
detectar
el
hecho
de
que
se
ha
producido
un
√∫nico
error
de
bit
,
sino
que
puede


utilizar
los
√≠ndices
de
la
columna
y
de
la
fila
que
presentan
errores
de
paridad
para
identifi-


car
realmente
el
bit
corrompido
y
corregir
dicho
error
.
La
Figura
5.6
muestra
un
ejemplo
en


el
que
el
bit
de
valor
1
en
la
posici√≥n
(
2
,
2
)
est√°
corrompido
,
habi√©ndose
cambiado
por
un
0
;


se
trata
de
un
error
que
es
tanto
detectable
como
corregible
en
el
receptor
.
Aunque
nuestra


explicaci√≥n
se
ha
centrado
en
los
d
bits
originales
de
informaci√≥n
,
un
√∫nico
error
dentro
de


los
propios
bits
de
paridad
tambi√©n
es
detectable
y
corregible
.
Los
esquemas
de
paridad
bidi-


mensional
tambi√©n
pueden
detectar
(
¬°
pero
no
corregir
!
)
cualquier
combinaci√≥n
de
dos
erro-


res
dentro
de
un
paquete
.
En
los
problemas
incluidos
al
final
del
cap√≠tulo
se
analizan
otras


propiedades
del
esquema
de
paridad
bidimensional
.


La
capacidad
del
receptor
para
detectar
y
corregir
errores
a
la
vez
se
conoce
con
el
nom-


bre
de
Correcci√≥n
de
errores
hacia
adelante
(
FEC
,
Forward
Error
Correction
)
.
Estas


t√©cnicas
se
suelen
utilizar
com√∫nmente
en
los
dispositivos
de
almacenamiento
y
reproduc-


ci√≥n
de
audio
,
como
por
ejemplo
los
CD
de
audio
.
En
un
entorno
de
red
,
las
t√©cnicas
FEC


tambi√©n
pueden
emplearse
por
s√≠
mismas
o
en
conjunci√≥n
con
t√©cnicas
ARQ
de
la
capa
de


enlace
,
similares
a
las
que
hemos
examinado
en
el
Cap√≠tulo
3
.
Las
t√©cnicas
FEC
son
valio-


sas
porque
pueden
reducir
el
n√∫mero
de
retransmisiones
realizadas
por
el
emisor
pero
,
lo


que
quiz√°
sea
m√°s
importante
,
tambi√©n
permiten
la
correcci√≥n
inmediata
de
errores
en
el


receptor
,
lo
que
evita
tener
que
esperar
el
retardo
de
propagaci√≥n
de
ida
y
vuelta
necesario


para
que
el
emisor
reciba
un
paquete
NAK
y
para
que
el
paquete
retransmitido
se
propague


de
nuevo
hacia
el
receptor
;
√©sta
es
una
caracter√≠stica
potencialmente
muy
importante
para


las
aplicaciones
de
red
en
tiempo
real
[
Rubenstein
1998
]
o
para
los
enlaces
(
como
los
enla-


426
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4265.2
‚Ä¢
T√âCNICAS
DE
DETECCI√ìN
Y
CORRECCI√ìN
DE
ERRORES
427


ces
en
el
espacio
profundo
)
que
presenten
grandes
retardos
de
propagaci√≥n
.
Entre
las
refe-


rencias
en
las
que
se
examina
el
uso
de
las
t√©cnicas
FEC
en
los
protocolos
de
control
de
erro-


res
podemos
citar
[
Biersack
1992
;
Nonnenmacher
1998
;
Byers
1998
;
Shacham
1990
]
.


5.2.2
M√©todos
basados
en
suma
de
comprobaci√≥n


En
las
t√©cnicas
de
suma
de
comprobaci√≥n
,
los
d
bits
de
datos
de
la
Figura
5.5
se
tratan
como


una
secuencia
de
enteros
de
k
bits
.
Un
m√©todo
simple
de
suma
de
comprobaci√≥n
consiste
en


sumar
estos
enteros
de
k
bits
y
utilizar
la
suma
resultante
como
bits
de
detecci√≥n
de
errores
.


La
suma
de
comprobaci√≥n
de
Internet
est√°
basada
en
este
enfoque
:
los
bytes
de
datos
se


tratan
como
enteros
de
16
bits
y
se
suman
.
Entonces
,
se
utiliza
el
complemento
a
1
de
esta


suma
para
formar
la
suma
de
comprobaci√≥n
de
Internet
que
se
incluye
en
la
cabecera
del
seg-


mento
.
Como
se
ha
visto
en
la
Secci√≥n
3.3
,
el
receptor
comprueba
la
suma
de
comprobaci√≥n


calculando
el
complemento
a
1
de
la
suma
de
los
datos
recibidos
(
incluyendo
la
suma
de


comprobaci√≥n
)
y
comprobando
si
el
resultado
tiene
todos
los
bits
a
1
.
Si
alguno
de
los
bits
es


un
0
,
eso
indicar√°
que
se
ha
producido
un
error
.
El
documento
RFC
1071
explica
en
detalle
el


algoritmo
de
suma
de
comprobaci√≥n
de
Internet
y
su
implementaci√≥n
.
En
los
protocolos
TCP


y
UDP
,
la
suma
de
comprobaci√≥n
de
Internet
se
calcula
sobre
todos
los
campos
(
incluyendo


los
campos
de
cabecera
y
de
datos
)
.
En
IP
,
la
suma
de
comprobaci√≥n
se
calcula
sobre
la
cabe-


cera
IP
(
dado
que
el
segmento
UDP
o
TCP
ya
tiene
su
propia
suma
de
comprobaci√≥n
)
.
En


otros
protocolos
,
como
por
ejemplo
XTP
[
Strayer
1992
]
,
se
calcula
una
suma
de
comproba-


ci√≥n
sobre
la
cabecera
y
otra
sobre
todo
el
paquete
.


1
0
1
0
1
1


1
1
1
1
0
0


0
1
1
1
0
1


0
0
1
0
1
0


1
0
1
0
1
1


1
0
1
1
0
0


0
1
1
1
0
1


0
0
1
0
1
0


Paridad
de
fila


Error
de


paridad


Error
de


paridad


Sin
errores
Error
corregible


de
un
√∫nico
bit


d1,1


d2,1


.
.
.


di,1


di+1,1


.
.
.


.
.
.


.
.
.


.
.
.


.
.
.


d1
,
j


d2
,
j


.
.
.


di
,
j


di+1
,
j


d1
,
j+1


d2
,
j+1


.
.
.


di
,
j+1


di+1
,
j+1


Paridad
de
columna


Figura
5.6
‚Ä¢
Paridad
par
bidimensional
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
427Los
m√©todos
de
suma
de
comprobaci√≥n
requieren
relativamente
poca
sobrecarga
de


paquete
.
Por
ejemplo
,
la
suma
de
comprobaci√≥n
en
TCP
y
UDP
s√≥lo
utiliza
16
bits
.
Sin


embargo
,
estas
sumas
proporcionan
una
protecci√≥n
relativamente
d√©bil
frente
a
los
errores
si


las
comparamos
con
las
comprobaciones
de
redundancia
c√≠clica
,
de
las
que
hablaremos
a


continuaci√≥n
y
que
se
utilizan
a
menudo
en
la
capa
de
enlace
.
Una
pregunta
bastante
natural


llegados
a
este
punto
ser√≠a
:
¬ø
por
qu√©
se
utilizan
sumas
de
comprobaci√≥n
en
la
capa
de
trans-


porte
y
comprobaciones
de
redundancia
c√≠clica
en
la
capa
de
enlace
?
Recuerde
que
normal-


mente
la
capa
de
transporte
se
implementa
por
software
en
un
host
como
parte
del
sistema


operativo
del
mismo
.
Puesto
que
el
mecanismo
de
detecci√≥n
de
errores
de
la
capa
de
trans-


porte
se
implementa
por
software
,
es
importante
utilizar
un
esquema
de
detecci√≥n
de
errores


simple
y
r√°pido
,
como
por
ejemplo
el
de
la
sumas
de
comprobaci√≥n
.
Por
el
contrario
,
la


detecci√≥n
de
errores
en
la
capa
de
enlace
se
implementa
en
un
hardware
dedicado
dentro
de


las
tarjetas
adaptadoras
,
pudiendo
dicho
hardware
realizar
r√°pidamente
las
operaciones
CRC


m√°s
complejas
.
Feldmeier
[
Feldmeier
1995
]
presenta
una
serie
de
t√©cnicas
de
implementa-


ci√≥n
r√°pida
en
software
no
s√≥lo
para
c√≥digos
de
suma
de
comprobaci√≥n
ponderados
,
sino


tambi√©n
para
c√≥digos
CRC
(
v√©ase
m√°s
adelante
)
y
otros
c√≥digos
.


5.2.3
Comprobaci√≥n
de
redundancia
c√≠clica
(
CRC
)


Una
t√©cnica
detecci√≥n
de
errores
utilizada
ampliamente
en
las
redes
de
computadoras
de
hoy


d√≠a
esta
basada
en
los
c√≥digos
de
comprobaci√≥n
de
redundancia
c√≠clica
(
CRC
,
Cyclic


Redundancy
Check
)
.
Los
c√≥digos
CRC
tambi√©n
se
conocen
con
el
nombre
de
c√≥digos
poli-


n√≥micos
,
dado
que
se
puede
ver
la
cadena
de
bits
que
hay
que
enviar
como
si
fuera
un
poli-


nomio
cuyos
coeficientes
son
los
valores
0
y
1
de
la
cadena
de
bits
,
interpret√°ndose
las


operaciones
realizadas
con
la
cadena
de
bits
seg√∫n
la
aritm√©tica
de
polinomios
.


Los
c√≥digos
CRC
operan
de
la
forma
siguiente
.
Considere
la
secuencia
de
datos
de
d


bits
,
D
,
que
el
nodo
emisor
quiere
transmitir
al
nodo
receptor
.
El
emisor
y
el
receptor
tienen


que
acordar
primero
un
patr√≥n
de
r
+
1
bits
,
conocido
como
generador
,
que
denominare-


mos
con
la
letra
G.
Impondremos
la
condici√≥n
de
que
el
bit
m√°s
significativo
(
el
bit
situado


m√°s
a
la
izquierda
)
de
G
sea
1
.
La
idea
clave
subyacente
a
los
c√≥digos
CRC
se
muestra
en
la


Figura
5.7
.
Para
un
determinada
secuencia
de
datos
,
D
,
el
emisor
seleccionar√°
r
bits
adicio-


nales
,
R
,
y
se
los
a√±adir√°
a
D
,
de
modo
que
el
patr√≥n
de
d
+
r
bits
resultante
(
interpretado


como
un
n√∫mero
binario
)
sea
exactamente
divisible
por
G
(
es
decir
,
no
tenga
ning√∫n
resto
)


utilizando
aritm√©tica
m√≥dulo
2
.
El
proceso
de
comprobaci√≥n
de
errores
con
los
c√≥digos
CRC


es
,
por
tanto
,
muy
simple
:
el
receptor
divide
los
d
+
r
bits
recibidos
entre
G.
Si
el
resto
es


distinto
de
cero
,
el
receptor
sabr√°
que
se
ha
producido
error
;
en
caso
contrario
,
se
aceptar√°n


los
datos
como
correctos
.


428
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


d
bits
r
bits


D
:
Bits
de
datos
que
se


van
a
enviar


D
‚Ä¢
2r
 
XOR
   
R


R
:
Bits
CRC
Patr√≥n
de
bits


F√≥rmula
matem√°tica


Figura
5.7
‚Ä¢
CRC
.
 

M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
428Todos
los
c√°lculos
de
los
c√≥digos
CRC
se
realizan
en
aritm√©tica
m√≥dulo
2
,
sin
ning√∫n


tipo
de
acarreo
ni
en
las
sumas
ni
en
las
restas
.
Esto
quiere
decir
que
la
suma
y
la
resta
son


id√©nticas
,
y
que
ambas
son
equivalentes
a
la
operaci√≥n
OR-exclusiva
(
XOR
)
bit
a
bit
de
los


operandos
.
As√≠
,
por
ejemplo
,


1011
XOR
0101
=
1110


1001
XOR
1101
=
0100


De
forma
similar
,
tambi√©n
tendremos
que


1011
‚Äì
0101
=
1110


1001
‚Äì
1101
=
0100


La
multiplicaci√≥n
y
la
divisi√≥n
son
iguales
que
en
aritm√©tica
en
base
2
,
excepto
porque
las


sumas
y
restas
necesarias
se
llevan
a
cabo
sin
acarreos
.
Como
en
la
aritm√©tica
binaria
ordi-


naria
,
la
multiplicaci√≥n
por
2
k
hace
que
un
patr√≥n
de
bits
se
desplace
k
posiciones
hacia
la


izquierda
.
Por
tanto
,
dados
D
y
R
,
el
valor
D
 
2r
XOR
R
nos
dar√°
el
patr√≥n
de


d
+
r
bits
mostrado
en
la
Figura
5.7
.
Utilizaremos
esta
caracterizaci√≥n
algebraica
del
patr√≥n


de
d
+
r
bits
de
la
Figura
5.7
en
nuestras
explicaciones
.


Vo
l
v
a
m
o
s
 
a
h
o
r
a
 
a
 
l
a
 
p
r
e
g
u
n
t
a
 
c
r
u
c
i
a
l
 
d
e
 
c
√≥
m
o
 
p
u
e
d
e
 
e
l
 
e
m
i
s
o
r
 
c
a
l
c
u
l
a
r
 
R.
Recuerde
que


queremos
encontrar
una
secuencia
R
tal
que
exista
n
que
cumpla


D
 
2r
XOR
R
=
nG


Es
decir
,
queremos
seleccionar
R
tal
que
G
divida
a
D
 
2r
XOR
R
sin
que
quede
resto
.


Si
aplicamos
XOR
(
es
decir
,
si
sumamos
en
m√≥dulo
2
sin
acarreo
)
R
a
ambos
lados
de
la


ecuaci√≥n
anterior
,
obtenemos


D
 
2r
=
nG
XOR
R


Esta
ecuaci√≥n
nos
dice
que
si
dividimos
D
 
2r
entre
G
,
el
valor
del
resto
ser√°
precisamente


R.
En
otras
palabras
,
podemos
calcular
R
como


La
Figura
5.8
ilustra
este
c√°lculo
para
el
caso
de
D
=
101110
,
d
=
6
,
G
=
1001
y
r
=
3
.


Los
9
bits
transmitidos
en
este
caso
ser√°n
101110
011
.
Puede
comprobar
estos
c√°lculos
por
s√≠


mismo
y
comprobar
tambi√©n
que
D
 
2r
=
101011
 
G
XOR
R.


Se
han
definido
est√°ndares
internacionales
para
generadores
G
de
8
,
12
,
16
y
32
bits
.
El


est√°ndar
CRC-32
para
32
bits
,
que
se
ha
adoptado
en
una
serie
de
protocolos
del
IEEE
para


la
capa
de
enlace
,
utiliza
el
generador


GCRC-32
=
100000100110000010001110110110111


Cada
uno
de
los
est√°ndares
de
CRC
puede
detectar
r√°fagas
de
errores
inferiores
a
r
+
1


bits
(
esto
significa
que
todos
los
errores
de
r
bits
consecutivos
o
menos
ser√°n
detectados
)
.


Adem√°s
,
en
las
condiciones
adecuadas
,
una
r√°faga
de
longitud
superior
a
r
+
1
bits
ser√°


detectada
con
una
probabilidad
de
1
‚Äì
0.5
r.
Asimismo
,
cada
uno
de
los
est√°ndares
CRC


puede
detectar
cualquier
n√∫mero
impar
de
errores
de
bit
.
En
[
Williams
1993
]
puede
encon-


trar
un
an√°lisis
de
la
implementaci√≥n
de
c√≥digos
CRC
.
La
teor√≠a
subyacente
a
los
c√≥digos


R
D


G


r


=
resto
2‚ãÖ


5.2
‚Ä¢
T√âCNICAS
DE
DETECCI√ìN
Y
CORRECCI√ìN
DE
ERRORES
429


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
429CRC
y
a
algunos
c√≥digos
incluso
m√°s
potentes
cae
fuera
del
alcance
de
este
libro
.
El
texto


de
[
Schwartz
1980
]
proporciona
una
excelente
introducci√≥n
a
este
tema
.


5.3
Protocolos
de
acceso
m√∫ltiple


En
la
introducci√≥n
de
este
cap√≠tulo
hemos
indicado
que
existen
dos
tipos
de
enlaces
de
red
:


enlaces
punto
a
punto
y
enlaces
de
difusi√≥n
(
broadcast
)
.
Un
enlace
punto
a
punto
est√°


compuesto
por
un
√∫nico
emisor
en
un
extremo
del
enlace
y
un
√∫nico
receptor
en
el
otro


extremo
.
Se
han
dise√±ado
muchos
protocolos
de
la
capa
de
enlace
para
enlaces
punto
a


punto
;
dos
de
esos
protocolos
,
de
los
que
hablaremos
posteriormente
en
el
cap√≠tulo
,
son
el


Protocolo
punto
a
punto
(
PPP
,
Point-to-Point
Protocol
)
y
el
protocolo
de
Control
del
enlace


de
datos
de
alto
nivel
(
HDLC
,
High-level
Data
Link
Control
)
.
El
segundo
tipo
de
enlace
,
un


enlace
de
difusi√≥n
,
puede
tener
m√∫ltiples
nodos
emisores
y
receptores
,
todos
conectados
al


mismo
y
√∫nico
canal
de
difusi√≥n
compartido
.
Utilizamos
aqu√≠
el
t√©rmino
difusi√≥n
porque


cuando
un
nodo
transmite
una
trama
,
el
canal
se
encarga
de
difundir
esa
trama
y
cada
uno


de
los
dem√°s
nodos
recibe
una
copia
.
Ethernet
y
las
redes
LAN
inal√°mbricas
son
ejemplos


de
tecnolog√≠as
de
difusi√≥n
de
la
capa
de
enlace
.
En
esta
secci√≥n
vamos
a
abstraernos


moment√°neamente
de
los
protocolos
espec√≠ficos
de
la
capa
de
enlace
y
vamos
a
examinar


en
primer
lugar
un
problema
de
crucial
importancia
para
esa
capa
:
c√≥mo
coordinar
el
acceso


de
m√∫ltiples
nodos
emisores
y
receptores
a
un
canal
de
difusi√≥n
compartido
,
lo
que
se


conoce
con
el
nombre
de
problema
de
acceso
m√∫ltiple
.
Los
canales
de
difusi√≥n
se
suelen


utilizar
en
las
redes
LAN
,
que
son
redes
geogr√°ficamente
concentradas
en
un
√∫nico
edificio


(
o
un
campus
corporativo
o
universitario
)
.
Por
ello
,
tambi√©n
examinaremos
al
final
de
esta


secci√≥n
c√≥mo
se
utilizan
los
canales
de
acceso
m√∫ltiple
en
las
redes
LAN
.


Todos
estamos
familiarizados
con
la
noci√≥n
de
transmisiones
de
difusi√≥n
,
ya
que
la


televisi√≥n
ha
estado
empleando
este
tipo
de
mecanismo
desde
que
fuera
inventada
.
Pero
la


televisi√≥n
tradicional
es
una
difusi√≥n
en
un
√∫nico
sentido
(
es
decir
,
hay
un
nodo
fijo
que


transmite
a
muchos
nodos
receptores
)
,
mientras
que
los
nodos
de
un
canal
de
difusi√≥n
de


430
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


1
0
0
1
1
0
1
1
1
0
0
0
0


1
0
1
0
1
1


1
0
0
1


1
0
1


0
0
0


1
0
1
0


1
0
0
1


1
1
0


0
0
0


1
1
0
0


1
0
0
1


1
0
1
0


1
0
0
1

 
0
1
1


G


D


R


Figura
5.8
‚Ä¢
Un
ejemplo
de
c√°lculo
de
CRC
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
430una
red
de
computadoras
pueden
tanto
enviar
como
recibir
.
Quiz√°
una
analog√≠a
m√°s
ade-


cuada
para
un
canal
de
difusi√≥n
extra√≠da
del
campo
de
las
relaciones
sociales
ser√≠a
un
coctel


en
el
que
muchas
personas
se
re√∫nen
en
una
gran
sala
(
el
aire
proporciona
el
medio
de
difu-


si√≥n
)
para
hablar
y
escuchar
.
Una
segunda
analog√≠a
ser√≠a
algo
con
lo
que
muchos
lectores


estar√°n
familiarizados
,
una
clase
,
en
la
que
uno
o
m√°s
profesores
y
estudiantes
comparten
de


forma
similar
el
mismo
y
√∫nico
medio
de
difusi√≥n
.
Un
problema
crucial
en
ambos
escena-


rios
es
el
de
determinar
qui√©n
es
el
que
tiene
derecho
a
la
palabra
(
es
decir
,
derecho
a
trans-


mitir
hacia
el
canal
)
y
cu√°ndo
lo
tiene
.
Las
personas
hemos
llegado
a
desarrollar
un
conjunto


elaborado
de
protocolos
con
el
fin
de
compartir
el
canal
de
difusi√≥n
:


‚Äú
Dar
a
todo
el
mundo
una
oportunidad
de
hablar
.
‚Äù


‚Äú
No
hablar
hasta
que
te
hablen
.
‚Äù


‚Äú
No
monopolizar
la
conversaci√≥n
.
‚Äù


‚Äú
Levantar
la
mano
si
se
tiene
una
pregunta
que
plantear
.
‚Äù


‚Äú
No
interrumpir
cuando
alguien
est√°
hablando
.
‚Äù


‚Äú
No
quedarse
dormido
cuando
alguien
est√°
hablando
.
‚Äù


De
forma
similar
,
las
redes
de
computadoras
tienen
protocolos
(
denominados
protoco-


los
de
acceso
m√∫ltiple
)
mediante
los
cuales
los
nodos
se
encargan
de
regular
sus
transmi-


siones
al
canal
de
difusi√≥n
compartido
.
Como
se
muestra
en
la
Figura
5.9
,
los
protocolos
de


acceso
m√∫ltiple
son
necesarios
en
una
amplia
variedad
de
escenarios
de
red
,
incluyendo
las


redes
de
√°rea
local
tanto
cableadas
como
inal√°mbricas
y
las
redes
de
sat√©lite
.
Aunque
t√©cni-


camente
cada
nodo
accede
al
canal
de
difusi√≥n
a
trav√©s
de
su
adaptador
,
en
esta
secci√≥n
nos


referiremos
con
el
t√©rmino
nodo
a
los
dispositivos
emisor
y
receptor
.
En
la
pr√°ctica
,
puede


haber
cientos
o
incluso
miles
de
nodos
comunic√°ndose
directamente
a
trav√©s
de
un
canal
de


difusi√≥n
.


Puesto
que
todos
los
nodos
son
capaces
de
transmitir
tramas
,
podr√≠a
darse
el
caso
de
que


m√°s
de
dos
nodos
transmitieran
tramas
al
mismo
tiempo
.
Cuando
esto
sucede
,
todos
los


nodos
reciben
varias
tramas
simult√°neamente
;
es
decir
,
las
tramas
transmitidas
colisionan


en
todos
los
receptores
.
Normalmente
,
cuando
se
produce
una
colisi√≥n
ninguno
de
los
nodos


receptores
puede
interpretar
ninguna
de
las
tramas
transmitidas
;
en
un
cierto
sentido
,
las


se√±ales
de
las
tramas
que
han
colisionado
se
entremezclan
y
no
pueden
separarse
.
Por
tanto
,


todas
las
tramas
implicadas
en
la
colisi√≥n
se
pierden
y
el
canal
de
difusi√≥n
est√°
desaprove-


chado
durante
el
intervalo
de
colisi√≥n
.
Obviamente
,
si
hay
muchos
nodos
que
quieren
trans-


mitir
tramas
de
manera
frecuente
,
muchas
de
las
transmisiones
provocar√°n
colisiones
y


buena
parte
del
ancho
de
banda
del
canal
de
difusi√≥n
se
desperdiciar√°
.


Para
poder
garantizar
que
el
canal
de
difusi√≥n
realice
un
trabajo
√∫til
aun
cuando
haya


m√∫ltiples
nodos
activos
,
es
necesario
coordinar
de
alguna
manera
las
transmisiones
de
esos


nodos
activos
.
Este
trabajo
de
coordinaci√≥n
es
responsabilidad
del
protocolo
de
acceso
m√∫l-


tiple
.
En
los
√∫ltimos
40
a√±os
se
han
escrito
miles
de
art√≠culos
y
cientos
de
tesis
doctorales


acerca
de
los
protocolos
de
acceso
m√∫ltiple
;
pueden
encontrar
en
[
Rom
1990
]
una
panor√°-


mica
bastante
completa
de
los
primeros
20
a√±os
de
estas
investigaciones
.
Hoy
d√≠a
,
la
inves-


tigaci√≥n
acerca
de
los
protocolos
de
acceso
m√∫ltiple
contin√∫a
de
manera
activa
debido
a
la


continua
aparici√≥n
de
nuevos
tipos
de
enlaces
y
,
en
particular
,
de
nuevos
enlaces
inal√°mbri-


cos
.


Al
o
 
l
a
r
g
o
 
d
e
 
l
o
s
 
a
√±
o
s
 
s
e
 
h
a
n
 
i
m
p
l
e
m
e
n
t
a
d
o
 
d
o
c
e
n
a
s
 
d
e
 
p
r
o
t
o
c
o
l
o
s
 
d
e
 
a
c
c
e
s
o
 
m
√∫
l
t
i
p
l
e


utilizando
diversas
tecnolog√≠as
de
la
capa
de
enlace
.
No
obstante
,
podemos
clasificar
casi


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
431


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
431todos
los
protocolos
de
acceso
m√∫ltiple
en
una
de
estas
tres
categor√≠as
:
protocolos
de
parti-


cionamiento
del
canal
,
protocolos
de
acceso
aleatorio
y
protocolos
de
toma
de
turnos
.


Hablaremos
de
estas
tres
categor√≠as
de
protocolos
de
acceso
multiple
en
las
tres
siguientes


subsecciones
.


Vamos
a
concluir
esta
introducci√≥n
observando
que
,
idealmente
,
un
protocolo
de
acceso


m√∫ltiple
para
un
canal
de
difusi√≥n
con
una
velocidad
de
R
bits
por
segundo
deber√≠a
tener
las


siguientes
caracter√≠sticas
deseables
:


1
.
Cuando
s√≥lo
haya
un
nodo
que
tenga
datos
para
enviar
,
a
dicho
nodo
se
le
asignar√°
una


tasa
de
transferencia
de
R
bps
.


2
.
Cuando
haya
M
nodos
con
datos
para
enviar
,
cada
uno
de
esos
nodos
tendr√°
una
tasa
de


transferencia
de
R
/
M
bps
.
Esto
no
implica
necesariamente
que
cada
uno
de
los
M
nodos


tenga
siempre
una
tasa
instant√°nea
igual
a
R
/
M
,
sino
m√°s
bien
que
cada
nodo
tendr√°
una


tasa
media
de
transmisi√≥n
igual
a
R
/
M
a
lo
largo
de
un
intervalo
de
tiempo
definido
ade-


cuadamente
.


3
.
El
protocolo
ser√°
descentralizado
;
es
decir
,
no
habr√°
ning√∫n
nodo
maestro
que
pueda


actuar
como
punto
√∫nico
de
fallo
para
la
red
.


432
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


Cable
compartido


(
por
ejemplo
,
Ethernet
)


Red
inal√°mbrica
compartida


(
por
ejemplo
,
WiFi
)


Sat√©lite
Coctel


Figura
5.9
‚Ä¢
Varios
canales
de
acceso
m√∫ltiple
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4324
.
El
protocolo
ser√°
simple
,
de
modo
que
no
sea
costoso
de
implementar
.


5.3.1
Protocolos
de
particionamiento
del
canal


Recuerde
de
nuestras
explicaciones
de
la
Secci√≥n
1.3
que
la
multiplexaci√≥n
por
divisi√≥n
en


el
tiempo
(
TDM
)
y
la
multiplexaci√≥n
por
divisi√≥n
de
frecuencia
(
FDM
)
son
dos
t√©cnicas
que


pueden
utilizarse
para
particionar
el
ancho
de
banda
de
un
canal
de
difusi√≥n
entre
todos
los


nodos
que
comparten
el
canal
.
Por
ejemplo
,
suponga
que
el
canal
da
soporte
a
N
nodos
y
que


la
tasa
de
transmisi√≥n
del
canal
es
igual
a
R
bps
.
TDM
divide
el
tiempo
en
marcos
tempo-


rales
y
luego
subdivide
cada
marco
temporal
en
N
particiones
de
tiempo
.
(
En
ingl√©s
,
el
t√©r-


mino
time
frame
,
marco
de
tiempo
,
de
TDM
no
debe
confundirse
con
la
unidad
de
datos
de


la
capa
de
enlace
intercambiada
entre
las
tarjetas
adaptadoras
de
red
del
emisor
y
del
recep-


tor
,
que
se
denomina
tambi√©n
frame
,
y
que
nosotros
hemos
denominado
trama
.
En
cualquier


caso
,
para
evitar
confusiones
en
esta
subsecci√≥n
nos
referiremos
a
la
unidad
de
datos
de
la


capa
de
enlace
intercambiada
como
paquete
.
)
Cada
partici√≥n
de
tiempo
se
asigna
entonces
a


uno
de
los
N
nodos
.
Cada
vez
que
un
nodo
tenga
un
paquete
para
enviar
,
transmite
los
bits


del
paquete
durante
su
partici√≥n
de
tiempo
asignada
,
dentro
del
marco
TDM
que
se
repite
de


forma
c√≠clica
.
Normalmente
,
los
tama√±os
de
partici√≥n
se
eligen
de
modo
que
pueda
transmi-


tirse
un
√∫nico
paquete
durante
la
partici√≥n
de
tiempo
asignada
.
La
Figura
5.10
muestra
un


ejemplo
simple
de
TDM
con
cuatro
nodos
.
Si
volvemos
a
nuestra
analog√≠a
del
coctel
,
un


coctel
regulado
mediante
TDM
permitir√≠a
a
uno
de
los
participantes
hablar
durante
un


periodo
fijo
de
tiempo
,
luego
permitir√≠a
a
otro
participante
hablar
durante
la
misma
cantidad


de
tiempo
,
y
as√≠
sucesivamente
.
Una
vez
que
todos
hubieran
tenido
la
oportunidad
de
hablar
,


el
patr√≥n
se
repetir√≠a
.


TDM
resulta
muy
atractivo
porque
elimina
las
colisiones
y
es
perfectamente
equitativo
.


Cada
nodo
obtiene
una
tasa
de
transmisi√≥n
dedicada
igual
a
R
/
N
bps
durante
cada
marco


temporal
.
Sin
embargo
,
presenta
dos
importantes
inconvenientes
.
En
primer
lugar
,
cada


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
433


4kHz


FDM


TDM


Enlace


4kHz


Partici√≥n


Todas
las
particiones
etiquetadas
con
‚Äú
2
‚Äù
est√°n


dedicadas
a
una
pareja
espec√≠fica
emisor-receptor
.


Marco


1


2


234
1234
12341234


Clave
:


Figura
5.10
‚Ä¢
Un
ejemplo
de
TDM
y
FDM
para
cuatro
nodos
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
433nodo
est√°
limitado
a
una
tasa
promedio
de
R
/
N
bps
aunque
sea
el
√∫nico
nodo
que
tiene


paquetes
para
transmitir
.
El
segundo
inconveniente
es
que
un
nodo
siempre
tiene
que
espe-


rar
a
que
le
llegue
el
turno
dentro
de
la
secuencia
de
transmisi√≥n
;
de
nuevo
,
esa
espera
ser√°


obligatoria
a√∫n
cuando
sea
el
√∫nico
nodo
que
tenga
una
trama
que
enviar
.
Imagine
que
esa


situaci√≥n
se
diera
con
un
asistente
al
coctel
que
es
el
√∫nico
que
tiene
algo
que
decir
(
imagine


que
nos
encontr√°ramos
con
la
circunstancia
,
todav√≠a
m√°s
rara
,
que
todo
el
mundo
quiere


escuchar
lo
que
esa
persona
tiene
que
decir
)
.
Evidentemente
,
TDM
ser√≠a
un
protocolo
de


acceso
m√∫ltiple
bastante
inadecuado
para
ese
coctel
en
concreto
.


Mientras
que
TDM
hace
que
los
nodos
compartan
el
canal
de
difusi√≥n
a
lo
largo
del


tiempo
,
FDM
divide
el
canal
de
R
bps
en
diferentes
frecuencias
(
cada
una
con
un
ancho
de


banda
de
R
/
N
)
y
asigna
cada
frecuencia
a
cada
uno
de
los
N
nodos
.
As√≠
,
FDM
crea
N
canales


m√°s
peque√±os
de
R
/
N
bps
a
partir
de
un
√∫nico
canal
disponible
mayor
a
R
bps
.
FDM
com-


parte
con
TDM
tanto
las
ventajas
como
los
inconvenientes
.
Evita
las
colisiones
y
divide
el


ancho
de
banda
equitativamente
entre
los
N
nodos
.
Sin
embargo
,
FDM
tambi√©n
comparte


una
desventaja
fundamental
con
TDM
:
cada
nodo
est√°
limitado
a
un
ancho
de
banda
de
R
/
N
,


incluso
cuando
sea
el
√∫nico
nodo
que
tienen
paquetes
para
enviar
.


Un
tercer
protocolo
de
particionamiento
del
canal
es
el
protocolo
de
Acceso
m√∫ltiple


por
divisi√≥n
de
c√≥digo
(
CDMA
,
Code
Division
Multiple
Access
)
.
Mientras
que
TDM
y


FDM
asignan
particiones
de
tiempo
y
frecuencias
,
respectivamente
,
a
los
nodos
,
CDMA


asigna
un
c√≥digo
diferente
a
cada
nodo
.
Cada
nodo
entonces
utiliza
su
c√≥digo
√∫nico
para


codificar
los
bits
de
datos
a
enviar
.
Si
se
seleccionan
los
c√≥digos
cuidadosamente
,
las
redes


CDMA
presentan
la
maravillosa
caracter√≠stica
de
que
los
distintos
nodos
puede
transmitir


simult√°neamente
y
conseguir
que
sus
respectivos
receptores
decodifiquen
correctamente
los


bits
de
datos
codificados
por
el
emisor
(
suponiendo
que
el
receptor
conozca
el
c√≥digo
utili-


zado
por
el
emisor
)
aunque
haya
interferencias
provocadas
por
las
transmisiones
realizadas


por
los
otros
nodos
.
CDMA
se
ha
utilizado
en
sistemas
militares
durante
alg√∫n
tiempo


(
debido
a
su
resistencia
a
las
interferencias
)
y
ahora
se
usa
ampliamente
en
el
mundo
civil
,


en
particular
en
la
telefon√≠a
celular
.
Puesto
que
el
uso
de
CDMA
est√°
tan
estrechamente


ligado
a
los
canales
inal√°mbricos
,
dejaremos
las
explicaciones
acerca
de
los
detalles
t√©cni-


cos
de
CDMA
para
el
Cap√≠tulo
6
.
Por
el
momento
,
nos
basta
con
saber
que
se
pueden
asig-


nar
c√≥digos
CDMA
,
al
igual
que
particiones
de
tiempo
en
TDM
y
frecuencias
en
FDM
a
los


usuarios
del
canal
de
acceso
m√∫ltiple
.


5.3.2
Protocolos
de
acceso
aleatorio


La
segunda
clase
general
de
protocolos
de
acceso
m√∫ltiple
son
los
protocolos
de
acceso


aleatorio
.
En
un
protocolo
de
acceso
aleatorio
,
cada
nodo
transmisor
transmite
siempre
a
la


m√°xima
velocidad
del
canal
,
que
es
R
bps
.
Cuando
se
produce
una
colisi√≥n
,
cada
uno
de
los


nodos
implicados
en
la
colisi√≥n
retransmite
repetidamente
su
trama
(
es
decir
,
su
paquete
)


hasta
que
la
trama
consiga
pasar
sin
sufrir
colisiones
.
Pero
cuando
un
nodo
experimenta
una


colisi√≥n
no
retransmite
necesariamente
la
trama
de
forma
inmediata
.
En
lugar
de
ello
,


espera
durante
un
tiempo
aleatorio
antes
de
retransmitir
la
trama
.
Cada
nodo
implicado
en


una
colisi√≥n
selecciona
un
retardo
aleatorio
independientemente
.
Puesto
que
los
retardos


aleatorios
son
elegidos
de
forma
independiente
,
es
posible
que
uno
de
los
nodos
seleccione


un
retardo
que
sea
suficientemente
menor
que
los
retardos
de
los
otros
nodos
que
han
inter-


venido
en
la
colisi√≥n
,
pudiendo
as√≠
ser
capaz
de
conseguir
que
su
trama
pase
a
trav√©s
del


canal
sin
experimentar
una
nueva
colisi√≥n
.


434
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
434Existen
docenas
,
si
no
centenares
de
protocolos
de
acceso
aleatorio
descritos
en
la
lite-


ratura
cient√≠fica
[
Rom
1990
;
Bertsekas
1991
]
.
En
esta
secci√≥n
describiremos
unos
pocos
de


los
protocolos
de
acceso
aleatorio
m√°s
com√∫nmente
utilizados
:
los
protocolos
ALOHA


[
Abramson
1970
;
Abramson
1985
]
y
los
protocolos
de
Acceso
m√∫ltiple
con
sondeo
de
por-


tadora
(
CSMA
,
Carrier
Sense
Multiple
Access
)
[
Kleinrock
1975b
]
.
Posteriormente
,
en
la


Secci√≥n
5.5
,
abordaremos
los
detalles
de
Ethernet
[
Metcalfe
1976
]
,
que
es
un
protocolo


CSMA
muy
popular
y
ampliamente
difundido
.


ALOHA
con
particiones


Comencemos
nuestro
estudio
de
los
protocolos
de
acceso
aleatorio
con
uno
de
los
protoco-


los
de
este
tipo
m√°s
simples
:
el
protocolo
ALOHA
con
particiones
.
En
nuestra
descripci√≥n


de
ALOHA
con
particiones
,
haremos
las
siguientes
suposiciones
:


‚Ä¢T
o
d
a
s
 
l
a
s
 
t
r
a
m
a
s
 
c
o
n
s
t
a
n
 
d
e
 
e
x
a
c
t
a
m
e
n
t
e
 
L
bits
.


‚Ä¢E
l
 
t
i
e
m
p
o
 
e
s
t
√°
 
d
i
v
i
d
i
d
o
 
e
n
 
p
a
r
t
i
c
i
o
n
e
s
 
d
e
 
L
/
R
segundos
(
es
decir
,
cada
partici√≥n
equivale


al
tiempo
que
se
tarda
en
transmitir
una
trama
)
.


‚Ä¢L
o
s
 
n
o
d
o
s
 
c
o
m
i
e
n
z
a
n
 
a
 
t
r
a
n
s
m
i
t
i
r
 
l
a
s
 
t
r
a
m
a
s
 
s
√≥
l
o
 
a
l
 
p
r
i
n
c
i
p
i
o
 
d
e
 
l
a
s
 
p
a
r
t
i
c
i
o
n
e
s
.
 

‚Ä¢L
o
s
 
n
o
d
o
s
 
e
s
t
√°
n
 
s
i
n
c
r
o
n
i
z
a
d
o
s
,
 
d
e
 
m
o
d
o
 
q
u
e
 
c
a
d
a
 
n
o
d
o
 
s
a
b
e
 
c
u
√°
n
d
o
 
c
o
m
i
e
n
z
a
n
 
l
a
s
 
p
a
r
t
i
-


ciones
.


‚Ä¢S
i
 
d
o
s
 
o
 
m
√°
s
 
t
r
a
m
a
s
 
c
o
l
i
s
i
o
n
a
n
 
e
n
 
u
n
a
 
p
a
r
t
i
c
i
√≥
n
,
 
e
n
t
o
n
c
e
s
 
t
o
d
o
s
 
l
o
s
 
n
o
d
o
s
 
d
e
t
e
c
t
a
n
 
l
a


colisi√≥n
incluso
antes
de
que
la
partici√≥n
termine
.


Sea
p
una
probabilidad
,
es
decir
,
un
n√∫mero
comprendido
entre
0
y
1
.
El
funcionamiento
del


protocolo
ALOHA
con
particiones
en
cada
nodo
es
simple
:


‚Ä¢C
u
a
n
d
o
 
e
l
 
n
o
d
o
 
t
i
e
n
e
 
u
n
a
 
n
u
e
v
a
 
t
r
a
m
a
 
q
u
e
 
e
n
v
i
a
r
,
 
e
s
p
e
r
a
 
h
a
s
t
a
 
e
l
 
c
o
m
i
e
n
z
o
 
d
e
 
l
a


siguiente
partici√≥n
y
transmite
la
trama
completa
dentro
de
la
partici√≥n
.


‚Ä¢S
i
 
n
o
 
s
e
 
p
r
o
d
u
c
e
 
u
n
a
 
c
o
l
i
s
i
√≥
n
,
 
e
l
 
n
o
d
o
 
h
a
b
r
√°
 
t
r
a
n
s
m
i
t
i
d
o
 
c
o
r
r
e
c
t
a
m
e
n
t
e
 
s
u
 
t
r
a
m
a
 
y
 
p
o
r


tanto
no
considerar√°
la
posibilidad
de
retransmitirla
(
el
nodo
puede
preparar
una
nueva


trama
para
su
transmisi√≥n
,
si
tiene
una
disponible
)
.


‚Ä¢S
i
 
s
e
 
p
r
o
d
u
c
e
 
u
n
a
 
c
o
l
i
s
i
√≥
n
,
 
e
l
 
n
o
d
o
 
d
e
t
e
c
t
a
 
l
a
 
c
o
l
i
s
i
√≥
n
 
a
n
t
e
s
 
d
e
 
q
u
e
 
l
a
 
p
a
r
t
i
c
i
√≥
n
 
t
e
r
m
i
n
e
.


El
nodo
retransmitir√°
su
trama
en
cada
partici√≥n
posterior
con
una
probabilidad
p
,
hasta


conseguir
que
la
trama
sea
transmitida
sin
experimentar
colisiones
.


Al
decir
que
se
retransmite
con
probabilidad
p
,
queremos
decir
que
el
nodo
lleva
a
cabo


en
la
pr√°ctica
una
especie
de
lanzamiento
de
una
moneda
trucada
:
si
se
sale
cara
,
la
trama
se


retransmite
,
lo
cual
sucede
con
probabilidad
p
;
si
sale
cruz
,
se
deja
pasar
la
partici√≥n
y


se
vuelve
a
lanzar
la
moneda
para
la
partici√≥n
siguiente
,
lo
que
ocurre
con
probabilidad


(
1
‚Äì
p
)
.
Todos
los
nodos
implicados
en
la
colisi√≥n
‚Äú
arrojan
sus
monedas
‚Äù
de
forma
indepen-


diente
.


Puede
parecer
que
el
protocolo
ALOHA
con
particiones
tiene
muchas
ventajas
.
A
dife-


rencia
de
los
mecanismos
de
particionamiento
del
canal
,
ALOHA
con
particiones
permite
a


un
nodo
retransmitir
continuamente
a
la
velocidad
m√°xima
,
R
,
cuando
dicho
nodo
sea
el


√∫nico
activo
(
decimos
que
un
nodo
est√°
activo
si
tiene
tramas
que
transmitir
)
.
ALOHA
con


particiones
tambi√©n
es
un
protocolo
altamente
descentralizado
,
porque
cada
nodo
detecta
las


colisiones
y
decide
de
forma
independiente
cu√°ndo
debe
retransmitir
(
sin
embargo
,


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
435


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
435ALOHA
con
particiones
requiere
que
las
particiones
est√©n
sincronizadas
en
los
nodos
;
en


breve
analizaremos
una
versi√≥n
no
particionada
del
protocolo
ALOHA
,
as√≠
como
los
proto-


colos
CSMA
,
ninguno
de
los
cuales
requiere
dicho
tipo
de
sincronizaci√≥n
)
.
ALOHA
con
par-


ticiones
es
tambi√©n
un
protocolo
extremadamente
simple
.


ALOHA
con
particiones
funciona
bien
cuando
s√≥lo
hay
un
nodo
activo
,
pero
¬ø
qu√©
efi-


ciencia
tiene
cuando
existen
m√∫ltiples
nodos
activos
?
Son
dos
las
posibles
preocupaciones


en
lo
que
respecta
a
la
eficiencia
.
En
primer
lugar
,
como
se
muestra
en
la
Figura
5.11
,


cuando
hay
m√∫ltiples
nodos
activos
una
cierta
fracci√≥n
de
las
particiones
experimentar√°


colisiones
y
por
tanto
se
‚Äú
desperdiciar√°
‚Äù
.
La
segunda
preocupaci√≥n
es
que
otra
fracci√≥n
de


las
particiones
estar√°
vac√≠aen
aquellos
casos
en
que
todos
los
nodos
activos
se
abstengan
de


transmitir
,
como
resultado
de
la
pol√≠tica
probabil√≠stica
de
retransmisi√≥n
.
Las
√∫nicas
particio-


nes
‚Äú
no
desperdiciadas
‚Äù
ser√°n
aquellas
para
las
que
haya
exactamente
un
nodo
transmi-


tiendo
.
A
las
particiones
en
las
que
hay
exactamente
un
nodo
transmitiendo
se
las
denomina


particiones
con
√©xito
.
La
eficiencia
de
un
protocolo
de
acceso
m√∫ltiple
con
particiones
se


define
como
la
fracci√≥n
(
calculada
a
largo
plazo
)
de
particiones
con
√©xito
cuando
existe
un


gran
n√∫mero
de
nodos
activos
,
cada
uno
de
los
cuales
tiene
siempre
una
gran
cantidad
de


tramas
que
enviar
.
Observe
que
si
no
se
utilizara
ning√∫n
tipo
de
control
de
acceso
y
cada


nodo
intentara
retransmitir
inmediatamente
despu√©s
de
cada
colisi√≥n
,
la
eficiencia
ser√≠a
cero
.


El
protocolo
ALOHA
con
particiones
hace
obviamente
que
la
eficiencia
aumente
por
encima


de
cero
pero
,
¬ø
cu√°nto
aumenta
?


Vamos
a
esbozar
el
modo
de
determinar
la
eficiencia
m√°xima
del
protocolo
ALOHA


con
particiones
.
Para
simplificar
las
cosas
,
vamos
a
modificar
el
protocolo
ligeramente
y
a


asumir
que
cada
nodo
trata
de
transmitir
una
trama
en
cada
partici√≥n
con
probabilidad
p.
(
Es


decir
,
suponemos
que
todos
los
nodos
tienen
siempre
una
trama
que
enviar
y
que
el
nodo


transmite
con
probabilidad
p
para
las
nuevas
tramas
,
y
no
s√≥lo
para
las
tramas
que
ya
hayan


sufrido
una
colisi√≥n
.
)
Suponga
que
existen
N
nodos
.
Entonces
,
la
probabilidad
de
que
una


partici√≥n
dada
sea
una
partici√≥n
de
√©xito
es
la
probabilidad
de
que
uno
de
los
nodos
trans-


436
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


Nodo
3


Clave
:


C
=
Partici√≥n
colisi√≥n


V
=
Partici√≥n
vac√≠a


E
=
Partici√≥n
 
de
√©xito


Nodo
2


Nodo
1


2
2
2


1
1
1
1


3
3
3


Tiempo


CVCEVCVE
E


Figura
5.11
‚Ä¢
Los
nodos
1
,
2
y
3
colisionan
en
la
primera
partici√≥n
.
El
nodo
2


consigue
tener
√©xito
finalmente
en
la
cuarta
partici√≥n
,
el
nodo
1


en
la
octava
partici√≥n
y
el
nodo
3
en
la
novena
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
436mita
y
de
que
los
restantes
N
‚Äì
1
nodos
no
transmitan
.
La
probabilidad
de
que
un
cierto
nodo


transmita
es
p
;
la
probabilidad
de
que
los
dem√°s
nodos
no
transmitan
es
(
1
‚Äì
p)N
/
H110021
.
Por


tanto
,
la
probabilidad
de
que
un
cierto
nodo
tenga
√©xito
al
transmitir
ser√°
p(1
‚Äì
p)N
/
H110021
.
Puesto


que
hay
N
nodos
,
la
probabilidad
de
que
exactamente
uno
de
los
N
nodos
tenga
√©xito
es


Np(1
‚Äì
p)N
/
H110021
.


Por
tanto
,
cuando
hay
N
nodos
activos
,
la
eficiencia
del
protocolo
ALOHA
con
parti-


ciones
es
Np(1
‚Äì
p)N
/
H110021
.
Para
obtener
la
eficiencia
m√°xima
para
N
nodos
activos
,
tenemos


que
determinar
el
valor
p
*
que
maximice
esta
expresi√≥n
.
(
Consulte
los
problemas
de
repaso


para
ver
un
esbozo
de
estos
c√°lculos
.
)
Y
para
obtener
la
m√°xima
eficiencia
para
un
gran


n√∫mero
de
nodos
activos
,
tomaremos
el
l√≠mite
de
Np*(1
‚Äì
p*)N
/
H110021
cuando
N
tiende
a
infinito
.


(
Consulte
de
nuevo
los
problemas
de
repaso
.
)
Despu√©s
de
realizar
estos
c√°lculos
,
se
puede


comprobar
que
la
eficiencia
m√°xima
del
protocolo
est√°
dada
por
1/
e
 
0,37
.
Es
decir
,


cuando
un
gran
n√∫mero
de
nodos
tienen
muchas
tramas
que
transmitir
,
entonces
(
como


m√°ximo
)
s√≥lo
el
37
por
ciento
de
las
particiones
conseguir√°n
transmitir
la
informaci√≥n
con


√©xito
.
Por
tanto
,
la
velocidad
de
transmisi√≥n
efectiva
del
canal
no
es
R
bps
sino
s√≥lo
0,37
R


bps
.
Un
an√°lisis
similar
muestra
tambi√©n
que
el
37
por
ciento
de
las
particiones
quedar√°n


vac√≠as
y
el
26
por
ciento
sufrir√°n
colisiones
.
¬°
Imag√≠nese
al
pobre
administrador
de
la
red
que


acaba
de
adquirir
un
sistema
ALOHA
con
particiones
a
100
Mbps
y
que
esperaba
poder


utilizar
la
red
para
transmitir
datos
entre
una
gran
cantidad
de
usuarios
,
con
una
velocidad


agregada
de
,
digamos
,
en
torno
a
80
Mbps
!
Aunque
el
canal
es
capaz
de
transmitir
una
deter-


minada
trama
a
la
velocidad
m√°xima
del
canal
de
100
Mbps
,
a
largo
plazo
,
la
tasa
de
trans-


ferencia
efectiva
de
este
canal
ser√°
menor
que
37
Mbps
.


Aloha


El
protocolo
ALOHA
con
particiones
requiere
que
todos
los
nodos
sincronicen
sus
transmi-


siones
para
que
√©stas
comiencen
al
principio
de
una
partici√≥n
.
El
primer
protocolo
ALOHA


[
Abramson
1970
]
era
en
realidad
un
protocolo
no
particionado
y
completamente
descentra-


lizado
.
En
el
protocolo
ALOHA
puro
,
cuando
llega
una
trama
(
es
decir
,
cuando
se
pasa
un


datagrama
desde
la
capa
de
red
en
el
nodo
emisor
)
el
nodo
transmite
inmediatamente
la
trama


en
su
totalidad
hacia
el
canal
de
difusi√≥n
.
Si
una
trama
transmitida
experimenta
una
colisi√≥n


con
una
o
m√°s
transmisiones
de
otros
nodos
,
el
nodo
(
despu√©s
de
transmitir
completamente
la


trama
que
ha
sufrido
la
colisi√≥n
)
retransmitir√°
la
trama
de
forma
inmediata
con
una
probabili-


dad
p.
En
caso
contrario
,
el
nodo
esperar√°
durante
un
tiempo
equivalente
al
tiempo
total
de


retransmisi√≥n
de
una
trama
.
Despu√©s
de
esta
espera
,
transmitir√°
la
trama
con
probabilidad
 
p
,


o
esperar√°
(
permaneciendo
inactivo
)
durante
otro
periodo
de
tiempo
igual
al
tiempo
de
trans-


misi√≥n
de
una
trama
con
una
probabilidad
1
‚Äì
p.


Para
determinar
la
eficiencia
m√°xima
del
protocolo
ALOHA
puro
vamos
a
centrarnos


en
un
nodo
individual
.
Haremos
las
mismas
suposiciones
que
en
nuestro
an√°lisis
del
proto-


colo
ALOHA
con
particiones
y
tomaremos
como
unidad
de
tiempo
el
tiempo
de
transmisi√≥n


de
una
trama
.
En
cualquier
instante
,
la
probabilidad
de
que
un
nodo
est√©
transmitiendo
una


trama
ser√°
p.
Suponga
que
esta
trama
comienza
su
transmisi√≥n
en
el
instante
t0
.
Como
se


muestra
en
la
Figura
5.12
,
para
que
esta
trama
pueda
transmitirse
con
√©xito
ning√∫n
otro
nodo


puede
iniciar
su
transmisi√≥n
en
el
intervalo
de
tiempo
[
t0
‚Äì
1
,
t0
]
,
ya
que
dicha
transmisi√≥n


se
solapar√≠a
con
el
inicio
de
la
transmisi√≥n
de
la
trama
del
nodo
i.
La
probabilidad
de
que


todos
los
dem√°s
nodos
no
comiencen
una
transmisi√≥n
en
ese
intervalo
es
(
1
‚Äì
p)N
/
H110021
.
De


forma
similar
,
ning√∫n
otro
nodo
puede
comenzar
una
transmisi√≥n
mientras
el
nodo
i
est√°


transmitiendo
,
ya
que
dicha
transmisi√≥n
se
solapar√≠a
con
la
√∫ltima
parte
de
la
transmisi√≥n


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
437


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
437del
nodo
i.
La
probabilidad
de
que
todos
los
dem√°s
nodos
no
inicien
una
transmisi√≥n
en
este


intervalo
ser√°
tambi√©n
(
1
‚Äì
p)N
/
H110021
.
Por
tanto
,
la
probabilidad
de
que
un
cierto
nodo
pueda


transmitir
con
√©xito
ser√°
p(1
‚Äì
p)2(N
/
H110021
)
.
Tomando
l√≠mites
como
en
el
caso
del
protocolo


ALOHA
con
particiones
,
encontramos
que
la
m√°xima
eficiencia
del
protocolo
ALOHA
puro


es
s√≥lo
de
1/(2e
)
,
que
es
exactamente
la
mitad
que
la
del
ALOHA
con
particiones
.
Por
tanto
,


ese
ser√°
el
precio
que
habr√°
que
pagar
por
disponer
de
un
protocolo
ALOHA
completamente


descentralizado
.


438
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


Tiempo


Solapamiento
con
el


principio
de
la
trama
i


t0
‚Äì
1
t0
t0
+
1


Solapamiento
con


el
final
de
la
trama
i


Trama
i
del
nodo


Figura
5.12
‚Ä¢
Transmisiones
que
interfieren
en
el
protocolo
ALOHA
puro
.


NORM
ABRAMSON
Y
ALOHANET


Norm
Abramson
,
doctor
ingeniero
,
era
un
apasionado
del
surf
y
estaba
tambi√©n
interesado


en
el
tema
de
la
conmutaci√≥n
de
paquetes
.
Esa
combinaci√≥n
de
intereses
le
llev√≥
a
la
univer-


sidad
de
Hawaii
en
1969
.
Hawaii
est√°
compuesto
por
muchas
islas
monta√±osas
,
lo
que


hace
dif√≠cil
instalar
y
operar
redes
terrestres
.
Cuando
no
estaba
practicando
surf
,
Abramson


se
dedicada
a
pensar
en
c√≥mo
dise√±ar
una
red
que
realizara
la
conmutaci√≥n
de
paquetes


v√≠a
radio
.
La
red
que
dise√±√≥
dispon√≠a
de
un
host
central
y
de
varios
nodos
secundarios


dispersos
por
las
islas
del
archipi√©lago
de
Hawaii
.
La
red
ten√≠a
dos
canales
,
cada
uno
de
los


cuales
utilizaba
una
banda
de
frecuencia
distinta
.
El
canal
de
bajada
difund√≠a
los
paquetes


desde
el
host
central
hacia
los
hosts
secundarios
,
mientras
que
el
de
subida
permit√≠a
enviar


paquetes
desde
los
hosts
secundarios
al
host
central
.
Adem√°s
de
enviar
paquetes
de
informa-


ci√≥n
,
el
host
central
tambi√©n
enviaba
a
trav√©s
del
canal
de
bajada
un
mensaje
de
reconoci-


miento
para
cada
uno
de
los
paquetes
recibidos
desde
los
hosts
secundarios
.


Puesto
que
los
hosts
secundarios
transmit√≠an
los
paquetes
de
forma
descentralizada
,
las


colisiones
en
el
canal
de
subida
eran
inevitables
.
Esta
observaci√≥n
condujo
a
Abramson
a


desarrollar
el
protocolo
ALOHA
puro
,
descrito
en
este
cap√≠tulo
.
En
1970
,
gracias
a
las
apor-


taciones
econ√≥micas
de
ARPA
,
Abramson
conect√≥
su
red
ALOHAnet
con
ARPAnet
.
El
trabajo


de
Abramson
es
importante
no
s√≥lo
porque
fue
el
primer
ejemplo
de
red
de
paquetes
v√≠a


radio
,
sino
tambi√©n
porque
sirvi√≥
de
inspiraci√≥n
a
Bob
Metcalfe
.
Unos
pocos
a√±os
m√°s
tarde
,


Metcalfe
modific√≥
el
protocolo
para
crear
el
protocolo
CSMA
/
CD
y
las
redes
LAN
Ethernet
.


HISTORIA


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
438Acceso
m√∫ltiple
con
sondeo
de
portadora
(
CSMA
)


Tanto
en
el
protocolo
ALOHA
puro
como
con
particiones
,
la
decisi√≥n
de
transmitir
por
parte


de
un
nodo
se
toma
independientemente
de
la
actividad
de
los
otros
nodos
conectados
al


canal
de
difusi√≥n
.
En
particular
,
los
nodos
nunca
prestan
atenci√≥n
,
en
el
momento
de
comen-


zar
a
transmitir
,
a
si
hay
otros
nodos
transmitiendo
ni
tampoco
dejan
de
transmitir
si
otro


nodo
comienza
a
interferir
con
su
transmisi√≥n
.
En
nuestra
analog√≠a
del
coctel
,
los
protocolos


ALOHA
se
parecen
bastante
a
uno
de
esos
invitados
maleducados
que
contin√∫an
charlando


independientemente
de
si
hay
otras
personas
haciendo
uso
de
la
palabra
.
Las
personas
dis-


ponemos
de
protocolos
que
nos
permiten
no
s√≥lo
comportarnos
de
manera
civilizada
,
sino


tambi√©n
reducir
la
cantidad
de
tiempo
desperdiciado
‚Äú
colisionando
‚Äù
unos
con
otros
durante


las
conversaciones
e
incrementar
as√≠
,
como
consecuencia
,
la
cantidad
de
informaci√≥n
que
en


nuestras
conversaciones
podemos
intercambiar
.
Espec√≠ficamente
,
hay
dos
reglas
importan-


tes
de
buena
educaci√≥n
en
las
conversaciones
que
mantenemos
los
seres
humanos
:


‚Ä¢
Escuchar
antes
de
hablar
.
Si
hay
otra
persona
hablando
,
esperaremos
hasta
que
haya
ter-


minado
.
En
el
mundo
de
las
redes
esto
se
denomina
sondeo
de
portadora
:
cada
nodo


escucha
el
canal
antes
de
transmitir
.
Si
actualmente
se
est√°
transmitiendo
una
trama
de


otro
nodo
por
el
canal
,
el
nodo
esperar√°
un
intervalo
de
tiempo
aleatorio
y
luego
volver√°


a
sondear
para
ver
si
existe
portadora
en
el
canal
.
Si
comprueba
que
el
canal
est√°
inac-


tivo
,
el
nodo
comenzar√°
a
transmitir
su
trama
.
En
caso
contrario
,
el
nodo
esperar√°
otro


intervalo
aleatorio
de
tiempo
y
volver√°
a
repetir
este
proceso
.


‚Ä¢
Si
alguien
comienza
a
hablar
al
mismo
tiempo
,
hay
que
dejar
de
hablar
.
En
el
mundo
de


las
redes
esto
se
denomina
detecci√≥n
de
colisiones
:
un
nodo
que
est√©
transmitiendo
escu-


char√°
qu√©
es
lo
que
hay
en
el
canal
mientras
dure
la
transmisi√≥n
.
Si
detecta
que
otro
nodo


est√°
transmitiendo
una
trama
que
interfiere
la
suya
,
dejar√°
de
transmitir
y
emplear√°
alg√∫n


tipo
de
protocolo
para
determinar
cu√°ndo
debe
volver
a
intentar
transmitir
de
nuevo
.


Estas
dos
reglas
est√°n
integradas
en
la
familia
de
protocolos
de
Acceso
m√∫ltiple
con


sondeo
de
portadora
(
CSMA
,
Carrier
Sense
Multiple
Access
)
y
CSMA
con
detecci√≥n
de


colisiones
(
CSMA
/
CD
)
[
Kleinrock
1975b
;
Metcalfe
1976
;
Lam
1980
;
Rom
1990
]
.
Se
han


propuesto
muchas
variantes
de
CSMA
y
CSMA
/
CD
.
Puede
consultar
esas
referencias
para


conocer
los
detalles
de
estos
protocolos
.
Estudiaremos
en
detalle
el
esquema
de
CSMA
/
CD


utilizado
en
Ethernet
en
la
Secci√≥n
5.5
.
Aqu√≠
consideraremos
algunas
de
las
caracter√≠sticas


m√°s
importantes
y
fundamentales
de
CSMA
y
CSMA
/
CD
.


La
primera
cuesti√≥n
que
podr√≠amos
plantearnos
acerca
de
CSMA
es
por
qu√©
,
si
todos


los
nodos
llevan
a
cabo
un
sondeo
de
portadora
,
se
producen
colisiones
.
Despu√©s
de
todo
,


los
nodos
se
guardar√°n
de
transmitir
cada
vez
que
detecten
que
otro
nodo
est√°
transmitiendo
.


La
mejor
forma
de
responder
a
esta
pregunta
es
ilustrarla
mediante
diagramas
espacio-


tiempo
[
Molle
1987
]
.
La
Figura
5.13
muestra
un
diagrama
espacio-tiempo
de
cuatro
nodos


(
A
,
B
,
C
,
D
)
conectados
a
un
bus
lineal
de
difusi√≥n
.
El
eje
horizontal
muestra
la
posici√≥n
de


cada
nodo
en
el
espacio
y
el
eje
vertical
representa
el
tiempo
.


En
el
instante
t0
,
el
nodo
B
comprueba
que
el
canal
est√°
inactivo
,
ya
que
no
hay
ning√∫n


nodo
transmitiendo
actualmente
.
Por
tanto
,
el
nodo
B
comenzar√°
a
transmitir
propag√°ndose


sus
bits
en
ambas
direcciones
a
lo
largo
del
medio
de
difusi√≥n
.
La
propagaci√≥n
hacia
abajo


de
los
bits
de
B
en
la
Figura
5.13
a
lo
largo
del
tiempo
indica
que
hace
falta
un
intervalo
de


tiempo
distinto
de
cero
para
que
los
bits
de
B
consigan
propagarse
(
aunque
lo
hagan
a
una


velocidad
pr√≥xima
a
la
de
la
luz
)
a
lo
largo
de
medio
de
difusi√≥n
.
En
el
instante
t1
(
t1
>
t0
)
el


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
439


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
439nodo
D
tiene
una
trama
que
enviar
.
Aunque
el
nodo
B
actualmente
est√°
transmitiendo
en
el


instante
t1
,
los
bits
que
B
est√°
transmitiendo
todav√≠a
no
han
alcanzado
a
D
,
por
lo
que
D


detectar√°
que
el
canal
est√°
inactivo
en
t1
.
De
acuerdo
con
el
protocolo
CSMA
,
D
por
tanto


comienza
a
transmitir
su
trama
.
Un
corto
intervalo
de
tiempo
despu√©s
,
la
transmisi√≥n
de


B
comienza
a
interferir
en
D
con
la
propia
transmisi√≥n
de
D.
A
partir
de
la
Figura
5.13


resulta
evidente
que
el
retardo
de
propagaci√≥n
de
canal
terminal
a
terminal
de
un
canal
de


difusi√≥n
(
el
tiempo
que
una
se√±al
tarda
en
propagarse
de
uno
de
los
nodos
a
otro
)
desempe-


√±ar√°
un
papel
fundamental
a
la
hora
de
determinar
el
rendimiento
del
canal
.
Cuanto
mayor


sea
este
retardo
de
propagaci√≥n
,
mayor
ser√°
la
probabilidad
de
que
un
nodo
que
efect√∫a
el


sondeo
de
portadora
no
sea
capaz
de
detectar
una
transmisi√≥n
que
ya
ha
comenzado
en
otro


nodo
de
la
red
.


En
la
Figura
5.13
los
nodos
no
realizan
una
detecci√≥n
de
colisiones
;
tanto
B
como
D


contin√∫an
transmitiendo
sus
tramas
en
su
totalidad
,
a√∫n
cuando
se
haya
producido
una
coli-


si√≥n
.
Cuando
un
nodo
realiza
una
detecci√≥n
de
colisiones
deja
de
transmitir
en
cuanto


detecta
que
se
ha
producido
una
colisi√≥n
.
La
Figura
5.14
muestra
el
mismo
escenario
que
la


Figura
5.13
salvo
porque
los
dos
nodos
abortan
ahora
su
transmisi√≥n
poco
despu√©s
de
detec-


tar
que
se
ha
producido
una
colisi√≥n
.
Evidentemente
,
a√±adir
el
mecanismo
de
detecci√≥n
de


colisiones
a
un
protocolo
de
acceso
m√∫ltiple
ayudar√°
a
incrementar
el
rendimiento
del
pro-


440
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


A


Tiempo
Tiempo


Espacio


t
0


t
1


BCD


Figura
5.13
‚Ä¢
Diagrama
espacio-tiempo
para
dos
nodos
CSMA
con


transmisiones
que
entran
en
colisi√≥n
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
440tocolo
,
al
no
transmitirse
una
trama
in√∫til
,
da√±ada
(
por
interferencia
con
una
trama
de
otro


nodo
)
en
su
totalidad
.
El
protocolo
Ethernet
que
estudiaremos
en
la
Secci√≥n
5.5
es
un
proto-


colo
CSMA
que
utiliza
detecci√≥n
de
colisiones
.


5.3.3
Protocolos
de
toma
de
turnos


Recuerde
que
dos
propiedades
deseables
de
un
protocolo
de
acceso
m√∫ltiple
son
:
(
1
)
cuando


s√≥lo
haya
un
nodo
activo
,
√©ste
tendr√°
una
tasa
de
transferencia
de
R
bps
y
(
2
)
cuando
haya


M
nodos
activos
,
entonces
cada
nodo
activo
dispondr√°
de
una
tasa
de
transferencia
de
apro-


ximadamente
R
/
M
bps
.
Los
protocolos
ALOHA
y
CSMA
presentan
la
primera
de
las
propie-


dades
,
pero
no
la
segunda
.
Esto
ha
servido
de
motivaci√≥n
para
que
una
serie
de


investigadores
creen
otra
clase
de
protocolos
:
los
protocolos
de
toma
de
turnos
.
Al
igual


que
con
los
protocolos
de
acceso
aleatorio
,
existen
docenas
de
protocolos
de
toma
de
turnos


distintos
y
cada
uno
de
estos
protocolos
tiene
m√∫ltiples
variantes
.
Aqu√≠
vamos
hablar
de
dos


de
los
protocolos
m√°s
importantes
de
este
tipo
.
El
primero
es
el
protocolo
de
sondeo


(
polling
)
.
Este
 
protocolo
requiere
que
se
designe
a
uno
de
los
nodos
como
nodo
maestro
.
El


nodo
maestro
sondea
a
cada
uno
de
los
otros
nodos
a
la
manera
de
turno
rotatorio
(
round


robin
)
.
En
particular
,
el
nodo
maestro
env√≠a
primero
un
mensaje
al
nodo
1
,
dici√©ndole
que


puede
transmitir
hasta
un
cierto
n√∫mero
m√°ximo
de
tramas
.
Despu√©s
de
que
el
nodo
1
trans-


mita
una
serie
de
tramas
,
el
nodo
maestro
le
dir√°
al
nodo
2
que
puede
transmitir
hasta
el


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
441


A


Tiempo
Tiempo


Tiempo
de


detecci√≥n
de
colisi√≥n/


cancelaci√≥n
de
la
trama


Espacio


t
0


t
1


BC
D


Figura
5.14
‚Ä¢
CSMA
con
detecci√≥n
de
colisiones
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
441m√°ximo
n√∫mero
de
tramas
.
(
El
nodo
maestro
puede
determinar
cu√°ndo
un
nodo
ha
termi-


nado
de
enviar
sus
tramas
observando
la
falta
de
se√±al
en
el
canal
.
)
El
procedimiento
conti-


n√∫a
de
esta
forma
ininterrumpidamente
,
encarg√°ndose
el
nodo
maestro
de
sondear
a
cada


uno
de
los
otros
nodos
de
forma
c√≠clica
.


El
protocolo
de
sondeo
elimina
las
colisiones
y
las
particiones
vac√≠as
que
infectan
los


protocolos
de
acceso
aleatorio
.
Esto
permite
que
el
mecanismo
de
sondeo
consiga
una
efi-


ciencia
mucho
mayor
,
aunque
tambi√©n
presenta
algunas
desventajas
.
La
primera
es
que
el


protocolo
introduce
un
retardo
de
sondeo
:
el
intervalo
de
tiempo
requerido
para
indicarle
a


un
nodo
que
puede
transmitir
.
Por
ejemplo
,
si
s√≥lo
hay
un
nodo
activo
,
entonces
el
nodo


transmitir√°
a
una
velocidad
menor
que
R
bps
,
ya
que
el
nodo
maestro
deber√°
sondear
a
cada


uno
de
los
nodos
inactivos
por
turno
cada
vez
que
el
nodo
activo
haya
terminado
de
enviar


su
n√∫mero
m√°ximo
de
tramas
.
El
segundo
inconveniente
,
que
puede
ser
m√°s
grave
,
es
que
si


el
nodo
maestro
falla
,
entonces
todo
el
canal
dejar√°
de
estar
operativo
.
El
protocolo
802.15


y
el
protocolo
Bluetooth
que
estudiaremos
en
la
Secci√≥n
6.3
son
ejemplos
de
protocolos
de


sondeo
.


El
segundo
protocolo
de
toma
de
turnos
es
el
protocolo
de
paso
de
testigo
.
En
este
pro-


tocolo
no
existe
ning√∫n
nodo
maestro
;
en
su
lugar
hay
una
trama
de
peque√±o
tama√±o
y
de


prop√≥sito
especial
conocida
con
el
nombre
de
testigo
(
token
)
que
va
siendo
intercambiada


entre
los
nodos
en
un
determinado
orden
fijo
.
Por
ejemplo
,
puede
que
el
nodo
1
env√≠e
el
tes-


tigo
siempre
al
nodo
2
,
el
nodo
2
al
nodo
3
y
el
nodo
N
al
nodo
1
.
Cuando
un
nodo
recibe
el


testigo
,
lo
retiene
si
dispone
de
alguna
trama
para
transmitir
;
en
caso
contrario
,
reenv√≠a


inmediatamente
el
testigo
al
siguiente
nodo
.
Si
un
nodo
tiene
tramas
que
transmitir
cuando


recibe
el
testigo
,
env√≠a
una
trama
detr√°s
de
otra
,
hasta
el
n√∫mero
m√°ximo
de
tramas
permi-


tido
y
luego
reenv√≠a
el
testigo
al
siguiente
nodo
.
El
mecanismo
de
paso
de
testigo
es
decen-


tralizado
y
extremadamente
eficiente
,
aunque
tambi√©n
tiene
sus
propios
problemas
.
Por


ejemplo
,
el
fallo
de
un
nodo
puede
hacer
que
todo
el
canal
quede
inutilizable
,
o
si
un
nodo


se
olvidara
accidentalmente
de
liberar
el
testigo
,
entonces
ser√≠a
necesario
invocar
alg√∫n
pro-


cedimiento
de
recuperaci√≥n
para
hacer
que
el
testigo
vuelva
a
circular
.
A
lo
largo
de
los
a√±os


se
han
desarrollado
muchos
protocolos
de
paso
de
testigo
y
cada
uno
de
ellos
tuvo
que
preo-


cuparse
de
resolver
estos
problemas
,
as√≠
como
algunos
otros
problemas
complicados
;
hare-


mos
menci√≥n
de
estos
protocolos
,
FDDI
e
IEEE
802.5
,
en
la
siguiente
secci√≥n
.


5.3.4
Redes
de
√°rea
local
(
LAN
)


Los
protocolos
de
acceso
m√∫ltiple
se
utilizan
junto
con
muchos
tipos
distintos
de
canales
de


difusi√≥n
.
Se
han
utilizado
para
canales
de
sat√©lite
e
inal√°mbricos
,
cuyos
nodos
transmiten
a


trav√©s
de
un
espectro
de
frecuencia
com√∫n
.
Actualmente
se
utilizan
en
el
canal
de
subida


para
el
acceso
a
Internet
por
cable
(
v√©ase
la
Secci√≥n
1.2
)
,
y
tambi√©n
se
utilizan
ampliamente


en
las
redes
de
√°rea
local
(
LAN
)
.


Recuerde
que
una
LAN
es
una
red
de
computadoras
concentrada
en
un
√°rea
geogr√°fica
,


como
por
ejemplo
en
un
edificio
o
en
un
campus
universitario
.
Cuando
un
usuario
accede
a


Internet
desde
un
campus
universitario
o
corporativo
,
el
acceso
casi
siempre
se
realiza
a
tra-


v√©s
de
una
LAN
;
espec√≠ficamente
,
el
acceso
se
lleva
a
cabo
desde
un
host
a
la
LAN
,
desde


√©sta
a
un
router
y
desde
el
router
a
Internet
,
como
se
muestra
en
la
Figura
5.15
.
La
velocidad


de
transmisi√≥n
,
R
,
de
la
mayor√≠a
de
las
redes
LAN
es
muy
alta
.
Incluso
a
principios
de
la


d√©cada
de
1980
,
las
redes
LAN
a
10
Mbps
eran
bastante
comunes
;
hoy
d√≠a
,
resultan
comu-


nes
las
redes
LAN
de
100
Mbps
y
1
Gbps
y
ya
hay
disponibles
redes
LAN
a
10
Gbps
.


442
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
442En
la
d√©cada
de
1980
y
a
principios
de
la
de
1990
hab√≠a
dos
clases
de
tecnolog√≠as
LAN


muy
populares
en
los
entornos
empresariales
.
La
primera
clase
era
la
de
las
redes


LAN
Ethernet
(
tambi√©n
conocidas
como
redes
LAN
802.3
[
IEEE
802.3
2009
]
)
,
que
est√°n


basadas
en
un
mecanismo
de
acceso
aleatorio
.
La
segunda
clase
de
tecnolog√≠as
LAN
estaba


compuesta
por
las
tecnolog√≠as
de
paso
de
testigo
,
incluyendo
la
tecnolog√≠a
token
ring
(
tam-


bi√©n
conocida
como
IEEE
802.5
[
IEEE
802.5
2009
]
)
y
la
Interfaz
de
datos
distribuidos


para
fibra
(
FDDI
,
Fiber
Distributed
Data
Interface
)
[
Jain
1994
]
.
Dado
que
vamos
a
anali-


zar
las
tecnolog√≠as
Ethernet
con
un
cierto
grado
de
detalle
en
la
Secci√≥n
5.5
,
centraremos


aqu√≠
nuestras
explicaciones
en
las
redes
LAN
de
paso
de
testigo
.
Nuestra
exposici√≥n
acerca


de
las
tecnolog√≠as
de
paso
de
testigo
es
intencionadamente
breve
,
porque
la
implacable
com-


petencia
de
las
redes
Ethernet
ha
hecho
que
estas
tecnolog√≠as
pr√°cticamente
se
hayan
extin-


guido
.
De
todos
modos
,
para
poder
proporcionar
ejemplos
de
tecnolog√≠as
de
paso
de
testigo


y
para
poder
disponer
de
una
cierta
perspectiva
hist√≥rica
resulta
√∫til
decir
unas
cuantas
pala-


bras
acerca
de
las
redes
de
paso
de
testigo
.


En
una
LAN
token
ring
,
los
N
nodos
de
la
LAN
(
hosts
y
routers
)
est√°n
conectados
en


anillo
mediante
una
serie
de
enlaces
directos
.
La
topolog√≠a
en
anillo
de
paso
de
testigo


define
el
orden
en
que
el
testigo
se
pasa
de
un
nodo
a
otro
.
Cuando
un
nodo
obtiene
el
tes-


tigo
y
env√≠a
una
trama
,
la
trama
se
propaga
alrededor
del
anillo
completo
,
creando
as√≠
un


canal
de
difusi√≥n
virtual
.
El
nodo
de
destino
lee
la
trama
a
partir
del
medio
de
la
capa
de


enlace
,
en
el
momento
que
la
trama
se
propaga
a
su
trav√©s
.
El
nodo
que
env√≠a
la
trama
tiene


la
responsabilidad
de
eliminar
la
trama
del
anillo
.
FDDI
se
dise√±√≥
para
redes
LAN
geogr√°fi-


camente
m√°s
amplias
,
incluyendo
las
redes
de
√°rea
metropolitana
(
MAN
,
Metropolitan


Area
Network
)
.
Para
las
redes
LAN
geogr√°ficamente
amplias
(
distribuidas
a
lo
largo
de


varios
kil√≥metros
)
es
poco
eficiente
dejar
que
una
trama
se
propague
de
vuelta
hacia
el
nodo


emisor
despu√©s
de
haber
sobrepasado
el
nodo
de
destino
.
FDDI
hace
que
el
nodo
de
destino


elimine
la
trama
del
anillo
.
(
Hablando
en
sentido
estricto
,
FDDI
no
es
por
tanto
un
canal
de


difusi√≥n
puro
,
ya
que
no
todos
los
nodos
reciben
las
tramas
transmitidas
.
)


5.3
‚Ä¢
PROTOCOLOS
DE
ACCESO
M√öLTIPLE
443


Hosts
de


usuario


Servidor


web


Router


LAN


Clave
:


Interfaz


Internet


Figura
5.15
‚Ä¢
Hosts
de
usuario
accediendo
a
un
servidor
web
de
Internet
a


trav√©s
de
una
LAN
,
estando
compuesto
el
canal
de
difusi√≥n
entre


un
host
de
usuario
y
el
router
por
un
√∫nico
enlace
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4435.4
Direccionamiento
de
la
capa
de
enlace


Los
nodos
(
es
decir
,
los
hosts
y
los
routers
)
tienen
direcciones
de
la
capa
de
enlace
.
Esto


podr√≠a
parecer
sorprendente
si
recordamos
del
Cap√≠tulo
4
que
los
nodos
tienen
tambi√©n


direcciones
de
la
capa
de
red
.
Es
posible
que
el
lector
se
est√©
preguntando
para
qu√©
necesita-


mos
disponer
de
direcciones
tanto
en
la
capa
de
red
como
en
la
de
enlace
.
Adem√°s
de
des-


cribir
la
sintaxis
y
la
funci√≥n
de
las
direcciones
de
la
capa
de
enlace
,
en
esta
secci√≥n


confiamos
en
arrojar
algo
de
luz
sobre
las
razones
por
las
que
resulta
√∫til
emplear
las
dos


capas
de
direcciones
y
,
de
hecho
,
veremos
que
esto
es
indispensable
.
Tambi√©n
nos
ocupare-


mos
del
Protocolo
de
resoluci√≥n
de
direcciones
(
ARP
,
Address
Resolution
Protocol
)
,
que


proporciona
un
mecanismo
para
traducir
las
direcciones
IP
en
direcciones
de
la
capa
de


enlace
.


5.4.1
Direcciones
MAC


En
realidad
,
no
son
los
nodos
(
es
decir
,
los
hosts
o
routers
)
los
que
tienen
asignadas
direccio-


nes
de
la
capa
de
enlace
,
sino
que
las
direcciones
de
la
capa
de
enlace
se
asignan
a
los
adap-


tadores
instalados
en
cada
nodo
.
Esto
se
ilustra
en
la
Figura
5.16
.
A
las
direcciones
de
la
capa


de
enlace
se
las
denomina
de
diversas
formas
como
direcci√≥n
LAN
,
direcci√≥n
f√≠sica
o


direcci√≥n
MAC
.
Dado
que
el
t√©rmino
direcci√≥n
MAC
parece
ser
el
m√°s
popular
,
en
lo
suce-


sivo
nos
referiremos
a
las
direcciones
de
la
capa
de
enlace
utilizando
dicho
t√©rmino
.
En
la


mayor√≠a
de
las
redes
LAN
(
incluyendo
las
redes
Ethernet
y
las
LAN
inal√°mbricas
802.11
)
,
la


direcci√≥n
MAC
tiene
6
bytes
de
longitud
,
lo
que
nos
da
248
posibles
direcciones
MAC
.
Como


se
muestra
en
la
Figura
5.16
,
estas
direcciones
de
6
bytes
suelen
expresarse
en
notaci√≥n
hexa-


decimal
,
indic√°ndose
cada
byte
de
la
direcci√≥n
mediante
una
pareja
de
n√∫meros
 
hexadeci-


males
.
Aunque
las
direcciones
MAC
se
dise√±aron
para
ser
permanentes
,
hoy
d√≠a
es
posible


modificar
la
direcci√≥n
MAC
de
un
adaptador
mediante
un
software
apropiado
.
Sin
embargo
,


en
el
resto
de
esta
secci√≥n
supondremos
que
la
direcci√≥n
MAC
de
un
adaptador
es
fija
.


Una
propiedad
interesante
de
las
direcciones
MAC
es
que
nunca
puede
haber
dos
adap-


tadores
con
la
misma
direcci√≥n
.
Esto
puede
parecer
sorprendente
,
dado
que
los
adaptadores


son
fabricados
por
muchas
compa√±√≠as
distintas
en
muchos
pa√≠ses
diferentes
.
¬ø
C√≥mo
puede


una
empresa
fabricante
de
adaptadores
de
Taiwan
estar
segura
de
que
est√°
utilizando
un
con-


junto
diferente
de
direcciones
del
que
emplea
otra
empresa
que
fabrica
adaptadores
en
B√©l-


gica
?
La
 
respuesta
es
que
el
IEEE
se
encarga
de
gestionar
el
espacio
de
direcciones
MAC
.


En
particular
,
cuando
una
empresa
quiere
fabricar
adaptadores
,
compra
por
un
precio
fijado


una
parte
del
espacio
de
direcciones
compuesto
por
2
24
direcciones
.
IEEE
asigna
el
frag-


mento
de
224
direcciones
fijando
los
primeros
24
bits
de
una
direcci√≥n
MAC
y
dejando
que
la


empresa
dise√±e
combinaciones
√∫nicas
de
los
√∫ltimos
24
bits
para
cada
adaptador
.


La
direcci√≥n
MAC
de
un
adaptador
tiene
una
estructura
plana
(
en
oposici√≥n
a
una


estructura
jer√°rquica
)
y
nunca
var√≠a
independientemente
de
a
d√≥nde
se
lleve
el
adaptador
.


Una
computadora
port√°til
con
una
tarjeta
Ethernet
siempre
tendr√°
la
misma
direcci√≥n
MAC
,


independientemente
de
d√≥nde
se
utilice
esa
computadora
.
Una
PDA
con
una
interfaz
802.11


tendr√°
siempre
tambi√©n
la
misma
direcci√≥n
MAC
,
independientemente
de
d√≥nde
la
lleve-


mos
.
Recuerde
que
,
por
contraste
,
las
direcciones
IP
tienen
una
estructura
jer√°rquica
(
es


decir
,
una
parte
de
red
y
una
parte
de
host
)
y
que
es
necesario
modificar
la
direcci√≥n
IP
de


un
nodo
cuando
el
host
se
mueve
,
es
decir
,
cuando
cambia
la
red
a
la
que
el
host
est√°
conec-


tado
.
La
direcci√≥n
MAC
de
un
adaptador
es
an√°loga
al
n√∫mero
del
carnet
de
identidad
o
de


444
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
444la
seguridad
social
de
una
persona
,
que
tambi√©n
tiene
una
estructura
de
direccionamiento


plana
que
no
cambia
independientemente
de
a
d√≥nde
se
vaya
a
vivir
esa
persona
.
Un
direc-


ci√≥n
IP
,
por
su
parte
,
ser√≠a
an√°loga
a
la
direcci√≥n
postal
de
una
personas
,
que
es
jer√°rquica
y


que
debe
modificarse
cada
vez
que
una
persona
cambia
de
domicilio
.
Al
igual
que
para
las


personas
resulta
√∫til
disponer
tanto
de
una
direcci√≥n
postal
como
de
un
n√∫mero
de
la
seguri-


dad
social
,
tambi√©n
para
los
nodos
resulta
√∫til
disponer
de
una
direcci√≥n
de
la
capa
de
red
y


de
una
direcci√≥n
MAC
.


Como
hemos
descrito
al
principio
de
esta
secci√≥n
,
cuando
un
adaptador
de
un
emisor


quiere
enviar
una
trama
a
otro
adaptador
de
destino
,
inserta
la
direcci√≥n
MAC
del
de
destino


en
la
trama
y
luego
la
env√≠a
a
trav√©s
de
la
red
LAN
.
Si
la
red
LAN
es
una
LAN
de
difusi√≥n


(
como
por
ejemplo
,
802.11
o
Ethernet
)
,
la
trama
ser√°
recibida
y
procesada
por
todos
los


dem√°s
adaptadores
de
la
LAN
.
En
particular
,
cada
adaptador
que
reciba
la
trama
compro-


bar√°
si
la
direcci√≥n
MAC
de
destino
contenida
en
la
trama
se
corresponde
con
su
propia


direcci√≥n
MAC
.
Si
existe
una
correspondencia
,
el
adaptador
extraer√°
el
datagrama
incluido


en
la
trama
y
lo
pasar√°
hacia
arriba
por
la
pila
de
protocolos
para
entreg√°rselo
a
su
nodo


padre
.
Si
no
hay
una
correspondencia
entre
ambas
direcciones
,
el
adaptador
descarta
la


trama
,
sin
pasar
el
datagrama
de
la
capa
de
red
hacia
arriba
por
la
pila
de
protocolos
.
De
este


modo
,
s√≥lo
el
nodo
de
destino
ser√°
interrumpido
cuando
se
reciba
la
trama
.


Sin
embargo
,
en
ocasiones
un
adaptador
de
un
emisor
s√≠
que
quiereque
todos
los
dem√°s


adaptadores
de
la
LAN
reciban
y
procesen
la
trama
que
va
a
enviar
.
En
este
caso
,
el
adapta-


dor
emisor
inserta
una
direcci√≥n
de
difusi√≥n
MAC
especial
en
el
campo
de
la
direcci√≥n
de


destino
de
la
trama
.
Para
las
redes
LAN
que
utilizan
direcciones
de
6
bytes
(
como
las
LAN


Ethernet
y
de
paso
de
testigo
)
,
la
direcci√≥n
de
difusi√≥n
es
una
cadena
compuesta
por
48


unos
(
1
)
consecutivos
(
es
decir
,
FF-
FF-FF-FF-FF-FF
en
notaci√≥n
hexadecimal
)
.


5.4.2
Protocolo
de
resoluci√≥n
de
direcciones
(
ARP
)


Dado
que
existen
tanto
direcciones
de
la
capa
de
red
(
por
ejemplo
,
direcciones
IP
de
Inter-


net
)
como
direcciones
de
la
capa
de
enlace
(
es
decir
,
direcciones
MAC
)
,
surge
la
necesidad


5.4
‚Ä¢
DIRECCIONAMIENTO
DE
LA
CAPA
DE
ENLACE
445


88-B2-2F-54-1A-0F5C-66-AB-90-75-B1


1A-23-F9-CD-06-9B


49-BD-D2-C7-56-2A


Figura
5.16
‚Ä¢
Cada
adaptador
conectado
a
una
LAN
dispone
de
una
direcci√≥n


MAC
√∫nica
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
445de
una
traducci√≥n
entre
ellas
.
En
Internet
,
esta
tarea
la
lleva
 
a
cabo
el
Protocolo
de
resolu-


ci√≥n
de
direcciones
(
ARP
,
Address
Resolution
Protocol
)
[
RFC
826
]
.


Para
comprender
la
necesidad
de
un
protocolo
como
ARP
,
considere
la
red
mostrada
en


la
Figura
5.17
.
En
este
sencillo
ejemplo
,
cada
nodo
tiene
una
direcci√≥n
IP
√∫nica
y
el
adapta-


dor
de
cada
nodo
tiene
una
direcci√≥n
MAC
√∫nica
.
Como
siempre
,
las
direcciones
IP
se


muestran
en
notaci√≥n
decimal
con
punto
y
las
direcciones
MAC
en
notaci√≥n
hexadecimal
.


Supongamos
ahora
que
el
nodo
con
la
direcci√≥n
IP
222.222.222.220
desea
enviar
un
data-


grama
IP
al
nodo
222.222.222.222
.
En
este
ejemplo
,
tanto
el
nodo
de
origen
como
el
destino


se
encuentran
en
la
misma
red
(
LAN
)
en
el
sentido
de
direccionamiento
expresado
en
la


Secci√≥n
4.4.2
.
Para
enviar
un
datagrama
,
el
nodo
de
origen
tiene
que
proporcionar
a
su
adap-


tador
no
s√≥lo
el
datagrama
IP
sino
tambi√©n
la
direcci√≥n
MAC
del
nodo
de
destino


222.222.222.222
.
El
adaptador
del
nodo
emisor
construir√°
entonces
una
trama
de
la
capa
de


enlace
que
contendr√°
la
direcci√≥n
MAC
del
nodo
destino
y
enviar√°
la
trama
a
la
red
LAN
.


La
pregunta
fundamental
en
esta
secci√≥n
es
:
¬ø
C√≥mo
determina
el
nodo
de
origen
la


direcci√≥n
MAC
del
nodo
de
destino
con
la
direcci√≥n
IP
222.222.222.222
?
Como
posible-


mente
ya
haya
adivinado
,
utiliza
el
protocolo
ARP
.
Un
m√≥dulo
ARP
en
el
nodo
emisor
toma


como
entrada
cualquier
direcci√≥n
IP
de
la
misma
LAN
y
devuelve
la
direcci√≥n
MAC
corres-


pondiente
.
En
nuestro
ejemplo
,
el
nodo
emisor
222.222.222.220
proporciona
a
su
m√≥dulo


ARP
la
direcci√≥n
IP
222.222.222.222
y
el
m√≥dulo
ARP
devuelve
la
correspondiente
direc-


ci√≥n
MAC
49-BD-D2-C7-56-2A.


Vemos
por
tanto
que
ARP
resuelve
una
direcci√≥n
IP
en
una
direcci√≥n
MAC
.
En
muchos


sentidos
,
esto
es
an√°logo
a
DNS
(
estudiado
en
la
Secci√≥n
2.5
)
,
que
resuelve
nombres
de
host


en
direcciones
IP
.
Sin
embargo
,
una
diferencia
importante
entre
los
dos
resolvedores
es
que


DNS
resuelve
nombres
de
host
para
hosts
ubicados
en
cualquier
lugar
de
Internet
,
mientras


446
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


PRINCIPLES
IN
PRACTICE


MANTENER
LAS
CAPAS
INDEPENDIENTES


Existen
varias
razones
por
las
que
los
nodos
tienen
direcciones
MAC
adem√°s
de
las
direcciones
de


la
capa
de
red
.
En
primer
lugar
,
las
redes
LAN
est√°n
dise√±adas
para
protocolos
arbitrarios
de
la


capa
de
red
,
no
s√≥lo
para
IP
e
Internet
.
Si
los
adaptadores
de
red
tuvieran
asignadas
direcciones


IP
en
lugar
de
direcciones
MAC
‚Äú
neutras
‚Äù
,
entonces
no
podr√≠an
dar
soporte
f√°cilmente
a
otros
pro-


tocolos
de
la
capa
de
red
(
como
por
ejemplo
,
IPX
o
DECnet
)
.
En
segundo
lugar
,
si
los
adaptadores


utilizaran
direcciones
de
la
capa
de
red
en
lugar
de
direcciones
MAC
,
la
direcci√≥n
de
la
capa
de


red
se
tendr√≠a
que
almacenar
en
la
memoria
RAM
del
adaptador
y
tendr√≠a
que
reconfigurarse


cada
vez
que
el
adaptador
se
moviera
(
o
se
encendiera
)
.
Otra
opci√≥n
ser√≠a
no
utilizar
ninguna


direcci√≥n
en
los
adaptadores
y
que
cada
adaptador
pasara
los
datos
(
normalmente
,
un
datagrama


IP
)
de
cada
trama
recibida
hacia
arriba
por
la
pila
de
protocolos
.
La
capa
de
red
podr√≠a
entonces


comprobar
si
existe
una
coincidencia
con
la
direcci√≥n
de
la
capa
de
red
.
Un
problema
que
surge


con
esta
opci√≥n
es
que
el
host
ser√≠a
interrumpido
por
cada
trama
enviada
a
trav√©s
de
la
LAN
,


incluyendo
aquellas
tramas
que
estuvieran
destinadas
a
otros
nodos
de
la
misma
LAN
de
difusi√≥n
.


En
resumen
,
con
el
fin
de
que
las
capas
sean
independientes
en
gran
medida
en
una
arquitectura


de
red
,
las
distintas
capas
necesitan
disponer
de
su
propio
esquema
de
direccionamiento
.
Hasta


ahora
hemos
hablado
de
tres
tipos
de
direcciones
:
nombres
de
host
para
la
capa
de
aplicaci√≥n
,


direcciones
IP
para
la
capa
de
red
y
direcciones
MAC
para
la
capa
de
enlace
.


PR√ÅCTICA


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
446que
ARP
resuelve
direcciones
IP
s√≥lo
para
los
nodos
de
una
misma
subred
.
Si
un
nodo


situado
en
California
intentara
utilizar
ARP
para
resolver
la
direcci√≥n
IP
de
un
nodo
en
Mis-


sissippi
,
ARP
devolver√≠a
un
error
.


Ahora
que
hemos
explicado
lo
que
hace
ARP
,
vamos
a
ver
c√≥mo
lo
hace
.
Cada
nodo


(
host
o
router
)
tiene
en
su
memoria
una
tabla
ARP
,
que
contiene
las
correspondencias
entre


las
direcciones
IP
y
las
direcciones
MAC
.
La
Figura
5.18
muestra
el
aspecto
que
puede
tener


la
tabla
ARP
del
nodo
222.222.222.220
.
La
tabla
ARP
tambi√©n
contiene
un
valor
de
tiempo


de
vida
(
TTL
)
,
que
indica
cu√°ndo
se
eliminar√°
cada
correspondencia
de
la
tabla
.
Observe


que
la
tabla
no
necesariamente
contiene
una
entrada
para
cada
nodo
de
la
subred
;
algunos


nodos
pueden
haber
tenido
entradas
que
han
caducado
,
mientras
que
otros
puede
que
nunca


hayan
tenido
una
entrada
en
la
tabla
.
El
tiempo
t√≠pico
de
caducidad
de
una
entrada
es
de
20


minutos
desde
el
momento
que
se
incluye
la
entrada
en
la
tabla
ARP
.


Suponga
ahora
que
el
nodo
222.222.222.220
quiere
enviar
un
datagrama
con
direccio-


namiento
IP
a
otro
nodo
de
dicha
subred
.
El
nodo
emisor
necesita
obtener
la
direcci√≥n


MAC
del
nodo
de
destino
dada
la
direcci√≥n
IP
de
dicho
nodo
.
Esta
tarea
es
f√°cil
si
la


tabla
ARP
del
nodo
emisor
tiene
una
entrada
para
nodo
de
destino
.
Pero
,
¬ø
qu√©
ocurre
si


la
tabla
ARP
no
contiene
actualmente
una
entrada
para
el
nodo
de
destino
?
En
particu-


lar
,
suponga
que
el
nodo
222.222.222.220
desea
enviar
un
datagrama
al
nodo


222.222.222
.
222
.
En
este
caso
,
el
nodo
emisor
utiliza
el
protocolo
ARP
para
resolver
la


direcci√≥n
.
En
primer
lugar
,
el
nodo
emisor
construye
un
paquete
especial
denominado


paquete
ARP
.
Un
paquete
ARP
contiene
varios
campos
,
incluyendo
las
direcciones
MAC
e


Direcci√≥n
IP
Direcci√≥n
MAC
TTL


222.222.222.221
88-B2-2F-54-1A-0F
13:45:00


222.222.222.223
5C-66-AB-90-75-B1
13:52:00


Figura
5.18
‚Ä¢
Una
posible
tabla
ARP
en
el
nodo
222.222.222.220
.
 

5.4
‚Ä¢
DIRECCIONAMIENTO
DE
LA
CAPA
DE
ENLACE
447


IP:222.222.222.221


IP:222.222.222.220


IP:222.222.222.223


IP:222.222.222.222


5C-66-AB-90-75-B1


1A-23-F9-CD-06-9B


49-BD-D2-C7-56-2A


88-B2-2F-54-1A-0F


Figura
5.17
‚Ä¢
Cada
nodo
de
una
LAN
tiene
una
direcci√≥n
IP
y
cada
adaptador


de
un
nodo
tiene
una
direcci√≥n
MAC
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
447IP
del
emisor
y
el
receptor
.
Los
paquetes
de
consulta
y
de
respuesta
ARP
tienen
el
mismo


formato
.
El
prop√≥sito
del
paquete
de
consulta
ARP
es
consultar
a
todos
los
dem√°s
nodos
de


la
subred
con
el
fin
de
determinar
la
direcci√≥n
MAC
correspondiente
a
la
direcci√≥n
IP
que


est√°
resolviendo
.


Vo
l
v
a
m
o
s
 
a
 
n
u
e
s
t
r
o
 
e
j
e
m
p
l
o
.
 
E
l
 
n
o
d
o
 
2
2
2
.
2
2
2
.
2
2
2
.
2
2
0
 
p
a
s
a
 
u
n
 
p
a
q
u
e
t
e
 
d
e
 
c
o
n
s
u
l
t
a


ARP
al
adaptador
junto
con
una
indicaci√≥n
de
que
el
adaptador
enviar√°
el
paquete
a
la
direc-


ci√≥n
de
difusi√≥n
MAC
,
FF-FF-FF-FF-FF-FF
.
El
adaptador
encapsula
el
paquete
ARP
en
una


trama
de
la
capa
de
enlace
,
utiliza
la
direcci√≥n
de
difusi√≥n
para
la
direcci√≥n
de
destino
de
la


trama
y
la
transmite
a
la
subred
.
Recuerde
la
analog√≠a
del
n√∫mero
de
la
seguridad
social
y
la


direcci√≥n
postal
:
una
consulta
ARP
es
equivalente
a
una
persona
gritando
en
una
sala
aba-


rrotada
de
cub√≠culos
de
alguna
empresa
(
por
ejemplo
,
CualquierEmpresa
):
‚Äú
¬ø
Cu√°l
es
el


n√∫mero
de
la
seguridad
social
de
la
persona
cuya
direcci√≥n
postal
es
Cub√≠culo
13
,
Sala
112
,


CualquierEmpresa
,
Palo
Alto
,
California
?
‚Äù
La
trama
que
contiene
la
consulta
ARP
es
reci-


bida
por
todos
los
dem√°s
adaptadores
existentes
en
la
subred
y
(
a
causa
de
la
direcci√≥n
de


difusi√≥n
)
cada
adaptador
pasa
la
consulta
ARP
contenida
en
la
trama
al
m√≥dulo
ARP
de


dicho
nodo
.
Cada
nodo
realiza
una
comprobaci√≥n
para
ver
si
su
direcci√≥n
IP
se
corresponde


con
la
direcci√≥n
IP
de
destino
del
paquete
ARP
.
El
√∫nico
nodo
en
el
que
se
produzca
la
coin-


cidencia
devolver√°
al
nodo
que
ha
realizado
la
consulta
una
respuesta
ARP
con
la
corres-


pondencia
deseada
.
El
nodo
que
ha
realizado
la
consulta
222.222.222.220
podr√°
entonces


actualizar
su
tabla
ARP
y
enviar
su
datagrama
IP
,
encapsulado
dentro
de
una
trama
de
la


capa
de
enlace
cuya
direcci√≥n
de
destino
MAC
es
la
del
nodo
que
ha
contestado
a
la
anterior


consulta
ARP
.


Hay
un
par
de
cosas
interesantes
que
comentar
acerca
del
protocolo
ARP
.
En
primer


lugar
,
el
mensaje
ARP
de
consulta
se
env√≠a
dentro
de
una
trama
de
difusi√≥n
,
mientras
que
el


mensaje
ARP
de
respuesta
se
env√≠an
dentro
de
una
trama
est√°ndar
.
Antes
de
continuar


leyendo
deber√≠a
pararse
a
pensar
por
qu√©
esto
es
as√≠
.
En
segundo
lugar
,
ARP
es
un
protocolo


plug-and-play
;
es
decir
,
la
tabla
ARP
de
un
nodo
se
construye
autom√°ticamente
(
no
tiene
que


ser
configurada
por
el
administrador
del
sistema
)
.
Y
si
un
nodo
est√°
desconectado
de
la


subred
,
su
entrada
finalmente
se
elimina
de
las
tablas
de
los
restantes
nodos
de
la
subred
.


Am
e
n
u
d
o
,
 
l
o
s
 
e
s
t
u
d
i
a
n
t
e
s
 
s
e
 
p
r
e
g
u
n
t
a
n
 
s
i
 
A
R
Pe
s
 
u
n
 
p
r
o
t
o
c
o
l
o
 
d
e
 
l
a
 
c
a
p
a
 
d
e
 
e
n
l
a
c
e
 
o
 
u
n


protocolo
de
la
capa
de
red
.
Como
hemos
visto
,
un
paquete
ARP
se
encapsula
dentro
de
una


trama
de
la
capa
de
enlace
y
as√≠
se
sit√∫a
,
arquitect√≥nicamente
,
encima
de
la
capa
de
enlace
.


Sin
embargo
,
un
paquete
ARP
dispone
de
campos
que
contienen
direcciones
de
la
capa
de


enlace
,
por
lo
que
se
podr√≠a
decir
que
es
un
protocolo
de
la
capa
de
enlace
,
pero
tambi√©n
con-


tiene
direcciones
de
la
capa
de
red
y
,
por
tanto
,
podr√≠a
tambi√©n
argumentarse
que
es
un
proto-


colo
de
la
capa
de
red
.
En
√∫ltimo
t√©rmino
,
probablemente
ARP
sea
considerado
un
protocolo


que
se
encuentra
a
caballo
entre
las
capas
de
enlace
y
de
red
(
no
se
ajusta
limpiamente
a
la


pila
de
protocolos
en
capas
simples
que
hemos
estudiado
en
el
Cap√≠tulo
1
)
.
¬°
Tales
son
las


complejidades
de
los
protocolos
del
mundo
real
!


Env√≠o
de
un
datagrama
a
un
nodo
fuera
de
la
subred


Ahora
deber√≠a
tener
claro
c√≥mo
funciona
ARP
cuando
un
nodo
desea
enviar
un
datagrama
a


otro
nodo
que
se
encuentra
en
la
misma
subred
.
Pasemos
entonces
a
un
situaci√≥n
algo
m√°s


complicada
en
la
que
un
nodo
de
una
subred
desea
enviar
un
datagrama
de
la
capa
de
red
a


un
nodo
que
est√°
fuera
de
la
subred
(
es
decir
,
a
trav√©s
de
un
router
a
otra
subred
)
.
Estudie-


mos
esta
situaci√≥n
en
el
contexto
de
la
Figura
5.19
,
que
muestra
una
red
simple
que
consta


de
dos
subredes
interconectadas
mediante
un
router
.


448
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4485.4
‚Ä¢
DIRECCIONAMIENTO
DE
LA
CAPA
DE
ENLACE
449


Hay
varias
cuestiones
interesantes
que
destacar
en
la
Figura
5.19
.
En
primer
lugar
,
exis-


ten
dos
tipos
de
nodos
:
hosts
y
routers
.
Cada
host
tiene
exactamente
una
direcci√≥n
IP
y
un


adaptador
.
Pero
,
como
se
ha
visto
en
el
Cap√≠tulo
4
,
un
router
tiene
una
direcci√≥n
IP
para


cada
una
de
sus
interfaces
.
Para
cada
interfaz
de
router
existe
tambi√©n
un
m√≥dulo
ARP
(
en


el
router
)
y
un
adaptador
.
Dado
que
el
router
de
la
Figura
5.19
tiene
dos
interfaces
,
tendr√°


dos
direcciones
IP
,
dos
m√≥dulos
ARP
y
dos
adaptadores
.
Por
supuesto
,
cada
adaptador
de
la


red
tiene
su
propia
direcci√≥n
MAC
.


F√≠jese
tambi√©n
en
que
la
Subred
1
tiene
la
direcci√≥n
de
red
111.111.111/24
y
que
la


Subred
2
tiene
la
direcci√≥n
de
red
222.222.222/24
.
As√≠
,
todas
las
interfaces
conectadas


a
la
Subred
1
tienen
direcciones
de
la
forma
111.111.111.xxx
y
todas
las
interfaces
conecta-


das
a
la
Subred
2
tienen
direcciones
de
la
forma
222.222.222.xxx
.


Examinemos
ahora
c√≥mo
un
host
de
la
Subred
1
enviar√≠a
un
datagrama
a
un
host
de
la


Subred
2
.
Espec√≠ficamente
,
suponga
que
el
host
111.111.111.111
desea
enviar
un
datagrama
IP


a
un
host
222.222.222.222
.
Como
es
habitual
,
el
host
emisor
pasa
el
datagrama
a
su
adap-


tador
.
Pero
el
host
emisor
tambi√©n
tiene
que
indicar
a
su
adaptador
una
direcci√≥n
MAC


de
destino
apropiada
.
¬ø
Qu√©
direcci√≥n
MAC
deber√≠a
utilizar
el
adaptador
?
Una
posibilidad


ser√≠a
probar
si
la
direcci√≥n
MAC
apropiada
es
la
del
adaptador
para
el
host
 
222.222.222
.


222
,
es
decir
,
49-BD-D2-C7-56-2A.
Sin
embargo
,
esta
suposici√≥n
resultar√≠a
err√≥nea
.
Si
el


adaptador
del
emisor
utilizara
dicha
direcci√≥n
MAC
,
entonces
ninguno
de
los
adaptadores


de
la
Subred
1
se
molestar√≠a
en
pasar
el
datagrama
IP
a
su
capa
de
red
,
ya
que
la
direcci√≥n


de
destino
de
la
trama
no
coincidir√≠a
con
al
direcci√≥n
MAC
de
ning√∫n
adaptador
de
la


Subred
1
.
El
datagrama
terminar√≠a
muriendo
e
ir√≠a
al
cielo
de
los
datagramas
.


Si
nos
fijamos
en
la
Figura
5.19
vemos
que
para
que
un
datagrama
vaya
desde


111.111.111.111
a
un
nodo
de
la
Subred
2
,
el
datagrama
tiene
en
primer
lugar
que
ser


enviado
a
la
interfaz
de
router
111.111.111.110
,
que
es
la
direcci√≥n
IP
del
router
del
primer


salto
en
el
camino
hacia
su
destino
final
.
Por
tanto
,
la
direcci√≥n
MAC
apropiada
para
la


trama
es
la
direcci√≥n
del
adaptador
de
la
interfaz
de
router
111.111.111.110
,
es
decir
,
E6-


E9-00-17-BB-4B.
¬ø
C√≥mo
adquiere
el
host
de
emisor
la
direcci√≥n
MAC
para
la
direcci√≥n


111.111.111.110
?
¬°
Por
supuesto
,
utilizando
ARP
!
Una
vez
que
el
adaptador
del
emisor
tiene


esta
direcci√≥n
MAC
,
crea
una
trama
(
que
contiene
el
datagrama
direccionado
a


222.222.22.22
)
y
env√≠a
la
trama
hacia
la
Subred
1
.
El
adaptador
del
router
de
la
Subred
1
ve


que
la
trama
de
la
capa
de
enlace
se
dirige
hacia
√©l
y
,
por
tanto
,
pasa
la
trama
a
la
capa
de


red
del
router
.
¬°
Estupendo
!
El
diagrama
IP
se
ha
transmitido
con
√©xito
desde
el
host
de
ori-


gen
al
router
.
Pero
todav√≠a
no
hemos
terminado
.
Todav√≠a
nos
queda
llevar
el
datagrama


desde
el
router
al
destino
.
Ahora
el
router
tiene
que
determinar
la
interfaz
correcta
a
la
que


IP:111.111.111.110IP:111.111.111.111


IP:111.111.111.112


IP:222.222.222.221


IP:222.222.222.222


74-29-9C-E8-FF-55


CC-49-DE-D0-AB-7D


E6-E9-00-17-BB-4B


1A-23-F9-CD-06-9B


IP:222.222.222.220


88-B2-2F-54-1A-0F


49-BD-D2-C7-56-2A


Figura
5.19
‚Ä¢
Dos
subredes
interconectadas
mediante
un
router
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
449el
datagrama
ser√°
reenviado
.
Como
se
ha
explicado
en
el
Cap√≠tulo
4
,
esto
se
hace
consul-


tando
la
tabla
de
reenv√≠o
del
router
.
La
tabla
de
reenv√≠o
indica
al
router
que
el
datagrama
es


reenv√≠ado
a
trav√©s
de
la
interfaz
de
router
222.222.222.220
.
Esta
interfaz
entonces
pasa
el


datagrama
a
su
adaptador
,
que
encapsula
el
datagrama
en
una
nueva
trama
y
la
env√≠a
a
la


subred
2
.
Esta
vez
,
la
direcci√≥n
MAC
de
destino
de
la
trama
es
la
direcci√≥n
MAC
del
des-


tino
final
.
Pero
,
¬ø
c√≥mo
obtiene
el
router
esta
direcci√≥n
MAC
de
destino
?
¬°
Por
supuesto
,
de


ARP
!


ARP
para
Ethernet
est√°
definido
en
el
documento
RFC
826
.
En
el
tutorial
de
TCP
/
IP
,


RFC
1180
,
se
proporciona
una
introducci√≥n
a
ARP
.
Exploraremos
en
m√°s
detalle
ARP
en
los


problemas
de
repaso
.


5.5
Ethernet


Ethernet
ha
avanzado
mucho
en
el
mercado
de
las
redes
LAN
cableadas
.
En
la
d√©cada
de


1980
y
a
principios
de
la
d√©cada
de
1990
,
Ethernet
se
enfrent√≥
a
muchos
de
los
desaf√≠os
de


otras
tecnolog√≠as
LAN
,
como
Token
Ring
,
FDDI
y
ATM
.
Algunas
de
estas
otras
tecnolog√≠as


tuvieron
√©xito
y
captaron
parte
del
mercado
de
las
redes
LAN
durante
unos
pocos
a√±os
.


Pero
,
desde
su
aparici√≥n
a
mediados
de
la
d√©cada
de
1970
,
Ethernet
ha
continuado
evolucio-


nando
y
creciendo
,
y
se
ha
mantenido
en
una
posici√≥n
dominante
.
Actualmente
,
Ethernet
es


de
lejos
la
tecnolog√≠a
para
redes
LAN
cableadas
predominante
y
,
probablemente
,
se
manten-


dr√°
ah√≠
en
el
futuro
.
Puede
decirse
que
Ethernet
ha
sido
a
las
redes
de
√°rea
local
lo
que
Inter-


net
a
las
redes
globales
.


Existen
muchas
razones
por
las
que
Ethernet
ha
tenido
√©xito
.
En
primer
lugar
,
Ethernet


fue
la
primera
LAN
de
alta
velocidad
ampliamente
implantada
.
Puesto
que
fue
implantada


muy
pronto
,
los
administradores
de
redes
est√°n
extremadamente
familiarizados
con
Ethernet


(
conocen
sus
grandezas
y
sus
rarezas
)
y
fueron
reacios
a
cambiar
a
otras
tecnolog√≠as
LAN


cuando
entraron
en
escena
.
En
segundo
lugar
,
Token
Ring
,
FDDI
y
ATM
eran
m√°s
comple-


jas
y
caras
que
Ethernet
,
lo
que
desanim√≥
a
los
administradores
de
redes
a
cambiar
.
En
ter-


cer
lugar
,
la
raz√≥n
m√°s
determinante
para
cambiar
a
otra
tecnolog√≠a
LAN
(
como
FDDI
o


ATM
)
era
normalmente
la
m√°s
alta
velocidad
de
datos
de
la
nueva
tecnolog√≠a
;
sin
embargo
,


Ethernet
siempre
se
defendi√≥
produciendo
versiones
que
operaban
a
velocidades
iguales
o


incluso
mayores
.
Ethernet
conmutada
se
introdujo
tambi√©n
a
principios
de
la
d√©cada
de


1990
,
lo
que
aument√≥
sus
tasas
de
datos
efectivas
.
Por
√∫ltimo
,
dado
que
Ethernet
ha
sido
tan


popular
,
el
hardware
Ethernet
(
en
concreto
,
los
adaptadores
y
los
conmutadores
)
ha
llegado


a
ser
c√≥modo
y
notablemente
barato
.


La
LAN
Ethernet
original
fue
inventada
a
mediados
de
la
d√©cada
de
1970
por
Bob
Met-


calfe
y
David
Boggs
.
La
Figura
5.20
muestra
el
esquema
que
realiz√≥
Metcalfe
.
En
la
figura


puede
observar
que
la
LAN
Ethernet
original
utilizaba
un
bus
coaxial
para
interconectar
los


nodos
.
Las
topolog√≠as
de
bus
para
Ethernet
realmente
se
mantuvieron
durante
la
d√©cada
de


1980
y
hasta
mediados
de
la
d√©cada
de
1990
.
Ethernet
con
una
topolog√≠a
de
bus
es
una
LAN


de
difusi√≥n
(
todas
las
tramas
transmitidas
viajan
hasta
todos
los
adaptadores
conectados
al


bus
y
son
procesadas
en
ellos
)
.


Af
i
n
a
l
e
s
 
d
e
 
l
a
 
d
√©
c
a
d
a
 
d
e
 
1
9
9
0
,
 
l
a
 
m
a
y
o
r
 
p
a
r
t
e
 
d
e
 
l
a
s
 
e
m
p
r
e
s
a
s
 
y
 
u
n
i
v
e
r
s
i
d
a
d
e
s
 
h
a
b
√≠
a
n


reemplazado
sus
redes
LAN
por
instalaciones
Ethernet
utilizando
topolog√≠as
en
estrella


basadas
en
concentradores
(
hubs
)
.
Como
se
muestra
en
la
Figura
5.21
,
en
tal
instalaci√≥n
los


hosts
(
y
los
routers
)
est√°n
directamente
conectados
a
un
concentrador
mediante
un
cable
de


450
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
450cobre
de
par
trenzado
.
Un
concentrador
es
un
dispositivo
de
la
capa
f√≠sica
que
act√∫a
sobre


los
bits
individuales
en
lugar
de
sobre
las
tramas
.
Cuando
un
bit
,
que
representa
un
cero
o


un
uno
,
llega
procedente
de
una
interfaz
,
el
concentrador
simplemente
vuelve
a
crear
el
bit
,


incrementa
su
intensidad
de
energ√≠a
y
lo
transmite
a
todas
las
dem√°s
interfaces
.
Por
tanto
,


Ethernet
con
una
topolog√≠a
de
estrella
basada
en
concentrador
es
tambi√©n
una
red
LAN
de


difusi√≥n
(
cuando
un
concentrador
recibe
un
bit
en
una
de
sus
interfaces
,
env√≠a
una
copia
al


resto
de
sus
interfaces
)
.
En
particular
,
si
un
concentrador
recibe
tramas
procedentes
de
dos


interfaces
distintas
al
mismo
tiempo
,
se
produce
una
colisi√≥n
y
los
nodos
que
crean
las
tra-


mas
tendr√°n
que
retransmitirlas
.


Ap
r
i
n
c
i
p
i
o
s
 
d
e
 
l
a
 
d
√©
c
a
d
a
 
d
e
 
2
0
0
0
 
E
t
h
e
r
n
e
t
 
e
x
p
e
r
i
m
e
n
t
√≥
 
u
n
a
 
c
a
m
b
i
o
 
e
v
o
l
u
t
i
v
o
 
a
√∫
n


mayor
.
Las
instalaciones
Ethernet
continuaron
utilizando
una
topolog√≠a
en
estrella
,
pero
el


concentrador
central
fue
reemplazado
por
un
conmutador
(
switch
)
.
Examinaremos
en
pro-


5.5
‚Ä¢
ETHERNET
451


Figura
5.20
‚Ä¢
El
dise√±o
original
de
Metcalfe
llev√≥
al
est√°ndar
Ethernet


10BASE5
,
que
inclu√≠a
un
cable
de
interfaz
que
conectaba


la
tarjeta
adaptadora
Ethernet
a
un
transductor
externo
.
 

Dos
pares


de
cable
de


cobre
de
par


trenzado
Clave
:


Concentrador
o
hub


Adaptador


Nodo


Figura
5.21
‚Ä¢
Topolog√≠a
en
estrella
para
Ethernet
:
los
nodos
est√°n
interconecta-


dos
mediante
un
concentrador
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
451fundidad
las
redes
Ethernet
conmutadas
m√°s
adelante
en
este
cap√≠tulo
.
Por
el
momento
,
s√≥lo


mencionaremos
que
un
conmutador
no
es
s√≥lo
un
dispositivo
sin
colisiones
,
sino
que
tam-


bi√©n
lleva
a
cabo
la
conmutaci√≥n
de
paquetes
mediante
un
almacenamiento
y
reenv√≠o
de


buena
fe
;
pero
,
a
diferencia
de
los
routers
,
que
operan
hasta
la
capa
3
,
un
conmutador
opera


s√≥lo
hasta
la
capa
2
.
 

5.5.1
Estructura
de
la
trama
de
Ethernet


Podemos
aprender
mucho
acerca
de
Ethernet
examinando
la
trama
que
utiliza
,
la
cual
se


muestra
en
la
Figura
5.22
.
Con
el
fin
de
proporcionar
a
esta
exposici√≥n
acerca
de
las
tramas


de
Ethernet
un
contexto
tangible
,
consideremos
el
env√≠o
de
un
datagrama
IP
desde
un
host
a


otro
host
,
estando
ambos
hosts
en
la
misma
red
LAN
Ethernet
(
por
ejemplo
,
en
la
LAN


Ethernet
de
la
Figura
5.21
)
.
(
Aunque
la
carga
√∫til
de
nuestra
trama
Ethernet
es
un
datagrama


IP
,
tenga
en
cuenta
que
una
trama
Ethernet
puede
transportar
tambi√©n
otros
paquetes
de
la


capa
de
red
.
)
El
adaptador
del
emisor
,
adaptador
A
,
tiene
la
direcci√≥n
MAC
AA-AA-AA-


AA-AA-AA
y
el
adaptador
del
receptor
,
adaptador
B
,
tiene
la
direcci√≥n
MAC
BB-BB-BB-


BB-BB-BB
.
El
adaptador
del
emisor
encapsula
el
datagrama
IP
dentro
de
una
trama


Ethernet
y
pasa
dicha
trama
a
la
capa
f√≠sica
.
El
adaptador
del
receptor
recibe
la
trama
de
la


capa
f√≠sica
,
extrae
el
datagrama
IP
y
lo
pasa
a
la
capa
de
red
.
En
este
contexto
,
examinemos


los
seis
campos
de
la
trama
 
Ethernet
mostrada
en
la
Figura
5.22
.


‚Ä¢
Campo
de
datos
(
46
a
1.500
bytes
)
.
Este
campo
transporta
el
datagrama
IP
.
La
unidad


m√°xima
de
transmisi√≥n
(
MTU
)
de
Ethernet
es
1.500
bytes
,
lo
que
quiere
decir
que
si
el


datagrama
IP
excede
de
1.500
bytes
,
entonces
el
host
tiene
que
fragmentar
el
datagrama
,


como
se
ha
explicado
en
la
Secci√≥n
4.4.1
.
El
tama√±o
m√≠nimo
del
campo
de
datos
es
46


bytes
,
lo
que
significa
que
si
el
datagrama
IP
tiene
menos
de
46
bytes
,
el
campo
de
datos


tiene
ser
rellenado
hasta
los
46
bytes
.
Cuando
se
utiliza
el
rellenado
,
los
datos
pasados
a


la
capa
de
red
contienen
tanto
el
relleno
como
el
datagrama
IP
.
La
capa
de
red
utiliza
el


campo
longitud
de
la
cabecera
del
datagrama
IP
para
eliminar
el
relleno
.


‚Ä¢
Direcci√≥n
de
destino
(
6
bytes
)
.
Este
campo
contiene
la
direcci√≥n
MAC
del
adaptador
de


destino
,
BB-BB-BB-BB-BB-BB
.
Cuando
el
adaptador
B
recibe
una
trama
Ethernet
cuya


direcci√≥n
de
destino
es
BB-BB-BB-BB-BB-BB
o
la
direcci√≥n
MAC
de
difusi√≥n
,
pasa
el


contenido
del
campo
de
datos
de
la
trama
a
la
capa
de
red
;
si
recibe
una
trama
con
cual-


quier
otra
direcci√≥n
MAC
,
descarta
la
trama
.


‚Ä¢
Direcci√≥n
de
origen
(
6
bytes
)
.
Este
campo
contiene
la
direcci√≥n
MAC
del
adaptador
que


transmite
la
trama
hacia
la
LAN
;
en
este
ejemplo
,
AA-AA-AA-AA-AA-AA
.


‚Ä¢
Campo
de
tipo
(
2
bytes
)
.
El
campo
de
tipo
permite
a
Ethernet
multiplexar
los
protocolos


de
la
capa
de
red
.
Para
comprender
esto
,
tenemos
que
tener
en
cuenta
que
los
hosts
pue-


den
utilizar
otros
protocolos
de
la
capa
de
red
adem√°s
de
IP
.
De
hecho
,
un
determinado


host
puede
dar
soporte
a
m√∫ltiples
protocolos
de
la
capa
de
red
utilizando
protocolos
dis-


tintos
para
las
diferentes
aplicaciones
.
Por
esta
raz√≥n
,
cuando
llega
la
trama
Ethernet
al


adaptador
B
,
√©ste
necesita
saber
a
qu√©
protocolo
de
la
capa
de
red
debe
pasar
(
es
decir
,


demultiplexar
)
el
contenido
del
campo
de
datos
.
IP
y
otros
protocolos
de
la
capa
red
(
por


ejemplo
,
Novell
IPX
o
AppleTalk
)
tienen
su
propio
n√∫mero
de
tipo
estandarizado
.
Ade-


m√°s
,
el
protocolo
ARP
(
estudiado
en
la
secci√≥n
anterior
)
tiene
su
propio
n√∫mero
de
tipo


y
si
la
trama
que
llega
contiene
un
paquete
ARP
(
es
decir
,
el
campo
de
tipo
contiene
el


hexadecimal
0806
)
,
el
paquete
ARP
ser√°
demultiplexado
y
entregado
al
protocolo
ARP
.


452
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
452Observe
que
el
campo
de
tipo
es
an√°logo
al
campo
de
protocolo
del
datagrama
de
la
capa


de
red
y
a
los
campos
de
n√∫mero
de
puerto
del
segmento
de
la
capa
de
transporte
;
todos


estos
campos
sirven
para
enlazar
un
protocolo
de
una
capa
con
un
protocolo
de
la
capa


superior
.


‚Ä¢
Comprobaci√≥n
de
redundancia
c√≠clica
(
CRC
)
(
4
bytes
)
.
Como
se
ha
visto
en
la
Secci√≥n


5.2.3
,
el
prop√≥sito
del
campo
CRC
es
permitir
que
el
adaptador
del
receptor
,
el
adaptador


B
,
detecte
los
errores
de
bit
de
la
trama
.


‚Ä¢
Pre√°mbulo
(
8
bytes
)
.
La
trama
Ethernet
comienza
con
el
campo
pre√°mbulo
de
8
bytes
.


Cada
uno
de
los
siete
primeros
bytes
tiene
el
valor
10101010
y
el
√∫ltimo
byte
tiene
el


valor
10101011
.
Los
siete
primeros
bytes
sirven
para
‚Äú
despertar
‚Äù
a
los
adaptadores
de


recepci√≥n
y
sincronizar
sus
relojes
con
el
reloj
del
emisor
.
¬ø
Por
qu√©
podr√≠an
estar
desin-


cronizados
los
relojes
?
Tenga
en
cuenta
que
el
objetivo
del
adaptador
A
es
transmitir
la


trama
a
10
Mbps
,
100
Mbps
o
1
Gbps
,
dependiendo
del
tipo
de
LAN
Ethernet
.
Sin


embargo
,
dado
que
nada
es
absolutamente
perfecto
,
el
adaptador
A
no
transmitir√°
la


trama
a
una
velocidad
exactamente
igual
a
la
objetivo
;
siempre
existe
cierta
deriva
res-


pecto
de
dicha
velocidad
,
una
deriva
que
no
es
conocida
a
priori
por
los
restantes
adap-


tadores
de
la
LAN
.
Un
adaptador
de
recepci√≥n
puede
sincronizarse
con
el
reloj
del


adaptador
A
sincroniz√°ndose
simplemente
con
los
bits
de
los
siete
primeros
bytes
del
pre-


√°mbulo
.
Los
√∫ltimos
2
bits
del
octavo
byte
del
pre√°mbulo
(
los
dos
primeros
1s
consecu-


tivos
)
alertan
al
adaptador
B
de
que
va
a
llegar
‚Äú
informaci√≥n
importante
‚Äù
.


Ethernet
utiliza
la
transmisi√≥n
en
banda
base
;
es
decir
,
el
adaptador
env√≠a
una
se√±al
digital


directamente
al
canal
de
difusi√≥n
.
La
tarjeta
de
interfaz
no
desplaza
la
se√±al
a
otra
banda
de


frecuencias
,
como
ocurre
con
el
sistema
ADSL
y
los
sistemas
de
m√≥dem
por
cable
.
Muchas


tecnolog√≠as
Ethernet
(
como
por
ejemplo
,
10BASE-T
)
tambi√©n
utilizan
la
codificaci√≥n
Man-


chester
,
como
se
muestra
en
la
Figura
5.23
.
Con
la
codificaci√≥n
Manchester
,
cada
bit
con-


tiene
una
transici√≥n
;
un
1
indica
una
transici√≥n
del
nivel
alto
al
nivel
bajo
,
mientras
que
un
0


indica
una
transici√≥n
del
nivel
bajo
al
nivel
alto
.
La
raz√≥n
de
utilizar
la
codificaci√≥n
Man-


chester
es
que
los
relojes
de
los
adaptadores
del
emisor
y
del
receptor
no
est√°n
perfecta-


mente
sincronizados
.
Al
incluir
una
transici√≥n
a
mitad
de
cada
bit
,
el
host
receptor
puede


sincronizar
su
reloj
con
el
del
host
emisor
.
Una
vez
que
el
reloj
del
adaptador
del
receptor


est√°
sincronizado
,
el
receptor
puede
delinear
cada
bit
y
determinar
si
se
trata
de
un
1
o
de
un


0
.
La
codificaci√≥n
Manchester
es
una
operaci√≥n
de
la
capa
f√≠sica
m√°s
que
de
la
capa
de


enlace
;
no
obstante
,
es
necesario
que
expliquemos
aqu√≠
brevemente
porque
se
utiliza


exhaustivamente
en
Ethernet
.


Servicio
sin
conexi√≥n
no
fiable


Todas
las
tecnolog√≠as
Ethernet
proporcionan
un
servicio
sin
conexi√≥n
a
la
capa
de
red
;
es


decir
,
cuando
el
adaptador
A
desea
enviar
un
datagrama
al
adaptador
B
,
el
adaptador
A
encap-


sula
el
datagrama
en
una
trama
Ethernet
y
la
env√≠a
a
la
red
LAN
,
sin
establecer
previamente


5.5
‚Ä¢
ETHERNET
453


Pre√°mbulo
CRCDirecci√≥n


de
destino


Direcci√≥n


de
origen


Tipo


Datos


Figura
5.22
‚Ä¢
Estructura
de
la
trama
Ethernet
.
 

M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
453un
acuerdo
con
el
adaptador
B.
Este
servicio
sin
conexi√≥n
de
la
capa
2
es
an√°logo
al
servicio


de
datagramas
de
la
capa
3
de
IP
y
al
servicio
sin
conexi√≥n
de
la
capa
4
de
UDP
.


Las
tecnolog√≠as
Ethernet
proporcionan
un
servicio
no
fiable
a
la
capa
de
red
.
Espec√≠fi-


camente
,
cuando
el
adaptador
B
recibe
una
trama
procedente
del
adaptador
A
ejecuta
una


comprobaci√≥n
CRC
de
la
trama
,
pero
ni
env√≠a
un
mensaje
de
reconocimiento
cuando
la


trama
pasa
la
comprobaci√≥n
CRC
,
ni
env√≠a
un
mensaje
de
reconocimiento
negativo
cuando


la
comprobaci√≥n
CRC
falla
.
Cuando
una
trama
no
pasa
la
comprobaci√≥n
CRC
,
el
adaptador


B
simplemente
la
descarta
.
Por
tanto
,
el
adaptador
A
no
sabe
si
la
trama
que
ha
transmitido


ha
llegado
al
adaptador
B
y
ha
superado
la
comprobaci√≥n
CRC
.
Esta
ausencia
de
un
trans-


porte
fiable
(
en
la
capa
de
enlace
)
hace
que
Ethernet
sea
una
tecnolog√≠a
simple
y
barata
.
Pero


tambi√©n
significa
que
el
flujo
de
datagramas
pasado
a
la
capa
de
red
puede
presentar
‚Äú
hue-


cos
‚Äù
.


Si
existen
huecos
porque
se
han
descartado
tramas
Ethernet
,
¬ø
la
aplicaci√≥n
del
host
B


ve
tambi√©n
esos
huecos
?
Como
hemos
visto
en
el
Cap√≠tulo
3
,
esto
depender√°
de
si
la
aplica-


ci√≥n
est√°
utilizando
UDP
o
TCP
.
Si
la
aplicaci√≥n
est√°
empleando
UDP
,
entonces
la
apli-


caci√≥n
del
host
B
ver√°
los
huecos
en
los
datos
.
Por
el
contrario
,
si
la
aplicaci√≥n
est√°


utilizando
TCP
,
entonces
TCP
en
el
host
B
no
confirmar√°
los
datos
contenidos
en
las
tramas


descartadas
,
obligando
a
TCP
en
el
host
A
a
realizar
retransmisiones
.
Observe
que
cuando


TCP
retransmite
los
datos
,
√©stos
finalmente
volver√°n
al
adaptador
Ethernet
en
el
que
fueron


descartados
.
Por
tanto
,
en
este
sentido
,
Ethernet
retransmite
los
datos
,
aunque
no
es
cons-


ciente
de
si
est√°
transmitiendo
un
nuevo
datagrama
con
nuevos
datos
,
o
un
datagrama
que


contiene
datos
que
ya
han
sido
transmitidos
al
menos
una
vez
.


5.5.2
CSMA
/
CD
:
protocolo
de
acceso
m√∫ltiple
de
Ethernet


Cuando
los
nodos
est√°n
interconectados
mediante
un
concentrador
(
en
oposici√≥n
a
un
con-


mutador
de
la
capa
de
enlace
)
,
como
se
muestra
en
la
Figura
5.21
,
la
LAN
Ethernet
es
una


aut√©ntica
LAN
de
difusi√≥n
;
es
decir
,
cuando
un
adaptador
transmite
una
trama
,
todos
los


adaptadores
de
la
LAN
reciben
esa
trama
.
Dado
que
Ethernet
puede
emplear
la
comunica-


ci√≥n
por
difusi√≥n
,
necesita
un
protocolo
de
acceso
m√∫ltiple
.
Ethernet
utiliza
el
famoso
pro-


tocolo
de
acceso
m√∫ltiple
CSMA
/
CD
.
Recuerde
que
,
como
hemos
visto
en
la
Secci√≥n
5.3
,


CSMA
/
CD
hace
lo
siguiente
:


454
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


Flujo
de
bits


Codificaci√≥n


Manchester


Codificaci√≥n


en
binario


Tiempo


10001001111


Figura
5.23
‚Ä¢
Codificaci√≥n
Manchester
.
 

M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4545.5
‚Ä¢
ETHERNET
455


1
.
Un
adaptador
puede
comenzar
a
transmitir
en
cualquier
instante
;
es
decir
,
no
existe
el


concepto
de
partici√≥n
de
tiempo
.


2
.
Un
adaptador
nunca
transmite
una
trama
cuando
detecta
que
alg√∫n
otro
adaptador
est√°


transmitiendo
;
es
decir
,
utiliza
un
mecanismo
de
sondeo
de
portadora
.


3
.
Un
adaptador
que
est√°
transmitiendo
aborta
su
transmisi√≥n
tan
pronto
como
detecta
que


otro
adaptador
tambi√©n
est√°
transmitiendo
;
es
decir
,
utiliza
un
mecanismo
de
detecci√≥n


de
colisiones
.


4
.
Antes
de
intentar
llevar
a
cabo
una
retransmisi√≥n
,
un
adaptador
espera
un
intervalo
de


tiempo
aleatorio
que
normalmente
es
m√°s
peque√±o
que
el
tiempo
que
se
tarda
en
trans-


mitir
una
trama
.
 

Estos
mecanismos
proporcionan
a
CSMA
/
CD
un
rendimiento
mucho
mejor
que
el
del
pro-


tocolo
ALOHA
con
particiones
en
un
entorno
LAN
.
De
hecho
,
si
el
retardo
m√°ximo
de
pro-


pagaci√≥n
entre
estaciones
es
muy
peque√±o
,
la
eficiencia
de
CSMA
/
CD
puede
aproximarse


al
100
por
ciento
.
Observe
tambi√©n
que
el
segundo
y
tercer
mecanismos
de
la
lista
anterior


requieren
que
los
adaptadores
de
Ethernet
sean
capaces
de
(
1
)
detectar
cu√°ndo
alg√∫n
otro


adaptador
est√°
transmitiendo
y
(
2
)
detectar
una
colisi√≥n
mientras
est√°n
transmitiendo
.
Los


adaptadores
Ethernet
realizan
estas
dos
tareas
midiendo
los
niveles
de
tensi√≥n
antes
y


durante
las
transmisiones
.


BOB
METCALFE
Y
ETHERNET


Como
estudiante
de
doctorado
en
la
Universidad
de
Harvard
a
principios
de
la
d√©cada
de


1970
,
Bob
Metcalfe
trabajaba
en
la
red
ARPAnet
en
el
MIT
.
Durante
sus
estudios
,
tambi√©n


conoci√≥
el
trabajo
de
Abramson
con
ALOHA
y
los
protocolos
de
acceso
aleatorio
.
Despu√©s


de
terminar
su
doctorado
y
justo
antes
de
comenzar
a
trabajar
en
el
Centro
de
investigaci√≥n


de
Xerox
Palo
Alto
(
Xerox
PARC
)
,
estuvo
durante
tres
meses
con
Abramson
y
sus
colegas
de


la
universidad
de
Hawaii
y
pudo
obtener
informaci√≥n
de
primera
mano
sobre
ALOHAnet
.


En
Xerox
PARC
,
Metcalfe
tambi√©n
conoci√≥
las
computadoras
Alto
,
que
en
muchos
sentidos


fueron
las
precursoras
de
las
computadoras
personales
de
la
d√©cada
de
1980
.
Metcalfe
vi√≥


la
necesidad
de
conectar
en
red
estas
computadoras
mediante
alg√∫n
sistema
econ√≥mico
.


As√≠
,
armado
con
sus
conocimientos
sobre
ARPAnet
,
ALOHAnet
y
los
protocolos
de
acceso


aleatorio
,
Metcalfe
(
junto
con
su
colega
David
Boggs
)
invent√≥
Ethernet
.


La
Ethernet
original
de
Metcalfe
y
Boggs
operaba
a
2,94
Mbps
y
pod√≠a
conectar
hasta


256
hosts
separados
hasta
aproximadamente
un
kil√≥metro
y
medio
.
Metcalfe
y
Boggs
tuvie-


ron
√©xito
al
conseguir
que
la
mayor√≠a
de
los
investigadores
de
Xerox
PARC
pudieran
comuni-


carse
a
trav√©s
de
sus
computadoras
Alto
.
Metcalfe
forj√≥
despu√©s
una
alianza
entre
Xerox
,


Digital
e
Intel
para
establecer
Ethernet
a
10
Mbps
como
est√°ndar
del
IEEE
.
Xerox
no
mostr√≥


demasiado
inter√©s
en
la
comercializaci√≥n
de
Ethernet
.
En
1979
,
Metcalfe
mont√≥
su
propia


empresa
,
3Com
,
que
desarroll√≥
y
comercializ√≥
tecnolog√≠a
de
redes
,
incluyendo
la
tecnolog√≠a


Ethernet
.
En
concreto
,
3Com
desarroll√≥
y
puso
en
el
mercado
tarjetas
Ethernet
a
principios
de


la
d√©cada
de
1980
para
las
tremedamente
populares
computadoras
personales
de
IBM
.
Met-


calfe
abandon√≥
3Com
en
1990
,
cuando
ten√≠a
2.000
empleados
y
 
unos
ingresos
de
400


millones
de
d√≥lares
.


HISTORIA


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
455Los
adaptadores
ejecutan
el
protocolo
CSMA
/
CD
sin
coordinaci√≥n
expl√≠cita
con
los


dem√°s
adaptadores
existentes
en
la
red
Ethernet
.
Dentro
de
un
adaptador
espec√≠fico
,
el
pro-


tocolo
CSMA
/
CD
opera
de
la
siguiente
forma
:


1
.
El
adaptador
obtiene
un
datagrama
de
la
capa
de
red
,
prepara
una
trama
Ethernet
y
la


coloca
en
un
buffer
del
adaptador
.


2
.
Si
el
adaptador
detecta
que
el
canal
est√°
inactivo
(
es
decir
,
durante
96
periodos
de
bit
el


adaptador
no
recibe
intensidad
de
se√±al
procedente
del
canal
)
,
comienza
a
transmitir
la


trama
.
Si
el
adaptador
detecta
que
el
canal
est√°
ocupado
,
espera
hasta
comprobar
que
no


hay
intensidad
de
se√±al
(
m√°s
otros
96
periodos
de
bit
)
y
luego
comienza
a
transmitir
la


trama
.


3
.
Mientras
est√°
transmitiendo
,
el
adaptador
monitoriza
la
presencia
de
se√±ales
proceden-


tes
de
otros
adaptadores
.
Si
el
adaptador
transmite
la
trama
completa
sin
detectar
nin-


guna
se√±al
procedente
de
otros
adaptadores
,
concluye
que
ha
terminado
su
trabajo
con


esa
trama
.


4
.
Si
el
adaptador
detecta
intensidad
de
se√±al
procedente
de
otros
adaptadores
mientras


est√°
transmitiendo
,
deja
de
transmitir
su
trama
y
transmite
una
se√±al
de
interferencia


(
jam
)
de
48
bits
.


5
.
Despu√©s
de
abortar
la
transmisi√≥n
de
la
trama
(
es
decir
,
de
transmitir
la
se√±al
de
interfe-


rencia
)
,
el
adaptador
entra
en
la
fase
de
espera
exponencial
(
backoff
exponencial
)
.


Espec√≠ficamente
,
a
la
hora
de
transmitir
una
determinada
trama
,
despu√©s
de
experimen-


tar
la
n-√©sima
colisi√≥n
para
esa
trama
,
el
adaptador
selecciona
un
valor
aleatorio
para
K


del
conjunto
{
0,1,2
,
.
.
.
,
2
m
‚Äì
1
}
,
donde
m
=
min(n,10
)
.
El
adaptador
espera
entonces


K
 
512
periodos
de
bit
y
vuelve
al
Paso
2
.


Es
necesario
que
comentemos
algunas
cosas
acerca
del
protocolo
CSMA
/
CD
.
El
prop√≥-


sito
de
la
se√±al
de
interferencia
es
el
de
garantizar
que
todos
los
adaptadores
que
est√°n
trans-


mitiendo
sean
conscientes
de
la
colisi√≥n
.
Veamos
un
ejemplo
.
Suponga
que
el
adaptador
A


comienza
a
transmitir
una
trama
y
justo
antes
de
que
la
se√±al
de
A
llegue
al
adaptador
B
√©ste


empieza
a
transmitir
.
Por
tanto
,
B
s√≥lo
transmitir√°
unos
pocos
bits
antes
de
abortar
su
trans-


misi√≥n
.
Esos
pocos
bits
se
propagar√°n
hasta
A
,
pero
es
posible
que
no
generen
una
intensi-


dad
de
se√±al
suficiente
como
para
que
A
detecte
la
colisi√≥n
.
Para
asegurarse
de
que
A
detecta


la
colisi√≥n
(
de
modo
que
tambi√©n
pueda
abortar
su
transmisi√≥n
)
,
B
transmite
la
se√±al
de


interferencia
de
48
bits
.


Ac
o
n
t
i
n
u
a
c
i
√≥
n
 
v
a
m
o
s
 
a
 
v
e
r
 
e
l
 
a
l
g
o
r
i
t
m
o
 
d
e
 
backoff
exponencial
.
Lo
primero
que
tene-


mos
que
observar
aqu√≠
es
que
un
periodo
de
bit
(
es
decir
,
el
tiempo
que
se
tarda
en
transmi-


tir
un
√∫nico
bit
)
es
muy
corto
;
en
una
red
Ethernet
a
10
Mbps
,
un
periodo
de
bit
es
igual
a


0,1
microsegundos
.
Veamos
un
ejemplo
.
Suponga
que
un
adaptador
intenta
transmitir
una


trama
por
primera
vez
y
mientras
est√°
transmitiendo
detecta
una
colisi√≥n
.
El
adaptador


selecciona
entonces
K
=
0
con
una
probabilidad
de
0,5
o
K
=
1
con
una
probabilidad
de
0,5
.


Si
el
adaptador
elige
K
=
0
,
entonces
pasa
de
forma
inmediata
al
Paso
2
despu√©s
de
transmi-


tir
la
se√±al
de
interferencia
.
Si
el
adaptador
elige
K
=
1
,
entonces
espera
51,2
microsegundos


antes
de
volver
al
Paso
2
.
Despu√©s
de
una
segunda
colisi√≥n
,
K
se
selecciona
con
la
misma


probabilidad
del
conjunto
{
0
,
1
,
2
,
3
}
.
Despu√©s
de
tres
colisiones
,
K
se
elige
con
la
mis-


ma
probabilidad
del
conjunto
{
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
}
.
Despu√©s
de
10
o
m√°s
colisiones
,
K
se


elige
con
la
misma
probabilidad
del
conjunto
{
0
,
1
,
2
,
.
.
.
,
1023
}
.
Por
tanto
,
el
tama√±o
de


los
conjuntos
de
los
que
se
selecciona
K
crece
exponencialmente
con
el
n√∫mero
de
colisio-


456
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
4565.5
‚Ä¢
ETHERNET
457


nes
(
hasta
n
=
10
)
;
√©sta
es
la
raz√≥n
por
la
que
el
algoritmo
de
backoff
de
Ethernet
se
deno-


mina
backoff
exponencial
.


El
est√°ndar
Ethernet
impone
l√≠mites
a
la
distancia
existente
entre
dos
nodos
cuales-


quiera
.
Estos
l√≠mites
garantizan
que
si
el
adaptador
A
elige
un
valor
m√°s
peque√±o
de
K
que


todos
los
dem√°s
adaptadores
implicados
en
una
colisi√≥n
,
entonces
el
adaptador
A
podr√°


transmitir
su
trama
sin
experimentar
una
nueva
colisi√≥n
.
En
los
problemas
de
repaso
vere-


mos
m√°s
detalladamente
esta
propiedad
.


¬ø
Por
qu√©
se
utiliza
el
algoritmo
de
backoff
exponencial
?
¬ø
Por
qu√©
no
seleccionar
K
,
por


ejemplo
,
del
conjunto
{
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
}
despu√©s
de
cada
colisi√≥n
?
La
raz√≥n
es
que


cuando
un
adaptador
experimenta
su
primera
colisi√≥n
,
no
tiene
ni
idea
de
cu√°ntos
adaptado-


res
est√°n
implicados
en
la
misma
.
Si
el
n√∫mero
de
adaptadores
que
han
colisionado
es


peque√±o
,
tiene
sentido
seleccionar
K
de
un
conjunto
peque√±o
de
valores
bajos
.
Por
el
con-


trario
,
si
son
muchos
los
adaptadores
implicados
en
la
colisi√≥n
,
tiene
sentido
elegir
K
de
un


conjunto
m√°s
grande
y
m√°s
disperso
de
valores
(
¬ø
por
qu√©
?
)
.
Aumentando
el
tama√±o
del
con-


junto
despu√©s
de
cada
colisi√≥n
,
el
adaptador
se
adapta
apropiadamente
a
estos
distintos
esce-


narios
.


Observe
tambi√©n
que
cada
vez
que
un
adaptador
prepara
una
nueva
trama
para
su


transmisi√≥n
ejecuta
el
algoritmo
CSMA
/
CD
presentado
anteriormente
,
no
teniendo
en


cuenta
las
colisiones
que
hayan
tenido
lugar
en
el
pasado
reciente
.
Por
tanto
,
es
posible
que


un
adaptador
con
una
nueva
trama
sea
capaz
de
llevar
a
cabo
una
transmisi√≥n
con
√©xito
de


forma
inmediata
mientras
que
otros
adaptadores
se
encuentran
en
el
estado
de
backoff


exponencial
.


Eficiencia
de
Ethernet


Cuando
s√≥lo
un
nodo
tiene
una
trama
para
enviar
,
el
nodo
puede
transmitir
a
la
velocidad


m√°xima
de
la
tecnolog√≠a
Ethernet
(
por
ejemplo
,
10
Mbps
,
100
Mbps
o
1
Gbps
)
.
Sin


embargo
,
si
muchos
nodos
tienen
tramas
que
transmitir
,
la
velocidad
efectiva
de
transmisi√≥n


del
canal
puede
ser
mucho
menor
.
Definimos
eficiencia
de
Ethernet
como
la
fracci√≥n
(
a


largo
plazo
)
de
tiempo
durante
el
que
las
tramas
est√°n
siendo
transmitidas
al
canal
sin
coli-


siones
,
cuando
existe
un
gran
n√∫mero
de
nodos
activos
,
teniendo
cada
uno
de
ellos
una
gran


cantidad
de
tramas
para
enviar
.
Para
obtener
una
buena
aproximaci√≥n
de
la
eficiencia
de


Ethernet
,
definimos
dprop
como
el
tiempo
m√°ximo
que
tarda
la
intensidad
de
la
se√±al
en
pro-


pagarse
entre
dos
adaptadores
.
Sea
dtrans
el
tiempo
necesario
para
transmitir
una
trama
Ether-


net
de
tama√±o
m√°ximo
(
aproximadamente
1,2
milisegundos
para
Ethernet
a
10
Mbps
)
.
Una


demostraci√≥n
de
la
expresi√≥n
de
la
eficiencia
de
Ethernet
queda
fuera
del
alcance
de
este


libro
(
consulte
[
Lam
1980
]
y
[
Bertsekas
1991
]
)
.
A
continuaci√≥n
proporcionamos
simple-


mente
la
siguiente
aproximaci√≥n
:


Ap
a
r
t
i
r
 
d
e
 
e
s
t
a
 
f
√≥
r
m
u
l
a
 
v
e
m
o
s
 
q
u
e
 
c
u
a
n
d
o
 
dprop
se
aproxima
a
0
,
la
eficiencia
tiende
a


1
.
Esto
confirma
la
idea
intuitiva
de
que
si
el
retardo
de
propagaci√≥n
es
cero
,
los
nodos
que


han
colisionado
abortar√°n
de
forma
inmediata
sus
transmisiones
,
evitando
as√≠
que
el
canal


se
desperdicie
.
Tambi√©n
,
cuando
dtrans
se
hace
muy
grande
,
la
eficiencia
tiende
a
1
.
Esto
es


igualmente
intuitivo
,
ya
que
cuando
una
trama
se
apropia
del
canal
se
mantendr√°
en
√©l


Eficiencia
=
+


1


15
dd
prop
   
trans


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
457durante
bastante
tiempo
y
,
por
tanto
,
el
canal
estar√°
realizando
un
trabajo
productivo
la


mayor
parte
del
tiempo
.


5.5.3
Tecnolog√≠as
Ethernet


En
nuestra
exposici√≥n
anterior
hemos
hecho
a
referencia
a
Ethernet
como
si
fuera
el
√∫nico


est√°ndar
de
protocolo
.
Pero
,
en
realidad
,
existen
muchas
versiones
diferentes
de
Ethernet
,


algunas
con
acr√≥nimos
algo
complicados
como
10BASE-T
,
10BASE-2
,
100BASE-T
,


1000BASE-LX
y
10GBASE-T.
√âstas
y
otras
muchas
tecnolog√≠as
Ethernet
han
sido
estanda-


rizadas
a
lo
largo
de
los
a√±os
por
el
grupo
de
trabajo
IEEE
802.3
CSMA
/
CD
(
Ethernet
)


[
IEEE
802.3
2009
]
.
Aunque
estos
acr√≥nimos
pueden
parecer
algo
complicados
,
realmente


tienen
su
l√≥gica
.
La
primera
parte
del
acr√≥nimo
hace
referencia
a
la
velocidad
del
est√°ndar
:


10
,
100
,
1000
o
10
G
,
para
10
Megabits
(
por
segundo
)
,
100
Megabits
,
Gigabit
y
10
Gigabits


Ethernet
,
respectivamente
.
‚Äú
BASE
‚Äù
hace
referencia
a
la
tecnolog√≠a
Ethernet
banda
base
,
que


significa
que
el
medio
f√≠sico
s√≥lo
transporta
tr√°fico
Ethernet
;
casi
todos
los
est√°ndares
802.3


son
para
Ethernet
banda
base
.
La
parte
final
del
acr√≥nimo
se
refiere
al
medio
f√≠sico
en
s√≠
.


Ethernet
es
una
especificaci√≥n
tanto
de
la
capa
de
enlace
como
de
la
capa
f√≠sica
y
puede


emplear
diversos
medios
f√≠sicos
entre
los
que
se
incluyen
el
cable
coaxial
,
el
cable
de
cobre


y
la
fibra
.
Generalmente
,
la
‚Äú
T
‚Äù
hace
referencia
al
cable
de
cobre
de
par
trenzado
.


Hist√≥ricamente
,
Ethernet
fue
concebida
inicialmente
como
un
segmento
de
cable
coa-


xial
,
como
se
muestra
en
la
Figura
5.20
.
Los
primeros
est√°ndares
10BASE-2
y
10BASE5


especificaban
Ethernet
a
10
Mbps
sobre
dos
tipos
de
cable
coaxial
,
cada
uno
de
ellos
limi-


tado
a
una
longitud
de
500
metros
.
Pod√≠an
obtenerse
recorridos
m√°s
largos
utilizando
un


repetidor
(
un
dispositivo
de
la
capa
f√≠sica
que
recibe
una
se√±al
en
su
entrada
y
regenera
la


se√±al
en
la
salida
)
.
Un
cable
coaxial
,
como
el
mostrado
en
la
Figura
5.20
,
se
corresponde


con
nuestra
visi√≥n
de
Ethernet
como
un
medio
de
difusi√≥n
(
todas
las
tramas
transmitidas
por


una
interfaz
son
recibidas
en
otras
interfaces
)
,
y
el
protocolo
CDMA
/
CD
de
Ethernet


resuelve
muy
bien
el
problema
del
acceso
m√∫ltiple
.
Los
nodos
simplemente
se
conectan
al


cable
,
y
voila
,
tenemos
una
red
de
√°rea
local
.


La
tecnolog√≠a
Ethernet
ha
pasado
por
una
serie
de
pasos
evolutivos
a
lo
largo
de
los


a√±os
y
la
Ethernet
actual
es
muy
diferente
de
los
dise√±os
de
las
topolog√≠as
de
bus
originales


que
utilizaban
cable
coaxial
.
En
la
mayor
parte
de
las
instalaciones
actuales
,
los
nodos
se


conectan
a
un
conmutador
mediante
segmentos
punto
a
punto
hechos
de
cable
de
cobre
de


par
trenzado
o
de
cable
de
fibra
√≥ptica
,
como
se
muestra
en
la
Figura
5.24
.


Am
e
d
i
a
d
o
s
 
d
e
 
l
a
 
d
√©
c
a
d
a
 
d
e
 
1
9
9
0
 
E
t
h
e
r
n
e
t
 
s
e
 
e
s
t
a
n
d
a
r
i
z
√≥
 
a
 
1
0
0
 
M
b
p
s
,
 
t
e
c
n
o
l
o
g
√≠
a
 
1
0


veces
m√°s
r√°pida
que
la
Ethernet
a
10
Mbps
.
El
protocolo
MAC
Ethernet
original
y
el
for-


mato
de
trama
se
conservaron
,
pero
se
definieron
capas
f√≠sicas
de
mayor
velocidad
para


cable
de
cobre
(
100BASE-T
)
y
fibra
(
100BASE-FX
,
100BASE-SX
,
100BASE-BX
)
.
La


Figura
5.25
muestra
estos
distintos
est√°ndares
,
junto
con
el
protocolo
MAC
Ethernet
y
el


formato
de
trama
comunes
.
La
tecnolog√≠a
Ethernet
a
100
Mbps
est√°
limitada
a
una
distancia


de
100
metros
sobre
cable
de
par
trenzado
y
a
varios
kil√≥metros
para
cable
de
fibra
,
lo
que


permite
conectar
conmutadores
Ethernet
situados
en
diferentes
edificios
.


Ethernet
Gigabit
 
es
una
extensi√≥n
de
los
est√°ndares
Ethernet
a
10
Mbps
y
100
Mbps
de


mayor
√©xito
.
Ofreciendo
una
tasa
de
datos
en
bruto
de
1.000
Mbps
,
Ethernet
Gigabit
man-


tiene
una
compatibilidad
total
con
la
enorme
base
instalada
de
equipos
Ethernet
.
El
est√°ndar


para
Ethernet
Gigabit
,
IEEE
802.3z
,
hace
lo
siguiente
:


458
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
458‚Ä¢U
t
i
l
i
z
a
 
e
l
 
f
o
r
m
a
t
o
 
d
e
 
t
r
a
m
a
 
E
t
h
e
r
n
e
t
 
e
s
t
√°
n
d
a
r
 
(
F
i
g
u
r
a
 
5
.
2
2
)
 
y
 
e
s
 
c
o
m
p
a
t
i
b
l
e
 
h
a
c
i
a
 
a
t
r
√°
s


con
las
tecnolog√≠as
10BASE-T
y
100BASE-T.
Esto
permite
una
f√°cil
integraci√≥n
de


Ethernet
Gigabit
con
la
base
instalada
existente
de
equipos
Ethernet
.


‚Ä¢P
e
r
m
i
t
e
 
e
l
 
u
s
o
 
d
e
 
e
n
l
a
c
e
s
 
p
u
n
t
o
 
a
 
p
u
n
t
o
,
 
a
s
√≠
 
c
o
m
o
 
d
e
 
c
a
n
a
l
e
s
 
d
e
 
d
i
f
u
s
i
√≥
n
 
c
o
m
p
a
r
t
i
-


dos
.
Los
enlaces
punto
a
punto
utilizan
conmutadores
mientras
que
los
canales
de


difusi√≥n
emplean
concentradores
,
como
se
ha
descrito
anteriormente
.
En
la
jerga
de


Ethernet
Gigabit
,
los
concentradores
reciben
el
nombre
de
distribuidores
con
buffer
.


‚Ä¢U
t
i
l
i
z
a
 
C
S
M
A
/
C
D
 
p
a
r
a
 
l
o
s
 
c
a
n
a
l
e
s
 
d
e
 
d
i
f
u
s
i
√≥
n
 
c
o
m
p
a
r
t
i
d
o
s
.
 
P
a
r
a
 
o
b
t
e
n
e
r
 
u
n
a
 
e
f
i
c
i
e
n
c
i
a


aceptable
,
la
distancia
m√°xima
entre
nodos
tiene
que
ser
restringida
de
forma
estricta
.


‚Ä¢
Permite
la
operaci√≥n
full-duplex
a
1.000
Mbps
en
ambas
direcciones
en
los
canales
punto


a
punto
.


Operando
inicialmente
sobre
cable
de
fibra
√≥ptica
,
ahora
Ethernet
Gigabit
es
capaz
de
ope-


rar
sobre
cable
UTP
de
categor√≠a
5
.
En
2007
se
estandariz√≥
Ethernet
a
10
Gbps
(
10GBASE-


T
)
,
proporcionando
a√∫n
mayores
capacidades
a
las
redes
LAN
Ethernet
.


5.5
‚Ä¢
ETHERNET
459


Conmutador


E


B


F


A


D


C


Figura
5.24
‚Ä¢
Conmutador
de
la
capa
de
enlace
que
interconecta
seis
nodos
.


F√≠sica


Transporte


Red


Enlace


Aplicaci√≥n


100BASE-TX


100BASE-T4


100BASE-T2


Protocolo
MAC


y
formato
de
trama


100BASE-SX


100BASE-FX


100BASE-BX


Figura
5.25
‚Ä¢
Est√°ndares
Ethernet
a
100
Mbps
:
una
capa
de
enlace
com√∫n
y


diferentes
capas
f√≠sicas
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
459Vamos
a
concluir
nuestra
exposici√≥n
sobre
la
tecnolog√≠a
Ethernet
planteando
una
cues-


ti√≥n
que
puede
que
le
haya
estado
rondando
la
cabeza
.
En
la
√©poca
de
las
topolog√≠as
de
bus


y
de
las
topolog√≠as
en
estrella
basadas
en
concentrador
,
Ethernet
era
claramente
un
enlace
de


difusi√≥n
(
como
se
ha
definido
en
la
Secci√≥n
5.3
)
en
el
que
se
produc√≠an
colisiones
entre
tra-


mas
cuando
los
nodos
transmit√≠an
al
mismo
tiempo
.
Para
tratar
estas
colisiones
,
el
est√°ndar


Ethernet
incluy√≥
el
protocolo
CSMA
/
CD
,
que
es
particularmente
efectivo
en
las
redes
LAN


cableadas
de
difusi√≥n
con
un
radio
geogr√°fico
peque√±o
.
Pero
,
si
el
uso
prevalente
de
hoy
d√≠a


es
una
topolog√≠a
en
estrella
basada
en
conmutadores
,
que
utiliza
la
conmutaci√≥n
de
paquetes


de
almacenamiento
y
reenv√≠o
,
¬ø
existe
realmente
la
necesidad
de
un
protocolo
MAC
Ether-


net
?
Como
veremos
en
la
Secci√≥n
5.6
,
un
conmutador
coordina
sus
transmisiones
y
nunca


reenv√≠a
m√°s
de
una
trama
a
la
misma
interfaz
en
un
determinado
instante
.
Adem√°s
,
los
con-


mutadores
modernos
son
full-duplex
,
por
lo
que
un
conmutador
y
un
nodo
pueden
enviarse


tramas
entre
s√≠
simult√°neamente
sin
interferir
.
En
otras
palabras
,
en
una
red
LAN
Ethernet


basada
en
conmutadores
no
se
producen
colisiones
y
,
por
tanto
,
no
se
necesita
un
protocolo


MAC
.


Como
hemos
visto
,
las
tecnolog√≠as
Ethernet
actuales
son
muy
diferentes
de
la
tecnolo-


g√≠a
Ethernet
original
concebida
por
Metcalfe
y
Boggs
hace
m√°s
de
30
a√±os
;
las
velocidades


se
han
incrementado
en
tres
√≥rdenes
de
magnitud
,
las
tramas
Ethernet
son
transportadas
por


una
amplia
variedad
de
medios
,
la
tecnolog√≠a
Ethernet
conmutada
se
ha
convertido
en
la
tec-


nolog√≠a
dominante
y
ahora
incluso
el
protocolo
MAC
con
frecuencia
no
es
necesario
.
¬ø
Sigue


siendo
todo
esto
realmente
Ethernet
?
Por
supuesto
,
la
respuesta
es
‚Äú
s√≠
,
por
definici√≥n
‚Äù
.
Sin


embargo
,
es
interesante
observar
que
a
pesar
de
todos
estos
cambios
,
hay
algo
que
se
ha


mantenido
inalterado
a
lo
largo
de
estos
30
a√±os
:
el
formato
de
la
trama
Ethernet
.
Quiz√°
sea


entonces
√©sta
la
√∫nica
verdadera
pieza
importante
del
est√°ndar
Ethernet
.


5.6
Conmutadores
de
la
capa
de
enlace


Como
se
muestra
en
la
Figura
5.26
,
las
redes
LAN
Ethernet
modernas
utilizan
una
topolog√≠a


en
estrella
,
estando
cada
nodo
conectado
a
un
conmutador
central
.
Hasta
el
momento
no


hemos
entrado
en
detalles
sobre
lo
que
realmente
hace
un
conmutador
y
c√≥mo
funciona
.
La


funci√≥n
de
un
conmutador
es
recibir
las
tramas
de
la
capa
de
enlace
entrantes
y
reenviarlas
a


los
enlaces
de
salida
;
enseguida
vamos
a
estudiar
la
funci√≥n
de
reenv√≠o
en
detalle
.
El
propio


conmutador
es
transparente
para
los
nodos
;
es
decir
,
un
nodo
dirige
una
trama
a
otro
nodo


(
en
lugar
de
dirigirla
al
conmutador
)
y
la
env√≠a
a
la
red
LAN
,
sin
ser
consciente
de
que
un


conmutador
recibir√°
la
trama
y
la
reenviar√°
a
los
dem√°s
nodos
.
La
velocidad
a
la
que
llegan


las
tramas
a
cualquiera
de
las
interfaces
de
salida
del
conmutador
puede
ser
temporalmente


mayor
que
la
capacidad
del
enlace
de
dicha
interfaz
.
Para
enfrentarse
a
este
problema
,
las


interfaces
de
salida
del
conmutador
disponen
de
buffers
,
de
forma
muy
parecida
a
como


las
interfaces
de
salida
de
un
router
disponen
de
buffers
para
los
datagramas
.
Veamos
ahora


detenidamente
c√≥mo
funciona
un
conmutador
.


5.6.1
Reenv√≠o
y
filtrado


El
filtrado
es
la
funci√≥n
del
conmutador
que
determina
si
una
trama
debe
ser
reenviada
a


alguna
interfaz
o
debe
ser
descartada
.
El
reenv√≠oes
la
funci√≥n
del
conmutador
que
deter-


mina
las
interfaces
a
las
que
un
trama
debe
dirigirse
y
luego
env√≠a
la
trama
a
esas
interfaces
.


460
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
460Las
funciones
de
filtrado
y
reenv√≠o
del
conmutador
se
realizan
utilizando
la
tabla
del
con-


mutador
.
Esta
tabla
contiene
entradas
para
algunos
nodos
,
no
necesariamente
todos
,
de
una


red
LAN
.
Una
entrada
de
la
tabla
del
conmutador
contiene
(
1
)
la
direcci√≥n
MAC
de
un


nodo
,
(
2
)
la
interfaz
del
conmutador
que
lleva
hacia
el
nodo
y
(
3
)
el
instante
en
el
que
la


entrada
para
el
nodo
fue
incluida
en
la
tabla
.
Un
ejemplo
de
tabla
de
conmutaci√≥n
para
el


conmutador
superior
de
la
Figura
5.26
se
muestra
en
la
Figura
5.27
.
Aunque
esta
descrip-


ci√≥n
de
reenv√≠o
de
tramas
puede
parecer
muy
similar
a
lo
que
hemos
visto
sobre
el
reenv√≠o


de
datagramas
en
el
Cap√≠tulo
4
,
veremos
que
existen
diferencias
importantes
.
Una
de
estas


diferencias
es
que
los
conmutadores
reenv√≠an
los
paquetes
bas√°ndose
en
las
direcciones


MAC
en
lugar
de
en
la
direcciones
IP
.
Tambi√©n
veremos
que
la
tabla
del
conmutador
se


construye
de
forma
muy
distinta
a
como
se
crea
la
tabla
de
reenv√≠o
de
un
router
.


Para
comprender
c√≥mo
funciona
el
filtrado
y
el
reenv√≠o
en
un
conmutador
,
suponga
que


una
trama
con
la
direcci√≥n
de
destino
DD-DD-DD-DD-DD-DD
llega
a
la
interfaz
x
del


Direcci√≥n
Interfaz
Hora


62-FE-F7-11-89-A3
1
9:32


7C-BA-B2-B4-91-10
3
9:36


....
....
....


Figura
5.27
‚Ä¢
Parte
de
la
tabla
del
conmutador
superior
de
la
Figura
5.26
.


5.6
‚Ä¢
CONMUTADORES
DE
LA
CAPA
DE
ENLACE
461


Servidor


de
correo


A
la
red


externa


1
Gbps


1


2
3


4


56


1
Gbps


1
Gbps


Ingenier√≠a
el√©ctrica
Ciencias
de
la
computacion


100
Mbps


(
fibra
)


100
Mbps


(
fibra
)


100
Mbps


(
fibra
)


Mezcla
de
10
Mbps
,


100
Mbps
y
1
Gbps


(
cable
de
Cat
5
)


Servidor


web


Ingenier√≠a
inform√°tica


Figura
5.26
‚Ä¢
Una
red
institucional
que
utiliza
una
combinaci√≥n
de
concentrado-


res
,
conmutadores
Ethernet
y
un
router
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
461conmutador
.
√âste
buscar√°
en
su
tabla
la
direcci√≥n
MAC
DD-DD-DD-DD-DD-DD
.
Se
plan-


tean
tres
posibilidades
:


‚Ä¢N
o
 
h
a
y
 
n
i
n
g
u
n
a
 
e
n
t
r
a
d
a
 
e
n
 
l
a
 
t
a
b
l
a
 
p
a
r
a
 
D
D
-
D
D
-
D
D
-
D
D
-
D
D
-
D
D
.
 
E
n
 
e
s
t
e
 
c
a
s
o
,
 
e
l
 
c
o
n
-


mutador
reenv√≠a
copias
de
la
trama
a
los
buffers
de
salida
que
preceden
a
todas
las
inter-


faces
salvo
a
la
interfaz
x.
En
otras
palabras
,
si
no
hay
ninguna
entrada
para
la
direcci√≥n


de
destino
,
el
conmutador
difunde
la
trama
.


‚Ä¢E
x
i
s
t
e
 
u
n
a
 
e
n
t
r
a
d
a
 
e
n
 
l
a
 
t
a
b
l
a
 
q
u
e
 
a
s
o
c
i
a
 
D
D
-
D
D
-
D
D
-
D
D
-
D
D
-
D
D
 
c
o
n
 
l
a
 
i
n
t
e
r
f
a
z
 
x.


En
este
caso
,
la
trama
procede
de
un
segmento
de
la
LAN
que
contiene
al
adaptador
DD-


DD-DD-DD-DD-DD
.
No
existe
la
necesidad
de
reenviar
la
trama
a
ninguna
de
las
res-


tantes
interfaces
,
el
conmutador
lleva
a
cabo
la
funci√≥n
de
filtrado
descartando
la
trama
.


‚Ä¢E
x
i
s
t
e
 
u
n
a
 
e
n
t
r
a
d
a
 
e
n
 
l
a
 
t
a
b
l
a
 
q
u
e
 
a
s
o
c
i
a
 
D
D
-
D
D
-
D
D
-
D
D
-
D
D
-
D
D
 
c
o
n
 
l
a
 
i
n
t
e
r
f
a
z
 
y 
x.


En
este
caso
,
la
trama
tiene
que
ser
reenviada
al
segmento
de
la
LAN
conectado
a
la


interfaz
y.
El
conmutador
lleva
a
cabo
su
funci√≥n
de
reenv√≠o
colocando
la
trama
en
un


buffer
de
salida
que
precede
a
la
interfaz
y.


Apliquemos
estas
reglas
al
conmutador
de
la
parte
superior
de
la
Figura
5.26
y
a
su


tabla
mostrada
en
la
Figura
5.27
.
Suponga
que
una
trama
con
la
direcci√≥n
de
destino
62-FE-


F7-11-89-A3
llega
al
conmutador
desde
la
interfaz
1
.
El
conmutador
examina
su
tabla
y
ve


que
el
destino
est√°
en
el
segmento
de
LAN
conectado
a
la
interfaz
1
(
es
decir
,
Ingenier√≠a


El√©ctrica
)
.
Esto
significa
que
la
trama
ya
ha
sido
difundida
en
el
segmento
de
LAN
que
con-


tiene
el
destino
.
Por
tanto
,
el
conmutador
filtra
(
es
decir
,
descarta
)
la
trama
.
Suponga
ahora


que
una
trama
con
la
misma
direcci√≥n
de
destino
llega
de
la
interfaz
2
.
De
nuevo
,
el
conmu-


tador
examina
su
tabla
y
ve
que
el
destino
est√°
en
la
direcci√≥n
de
interfaz
1
;
por
tanto
,
reen-


v√≠a
la
trama
al
buffer
de
salida
que
precede
a
la
interfaz
1
.
Con
este
ejemplo
deber√≠a
quedar


claro
que
a
medida
que
la
tabla
del
conmutador
se
completa
y
precisa
,
el
conmutador
reen-


v√≠a
las
tramas
hacia
los
destinos
sin
llevar
a
cabo
ninguna
difusi√≥n
.


En
este
sentido
,
un
conmutador
es
‚Äú
m√°s
inteligente
‚Äù
que
un
concentrador
.
Pero
,
¬ø
como


se
configura
la
tabla
del
conmutador
?
¬ø
Existen
equivalentes
para
la
capa
de
enlace
de
los


protocolos
de
enrutamiento
de
la
capa
de
red
?
¬ø
O
tiene
un
administrador
sobrecargado
de


trabajo
que
configurar
manualmente
la
tabla
del
conmutador
?


5.6.2
Auto-aprendizaje


Los
conmutadores
tienen
la
fant√°stica
propiedad
(
especialmente
para
los
administradores
de


redes
sobrecargados
de
trabajo
)
de
que
su
tabla
se
construye
de
forma
autom√°tica
,
din√°mica


y
aut√≥noma
,
sin
intervenci√≥n
de
un
administrador
de
redes
ni
de
ning√∫n
protocolo
de
confi-


guraci√≥n
.
En
otras
palabras
,
los
conmutadores
son
auto-aprendices
.
Esta
capacidad
se
lleva


cabo
de
la
forma
siguiente
:


1
.
Inicialmente
,
la
tabla
del
conmutador
est√°
vac√≠a
.


2
.
Para
cada
trama
entrante
recibida
en
una
interfaz
,
el
conmutador
almacena
en
su
tabla


(
1
)
la
direcci√≥n
MAC
especificada
en
el
campo
direcci√≥n
de
origen
de
la
trama
,
(
2
)
la


interfaz
de
la
que
procede
la
trama
y
(
3
)
la
hora
actual
.
De
esta
forma
,
el
conmutador


registra
en
su
tabla
el
segmento
de
la
LAN
en
la
que
reside
el
nodo
emisor
.
Si
todos
los


nodos
de
la
LAN
terminan
enviando
una
trama
,
entonces
todos
los
nodos
terminar√°n


estando
registrados
en
la
tabla
.


462
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
462Direcci√≥n
Interfaz
Hora


01-12-23-34-45-56
2
9:39


62-FE-F7-11-89-A3
1
9:32


7C-BA-B2-B4-91-10
3
9:36


....
....
....


Figura
5.28
‚Ä¢
El
conmutador
aprende
la
ubicaci√≥n
de
un
adaptador
con
la


direcci√≥n
01-12-23-34-45-56
.


3
.
El
conmutador
borra
una
direcci√≥n
de
la
tabla
si
no
se
recibe
ninguna
trama
con
esa


direcci√≥n
como
direcci√≥n
de
origen
transcurrido
un
cierto
periodo
de
tiempo
(
el
tiempo


de
envejecimiento
)
.
De
esta
forma
,
si
un
PC
es
sustituido
por
otro
(
con
un
adaptador


diferente
)
,
la
direcci√≥n
MAC
del
PC
original
ser√°
eliminado
de
la
tabla
del
conmutador
.


Examinemos
la
propiedad
de
auto-aprendizaje
del
conmutador
superior
de
la
Figura


5.26
y
su
tabla
de
conmutaci√≥n
correspondiente
,
mostrada
en
la
Figura
5.27
.
Suponga
que
a


las
9:39
una
trama
con
la
direcci√≥n
de
origen
01-12-23-34-45-56
llega
procedente
de
la


interfaz
2
.
Suponga
tambi√©n
que
esa
direcci√≥n
no
est√°
incluida
en
la
tabla
del
conmutador
.


Entonces
el
conmutador
a√±ade
una
nueva
entrada
,
como
se
muestra
en
la
Figura
5.28
.


Continuando
con
el
ejemplo
,
suponga
que
el
tiempo
de
envejecimiento
para
este
con-


mutador
es
de
60
minutos
,
y
que
entre
las
9:32
y
las
10:32
no
le
llega
ninguna
trama
con
la


direcci√≥n
de
origen
62-FE-F7-11-89-A3
.
Entonces
,
a
las
10:32
,
el
conmutador
eliminar√°
es-


ta
direcci√≥n
de
su
tabla
.


Los
conmutadores
son
dispositivos
plug-and-play
porque
no
requieren
intervenci√≥n
ni


de
un
administrador
de
redes
ni
de
los
usuarios
.
Un
administrador
de
redes
que
desee
insta-


lar
un
conmutador
no
tiene
que
hacer
nada
m√°s
que
conectar
los
segmentos
de
la
LAN
a
las


interfaces
del
conmutador
.
El
administrador
no
tiene
que
configurar
las
tablas
del
conmuta-


dor
en
el
momento
de
la
instalaci√≥n
ni
cuando
se
elimina
un
host
de
uno
de
los
segmentos


de
la
LAN
.
Los
conmutadores
tambi√©n
permiten
la
comunicaci√≥n
full-duplex
,
lo
que
signi-


fica
que
para
cualquier
enlace
que
conecte
un
nodo
con
el
conmutador
,
tanto
el
nodo
como


el
conmutador
pueden
transmitir
al
mismo
tiempo
sin
que
se
produzcan
colisiones
.


5.6.3
Propiedades
de
la
conmutaci√≥n
de
la
capa
de
enlace


Una
vez
que
hemos
descrito
el
funcionamiento
b√°sico
de
un
conmutador
de
la
capa
de


enlace
,
vamos
a
pasar
a
ver
sus
caracter√≠sticas
y
propiedades
.
Utilizando
la
red
LAN
de
la


Figura
5.24
podemos
identificar
varias
ventajas
de
utilizar
conmutadores
,
en
lugar
de
enla-


ces
de
difusi√≥n
como
las
topolog√≠as
de
bus
o
basadas
en
concentradores
.


‚Ä¢
Eliminaci√≥n
de
las
colisiones
.
En
una
red
LAN
construida
con
conmutadores
(
y
sin
con-


centradores
)
no
se
desperdicia
ancho
de
banda
a
causa
de
las
colisiones
.
Los
conmutado-


res
almacenan
las
tramas
en
buffer
y
nunca
transmiten
m√°s
de
una
trama
a
un
segmento


simult√°neamente
.
Al
igual
que
con
los
routers
,
la
tasa
m√°xima
de
transferencia
agregada


de
un
conmutador
es
la
suma
de
todas
las
tasas
de
las
interfaces
del
conmutador
.
Por


tanto
,
los
conmutadores
proporcionan
una
mejora
significativa
en
cuanto
al
rendimiento


respecto
al
de
las
redes
LAN
con
enlaces
de
difusi√≥n
.


5.6
‚Ä¢
CONMUTADORES
DE
LA
CAPA
DE
ENLACE
463


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
463‚Ä¢
Enlaces
heterog√©neos
.
Dado
que
un
conmutador
a√≠sla
un
enlace
de
otro
,
los
distintos


enlaces
de
una
LAN
pueden
operar
a
velocidades
diferentes
y
pueden
utilizar
diferentes


medios
f√≠sicos
.
Por
ejemplo
,
en
la
Figura
5.24
,
A
puede
conectarse
mediante
un
enlace


de
cobre
10BASE-T
a
10
Mbps
,
B
puede
conectarse
mediante
un
enlace
de
fibra


100BASE-FX
a
100
Mbps
y
C
puede
conectarse
mediante
un
enlace
de
cobre
1000


BASE-T
a
1
Gbps
.
Por
tanto
,
un
conmutador
es
ideal
para
combinar
equipos
heredados


con
equipos
nuevos
.


‚Ä¢
Administraci√≥n
.
Adem√°s
de
proporcionar
una
seguridad
mejorada
(
v√©ase
el
recuadro


dedicado
a
la
seguridad
)
,
un
conmutador
tambi√©n
facilita
las
tareas
de
gesti√≥n
de
la
red
.


Por
ejemplo
,
si
un
adaptador
de
red
funciona
mal
y
env√≠a
continuamente
tramas
Ether-


net
,
un
conmutador
puede
detectar
el
problema
y
desconectar
internamente
el
adapta-


dor
que
est√°
funcionando
incorrectamente
.
Con
esta
caracter√≠stica
,
el
administrador
de


la
red
no
tiene
que
levantarse
de
la
cama
y
conducir
hasta
la
oficina
para
corregir
el


problema
.
Del
mismo
modo
,
un
corte
en
un
cable
s√≥lo
desconecta
al
nodo
que
est√°


usando
el
cable
cortado
para
conectarse
al
conmutador
.
En
la
√©poca
del
cable
coaxial
,


los
administradores
de
red
pasaban
muchas
horas
‚Äú
recorriendo
las
l√≠neas
‚Äù
(
o
dicho
de


forma
m√°s
precisa
,
‚Äú
arrastr√°ndose
por
el
suelo
‚Äù
)
hasta
localizar
el
cable
roto
que
hab√≠a


hecho
que
se
cayera
toda
la
red
.
Como
veremos
en
el
Cap√≠tulo
9
(
Administraci√≥n
de
la


red
)
,
los
conmutadores
tambi√©n
recopilan
estad√≠sticas
acerca
del
uso
del
ancho
de
banda
,


de
las
tasas
de
colisi√≥n
y
de
los
tipos
de
tr√°fico
,
y
ponen
esta
informaci√≥n
a
disposici√≥n


del
administrador
de
la
red
.
Esta
informaci√≥n
puede
emplearse
para
depurar
y
corregir


problemas
y
para
planificar
c√≥mo
deber√°
la
red
LAN
evolucionar
en
el
futuro
.
Los
inves-


tigadores
est√°n
explorando
la
adici√≥n
de
todav√≠a
m√°s
funcionalidades
para
la
administra-


ci√≥n
de
las
redes
LAN
Ethernet
en
implantaciones
de
prototipos
[
Casado
2007
]
.


5.6.4
Conmutadores
frente
a
routers


Como
hemos
visto
en
el
Cap√≠tulo
4
,
los
routers
son
dispositivos
de
conmutaci√≥n
de
alma-


cenamiento
y
reenv√≠o
que
reenv√≠an
los
paquetes
utilizando
direcciones
de
la
capa
de
red
.


Aunque
un
conmutador
tambi√©n
es
un
dispositivo
de
conmutaci√≥n
de
paquetes
de
almacena-


miento
y
reenv√≠o
,
es
fundamentalmente
diferente
de
un
router
porque
reenv√≠a
los
paquetes


utilizando
direcciones
MAC
.
Mientras
que
un
router
es
un
dispositivo
de
conmutaci√≥n
de


paquetes
de
la
capa
3
,
un
conmutador
es
un
dispositivo
de
conmutaci√≥n
de
paquetes
de
la


capa
2
.


Aunque
los
conmutadores
y
los
routers
son
fundamentalmente
diferentes
,
los
adminis-


tradores
de
red
a
menudo
tienen
que
elegir
entre
ellos
a
la
hora
de
instalar
un
dispositivo
de


interconexi√≥n
.
Por
ejemplo
,
en
la
red
de
la
Figura
5.26
el
administrador
de
red
podr√≠a
haber


utilizado
f√°cilmente
un
router
en
lugar
de
un
conmutador
para
conectar
las
redes
LAN


departamentales
,
los
servidores
y
el
router
de
pasarela
de
Internet
.
De
hecho
,
un
router
per-


mitir√≠a
las
comunicaciones
entre
departamentos
sin
crear
colisiones
.
Puesto
que
tanto
los


conmutadores
como
los
routers
son
candidatos
como
dispositivos
de
interconexi√≥n
,
¬ø
cu√°les


son
los
pros
y
los
contras
de
cada
uno
de
ellos
?


En
primer
lugar
vamos
a
ocuparnos
de
los
pros
y
los
contras
de
los
conmutadores
.


Como
hemos
mencionado
anteriormente
,
los
conmutadores
son
dispositivos
plug-and-play
,


una
propiedad
muy
apreciada
por
todos
los
administradores
de
red
del
mundo
sobrecarga-


dos
de
trabajo
.
Los
conmutadores
tambi√©n
ofrecen
tasas
de
filtrado
y
reenv√≠o
relativamente


altas
(
como
se
muestra
en
la
Figura
5.29
,
los
conmutadores
tienen
que
procesar
las
tramas


464
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
464s√≥lo
hasta
la
capa
2
,
mientras
que
los
routers
tienen
que
procesar
los
datagramas
hasta
la


capa
3
)
.
Por
otro
lado
,
para
impedir
los
ciclos
de
las
tramas
de
difusi√≥n
,
la
topolog√≠a
activa


de
una
red
conmutada
est√°
restringida
a
un
√°rbol
de
recubrimiento
.
Adem√°s
,
una
red
conmu-


tada
grande
requerir√°
tablas
ARP
grandes
en
los
nodos
y
generar√°
una
cantidad
de
procesa-


miento
y
tr√°fico
ARP
sustancial
.
Los
conmutadores
no
ofrecen
ninguna
protecci√≥n
frente
a


las
tormentas
de
difusi√≥n
(
si
un
host
est√°
descontrolado
y
transmite
un
flujo
de
tramas
Ether-


5.6
‚Ä¢
CONMUTADORES
DE
LA
CAPA
DE
ENLACE
465


HUSMEANDO
EN
UNA
LAN
CONMUTADA
:


ENVENENAMIENTO
DE
UN
CONMUTADOR


Cuando
un
nodo
est√°
conectado
a
un
conmutador
,
normalmente
s√≥lo
recibe
las
tramas
que
le


est√°n
siendo
enviadas
de
forma
expl√≠cita
.
Por
ejemplo
,
considere
la
red
LAN
conmutada
de
la


Figura
5.24
.
Cuando
el
nodo
A
env√≠a
una
trama
al
nodo
B
y
existe
una
entrada
para
el
nodo


B
en
la
tabla
del
conmutador
,
√©ste
reenviar√°
la
trama
√∫nicamente
al
nodo
B.
Si
el
nodo
C
est√°


ejecutando
un
programa
husmeador
(
sniffer
)
,
no
podr√°
husmear
esta
trama
de
A
a
B.
Por


tanto
,
en
una
LAN
conmutada
(
en
contraste
con
un
entorno
de
enlaces
de
difusi√≥n
como
las


redes
LAN
802.11
o
las
redes
LAN
Ethernet
basadas
en
concentrador
)
es
m√°s
dif√≠cil
para
un


atacante
husmear
las
tramas
.
Sin
embargo
,
dado
que
los
conmutadores
difunden
las
tramas


que
tienen
direcciones
de
destino
que
no
est√°n
almacenadas
en
sus
tablas
de
conmutaci√≥n
,
el


programa
sniffer
de
C
puede
todav√≠a
husmear
algunas
tramas
que
no
est√°n
expl√≠citamente
diri-


gidas
a
C.
Adem√°s
,
un
programa
sniffer
podr√°
husmear
todas
las
tramas
Ethernet
de
difusi√≥n


que
tengan
la
direcci√≥n
de
destino
de
difusi√≥n
FF‚ÄìFF‚ÄìFF‚ÄìFF‚ÄìFF‚ÄìFF
.
Un
ataque
bien
conocido


contra
un
conmutador
,
que
recibe
el
nombre
de
envenenamiento
de
conmutador
,
consis-


te
en
enviar
toneladas
de
paquetes
al
conmutador
con
muchas
direcciones
MAC


de
origen
falsas
diferentes
,
que
rellenar√°n
la
tabla
del
conmutador
con
entradas
falsas
y
no


dejar√°n
espacio
para
las
direcciones
MAC
de
los
nodos
leg√≠timos
.
Esto
hace
que
el
conmu-


tador
difunda
la
mayor
parte
de
las
tramas
,
las
cuales
pueden
ser
seleccionadas
por
el
hus-


meador
[
Skoudis
2006
]
.
Dado
que
este
ataque
es
bastante
complejo
incluso
para
un
atacante


avanzado
,
los
conmutadores
son
significativamente
menos
vulnerables
a
los
sniffers
que
las


redes
LAN
inal√°mbricas
y
basadas
en
concentradores
.


SEGURIDAD


Host


Aplicaci√≥n


Host


Transporte


Red


Enlace


F√≠sica


Enlace


F√≠sica


Red


Conmutador
Router


Enlace


F√≠sica


Aplicaci√≥n


Transporte


Red


Enlace


F√≠sica


Figura
5.29
‚Ä¢
Procesamiento
de
paquetes
en
conmutadores
,
routers
y
hosts
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
465net
de
difusi√≥n
sin
fin
,
los
conmutadores
reenviar√°n
todas
esas
tramas
,
haciendo
que
toda
la


red
colapse
)
.


Consideremos
ahora
los
pros
y
los
contras
de
los
routers
.
Puesto
que
frecuentemente
el


direccionamiento
de
red
es
jer√°rquico
(
y
no
plano
como
el
direccionamiento
MAC
)
,
normal-


mente
los
paquetes
no
seguir√°n
ciclos
a
trav√©s
de
los
routers
incluso
cuando
la
red
tenga


rutas
redundantes
.
(
Sin
embargo
,
los
paquetes
pueden
seguir
ciclos
cuando
las
tablas
del


router
est√°n
mal
configuradas
;
pero
como
hemos
estudiado
en
el
Cap√≠tulo
4
,
IP
utiliza
un


campo
especial
de
la
cabecera
del
datagrama
para
limitar
estos
ciclos
.
)
Por
tanto
,
los
paque-


tes
no
est√°n
restringidos
a
un
√°rbol
de
recubrimiento
y
pueden
utilizar
la
mejor
ruta
entre
el


origen
y
el
destino
.
Dado
que
los
routers
no
tienen
la
restricci√≥n
del
√°rbol
de
recubrimiento
,


han
permitido
que
Internet
haya
sido
creada
con
una
topolog√≠a
rica
que
incluye
,
por
ejem-


plo
,
m√∫ltiples
enlaces
activos
entre
Europa
y
Am√©rica
del
Norte
.
Otra
funcionalidad
de
los


routers
es
que
proporcionan
protecci√≥n
mediante
cortafuegos
frente
a
las
tormentas
de
difu-


si√≥n
de
la
capa
2
.
Quiz√°
el
inconveniente
m√°s
significativo
de
los
routers
es
que
no
son
dis-


positivos
plug-and-play
(
ellos
y
los
hosts
conectados
a
ellos
necesitan
que
sus
direcciones


IP
sean
configuradas
)
.
Adem√°s
,
los
routers
suelen
tener
un
tiempo
de
procesamiento
por


paquete
mayor
que
los
conmutadores
,
ya
que
tienen
que
procesar
campos
hasta
la
capa
3
.


Por
√∫ltimo
,
en
ingl√©s
existen
dos
formas
diferentes
de
pronunciar
la
palabra
router
(
‚Äú
rootor
‚Äù


o
‚Äú
rowter
‚Äù
)
,
y
la
gente
pierde
mucho
tiempo
discutiendo
acerca
de
la
pronunciaci√≥n
apro-


piada
[
Perlman
1999
]
.


Dado
que
tanto
los
conmutadores
como
los
routers
tienen
sus
ventajas
y
sus
inconvenien-


tes
(
como
se
resume
en
la
Tabla
5.1
)
,
entonces
¬ø
cu√°ndo
debe
utilizar
una
red
institucional
(
por


ejemplo
,
un
red
de
un
campus
universitario
o
una
red
corporativa
)
conmutadores
y
cu√°ndo
rou-


ters
?
Normalmente
,
las
redes
peque√±as
que
constan
de
unos
pocos
cientos
de
hosts
tienen


menos
segmentos
de
LAN
.
Los
conmutadores
son
suficientes
para
estas
redes
peque√±as
,
ya


que
localizan
el
tr√°fico
y
aumentan
la
tasa
de
transferencia
agregada
sin
la
necesidad
de
confi-


gurar
direcciones
IP
.
Pero
las
redes
de
mayor
tama√±o
que
constan
de
miles
de
hosts
suelen


incluir
routers
dentro
de
la
red
(
adem√°s
de
conmutadores
)
.
Los
routers
proporcionan
un
aisla-


miento
m√°s
robusto
del
tr√°fico
,
controlan
las
tormentas
de
difusi√≥n
y
utilizan
rutas
m√°s
‚Äú
inteli-


gentes
‚Äù
entre
los
hosts
de
la
red
.


Para
ver
una
exposici√≥n
sobre
los
pros
y
los
contras
de
las
redes
conmutadas
y
enruta-


das
,
as√≠
como
un
estudio
de
c√≥mo
la
tecnolog√≠a
LAN
conmutada
puede
ampliarse
para
aco-


modar
dos
√≥rdenes
de
magnitud
m√°s
de
hosts
que
las
redes
Ethernet
actuales
,
consulte
[
Kim


2008
]
.


5.6.5
Redes
de
√°rea
local
virtuales
(
VLAN
)


En
nuestra
explicaci√≥n
anterior
de
la
Figura
5.26
hemos
mencionado
que
las
redes
LAN
ins-


titucionales
modernas
suelen
estar
configuradas
de
forma
jer√°rquica
,
teniendo
cada
grupo
de


trabajo
(
departamento
)
su
propia
red
LAN
conmutada
conectada
a
las
redes
LAN
conmuta-


das
de
los
otros
grupos
a
trav√©s
de
una
jerarqu√≠a
de
conmutadores
.
Aunque
una
configuraci√≥n


de
este
tipo
funciona
bien
en
un
mundo
ideal
,
el
mundo
real
est√°
bastante
alejado
del
ideal
.


En
la
configuraci√≥n
de
la
Figura
5.26
podemos
identificar
tres
desventajas
:


‚Ä¢
Falta
de
aislamiento
del
tr√°fico
.
Aunque
la
jerarqu√≠a
localiza
el
tr√°fico
del
grupo
dentro


de
un
mismo
conmutador
,
el
tr√°fico
de
difusi√≥n
(
por
ejemplo
,
las
tramas
que
transportan


los
mensajes
ARP
y
DHCP
o
las
tramas
cuyo
destino
todav√≠a
no
ha
sido
aprendido
por


un
conmutador
auto-aprendiz
)
tienen
que
atravesar
toda
la
red
institucional
.
Limitar
el


466
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
466Concentradores
Routers
Conmutadores


Aislamiento
del
tr√°fico
No
S√≠
S√≠


Plug
and
play
S√≠
No
S√≠


Enrutamiento
√≥ptimo
No
S√≠
No


Tabla
5.1
‚Ä¢
Comparaci√≥n
de
las
funcionalidades
t√≠picas
de
dispositivos
de


interconexi√≥n
populares
.


√°mbito
del
tr√°fico
de
difusi√≥n
mejorar√≠a
el
rendimiento
de
la
LAN
.
Quiz√°
m√°s
impor-


tante
,
ser√≠a
tambi√©n
deseable
limitar
el
tr√°fico
de
difusi√≥n
de
la
LAN
por
razones
de


seguridad
y
confidencialidad
.
Por
ejemplo
,
si
un
grupo
contiene
al
equipo
de
direcci√≥n


de
la
empresa
y
otro
grupo
tiene
empleados
descontentos
que
ejecutan
paquetes
sniffer


Wireshark
,
probablemente
el
administrador
de
la
red
preferir√°
que
el
tr√°fico
del
equipo


de
direcci√≥n
nunca
llegue
a
los
hosts
de
los
empleados
.
Este
tipo
de
aislamiento
podr√≠a


proporcionarse
sustituyendo
el
conmutador
central
de
la
Figura
5.26
por
un
router
.
Ense-


guida
veremos
que
este
aislamiento
tambi√©n
se
puede
conseguir
a
trav√©s
de
una
soluci√≥n


conmutada
(
capa
2
)
.


‚Ä¢
Uso
ineficiente
de
los
conmutadores
.
Si
en
lugar
de
tres
grupos
la
instituci√≥n
tiene
10


grupos
,
entonces
se
necesitar√≠an
10
conmutadores
de
primer
nivel
.
Si
cada
uno
de
los


grupos
es
peque√±o
,
por
ejemplo
,
est√°n
formados
por
menos
de
10
personas
,
entonces
un


√∫nico
conmutador
de
96
puertos
ser√≠a
lo
suficientemente
grande
como
para
acomodar
a


todo
el
mundo
,
pero
este
√∫nico
conmutador
no
proporcionar√≠a
la
funcionalidad
de
aisla-


miento
del
tr√°fico
.


‚Ä¢
Gesti√≥n
de
los
usuarios
.
Si
un
empleado
se
mueve
entre
grupos
,
el
cableado
f√≠sico
debe


modificarse
para
conectar
al
empleado
a
un
conmutador
diferente
de
la
Figura
5.26
.
Los


empleados
que
pertenecen
a
dos
grupos
constituyen
incluso
un
problema
mayor
.


Afortunadamente
,
cada
una
de
estas
desventajas
puede
ser
abordada
por
un
conmutador


compatible
con
redes
de
√°rea
local
virtuales
(
VLAN
,
Virtual
Local
Area
Network
)
.


Como
su
nombre
sugiere
,
un
conmutador
compatible
con
redes
VLAN
permite
definir


m√∫ltiples
redes
de
√°rea
local
virtuales
sobre
una
√∫nica
infraestructura
de
red
de
√°rea
local


f√≠sica
.
Los
hosts
de
una
VLAN
se
comunican
entre
s√≠
como
si
s√≥lo
ellos
(
y
ning√∫n
otro
host
)


estuvieran
conectados
al
conmutador
.
En
una
VLAN
basada
en
puertos
,
el
administrador
de


la
red
divide
los
puertos
(
interfaces
)
del
conmutador
en
grupos
.
Cada
grupo
constituye
una


VLAN
,
con
los
puertos
de
cada
VLAN
formando
un
dominio
de
difusi√≥n
(
es
decir
,
el
tr√°fico


de
difusi√≥n
de
un
puerto
s√≥lo
puede
llegar
a
los
dem√°s
puertos
del
grupo
)
.
La
Figura
5.30


muestra
un
√∫nico
conmutador
con
16
puertos
.
Los
puertos
2
a
8
pertenecen
a
la
VLAN
IE
,
y


los
puertos
9
a
15
pertenecen
a
la
VLAN
CC
(
los
puertos
1
y
16
no
est√°n
asignados
)
.
Esta


VLAN
resuelve
todas
las
dificultades
mencionadas
anteriormente
(
las
tramas
de
las
VLAN


IE
y
CC
est√°n
aisladas
entre
s√≠
,
los
dos
conmutadores
de
la
Figura
5.26
se
han
sustituido
por


un
√∫nico
conmutador
y
si
el
usuario
del
puerto
8
del
conmutador
se
une
al
departamento
CC
,


el
operador
de
red
simplemente
tendr√°
que
reconfigurar
el
software
de
la
VLAN
de
modo


que
el
puerto
8
ahora
est√©
asociado
con
la
VLAN
CC
.
Es
f√°cil
imaginar
c√≥mo
se
configura
y


funciona
el
conmutador
para
redes
VLAN
:
el
administrador
de
la
red
declara
que
un
puerto


pertenece
a
una
determinada
VLAN
(
los
puertos
no
declarados
pertenecen
a
una
VLAN


5.6
‚Ä¢
CONMUTADORES
DE
LA
CAPA
DE
ENLACE
467


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
467predeterminada
)
utilizando
un
software
de
gesti√≥n
de
conmutadores
;
en
el
conmutador
se


mantiene
una
tabla
de
correspondencias
entre
puertos
y
redes
VLAN
y
el
hardware
del
con-


mutador
s√≥lo
entrega
tramas
entre
puertos
que
pertenecen
a
la
misma
VLAN
.


Pero
a
causa
del
completo
aislamiento
de
las
dos
redes
VLAN
,
hemos
introducido
una


nueva
dificultad
:
¬ø
c√≥mo
puede
enviarse
el
tr√°fico
del
departamento
IE
al
departamento
CC
?


Una
forma
de
resolver
esto
ser√≠a
conectando
un
puerto
del
conmutador
VLAN
(
por
ejemplo
,


el
puerto
1
en
la
Figura
5.30
)
a
un
router
externo
y
configurando
dicho
puerto
para
que
per-


tenezca
tanto
a
la
VLAN
IE
como
a
la
VLAN
CC
.
En
este
caso
,
incluso
aunque
los
departa-


mentos
IE
y
CC
compartan
el
mismo
conmutador
f√≠sico
,
la
configuraci√≥n
l√≥gica
ser√≠a
como


si
dichos
departamentos
tuvieran
conmutadores
separados
conectados
a
trav√©s
de
un
router
.


Un
datagrama
IP
enviado
desde
el
departamento
IE
al
departamento
CC
primero
atravesar√≠a


la
VLAN
IE
para
llegar
al
router
y
luego
ser√≠a
reenviado
por
el
router
por
la
VLAN
CC
hasta


el
host
de
CC
.
Afortunadamente
,
los
fabricantes
de
conmutadores
hacen
que
dicha
tarea
de


configuraci√≥n
resulte
sencilla
para
los
administradores
de
red
,
incorporando
en
un
√∫nico
dis-


positivo
un
conmutador
VLAN
y
un
router
,
con
lo
que
no
es
necesario
utilizar
un
router


externo
separado
.
En
uno
de
los
problemas
de
repaso
del
final
del
cap√≠tulo
se
examina
este


escenario
m√°s
en
detalle
.


Vo
l
v
a
m
o
s
 
d
e
 
n
u
e
v
o
 
a
 
l
a
 
F
i
g
u
r
a
 
5
.
2
6
.
 
S
u
p
o
n
g
a
 
a
h
o
r
a
 
q
u
e
 
e
n
 
l
u
g
a
r
 
d
e
 
t
e
n
e
r
 
u
n
 
d
e
p
a
r
t
a
-


mento
de
Ingenier√≠a
Inform√°tica
separado
,
algunos
de
los
acad√©micos
de
IE
y
CC
est√°n
alo-


jados
en
edificios
diferentes
,
donde
(
¬°
por
supuesto
!
)
necesitan
tener
acceso
a
la
red
y
(
¬°
por


supuesto
tambi√©n
!
)
desean
formar
parte
de
la
VLAN
de
su
departamento
.
La
Figura
5.31


muestra
un
segundo
conmutador
de
8
puertos
,
en
el
que
los
puertos
se
han
definido
como


pertenecientes
a
la
VLAN
IE
o
a
la
VLAN
CC
,
seg√∫n
sea
necesario
.
Pero
,
¬ø
c√≥mo
deben


interconectarse
estos
dos
conmutadores
?
Una
soluci√≥n
f√°cil
ser√≠a
definir
un
puerto
que
per-


teneciera
a
la
VLAN
CC
en
cada
conmutador
(
y
lo
mismo
para
la
VLAN
IE
)
y
conectar


estos
puertos
entre
s√≠
,
como
se
muestra
en
la
Figura
5.31(a
)
.
Sin
embargo
,
esta
soluci√≥n
no


es
escalable
,
ya
que
N
redes
VLAN
requerir√≠an
N
puertos
en
cada
conmutador
simplemente


para
interconectar
los
dos
conmutadores
.


Un
m√©todo
m√°s
escalable
consiste
en
interconectar
los
conmutadores
VLAN
utilizando


la
t√©cnica
conocida
como
troncalizaci√≥n
VLAN
(
VLAN
Trunking
)
.
Con
esta
t√©cnica
,
mos-


trada
en
la
Figura
 
5.31(b
)
,
un
puerto
especial
de
cada
conmutador
(
el
puerto
16
en
el
con-


mutador
de
la
izquierda
y
el
puerto
1
en
el
de
la
derecha
)
se
configura
como
un
puerto


468
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


1


Ingenier√≠a
El√©ctrica
(
IE
)


(
puertos
VLAN
2‚Äì8
)


Ciencias
de
la
Computaci√≥n
(
CC
)


(
puertos
VLAN
9‚Äì15
)


9
15


24
8
10
16


Figura
5.30
‚Ä¢
Un
mismo
conmutador
con
dos
redes
VLAN
configuradas
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
468troncal
para
interconectar
los
dos
conmutadores
VLAN
.
El
puerto
troncal
pertenece
a
todas


las
VLAN
y
las
tramas
enviadas
a
cualquier
VLAN
son
reenviadas
a
trav√©s
del
enlace
tron-


cal
hacia
el
otro
conmutador
.
Pero
esta
soluci√≥n
nos
conduce
a
otra
pregunta
:
¬ø
c√≥mo
sabe


un
conmutador
que
una
trama
que
ha
llegado
a
un
puerto
troncal
pertenece
a
una
VLAN


concreta
?
El
IEEE
ha
definido
un
formato
de
trama
Ethernet
ampliado
,
802.1Q
,
para
las
tra-


mas
que
atraviesan
un
enlace
troncal
VLAN
.
Como
se
muestra
en
la
Figura
5.32
,
la
trama


802.1Q
est√°
formada
por
la
trama
Ethernet
est√°ndar
m√°s
una
etiqueta
VLAN
de
cuatro


5.6
‚Ä¢
CONMUTADORES
DE
LA
CAPA
DE
ENLACE
469


1


16


1


8


1


Ingenier√≠a
El√©ctrica


(
puertos
VLAN
2‚Äì8
)


b.


a.


Ingenier√≠a
El√©ctrica


(
puertos
VLAN
2
,
3
,
6
)


Enlace


troncal


Ciencias
de
la
Computaci√≥n


(
puertos
VLAN
9‚Äì15
)


9
15


24
8
10
16


1


2


3


4


5


68


7


Ciencias
de
la
Computaci√≥n


(
puertos
VLAN
4
,
5
,
7
)


Figura
5.31
‚Ä¢
Conexi√≥n
de
dos
conmutadores
VLAN
con
dos
redes
VLAN
:


(
a
)
dos
cables
(
b
)
enlace
troncal
.


Pre√°mbulo
CRCDirecci√≥n


de
destino


Direcci√≥n


de
origen


Tipo


Datos


Pre√°mbulo
CRC'Direcci√≥n


de
destino


Direcci√≥n


de
origen


Tipo


Informaci√≥n
de
control
de
etiquetado


Identificador
de
protocolo
de
etiquetado


CRT


recalculado


Datos


Figura
5.32
‚Ä¢
Trama
Ethernet
original
(
arriba
)
,
trama
Ethernet
con
etiquetado


VLAN
802.1Q
(
abajo
)
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
469bytes
a√±adida
a
la
cabecera
que
transporta
la
identidad
de
la
VLAN
a
la
que
pertenece
la


trama
.
El
conmutador
del
lado
emisor
de
un
enlace
troncal
VLAN
a√±ade
la
etiqueta
VLAN


a
la
trama
,
la
cual
es
analizada
y
eliminada
por
el
conmutador
del
lado
receptor
del
enlace


troncal
.
La
etiqueta
VLAN
en
s√≠
consta
de
un
campo
Identificador
de
protocolo
de
etique-


tado
(
TPID
,
Tag
Protocol
Identifier
)
de
2
bytes
(
que
tiene
un
valor
hexadecimal
fijo
de
81-


00
)
,
un
campo
Informaci√≥n
de
control
de
etiquetado
(
Tag
Control
Information
)
de
2
bytes
,


que
contiene
un
campo
identificador
de
VLAN
de
12
bits
y
un
campo
de
prioridad
de
3
bits
,


cuya
finalidad
es
similar
a
la
del
campo
TOS
de
los
datagramas
IP
.


En
esta
exposici√≥n
hemos
hablado
muy
brevemente
de
las
redes
VLAN
y
nos
hemos


centrado
en
las
VLAN
basadas
en
puertos
.
Debemos
decir
tambi√©n
que
las
redes
VLAN
pue-


den
definirse
de
otras
formas
.
En
las
VLAN
basadas
en
direcciones
MAC
,
el
administrador


de
redes
especifica
el
conjunto
de
direcciones
MAC
que
pertenece
a
cada
VLAN
.
Cuando


un
dispositivo
se
conecta
a
un
puerto
,
el
puerto
se
conecta
a
la
VLAN
apropiada
bas√°ndose


en
la
direcci√≥n
MAC
del
dispositivo
.
Las
redes
VLAN
tambi√©n
pueden
definirse
bas√°ndose


en
protocolos
de
la
capa
de
red
(
como
por
ejemplo
,
IPv4
,
IPv6
o
Appletalk
)
y
en
otros
crite-


rios
.
Consulte
el
est√°ndar
802.1Q
[
IEEE
802.1q
2005
]
para
conocer
m√°s
detalles
.


5.7
PPP
:
Protocolo
punto
a
punto


Hasta
el
momento
gran
parte
de
nuestra
exposici√≥n
sobre
los
protocolos
de
la
capa
de
enlace


ha
estado
centrada
en
los
protocolos
para
los
canales
de
difusi√≥n
.
En
esta
secci√≥n
vamos
a


abordar
un
protocolo
de
la
capa
de
enlace
para
los
enlaces
punto
a
punto
:
PPP
,
el
protocolo


punto
a
punto
.
Puesto
que
PPP
es
t√≠picamente
el
protocolo
elegido
para
un
enlace
de
acceso


telef√≥nico
de
un
host
residencial
,
es
indudablemente
uno
de
los
protocolos
de
la
capa
de


enlace
m√°s
ampliamente
implantado
actualmente
.
El
otro
protocolo
de
la
capa
de
enlace


importante
en
uso
hoy
d√≠a
es
el
protocolo
HDLC
(
High-level
Data
Link
Control
)
;
consulte


[
Spragins
1991
]
si
desea
obtener
informaci√≥n
acerca
de
HDLC
.
Aqu√≠
,
nuestra
exposici√≥n


sobre
el
protocolo
PPP
m√°s
simple
nos
va
a
permitir
examinar
muchas
de
las
m√°s
importan-


tes
funcionalidades
de
un
protocolo
de
la
capa
de
enlace
punto
a
punto
.


Como
su
nombre
implica
,
el
protocolo
punto
a
punto
PPP
[
RFC
1661
;
RFC
2153
]
es
un


protocolo
de
la
capa
de
enlace
que
opera
sobre
un
enlace
punto
a
punto
:
un
enlace
que


conecta
directamente
dos
nodos
situados
cada
uno
de
ellos
en
un
extremo
del
enlace
.
El


enlace
punto
a
punto
sobre
el
que
PPP
opera
puede
ser
una
l√≠nea
telef√≥nica
serie
(
por
ejem-


plo
,
una
conexi√≥n
por
m√≥dem
de
56
K
)
,
un
enlace
SONET
/
SDH
,
una
conexi√≥n
X.25
o
un


circuito
RDSI
.
Como
ya
hemos
mencionado
,
PPP
suele
ser
el
protocolo
elegido
por
los
usua-


rios
dom√©sticos
para
conectarse
con
sus
ISP
a
trav√©s
de
una
conexi√≥n
de
acceso
telef√≥nico
.


Antes
de
profundizar
en
los
detalles
de
PPP
,
es
interesante
examinar
los
requisitos
ori-


ginales
que
el
IETF
estableci√≥
para
el
dise√±o
de
PPP
[
RFC
1547
]
:


‚Ä¢
Entramado
de
paquetes
.
El
emisor
de
la
capa
de
enlace
del
protocolo
PPP
tiene
que


poder
tomar
un
paquete
del
nivel
de
red
y
encapsularlo
dentro
de
la
trama
de
la
capa


de
enlace
PPP
de
tal
modo
que
el
receptor
sea
capaz
de
identificar
el
inicio
y
el
final


tanto
de
la
trama
de
la
capa
de
enlace
como
del
paquete
de
la
capa
de
red
contenido


en
ella
.


‚Ä¢
Transparencia
.
El
protocolo
PPP
no
debe
aplicar
ninguna
restricci√≥n
a
los
datos
que
apa-


recen
en
el
paquete
de
la
capa
de
red
(
ni
a
las
cabeceras
ni
a
los
datos
)
.
Por
ejemplo
,
PPP


470
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
470no
puede
prohibir
el
uso
de
ciertos
patrones
de
bits
en
el
paquete
de
la
capa
de
red
.
V
ol-


veremos
sobre
este
tema
enseguida
cuando
hablemos
del
rellenado
de
bytes
.


‚Ä¢
M√∫ltiples
protocolos
de
la
capa
de
red
.
El
protocolo
PPP
tiene
que
poder
dar
soporte
a


m√∫ltiples
protocolos
de
la
capa
de
red
(
por
ejemplo
,
IP
y
DECnet
)
que
se
ejecuten
sobre


el
mismo
enlace
f√≠sico
de
forma
simult√°nea
.
Del
mismo
modo
que
se
necesita
el
proto-


colo
IP
para
multiplexar
diferentes
protocolos
de
la
capa
de
transporte
(
por
ejemplo
,
TCP


y
UDP
)
sobre
una
√∫nica
conexi√≥n
terminal
a
terminal
,
tambi√©n
PPP
tiene
que
ser
capaz


de
multiplexar
diferentes
protocolos
de
la
capa
de
red
sobre
una
√∫nica
conexi√≥n
punto
a


punto
.
Este
requisito
quiere
decir
que
,
como
m√≠nimo
,
probablemente
PPP
requerir√°
un


campo
de
tipo
de
protocolo
o
alg√∫n
mecanismo
similar
para
que
el
PPP
del
lado
receptor


pueda
demultiplexar
una
trama
recibida
en
el
protocolo
de
la
capa
de
red
apropiado
.


‚Ä¢
M√∫ltiples
tipos
de
enlaces
.
Adem√°s
de
poder
transportar
m√∫ltiples
protocolos
de
nivel


superior
,
PPP
tambi√©n
tiene
que
poder
operar
sobre
una
amplia
variedad
de
tipos
de
enla-


ces
,
incluyendo
enlaces
serie
(
que
transmiten
un
bit
cada
vez
en
una
direcci√≥n
dada
)
o


paralelo
(
que
transmiten
bits
en
paralelo
)
,
enlaces
s√≠ncronos
(
que
transmiten
una
se√±al
de


reloj
junto
con
los
bits
de
datos
)
o
as√≠ncronos
,
enlaces
de
baja
velocidad
o
de
alta
veloci-


dad
,
o
enlaces
el√©ctricos
u
√≥pticos
.


‚Ä¢
Detecci√≥n
de
errores
.
Un
receptor
PPP
tiene
que
ser
capaz
de
detectar
errores
de
bit
en


las
tramas
recibidas
.


‚Ä¢
Pervivencia
de
la
conexi√≥n
.
PPP
tiene
que
ser
capaz
de
detectar
un
fallo
en
el
nivel
de


enlace
(
por
ejemplo
,
la
incapacidad
para
transferir
datos
desde
el
lado
emisor
del
enlace


al
lado
receptor
del
mismo
)
y
de
se√±alar
esa
condici√≥n
de
error
a
la
capa
de
red
.


‚Ä¢
Negociaci√≥n
de
direcciones
de
la
capa
de
red
.
PPP
tiene
que
proporcionar
un
mecanismo


para
que
las
capas
de
red
(
por
ejemplo
,
IP
)
que
se
est√°n
comunicando
puedan
aprender
o


configurar
las
direcciones
de
la
capa
de
red
de
cada
una
de
ellas
.


‚Ä¢
Simplicidad
.
Se
requiri√≥
que
PPP
cumpliera
una
serie
de
requisitos
adicionales
adem√°s


de
los
que
acabamos
de
enumerar
.
El
primero
y
m√°s
importante
de
todos
ellos
es
la
sim-


plicidad
.
El
documento
RFC
1547
establece
que
‚Äú
El
lema
de
un
protocolo
punto
a
punto


debe
ser
la
simplicidad
.
‚Äù
¬°
Una
orden
muy
estricta
,
teniendo
en
cuenta
todos
los
dem√°s


requisitos
definidos
para
el
dise√±o
de
PPP
!
Aproximadamente
100
documentos
RFC


definen
ahora
los
distintos
aspectos
de
este
protocolo
‚Äú
simple
‚Äù
.


Aunque
puede
parecer
que
son
demasiados
los
requisitos
impuestos
al
dise√±o
de
PPP
,
la


situaci√≥n
podr√≠a
haber
sido
realmente
m√°s
dif√≠cil
.
Las
especificaciones
de
dise√±o
de
PPP


tambi√©n
indican
de
forma
expl√≠cita
las
funcionalidades
de
protocolo
que
PPP
no
requer√≠a


implementar
:


‚Ä¢
Correcci√≥n
de
errores
.
Se
requiere
que
PPP
detecte
los
errores
de
bit
pero
no
se
requiere


que
los
corrija
.


‚Ä¢
Control
de
flujo
.
Se
espera
que
un
receptor
PPP
sea
capaz
de
recibir
tramas
a
la
veloci-


dad
m√°xima
de
la
capa
f√≠sica
subyacente
.
Si
una
capa
superior
no
puede
recibir
paquetes


a
esa
velocidad
m√°xima
,
entonces
es
responsabilidad
de
la
capa
superior
el
eliminar


paquetes
o
regular
al
emisor
en
la
capa
superior
.
Es
decir
,
en
lugar
de
que
el
propio
emi-


sor
PPP
regule
su
velocidad
de
transmisi√≥n
,
es
responsabilidad
de
un
protocolo
de
nivel


superior
el
regular
la
velocidad
a
la
que
los
paquetes
son
entregados
a
PPP
para
su
trans-


misi√≥n
.


5.7
‚Ä¢
PPP
:
PROTOCOLO
PUNTO
A
PUNTO
471


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
471‚Ä¢
Secuenciamiento
.
No
se
requiere
que
PPP
entregue
las
tramas
al
receptor
en
el
mismo


orden
en
que
fueron
enviadas
por
el
emisor
.
Es
interesante
observar
que
aunque
esta
fle-


xibilidad
es
compatible
con
el
modelo
de
servicio
de
IP
(
que
permite
que
los
paquetes
IP


sean
entregados
terminal
a
terminal
en
cualquier
orden
)
,
otros
protocolos
de
la
capa
de


red
que
operan
sobre
PPP
requieren
una
entrega
de
paquetes
terminal
a
terminal
en


secuencia
.


‚Ä¢
Enlaces
multipunto
.
PPP
s√≥lo
necesita
operar
sobre
enlaces
que
tienen
un
√∫nico
emisor
y


un
√∫nico
receptor
.
Otros
protocolos
de
la
capa
de
enlace
,
como
HDLC
,
pueden
acomodar


varios
receptores
en
un
enlace
(
por
ejemplo
,
un
escenario
tipo
Ethernet
)
.


Una
vez
vistos
los
objetivos
de
dise√±o
(
y
los
no
objetivos
)
de
PPP
,
pasemos
a
ver
c√≥mo
cum-


ple
el
dise√±o
de
PPP
dichos
objetivos
.


5.7.1
Trama
de
datos
PPP


La
Figura
5.33
muestra
una
trama
de
datos
PPP
que
utiliza
un
entramado
tipo
HDLC
[
RFC


1662
]
.
La
trama
PPP
consta
de
los
campos
siguientes
:


‚Ä¢
Campo
Indicador
.
Todas
las
tramas
PPP
comienzan
y
terminan
con
un
campo
indicador


de
1
byte
,
cuyo
valor
es
01111110
.


‚Ä¢
Campo
de
direcci√≥n
.
El
√∫nico
valor
posible
en
este
campo
es
11111111
.


‚Ä¢
Campo
de
control
.
El
√∫nico
valor
posible
en
este
campo
es
00000011
.
Puesto
que
los


campos
de
direcci√≥n
y
de
control
s√≥lo
pueden
tomar
un
valor
fijo
,
es
posible
que
se
est√©


preguntando
por
qu√©
se
han
definido
dichos
campos
.
La
especificaci√≥n
de
PPP
[
RFC


1662
]
establece
que
otros
valores
‚Äú
pueden
ser
definidos
m√°s
adelante
‚Äù
,
aunque
no
se
ha


definido
ninguno
hasta
la
fecha
.
Dado
que
estos
valores
toman
valores
fijos
,
PPP
permite


al
emisor
no
enviar
los
bytes
de
direcci√≥n
y
de
control
,
ahorrando
as√≠
2
bytes
de
sobre-


carga
en
la
trama
PPP
.


‚Ä¢
Protocolo
.
El
campo
protocolo
indica
al
receptor
PPP
el
protocolo
de
la
capa
superior
al


que
pertenecen
los
datos
encapsulados
recibidos
(
es
decir
,
el
contenido
del
campo
de


informaci√≥n
de
la
trama
PPP
)
.
Al
recibir
una
trama
PPP
,
el
receptor
PPP
comprobar√°
si
la


trama
es
correcta
y
luego
pasar√°
los
datos
encapsulados
al
protocolo
apropiado
.
Los


documentos
RFC
1700
y
RFC
3232
definen
los
c√≥digos
de
protocolo
de
16
bits
utiliza-


dos
por
PPP
.
A
nosotros
nos
interesa
el
protocolo
IP
(
es
decir
,
los
datos
encapsulados
en


la
trama
PPP
forman
un
datagrama
IP
)
,
el
cual
tiene
un
valor
hexadecimal
de
21
;
aunque


tambi√©n
pueden
emplearse
otros
protocolos
de
la
capa
de
red
como
AppleTalk
,
que
tiene


el
valor
29
,
y
el
protocolo
DECnet
,
que
tiene
el
valor
27
.


472
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


01111110
0111111011111111
00000011
Protocolo


Indicador
IndicadorDirecci√≥n
Control


Info
Comprobac
.


1
111
1
o
2


Longitud


variable
2
o
4


Figura
5.33
‚Ä¢
Formato
de
la
trama
de
datos
PPP
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
472‚Ä¢
Informaci√≥n
.
Este
campo
contiene
el
paquete
(
datos
)
encapsulado
que
est√°
siendo
envia-


do
por
un
protocolo
de
la
capa
superior
(
por
ejemplo
,
IP
)
sobre
el
enlace
PPP
.
La
longi-


tud
m√°xima
predeterminada
de
este
campo
es
1.500
bytes
,
aunque
como
veremos
m√°s


adelante
este
valor
puede
cambiarse
cuando
se
configura
el
enlace
por
primera
vez
.


‚Ä¢
Suma
de
comprobaci√≥n
.
El
campo
de
suma
de
comprobaci√≥n
se
utiliza
para
detectar
erro-


res
de
bit
en
una
trama
transmitida
.
Se
emplea
un
c√≥digo
de
redundancia
c√≠clica
est√°ndar


HDLC
de
2
o
4
bytes
.


Rellenado
de
bytes


Antes
de
terminar
nuestra
exposici√≥n
acerca
de
las
tramas
PPP
,
consideremos
un
problema


que
surge
cuando
cualquier
protocolo
utiliza
un
patr√≥n
de
bits
espec√≠fico
en
un
campo
indica-


dor
para
marcar
el
principio
o
el
final
de
la
trama
.
¬ø
Qu√©
ocurre
si
el
patr√≥n
indicador
aparece


en
cualquier
posici√≥n
del
paquete
?
Por
ejemplo
,
¬ø
qu√©
ocurre
si
el
valor
del
campo
indicador


01111110
aparece
en
el
campo
de
informaci√≥n
?
¬ø
Detectar√°
el
receptor
incorrectamente
el


final
de
la
trama
PPP
?


Una
forma
de
resolver
este
problema
ser√≠a
que
PPP
prohibiera
al
protocolo
de
la
capa


superior
que
enviara
datos
que
contuvieran
el
patr√≥n
de
bits
del
campo
indicador
.
El
requi-


sito
de
transparencia
de
PPP
mencionado
anteriormente
elimina
esta
posibilidad
.
Una
solu-


ci√≥n
alternativa
,
que
es
la
que
emplea
PPP
y
otros
muchos
protocolos
,
consiste
en
utilizar


una
t√©cnica
conocida
como
rellenado
de
bytes
.


PPP
define
un
byte
especial
de
escape
de
control
,
01111101
.
Si
la
secuencia
del
indica-


dor
,
01111110
,
aparece
en
cualquier
posici√≥n
de
la
trama
,
excepto
en
el
campo
indicador
,
PPP


precede
dicha
aparici√≥n
del
patr√≥n
indicador
con
el
byte
de
escape
de
control
.
Es
decir
,


‚Äú
rellena
‚Äù
(
a√±ade
)
con
un
byte
de
escape
de
control
el
flujo
de
datos
transmitidos
que
precede


a
01111110
,
con
el
fin
de
indicar
que
el
siguiente
011111110
no
es
un
valor
de
indicador
sino


que
son
datos
reales
.
Por
supuesto
,
un
receptor
que
ve
una
secuencia
01111110
precedida
por


01111101
eliminar√°
el
byte
de
escape
de
control
a√±adido
para
reconstruir
los
datos
originales
.


De
forma
similar
,
si
el
propio
patr√≥n
de
bits
del
byte
de
escape
de
control
aparece
como
datos


reales
,
tambi√©n
deber√°
antepon√©rsele
el
byte
de
escape
de
control
de
relleno
.
Por
tanto
,


cuando
el
receptor
ve
un
√∫nico
byte
de
escape
de
control
en
el
flujo
de
datos
,
sabe
que
el
byte


fue
a√±adido
al
flujo
de
datos
.
Dos
bytes
de
escape
de
control
seguidos
quieren
decir
que
uno


de
ellos
pertenece
a
los
datos
originales
que
est√°n
siendo
enviados
.
La
Figura
5.34
ilustra
la


t√©cnica
de
relleno
de
bytes
de
PPP
.
(
Realmente
,
PPP
tambi√©n
aplica
una
operaci√≥n
XOR
con


5.7
‚Ä¢
PPP
:
PROTOCOLO
PUNTO
A
PUNTO
473


b5


b4


01111110


b2


b1


b5
b4
01111110
01111
101
b2
b1


b1


b2


01111110


b4


b5


PPP
PPP


Figura
5.34
‚Ä¢
Rellenado
de
bytes
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
473el
hexadecimal
20
al
byte
de
datos
al
que
le
precede
el
byte
de
escape
,
un
detalle
que
hemos


omitido
para
simplificar
la
exposici√≥n
.
)


Debemos
comentar
tambi√©n
que
PPP
tiene
un
Protocolo
de
control
de
enlace
(
LCP
,
Link


Control
Protocol
)
,
cuyo
trabajo
consiste
en
llevar
a
cabo
la
inicializaci√≥n
,
el
mantenimiento


y
el
cierre
de
un
enlace
PPP
.
LCP
se
estudia
con
cierto
detalle
en
el
material
en
l√≠nea
aso-


ciado
con
el
libro
.


5.8
Virtualizaci√≥n
de
enlaces
:
la
red
como
una
capa


de
enlace


Puesto
que
este
cap√≠tulo
est√°
relacionado
con
los
protocolos
de
la
capa
de
enlace
,
y
dado
que


estamos
aproxim√°ndonos
al
final
del
cap√≠tulo
,
vamos
a
reflexionar
acerca
del
modo
en
que


ha
evolucionado
nuestra
compresi√≥n
acerca
del
t√©rmino
enlace
.
Al
comenzar
el
cap√≠tulo
,


contempl√°bamos
los
enlaces
como
cables
f√≠sicos
que
conectaban
dos
hosts
que
se
comunica-


ban
entre
s√≠
,
como
se
ilustraba
en
la
Figura
5.2
.
Al
estudiar
los
protocolos
de
acceso
m√∫ltiple


(
Figura
5.9
)
,
hemos
visto
que
pod√≠an
conectarse
varios
hosts
mediante
un
cable
compartido


y
que
el
‚Äú
cable
‚Äù
que
conectaba
esos
hosts
pod√≠a
ser
un
espectro
de
radio
u
otro
medio
de


comunicaci√≥n
.
Esto
nos
llev√≥
a
considerar
el
enlace
en
forma
algo
m√°s
abstracta
como
un


canal
m√°s
que
como
un
cable
.
En
nuestro
estudio
de
las
redes
LAN
Ethernet
(
Figuras
5.26
y


5.31
)
,
hemos
visto
que
los
medios
de
interconexi√≥n
pod√≠an
ser
,
de
hecho
,
una
infraestructura


conmutada
bastante
compleja
.
Sin
embargo
,
a
todo
lo
largo
de
esta
evoluci√≥n
,
los
propios


hosts
manten√≠an
la
visi√≥n
de
que
el
medio
de
interconexi√≥n
era
simplemente
un
canal
de
la


capa
enlace
que
conectaba
dos
o
m√°s
hosts
.
Vimos
,
por
ejemplo
,
que
un
host
 
Ethernet
pod√≠a


ser
afortunadamente
inconsciente
de
si
estaba
conectado
a
los
hosts
de
otra
LAN
mediante


un
√∫nico
segmento
LAN
de
corto
alcance
(
Figura
5.9
)
o
por
una
LAN
conmutada
geogr√°fi-


camente
dispersa
(
Figura
5.26
)
o
mediante
una
VLAN
(
Figura
5.31
)
.


En
la
Secci√≥n
5.7
hemos
visto
que
el
protocolo
PPP
se
emplea
a
menudo
sobre
una


conexi√≥n
v√≠a
m√≥dem
entre
dos
hosts
.
En
este
caso
,
el
enlace
que
conecta
los
dos
hosts
es


realmente
la
red
telef√≥nica
:
una
red
global
de
telecomunicaciones
,
l√≥gicamente
separada
,


con
sus
propios
conmutadores
,
enlaces
y
pilas
de
protocolos
para
la
transferencia
de
datos
y


la
se√±alizaci√≥n
.
Sin
embargo
,
desde
el
punto
de
vista
de
la
capa
de
enlace
de
Internet
,
la


conexi√≥n
de
acceso
telef√≥nico
a
trav√©s
de
la
red
de
telefon√≠a
es
contemplada
como
un
sim-


ple
‚Äú
cable
‚Äù
.
En
este
sentido
,
Internet
virtualiza
la
red
telef√≥nica
vi√©ndola
como
una
tecnolo-


g√≠a
de
la
capa
de
enlace
que
proporciona
conectividad
de
dicha
capa
entre
dos
hosts
de


Internet
.
Recordemos
,
de
nuestro
an√°lisis
de
las
redes
solapadas
en
el
Cap√≠tulo
2
,
que
de


forma
similar
las
redes
solapadas
ven
Internet
como
un
medio
de
proporcionar
conectividad


entre
los
nodos
solapados
,
buscando
un
solapamiento
de
Internet
de
la
misma
manera
que


Internet
solapa
la
red
telef√≥nica
.


En
esta
secci√≥n
vamos
a
abordar
las
redes
de
Conmutaci√≥n
de
etiquetas
multiprotocolo


(
MPLS
,
Multiprotocol
Label
Switching
)
.
A
diferencia
de
la
red
telef√≥nica
de
conmutaci√≥n


de
circuitos
,
MPLS
es
una
red
de
circuitos
virtuales
de
conmutaci√≥n
de
paquetes
de
ple-


no
derecho
.
Tiene
sus
propios
formatos
de
paquete
y
comportamientos
de
reenv√≠o
.
Por
tanto
,


desde
el
punto
de
vista
pedag√≥gico
,
el
an√°lisis
de
MPLS
encaja
bien
en
un
estudio
de
la


capa
de
red
o
de
la
capa
de
enlace
.
Sin
embargo
,
desde
el
punto
de
vista
de
Internet
,
pode-


mos
considerar
MPLS
,
al
igual
que
la
red
telef√≥nica
y
las
redes
Ethernet
conmutadas
,
como


474
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
474una
tecnolog√≠a
de
la
capa
de
enlace
que
sirve
para
interconectar
dispositivos
IP
.
Por
tanto
,


hemos
incluido
MPLS
en
nuestro
estudio
de
la
capa
de
enlace
.
Las
redes
Frame-Relay
y


ATM
tambi√©n
pueden
emplearse
para
interconectar
dispositivos
IP
,
aunque
representan
una


tecnolog√≠a
algo
m√°s
antigua
(
aunque
todav√≠a
con
implantaci√≥n
)
,
de
modo
que
no
cubrire-


mos
esas
redes
aqu√≠
.
Puede
ver
m√°s
detalles
en
el
libro
de
[
Goralski
1999
]
.
Nuestro
trata-


miento
de
MPLS
ser√°
necesariamente
breve
,
ya
que
podr√≠an
escribirse
(
y
se
han
escrito
)


libros
completos
sobre
estas
redes
.
Le
recomendamos
que
lea
[
Davie
2000
]
para
conocer


m√°s
detalles
sobre
MPLS
.
Aqu√≠
nos
centraremos
principalmente
en
el
modo
en
que
los
ser-


vidores
MPLS
se
interconectan
con
los
dispositivos
IP
,
aunque
tambi√©n
profundizaremos


algo
m√°s
en
las
tecnolog√≠as
subyacentes
.


Conmutaci√≥n
de
etiquetas
multiprotocolo
(
MPLS
)


La
conmutaci√≥n
de
etiquetas
multiprotocolo
(
MPLS
)
ha
evolucionado
a
partir
de
una
serie


de
desarrollos
industriales
que
tuvieron
lugar
a
mediados
y
finales
de
la
d√©cada
de
1990
y


que
buscaban
mejorar
la
velocidad
de
reenv√≠o
de
los
routers
IP
,
adoptando
un
concepto
clave


del
mundo
de
las
redes
de
circuitos
virtuales
:
una
etiqueta
de
longitud
fija
.
El
objetivo
no


era
 
abandonar
la
infraestructura
de
reenv√≠o
de
datagramas
IP
basada
en
el
destino
,
sustitu-


y√©ndola
por
otra
basada
en
etiquetas
de
longitud
fija
y
circuitos
virtuales
,
sino
expandir
la


infraestructura
existente
etiquetando
selectivamente
los
datagramas
y
permitiendo
a
los
rou-


ters
reenviar
esos
datagramas
bas√°ndose
en
etiquetas
de
longitud
fija
(
en
lugar
de
en
direc-


ciones
IP
de
destino
)
,
siempre
que
fuera
posible
.
Es
importante
observar
que
estas
t√©cnicas


funcionan
mano
a
mano
con
IP
,
utilizando
el
direccionamiento
y
el
enrutamiento
IP
.
El
IETF


unific√≥
estos
esfuerzos
mediante
el
protocolo
MPLS
[
RFC
3031
,
RFC
3032
]
,
consiguiendo


as√≠
mezclar
de
forma
efectiva
las
t√©cnicas
de
circuitos
virtuales
en
una
red
de
datagramas


enrutados
.


Comencemos
nuestro
estudio
sobre
MPLS
considerando
el
formato
de
una
trama
de
la


capa
de
enlace
gestionada
por
un
router
compatible
con
MPLS
.
La
Figura
5.35
muestra
que


una
trama
de
la
capa
de
enlace
transmitida
a
trav√©s
de
un
enlace
PPP
o
red
LAN
(
como
por


ejemplo
Ethernet
)
tiene
una
cabecera
MPLS
peque√±a
,
que
se
a√±ade
entre
la
cabecera
de
la


capa
2
(
es
decir
,
PPP
o
Ethernet
)
y
la
cabecera
de
la
capa
3
(
es
decir
,
IP
)
.
El
documento
RFC


3032
define
el
formato
de
la
cabecera
MPLS
para
tales
enlaces
;
en
otros
RFC
se
definen


tambi√©n
las
cabeceras
para
las
redes
ATM
y
Frame-Relay
.
Entre
los
campos
de
la
cabecera


MPLS
se
encuentran
la
etiqueta
(
que
desempe√±a
el
papel
del
identificador
de
circuito
virtual


que
hemos
visto
en
la
Secci√≥n
4.2.1
)
;
3
bits
reservados
para
su
uso
experimental
;
un
√∫nico


bit
S
,
que
se
utiliza
para
indicar
el
final
de
una
serie
de
cabeceras
MPLS
‚Äú
apiladas
‚Äù
(
un
tema


avanzado
del
que
no
hablaremos
aqu√≠
)
y
un
campo
de
tiempo
de
vida
.


5.8
‚Ä¢
VIRTUALIZACI√ìN
DE
ENLACES
:
LA
RED
COMO
UNA
CAPA
DE
ENLACE
475


Cabecera
PPP


o
Ethernet
Cabecera
MPLS
Cabecera
IP
Resto
de
la
trama


de
la
capa
de
enlace


Etiqueta
Exp
S
TTL


Figura
5.35
‚Ä¢
Cabecera
MPLS
:
se
localiza
entre
las
cabeceras
de
la
capa
de


enlace
y
de
la
capa
de
red
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
475Es
evidente
de
manera
inmediata
,
a
partir
de
la
Figura
5.35
,
que
una
trama
ampliada


MPLS
s√≥lo
puede
intercambiarse
entre
routers
compatibles
con
MPLS
(
dado
que
un
router


no
compatible
con
MPLS
se
quedar√≠a
bastante
confundido
al
encontrar
una
cabecera
MPLS


donde
esperaba
encontrar
la
cabecera
IP
)
.
Los
routers
compatibles
con
MPLS
se
suelen


denominar
routers
de
conmutaci√≥n
de
etiquetas
,
ya
que
reenv√≠an
las
tramas
MPLS
bus-


cando
la
etiqueta
MPLS
en
su
tabla
de
reenv√≠o
y
luego
pasando
inmediatamente
el
data-


grama
a
la
interfaz
de
salida
apropiada
.
Por
tanto
,
el
router
compatible
con
MPLS
no


necesita
extraer
la
direcci√≥n
IP
de
destino
y
realizar
una
b√∫squeda
del
prefijo
con
la
coinci-


dencia
m√°s
larga
dentro
de
la
tabla
de
reenv√≠o
.
Pero
,
¬ø
c√≥mo
sabe
un
router
si
su
vecino
es


compatible
con
MPLS
y
c√≥mo
sabe
qu√©
etiqueta
asociar
con
la
direcci√≥n
IP
de
destino
indi-


cada
?
Para
responder
a
estas
preguntas
,
necesitamos
examinar
la
interacci√≥n
entre
un
grupo


de
routers
compatibles
con
MPLS
.


En
el
ejemplo
de
la
Figura
5.36
los
routers
R1
a
R4
son
compatibles
con
MPLS
.
Los


routers
R5
y
R6
son
routers
IP
est√°ndar
.
R1
ha
anunciado
a
R2
y
a
R3
que
puede
enrutar


hacia
el
destino
A
y
que
una
trama
recibida
con
una
etiqueta
MPLS
igual
a
6
ser√°
reenviada


al
destino
A.
El
router
R3
ha
anunciado
al
router
R4
que
puede
realizar
el
enrutamiento


hacia
los
destinos
A
y
D
,
y
que
las
tramas
entrantes
con
etiquetas
MPLS
de
valor
10
y
12
,


respectivamente
,
ser√°n
conmutadas
hacia
esos
destinos
.
El
router
R2
tambi√©n
ha
anunciado


al
router
R4
que
puede
alcanzar
el
destino
A
y
que
una
trama
recibida
con
la
etiqueta
MPLS


de
valor
8
ser√°
conmutada
hacia
A.
Observe
que
ahora
el
router
R4
se
encuentra
en
la
intere-


sante
situaci√≥n
de
tener
dos
rutas
MPLS
para
llegar
a
A
:
a
trav√©s
de
la
interfaz
0
con
etiqueta


MPLS
saliente
igual
a
10
,
y
a
trav√©s
de
la
interfaz
1
con
etiqueta
MPLS
igual
a
8
.
El
cuadro


general
de
la
estructura
de
red
mostrada
en
la
Figura
5.36
es
que
los
dispositivos
IP
R5
,
R6
,


Ay
 
D
 
e
s
t
√°
n
 
i
n
t
e
r
c
o
n
e
c
t
a
d
o
s
 
a
 
t
r
a
v
√©
s
 
d
e
 
u
n
a
 
i
n
f
r
a
e
s
t
r
u
c
t
u
r
a
 
M
P
L
S
 
(
l
o
s
 
r
o
u
t
e
r
s
 
c
o
m
p
a
t
i
b
l
e
s


con
MPLS
R1
,
R2
,
R3
y
R4
)
,
de
forma
muy
similar
a
como
pueden
conectarse
entre
s√≠
diver-


sos
dispositivos
IP
mediante
una
red
ATM
o
una
LAN
conmutada
.
Y
al
igual
que
sucede
con


476
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


R4


etiqueta


de
entrada


etiqueta


de
salida


10


12


8


A


D


A


0


0


1


destino
interfaz


de
salida


R6


R5


R3


R2


D


A


0


00


11


0


R1


etiqueta


de
entrada


etiqueta


de
salida


6


9


A


D


1


0


10


12


destino
interfaz


de
salida


etiqueta


de
entrada


etiqueta


de
salida


‚Äì
A
06


destino
interfaz


de
salida


etiqueta


de
entrada


etiqueta


de
salida


6A
08


destino
interfaz


de
salida


Figura
5.36
‚Ä¢
Reenv√≠o
mejorado
mediante
MPLS
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
476una
red
ATM
o
una
LAN
conmutada
,
los
routers
R1
a
R4
compatibles
con
MPLS
se
encar-


gan
de
realizar
esa
conmutaci√≥n
sin
ni
siquiera
tocar
la
cabecera
IP
de
los
paquetes
.


En
nuestra
exposici√≥n
anterior
no
hemos
especificado
el
protocolo
concreto
que
se
uti-


liza
para
distribuir
las
etiquetas
entre
los
routers
compatibles
con
MPLS
,
ya
que
los
detalles


de
este
tipo
de
se√±alizaci√≥n
caen
fuera
del
alcance
del
libro
.
Sin
embargo
,
tenemos
que
dejar


constancia
de
que
el
grupo
de
trabajo
de
IETF
dedicado
a
MPLS
ha
especificado
en
[
RFC


3468
]
que
el
centro
de
sus
esfuerzos
dentro
del
campo
de
la
se√±alizaci√≥n
de
MPLS
ser√°
una


extensi√≥n
del
protocolo
RSVP
(
que
estudiaremos
en
el
Cap√≠tulo
7
)
,
conocida
como
RSVP-


TE
[
RFC
3209
]
.
Por
tanto
,
el
lector
interesado
puede
consultar
el
documento
RFC
3209
.


Hasta
ahora
,
el
√©nfasis
de
nuestro
estudio
sobre
MPLS
se
han
centrado
en
el
hecho
de


que
MPLS
realiza
la
conmutaci√≥n
bas√°ndose
en
etiquetas
,
sin
necesidad
de
considerar
la


direcci√≥n
IP
de
un
paquete
.
Las
verdaderas
ventajas
de
MPLS
y
la
raz√≥n
del
actual
inter√©s


en
este
tipo
de
tecnolog√≠a
radica
,
sin
embargo
,
no
en
los
potenciales
aumentos
de
las
veloci-


dades
de
conmutaci√≥n
,
sino
m√°s
bien
en
las
nuevas
capacidades
de
gesti√≥n
del
tr√°fico
que


MPLS
posibilita
.
Como
ya
hemos
indicado
,
R4
dispone
de
dos
rutas
MPLS
hacia
A.
Si
el


reenv√≠o
se
realizara
m√°s
arriba
,
en
la
capa
IP
,
bas√°ndose
en
la
direcci√≥n
IP
,
los
protocolos
de


enrutamiento
IP
que
hemos
estudiado
en
el
Cap√≠tulo
4
especificar√≠an
solamente
una
√∫nica


ruta
de
coste
m√≠nimo
hacia
A.
Por
tanto
,
MPLS
proporciona
la
capacidad
de
reenviar
paque-


tes
a
trav√©s
de
rutas
que
no
ser√≠an
posibles
utilizando
los
protocolos
de
enrutamiento
IP


est√°ndar
.
√âste
es
un
tipo
simple
de
ingenier√≠a
de
tr√°ficoutilizando
MPLS
[
RFC
3346
;
RFC


3272
;
RFC
2702
;
Xiao
2000
]
,
mediante
el
que
un
operador
de
red
puede
anular
el
enruta-


miento
IP
normal
y
forzar
a
que
parte
del
tr√°fico
dirigido
hacia
un
cierto
destino
tome
una


determinada
ruta
,
mientras
que
el
resto
del
tr√°fico
dirigido
a
ese
mismo
destino
sigue


una
ruta
distinta
(
bien
por
razones
de
pol√≠tica
,
de
rendimiento
o
de
alg√∫n
otro
tipo
)
.


Tambi√©n
se
puede
utilizar
MPLS
para
muchos
otros
prop√≥sitos
.
Puede
emplearse
para


llevar
a
cabo
una
restauraci√≥n
r√°pida
de
las
rutas
de
reenv√≠o
de
MPLS
;
por
ejemplo
,
para


volver
a
enrutar
el
tr√°fico
a
trav√©s
de
una
ruta
de
reserva
precalculada
como
respuesta
a
un


fallo
de
un
enlace
[
Kar
2000
;
Huang
2002
;
RFC
3469
]
.
MPLS
tambi√©n
se
puede
emplear


para
implementar
el
marco
de
trabajo
de
servicio
diferenciado
que
estudiaremos
en
el
Cap√≠-


tulo
7
.
Por
√∫ltimo
,
digamos
que
MPLS
puede
utilizarse
(
y
de
hecho
se
ha
utilizado
)
para


implementar
las
denominadas
redes
privadas
virtuales
(
VPN
,
Virtual
Private
Network
)
.


Al
implementar
una
VPN
para
un
cliente
,
un
ISP
utiliza
su
red
compatible
con
 
MPLS
para


conectar
entre
s√≠
las
diversas
redes
del
cliente
.
MPLS
puede
emplearse
para
aislar
tanto
los


recursos
como
el
direccionamiento
empleados
por
la
VPN
del
cliente
con
respecto
a
los
de


otros
usuarios
que
tambi√©n
tengan
que
atravesar
la
red
del
ISP
;
consulte
 
[
DeClercq
2002
]


para
ver
m√°s
detalles
.


Nuestra
exposici√≥n
acerca
de
MPLS
ha
sido
necesariamente
breve
y
animamos
al
lector


a
consultar
las
referencias
mencionadas
.
Hay
que
destacar
que
,
con
tantos
posibles
usos
de


MPLS
,
este
protocolo
parece
estar
convirti√©ndose
r√°pidamente
en
la
‚Äú
navaja
multiusos
‚Äù
de


la
ingenier√≠a
de
tr√°fico
en
Internet
.


5.9
Un
d√≠a
en
la
vida
de
una
solicitud
de
p√°gina
web


Ahora
que
ya
hemos
cubierto
el
tema
de
la
capa
de
enlace
en
este
cap√≠tulo
,
y
las
capas
de


red
,
de
transporte
y
de
aplicaci√≥n
en
los
anteriores
,
nuestro
viaje
de
descenso
por
la
pila


de
protocolos
est√°
completo
.
Al
principio
del
libro
(
Secci√≥n
1.1
)
,
dec√≠amos
que
‚Äú
buena


5.9
‚Ä¢
UN
D√çA
EN
LA
VIDA
DE
UNA
SOLICITUD
DE
P√ÅGINA
WEB
477


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
477parte
de
este
libro
est√°
relacionada
con
los
protocolos
de
las
redes
de
computadoras
‚Äù
,
y
en


los
primeros
cinco
cap√≠tulo
hemos
visto
que
es
as√≠
.
Antes
de
zambullirnos
en
los
cap√≠tulos


tem√°ticos
de
la
segunda
parte
del
libro
,
conviene
finalizar
nuestro
viaje
descendente
por
la


pila
de
protocolos
adoptando
una
vista
integrada
y
hol√≠stica
de
los
protocolos
que
hemos


estudiado
hasta
el
momento
.
Una
forma
,
por
tanto
,
de
adoptar
esta
‚Äú
vista
panor√°mica
‚Äù
con-


siste
en
identificar
los
muchos
(
¬°
much√≠simos
!
)
protocolos
implicados
en
satisfacer
incluso


la
m√°s
simple
de
las
solicitudes
:
la
descarga
de
una
p√°gina
web
.
La
Figura
5.37
ilustra
el


que
ser√°
nuestro
escenario
de
trabajo
:
un
estudiante
,
Benito
,
conecta
una
computadora
por-


t√°til
al
conmutador
Ethernet
de
su
facultad
y
descarga
una
p√°gina
web
(
por
ejemplo
la


p√°gina
principal
de
www.google.com
)
.
Como
sabemos
ahora
,
son
muchas
las
cosas
que


suceden
‚Äú
entre
bambalinas
‚Äù
para
satisfacer
esta
solicitud
aparentemente
simple
.
Una
pr√°c-


tica
de
laboratorio
con
Wireshark
incluida
al
final
del
cap√≠tulo
le
permitir√°
examinar
con


mayor
detalle
una
serie
de
archivos
de
traza
que
contienen
varios
de
los
paquetes
implica-


dos
en
escenarios
similares
.


Inicio
:
DHCP
,
UDP
,
IP
y
Ethernet


Supongamos
que
Benito
arranca
su
computadora
port√°til
y
luego
la
conecta
a
un
cable


Ethernet
conectado
al
conmutador
Ethernet
de
la
facultad
,
que
a
su
vez
est√°
conectado
al


router
de
la
facultad
,
como
se
muestra
en
la
Figura
5.37
.
El
router
de
la
facultad
est√°
conec-


tado
a
un
ISP
,
que
en
este
caso
se
llama
comcast.net
.
En
este
ejemplo
,
comcast.net
propor-


ciona
el
servicio
DNS
para
la
facultad
;
por
tanto
,
el
servidor
DNS
reside
en
la
red
de


comcast
,
en
lugar
de
en
la
red
de
la
facultad
.
Supondremos
que
el
servidor
DHCP
est√°
eje-


cut√°ndose
dentro
del
router
,
como
suele
ser
el
caso
.


478
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


00:22:6B:45:1F:1B


68.85.2.1


00:16
:
D3:23:68:8A


68.85.2.101


comcast.net


servidor
DNS


68.87.71.226


www.google.com


servidor
web


64.233.169.105


Red
de
la
Facultad


68.80.2.0/24


Red
de
Comcast


68.80.0.0/13


Red
de
Google


64.233.160.0/19


1‚Äì7


8‚Äì13


18‚Äì24


14‚Äì17


Figura
5.37


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
478Cuando
Benito
conecta
por
primera
vez
su
port√°til
a
la
red
,
no
puede
hacer
nada
(
por


ejemplo
,
descargar
una
p√°gina
web
)
sin
una
direcci√≥n
IP
.
Por
tanto
,
la
primera
acci√≥n
rela-


cionada
con
la
red
que
lleva
a
cabo
la
computadora
port√°til
de
Benito
es
ejecutar
el
proto-


colo
DHCP
para
obtener
una
direcci√≥n
IP
,
as√≠
como
otras
informaciones
,
desde
el
servidor


DHCP
local
:


1
.
El
sistema
operativo
del
port√°til
de
Benito
crea
un
mensaje
de
solicitud
DHCP
(
Sec-


ci√≥n
4.4.2
)
y
lo
incluye
en
un
segmento
UDP
(
Secci√≥n
3.3
)
con
el
puerto
de
destino
67


(
servidor
DHCP
)
y
el
puerto
de
origen
68
(
cliente
DHCP
)
.
A
continuaci√≥n
,
el
segmento


UDP
es
insertado
dentro
de
un
datagrama
IP
(
Secci√≥n
4.4.1
)
con
una
direcci√≥n
IP
de


destino
de
difusi√≥n
(
255.255.255.255
)
y
una
direcci√≥n
IP
de
origen
igual
a
0.0.0.0
,
dado


que
la
computadora
port√°til
de
Benito
no
tiene
todav√≠a
una
direcci√≥n
IP
.


2
.
El
datagrama
IP
que
contiene
el
mensaje
de
solicitud
DHCP
se
inserta
entonces
en
una


trama
Ethernet
(
Secci√≥n
5.5.1
)
.
La
trama
Ethernet
tiene
una
direcci√≥n
MAC
de
des-


tino
igual
a
FF
:
FF
:
FF
:
FF
:
FF
:
FF
,
de
modo
que
la
trama
ser√°
difundida
a
todos
los
dispo-


sitivos
conectados
al
conmutador
(
entre
los
que
cabe
esperar
que
se
encuentre
un


servidor
DHCP
)
;
la
direcci√≥n
MAC
de
origen
de
la
trama
es
la
de
la
computadora
por-


t√°til
de
Benito
,
00:16
:
D3:23:68:8A.


3
.
La
trama
Ethernet
de
difusi√≥n
que
contiene
la
solicitud
DHCP
es
la
primera
trama


enviada
por
la
computadora
de
Benito
al
conmutador
Ethernet
.
El
conmutador
difunde


la
trama
entrante
a
todos
los
puertos
de
salida
,
incluyendo
el
puerto
conectado
al
rou-


ter
.


4
.
El
router
recibe
la
trama
Ethernet
de
difusi√≥n
que
contiene
la
solicitud
DHCP
a
trav√©s


de
su
propia
interfaz
con
direcci√≥n
MAC
00:22:6B:45:1F:1B
,
extrayendo
el
datagrama


IP
de
la
trama
Ethernet
.
La
direcci√≥n
IP
de
destino
de
difusi√≥n
contenida
en
el
data-


grama
indica
que
este
datagrama
IP
tiene
que
ser
procesado
por
los
protocolos
de
la


capa
superior
existentes
en
este
nodo
.
De
modo
que
se
demultiplexa
(
Secci√≥n
3.2
)
la


carga
√∫til
del
datagrama
(
un
segmento
UDP
)
y
se
entrega
esa
carga
√∫til
a
UDP
,
tras
lo


cual
se
extrae
del
segmento
UDP
el
mensaje
de
solicitud
DHCP
.
Ahora
el
servidor


DHCP
dispone
del
mensaje
de
solicitud
DHCP
.


5
.
Supongamos
que
el
servidor
DHCP
que
se
est√°
ejecutando
en
el
router
puede
asignar


direcciones
IP
dentro
del
bloque
CIDR
(
Secci√≥n
4.4.2
)
68.85.2.0/24
.
En
este
ejemplo
,


todas
las
direcciones
IP
utilizadas
dentro
de
la
Facultad
se
encuentran
dentro
del
bloque


de
direcciones
de
Comcast
.
Supongamos
que
el
servidor
DHCP
asigna
la
direcci√≥n


68.85.2.101
al
port√°til
de
Benito
.
El
servidor
DHCP
crear√°
un
mensaje
ACK
DHCP


(
Secci√≥n
4.4.2
)
que
contendr√°
esta
direcci√≥n
IP
,
as√≠
como
la
direcci√≥n
IP
del
servidor


DNS
(
68.87.71.226
)
,
la
direcci√≥n
IP
del
router
de
pasarela
predeterminado
(
68.85.2.1
)


y
el
bloque
de
subred
(
68.85.2.0/24
)
(
o
,
lo
que
es
lo
mismo
,
la
‚Äú
m√°scara
de
red
‚Äù
)
.
El


mensaje
DHCP
se
inserta
dentro
de
un
segmento
UDP
,
que
a
su
vez
se
incluye
dentro


de
un
datagrama
IP
,
que
se
inserta
en
una
trama
Ethernet
.
La
trama
Ethernet
tiene
una


direcci√≥n
MAC
de
origen
que
ser√°
igual
a
la
de
la
interfaz
entre
el
router
y
la
red
dom√©s-


tica
(
00:22:6B:45:1F:1B
)
y
una
direcci√≥n
MAC
de
destino
que
ser√°
igual
a
la
de
la
com-


putadora
port√°til
de
Benito
(
00:16
:
D3:23:68:8A
)
.


6
.
La
trama
Ethernet
que
contiene
la
respuesta
ACK
DHCP
se
env√≠a
(
unidifusi√≥n
)
desde
el


router
hacia
el
conmutador
.
Puesto
que
el
conmutador
tiene
la
caracter√≠stica
de
auto-


aprendizaje
(
Secci√≥n
5.6.2
)
y
ha
recibido
anteriormente
una
trama
Ethernet
(
la
que


5.9
‚Ä¢
UN
D√çA
EN
LA
VIDA
DE
UNA
SOLICITUD
DE
P√ÅGINA
WEB
479


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
479conten√≠a
la
solicitud
DHCP
)
desde
el
port√°til
de
Benito
,
el
conmutador
sabe
reenviar


una
trama
dirigida
a
00:16
:
D3:23:68:8A
√∫nicamente
hacia
el
puerto
de
salida
que
con-


duce
al
port√°til
de
Benito
.


7
.
La
computadora
port√°til
de
Benito
recibe
la
trama
Ethernet
que
contiene
la
respuesta


ACK
DHCP
,
extrae
el
datagrama
IP
de
la
trama
Ethernet
,
extrae
el
segmento
UDP
del


datagrama
IP
y
extrae
el
mensaje
ACK
DHCP
del
segmento
UDP
.
A
continuaci√≥n
,
el


cliente
DHCP
de
Benito
anota
su
direcci√≥n
IP
y
la
direcci√≥n
IP
de
su
servidor
DNS
.


Tambi√©n
instala
la
direcci√≥n
del
router
de
pasarela
predeterminado
en
su
tabla
de
reen-


v√≠o
IP(Secci√≥n
4.1
)
.
El
port√°til
de
Benito
enviar√°
hacia
el
router
de
pasarela
predeter-


minado
todos
los
datagramas
cuya
direcci√≥n
de
destino
caiga
fuera
de
su
subred


68.85.2.0/24
.
Llegados
a
este
punto
,
la
computadora
port√°til
de
Benito
ha
inicializado


sus
componentes
de
red
y
est√°
lista
para
iniciar
el
procesamiento
de
la
extracci√≥n
de
la


p√°gina
web
.
(
Observe
que
s√≥lo
son
necesarios
los
dos
√∫ltimos
pasos
DHCP
,
de
los
cua-


tro
presentados
en
el
Cap√≠tulo
4
.
)


Seguimos
con
el
inicio
:
DNS
,
ARP


Cuado
Benito
escribe
la
direcci√≥n
URL
correspondiente
a
www.google.com
en
su
navega-


dor
web
,
comienza
la
larga
cadena
de
sucesos
que
terminar√°
por
hacer
que
se
muestre
la


p√°gina
de
inicio
de
Google
en
su
navegador
web
.
El
navegador
de
Benito
comienza
creando


un
socket
TCP
(
Secci√≥n
2.7
)
que
se
utilizar√°
para
enviar
la
solicitud
HTTP
(
Secci√≥n
2.2
)


hacia
www.google.com
.
Para
crear
el
socket
,
la
computadora
port√°til
de
Benito
necesita


conocer
la
direcci√≥n
IP
de
www.google.com
.
En
la
Secci√≥n
2.5
hemos
visto
que
se
utiliza
el


protocolo
DNS
para
proporcionar
este
servicio
de
traducci√≥n
de
nombres
a
direcciones
IP
.


8
.
El
sistema
operativo
de
la
computadora
de
Benito
crea
por
tanto
un
mensaje
de
con-


sulta
DNS
(
Secci√≥n
2.5.3
)
,
incluyendo
la
cadena
‚Äú
www.google.com
‚Äù
en
la
secci√≥n
de


consulta
del
mensaje
DNS
.
Despu√©s
,
este
mensaje
DNS
se
inserta
dentro
de
un
seg-


mento
UDP
con
un
puerto
de
destino
igual
a
53
(
servidor
DNS
)
.
Despu√©s
el
segmento


UDP
se
inserta
dentro
de
un
datagrama
IP
con
una
direcci√≥n
IP
de
destino
igual
a


68.87.71.226
(
la
direcci√≥n
del
servidor
DNS
devuelta
en
el
mensaje
ACK
DHCP
en
el


Paso
5
)
y
una
direcci√≥n
IP
de
origen
igual
a
68.85.2.101
.


9
.
La
computadora
port√°til
de
Benito
inserta
entonces
el
datagrama
que
contiene
el
men-


saje
de
consulta
DNS
dentro
de
una
trama
Ethernet
.
Esta
trama
ser√°
enviada
(
direccio-


nada
en
la
capa
de
enlace
)
al
router
de
pasarela
de
la
red
de
la
facultad
de
Benito
.
Sin


embargo
,
a√∫n
cuando
el
port√°til
de
Benito
conoce
la
direcci√≥n
IP
del
router
de
pasarela


de
la
facultad
(
68.85.2.1
)
,
gracias
al
mensaje
ACK
DHCP
del
Paso
5
anterior
,
no
sabe


la
direcci√≥n
MAC
del
router
de
pasarela
.
Para
obtener
la
direcci√≥n
MAC
de
este
router


de
pasarela
,
el
port√°til
de
Benito
necesita
utilizar
el
protocolo
ARP(Secci√≥n
5.4.2
)
.


10
.
La
computadora
port√°til
de
Benito
crea
un
mensaje
de
consulta
ARP
con
una
direcci√≥n


IP
de
destino
igual
a
68.85.2.1
(
el
router
de
pasarela
predeterminado
)
,
incluye
el
men-


saje
ARP
dentro
de
una
trama
Ethernet
con
una
direcci√≥n
de
destino
de
difusi√≥n


(
FF
:
FF
:
FF
:
FF
:
FF
:
FF
)
y
env√≠a
la
trama
Ethernet
hacia
el
conmutador
,
que
entrega
la


trama
a
todos
los
dispositivos
conectados
,
incluyendo
al
router
de
pasarela
.


11
.
El
router
de
pasarela
recibe
la
trama
que
contiene
el
mensaje
de
solicitud
ARP
a
trav√©s


de
la
interfaz
con
la
red
de
la
facultad
y
se
encuentra
con
que
la
direcci√≥n
IP
de
destino
,


480
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
48068.85.2.1
,
contenida
en
el
mensaje
ARP
,
coincide
con
la
direcci√≥n
IP
de
su
propia
inter-


faz
.
El
router
de
pasarela
prepara
en
consecuencia
una
respuesta
ARP
,
indicando
que


su
direcci√≥n
MAC
00:22:6B:45:1F:1B
se
corresponde
con
la
direcci√≥n
IP
68.85.2.1
.
A


continuaci√≥n
,
inserta
el
mensaje
de
respuesta
ARP
en
una
trama
Ethernet
,
con
una
direc-


ci√≥n
de
destino
igual
a
00:16
:
D3:23:68:8A
(
la
de
la
computadora
port√°til
de
Benito
)
y


env√≠a
la
trama
al
conmutador
,
que
la
entrega
al
port√°til
de
Benito
.


12
.
El
port√°til
de
Benito
recibe
la
trama
que
contiene
el
mensaje
de
respuesta
ARP
y
extrae


la
direcci√≥n
MAC
del
router
de
pasarela
(
00:22:6B:45:1F:1B
)
de
ese
mensaje
.


13
.
La
computadora
port√°til
de
Benito
podr√°
ahora
(
¬°
finalmente
!
)
dirigir
la
trama
Ethernet


que
contiene
la
consulta
DNS
hacia
la
direcci√≥n
MAC
del
router
de
pasarela
.
Observe


que
el
datagrama
IP
de
esta
trama
tiene
la
direcci√≥n
IP
de
destino
68.87.71.226
(
el
ser-


vidor
DNS
)
,
mientras
que
la
trama
tiene
la
direcci√≥n
de
destino
00:22:6B:45:1F:1B
(
el


router
de
pasarela
)
.
El
port√°til
de
Benito
env√≠a
esta
trama
al
conmutador
,
que
la
entrega


al
router
de
pasarela
.


Seguimos
con
el
inicio
:
enrutamiento
dentro
del
dominio
al
servidor
DNS


14
.
El
router
de
pasarela
recibe
la
trama
y
extrae
el
datagrama
IP
que
contiene
la
consulta


DNS
.
El
router
busca
la
direcci√≥n
de
destino
de
este
datagrama
(
68.87.71.226
)
y
deter-


mina
a
partir
de
su
tabla
de
reenv√≠o
que
el
datagrama
debe
enviarse
al
router
situado


m√°s
a
la
izquierda
dentro
de
la
red
de
Comcast
de
la
Figura
5.37
.
El
datagrama
IP
se


inserta
dentro
de
una
trama
de
la
capa
de
enlace
que
resulte
apropiada
para
el
enlace
que


conecta
el
router
de
la
facultad
con
el
router
de
Comcast
situado
m√°s
a
la
izquierda
,
des-


pu√©s
de
lo
cual
la
trama
se
env√≠a
a
trav√©s
de
ese
enlace
.


15
.
El
router
situado
m√°s
a
la
izquierda
dentro
de
la
red
de
Comcast
recibe
la
trama
,
extrae


el
datagrama
IP
,
examina
la
direcci√≥n
de
destino
del
datagrama
(
68.87.71.226
)
y
deter-


mina
,
gracias
a
su
tabla
de
reenv√≠o
,
la
interfaz
de
salida
a
trav√©s
de
la
cual
debe
reenviar


el
datagrama
hacia
el
servidor
DNS
.
La
tabla
de
reenv√≠o
habr√°
sido
previamente
relle-


nada
mediante
el
protocolo
interno
del
dominio
de
Comcast
(
por
ejemplo
RIP
,
OSPF
o


IS-IS
,
Secci√≥n
4.6
)
,
as√≠
como
mediante
el
protocolo
entre
dominios
de
Internet
,


BGP
.


16
.
Finalmente
,
el
datagrama
IP
que
contiene
la
consulta
DNS
terminar√°
por
llegar
al
servi-


dor
DNS
,
el
cual
extrae
el
mensaje
de
consulta
DNS
,
busca
el
nombre
www.google
.


com
en
su
base
de
datos
DNS
(
Secci√≥n
2.5
)
y
encuentra
el
registro
de
recurso
DNS


que
contiene
la
direcci√≥n
IP
(
64.233.169.105
)
para
www.google.com
(
suponiendo
que


esa
direcci√≥n
est√©
actualmente
almacenada
en
la
cach√©
del
servidor
DNS
)
.
Recuerde
que


estos
datos
de
cach√©
tienen
su
origen
en
el
servidor
DNS
autoritativo
(
Secci√≥n
2.5.2
)


correspondiente
a
google.com
.
El
servidor
DNS
compondr√°
un
mensaje
de
respuesta


DNS
con
la
correspondencia
entre
el
nombre
de
host
y
la
direcci√≥n
IP
,
despu√©s
de
lo


cual
inserta
el
mensaje
de
respuesta
DNS
en
un
segmento
UDP
e
inserta
este
segmento


en
un
datagrama
IP
dirigido
a
la
computadora
port√°til
de
Benito
(
68.85.2.101
)
.
Este


datagrama
ser√°
reenviado
de
vuelta
a
trav√©s
de
la
red
de
Comcast
hasta
el
router
de
la


facultad
,
y
desde
all√≠
,
a
trav√©s
del
conmutador
Ethernet
a
la
computadora
de
Benito
.


17
.
La
computadora
port√°til
de
Benito
extrae
la
direcci√≥n
IP
del
servidor
www.google.com


del
mensaje
DNS
.
Finalmente
,
despu√©s
de
un
mont√≥n
de
trabajo
,
la
computadora
port√°-


til
de
Benito
estar√°
ya
lista
para
contactar
con
el
servidor
www.google.com
.


5.9
‚Ä¢
UN
D√çA
EN
LA
VIDA
DE
UNA
SOLICITUD
DE
P√ÅGINA
WEB
481


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
481Interacci√≥n
web
cliente-servidor
:
TCP
y
HTTP


18
.
Ahora
que
el
port√°til
de
Benito
dispone
de
la
direcci√≥n
IP
de
www
.
google.com
,
puede


crear
el
socket
TCP
(
Secci√≥n
2.7
)
que
se
utilizar√°
para
enviar
el
mensaje
GET
HTTP


(
Secci√≥n
2.2.3
)
a
www.google.com
.
Cuando
Benito
crea
el
socket
TCP
,
el
protocolo


TCP
de
su
port√°til
tiene
que
llevar
a
cabo
primero
un
proceso
de
acuerdo
en
tres
fases


(
Secci√≥n
3.5.6
)
con
el
TCP
de
www.google.com
.
El
port√°til
de
Benito
crear√°
primero
,


por
tanto
,
un
segmento
SYN
TCP
con
puerto
de
destino
80
(
para
HTTP
)
,
insertar√°
el


segmento
TCP
dentro
de
un
datagrama
IP
con
una
direcci√≥n
de
destino
IP
igual
a


64.233.169.105
(
www.google.com
)
,
incluir√°
el
datagrama
dentro
de
una
trama
con
una


direcci√≥n
MAC
de
destino
igual
a
00:22:6B:45:1F:1B
(
el
router
de
pasarela
)
y
enviar√°


la
trama
al
conmutador
.


19
.
Los
routers
de
la
red
de
la
facultad
,
de
la
red
de
Comcast
y
de
la
red
de
Google
reenv√≠an


el
datagrama
que
contiene
el
segmento
SYN
TCP
hacia
www.google.com
,
utilizando
la


tabla
de
reenv√≠o
de
cada
router
,
como
suced√≠a
en
los
pasos
14‚Äì16
anteriores
.
Recuerde


que
las
entradas
de
las
tablas
de
reenv√≠o
de
los
routers
que
gobiernan
el
reenv√≠o
de


paquetes
a
trav√©s
del
enlace
entre
dominios
entre
las
redes
de
Comcast
y
de
Google
son


determinadas
mediante
el
protocolo
BGP
(
Secci√≥n
4.6.3
)
.


20
.
En
alg√∫n
momento
,
el
datagrama
que
contiene
el
segmento
SYN
TCP
llegar√°
a


www.google.com
.
El
mensaje
SYN
TCP
ser√°
extra√≠do
del
datagrama
y
demultiplexado


para
ser
entregado
al
socket
de
acogida
asociado
con
el
puerto
80
.
Se
crea
entonces
un


socket
de
conexi√≥n
(
Secci√≥n
2.7
)
para
la
conexi√≥n
TCP
entre
el
servidor
HTTP
de
Goo-


gle
y
la
computadora
port√°til
de
Benito
.
Se
genera
entonces
un
segmento
SYNACK
TCP


(
Secci√≥n
3.5.6
)
,
se
inserta
dentro
de
un
datagrama
dirigido
al
port√°til
de
Benito
y
,
final-


mente
,
se
inserta
dicho
datagrama
dentro
de
una
trama
de
la
capa
de
enlace
que
resulte


apropiada
para
el
enlace
que
conecta
www.google.com
con
su
router
de
primer
salto
.


21
.
El
datagrama
que
contiene
el
segmento
SYNACK
TCP
se
reenv√≠a
a
trav√©s
de
las
redes


de
Google
,
de
Comcast
y
de
la
facultad
,
terminando
por
llegar
hasta
la
tarjeta
Ethernet


del
port√°til
de
Benito
.
El
datagrama
es
demultiplexado
dentro
del
sistema
operativo
y


entregado
al
socket
TCP
creado
en
el
Paso
18
,
con
lo
que
entrar√°
en
estado
conectado
.


22
.
Ahora
que
el
socket
del
port√°til
de
Benito
est√°
(
¬°
finalmente
!
)
listo
para
enviar
bytes
a


www.google.com
,
el
navegador
de
Benito
crea
el
mensaje
GET
HTTP
(
Secci√≥n
2.2.3
)


que
contiene
el
URL
que
quiere
extraer
.
Entonces
,
el
mensaje
GET
HTTP
se
escribe
en


el
socket
,
donde
pasa
a
ser
la
carga
√∫til
de
un
segmento
TCP
.
El
segmento
TCP
se
incluye


en
un
datagrama
y
se
env√≠a
y
se
entrega
a
www.google.com
como
en
los
Pasos
18‚Äì20
.


23
.
El
servidor
HTTP
en
www.google.com
lee
el
mensaje
GET
HTTP
del
socket
TCP
,
crea


un
mensaje
de
respuesta
HTTP
(
Secci√≥n
2.2
)
,
inserta
el
contenido
de
la
p√°gina
web


solicitada
en
el
cuerpo
del
mensaje
de
respuesta
HTTP
y
env√≠a
el
mensaje
a
trav√©s
del


socket
TCP
.


24
.
El
datagrama
que
contiene
el
mensaje
de
respuesta
HTTP
se
reenv√≠a
a
trav√©s
de
las


redes
de
Google
,
de
Comcast
y
de
la
facultad
y
llega
a
la
computadora
port√°til
de


Benito
.
El
navegador
web
de
Benito
lee
la
respuesta
HTTP
del
socket
,
extrae
el
c√≥digo


HTML
correspondiente
a
la
p√°gina
web
del
cuerpo
de
la
respuesta
HTTP
y
,
finalmente
,


(
¬°
finalmente
!
)
muestra
la
p√°gina
web
.


El
escenario
descrito
cubre
una
gran
cantidad
de
aspectos
de
la
comunicaci√≥n
por
red
.


Si
ha
comprendido
la
mayor
parte
del
ejemplo
anterior
o
todo
√©l
,
entonces
habr√°
avanzado


482
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
482mucho
desde
que
leyera
por
primera
vez
la
Secci√≥n
1.1
,
donde
dec√≠amos
que
‚Äú
buena
parte


de
este
libro
trata
de
los
protocolos
de
redes
de
computadoras
‚Äù
,
momento
en
el
que
posible-


mente
se
estaba
preguntando
qu√©
es
un
protocolo
.
Aunque
el
ejemplo
anterior
puede
parecer


bastante
detallado
,
hemos
omitido
varios
posibles
protocolos
adicionales
(
como
por
ejem-


plo
,
NAT
ejecut√°ndose
en
el
router
de
pasarela
de
la
facultad
,
el
acceso
inal√°mbrico
a
dicha


red
,
los
protocolos
de
seguridad
para
el
acceso
a
red
o
para
cifrar
segmentos
y
datagramas
,
o


los
protocolos
de
gesti√≥n
de
red
)
,
as√≠
como
diversas
consideraciones
adicionales
(
el
almace-


namiento
en
cach√©
web
,
la
jerarqu√≠a
DNS
)
que
podemos
encontrar
en
la
red
Internet
p√∫blica
.


Hablaremos
de
algunos
de
estos
temas
y
otros
en
la
segunda
parte
del
libro
.


Por
√∫ltimo
,
cabe
recalcar
que
el
ejemplo
anterior
era
una
visi√≥n
integrada
y
hol√≠stica
,


aunque
tambi√©n
refleja
los
componentes
esenciales
de
muchos
de
los
protocolos
que
hemos


estudiado
en
esta
primera
parte
del
libro
.
El
ejemplo
pretend√≠a
centrarse
m√°s
en
el
‚Äú
c√≥mo
‚Äù


que
en
el
‚Äú
por
qu√©
‚Äù
.
Si
desea
una
visi√≥n
m√°s
amplia
y
reflexiva
del
dise√±o
de
los
protocolos


de
red
en
general
,
consulte
[
Clark
1988
,
RFC
5218
]
.


5.10
Resumen


En
este
cap√≠tulo
hemos
examinado
la
capa
de
enlace
:
sus
servicios
,
los
principios
que
sub-


yacen
a
su
funcionamiento
y
una
serie
de
protocolos
espec√≠ficos
importantes
que
utilizan


esos
principios
a
la
hora
de
implementar
servicios
de
la
capa
de
enlace
.


Hemos
visto
que
el
servicio
b√°sico
de
la
capa
de
enlace
consiste
en
mover
un
datagrama


de
la
capa
de
red
desde
un
nodo
(
router
o
host
)
hasta
otro
nodo
adyacente
.
Tambi√©n
hemos


visto
que
todos
los
protocolos
de
la
capa
de
enlace
operan
encapsulando
un
datagrama
de
la


capa
de
red
dentro
de
una
trama
de
la
capa
de
enlace
antes
de
transmitir
la
trama
a
trav√©s
del


enlace
existente
hasta
el
nodo
adyacente
.
Sin
embargo
,
y
yendo
m√°s
all√°
de
esta
funci√≥n


com√∫n
de
entramado
,
hemos
estudiado
que
los
diferentes
protocolos
de
la
capa
de
enlace


proporcionan
servicios
muy
distintos
de
acceso
al
enlace
,
entrega
(
fiabilidad
,
detecci√≥n/


correcci√≥n
de
errores
)
,
control
de
flujo
y
transmisi√≥n
(
por
ejemplo
,
full-duplex
frente
a
semi-


duplex
)
.
Estas
diferencias
se
deben
en
parte
a
la
amplia
variedad
de
tipos
de
enlace
sobre
los


que
deben
operar
los
protocolos
de
la
capa
de
enlace
.
Un
simple
enlace
punto
a
punto
tiene


un
√∫nico
emisor
y
un
√∫nico
receptor
que
se
comunican
a
trav√©s
de
√∫nico
‚Äú
cable
‚Äù
.
Los
enla-


ces
de
acceso
m√∫ltiple
,
por
su
parte
,
son
compartidos
por
varios
emisores
y
receptores
;
en


consecuencia
,
el
protocolo
de
la
capa
de
enlace
para
un
canal
de
acceso
m√∫ltiple
dispone
de


un
protocolo
(
su
protocolo
de
acceso
m√∫ltiple
)
para
la
coordinaci√≥n
del
acceso
al
enlace
.
En


el
caso
de
MPLS
,
el
‚Äú
enlace
‚Äù
que
conecta
dos
nodos
adyacentes
(
por
ejemplo
,
dos
routers


IP
que
sean
adyacentes
en
sentido
IP
,
es
decir
,
que
ambos
son
routers
IP
del
siguiente
salto


hacia
un
determinado
destino
)
puede
ser
en
realidad
una
red
en
s√≠
misma
.
En
un
cierto
sen-


tido
,
la
idea
de
una
red
considerada
como
un
enlace
no
deber√≠a
resultar
demasiado
extra√±a
.


Un
enlace
telef√≥nico
que
conecta
una
computadora
/
m√≥dem
dom√©stico
con
un
m√≥dem
/
router


remoto
,
por
ejemplo
,
es
en
realidad
una
ruta
que
pasa
a
trav√©s
de
una
sofisticada
y
compleja


red
telef√≥nica
.


Entre
los
principios
que
subyacen
a
la
comunicaci√≥n
de
la
capa
de
enlace
,
hemos
exa-


minado
las
t√©cnicas
de
detecci√≥n
y
correcci√≥n
de
errores
,
los
protocolos
de
acceso
m√∫ltiple
,


el
direccionamiento
de
la
capa
de
enlace
,
la
virtualizaci√≥n
(
redes
VLAN
)
y
la
construcci√≥n


de
redes
LAN
ampliadas
mediante
concentradores
y
conmutadores
.
En
el
caso
de
la
detec-


ci√≥n
y
correcci√≥n
de
errores
,
hemos
examinado
c√≥mo
es
posible
a√±adir
bits
adicionales
a
la


RESUMEN
483


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
483cabecera
de
una
trama
con
el
fin
de
detectar
,
y
en
algunos
casos
de
corregir
,
errores
de
inver-


si√≥n
de
bit
que
puedan
producirse
al
transmitir
la
trama
a
trav√©s
de
un
enlace
.
Hemos
anali-


zado
los
esquemas
simples
de
paridad
y
de
suma
de
comprobaci√≥n
,
as√≠
como
los
c√≥digos
de


redundancia
c√≠clica
m√°s
robustos
.
Despu√©s
,
hemos
pasado
a
analizar
el
tema
de
los
protoco-


los
de
acceso
m√∫ltiple
.
Hemos
identificado
y
estudiado
tres
enfoques
generales
para
la
coor-


dinaci√≥n
del
acceso
a
un
canal
de
difusi√≥n
:
t√©cnicas
de
particionamiento
del
canal
(
TDM
,


FDM
)
,
t√©cnicas
de
acceso
aleatorio
(
los
protocolos
ALOHA
y
CSMA
)
y
t√©cnicas
de
toma


por
turnos
(
sondeo
y
paso
de
testigo
)
.
Hemos
visto
que
una
consecuencia
de
hacer
que
m√∫l-


tiples
nodos
compartan
un
√∫nico
canal
de
difusi√≥n
era
la
necesidad
de
proporcionar
direc-


ciones
de
nodo
en
la
capa
de
enlace
.
Hemos
estudiado
que
las
direcciones
f√≠sicas
son
muy


distintas
de
las
direcciones
de
la
capa
de
red
y
que
,
en
el
caso
de
Internet
,
se
utiliza
un
pro-


tocolo
especial
(
ARP
,
Protocolo
de
resoluci√≥n
de
direcciones
)
para
traducir
entre
estos
dos


tipos
de
direccionamiento
.
Despu√©s
hemos
examinado
c√≥mo
los
nodos
que
comparten
un


canal
de
difusi√≥n
forman
una
red
LAN
y
c√≥mo
pueden
conectarse
entre
s√≠
varias
redes
LAN


para
formar
otras
redes
LAN
de
mayor
tama√±o
,
todo
ello
sin
la
intervenci√≥n
del
enruta-


miento
de
la
capa
red
para
interconectar
esos
nodos
locales
.


Tambi√©n
hemos
cubierto
en
detalle
una
serie
de
protocolos
espec√≠ficos
de
la
capa
de


enlace
:
Ethernet
y
PPP
.
Hemos
terminado
nuestro
estudio
de
la
capa
de
enlace
centr√°ndonos


en
c√≥mo
las
redes
MPLS
proporcionan
servicios
de
la
capa
de
enlace
cuando
inter-conectan


routers
IP
.
Hemos
concluido
el
cap√≠tulo
(
y
de
hecho
los
primeros
cinco
cap√≠tulos
)
identifi-


cando
los
muchos
protocolos
necesarios
para
acceder
a
una
simple
p√°gina
web
.
Habiendo


cubierto
la
capa
de
enlace
,
hemos
concluido
nuestro
viaje
descendente
por
la
pila
de
proto-


colos
.
Verdaderamente
,
la
capa
f√≠sica
se
encuentra
por
debajo
de
la
capa
de
enlace
de
datos
,


pero
quiz√°
sea
mejor
dejar
los
detalles
de
la
capa
f√≠sica
para
otro
curso
(
por
ejemplo
,
un


curso
sobre
teor√≠a
de
la
comunicaci√≥n
m√°s
que
sobre
redes
de
computadoras
)
.
No
obstante
,


es
cierto
que
hemos
tocado
varios
aspectos
de
la
capa
f√≠sica
en
este
cap√≠tulo
y
en
el
Cap√≠tulo


1
(
nuestra
exposici√≥n
acerca
de
los
medios
f√≠sicos
de
la
Secci√≥n
1.2
)
.
Consideraremos
de


nuevo
la
capa
f√≠sica
cuando
estudiemos
las
caracter√≠sticas
de
los
enlaces
inal√°mbricos
en
el


siguiente
cap√≠tulo
.


Aunque
nuestro
viaje
por
la
pila
de
protocolos
ya
haya
concluido
,
nuestro
estudio
de
las


redes
de
computadoras
no
ha
terminado
en
modo
alguno
.
En
los
siguientes
cuatro
cap√≠tulos


nos
ocuparemos
de
las
redes
inal√°mbricas
,
las
redes
multimedia
,
la
seguridad
de
red
y
la


gesti√≥n
de
red
.
Estos
cuatro
temas
no
encajan
de
manera
natural
en
ninguna
de
las
capas
que


conocemos
.
De
hecho
,
cada
uno
de
ellos
cruza
muchas
de
esas
distintas
capas
.
Comprender


estos
temas
(
que
se
califican
de
temas
avanzados
en
algunos
libros
de
texto
)
requiere
por


tanto
un
s√≥lido
conocimiento
de
todas
las
capas
de
la
pila
de
protocolos
,
un
conocimiento


que
nuestro
estudio
de
la
capa
de
enlace
de
datos
nos
ha
permitido
terminar
de
adquirir
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
5
Cuestiones
de
repaso


SECCIONES
5.1‚Äì5.2


R1
.
Considere
la
analog√≠a
de
los
transportes
de
la
Secci√≥n
5.1.1
.
Si
el
pasajero
es
an√°logo


a
un
datagrama
,
¬ø
qu√©
ser√≠a
an√°logo
a
la
trama
de
la
capa
de
enlace
?


484
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
484R2
.
Si
todos
los
enlaces
de
Internet
tuvieran
que
proporcionar
un
servicio
de
entrega
fia-


ble
,
¬ø
ser√≠a
el
servicio
de
entrega
fiable
de
TCP
redundante
?
¬ø
Por
qu√©
?


R3
.
¬ø
Cu√°les
son
algunos
de
los
posibles
servicios
que
puede
ofrecer
un
protocolo
de
la


capa
de
enlace
a
la
capa
de
red
?
¬ø
Cu√°les
de
estos
servicios
de
la
capa
de
enlace
tienen


servicios
correspondientes
en
IP
?
¬ø
Y
en
TCP
?


SECCI√ìN
5.3


R4
.
Suponga
que
dos
nodos
comienzan
a
transmitir
al
mismo
tiempo
un
paquete
de
longi-


tud
L
a
trav√©s
de
un
canal
de
difusi√≥n
de
velocidad
R.
Sea
el
retardo
de
propagaci√≥n


entre
los
dos
nodos
dprop
.
¬ø
Se
producir√°
una
colisi√≥n
si
dprop
<
L
/R
?
¬ø
Por
qu√©
?


R5
.
En
la
Secci√≥n
5.3
hemos
enumerado
cuatro
caracter√≠sticas
deseables
de
un
canal
de


difusi√≥n
.
¬ø
Cu√°les
de
estas
caracter√≠sticas
presenta
el
protocolo
ALOHA
con
particio-


nes
?
¬ø
Cu√°les
de
estas
caracter√≠sticas
presentan
los
protocolos
de
paso
de
testigo
?


R6
.
Describa
los
protocolos
de
sondeo
y
de
paso
de
testigo
utilizando
la
analog√≠a
de
las


interacciones
de
las
personas
que
asisten
a
un
coctel
.


R7
.
¬ø
Por
qu√©
el
protocolo
token-ring
resulta
ineficiente
si
una
red
LAN
tiene
un
per√≠metro


muy
grande
?


SECCI√ìN
5.4


R8
.
¬ø
Cu√°l
es
el
tama√±o
del
espacio
de
direcciones
MAC
?
¬ø
Y
el
del
espacio
de
direcciones


de
IPv4
?
¬ø
Y
el
del
espacio
de
direcciones
de
IPv6
?


R9
.
Suponga
que
los
nodos
A
,
B
y
C
est√°n
conectados
a
la
misma
red
LAN
de
difusi√≥n
(
a


trav√©s
de
sus
adaptadores
)
.
Si
A
env√≠a
miles
de
datagramas
IP
a
B
,
con
cada
trama
que


los
encapsula
dirigida
hacia
la
direcci√≥n
MAC
de
B
,
¬ø
procesar√°
el
adaptador
de
C


estas
tramas
?
En
caso
afirmativo
,
¬ø
pasar√°
el
adaptador
de
C
los
datagramas
IP
de


dichas
tramas
a
la
capa
de
red
de
C
?
¬ø
C√≥mo
variar√≠a
su
respuesta
si
A
env√≠a
las
tramas


con
la
direcci√≥n
MAC
de
difusi√≥n
?


R10
.
¬ø
Por
qu√©
las
consultas
ARP
se
env√≠an
dentro
de
una
trama
de
difusi√≥n
?
¬ø
Por
qu√©
la
res-


puesta
ARP
se
env√≠a
dentro
de
una
trama
con
una
direcci√≥n
MAC
de
destino
espec√≠-


fica
?


R11
.
En
la
red
de
la
Figura
5.19
el
router
tiene
dos
m√≥dulos
ARP
,
cada
uno
con
su
propia


tabla
ARP
.
¬ø
Es
posible
que
la
misma
direcci√≥n
MAC
aparezca
en
ambas
tablas
?


SECCI√ìN
5.5


R12
.
Compare
las
estructuras
de
trama
de
Ethernet
10BASE-T
,
100BASE-T
y
Gigabit
.
¬ø
En


qu√©
se
diferencian
?


R13
.
Suponga
que
un
adaptador
a
10
Mbps
env√≠a
por
un
canal
un
flujo
infinito
de
unos
(
1s
)


utilizando
codificaci√≥n
Manchester
.
¬ø
Cu√°ntas
transiciones
por
segundo
tiene
la
se√±al


de
salida
del
adaptador
?


R14
.
En
CSMA
/
CD
,
despu√©s
de
la
quinta
colisi√≥n
,
¬ø
cu√°l
es
la
probabilidad
de
que
un
nodo


seleccione
K
=
4
?
¬ø
A
cu√°ntos
segundos
de
retardo
corresponde
el
resultado
K
=
4
en


una
red
Ethernet
a
10
Mbps
?


PROBLEMAS
Y
CUESTIONES
DE
REPASO
485


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
485SECCI√ìN
5.6


R15
.
Considere
la
Figura
5.26
.
¬ø
Cu√°ntas
subredes
hay
,
en
el
sentido
de
direccionamiento


explicado
en
la
Secci√≥n
4.4
?


SECCI√ìN
5.7


R16
.
¬ø
Cu√°l
es
el
n√∫mero
m√°ximo
de
redes
VLAN
que
pueden
configurarse
en
un
conmuta-


dor
que
soporta
el
protocolo
802.1Q
?
¬ø
Por
qu√©
?


R17
.
Suponga
que
tenemos
que
conectar
N
conmutadores
que
dan
soporte
a
K
grupos


VLAN
mediante
un
protocolo
de
enlace
troncal
(
trunking
)
?
¬ø
Cu√°ntos
puertos
son


necesarios
para
conectar
los
conmutadores
?
Justifique
su
respuesta
.


Problemas


P1
.
Suponga
que
el
contenido
de
informaci√≥n
de
un
paquete
es
el
patr√≥n
de
bits
1110
1011


1001
1101
y
que
est√°
utilizando
un
esquema
de
paridad
par
.
¬ø
Cu√°l
ser√≠a
el
valor
del


campo
que
contiene
los
bits
de
paridad
para
el
caso
de
un
esquema
de
paridad
bidi-


mensional
?
La
respuesta
debe
ser
tal
que
se
utilice
un
campo
de
suma
de
comproba-


ci√≥n
de
longitud
m√≠nima
.


P2
.
Demuestre
(
proporcionando
un
ejemplo
distinto
del
de
la
Figura
5.6
)
que
los
c√≥digos


de
paridad
bidimensional
permiten
corregir
y
detectar
un
√∫nico
error
de
bit
.
Indique


(
proporcionando
un
ejemplo
)
un
error
doble
de
bit
que
pueda
ser
detectado
pero
no


corregido
.


P3
.
Suponga
que
la
parte
de
informaci√≥n
de
un
paquete
(
D
en
la
Figura
5.4
)
contiene
10


bytes
compuestos
de
la
representaci√≥n
en
c√≥digo
ASCII
binario
sin
signo
de
8
bits
de


la
cadena
de
caracteres
‚Äú
Link
Layer
‚Äù
(
capa
de
enlace
)
.
Calcule
la
suma
de
comproba-


ci√≥n
de
Internet
para
estos
datos
.


P4
.
Considere
el
problema
anterior
,
pero
suponga
que
los
10
bytes
contienen
:


a.
la
representaci√≥n
binaria
de
los
n√∫meros
1
a
10
.


b.
la
representaci√≥n
ASCII
de
las
letras
A
hasta
J
(
may√∫sculas
)
.


c.
la
representaci√≥n
ASCII
de
las
letras
a
hasta
j
(
min√∫sculas
)
.


Calcule
la
suma
de
comprobaci√≥n
de
Internet
para
estos
datos
.


P5
.
Considere
el
generador
de
7
bits
,
G
=
10011
,
y
suponga
que
D
tiene
el
valor


1010101010
.
¬ø
Cu√°l
es
el
valor
de
R
?


P6
.
Considere
el
problema
anterior
,
pero
ahora
suponga
que
D
tiene
el
valor
:


a.
1001000101
.


b.
1010001111
.


c.
0101010101
.


P7
.
En
este
problema
vamos
a
explorar
algunas
de
las
propiedades
del
c√≥digo
CRC
.
Para
el


generador
G
=
1001
dado
en
la
Secci√≥n
5.2.3
,
responda
a
las
siguientes
cuestiones
:


a.
¬ø
Por
qu√©
puede
detectar
cualquier
error
simple
de
bit
en
los
datos
D
?


486
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
486b
.
¬ø
Puede
el
generador
G
anterior
detectar
cualquier
n√∫mero
impar
de
errores
de
bit
?


¬ø
Por
qu√©
?


P8
.
En
la
Secci√≥n
5.3
,
hemos
proporcionado
un
esbozo
del
c√°lculo
de
la
eficiencia
del
pro-


tocolo
ALOHA
con
particiones
.
En
este
problema
vamos
a
completar
dicho
c√°lculo
.


a.
Recuerde
que
cuando
hay
N
nodos
activos
,
la
eficiencia
de
ALOHA
con
particiones


es
Np(1
‚Äì
p)N‚Äì1
.
Calcule
el
valor
de
p
que
maximiza
esta
expresi√≥n
.


b.
Utilizando
el
valor
de
p
determinado
en
el
apartado
(
a
)
,
calcule
la
eficiencia
del


protocolo
ALOHA
con
particiones
haciendo
que
N
tienda
a
infinito
.
Sugerencia
:


(
1
‚Äì
1
/
N)N
tiende
a
1
/
e
cuando
N
tiende
a
infinito
.


P9
.
Demuestre
que
la
eficiencia
m√°xima
del
protocolo
ALOHA
puro
es
1/(2
e
)
.
Nota
:
este


problema
es
sencillo
despu√©s
de
haber
completado
el
problema
anterior
.


P10
.
Considere
los
nodos
A
y
B
que
utilizan
el
protocolo
ALOHA
con
particiones
para


competir
por
un
canal
.
Suponga
que
el
nodo
A
tiene
m√°s
datos
para
transmitir
que
el


nodo
 
B
,
y
que
la
probabilidad
de
retransmisi√≥n
del
nodo
A
,
pA
,
es
mayor
que
la
pro-


babilidad
de
retransmisi√≥n
del
nodo
B
,
pB
.


a.
Proporcione
una
f√≥rmula
para
la
tasa
media
de
transferencia
del
nodo
A.
¬ø
Cu√°l
es


la
eficiencia
total
del
protocolo
con
estos
dos
nodos
?
 

b.
Si
pA
=
2pB
,
¬ø
ser√°
la
tasa
media
de
transferencia
de
A
el
doble
que
la
del
nodo
B
?


¬ø
Por
qu√©
?
Si
no
es
as√≠
,
¬ø
c√≥mo
podemos
seleccionar
valores
de
pA
y
pB
para
que
esto


ocurra
?


c.
En
general
,
suponga
que
hay
N
nodos
,
entre
los
que
el
nodo
A
tiene
una
probabili-


dad
de
retransmisi√≥n
2p
y
todos
los
dem√°s
nodos
tienen
una
probabilidad
de


retransmisi√≥n
p.
Proporcione
las
expresiones
necesarias
para
calcular
las
tasas


medias
de
transferencia
del
nodo
A
y
de
los
restantes
nodos
.
 

P11
.
Suponga
que
cuatro
nodos
activos
(
nodos
A
,
B
,
C
y
D
)
est√°n
compitiendo
por
el
acceso


a
un
canal
utilizando
el
protocolo
ALOHA
con
particiones
.
Suponga
que
cada
nodo


tiene
un
n√∫mero
infinito
de
paquetes
que
transmitir
y
que
cada
nodo
intenta
transmi-


tir
en
cada
partici√≥n
con
una
probabilidad
p.
La
primera
partici√≥n
tiene
el
n√∫mero
1
,
la


segunda
el
n√∫mero
2
,
etc.


a.
¬ø
Cu√°l
es
la
probabilidad
de
que
el
nodo
A
tenga
√©xito
por
primera
vez
en
la
parti-


ci√≥n
5
?


b.
¬ø
Cu√°l
es
la
probabilidad
de
que
alg√∫n
nodo
(
A
,
B
,
C
o
D
)
tenga
√©xito
en
la
parti-


ci√≥n
4
?


c.
¬ø
Cu√°l
es
la
probabilidad
de
que
el
primer
√©xito
suceda
en
la
partici√≥n
3
?


d.
¬ø
Cu√°l
es
la
eficiencia
de
este
sistema
de
cuatro
nodos
?


P12
.
Dibuje
una
gr√°fica
con
la
eficiencia
de
los
protocolos
ALOHA
con
particiones
y


ALOHA
puro
en
funci√≥n
de
p
para
los
siguientes
valores
de
N
:


a.
N 
15
.


b.
N 
20
.


c.
N 
30
.


PROBLEMAS
487


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
487P13
.
Considere
un
canal
de
difusi√≥n
con
N
nodos
y
una
tasa
de
transmisi√≥n
de
R
bps
.


Suponga
que
el
canal
de
difusi√≥n
utiliza
sondeo
(
con
un
nodo
adicional
de
sondeo
)


para
regular
el
acceso
m√∫ltiple
.
Suponga
que
la
cantidad
de
tiempo
desde
que
un
nodo


completa
una
transmisi√≥n
hasta
que
se
le
permite
transmitir
al
nodo
siguiente
(
es
decir
,


el
retardo
de
sondeo
)
es
dsondeo
.
Suponga
que
dentro
de
una
ronda
de
sondeo
,
a
cada


nodo
se
le
permite
transmitir
un
m√°ximo
de
Q
bits
.
¬ø
Cu√°l
es
la
tasa
m√°xima
de
trans-


ferencia
del
canal
de
difusi√≥n
?


P14
.
Considere
tres
redes
LAN
interconectadas
mediante
dos
routers
,
como
se
muestra
en


la
Figura
5.38
.


a.
Asigne
direcciones
IP
a
todas
las
interfaces
.
Para
la
Subred
 
1
utilice
direcciones
de


la
forma
192.168.1.xxx
;
para
la
Subred
2
utilice
direcciones
de
la
forma
192.168.2
.


xxx
;
y
para
la
Subred
3
emplee
direcciones
de
la
forma
192.168.3.xxx
.


b.
Asigne
direcciones
MAC
a
todos
los
adaptadores
.


c.
Considere
el
env√≠o
de
un
datagrama
IP
desde
el
host
E
al
host
B.
Suponga
que
todas


las
tablas
ARP
est√°n
actualizadas
.
Enumere
todos
los
pasos
,
como
hemos
hecho
en


el
ejemplo
para
un
√∫nico
router
en
la
Secci√≥n
5.4.2
.


d.
Repita
el
apartado
(
c
)
suponiendo
ahora
que
la
tabla
ARP
del
host
emisor
est√°
vac√≠a


(
y
que
todas
las
dem√°s
tablas
est√°n
actualizadas
)
.


P15
.
Considere
la
Figura
5.38
.
Ahora
vamos
sustituir
el
router
situado
entre
las
subredes
1


y
2
por
un
conmutador
S1
,
y
vamos
a
etiquetar
el
router
situado
entre
las
subredes
2
y


3
como
R1
.


a.
Considere
el
env√≠o
de
un
datagrama
IP
desde
el
host
E
al
host
F.
¬ø
Pedir√°
el
host
E


al
router
R1
que
le
ayude
a
reenviar
el
datagrama
?
¬ø
Por
qu√©
?
En
la
trama
Ethernet


488
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


A


C


B


Subred
1


Subred
2


Subred
3


D


E


F


Figura
5.38
‚Ä¢
Tres
subredes
interconectadas
mediante
routers
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
488que
contiene
el
datagrama
IP
,
¬ø
cu√°les
son
las
direcciones
IP
y
MAC
de
origen
y
de


destino
?


b.
Suponga
que
E
quiere
enviar
un
datagrama
IP
a
B
y
suponga
que
la
cach√©
ARP
de


E
no
contiene
la
direcci√≥n
MAC
de
B.
¬ø
Realizar√°
E
una
consulta
ARP
para
averi-


guar
la
direcci√≥n
MAC
de
B
?
¬ø
Por
qu√©
?
En
la
trama
Ethernet
(
que
contiene
el
data-


grama
IP
destinado
a
B
)
que
se
le
entrega
al
router
R1
,
¬ø
cu√°les
son
las
direcciones


IP
y
MAC
de
origen
y
de
destino
?


c.
Suponga
que
el
host
A
quiere
enviar
un
datagrama
IP
al
host
B
,
y
que
ni
la
cach√©


ARP
de
A
contiene
la
direcci√≥n
MAC
de
B
ni
la
cach√©
ARP
de
B
contiene
la
direc-


ci√≥n
MAC
de
A.
Suponga
adem√°s
que
la
tabla
de
reenv√≠o
del
conmutador
S1
con-


tiene
entradas
√∫nicamente
para
el
host
B
y
el
router
R1
.
Por
tanto
,
A
difundir√°
un


mensaje
de
solicitud
ARP
.
¬ø
Qu√©
acciones
realizar√°
el
conmutador
S1
una
vez
que


reciba
el
mensaje
de
solicitud
ARP
?
¬ø
Recibir√°
tambi√©n
el
router
R1
esta
solicitud


ARP
?
En
caso
afirmativo
,
¬ø
reenviar√°
R1
el
mensaje
hacia
la
Subred
3
?
Una
vez


que
el
host
B
reciba
este
mensaje
de
solicitud
ARP
,
devolver√°
al
host
A
un
mensaje


de
respuesta
ARP
.
Pero
¬ø
enviar√°
un
mensaje
de
consulta
ARP
para
preguntar
por
la


direcci√≥n
MAC
de
A
?
¬ø
Por
qu√©
?
¬ø
Que
har√°
el
conmutador
S1
una
vez
que
reciba
el


mensaje
de
respuesta
ARP
del
host
B
?


P16
.
Considere
el
problema
anterior
,
pero
ahora
suponga
que
el
router
situado
entre
las


subredes
2
y
3
es
sustituido
por
un
conmutador
.
Responda
a
las
preguntas
de
los
apar-


tados
(
a)‚Äì(c
)
del
problema
anterior
en
este
nuevo
contexto
.


P17
.
Recuerde
que
con
el
protocolo
CSMA
/
CD
el
adaptador
espera
K
 
512
periodos
de
bit


despu√©s
de
producirse
una
colisi√≥n
,
donde
K
se
selecciona
aleatoriamente
.
Para
K
=


100
,
¬ø
cu√°nto
tiempo
espera
el
adaptador
hasta
volver
al
Paso
2
para
una
red
Ethernet
a


10
Mbps
?
¬ø
Y
para
una
red
Ethernet
a
100
Mbps
?


P18
.
Suponga
que
los
nodos
A
y
B
se
encuentran
en
el
mismo
bus
Ethernet
a
10
Mbps
y
que


el
retardo
de
propagaci√≥n
entre
los
dos
nodos
es
igual
a
325
periodos
de
bit
.
Suponga


que
el
nodo
A
comienza
a
transmitir
una
trama
y
que
,
antes
de
finalizar
,
el
nodo
B


comienza
a
transmitir
otra
trama
.
¬ø
Podr√≠a
A
finalizar
la
transmisi√≥n
antes
de
detectar


que
B
ha
transmitido
?
¬ø
Por
qu√©
?
Si
la
respuesta
es
afirmativa
,
entonces
Acreer√°
inco-


rrectamente
que
su
trama
se
ha
transmitido
con
√©xito
sin
que
se
haya
producido
una
coli-


si√≥n
.
Sugerencia
:
suponga
que
en
el
instante
t
=
0
periodos
de
bit
A
comienza
a


transmitir
una
trama
.
En
el
caso
peor
,
A
transmitir√°
una
trama
de
tama√±o
m√≠nimo
que


ocupar√°
512
+
64
periodos
de
bit
.
Por
lo
que
A
terminar√≠a
de
transmitir
la
trama
para
t
=


512
+
64
periodos
de
bit
.
Por
tanto
,
la
respuesta
es
no
si
la
se√±al
de
B
alcanza
a
A
antes


del
instante
t
=
5
1
2
 
+
 
6
4
 
p
e
r
i
o
d
o
s
 
d
e
 
b
i
t
s
.
 
E
n
 
e
l
 
c
a
s
o
 
p
e
o
r
,
 
¬ø
c
u
√°
n
d
o
 
a
l
c
a
n
z
a
r
√≠
a
 
a
 
Al
a


se√±al
de
B
?


P19
.
Explique
por
qu√©
hace
falta
un
tama√±o
m√≠nimo
de
trama
para
Ethernet
.
Por
ejemplo
,


Ethernet
10Base
impone
un
tama√±o
m√≠nimo
de
trama
de
64
bytes
(
si
ha
hecho
el
pro-


blema
anterior
podr√≠a
haberse
dado
cuenta
de
cu√°l
es
la
raz√≥n
)
.
Ahora
suponga
que
la


distancia
entre
dos
extremos
de
una
red
LAN
Ethernet
es
d.
¬ø
Puede
hallar
una
f√≥rmula


que
permite
obtener
el
tama√±o
m√≠nimo
de
trama
necesario
para
los
paquetes
Ethernet
?


Bas√°ndose
en
su
razonamiento
,
¬ø
cu√°l
ser√°
el
tama√±o
m√≠nimo
requerido
de
paquete
de


una
red
Ethernet
que
abarque
2
kil√≥metros
?


PROBLEMAS
489


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
489P20
.
Suponga
que
quiere
incrementar
la
velocidad
de
enlace
de
su
cable
Ethernet
,
¬ø
C√≥mo


afectar√≠a
esta
actualizaci√≥n
a
los
tama√±os
m√≠nimos
de
paquetes
requeridos
?
Si
actua-


liza
su
cable
a
una
velocidad
mayor
y
se
da
cuenta
de
que
no
puede
cambiar
el
tama√±o


de
paquete
,
¬ø
qu√©
otra
cosa
puede
hacer
para
que
la
red
pueda
seguir
operando
correc-


tamente
?


P21
.
Suponga
que
los
nodos
A
y
B
se
encuentran
en
el
mismo
bus
Ethernet
a
10
Mbps
y
que


el
retardo
de
propagaci√≥n
entre
los
dos
nodos
es
igual
a
245
periodos
de
bit
.
Suponga


que
A
y
B
env√≠an
tramas
al
mismo
tiempo
,
que
las
tramas
colisionan
y
que
luego
A
y


B
seleccionan
diferentes
valores
de
K
en
el
algoritmo
CSMA
/
CD
.
Suponiendo
que
no


haya
ning√∫n
otro
nodo
activo
,
¬ø
pueden
colisionar
las
retransmisiones
de
A
y
B
?
Para


nuestros
prop√≥sitos
,
basta
con
resolver
el
siguiente
ejemplo
.
Suponga
que
A
y
B


comienzan
la
transmisi√≥n
en
t
=
0
periodos
de
bit
.
Ambos
detectan
la
colisi√≥n
en
el
ins-


tante
t
=
245
periodos
de
bits
y
terminan
de
transmitir
una
se√±al
de
interferencia
en
t
=


245
+
48
=
293
periodos
de
bit
.
Suponga
que
KA
=
0
y
KB
=
1
.
¬ø
Para
qu√©
instante
pro-


gramar√°
B
su
retransmisi√≥n
?
¬ø
En
qu√©
momento
comenzar√°
A
su
transmisi√≥n
?
(
Nota
:


los
nodos
tienen
que
esperar
a
que
el
canal
est√©
inactivo
despu√©s
de
volver
al
Paso
2


(
consulte
el
protocolo
)
.
¬ø
En
qu√©
momento
alcanza
a
B
la
se√±al
de
A
?
¬ø
Se
abstendr√°
B


de
transmitir
en
el
instante
programado
?


P22
.
Considere
una
red
Ethernet
100BASE-T
a
100
Mbps
con
todos
los
nodos
directamente


conectados
a
un
concentrador
.
Para
tener
una
eficiencia
de
0,50
,
¬ø
cu√°l
deber√≠a
ser
la


distancia
m√°xima
entre
un
nodo
y
el
concentrador
?
Suponga
una
longitud
de
trama
de


1.000
bytes
y
que
no
existe
ning√∫n
repetidor
.
¬ø
Garantiza
tambi√©n
esta
distancia
m√°xima


que
un
nodo
A
que
est√°
transmitiendo
ser√°
capaz
de
detectar
si
cualquier
otro
nodo
ha


transmitido
mientras
A
estaba
transmitiendo
?
¬ø
Por
qu√©
?
¬ø
C√≥mo
es
esa
distancia


m√°xima
,
comparada
con
el
est√°ndar
real
a
100
Mbps
?
Suponga
que
la
velocidad
de


propagaci√≥n
de
la
se√±al
en
Ethernet
100BASE-T
es
1,8
 
108
m
/
s.


P23
.
Suponga
que
hay
cuatro
nodos
,
A
,
B
,
C
y
D
,
conectados
a
un
concentrador
mediante


cables
Ethernet
a
10
Mbps
.
Las
distancias
entre
el
concentrador
y
estos
cuatro
nodos


son
300
,
400
,
500
y
700
metros
,
respectivamente
.
Recuerde
que
para
esta
red
Ethernet


se
utiliza
el
protocolo
CSMA
/
CD
.
Suponga
que
la
velocidad
de
propagaci√≥n
de
la


se√±al
es
2
 
108
m
/
s.


a.
¬ø
Cu√°l
es
la
longitud
m√≠nima
de
trama
requerida
?
¬ø
Cu√°l
es
la
longitud
m√°xima
de


trama
requerida
?


b.
Si
todas
las
tramas
tiene
una
longitud
de
1.500
bits
,
calcule
la
eficiencia
de
esta
red


Ethernet
.


P24
.
En
este
problema
tendr√°
que
deducir
la
eficiencia
de
un
protocolo
de
acceso
m√∫ltiple


de
tipo
CSMA
/
CD
.
En
dicho
protocolo
,
el
tiempo
est√°
particionado
y
todos
los
adapta-


dores
est√°n
sincronizados
con
las
particiones
.
Sin
embargo
,
a
diferencia
del
protocolo


ALOHA
con
particiones
,
la
longitud
de
una
partici√≥n
(
en
segundos
)
es
muy
inferior
al


tiempo
de
trama
(
el
tiempo
necesario
para
transmitir
una
trama
)
.
Sea
S
la
longitud
de


una
partici√≥n
.
Suponga
que
todas
las
tramas
tienen
una
longitud
constante
L
=
kRS
,


donde
R
es
la
velocidad
de
transmisi√≥n
del
canal
y
k
es
un
entero
de
gran
magnitud
.


Suponga
que
existen
N
nodos
,
cada
uno
con
un
n√∫mero
infinito
de
tramas
para
enviar
.


Suponga
tambi√©n
que
dprop
<
S
,
de
modo
que
todos
los
nodos
pueden
detectar
una
coli-


si√≥n
antes
de
que
finalice
una
partici√≥n
de
tiempo
.
El
protocolo
es
como
sigue
:


490
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
490‚Ä¢S
i
,
 
p
a
r
a
 
u
n
a
 
p
a
r
t
i
c
i
√≥
n
 
d
e
t
e
r
m
i
n
a
d
a
,
 
n
i
n
g
√∫
n
 
n
o
d
o
 
e
s
t
√°
 
e
n
 
p
o
s
e
s
i
√≥
n
 
d
e
l
 
c
a
n
a
l
,
 
t
o
d
o
s


los
nodos
competir√°n
por
el
acceso
al
canal
;
en
particular
,
cada
uno
de
los
nodos


transmite
durante
esa
partici√≥n
con
una
probabilidad
p.
Si
exactamente
un
nodo


transmite
en
la
partici√≥n
,
dicho
nodo
se
apropia
del
canal
durante
las
subsiguientes


k
‚Äì
1
particiones
y
transmite
su
trama
completa
.


‚Ä¢S
i
 
a
l
g
√∫
n
 
n
o
d
o
 
e
s
t
√°
 
e
n
 
p
o
s
e
s
i
√≥
n
 
d
e
l
 
c
a
n
a
l
,
 
t
o
d
o
s
 
l
o
s
 
d
e
m
√°
s
 
n
o
d
o
s
 
s
e
 
a
b
s
t
i
e
n
e
n
 
d
e


transmitir
hasta
que
el
nodo
que
posee
el
canal
ha
terminado
de
transmitir
su
trama
.


Una
vez
que
este
nodo
ha
transmitido
su
trama
,
todos
los
nodos
compiten
por
acce-


der
al
canal
.


Observe
que
el
canal
alterna
entre
dos
estados
distintos
:
el
estado
productivo
,
que
dura


exactamente
k
particiones
,
y
el
estado
no
productivo
,
que
dura
un
n√∫mero
aleatorio
de


particiones
.
Obviamente
,
la
eficiencia
del
canal
ser√°
la
relaci√≥n
k/(k
+
x
)
,
donde
x
es
el


n√∫mero
esperado
de
particiones
no
productivas
consecutivas
.


a.
Para
N
y
p
fijos
,
determine
la
eficiencia
de
este
protocolo
.


b.
Para
un
valor
fijo
N
,
determine
el
valor
de
p
que
maximiza
la
eficiencia
.


c.
Utilizando
el
valor
de
p
(
que
es
funci√≥n
de
N
)
calculado
en
el
apartado
(
b
)
,
deter-


mine
la
eficiencia
cuando
N
tiende
a
infinito
.


d.
Demuestre
que
esta
eficiencia
tiende
a
1
a
medida
que
aumenta
el
tama√±o
de
la


trama
.


P25
.
Suponga
que
dos
nodos
,
A
y
B
,
est√°n
conectados
en
los
extremos
opuestos
de
un
cable


de
800
metros
y
que
cada
uno
de
ellos
tiene
una
trama
de
1.500
bits
(
incluyendo
todas


las
cabeceras
y
pre√°mbulos
)
que
enviar
al
otro
.
Ambos
nodos
intentan
transmitir
en
el


instante
t
=
0
.
Suponga
que
existen
cuatro
repetidores
entre
A
y
B
,
cada
uno
de
los
cua-


les
inserta
un
retardo
de
20
bits
.
Suponga
que
la
velocidad
de
transmisi√≥n
es
de
100


Mbps
y
que
se
utiliza
CSMA
/
CD
con
intervalos
de
espera
(
backoff
)
que
son
m√∫ltiplos


de
512
bits
.
Despu√©s
de
la
primera
colisi√≥n
,
A
saca
K
=
0
y
B
saca
K
=
1
en
el
proto-


colo
de
backoff
exponencial
.
Ignore
la
se√±al
de
interferencia
y
el
retardo
de
96
perio-


dos
de
bit
.


a.
¬ø
Cu√°l
es
el
retardo
de
propagaci√≥n
unidireccional
(
incluyendo
los
retardos
de
los


repetidores
)
entre
A
y
B
en
segundos
?
Suponga
que
la
velocidad
de
propagaci√≥n
de


la
se√±al
es
igual
a
2
 
108
m
/
s.


b.
¬ø
En
qu√©
momento
(
en
segundos
)
habr√°
sido
entregado
completamente
a
B
el


paquete
de
A
?


c.
Ahora
suponga
que
s√≥lo
A
tiene
un
paquete
que
enviar
y
que
los
repetidores
se
sus-


tituyen
por
conmutadores
.
Suponga
que
cada
conmutador
tiene
un
retardo
de
pro-


cesamiento
de
20
bits
,
adem√°s
de
un
retardo
de
almacenamiento
y
reenv√≠o
.
¬ø
En
qu√©


momento
,
en
segundos
,
se
entregar√°
a
B
el
paquete
de
A
?


P26
.
En
el
est√°ndar
Ethernet
,
un
emisor
realiza
una
pausa
de
96
periodos
de
bit
entre
el
env√≠o


de
dos
tramas
consecutivas
.
Este
periodo
de
pausa
se
denomina
hueco
entre
tramas
y
se


utiliza
para
permitir
que
un
dispositivo
receptor
complete
el
procesamiento
de
una


trama
recibida
y
se
prepare
para
la
recepci√≥n
de
la
siguiente
.
Desde
que
el
est√°ndar


Ethernet
fuera
especificado
,
se
han
producido
importantes
avances
en
la
tecnolog√≠a
,


incluyendo
los
relativos
a
la
velocidad
de
los
procesadores
,
de
la
memoria
y
de
las
pro-


PROBLEMAS
491


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
491pias
velocidades
de
transmisi√≥n
Ethernet
.
Si
hubiera
que
reescribir
el
est√°ndar
,
¬ø
c√≥mo


afectar√≠an
estas
mejoras
al
hueco
entre
tramas
?


P27
.
Considere
la
Figura
5.38
del
Problema
P14
.
Proporcione
direcciones
MAC
e
IP
para


las
interfaces
del
host
A
,
de
ambos
routers
y
del
host
F.
Suponga
que
el
host
A
env√≠a


un
datagrama
al
host
F.
Indique
las
direcciones
MAC
de
origen
y
de
destino
conteni-


das
en
la
trama
que
encapsula
este
datagrama
IP
a
medida
que
la
trama
es
transmitida


(
i
)
de
A
al
router
de
la
izquierda
,
(
ii
)
desde
el
router
de
la
izquierda
al
router
de
la
dere-


cha
y
(
iii
)
desde
el
router
de
la
derecha
al
host
F.
Indique
tambi√©n
las
direcciones
IP
de


origen
y
de
destino
del
datagrama
IP
encapsulado
dentro
de
la
trama
en
cada
uno
de


estos
instantes
de
tiempo
.


P28
.
Suponga
ahora
que
el
router
de
la
izquierda
de
la
Figura
5.38
se
sustituye
por
un
con-


mutador
.
Los
hosts
A
,
B
,
C
y
D
y
el
router
de
la
derecha
se
conectan
en
estrella
a
ese


conmutador
.
Indique
las
direcciones
MAC
de
origen
y
de
destino
contenidas
en
la


trama
que
encapsula
a
este
datagrama
IP
,
a
medida
que
la
trama
se
transmite
(
i
)
desde


Aa
l
 
c
o
n
m
u
t
a
d
o
r
,
 
(
ii
)
desde
el
conmutador
al
router
de
la
derecha
y
(
iii
)
desde
el
router


de
la
derecha
a
F.
Indique
tambi√©n
las
direcciones
IP
de
origen
y
de
destino
contenidas


en
el
datagrama
IP
encapsulado
dentro
de
la
trama
en
cada
uno
de
estos
instantes
de


tiempo
.


P29
.
Considere
la
Figura
5.26
.
Suponga
que
todos
los
enlaces
son
a
100
Mbps
.
¬ø
Cu√°l
es
la


tasa
m√°xima
total
agregada
de
transferencia
que
puede
conseguirse
en
los
9
hosts
y
los


dos
servidores
de
esta
red
?
Puede
suponer
que
cualquier
host
o
servidor
puede
enviar


a
cualquier
otro
host
o
servidor
.
¬ø
Por
qu√©
?


P30
.
Suponga
que
los
tres
conmutadores
departamentales
de
la
Figura
5.26
se
sustituyen


por
concentradores
.
Todos
los
enlaces
son
a
100
Mbps
.
Responda
en
estas
condicio-


nes
a
las
cuestiones
planteadas
en
el
Problema
P29
.


P31
.
Suponga
que
todos
los
conmutadores
de
la
Figura
5.26
son
sustituidos
por
concentra-


dores
.
Todos
los
enlaces
son
a
100
Mbps
.
Responda
en
estas
condiciones
a
las
cuestio-


nes
planteadas
en
el
Problema
P29
.


P32
.
Considere
la
operaci√≥n
de
un
conmutador
con
aprendizaje
en
el
contexto
de
la
Figura


5.24
.
Suponga
que
(
i
)
B
env√≠a
una
trama
a
E
,
(
ii
)
E
responde
enviando
una
trama
a
B
,


(
iii
)
Ae
n
v
√≠
a
 
u
n
a
 
t
r
a
m
a
 
a
 
B
,
 
(
iv
)
B
responde
enviando
una
trama
a
A.
Inicialmente
,
la


tabla
del
conmutador
est√°
vac√≠a
.
Muestre
el
estado
de
la
tabla
del
conmutador
antes
y


despu√©s
de
cada
uno
de
estos
sucesos
.
Para
cada
suceso
,
identifique
el
enlace
o
los


enlaces
a
trav√©s
de
los
cuales
se
reenviar√°
la
trama
transmitida
y
justifique
brevemente


sus
respuestas
.


P33
.
En
este
problema
vamos
a
explorar
el
uso
de
peque√±os
paquetes
para
aplicaciones
de


Vo
z
 
s
o
b
r
e
 
I
P.
 
U
n
o
 
d
e
 
l
o
s
 
i
n
c
o
n
v
e
n
i
e
n
t
e
s
 
d
e
 
u
n
 
t
a
m
a
√±
o
 
d
e
 
p
a
q
u
e
t
e
 
p
e
q
u
e
√±
o
 
e
s
 
q
u
e
 
u
n
a


gran
parte
del
ancho
de
banda
del
enlace
es
consumido
por
los
bytes
de
sobrecarga
.


De
cara
al
an√°lisis
,
suponga
que
el
paquete
consta
de
P
bytes
de
datos
y
5
bytes
de


cabecera
.


a.
Considere
el
env√≠o
directo
de
un
origen
de
voz
codificado
digitalmente
.
Suponga


que
el
origen
se
codifica
a
una
velocidad
constante
de
128
kbps
.
Suponga
que
cada


paquete
se
rellena
completamente
antes
de
que
el
origen
env√≠e
el
paquete
a
la
red
.


492
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
492El
tiempo
requerido
para
rellenar
un
paquete
se
denomina
retardo
de
empaque-


tado
.
En
funci√≥n
de
L
,
determine
el
retardo
de
empaquetado
en
milisegundos
.


b.
Los
retardos
de
empaquetado
superiores
a
20
ms
pueden
dar
lugar
a
un
eco
percep-


tible
y
desagradable
.
Determine
el
retardo
de
empaquetado
para
L
=
1.500
bytes
(
lo


que
se
corresponde
aproximadamente
con
un
paquete
Ethernet
de
tama√±o
m√°ximo
)


y
para
L
=
50
(
lo
que
se
corresponde
con
un
paquete
ATM
)
.


c.
Calcule
el
retardo
de
almacenamiento
y
reenv√≠o
en
un
√∫nico
conmutador
para
una


velocidad
de
enlace
de
R
=
622
Mbps
para
L
=
1.500
bytes
y
para
L
=
50
bytes
.


d.
Comente
las
ventajas
de
utilizar
un
tama√±o
de
paquete
peque√±o
.


P34
.
Considere
el
√∫nico
conmutador
VLAN
de
la
Figura
5.30
y
suponga
que
se
conecta
un


router
externo
al
puerto
1
del
conmutador
.
Asigne
direcciones
IP
a
los
hosts
de
las


redes
IR
y
CC
y
a
la
interfaz
del
router
.
Indique
los
pasos
seguidos
tanto
en
la
capa
de


red
como
en
la
capa
de
enlace
para
transferir
un
datagrama
IP
desde
un
host
de
IE
a
un


host
de
CC
(
Sugerencia
:
vuelva
a
leer
en
el
texto
los
comentarios
acerca
de
la
Figura


5.19
)
.


P35
.
Considere
la
red
MPLS
mostrada
en
la
Figura
5.36
y
suponga
que
ahora
los
routers


R5
y
R6
son
compatibles
con
MPLS
.
Suponga
que
deseamos
realizar
la
ingenier√≠a
de


tr√°fico
de
modo
que
los
paquetes
procedentes
de
R6
y
destinados
a
A
se
conmuten


hacia
A
a
trav√©s
de
R6-R4-R3-R1
,
y
que
los
paquetes
procedentes
de
R5
destinados
a


As
e
 
c
o
n
m
u
t
e
n
 
a
 
t
r
a
v
√©
s
 
d
e
 
R
5
-
R
4
-
R
2
-
R
1
.
 
D
e
t
a
l
l
e
 
l
a
s
 
t
a
b
l
a
s
 
M
P
L
S
 
d
e
 
R
5
 
y
 
R
6
,
 
a
s
√≠


como
la
tabla
modificada
de
R4
,
que
har√≠an
esto
posible
.


P36
.
Considere
de
nuevo
el
mismo
escenario
que
el
problema
anterior
,
pero
suponga
que


los
paquetes
de
R6
destinados
a
D
se
conmutan
a
trav√©s
de
R6-R4-R3
,
mientras
que


los
paquetes
procedentes
de
R5
destinados
a
D
se
conmutan
a
trav√©s
de
R4-R2-R1-R3
.


Determine
las
tablas
MPLS
en
todos
los
routers
que
har√≠an
esto
posible
.


P37
.
En
este
problema
vamos
a
juntar
muchas
de
las
cosas
que
hemos
aprendido
acerca
de


los
protocolos
de
Internet
.
Suponga
que
entra
en
una
habitaci√≥n
,
se
conecta
a
Ether-


net
y
desea
descargar
una
p√°gina
web
.
¬ø
Cu√°les
son
todos
los
pasos
de
protocolo
que


tienen
lugar
,
comenzando
desde
el
instante
en
que
enciende
su
PC
y
hasta
el


momento
en
que
obtiene
la
p√°gina
web
?
Suponga
que
no
hay
nada
en
la
cach√©
DNS


ni
en
la
cach√©
del
navegador
cuando
enciende
su
PC
.
(
Sugerencia
:
los
pasos
incluyen


el
uso
de
los
protocolos
Ethernet
,
DHCP
,
ARP
,
DNS
,
TCP
y
HTTP
.
)
Indique
expl√≠ci-


tamente
en
sus
pasos
c√≥mo
se
obtienen
las
direcciones
IP
y
MAC
de
un
router
de


pasarela
.


Preguntas
para
la
discusi√≥n


Le
animamos
a
explorar
la
Web
a
la
hora
de
buscar
las
respuestas
para
las
siguientes
cues-


tiones
.


D1
.
Aproximadamente
,
¬ø
cu√°l
es
el
rango
de
precios
de
un
adaptador
a
10/100
Mbps
?
¬ø
Y


de
un
adaptador
Ethernet
Gigabit
?
¬ø
C√≥mo
son
estos
precios
,
comparados
con
un


m√≥dem
de
acceso
telef√≥nico
a
56
kbps
o
con
un
m√≥dem
ADSL
?


PREGUNTAS
PARA
LA
DISCUSI√ìN
493


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
493D2
.
El
precio
de
los
conmutadores
depende
a
menudo
del
n√∫mero
de
interfaces
(
tambi√©n


denominadas
puertos
en
la
jerga
de
las
redes
LAN
)
.
Aproximadamente
,
¬ø
cu√°l
es
el


rango
de
precio
actual
por
interfaz
para
un
conmutador
que
s√≥lo
dispone
de
interfaces


a
100
Mbps
?


D3
.
Muchas
de
las
funciones
de
un
adaptador
pueden
realizarse
en
un
software
que
se
eje-


cute
en
la
CPU
del
nodo
.
¬ø
Cu√°les
son
las
ventajas
y
desventajas
de
pasar
esta
funcio-


nalidad
del
adaptador
al
nodo
?


D4
.
Busque
en
la
Web
los
n√∫meros
de
protocolo
utilizados
en
una
trama
Ethernet
para
un


datagrama
IP
y
para
un
paquete
ARP
.


D5
.
Lea
las
referencias
[
Xiao
2000
,
Huang
2002
y
RFC
3346
]
acerca
de
la
ingenier√≠a
de


tr√°fico
mediante
MPLS
.
Enumere
una
serie
de
objetivos
de
la
ingenier√≠a
de
tr√°fico
.


¬ø
Cu√°les
de
estos
objetivos
s√≥lo
pueden
satisfacerse
utilizando
MPLS
y
cu√°les
otros


pueden
satisfacerse
utilizando
protocolos
existentes
no
MPLS
?
En
el
√∫ltimo
caso
,


¬ø
qu√©
ventajas
ofrece
MPLS
?


Pr√°cticas
de
laboratorio
con
Wireshark


En
el
sitio
web
del
libro
,
http://www.awl.com/kurose-ross
,
encontrar√°
una
pr√°ctica
de
labo-


ratorio
con
Wireshark
que
permite
examinar
el
funcionamiento
del
protocolo
IEEE
802.3
y


el
formato
de
trama
Wireshark
.


Una
segunda
pr√°ctica
de
laboratorio
con
Wireshark
examina
las
trazas
de
paquetes


tomadas
en
un
escenario
de
red
dom√©stica
similar
al
de
la
Figura
5.37
.


494
CAP√çTULO
5
‚Ä¢
LA
CAPA
DE
ENLACE
Y
LAS
REDES
DE
√ÅREA
LOCAL


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
494495


¬ø
Por
qu√©
decidi√≥
especializarse
en
el
campo
de
las
redes
?


Cuando
llegu√©
a
UCLA
como
estudiante
graduado
en
el
oto√±o
de
1969
,
mi
intenci√≥n
era
estudiar
teo-


r√≠a
de
control
.
Entonces
asisit√≠
a
las
clases
de
teor√≠a
de
colas
de
Leonard
Kleinrock
y
me
qued√©
muy


impresionado
.
Durante
un
tiempo
estuve
trabajando
en
el
control
adaptativo
de
sistemas
de
colas
,
como


posible
tema
de
mi
tesis
.
A
principios
de
1972
,
Larry
Roberts
inici√≥
el
proyecto
Satellite
System
de


ARPAnet
 
(
posteriormente
denominado
Packet
Satellite
)
.
El
profesor
Kleinrock
me
pidi√≥
que
me
unie-


ra
al
proyecto
.
Lo
primero
que
hicimos
fue
a√±adir
un
algoritmo
de
backoff
simple
,
aunque
realista
,
al


protocolo
ALOHA
con
particiones
.
Poco
despu√©s
,
me
encontr√©
con
numerosos
problemas
de
investi-


gaci√≥n
interesantes
,
como
el
problema
de
inestabilidad
de
ALOHA
y
la
necesidad
de
backoff
adaptati-


vo
,
temas
que
terminar√≠an
formando
el
n√∫cleo
de
mi
tesis
.


Usted
estuvo
muy
activo
en
los
primeros
d√≠as
de
Internet
en
la
d√©cada
de
1970
,
comenzando
sus


d√≠as
de
estudiante
en
UCLA
.
¬ø
C√≥mo
eran
las
cosas
entonces
?
¬ø
Alguien
imaginaba
lo
que
Internet


llegar√≠a
a
ser
?


La
atm√≥sfera
no
era
realmente
distinta
de
la
de
otros
proyectos
de
construcci√≥n
de
sistemas
que
yo


hab√≠a
conocido
en
la
industria
y
en
las
instituciones
acad√©micas
.
El
objetivo
inicialmente
establecido


para
ARPAnet
era
bastante
modesto
,
es
decir
,
lo
que
se
quer√≠a
era
proporcionar
acceso
a
una
serie
de


computadoras
muy
caras
desde
ubicaciones
remotas
,
de
modo
que
muchos
m√°s
cient√≠ficos
pudieran


utilizarlas
.
Sin
embargo
,
con
el
inicio
del
proyecto
Packet
Satellite
en
1972
y
del
proyecto
Packet


Radio
en
1973
,
los
objetivos
de
ARPA
se
hab√≠an
ampliado
sustancialmente
.
En
1973
,
ARPA
estaba


construyendo
tres
redes
de
paquetes
distintas
al
mismo
tiempo
y
Vint
Cerf
y
Bob
Kahn
se
vieron
obli-


gados
a
desarrollar
una
estrategia
de
interconexi√≥n
.


En
aquel
entonces
,
todos
estos
desarrollos
progresivos
en
el
campo
de
las
redes
se
ve√≠an
(
o
eso


cre√≠a
)
m√°s
que
como
algo
l√≥gico
que
como
algo
m√°gico
.
Nadie
podr√≠a
haber
previsto
la
escala
de


Internet
y
la
potencia
actual
de
las
computadoras
personales
.
Pas√≥
una
d√©cada
antes
de
que
aparecie-


ran
los
primeros
PC
.
Para
poner
las
cosas
en
perspectiva
,
la
mayor√≠a
de
los
estudiantes
enviaban
sus


programas
de
computadora
en
forma
de
pilas
de
fichas
perforadas
,
para
su
procesamiento
por
lotes
.


S√≥lo
algunos
estudiantes
ten√≠an
acceso
directo
a
las
computadoras
,
que
normalmente
estaban
ubicadas


en
√°reas
restringidas
.
Los
m√≥dems
eran
lentos
y
constitu√≠an
todav√≠a
una
rareza
.
Como
estudiante
gra-


Simon
S.
Lam


Simon
S.
Lam
es
catedr√°tico
y
Regent
Chair
del
Departamento
de


Ciencias
de
la
Computaci√≥n
de
la
Universidad
de
Texas
en
Austin
.


Entre
1971
y
1974
estuvo
trabajando
en
el
Centro
de
Medidas
de


Red
de
ARPA
en
UCLA
,
donde
trabaj√≥
con
conmutaci√≥n
de
paquetes


v√≠a
sat√©lite
y
v√≠a
radio
.
Dirigi√≥
un
grupo
de
investigaci√≥n
que
invent√≥
los


sockets
seguros
y
prototip√≥
,
en
1993
,
la
primera
capa
de
sockets


seguros
(
SSL
)
denominada
Secure
Network
Programming
,
que
gan√≥
el


premio
al
mejor
sistema
software
de
ACM
en
2004
.
Sus
intereses
de


investigaci√≥n
se
encuentran
en
el
campo
del
dise√±o
y
el
an√°lisis
de


protocolos
de
red
y
servicios
de
seguridad
.
Se
gradu√≥
en
la
universidad


del
Estado
de
Washington
,
obteniendo
su
m√°ster
y
su
doctorado
en


UCLA
.
Fue
elegido
para
la
Academia
Nacional
de
Ingenier√≠a
en
2007
.


ENTREVISTA
CON
...


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
495496


duado
lo
√∫nico
que
yo
ten√≠a
era
un
tel√©fono
sobre
mi
mesa
y
utilizaba
l√°piz
y
papel
para
hacer
la
mayor


parte
de
mi
trabajo
.


¬ø
Hacia
d√≥nde
cree
que
se
encaminan
el
campo
de
la
redes
e
Internet
?


En
el
pasado
,
la
simplicidad
del
protocolo
IP
de
Internet
era
su
mayor
fortaleza
a
la
hora
de
vencer


otras
soluciones
competidoras
y
convertirse
en
el
est√°ndar
de
facto
para
la
comunicaci√≥n
entre
redes
.


Ad
i
f
e
r
e
n
c
i
a
 
d
e
 
o
t
r
a
s
 
s
o
l
u
c
i
o
n
e
s
 
c
o
m
p
e
t
i
d
o
r
a
s
,
 
c
o
m
o
 
X
.
2
5
 
e
n
 
l
a
 
d
√©
c
a
d
a
 
d
e
 
1
9
8
0
 
y
 
A
T
M
 
e
n
 
l
a
 
d
√©
c
a
d
a


de
1990
,
IP
puede
ejecutarse
por
encima
de
cualquier
tecnolog√≠a
de
red
de
la
capa
de
enlace
,
porque


ofrece
√∫nicamente
un
servicio
de
datagramas
de
mejor
esfuerzo
.
Por
tanto
,
cualquier
red
de
paquetes


puede
conectarse
a
Internet
.


Hoy
d√≠a
,
la
mayor
fortaleza
de
IP
es
en
realidad
una
desventaja
.
IP
es
como
una
especie
de
cami-


sa
de
fuerza
que
hace
que
los
desarrollos
de
Internet
queden
constre√±idos
a
una
serie
de
direcciones


espec√≠ficas
.
En
los
√∫ltimos
a√±os
muchos
investigadores
han
redirigido
sus
esfuerzos
,
concentr√°ndose


√∫nicamente
en
la
capa
de
aplicaci√≥n
.
Tambi√©n
se
est√°n
desarrollando
numerosas
investigaciones
en
el


campo
de
las
redes
inal√°mbricas
ad
hoc
,
de
las
redes
de
sensores
y
de
las
redes
por
sat√©lite
.
Estas
redes


pueden
verse
como
sistemas
aut√≥nomos
o
como
sistemas
de
la
capa
de
enlace
,
pudiendo
florecer
ese


tipo
de
sistemas
porque
caen
fuera
de
la
camisa
de
fuerza
representada
por
IP
.


Muchas
personas
est√°n
entusiasmadas
con
las
posibilidades
que
los
sistemas
P2P
ofrecen
como


plataforma
para
el
desarrollo
de
aplicaciones
de
Internet
novedosas
.
Sin
embargo
,
los
sistemas
P2P
son


muy
ineficientes
en
su
uso
en
los
recursos
de
Internet
.
Una
de
las
cosas
que
me
preocupa
es
si
la
capa-


cidad
de
transmisi√≥n
y
de
conmutaci√≥n
del
n√∫cleo
de
Internet
continuar√°n
increment√°ndose
m√°s
r√°pi-


do
que
la
demanda
de
tr√°fico
a
medida
que
Internet
crezca
para
interconectar
todo
tipo
de
dispositivos


y
soportar
las
futuras
aplicaciones
de
tipo
P2P.
Sin
un
sustancial
sobredimensionamiento
de
la
capaci-


dad
,
garantizar
la
estabilidad
de
la
red
en
presencia
de
ataques
maliciosos
y
de
congesti√≥n
continuar√°


representando
un
enorme
desaf√≠o
.


El
enorme
crecimiento
de
Internet
tambi√©n
requiere
asignar
nuevas
direcciones
IP
a
gran
veloci-


dad
a
los
operadores
de
red
y
a
las
empresas
de
todo
el
mundo
.
A
la
velocidad
actual
,
el
conjunto
de


direcciones
IPv4
no
asignadas
se
agotar√°
en
unos
pocos
a√±os
.
Cuando
eso
suceda
,
s√≥lo
podr√°n
asig-


narse
grandes
bloques
contiguos
del
espacio
de
direcciones
a
partir
del
espacio
de
direcciones
de
IPv6
.


Como
la
adopci√≥n
de
IPv6
est√°
siendo
lenta
en
un
principio
,
debido
a
la
falta
de
incentivos
para
los


nuevos
usuarios
,
lo
m√°s
probable
es
que
IPv4
e
IPv6
coexistan
en
Internet
durante
muchos
a√±os
toda-


v√≠a
.
Una
migraci√≥n
satisfactoria
desde
una
Internet
predominantemente
IPv4
a
otra
predominantemen-


te
IPv6
requerir√°
un
sustancial
esfuerzo
global
.


¬ø
Cu√°l
es
la
parte
m√°s
atractiva
de
su
trabajo
?


La
parte
m√°s
atractiva
de
mi
trabajo
como
profesor
es
ense√±ar
y
motivar
a
todos
los
alumnos
de
mi


clase
y
a
todos
los
estudiantes
de
doctorado
a
los
que
superviso
,
en
lugar
de
concentrarme
s√≥lo
en
los


m√°s
brillantes
.
Las
personas
muy
brillantes
y
motivadas
pueden
requerir
alguna
gu√≠a
pero
no
mucho


m√°s
.
A
menudo
aprendo
m√°s
de
estos
estudiantes
de
lo
que
ellos
aprenden
de
m√≠
.
Lo
m√°s
atractivo
,
el


mayor
desaf√≠o
,
es
educar
y
motivar
a
los
estudiantes
que
no
son
sobresalientes
.


¬ø
Qu√©
impacto
cree
que
tendr√°
la
tecnolog√≠a
en
el
futuro
sobre
la
ense√±anza
?


Antes
o
despu√©s
,
casi
todos
los
conocimientos
humanos
ser√°n
accesibles
a
trav√©s
de
Internet
,
que
ser√°


la
herramienta
m√°s
potente
para
el
aprendizaje
.
Esta
enorme
base
de
conocimientos
nos
dar√°
la
posi-


bilidad
de
nivelar
el
campo
de
juego
para
los
estudiantes
de
todo
el
mundo
.
Por
ejemplo
,
los
estudian-


tes
motivados
en
cualquier
pa√≠s
podr√°n
acceder
a
los
sitios
web
de
primera
fila
,
a
conferencias
multi-


media
y
a
materiales
formativos
.
Hoy
d√≠a
,
se
dice
que
las
bibliotecas
digitales
de
IEEE
y
ACM
han
ace-


lerado
el
desarrollo
de
las
investigaciones
en
ciencias
de
la
computaci√≥n
en
China
.
Con
el
tiempo
,


Internet
eliminar√°
todas
las
barreras
geogr√°ficas
en
lo
que
a
la
ense√±anza
se
refiere
.


M05_KUROSE.qxd
 
21/3/10
 
13:22
 
P√°gina
496CAP√çTULO
6


Redes


inal√°mbricas


y
m√≥viles


497


En
el
mundo
de
la
telefon√≠a
,
los
√∫ltimos
15
a√±os
han
sido
indudablemente
la
edad
dorada
de


la
telefon√≠a
celular
.
El
n√∫mero
de
abonados
a
los
servicios
de
telefon√≠a
celular
en
todo
el


mundo
ha
pasado
de
34
millones
en
1993
a
4.000
millones
a
finales
de
2008
,
sobrepasando


ahora
el
n√∫mero
de
abonados
celulares
al
de
l√≠neas
telef√≥nicas
normales
[
ITU
Statistics


2009
]
.
Las
numerosas
ventajas
de
los
tel√©fonos
celulares
son
evidentes
para
todo
el
mundo
:


disponemos
de
acceso
a
la
red
de
telefon√≠a
global
en
cualquier
momento
,
en
cualquier
lugar


y
sin
ning√∫n
tipo
de
restricci√≥n
,
utilizando
un
dispositivo
ligero
y
muy
port√°til
.
Con
la
lle-


gada
de
las
computadoras
port√°tiles
,
las
computadoras
de
mano
,
las
PDA
y
su
promesa
de


disponer
de
un
acceso
en
cualquier
momento
,
en
cualquier
lugar
y
sin
ning√∫n
tipo
de
restric-


ci√≥n
a
la
Internet
global
,
¬ø
nos
estamos
aproximando
a
una
explosi√≥n
similar
en
el
uso
de
dis-


positivos
Internet
inal√°mbricos
?


Independientemente
del
futuro
crecimiento
del
uso
de
dispositivos
Internet
inal√°mbri-


cos
,
ya
est√°
claro
que
las
redes
inal√°mbricas
y
los
servicios
relacionados
con
la
movilidad


que
esas
redes
hacen
posibles
est√°n
aqu√≠
para
quedarse
entre
nosotros
.
Desde
el
punto
de


vista
de
la
comunicaci√≥n
por
red
,
los
desaf√≠os
planteados
por
estas
redes
,
particularmente
en


las
capas
de
enlace
de
datos
y
de
red
,
son
tan
diferentes
de
los
de
las
redes
 
de
computadoras


cableadas
tradicionales
,
que
resulta
imperativo
dedicar
todo
un
cap√≠tulo
(
es
decir
,
este
cap√≠-


tulo
)
al
estudio
de
las
redes
inal√°mbricas
y
m√≥viles
.


Comenzaremos
el
cap√≠tulo
con
un
estudio
de
los
usuarios
m√≥viles
,
los
enlaces
inal√°m-


bricos
y
las
redes
inal√°mbricas
,
as√≠
como
de
su
relaci√≥n
con
las
redes
de
mayor
tama√±o
(
nor-


malmente
cableadas
)
a
las
que
se
conectan
.
Estableceremos
la
distinci√≥n
entre
los
desaf√≠os


planteados
por
la
naturaleza
inal√°mbrica
de
los
enlaces
de
comunicaciones
en
dichas
redes


y
por
la
movilidad
que
esos
enlaces
inal√°mbricos
permiten
.
Al
realizar
esta
importante
dis-


tinci√≥n
entre
el
car√°cter
inal√°mbrico
y
la
movilidad
,
podremos
aislar
,
identificar
y
dominar


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
497498
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


mucho
mejor
los
conceptos
clave
de
cada
una
de
las
√°reas
.
Observe
que
existen
,
por


supuesto
,
muchos
entornos
de
red
en
los
que
los
nodos
de
red
son
inal√°mbricos
pero
no


m√≥viles
(
por
ejemplo
,
redes
inal√°mbricas
dom√©sticas
o
empresariales
con
estaciones
de
tra-


bajo
est√°ticas
y
grandes
pantallas
de
computadora
)
,
y
que
existen
formas
de
movilidad
que


no
requieren
de
enlaces
inal√°mbricos
(
por
ejemplo
,
un
trabajador
que
utiliza
una
computa-


dora
port√°til
con
conexi√≥n
por
cable
en
casa
,
apaga
la
computadora
va
hasta
la
oficina
y


conecta
la
computadora
a
la
red
cableada
de
la
empresa
)
.
Por
supuesto
,
muchos
de
los
entor-


nos
de
red
m√°s
atractivos
son
aquellos
en
los
que
los
usuarios
son
a
la
vez
inal√°mbricos
y


m√≥viles
;
por
ejemplo
,
un
escenario
en
el
que
un
usuario
m√≥vil
(
situado
por
ejemplo
en
el


asiento
posterior
de
un
veh√≠culo
)
mantiene
una
llamada
de
voz
sobre
IP
y
m√∫ltiples
conexio-


nes
TCP
activas
,
mientras
el
veh√≠culo
circula
por
la
autopista
a
160
kil√≥metros
por
hora
.
Es


aqu√≠
,
en
la
intersecci√≥n
del
car√°cter
inal√°mbrico
y
la
movilidad
,
donde
encontraremos
los


desaf√≠os
t√©cnicos
m√°s
interesantes
.


Comenzaremos
ilustrando
el
entorno
que
vamos
a
emplear
para
nuestro
an√°lisis
de
la


comunicaci√≥n
inal√°mbrica
y
la
movilidad
:
una
red
en
la
que
hay
una
serie
de
usuarios
ina-


l√°mbricos
(
y
posiblemente
m√≥viles
)
conectados
a
otra
infraestructura
de
red
de
mayor


tama√±o
mediante
un
enlace
inal√°mbrico
situado
en
la
frontera
de
la
red
.
A
continuaci√≥n
,


pasaremos
a
estudiar
las
caracter√≠sticas
de
este
enlace
inal√°mbrico
en
la
Secci√≥n
6.2
.
Inclui-


mos
una
breve
introducci√≥n
al
Acceso
m√∫ltiple
por
divisi√≥n
de
c√≥digo
(
CDMA
,
Code
Divi-


sion
Multiple
Access
)
,
un
protocolo
de
acceso
a
un
medio
compartido
que
se
emplea
a


menudo
en
las
redes
inal√°mbricas
.
Dicho
estudio
lo
haremos
tambi√©n
en
la
Secci√≥n
6.2
.
En


la
Secci√≥n
6.3
,
examinaremos
con
un
cierto
grado
de
profundidad
los
aspectos
de
nivel
de


enlace
del
est√°ndar
de
red
LAN
inal√°mbrica
IEEE
802.11
(
WiFi
)
;
tambi√©n
dedicaremos
unas


pocas
palabras
a
Bluetooth
y
WiMAX
.
En
la
Secci√≥n
6.4
veremos
una
panor√°mica
del


acceso
celular
a
Internet
,
incluyendo
las
emergentes
tecnolog√≠as
celulares
3
G
que
propor-


cionan
tanto
voz
como
acceso
a
Internet
a
alta
velocidad
.
En
la
Secci√≥n
6.5
fijaremos
nues-


tra
atenci√≥n
en
la
movilidad
,
centr√°ndonos
en
los
problemas
de
localizar
a
un
usuario
m√≥vil
,


efectuar
el
enrutamiento
hasta
ese
usuario
m√≥vil
e
ir
‚Äú
transfiriendo
‚Äù
al
usuario
m√≥vil
,
que
se


est√°
desplazando
din√°micamente
desde
un
punto
de
conexi√≥n
a
la
red
hasta
otro
.
Examina-


remos
c√≥mo
se
implementan
estos
servicios
m√≥viles
en
el
est√°ndar
de
IP
m√≥vil
y
en
GSM


en
las
Secciones
 
6.6
y
6.7
,
respectivamente
.
Por
√∫ltimo
,
en
la
Secci√≥n
6.8
,
consideraremos


el
impacto
de
los
enlaces
inal√°mbricos
y
la
movilidad
sobre
los
protocolos
de
la
capa
de


transporte
y
las
aplicaciones
en
red
.


6.1
Introducci√≥n


La
Figura
6.1
muestra
el
escenario
con
el
que
vamos
a
analizar
los
temas
de
la
comunica-


ci√≥n
inal√°mbrica
de
datos
y
la
movilidad
.
Comenzaremos
manteniendo
nuestro
estudio
en


un
nivel
lo
suficientemente
general
como
para
cubrir
un
amplio
rango
de
redes
,
incluyendo


tanto
las
redes
LAN
inal√°mbricas
(
como
por
ejemplo
IEEE
802.11
)
y
las
redes
celulares


(
como
una
red
3
G
)
;
en
secciones
posteriores
profundizaremos
en
un
an√°lisis
m√°s
detallado


de
determinadas
arquitecturas
inal√°mbricas
m√°s
espec√≠ficas
.
Dentro
de
una
red
inal√°mbrica


podemos
identificar
los
siguientes
elementos
:


‚Ä¢
Hosts
inal√°mbricos
.
Como
en
el
caso
de
las
redes
cableadas
,
los
hosts
son
los
dispositi-


vos
que
act√∫an
como
sistemas
terminales
y
que
ejecutan
las
aplicaciones
.
Un
host
ina-


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
4986.1
‚Ä¢
INTRODUCCI√ìN
499


l√°mbrico
puede
ser
una
computadora
port√°til
,
una
computadora
de
mano
,
una
PDA
,
un


tel√©fono
o
una
computadora
de
escritorio
.
Los
hosts
en
s√≠
pueden
ser
m√≥viles
o
no
.


‚Ä¢
Enlaces
inal√°mbricos
.
Un
host
se
conecta
a
una
estaci√≥n
base
(
definida
m√°s
adelante
)
o


a
otro
host
inal√°mbrico
a
trav√©s
de
un
enlace
de
comunicaciones
inal√°mbrico
.
Las
dife-


rentes
tecnolog√≠as
de
enlace
inal√°mbrico
tienen
distintas
velocidades
de
transmisi√≥n
y


pueden
transmitir
a
diferentes
distancias
.
La
Figura
6.2
muestra
dos
caracter√≠sticas
clave


(
√°rea
de
cobertura
y
velocidad
del
enlace
)
de
los
est√°ndares
m√°s
populares
de
redes
ina-


l√°mbricas
.
(
La
figura
s√≥lo
pretende
proporcionar
una
idea
aproximada
de
estas
caracte-


r√≠sticas
.
Por
ejemplo
,
algunos
de
estos
tipos
de
redes
s√≥lo
ahora
se
est√°n
comenzado
a


implantar
y
algunas
velocidades
de
enlace
pueden
aumentar
o
disminuir
respecto
a
los


valores
mostrados
,
dependiendo
de
la
distancia
,
de
las
condiciones
del
canal
y
del


n√∫mero
de
usuarios
en
la
red
inal√°mbrica
.
)
Nos
ocuparemos
de
estos
est√°ndares
m√°s
ade-


ACCESO
WIFI
P√öBLICO
:
¬ø
ESTAR√Å
PRONTO
DISPONIBLE
EN
LOS
SEM√ÅFOROS
?


Los
puntos
de
acceso
WiFi
(
WiFi
hotspots
,
ubicaciones
p√∫blicas
en
las
que
los
usuarios
pue-


den
encontrar
acceso
inal√°mbrico
802.11
)
est√°n
siendo
cada
vez
m√°s
comunes
en
los
hote-


les
,
aeropuertos
y
caf√©s
de
todo
el
mundo
.


A
finales
de
2008
,
T-Mobile
proporciona
accesos
de
este
tipo
en
m√°s
de
10.000


ubicaciones
de
Estados
Unidos
(
y
en
m√°s
de
45.000
en
todo
el
mundo
)
,
incluyendo
las


cafeter√≠as
Starbucks
y
las
tiendas
Borders
Books
&
Music
.
La
mayor√≠a
de
los
campus
universi-


tarios
ofrecen
un
acceso
inal√°mbrico
ubicuo
y
resulta
dif√≠cil
encontrar
un
hotel
en
el
que
no


exista
acceso
inal√°mbrico
a
Internet
.
Muchas
ciudades
,
entre
las
que
se
incluyen
Filadelfia
,


San
Francisco
,
Toronto
y
Hong
Kong
han
anunciado
planes
para
proporcionar
acceso
ina-


l√°mbrico
ubicuo
dentro
de
la
ciudad
.
El
objetivo
en
Filadelfia
era
‚Äú
convertir
Filadelfia
en
el


√°rea
de
acceso
WiFi
m√°s
grande
de
Estados
Unidos
y
ayudar
a
mejorar
la
educaci√≥n
,


eliminar
las
diferencias
sociales
de
car√°cter
digital
,
mejorar
el
desarrollo
de
los
barrios
y


reducir
el
coste
de
administraci√≥n
‚Äù
.
Inicialmente
el
plan
requer√≠a
instalar
puntos
de
acceso


inal√°mbrico
802.11b
en
,
aproximadamente
,
4.000
sem√°foros
y
dispositivos
de
control
de


tr√°fico
.
El
ambicioso
programa
,
un
acuerdo
entre
la
ciudad
,
Wireless
Philadelphia
(
una
enti-


dad
sin
√°nimo
de
lucro
)
y
Earthlink
(
un
proveedor
de
servicios
Internet
)
,
ha
llegado
a
cons-


truir
una
red
operativa
.
El
proyecto
GovWiFi
de
Hong
Kong
‚Äù
proporcionar√°
servicio
Wi-Fi


gratuito
en
350
oficinas
gubernamentales
en
una
serie
de
fases
.
Se
situar√°n
unos
2.000


puntos
de
acceso
Wi-Fi
p√∫blicos
dentro
del
territorio
y
se
har√°
de
Hong
Kong
una
ciudad


inal√°mbrica
,
con
cerca
de
10.000
puntos
de
acceso
Wi-Fi
p√∫blicos
en
2009
‚Äù
.


Sin
embargo
,
llevar
a
cabo
planes
para
un
acceso
WiFi
ubicuo
a
nivel
municipal


presenta
ciertas
dificultades
.
La
red
WiFi
municipal
de
San
Francisco
nunca
ha
llegado
a


pasar
de
la
fase
de
propuesta
.
En
2008
,
Earthlink
di√≥
por
finalizado
su
servicio
WiFi
en


Filadelfia
.
Pero
la
red
WiFi
municipal
que
opera
en
el
centro
de
Toronto
y
que
no
es
gratuita


contin√∫a
estando
operativa
,
as√≠
como
las
redes
WiFi
municipales
de
otras
varias
ciudades


y
pueblos
m√°s
peque√±os
.
Los
intentos
de
disponer
de
redes
inal√°mbricas
municipales


contin√∫an
.
http://www.muniwireless.com/
es
un
sitio
web
en
el
que
se
realiza
un


seguimiento
del
panorama
,
siempre
cambiante
,
de
las
redes
inal√°mbricas
municipales
.


HISTORIA


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
499lante
a
lo
largo
de
la
primera
mitad
de
este
cap√≠tulo
;
tambi√©n
consideraremos
otras
carac-


ter√≠sticas
de
los
enlaces
inal√°mbricos
,
como
sus
tasas
de
error
de
bit
y
las
causas
de
esos


errores
,
en
la
Secci√≥n
6.2
.


En
la
Figura
6.1
una
serie
de
enlaces
inal√°mbricos
conectan
a
un
conjunto
de
hosts


inal√°mbricos
ubicados
en
la
frontera
de
la
red
con
la
infraestructura
de
esa
red
de


mayor
tama√±o
.
Conviene
a√±adir
que
los
enlaces
inal√°mbricos
tambi√©n
se
utilizan
en


ocasiones
dentro
de
una
red
para
conectar
entre
s√≠
routers
,
conmutadores
y
otros
equi-


pos
de
red
.
Sin
embargo
,
nuestro
enfoque
en
este
cap√≠tulo
se
centrar√°
en
el
uso
de
las


comunicaciones
inal√°mbricas
alrededor
de
las
fronteras
de
la
red
,
ya
que
es
ah√≠
donde


podemos
encontrar
los
desaf√≠os
t√©cnicos
m√°s
atractivos
y
donde
se
est√°
experimentado


un
aut√©ntico
crecimiento
.


‚Ä¢
Estaci√≥n
base
.
La
estaci√≥n
base
es
una
parte
clave
de
la
infraestructura
de
la
red
inal√°m-


brica
.
A
diferencia
del
host
inal√°mbrico
y
de
los
enlaces
inal√°mbricos
,
una
estaci√≥n
base


no
tiene
un
equivalente
obvio
dentro
de
las
redes
cableadas
.
La
estaci√≥n
base
es
respon-


sable
de
enviar
y
recibir
datos
(
es
decir
,
paquetes
)
hacia
y
desde
un
host
inal√°mbrico
que


est√©
asociado
con
esa
estaci√≥n
base
.
La
estaci√≥n
base
ser√°
a
menudo
responsable
de
coor-


dinar
la
transmisi√≥n
de
los
m√∫ltiples
hosts
inal√°mbricos
que
est√©n
asociados
con
ella
.


Cuando
decimos
que
un
host
inal√°mbrico
est√°
‚Äú
asociado
‚Äù
con
una
estaci√≥n
base
,
quere-


mos
decir
que
(
1
)
el
host
se
encuentra
dentro
de
la
distancia
m√°xima
de
comunicaci√≥n


500
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Infraestructura


de
red


Clave
:


Punto
de
acceso
inal√°mbrico


√Årea
de
cobertura


Host
inal√°mbrico


Host
inal√°mbrico
en
movimiento


Figura
6.1
‚Ä¢
Elementos
de
una
red
inal√°mbrica
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
500inal√°mbrica
de
la
estaci√≥n
base
y
(
2
)
el
host
utiliza
la
estaci√≥n
base
para
reenviar
datos


hacia
y
desde
la
red
de
mayor
tama√±o
.
Las
torres
de
telefon√≠a
en
las
redes
celulares
y


los
puntos
de
acceso
en
las
redes
LAN
inal√°mbricas
802.11
son
ejemplos
de
estaciones


base
.


En
la
Figura
6.1
,
la
estaci√≥n
base
est√°
conectada
a
la
red
de
mayor
tama√±o
(
por
ejemplo
,


a
Internet
,
a
una
red
dom√©stica
o
corporativa
o
a
una
red
telef√≥nica
)
,
funcionando
as√≠


como
retransmisor
de
la
capa
de
enlace
entre
el
host
inal√°mbrico
y
el
resto
del
mundo


con
el
que
el
host
se
comunica
.


De
los
hosts
asociados
con
una
estaci√≥n
base
se
suele
decir
que
operan
en
modo
de


infraestructura
,
puesto
que
todos
los
servicios
de
red
tradicionales
(
como
por
ejem-


plo
,
la
asignaci√≥n
de
direcciones
y
el
enrutamiento
)
son
proporcionados
por
la
red
con


la
que
un
host
se
conecta
a
trav√©s
de
la
estaci√≥n
base
.
En
las
redes
ad
hoc
,
los
hosts


inal√°mbricos
no
tienen
ninguna
infraestructura
de
ese
tipo
a
la
que
conectarse
.
En


ausencia
de
dicha
infraestructura
,
los
propios
hosts
tienen
que
proporcionar
servicios


tales
como
el
enrutamiento
,
la
asignaci√≥n
de
direcciones
,
la
traducci√≥n
de
nombres
de


tipo
DNS
,
etc.


Cuando
un
host
m√≥vil
se
desplaza
fuera
del
alcance
de
una
estaci√≥n
base
y
entra
dentro


del
√°rea
de
cobertura
de
otra
,
cambia
su
punto
de
conexi√≥n
con
la
red
de
mayor
tama√±o


(
es
decir
,
cambia
la
estaci√≥n
base
con
la
que
est√°
asociado
)
;
este
proceso
se
conoce
con


el
nombre
de
transferencia
(
handoff
)
.
Este
tipo
de
movilidad
plantea
numerosos
y
com-


plejos
problemas
.
Si
un
host
puede
moverse
,
¬ø
c√≥mo
podemos
averiguar
la
ubicaci√≥n


actual
del
host
m√≥vil
dentro
de
la
red
,
para
poder
reenviar
datos
a
ese
host
m√≥vil
?
¬ø
C√≥mo


se
lleva
a
cabo
el
direccionamiento
,
sabiendo
que
un
host
puede
estar
en
una
de
muchas


posibles
ubicaciones
?
Si
el
host
se
mueve
durante
una
conexi√≥n
TCP
o
llamada
telef√≥-


nica
,
¬ø
c√≥mo
se
pueden
enrutar
los
datos
,
para
que
la
conexi√≥n
contin√∫e
activa
de
forma


6.1
‚Ä¢
INTRODUCCI√ìN
501


802.11a
,
g


802.11n


802.11a
,
g
punto
a
punto


WiMAX802.11b


UMTS
/
WCDMA-HSDPA
,
CDMA2000-1xEVDO


802.15.1


UMTS
/
WCDMA
,
CDMA2000


IS-95
,
CDMA
,
GSM


Interiores
Exteriores
Exteriores


alcance
medio


Exteriores


largo
alcance


3
G


2
G


10‚Äì30
m
50‚Äì200
m
200m‚Äì4
km
5
km‚Äì20
km


54
Mbps


4
Mbps


5‚Äì11
Mbps


200
Mbps


1
Mbps


384
kbps


56
kbps


3
G


mejorado


Figura
6.2
‚Ä¢
Caracter√≠sticas
del
enlace
para
una
serie
de
est√°ndares
selecciona-


dos
de
redes
inal√°mbricas
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
501ininterrumpida
?
√âstas
y
otras
muchas
(
¬°
much√≠simas
!
)
cuestiones
hacen
de
las
redes
ina-


l√°mbricas
y
m√≥viles
un
√°rea
de
investigaci√≥n
particularmente
atractiva
.


‚Ä¢
Infraestructura
de
red
.
√âsta
es
la
red
de
mayor
tama√±o
con
la
que
un
host
inal√°mbrico


puede
querer
comunicarse
.


Habiendo
examinado
los
elementos
de
una
red
inal√°mbrica
,
observemos
que
estos
ele-


mentos
pueden
combinarse
de
muchas
formas
distintas
para
componer
distintos
tipos
de


redes
inal√°mbricas
.
Conocer
una
taxonom√≠a
de
estos
tipos
de
redes
inal√°mbricas
puede
ser


√∫til
a
la
hora
de
leer
este
cap√≠tulo
o
a
la
hora
de
leer
o
aprender
m√°s
acerca
de
las
redes


inal√°mbricas
m√°s
all√°
de
lo
que
en
este
libro
se
expone
.
En
el
nivel
m√°s
general
,
podemos


clasificar
las
redes
inal√°mbricas
seg√∫n
dos
criterios
:
(
i
)
si
un
paquete
dentro
de
la
red
ina-


l√°mbrica
realiza
exactamente
un
salto
inal√°mbrico
o
varios
saltos
inal√°mbricos
y
(
ii
)
si


existe
una
infraestructura
,
como
por
ejemplo
una
estaci√≥n
base
,
dentro
de
la
red
:


‚Ä¢
Redes
basadas
en
infraestructura
y
un
√∫nico
salto
.
Estas
redes
tienen
una
estaci√≥n
base


conectada
a
una
red
cableada
de
mayor
tama√±o
(
por
ejemplo
,
Internet
)
.
Adem√°s
,
toda
la


comunicaci√≥n
se
realiza
entre
esta
estaci√≥n
base
y
un
host
inal√°mbrico
,
con
un
√∫nico


salto
inal√°mbrico
.
Las
redes
802.11
que
utilizamos
en
las
aulas
,
en
las
cafeter√≠as
o
en
las


bibliotecas
;
las
redes
de
telefon√≠a
celular
y
las
redes
802.16
WiMAX
,
de
las
que
pronto


hablaremos
,
caen
todas
ellas
dentro
de
esta
categor√≠a
.


‚Ä¢
Redes
sin
infraestructura
y
un
√∫nico
salto
.
En
estas
redes
no
existe
una
estaci√≥n
base


conectada
a
una
red
inal√°mbrica
.
Sin
embargo
,
como
veremos
,
uno
de
los
nodos
de
esta


red
de
un
√∫nico
salto
puede
coordinar
las
transmisiones
de
los
restantes
nodos
.
Las
redes


Bluetooth
(
que
estudiaremos
en
la
Secci√≥n
6.3.6
)
y
las
redes
802.11
en
modo
ad
hoc
son


redes
sin
infraestructura
y
de
un
√∫nico
salto
.


‚Ä¢
Redes
basadas
en
infraestructura
y
m√∫ltiples
saltos
.
En
estas
redes
existe
una
estaci√≥n


base
que
est√°
cableada
a
la
red
de
mayor
tama√±o
.
Sin
embargo
,
algunos
nodos
inal√°mbri-


cos
pueden
tener
que
retransmitir
sus
comunicaciones
a
trav√©s
de
otros
nodos
inal√°m-


bricos
con
el
fin
de
comunicarse
a
trav√©s
de
la
estaci√≥n
base
.
Algunas
redes
de
sensores


inal√°mbricos
y
las
denominadas
redes
de
malla
inal√°mbricas
caen
dentro
de
esta
cate-


gor√≠a
.


‚Ä¢
Redes
sin
infraestructura
y
m√∫ltiples
saltos
.
En
estas
redes
no
existe
una
estaci√≥n
base
y


los
nodos
pueden
tener
que
retransmitir
sus
mensajes
a
trav√©s
de
otros
diversos
nodos


para
alcanzar
un
cierto
destino
.
Los
nodos
tambi√©n
pueden
ser
m√≥viles
,
con
lo
que
la


conectividad
entre
los
nodos
ir√°
variando
,
lo
que
constituye
una
clase
de
redes
conocidas


con
el
el
nombre
de
redes
m√≥viles
ad
hoc
(
MANET
,
Mobile
ad
hoc
network
)
.
Si
los


nodos
m√≥viles
son
veh√≠culos
,
la
red
se
denomina
red
vehicular
ad
hoc
(
VANET
,
Vehi-


cular
Ad
hoc
NETwork
)
.
Como
puede
imaginar
,
el
desarrollo
de
protocolos
para
tales


redes
es
enormemente
complicado
y
es
materia
de
muchas
investigaciones
que
est√°n


actualmente
en
marcha
.


En
este
cap√≠tulo
vamos
a
limitarnos
fundamentalmente
a
la
redes
de
un
√∫nico
salto
y
,
dentro


de
ellas
,
a
las
redes
basadas
en
infraestructura
.


Pero
examinemos
ahora
con
mayor
profundidad
los
desaf√≠os
t√©cnicos
que
surgen
dentro


de
las
redes
inal√°mbricas
y
m√≥viles
.
Comenzaremos
considerando
los
enlaces
inal√°mbricos


individuales
y
dejando
nuestro
estudio
acerca
de
las
cuestiones
de
movilidad
para
m√°s
ade-


lante
dentro
del
cap√≠tulo
.


502
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5026.2
Caracter√≠sticas
de
las
redes
y
enlaces
inal√°mbricos


Comencemos
considerando
una
simple
red
cableada
,
por
ejemplo
una
red
dom√©stica
,
con
un


conmutador
Ethernet
cableado
(
v√©ase
la
Secci√≥n
5.6
)
que
interconecta
los
hosts
.
Si
reempla-


zamos
la
Ethernet
cableada
por
una
red
inal√°mbrica
802.11
,
tendr√≠amos
que
sustituir
las
tar-


jetas
Ethernet
cableadas
de
los
hosts
por
tarjetas
NIC
inal√°mbricas
y
cambiar
el
conmutador


Ethernet
por
un
punto
de
acceso
inal√°mbrico
,
pero
no
har√≠a
falta
pr√°cticamente
ning√∫n
cam-


bio
en
la
capa
de
red
ni
en
las
capas
superiores
.
Esto
sugiere
que
debemos
centrar
nuestra


atenci√≥n
en
la
capa
de
enlace
a
la
hora
de
buscar
diferencias
importantes
entre
las
redes


cableadas
e
inal√°mbricas
.
De
hecho
,
podemos
encontrar
varias
distinciones
de
importancia


entre
un
enlace
cableado
y
un
enlace
inal√°mbrico
:


‚Ä¢
Intensidad
decreciente
de
la
se√±al
.
La
radiaci√≥n
electromagn√©tica
se
aten√∫a
a
medida
que


va
atravesando
la
materia
(
por
ejemplo
,
una
se√±al
de
radio
que
atraviesa
una
pared
)
.


Incluso
en
el
espacio
vac√≠o
la
se√±al
se
dispersar√°
,
lo
que
da
como
resultado
una
intensi-


dad
de
se√±al
decreciente
(
en
ocasiones
denominada
p√©rdida
de
propagaci√≥n
,
path
loss
)


a
medida
que
se
incrementa
la
distancia
entre
el
emisor
y
el
receptor
.


‚Ä¢
Interferencias
de
otros
or√≠genes
.
Los
or√≠genes
de
radio
que
transmiten
en
la
misma
banda


de
frecuencia
interferir√°n
entre
s√≠
.
Por
ejemplo
,
los
tel√©fonos
inal√°mbricos
a
2,4
GHz
y


las
redes
LAN
inal√°mbricas
802.11b
transmiten
en
la
misma
banda
de
frecuencias
.
Por


tanto
,
el
usuario
de
una
red
LAN
inal√°mbrica
802.11b
que
est√©
hablando
a
trav√©s
de
un


tel√©fono
inal√°mbrico
a
2,4
GHz
puede
esperar
que
ni
la
red
ni
el
tel√©fono
tengan
un
com-


portamiento
particularmente
satisfactorio
.
Adem√°s
de
las
interferencias
de
los
or√≠genes


de
transmisi√≥n
,
el
ruido
electromagn√©tico
presente
en
el
entorno
(
por
ejemplo
,
un
motor


cercano
o
un
microondas
)
tambi√©n
pueden
provocar
interferencias
.


‚Ä¢
Propagaci√≥n
multicamino
.
La
propagaci√≥n
multicamino
(
multipath
)
tiene
lugar
cuando


partes
de
la
onda
electromagn√©tica
se
reflejan
en
los
objetos
y
en
el
suelo
,
tomando
cami-


nos
de
diferentes
longitudes
entre
un
emisor
y
un
receptor
.
Esto
hace
que
la
se√±al
reci-


bida
sea
menos
limpia
en
el
receptor
.
El
desplazamiento
de
objetos
situados
entre
el


emisor
y
el
receptor
puede
hacer
que
la
propagaci√≥n
multicamino
var√≠e
a
lo
largo
del


tiempo
.


Para
ver
una
explicaci√≥n
detallada
de
las
caracter√≠sticas
,
modelos
y
medidas
de
los
canales


inal√°mbricos
,
consulte
[
Anderson
1995
]
.


La
exposici√≥n
anterior
sugiere
que
los
errores
de
bit
ser√°n
m√°s
comunes
en
los
enlaces


inal√°mbricos
que
en
los
enlaces
cableados
.
Por
esta
raz√≥n
,
no
resulta
sorprendente
que
los


protocolos
de
enlace
inal√°mbrico
(
como
el
protocolo
802.11
que
examinaremos
en
la


siguiente
secci√≥n
)
no
s√≥lo
empleen
potentes
c√≥digos
CRC
para
la
detecci√≥n
de
errores
,
sino


tambi√©n
protocolos
de
la
capa
de
enlace
con
transferencia
de
datos
fiable
que
se
encargan
de


retransmitir
las
tramas
corrompidas
.


Habiendo
considerado
los
problemas
que
pueden
afectar
a
un
canal
inal√°mbrico
,
volva-


mos
nuestra
atenci√≥n
al
host
que
recibe
la
se√±al
inal√°mbrica
.
El
host
recibe
una
se√±al
elec-


tromagn√©tica
que
es
una
combinaci√≥n
de
una
forma
degradada
de
la
se√±al
original


transmitida
por
el
emisor
(
degradada
debido
a
los
efectos
de
la
atenuaci√≥n
y
de
la
propaga-


ci√≥n
multicamino
que
hemos
visto
anteriormente
,
entre
otros
)
y
del
ruido
de
fondo
presente


en
el
entorno
.
La
relaci√≥n
se√±al-ruido
(
SNR
,
Signal-to-Noise
Ratio
)
es
una
medida
rela-


tiva
de
la
intensidad
de
la
se√±al
recibida
(
es
decir
,
de
la
informaci√≥n
que
se
est√°
transmi-


6.2
‚Ä¢
CARACTER√çSTICAS
DE
LAS
REDES
Y
ENLACES
INAL√ÅMBRICOS
503


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
503tiendo
)
y
de
este
ruido
.
Normalmente
,
la
relaci√≥n
se√±al-ruido
se
mide
en
unidades
de
deci-


belios
(
dB
)
,
que
es
una
unidad
de
medida
que
algunos
creen
que
los
ingenieros
el√©ctricos


utilizan
principalmente
para
confundir
a
los
inform√°ticos
.
La
SNR
,
medida
en
dB
,
es
veinte


veces
la
relaci√≥n
del
logaritmo
en
base
10
de
la
amplitud
de
la
se√±al
recibida
y
la
amplitud


del
ruido
.
De
cara
a
lo
que
aqu√≠
nos
ocupa
,
lo
√∫nico
que
necesitamos
saber
es
que
,
cuanto


mayor
sea
la
relaci√≥n
SNR
,
m√°s
f√°cil
le
ser√°
al
receptor
extraer
la
se√±al
transmitida
del
ruido


de
fondo
.


La
Figura
6.3
(
adaptada
de
[
Holland
2001
]
)
muestra
la
tasa
de
errores
de
bit
(
BER
,
Bit


Error
Rate
)
que
,
dicho
de
forma
simple
,
es
la
probabilidad
de
que
un
bit
transmitido
llegue


de
forma
err√≥nea
al
receptor
,
en
funci√≥n
de
la
SNR
para
tres
t√©cnicas
de
modulaci√≥n
distin-


tas
utilizadas
para
codificar
la
informaci√≥n
para
su
transmisi√≥n
a
trav√©s
de
un
canal
inal√°m-


brico
idealizado
.
La
teor√≠a
de
la
modulaci√≥n
y
de
la
codificaci√≥n
,
as√≠
como
las
t√©cnicas
de


extracci√≥n
de
la
se√±al
y
de
an√°lisis
de
BER
,
caen
fuera
del
alcance
de
este
libro
(
consulte


[
Schwartz
1980
]
si
desea
obtener
m√°s
informaci√≥n
sobre
estos
temas
)
.
De
todos
modos
,
la


Figura
6.3
ilustra
varias
caracter√≠sticas
de
la
capa
f√≠sica
que
son
importantes
a
la
hora
de


comprender
los
protocolos
de
comunicaci√≥n
inal√°mbrica
de
las
capas
superiores
.


‚Ä¢
Para
un
determinado
esquema
de
modulaci√≥n
,
cuanto
mayor
es
la
SNR
menor
es
la


BER
.
Dado
que
un
emisor
puede
incrementar
la
SNR
aumentando
su
potencia
de
trans-


misi√≥n
,
podr√°
reducir
la
probabilidad
de
que
una
trama
se
reciba
de
forma
err√≥nea


aumentando
esa
potencia
de
transmisi√≥n
.
Observe
,
sin
embargo
,
que
existe
muy
poca


ventaja
pr√°ctica
cuando
se
incrementa
la
potencia
m√°s
all√°
de
un
cierto
umbral
para
,


por
ejemplo
,
reducir
la
tasa
de
errores
de
bit
(
BER
)
de
10
-12
a
10-13
.
Tambi√©n
existen


desventajas
asociadas
con
ese
incremento
de
la
potencia
de
transmisi√≥n
:
el
emisor
tendr√°


que
gastar
m√°s
energ√≠a
(
lo
que
es
una
consideraci√≥n
de
gran
importancia
para
los
usua-


rios
m√≥viles
alimentados
por
bater√≠as
)
y
es
m√°s
probable
que
las
transmisiones
del
emi-


sor
interfieran
con
las
de
otros
emisores
(
v√©ase
la
Figura
6.4(b
)
)
.


504
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Figura
6.3
‚Ä¢
Tasa
de
errores
de
bit
,
velocidad
de
transmisi√≥n
y
SNR
.


10‚Äì7


10‚Äì6


10‚Äì5


10‚Äì4


10‚Äì3


10‚Äì2


10‚Äì1


10
20
30
400


SNR
(
dB
)


BER


QAM16


(
4
Mbps
)


QAM256


(
8
Mbps
)


BPSK


(
1Mpbs
)


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
504‚Ä¢
Para
una
SNR
dada
,
una
t√©cnica
de
modulaci√≥n
con
una
velocidad
de
transmisi√≥n
de
bit


m√°s
alta
(
independientemente
de
si
esos
bits
son
err√≥neos
o
no
)
tendr√°
una
tasa
de
erro-


res
de
bit
mayor
.
Por
ejemplo
,
en
la
Figura
6.3
,
con
una
SNR
de
10
dB
,
la
modulaci√≥n


BPSK
con
una
velocidad
de
transmisi√≥n
de
1
Mbps
tiene
una
BER
inferior
a
10
-7
,
mien-


tras
que
con
la
modulaci√≥n
QAM16
,
con
una
velocidad
de
transmisi√≥n
de
4
Mbps
,
la


BER
es
10-1
,
demasiado
alta
como
para
resultar
√∫til
en
la
pr√°ctica
.
Sin
embargo
,
con
una


SNR
de
20
dB
,
la
modulaci√≥n
QAM16
tiene
una
velocidad
de
transmisi√≥n
de
4
Mbps
y


una
BER
de
10-7
,
mientras
que
la
modulaci√≥n
BPSK
tiene
una
velocidad
de
transmisi√≥n


de
s√≥lo
1
Mbps
y
una
BER
que
es
demasiado
baja
y
cae
(
literalmente
)
‚Äú
fuera
del
gr√°-


fico
‚Äù
.
Si
podemos
tolerar
una
BER
de
10
-7
,
la
mayor
velocidad
de
transmisi√≥n
ofrecida


por
QAM16
har√≠a
que
fuera
la
t√©cnica
de
modulaci√≥n
preferida
para
esa
situaci√≥n
.
Estas


consideraciones
nos
conducen
a
la
caracter√≠stica
final
que
describimos
a
continuaci√≥n
.


‚Ä¢
Puede
utilizarse
una
selecci√≥n
din√°mica
de
la
t√©cnica
de
modulaci√≥n
de
la
capa
f√≠sica


para
adaptar
la
t√©cnica
de
modulaci√≥n
a
las
condiciones
del
canal
.
La
SNR
(
y
por
tanto


la
BER
)
puede
variar
como
resultado
de
la
movilidad
o
debido
a
cambios
en
el
entorno
.


En
los
sistemas
celulares
de
transmisi√≥n
de
datos
y
en
las
redes
802.16
WiMAX
y
802.11


WiFi
,
que
examinaremos
en
la
Secci√≥n
6.3
,
se
usan
t√©cnicas
de
codificaci√≥n
y
modula-


ci√≥n
adaptativas
.
Esto
permite
,
por
ejemplo
,
la
selecci√≥n
de
una
t√©cnica
de
modulaci√≥n


que
proporcione
la
m√°xima
velocidad
de
transmisi√≥n
,
sujeta
a
una
restricci√≥n
relativa
a


la
BER
,
para
unas
determinadas
caracter√≠sticas
del
canal
.


Una
tasa
de
errores
de
bit
m√°s
alta
y
variable
en
el
tiempo
no
es
la
√∫nica
diferencia
entre


un
enlace
cableado
y
un
enlace
inal√°mbrico
.
Recuerde
que
en
el
caso
de
los
enlaces
cablea-


dos
de
difusi√≥n
,
todos
los
nodos
reciben
las
transmisiones
realizadas
por
los
restantes
nodos
.


En
el
caso
de
los
enlaces
inal√°mbricos
,
la
situaci√≥n
no
es
tan
simple
como
se
muestra
en
la


Figura
6.4
.
Suponga
que
la
estaci√≥n
A
est√°
transmitiendo
hacia
la
estaci√≥n
B.
Suponga
tam-


bi√©n
que
la
estaci√≥n
C
est√°
transmitiendo
hacia
la
estaci√≥n
B.
Con
el
denominado
 
problema


del
terminal
oculto
,
las
obstrucciones
f√≠sicas
presentes
en
el
entorno
(
por
ejemplo
,
una


monta√±a
o
un
edificio
)
pueden
impedir
que
A
y
C
escuchen
las
transmisiones
del
otro
,


incluso
a√∫n
cuando
las
transmisiones
de
A
y
C
est√©n
interfiri√©ndose
mutuamente
en
el
des-


6.2
‚Ä¢
CARACTER√çSTICAS
DE
LAS
REDES
Y
ENLACES
INAL√ÅMBRICOS
505


A


A


C


BC


Ubicaci√≥n


b.a
.


0Intensidad
de
la
se√±al


B


Figura
6.4
‚Ä¢
Problema
del
terminal
oculto
causado
por
la
existencia
de
un


obst√°culo
(
a
)
y
problema
del
desvanecimiento
(
b
)
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
505tino
B.
Esto
se
muestra
en
la
Figura
6.4(a
)
.
Un
segundo
escenario
que
da
como
resultado
la


presencia
de
colisiones
indetectables
en
el
receptor
es
el
debido
al
desvanecimiento
de
la


intensidad
de
la
se√±al
a
medida
que
√©sta
se
propaga
a
trav√©s
del
medio
inal√°mbrico
.
La


Figura
6.4(b
)
ilustra
el
caso
en
el
que
A
y
C
est√°n
colocadas
de
tal
forma
que
sus
se√±ales
no


son
lo
suficientemente
intensas
como
para
que
puedan
ambas
estaciones
detectar
las
trans-


misiones
de
la
otra
,
a
pesar
de
lo
cual
esas
se√±ales
tienen
una
intensidad
suficiente
como


para
interferir
entre
s√≠
en
la
estaci√≥n
B.
Como
veremos
en
la
Secci√≥n
6.3
,
los
problemas
del


terminal
oculto
y
del
desvanecimiento
hacen
que
el
acceso
m√∫ltiple
en
una
red
inal√°mbrica


sea
considerablemente
m√°s
complejo
que
en
una
red
cableada
.


6.2.1
CDMA


Recuerde
del
Cap√≠tulo
5
que
cuando
los
hosts
se
comunican
a
trav√©s
de
un
medio
compar-


tido
,
se
necesita
un
protocolo
para
que
las
se√±ales
enviadas
por
varios
emisores
no
interfie-


ran
en
los
receptores
.
En
el
Cap√≠tulo
5
hemos
descrito
tres
clases
de
protocolos
de
acceso


al
medio
:
particionamiento
del
canal
,
acceso
aleatorio
y
toma
de
turnos
.
El
Acceso
m√∫lti-


ple
por
divisi√≥n
de
c√≥digo
(
CDMA
,
Code
Division
Multiple
Access
)
pertenece
a
la
familia


de
protocolos
de
particionamiento
del
canal
.
Es
el
protocolo
prevalente
en
las
tecnolog√≠as


celulares
y
de
redes
LAN
inal√°mbricas
.
Puesto
que
CDMA
es
tan
importante
en
el
mundo


inal√°mbrico
,
vamos
a
echar
ahora
un
r√°pido
vistazo
a
CDMA
antes
de
entrar
en
las
seccio-


nes
posteriores
a
analizar
tecnolog√≠as
espec√≠ficas
del
acceso
inal√°mbrico
.


En
un
protocolo
CDMA
,
cada
bit
enviado
se
codifica
multiplic√°ndolo
por
una
se√±al


(
el
c√≥digo
)
que
var√≠a
a
una
velocidad
mucho
mayor
(
conocida
con
el
nombre
de


velocidad
de
chip
,
chipping
rate
)
que
la
secuencia
original
de
bits
de
datos
.
La
Figura
6.5


muestra
un
escenario
idealizado
de
codificaci√≥n
/
decodificaci√≥n
CDMA
.
Suponga
que


definimos
la
unidad
de
tiempo
seg√∫n
la
velocidad
a
la
que
llegan
al
codificador
CDMA


los
bits
de
datos
originales
;
es
decir
,
cada
bit
original
de
datos
que
haya
que
transmitir


requiere
una
partici√≥n
de
tiempo
de
un
bit
.
Sea
di
el
valor
del
bit
de
datos
para
la
i-√©sima


partici√≥n
de
bit
.
Por
comodidad
matem√°tica
,
vamos
a
representar
los
bits
de
datos
que
ten-


gan
un
valor
0
como
‚Äì
1
.
Cada
partici√≥n
de
bit
se
subdivide
a
su
vez
en
M
mini-particio-


nes
;
en
la
Figura
6.5
M
=
8
,
aunque
en
la
pr√°ctica
M
es
mucho
mayor
.
El
c√≥digo
CDMA


utilizado
por
el
emisor
est√°
compuesto
por
una
serie
de
M
valores
,
cm
,
m
=
1
,
.
.
.
,
M
,


cada
uno
de
los
cuales
tiene
el
valor
+1
o
‚Äì
1
.
En
el
ejemplo
de
la
Figura
6.5
,
el
c√≥digo


CDMA
de
M
bits
que
est√°
utilizando
el
emisor
es
(
1
,
1
,
1
,
‚Äì
1
,
1
,
‚Äì
1
,
‚Äì
1
,
‚Äì
1
)
.


Para
ilustrar
c√≥mo
funciona
CDMA
,
vamos
a
centrarnos
en
el
i-√©simo
bit
de
datos
,
di
.


Para
la
m-√©sima
mini-partici√≥n
del
tiempo
de
transmisi√≥n
de
bit
de
di
,
la
salida
del
codifica-


dor
CDMA
,
Zi
,
m
,
es
el
valor
de
di
multiplicado
por
el
m-√©simo
bit
del
c√≥digo
asignado


CDMA
,
cm
:


(
6.1
)


En
un
mundo
ideal
en
el
que
no
existieran
otros
emisores
interfiriendo
,
el
receptor
recibir√≠a


los
bits
codificados
,
Zi
,
m
,
y
recuperar√≠a
el
bit
de
datos
original
,
di
,
realizando
el
c√°lculo
:


(
6.2
)


dZ
ci


m


M


i
,
mm= 


=


‚àë


1


1
M
  

Zd
ci
,
m
i
m= 
  

506
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
506El
lector
puede
trabajar
los
detalles
del
ejemplo
de
la
Figura
6.5
para
ver
que
los
bits
de


datos
originales
se
recuperan
,
efectivamente
,
de
modo
correcto
en
el
receptor
utilizando
la


Ecuaci√≥n
6.2
.


Sin
embargo
,
el
mundo
dista
mucho
de
ser
ideal
y
,
como
hemos
dicho
anteriormente
,


CDMA
debe
trabajar
en
presencia
de
otros
emisores
que
interfieren
y
que
est√°n
codificando
y


transmitiendo
sus
datos
utilizando
otro
c√≥digo
asignado
diferente
.
Pero
,
¬ø
c√≥mo
puede
un


receptor
CDMA
recuperar
los
bits
de
datos
originales
del
emisor
cuando
esos
bits
de
datos


est√°n
entremezclados
con
los
bits
transmitidos
por
otros
emisores
?
CDMA
funciona
bajo
la


suposici√≥n
de
que
las
se√±ales
interferentes
de
los
bits
transmitidos
son
aditivas
.
Esto
signi-


fica
,
por
ejemplo
,
que
si
los
tres
emisores
env√≠an
un
valor
1
y
un
cuarto
emisor
env√≠a
un
valor


‚Äì
1
durante
la
misma
mini-partici√≥n
,
entonces
la
se√±al
recibida
en
todos
los
receptores


durante
esa
mini-partici√≥n
ser√°
un
2
(
dado
que
1
/H11001
1
/H110011
/H110021
=
2
)
.
En
presencia
de
m√∫lti-


ples
emisores
,
el
emisor
s
calcula
sus
transmisiones
codificadas
,
Zs


i
,
m
,
exactamente
de
la


misma
forma
que
en
la
Ecuaci√≥n
6.1
.
El
valor
que
llega
a
un
receptor
durante
la
m-√©sima


6.2
‚Ä¢
CARACTER√çSTICAS
DE
LAS
REDES
Y
ENLACES
INAL√ÅMBRICOS
507


11
1
1


-1
-1
-1
-1


11
1
1


-1
-1
-1
-1


1


-1
-1-1-1


1
1
1
1


-1
-1
-1
-1


1
1
1

 
Entrada
recibida


en
la
partici√≥n


de
tiempo1

 
Entrada
recibida


en
la
partici√≥n


de
tiempo
0


C√≥digo


1


-1
-1-1-1


1
1
1
1


-1
-1
-1
-1


1
1
1Bits
de


datos


C√≥digo
11
1
1


-1
-1
-1
-1


11
1
1


-1
-1
-1
-1


d1
=
-1


d0
=
1


Partici√≥n


de
tiempo
1


Emisor
Salida
del
canal
Zi
,
m


Receptor


Zi
,
m


Zi
,
m


d


M


i


m=1


M


Partici√≥n


de
tiempo
1
.


Salida
del
canal


Partici√≥n


de
tiempo
0
.


Salida
del
canal


Partici√≥n


de
tiempo
0


d1
=
-1


d0
=
1


Figura
6.5
‚Ä¢
Un
ejemplo
simple
de
CDMA
:
codificaci√≥n
del
emisor
y


decodificaci√≥n
del
receptor
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
507mini-partici√≥n
de
la
i-√©sima
partici√≥n
de
bit
ser√°
ahora
,
sin
embargo
,
la
suma
de
los
bits
trans-


mitidos
por
los
N
emisores
durante
dicha
mini-partici√≥n
:


Sorprendentemente
,
si
se
eligen
cuidadosamente
los
c√≥digos
de
los
emisores
,
cada
receptor


puede
recuperar
los
datos
enviados
por
un
determinado
emisor
a
partir
de
la
se√±al
agre-


gada
,
simplemente
utilizando
el
c√≥digo
del
emisor
exactamente
en
la
misma
forma
que
en
la


Ecuaci√≥n
6.2
:


(
6.3
)


como
se
muestra
en
la
Figura
6.6
para
un
ejemplo
de
CDMA
con
dos
emisores
.
El
c√≥digo


CDMA
de
M
bits
utilizado
por
el
emisor
de
la
parte
superior
es
(
1
,
1
,
1
,
‚Äì
1
,
1
,
‚Äì
1
,
‚Äì
1
,
‚Äì
1
)
,


mientras
que
el
c√≥digo
CDMA
empleado
por
el
emisor
de
la
parte
inferior
es
(
1
,
‚Äì
1
,
1
,
1
,
1
,


‚Äì
1
,
1
,
1
)
.
La
Figura
6.6
ilustra
el
caso
de
un
receptor
que
recupera
los
bits
de
datos
origina-


les
correspondientes
al
emisor
de
la
parte
superior
.
Observe
que
el
receptor
es
capaz
de


extraer
los
datos
del
emisor
1
a
pesar
de
que
est√©n
siendo
interferidos
por
la
transmisi√≥n


correspondiente
al
emisor
2
.


Recuerde
la
analog√≠a
del
coctel
del
Cap√≠tulo
5
.
Un
protocolo
CDMA
es
similar
al


caso
en
que
los
participantes
en
la
reuni√≥n
hablen
en
m√∫ltiples
idiomas
;
en
tales
cir-


cunstancias
,
los
seres
humanos
somos
bastante
buenos
a
la
hora
de
centrarnos
en
la
con-


versaci√≥n
que
se
est√°
manteniendo
en
el
idioma
que
comprendemos
,
al
mismo
tiempo


que
filtramos
las
restantes
conversaciones
.
Podemos
ver
,
a
partir
de
estas
explicaciones
,


que
CDMA
es
un
protocolo
de
particionamiento
,
en
el
sentido
de
que
particiona
el
espa-


cio
de
c√≥digos
(
en
lugar
del
tiempo
o
la
frecuencia
)
y
asigna
a
cada
nodo
una
parte
dedi-


cada
de
ese
espacio
de
c√≥digos
.


El
an√°lisis
que
aqu√≠
hemos
realizado
de
CDMA
es
necesariamente
breve
;
en
la
pr√°ctica
,


es
preciso
contemplar
diversas
cuestiones
relativamente
complicadas
.
En
primer
lugar
,
para


que
los
receptores
CDMA
sean
capaces
de
extraer
una
se√±al
de
un
emisor
concreto
,
los
c√≥di-


gos
CDMA
deben
elegirse
cuidadosamente
.
En
segundo
lugar
,
nuestro
an√°lisis
part√≠a
de
la


suposici√≥n
de
que
las
intensidades
de
las
se√±ales
recibidas
de
los
diversos
emisores
eran


iguales
,
pero
en
la
realidad
esto
puede
ser
dif√≠cil
de
conseguir
.
Existe
bastante
literatura
t√©c-


nica
en
la
que
se
analizan
estas
y
otras
cuestiones
relacionadas
con
CDMA
;
consulte
[
Pick-


holtz
1982
;
Viterbi
1995
]
para
ver
m√°s
detalles
.


6.3
WiFi
:
redes
LAN
inal√°mbricas
802.11


Presentes
por
todas
partes
,
en
las
oficinas
,
en
los
domicilios
particulares
,
en
las
instituciones


educativas
,
en
la
cafeter√≠as
,
en
los
aeropuertos
e
incluso
en
la
esquina
de
cualquier
calle
,
las


redes
LAN
inal√°mbricas
son
hoy
en
d√≠a
una
de
las
tecnolog√≠as
m√°s
importantes
de
redes
de


acceso
para
Internet
.
Aunque
en
la
d√©cada
de
1990
se
desarrollaron
muchas
tecnolog√≠as
y


est√°ndares
para
redes
LAN
inal√°mbricas
,
hay
una
clase
concreta
de
est√°ndares
que
ha
termi-


nado
por
emerger
como
ganador
indiscutible
:
la
red
LAN
inal√°mbrica
IEEE
802.11
,
tam-


dZ
ci


m


M


i
,
mm= 


=


‚àë


1


1
M
 
*


ZZi
,
m


s


N


i
,
m


s
*
=


=


‚àë


1


508
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5086.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
509


Receptor
1


11
1
1


-1
-1
-1
-1


11
1
1


-1
-1-1
-1


Entrada
recibida


en
la
partici√≥n


de
tiempo
1


Entrada
recibida


en
la
partici√≥n


de
tiempo
0


Bits
de


datos


Bits
de


datos


11
1
1


-1
-1
-1
-1


11
1
1


-1
-1-1
-1


C√≥digo


Emisores


1
1
1


-1


1
1
1


-1


1


-1
-1


1
1
1
1
1


C√≥digo


C√≥digo


+


-2


2
2
2
2
2


-2


2


-2


2
2
2
2
2


-2


2


Canal
,
Zi
,
m
*


Zi
,
m
di
 
‚Ä¢
cm=


Zi
,
m
‚Ä¢
cm


d


M


i


m=1


M


=


‚àë


d1
=
-1


d0
=
1


d1
=
12


1


1
*


222


Zi
,
m
di
 
‚Ä¢
cm=


11
1


d0
=
12


1


1


d1
=
-1


d0
=
1


1


1


Figura
6.6
‚Ä¢
Un
ejemplo
de
CDMA
con
dos
emisores
.


bi√©n
conocida
como
red
WiFi
.
En
esta
secci√≥n
vamos
a
examinar
en
detalle
las
redes
LAN


inal√°mbricas
802.11
,
su
estructura
de
trama
,
su
protocolo
de
acceso
al
medio
y
la
intercone-


xi√≥n
de
las
redes
LAN
802.11
con
las
redes
LAN
Ethernet
cableadas
.


Existen
varios
est√°ndares
802.11
para
la
tecnolog√≠a
LAN
inal√°mbrica
,
incluyendo


802.11b
,
802.11a
y
802.11
g.
La
Tabla
6.1
resume
las
caracter√≠sticas
principales
de
estos


est√°ndares
.
En
el
momento
de
escribir
este
libro
(
primavera
de
2009
)
,
hay
muchos
m√°s


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
509Est√°ndar
Rango
de
frecuencias
(
Estados
Unidos
)
Velocidad
de
datos


802.11b
2,4‚Äì2,485
GHz
hasta
11
Mbps


802.11a
5,1‚Äì5,8
GHz
hasta
54
Mbps


802.11
g
2,4‚Äì2,485
GHz
hasta
54
Mbps


Tabla
6.1
‚Ä¢
Resumen
de
los
est√°ndares
IEEE
802.11
.


dispositivos
802.11
g
que
est√°n
siendo
ofrecidos
por
los
fabricantes
de
puntos
de
acceso
y


tarjetas
LAN
.
Tambi√©n
hay
disponibles
diversos
dispositivos
en
modo
dual
(
802.11a
/
g
)
y
tri-


modo
(
802.11a
/
b
/
g
)
.


Los
tres
est√°ndares
802.11
comparten
muchas
caracter√≠sticas
.
Todos
ellos
emplean
el


mismo
protocolo
de
acceso
al
medio
,
CSMA
/
CA
,
del
que
pronto
hablaremos
.
Los
tres
usan


tambi√©n
la
misma
estructura
de
trama
para
la
capa
de
enlace
.
Los
tres
est√°ndares
tienen
la


capacidad
de
reducir
su
velocidad
de
transmisi√≥n
para
poder
alcanzar
mayores
distancias
.
Y


los
tres
est√°ndares
permiten
trabajar
tanto
‚Äú
en
modo
de
infraestructura
‚Äù
como
en
‚Äú
modo
ad


hoc
‚Äù
,
como
pronto
veremos
.
Sin
embargo
,
como
se
muestra
en
la
Tabla
6.1
,
los
tres
est√°nda-


res
presentan
algunas
diferencias
importantes
en
la
capa
f√≠sica
.


La
tecnolog√≠a
LAN
inal√°mbrica
802.11b
ofrece
una
velocidad
de
datos
de
11
Mbps
y


opera
en
la
banda
de
frecuencias
sin
licencia
de
2,4‚Äì2,485
GHz
,
compitiendo
por
el
espec-


tro
de
frecuencias
con
los
tel√©fonos
a
2,4
GHz
y
los
hornos
microondas
.
Las
redes
LAN


inal√°mbricas
802.1la
pueden
operar
a
velocidades
de
bit
significativamente
mayores
,
pero


lo
hacen
a
frecuencia
m√°s
altas
.
Operando
a
una
mayor
frecuencia
,
las
redes
LAN
802.11a


tienen
una
distancia
de
transmisi√≥n
m√°s
corta
para
un
determinado
nivel
de
potencia
y
se


ven
m√°s
afectadas
por
los
problemas
de
la
propagaci√≥n
multicamino
.
Las
redes
LAN


802.11
g
operan
en
la
misma
banda
de
menor
frecuencia
que
el
est√°ndar
802.11b
y
son


compatibles
hacia
atr√°s
con
802.11b
(
de
modo
que
,
en
una
red
,
los
clientes
802.11b
se


pueden
actualizar
incrementalmente
)
,
a
pesar
de
lo
cual
utilizan
las
velocidades
de
trans-


misi√≥n
mayores
del
est√°ndar
802.11a
,
lo
que
permite
a
los
usuarios
disfrutar
de
lo
mejor


los
otros
dos
est√°ndares
.


Hay
un
nuevo
est√°ndar
WiFi
,
802.11n
[
IEEE
802.11n
2009
]
,
que
se
encuentra
en
pro-


ceso
de
estandarizaci√≥n
.
802.11n
utiliza
antenas
de
entrada
m√∫ltiple
y
salida
m√∫ltiple


(
MIMO
,
Multiple-Input
Multiple-Output
)
;
es
decir
,
dos
o
m√°s
antenas
en
el
lado
emisor
y


dos
o
m√°s
antenas
en
el
lado
receptor
est√°n
transmitiendo
/
recibiendo
diferentes
se√±ales


[
Diggavi
2004
]
.
Aunque
todav√≠a
el
proceso
de
estandarizaci√≥n
no
ha
concluido
,
ya
hay
dis-


ponibles
productos
pre-est√°ndar
,
en
los
que
las
primeras
pruebas
realizadas
muestran
que
se


pueden
conseguir
en
la
pr√°ctica
tasas
de
transferencia
de
transmisi√≥n
de
m√°s
de
200
Mbps


[
Newman
2008
]
.
Un
problema
importante
del
actual
borrador
del
est√°ndar
es
la
forma
en


que
los
dispositivos
802.11n
interactuar√°n
con
los
dispositivos
802.11a
/
b
/
g
existentes
.


6.3.1
La
arquitectura
802.11


La
Figura
6.7
ilustra
los
principales
componentes
de
la
arquitectura
de
una
red
LAN
inal√°m-


brica
802.11
.
El
componente
fundamental
de
la
arquitectura
802.11
es
el
conjunto
de
servi-


cio
b√°sico
(
BSS
,
Basic
Service
Set
)
.
Un
BSS
contiene
una
o
m√°s
estaciones
inal√°mbricas
y


510
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
510una
estaci√≥n
base
central
,
conocida
con
el
nombre
de
punto
de
acceso
(
AP
,
Access
Point
)


en
terminolog√≠a
802.11
.
La
Figura
6.7
muestra
el
punto
de
acceso
en
cada
uno
de
los
dos


BSS
;
los
puntos
de
acceso
se
interconectan
a
un
dispositivo
de
interconexi√≥n
(
como
un
con-


mutador
o
un
router
)
,
que
a
su
vez
lleva
hacia
Internet
.
En
una
red
dom√©stica
t√≠pica
existir√°


un
punto
de
acceso
y
un
router
(
normalmente
integrados
en
una
misma
unidad
)
,
que
conec-


tar√°n
el
BSS
con
Internet
.


Al
igual
que
sucede
con
los
dispositivos
Ethernet
,
cada
estaci√≥n
inal√°mbrica
802.11


tiene
una
direcci√≥n
MAC
de
6
bytes
que
est√°
almacenada
en
el
firmware
de
la
tarjeta
adap-


tadora
de
la
estaci√≥n
(
es
decir
,
en
la
tarjeta
de
interfaz
de
red
802.11
)
.
Cada
punto
de
acceso


tiene
tambi√©n
una
direcci√≥n
MAC
para
su
interfaz
inal√°mbrica
.
Al
igual
que
sucede
con


Ethernet
,
estas
direcciones
MAC
son
administradas
por
el
IEEE
y
son
(
en
teor√≠a
)
global-


mente
√∫nicas
.


Como
hemos
dicho
en
la
Secci√≥n
6.1
,
las
redes
LAN
inal√°mbricas
que
incorporan
pun-


tos
de
acceso
suelen
denominarse
redes
LAN
inal√°mbricas
de
infraestructura
,
siendo
la


‚Äú
infraestructura
‚Äù
los
puntos
de
acceso
junto
con
la
infraestructura
de
Ethernet
cableada
que


interconecta
los
puntos
de
acceso
y
un
router
.
La
Figura
6.8
muestra
que
las
estaciones


IEEE
802.11
tambi√©n
pueden
agruparse
para
formar
una
red
ad
hoc
:
una
red
sin
ning√∫n
con-


trol
central
y
que
no
tiene
conexiones
con
el
‚Äú
mundo
exterior
‚Äù
.
En
este
caso
,
la
red
es
for-


mada
‚Äú
sobre
la
marcha
‚Äù
por
una
serie
de
dispositivos
m√≥viles
que
se
han
encontrado
con


que
est√°n
pr√≥ximos
entre
s√≠
,
que
tienen
una
necesidad
de
comunicarse
y
que
no
encuentran


ninguna
infraestructura
de
red
preexistente
en
la
ubicaci√≥n
en
la
que
est√°n
.
Una
red
ad
hoc


podr√≠a
formarse
cuando
una
serie
de
personas
con
computadoras
port√°tiles
se
juntan
(
por


ejemplo
,
en
una
sala
de
conferencias
,
en
un
tren
o
en
un
veh√≠culo
)
y
quieren
intercambiar


datos
en
ausencia
de
un
punto
acceso
centralizado
.
Se
ha
generado
un
enorme
inter√©s
en
las


redes
ad
hoc
,
ya
que
los
dispositivos
port√°tiles
capaces
de
comunicarse
entre
s√≠
contin√∫an


proliferando
.
En
esta
secci√≥n
,
sin
embargo
,
centraremos
nuestra
atenci√≥n
en
las
redes
LAN


inal√°mbricas
de
infraestructura
.


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
511


InternetConmutador


o
router


AP


BSS
1


BSS
2


AP


Figura
6.7
‚Ä¢
Arquitectura
de
una
red
LAN
IEEE
802.11
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
511Canales
y
asociaci√≥n


En
la
arquitectura
802.11
cada
estaci√≥n
inal√°mbrica
necesita
asociarse
con
un
punto
de


acceso
antes
de
poder
enviar
o
recibir
datos
de
la
capa
de
red
.
Aunque
todos
los
est√°ndares


802.11
utilizan
el
mecanismo
de
asociaci√≥n
,
analizaremos
el
tema
espec√≠ficamente
en
el


contexto
de
IEEE
802.11b
/
g.


Cuando
un
administrador
de
red
instala
un
punto
de
acceso
,
asigna
un
Identificador
de


conjunto
de
servicio
(
SSID
,
Service
Set
Identifier
)
de
una
o
dos
palabras
a
ese
punto
de


acceso
.
(
Por
ejemplo
,
cuando
se
‚Äú
ven
las
redes
disponibles
‚Äù
en
Microsoft
Windows
XP
,
apa-


rece
una
lista
que
muestra
el
identificador
SSID
de
cada
punto
de
acceso
que
est√©
dentro
del


alcance
.
)
El
administrador
debe
tambi√©n
asignar
un
n√∫mero
de
canal
a
ese
punto
de
acceso
.


Para
comprender
los
n√∫meros
de
canal
,
recuerde
que
802.11
opera
en
el
rango
de
frecuen-


cias
de
2,4
GHz
a
2,485
GHz
.
Dentro
de
esta
banda
de
85
MHz
,
802.11
define
11
canales


parcialmente
solapados
.
Dados
dos
canales
cualesquiera
diremos
que
no
se
solapan
si
y
s√≥lo


si
est√°n
separados
por
cuatro
o
m√°s
canales
.
En
particular
,
el
conjunto
de
canales
1
,
6
y
11


es
el
√∫nico
conjunto
de
tres
canales
no
solapados
.
Esto
quiere
decir
que
un
administrador


podr√≠a
crear
una
red
LAN
inal√°mbrica
con
una
velocidad
m√°xima
de
transmisi√≥n
agregada


de
33
Mbps
instalando
tres
puntos
de
acceso
802.11b
en
la
misma
ubicaci√≥n
f√≠sica
,
asig-


nando
los
canales
1
,
6
y
11
a
los
puntos
de
acceso
e
interconectando
todos
los
puntos
de


acceso
mediante
un
conmutador
.


Ahora
que
tenemos
unos
conocimientos
b√°sicos
de
los
canales
802.11
,
vamos
a
descri-


bir
una
situaci√≥n
interesante
(
y
que
no
resulta
tan
rara
):
la
de
la
jungla
WiFi
.
Una
jungla


WiFi
es
cualquier
ubicaci√≥n
f√≠sica
en
la
que
una
estaci√≥n
inal√°mbrica
est√°
recibiendo
una


se√±al
suficientemente
intensa
desde
dos
o
m√°s
puntos
de
acceso
.
Por
ejemplo
,
en
muchas


cafeter√≠as
de
la
ciudad
de
Nueva
York
una
estaci√≥n
inal√°mbrica
puede
captar
la
se√±al
de


numerosos
puntos
de
acceso
cercanos
.
Uno
de
los
puntos
de
acceso
puede
ser
gestionado


por
la
propia
cafeter√≠a
,
mientras
que
los
otros
pueden
encontrarse
en
viviendas
situadas


cerca
de
la
misma
.
Cada
uno
de
estos
puntos
de
acceso
estar√°
,
probablemente
,
ubicado
en


una
subred
IP
diferente
y
se
le
habr√°
asignado
un
canal
de
manera
independiente
.


Suponga
ahora
que
entramos
en
dicha
jungla
WiFi
con
nuestra
computadora
port√°til
,


buscando
poder
acceder
a
Internet
de
manera
inal√°mbrica
.
Suponga
que
existen
cinco
pun-


tos
de
acceso
en
esa
jungla
WiFi
.
Para
poder
obtener
acceso
a
Internet
,
nuestra
estaci√≥n


512
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


BSS


Figura
6.8
‚Ä¢
Una
red
ad
hoc
IEEE
802.11
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
512inal√°mbrica
necesita
unirse
a
exactamente
una
de
las
subredes
y
,
por
tanto
,
necesitar√°


asociarse
con
exactamente
uno
de
los
puntos
de
acceso
.
Asociarse
quiere
decir
que
la


estaci√≥n
inal√°mbrica
crear√°
un
cable
virtual
entre
ella
misma
y
el
punto
de
acceso
.
Espec√≠-


ficamente
,
s√≥lo
el
punto
de
acceso
asociado
enviar√°
tramas
de
datos
(
es
decir
,
tramas
que


contienen
datos
,
como
por
ejemplo
un
datagrama
)
a
nuestra
estaci√≥n
inal√°mbrica
y
nues-


tra
estaci√≥n
inal√°mbrica
enviar√°
tramas
de
datos
hacia
Internet
solamente
a
trav√©s
del


punto
de
acceso
asociado
.
Pero
,
¬ø
c√≥mo
se
asocia
una
estaci√≥n
inal√°mbrica
con
un
punto


de
acceso
concreto
?
Todav√≠a
m√°s
importante
:
¬ø
c√≥mo
sabe
una
estaci√≥n
inal√°mbrica
qu√©


puntos
de
acceso
hay
en
esa
jungla
,
si
es
que
hay
alguno
?


El
est√°ndar
802.11
requiere
que
un
punto
de
acceso
env√≠e
de
forma
peri√≥dica
tramas


baliza
(
beacon
frames
)
,
cada
una
de
las
cuales
incluye
la
direcci√≥n
MAC
y
el
identificador


SSID
del
punto
de
acceso
.
La
estaci√≥n
inal√°mbrica
,
que
sabe
que
los
puntos
de
acceso
est√°n


enviando
tramas
baliza
,
explora
los
once
canales
buscando
la
tramas
baliza
de
cualquier


punto
de
acceso
que
pueda
haber
en
las
proximidades
(
algunos
de
los
cuales
pueden
estar


transmitiendo
a
trav√©s
del
mismo
canal
,
ya
que
estamos
en
una
jungla
)
.
Habiendo
determi-


nado
qu√©
puntos
de
acceso
hay
disponibles
a
trav√©s
de
las
tramas
baliza
,
seleccionamos
(
o


nuestro
host
inal√°mbrico
selecciona
)
uno
de
los
puntos
de
acceso
para
llevar
a
cabo
la
aso-


ciaci√≥n
.


El
est√°ndar
802.11
no
especifica
un
algoritmo
para
seleccionar
con
cu√°l
de
los
puntos
de


acceso
disponibles
asociarse
;
dicho
algoritmo
se
deja
al
arbitrio
de
los
dise√±adores
del
soft-


ware
y
el
firmware
802.11
del
host
inal√°mbrico
.
Normalmente
,
el
host
elige
el
punto
de


acceso
cuya
trama
baliza
se
recibe
con
la
m√°xima
intensidad
de
se√±al
.
Pero
,
aunque
una
alta


intensidad
de
se√±al
resulta
conveniente
(
vea
,
por
ejemplo
,
la
Figura
6.3
)
,
la
intensidad
de
la


se√±al
no
es
la
√∫nica
caracter√≠stica
del
punto
de
acceso
que
influir√°
en
el
rendimiento
que
un


host
perciba
.
En
particular
,
es
posible
que
el
punto
de
acceso
seleccionado
pueda
tener
una


gran
intensidad
de
se√±al
,
pero
que
pueda
estar
sobrecargado
por
otra
serie
de
hosts
asociados


(
que
necesitar√°n
compartir
el
ancho
de
banda
inal√°mbrico
disponible
en
dicho
punto
de


acceso
)
,
mientras
que
se
deja
sin
seleccionar
un
punto
de
acceso
bastante
descargado
,
debido


a
que
la
intensidad
de
la
se√±al
es
ligeramente
menor
.
Por
esto
,
recientemente
se
han
propuesto


diversas
formas
de
elecci√≥n
de
los
puntos
de
acceso
[
Vasudevan
2005
;
Nicholson
2006
;


Sudaresan
2006
]
.
Para
ver
una
interesante
discusi√≥n
pr√°ctica
acerca
de
c√≥mo
se
mide
la
inten-


sidad
de
la
se√±al
,
consulte
[
Bardwell
2004
]
.


El
proceso
de
exploraci√≥n
de
los
canales
y
de
escucha
de
las
tramas
baliza
se
conoce


con
el
nombre
de
exploraci√≥n
pasiva
(
v√©ase
la
Figura
6.9a
)
.
Un
host
inal√°mbrico
tambi√©n


puede
realizar
una
exploraci√≥n
activa
,
difundiendo
una
trama
de
sondeo
que
ser√°
recibida


por
todos
los
puntos
de
acceso
que
caigan
dentro
del
alcance
del
host
inal√°mbrico
,
como
se


muestra
en
la
Figura
6.9b
.
Los
puntos
de
acceso
responden
a
la
trama
de
la
solicitud
de
son-


deo
con
una
trama
de
respuesta
de
sondeo
.
El
host
inal√°mbrico
puede
entonces
elegir
el


punto
de
acceso
con
el
que
asociarse
de
entre
todos
aquellos
que
hayan
respondido
.


Despu√©s
de
seleccionar
el
AP
con
el
que
asociarse
,
el
host
inal√°mbrico
env√≠a
una
trama


de
solicitud
de
asociaci√≥n
a
ese
punto
de
acceso
,
el
cual
responde
con
una
trama
de
respuesta


de
asociaci√≥n
.
Observe
que
este
segundo
acuerdo
de
solicitud
/
respuesta
tambi√©n
es
necesa-


rio
cuando
se
utiliza
la
exploraci√≥n
activa
,
dado
que
un
punto
de
acceso
que
est√°
respon-


diendo
a
la
trama
inicial
de
solicitud
de
sondeo
no
sabe
cu√°l
de
los
(
posiblemente


numerosos
)
puntos
de
acceso
que
hayan
respondido
va
a
seleccionar
el
host
para
asociarse
,


de
la
misma
manera
que
un
cliente
DHCP
puede
seleccionar
entre
m√∫ltiples
servidores


DHCP
(
v√©ase
la
Figura
4.21
)
.
Una
vez
asociado
con
un
punto
de
acceso
,
el
host
se
unir√°
a
la


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
513


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
513subred
(
en
el
sentido
de
direccionamiento
IP
de
la
Secci√≥n
4.4.2
)
a
la
que
pertenezca
el


punto
de
acceso
.
Normalmente
el
host
enviar√°
un
mensaje
de
descubrimiento
DHCP
(
v√©ase


la
Figura
4.21
)
hacia
la
subred
a
trav√©s
del
punto
de
acceso
para
obtener
una
direcci√≥n
IP
de


esa
subred
.
Una
vez
obtenida
la
direcci√≥n
,
el
resto
del
mundo
ver√°
entonces
a
dicho
host


simplemente
como
otro
host
cualquiera
con
una
direcci√≥n
IP
perteneciente
a
dicha
subred
.


Para
poder
crear
una
asociaci√≥n
con
un
punto
de
acceso
concreto
,
puede
que
la
estaci√≥n


inal√°mbrica
tenga
que
autenticarse
ante
el
punto
de
acceso
.
Las
redes
LAN
inal√°mbricas


802.11
proporcionan
diversas
alternativas
para
la
autenticaci√≥n
y
el
acceso
.
Una
t√©cnica
,
uti-


lizada
por
muchas
compa√±√≠as
,
permite
el
acceso
a
una
red
inal√°mbrica
bas√°ndose
en
la


direcci√≥n
MAC
de
la
estaci√≥n
.
Una
segunda
t√©cnica
,
empleada
en
muchos
caf√©s
Internet
,


utiliza
nombres
de
usuario
y
contrase√±as
.
En
ambos
casos
,
el
punto
de
acceso
se
comunica


normalmente
con
un
servidor
de
autenticaci√≥n
,
reenviando
la
informaci√≥n
intercambiada


entre
la
estaci√≥n
terminal
inal√°mbrica
y
el
servidor
de
autenticaci√≥n
utilizando
un
protocolo


como
RADIUS
[
RFC
2865
]
o
DIAMETER
[
RFC
3588
]
.
Separar
el
servidor
de
autentica-


ci√≥n
del
punto
de
acceso
permite
que
un
√∫nico
servidor
de
autenticaci√≥n
proporcione
servi-


cio
a
muchos
puntos
de
acceso
distintos
,
centralizando
las
(
a
menudo
sensibles
)
decisiones


relativas
a
la
autenticaci√≥n
y
al
acceso
en
ese
√∫nico
servidor
y
manteniendo
los
costes
y
la


complejidad
de
los
puntos
de
acceso
relativamente
bajos
.
Veremos
en
la
Secci√≥n
8.8
que
el


nuevo
protocolo
IEEE
802.11i
,
que
define
los
aspectos
de
seguridad
de
la
familia
de
proto-


colos
802.11
,
adopta
precisamente
este
enfoque
.


6.3.2
El
protocolo
MAC
802.11


Una
vez
asociada
una
estaci√≥n
inal√°mbrica
con
un
punto
de
acceso
,
la
estaci√≥n
puede


comenzar
a
enviar
y
recibir
tramas
de
datos
hacia
y
desde
el
punto
de
acceso
.
Pero
,
dado
que


puede
haber
m√∫ltiples
estaciones
que
pueden
desear
transmitir
tramas
de
datos
al
mismo


tiempo
a
trav√©s
del
mismo
canal
,
es
preciso
utilizar
un
protocolo
de
acceso
m√∫ltiple
para


514
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


1


1


32


H1


AP
2AP
1


BBS
1


a.
Exploraci√≥n
pasiva

 
1
.
 
T
r
a
m
a
s
 
b
a
l
i
z
a
 
e
n
v
i
a
d
a
s
 
d
e
s
d
e
 
l
o
s
 
          
puntos
de
acceso
.

 
2
.
 
E
n
v
√≠
o
 
d
e
 
l
a
 
t
r
a
m
a
 
d
e
 
s
o
l
i
c
i
t
u
d
 
d
e
 
a
s
o
c
i
a
c
i
√≥
n
 
  
d
e
s
d
e
 
H
1
 
a
l
 
A
P
 
s
e
l
e
c
c
i
o
n
a
d
o
.

 
3
.
 
E
n
v
√≠
o
 
d
e
 
l
a
 
t
r
a
m
a
 
d
e
 
r
e
s
p
u
e
s
t
a
 
d
e
 
a
s
o
c
i
a
c
i
√≥
n
 
  
d
e
s
d
e
 
e
l
 
A
P
 
s
e
l
e
c
c
i
o
n
a
d
o
 
a
 
H
1
.


b.
Exploraci√≥n
activa

 
1
.
 
D
i
f
u
s
i
√≥
n
 
d
e
s
d
e
 
H
1
 
d
e
 
u
n
a
 
t
r
a
m
a
 
d
e
 
s
o
l
i
c
i
t
u
d
 
d
e
 
s
o
n
d
e
o
.

 
2
.
 
E
n
v
√≠
o
 
d
e
 
t
r
a
m
a
s
 
d
e
 
r
e
s
p
u
e
s
t
a
 
d
e
 
s
o
n
d
e
o
 
d
e
s
d
e
 
l
o
s
 
A
P
.
 
 
3
.
 
E
n
v
√≠
o
 
d
e
 
t
r
a
m
a
 
d
e
 
s
o
l
i
c
i
t
u
d
 
d
e
 
a
s
o
c
i
a
c
i
√≥
n
 
  
d
e
s
d
e
 
H
1
 
a
l
 
A
P
 
s
e
l
e
c
c
i
o
n
a
d
o
.

 
4
.
 
E
n
v
√≠
o
 
d
e
 
t
r
a
m
a
 
d
e
 
r
e
s
p
u
e
s
t
a
 
d
e
 
a
s
o
c
i
a
c
i
√≥
n

  
d
e
s
d
e
 
e
l
 
A
P
 
s
e
l
e
c
c
i
o
n
a
d
o
 
a
 
H
1

  

BBS
2


2


2


43


H1


AP
2AP
1


BBS
1
BBS
2


1


Figura
6.9
‚Ä¢
Exploraci√≥n
activa
y
pasiva
de
los
puntos
de
acceso
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
514coordinar
esas
transmisiones
.
En
este
escenario
,
una
estaci√≥n
puede
ser
una
estaci√≥n
ina-


l√°mbrica
o
un
punto
de
acceso
.
Como
se
explica
en
el
Cap√≠tulo
5
y
en
la
Secci√≥n
6.2.1
,
en


t√©rminos
generales
existen
tres
clases
de
protocolos
de
acceso
m√∫ltiple
:
particionamien-


to
del
canal
(
incluyendo
CDMA
)
,
acceso
aleatorio
y
toma
por
turnos
.
Inspirados
por
el


enorme
√©xito
de
Ethernet
y
su
protocolo
de
acceso
aleatorio
,
los
dise√±adores
de
la
arquitec-


tura
802.11
seleccionaron
un
protocolo
de
acceso
aleatorio
para
las
redes
LAN
inal√°mbricas


802.11
.
Este
protocolo
de
acceso
aleatorio
se
conoce
como
CSMA
con
evitaci√≥n
de
colisio-


nes
o
,
m√°s
sucintamente
,
CSMA
/
CA
(
Collision
Avoidance
)
.
Al
igual
que
sucede
con
el
pro-


tocolo
CSMA
/
CD
de
Ethernet
,
las
siglas
‚Äú
CSMA
‚Äù
en
CSMA
/
CA
hacen
referencia
al


‚Äú
acceso
m√∫ltiple
por
sondeo
de
portadora
‚Äù
,
lo
que
significa
que
cada
estaci√≥n
sondea
el


canal
antes
de
transmitir
y
se
abstiene
de
transmitir
cuando
detecta
que
el
canal
est√°
ocu-


pado
.
Aunque
tanto
Ethernet
como
802.11
utilizan
acceso
aleatorio
con
sondeo
de
portadora
,


los
dos
protocolos
MAC
presentan
diferencias
importantes
.
En
primer
lugar
,
en
vez
de
utili-


zar
detecci√≥n
de
colisiones
,
802.11
utiliza
t√©cnicas
de
evitaci√≥n
de
las
colisiones
.
En


segundo
lugar
,
debido
a
las
relativamente
altas
tasas
de
errores
de
bit
de
los
canales
inal√°m-


bricos
,
802.11
(
a
diferencia
de
Ethernet
)
utiliza
un
esquema
de
reconocimiento
/
retransmi-


si√≥n
(
ARQ
)
de
la
capa
de
enlace
.
M√°s
adelante
se
describen
los
esquemas
de
evitaci√≥n
de


las
colisiones
y
de
reconocimiento
en
la
capa
de
enlace
de
802.11
.


Recuerde
de
las
Secciones
5.3
y
5.5
que
con
el
algoritmo
de
detecci√≥n
de
colisiones
de


Ethernet
,
una
estaci√≥n
Ethernet
escucha
el
canal
a
medida
que
transmite
.
Si
detecta
,
mien-


tras
est√°
transmitiendo
,
que
hay
otra
estaci√≥n
transmitiendo
tambi√©n
,
aborta
su
transmisi√≥n
y


trata
de
transmitir
de
nuevo
despu√©s
de
esperar
un
periodo
de
tiempo
peque√±o
y
aleatorio
.
A


diferencia
del
protocolo
Ethernet
802.3
,
el
protocolo
MAC
802.11
no
implementa
ning√∫n


mecanismo
de
detecci√≥n
de
colisiones
.
Hay
dos
razones
importantes
para
esto
:


‚Ä¢L
a
 
c
a
p
a
c
i
d
a
d
 
d
e
 
d
e
t
e
c
t
a
r
 
c
o
l
i
s
i
o
n
e
s
 
r
e
q
u
i
e
r
e
 
l
a
 
c
a
p
a
c
i
d
a
d
 
d
e
 
e
n
v
i
a
r
 
(
l
a
 
p
r
o
p
i
a
 
s
e
√±
a
l
 
d
e
 
l
a


estaci√≥n
)
y
de
recibir
(
para
determinar
si
otra
estaci√≥n
tambi√©n
est√°
transmitiendo
)
al


mismo
tiempo
.
Puesto
que
la
intensidad
de
la
se√±al
recibida
es
normalmente
muy


peque√±a
si
la
comparamos
con
la
intensidad
de
la
se√±al
transmitida
por
el
adaptador


802.11
,
resulta
muy
costoso
construir
un
hardware
que
pueda
detectar
una
colisi√≥n
.


‚Ä¢T
o
d
a
v
√≠
a
 
m
√°
s
 
i
m
p
o
r
t
a
n
t
e
 
e
s
 
q
u
e
,
 
i
n
c
l
u
s
o
 
s
i
 
e
l
 
a
d
a
p
t
a
d
o
r
 
p
u
d
i
e
r
a
 
t
r
a
n
s
m
i
t
i
r
 
y
 
e
s
c
u
c
h
a
r
 
a
l


mismo
tiempo
(
y
supuestamente
abortar
la
transmisi√≥n
cuando
detecte
que
el
canal
est√°


ocupado
)
,
el
adaptador
seguir√≠a
sin
ser
capaz
de
detectar
todas
las
colisiones
,
debido
a


los
problemas
del
terminal
oculto
y
del
desvanecimiento
que
hemos
explicado
en
la
Sec-


ci√≥n
6.2
.


Puesto
que
las
redes
LAN
inal√°mbricas
802.11
no
utilizan
la
detecci√≥n
de
colisiones
,


una
vez
que
una
estaci√≥n
empieza
a
transmitir
una
trama
la
transmite
en
su
totalidad
;
es


decir
,
una
vez
que
una
estaci√≥n
comienza
a
transmitir
,
no
hay
vuelta
atr√°s
.
Como
cabr√≠a


esperar
,
la
transmisi√≥n
de
tramas
completas
(
en
especial
,
tramas
largas
)
cuando
las
colisio-


nes
son
abundantes
puede
degradar
significativamente
el
rendimiento
de
un
protocolo
de


acceso
m√∫ltiple
.
Para
reducir
la
probabilidad
de
colisi√≥n
,
802.11
emplea
varias
t√©cnicas
de


evitaci√≥n
de
colisiones
,
que
explicaremos
en
breve
.


Sin
embargo
,
antes
de
entrar
en
el
tema
de
la
evitaci√≥n
de
las
colisiones
,
necesitamos


examinar
en
primer
lugar
el
esquema
de
reconocimiento
de
la
capa
de
enlace
en
802.11
.


Recuerde
de
la
Secci√≥n
6.2
que
,
cuando
una
estaci√≥n
en
una
LAN
inal√°mbrica
env√≠a
una


trama
,
√©sta
puede
no
llegar
intacta
a
la
estaci√≥n
de
destino
por
diversas
razones
.
Para
resol-


ver
esta
probabilidad
no
desde√±able
de
fallo
,
el
protocolo
MAC
802.11
utiliza
reconoci-


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
515


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
515mientos
de
la
capa
de
enlace
.
Como
se
muestra
en
la
Figura
6.10
,
cuando
la
estaci√≥n
de
des-


tino
recibe
una
trama
,
pasa
la
prueba
de
comprobaci√≥n
de
CRC
,
espera
un
corto
periodo
de


tiempo
conocido
con
el
nombre
de
Espaciado
corto
entre
tramas
(
SIFS
,
Short
Inter-


frame
Spacing
)
y
luego
devuelve
una
trama
de
reconocimiento
.
Si
la
estaci√≥n
transmisora


no
recibe
una
trama
de
reconocimiento
dentro
de
un
periodo
de
tiempo
especificado
,
supone


que
se
ha
producido
un
error
y
retransmite
la
trama
,
utilizando
el
protocolo
CSMA
/
CA
para


acceder
al
canal
.
Si
no
se
recibe
una
trama
de
reconocimiento
despu√©s
de
un
n√∫mero
fijo
de


retransmisiones
,
la
estaci√≥n
transmisora
se
da
por
vencida
y
descarta
la
trama
.


Habiendo
explorado
c√≥mo
emplea
802.11
los
reconocimientos
de
la
capa
de
enlace
,


estamos
en
disposici√≥n
de
describir
el
protocolo
CSMA
/
CA
802.11
.
Suponga
que
una
esta-


ci√≥n
(
estaci√≥n
inal√°mbrica
o
punto
de
acceso
)
dispone
de
una
trama
para
transmitir
.


1
.
Si
la
estaci√≥n
detecta
inicialmente
que
el
canal
est√°
inactivo
,
transmite
la
trama
despu√©s


de
un
corto
periodo
de
tiempo
,
conocido
con
el
nombre
de
Espacio
distribuido
entre


tramas
(
DIFS
,
Distributed
Inter-frame
Space
)
;
v√©ase
la
Figura
6.10
.


2
.
En
caso
contrario
,
la
estaci√≥n
selecciona
un
valor
de
espera
(
backoff
)
aleatorio
y
efect√∫a


una
cuenta
atr√°s
con
este
valor
mientras
detecta
que
el
canal
est√°
inactivo
.
Cuando


detecta
que
el
canal
est√°
ocupado
,
el
valor
del
contador
permanece
congelado
.


3
.
Cuando
el
contador
alcanza
el
valor
cero
(
observe
que
esto
s√≥lo
puede
suceder
mientras


se
detecta
que
el
canal
est√°
inactivo
)
,
la
estaci√≥n
transmite
la
trama
completa
y
luego


espera
a
recibir
un
reconocimiento
.


516
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Destino


DIFS


SIFS


datos


ACK


Origen


Figura
6.10
‚Ä¢
802.11
utiliza
reconocimientos
(
ACK
)
de
la
capa
de
enlace
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5164
.
Si
se
recibe
una
trama
de
reconocimiento
,
la
estaci√≥n
transmisora
sabe
que
su
trama
ha


sido
recibida
correctamente
en
la
estaci√≥n
de
destino
.
Si
la
estaci√≥n
tiene
otra
trama
que


enviar
,
comienza
de
nuevo
el
protocolo
CSMA
/
CA
en
el
paso
2
.
Si
no
se
recibe
una


trama
de
reconocimiento
,
la
estaci√≥n
transmisora
vuelva
a
entrar
en
la
fase
de
backoff


del
paso
2
,
seleccionando
el
valor
aleatorio
de
un
intervalo
m√°s
largo
.


Recuerde
que
con
el
protocolo
de
acceso
m√∫ltiple
CSMA
/
CD
de
Ethernet
(
Secci√≥n


5.5.2
)
una
estaci√≥n
comienza
a
transmitir
en
cuanto
detecta
que
el
canal
est√°
inactivo
.
Sin


embargo
,
con
CSMA
/
CA
la
estaci√≥n
se
abstiene
de
transmitir
mientras
efect√∫a
la
cuenta


atr√°s
,
a√∫n
cuando
detecte
que
no
hay
actividad
en
el
canal
.
¬ø
Por
qu√©
CSMA
/
CD
y
CSMA/


CA
adoptan
enfoques
tan
distintos
en
este
punto
?


Para
responder
a
esta
cuesti√≥n
,
consideremos
un
escenario
en
el
que
hay
dos
estaciones
,


cada
una
de
ellas
con
una
trama
para
transmitir
,
pero
ninguna
de
las
estaciones
transmite


inmediatamente
,
porque
ambas
detectan
que
hay
una
tercera
estaci√≥n
que
ya
est√°
transmi-


tiendo
.
Con
CSMA
/
CD
de
Ethernet
,
ambas
estaciones
transmitir√≠an
tan
pronto
como
detec-


taran
que
la
tercera
estaci√≥n
ha
dejado
de
transmitir
.
Esto
provocar√≠a
una
colisi√≥n
,
lo
cual
no


es
un
serio
problema
en
CSMA
/
CD
,
ya
que
ambas
estaciones
abortar√≠an
sus
transmisiones
y


por
tanto
evitar√≠an
transmitir
in√∫tilmente
el
resto
de
sus
tramas
.
Sin
embargo
,
en
802.11
,
la


situaci√≥n
es
muy
distinta
.
Puesto
que
802.11
no
detecta
las
colisiones
y
no
aborta
en
conse-


cuencia
las
transmisiones
,
la
trama
que
sufre
una
colisi√≥n
ser√°
transmitida
en
su
totalidad
.


Por
tanto
,
el
objetivo
de
802.11
es
evitar
las
colisiones
siempre
que
sea
posible
.
En
802.11
,


si
las
dos
estaciones
detectan
que
el
canal
est√°
ocupado
,
ambas
entran
inmediatamente
en
un


estado
de
espera
aleatoria
,
con
lo
que
cabe
esperar
que
ambas
seleccionen
valores
de
espera


(
backoff
)
diferentes
.
Si
dichos
valores
son
verdaderamente
distintos
,
una
vez
que
el
canal


pase
a
estar
inactivo
una
de
las
dos
estaciones
empezar√°
a
transmitir
antes
que
la
otra
y
(
si


las
dos
estaciones
no
est√°n
ocultas
a
ojos
una
de
otra
)
la
‚Äú
estaci√≥n
perdedora
‚Äù
escuchar√°
la


se√±al
de
la
estaci√≥n
‚Äú
ganadora
‚Äù
,
congelar√°
su
cuenta
atr√°s
y
se
abstendr√°
de
transmitir
hasta


que
la
estaci√≥n
ganadora
haya
completado
su
transmisi√≥n
.
De
esta
forma
se
evita
una
cos-


tosa
colisi√≥n
.
Por
supuesto
,
en
802.11
siguen
pudi√©ndose
producir
colisiones
con
este
esce-


nario
:
las
dos
estaciones
podr√≠an
estar
ocultas
a
ojos
una
de
otra
o
las
dos
estaciones
podr√≠an


seleccionar
valores
de
espera
aleatorios
lo
suficientemente
pr√≥ximos
como
para
que
la
trans-


misi√≥n
procedente
de
la
estaci√≥n
que
comience
primero
pueda
alcanzar
a
la
segunda
esta-


ci√≥n
.
Recuerde
que
ya
nos
hemos
encontrado
anteriormente
con
este
problema
al
hablar
de


los
algoritmos
de
acceso
aleatorio
en
el
contexto
de
la
Figura
5.14
.


Enfrent√°ndose
al
problema
de
los
terminales
ocultos
:
RTS
y
CTS


El
protocolo
MAC
802.11
tambi√©n
incluye
un
excelente
(
pero
opcional
)
esquema
de


reserva
,
que
ayuda
a
evitar
las
colisiones
incluso
en
presencia
de
terminales
ocultos
.
Vamos


a
analizar
este
esquema
en
el
contexto
de
la
Figura
6.11
,
que
muestra
dos
estaciones
ina-


l√°mbricas
y
un
punto
de
acceso
.
Ambas
estaciones
inal√°mbricas
caen
dentro
del
alcance
del


punto
de
acceso
(
cuya
√°rea
de
cobertura
se
muestra
como
un
c√≠rculo
sombreado
)
y
ambas


est√°n
relacionadas
con
el
punto
de
acceso
.
Sin
embargo
,
debido
al
desvanecimiento
,
los


rangos
de
se√±al
de
las
estaciones
inal√°mbricas
est√°n
limitados
al
interior
de
los
c√≠rculos


sombreados
de
la
Figura
6.11
.
En
consecuencia
,
cada
una
de
las
estaciones
inal√°mbricas


est√°
oculta
a
ojos
de
la
otra
,
aunque
ninguna
de
las
dos
est√°
oculta
para
el
punto
de
acceso
.


Consideremos
ahora
por
qu√©
los
terminales
ocultos
pueden
ser
problem√°ticos
.
Suponga


que
la
estaci√≥n
H1
est√°
transmitiendo
una
trama
y
que
,
en
mitad
de
la
transmisi√≥n
de
H1
,
la


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
517


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
517estaci√≥n
H2
quiere
enviar
una
trama
al
punto
de
acceso
.
H2
,
al
no
escuchar
la
transmisi√≥n


de
H1
,
esperar√°
primero
un
intervalo
DIFS
y
luego
transmitir√°
la
trama
,
provocando
una


colisi√≥n
.
Por
tanto
,
el
canal
se
desperdiciar√°
durante
el
periodo
completo
de
transmisi√≥n
de


H1
,
as√≠
como
durante
la
transmisi√≥n
de
H2
.


Para
evitar
este
problema
,
el
protocolo
IEEE
802.11
permite
a
una
estaci√≥n
utilizar
una


corta
trama
de
control
de
Solicitud
de
transmisi√≥n
(
RTS
,
Request
to
Send
)
y
otra
corta


trama
de
control
de
Preparado
para
enviar
(
CTS
,
Clear
to
Send
)
para
reservar
el
acceso


al
canal
.
Cuando
un
emisor
quiere
enviar
una
trama
DATA
,
puede
enviar
primero
una
trama


RTS
al
punto
de
acceso
,
indicando
el
tiempo
total
requerido
para
transmitir
la
trama
DATA


y
la
trama
de
reconocimiento
(
ACK
)
.
Cuando
el
punto
de
acceso
recibe
la
trama
RTS
,
res-


ponde
difundiendo
una
trama
CTS
.
Esta
trama
CTS
sirve
a
dos
prop√≥sitos
distintos
:
propor-


ciona
al
emisor
un
permiso
expl√≠cito
para
enviar
y
tambi√©n
informa
a
las
otras
estaciones
de


que
no
deben
transmitir
durante
ese
periodo
de
tiempo
reservado
.


Por
tanto
,
en
la
Figura
6.12
,
antes
de
transmitir
una
trama
DATA
,
H1
difunde
primero


una
trama
RTS
,
que
ser√°
escuchada
por
todas
las
estaciones
situadas
en
su
√°rea
de
cobertura
,


incluyendo
al
punto
de
acceso
.
A
continuaci√≥n
,
el
punto
de
acceso
responde
con
una
trama


CTS
,
que
ser√°
escuchada
por
todas
las
estaciones
dentro
de
su
√°rea
de
cobertura
,
incluyendo


a
H1
y
H2
.
La
estaci√≥n
H2
,
habiendo
escuchado
la
trama
CTS
,
se
abstendr√°
de
transmitir


durante
el
tiempo
especificado
en
la
trama
CTS
.
Las
tramas
 
RTS
,
CTS
,
DATA
y
ACK
se


muestran
en
la
Figura
6.12
.


El
uso
de
las
tramas
RTS
y
CTS
puede
mejorar
el
rendimiento
de
dos
formas
impor-


tantes
:


‚Ä¢
El
problema
de
las
estaciones
ocultas
queda
mitigado
,
ya
que
una
trama
DATA
larga
s√≥lo


se
transmitir√°
despu√©s
de
haber
reservado
el
canal
.


‚Ä¢
Puesto
que
las
tramas
RTS
y
CTS
son
cortas
,
una
colisi√≥n
que
implique
a
una
trama
RTS


o
CTS
s√≥lo
durar√°
mientras
duren
esas
tramas
cortas
RTS
o
CTS
.
Una
vez
transmitidas


las
tramas
RTS
y
CTS
correctamente
,
las
tramas
DATA
y
ACK
siguientes
deber√≠an
poder


transmitirse
sin
colisiones
.


518
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


APH1
H2


Figura
6.11
‚Ä¢
Ejemplo
de
terminales
ocultos
:
H1
est√°
oculto
a
ojos
de
H2


y
viceversa
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
518Le
animamos
a
comprobar
el
funcionamiento
del
applet
802.11
disponible
en
el
sitio
web


del
libro
.
Este
applet
interactivo
ilustra
el
protocolo
CSMA
/
CA
,
incluyendo
la
secuencia
de


intercambio
RTS
/
CTS
.


Aunque
el
intercambio
RTS
/
CTS
puede
ayudar
a
reducir
las
colisiones
,
tambi√©n
intro-


duce
un
retardo
y
consume
recursos
del
canal
.
Por
esta
raz√≥n
,
el
intercambio
RTS
/
CTS
sola-


mente
se
utiliza
(
si
es
que
se
utiliza
en
absoluto
)
para
reservar
el
canal
para
la
transmisi√≥n


de
una
trama
DATA
larga
.
En
la
pr√°ctica
,
cada
estaci√≥n
inal√°mbrica
puede
establecer
un


umbral
RTS
,
de
modo
que
la
secuencia
RTS
/
CTS
se
utilice
√∫nicamente
cuando
la
trama
que


hay
que
transmitir
sea
mayor
que
el
umbral
.
Para
muchas
estaciones
inal√°mbricas
,
el
valor


umbral
RTS
predeterminado
es
mayor
que
la
longitud
m√°xima
de
trama
,
por
lo
que
la


secuencia
RTS
/
CTS
se
omite
para
todas
las
tramas
DATA
enviadas
.


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
519


Destino
Todos
los
nodos
restantes


Diferir


acceso


Origen


DIFS


ACK


SIFS


SIFS


SIFS


DATA


CTS
CTS


ACK


RTS


Figura
6.12
‚Ä¢
Evitaci√≥n
de
colisiones
utilizando
las
tramas
RTS
y
CTS
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
519Utilizaci√≥n
de
802.11
como
un
enlace
punto
a
punto


Nuestro
an√°lisis
se
ha
centrado
hasta
el
momento
en
el
uso
de
802.11
en
una
configuraci√≥n


de
acceso
m√∫ltiple
.
Es
necesario
mencionar
que
si
hay
dos
nodos
,
cada
uno
de
los
cuales


dispone
de
una
antena
direccional
,
ambos
pueden
apuntar
sus
antenas
hacia
el
otro
nodo
y


ejecutar
el
protocolo
802.11
sobre
lo
que
es
,
esencialmente
,
un
enlace
punto
a
punto
.
Dado


el
bajo
coste
del
hardware
802.11
comercial
,
la
utilizaci√≥n
de
antenas
direccionales
y
una


potencia
de
transmisi√≥n
incrementada
,
permite
utilizar
802.11
como
un
medio
barato
de
pro-


porcionar
conexiones
punto
a
punto
inal√°mbricas
a
distancias
de
decenas
de
kil√≥metros
.


[
Raman
2007
]
describe
dichas
redes
inal√°mbricas
multisalto
operando
en
la
llanuras
rurales


del
Ganges
en
la
India
y
que
contienen
enlaces
802.11
punto
a
punto
.


6.3.3
La
trama
IEEE
802.11


Aunque
la
trama
802.11
comparte
muchas
similitudes
con
una
trama
Ethernet
,
tambi√©n
con-


tiene
diversos
campos
que
son
espec√≠ficos
para
su
uso
en
enlaces
inal√°mbricos
.
La
trama


802.11
se
muestra
en
la
Figura
6.13
.
Los
n√∫meros
situados
encima
de
cada
campo
de
la


trama
representan
las
longitudes
de
los
campos
en
bytes
;
los
n√∫meros
situados
por
encima


de
cada
uno
de
los
subcampos
en
el
campo
de
control
de
trama
representan
las
longitudes
de


los
subcampos
en
bits
.
Examinemos
ahora
los
campos
de
la
trama
,
as√≠
como
algunos
de
los


subcampos
m√°s
importantes
del
campo
de
control
de
trama
.


Campos
de
carga
√∫til
y
CRC


En
el
coraz√≥n
de
la
trama
se
encuentra
la
carga
√∫til
,
que
normalmente
estar√°
compuesta
por


un
datagrama
IP
o
un
paquete
ARP
.
Aunque
el
campo
puede
tener
una
longitud
de
hasta


2.312
bytes
,
normalmente
la
longitud
es
inferior
a
1.500
bytes
,
conteniendo
el
campo
un


datagrama
IP
o
un
paquete
ARP
.
Al
igual
que
con
una
trama
Ethernet
,
una
trama
802.11


incluye
un
c√≥digo
de
redundancia
c√≠clica
(
CRC
)
de
32
bits
,
de
modo
que
el
receptor
pueda


detectar
errores
de
bit
en
la
trama
recibida
.
Como
ya
hemos
visto
,
los
errores
de
bit
son


mucho
m√°s
comunes
en
las
redes
LAN
inal√°mbricas
que
en
las
redes
LAN
cableadas
,
por
lo


que
el
CRC
aqu√≠
es
todav√≠a
m√°s
√∫til
.


Campos
de
direcci√≥n


Quiz√°
la
diferencia
m√°s
llamativa
en
la
trama
802.11
es
que
tiene
cuatro
campos
de
direc-


ci√≥n
,
cada
uno
de
los
cuales
puede
contener
una
direcci√≥n
MAC
de
6
bytes
.
¬ø
Pero
por
qu√©


se
utilizan
cuatro
campos
de
direcci√≥n
?
¬ø
No
bastar√≠a
con
un
campo
MAC
de
origen
y
un


campo
MAC
de
destino
,
como
sucede
en
Eth
ernet
?
Resulta
que
tres
de
los
campos
de


direcci√≥n
son
necesarios
para
prop√≥sitos
de
la
comunicaci√≥n
por
la
red
,
espec√≠ficamente


para
mover
el
datagrama
de
la
capa
de
red
de
una
estaci√≥n
inal√°mbrica
hasta
una
interfaz
de


router
a
trav√©s
de
un
punto
de
acceso
.
El
cuarto
campo
de
direcci√≥n
se
utiliza
cuando
los


puntos
de
acceso
se
reenv√≠an
tramas
entre
s√≠
en
modo
ad
hoc
.
Puesto
que
s√≥lo
estamos
con-


siderando
aqu√≠
las
redes
de
infraestructura
,
vamos
a
centrarnos
en
los
tres
primeros
campos


de
direcci√≥n
.
El
est√°ndar
802.11
define
estos
campos
como
sigue
:


‚Ä¢D
i
r
e
c
c
i
√≥
n
2
 
e
s
 
l
a
 
d
i
r
e
c
c
i
√≥
n
 
M
A
C
 
d
e
 
l
a
 
e
s
t
a
c
i
√≥
n
 
q
u
e
 
t
r
a
n
s
m
i
t
e
 
l
a
 
t
r
a
m
a
.
 
P
o
r
 
t
a
n
t
o
,
 
s
i
 
u
n
a


estaci√≥n
inal√°mbrica
transmite
la
trama
,
la
direcci√≥n
MAC
de
dicha
estaci√≥n
se
inser-


tar√°
en
el
campo
Direcci√≥n
2
.
De
forma
similar
,
si
es
un
punto
de
acceso
el
que
trans-


520
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
520mite
la
trama
,
en
el
campo
Direcci√≥n
2
se
insertar√°
la
direcci√≥n
MAC
de
dicho
punto
de


acceso
.
 

‚Ä¢E
l
 
c
a
m
p
o
 
Direcci√≥n
1
contiene
la
direcci√≥n
MAC
de
la
estaci√≥n
inal√°mbrica
que
tiene


que
recibir
la
trama
.
Por
tanto
,
si
una
estaci√≥n
inal√°mbrica
m√≥vil
transmite
la
trama
,


Direcci√≥n
1
contendr√°
la
direcci√≥n
MAC
del
punto
de
acceso
de
destino
.
De
forma
simi-


lar
,
si
un
punto
de
acceso
transmite
la
trama
,
Direcci√≥n
1
contendr√°
la
direcci√≥n
MAC


de
la
estaci√≥n
inal√°mbrica
de
destino
.


‚Ä¢P
a
r
a
 
c
o
m
p
r
e
n
d
e
r
 
e
l
 
c
a
m
p
o
 
D
i
r
e
c
c
i
√≥
n
 
3
,
 
r
e
c
u
e
r
d
e
 
q
u
e
 
e
l
 
B
S
S
 
(
q
u
e
 
c
o
n
s
t
a
 
d
e
l
 
p
u
n
t
o
 
d
e


acceso
y
las
estaciones
inal√°mbricas
)
forma
parte
de
una
subred
y
que
dicha
subred
se


conecta
a
otras
subredes
a
trav√©s
de
alguna
interfaz
de
router
.
El
campo
Direcci√≥n
3
con-


tiene
la
direcci√≥n
MAC
de
esa
interfaz
de
router
.


Para
entender
mejor
el
prop√≥sito
del
campo
Direcci√≥n
3
,
veamos
un
ejemplo
de
comu-


nicaci√≥n
por
red
en
el
contexto
de
la
Figura
6.14
.
En
esta
figura
hay
dos
puntos
de
acceso
,


cada
uno
de
los
cuales
es
responsable
de
una
serie
de
estaciones
inal√°mbricas
.
Cada
uno
de


los
puntos
de
acceso
tiene
una
conexi√≥n
directa
con
un
router
,
el
cual
a
su
vez
se
conecta
a


la
red
Internet
global
.
Debemos
recordar
que
un
punto
de
acceso
es
un
dispositivo
de
la
capa


de
enlace
y
que
,
por
tanto
,
nunca
‚Äú
habla
‚Äù
IP
ni
comprende
las
direcciones
IP
.
Considere


ahora
el
proceso
de
transferir
un
datagrama
desde
la
interfaz
del
router
R1
hasta
la
estaci√≥n


inal√°mbrica
H1
.
El
router
no
es
consciente
de
que
existe
un
punto
de
acceso
entre
√©l
y
H1
;


desde
la
perspectiva
del
router
,
H1
es
simplemente
un
host
en
una
de
las
subredes
a
la
que
el


router
est√°
conectado
.


‚Ä¢E
l
 
r
o
u
t
e
r
,
 
q
u
e
 
c
o
n
o
c
e
 
l
a
 
d
i
r
e
c
c
i
√≥
n
 
I
P
d
e
 
H
1
 
(
a
 
p
a
r
t
i
r
 
d
e
 
l
a
 
d
i
r
e
c
c
i
√≥
n
 
d
e
 
d
e
s
t
i
n
o
 
d
e
l
 
d
a
t
a
-


grama
)
,
utiliza
ARP
para
determinar
la
direcci√≥n
MAC
de
H1
,
al
igual
que
en
una
red


LAN
Ethernet
normal
.
Despu√©s
de
obtener
la
direcci√≥n
MAC
de
H1
,
la
interfaz
del
rou-


ter
R1
encapsula
el
datagrama
dentro
de
una
trama
Ethernet
.
El
campo
de
direcci√≥n
de


origen
de
esta
trama
contiene
la
direcci√≥n
MAC
de
R1
y
el
campo
de
la
direcci√≥n
de
des-


tino
contiene
la
direcci√≥n
MAC
de
H1
.


‚Ä¢C
u
a
n
d
o
 
l
a
 
t
r
a
m
a
 
E
t
h
e
r
n
e
t
 
l
l
e
g
a
 
a
l
 
p
u
n
t
o
 
d
e
 
a
c
c
e
s
o
,
 
√©
s
t
e
 
c
o
n
v
i
e
r
t
e
 
l
a
 
t
r
a
m
a
 
E
t
h
e
r
n
e
t


802.3
en
una
trama
802.11
antes
de
transmitirla
por
el
canal
inal√°mbrico
.
El
punto
de


acceso
rellena
los
campos
Direcci√≥n
1
y
Direcci√≥n
2
con
la
direcci√≥n
MAC
de
H1
y
su


propia
direcci√≥n
MAC
,
respectivamente
,
como
hemos
descrito
anteriormente
.
Como


Direcci√≥n
3
,
el
punto
de
acceso
inserta
la
direcci√≥n
MAC
de
R1
.
De
esta
manera
,
H1


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
521


Control


de
trama


2


2241
1
1
1
1
1
1
1


26
6
6
2
6
0
-
2
3
1
2
4


Trama
(
los
n√∫meros
indican
la
longitud
del
campo
en
bytes
):


Direcci√≥n


1Duraci√≥n
Carga


√∫til
CRC


Versi√≥n


protocolo


Hacia


AP


Desde


AP


M√°s


frag
.


Gesti√≥n


potencia


M√°s


datos


Direcci√≥n


2


Direcci√≥n


3


Direcci√≥n


4


Control


secuencia


Tipo
Subtipo
Reintentar
WEP
Rsvd


Campo
de
control
de
trama
expandido
(
los
n√∫meros
indican
la
longitud
de
los
subcampos
en
bits
):


Figura
6.13
‚Ä¢
Trama
802.11
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
521puede
determinar
(
a
partir
de
la
direcci√≥n
3
)
la
direcci√≥n
MAC
de
la
interfaz
del
router


que
envi√≥
el
datagrama
hacia
la
subred
.


Considere
ahora
lo
que
sucede
cuando
la
estaci√≥n
inal√°mbrica
H1
responde
transfiriendo
un


datagrama
desde
H1
a
R1
.


‚Ä¢
H1
crea
una
trama
802.11
,
rellenando
los
campos
Direcci√≥n
1
y
Direcci√≥n
2
con
la
direc-


ci√≥n
MAC
del
punto
de
acceso
y
la
de
H1
,
respectivamente
,
como
hemos
descrito
ante-


riormente
.
Como
Direcci√≥n
3
,
H1
inserta
la
direcci√≥n
MAC
de
R1
.


‚Ä¢
Cuando
el
punto
de
acceso
recibe
la
trama
802.11
,
la
convierte
en
una
trama
Ethernet
.
El


campo
de
direcci√≥n
de
origen
de
esta
trama
ser√°
la
direcci√≥n
MAC
de
H1
,
mientras
que


el
campo
de
direcci√≥n
de
destino
ser√°
la
direcci√≥n
MAC
de
R1
.
Por
tanto
,
el
campo


Direcci√≥n
3
permite
al
punto
de
acceso
determinar
la
direcci√≥n
MAC
de
destino
apro-


piada
a
la
hora
de
construir
la
trama
Ethernet
.


En
resumen
,
el
campo
Direcci√≥n
3
desempe√±a
un
papel
crucial
para
la
comunicaci√≥n
por
red


entre
el
BSS
y
una
red
LAN
cableada
.


Campos
N√∫mero
de
secuencia
,
Duraci√≥n
y
Control
de
trama


Recuerde
que
en
802.11
,
cada
vez
que
una
estaci√≥n
recibe
correctamente
una
trama
proce-


dente
de
otra
estaci√≥n
devuelve
un
mensaje
de
reconocimiento
.
Puesto
que
los
reconoci-


mientos
pueden
perderse
,
la
estaci√≥n
transmisora
podr√≠a
enviar
m√∫ltiples
copias
de
una


determinada
trama
.
Como
vimos
en
nuestro
an√°lisis
del
protocolo
rdt2.1
(
Secci√≥n
3.4.1
)
,


el
uso
de
n√∫meros
de
secuencia
permite
al
receptor
distinguir
entre
una
trama
reci√©n
trans-


mitida
y
la
retransmisi√≥n
de
una
trama
anterior
.
El
campo
de
n√∫mero
de
secuencia
en
la


522
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Internet


Router


AP


H1
R1


BSS
1


BSS
2


AP


Figura
6.14
‚Ä¢
Uso
de
los
campos
de
direcci√≥n
en
las
tramas
802.11
:
env√≠o
de


tramas
entre
H1
y
R1
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
522trama
802.11
sirve
aqu√≠
,
en
la
capa
de
enlace
,
exactamente
al
mismo
prop√≥sito
que
serv√≠a
a


la
capa
de
transporte
en
el
Cap√≠tulo
3
.


Recuerde
que
el
protocolo
802.11
permite
a
una
estaci√≥n
transmisora
reservar
el
canal


durante
un
periodo
de
tiempo
,
que
incluye
el
tiempo
para
transmitir
su
trama
de
datos
y
el


tiempo
para
transmitir
una
trama
de
reconocimiento
.
Este
valor
de
duraci√≥n
est√°
incluido
en


el
campo
Duraci√≥n
de
la
trama
(
tanto
para
las
tramas
de
datos
como
para
las
tramas
RTS
y


CTS
)
.


Como
se
muestra
en
la
Figura
6.13
,
el
campo
de
control
de
trama
incluye
muchos
sub-


campos
.
Vamos
a
limitarnos
a
comentar
algunas
cosas
acerca
de
los
subcampos
m√°s
impor-


tantes
;
para
ver
una
exposici√≥n
m√°s
completa
,
puede
consultar
la
especificaci√≥n
802.11


[
Held
2001
;
Crow
1997
;
IEEE
802.11
1999
]
.
Los
campos
tipo
y
subtipo
se
utilizan
para
dis-


tinguir
las
tramas
de
asociaci√≥n
,
RTS
,
CTS
,
ACK
y
de
datos
.
Los
campos
hacia
y
desde
se


utilizan
para
definir
los
significados
de
los
diferentes
campos
de
direcci√≥n
(
estos
significa-


dos
cambian
dependiendo
de
si
se
est√°
utilizando
el
modo
ad
hoc
o
el
modo
de
infraestruc-


tura
,
y
en
este
√∫ltimo
caso
dependiendo
de
si
quien
est√°
enviando
la
trama
es
una
estaci√≥n


inal√°mbrica
o
un
punto
de
acceso
)
.
Finalmente
,
el
campo
WEP
indica
si
se
est√°
empleando


cifrado
o
no
(
hablaremos
de
WEP
en
el
Cap√≠tulo
8)
.


6.3.4
Movilidad
dentro
de
la
misma
subred
IP


Para
incrementar
el
rango
f√≠sico
de
una
red
LAN
inal√°mbrica
,
las
empresas
y
universidades


suelen
implantar
varios
BSS
dentro
de
la
misma
subred
IP
.
Esto
plantea
naturalmente
el
pro-


blema
de
la
movilidad
entre
los
distintos
BSS
:
¬ø
c√≥mo
pueden
moverse
las
estaciones
ina-


l√°mbricas
de
forma
transparente
de
un
BSS
a
otro
,
mientras
mantienen
una
serie
de
sesiones


TCP
activas
?
Como
veremos
en
esta
subsecci√≥n
,
la
movilidad
puede
gestionarse
de
forma


relativamente
sencilla
cuando
los
BSS
forman
parte
de
una
misma
subred
.
Cuando
las
esta-


ciones
se
desplazan
entre
subredes
contiguas
,
hacen
falta
protocolos
m√°s
complejos
de
ges-


ti√≥n
de
la
movilidad
,
como
los
que
estudiaremos
en
las
Secciones
6.5
y
6.6
.


Examinemos
ahora
un
ejemplo
espec√≠fico
de
movilidad
entre
diversos
BSS
dentro
de
la


misma
subred
.
La
Figura
6.15
muestra
dos
BSS
interconectados
con
un
host
,
H1
,
que
se
des-


plaza
desde
BSS1
a
BSS2
.
Puesto
que
en
este
ejemplo
el
dispositivo
de
interconexi√≥n
que


conecta
a
los
dos
BSS
no
es
un
router
,
todas
las
estaciones
de
los
dos
BSS
,
incluyendo
los


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
523


BSS
1
BSS
2


H1


Conmutador


AP
1
AP
2


Figura
6.15
‚Ä¢
Movilidad
dentro
de
la
misma
subred
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
523puntos
de
acceso
,
pertenecen
a
la
misma
subred
IP
.
Por
tanto
,
cuando
H1
se
mueve
desde


BSS1
a
BSS2
puede
conservar
su
direcci√≥n
IP
y
todas
sus
conexiones
TCP
activas
.
Si
el
dis-


positivo
de
interconexi√≥n
fuera
un
router
,
entonces
H1
tendr√≠a
que
obtener
una
nueva
direc-


ci√≥n
IP
en
la
subred
hacia
la
cual
se
est√°
moviendo
.
Este
cambio
de
direcci√≥n
interrumpir√≠a


(
y
har√≠a
que
se
terminara
)
cualquier
conexi√≥n
TCP
activa
en
H1
.
En
la
Secci√≥n
6.6
veremos


c√≥mo
puede
utilizarse
un
protocolo
de
movilidad
de
la
capa
red
,
como
por
ejemplo
IP
m√≥vil
,


para
evitar
este
problema
.


¬ø
Pero
qu√©
es
lo
que
sucede
espec√≠ficamente
cuando
H1
se
mueve
de
BSS1
a
BSS2
?
A


medida
que
H1
se
aleja
de
AP1
,
H1
detecta
que
la
se√±al
de
AP1
comienza
a
debilitarse
y


empieza
entonces
a
explorar
en
busca
de
una
se√±al
de
mayor
intensidad
.
H1
recibe
tramas


baliza
de
AP2
(
que
en
muchos
entornos
corporativos
y
universitarios
tendr√°n
el
mismo
iden-


tificador
SSID
que
AP1
)
.
H1
se
desasocia
entonces
de
AP1
y
se
asocia
con
AP2
,
al
mismo


tiempo
que
mantiene
su
direcci√≥n
IP
y
sus
sesiones
TCP
activas
.


Esto
resuelve
el
problema
de
la
transferencia
desde
el
punto
de
vista
del
host
y
del
punto


de
acceso
.
¬ø
Pero
qu√©
sucede
con
el
conmutador
de
la
Figura
6.15
?
¬ø
C√≥mo
sabe
que
el
host


se
ha
desplazado
de
un
punto
de
acceso
a
otro
?
Como
recordar√°
del
Cap√≠tulo
5
,
los
conmu-


tadores
disponen
de
una
caracter√≠stica
de
‚Äú
auto-aprendizaje
‚Äù
,
que
les
permite
construir
auto-


m√°ticamente
sus
tablas
de
reenv√≠o
.
Esta
caracter√≠stica
de
auto-aprendizaje
gestiona
de
forma


eficiente
los
desplazamiento
ocasionales
(
por
ejemplo
,
cuando
se
transfiere
a
un
empleado


de
un
departamento
a
otro
)
;
sin
embargo
,
los
conmutadores
no
fueron
dise√±ados
para
dar


soporte
a
usuarios
extremadamente
m√≥viles
que
deseen
mantener
las
conexiones
TCP
mien-


tras
se
desplazan
entre
varios
BSS
.
Para
apreciar
cu√°l
es
aqu√≠
el
problema
,
recuerde
que


antes
del
desplazamiento
el
conmutador
tiene
una
entrada
en
su
tabla
de
reenv√≠o
que
empa-


reja
la
direcci√≥n
MAC
de
H1
con
la
interfaz
saliente
del
conmutador
a
trav√©s
de
la
cual
se


puede
alcanzar
a
H1
.
Si
H1
se
encuentra
inicialmente
en
BSS1
,
entonces
un
datagrama
des-


tinado
a
H1
tendr√°
que
ser
dirigido
hacia
H1
a
trav√©s
del
punto
de
acceso
AP1
.
Sin
embargo
,


una
vez
que
H1
se
asocia
con
BSS2
sus
tramas
deben
ser
dirigidas
hacia
AP2
.
Una
soluci√≥n


(
que
en
cierto
modo
es
un
truco
)
es
que
AP2
env√≠e
al
conmutador
una
trama
Ethernet
de


difusi√≥n
con
la
direcci√≥n
de
origen
de
H1
justo
despu√©s
de
la
nueva
asociaci√≥n
.
Cuando
el


conmutador
reciba
la
trama
actualizar√°
su
tabla
de
reenv√≠o
,
permitiendo
alcanzar
a
H1
a
tra-


v√©s
de
AP2
.
El
grupo
de
est√°ndares
802.11f
est√°
desarrollando
un
protocolo
entre
puntos
de


acceso
(
inter-AP
)
para
gestionar
este
problema
y
otros
problemas
relacionados
.


6.3.5
Caracter√≠sticas
avanzadas
de
802.11


Vamos
a
terminar
nuestro
estudio
sobre
802.11
con
un
breve
an√°lisis
de
dos
capacidades


avanzadas
que
podemos
encontrar
en
las
redes
802.11
.
Como
veremos
,
estas
capacida-


des
no
est√°n
completamente
especificadas
en
el
est√°ndar
802.11
,
sino
que
son
una
serie
de


mecanismos
especificados
en
el
est√°ndar
los
que
hacen
posible
dichas
capacidades
.
Esto


permite
que
los
diferentes
fabricantes
implementen
dichas
capacidades
utilizando
sus
pro-


pias
t√©cnicas
(
propietarias
)
,
lo
que
supuestamente
les
puede
proporcionar
ventajas
sobre
sus


competidores
.


Adaptaci√≥n
de
la
velocidad
en
802.11


Hemos
visto
anteriormente
,
en
la
Figura
6.3
,
que
las
diferentes
t√©cnicas
de
modulaci√≥n


(
con
las
diferentes
velocidades
de
transmisi√≥n
que
proporcionan
)
pueden
resultar
apropia-


das
para
diferentes
escenarios
de
SNR
.
Considere
por
ejemplo
un
usuario
802.11
m√≥vil
que


524
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
524se
encuentra
inicialmente
a
20
metros
de
la
estaci√≥n
base
con
una
alta
relaci√≥n
se√±al-ruido
.


Dado
el
alto
valor
de
SNR
,
el
usuario
puede
comunicarse
con
la
estaci√≥n
base
utilizando


una
t√©cnica
de
modulaci√≥n
de
la
capa
f√≠sica
que
proporcione
altas
velocidades
de
transmi-


si√≥n
,
al
mismo
tiempo
que
se
mantiene
una
baja
BER
.
Este
usuario
podr√°
operar
en
las


mejores
condiciones
.
Suponga
ahora
que
el
usuario
comienza
a
moverse
alej√°ndose
de
la


estaci√≥n
base
,
con
lo
que
la
SNR
disminuye
a
medida
que
la
distancia
con
la
estaci√≥n
base


se
incrementa
.
En
este
caso
,
si
no
cambia
la
t√©cnica
de
modulaci√≥n
utilizada
en
el
proto-


colo
802.11
que
opera
entre
la
estaci√≥n
base
y
el
usuario
,
la
BER
comenzar√°
a
ser
inacepta-


blemente
alta
a
medida
que
la
relaci√≥n
SNR
se
reduzca
,
llegando
eventualmente
a
un
punto


en
que
ninguna
de
las
tramas
transmitidas
se
reciba
correctamente
.


Por
esta
raz√≥n
,
algunas
implementaciones
de
802.11
tienen
una
capacidad
de
adapta-


ci√≥n
de
la
velocidad
que
permite
seleccionar
adaptativamente
la
t√©cnica
subyacente
de


modulaci√≥n
de
la
capa
f√≠sica
que
hay
que
utilizar
,
bas√°ndose
en
las
caracter√≠sticas
pasadas
o


recientes
del
canal
.
La
implementaci√≥n
WaveLAN-II
de
802.11b
de
Lucent
[
Kamerman


1997
]
proporciona
m√∫ltiples
velocidades
de
transmisi√≥n
de
datos
.
Si
un
nodo
env√≠a
dos
tra-


mas
consecutivas
sin
recibir
una
trama
de
reconocimiento
(
una
indicaci√≥n
impl√≠cita
de
que


hay
errores
de
bit
en
el
canal
)
,
la
velocidad
de
transmisi√≥n
se
reduce
al
siguiente
nivel
infe-


rior
.
Si
se
confirman
10
tramas
consecutivas
o
si
finaliza
el
recuento
de
un
temporizador
que


controla
el
tiempo
transcurrido
desde
la
√∫ltima
reducci√≥n
,
la
velocidad
de
transmisi√≥n
se


incrementa
al
nivel
inmediatamente
superior
.
Este
mecanismo
de
adaptaci√≥n
de
la
velocidad


comparte
la
misma
filosof√≠a
de
‚Äú
prueba
‚Äù
que
el
mecanismo
de
control
de
congesti√≥n
de


TCP
:
cuando
las
condiciones
son
buenas
(
lo
que
est√°
indicado
por
la
recepci√≥n
de
tramas


ACK
)
,
la
velocidad
de
transmisi√≥n
se
incrementa
,
hasta
que
sucede
algo
‚Äú
malo
‚Äù
(
la
falta
de


recepci√≥n
de
tramas
ACK
)
;
cuando
sucede
algo
‚Äú
malo
‚Äù
,
la
velocidad
de
transmisi√≥n
se


reduce
.
La
adaptaci√≥n
de
velocidad
en
802.11
y
en
el
control
de
congesti√≥n
TCP
son
,
por


tanto
,
similares
al
ni√±o
que
est√°
constantemente
pidiendo
m√°s
y
m√°s
a
sus
padres
(
por
ejem-


plo
,
caramelos
,
en
caso
de
un
ni√±o
de
corta
edad
,
o
una
hora
de
llegada
a
casa
m√°s
tard√≠a
en


el
caso
de
los
adolescentes
)
hasta
que
los
padres
dicen
finalmente
que
¬°
Ya
basta
!
,
momento


en
que
el
ni√±o
echa
marcha
atr√°s
(
s√≥lo
para
intentarlo
posteriormente
cuando
la
situaci√≥n


haya
posiblemente
mejorado
)
.
Tambi√©n
se
han
propuesto
varios
otros
esquemas
para
mejo-


rar
este
sistema
b√°sico
de
ajuste
autom√°tico
de
la
velocidad
[
Holland
2001
;
Lacage
2004
]
.


Gesti√≥n
de
la
potencia


La
potencia
es
un
recurso
escaso
en
los
dispositivos
m√≥viles
,
por
lo
que
el
est√°ndar
802.11


proporciona
capacidades
de
gesti√≥n
de
la
potencia
que
permiten
a
los
nodos
802.11
minimi-


zar
la
cantidad
de
tiempo
que
sus
funciones
de
detecci√≥n
,
transmisi√≥n
y
recepci√≥n
,
as√≠
como


otros
circuitos
,
necesitan
estar
‚Äú
activos
‚Äù
.
La
gesti√≥n
de
potencia
en
802.11
opera
de
la
forma


siguiente
:
un
nodo
es
capaz
de
alternar
expl√≠citamente
entre
los
estados
dormido
y
despierto


(
a
diferencia
de
los
estudiantes
que
se
duermen
durante
las
clases
)
.
Un
nodo
indica
al
punto


de
acceso
que
se
va
a
ir
a
dormir
poniendo
a
1
el
bit
de
gesti√≥n
de
potencia
en
la
cabecera
de


una
trama
802.11
.
Entonces
se
configura
un
temporizador
en
el
nodo
para
despertar
a
√©ste


justo
antes
del
momento
en
el
que
el
punto
de
acceso
tiene
programado
enviar
su
trama


baliza
(
recuerde
que
un
punto
de
acceso
env√≠a
normalmente
una
trama
baliza
cada
100
mili-


segundos
)
.
Puesto
que
el
punto
de
acceso
sabe
,
gracias
a
que
el
bit
de
gesti√≥n
de
potencia


est√°
activado
,
que
el
nodo
se
va
a
dormir
,
el
punto
de
acceso
sabr√°
que
no
debe
enviar
nin-


guna
trama
a
dicho
nodo
y
almacenar√°
en
un
buffer
todas
las
tramas
destinadas
a
ese
host


dormido
para
su
transmisi√≥n
posterior
.


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
525


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
525El
nodo
se
despertar√°
justo
antes
de
que
el
punto
de
acceso
env√≠e
una
trama
baliza
y


entrar√°
r√°pidamente
en
el
estado
completamente
activo
(
a
diferencia
de
lo
que
sucede
con


los
estudiantes
adormilados
,
este
despertar
requiere
√∫nicamente
250
microsegundos
[
Ka-


merman
1997
]
)
.
Las
tramas
baliza
enviadas
por
el
punto
de
acceso
contienen
una
lista
de


nodos
cuyas
tramas
se
han
guardado
en
buffer
en
el
punto
de
acceso
.
Si
no
existen
tramas
en


el
buffer
para
el
nodo
,
√©ste
puede
volver
a
dormirse
.
En
caso
contrario
,
el
nodo
puede
solici-


tar
expl√≠citamente
que
se
le
env√≠en
las
tramas
almacenadas
en
buffer
transmitiendo
un
men-


saje
de
sondeo
hacia
el
punto
de
acceso
.
Con
un
tiempo
entre
balizas
de
100
milisegundos
,


un
tiempo
de
reactivaci√≥n
de
250
microsegundos
y
un
tiempo
similarmente
peque√±o
para


recibir
una
trama
baliza
y
comprobar
que
no
hay
ninguna
trama
en
el
buffer
,
un
nodo
que
no


tenga
tramas
que
enviar
o
recibir
puede
estar
durmiendo
el
99
por
ciento
del
tiempo
,
lo
que


permite
un
ahorro
considerable
de
energ√≠a
.


6.3.6
M√°s
all√°
de
802.11
:
Bluetooth
y
WiMAX


Como
se
ilustra
en
la
Figura
6.2
,
el
est√°ndar
WiFi
IEEE
802.11
est√°
pensado
para
la
comu-


nicaci√≥n
entre
dispositivos
separados
hasta
100
metros
(
excepto
cuando
se
utiliza
802.11
en


una
configuraci√≥n
punto
a
punto
con
una
antena
direccional
)
.
Existen
otros
dos
protocolos


est√°ndar
IEEE
802
:
Bluetooth
(
definido
en
el
est√°ndar
IEEE
802.15.1
[
IEEE
802.15
2009
]
)


y
WiMAX
(
definido
en
el
est√°ndar
IEEE
802.16
[
IEEE
802.16d
2004
;
IEEE
802.16e


2005
]
)
para
la
comunicaci√≥n
a
distancias
m√°s
cortas
y
m√°s
largas
,
respectivamente
.


Bluetooth


Una
red
IEEE
802.15.1
opera
con
un
corto
alcance
,
a
baja
potencia
y
con
bajo
coste
.
Se
trata


b√°sicamente
de
una
tecnolog√≠a
de
‚Äú
sustituci√≥n
de
cables
‚Äù
de
baja
potencia
,
corto
alcance
y


baja
velocidad
para
la
interconexi√≥n
de
computadoras
de
bolsillo
,
dispositivos
perif√©ricos
,


tel√©fonos
celulares
y
dispositivos
PDA
,
mientras
que
802.11
es
una
tecnolog√≠a
de
‚Äú
acceso
‚Äù


de
mayor
potencia
,
de
alcance
medio
y
mayor
velocidad
.
Por
esta
raz√≥n
,
las
redes
802.15.1


se
denominan
en
ocasiones
redes
inal√°mbricas
de
√°rea
personal
(
WPAN
,
Wireless
Personal


Area
Network
)
.
Las
capas
de
enlace
y
f√≠sica
de
802.15.1
est√°n
basadas
en
la
especificaci√≥n


anterior
de
Bluetooth
para
redes
de
√°rea
personal
[
Held
2001
,
Bisdikian
2001
]
.
Las
redes


802.15.1
operan
en
la
banda
de
radio
sin
licencia
de
2,4
GHz
en
forma
TDM
,
con
particio-


nes
de
tiempo
de
625
microsegundos
.
Durante
cada
partici√≥n
de
tiempo
,
un
emisor
trans-


mite
en
uno
de
79
canales
,
cambiando
el
canal
de
una
partici√≥n
a
otra
en
una
forma
conocida


pero
pseudo-aleatoria
.
Este
tipo
de
saltos
de
canal
,
que
es
una
t√©cnica
conocida
con
el
nom-


bre
de
Espectro
disperso
por
salto
de
frecuencia
(
FHSS
,
Frequency-Hopping
Spread


Spectrum
)
,
distribuye
las
transmisiones
a
lo
largo
del
tiempo
por
todo
el
espectro
de
fre-


cuencias
.
802.15.1
puede
proporcionar
velocidades
de
datos
de
hasta
4
Mbps
.


Las
redes
802.15.1
son
redes
ad
hoc
:
no
hace
falta
ninguna
infraestructura
(
por
ejem-


plo
,
un
punto
de
acceso
)
para
interconectar
los
dispositivos
802.15.1
.
Por
tanto
,
estos
dispo-


sitivos
deben
organizarse
por
s√≠
mismos
.
Los
dispositivos
802.15.1
se
organizan
primero
en


una
picored
(
piconet
)
,
formada
por
hasta
ocho
dispositivos
activos
,
como
se
muestra
en
la


Figura
6.16
.
Uno
de
estos
dispositivos
se
designa
como
maestro
,
actuando
los
dispositivos


restantes
como
esclavos
.
El
nodo
maestro
gobierna
realmente
la
picored
:
es
su
reloj
el
que


determina
el
tiempo
en
la
picored
;
el
dispositivo
maestro
puede
transmitir
en
cada
partici√≥n


con
n√∫mero
impar
y
un
esclavo
s√≥lo
puede
transmitir
despu√©s
de
que
el
maestro
se
haya


comunicado
con
√©l
en
la
partici√≥n
anterior
e
incluso
entonces
el
esclavo
s√≥lo
puede
transmi-


526
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
526tir
hacia
el
maestro
.
Adem√°s
de
los
dispositivos
esclavos
,
puede
haber
hasta
255
dispositi-


vos
aparcados
dentro
de
la
red
.
Estos
dispositivos
no
pueden
comunicarse
hasta
que
su


estado
sea
cambiado
por
el
nodo
maestro
de
aparcado
a
activo
.


Para
obtener
m√°s
informaci√≥n
acerca
de
las
redes
WPAN
802.15.1
,
el
lector
interesado


puede
consultar
las
referencias
sobre
Bluetooth
[
Held
2001
,
Bisdikian
2001
]
o
el
sitio
web


oficial
de
IEEE
802.15
[
IEEE
802.15
2009
]
.


WiMAX


WiMAX
(
World
Interoperability
for
Microwave
Access
,
Interoperabilidad
mundial
para


acceso
por
microondas
)
es
una
familia
de
est√°ndares
IEEE
802.16
que
trata
de
suministrar


datos
inal√°mbricos
a
un
gran
n√∫mero
de
usuarios
en
un
√°rea
extensa
,
a
velocidades
capaces


de
competir
con
las
de
los
modems
por
cable
y
las
redes
ADSL
.
El
est√°ndar
802.16d
actua-


liza
el
est√°ndar
anterior
802.16a
.
El
est√°ndar
802.16e
pretende
soportar
la
movilidad
a
velo-


cidades
de
70-80
millas
por
hora
,
unos
105-120
kil√≥metros
por
hora
(
es
decir
,
velocidad
de


autopista
en
la
mayor√≠a
de
los
pa√≠ses
fuera
de
Europa
)
y
tiene
una
estructura
de
enlace
dife-


rente
para
dispositivos
peque√±os
y
de
recursos
limitados
tales
como
las
PDA
,
los
tel√©fonos


y
las
computadoras
port√°tiles
.


La
arquitectura
802.16
est√°
basada
en
la
noci√≥n
de
una
estaci√≥n
base
que
sirve
de


modo
centralizado
a
un
n√∫mero
potencialmente
grande
de
clientes
(
conocidos
con
el
nom-


bre
de
estaciones
de
abonado
)
asociados
con
dicha
estaci√≥n
base
.
En
este
sentido
,
WiMAX


recuerda
tanto
a
WiFi
en
modo
de
infraestructura
como
a
las
redes
de
telefon√≠a
celular
.
La


estaci√≥n
base
coordina
la
transmisi√≥n
de
los
paquetes
de
la
capa
de
enlace
tanto
en
la
direc-


ci√≥n
de
bajada
(
desde
la
estaci√≥n
base
a
las
estaciones
de
abonado
)
como
de
subida
(
desde


las
estaciones
de
abonado
hacia
la
estaci√≥n
base
)
,
de
acuerdo
con
la
estructura
de
marcos


TDM
mostrada
en
la
Figura
6.17
.
Utilizaremos
aqu√≠
el
t√©rmino
‚Äú
paquete
‚Äù
en
lugar
del
t√©r-


mino
‚Äú
trama
‚Äù
(
que
hemos
usado
para
802.11
y
otros
paquetes
de
la
capa
de
enlace
)
para


distinguir
la
unidad
de
datos
de
la
capa
de
enlace
de
la
estructura
de
marcos
TDM
mostrada


en
la
Figura
6.17
.
WiMAX
opera
,
por
tanto
,
en
modo
de
multiplexaci√≥n
por
divisi√≥n
en


el
tiempo
(
TDM
)
,
aunque
los
tiempos
de
marco
son
variables
como
se
indica
m√°s
adelante
.


6.3
‚Ä¢
WIFI
:
REDES
LAN
INAL√ÅMBRICAS
802.11
527


Radio
de


cobertura


Dispositivo
maestro


Dispositivo
esclavo


Dispositivo
aparcado


Clave
:


M


M


S


S


S
S


P


P


P


P


P


Figura
6.16
‚Ä¢
Una
picored
Bluetooth
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
527Observemos
que
WiMAX
tambi√©n
define
un
modo
FDM
de
operaci√≥n
,
aunque
aqu√≠
no
lo


vamos
a
tratar
.


Al
principio
de
la
estructura
de
marcos
TDM
,
la
estaci√≥n
base
env√≠a
en
primer
lugar
la


lista
de
mensajes
 
MAP
(
Media
Access
Protocol
)
descendentes
que
informa
a
las
estaciones


de
abonado
de
las
propiedades
de
la
capa
f√≠sica
(
esquema
de
modulaci√≥n
,
codificaci√≥n
y


par√°metros
de
correcci√≥n
de
errores
)
que
se
utilizar√°n
para
transmitir
las
subsiguientes
r√°fa-


gas
de
paquetes
dentro
de
la
estructura
de
marcos
TDM
.
Puede
haber
m√∫ltiples
r√°fagas
den-


tro
de
una
estructura
y
m√∫ltiples
paquetes
dentro
de
una
r√°faga
destinada
a
una
determinada


estaci√≥n
de
abonado
.
La
estaci√≥n
base
transmite
todos
los
paquetes
contenidos
en
la
r√°faga


utilizando
las
mismas
propiedades
de
la
capa
f√≠sica
.
Sin
embargo
,
dichas
propiedades
pue-


den
cambiar
de
una
r√°faga
a
otra
,
permitiendo
a
la
estaci√≥n
base
seleccionar
esquemas
de


transmisi√≥n
de
la
capa
f√≠sica
que
est√©n
√≥ptimamente
adaptados
a
cada
estaci√≥n
de
abonado


receptora
.
La
estaci√≥n
base
puede
seleccionar
el
conjunto
de
receptores
a
los
que
va
a
enviar


en
esta
estructura
en
funci√≥n
de
las
condiciones
actuales
estimadas
del
canal
existente
hasta


cada
receptor
.
Esta
forma
de
 
planificaci√≥n
oportunista
[
Bender
2000
,
Kulkarni
2005
]


(
adaptar
el
protocolo
de
la
capa
f√≠sica
a
las
condiciones
del
canal
entre
el
emisor
y
el
recep-


tor
,
y
seleccionar
los
receptores
a
los
que
se
enviar√°n
los
paquetes
bas√°ndose
en
las
condi-


ciones
del
canal
)
permite
a
la
estaci√≥n
base
hacer
un
uso
√≥ptimo
del
medio
inal√°mbrico
.
El


est√°ndar
WiMAX
no
impone
un
conjunto
concreto
de
par√°metros
de
la
capa
f√≠sica
que
haya


que
utilizar
en
una
situaci√≥n
determinada
;
dicha
decisi√≥n
se
deja
al
arbitrio
del
fabricante


del
equipo
WiMAX
y
del
operador
de
red
.


Una
estaci√≥n
base
WiMAX
tambi√©n
regula
el
acceso
de
las
estaciones
de
abonado
al


canal
ascendente
mediante
el
uso
de
mensajes
UL-MAP
.
Estos
mensajes
controlan
la
can-


tidad
de
tiempo
durante
la
cual
se
da
a
cada
estaci√≥n
de
abonado
acceso
al
canal
en
los


subsiguientes
canales
ascendentes
.
De
nuevo
,
el
est√°ndar
WiMAX
no
impone
ninguna


pol√≠tica
concreta
para
asignar
el
tiempo
de
canal
ascendente
a
un
cliente
;
es
una
decisi√≥n


que
se
deja
al
operador
de
red
.
En
lugar
de
ello
,
WiMAX
proporciona
los
mecanismos


(
tales
como
los
mensajes
de
control
UL-MAP
)
para
implementar
una
pol√≠tica
que
podr√≠a


asignar
diferentes
periodos
de
tiempo
de
acceso
al
canal
a
las
distintas
estaciones
de
abo-


nado
.
Los
abonados
emplean
las
partes
iniciales
de
la
estructura
de
canal
ascendente
para


transmitir
mensajes
de
control
del
enlace
radio
,
mensajes
para
solicitar
la
admisi√≥n
y
la


autenticaci√≥n
en
la
red
WiMAX
y
mensajes
de
protocolos
de
mayor
nivel
relacionados


con
la
administraci√≥n
,
como
por
ejemplo
DHCP
y
SNMP
.


La
Figura
6.18
muestra
el
formato
del
paquete
MAC
WiMAX
.
El
√∫nico
campo
que


vamos
a
comentar
aqu√≠
es
el
campo
de
identificador
de
conexi√≥n
de
la
cabecera
.
WiMAX
es


una
arquitectura
orientada
a
conexi√≥n
que
permite
que
cada
conexi√≥n
tenga
asociados
una


calidad
de
servicio
(
QoS
)
,
unos
par√°metros
de
tr√°fico
y
otras
informaciones
.
El
c√≥mo
haya


528
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


DL


r√°faga
2


DL


r√°faga
n


Inicial
.
,


mant
.


Solicitud


conexi√≥n
SS
1
SS
2DL


r√°faga
1DL-MAP
UL-MAP


Canal


descendente


Canal


ascendente


pream
.


SS
k


Figura
6.17
‚Ä¢
Estructura
de
marcos
TDM
802.16
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
528que
proporcionar
esta
calidad
de
servicio
es
cuesti√≥n
del
operador
de
red
.
WiMAX
propor-


ciona
los
mecanismos
de
bajo
nivel
(
por
ejemplo
,
estimaci√≥n
del
canal
y
campos
de
solici-


tud
de
admisi√≥n
para
la
conexi√≥n
,
con
el
fin
de
transportar
informaci√≥n
entre
la
estaci√≥n
base


y
el
host
)
,
pero
no
proporciona
el
enfoque
global
ni
las
pol√≠ticas
para
proporcionar
la
cali-


dad
de
servicio
.
A√∫n
cuando
cada
estaci√≥n
de
abonado
tendr√°
una
direcci√≥n
MAC
de
48
bits


(
como
en
las
redes
802.3
y
802.11
)
,
en
WiMAX
esta
direcci√≥n
MAC
se
puede
considerar


m√°s
apropiadamente
como
un
identificador
de
equipo
,
ya
que
la
comunicaci√≥n
entre
equi-


pos
terminales
termina
por
ser
asignada
a
un
identificador
de
conexi√≥n
(
en
lugar
de
a
las


direcciones
de
los
terminales
emisor
y
receptor
de
la
conexi√≥n
)
.


Nuestro
tratamiento
de
WiMAX
ha
sido
necesariamente
breve
y
hay
muchos
otros


temas
que
no
hemos
podido
analizar
aqu√≠
,
como
la
gesti√≥n
de
potencia
(
un
modo
de
dormir


similar
al
de
802.11
)
,
la
transferencia
de
llamadas
(
handoff
)
,
la
planificaci√≥n
dependiente


del
estado
del
canal
de
las
transmisiones
de
unidades
de
datos
protocolo
(
PDU
)
MAC
pro-


cedentes
de
la
estaci√≥n
base
,
el
mecanismo
QoS
y
la
seguridad
.
Estando
el
est√°ndar
802.16e


todav√≠a
en
desarrollo
,
los
sistemas
WiMAX
continuar√°n
evolucionando
a
lo
largo
de
los
pr√≥-


ximos
a√±os
.
Mientras
que
los
est√°ndares
indicados
anteriormente
permiten
conocer
de
una


forma
relativamente
‚Äú
ardua
‚Äù
√©stos
y
otros
temas
relacionados
con
WiMAX
,
[
Eklund
2002
,


Cicconetti
2006
]
proporcionan
una
serie
de
panor√°micas
de
WiMAX
muy
comprensibles
.


6.4
Acceso
celular
a
Internet


En
la
secci√≥n
anterior
hemos
examinado
c√≥mo
un
host
puede
acceder
a
Internet
cuando


entra
dentro
de
un
√°rea
de
cobertura
WiFi
,
es
decir
,
cuando
se
encuentra
en
las
vecindades


de
un
punto
de
acceso
802.11
.
Pero
la
mayor√≠a
de
las
√°reas
WiFi
tienen
una
cobertura


peque√±a
,
de
entre
10
y
100
metros
de
di√°metro
y
las
redes
WiMAX
,
que
tienen
un
√°rea


mayor
,
est√°n
todav√≠a
por
implantarse
.
¬ø
Qu√©
podemos
hacer
cuando
necesitamos
desespera-


damente
acceso
inal√°mbrico
a
Internet
y
no
podemos
acceder
a
un
√°rea
WiFi
?


Dado
que
la
telefon√≠a
celular
es
ahora
onmipresente
en
muchas
√°reas
de
todo
el
mundo
,


una
estrategia
natural
consiste
en
extender
las
redes
celulares
de
modo
que
soporten
no
s√≥lo


la
telefon√≠a
de
voz
sino
tambi√©n
el
acceso
inal√°mbrico
a
Internet
.
Idealmente
,
este
acceso
a


6.4
‚Ä¢
ACCESO
CELULAR
A
INTERNET
529


Tipo0
EC
ESF
CI
EKS
RSV
Longitud


MSB
(
3
)


ID
de
conexi√≥n


(
LSD
)


Longitud
LSB


Cabecera
CRC


ID
de
conexi√≥n


(
MSB
)


Carga
√∫til


CRC
de
32
bits


Figura
6.18
‚Ä¢
Paquete
802.16
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
529Internet
se
llevar√≠a
a
cabo
a
una
velocidad
razonablemente
alta
y
permitir√≠a
una
movilidad


transparente
,
con
lo
que
los
usuarios
podr√≠an
mantener
sus
sesiones
TCP
mientras
est√°n
via-


jando
,
por
ejemplo
,
en
un
autob√∫s
o
en
un
tren
.
Con
tasas
de
bit
lo
suficientemente
altas


tanto
para
subida
como
para
bajada
,
el
usuario
podr√≠a
incluso
mantener
sesiones
de
video-


conferencia
mientras
deambula
de
un
lado
a
otro
(
roaming
)
.
Este
escenario
no
es
tan
futu-


rista
como
puede
parecer
.
En
el
momento
de
escribir
estas
l√≠neas
(
primavera
de
2009
)
,


muchos
proveedores
de
servicios
de
telefon√≠a
celular
de
Estados
Unidos
ofrecen
a
sus
abo-


nados
un
servicio
de
acceso
celular
a
Internet
por
menos
de
50
d√≥lares
mensuales
,
con
velo-


cidades
de
bajada
y
de
subida
de
unos
cuantos
centenares
de
kilobits
por
segundo
.


Asimismo
,
est√°n
empezando
a
estar
disponibles
velocidades
de
datos
de
varios
megabits
por


segundo
a
medida
que
se
van
implantando
cada
vez
m√°s
los
servicios
de
datos
de
banda


ancha
como
HSDPA
.


En
esta
secci√≥n
,
proporcionamos
una
breve
panor√°mica
de
las
tecnolog√≠as
actuales
y


emergentes
de
acceso
celular
a
Internet
.
Nos
centraremos
de
nuevo
principalmente
en
el
pri-


mer
salto
inal√°mbrico
entre
el
tel√©fono
celular
y
la
infraestructura
de
red
cableada
;
en
la
Sec-


ci√≥n
6.7
veremos
c√≥mo
se
enrutan
las
llamadas
hacia
un
usuario
que
se
est√°
moviendo
entre


las
distintas
estaciones
base
.
Nuestro
an√°lisis
,
debido
a
su
brevedad
,
s√≥lo
proporcionar√°
una


descripci√≥n
simplificada
y
de
nivel
general
de
las
tecnolog√≠as
celulares
.
Por
supuesto
,
las


comunicaciones
celulares
modernas
son
un
tema
de
gran
profundidad
y
de
gran
amplitud
,


existiendo
muchas
universidades
que
ofrecen
cursos
completos
sobre
el
mismo
.
Los
lectores


que
deseen
conocer
m√°s
detalles
pueden
consultar
[
Goodman
1997
;
Kaaranen
2001
;
Lin


2001
;
Korhonen
2003
,
Schiller
2003
;
Scourias
2007
;
Turner
2009
]
,
as√≠
como
[
Mouly
1992
]


que
es
una
referencia
particularmente
excelente
y
exhaustiva
.


6.4.1
Panor√°mica
de
la
arquitectura
de
las
redes
celulares


En
nuestra
descripci√≥n
de
la
arquitectura
de
las
redes
celulares
de
esta
secci√≥n
,
adoptaremos


la
terminolog√≠a
de
los
est√°ndares
del
Sistema
global
de
comunicaciones
m√≥viles
(
GSM
,
Glo-


bal
System
for
Mobile
Communications
)
.
(
Para
los
aficionados
a
las
cuestiones
hist√≥ricas
,
el


acr√≥nimo
GSM
derivaba
originalmente
de
Groupe
Sp√©cial
Mobile
,
aunque
luego
se
adopt√≥


el
nombre
ingl√©s
,
conserv√°ndose
las
letras
originales
del
acr√≥nimo
.
)
En
la
d√©cada
de
1980
,


los
organismos
reguladores
europeos
se
dieron
cuenta
de
la
necesidad
de
un
sistema
de
tele-


fon√≠a
celular
digital
europeo
que
pudiera
sustituir
los
numerosos
sistemas
de
telefon√≠a
celu-


lar
anal√≥gica
,
que
eran
incompatibles
entre
s√≠
.
Esta
iniciativa
condujo
a
la
definici√≥n
del


est√°ndar
GSM
[
Mouly
1992
]
.
En
Europa
se
implant√≥
la
tecnolog√≠a
GSM
con
un
gran
√©xito
a


principios
de
la
d√©cada
de
1990
,
y
desde
entonces
GSM
ha
crecido
hasta
convertirse
en
el


sistema
dominante
dentro
de
la
telefon√≠a
celular
;
en
estos
momentos
,
m√°s
del
80
por
ciento


de
todos
los
abonados
de
telefon√≠a
celular
del
mundo
utilizan
GSM
.


Cuando
las
personas
hablan
acerca
de
la
tecnolog√≠a
celular
,
a
menudo
la
clasifican


como
perteneciente
a
una
de
varias
‚Äú
generaciones
‚Äù
.
Las
primeras
generaciones
estaban
dise-


√±adas
principalmente
para
el
tr√°fico
de
voz
.
Los
sistemas
de
primera
generaci√≥n
(
1
G
)
eran


sistemas
FDMA
anal√≥gicos
,
dise√±ados
exclusivamente
para
la
comunicaci√≥n
√∫nicamente
de


voz
.
Estos
sistemas
1
G
est√°n
pr√°cticamente
extintos
en
la
actualidad
,
habiendo
sido
sustitui-


dos
por
los
sistemas
2
G
digitales
.
Los
sistemas
2
G
originales
tambi√©n
estaban
dise√±ados


para
voz
,
pero
posteriormente
se
ampliaron
(
2.5
G
)
para
soportar
servicios
tanto
de
voz
como


de
datos
(
es
decir
,
Internet
)
.
Los
sistemas
3
G
,
que
est√°n
siendo
implantados
actualmente
,


tambi√©n
soportan
voz
y
datos
,
pero
poniendo
un
√©nfasis
cada
vez
mayor
en
las
capacidades


de
datos
y
en
los
enlaces
de
acceso
de
radio
de
m√°s
alta
velocidad
.


530
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
530Arquitectura
de
redes
celulares
,
2
G
:
conexiones
de
voz
con
la
red
telef√≥nica


El
t√©rmino
celular
hace
referencia
al
hecho
de
que
la
regi√≥n
cubierta
por
una
red
celular
est√°


dividida
en
una
serie
de
√°reas
geogr√°ficas
de
cobertura
,
denominadas
celdas
,
que
se
mues-


tran
como
hex√°gonos
en
la
parte
izquierda
de
la
Figura
6.19
.
Igual
que
el
est√°ndar
WiFi


802.11
que
hemos
estudiado
en
la
Secci√≥n
6.3.1
,
GSM
tiene
su
propia
nomenclatura
parti-


6.4
‚Ä¢
ACCESO
CELULAR
A
INTERNET
531


TECNOLOG√çA
M√ìVIL
CELULAR
3
G
FRENTE
A
REDES
LAN
INAL√ÅMBRICAS


Muchos
operadores
de
telefon√≠a
m√≥vil
celular
est√°n
implantando
sistemas
m√≥viles
celulares


3
G
con
velocidades
de
datos
en
interiores
de
2
Mbps
y
en
exteriores
de
384
kbps
y
supe-


riores
.
Los
sistemas
3
G
se
est√°n
implantando
en
bandas
de
radiofrecuencia
con
licencia
,


habiendo
pagado
algunos
operadores
sumas
considerables
a
los
respectivos
gobiernos
por


dichas
licencias
.
Los
sistemas
3
G
permiten
a
los
usuarios
acceder
a
Internet
desde
ubicacio-


nes
remotas
en
exteriores
mientras
est√°n
viajando
,
de
forma
similar
al
actual
acceso
a
los


servicios
de
telefon√≠a
celular
.
Por
ejemplo
,
la
tecnolog√≠a
3
G
permite
a
un
usuario
acceder
a


informaci√≥n
de
mapas
de
carreteras
mientras
est√°
conduciendo
un
veh√≠culo
o
consultar
la


informaci√≥n
sobre
la
cartelera
cinematogr√°fica
mientras
est√°
tomando
el
sol
en
una
playa
.


Sin
embargo
,
muchos
expertos
est√°n
empezando
a
cuestionar
si
la
tecnolog√≠a
3
G
tendr√°


√©xito
,
dado
su
alto
coste
y
la
competencia
representada
por
la
tecnolog√≠a
de
redes
LAN
ina-


l√°mbricas
.
En
particular
,
estos
expertos
argumentan
que
:


‚Ä¢
La
emergente
infraestructura
de
redes
LAN
inal√°mbricas
ser√°
en
el
futuro
pr√°cticamente


ubicua
.
Las
redes
LAN
inal√°mbricas
IEEE
802.11
,
que
operan
a
54
Mbps
,
disfrutan
de


una
implantaci√≥n
cada
vez
mayor
.
Casi
todas
las
computadoras
port√°tiles
y
las
PDA


vienen
equipadas
de
f√°brica
con
tarjetas
LAN
802.11
.
Adem√°s
,
los
dispositivos
Internet


emergentes
(
como
las
c√°maras
inal√°mbricas
y
los
marcos
de
fotograf√≠as
electr√≥nicos
)


tambi√©n
utilizar√°n
peque√±as
tarjetas
LAN
inal√°mbricas
de
baja
potencia
.


‚Ä¢
WiMAX
,
que
hemos
estudiado
en
la
Secci√≥n
6.3.6
,
promete
ofrecer
servicios
de
datos


de
√°rea
extensa
a
los
usuarios
m√≥viles
a
velocidades
de
varios
megabits
por
segundo
o


superiores
.
Sprint
Nextel
est√°
invirtiendo
muchos
miles
de
millones
de
d√≥lares
en
la


implantaci√≥n
de
WiMAX
.


‚Ä¢
Las
estaciones
base
para
redes
LAN
inal√°mbricas
podr√≠an
tambi√©n
comunicarse
con
dis-


positivos
de
telefon√≠a
m√≥vil
.
Los
tel√©fonos
futuros
podr√≠an
ser
capaces
de
conectarse
a
la


red
de
telefon√≠a
celular
o
a
una
red
IP
,
utilizando
un
servicio
de
voz
sobre
IP
similar
a


Skype
,
evitando
con
ello
los
servicios
de
datos
3
G
y
los
servicios
de
voz
de
telefon√≠a


celular
de
los
operadores
.


HISTORIA


Por
supuesto
,
muchos
otros
expertos
piensan
que
3
G
no
s√≥lo
ser√°
un
gran
√©xito
,
sino


que
tambien
va
a
revolucionar
de
forma
importante
la
manera
en
que
trabajamos
y
vivi-


mos
.
Evidentemente
,
puede
que
tanto
WiFi
como
3
G
se
conviertan
en
tecnolog√≠as
ina-


l√°mbricas
prevalentes
,
y
que
los
dispositivos
inal√°mbricos
puedan
seleccionar
autom√°ti-


camente
,
mientras
se
desplazan
,
la
tecnolog√≠a
de
acceso
que
proporcione
el
mejor
servi-


cio
en
cada
ubicaci√≥n
f√≠sica
concreta
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
531cular
.
Cada
celda
contiene
una
estaci√≥n
transductora
base
(
BTS
,
Base
Transceiver
Sta-


tion
)
que
transmite
y
recibe
se√±ales
hacia
y
desde
las
estaciones
m√≥viles
que
se
encuentran


dentro
de
su
celda
.
El
√°rea
de
cobertura
de
una
celda
depende
de
muchos
factores
,
inclu-


yendo
la
potencia
de
transmisi√≥n
de
la
BTS
,
la
potencia
de
transmisi√≥n
de
los
dispositivos


de
usuario
,
los
edificios
situados
dentro
de
la
celda
que
puedan
obstruir
las
comunicaciones


y
la
altura
de
las
antenas
de
la
estaci√≥n
base
.
Aunque
la
Figura
6.19
muestra
que
cada
celda


contiene
una
estaci√≥n
transductora
base
situada
en
el
centro
de
la
celda
,
muchos
sistemas


actuales
colocan
las
BTS
en
las
esquinas
donde
intersectan
tres
celdas
,
de
modo
que
una


√∫nica
BTS
con
antenas
direccionales
pueda
dar
servicio
a
las
tres
.


El
est√°ndar
GSM
para
los
sistemas
celulares
2
G
utiliza
una
combinaci√≥n
FDM
/
TDM


(
radio
)
para
la
interfaz
a√©rea
.
Recuerde
del
Cap√≠tulo
1
que
,
con
FDM
pura
,
el
canal
se
parti-


ciona
en
una
serie
de
canales
de
frecuencia
,
estando
cada
banda
dedicada
a
una
llamada
.


Recuerde
tambi√©n
de
ese
cap√≠tulo
que
,
con
la
multiplexaci√≥n
TDM
pura
,
el
tiempo
se
divide


en
marcos
que
a
su
vez
se
subdividen
en
particiones
y
que
a
cada
llamada
se
le
asigna
el
uso


de
una
partici√≥n
concreta
dentro
del
marco
.
En
los
sistemas
FDM
/
TDM
combinados
,
el


canal
se
particiona
en
una
serie
de
sub-bandas
de
frecuencia
y
dentro
de
cada
sub-banda
el


tiempo
se
divide
en
marcos
y
particiones
.
Por
tanto
,
para
un
sistema
FDM
/
TDM
combinado
,


si
el
canal
est√°
particionado
en
F
sub-bandas
y
el
tiempo
se
divide
en
T
particiones
,
enton-


ces
el
canal
podr√°
soportar
F.T
llamadas
simult√°neas
.
 

Los
sistemas
GSM
est√°n
compuestos
por
bandas
de
frecuencia
de
200
kHz
soportando


cada
banda
ocho
llamadas
TDM
.
GSM
codifica
la
voz
a
13
kbps
y
a
12,2
kbps
.
Un
est√°n-


dar
competidor
de
GSM
,
IS-95
CDMA
y
su
sucesor
CDMA
2000
,
utiliza
acceso
m√∫ltiple


532
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


BSC


BSC


MSC


Clave
:
Estaci√≥n
base
transductora


(
BTS
)


Controlador
de
la
estaci√≥n
base


(
BSC
)


Centro
de
conmutaci√≥n
m√≥vil


(
MSC
)


Abonados
m√≥viles


MSC


pasarela


Sistema
de
la
estaci√≥n


base
(
BSS
)


Sistema
de
la
estaci√≥n
base
(
BSS
)


Red
telef√≥nica


p√∫blica


G


Figura
6.19
‚Ä¢
Componentes
de
una
arquitectura
de
red
celular
GSM
2G.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
532por
divisi√≥n
de
c√≥digo
(
v√©ase
la
Secci√≥n
6.2.1
)
en
lugar
de
la
t√©cnica
combinada
FDM/


TDM
,
lo
que
hace
que
los
tel√©fonos
de
usuario
GSM
no
puedan
operar
en
una
red
IS-95
y


viceversa
.


El
controlador
de
la
estaci√≥n
base
(
BSC
,
Base
Station
Controller
)
de
una
red
GSM


puede
estar
f√≠sicamente
ubicado
junto
a
una
BTS
,
pero
normalmente
un
mismo
BSC
dar√°


servicio
a
varias
decenas
de
estaciones
transductoras
base
.
El
papel
del
BSC
consiste
en


asignar
los
canales
de
radio
de
las
BTS
a
los
abonados
m√≥viles
,
realizar
las
tareas
de


localizaci√≥n
de
abonados
(
paging
)
(
determinar
la
celda
en
la
que
se
encuentra
un
usuario


m√≥vil
)
y
llevar
a
cabo
la
transferencia
de
los
usuarios
m√≥viles
,
que
es
un
tema
del
que
nos


ocuparemos
en
breve
en
la
Secci√≥n
6.7.2
.
El
controlador
de
las
estaciones
base
y
las
estacio-


nes
transductoras
base
que
controla
forman
,
colectivamente
,
un
Sistema
de
estaciones
base


(
BSS
,
Base
Station
System
)
GSM
.


Como
veremos
en
la
Secci√≥n
6.7
,
el
Centro
de
conmutaci√≥n
m√≥vil
(
MSC
,
Mobile


Switching
Center
)
desempe√±a
el
papel
central
en
lo
que
respecta
a
la
autorizaci√≥n
de
los


usuarios
y
la
facturaci√≥n
(
por
ejemplo
,
determinando
si
se
permite
a
un
cierto
dispositivo


m√≥vil
conectarse
a
la
red
celular
)
,
el
establecimiento
y
finalizaci√≥n
de
llamadas
y
la
transfe-


rencia
de
las
mismas
.
Un
√∫nico
MSC
contendr√°
normalmente
hasta
cinco
BSC
,
lo
que
per-


mite
tener
aproximadamente
unos
200.000
abonados
por
MSC
.
La
red
de
un
proveedor
de


servicio
celular
tendr√°
un
serie
de
centros
MSC
,
siendo
algunos
de
ellos
MSC
especiales


conocidos
con
el
nombre
de
centros
MSC
pasarela
,
los
cuales
sirven
para
conectar
la
red


celular
de
ese
proveedor
con
la
red
telef√≥nica
p√∫blica
de
mayor
tama√±o
.


Arquitectura
de
las
redes
celulares
,
2.5
G
y
3
G
:
ampliaci√≥n
de
Internet
a
los


abonados
de
telefon√≠a
celular


Hasta
el
momento
,
nuestras
explicaciones
se
han
centrado
en
la
conexi√≥n
de
los
usuarios
de


telefon√≠a
celular
a
la
red
de
telefon√≠a
p√∫blica
.
Pero
,
cada
vez
m√°s
,
los
usuarios
m√≥viles
acce-


den
a
Internet
a
trav√©s
de
la
red
celular
utilizando
dispositivos
como
iPhones
,
Blackberries
,


computadoras
port√°tiles
y
otros
.
Una
forma
de
hacer
esto
utilizando
s√≥lo
la
infraestructura


2
G
mostrada
en
la
Figura
6.19
consiste
en
utilizar
una
conexi√≥n
de
telefon√≠a
celular
como


conexi√≥n
de
acceso
telef√≥nico
a
un
ISP
,
de
la
misma
forma
que
muchos
usuarios
dom√©sticos


utilizaban
en
la
d√©cada
de
1990
su
tel√©fono
convencional
para
tener
acceso
telef√≥nico
a
un


ISP
.
Sin
embargo
,
la
desventaja
de
este
enfoque
es
la
velocidad
de
transmisi√≥n
extremada-


mete
lenta
(
normalmente
unas
decenas
de
kilobits
por
segundo
y
a
menudo
menos
que
eso
)


disponible
mediante
una
conexi√≥n
celular
de
acceso
telef√≥nico
.
Idealmente
,
lo
que
nos
gus-


tar√≠a
es
ampliar
el
alcance
de
IP
hasta
el
propio
sistema
de
estaciones
base
utilizando
l√≠neas


de
alto
ancho
de
banda
y
emplear
despu√©s
m√∫ltiples
canales
de
voz
o
redes
mejoradas
de


acceso
por
radio
para
conectar
a
los
usuarios
m√≥viles
al
sistema
de
estaciones
base
a
alta


velocidad
.
√âste
es
precisamente
el
enfoque
adoptado
en
los
sistemas
celulares
2.5
G
y
3G.


La
Figura
6.20
muestra
la
arquitectura
de
red
celular
para
2.5
G
GSM
,
que
ampl√≠a
el


est√°ndar
2
G
GSM
para
proporcionar
acceso
de
alta
velocidad
a
Internet
.
El
enfoque
adop-


tado
por
los
dise√±adores
de
2.5
G
GSM
es
muy
claro
:
no
tocar
el
n√∫cleo
de
la
red
de
telefo-


n√≠a
celular
GSM
.
Esto
se
consigue
proporcionando
acceso
a
Internet
en
la
frontera
de
la
red
,


como
una
funcionalidad
a√±adida
independiente
,
en
lugar
de
como
una
funcionalidad
inte-


grada
en
el
n√∫cleo
de
la
red
de
telefon√≠a
celular
existente
(
lo
que
hubiera
requerido
efectuar


cambios
en
dicho
n√∫cleo
)
.
Esa
capacidad
a√±adida
se
implementa
en
la
red
de
acceso
por


radio
,
el
BSC
,
mediante
la
introducci√≥n
de
una
red
separada
de
nodos
SGSN
(
Serving


GPRS
Support
Node
,
Nodo
de
soporte
GPRS
)
.


6.4
‚Ä¢
ACCESO
CELULAR
A
INTERNET
533


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
533En
el
BSC
,
los
canales
FDM
/
TDM
de
la
interfaz
a√©rea
que
transportan
datagramas
IP


se
reenv√≠an
desde
el
BSC
hacia
el
nodo
SGSN
el
cual
se
comunica
con
el
MSC
para
llevar
a


cabo
la
autorizaci√≥n
de
los
usuarios
,
la
transferencia
de
los
mismos
y
otras
funciones
.
Ade-


m√°s
de
este
tr√°fico
de
se√±alizaci√≥n
,
el
SGSN
se
encarga
de
reenviar
los
datagramas
IP
del


BSC
hacia
/
desde
Internet
.
En
la
red
de
acceso
por
radio
,
se
introdujo
el
Servicio
general
de


paquetes
radio
(
GPRS
,
General
Packet
Radio
Service
)
en
GSM
2.5
G
para
permitir
a
los


usuarios
utilizar
din√°micamente
m√∫ltiples
canales
de
radio
para
los
datos
IP
,
obteni√©ndose


as√≠
tasas
de
hasta
115
kbps
.
Siguiendo
la
estela
de
GPRS
,
luego
se
introdujo
el
sistema


Velocidades
de
datos
mejoradas
para
evoluci√≥n
global
(
EDGE
,
Enhanced
Data
Rates
for


Global
Evolution
)
con
el
fin
de
incrementar
las
velocidades
de
datos
de
una
red
GSM
/
GPRS


hasta
384
kbps
.
[
Ericsson
2009
]
proporciona
una
excelente
panor√°mica
de
EDGE
.


Los
sistemas
celulares
3
G
ofrecen
servicios
de
telefon√≠a
y
velocidades
de
datos
signifi-


cativamente
mayores
que
sus
contrapartidas
2.5G.
En
particular
,
los
sistemas
3
G
est√°n
obli-


gados
a
proporcionar
:


‚Ä¢
144
kbps
a
velocidades
de
conducci√≥n
de
veh√≠culos
.


‚Ä¢3
8
4
 
k
b
p
s
 
p
a
r
a
 
u
t
i
l
i
z
a
c
i
√≥
n
 
e
s
t
√°
t
i
c
a
 
e
n
 
e
x
t
e
r
i
o
r
e
s
 
o
 
v
e
l
o
c
i
d
a
d
e
s
 
t
√≠
p
i
c
a
s
 
d
e
 
u
n
a
 
p
e
r
s
o
n
a


caminando
.


‚Ä¢
2
Mbps
para
interiores
.


El
Servicio
universal
de
comunicaciones
m√≥viles
(
UMTS
,
Universal
Mobile
Tele-


communications
Service
)
,
una
de
las
tecnolog√≠as
3
G
m√°s
populares
,
es
una
evoluci√≥n
de


GSM
2.5
G
que
soporta
capacidades
3G.
La
arquitectura
de
una
red
UMTS
se
asemeja
bas-


tante
a
la
arquitectura
de
las
redes
GSM
establecidas
.
En
particular
,
se
contin√∫an
utilizando


las
redes
de
datos
2.5
G
existentes
que
se
muestran
en
la
Figura
6.20
,
de
la
misma
manera


534
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


BSC
MSC


Clave
:


Nodo
de
soporte


GPRS
servidor


(
SGSN
)


Nodo
de
soporte


GPRS
pasarela


(
GGSN
)


MSC


pasarela


Sistema
de
la


estaci√≥n
base
(
BSS
)


Red
telef√≥nica


p√∫blica


GGSNSGSNG


Internet


p√∫blica


G


G


Figura
6.20
‚Ä¢
Arquitectura
de
las
redes
de
voz
y
datos
celulares
GSM
2.5G.
 

M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
534que
las
redes
2.5
G
respetaban
las
redes
de
voz
existentes
en
el
momento
de
su
introducci√≥n
.


Un
cambio
significativo
en
UMTS
es
que
,
en
lugar
de
utilizar
el
esquema
FDMA
/
TDMA
de


GSM
,
utiliza
una
t√©cnica
CDMA
,
denominada
CDMA
de
banda
ancha
mediante
secuencia


directa
(
DS-WCDMA
,
Direct
Sequence
Wideband
CDMA
)
,
dentro
de
particiones
TDMA


(
con
marcos
de
particiones
TDMA
disponibles
en
m√∫ltiples
frecuencias
,
lo
que
constituye


un
uso
interesante
de
las
tres
t√©cnicas
dedicadas
de
compartici√≥n
de
un
canal
que
hemos


identificado
anteriormente
)
.
Este
cambio
requiere
una
nueva
red
de
acceso
inal√°mbrico
celu-


lar
operando
en
paralelo
con
la
red
de
sistemas
BSS
mostrada
en
la
Figura
6.20
.
El
servicio


de
datos
asociado
con
la
especificaci√≥n
WCDMA
se
conoce
con
las
siglas
HSDPA
/
HSUPA


(
High
Speed
Downlink
/
Uplink
Packet
Access
,
Acceso
de
paquetes
de
alta
velocidad
descen-


dente
/
ascendente
)
y
promete
velocidades
de
datos
de
hasta
14
Mbps
.
Puede
encontrar
m√°s


detalles
relativos
a
las
redes
3
G
en
el
sitio
web
del
Proyecto
del
Consorcio
de
Tercera
Gene-


raci√≥n
(
3GPP
,
3rd
Generation
Partnership
Project
)
[
3GPP
2009
]
.


En
junio
de
2007
ya
hab√≠an
sido
conectados
200
millones
de
abonados
3G.
Esto
s√≥lo


representa
el
6,7
por
ciento
de
los
3.000
millones
de
abonados
de
telefon√≠a
m√≥vil
que
hay
en


todo
el
mundo
.
En
los
pa√≠ses
en
los
que
los
sistemas
3
G
fueron
introducidos
primero
(
Jap√≥n


y
Corea
del
Sur
)
m√°s
de
la
mitad
de
todos
los
abonados
utilizan
3G.
En
Europa
,
el
pa√≠s
pun-


tero
es
Italia
,
con
un
tercio
de
sus
abonados
utilizando
3G.
Otros
pa√≠ses
punteros
incluyen


Reino
Unido
,
Austria
,
Australia
y
Singapur
.


Habi√©ndose
definido
varias
generaciones
de
especificaciones
3
G
y
estando
en
marcha


las
correspondientes
implementaciones
,
¬ø
tendremos
que
esperar
mucho
para
que
aparezcan


los
sistemas
inal√°mbricos
4
G
?
La
respuesta
es
s√≠
y
no
.
No
existe
ninguna
definici√≥n
formal


de
c√≥mo
deben
ser
esos
sistemas
4
G
,
a
pesar
de
lo
cual
hay
fabricantes
que
est√°n
dise√±ando


equipos
(
por
ejemplo
,
WiMAX
)
que
ya
superan
las
prestaciones
de
los
sistemas
3G.
Por


supuesto
,
cuando
se
definan
e
implementen
los
sistemas
4
G
,
estos
operar√°n
a
velocidades


m√°s
altas
que
los
sistemas
3
G
,
de
1
Gbps
o
m√°s
;
asimismo
,
permitir√°n
integrar
m√°s
estre-


chamente
los
protocolos
de
Internet
y
lo
m√°s
probable
es
que
se
centren
en
las
comunicacio-


nes
multimedia
,
los
servicios
basados
en
la
ubicaci√≥n
y
en
la
seguridad
.


6.5
Gesti√≥n
de
la
movilidad
:
principios


Habiendo
cubierto
la
naturaleza
inal√°mbrica
de
los
enlaces
de
comunicaciones
existentes
en


una
red
inal√°mbrica
,
ahora
es
el
momento
de
volver
nuestra
atenci√≥n
hacia
la
movilidad
que


estos
enlaces
inal√°mbricos
permiten
.
En
el
sentido
m√°s
amplio
,
un
nodo
m√≥vil
es
aqu√©l
que


cambia
su
punto
de
conexi√≥n
con
la
red
a
lo
largo
del
tiempo
.
Puesto
que
el
t√©rmino


movilidad
ha
adoptado
muchos
significados
tanto
en
el
mundo
de
las
computadoras
como


en
el
de
la
telefon√≠a
,
conviene
primero
considerar
con
cierto
detalle
diversas
dimensiones
de


la
movilidad
.


‚Ä¢
Desde
el
punto
de
vista
de
la
capa
de
red
,
¬ø
c√≥mo
de
m√≥vil
es
un
usuario
?
Un
usuario


f√≠sicamente
m√≥vil
plantear√°
un
conjunto
muy
distinto
de
desaf√≠os
a
la
capa
de
red
,


dependiendo
de
c√≥mo
se
mueva
entre
los
puntos
de
conexi√≥n
con
la
red
.
En
un
extremo


del
espectro
de
la
Figura
6.21
,
un
usuario
puede
llevar
consigo
una
computadora
port√°-


til
con
una
tarjeta
de
interfaz
de
red
inal√°mbrica
mientras
pasea
por
un
edificio
.
Como


vimos
en
la
Secci√≥n
6.3.4
,
este
usuario
no
es
m√≥vil
desde
la
perspectiva
de
la
capa
de


red
.
Adem√°s
,
si
el
usuario
se
asocia
con
el
mismo
punto
de
acceso
,
independientemente


6.5
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
:
PRINCIPIOS
535


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
535de
su
ubicaci√≥n
,
ese
usuario
no
es
ni
siquiera
m√≥vil
desde
la
perspectiva
de
la
capa
de


enlace
.


En
el
otro
extremo
del
espectro
,
considere
el
usuario
que
est√°
viajando
a
150
kil√≥metros


por
hora
por
una
autov√≠a
en
un
BMW
,
pasando
por
m√∫ltiples
redes
de
acceso
inal√°mbricas


y
que
quiere
mantener
una
conexi√≥n
TCP
ininterrumpida
con
alguna
aplicaci√≥n
remota
a


todo
lo
largo
del
viaje
.
¬°
Este
usuario
s√≠
que
es
m√≥vil
sin
ning√∫n
tipo
de
dudas
!
Entre
estos


dos
extremos
se
encontrar√≠a
el
usuario
que
traslada
una
computadora
port√°til
desde
una


ubicaci√≥n
(
por
ejemplo
,
su
oficina
o
su
domicilio
)
a
otra
(
por
ejemplo
,
una
cafeter√≠a
o
un


aula
)
y
quiere
conectarse
a
la
red
en
esa
nueva
ubicaci√≥n
.
Este
usuario
tambi√©n
es
m√≥vil


(
aunque
menos
que
el
conductor
del
BMW
)
,
pero
no
necesita
mantener
una
conexi√≥n


activa
mientras
se
est√°
moviendo
entre
los
puntos
de
conexi√≥n
con
la
red
.
La
Figura
6.21


ilustra
este
espectro
de
movilidad
del
usuario
desde
la
perspectiva
de
la
capa
de
red
.


‚Ä¢
¬ø
Hasta
qu√©
punto
es
importante
que
la
direcci√≥n
del
nodo
m√≥vil
sea
siempre
la
misma
?


Con
la
telefon√≠a
m√≥vil
,
nuestro
n√∫mero
de
tel√©fono
(
que
es
b√°sicamente
la
direcci√≥n
de


la
capa
de
red
de
nuestro
tel√©fono
)
contin√∫a
siendo
el
mismo
a
medida
que
nos
desplaza-


mos
desde
la
red
de
telefon√≠a
m√≥vil
de
un
proveedor
a
la
de
otro
.
¬ø
Deben
las
computado-


ras
port√°tiles
mantener
de
forma
similar
la
misma
direcci√≥n
IP
mientras
se
est√°n


desplazando
entre
redes
IP
?


La
respuesta
a
esta
cuesti√≥n
depender√°
en
gran
medida
de
las
aplicaciones
que
se
est√©n


ejecutando
.
Para
el
conductor
del
BMW
que
quiere
mantener
una
conexi√≥n
TCP
ininte-


rrumpida
con
una
aplicaci√≥n
remota
mientras
viaja
por
la
autov√≠a
,
ser√≠a
conveniente
man-


tener
la
misma
direcci√≥n
IP
.
Recuerde
del
Cap√≠tulo
3
que
una
aplicaci√≥n
Internet
necesita


conocer
la
direcci√≥n
IP
y
el
n√∫mero
de
puerto
de
la
entidad
remota
con
la
que
se
est√°


comunicando
.
Si
una
entidad
m√≥vil
es
capaz
de
mantener
su
direcci√≥n
IP
a
medida
que


se
desplaza
,
la
movilidad
se
convertir√°
en
algo
transparente
desde
el
punto
de
vista
de
la


aplicaci√≥n
.
Esta
transparencia
tiene
un
enorme
valor
,
ya
que
la
aplicaci√≥n
no
tendr√°
que


preocuparse
de
la
cuesti√≥n
de
que
las
direcciones
IP
puedan
potencialmente
cambiar
,
y


un
mismo
c√≥digo
de
aplicaci√≥n
permitir√°
dar
servicio
tanto
a
conexiones
m√≥viles
como


no
m√≥viles
.
Veremos
en
la
siguiente
secci√≥n
que
la
tecnolog√≠a
de
IP
m√≥vil
proporciona


esta
transparencia
,
permitiendo
a
un
nodo
m√≥vil
mantener
su
direcci√≥n
IP
permanente


mientras
se
est√°
desplazando
de
una
red
a
otra
.


Por
otro
lado
,
un
usuario
m√≥vil
menos
glamuroso
podr√≠a
simplemente
querer
apagar
su


computadora
port√°til
en
la
oficina
,
llevarla
a
su
domicilio
,
volver
a
encenderla
y
trabajar


desde
su
casa
.
Si
la
computadora
port√°til
funciona
principalmente
como
un
cliente
en


536
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


El
usuario
√∫nicamente


se
mueve
dentro
de
la


misma
red
de
acceso


inal√°mbrica
.


Sin
movilidad
Alta
movilidad


El
usuario
se
mueve


entre
redes
de
acceso
,


desconect√°ndose


al
moverse
de
una


red
a
otra
.


El
usuario
se
mueve


entre
varias
redes
de


acceso
,
manteniendo


conexiones
activas
.


Figura
6.21
‚Ä¢
Diversos
grados
de
movilidad
desde
el
punto
de
vista
de
la
capa


de
red
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
536aplicaciones
cliente-servidor
(
por
ejemplo
,
enviar
/
leer
correo
electr√≥nico
,
navegar
por
la


Web
,
conectarse
mediante
Telnet
a
un
host
remoto
)
desde
su
domicilio
,
la
direcci√≥n
IP


concreta
utilizada
por
la
computadora
port√°til
no
tiene
tanta
importancia
.
En
particular
,


el
usuario
podr√≠a
perfectamente
funcionar
con
una
direcci√≥n
que
el
ISP
que
da
servicio
a


su
domicilio
le
asignara
temporalmente
a
la
computadora
port√°til
.
Ya
hemos
visto
en
la


Secci√≥n
4.4
que
DHCP
ya
proporciona
esta
funcionalidad
.


‚Ä¢
¬ø
Qu√©
infraestructura
cableada
de
soporte
hay
disponible
?
En
todos
los
escenarios
ante-


riores
,
hemos
supuesto
impl√≠citamente
que
existe
una
infraestructura
fija
a
la
que
el
usua-


rio
m√≥vil
puede
conectarse
:
por
ejemplo
,
la
red
del
ISP
que
da
servicio
a
su
domicilio
,
la


red
de
acceso
inal√°mbrica
de
la
oficina
o
las
redes
de
acceso
inal√°mbrico
que
atraviesan


la
autov√≠a
.
¬ø
Qu√©
sucede
si
no
existe
tal
infraestructura
?
Si
dos
usuarios
est√°n
pr√≥ximos


entre
s√≠
,
desde
el
punto
de
vista
de
las
comunicaciones
,
¬ø
pueden
establecer
una
conexi√≥n


de
red
en
ausencia
de
cualquier
otra
infraestructura
de
la
capa
de
red
?
Las
redes
ad
hoc


proporcionan
precisamente
estas
capacidades
.
Este
√°rea
en
r√°pido
desarrollo
constituye


la
vanguardia
de
las
investigaciones
en
redes
m√≥viles
y
cae
fuera
del
alcance
de
este


libro
.
En
[
Perkins
2000
]
y
en
las
p√°ginas
web
del
grupo
de
trabajo
de
redes
m√≥viles
ad


hoc
(
manet
)
del
IETF
[
manet
2009
]
se
proporciona
un
tratamiento
bastante
exhaustivo


de
esta
materia
.


Para
ilustrar
los
problemas
implicados
en
el
hecho
de
autorizar
a
un
usuario
m√≥vil
a


mantener
conexiones
activas
mientras
se
est√°
desplazando
entre
varias
redes
,
vamos
a
con-


siderar
una
analog√≠a
humana
.
Un
veintea√±ero
que
se
va
del
domicilio
familiar
pasa
a
ser
un


adulto
m√≥vil
,
viviendo
en
una
serie
de
habitaciones
y
/
o
apartamentos
,
cambiando
a
menudo


de
direcci√≥n
.
Si
un
viejo
conocido
quiere
ponerse
en
contacto
con
√©l
,
¬ø
c√≥mo
puede
ese
cono-


cido
encontrar
la
direcci√≥n
de
su
amigo
m√≥vil
?
Una
forma
com√∫n
ser√≠a
contactar
con
la


familia
,
ya
que
un
adulto
m√≥vil
a
menudo
registrar√°
ante
la
familia
(
le
comunicar√°
)
su
direc-


ci√≥n
actual
(
aunque
s√≥lo
sea
para
que
sus
padres
puedan
enviarle
dinero
para
pagarle
el


alquiler
)
.
El
domicilio
familiar
,
con
su
direcci√≥n
permanente
,
se
convertir√°
en
ese
lugar
al


que
otros
pueden
acudir
en
primer
lugar
para
poder
comunicarse
con
ese
adulto
m√≥vil
.
Las


comunicaciones
posteriores
de
ese
viejo
conocido
pueden
ser
indirectas
(
por
ejemplo
,
ese


conocido
puede
enviar
correo
al
domicilio
de
los
padres
y
√©stos
reenviar
el
correo
a
nuestro


adulto
m√≥vil
)
o
directas
(
por
ejemplo
,
cuando
ese
viejo
conocido
utiliza
la
direcci√≥n
que
le


han
facilitado
los
padres
para
enviar
el
correo
directamente
a
su
amigo
m√≥vil
)
.


En
un
entorno
de
red
,
el
domicilio
permanente
de
un
nodo
m√≥vil
(
como
por
ejemplo


una
computadora
port√°til
o
una
PDA
)
se
conoce
con
el
nombre
de
red
propia
(
home
net-


work
)
y
la
entidad
 
dentro
de
la
red
propia
que
se
encarga
de
llevar
a
cabo
las
funciones
de


gesti√≥n
de
la
movilidad
,
de
las
que
hablaremos
m√°s
adelante
,
por
cuenta
del
nodo
m√≥vil
se


conoce
como
agente
propio
(
home
agent
)
.
La
red
en
la
que
reside
actualmente
el
nodo


m√≥vil
se
conoce
con
el
nombre
de
red
ajena
o
visitada
(
foreing
or
visited
network
)
y
la


entidad
dentro
de
la
red
ajena
que
ayuda
al
nodo
m√≥vil
con
las
funciones
de
gesti√≥n
de
la


movilidad
,
que
veremos
m√°s
adelante
,
se
conoce
con
el
nombre
de
agente
ajeno
(
foreing


agent
)
.
Para
los
profesionales
m√≥viles
,
lo
m√°s
probable
es
que
su
red
propia
sea
la
red
de
su


empresa
,
mientras
que
la
red
ajena
podr√≠a
ser
la
de
un
colega
al
que
est√©n
visitando
.
Un


corresponsal
(
correspondent
)
es
la
entidad
que
se
quiere
comunicar
con
el
nodo
m√≥vil
.
La


Figura
6.22
ilustra
estos
conceptos
,
as√≠
como
los
conceptos
de
direccionamiento
considera-


dos
m√°s
adelante
.
En
la
Figura
6.22
,
observe
que
los
agentes
se
muestran
como
si
estuvieran


ubicados
en
routers
(
por
ejemplo
,
como
procesos
ejecut√°ndose
en
routers
)
,
pero
tambi√©n


podr√≠an
ejecutarse
en
otros
hosts
o
servidores
de
la
red
.


6.5
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
:
PRINCIPIOS
537


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5376.5.1
Direccionamiento


Hemos
observado
anteriormente
que
,
para
que
la
movilidad
de
los
usuarios
sea
transparente


a
ojos
de
las
aplicaciones
de
red
,
es
deseable
que
los
nodos
m√≥viles
conserven
su
direcci√≥n


mientras
se
mueven
de
una
red
a
otra
.
Cuando
un
nodo
m√≥vil
reside
en
una
red
ajena
,
todo


el
tr√°fico
dirigido
a
la
direcci√≥n
permanente
de
dicho
nodo
ahora
tendr√°
que
ser
enrutado


hacia
la
red
ajena
.
¬ø
C√≥mo
puede
hacerse
esto
?
Una
opci√≥n
es
que
la
red
ajena
anuncie
a


todas
las
dem√°s
redes
que
el
nodo
m√≥vil
est√°
residiendo
ahora
en
su
red
.
Esto
podr√≠a
hacerse


mediante
el
intercambio
usual
de
informaci√≥n
de
enrutamiento
entre
dominios
y
dentro
de


los
dominios
y
requerir√≠a
pocos
cambios
en
la
infraestructura
de
enrutamiento
existente
.
La


red
ajena
podr√≠a
simplemente
anunciar
a
sus
vecinos
que
dispone
de
una
ruta
altamente


espec√≠fica
hacia
la
direcci√≥n
permanente
del
nodo
m√≥vil
(
es
decir
,
b√°sicamente
consistir√≠a


en
informar
a
otras
redes
de
que
dispone
de
la
ruta
correcta
para
enviar
datagramas
a
la


direcci√≥n
permanente
del
nodo
m√≥vil
;
v√©ase
la
Secci√≥n
4.4
)
.
Esos
vecinos
propagar√≠an


entonces
esa
informaci√≥n
de
enrutamiento
por
toda
la
red
como
parte
del
procedimiento
nor-


mal
de
actualizaci√≥n
de
la
informaci√≥n
de
enrutamiento
y
de
las
tablas
de
reenv√≠o
.
Cuando


el
nodo
m√≥vil
abandone
una
red
ajena
y
se
una
a
otra
,
la
nueva
red
ajena
anunciar√°
una


nueva
ruta
altamente
espec√≠fica
hacia
el
nodo
m√≥vil
y
la
antigua
red
ajena
retirar√°
su
infor-


maci√≥n
de
enrutamiento
relativa
a
ese
nodo
m√≥vil
.


538
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Agente
propio


Red
propia
:


128.119.40/24


Red
visitada
:


79.129.13/24


Nodo
m√≥vil


Direcci√≥n
permanente
:


128.119.40.186
Direcci√≥n
permanente
:


128.119.40.186


Agente
ajeno


Direcci√≥n
COA
:


79.129.13.2


Red
de
√°rea
extensa


Corresponsal


Figura
6.22
‚Ä¢
Elementos
iniciales
de
una
arquitectura
de
red
m√≥vil
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
538Esto
resuelve
dos
problemas
a
la
vez
,
y
lo
hace
sin
llevar
a
cabo
cambios
significativos


en
la
infraestructura
de
la
capa
de
red
.
Otras
redes
conocer√°n
la
ubicaci√≥n
del
nodo
m√≥vil
y


ser√°
f√°cil
enrutar
los
datagramas
hacia
√©l
,
ya
que
las
tablas
de
reenv√≠o
dirigir√°n
los
datagra-


mas
a
la
red
ajena
.
Sin
embargo
,
una
desventaja
significativa
es
la
de
la
escalabilidad
.
Si
la


gesti√≥n
de
la
movilidad
tuviera
que
ser
responsabilidad
de
los
routers
de
la
red
,
los
routers


tendr√≠an
que
mantener
entradas
en
sus
tablas
de
reenv√≠o
para
un
n√∫mero
potencialmente


muy
alto
de
millones
de
nodos
m√≥viles
y
actualizar
dichas
entrada
a
medida
que
los
nodos


se
movieran
.
En
los
problemas
incluidos
al
final
del
cap√≠tulo
se
exploran
otras
desventajas


adicionales
.


Un
enfoque
alternativo
(
que
adem√°s
se
ha
adoptado
en
la
pr√°ctica
)
consiste
en
trasladar


la
funcionalidad
de
movilidad
desde
el
n√∫cleo
de
la
red
hasta
la
frontera
de
la
misma
,
lo
cual


es
un
tema
recurrente
en
nuestro
estudio
de
la
arquitectura
de
Internet
.
Una
forma
natural
de


hacer
esto
es
mediante
la
red
propia
del
nodo
m√≥vil
.
De
la
misma
forma
que
los
padres
del


veintea√±ero
m√≥vil
se
encargan
de
controlar
la
ubicaci√≥n
de
su
hijo
,
el
agente
propio
situado


en
la
red
propia
del
nodo
m√≥vil
puede
controlar
en
qu√©
red
ajena
reside
el
nodo
m√≥vil
.


Obviamente
,
ser√°
necesario
que
exista
un
protocolo
entre
el
nodo
m√≥vil
(
o
un
agente
ajeno


que
represente
al
nodo
m√≥vil
)
y
el
agente
propio
para
poder
actualizar
la
ubicaci√≥n
del
nodo


m√≥vil
.


Consideremos
ahora
el
agente
ajeno
con
un
poco
m√°s
de
detalle
.
El
enfoque
concep-


tualmente
m√°s
simple
,
mostrado
en
la
Figura
6.22
,
consiste
en
ubicar
los
agentes
ajenos
en


los
 
routers
de
frontera
de
la
red
ajena
.
Un
papel
del
agente
ajeno
consiste
en
crear
la
deno-


minada
direcci√≥n
cedida
(
COA
,
care-of
address
)
para
el
nodo
m√≥vil
,
en
la
que
la
parte
de


red
de
la
COA
se
corresponde
con
la
de
la
red
ajena
.
Por
tanto
,
habr√°
dos
direcciones
aso-


ciadas
con
un
nodo
m√≥vil
,
su
direcci√≥n
permanente
(
an√°loga
a
la
direcci√≥n
del
domicilio


familiar
de
nuestro
veintea√±ero
m√≥vil
)
y
su
COA
,
a
veces
denominada
direcci√≥n
ajena


(
an√°loga
a
la
direcci√≥n
de
la
vivienda
en
la
que
est√°
residiendo
actualmente
nuestro
veintea-


√±ero
m√≥vil
)
.
 
En
el
ejemplo
de
la
Figura
6.22
,
la
direcci√≥n
permanente
del
nodo
m√≥vil
es


128.119.40.186
.
Cuando
est√°
visitando
la
red
79.129.13/24
,
el
nodo
m√≥vil
tiene
una
COA


igual
a
79.129.13.2
.
Un
segundo
papel
del
agente
ajeno
consiste
en
informar
al
agente
pro-


pio
de
que
el
nodo
m√≥vil
reside
en
su
red
(
en
la
del
agente
ajeno
)
y
tiene
la
COA
indicada
.


Veremos
enseguida
que
la
COA
se
utiliza
para
‚Äú
re-enrutar
‚Äù
datagramas
hacia
el
nodo
m√≥vil


a
trav√©s
de
su
agente
ajeno
.


Aunque
hemos
separado
la
funcionalidad
del
nodo
m√≥vil
y
del
agente
ajeno
,
merece
la


pena
indicar
que
el
nodo
m√≥vil
tambi√©n
puede
asumir
las
responsabilidades
del
agente


ajeno
.
Por
ejemplo
,
el
nodo
m√≥vil
podr√≠a
obtener
una
COA
en
la
red
ajena
(
por
ejemplo
,
uti-


lizando
un
protocolo
como
DHCP
)
e
informar
√©l
mismo
al
agente
propio
de
cu√°l
es
su
COA
.


6.5.2
Enrutamiento
hacia
un
nodo
m√≥vil


Hemos
visto
c√≥mo
un
nodo
m√≥vil
puede
obtener
una
COA
y
c√≥mo
puede
informar
a
su


agente
propio
de
dicha
direcci√≥n
.
Pero
hacer
que
el
agente
propio
conozca
la
COA
s√≥lo


resuelve
parte
del
problema
.
¬ø
C√≥mo
deber√≠an
direccionarse
los
datagramas
y
c√≥mo
deber√≠an


reenviarse
hacia
el
nodo
m√≥vil
?
Puesto
que
s√≥lo
el
agente
propio
(
y
no
los
routers
del
resto


de
la
red
)
conoce
la
ubicaci√≥n
del
nodo
m√≥vil
,
ya
no
bastar√°
con
dirigir
simplemente
un


datagrama
a
la
direcci√≥n
permanente
del
nodo
m√≥vil
y
enviarlo
hacia
la
infraestructura
de
la


capa
de
red
,
sino
que
hay
que
hacer
algo
m√°s
.
Podemos
identificar
dos
enfoques
distintos
,
a


los
que
denominaremos
enrutamiento
indirecto
y
enrutamiento
directo
.


6.5
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
:
PRINCIPIOS
539


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
539Enrutamiento
indirecto
hacia
un
nodo
m√≥vil


Consideremos
en
primer
lugar
un
corresponsal
que
desea
enviar
un
datagrama
a
un
nodo


m√≥vil
.
Con
la
t√©cnica
del
enrutamiento
indirecto
,
el
corresponsal
simplemente
direcciona


el
datagrama
con
la
direcci√≥n
permanente
del
nodo
m√≥vil
y
lo
env√≠a
a
la
red
,
completamente


ignorante
de
si
el
nodo
m√≥vil
reside
en
su
red
propia
o
est√°
visitando
una
red
ajena
;
por


tanto
,
la
movilidad
es
completamente
transparente
para
el
corresponsal
.
Dichos
datagramas


se
enrutan
primero
de
la
forma
habitual
hacia
la
red
propia
del
nodo
m√≥vil
.
Esto
se
ilustra
en


el
paso
1
de
la
Figura
6.23
.


Vo
l
v
a
m
o
s
 
a
h
o
r
a
 
n
u
e
s
t
r
a
 
a
t
e
n
c
i
√≥
n
 
h
a
c
i
a
 
e
l
 
a
g
e
n
t
e
 
p
r
o
p
i
o
.
 
A
d
e
m
√°
s
 
d
e
 
s
e
r
 
r
e
s
p
o
n
s
a
b
l
e
 
d
e


interactuar
con
un
ajeno
para
saber
en
todo
momento
la
COA
del
nodo
m√≥vil
,
el
agente
pro-


pio
tiene
otra
funci√≥n
muy
importante
.
Su
segunda
tarea
consiste
en
estar
atento
para
ver
si


llegan
datagramas
dirigidos
a
nodos
cuya
red
propia
sea
la
de
ese
agente
propio
,
pero
que


est√©n
actualmente
residiendo
en
una
red
ajena
.
El
agente
propio
intercepta
estos
datagra-


mas
y
luego
los
reenv√≠a
hacia
un
nodo
m√≥vil
siguiendo
un
proceso
de
dos
pasos
.
Primero
,


el
datagrama
es
reenviado
hacia
el
agente
ajeno
,
utilizando
la
direcci√≥n
COA
del
nodo
m√≥-


vil
(
paso
2
de
la
Figura
6.23
)
y
luego
es
reenviado
desde
el
agente
ajeno
hacia
el
nodo


m√≥vil
(
paso
3
de
la
Figura
6.23
)
.


Es
bastante
instructivo
analizar
este
re-enrutamiento
con
mayor
detalle
.
El
agente
propio


necesitar√°
direccionar
el
datagrama
utilizando
la
COA
del
nodo
m√≥vil
,
de
modo
que
la
capa


de
red
enruta
el
datagrama
hacia
la
red
ajena
.
Por
otro
lado
,
es
deseable
dejar
el
datagrama


540
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Agente


propio


Red
propia
:


128.119.40/24


Red
visitada
:


79.129.13/24


Nodo
m√≥vil


Direcci√≥n
permanente
:


128.119.40.186
Direcci√≥n
permanente
:


128.119.40.186


Agente


ajeno


Direcci√≥n


COA
:


79.129.13.2


Red
de
√°rea
extensa


Corresponsal


1


2


4


3


Figura
6.23
‚Ä¢
Enrutamiento
indirecto
a
un
nodo
m√≥vil
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
540del
corresponsal
intacto
,
ya
que
la
aplicaci√≥n
que
va
a
recibir
el
datagrama
no
debe
ser
cons-


ciente
de
que
el
datagrama
ha
sido
reenviado
a
trav√©s
del
agente
propio
.
Ambos
objetivos


pueden
satisfacerse
haciendo
que
el
agente
propio
encapsule
el
datagrama
completo
original


del
corresponsal
dentro
de
un
nuevo
datagrama
m√°s
grande
.
Este
datagrama
de
mayor


tama√±o
se
direcciona
y
se
entrega
a
la
COA
del
nodo
m√≥vil
.
El
agente
ajeno
,
que
 
‚Äú
posee
‚Äù
la


COA
,
recibir√°
y
desencapsular√°
el
datagrama
;
es
decir
,
extraer√°
el
datagrama
original
del


corresponsal
de
dentro
del
datagrama
m√°s
grande
que
lo
encapsula
y
reenviar√°
(
paso
3
de
la


Figura
6.23
)
el
datagrama
original
hacia
el
nodo
m√≥vil
.
La
Figura
6.24
muestra
un
datagrama


original
de
un
corresponsal
que
es
enviado
hacia
la
red
propia
,
un
datagrama
encapsulado


enviado
hacia
el
agente
ajeno
y
el
datagrama
original
entregado
al
nodo
m√≥vil
.
El
lector


atento
observar√°
que
la
encapsulaci√≥n
/
desencapsulaci√≥n
aqu√≠
descrita
es
id√©ntica
al
concepto


de
tunelizaci√≥n
,
explicado
en
el
Cap√≠tulo
4
en
el
contexto
de
la
multidifusi√≥n
IP
y
de
IPv6
.


Consideremos
ahora
c√≥mo
un
nodo
m√≥vil
env√≠a
datagramas
a
un
corresponsal
.
Esto
es


bastante
simple
,
ya
que
el
nodo
m√≥vil
puede
dirigir
sus
datagramas
directamente
al
corres-


ponsal
(
utilizando
su
propia
direcci√≥n
permanente
como
la
direcci√≥n
de
origen
y
la
direc-


ci√≥n
del
corresponsal
como
direcci√≥n
de
destino
)
.
Puesto
que
el
nodo
m√≥vil
conoce
la


direcci√≥n
del
corresponsal
,
no
hay
ninguna
necesidad
de
enrutar
el
datagrama
a
trav√©s
del


agente
propio
.
Esto
se
muestra
en
el
paso
4
de
la
Figura
6.23
.


Resumamos
nuestras
explicaciones
acerca
del
enrutamiento
indirecto
indicando
la


nueva
funcionalidad
requerida
en
la
capa
de
red
para
soportar
la
movilidad
.


‚Ä¢
Un
protocolo
entre
el
nodo
m√≥vil
y
el
agente
ajeno
.
El
nodo
m√≥vil
se
registrar√°
ante
el


agente
ajeno
cuando
se
conecte
a
la
red
ajena
.
De
forma
similar
,
el
nodo
m√≥vil
se
desre-


gistrar√°
ante
el
agente
ajeno
cuando
abandone
la
red
ajena
.


6.5
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
:
PRINCIPIOS
541


Agente


propio


Direcci√≥n
permanente
:


128.119.40.186
Direcci√≥n
permanente
:


128.119.40.186


Agente


ajeno


Corresponsal


dest
:
128.119.40.186


dest
:
79.129.13.2
dest
:
128.119.40.186


dest
:
128.119.40.186


Direcci√≥n
COA
:


79.129.13.2


Figura
6.24
‚Ä¢
Encapsulaci√≥n
y
desencapsulaci√≥n
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
541‚Ä¢
Un
protocolo
de
registro
entre
el
agente
ajeno
y
el
agente
propio
.
El
agente
ajeno
regis-


trar√°
la
COA
del
nodo
m√≥vil
ante
el
agente
propio
.
El
agente
ajeno
no
necesita
desre-


gistrar
expl√≠citamente
una
COA
cuando
un
nodo
m√≥vil
abandona
su
red
,
porque
el
subsi-


guiente
registro
de
una
nueva
COA
,
cuando
el
nodo
m√≥vil
se
desplace
a
otra
red
,
se


encargar√°
de
ello
.


‚Ä¢
Un
protocolo
de
encapsulaci√≥n
de
datagramas
para
el
agente
propio
.
Este
protocolo


se
encargar√°
de
la
encapsulaci√≥n
y
del
reenv√≠o
del
datagrama
original
del
corresponsal


dentro
de
un
datagrama
dirigido
a
la
COA
.


‚Ä¢
Un
protocolo
de
desencapsulaci√≥n
para
el
agente
ajeno
.
Este
protocolo
se
encargar√°
de


la
extracci√≥n
del
datagrama
original
del
corresponsal
a
partir
del
datagrama
encapsu-


lante
y
del
reenv√≠o
del
datagrama
original
al
nodo
m√≥vil
.


La
exposici√≥n
anterior
proporciona
todos
los
elementos
(
agentes
ajenos
,
el
agente
pro-


pio
y
reenv√≠o
indirecto
)
necesarios
para
que
un
nodo
m√≥vil
pueda
mantener
una
conexi√≥n


activa
mientras
se
desplaza
de
una
red
a
otra
.
Como
ejemplo
del
modo
en
que
estos
elemen-


tos
encajan
,
suponga
que
el
nodo
m√≥vil
est√°
conectado
a
la
red
ajena
A
,
que
ha
registrado


una
COA
en
la
red
A
ante
su
agente
propio
y
que
est√°
recibiendo
datagramas
que
se
est√°n


enrutando
indirectamente
a
trav√©s
de
su
agente
propio
.
El
nodo
m√≥vil
se
desplaza
ahora
a
la


red
ajena
B
y
se
registra
ante
el
agente
ajeno
de
esa
red
,
el
cual
informa
al
agente
propio
de


la
nueva
COA
del
nodo
m√≥vil
.
A
partir
de
ese
momento
,
el
agente
propio
re-enrutar√°
los


datagramas
hacia
la
red
ajena
B.
En
lo
que
a
un
corresponsal
respecta
,
la
movilidad
es
trans-


parente
,
ya
que
los
datagramas
se
enrutan
a
trav√©s
del
mismo
agente
propio
,
tanto
antes


como
despu√©s
de
que
el
nodo
m√≥vil
se
haya
desplazado
.
En
lo
que
respecta
al
agente
propio
,


no
existe
ninguna
interrupci√≥n
en
el
flujo
de
datagramas
,
ya
que
los
datagramas
que
vayan


llegando
se
reenv√≠an
primero
hacia
la
red
ajena
A
y
,
despu√©s
del
cambio
de
COA
,
se
reen-


v√≠an
a
la
red
ajena
B.
¬ø
Pero
qu√©
pasa
con
el
nodo
m√≥vil
?
¬ø
Experimentar√°
una
interrupci√≥n


en
el
flujo
de
datagramas
mientras
se
desplaza
de
una
red
a
la
otra
?
Mientras
que
el
tiempo


que
transcurre
entre
la
desconexi√≥n
del
nodo
m√≥vil
de
la
red
A
(
en
cuyo
momento
ya
no


puede
recibir
datagramas
a
trav√©s
de
A
)
y
la
conexi√≥n
a
la
red
B
(
en
cuyo
momento
regis-


trar√°
una
nueva
COA
ante
su
agente
propio
)
sea
peque√±o
,
s√≥lo
se
perder√°n
unos
pocos
data-


gramas
.
Recuerde
del
Cap√≠tulo
3
que
las
conexiones
terminal
a
terminal
pueden
sufrir


p√©rdidas
de
datagramas
debidas
a
la
congesti√≥n
de
la
red
.
Por
tanto
,
la
p√©rdida
ocasional
de


datagramas
en
una
conexi√≥n
cuando
un
nodo
se
desplaza
de
una
red
a
otra
no
constituye
en


modo
alguno
un
problema
catastr√≥fico
.
Si
hiciera
falta
una
comunicaci√≥n
libre
de
p√©rdidas
,


los
mecanismos
de
la
capa
superior
podr√≠an
recuperarse
de
la
p√©rdida
de
datagramas
,
inde-


pendientemente
de
si
dicha
p√©rdida
es
el
resultado
de
una
congesti√≥n
en
la
red
o
de
la
movi-


lidad
del
usuario
.


En
el
est√°ndar
de
IP
m√≥vil
[
RFC
3344
]
,
del
que
hablaremos
en
la
Secci√≥n
6.6
,
se
utiliza


una
t√©cnica
de
enrutamiento
indirecto
.


Enrutamiento
directo
hacia
un
nodo
m√≥vil


La
t√©cnica
basada
en
el
enrutamiento
indirecto
ilustrada
en
la
Figura
6.23
se
ve
aquejada
de


una
ineficiencia
conocida
como
el
problema
del
enrutamiento
triangular
:
los
datagramas


dirigidos
al
nodo
m√≥vil
deben
enrutarse
en
primer
lugar
hacia
el
agente
propio
y
luego
hacia


la
red
ajena
,
a√∫n
cuando
exista
una
ruta
mucho
m√°s
eficiente
entre
el
corresponsal
y
el
nodo


m√≥vil
.
En
el
caso
peor
,
imagine
un
usuario
m√≥vil
que
est√°
visitando
la
red
ajena
de
un


colega
.
Los
dos
est√°n
sentados
uno
al
lado
del
otro
e
intercambiando
datos
a
trav√©s
de
la
red
.


542
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
542Los
datagramas
del
corresponsal
(
en
este
caso
,
el
colega
del
visitante
)
se
enrutar√°n
hacia
el


agente
propio
del
usuario
m√≥vil
y
luego
volver√°n
a
la
red
ajena
.


La
t√©cnica
de
enrutamiento
directo
elimina
la
ineficiencia
del
enrutamiento
triangular
,


pero
el
precio
que
hay
que
pagar
es
una
mayor
complejidad
.
Con
la
t√©cnica
del
enrutamiento


directo
,
un
agente
corresponsal
situado
en
la
red
del
corresponsal
determina
primero
la


COA
del
nodo
m√≥vil
.
Esto
puede
conseguirse
haciendo
que
el
agente
corresponsal
consulte


al
agente
propio
,
suponiendo
que
(
como
en
el
caso
del
enrutamiento
indirecto
)
el
nodo
m√≥vil


tiene
registrado
un
valor
actualizado
de
su
COA
ante
el
agente
propio
.
Tambi√©n
es
posible


que
el
propio
corresponsal
lleve
a
cabo
la
funci√≥n
del
agente
corresponsal
,
al
igual
que
el


nodo
m√≥vil
puede
realizar
la
funci√≥n
del
agente
ajeno
.
Esto
se
muestra
en
los
pasos
1
y
2
de


la
Figura
6.25
.
Entonces
,
el
agente
corresponsal
tuneliza
los
datagramas
(
pasos
3
y
4
de
la


Figura
6.25
)
directamente
hacia
la
COA
del
nodo
m√≥vil
,
de
forma
an√°loga
a
la
tunelizaci√≥n


que
lleva
a
cabo
el
agente
propio
.
 

Aunque
el
enrutamiento
directo
resuelve
el
problema
del
enrutamiento
triangular
,
plan-


tea
dos
problemas
adicionales
de
importancia
:


‚Ä¢H
a
c
e
 
f
a
l
t
a
 
u
n
 
protocolo
de
localizaci√≥n
de
usuarios
m√≥viles
para
que
el
agente
corres-


ponsal
consulte
al
agente
propio
con
el
fin
de
obtener
la
COA
del
nodo
m√≥vil
(
pasos
1
y


2
de
la
Figura
6.25
)
.


6.5
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
:
PRINCIPIOS
543


Agente


propio


Red
propia
:


128.119.40/24


Red
visitada
:


79.129.13/24


Nodo
m√≥vil


Direcci√≥n
permanente
:


128.119.40.186


Clave
:


Direcci√≥n
permanente
:


128.119.40.186


Agente


ajeno


Direcci√≥n
COA
:


79.129.13.2


Red
de
√°rea


extensa


Corresponsal


Mensajes
de
control


Agente


corresponsal


1


2


4


3


Flujo
de
datos


Figura
6.25
‚Ä¢
Enrutamiento
directo
a
un
usuario
m√≥vil
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
543‚Ä¢C
u
a
n
d
o
 
e
l
 
n
o
d
o
 
m
√≥
v
i
l
 
s
e
 
d
e
s
p
l
a
z
a
 
d
e
 
u
n
a
 
r
e
d
 
a
j
e
n
a
 
a
 
o
t
r
a
,
 
¬ø
c
√≥
m
o
 
p
o
d
r
e
m
o
s
 
e
n
t
o
n
c
e
s


reenviar
los
datos
hacia
la
nueva
red
ajena
?
En
el
caso
del
enrutamiento
indirecto
,
este


problema
se
resolv√≠a
f√°cilmente
actualizando
la
COA
mantenida
por
el
agente
propio
.
Sin


embargo
,
con
el
enrutamiento
directo
,
el
agente
corresponsal
s√≥lo
consulta
la
COA
una


vez
al
agente
propio
,
al
comienzo
de
la
sesi√≥n
.
Por
tanto
,
la
actualizaci√≥n
de
la
COA
en
el


agente
propio
,
aunque
sigue
siendo
necesaria
,
no
ser√°
suficiente
para
resolver
el
problema


de
c√≥mo
enrutar
los
datos
hacia
la
nueva
red
ajena
del
nodo
m√≥vil
.


Una
soluci√≥n
ser√≠a
crear
un
nuevo
protocolo
para
notificar
al
corresponsal
el
cambio
de


la
COA
.
Otra
soluci√≥n
alternativa
,
que
veremos
adoptada
en
la
pr√°ctica
en
las
redes
GSM
,


funciona
de
la
forma
siguiente
:
suponga
que
los
datos
est√°n
siendo
reenviados
actualmente


hacia
el
nodo
m√≥vil
en
la
red
ajena
en
la
que
dicho
nodo
estaba
ubicado
en
el
momento
de


comenzar
la
sesi√≥n
(
paso
1
de
la
Figura
6.26
)
.
Identificaremos
al
agente
ajeno
de
dicha
red


ajena
en
la
que
el
nodo
m√≥vil
se
encontraba
inicialmente
con
el
nombre
de
agente
ajeno


ancla
.
Cuando
el
nodo
m√≥vil
se
desplaza
a
una
nueva
red
ajena
(
paso
2
de
la
Figura
6.26
)
se


registra
ante
el
nuevo
agente
ajeno
(
paso
3
)
y
el
nuevo
agente
ajeno
proporciona
al
agente


ajeno
ancla
la
nueva
COA
del
nodo
m√≥vil
(
paso
4
)
.
Cuando
el
agente
ajeno
ancla
recibe
un


datagrama
encapsulado
para
un
nodo
m√≥vil
que
ya
ha
salido
de
su
red
,
puede
entonces
reen-


capsular
el
datagrama
y
reenviarlo
al
nodo
m√≥vil
(
paso
5
)
utilizando
la
nueva
COA
.
Si
el


nodo
m√≥vil
se
desplaza
posteriormente
otra
vez
a
otra
nueva
red
ajena
,
el
agente
ajeno
de


esa
nueva
red
visitada
contactar√°
con
el
agente
ajeno
ancla
para
establecer
el
reenv√≠o
hacia


esta
nueva
red
ajena
.


544
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Agente


propio


Red
propia
:
Red
ajena


visitada
al
inicio


de
la
sesi√≥n
:


Nueva
red


ajena
:


Agente


ajeno


ancla


Nuevo
agente
ajeno


Red
de
√°rea


extensa


Corresponsal


Agente


corresponsal


1


4


2


3


5


Figura
6.26
‚Ä¢
Transferencia
de
m√≥viles
entre
redes
con
enrutamiento


directo
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5446.6
IP
m√≥vil


Los
protocolos
y
la
arquitectura
de
Internet
necesarios
para
dar
soporte
a
la
movilidad
,


colectivamente
conocidos
con
el
nombre
de
IP
m√≥vil
,
est√°n
definidos
principalmente
en


RFC
3344
para
IPv4
.
IP
m√≥vil
es
un
est√°ndar
flexible
,
que
soporta
muchos
modos
distintos


de
operaci√≥n
(
por
ejemplo
,
operaci√≥n
con
o
sin
un
agente
ajeno
)
,
m√∫ltiples
formas
de
que


los
agentes
y
los
nodos
m√≥viles
se
descubran
entre
s√≠
,
utilizaci√≥n
de
direcciones
COA
√∫nicas


o
m√∫ltiples
y
diversas
formas
de
encapsulaci√≥n
.
Como
tal
,
IP
m√≥vil
es
un
est√°ndar
complejo


y
har√≠a
falta
un
libro
completo
para
describirlo
en
detalle
;
de
hecho
,
uno
de
tales
libros
es


[
Perkins
1998b
]
.
Nuestro
objetivo
aqu√≠
,
mucho
m√°s
modesto
,
es
proporcionar
una
panor√°-


mica
de
los
aspectos
m√°s
importantes
de
IP
m√≥vil
e
ilustrar
su
uso
en
unos
cuantos
escena-


rios
comunes
.


La
arquitectura
de
IP
m√≥vil
contiene
muchos
de
los
elementos
que
hemos
presentado


anteriormente
,
incluyendo
los
conceptos
de
agente
propio
,
agente
ajeno
,
direcciones
COA
y


encapsulaci√≥n
/
desencapsulaci√≥n
.
El
est√°ndar
actual
[
RFC
3344
]
especifica
el
uso
del
enru-


tamiento
indirecto
hacia
el
nodo
m√≥vil
.


El
est√°ndar
IP
m√≥vil
consta
de
tres
elementos
principales
:


‚Ä¢
Descubrimiento
de
agentes
.
IP
m√≥vil
define
los
protocolos
utilizados
por
un
agente
pro-


pio
o
ajeno
para
anunciar
sus
servicios
a
los
nodos
m√≥viles
,
as√≠
como
protocolos
para
que


los
nodos
m√≥viles
soliciten
los
servicios
de
un
agente
ajeno
o
propio
.


‚Ä¢
Registro
ante
el
agente
propio
.
IP
m√≥vil
define
los
protocolos
utilizados
por
el
nodo


m√≥vil
y
/
o
el
agente
ajeno
para
registrar
y
desregistrar
direcciones
COA
ante
el
agente


propio
de
un
nodo
m√≥vil
.


‚Ä¢
Enrutamiento
indirecto
de
los
datagramas
.
El
est√°ndar
tambi√©n
define
la
forma
en
que
el


agente
propio
reenv√≠a
los
datagramas
hacia
los
nodos
m√≥viles
,
incluyendo
reglas
para
el


reenv√≠o
de
datagramas
,
reglas
para
la
gesti√≥n
de
las
condiciones
de
error
y
diversas
for-


mas
de
encapsulaci√≥n
[
RFC
2003
,
RFC
2004
]
.


Las
consideraciones
de
seguridad
tienen
una
gran
importancia
a
lo
largo
de
todo
el


est√°ndar
de
IP
m√≥vil
.
Por
ejemplo
,
es
clara
la
necesidad
de
que
un
nodo
m√≥vil
se
autenti-


que
para
garantizar
que
los
usuarios
maliciosos
no
puedan
registrar
una
direcci√≥n
COA


falsa
ante
un
agente
propio
que
har√≠a
que
todos
los
datagramas
destinados
a
una
direcci√≥n


IP
fueran
redirigidos
hacia
el
usuario
malicioso
.
En
IP
m√≥vil
la
seguridad
se
consigue
utili-


zando
muchos
de
los
mecanismos
que
examinaremos
en
el
Cap√≠tulo
8
,
por
lo
que
en
las


explicaciones
que
siguen
no
vamos
a
tocar
los
problemas
de
seguridad
.


Descubrimiento
de
agentes


Un
nodo
de
IP
m√≥vil
que
llegue
a
una
nueva
red
,
independientemente
de
si
est√°
conectando


a
una
red
ajena
o
volviendo
a
la
suya
propia
,
debe
averiguar
la
identidad
del
agente
ajeno
o


propio
correspondiente
.
De
hecho
,
es
el
descubrimiento
de
un
nuevo
agente
ajeno
,
con
una


nueva
direcci√≥n
de
red
,
el
que
permite
a
la
capa
de
red
del
nodo
m√≥vil
averiguar
que
acaba


de
entrar
en
una
nueva
red
ajena
.
Este
proceso
se
conoce
con
el
nombre
de
descubrimiento


de
agentes
.
El
descubrimiento
de
agentes
puede
realizarse
de
una
de
dos
formas
:
mediante


los
anuncios
de
los
agentes
o
mediante
las
solicitudes
de
agente
.


6.6
‚Ä¢
IP
M√ìVIL
545


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
545Con
el
anuncio
de
agente
,
cada
agente
ajeno
o
propio
anuncia
sus
servicios
,
utilizando


una
extensi√≥n
del
protocolo
existente
de
descubrimiento
de
router
[
RFC
1256
]
.
El
agente


difunde
peri√≥dicamente
un
mensaje
ICMP
con
un
campo
de
tipo
de
valor
9
(
descubrimiento


de
router
)
a
trav√©s
de
todos
los
enlaces
con
los
que
est√©
conectado
.
El
mensaje
de
descubri-


miento
de
router
contiene
la
direcci√≥n
IP
del
router
(
es
decir
,
el
agente
)
,
permitiendo
as√≠
que


los
nodos
m√≥viles
conozcan
la
direcci√≥n
IP
del
agente
.
El
mensaje
de
descubrimiento
de


router
tambi√©n
contiene
una
extensi√≥n
de
anuncio
de
agente
de
movilidad
que
contiene


informaci√≥n
adicional
que
el
nodo
m√≥vil
necesita
.
Entre
los
campos
m√°s
importantes
de
esa


extensi√≥n
se
encuentran
los
siguientes
:


‚Ä¢
Bit
de
agente
propio
(
H
)
.
Indica
que
el
agente
es
un
agente
propio
para
la
red
en
la
que


reside
.


‚Ä¢
Bit
de
agente
ajeno
(
F
)
.
Indica
que
el
agente
es
un
agente
ajeno
para
la
red
en
la
que


reside
.


‚Ä¢
Bit
de
registro
requerido
(
R
)
.
Indica
que
los
usuarios
m√≥viles
en
esta
red
deber√°n
regis-


trarse
ante
un
agente
ajeno
.
En
particular
,
un
usuario
m√≥vil
no
podr√°
obtener
una
direc-


ci√≥n
COA
en
la
red
ajena
(
por
ejemplo
,
utilizando
DHCP
)
y
asumir
√©l
mismo
la


funcionalidad
del
agente
ajeno
sin
antes
registrarse
ante
el
agente
ajeno
.


‚Ä¢
Bits
de
encapsulaci√≥n
M
,
G.
Indican
si
se
utilizar√°
alg√∫n
tipo
de
encapsulaci√≥n
distinta


de
la
encapsulaci√≥n
IP-en-IP
.


‚Ä¢
Campos
de
direcci√≥n
COA
.
Es
una
lista
de
una
o
m√°s
direcciones
COA
proporcionada


por
el
agente
ajeno
.
En
el
ejemplo
que
indicamos
m√°s
adelante
,
la
direcci√≥n
COA
estar√°


asociada
con
el
agente
ajeno
,
que
recibir√°
los
datagramas
destinados
a
esa
COA
y
luego


los
reenviar√°
al
nodo
m√≥vil
apropiado
.
El
usuario
m√≥vil
seleccionar√°
una
de
estas
direc-


ciones
como
direcci√≥n
COA
a
la
hora
de
registrarse
ante
su
agente
propio
.


La
Figura
6.27
ilustra
algunos
de
los
campos
clave
contenidos
en
el
mensaje
de
anuncio
de


agente
.


Con
la
solicitud
de
agente
,
un
nodo
m√≥vil
que
quiera
averiguar
informaci√≥n
acerca
de


los
agentes
sin
esperar
a
recibir
un
anuncio
de
agente
puede
difundir
un
mensaje
de
solicitud


de
agente
,
que
es
simplemente
un
mensaje
ICMP
con
un
campo
de
tipo
que
contiene
el


valor
10
.
Un
agente
que
reciba
la
solicitud
enviar√°
directamente
al
nodo
m√≥vil
un
anuncio


de
agente
,
mediante
un
mensaje
de
unidifusi√≥n
,
pudiendo
entonces
el
nodo
m√≥vil
proceder


como
si
hubiera
recibido
un
anuncio
no
solicitado
.


Registro
ante
el
agente
propio


Una
vez
que
un
nodo
IP
m√≥vil
ha
recibido
una
direcci√≥n
COA
,
debe
registrar
dicha
direc-


ci√≥n
ante
su
agente
propio
.
Esto
puede
hacerse
a
trav√©s
del
agente
ajeno
(
que
se
encargar√°


de
registrar
la
COA
ante
el
agente
propio
)
o
lo
puede
hacer
tambi√©n
directamente
el
propio


nodo
de
IP
m√≥vil
.
Vamos
a
analizar
el
primero
de
los
casos
,
que
consta
de
cuatro
pasos
:


1
.
Despu√©s
de
recibir
el
anuncio
de
un
agente
ajeno
,
el
nodo
m√≥vil
env√≠a
un
mensaje
de


registro
de
IP
m√≥vil
a
ese
agente
ajeno
.
El
mensaje
de
registro
se
transporta
dentro
de


un
datagrama
UDP
y
se
env√≠a
al
puerto
434
.
El
mensaje
de
registro
incluye
una
direc-


ci√≥n
COA
anunciada
por
el
agente
ajeno
,
adem√°s
de
la
direcci√≥n
del
agente
propio


(
HA
)
,
la
direcci√≥n
permanente
del
nodo
m√≥vil
(
MA
)
,
el
tiempo
de
vida
solicitado
para


546
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
546el
registro
y
un
identificador
de
registro
de
64
bits
.
El
tiempo
de
vida
solicitado
para
el


registro
es
el
n√∫mero
de
segundos
durante
los
cuales
el
registro
tendr√°
validez
.
Si
el


registro
no
se
renueva
ante
el
agente
propio
dentro
de
ese
tiempo
de
vida
especificado


el
registro
quedar√°
invalidado
.
El
identificador
de
registro
act√∫a
como
un
n√∫mero
de


secuencia
y
sirve
para
establecer
la
correspondencia
entre
una
respuesta
de
registro
reci-


bida
y
una
solicitud
de
registro
,
como
se
indica
m√°s
adelante
.


2
.
El
agente
ajeno
recibe
el
mensaje
de
registro
y
anota
la
direcci√≥n
IP
permanente
del


nodo
m√≥vil
.
El
agente
ajeno
ahora
sabe
que
debe
buscar
datagramas
que
contengan
un


datagrama
encapsulado
cuya
direcci√≥n
de
destino
coincida
con
esa
direcci√≥n
perma-


nente
del
nodo
m√≥vil
.
El
agente
ajeno
env√≠a
a
continuaci√≥n
un
mensaje
de
registro
de


IP
m√≥vil
(
de
nuevo
dentro
de
un
datagrama
UDP
)
al
puerto
434
del
agente
propio
.
El


mensaje
contiene
las
direcciones
COA
,
HA
y
MA
,
el
formato
de
encapsulaci√≥n
solici-


tado
,
el
tiempo
de
vida
de
registro
solicitado
y
el
identificador
de
registro
.


3
.
El
agente
propio
recibe
la
solicitud
de
registro
y
comprueba
la
autenticidad
y
la
correc-


ci√≥n
de
la
misma
.
El
agente
propio
establece
una
asociaci√≥n
entre
la
direcci√≥n
IP
per-


manente
del
nodo
m√≥vil
y
la
direcci√≥n
COA
.
De
este
modo
,
en
el
futuro
,
los
datagramas


que
el
agente
propio
reciba
y
que
est√©n
dirigidos
al
nodo
m√≥vil
ser√°n
encapsulados
y


tunelizados
hacia
la
direcci√≥n
COA
.
El
agente
propio
env√≠a
una
respuesta
de
registro
de


IP
m√≥vil
que
contiene
las
direcciones
HA
y
MA
,
el
tiempo
de
vida
real
del
registro
y
el


identificador
de
registro
correspondiente
a
la
solicitud
que
se
est√©
satisfaciendo
con
esta


respuesta
.


4
.
El
agente
ajeno
recibe
la
respuesta
de
registro
y
a
continuaci√≥n
la
reenv√≠a
hacia
el
nodo


m√≥vil
.
 

6.6
‚Ä¢
IP
M√ìVIL
547


Tipo
=
9
C√≥digo
=
0


Tipo
=
16
Longitud
N√∫mero
de
secuencia


Tiempo
de
vida
del
registro
ReservadoBits


RBHFMGrT


Suma
de
comprobaci√≥n


Campos


ICMP
est√°ndar


0
8
16
24


Direcci√≥n
del
router


0
o
m√°s
direcciones
COA
Extensi√≥n
de


anuncio
de


agente
de


movilidad


Figura
6.27
‚Ä¢
Mensaje
de
descubrimiento
de
router
ICMP
con
la
extensi√≥n
de


anuncio
de
agente
de
movilidad
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
547Llegados
a
este
punto
,
el
proceso
de
registro
estar√°
terminado
y
el
nodo
m√≥vil
podr√°


recibir
los
datagramas
enviados
hacia
su
direcci√≥n
permanente
.
La
Figura
6.28
ilustra
estos


pasos
.
Observe
que
el
agente
propio
especifica
un
tiempo
de
vida
m√°s
peque√±o
que
el


tiempo
de
vida
solicitado
por
el
nodo
m√≥vil
.


Un
agente
ajeno
no
necesita
desregistrar
expl√≠citamente
una
direcci√≥n
COA
cuando
un


nodo
m√≥vil
abandone
su
red
.
Ese
proceso
de
cancelaci√≥n
de
la
direcci√≥n
tendr√°
lugar
auto-


m√°ticamente
cuando
el
nodo
m√≥vil
se
desplace
a
una
red
nueva
(
independientemente
de
si


es
otra
red
ajena
o
si
se
trata
de
su
red
propia
)
y
registre
una
nueva
direcci√≥n
COA
.


El
est√°ndar
de
IP
m√≥vil
permite
muchas
capacidades
y
escenarios
adicionales
a
los
que


hemos
descrito
.
El
lector
interesado
puede
consultar
[
Perkins
1998b
;
RFC
3344
]
.


548
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Agente
propio


HA
:
128.119.40.7


Agente
m√≥vil


MA
:
128.119.40.186


Red
visitada
:


79.129.13/24


Anuncio
agente
ICMP


COA
:
79.129.13.2


.
.
.


COA
:
79.129.13.2


HA:128.119.40.7


MA
:
128.119.40.186


Tiempo
de
vida
:
9999


identificador
:
714


.
.
.


Solicitud
de
registro


COA
:
79.129.13.2


HA:128.119.40.7


MA
:
128.119.40.186


Tiempo
de
vida
:
9999


identificador
:
714


formato
de
encapsulaci√≥n


.
.
.


Solicitud
de
registro


Tiempo
Tiempo
Tiempo


HA
:
128.119.40.7


MA
:
128.119.40.186


Tiempo
de
vida
:
4999


identificaci√≥n
:
714


formato
de
encapsulaci√≥n


.
.
.


Respuesta
de
registro


HA
:
128.119.40.7


MA
:
128.119.40.186


Tiempo
de
vida
:
4999


identificador
:
714


.
.
.


Respuesta
de
registro


Agente
ajeno


COA
:
79.129.13.2


Figura
6.28
‚Ä¢
Anuncio
de
agente
y
registro
de
IP
m√≥vil
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5486.7
Gesti√≥n
de
la
movilidad
en
redes
celulares


Habiendo
examinado
c√≥mo
se
gestiona
la
movilidad
en
las
redes
IP
,
volvamos
ahora
nuestra


atenci√≥n
a
otras
redes
que
tienen
una
historia
mucho
m√°s
dilatada
de
soporte
de
la
movili-


dad
:
las
redes
de
telefon√≠a
celular
.
Mientras
que
en
la
Secci√≥n
6.4
nos
hemos
centrado
en
el


enlace
inal√°mbrico
del
primer
salto
dentro
de
las
redes
celulares
,
aqu√≠
vamos
a
centrarnos
en


la
movilidad
,
utilizando
como
caso
de
estudio
la
arquitectura
de
las
redes
celulares
GSM


[
Goodman
1997
;
Mouly
1992
;
Scourias
1997
;
Kaaranen
2001
;
Korhonen
2003
;
Turner


2009
]
,
dado
que
se
trata
de
una
tecnolog√≠a
madura
y
de
amplia
implantaci√≥n
.
Como
en
el


caso
de
IP
m√≥vil
,
veremos
que
la
arquitectura
de
las
redes
GSM
integra
varios
de
los
princi-


pios
fundamentales
que
hemos
identificado
en
la
Secci√≥n
6.5
.


Al
igual
que
IP
m√≥vil
,
GSM
adopta
una
t√©cnica
basada
en
el
enrutamiento
indirecto


(
v√©ase
la
Secci√≥n
6.5.2
)
,
enrutando
primero
la
llamada
del
corresponsal
hacia
la
red
propia


del
usuario
m√≥vil
y
de
all√≠
a
la
red
visitada
.
En
terminolog√≠a
GSM
,
la
red
propia
del
usuario


m√≥vil
se
denomina
red
m√≥vil
terrestre
p√∫blica
propia
(
home
PLMN
,
home
Public
Land


Mobile
Network
)
.
Dado
que
el
acr√≥nimo
PLMN
resulta
un
tanto
complicado
de
pronunciar


y
dado
que
tratamos
de
evitar
una
sopa
de
letras
de
acr√≥nimos
,
en
lo
sucesivo
nos
referire-


mos
a
la
PLMN
propia
de
GSM
simplemente
con
el
nombre
de
red
propia
.
La
red
propia
es


el
proveedor
de
telefon√≠a
celular
con
el
que
est√°
abonado
el
usuario
m√≥vil
(
es
decir
,
el
pro-


veedor
que
factura
al
usuario
por
los
servicios
mensuales
de
telefon√≠a
celular
)
.
La
PLMN


visitada
,
a
la
que
denominaremos
sencillamente
red
visitada
,
es
la
red
en
la
que
reside


actualmente
el
usuario
m√≥vil
.


Como
en
el
caso
de
IP
m√≥vil
,
las
responsabilidades
de
las
redes
propia
y
visitada
son


bastante
distintas
.


‚Ä¢L
a
 
r
e
d
 
p
r
o
p
i
a
 
m
a
n
t
i
e
n
e
 
u
n
a
 
b
a
s
e
 
d
e
 
d
a
t
o
s
 
q
u
e
 
s
e
 
c
o
n
o
c
e
 
c
o
n
 
e
l
 
n
o
m
b
r
e
 
d
e
 
Registro
de


ubicaciones
propias
(
HLR
,
Home
Location
Register
)
,
que
contiene
el
n√∫mero
de
tel√©-


fono
celular
permanente
y
la
informaci√≥n
del
perfil
de
abonado
para
cada
uno
de
sus
abo-


nados
.
Es
importante
resaltar
que
la
base
de
datos
HLR
tambi√©n
contiene
informaci√≥n


acerca
de
las
ubicaciones
actuales
de
estos
abonados
.
Es
decir
,
si
un
usuario
m√≥vil
est√°


actualmente
en
situaci√≥n
de
itinerancia
(
roaming
)
dentro
de
la
red
celular
de
otro
provee-


dor
,
la
 
HLR
contendr√°
suficiente
informaci√≥n
como
para
obtener
(
a
trav√©s
de
un
proceso


que
vamos
a
describir
en
breve
)
una
direcci√≥n
,
dentro
de
la
red
visitada
,
hacia
la
que


enrutar
las
llamadas
dirigidas
al
usuario
m√≥vil
.
Como
veremos
,
un
conmutador
especial


dentro
de
la
red
propia
,
conocido
como
Centro
de
conmutaci√≥n
pasarela
para
servi-


cios
m√≥viles
(
GMSC
,
Gateway
Mobile
services
Switching
Center
)
es
contactado
por
el


corresponsal
cada
vez
que
realiza
una
llamada
a
un
usuario
m√≥vil
.
De
nuevo
,
para
tratar


de
evitar
el
uso
excesivo
de
acr√≥nimos
,
en
lo
sucesivo
nos
vamos
a
referir
al
GMSC
con


el
t√©rmino
m√°s
descriptivo
de
MSC
propio
.


‚Ä¢L
a
 
r
e
d
 
v
i
s
i
t
a
d
a
 
m
a
n
t
i
e
n
e
 
u
n
a
 
b
a
s
e
 
d
e
 
d
a
t
o
s
 
c
o
n
o
c
i
d
a
 
c
o
n
 
e
l
 
n
o
m
b
r
e
 
d
e
 
Registro
de
ubi-


caci√≥n
de
visitantes
(
VLR
,
Visitor
Location
Register
)
.
La
base
de
datos
VLR
contiene


una
entrada
para
cada
usuario
m√≥vil
que
se
encuentra
actualmente
en
la
parte
de
la
red
a


la
que
da
servicio
VLR
.
Las
entradas
de
VLR
aparecen
y
desaparecen
,
por
tanto
,
a


medida
que
los
usuarios
m√≥viles
entran
y
salen
de
la
red
.
La
base
de
datos
VLR
normal-


mente
est√°
co-ubicada
con
el
centro
de
conmutaci√≥n
m√≥vil
(
MSC
)
que
coordina
el
esta-


blecimiento
de
llamadas
hacia
y
desde
la
red
visitada
.


6.7
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
EN
REDES
CELULARES
549


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
549En
la
pr√°ctica
,
la
red
celular
de
un
proveedor
sirve
como
red
propia
para
sus
abonados
y


como
red
visitada
para
los
usuarios
m√≥viles
que
est√©n
abonados
a
un
proveedor
diferente
de


telefon√≠a
celular
.


6.7.1
Enrutamiento
de
llamadas
hacia
un
usuario
m√≥vil


Ahora
podemos
describir
c√≥mo
se
realiza
una
llamada
a
un
usuario
m√≥vil
GSM
que
se


encuentra
en
una
red
ajena
.
A
continuaci√≥n
proporcionamos
un
ejemplo
simple
;
el
lector
inte-


resado
puede
encontrar
otros
escenarios
m√°s
complejos
en
[
Mouly
1992
]
.
Los
pasos
,
ilustra-


dos
en
la
Figura
6.29
,
son
los
siguientes
:


1
.
El
corresponsal
marca
el
n√∫mero
telef√≥nico
del
usuario
m√≥vil
.
Este
n√∫mero
no
hace


referencia
por
s√≠
mismo
a
ninguna
l√≠nea
telef√≥nica
o
ubicaci√≥n
concreta
(
despu√©s
de


todo
,
el
n√∫mero
telef√≥nico
es
fijo
,
mientras
que
el
usuario
es
m√≥vil
)
.
Los
primeros
d√≠gi-


tos
del
n√∫mero
son
suficientes
para
identificar
globalmente
la
red
propia
a
la
que
el


m√≥vil
pertenece
.
La
llamada
ser√°
enrutada
desde
el
corresponsal
,
a
trav√©s
de
la
red
tele-


f√≥nica
conmutada
p√∫blica
(
PSTN
,
Public
Switched
Telephone
Network
)
,
hasta
el
MSC


propio
de
la
red
propia
del
m√≥vil
.
√âste
es
el
primer
tramo
de
la
llamada
.


2
.
El
MSC
propio
recibe
la
llamada
e
interroga
a
HLR
para
determinar
la
ubicaci√≥n
del


usuario
m√≥vil
.
En
el
caso
m√°s
simple
,
HLR
devuelve
el
N√∫mero
de
itinerancia
de
la


estaci√≥n
m√≥vil
(
MSRN
,
Mobile
Station
Roaming
Number
)
,
al
que
en
lo
sucesivo


denominaremos
simplemente
n√∫mero
de
itinerancia
.
Observe
que
este
n√∫mero
es
dife-


rente
del
n√∫mero
telef√≥nico
permanente
del
m√≥vil
que
est√°
asociado
con
la
red
propia


del
m√≥vil
.
El
n√∫mero
de
itinerancia
es
ef√≠mero
:
es
asignado
tmporalmente
al
m√≥vil


cuando
entra
dentro
de
una
red
visitada
.
El
n√∫mero
de
itinerancia
juega
un
papel
similar


al
de
la
direcci√≥n
COA
en
IP
m√≥vil
y
,
al
igual
que
la
direcci√≥n
COA
,
es
invisible
para
el


corresponsal
y
para
el
m√≥vil
.
Si
el
registro
HLR
no
tiene
el
n√∫mero
de
itinerancia
,


devuelve
la
direcci√≥n
del
VLR
en
la
red
visitada
.
En
este
caso
(
no
mostrado
en
la
Figura


6.29
)
,
el
MSC
propio
necesitar√°
consultar
a
ese
VLR
para
obtener
el
n√∫mero
de
itine-


rancia
del
nodo
m√≥vil
.
Pero
,
¬ø
c√≥mo
obtiene
el
HLR
el
n√∫mero
de
itinerancia
o
la
direc-


ci√≥n
del
VLR
?
¬ø
Qu√©
sucede
con
estos
valores
cuando
el
usuario
m√≥vil
se
desplaza
a


otra
red
visitada
?
Analizaremos
estas
importantes
cuestiones
enseguida
.


3
.
Conocido
el
n√∫mero
de
itinerancia
,
el
MSC
propio
establece
el
segundo
tramo
de
la
lla-


mada
a
trav√©s
de
la
red
hasta
el
MSC
de
la
red
visitada
.
Con
ello
,
la
llamada
se
habr√°


completado
,
produci√©ndose
el
enrutamiento
desde
el
corresponsal
hasta
el
MSC
propio
,


de
√©ste
al
MSC
visitado
y
de
ah√≠
a
la
estaci√≥n
base
que
da
servicio
al
usuario
m√≥vil
.


Una
cuesti√≥n
no
resuelta
en
el
paso
2
es
c√≥mo
el
HLR
obtiene
la
informaci√≥n
acerca


de
la
ubicaci√≥n
del
usuario
m√≥vil
.
Cuando
se
enciende
un
tel√©fono
m√≥vil
o
√©ste
entra
en


una
parte
de
una
red
visitada
que
est√°
cubierta
por
un
nuevo
VLR
,
el
m√≥vil
debe
registrarse


ante
la
red
visitada
.
Esto
se
realiza
intercambiando
mensajes
de
se√±alizaci√≥n
entre
el
m√≥vil


y
el
VLR
.
El
VLR
visitado
,
a
su
vez
,
env√≠a
un
mensaje
de
solicitud
de
actualizaci√≥n
de
la


ubicaci√≥n
al
HLR
del
m√≥vil
.
Este
mensaje
informa
al
HLR
o
bien
del
n√∫mero
de
itineran-


cia
a
trav√©s
del
cual
se
puede
contactar
con
el
m√≥vil
,
o
de
la
direcci√≥n
del
VLR
(
al
que
se


puede
consultar
m√°s
adelante
para
obtener
el
n√∫mero
de
itinerancia
del
m√≥vil
)
.
Como
parte


de
este
intercambio
,
el
VLR
obtiene
tambi√©n
informaci√≥n
de
abonado
de
la
base
de
datos


HLR
acerca
del
m√≥vil
y
determina
qu√©
servicios
(
en
su
caso
)
tiene
que
proporcionar
la
red


visitada
al
usuario
m√≥vil
.


550
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5506.7.2
Transferencia
de
llamadas
en
GSM


Cuando
una
estaci√≥n
m√≥vil
cambia
su
asociaci√≥n
de
una
estaci√≥n
base
a
otra
durante
una


llamada
se
produce
lo
que
se
denomina
transferencia
o
cesi√≥n
de
la
llamada
.
Como
se


muestra
en
la
Figura
6.30
,
la
llamada
del
m√≥vil
es
enrutada
inicialmente
(
antes
de
la
transfe-


rencia
)
hacia
el
m√≥vil
a
trav√©s
de
una
estaci√≥n
base
(
a
la
que
denominaremos
estaci√≥n
base


antigua
)
mientras
que
despu√©s
de
la
transferencia
se
enruta
hacia
el
m√≥vil
a
trav√©s
de
otra


estaci√≥n
base
(
a
la
que
denominaremos
nueva
estaci√≥n
base
)
.
Observe
que
una
transferencia


6.7
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
EN
REDES
CELULARES
551


Usuario


m√≥vil


Red


visitada


Red


propia


Red
telef√≥nica


conmutada


p√∫blica


1


3


Corresponsal


VLR


HLR


2


Figura
6.29
‚Ä¢
Establecimiento
de
una
llamada
hacia
un
usuario
m√≥vil
:


enrutamiento
indirecto
.


Antigua
BS
Nueva
BS


Antiguo


enrutamiento


Nuevo


enrutamiento


VLR


Figura
6.30
‚Ä¢
Escenario
de
transferencia
de
llamadas
entre
estaciones
base
con


un
MSC
com√∫n
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
551de
llamada
entre
las
estaciones
base
da
como
resultado
no
s√≥lo
que
el
m√≥vil
transmita
/
reciba


hacia
/
desde
una
estaci√≥n
base
nueva
,
sino
tambi√©n
que
la
llamada
activa
se
re-enrute
desde


un
punto
de
conmutaci√≥n
dentro
de
la
red
hacia
la
nueva
estaci√≥n
base
.
Inicialmente
,
vamos


a
suponer
que
las
estaciones
base
nueva
y
antigua
comparten
el
mismo
MSC
y
que
dicho
re-


enrutamiento
tiene
lugar
en
ese
MSC
.


Puede
haber
varias
razones
para
que
se
produzca
la
transferencia
de
la
llamada
,
entre


las
que
podemos
citar
(
1
)
que
la
se√±al
entre
la
estaci√≥n
base
actual
y
el
m√≥vil
se
puede
haber


deteriorado
hasta
tal
punto
que
exista
riesgo
de
que
la
llamada
se
interrumpa
y
(
2
)
que
una


celda
pueda
haberse
sobrecargado
debido
a
que
est√°
gestionando
un
gran
n√∫mero
de
llama-


das
.
Esta
congesti√≥n
puede
aliviarse
transfiriendo
usuarios
m√≥viles
a
otras
celdas
cercanas


menos
congestionadas
.


Mientras
que
est√°
asociado
con
una
estaci√≥n
base
,
el
m√≥vil
mide
peri√≥dicamente
la


intensidad
de
una
se√±al
baliza
recibida
desde
su
estaci√≥n
base
actual
,
as√≠
como
se√±ales
baliza


procedentes
de
estaciones
base
cercanas
que
el
m√≥vil
pueda
‚Äú
escuchar
‚Äù
.
Estas
medidas
son


reenviadas
una
o
dos
veces
por
segundo
hacia
la
estaci√≥n
base
actual
del
m√≥vil
.
Es
la
propia


estaci√≥n
base
antigua
la
que
inicia
la
transferencia
de
una
llamada
en
GSM
bas√°ndose
en


estas
medidas
,
en
la
carga
actual
de
m√≥viles
existente
en
las
celdas
cercanas
y
en
otros
fac-


tores
[
Mouly
1992
]
.
El
est√°ndar
GSM
no
especifica
el
algoritmo
concreto
que
una
estaci√≥n


base
debe
utilizar
a
la
hora
de
determinar
si
transferir
o
no
una
llamada
.


La
Figura
6.31
ilustra
los
pasos
que
se
llevan
a
cabo
cuando
una
estaci√≥n
base
decide


transferir
un
usuario
m√≥vil
:


1
.
La
estaci√≥n
base
(
BS
)
antigua
informa
al
MSC
visitado
de
que
hay
que
realizar
una


transferencia
,
as√≠
como
de
la
estaci√≥n
base
(
o
del
posible
conjunto
de
estaciones
base
)
a


la
que
hay
que
transferir
el
m√≥vil
.


2
.
El
MSC
visitado
inicia
las
operaciones
de
establecimiento
de
la
ruta
hacia
la
nueva
esta-


ci√≥n
base
,
asignando
los
recursos
necesarios
para
transportar
la
llamada
re-enrutada
y


se√±alizando
a
la
nueva
estaci√≥n
base
que
se
va
a
producir
una
transferencia
.


3
.
La
nueva
estaci√≥n
base
asigna
y
activa
un
nuevo
canal
de
radio
para
que
lo
utilice
el


m√≥vil
.


552
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


Antigua


BS


Nueva


BS


1


5


78


2


3


6


4


VLR


Figura
6.31
‚Ä¢
Pasos
necesarios
para
realizar
una
transferencia
entre
estaciones


base
con
un
MSC
com√∫n
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5524
.
La
nueva
estaci√≥n
base
env√≠a
de
vuelta
al
MSC
visitado
y
a
la
estaci√≥n
base
antigua
una


se√±al
indicativa
de
que
se
ha
establecido
la
ruta
entre
el
MSC
visitado
y
la
nueva
esta-


ci√≥n
base
,
y
de
que
hay
que
informar
al
m√≥vil
de
la
transferencia
que
se
va
a
producir
.


La
nueva
estaci√≥n
base
proporciona
toda
la
informaci√≥n
que
el
m√≥vil
necesitar√°
para


asociarse
con
ella
.


5
.
El
m√≥vil
es
informado
de
que
debe
realizar
una
transferencia
.
Observe
que
hasta
este


punto
,
el
m√≥vil
ha
estado
completamente
ignorante
de
que
la
red
estaba
realizando
el


trabajo
necesario
para
llevar
a
cabo
una
transferencia
(
por
ejemplo
,
asignar
un
canal
en


la
nueva
estaci√≥n
base
y
asignar
una
ruta
entre
el
MSC
visitado
y
la
nueva
estaci√≥n


base
)
.


6
.
El
m√≥vil
y
la
nueva
estaci√≥n
base
intercambian
uno
o
m√°s
mensajes
para
activar
com-


pletamente
el
nuevo
canal
en
la
estaci√≥n
base
nueva
.


7
.
El
m√≥vil
env√≠a
a
la
nueva
estaci√≥n
base
un
mensaje
indicando
que
se
ha
completado
la


transferencia
,
el
cual
es
reenviado
hacia
el
MSC
visitado
.
Entonces
,
el
MSC
visitado
re-


enruta
la
llamada
activa
hacia
el
m√≥vil
a
trav√©s
de
la
nueva
estaci√≥n
base
.


8
.
Por
√∫ltimo
,
se
liberan
los
recursos
asignados
en
la
ruta
que
llevaba
hacia
la
antigua
esta-


ci√≥n
base
.


Vamos
a
concluir
nuestro
an√°lisis
de
transferencia
de
llamadas
considerando
lo
que
ocu-


rre
cuando
el
m√≥vil
se
desplaza
a
una
estaci√≥n
base
que
est√°
asociada
con
un
MSC
diferente


al
de
la
antigua
estaci√≥n
base
,
y
tambi√©n
lo
que
sucede
cuando
este
tipo
de
transferencia


entre
dos
MSC
tiene
lugar
m√°s
de
una
vez
.
Como
se
muestra
en
la
Figura
6.32
,
GSM
define


6.7
‚Ä¢
GESTI√ìN
DE
LA
MOVILIDAD
EN
REDES
CELULARES
553


Red
propia
Corresponsal


a.
 
Antes
de
la
transferencia
.


MSC


ancla
Red


telef√≥nica


conmutada


p√∫blica


b.
 
Despu√©s
de
la
transferencia
.


Corresponsal


MSC


ancla


Red


telef√≥nica


conmutada


p√∫blica


Red
propia


Figura
6.32
‚Ä¢
Re-enrutamiento
a
trav√©s
de
un
MSC
ancla
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
553el
concepto
de
MSC
ancla
.
El
MSC
ancla
es
el
MSC
que
estaba
siendo
visitado
por
el
m√≥vil


cuando
da
comienzo
una
llamada
;
por
tanto
,
el
MSC
ancla
sigue
siendo
el
mismo
a
todo
lo


largo
de
la
llamada
.
Mientras
dure
la
llamada
e
independientemente
del
n√∫mero
de
transfe-


rencias
inter-MSC
realizadas
por
el
m√≥vil
,
la
llamada
es
enrutada
desde
el
MSC
propio
hasta


el
MSC
ancla
y
despu√©s
desde
el
MSC
ancla
al
MSC
visitado
en
el
que
el
m√≥vil
est√©
situado


actualmente
.
Cuando
un
m√≥vil
se
desplaza
desde
el
√°rea
de
cobertura
de
un
MSC
a
la
de


otro
,
la
llamada
activa
se
re-enruta
desde
el
MSC
ancla
hasta
el
nuevo
MSC
visitado
que


contiene
a
la
nueva
estaci√≥n
base
.
Por
tanto
,
en
cada
momento
existen
,
como
mucho
,
tres


MSC
(
el
MSC
propio
,
el
MSC
ancla
y
el
MSC
visitado
)
entre
el
corresponsal
y
el
m√≥vil
.
La


Figura
6.32
ilustra
el
enrutamiento
de
una
llamada
entre
los
MSC
visitados
por
un
usuario


m√≥vil
.


En
lugar
de
mantener
un
√∫nico
salto
de
MSC
desde
el
MSC
ancla
al
MSC
actual
,
una


t√©cnica
alternativa
habr√≠a
sido
encadenar
simplemente
los
MSC
visitados
por
el
m√≥vil
,


haciendo
que
cada
MSC
antiguo
reenv√≠e
la
llamada
activa
al
nuevo
MSC
cada
vez
que
el


m√≥vil
se
desplace
hasta
un
nuevo
MSC
.
Dicho
encadenamiento
de
centros
MSC
puede
tener


lugar
 
en
las
redes
celulares
IS-41
,
con
un
paso
opcional
de
minimizaci√≥n
de
la
ruta
para
eli-


minar
los
MSC
existentes
entre
el
MSC
ancla
y
el
MSC
visitado
actual
[
Lin
2001
]
.


Terminamos
esta
exposici√≥n
acerca
de
la
gesti√≥n
de
la
movilidad
GSM
con
una
compa-


raci√≥n
de
la
gesti√≥n
de
movilidad
en
GSM
e
IP
m√≥vil
.
La
comparaci√≥n
en
la
Tabla
6.2
indica


que
aunque
las
redes
celulares
e
IP
son
fundamentalmente
distintos
en
muchos
aspectos
,


comparten
un
sorprendente
n√∫mero
de
elementos
funcionales
comunes
y
de
t√©cnicas
globa-


les
a
la
hora
de
gestionar
la
movilidad
.


Elemento
GSM
Comentarios
sobre
el
elemento
GSM
Elemento
IP
m√≥vil


Sistema
propio
Red
a
la
que
pertenece
el
n√∫mero
de
tel√©fono
permanente
Red
propia


del
usuario
m√≥vil
.


Centro
de
conmutaci√≥n
m√≥vil
pasarela
MSC
propio
:
punto
de
contacto
para
obtener
la
direcci√≥n
Agente
propio


o
simplemente
MSC
propio
,
enrutable
del
usuario
m√≥vil
.
HLR
:
base
de
datos
en
el


Registro
de
ubicaci√≥n
propio
(
HLR
)
sistema
propio
que
contiene
el
n√∫mero
de
tel√©fono
 

permanente
,
la
informaci√≥n
de
perfil
,
la
ubicaci√≥n
actual
  

del
usuario
m√≥vil
y
la
informaci√≥n
de
abono
.


Sistema
visitado
Red
distinta
del
sistema
propio
en
la
que
reside
Red
visitada


actualmente
el
usuario
m√≥vil
.


Centro
de
conmutaci√≥n
de
servicios
MSC
visitado
:
responsable
de
establecer
las
llamadas
 
Agente
ajeno


m√≥viles
visitados
,
hacia
/
desde
los
nodos
m√≥viles
en
las
celdas
asociadas
  

Registro
de
ubicaci√≥n
de
visitantes
(
VLR
)
con
el
MSC
.


VLR
:
entrada
temporal
en
la
base
de
datos
dentro
del


sistema
visitado
,
que
contiene
informaci√≥n
de
subscripci√≥n


para
cada
usuario
m√≥vil
visitante
.


N√∫mero
de
itinerancia
de
la
estaci√≥n
Direcci√≥n
enrutable
para
el
segmento
de
llamada
telef√≥nica
 
Direcci√≥n
COA


m√≥vil
(
MSRN
)
o
simplemente
entre
el
MSC
propio
y
el
MSC
visitado
,
que
no
es
visible
ni


n√∫mero
de
itinerancia
para
el
m√≥vil
ni
para
el
corresponsal
.


Tabla
6.2
‚Ä¢
Aspectos
comunes
entre
IP
m√≥vil
y
GSM
en
lo
que
respecta
a
la


movilidad
.


554
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5546.8
Tecnolog√≠a
inal√°mbrica
y
movilidad
:
impacto
sobre


los
protocolos
de
las
capas
superiores


En
este
cap√≠tulo
,
hemos
visto
que
las
redes
inal√°mbricas
difieren
significativamente
de
sus


contrapartidas
cableadas
tanto
en
la
capa
de
enlace
(
como
resultado
de
caracter√≠sticas
del


canal
inal√°mbrico
tales
como
el
desvanecimiento
,
el
multicamino
y
los
terminales
ocultos
)


como
en
la
capa
de
red
(
como
resultado
de
la
existencia
de
usuarios
m√≥viles
que
cambian


sus
puntos
de
asociaci√≥n
con
la
red
)
.
Pero
,
¬ø
existen
diferencias
importantes
en
las
capas
de


transporte
y
de
aplicaci√≥n
?
Resulta
tentador
pensar
que
estas
diferencias
ser√°n
menores
,


dado
que
la
capa
de
red
proporciona
a
las
capas
superiores
el
modelo
de
servicio
de
entrega


de
mejor
esfuerzo
tanto
en
las
redes
cableadas
como
en
las
inal√°mbricas
.
De
forma
similar
,


si
se
utilizan
protocolos
como
TCP
o
UDP
para
proporcionar
los
servicios
de
la
capa
de


transporte
a
las
aplicaciones
tanto
en
redes
inal√°mbricas
como
cableadas
,
entonces
la
capa


de
aplicaci√≥n
tampoco
tendr√≠a
por
qu√©
ser
modificada
.
En
un
cierto
sentido
,
nuestra
intui-


ci√≥n
 
es
correcta
:
TCP
y
UDP
pueden
(
y
de
hecho
lo
hacen
)
operar
en
redes
con
enlaces
ina-


l√°mbricos
.
Por
otra
parte
,
los
protocolos
de
transporte
en
general
,
y
TCP
en
particular
,


pueden
tener
en
ocasiones
un
rendimiento
muy
distinto
en
las
redes
cableadas
e
inal√°mbri-


cas
,
y
es
aqu√≠
,
en
t√©rminos
de
rendimiento
,
que
las
diferencias
se
manifiestan
.
Veamos
por


qu√©
.


Recuerde
que
TCP
retransmite
los
segmentos
perdidos
o
corruptos
a
lo
largo
de
la
ruta


existente
entre
el
emisor
y
el
receptor
.
En
el
caso
de
usuarios
m√≥viles
,
las
p√©rdidas
pueden


ser
el
resultado
de
la
congesti√≥n
de
la
red
(
desbordamiento
de
los
buffers
de
los
routers
)
o
de


la
transferencia
de
llamadas
(
por
ejemplo
,
debido
a
retardos
en
el
re-enrutamiento
de
seg-


mentos
hacia
el
nuevo
punto
de
asociaci√≥n
con
la
red
de
un
m√≥vil
)
.
En
todos
los
casos
,
los


mensajes
ACK
del
receptor
al
emisor
de
TCP
s√≥lo
indican
que
un
segmento
no
ha
sido
reci-


bido
intacto
;
el
emisor
no
es
consciente
de
si
el
segmento
se
ha
perdido
a
causa
de
la
con-


gesti√≥n
,
durante
la
transferencia
o
porque
se
han
detectado
bits
err√≥neos
.
En
todos
los
casos
,


la
respuesta
del
emisor
es
la
misma
:
retransmitir
el
segmento
.
La
respuesta
del
control
de


congesti√≥n
de
TCP
es
tambi√©n
siempre
la
misma
en
todos
los
casos
:
TCP
disminuye
el


tama√±o
de
su
ventana
de
congesti√≥n
como
se
explica
en
la
Secci√≥n
3.7
.
Reduciendo
incon-


dicionalmente
su
ventana
de
congesti√≥n
,
TCP
asume
impl√≠citamente
que
las
p√©rdidas
de
seg-


mento
se
deben
a
la
congesti√≥n
m√°s
que
a
la
corrupci√≥n
o
a
la
transferencia
de
llamadas
.


Pero
,
como
hemos
visto
en
la
Secci√≥n
6.2
,
los
errores
de
bit
son
mucho
m√°s
comunes
en
las


redes
inal√°mbricas
que
en
las
redes
cableadas
.
Cuando
se
producen
tales
errores
de
bits
o


cuando
tienen
lugar
p√©rdidas
debido
al
mecanismo
de
transferencia
no
existe
realmente
nin-


guna
raz√≥n
para
que
el
emisor
TCP
reduzca
su
ventana
de
congesti√≥n
(
y
por
tanto
su
veloci-


dad
de
env√≠o
)
.
De
hecho
,
podr√≠a
darse
perfectamente
el
caso
de
que
los
buffers
de
los
routers


est√©n
vac√≠os
y
de
que
los
paquetes
est√©n
fluyendo
a
lo
largo
de
la
ruta
terminal
a
terminal
sin


que
la
congesti√≥n
represente
ning√∫n
obst√°culo
.


Los
investigadores
se
dieron
cuenta
a
principios
y
mediados
de
la
d√©cada
de
1990
de


que
dadas
las
tasas
de
errores
de
bit
en
los
enlaces
inal√°mbricos
y
la
posibilidad
de
que
se


produzcan
p√©rdidas
en
la
transferencia
de
llamadas
,
la
respuesta
del
control
de
congesti√≥n


de
TCP
podr√≠a
ser
problem√°tica
en
una
configuraci√≥n
inal√°mbrica
.
Para
resolver
este
pro-


blema
se
pueden
usar
tres
clases
gen√©ricas
de
t√©cnicas
:


‚Ä¢
Recuperaci√≥n
local
.
Los
protocolos
de
recuperaci√≥n
local
permiten
recuperarse
de
los


errores
de
bit
en
el
lugar
y
en
el
momento
en
que
esos
errores
se
producen
(
por
ejemplo
,


6.8
‚Ä¢
TECNOLOG√çA
INAL√ÅMBRICA
Y
MOVILIDAD
555


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
555en
el
enlace
inal√°mbrico
)
;
un
caso
ser√≠a
el
protocolo
ARQ
802.11
que
hemos
estudiado


en
la
Secci√≥n
6.3
,
o
algunas
t√©cnicas
m√°s
sofisticadas
que
utilizan
tanto
ARQ
como
FEC


[
Ayanoglu
1995
]
.


‚Ä¢
Conocimiento
por
parte
del
emisor
TCP
de
enlaces
inal√°mbricos
.
En
las
t√©cnicas
de


recuperaci√≥n
local
,
el
emisor
TCP
es
afortunadamente
inconsciente
de
que
sus
segmen-


tos
est√°n
atravesando
un
enlace
inal√°mbrico
.
Una
t√©cnica
alternativa
es
que
es
el
emisor


y
el
receptor
TCP
sean
conscientes
de
la
existencia
de
un
enlace
inal√°mbrico
,
para
distin-


guir
entre
las
p√©rdidas
por
congesti√≥n
que
tienen
lugar
en
la
red
cableada
y
las
p√©rdidas/


corrupciones
que
se
producen
en
el
enlace
inal√°mbrico
,
y
para
invocar
los
mecanismos


de
control
de
congesti√≥n
s√≥lo
en
respuesta
a
las
p√©rdidas
debidas
a
que
la
red
cableada


est√°
congestionada
.
[
Balakrishnan
1997
]
investiga
diversos
tipos
de
TCP
,
bajo
la
suposi-


ci√≥n
de
que
los
sistemas
terminales
puedan
llevar
a
cabo
esta
distinci√≥n
.
[
Wei
2004
]


investiga
t√©cnicas
para
distinguir
entre
las
p√©rdidas
de
los
segmentos
cableados
e
inal√°m-


bricos
de
una
ruta
terminal
a
terminal
.


‚Ä¢
T√©cnicas
de
conexi√≥n
dividida
.
En
la
t√©cnica
de
conexi√≥n
dividida
[
Bakre
1995
]
,
la
cone-


xi√≥n
terminal
a
terminal
entre
el
usuario
m√≥vil
y
el
otro
punto
terminal
se
divide
en
dos


conexiones
de
la
capa
de
transporte
:
una
desde
el
host
m√≥vil
hasta
el
punto
de
acceso
ina-


l√°mbrico
y
otra
desde
el
punto
de
acceso
inal√°mbrico
hasta
el
otro
punto
terminal
de
la


comunicaci√≥n
(
que
asumiremos
aqu√≠
que
se
trata
de
un
host
cableado
)
.
La
conexi√≥n


terminal
a
terminal
se
forma
,
por
tanto
,
mediante
la
concatenaci√≥n
de
una
parte
inal√°m-


brica
y
una
parte
cableada
.
La
capa
de
transporte
a
trav√©s
del
segmento
inal√°mbrico


puede
ser
una
conexi√≥n
TCP
est√°ndar
[
Bakre
1995
]
o
un
protocolo
de
recuperaci√≥n
de


errores
especialmente
adaptado
ejecut√°ndose
sobre
UDP
.
[
Yavatkar
1994
]
investiga
el


uso
de
un
protocolo
de
repetici√≥n
selectiva
de
la
capa
de
transporte
a
trav√©s
de
la
cone-


xi√≥n
inal√°mbrica
.
Las
medidas
contenidas
en
[
Wei
2006
]
indican
que
las
conexiones
TCP


divididas
se
utilizan
ampliamente
en
las
redes
de
datos
celulares
y
que
pueden
,
de
hecho
,


llevarse
a
cabo
mejoras
significativas
utilizando
ese
tipo
de
conexiones
divididas
.


Nuestro
tratamiento
de
TCP
sobre
los
enlaces
inal√°mbricos
ha
sido
necesariamente


breve
.
Animamos
al
lector
a
consultar
las
referencias
para
conocer
m√°s
detalles
acerca
de


esta
√°rea
activa
de
investigaci√≥n
.


Habiendo
considerado
los
protocolos
de
la
capa
de
transporte
,
veamos
a
continuaci√≥n
el


efecto
de
la
tecnolog√≠a
inal√°mbrica
y
de
la
movilidad
sobre
los
protocolos
de
la
capa
de
apli-


caci√≥n
.
Aqu√≠
,
una
consideraci√≥n
importante
es
que
los
enlaces
inal√°mbricos
suelen
tener


anchos
de
banda
relativamente
bajos
,
como
vimos
en
la
Figura
6.2
.
Como
resultado
,
las
apli-


caciones
que
operan
sobre
enlaces
inal√°mbricos
,
particularmente
,
sobre
enlaces
inal√°mbri-


cos
celulares
,
deben
tratar
el
ancho
de
banda
como
un
recurso
escaso
.
Por
ejemplo
,
un


servidor
web
que
est√©
enviando
contenido
a
un
navegador
web
que
se
ejecuta
sobre
un
tel√©-


fono
3
G
probablemente
no
pueda
proporcionar
un
contenido
con
la
misma
riqueza
de
im√°-


genes
que
el
que
env√≠a
a
un
navegador
que
est√©
operando
a
trav√©s
de
una
conexi√≥n
cableada
.


Aunque
los
enlaces
inal√°mbricos
presentan
desaf√≠os
en
la
capa
de
aplicaci√≥n
,
la
movilidad


que
permiten
tambi√©n
hace
posible
un
amplio
conjunto
de
aplicaciones
conscientes
de
la


ubicaci√≥n
y
del
contexto
[
Chen
2000
]
.
En
t√©rminos
m√°s
generales
,
las
redes
inal√°mbricas
y


m√≥viles
desempe√±ar√°n
un
papel
crucial
a
la
hora
de
conseguir
disponer
de
los
entornos
de


computaci√≥n
ubicua
del
futuro
[
Weiser
1991
]
.
Dicho
esto
,
terminemos
dejando
claro
que


esto
es
s√≥lo
la
punta
del
iceberg
en
lo
que
respecta
al
impacto
de
las
redes
inal√°mbricas
y


m√≥viles
sobre
las
aplicaciones
en
red
y
sus
protocolos
.


556
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
5566.9
Resumen


Las
redes
inal√°mbricas
y
m√≥viles
han
revolucionado
la
telefon√≠a
y
est√°n
teniendo
un


impacto
cada
vez
m√°s
profundo
tambi√©n
en
el
mundo
de
las
redes
de
computadoras
.
Con
su


acceso
no
restringido
,
en
cualquier
momento
y
en
cualquier
lugar
,
a
la
infraestructura
global


de
red
,
no
s√≥lo
est√°n
haciendo
que
el
acceso
de
red
sea
m√°s
ubicuo
,
sino
que
tambi√©n
permi-


ten
un
conjunto
muy
excitante
de
nuevos
servicios
dependientes
de
la
ubicaci√≥n
.
Dada
la


creciente
importancia
de
las
redes
inal√°mbricas
y
m√≥viles
,
este
cap√≠tulo
se
ha
centrado
en


los
principios
,
en
las
tecnolog√≠as
de
enlaces
comunes
y
en
las
arquitecturas
de
red
necesarias


para
dar
soporte
a
las
comunicaciones
inal√°mbricas
y
m√≥viles
.


Hemos
comenzado
el
cap√≠tulo
con
una
introducci√≥n
a
las
redes
inal√°mbricas
y
m√≥viles
,


estableciendo
una
importante
distinci√≥n
entre
los
desaf√≠os
planteados
por
la
naturaleza


inal√°mbrica
de
los
enlaces
de
comunicaciones
de
tales
redes
y
por
la
movilidad
que
estos


enlaces
inal√°mbricos
hacen
posible
.
Esto
nos
ha
permitido
aislar
,
identificar
y
dominar


mejor
los
conceptos
clave
de
cada
√°rea
.
Nos
hemos
centrado
primero
en
la
comunicaci√≥n


inal√°mbrica
,
considerando
las
caracter√≠sticas
de
un
enlace
inal√°mbrico
en
la
Secci√≥n
6.2
.
En


las
Secciones
6.3
y
6.4
hemos
examinado
los
aspectos
del
nivel
de
enlace
del
est√°ndar
para


redes
LAN
inal√°mbricas
802.11
del
IEEE
(
WiFi
)
,
del
est√°ndar
WiMAX
802.16
,
del
est√°ndar


Bluetooth
802.15.1
y
del
acceso
celular
a
Internet
.
Despu√©s
hemos
vuelto
nuestra
atenci√≥n


hacia
el
problema
de
la
movilidad
.
En
la
Secci√≥n
6.5
hemos
identificado
diversas
formas
de


movilidad
,
viendo
que
los
diversos
puntos
a
lo
largo
de
este
espectro
planteaban
diferentes


desaf√≠os
y
admit√≠an
distintas
soluciones
.
Hemos
considerado
los
problemas
de
localizar
un


usuario
m√≥vil
y
efectuar
el
enrutamiento
hasta
√©l
,
as√≠
como
las
t√©cnicas
para
transferir
a


los
usuarios
m√≥viles
que
se
desplazan
din√°micamente
desde
un
punto
de
asociaci√≥n
con
la


red
hasta
otro
.
En
las
Secciones
6.6
y
6.7
,
respectivamente
,
hemos
examinado
c√≥mo
se


resolv√≠an
estas
cuestiones
en
el
est√°ndar
IP
m√≥vil
y
en
GSM
.
Por
√∫ltimo
,
hemos
considerado


el
impacto
de
los
enlaces
inal√°mbricos
y
la
movilidad
en
los
protocolos
de
la
capa
de
trans-


porte
y
sobre
las
aplicaciones
en
red
en
la
Secci√≥n
6.8
.


Aunque
hemos
dedicado
un
cap√≠tulo
completo
al
estudio
de
las
redes
inal√°mbricas
y


m√≥viles
,
har√≠a
falta
un
libro
completo
(
o
m√°s
)
para
explorar
totalmente
este
campo
tan
atrac-


tivo
y
en
tan
r√°pida
expansi√≥n
.
Animamos
al
lector
a
profundizar
m√°s
en
este
campo
consul-


tando
las
muchas
referencias
que
hemos
proporcionado
a
lo
largo
del
cap√≠tulo
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
6
‚Ä¢
Cuestiones
de
repaso


SECCI√ìN
6.1


R1
.
¬ø
Qu√©
quiere
decir
que
una
red
inal√°mbrica
est√°
operando
en
‚Äú
modo
de
infraestruc-


tura
‚Äù
?
Si
la
red
no
se
encuentra
en
modo
de
infraestructura
,
¬ø
en
qu√©
modo
de
opera-


ci√≥n
se
encuentra
y
cu√°l
es
la
diferencia
entre
ese
modo
de
operaci√≥n
y
el
modo
de


infraestructura
?


R2
.
¬ø
Cu√°les
son
los
cuatro
tipos
de
redes
inal√°mbricas
identificados
en
nuestra
taxonom√≠a


de
la
Secci√≥n
6.1
?
¬ø
Cu√°les
de
estos
tipos
de
redes
inal√°mbricas
ha
usado
usted
?


PROBLEMAS
Y
CUESTIONES
DE
REPASO
557


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
557SECCI√ìN
6.2


R3
.
¬ø
Cu√°les
son
las
diferencias
entre
los
siguientes
tipos
de
deficiencias
de
los
canales
ina-


l√°mbricos
:
p√©rdida
de
la
ruta
,
propagaci√≥n
multicamino
,
interferencia
de
otros
or√≠ge-


nes
?


R4
.
A
medida
que
un
nodo
m√≥vil
se
va
alejando
de
una
estaci√≥n
base
,
¬ø
qu√©
dos
acciones


puede
llevar
a
cabo
una
estaci√≥n
base
para
garantizar
que
la
probabilidad
de
p√©rdida


de
las
tramas
transmitidas
no
se
incremente
?


SECCI√ìN
6.3


R5
.
Describa
el
papel
de
las
tramas
baliza
en
802.11
.


R6
.
Verdadero
o
falso
:
antes
de
que
una
estaci√≥n
802.11
transmita
una
trama
de
datos
,


debe
en
primer
lugar
enviar
una
trama
RTS
y
recibir
la
correspondiente
trama
CTS
.


R7
.
¬ø
Por
qu√©
se
utilizan
los
reconocimientos
en
802.11
,
pero
no
en
una
Ethernet
cableada
?


R8
.
Verdadero
o
falso
:
Ethernet
y
802.11
utilizan
la
misma
estructura
de
trama
.


R9
.
Describa
c√≥mo
funciona
el
umbral
RTS
.


R10
.
Suponga
que
las
tramas
RTS
y
CTS
de
IEEE
802.11
fueran
tan
largas
como
las
tramas


DATA
y
ACK
est√°ndar
.
¬ø
Proporcionar√≠a
entonces
alguna
ventaja
el
uso
de
la
tramas


CTS
y
RTS
?
¬ø
Por
qu√©
?


R11
.
En
la
Secci√≥n
6.3.4
se
ha
analizado
la
movilidad
en
los
est√°ndares
802.11
,
en
la
que


una
estaci√≥n
inal√°mbrica
se
desplaza
desde
una
BSS
a
otra
dentro
de
una
misma


subred
.
Cuando
los
puntos
de
acceso
est√°n
interconectados
mediante
un
conmutador
,


un
punto
de
acceso
puede
necesitar
enviar
una
trama
con
una
direcci√≥n
MAC
suplan-


tada
para
hacer
que
el
conmutador
reenv√≠e
la
trama
adecuadamente
.
¬ø
Por
qu√©
?


R12
.
¬ø
Cu√°les
son
las
diferencias
entre
un
dispositivo
maestro
en
una
red
Bluetooth
y
una


estaci√≥n
base
en
una
red
802.11
?


R13
.
V
erdadero
o
falso
:
en
WiMAX
,
una
estaci√≥n
base
debe
transmitir
hacia
todos
los


nodos
a
la
misma
velocidad
de
canal
.


R14
.
¬ø
Qu√©
quiere
decir
el
t√©rmino
‚Äú
planificaci√≥n
oportunista
‚Äù
en
WiMAX
?


R15
.
En
la
Secci√≥n
6.3.2
hemos
visto
que
hay
dos
est√°ndares
3
G
principales
:
UMTS
y


CDMA-2000
.
¬ø
De
qu√©
est√°ndares
2
G
y
2.5
G
son
herederos
cada
uno
de
estos
dos


est√°ndares
?


SECCI√ìN
6.5‚Äì6.6


R16
.
Si
un
nodo
dispone
de
una
conexi√≥n
inal√°mbrica
con
Internet
,
¬ø
tiene
que
ser
m√≥vil
ese


nodo
?
Explique
su
respuesta
.
Suponga
que
un
usuario
con
una
computadora
port√°til


va
paseando
por
su
domicilio
y
siempre
accede
a
Internet
a
trav√©s
del
mismo
punto
de


acceso
.
¬ø
Es
este
usuario
m√≥vil
desde
el
punto
de
vista
de
la
red
?
Explique
su
res-


puesta
.


R17
.
¬ø
Cu√°l
es
la
diferencia
entre
una
direcci√≥n
permanente
y
una
direcci√≥n
cedida
(
COA
)
?


¬ø
Qui√©n
asigna
una
direcci√≥n
COA
?


558
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
558R18
.
Considere
una
conexi√≥n
TCP
que
pasa
a
trav√©s
de
IP
m√≥vil
.
Indique
si
es
verdadera
o


falsa
la
siguiente
afirmaci√≥n
:
la
fase
de
la
conexi√≥n
TCP
entre
el
corresponsal
y
el
host


m√≥vil
pasa
a
trav√©s
de
la
red
propia
del
m√≥vil
,
pero
la
fase
de
transferencia
de
datos
se


lleva
a
cabo
directamente
entre
el
corresponsal
y
el
host
m√≥vil
,
sin
pasar
por
la
red


propia
.


SECCI√ìN
6.7


R19
.
¬ø
Cu√°les
son
los
objetivos
de
los
registros
HLR
y
VLR
en
las
redes
GSM
?
¬ø
Qu√©
ele-


mentos
de
IP
m√≥vil
son
similares
al
HLR
y
al
VLR
?


R20
.
¬ø
Cu√°l
es
el
papel
del
MSC
ancla
en
las
redes
GSM
?


SECCI√ìN
6.8


R21
.
¬ø
Qu√©
tres
t√©cnicas
pueden
utilizarse
para
evitar
que
un
√∫nico
enlace
inal√°mbrico


degrade
el
rendimiento
de
una
conexi√≥n
TCP
terminal
a
terminal
de
la
capa
de
trans-


porte
?


Problemas


P1
.
Considere
el
ejemplo
de
CDMA
con
un
√∫nico
emisor
de
la
Figura
6.5
.
¬ø
Cu√°l
ser√≠a
la


salida
del
emisor
(
para
los
2
bits
de
datos
mostrados
)
si
el
c√≥digo
CDMA
del
emisor


fuera
(
1
,
‚Äì
1
,
1
,
‚Äì
1
,
1
,
‚Äì
1
,
1
,
‚Äì
1
)
?


P2
.
Considere
el
emisor
2
en
la
Figura
6.6
.
¬ø
Cu√°l
es
la
salida
del
emisor
hacia
el
canal


(
antes
de
que
se
sume
con
la
se√±al
procedente
del
emisor
1
)
,
Z2


i
,
m
?


P3
.
Suponga
que
el
receptor
de
la
Figura
6.6
deseara
recibir
los
datos
que
est√°n
siendo


enviados
por
el
emisor
2
.
Demuestre
(
mediante
los
c√°lculos
necesarios
)
que
el
recep-


tor
puede
efectivamente
recuperar
los
datos
del
emisor
2
a
partir
de
la
se√±al
agregada


del
canal
utilizando
el
c√≥digo
correspondiente
al
emisor
2
.


P4
.
Para
el
ejemplo
de
dos
emisores
y
dos
receptores
,
proporcione
un
ejemplo
de
dos
c√≥di-


gos
CDMA
que
contengan
valores
1
y
/H110021
y
que
no
permitan
a
los
dos
receptores


extraer
los
bits
originales
transmitidos
por
los
emisores
CDMA
.


P5
.
Suponga
que
hay
dos
ISP
que
proporcionan
acceso
WiFi
en
una
determinada
cafete-


r√≠a
,
operando
cada
uno
de
esos
ISP
con
su
propio
punto
de
acceso
y
disponiendo
de
su


propio
bloque
de
direcciones
IP
.


a.
Suponga
adem√°s
que
,
por
accidente
,
cada
ISP
ha
configurado
su
punto
de
acceso


para
operar
con
el
canal
11
.
¬ø
Dejar√≠a
completamente
de
funcionar
el
protocolo


802.11
en
esta
situaci√≥n
?
Explique
lo
que
sucede
cuando
dos
estaciones
,
cada
una


de
ellas
asociada
con
un
ISP
diferente
,
tratan
de
transmitir
al
mismo
tiempo
.


b.
Suponga
ahora
que
uno
de
los
puntos
de
acceso
opera
a
trav√©s
del
canal
1
y
que
el


otro
opera
a
trav√©s
del
canal
11
.
¬ø
C√≥mo
modifica
esto
sus
respuestas
anteriores
?


P6
.
En
el
paso
4
del
protocolo
CSMA
/
CA
,
una
estaci√≥n
que
transmite
con
√©xito
una
trama


inicia
el
protocolo
CSMA
/
CA
para
transmitir
una
segunda
trama
en
el
paso
2
en
lugar


de
en
el
paso
1
.
¬ø
Qu√©
razones
pueden
haber
tenido
en
mente
los
dise√±adores
de


PROBLEMAS
559


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
559CSMA
/
CA
para
hacer
que
dicha
estaci√≥n
no
transmita
la
segunda
trama
de
forma


inmediata
(
si
se
detecta
que
el
canal
est√°
inactivo
)
?


P7
.
Suponga
que
configuramos
una
estaci√≥n
802.11b
para
reservar
siempre
el
canal
con
la


secuencia
RTS
/
CTS
.
Suponga
tambi√©n
que
esta
estaci√≥n
desea
de
repente
transmitir


1.000
bytes
de
datos
y
que
todas
las
dem√°s
estaciones
est√°n
inactivas
en
ese
momento
.


Calcule
el
tiempo
requerido
para
transmitir
la
trama
y
recibir
el
mensaje
de
reconoci-


miento
en
funci√≥n
de
SIFS
y
DIFS
,
e
ignorando
el
retardo
de
propagaci√≥n
y
supo-


niendo
que
no
se
produce
ning√∫n
error
de
bit
.


P8
.
Considere
el
escenario
mostrado
en
la
Figura
6.33
,
en
el
que
hay
cuatro
nodos
inal√°m-


bricos
,
A
,
B
,
C
y
D.
El
radio
de
cobertura
de
los
cuatro
nodos
se
muestra
mediante
los


√≥valos
sombreados
;
todos
los
nodos
comparten
la
misma
frecuencia
.
Cuando
A
trans-


mite
,
s√≥lo
puede
ser
escuchada
/
recibida
por
B
;
cuando
B
transmite
,
tanto
A
como
C


pueden
escuchar
/
recibir
desde
B
;
cuando
C
transmite
,
tanto
B
como
D
pueden
escu-


char
/
recibir
desde
C
;
cuando
D
transmite
,
s√≥lo
C
puede
escuchar
/
recibir
desde
D.


Suponga
ahora
que
cada
nodo
tiene
un
suministro
infinito
de
mensajes
que
quiere


enviar
a
cada
uno
de
los
otros
nodos
.
Si
el
destino
de
un
mensaje
no
es
un
vecino


inmediato
del
nodo
,
entonces
los
mensajes
deben
ser
reenviados
.
Por
ejemplo
,
si
A


desea
enviar
a
D
,
el
mensaje
debe
enviarse
primero
a
B
,
el
cual
lo
env√≠a
a
C
y
√©ste
lo


env√≠a
a
D.
El
tiempo
est√°
particionado
y
el
tiempo
de
transmisi√≥n
de
cada
mensaje
es


exactamente
igual
a
una
partici√≥n
de
tiempo
,
como
sucede
por
ejemplo
en
el
proto-


colo
Aloha
con
particiones
.
Durante
una
partici√≥n
de
tiempo
,
un
nodo
puede
hacer
una


de
las
cosas
siguientes
:
(
i
)
enviar
un
mensaje
;
(
ii
)
recibir
un
mensaje
(
si
se
est√°


enviando
exactamente
un
mensaje
a
ese
nodo
)
,
(
iii
)
permanecer
en
silencio
.
Como


siempre
,
si
un
nodo
escucha
dos
o
m√°s
transmisiones
simult√°neas
se
produce
una
coli-


si√≥n
y
ninguno
de
los
mensajes
transmitidos
ser√°
recibido
correctamente
.
Puede
asu-


mir
aqu√≠
que
no
existen
errores
de
nivel
de
bit
y
que
,
por
tanto
,
si
se
est√°
enviando


exactamente
un
mensaje
,
√©ste
ser√°
recibido
correctamente
por
aquellos
nodos
que
se


encuentren
dentro
del
radio
de
transmisi√≥n
del
emisor
.


a.
Suponga
ahora
que
un
controlador
omnisciente
(
es
decir
,
un
controlador
que


conoce
el
estado
de
todos
los
nodos
de
la
red
)
puede
ordenar
a
cada
nodo
que
haga


lo
que
el
controlador
omnisciente
quiere
,
es
decir
,
enviar
un
mensaje
,
recibir
un


mensaje
o
permanecer
en
silencio
.
Dado
este
controlador
omnisciente
,
¬ø
cu√°l
es
la


velocidad
m√°xima
a
la
que
puede
transmitirse
un
mensaje
desde
C
a
A
,
supuesto


que
no
haya
ning√∫n
otro
mensaje
entre
ning√∫n
otro
par
de
nodos
origen
/
destino
?


560
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


AB
C
D


Figura
6.33
‚Ä¢
Escenario
para
el
Problema
P8
.


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
560b
.
Suponga
ahora
que
A
env√≠a
mensajes
a
B
y
que
D
env√≠a
mensajes
a
C.
¬ø
Cu√°l
es
la


tasa
m√°xima
combinada
a
la
que
pueden
fluir
mensajes
de
datos
desde
A
hasta
B
y


desde
D
hasta
C
?


c.
Suponga
ahora
que
A
env√≠a
mensajes
a
B
y
que
C
env√≠a
mensajes
a
D.
¬ø
Cu√°l
es
la


tasa
m√°xima
combinada
a
la
que
pueden
fluir
mensajes
de
datos
desde
A
hasta
B
y


desde
C
hasta
D
?


d.
Suponga
ahora
que
sustituimos
los
enlaces
inal√°mbricos
por
enlaces
cableados
.


Repita
los
apartados
(
a
)
hasta
(
c
)
en
este
escenario
cableado
.


e.
Ahora
suponga
que
volvemos
al
escenario
inal√°mbrico
y
que
para
todos
los
mensa-


jes
de
datos
enviados
desde
el
origen
al
destino
,
el
destino
responde
con
un
men-


saje
ACK
dirigido
al
origen
(
por
ejemplo
,
como
en
TCP
)
.
Suponga
tambi√©n
que


cada
mensaje
ACK
ocupa
una
partici√≥n
.
Repita
los
apartados
(
a
)
‚Äì
(
c
)
anteriores


para
este
escenario
.


P9
.
Describa
el
formato
de
la
trama
Bluetooth
802.15.1
.
Tendr√°
que
leer
algunas
referen-


cias
,
adem√°s
de
este
libro
,
para
poder
encontrar
la
informaci√≥n
correspondiente
.
¬ø
Hay


algo
en
el
formato
de
trama
que
limite
de
manera
inherente
el
n√∫mero
de
nodos
acti-


vos
de
una
red
802.15.1
a
ocho
nodos
?
Explique
su
respuesta
.


P10
.
Considere
el
siguiente
escenario
WiMAX
idealizado
.
La
subtrama
descendente
(
v√©ase


la
Figura
6.17
)
est√°
particionada
en
el
tiempo
,
con
N
particiones
descendentes
por
sub-


trama
,
teniendo
todas
las
particiones
de
tiempo
la
misma
duraci√≥n
.
Hay
cuatro
nodos
,


A
,
B
,
C
y
D
,
alcanzables
desde
la
estaci√≥n
base
a
velocidades
de
10
Mbps
,
5
Mbps
,


2,5
Mbps
y
1
Mbps
,
respectivamente
,
en
el
canal
descendente
.
La
estaci√≥n
base
tiene


una
cantidad
infinita
de
datos
que
enviar
a
cada
uno
de
los
nodos
y
puede
enviar
a


cualquiera
de
esos
cuatro
nodos
durante
cualquiera
de
las
particiones
de
tiempo
de
la


subtrama
descendente
.


a.
¬ø
Cu√°l
es
la
velocidad
m√°xima
a
la
que
la
estaci√≥n
base
puede
enviar
a
los
nodos
,


suponiendo
que
puede
enviar
a
cualquier
nodo
que
elija
durante
cada
partici√≥n
de


tiempo
?
¬ø
Es
equitativa
su
soluci√≥n
?
Explique
su
respuesta
y
defina
qu√©
quiere
decir


con
el
t√©rmino
‚Äú
equitativa
‚Äù
.


b.
Si
imponemos
el
requisito
de
que
la
comunicaci√≥n
sea
equitativa
,
en
el
sentido
de


que
cada
nodo
deba
recibir
la
misma
cantidad
de
datos
durante
cada
subtrama
des-


cendente
,
¬ø
cu√°l
es
la
velocidad
media
de
transmisi√≥n
de
la
estaci√≥n
de
base
(
a
todos


los
nodos
)
durante
la
subtrama
descendente
?
Explique
c√≥mo
ha
llegado
a
obtener


su
respuesta
.


c.
Suponga
que
el
criterio
de
comunicaci√≥n
equitativa
es
que
cada
nodo
puede
recibir


como
mucho
el
doble
de
datos
que
cualquier
otro
nodo
durante
la
subtrama
.
¬ø
Cu√°l


es
la
velocidad
media
de
transmisi√≥n
de
la
estaci√≥n
base
(
a
todos
los
nodos
)
durante


la
subtrama
?
Explique
c√≥mo
ha
obtenido
su
respuesta
.


P11
.
En
la
Secci√≥n
6.5
,
una
soluci√≥n
propuesta
para
permitir
que
los
usuarios
m√≥viles
man-


tengan
sus
direcciones
IP
a
medida
que
se
desplazan
entre
redes
ajenas
era
hacer
que


una
red
ajena
anunciara
una
ruta
altamente
espec√≠fica
hacia
el
usuario
m√≥vil
y
usar
la


infraestructura
de
enrutamiento
existente
para
propagar
esta
informaci√≥n
a
trav√©s
de
la


red
.
Para
esta
soluci√≥n
,
ya
dijimos
que
la
escalabilidad
es
un
problema
.
Suponga
que


cuando
un
usuario
m√≥vil
se
desplaza
de
una
red
a
otra
,
la
nueva
red
ajena
anuncia
una


PROBLEMAS
561


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
561ruta
espec√≠fica
hacia
el
usuario
m√≥vil
y
que
la
red
ajena
antigua
retira
su
ruta
.
Con-


sidere
c√≥mo
se
propagar√≠a
la
informaci√≥n
de
enrutamiento
con
un
algoritmo
de
vector


de
distancia
(
particularmente
para
el
caso
de
enrutamiento
entre
dominios
,
entre
redes


que
abarquen
todo
el
globo
terr√°queo
)
.


a.
¬ø
Podr√≠an
otros
routers
ser
capaces
de
enrutar
datagramas
inmediatamente
hacia
la


nueva
red
ajena
,
en
cuanto
la
red
ajena
comience
a
anunciar
su
ruta
?


b.
¬ø
Es
posible
que
los
diferentes
routers
crean
que
el
usuario
m√≥vil
se
encuentra
en


diferentes
redes
ajenas
?


c.
Analice
la
escala
temporal
sobre
la
que
otros
routers
de
la
red
terminar√°n
por
apren-


der
la
ruta
hacia
los
usuarios
m√≥viles
.


P12
.
Suponga
que
el
corresponsal
de
la
Figura
6.22
fuera
m√≥vil
.
Dibuje
la
infraestructura


adicional
de
la
capa
de
red
que
ser√≠a
necesaria
para
enrutar
el
datagrama
desde
el
usua-


rio
m√≥vil
original
hasta
el
(
ahora
m√≥vil
)
corresponsal
.
Muestre
la
estructura
del
da-


tagrama
(
o
de
los
datagramas
)
entre
el
usuario
m√≥vil
original
y
el
(
ahora
m√≥vil
)


corresponsal
,
como
en
la
Figura
6.23
.


P13
.
En
IP
m√≥vil
,
¬ø
qu√©
efecto
tendr√°
la
movilidad
sobre
los
retardos
terminal
a
terminal
de


los
datagramas
enviados
desde
un
origen
a
un
destino
?


P14
.
Considere
el
ejemplo
de
encadenamiento
analizado
al
final
de
la
Secci√≥n
6.7.2
.


Suponga
que
un
usuario
m√≥vil
visita
las
redes
ajenas
A
,
B
y
C
y
que
un
corresponsal


inicia
una
conexi√≥n
con
el
usuario
m√≥vil
cuando
√©ste
reside
en
la
red
ajena
A.
Enumere


la
secuencia
de
mensajes
entre
los
agentes
ajenos
y
entre
esos
agentes
ajenos
y
el
agente


propio
,
a
medida
que
el
usuario
m√≥vil
se
desplaza
desde
la
red
A
a
la
red
B
y
a
la
red


C.
A
continuaci√≥n
,
suponga
que
no
realizamos
el
encadenamiento
y
que
hay
que
noti-


ficar
expl√≠citamente
al
corresponsal
(
as√≠
como
al
agente
propio
)
los
cambios
en
la


direcci√≥n
COA
del
usuario
m√≥vil
.
Enumere
la
secuencia
de
mensajes
que
habr√≠a
que


intercambiar
en
este
segundo
escenario
.


P15
.
Considere
dos
nodos
m√≥viles
en
una
red
ajena
que
dispone
de
un
agente
ajeno
.
¬ø
Es


posible
que
los
dos
nodos
m√≥viles
utilicen
la
misma
direcci√≥n
COA
en
IP
m√≥vil
?


Explique
su
respuesta
.


P16
.
En
nuestro
an√°lisis
de
c√≥mo
el
registro
VLR
actualizaba
el
HLR
con
informaci√≥n


acerca
de
la
ubicaci√≥n
actual
del
m√≥vil
,
¬ø
cu√°les
son
las
ventajas
y
desventajas
de
pro-


porcionar
al
HLR
el
MSRN
en
lugar
de
la
direcci√≥n
del
VLR
?


Preguntas
para
la
discusi√≥n


D1
.
Enumere
cinco
productos
que
est√©n
actualmente
en
el
mercado
y
que
proporcionen


una
interfaz
Bluetooth
802.15
.


D2
.
¬ø
Hay
servicio
inal√°mbrico
3
G
disponible
en
su
regi√≥n
?
¬ø
Qu√©
precio
tiene
?
¬ø
Qu√©
apli-


caciones
soporta
?


D3
.
Como
usuario
de
IEEE
802.11
,
¬ø
qu√©
tipos
de
problemas
ha
observado
?
¬ø
C√≥mo
pue-


den
evolucionar
los
dise√±os
de
802.11
para
solventar
estos
problemas
?


562
CAP√çTULO
6
‚Ä¢
REDES
INAL√ÅMBRICAS
Y
M√ìVILES


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
562D4
.
Realice
una
b√∫squeda
en
la
Web
para
localizar
pruebas
de
implantaci√≥n
de
 
WiMAX
.


¬ø
Qu√©
extensi√≥n
han
tenido
estos
proyectos
piloto
?
¬ø
Qu√©
velocidades
se
han
conse-


guido
y
a
qu√©
distancias
?
¬ø
Con
cu√°ntos
usuarios
?


D5
.
Realice
una
b√∫squeda
en
la
Web
para
ver
implantaciones
de
EVDO
y
HSDPA
.
¬ø
Cu√°l


ha
sido
la
tecnolog√≠a
m√°s
implantada
hasta
la
fecha
?
¬ø
D√≥nde
?


Pr√°cticas
de
laboratorio
con
Wireshark


En
el
sitio
web
del
libro
,
http://www.awl.com/kurose-ross
,
encontrar√°
 
una
pr√°ctica
de
labo-


ratorio
con
Wireshark
para
este
cap√≠tulo
en
la
que
se
capturan
y
analizan
las
tramas
802.11


intercambiadas
entre
una
computadora
port√°til
inal√°mbrica
y
un
punto
de
acceso
.


PR√ÅCTICAS
DE
LABORATORIO
CON
WIRESHARK
563


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
563¬øPor
qu√©
decidi√≥
especializarse
en
tecnolog√≠a
inal√°mbrica
/
m√≥vil
?


Mi
implicaci√≥n
con
las
redes
inal√°mbricas
y
la
movilidad
fue
una
consecuencia
natural
de
mi
trabajo


en
proyectos
del
departamento
de
investigaci√≥n
de
IBM
a
finales
de
la
d√©cada
de
1980
.
Dispon√≠amos


de
enlaces
v√≠a
radio
y
est√°bamos
intentando
construir
un
tipo
de
dispositivo
al
estilo
del
‚Äú
ThinkPad
‚Äù


(
como
Palm
Pilot
)
con
conectividad
inal√°mbrica
y
reconocimiento
de
escritura
manuscrita
.


Desarrollamos
una
soluci√≥n
simple
(
posteriormente
denominada
IP
m√≥vil
)
y
nos
dimos
cuenta
de


que
funcionaba
.
Utilizando
nuestra
experiencia
con
IP
m√≥vil
,
desarrollamos
una
modificaci√≥n
r√°pida


y
efectiva
de
RIP
que
permit√≠a
construir
redes
ad
hoc
.
Esto
tambi√©n
funcion√≥
muy
bien
.
Al
decir
que


‚Äú
funcion√≥
‚Äù
,
quiero
decir
que
las
aplicaciones
funcionaban
perfectamente
sin
ninguna
modificaci√≥n
y


que
la
red
no
se
ven√≠a
abajo
a
causa
de
los
nuevos
dise√±os
.
Estas
propiedades
son
las
que
se
suelen


denominar
‚Äú
transparencia
de
aplicaci√≥n
‚Äù
y
‚Äú
escalabilidad
‚Äù
.


Por
supuesto
,
el
trabajo
en
un
laboratorio
es
enormemente
distinto
del
√©xito
comercial
,
y
estas
dos


tecnolog√≠as
tienen
todav√≠a
un
gran
potencial
comercial
que
no
se
ha
visto
satisfecho
.


564


Charlie
Perkins


Charles
E.
Perkins
es
Technical
Fellow
en
WiChorus
,
donde
se


dedica
a
investigar
nuevas
t√©cnicas
para
la
aplicaci√≥n
de


protocolos
de
gesti√≥n
de
la
movilidad
en
Internet
a
nuevas


generaciones
de
medios
inal√°mbricos
,
como
WiMAX
y
LTE
.


Estas
tecnolog√≠as
ya
han
comenzado
a
hacer
que
las
conexio-


nes
inal√°mbricas
de
banda
ancha
sean
una
realidad
,
abriendo


nuevas
oportunidades
para
la
expansi√≥n
de
Internet
y
para
el


suministro
de
contenido
multimedia
a
la
carta
.
Es
el
editor


documental
del
grupo
de
trabajo
de
IP
m√≥vil
del
IETF
(
Internet


Engineering
Task
Force
)
,
autor
o
co-autor
de
documentos
de


estandarizaci√≥n
en
los
grupos
de
trabajo
mip4
,
mip6
,
manet
,
mext
,
dhc
,
seamoby
(
movilidad


transparente
)
y
autoconf
,
y
es
editor
de
diversas
revistas
de
la
ACM
y
el
IEEE
relacionadas
con


las
redes
inal√°mbricas
.
En
WiChorus
,
ha
continuado
su
implicaci√≥n
en
desarrollos
avanzados


que
emplean
IP
m√≥vil
,
IPv6
y
otros
protocolos
basados
en
los
trabajos
del
IETF
.
Ha
sido
autor
y


editor
de
libros
sobre
IP
m√≥vil
y
redes
ad
hoc
,
y
ha
publicado
diversos
art√≠culos
,
algunos
de


ellos
premiados
,
en
las
√°reas
de
redes
m√≥viles
,
redes
ad
hoc
,
optimizaci√≥n
de
rutas
para
redes


m√≥viles
,
descubrimiento
de
recursos
y
configuraci√≥n
autom√°tica
para
computadoras
m√≥viles
.
Es


uno
de
los
creadores
de
MobiHoc
y
ha
actuado
como
General
Chair
y
Program
Committee


Chair
.
Ha
participado
en
el
Consejo
de
Arquitectura
Internet
del
IETF
y
en
varios
comit√©s
para


el
Consejo
Nacional
de
Investigaci√≥n
de
los
Estados
Unidos
,
y
tambi√©n
ha
formado
parte
de


diversos
paneles
de
evaluaci√≥n
t√©cnica
para
el
Laboratorio
de
Investigaci√≥n
del
Ej√©rcito
y
el


programa
 
MICS
suizo
.
M√°s
recientemente
,
ha
actuado
como
General
Chair
en
la
conferencia


WiNS-DR
y
de
MASS
2006
.


UNA
ENTREVISTA
CON
...


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
564¬øCu√°l
fue
su
primer
trabajo
en
la
industria
de
las
computadoras
?


Trabaj√©
en
TRW
Controls
,
en
Houston
,
Texas
.
Fue
un
cambio
bastante
dr√°stico
con
respecto
a
los
estu-


dios
universitarios
.


Una
cosa
que
aprend√≠
en
TRW
Controls
es
lo
pobre
que
es
el
software
de
soporte
incluso
para
los


sistemas
de
control
de
utilidades
m√°s
cr√≠ticos
.
Se
supone
que
estos
sistemas
deb√≠an
controlar
el
flujo


de
electricidad
en
enormes
redes
el√©ctricas
,
y
el
software
subyacente
era
desarrollado
de
una
manera


que
pon√≠a
los
pelos
de
punta
.
Adem√°s
,
los
planes
de
desarrollo
ten√≠an
siempre
unos
tiempos
muy
apre-


tados
y
los
programadores
eran
enormemente
c√≠nicos
acerca
de
las
intenciones
de
la
direcci√≥n
y
de
las


condiciones
de
trabajo
.


El
sistema
completo
necesitaba
ser
redise√±ado
desde
el
principio
.
No
tengo
muchas
razones
para


creer
que
las
cosas
hayan
cambiado
durante
los
√∫ltimos
30
a√±os
,
especialmente
dadas
la
recientes
noti-


cias
acerca
del
apag√≥n
de
2003
.
De
hecho
,
dada
la
desregulaci√≥n
que
ha
vivido
el
sector
,
estoy
seguro


de
que
las
cosas
son
todav√≠a
peor
de
como
las
recuerdo
.


Me
satisfizo
mucho
dejar
TRW
Controls
y
entrar
a
trabajar
en
Tektronix
(
Tek
Labs
)
.


¬ø
Cu√°l
es
la
parte
de
su
trabajo
que
constituye
un
mayor
desaf√≠o
?


El
mayor
reto
de
mi
trabajo
es
comprender
qu√©
es
lo
que
debo
hacer
para
ayudar
a
mi
empresa
.


Asimismo
,
considero
parte
de
mi
trabajo
dar
forma
a
las
tecnolog√≠as
inal√°mbricas
con
las
que
entro
en


contacto
,
para
que
puedan
proporcionar
un
mejor
servicio
y
una
experiencia
cotidiana
m√°s
agradable


a
la
gente
.
El
negocio
de
mi
empresa
consiste
en
proporcionar
equipos
de
infraestructura
para
la
conec-


tividad
inal√°mbrica
de
alta
velocidad
.
Adem√°s
de
hacer
evolucionar
los
documentos
de
estandarizaci√≥n


relevantes
,
espero
encontrar
formas
de
simplificar
los
sistemas
resultantes
aplicando
las
diversas
t√©c-


nicas
relacionadas
con
los
trabajos
del
IETF
.
Hacer
esto
de
una
forma
que
permita
tambi√©n
maximizar


el
beneficio
potencial
de
las
tecnolog√≠as
que
desarrollamos
convierte
cada
d√≠a
en
un
nuevo
desaf√≠o
.
Son


muchas
las
cosas
que
hay
que
hacer
y
las
oportunidades
son
inmensas
.


Au
n
 
n
i
v
e
l
 
t
√©
c
n
i
c
o
 
m
√°
s
 
d
e
t
a
l
l
a
d
o
,
 
e
n
 
e
l
 
q
u
e
 
p
o
r
 
c
i
e
r
t
o
 
m
e
 
e
n
c
u
e
n
t
r
o
 
m
u
c
h
o
 
m
√°
s
 
c
√≥
m
o
d
o
,
 
t
r
a
t
o
 
d
e


resolver
problemas
de
los
protocolos
de
red
de
forma
que
impongan
la
menor
carga
posible
a
los
dis-


positivos
inal√°mbricos
(
¬°
y
a
sus
bater√≠as
!
)
y
que
presenten
a
los
usuarios
las
m√≠nimas
incomodidades


posibles
.
Interconectar
los
dispositivos
inal√°mbricos
actuales
con
Internet
mediante
las
nuevas
tecno-


log√≠as
inal√°mbricas
de
alta
velocidad
es
enormemente
interesante
desde
el
punto
de
vista
t√©cnico
y


ofrece
un
potencial
ilimitado
para
el
√©xito
comercial
para
aqu√©llos
que
puedan
encontrar
la
manera


correcta
de
proseguir
los
desarrollos
.
Adem√°s
,
ahora
estamos
comenzando
a
enfrentarnos
a
un
intere-


sante
desaf√≠o
,
a
medida
que
nuestro
espacio
de
direcciones
IPv4
subyacente
se
empieza
a
agotar
,


previ√©ndose
que
ese
agotamiento
tendr√°
lugar
en
los
pr√≥ximos
dos
o
tres
a√±os
.
IPv6
ha
resultado
bas-


tante
m√°s
dif√≠cil
de
implantar
de
lo
que
se
predijo
hace
diez
a√±os
,
a√∫n
cuando
las
especificaciones
b√°si-


cas
est√©n
bastante
maduras
.


¬ø
Cu√°l
cree
que
es
el
futuro
de
la
tecnolog√≠a
inal√°mbrica
?


Toda
la
industria
inal√°mbrica
est√°
sufriendo
un
tremendo
cambio
y
nadie
sabe
cu√°l
puede
ser
el
fin
.


Est√°n
emergiendo
tecnolog√≠as
inal√°mbricas
de
alta
velocidad
y
pueden
tener
efectos
pr√°cticos
no
pre-


vistos
que
podr√≠an
cambiar
de
forma
importante
nuestra
sociedad
.
Nuestras
actuales
expectativas
acer-


ca
de
la
intimidad
y
las
limitaciones
en
nuestra
capacidad
de
comunicarnos
unos
con
otros
(
voz
,
im√°-


genes
y
datos
)
,
podr√≠an
ser
irreconocibles
dentro
de
diez
a√±os
.
A
medida
que
las
empresas
se
vayan


convirtiendo
m√°s
y
m√°s
a
las
comunicaciones
inal√°mbricas
,
resulta
bastante
posible
que
se
tomen
nue-


vas
medidas
de
seguridad
que
cambiar√°n
significativamente
nuestra
experiencia
de
trabajo
.


Parece
bastante
claro
que
se
asignar√°n
m√°s
partes
del
espectro
a
los
distintos
esquemas
de
las


comunicaciones
por
radio
.
Los
nuevos
esquemas
pueden
tener
una
muy
alta
velocidad
.
Hay
comuni-


dades
que
han
hecho
experimentos
de
ofrecer
a
sus
ciudadanos
m√°s
y
m√°s
comunicaciones
inal√°m-


bricas
de
alta
velocidad
;
una
ciudad
completa
podr√≠a
convertirse
en
una
red
inal√°mbrica
de
√°rea
local
.


565


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
565Esto
podr√≠a
tener
el
efecto
de
reforzar
el
sentimiento
de
comunidad
que
se
ha
perdido
hace
mucho
en


nuestra
sociedad
,
al
menos
en
Estados
Unidos
.
Por
supuesto
,
la
comunidad
seguir√°
demandando
acce-


so
a
Internet
.
La
capacidad
de
disco
est√°
creciendo
tan
r√°pidamente
y
a
precios
tan
econ√≥micos
,
que
ya


podemos
llevar
en
nuestros
bolsillos
toda
la
Wikipedia
y
probablemente
todos
los
n√∫mero
de
tel√©fono


del
mundo
,
por
no
mencionar
bibliotecas
personales
sin
precedentes
llenas
de
libros
,
m√∫sica
y
pel√≠cu-


las
.


La
tecnolog√≠a
inal√°mbrica
est√°
acelerando
el
crecimiento
de
Internet
.
A
medida
que
se
abaratan


los
dispositivos
inal√°mbricos
,
estamos
viendo
comunicaciones
Internet
por
todas
partes
(
pendientes
,


juegos
multijugador
,
lectores
de
billetes
en
el
metro
)
.
Esto
est√°
motivando
la
aparici√≥n
de
nuevas
apli-


caciones
y
nuevas
soluciones
de
seguridad
.


566


M06_KURO9675_05_SE_CH06.qxd
 
22/3/10
 
09:57
 
P√°gina
566CAP√çTULO
7


Redes


multimedia


567


Actualmente
estamos
siendo
testigos
de
la
amplia
implantaci√≥n
de
aplicaciones
de
audio
y


v√≠deo
en
Internet
.
Cientos
de
sitios
,
entre
los
que
se
incluyen
CCN
,
Rhapsody
,
Napster
,


MSN
,
AOL
,
Yahoo
!
,
ponen
a
nuestra
disposici√≥n
flujos
con
contenido
de
audio
y
v√≠deo
.
You-


Tube
y
otros
sitios
de
compartici√≥n
de
v√≠deo
permiten
a
los
usuarios
utilizar
(
bajo
demanda
)


clips
de
v√≠deo
que
han
sido
cargados
por
otros
usuarios
.
Millones
de
usuarios
utilizan
de


forma
regular
Skype
para
cubrir
sus
necesidades
de
telefon√≠a
y
de
videoconferencia
.
Y
algu-


nos
canales
de
televisi√≥n
tradicionales
ahora
est√°n
distribuyendo
a
trav√©s
de
Internet
,
permi-


tiendo
a
los
usuarios
de
Internet
ver
canales
de
televisi√≥n
que
tienen
su
origen
en
todos
los


rincones
del
mundo
.
Este
explosivo
crecimiento
de
las
aplicaciones
multimedia
en
Internet


es
principalmente
el
resultado
de
la
creciente
penetraci√≥n
del
acceso
residencial
a
la
banda


ancha
y
el
acceso
inal√°mbrico
de
alta
velocidad
(
como
por
ejemplo
WiFi
)
.
Como
hemos


visto
en
la
Secci√≥n
1.2
,
las
velocidades
de
acceso
de
banda
ancha
continuar√°n
aumentando
,


animando
a√∫n
m√°s
la
implantaci√≥n
de
nuevas
y
excitantes
aplicaciones
multimedia
.


Los
requisitos
de
servicio
de
las
aplicaciones
multimedia
difieren
significativamente
de


los
de
las
aplicaciones
el√°sticas
tradicionales
,
como
el
correo
electr√≥nico
,
la
navegaci√≥n
por


la
Web
,
los
inicios
de
sesi√≥n
remotos
y
la
descarga
y
compartici√≥n
de
archivos
(
que
hemos


estudiado
en
el
Cap√≠tulo
2
)
.
En
particular
,
a
diferencia
de
las
aplicaciones
el√°sticas
,
las
apli-


caciones
multimedia
son
extremadamente
sensibles
a
los
retardos
terminal
a
terminal
y
a
la


variaci√≥n
del
retardo
,
aunque
pueden
tolerar
p√©rdidas
de
datos
ocasionales
.


Comenzaremos
este
cap√≠tulo
con
una
taxonom√≠a
de
las
aplicaciones
multimedia
en
la


Secci√≥n
7.1
.
Veremos
que
una
aplicaci√≥n
multimedia
puede
clasificarse
como
flujo
de


audio
/
v√≠deo
almacenado
,
flujo
de
audio
/
v√≠deo
en
vivo
o
audio
/
v√≠deo
interactivo
en
tiempo


real
.
Adem√°s
,
veremos
que
cada
una
de
estas
clases
de
aplicaci√≥n
tiene
un
conjunto
dife-


rente
de
requisitos
de
servicio
para
la
red
.
En
la
Secci√≥n
7.2
,
examinaremos
los
flujos
de


audio
/
v√≠deo
almacenado
.
En
la
Secci√≥n
7.3
,
investigaremos
las
t√©cnicas
de
nivel
de
aplica-


ci√≥n
que
pueden
mejorar
el
rendimiento
de
las
aplicaciones
multimedia
dentro
del
servicio


de
mejor
esfuerzo
de
la
red
Internet
actual
y
,
en
la
Secci√≥n
7.4
,
nos
ocuparemos
de
varios


protocolos
multimedia
que
se
emplean
actualmente
en
Internet
.
En
la
Secci√≥n
7.5
,
investi-


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
567garemos
mecanismos
de
la
red
que
pueden
utilizarse
para
diferenciar
una
clase
de
tr√°fico


(
por
ejemplo
,
aplicaciones
tolerantes
al
retardo
tales
como
las
multimedia
)
de
otra
(
por


ejemplo
,
aplicaciones
el√°sticas
como
FTP
)
,
y
proporcionaremos
un
servicio
diferenciado


entre
las
diversas
clases
de
tr√°fico
.
Por
√∫ltimo
,
en
la
Secci√≥n
7.6
,
consideraremos
el
caso
en


el
que
la
red
debe
proporcionar
garant√≠as
de
rendimiento
a
las
aplicaciones
;
por
ejemplo
,


que
una
llamada
telef√≥nica
IP
basada
en
paquetes
obtenga
el
mismo
rendimiento
que
si
la


llamada
se
hiciera
a
trav√©s
de
una
red
telef√≥nica
de
conmutaci√≥n
de
circuitos
.
Veremos
que


esto
requiere
la
introducci√≥n
de
nuevos
mecanismos
y
protocolos
de
red
.


7.1
Aplicaciones
de
redes
multimedia


En
nuestra
exposici√≥n
del
Cap√≠tulo
2
acerca
de
los
requisitos
de
servicio
de
las
aplicaciones


identificamos
una
serie
de
ejes
a
lo
largo
de
los
cuales
pueden
clasificarse
estos
requisitos
.


Dos
de
estos
ejes
(
consideraciones
sobre
temporizaci√≥n
y
tolerancia
a
la
p√©rdida
de
datos
)


son
particularmente
importantes
para
las
aplicaciones
multimedia
en
red
.
Las
consideracio-


nes
sobre
temporizaci√≥n
son
importantes
porque
muchas
aplicaciones
multimedia
son
extre-


madamente
sensibles
a
los
retardos
.
Veremos
enseguida
que
en
muchas
aplicaciones


multimedia
los
paquetes
que
sufren
un
retardo
emisor-receptor
de
m√°s
de
unos
pocos
cien-


tos
de
milisegundos
resultan
in√∫tiles
para
el
receptor
.
Por
otro
lado
,
las
aplicaciones
multi-


media
de
red
casi
siempre
son
tolerantes
a
las
p√©rdidas
(
las
p√©rdidas
ocasionales
s√≥lo


causan
fallos
ocasionales
en
la
reproducci√≥n
del
audio
/
v√≠deo
y
estas
p√©rdidas
a
menudo
pue-


den
ser
parcial
o
totalmente
disimuladas
)
.
Estas
caracter√≠sticas
de
sensibilidad
a
los
retardos


y
tolerancia
a
las
p√©rdidas
son
claramente
diferentes
de
las
correspondientes
relativas
a
las


aplicaciones
el√°sticas
como
la
Web
,
el
correo
electr√≥nico
,
FTP
y
Telnet
.
En
las
aplicaciones


el√°sticas
,
los
retardos
largos
son
molestos
aunque
no
especialmente
da√±inos
,
pero
la
com-


pletitud
y
la
integridad
de
los
datos
transferidos
son
de
suma
importancia
.


7.1.1
Ejemplos
de
aplicaciones
multimedia


Internet
puede
soportar
una
amplia
variedad
de
atractivas
aplicaciones
multimedia
.
En
esta


subsecci√≥n
vamos
a
considerar
tres
clases
generales
de
aplicaciones
multimedia
:
los
flujos


de
audio
/
v√≠deo
almacenado
,
los
flujos
de
audio
/
v√≠deo
en
vivo
y
el
audio
/
v√≠deo
interactivo
en


tiempo
real
.


En
este
cap√≠tulo
no
vamos
a
ocuparnos
de
las
aplicaciones
que
se
descargan
y
luego
se


reproducen
,
como
por
ejemplo
la
descarga
completa
de
un
archivo
MP3
mediante
una
apli-


caci√≥n
de
compartici√≥n
de
archivos
P2P
antes
de
reproducirlo
.
De
hecho
,
las
aplicaciones


que
se
descargan
y
luego
se
reproducen
son
aplicaciones
el√°sticas
de
transferencia
de
archi-


vos
sin
ning√∫n
requisito
especial
de
retardo
.
En
el
Cap√≠tulo
2
ya
hemos
examinado
la
trans-


ferencia
de
archivos
(
HTTP
y
FTP
)
y
los
sistemas
de
compartici√≥n
de
archivos
P2P.


Flujos
de
audio
y
v√≠deo
almacenado


En
esta
clase
de
aplicaciones
,
los
clientes
solicitan
archivos
de
audio
o
de
v√≠deo
comprimidos


bajo
demanda
que
est√°n
almacenados
en
servidores
.
Hoy
d√≠a
existen
miles
de
sitios
que
pro-


porcionan
flujos
de
audio
y
de
v√≠deo
almacenado
,
entre
los
que
se
incluyen
CNN
,
Microsoft


Video
y
YouTube
.
Este
tipo
de
aplicaciones
presentan
tres
caracter√≠sticas
diferenciadoras
:


568
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
568‚Ä¢
Medios
almacenados
.
El
contenido
multimedia
,
que
ha
sido
pregrabado
,
se
almacena
en


un
servidor
.
Puesto
que
el
contenido
est√°
pregrabado
,
el
usuario
en
el
cliente
puede
pau-


sar
,
rebobinar
,
pasar
hacia
adelante
o
buscar
en
el
contenido
multimedia
.
El
instante


desde
que
el
usuario
hace
una
de
estas
solicitudes
hasta
que
la
acci√≥n
tiene
lugar
en
el


cliente
debe
ser
del
orden
de
uno
a
diez
segundos
para
ser
una
respuesta
aceptable
.


‚Ä¢
Flujos
.
En
una
aplicaci√≥n
de
flujo
de
audio
/
v√≠deo
almacenado
,
normalmente
un
cliente


inicia
la
reproducci√≥n
del
audio
/
v√≠deo
y
unos
pocos
segundos
despu√©s
comienza
a
recibir


el
archivo
procedente
del
servidor
.
Esto
significa
que
el
cliente
reproducir√°
el
audio/


7.1
‚Ä¢
APLICACIONES
DE
REDES
MULTIMEDIA
569


IPTV


Tradicionalmente
,
el
contenido
de
televisi√≥n
ha
sido
distribuido
mediante
microondas
terres-


tres
,
sistemas
h√≠bridos
de
fibra
y
cable
coaxial
(
HFC
)
y
canales
de
sat√©lites
geoestacionarios


(
v√©ase
la
Secci√≥n
1.2
)
.
Pero
en
la
√©poca
actual
de
Internet
existe
un
tremendo
inter√©s
en
la


IPTV
;
es
decir
,
la
distribuci√≥n
del
contenido
de
televisi√≥n
a
trav√©s
de
Internet
.


Uno
de
los
desaf√≠os
de
la
tecnolog√≠a
IPTV
es
la
gran
cantidad
de
ancho
de
banda
necesa-


rio
,
especialmente
en
el
servidor
de
origen
.
Por
ejemplo
,
considere
la
distribuci√≥n
de
un


evento
deportivo
importante
,
como
el
partido
de
la
Copa
del
Mundo
,
desde
un
√∫nico
servidor


a
100
millones
de
usuarios
concurrentes
a
trav√©s
de
Internet
.
Si
la
velocidad
de
v√≠deo
es
s√≥lo


de
1
Mbps
,
entonces
el
ancho
de
banda
requerido
del
servidor
ser√≠a
del
orden
de
100
tera-


bits
/
segundo
.
Por
tanto
,
la
cl√°sica
distribuci√≥n
cliente-servidor
es
completamente
inaceptable
.


Si
la
multidifusi√≥n
IP
estuviera
ampliamente
implantada
en
Internet
ser√≠a
mucho
m√°s
f√°cil


hacer
de
IPTV
una
realidad
.
Otra
alternativa
es
distribuir
el
v√≠deo
a
trav√©s
de
una
red
sola-


pada
de
multidifusi√≥n
,
tal
como
las
proporcionadas
por
las
redes
de
distribuci√≥n
de
contenido


(
CDN
,
Content
Distribution
Network
)
(
v√©ase
la
Secci√≥n
7.3
)
.


Otra
alternativa
m√°s
ser√≠a
emplear
la
distribuci√≥n
entre
pares
,
donde
cada
par
que
recibe


un
canal
de
televisi√≥n
tambi√©n
ayuda
a
redistribuir
el
canal
a
otros
pares
.
Quiz√°
el
mayor


atractivo
de
esta
t√©cnica
es
el
bajo
coste
de
distribuci√≥n
:
si
los
pares
individuales
proporcio-


nan
colectivamente
el
suficiente
ancho
de
banda
de
carga
,
es
posible
que
se
necesite
poco


ancho
de
banda
en
el
servidor
(
quiz√°
s√≥lo
unas
cuantas
veces
la
velocidad
de
v√≠deo
)
.


Con
un
coste
tan
bajo
,
cualquier
usuario
equipado
con
una
c√°mara
web
podr√≠a
distribuir


un
programa
en
vivo
a
millones
de
usuarios
a
un
coste
despreciable
.


Hasta
la
fecha
,
una
serie
de
sistemas
de
IPTV
P2P
similares
a
BitTorrent
han
disfrutado
de


una
exitosa
implantaci√≥n
.
El
pionero
en
este
campo
,
CoolStreaming
,
ten√≠a
m√°s
de
4.000


usuarios
simult√°neos
en
2003
[
CoolStreaming
2005
]
.
M√°s
recientemente
,
otros
sistemas
,


entre
los
que
se
incluyen
PPLive
y
ppstream
,
han
informado
de
grandes
√©xitos
,
con
decenas


de
miles
de
usuarios
simult√°neos
viendo
canales
a
velocidades
de
entre
300
kbps
y
1
Mbps
.


En
estos
sistemas
de
tipo
BitTorrent
,
los
pares
forman
una
red
solapada
din√°mica
e
intercam-


bian
fragmentos
de
v√≠deo
con
sus
vecinos
de
red
.
Ser√°
interesante
ver
c√≥mo
evoluciona
IPTV


en
los
pr√≥ximos
5
a10
a√±os
.
¬ø
Qu√©
tecnolog√≠a
subyacente
utilizar√°
:
CDN
o
P2P
,
o
alguna
que


sea
un
h√≠brido
de
ambas
?
¬ø
Habr√°
una
parte
significativa
de
los
aficionados
a
la
Copa
del


Mundo
que
vean
los
partidos
a
trav√©s
de
Internet
en
2014
?


HISTORIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
569v√≠deo
desde
una
posici√≥n
del
archivo
mientras
est√°
recibiendo
del
servidor
partes
poste-


riores
del
mismo
.
Esta
t√©cnica
,
conocida
como
transmisi√≥n
de
flujos
,
evita
descargar
el


archivo
completo
(
e
incurrir
en
un
retardo
potencialmente
largo
)
antes
de
comenzar
la


reproducci√≥n
.
Existen
muchos
clientes
para
la
reproducci√≥n
de
flujos
multimedia
como


RealPlayer
de
RealNetworks
[
RealNetworks
2009
]
,
QuickTime
de
Apple
[
QuickTime


2009
]
,
y
Windows
Media
de
Microsoft
[
Microsoft
Media
Player
2009
]
.


‚Ä¢
Reproducci√≥n
continua
.
Una
vez
que
se
inicia
la
reproducci√≥n
del
contenido
multimedia


deber√≠a
proseguir
de
acuerdo
con
la
temporizaci√≥n
original
de
la
grabaci√≥n
.
Por
tanto
,


los
datos
deben
recibirse
del
servidor
a
tiempo
para
su
reproducci√≥n
en
el
cliente
;
si
no


es
as√≠
,
el
usuario
experimentar√°
frustrantes
retardos
de
almacenamiento
en
buffer
.
Aun-


que
las
aplicaciones
multimedia
almacenadas
tienen
que
cumplir
los
requisitos
de
repro-


ducci√≥n
continua
,
sus
restricciones
de
retardo
terminal
a
terminal
son
menos
restrictivas


que
las
de
las
aplicaciones
interactivas
en
vivo
,
como
la
telefon√≠a
y
la
videoconferencia


por
Internet
(
v√©ase
m√°s
adelante
)
.


Flujos
de
audio
y
v√≠deo
en
vivo


Este
tipo
de
aplicaciones
es
similar
a
la
difusi√≥n
tradicional
de
radio
y
televisi√≥n
,
excepto


porque
la
transmisi√≥n
tiene
lugar
a
trav√©s
de
Internet
.
Estas
aplicaciones
permiten
a
un
usua-


rio
recibir
una
transmisi√≥n
de
radio
o
televisi√≥n
en
vivo
emitida
desde
cualquier
rinc√≥n
del


mundo
.
(
Por
ejemplo
,
uno
de
los
autores
de
este
libro
con
frecuencia
escucha
su
emisora
de


radio
favorita
de
Filadelfia
cuando
viaja
.
El
otro
autor
normalmente
escuchaba
las
difusio-


nes
en
vivo
de
los
partidos
de
su
muy
querido
equipo
de
baloncesto
de
la
universidad
cuando


estuvo
viviendo
en
Francia
durante
un
a√±o
.
)
Estas
aplicaciones
se
conocen
como
IPTV
y


radio
por
Internet
.
Hoy
d√≠a
,
existen
miles
de
emisoras
de
radio
que
emiten
a
trav√©s
de
Inter-


net
y
un
gran
n√∫mero
de
implantaciones
de
IPTV
(
v√©ase
el
recuadro
dedicado
a
IPTV
)
.


Dado
que
los
flujos
de
audio
/
v√≠deo
en
vivo
no
est√°n
almacenados
,
un
cliente
no
puede


hacer
un
avance
r√°pido
del
medio
.
Sin
embargo
,
con
el
almacenamiento
local
de
los
datos


recibidos
otras
operaciones
interactivas
tales
como
la
puesta
en
pausa
o
el
rebobinado
s√≠
son


posibles
.
Las
aplicaciones
en
vivo
de
tipo
difusi√≥n
a
menudo
tienen
muchos
clientes
que


reciben
el
mismo
programa
de
audio
/
v√≠deo
.
La
distribuci√≥n
de
audio
/
v√≠deo
en
vivo
a
muchos


receptores
puede
llevarse
a
cabo
de
forma
eficiente
mediante
las
t√©cnicas
de
multidifusi√≥n


IP
descritas
en
la
Secci√≥n
4.7
.
Sin
embargo
,
actualmente
la
distribuci√≥n
de
audio
/
v√≠deo
en


vivo
suele
conseguirse
a
trav√©s
de
flujos
de
multidifusi√≥n
de
la
capa
de
aplicaci√≥n
(
utili-


zando
P2P
o
CDN
)
o
a
trav√©s
de
m√∫ltiples
flujos
de
unidifusi√≥n
servidor-cliente
separados
.


Al
igual
que
con
los
flujos
multimedia
almacenados
se
requiere
reproducci√≥n
continua
,
aun-


que
las
restricciones
de
temporizaci√≥n
son
menos
estrictas
que
para
las
aplicaciones
interac-


tivas
en
tiempo
real
.
Pueden
tolerarse
retardos
de
hasta
decenas
de
segundos
desde
el


momento
en
que
el
usuario
solicita
el
suministro
/
reproducci√≥n
de
una
transmisi√≥n
en
vivo


hasta
que
comienza
la
reproducci√≥n
.


Audio
y
v√≠deo
interactivo
en
tiempo
real


Este
tipo
de
aplicaciones
permite
a
los
usuarios
emplear
el
audio
y
el
v√≠deo
para
comuni-


carse
entre
s√≠
en
tiempo
real
.
El
audio
interactivo
en
tiempo
real
a
trav√©s
de
Internet
suele


referirse
como
telefon√≠a
por
Internet
,
ya
que
,
desde
la
perspectiva
del
usuario
,
es
similar
al


servicio
de
telefon√≠a
de
conmutaci√≥n
de
circuitos
tradicional
.
La
telefon√≠a
por
Internet
puede


proporcionar
centrales
telef√≥nicas
PBX
(
Private
Branch
Exchange
)
y
servicios
telef√≥nicos


570
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
570locales
y
de
larga
distancia
a
un
coste
muy
bajo
.
Tambi√©n
puede
facilitar
la
implantaci√≥n
de


nuevos
servicios
que
las
redes
tradicionales
de
conmutaci√≥n
de
circuitos
no
soportan
f√°cil-


mente
,
como
por
ejemplo
la
detecci√≥n
de
presencia
,
la
comunicaci√≥n
en
grupo
,
el
filtrado
de


llamantes
,
la
integraci√≥n
telefon√≠a-Web
y
muchos
m√°s
.
Actualmente
hay
disponibles
nume-


rosos
productos
de
tele-fon√≠a
Internet
.
Por
ejemplo
,
los
usuarios
de
Skype
pueden
realizar


llamadas
de
voz
PC-a-tel√©fono
y
PC-a-PC
.
Con
el
v√≠deo
interactivo
en
tiempo
real
,
tambi√©n


denominado
videoconferencia
,
los
individuos
pueden
comunicarse
de
forma
visual
y
oral
.


Actualmente
tambi√©n
hay
disponibles
muchos
productos
de
v√≠deo
interactivo
en
tiempo
real


para
Internet
,
entre
los
que
se
incluyen
NetMeeting
de
Microsoft
,
v√≠deo
Skype
y
diversos


productos
de
Polycom
.
Observe
que
en
una
aplicaci√≥n
de
audio
/
v√≠deo
interactivo
en
tiempo


real
un
usuario
puede
hablar
o
mover
la
cabeza
en
cualquier
momento
.
En
una
conversaci√≥n


con
interacci√≥n
entre
varios
interlocutores
,
el
retardo
desde
que
un
usuario
habla
o
se
mueve


hasta
que
la
acci√≥n
se
manifiesta
en
los
hosts
receptores
debe
ser
menor
que
unos
pocos


cientos
de
milisegundos
.
En
el
caso
de
voz
,
los
retardos
menores
de
50
milisegundos
no
son


percibidos
por
el
o√≠do
humano
,
los
retardos
comprendidos
entre
150
y
400
milisegundos


pueden
ser
aceptables
y
los
retardos
mayores
de
400
milisegundos
pueden
dar
lugar
a
con-


versaciones
frustrantes
,
si
no
completamente
ininteligibles
.


7.1.2
Obst√°culos
para
la
informaci√≥n
multimedia


en
la
Internet
actual


Recuerde
que
el
protocolo
IP
implantado
en
la
red
Internet
actual
proporciona
un
servicio


de
mejor
esfuerzo
a
todos
los
datagramas
que
transporta
.
En
otras
palabras
,
Internet
hace


todo
lo
posible
por
trasladar
cada
datagrama
desde
el
emisor
al
receptor
tan
r√°pido
como
es


posible
,
pero
no
promete
nada
sobre
el
retardo
terminal
a
terminal
que
puede
sufrir
un


paquete
individual
.
Ni
tampoco
hace
ninguna
promesa
acerca
de
la
variaci√≥n
del
retardo
de


paquete
dentro
de
un
flujo
de
paquetes
.
Puesto
que
TCP
y
UDP
se
ejecutan
sobre
IP
,
se


deduce
que
ninguno
de
estos
protocolos
de
transporte
proporciona
ninguna
garant√≠a
de


retardo
a
las
aplicaciones
que
los
invocan
.
Debido
a
la
falta
de
un
esfuerzo
especial
por


entregar
los
paquetes
a
tiempo
,
es
un
problema
extremadamente
desafiante
desarrollar
apli-


caciones
de
red
multimedia
de
√©xito
para
Internet
.
No
obstante
,
hasta
la
fecha
,
las
aplicacio-


nes
multimedia
en
Internet
han
alcanzado
un
notable
√©xito
.
Por
ejemplo
,
los
flujos
de
audio


y
de
v√≠deo
almacenado
con
retardos
de
interactividad
con
el
usuario
de
entre
5
y
10
segun-


dos
son
actualmente
habituales
en
Internet
.
Pero
durante
los
periodos
de
pico
de
tr√°fico
,
el


rendimiento
puede
ser
insatisfactorio
,
especialmente
cuando
los
enlaces
intervinientes
est√°n


congestionados
(
como
los
enlaces
transoce√°nicos
congestionados
)
.


El
v√≠deo
interactivo
en
tiempo
real
y
la
telefon√≠a
por
Internet
han
encontrado
tambi√©n


un
amplio
uso
;
por
ejemplo
,
de
forma
rutinaria
hay
m√°s
de
siete
millones
de
usuarios
de


Skype
en
l√≠nea
en
un
instante
de
tiempo
determinado
.
Las
aplicaciones
de
v√≠deo
y
voz
inte-


ractivas
en
tiempo
real
imponen
estrictas
restricciones
sobre
el
retardo
y
la
fluctuaci√≥n
de


los
paquetes
.
La
fluctuaci√≥n
de
paquetes
(
packet
jitter
)
es
la
variabilidad
de
los
retardos
de


los
paquetes
dentro
del
mismo
flujo
de
paquetes
.
Las
aplicaciones
de
voz
y
v√≠deo
en
tiempo


real
pueden
funcionar
bien
cuando
el
ancho
de
banda
est√°
completamente
disponible
y
,
por


tanto
,
el
retardo
y
la
fluctuaci√≥n
son
m√≠nimos
.
Pero
la
calidad
puede
deteriorarse
hasta
unos


niveles
inaceptables
tan
pronto
como
el
flujo
de
paquetes
de
voz
o
de
v√≠deo
en
tiempo
real


llegan
a
un
enlace
moderadamente
congestionado
.


El
dise√±o
de
aplicaciones
multimedia
podr√≠a
ser
realmente
m√°s
sencillo
si
existieran


servicios
Internet
de
primera
y
segunda
clase
,
en
los
que
los
paquetes
de
primera
clase
estu-


7.1
‚Ä¢
APLICACIONES
DE
REDES
MULTIMEDIA
571


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
571vieran
limitados
en
n√∫mero
y
recibieran
un
servicio
de
prioridad
en
las
colas
de
los
routers
.


Una
servicio
de
primera
clase
de
este
tipo
podr√≠a
ser
satisfactorio
para
las
aplicaciones
sen-


sibles
al
retardo
.
Pero
,
hasta
la
fecha
,
Internet
emplea
casi
siempre
un
m√©todo
igualitario


para
la
planificaci√≥n
de
paquetes
en
las
colas
de
los
routers
.
Todos
los
paquetes
reciben
el


mismo
servicio
;
ning√∫n
paquete
,
incluyendo
los
paquetes
de
audio
y
v√≠deo
sensibles
al


retardo
,
reciben
un
servicio
especial
de
prioridad
en
las
colas
de
los
routers
.
No
importa
el


dinero
que
se
tenga
ni
lo
importante
que
se
sea
,
¬°
tendr√°
que
ponerse
a
la
cola
y
esperar
a
que


le
llegue
su
turno
!
En
la
segunda
mitad
del
cap√≠tulo
examinaremos
las
arquitecturas
pro-


puestas
que
plantean
la
eliminaci√≥n
de
esta
restricci√≥n
.


As√≠
,
por
el
momento
tenemos
que
seguir
conviviendo
con
el
servicio
de
mejor
esfuerzo
.


Pero
conocida
esta
restricci√≥n
,
podemos
tomar
algunas
decisiones
de
dise√±o
y
emplear
algu-


nos
trucos
para
mejorar
la
calidad
percibida
por
el
usuario
de
aplicaciones
multimedia
de


red
.
Por
ejemplo
,
podemos
enviar
los
datos
de
audio
o
de
v√≠deo
a
trav√©s
de
UDP
,
e
ignorar
la


baja
tasa
de
transferencia
de
TCP
cuando
este
protocolo
entra
en
su
fase
de
arranque
lento
.


Podemos
retardar
la
reproducci√≥n
en
el
receptor
100
o
m√°s
milisegundos
,
con
el
fin
de
ate-


nuar
los
efectos
de
la
fluctuaci√≥n
inducida
por
la
red
.
Podemos
incluir
marcas
de
tiempo
en


los
paquetes
en
el
emisor
,
de
manera
que
el
receptor
sepa
cu√°ndo
deber√≠an
reproducirse
los


paquetes
.
En
el
caso
del
audio
y
el
v√≠deo
almacenado
podemos
extraer
datos
anticipada-


mente
durante
la
reproducci√≥n
siempre
que
existan
espacios
de
almacenamiento
en
el
cliente


y
ancho
de
banda
adicionales
.
Podemos
incluso
enviar
informaci√≥n
redundante
para
mitigar


los
efectos
de
la
p√©rdida
de
paquetes
inducida
por
la
red
.
Estudiaremos
muchas
de
estas
t√©c-


nicas
en
la
primera
parte
del
cap√≠tulo
.


7.1.3
¬ø
C√≥mo
deber√≠a
evolucionar
Internet
para
dar
un
mejor


soporte
a
las
aplicaciones
multimedia
?


Hoy
d√≠a
existe
un
debate
continuo
acerca
de
c√≥mo
deber√≠a
evolucionar
Internet
para
acomo-


dar
mejor
el
tr√°fico
multimedia
con
sus
estrictas
restricciones
de
temporizaci√≥n
.
En
un


extremo
se
encuentran
algunos
investigadores
que
argumentan
que
habr√≠a
que
llevar
a
cabo


cambios
fundamentales
en
Internet
,
con
el
fin
de
que
dichas
aplicaciones
puedan
reservar


expl√≠citamente
ancho
de
banda
terminal
a
terminal
y
recibir
as√≠
una
garant√≠apara
su
ren-


dimiento
terminal
a
terminal
.
Una
garant√≠a
estricta
quiere
decir
que
la
aplicaci√≥n
recibir√°


la
calidad
de
servicio
(
QoS
)
solicitada
con
absoluta
seguridad
.
Una
garant√≠a
parcialquiere


decir
que
la
aplicaci√≥n
recibir√°
su
calidad
de
servicio
solicitada
con
una
alta
probabili-


dad
.
Estos
investigadores
creen
que
si
un
usuario
desea
,
por
ejemplo
,
hacer
una
llamada


telef√≥nica
por
Internet
desde
el
host
A
al
host
B
,
entonces
la
aplicaci√≥n
telef√≥nica
de
Inter-


net
deber√≠a
poder
reservar
ancho
de
banda
de
forma
expl√≠cita
en
cada
uno
de
los
enlaces
de


una
ruta
existente
entre
ambos
hosts
.
Pero
permitir
que
las
aplicaciones
hagan
reservas
y


requerir
a
la
red
aceptar
las
reservas
requiere
algunos
grandes
cambios
.
En
primer
lugar
,
nece-


sitamos
un
protocolo
que
,
en
nombre
de
las
aplicaciones
,
reserve
ancho
de
banda
en
los
enla-


ces
que
definen
el
camino
desde
los
emisores
hasta
sus
respectivos
receptores
.
En
segundo


lugar
,
habr√°
que
modificar
las
pol√≠ticas
de
planificaci√≥n
en
las
colas
de
los
routers
,
de
modo


que
las
reservas
de
ancho
de
banda
puedan
ser
aceptadas
.
Con
estas
nuevas
pol√≠ticas
de
pla-


nificaci√≥n
,
no
todos
los
paquetes
recibir√°n
el
mismo
tratamiento
;
en
su
lugar
,
aquellos
que


reserven
(
y
paguen
)
m√°s
obtendr√°n
m√°s
.
En
tercer
lugar
,
para
aceptar
las
reservas
,
las
apli-


caciones
tienen
que
proporcionar
a
la
red
una
descripci√≥n
del
tr√°fico
que
pretenden
enviar
.


La
red
entonces
tendr√°
que
vigilar
el
tr√°fico
de
cada
aplicaci√≥n
para
garantizar
que
cumple


572
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
572con
la
descripci√≥n
.
Por
√∫ltimo
,
la
red
debe
disponer
de
un
medio
para
determinar
si
tiene
el


suficiente
ancho
de
banda
disponible
como
para
dar
soporte
a
cualquier
nueva
solicitud
de


reserva
.
Estos
mecanismos
,
cuado
se
combinan
,
requieren
un
software
nuevo
y
complejo


tanto
en
los
hosts
como
en
los
routers
,
as√≠
como
nuevos
tipos
de
servicios
.
Veremos
estos


mecanismos
en
detalle
en
la
Secci√≥n
7.6
.


En
el
otro
extremo
,
algunos
investigadores
argumentan
que
no
es
necesario
realizar
nin-


g√∫n
cambio
fundamental
en
el
servicio
de
mejor
esfuerzo
ni
en
los
protocolos
de
Internet


subyacentes
.
En
su
lugar
,
defienden
el
m√©todo
de
laissez-faire
:


‚Ä¢A
m
e
d
i
d
a
 
q
u
e
 
l
a
 
d
e
m
a
n
d
a
 
a
u
m
e
n
t
a
,
 
l
o
s
 
I
S
P
(
t
a
n
t
o
 
d
e
 
n
i
v
e
l
 
s
u
p
e
r
i
o
r
 
c
o
m
o
 
d
e
 
n
i
v
e
l
 
i
n
f
e
-


rior
)
escalan
sus
redes
para
satisfacer
la
demanda
.
Espec√≠ficamente
,
los
ISP
ofrecer√°n
el


suficiente
ancho
de
banda
y
la
suficiente
capacidad
de
conmutaci√≥n
como
para
propor-


cionar
,
dentro
de
sus
redes
,
un
funcionamiento
satisfactorio
en
lo
que
respecta
al
retardo


y
a
la
p√©rdida
de
paquetes
[
Huang
2005
]
.
Los
ISP
proporcionar√°n
un
mejor
servicio
a
sus


clientes
(
usuarios
e
ISP
clientes
)
,
que
se
traducir√°
en
unos
mayores
ingresos
,
gracias
a
la


existencia
de
m√°s
clientes
y
a
las
mayores
tasas
por
los
servicios
.
Para
garantizar
que
las


aplicaciones
multimedia
recibir√°n
un
servicio
adecuado
,
incluso
en
el
caso
de
que
exista


sobrecarga
,
un
ISP
puede
sobredimensionar
el
ancho
de
banda
y
la
capacidad
de
conmu-


taci√≥n
.
Con
una
previsi√≥n
del
tr√°fico
y
una
provisi√≥n
de
ancho
de
banda
apropiadas


puede
proporcionarse
una
garant√≠a
parcial
de
calidad
de
servicio
(
QoS
)
.


‚Ä¢L
a
 
r
e
d
e
s
 
d
e
 
d
i
s
t
r
i
b
u
c
i
√≥
n
 
d
e
 
c
o
n
t
e
n
i
d
o
 
(
C
D
N
)
 
d
u
p
l
i
c
a
n
 
e
l
 
c
o
n
t
e
n
i
d
o
 
a
l
m
a
c
e
n
a
d
o
 
y
 
l
o


insertan
en
las
fronteras
de
Internet
.
Puesto
que
una
gran
parte
del
tr√°fico
que
fluye
a
tra-


v√©s
de
Internet
es
contenido
almacenado
(
p√°ginas
web
,
archivos
MP3
,
v√≠deo
)
,
las
redes


CDN
pueden
aliviar
de
forma
significativa
las
cargas
de
tr√°fico
en
los
ISP
y
las
interfa-


ces
entre
pares
entre
los
ISP
.
Adem√°s
,
las
redes
CDN
proporcionan
un
servicio
diferen-


ciado
a
los
proveedores
de
contenido
:
los
proveedores
de
contenido
que
pagan
un


servicio
CDN
pueden
suministrar
el
contenido
m√°s
r√°pidamente
y
de
forma
m√°s
efectiva
.


En
la
Secci√≥n
7.3
estudiaremos
las
redes
CDN
.


‚Ä¢E
n
 
e
l
 
c
a
s
o
 
d
e
l
 
t
r
√°
f
i
c
o
 
d
e
 
f
l
u
j
o
s
 
e
n
 
v
i
v
o
 
(
c
o
m
o
 
e
l
 
g
e
n
e
r
a
d
o
 
p
o
r
 
u
n
 
e
v
e
n
t
o
 
d
e
p
o
r
t
i
v
o
)
 
q
u
e


se
env√≠a
a
millones
de
usuarios
simult√°neamente
,
pueden
implantarse
redes
solapadas


de
multidifusi√≥n
.
Una
red
de
este
tipo
consta
de
hosts
de
usuario
y
,
posiblemente
,
de
ser-


vidores
dedicados
dispersos
por
Internet
.
Estos
hosts
,
servidores
y
enlaces
l√≥gicos
entre


ellos
forman
colectivamente
una
red
solapada
,
la
cual
multidifunde
(
v√©ase
la
Secci√≥n


4.7
)
el
tr√°fico
desde
el
emisor
a
millones
de
usuarios
.
A
diferencia
de
IP
multidifusi√≥n
,


donde
la
funci√≥n
de
multidifusi√≥n
es
realizada
por
los
routers
en
la
capa
IP
,
las
redes


solapadas
llevan
a
cabo
la
multidifusi√≥n
en
la
capa
de
aplicaci√≥n
.
Por
ejemplo
,
el
host
de


origen
puede
enviar
el
flujo
a
tres
servidores
solapados
;
cada
uno
de
los
servidores
sola-


pados
puede
reenviar
el
flujo
a
los
dem√°s
servidores
y
hosts
solapados
;
el
proceso
conti-


n√∫a
,
creando
un
√°rbol
de
distribuci√≥n
por
encima
de
la
red
IP
subyacente
.
Transmitiendo


por
multidifusi√≥n
el
tr√°fico
en
vivo
m√°s
popular
a
trav√©s
de
redes
solapadas
,
la
carga
de


tr√°fico
global
de
Internet
puede
reducirse
respecto
al
caso
de
la
distribuci√≥n
por
unidifu-


si√≥n
.


Entre
el
grupo
que
defiende
las
reservas
y
el
que
defiende
el
laissez-faire
existe
un
ter-


cer
grupo
,
el
que
defiende
los
servicios
diferenciados
(
Diffserv
)
.
Este
grupo
desea
realizar


cambios
relativamente
peque√±os
en
las
capas
de
red
y
de
transporte
e
introducir
esquemas


simples
de
pol√≠ticas
y
de
precios
en
la
frontera
de
la
red
(
es
decir
,
en
la
interfaz
entre
el
usua-


7.1
‚Ä¢
APLICACIONES
DE
REDES
MULTIMEDIA
573


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
573rio
y
el
ISP
del
usuario
)
.
La
idea
consiste
en
introducir
un
n√∫mero
peque√±o
de
clases
de
tr√°-


fico
(
posiblemente
s√≥lo
dos
clases
)
,
asignar
cada
datagrama
a
una
de
las
clases
,
asignar
a


cada
datagrama
un
nivel
de
servicio
diferente
dependiendo
de
su
clase
en
las
colas
de
los


routers
y
cobrar
a
los
usuarios
de
acuerdo
con
la
clase
de
paquetes
que
est√©
enviando
a
la


red
.
En
la
Secci√≥n
7.5
nos
ocuparemos
de
los
servicios
diferenciados
.


Estos
tres
enfoques
para
el
tratamiento
del
tr√°fico
multimedia
(
mejorar
el
servicio
de


mejor
esfuerzo
,
QoS
diferencial
y
QoS
garantizado
)
se
resumen
en
la
Tabla
7.1
y
se
abordan


en
las
Secciones
7.3
,
7.5
y
7.6
,
respectivamente
.


7.1.4
Compresi√≥n
de
audio
y
v√≠deo


Antes
de
poder
transmitir
a
una
red
de
computadoras
el
audio
y
el
v√≠deo
es
necesario
digita-


lizarlo
y
comprimirlo
.
La
necesidad
de
la
digitalizaci√≥n
es
obvia
:
las
redes
de
computadoras


transmiten
bits
,
de
modo
que
toda
la
informaci√≥n
transmitida
tiene
que
representarse
como


una
secuencia
de
bits
.
La
compresi√≥n
es
importante
porque
el
audio
y
el
v√≠deo
descompri-


midos
consumen
enormes
cantidades
de
almacenamiento
y
de
ancho
de
banda
:
eliminando


las
redundancias
inherentes
mediante
la
compresi√≥n
de
las
se√±ales
de
audio
y
v√≠deo
digitali-


zadas
puede
reducirse
la
cantidad
de
datos
que
habr√°
que
almacenar
y
transmitir
en
varios


√≥rdenes
de
magnitud
.
Por
ejemplo
,
una
√∫nica
imagen
de
1024
p√≠xeles
,
con
cada
p√≠xel
codifi-


cado
con
24
bits
(
8
bits
por
cada
uno
de
los
colores
rojo
,
verde
y
azul
)
requiere
3
Mbytes
de


almacenamiento
sin
compresi√≥n
.
Se
tardar√≠an
siete
minutos
en
enviar
esta
imagen
a
trav√©s


de
un
enlace
de
64
kbps
.
Si
la
imagen
se
comprime
con
una
relaci√≥n
de
comprensi√≥n


modesta
de
10:1
,
el
requisito
de
almacenamiento
se
reduce
a
300
kbytes
y
el
tiempo
de


transmisi√≥n
se
reduce
tambi√©n
en
un
factor
de
10
.


El
tema
de
la
compresi√≥n
del
audio
y
el
v√≠deo
es
muy
extenso
,
ya
que
ha
constituido
un


√°rea
de
investigaci√≥n
durante
m√°s
de
50
a√±os
y
actualmente
existen
,
literalmente
,
cientos
de


t√©cnicas
y
est√°ndares
populares
para
la
compresi√≥n
de
audio
y
de
v√≠deo
.
Muchas
universida-


des
ofrecen
cursos
completos
dedicados
a
la
compresi√≥n
de
audio
y
la
compresi√≥n
de
v√≠deo
.


Por
tanto
,
aqu√≠
s√≥lo
vamos
a
proporcionar
una
breve
introducci√≥n
de
car√°cter
general
sobre


el
tema
.


Unidad
de
Implantaci√≥n


Enfoque
asignaci√≥n
Garant√≠a
hasta
la
fecha
Complejidad
Mecanismos


Mejorar
el
servicio
ninguna
ninguna
o
en
cualquier
m√≠nima
soporte
de
la
capa


de
mejor
esfuerzo
parcial
lugar
de
aplicaci√≥n
,
CDN
,


sobredimensionamiento


QoS
diferencial
clases
de
flujos
ninguna
o
alguna
media
vigilancia
,


parcial
planificaci√≥n


QoS
garantizado
flujos
parcial
o
estricta
,
poca
alta
vigilancia
,


individuales
una
vez
que
un
planificaci√≥n
,


flujo
es
admitido
admisi√≥n
y


se√±alizaci√≥n
de


llamadas


Tabla
7.1
‚Ä¢
Tres
m√©todos
para
dar
soporte
a
las
aplicaciones
multimedia
.


574
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
574Compresi√≥n
de
audio
en
Internet


Una
se√±al
de
audio
anal√≥gica
que
var√≠a
de
forma
continua
(
que
podr√≠a
ser
voz
o
m√∫sica
)
nor-


malmente
se
convierte
en
una
se√±al
digital
del
siguiente
modo
:


‚Ä¢E
n
 
p
r
i
m
e
r
 
l
u
g
a
r
,
 
l
a
 
s
e
√±
a
l
 
d
e
 
a
u
d
i
o
 
a
n
a
l
√≥
g
i
c
a
 
s
e
 
m
u
e
s
t
r
e
a
 
a
 
u
n
a
 
t
a
s
a
 
f
i
j
a
,
 
p
o
r
 
e
j
e
m
p
l
o
,
 
a


8.000
muestras
por
segundo
.
El
valor
de
cada
muestra
es
un
n√∫mero
real
arbitrario
.


‚Ä¢A
c
o
n
t
i
n
u
a
c
i
√≥
n
,
 
c
a
d
a
 
u
n
a
 
d
e
 
l
a
s
 
m
u
e
s
t
r
a
s
 
s
e
 
r
e
d
o
n
d
e
a
 
a
 
u
n
o
 
d
e
 
u
n
 
n
√∫
m
e
r
o
 
f
i
n
i
t
o
 
d
e
 
v
a
l
o
-


res
.
Esta
operaci√≥n
se
conoce
con
el
nombre
de
cuantizaci√≥n
.
El
n√∫mero
de
valores
fini-


tos
(
denominados
valores
de
cuantizaci√≥n
)
normalmente
es
una
potencia
de
dos
,
por


ejemplo
,
256
valores
de
cuantizaci√≥n
.


‚Ä¢C
a
d
a
 
u
n
o
 
d
e
 
l
o
s
 
v
a
l
o
r
e
s
 
d
e
 
c
u
a
n
t
i
z
a
c
i
√≥
n
 
s
e
 
r
e
p
r
e
s
e
n
t
a
 
m
e
d
i
a
n
t
e
 
u
n
 
n
√∫
m
e
r
o
 
f
i
j
o
 
d
e
 
b
i
t
s
.


Por
ejemplo
,
si
hay
256
valores
de
cuantizaci√≥n
,
entonces
cada
valor
(
y
por
tanto
cada


muestra
)
se
representa
mediante
1
byte
.
Cada
una
de
las
muestras
se
convierte
a
su
repre-


sentaci√≥n
de
bits
.
Las
representaciones
de
bits
de
todas
las
muestras
se
concatenan
para


formar
la
representaci√≥n
digital
de
la
se√±al
.


Por
ejemplo
,
si
una
se√±al
de
audio
anal√≥gica
se
muestrea
con
una
tasa
de
8.000
mues-


tras
por
segundo
y
cada
muestra
se
cuantiza
y
representa
mediante
8
bits
,
entonces
la
se√±al


digital
resultante
tendr√°
una
tasa
de
64.000
bits
por
segundo
.
Esta
se√±al
digital
puede
enton-


ces
convertirse
de
nuevo
(
es
decir
,
decodificarse
)
en
una
se√±al
anal√≥gica
para
su
reproduc-


ci√≥n
.
Sin
embargo
,
normalmente
la
se√±al
anal√≥gica
decodificada
es
diferente
de
la
se√±al
de


audio
original
.
Aumentando
la
tasa
de
muestreo
y
el
n√∫mero
de
valores
de
cuantizaci√≥n
,
la


se√±al
decodificada
puede
aproximarse
a
la
se√±al
anal√≥gica
original
.
Por
tanto
,
existe
una


clara
relaci√≥n
de
compromiso
entre
la
calidad
de
la
se√±al
decodificada
y
los
requisitos
de


almacenamiento
y
ancho
de
banda
de
la
se√±al
digital
.


La
t√©cnica
de
codificaci√≥n
b√°sica
que
acabamos
de
describir
se
conoce
como


Modulaci√≥n
por
c√≥digo
de
pulsos
(
PCM
,
Pulse
Code
Modulation
)
.
La
codificaci√≥n
de


voz
normalmente
utiliza
PCM
,
con
una
tasa
de
muestreo
de
8.000
muestras
por
segundo


y
8
bits
por
muestra
,
lo
que
proporciona
una
tasa
de
64
kbps
.
Los
discos
de
audio
com-


pacto
(
CD
)
tambi√©n
emplean
la
modulaci√≥n
PCM
,
con
una
tasa
de
muestreo
de
44.100


muestras
por
segundo
y
16
bits
por
muestra
;
esto
proporciona
una
tasa
de
705,6
kbps
para


mono
y
de
1,411
Mbps
para
est√©reo
.


Una
tasa
de
bit
de
1,411
Mbps
para
m√∫sica
en
est√©reo
excede
la
mayor√≠a
de
las
veloci-


dades
de
acceso
e
incluso
los
64
kbps
para
voz
exceden
la
velocidad
de
acceso
de
un
usua-


rio
de
m√≥dem
de
acceso
telef√≥nico
.
Por
estas
razones
,
la
voz
y
la
m√∫sica
codificadas


mediante
PCM
rara
vez
se
utilizan
en
Internet
;
en
su
lugar
se
emplean
t√©cnicas
de
compre-


si√≥n
para
reducir
las
tasas
de
bit
de
los
flujos
.
Entre
las
t√©cnicas
de
compresi√≥n
de
voz
popu-


lares
se
incluyen
GSM
(
13
kbps
)
,
G.729
(
8
kbps
)
,
G.723.3
(
6,4
y
5,3
kbps
)
y
una
gran


cantidad
de
t√©cnicas
propietarias
.
Una
t√©cnica
de
compresi√≥n
popular
para
m√∫sica
est√©reo
de


calidad
tipo
CD
es
MPEG
1
layer
3
,
m√°s
com√∫nmente
conocida
como
MP3
.
Los
codifica-


dores
de
MP3
normalmente
comprimen
a
tasas
de
96
kbps
,
128
kbps
y
160
kbps
y
degradan


muy
poco
el
sonido
.
Cuando
un
archivo
MP3
se
divide
en
fragmentos
,
cada
fragmento
sigue


siendo
reproducible
.
Este
formato
de
archivo
sin
cabecera
permite
transmitir
a
trav√©s
de


Internet
los
archivos
de
m√∫sica
MP3
como
si
fueran
flujos
(
suponiendo
que
la
velocidad
de


bit
de
reproducci√≥n
y
la
velocidad
de
la
conexi√≥n
a
Internet
sean
compatibles
)
.
El
est√°ndar


de
compresi√≥n
MP3
es
complejo
y
utiliza
mecanismos
de
enmascaramiento
psicoac√∫stico
,


reducci√≥n
de
redundancia
y
buffers
de
reserva
de
bits
.


7.1
‚Ä¢
APLICACIONES
DE
REDES
MULTIMEDIA
575


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
575Compresi√≥n
de
v√≠deo
en
Internet


Un
v√≠deo
es
una
secuencia
de
im√°genes
,
normalmente
reproducidas
a
una
velocidad
cons-


tante
;
por
ejemplo
,
a
24
o
30
im√°genes
por
segundo
.
Una
imagen
codificada
digitalmente


y
no
comprimida
consta
de
una
matriz
de
p√≠xeles
,
con
cada
p√≠xel
codificado
mediante
una


serie
de
bits
que
representan
la
luminancia
y
el
color
.
Existen
dos
tipos
de
redundancia
en


el
v√≠deo
que
pueden
ser
explotados
por
los
mecanismos
de
compresi√≥n
.
La
redundancia


espacial
es
la
redundancia
contenida
en
la
propia
imagen
.
Por
ejemplo
,
una
imagen
que


tiene
gran
cantidad
de
espacio
en
blanco
puede
ser
comprimida
de
forma
eficiente
.
La


redundancia
temporal
refleja
la
repetici√≥n
de
una
imagen
a
la
siguiente
.
Por
ejemplo
,
si


una
imagen
y
la
siguiente
son
exactamente
iguales
,
no
existe
ninguna
raz√≥n
para
codificar


tambi√©n
la
segunda
de
ellas
;
es
m√°s
eficiente
indicar
simplemente
durante
el
proceso
de


codificaci√≥n
que
la
segunda
imagen
es
exactamente
igual
que
la
primera
.


Los
est√°ndares
de
compresi√≥n
MPEG
se
encuentran
entre
las
t√©cnicas
de
compresi√≥n


m√°s
populares
.
Entre
estos
se
incluyen
MPEG
1
para
v√≠deo
de
calidad
CD-ROM
(
1,5


Mbps
)
,
MPEG
2
para
v√≠deo
de
alta
calidad
DVD
(
3-6
Mbps
)
y
MPEG
4
para
compresi√≥n


de
v√≠deo
orientada
a
objeto
.
Los
est√°ndares
MPEG
est√°n
basados
fundamentalmente
en
el


est√°ndar
JPEG
para
la
compresi√≥n
de
im√°genes
y
explotan
la
redundancia
temporal
de
las


im√°genes
,
adem√°s
de
la
redundancia
espacial
explotada
por
JPEG
.
Los
est√°ndares
de
com-


presi√≥n
de
v√≠deo
H.261
tambi√©n
son
muy
populares
en
Internet
.
Adem√°s
,
existen
numerosos


esquemas
propietarios
,
entre
los
que
se
incluyen
QuickTime
de
Apple
y
los
codificadores


Real
Networks
.


Los
lectores
interesados
en
aprender
m√°s
acerca
de
la
codificaci√≥n
de
audio
y
v√≠deo


pueden
consultar
[
Rao
1996
]
y
[
Solari
1997
]
.
Un
buen
libro
sobre
las
redes
multimedia
en


general
es
[
Crowcroft
1999
]
.


7.2
Flujos
de
audio
y
de
v√≠deo
almacenado


En
los
√∫ltimos
a√±os
,
la
transmisi√≥n
de
flujos
de
audio
y
de
v√≠deo
se
ha
convertido
en
una


aplicaci√≥n
popular
y
en
un
consumidor
importante
de
ancho
de
banda
de
red
.
En
estas
apli-


caciones
,
el
cliente
solicita
archivos
comprimidos
de
audio
/
v√≠deo
que
residen
en
servidores
.


Como
pronto
veremos
,
estos
servidores
pueden
ser
servidores
web
normales
o
servidores


especiales
para
flujos
adaptados
para
aplicaciones
de
flujos
de
audio
/
v√≠deo
.
Una
vez
reci-


bida
la
solicitud
del
cliente
,
el
servidor
env√≠a
un
archivo
de
audio
/
v√≠deo
al
cliente
pasando
el


archivo
a
un
socket
.
Aunque
se
puede
utilizar
tanto
TCP
como
UDP
,
hoy
d√≠a
la
mayor
parte


del
tr√°fico
de
flujos
de
audio
/
v√≠deo
es
transportado
por
TCP
.
(
Los
cortafuegos
a
menudo
se


configuran
para
bloquear
el
tr√°fico
de
UDP
.
Adem√°s
,
utilizando
TCP
,
con
su
servicio
de


entrega
fiable
,
el
archivo
completo
consigue
transferirse
al
cliente
sin
p√©rdida
de
paquetes
,


permitiendo
que
el
archivo
pueda
ser
reproducido
en
el
futuro
desde
una
cach√©
local
.
)
[
Sri-


panidkulchai
2004
]
.
Una
vez
que
el
archivo
de
audio
/
v√≠deo
solicitado
comienza
a
llegar
,
el


cliente
inicia
su
reproducci√≥n
pasados
unos
pocos
segundos
.
Algunos
sistemas
tambi√©n
pro-


porcionan
interactividad
con
el
usuario
;
por
ejemplo
,
el
usuario
puede
pausar
/
reanudar
el


archivo
de
audio
/
v√≠deo
o
saltar
de
un
punto
a
otro
dentro
del
mismo
.
El
protocolo
de
trans-


misi√≥n
de
flujos
en
tiempo
real
(
RTSP
,
Real-Time
Streaming
Protocol
)
,
que
veremos
al


final
de
esta
secci√≥n
,
es
un
protocolo
de
dominio
p√∫blico
que
proporciona
interactividad
con


el
usuario
.


576
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
5767.2
‚Ä¢
FLUJOS
DE
AUDIO
Y
DE
V√çDEO
ALMACENADO
577


FLUJOS
DE
AUDIO
Y
DE
V√çDEO
ALMACENADO
:


DESDE
REALNETWORKS
A
YOUTUBE


RealNetworks
,
una
empresa
pionera
en
la
transmisi√≥n
de
flujos
de
audio
y
de
v√≠deo
,
fue
la


primera
compa√±√≠a
que
ofreci√≥
audio
a
trav√©s
de
Internet
al
p√∫blico
en
general
.
Su
producto


inicial
(
el
sistema
RealAudio
distribuido
en
1995
)
inclu√≠a
un
codificador
de
audio
,
un


servidor
de
audio
y
un
reproductor
de
audio
.
Permit√≠a
a
los
usuarios
navegar
,
seleccionar
y


reproducir
contenido
de
audio
desde
Internet
bajo
demanda
,
por
lo
que
r√°pidamente
se


convirti√≥
en
un
sistema
de
distribuci√≥n
popular
para
los
proveedores
de
contenido
de


entretenimiento
,
educativo
y
de
noticias
.


Actualmente
,
los
flujos
de
audio
y
v√≠deo
se
encuentran
entre
los
servicios
m√°s
populares
de


Internet
.
No
s√≥lo
existe
una
gran
cantidad
de
empresas
que
ofrecen
contenido
de
este
tipo
,


sino
que
tambi√©n
se
est√°n
empleando
una
multitud
de
distintos
servidores
,
reproductores
y
tec-


nolog√≠as
de
protocolo
.
Algunos
ejemplos
interesantes
(
a
fecha
de
2009
)
son
:


‚Ä¢R
h
a
p
s
o
d
y
 
d
e
 
R
e
a
l
N
e
t
w
o
r
k
s
:
proporciona
a
los
usuarios
servicios
de
suscripci√≥n


para
descarga
y
transmisi√≥n
de
flujos
.
Rhapsody
utiliza
su
propio
cliente
propietario
,


que
recupera
canciones
de
su
servidor
propietario
utilizando
HTTP
.
Cuando
una
can-


ci√≥n
llega
a
trav√©s
de
HTTP
se
reproduce
en
su
cliente
Rhapsody
.
El
acceso
al
contenido


descargado
est√°
restringido
mediante
un
sistema
de
Gesti√≥n
de
derechos
digital
(
DRM
,


Digital
Rights
Management
)
.


‚Ä¢M
S
N
 
V
i
d
e
o
:
los
usuarios
se
descargan
una
amplia
variedad
de
contenidos
,
inclu-


yendo
noticias
internacionales
y
clips
de
v√≠deos
musicales
.
El
v√≠deo
se
reproduce


mediante
el
popular
reproductor
Windows
Media
Player
(
WMP
)
,
que
est√°
disponible
en


casi
todos
los
hosts
Windows
.
La
comunicaci√≥n
entre
WMP
y
el
servidor
de
Microsoft
se


hace
mediante
el
protocolo
propietario
MMS
(
Microsoft
Media
Server
)
,
que
normal-


mente
intenta
transmitir
los
flujos
sobre
RTSP
/
RTP
;
si
esta
soluci√≥n
falla
a
causa
de
los


cortafuegos
,
prueba
a
recuperar
el
contenido
a
trav√©s
de
HTTP
.


‚Ä¢M
u
z
e
:
proporciona
un
servicio
de
muestras
de
audio
para
minoristas
,
como
BestBuy
y


Yahoo
.
Las
muestras
de
m√∫sica
seleccionadas
en
los
sitios
de
estos
minoristas
realmente


proceden
de
Muze
,
y
se
transmiten
a
trav√©s
de
WMP
.
Muze
,
Rhapsody
,
YouTube


y
muchos
otros
proveedores
de
flujos
multimedia
utilizan
redes
de
distribuci√≥n
de


contenido
(
CDN
)
para
distribuir
sus
contenidos
,
como
se
explica
en
la
Secci√≥n
7.3
.


‚Ä¢Y
o
u
T
u
b
e
:
el
tremendamente
popular
servicio
de
compartici√≥n
de
v√≠deos
utiliza
un


cliente
basado
en
Flash
(
integrado
en
la
p√°gina
web
)
.
La
comunicaci√≥n
entre
el
cliente


y
los
servidores
de
YouTube
se
hace
a
trav√©s
de
HTTP
.


¬ø
Qu√©
es
lo
que
nos
deparar√°
el
futuro
?
Actualmente
,
la
mayor
parte
de
los
flujos
de
v√≠deo


son
de
baja
calidad
y
se
codifican
a
tasas
de
500
kbps
o
menores
.
La
calidad
del
v√≠deo


realmente
mejorar√°
cuando
el
acceso
a
Internet
de
banda
ancha
y
de
fibra
en
los
domicilios


adquiera
una
mayor
predominancia
.
Y
muy
posiblemente
nuestros
reproductores
port√°tiles
de


m√∫sica
ya
no
almacenar√°n
la
m√∫sica
,
sino
que
la
obtendr√°n
directamente
,
bajo
demanda
,
a


trav√©s
de
canales
inal√°mbricos
.


HISTORIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
577Los
usuarios
a
menudo
solicitan
la
transmisi√≥n
de
flujos
de
audio
/
v√≠deo
a
trav√©s
de
un


cliente
web
(
es
decir
,
un
navegador
)
,
pero
luego
reproducen
y
controlan
la
reproducci√≥n
de


√©stos
mediante
un
reproductor
multimedia
,
como
por
ejemplo
Windows
Media
Player
o


Flash
.
El
reproductor
multimedia
realiza
varias
funciones
,
entre
las
que
se
incluyen
las


siguientes
:


‚Ä¢
Descomprensi√≥n
.
El
audio
/
v√≠deo
casi
siempre
se
comprime
con
el
fin
de
ahorrar
espacio


de
almacenamiento
en
disco
y
ancho
de
banda
de
red
.
Un
reproductor
multimedia
tiene


que
descomprimir
el
audio
/
v√≠deo
sobre
la
marcha
durante
la
reproducci√≥n
.


‚Ä¢
Eliminaci√≥n
de
las
fluctuaciones
.
La
fluctuaci√≥n
de
los
paquetes
es
la
variabilidad
de
los


retardos
del
origen
al
destino
de
los
paquetes
contenidos
en
un
mismo
flujo
de
paquetes
.


Puesto
que
el
audio
y
el
v√≠deo
tienen
que
reproducirse
con
la
misma
temporizaci√≥n
que


fueron
grabados
,
un
receptor
almacenar√°
en
buffer
los
paquetes
recibidos
durante
un


corto
periodo
de
tiempo
para
eliminar
esa
fluctuaci√≥n
.
Examinaremos
este
tema
en
deta-


lle
en
la
Secci√≥n
7.3
.


7.2.1
Acceso
al
audio
y
al
v√≠deo
a
trav√©s
de
un
servidor
web


El
audio
/
v√≠deo
almacenado
puede
residir
bien
en
un
servidor
web
que
entrega
los
archivos


de
audio
/
v√≠deo
al
cliente
a
trav√©s
de
HTTP
,
o
bien
en
un
servidor
dedicado
de
flujos
de


audio
/
v√≠deo
utilizando
HTTP
o
alg√∫n
otro
protocolo
.
En
esta
subsecci√≥n
,
vamos
examinar
la


entrega
de
flujos
de
audio
/
v√≠deo
desde
un
servidor
web
;
en
la
siguiente
subsecci√≥n
nos
cen-


traremos
en
la
entrega
desde
un
servidor
de
flujos
.
El
suministro
de
flujos
multimedia
v√≠a


HTTP
se
ha
hecho
muy
popular
gracias
a
los
cortafuegos
(
v√©ase
el
Cap√≠tulo
8)
,
que
suelen


permitir
que
el
tr√°fico
HTTP
los
atraviese
,
mientras
que
los
protocolos
propietarios
son
blo-


queados
.


Consideremos
en
primer
lugar
el
caso
de
los
flujos
de
audio
.
Cuando
un
archivo
de


audio
reside
en
un
servidor
web
,
el
archivo
es
un
objeto
ordinario
dentro
del
sistema
de


archivos
del
servidor
,
como
lo
son
los
archivos
HTML
y
JPEG
.
Cuando
un
usuario
desea


escuchar
el
archivo
de
audio
,
el
host
del
usuario
establece
una
conexi√≥n
TCP
con
el
servidor


web
y
env√≠a
una
solicitud
HTTP
para
el
objeto
.
Despu√©s
de
recibir
una
solicitud
,
el
servidor


web
encapsula
el
archivo
de
audio
en
un
mensaje
de
respuesta
HTTP
y
lo
env√≠a
de
vuelta
a


trav√©s
de
la
conexi√≥n
TCP
.
El
caso
de
un
archivo
de
v√≠deo
puede
ser
un
poco
m√°s
compli-


cado
si
las
partes
de
audio
y
v√≠deo
est√°n
almacenadas
en
dos
archivos
.
Tambi√©n
es
posible


que
el
audio
y
el
v√≠deo
vayan
intercalados
en
el
mismo
archivo
,
en
cuyo
caso
s√≥lo
habr√°
que


enviar
un
objeto
al
cliente
.
Con
el
fin
de
simplificar
nuestra
exposici√≥n
,
vamos
a
suponer


que
en
el
caso
del
v√≠deo
,
ambas
partes
,
audio
y
v√≠deo
,
est√°n
contenidas
en
un
√∫nico
archivo
.


En
muchas
implementaciones
de
transmisi√≥n
de
flujos
de
audio
/
v√≠deo
sobre
HTTP
,
la


funcionalidad
del
lado
del
cliente
se
divide
en
dos
partes
.
La
tarea
del
navegador
es
solicitar


un
metarchivoque
proporciona
informaci√≥n
(
por
ejemplo
,
un
URL
y
un
tipo
de
codificaci√≥n
,


de
modo
que
pueda
ser
identificado
el
reproductor
multimedia
apropiado
)
acerca
del
archivo


multimedia
que
va
a
ser
transmitido
mediante
HTTP
.
Este
metarchivo
se
pasa
entonces
des-


de
el
navegador
al
reproductor
multimedia
,
cuyo
trabajo
consiste
en
contactar
al
servidor


HTTP
,
el
cual
a
continuaci√≥n
env√≠a
el
archivo
multimedia
al
reproductor
v√≠a
HTTP
.
Estos


pasos
se
ilustran
en
la
Figura
7.1
:


1
.
El
usuario
hace
clic
en
el
hiperv√≠nculo
correspondiente
a
un
archivo
de
audio
/
v√≠deo
.
El


hiperv√≠nculo
no
apunta
directamente
a
dicho
archivo
,
sino
a
un
metarchivo
.
El
metar-


578
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
578chivo
contiene
el
URL
al
archivo
de
audio
/
v√≠deo
real
.
El
mensaje
de
respuesta
HTTP


que
encapsula
el
metarchivo
incluye
una
l√≠nea
de
cabecera
con
el
tipo
de
contenido
que


indica
una
aplicaci√≥n
de
audio
/
v√≠deo
espec√≠fica
.


2
.
El
navegador
del
cliente
examina
la
l√≠nea
de
cabecera
correspondiente
al
tipo
de
conte-


nido
del
mensaje
de
respuesta
,
ejecuta
el
reproductor
multimedia
asociado
y
pasa
el


cuerpo
del
mensaje
de
respuesta
(
es
decir
,
el
metarchivo
)
al
reproductor
.


3
.
El
reproductor
multimedia
establece
una
conexi√≥n
TCP
directamente
con
el
servidor


HTTP
.
El
reproductor
multimedia
env√≠a
un
mensaje
de
respuesta
HTTP
para
el
archivo


de
audio
/
v√≠deo
a
trav√©s
de
la
conexi√≥n
TCP
.
El
archivo
de
audio
/
v√≠deo
se
env√≠a
dentro


de
un
mensaje
de
respuesta
HTTP
hacia
el
reproductor
,
el
cual
reproduce
el
archivo
.


La
importancia
del
paso
intermedio
de
adquisici√≥n
del
metarchivo
es
evidente
.
Cuando


el
navegador
ve
el
tipo
de
contenido
del
archivo
puede
ejecutar
el
reproductor
apropiado
y
,


de
este
modo
,
hacer
que
el
reproductor
contacte
directamente
con
el
servidor
.


Acabamos
de
ver
c√≥mo
un
metarchivo
puede
hacer
que
un
reproductor
se
comunique


directamente
con
un
servidor
web
que
almacena
un
archivo
de
audio
/
v√≠deo
.
Existen
todav√≠a


muchas
empresas
que
venden
productos
para
la
transmisi√≥n
de
flujos
de
audio
/
v√≠deo
que
no


recomiendan
la
arquitectura
que
acabamos
de
describir
.
En
su
lugar
,
recomiendan
transmitir


los
flujos
de
audio
/
v√≠deo
almacenado
desde
servidores
de
flujos
dedicados
,
los
cuales
han


sido
optimizados
para
dicha
tarea
.


7.2.2
Env√≠o
de
informaci√≥n
multimedia
desde
un
servidor


de
flujos
a
una
aplicaci√≥n
de
ayuda


Un
servidor
de
flujos
puede
ser
un
servidor
de
flujos
propietario
,
como
los
comercializados


por
RealNetworks
y
Microsoft
,
o
puede
ser
un
servidor
de
flujos
de
dominio
p√∫blico
.
Con


un
servidor
de
flujos
,
el
audio
/
v√≠deo
puede
enviarse
a
trav√©s
de
HTTP
/
TCP
;
o
mediante


7.2
‚Ä¢
FLUJOS
DE
AUDIO
Y
DE
V√çDEO
ALMACENADO
579


Servidor


Servidor
web


con
archivos


de
audio/


v√≠deo


Navegador


web


Cliente


Solicitud
/
respuesta
HTTP
para
metarchivo


Archivo
multimedia
solicitado


y
enviado
utilizando
HTTP


Reproduc
.


multimedia


Metarchivo


2


1


3


Figura
7.1
‚Ä¢
El
servidor
web
env√≠a
directamente
el
flujo
de
audio
/
v√≠deo
al


reproductor
multimedia
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
579UDP
utilizando
protocolos
de
la
capa
de
aplicaci√≥n
que
pueden
adaptarse
mejor
que
HTTP
a


la
transmisi√≥n
de
flujos
de
audio
/
v√≠deo
.


Esta
arquitectura
requiere
dos
servidores
,
como
se
muestra
en
la
Figura
7.2
.
Un
servi-


dor
,
el
servidor
web
,
sirve
las
p√°ginas
web
(
incluyendo
metarchivos
)
.
El
segundo
servidor
,


el
 
servidor
de
flujos
,
sirve
los
archivos
de
audio
/
v√≠deo
.
Los
dos
servidores
pueden
ejecu-


tarse
en
el
mismo
sistema
terminal
o
en
dos
sistemas
terminales
distintos
.
Los
pasos
que
se


siguen
en
esta
arquitectura
son
similares
a
los
descritos
en
la
anterior
subsecci√≥n
.
Sin


embargo
,
ahora
el
reproductor
multimedia
solicita
el
archivo
a
un
servidor
de
flujos
en
lugar


de
a
un
servidor
web
,
y
ahora
el
reproductor
y
el
servidor
de
flujos
pueden
interactuar
utili-


zando
sus
propios
protocolos
.
Estos
protocolos
permiten
una
rica
interacci√≥n
del
usuario
con


el
flujo
de
audio
/
v√≠deo
.


En
la
arquitectura
de
la
Figura
7.2
existen
muchas
opciones
para
la
entrega
del
audio/


v√≠deo
desde
el
servidor
de
flujos
al
reproductor
multimedia
.
A
continuaci√≥n
proporcionamos


una
lista
parcial
de
las
opciones
.


1
.
El
archivo
de
audio
/
v√≠deo
se
env√≠a
sobre
UDP
a
una
velocidad
constante
igual
a
la
velo-


cidad
de
vaciado
del
receptor
(
que
es
la
tasa
de
codificaci√≥n
del
audio
/
v√≠deo
)
.
Por
ejem-


plo
,
si
el
audio
se
comprime
utilizando
GSM
a
una
tasa
de
13
kbps
,
entonces
el
servidor


temporiza
la
transmisi√≥n
del
archivo
de
audio
comprimido
a
13
kbps
.
En
cuanto
el


cliente
recibe
el
audio
/
v√≠deo
comprimido
de
la
red
,
lo
descomprime
y
reproduce
.


2
.
Esto
es
lo
mismo
que
en
la
primera
opci√≥n
,
pero
en
este
caso
el
reproductor
multime-


dia
retarda
la
reproducci√≥n
entre
dos
y
cinco
segundos
con
el
fin
de
eliminar
la
fluc-


tuaci√≥n
inducida
por
la
red
.
El
cliente
lleva
a
cabo
esta
tarea
insertando
el
archivo


comprimido
que
recibe
de
la
red
en
un
buffer
cliente
,
como
se
muestra
en
la
Figura


580
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Navegador


web


solicitud
/
repuesta
HTTP
para
el
archivo

    
de
descripci√≥n
de
la
presentaci√≥n


Cliente


Reproduc
.


multimediaArchivo
de
descripci√≥n

   
de
la
presentaci√≥n


2


1


Servidores


Servidor


web


Archivo
multimedia
solicitado
y
enviado


3
Servidor


de
flujos


Figura
7.2
‚Ä¢
Transmisi√≥n
desde
un
servidor
de
flujos
a
un
reproductor


multimedia
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
5807.3
.
Una
vez
que
el
cliente
ha
precargado
unos
pocos
segundos
del
archivo
comienza
a


vaciar
el
buffer
.
En
este
caso
,
y
tambi√©n
en
la
opci√≥n
anterior
,
la
velocidad
de
relleno


x(t
)
es
igual
a
la
velocidad
de
vaciado
d
,
e
x
c
e
p
t
o
 
c
u
a
n
d
o
 
s
e
 
p
r
o
d
u
c
e
 
u
n
a
 
p
√©
r
d
i
d
a
 
d
e


paquetes
,
en
cuyo
caso
x(t
)
ser√°
moment√°neamente
menor
que
d.


3
.
Los
archivos
multimedia
se
env√≠an
sobre
TCP
.
El
servidor
inserta
el
archivo
multimedia


en
el
socket
TCP
tan
r√°pidamente
como
puede
;
el
cliente
(
es
decir
,
el
reproductor
multi-


media
)
lee
del
socket
TCP
tan
r√°pido
como
puede
y
coloca
el
v√≠deo
comprimido
en
el


buffer
del
reproductor
.
Despu√©s
de
un
retardo
inicial
de
dos
a
cinco
segundos
,
el
repro-


ductor
lee
de
su
buffer
a
una
velocidad
d
y
reenv√≠a
el
archivo
comprimido
a
descompre-


si√≥n
y
reproducci√≥n
.
Dado
que
TCP
retransmite
los
paquetes
perdidos
,
tiene
el
potencial


de
proporcionar
una
mejor
calidad
de
sonido
que
UDP
.
Por
otro
lado
,
la
velocidad
de


relleno
x(t
)
ahora
fluct√∫a
con
el
tiempo
a
causa
del
control
de
congesti√≥n
y
del
control


de
flujo
de
ventana
de
TCP
.
En
realidad
,
despu√©s
de
producirse
una
p√©rdida
de
paque-


tes
,
el
control
de
congesti√≥n
de
TCP
puede
reducir
la
velocidad
instant√°nea
a
un
valor


menor
que
el
de
d
durante
largos
periodos
de
tiempo
.
De
este
modo
,
el
buffer
cliente


puede
vaciarse
(
un
proceso
conocido
como
inanici√≥n
)
e
introducir
pausas
indeseables


en
la
salida
del
flujo
de
audio
/
v√≠deo
en
el
cliente
.
[
Wang
2004
]
demuestra
que
cuando


la
tasa
media
de
transferencia
de
TCP
es
aproximadamente
igual
a
dos
veces
la
veloci-


dad
media
de
bit
,
los
flujos
TCP
permiten
minimizar
la
inanici√≥n
y
obtener
retardos
de


arranque
peque√±os
.


Para
la
tercera
opci√≥n
,
el
comportamiento
de
x(t
)
depender√°
en
gran
medida
del
tama√±o


del
buffer
cliente
(
el
cual
no
debe
confundirse
con
el
buffer
del
receptor
TCP
)
.
Si
este
buffer


es
lo
suficientemente
grande
como
para
almacenar
el
archivo
multimedia
completo
(
posi-


blemente
en
disco
)
,
entonces
TCP
har√°
uso
de
todo
el
ancho
de
banda
instant√°neo
disponi-


ble
para
la
conexi√≥n
,
de
modo
que
x(t
)
pueda
hacerse
mucho
mayor
que
d.
Si
x(t
)
es
mucho


mayor
que
d
durante
largos
periodos
de
tiempo
,
entonces
gran
parte
del
archivo
multimedia


se
precarga
en
el
cliente
y
la
subsiguiente
inanici√≥n
del
cliente
es
muy
improbable
.
Si
,
por
el


contrario
,
el
buffer
del
cliente
es
peque√±o
,
entonces
x(t
)
fluctuar√°
alrededor
del
valor
de
la


velocidad
de
vaciado
d
,
siendo
entonces
el
riesgo
de
inanici√≥n
del
cliente
mucho
mayor
.


7.2
‚Ä¢
FLUJOS
DE
AUDIO
Y
DE
V√çDEO
ALMACENADO
581


Velocidad


de
relleno
=
x(t
)


Velocidad


de
vaciado
=
d
A
descompresi√≥n


y
reproducci√≥n


De
la


red


Datos
de
v√≠deo


precargados


Buffer
de
cliente


Figura
7.3
‚Ä¢
El
buffer
cliente
se
llena
a
una
velocidad
x(t
)
y
se
vac√≠a
a
una


velocidad
d.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
5817.2.3
Protocolo
de
transmisi√≥n
de
flujos
en
tiempo
real
(
RTSP
)


Muchos
usuarios
multimedia
de
Internet
(
especialmente
aquellos
que
han
crecido
con
el


mando
de
la
TV
en
la
mano
)
desear√°n
controlar
la
reproducci√≥n
de
los
medios
continuos


pausando
la
reproducci√≥n
,
saltando
a
un
punto
anterior
o
posterior
de
la
misma
,
haciendo
un


avance
r√°pido
o
un
rebobinado
visual
de
la
reproducci√≥n
,
etc.
Esta
funcionalidad
es
similar


a
la
de
la
que
dispone
un
usuario
que
tiene
un
reproductor
de
DVD
para
la
visualizaci√≥n
de


v√≠deos
en
DVD
o
un
reproductor
de
discos
CD
para
escuchar
m√∫sica
.
Para
que
un
usuario


pueda
controlar
la
reproducci√≥n
,
el
reproductor
multimedia
y
el
servidor
necesitan
un
proto-


colo
que
les
permita
intercambiar
la
informaci√≥n
de
control
de
la
reproducci√≥n
.
El
Protocolo


de
flujos
en
tiempo
real
(
RTSP
,
Real-Time
Streaming
Protocol
)
,
definido
en
RFC
2326
,
es


dicho
protocolo
.
Antes
de
abordar
los
detalles
de
RTSP
,
veamos
primero
qu√©
no
hace
RTSP
.


‚Ä¢R
T
S
P
n
o
 
d
e
f
i
n
e
 
e
s
q
u
e
m
a
s
 
d
e
 
c
o
m
p
r
e
s
i
√≥
n
 
p
a
r
a
 
a
u
d
i
o
 
y
 
v
√≠
d
e
o
.
 

‚Ä¢R
T
S
P
n
o
 
d
e
f
i
n
e
 
c
√≥
m
o
 
s
e
 
e
n
c
a
p
s
u
l
a
n
 
e
l
 
a
u
d
i
o
 
y
 
e
l
 
v
√≠
d
e
o
 
e
n
 
p
a
q
u
e
t
e
s
 
p
a
r
a
 
s
u
 
t
r
a
n
s
m
i
s
i
√≥
n


a
trav√©s
de
una
red
;
RTP
o
cualquier
otro
protocolo
propietario
puede
proporcionar
el


mecanismo
de
encapsulaci√≥n
para
los
flujos
multimedia
(
RTP
se
estudia
en
la
Secci√≥n


7.4
)
.
Por
ejemplo
,
los
servidores
y
reproductores
de
audio
/
v√≠deo
de
RealNetworks
utili-


zan
RTSP
para
intercambiar
informaci√≥n
de
control
,
pero
el
propio
flujo
multimedia


puede
ser
encapsulado
en
paquetes
RTP
o
en
alg√∫n
otro
formato
de
datos
propietario
.


‚Ä¢R
T
S
P
n
o
 
r
e
s
t
r
i
n
g
e
 
c
√≥
m
o
 
s
e
 
t
r
a
n
s
p
o
r
t
a
 
e
l
 
f
l
u
j
o
 
m
u
l
t
i
m
e
d
i
a
;
 
p
u
e
d
e
 
s
e
r
 
t
r
a
n
s
p
o
r
t
a
d
o
 
s
o
b
r
e


UDP
o
TCP
.


‚Ä¢R
T
S
P
n
o
 
r
e
s
t
r
i
n
g
e
 
c
√≥
m
o
 
e
l
 
r
e
p
r
o
d
u
c
t
o
r
 
m
u
l
t
i
m
e
d
i
a
 
a
l
m
a
c
e
n
a
 
e
n
 
b
u
f
f
e
r
 
e
l
 
a
u
d
i
o
/
v
√≠
d
e
o
.
 
E
l


flujo
de
audio
/
v√≠deo
puede
reproducirse
tan
pronto
como
empieza
a
llegar
al
cliente
,


puede
reproducirse
despu√©s
de
un
retardo
de
unos
pocos
segundos
o
puede
descargarse


completo
antes
de
iniciar
la
reproducci√≥n
.


Por
tanto
,
si
RTSP
no
hace
nada
de
lo
anterior
,
¬ø
qu√©
hace
?
RTSP
permite
que
un
repro-


ductor
multimedia
controle
la
transmisi√≥n
de
un
flujo
multimedia
.
Como
ya
hemos
mencio-


nado
,
las
acciones
de
control
son
:
pausar
/
reanudar
,
reposicionar
la
reproducci√≥n
,
avance


r√°pido
y
rebobinado
.
RTSP
es
un
protocolo
fuera
de
banda
.
En
particular
,
los
mensajes


RTSP
se
env√≠an
fuera
de
banda
,
mientras
que
los
flujos
multimedia
,
cuya
estructura
de


paquete
no
est√°
definida
por
RTSP
,
se
consideran
‚Äú
en
banda
‚Äù
.
Los
mensajes
RTSP
utilizan
un


n√∫mero
de
puerto
diferente
,
el
544
,
del
empleado
por
los
flujos
multimedia
.
La
especificaci√≥n


RTSP
[
RFC
2326
]
permite
que
los
mensajes
RTSP
sean
enviados
sobre
TCP
o
sobre
UDP
.


Recuerde
de
la
Secci√≥n
2.3
que
el
Protocolo
de
transferencia
de
archivos
(
FTP
)
tambi√©n


utiliza
el
concepto
de
fuera
de
banda
.
En
particular
,
FTP
emplea
dos
parejas
de
sockets


cliente/
servidor
,
teniendo
cada
pareja
su
propio
n√∫mero
de
puerto
:
una
pareja
de
sockets


cliente
/
servidor
soporta
una
conexi√≥n
TCP
que
transporta
informaci√≥n
de
control
y
la
otra


pareja
de
sockets
cliente
/
servidor
soporta
una
conexi√≥n
TCP
que
realmente
transporta
el


archivo
.
El
canal
de
RTSP
es
similar
en
muchos
puntos
al
canal
de
control
de
FTP
.


Veamos
ahora
un
ejemplo
simple
de
RTSP
,
el
cual
se
ilustra
en
la
Figura
7.4
.
En
primer


lugar
,
el
navegador
web
solicita
de
un
servidor
web
un
archivo
de
descripci√≥n
de
la
presen-


taci√≥n
.
Este
archivo
de
descripci√≥n
puede
contener
referencias
a
varios
archivos
multimedia


continuos
,
as√≠
como
directivas
para
la
sincronizaci√≥n
de
los
mismos
.
Cada
referencia
a
un


archivo
multimedia
continuo
comienza
con
el
m√©todo
URL
,
rtsp://.
A
continuaci√≥n
pro-


porcionamos
un
archivo
de
presentaci√≥n
que
ha
sido
adaptado
de
[
Schulzrinne
1997
]
.
En


582
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
582esta
presentaci√≥n
se
reproducen
sendos
flujos
de
audio
y
v√≠deo
en
paralelo
y
con
sincroniza-


ci√≥n
del
movimiento
de
los
labios
(
como
parte
del
mismo
grupo
)
.
Para
el
flujo
de
audio
,
el


reproductor
multimedia
puede
elegir
(
conmutar
)
entre
dos
grabaciones
de
audio
,
una
de
baja


fidelidad
y
otra
de
alta
fidelidad
.
(
El
formato
del
archivo
es
similar
a
SMIL
[
SMIL
2009
]
,


formato
que
emplean
muchos
productos
de
transmisi√≥n
de
flujos
multimedia
para
 
definir


presentaciones
multimedia
sincronizadas
.
)


El
servidor
web
encapsula
el
archivo
de
descripci√≥n
de
la
presentaci√≥n
en
un
mensaje


de
respuesta
HTTP
y
lo
env√≠a
al
navegador
.
Cuando
el
navegador
recibe
dicha
respuesta


HTTP
,
invoca
a
un
reproductor
multimedia
(
es
decir
,
a
la
aplicaci√≥n
de
ayuda
)
bas√°ndose
en


el
campo
que
define
el
tipo
de
contenido
del
mensaje
.
El
archivo
de
descripci√≥n
de
la


presentaci√≥n
hace
referencia
a
los
flujos
multimedia
utilizando
el
m√©todo
URL
rtsp://
,


al
igual
que
en
el
ejemplo
anterior
.
Como
se
muestra
en
la
Figura
7.4
,
el
reproductor
y
el


servidor
intercambian
una
serie
de
mensajes
RTSP
.
El
reproductor
env√≠a
una
solicitud
RTSP


SETUP
y
el
servidor
responde
con
una
mensaje
RTSP
OK
.
El
reproductor
env√≠a
una
solici-


tud
RTSP
de
reproducci√≥n
PLA
de
,
digamos
,
audio
de
baja
fidelidad
y
el
servidor
le
res-


ponde
con
un
mensaje
RTSP
OK
.
En
este
punto
,
el
servidor
de
flujos
coloca
el
audio
de
baja


fidelidad
en
su
propio
canal
en
banda
.
A
continuaci√≥n
,
el
reproductor
multimedia
env√≠a
una


solicitud
RTSP
de
pausa
con
el
mensaje
PAUSE
y
el
servidor
responde
de
nuevo
con
un


mensaje
RTSP
OK
.
Cuando
el
usuario
ha
terminado
,
el
reproductor
multimedia
env√≠a
una


solicitud
RTSP
TEARDOWN
para
terminar
la
sesi√≥n
y
el
servidor
confirma
con
un
mensaje


de
respuesta
RTSP
OK
.


7.2
‚Ä¢
FLUJOS
DE
AUDIO
Y
DE
V√çDEO
ALMACENADO
583


Cliente
Servidores


Navegador


web


GET
HTTP


Archivo
de
descripci√≥n


de
la
presentaci√≥n


Configuraci√≥n
(
SETUP
)


Reproducir
(
PLAY
)


Flujo
multimedia


Pausa
(
PAUSE
)


Terminar
(
TEARDOWN
)


Servidor


web


Reproductor


multimedia


Servidor


multimedia


Figura
7.4
‚Ä¢
Interacci√≥n
entre
un
cliente
y
un
servidor
utilizando
RTSP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
583
<
title
>
Twister</title
>


<
session
>


<
group
language
=
en
lipsync
>


<
switch
>


<
track
type
=
audio


e=‚ÄùPCMU/8000/1
‚Äù


src=‚Äùrtsp://audio.example.com
/
twister
/
audio.en
/
lofi
‚Äù
>


<
track
type
=
audio


e=‚ÄùDVI4/16000/2
‚Äù
pt=‚Äù90
DVI4/8000/1
‚Äù


src=‚Äùrtsp://audio.example.com
/
twister
/
audio.en
/
hifi
‚Äù
>


<
/switch
>


<
track
type=‚Äùvideo
/
jpeg
‚Äù


src=‚Äùrtsp://video.example.com
/
twister
/
video
‚Äù
>


<
/group
>


<
/session
>


Veamos
ahora
los
mensajes
RTSP
reales
.
El
siguiente
listado
es
un
ejemplo
simplifi-


cado
de
una
sesi√≥n
RTSP
entre
un
cliente
(
C
:)
y
un
servidor
(
S
:)
.


C
:
SETUP
rtsp://audio.example.com/twister/audio
RTSP/1.0


Cseq
:
1


Transport
:
rtp
/
udp
;
compression
;
port=3056
;
mode
=
PLAY


S
:
RTSP/1.0
200
OK


Cseq
:
1


Session
:
4231


C
:
PLAY
rtsp://audio.example.com/twister/audio.en/lofi
RTSP/1.0


Range
:
npt=0-


Cseq
:
2


Session
:
4231


S
:
RTSP/1.0
200
OK


Cseq
:
2


Session
:
4231


C
:
PAUSE
rtsp://audio.example.com/twister/audio.en/lofi
RTSP/1.0


Range
:
npt=37


Cseq
:
3


Session
:
4231


S
:
RTSP/1.0
200
OK


Cseq
:
3


Session
:
4231


C
:
TEARDOWN
rtsp://audio.example.com/twister/audio.en/lofi
RTSP/1.0


Cseq
:
4


Session
:
4231


S
:
RTSP/1.0
200
OK


Cseq
:
4


Session
:
4231


Es
interesante
destacar
las
similitudes
entre
HTTP
y
RTSP
.
Todos
los
mensajes
de
soli-


citud
y
de
respuesta
est√°n
en
texto
ASCII
,
el
cliente
emplea
m√©todos
estandarizados


584
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
584(SETUP
,
PLAY
,
PAUSE
,
etc.
)
y
el
servidor
responde
con
c√≥digos
de
respuesta
estandariza-


dos
.
No
obstante
,
una
diferencia
importante
es
que
el
servidor
RTSP
controla
el
estado
del


cliente
para
cada
sesi√≥n
RTSP
activa
.
Por
ejemplo
,
el
servidor
controla
si
el
cliente
se


encuentra
en
el
estado
de
inicializaci√≥n
,
de
reproducci√≥n
o
en
pausa
(
v√©ase
la
tarea
de
pro-


gramaci√≥n
al
final
del
cap√≠tulo
)
.
La
sesi√≥n
y
los
n√∫meros
de
secuencia
,
que
forman
parte
de


cada
mensaje
de
solicitud
y
de
respuesta
RTSP
,
ayudan
al
servidor
a
controlar
el
estado
de
la


sesi√≥n
.
El
n√∫mero
de
sesi√≥n
se
fija
para
la
sesi√≥n
completa
;
el
cliente
incrementa
el
n√∫mero


de
secuencia
cada
vez
que
env√≠a
un
nuevo
mensaje
;
el
servidor
se
hace
eco
del
n√∫mero
de


sesi√≥n
y
del
n√∫mero
de
secuencia
actual
.


Como
se
muestra
en
el
ejemplo
,
el
cliente
inicia
la
sesi√≥n
con
la
solicitud
SETUP
,
pro-


porcionando
el
URL
del
archivo
que
va
a
ser
transmitido
como
flujo
y
la
versi√≥n
de
RTSP
.


El
mensaje
de
configuraci√≥n
(
SETUP
)
incluye
el
n√∫mero
de
puerto
del
cliente
al
que
debe


enviarse
el
archivo
multimedia
.
Este
mensaje
de
configuraci√≥n
tambi√©n
indica
que
el


archivo
deber√°
ser
enviado
sobre
UDP
utilizando
el
protocolo
de
empaquetamiento
RTP


(
que
veremos
en
la
Secci√≥n
7.4
)
.
Observe
que
,
en
este
ejemplo
,
el
reproductor
elige
no


reproducir
la
presentaci√≥n
completa
,
sino
s√≥lo
la
parte
de
baja
fidelidad
de
la
misma
.


RTSP
realmente
es
capaz
de
hacer
mucho
m√°s
que
lo
que
hemos
explicado
en
esta
breve


introducci√≥n
.
En
particular
,
RTSP
dispone
de
facilidades
que
permiten
a
los
clientes
dirigir


flujos
hacia
el
servidor
(
por
ejemplo
,
para
grabar
)
.
RTSP
ha
sido
adoptado
por
RealNet-


works
,
uno
de
los
l√≠deres
de
la
industria
en
flujos
de
audio
/
v√≠deo
.
Henning
Schulzrinne
pro-


porciona
una
p√°gina
web
sobre
RTSP
[
Schulzrinne-RTSP
2009
]
.


Al
final
del
cap√≠tulo
puede
encontrar
una
tarea
de
programaci√≥n
para
crear
un
sistema
de


flujos
de
v√≠deo
(
tanto
de
servidor
como
de
cliente
)
que
se
aprovecha
de
RTSP
.
Esta
tarea
pre-


cisa
la
escritura
de
c√≥digo
que
construya
y
env√≠e
realmente
mensajes
RTSP
en
el
cliente
.
La


tarea
proporciona
el
c√≥digo
de
servidor
RTSP
,
el
cual
analiza
los
mensajes
RTSP
y
construye


las
respuestas
apropiadas
.
A
los
lectores
interesados
en
obtener
unos
conocimientos
m√°s
pro-


fundos
sobre
RTSP
les
animamos
a
que
lleven
a
cabo
esta
interesante
tarea
.


7.3
Utilizaci√≥n
√≥ptima
del
servicio
de


entrega
de
mejor
esfuerzo


El
protocolo
Internet
de
la
capa
de
red
,
IP
,
proporciona
un
servicio
de
entrega
de
mejor


esfuerzo
.
Esto
quiere
decir
que
el
servicio
trata
de
hacer
lo
que
puede
para
transferir
cada


datagrama
desde
el
origen
hasta
el
destino
de
la
forma
m√°s
r√°pida
posible
.
Sin
embargo
,
no


realiza
ning√∫n
tipo
de
promesa
en
lo
que
se
refiere
a
la
duraci√≥n
del
retardo
terminal
a
ter-


minal
para
un
paquete
individual
,
ni
de
la
intensidad
de
las
fluctuaciones
temporales
de
los


paquetes
,
ni
tampoco
acerca
de
las
p√©rdidas
de
paquetes
dentro
del
flujo
de
datos
.
La
falta


de
garant√≠as
acerca
del
retardo
y
de
la
fluctuaci√≥n
de
los
paquetes
impone
una
serie
de
desa-


f√≠os
significativos
al
dise√±o
de
aplicaciones
multimedia
en
tiempo
real
,
como
la
telefon√≠a


por
Internet
y
las
videoconferencias
en
tiempo
real
que
son
enormemente
sensibles
a
los


retardos
,
a
las
fluctuaciones
y
a
la
p√©rdida
de
paquetes
.


En
esta
secci√≥n
vamos
a
ver
diversas
formas
en
las
que
pueden
mejorarse
las
prestacio-


nes
de
las
aplicaciones
multimedia
sobre
una
red
basada
en
un
servicio
de
entrega
de
mejor


esfuerzo
.
Nos
vamos
centrar
en
las
t√©cnicas
de
la
capa
de
aplicaci√≥n
;
es
decir
,
en
t√©cnicas


que
no
requieren
efectuar
ninguna
modificaci√≥n
en
el
n√∫cleo
de
la
red
,
ni
tampoco
en
la
capa


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
585


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
585de
transporte
de
los
hosts
terminales
.
En
primer
lugar
describiremos
los
efectos
de
la


p√©rdida
de
paquetes
,
de
los
retardos
y
de
las
fluctuaciones
de
esos
retardos
sobre
las
aplica-


ciones
multimedia
.
A
continuaci√≥n
pasaremos
a
analizar
las
t√©cnicas
utilizadas
para
sobre-


ponerse
a
esas
deficiencias
.
Despu√©s
describiremos
c√≥mo
pueden
emplearse
las
redes
de


distribuci√≥n
de
contenido
y
las
t√©cnicas
de
sobredimensionamiento
de
recursos
para
evitar
la


aparici√≥n
de
esas
deficiencias
.


7.3.1
Limitaciones
de
un
servicio
de
entrega
de
mejor
esfuerzo


Hemos
mencionado
que
el
servicio
de
entrega
de
mejor
esfuerzo
puede
conducir
a
la
p√©r-


dida
de
paquetes
,
a
que
se
experimente
un
retardo
excesivo
terminal
a
terminal
y
a
que
se


manifieste
una
alta
fluctuaci√≥n
temporal
de
los
paquetes
.
Vamos
a
examinar
estas
cuestiones


m√°s
en
detalle
.
Para
que
nuestro
an√°lisis
sea
lo
m√°s
concreto
posible
,
vamos
a
hablar
de


estos
mecanismos
en
el
contexto
de
una
aplicaci√≥n
de
telefon√≠a
Internet
,
descrita
m√°s


abajo
.
La
situaci√≥n
es
similar
para
las
aplicaciones
de
videoconferencia
en
tiempo
real


[
Bolot
1994
]
.


El
hablante
en
nuestro
ejemplo
de
telefon√≠a
por
Internet
genera
una
se√±al
de
audio
que


est√°
compuesta
de
una
serie
alternativa
de
periodos
de
conversaci√≥n
y
periodos
de
silencio
.


Para
poder
ahorrar
ancho
de
banda
,
nuestra
aplicaci√≥n
de
telefon√≠a
por
Internet
s√≥lo
genera


paquetes
durante
los
periodos
de
conversaci√≥n
.
En
cada
uno
de
esos
periodos
de
conversa-


ci√≥n
,
el
emisor
genera
bytes
a
una
velocidad
de
8.000
bytes
por
segundo
y
cada
20
milise-


gundos
agrupa
esos
bytes
en
una
serie
de
fragmentos
.
Por
tanto
,
el
n√∫mero
de
bytes
en
un


fragmento
ser√°
igual
a
(
20
milisegundos
)
¬∑
(
8.000
bytes
/
segundo
)
=
160
bytes
.
A
cada
frag-


mento
se
le
asocia
una
cabecera
especial
cuyo
contenido
analizaremos
m√°s
adelante
.
El
frag-


mento
y
su
cabecera
se
encapsulan
en
un
segmento
UDP
mediante
una
llamada
a
la
interfaz


de
socket
.
De
este
modo
,
durante
un
periodo
de
conversaci√≥n
se
env√≠a
un
segmento
UDP


cada
20
milisegundos
.


Si
cada
paquete
consigue
llegar
al
receptor
y
tiene
un
retardo
terminal
a
terminal
de


duraci√≥n
constante
y
peque√±a
,
entonces
los
paquetes
llegar√°n
al
receptor
peri√≥dicamente


cada
20
milisegundos
durante
los
periodos
de
conversaci√≥n
.
En
estas
condiciones
ideales
,
el


receptor
puede
simplemente
reproducir
cada
fragmento
en
cuanto
lo
recibe
.
Pero
lamenta-


blemente
,
algunos
paquetes
pueden
perderse
y
la
mayor√≠a
de
los
paquetes
no
tendr√°
el


mismo
retardo
terminal
a
terminal
,
incluso
en
una
Internet
que
est√©
congestionada
s√≥lo
lige-


ramente
.
Por
esta
raz√≥n
,
el
receptor
debe
tener
algo
m√°s
de
cuidado
a
la
hora
de
determinar


(
1
)
cu√°ndo
hay
que
reproducir
un
fragmento
y
(
2
)
qu√©
hay
que
hacer
cuando
falta
un
frag-


mento
.


P√©rdida
de
paquetes


Considere
uno
de
los
segmentos
UDP
generados
por
nuestra
aplicaci√≥n
de
telefon√≠a
Inter-


net
.
El
segmento
UDP
se
encapsula
dentro
de
un
datagrama
IP
.
A
medida
que
el
datagrama


viaja
por
la
red
pasa
por
una
serie
de
buffers
(
es
decir
,
colas
)
en
los
routers
para
poder
acce-


der
a
los
enlaces
de
salida
de
√©stos
.
Es
posible
que
uno
o
m√°s
de
los
buffers
en
la
ruta
exis-


tente
entre
el
emisor
y
el
receptor
est√©
lleno
y
no
pueda
admitir
el
datagrama
IP
.
En
este
caso


el
datagrama
IP
ser√°
descartado
,
por
lo
que
nunca
llegar√°
a
la
aplicaci√≥n
receptora
.


Las
p√©rdidas
podr√≠an
eliminarse
enviando
los
paquetes
sobre
TCP
en
lugar
de
sobre


UDP
.
Recuerde
que
TCP
retransmite
los
paquetes
que
no
llegan
a
su
destino
.
Sin
embargo
,


los
mecanismos
de
retransmisi√≥n
se
suelen
considerar
inaceptables
para
las
aplicaciones
de


586
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
586audio
interactivas
en
tiempo
real
,
como
la
de
telefon√≠a
por
Internet
,
porque
incrementan
el


retardo
terminal
a
terminal
[
Bolot
1996
]
.
Adem√°s
,
debido
al
control
de
congesti√≥n
de
TCP
,


la
velocidad
de
transmisi√≥n
en
el
emisor
puede
verse
reducida
despu√©s
de
una
p√©rdida
de


paquetes
,
fij√°ndose
una
velocidad
inferior
a
la
velocidad
de
consumo
de
paquetes
en
el


receptor
.
Esto
puede
tener
un
impacto
grave
sobre
la
inteligibilidad
de
la
voz
en
el
receptor
.


Por
estas
razones
,
la
mayor√≠a
de
las
aplicaciones
de
telefon√≠a
por
Internet
existentes
se
eje-


cutan
sobre
UDP
y
no
se
preocupan
de
retransmitir
los
paquetes
perdidos
.
[
Baset
2006
]


informa
de
que
Skype
utiliza
UDP
a
menos
que
un
usuario
se
encuentre
detr√°s
de
un
traduc-


tor
NAT
o
de
un
cortafuegos
que
bloquee
los
segmentos
UDP
(
en
cuyo
caso
se
emplea
TCP
)
.


Pero
las
p√©rdidas
de
paquetes
no
son
necesariamente
tan
desastrosas
como
podr√≠a
pare-


cer
.
De
hecho
,
se
pueden
tolerar
perfectamente
tasas
de
p√©rdida
de
paquetes
de
entre
el
1
y


el
20
por
ciento
,
dependiendo
de
c√≥mo
se
codifique
y
transmita
la
voz
y
de
c√≥mo
se
oculten


esas
p√©rdidas
en
el
receptor
.
Por
ejemplo
,
los
mecanismos
de
correcci√≥n
de
errores
hacia


adelante
(
FEC
,
Forward
Error
Correction
)
pueden
ayudar
a
ocultar
las
p√©rdidas
de
paque-


tes
.
Veremos
m√°s
adelante
que
con
las
t√©cnicas
FEC
se
transmite
informaci√≥n
redundante


junto
con
la
informaci√≥n
original
,
de
modo
que
una
parte
de
los
datos
originales
perdidos


puede
recuperarse
a
partir
de
esa
informaci√≥n
redundante
.
Sin
embargo
,
si
uno
o
m√°s
de
los


enlaces
existentes
entre
el
emisor
y
el
receptor
est√°
severamente
congestionado
y
la
tasa
de


p√©rdida
de
paquetes
excede
del
10
o
20
por
ciento
(
aunque
estas
tasas
tan
altas
raramente
se


observan
en
las
redes
bien
dise√±adas
)
,
entonces
no
hay
nada
que
podamos
hacer
para
conse-


guir
una
calidad
de
sonido
aceptable
.
Claramente
,
el
servicio
de
entrega
de
mejor
esfuerzo


tiene
sus
limitaciones
.


Retardo
terminal
a
terminal


El
retardo
terminal
a
terminal
es
la
suma
de
los
retardos
de
transmisi√≥n
,
de
procesamiento


y
de
puesta
en
cola
de
los
routers
;
los
retardos
de
propagaci√≥n
de
los
enlaces
y
los
retardos


de
procesamiento
en
los
sistemas
terminales
.
Para
las
aplicaciones
de
audio
altamente
inte-


ractivas
,
como
la
telefon√≠a
por
Internet
,
los
retardos
terminal
a
terminal
inferiores
a
150


milisegundos
no
son
perceptibles
por
los
oyentes
humanos
;
los
retardos
entre
150
y
400


milisegundos
son
aceptables
,
aunque
distan
mucho
de
ser
ideales
,
y
los
retardos
mayores


que
400
milisegundos
pueden
afectar
seriamente
a
la
interactividad
en
las
conversaciones
de


voz
.
El
lado
receptor
de
una
aplicaci√≥n
de
telefon√≠a
por
Internet
descartar√°
normalmente


todos
los
paquetes
que
est√©n
retardados
m√°s
de
un
cierto
umbral
,
como
por
ejemplo
m√°s
de


400
milisegundos
.
Por
tanto
,
los
paquetes
cuyo
retardo
sea
superior
al
umbral
prefijado
se


perder√°n
.


Fluctuaci√≥n
de
los
paquetes


Un
componente
crucial
del
retardo
terminal
a
terminal
son
los
retardos
aleatorios
de
puesta


en
cola
dentro
de
los
routers
.
A
causa
de
estos
retardos
variables
dentro
de
la
red
,
el
tiempo


que
transcurre
desde
el
momento
en
que
se
genera
un
paquete
en
el
origen
hasta
que
se


recibe
en
el
destino
puede
fluctuar
de
un
paquete
a
otro
.
Este
fen√≥meno
se
conoce
como


fluctuaci√≥n
o
jitter
.


Por
ejemplo
,
considere
dos
paquetes
consecutivos
dentro
de
un
periodo
de
conversaci√≥n


de
nuestra
aplicaci√≥n
de
telefon√≠a
por
Internet
.
El
emisor
env√≠a
el
segundo
paquete
20
milise-


gundos
despu√©s
de
enviar
el
primero
.
Pero
en
el
receptor
,
el
espaciado
entre
estos
paquetes


puede
ser
mayor
de
20
milisegundos
.
Para
ver
por
qu√©
,
suponga
que
el
primer
paquete
llega
a


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
587


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
587una
cola
pr√°cticamente
vac√≠a
dentro
de
un
router
y
que
,
justo
antes
de
que
el
segundo
paquete


llegue
a
esa
misma
cola
,
entran
en
la
cola
un
gran
n√∫mero
de
paquetes
procedentes
de
otros


or√≠genes
.
Puesto
que
el
primer
paquete
sufre
un
peque√±o
retardo
de
puesta
en
cola
y
el


segundo
paquete
sufre
un
retardo
de
puesta
en
cola
mucho
mayor
dentro
de
este
router
,


el
espaciado
entre
el
primer
y
el
segundo
paquete
ser√°
superior
a
20
milisegundos
.
De
la


misma
manera
,
el
espaciado
entre
paquetes
consecutivos
tambi√©n
podr√≠a
ser
inferior
a
20


milisegundos
.
Para
ver
por
qu√©
,
considere
de
nuevo
dos
paquetes
consecutivos
dentro
de
un


periodo
de
conversaci√≥n
.
Suponga
que
el
primer
paquete
se
coloca
al
final
de
una
cola
que


contiene
un
gran
n√∫mero
de
paquetes
y
que
el
segundo
paquete
llega
a
esa
cola
antes
de


que
otros
paquetes
de
otros
or√≠genes
entren
en
la
cola
.
En
este
caso
,
nuestros
dos
paquetes


estar√°n
uno
detr√°s
del
otro
dentro
de
la
cola
.
Si
el
tiempo
que
se
tarda
en
transmitir
un
paquete


a
trav√©s
del
enlace
de
salida
del
router
es
inferior
a
20
milisegundos
,
entonces
el
espaciado


entre
el
primer
y
el
segundo
paquete
ser√°
tambi√©n
inferior
a
20
milisegundos
.


La
situaci√≥n
es
an√°loga
a
la
que
se
produce
cuando
circulan
veh√≠culos
por
una
carre-


tera
.
Suponga
que
usted
y
un
amigo
viajan
cada
uno
en
su
autom√≥vil
desde
San
Diego
a


F√©nix
.
Suponga
tambi√©n
que
usted
y
su
amigo
tienen
formas
similares
de
conducir
y
que


ambos
viajan
a
100
km
/
hora
cuando
el
tr√°fico
lo
permite
.
Finalmente
,
suponga
que
su
amigo


comienza
el
viaje
una
hora
antes
que
usted
.
Entonces
,
dependiendo
del
tr√°fico
con
el
que
√©l


o
usted
se
encuentren
,
puede
que
llegue
a
F√©nix
menos
de
una
hora
o
m√°s
de
una
hora
des-


pu√©s
que
su
amigo
.


Si
el
receptor
ignora
la
presencia
de
las
fluctuaciones
y
reproduce
los
segmentos
en


cuanto
llegan
,
entonces
la
calidad
del
audio
resultante
puede
llegar
a
ser
ininteligible
en
el


receptor
.
Afortunadamente
,
las
fluctuaciones
pueden
eliminarse
a
menudo
utilizando
n√∫me-


ros
de
secuencia
,
marcas
de
tiempo
y
un
retardo
de
reproducci√≥n
,
como
se
explica
a
con-


tinuaci√≥n
.


7.3.2
Eliminaci√≥n
de
las
fluctuaciones
al
reproducir


el
audio
en
el
receptor


Para
una
aplicaci√≥n
de
voz
como
la
telefon√≠a
por
Internet
o
la
m√∫sica
bajo
demanda
,
el


receptor
debe
tratar
de
reproducir
s√≠ncronamente
los
fragmentos
de
voz
en
presencia
de
unas


fluctuaciones
aleatorias
en
la
red
;
las
aplicaciones
de
v√≠deo
tienen
a
menudo
requisitos
simi-


lares
.
Esto
normalmente
se
hace
combinando
los
siguientes
tres
mecanismos
:


‚Ä¢
Precediendo
cada
fragmento
con
un
n√∫mero
de
secuencia
.
El
emisor
incrementa
el


n√∫mero
de
secuencia
en
una
unidad
por
cada
uno
de
los
paquetes
que
genera
.


‚Ä¢
Precediendo
cada
fragmento
con
una
marca
de
tiempo
.
El
emisor
marca
cada
fragmento


con
la
hora
a
la
que
el
fragmento
fue
generado
.


‚Ä¢
Retardando
la
reproducci√≥n
de
los
fragmentos
en
el
receptor
.
El
retardo
de
reproduc-


ci√≥n
de
los
fragmentos
de
audio
recibidos
debe
ser
lo
suficientemente
grande
como
para


que
la
mayor
parte
de
los
paquetes
se
reciban
antes
de
su
instante
de
reproducci√≥n
plani-


ficado
.
Este
retardo
de
reproducci√≥n
puede
ser
fijo
a
lo
largo
de
toda
la
sesi√≥n
de
audio
,


o
variar
adaptativamente
a
lo
largo
de
dicha
sesi√≥n
.
Los
paquetes
que
no
lleguen
antes
de


su
tiempo
de
reproducci√≥n
planificado
se
consideran
paquetes
perdidos
y
se
ignoran
;


como
hemos
indicado
anteriormente
,
el
receptor
puede
utilizar
alg√∫n
tipo
de
interpola-


ci√≥n
de
voz
para
tratar
de
ocultar
las
p√©rdidas
.


588
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
588Veamos
ahora
c√≥mo
pueden
aliviar
o
incluso
eliminar
los
efectos
de
las
fluctuaciones


estos
tres
mecanismos
cuando
se
les
combina
apropiadamente
.
Vamos
a
examinar
dos


estrategias
de
reproducci√≥n
:
el
retardo
de
reproducci√≥n
fijo
y
el
retardo
de
reproducci√≥n


adaptativo
.


Retardo
de
reproducci√≥n
fijo


Con
la
estrategia
basada
en
un
retardo
fijo
,
el
receptor
intenta
reproducir
cada
fragmento


exactamente
q
milisegundos
despu√©s
de
que
ese
fragmento
haya
sido
generado
.
Por
tanto
,
si


un
fragmento
tiene
una
marca
de
tiempo
que
indica
que
fue
generado
en
el
instante
t
,
el


receptor
reproduce
dicho
fragmento
en
el
instante
t
+
q
,
suponiendo
que
el
fragmento
haya


llegado
antes
de
ese
momento
.
Los
paquetes
que
lleguen
despu√©s
de
su
instante
de
repro-


ducci√≥n
planificado
se
descartan
y
se
consideran
perdidos
.


¬ø
Qu√©
valor
ser√≠a
adecuado
para
q
?
La
telefon√≠a
por
Internet
puede
permitir
retardos
de


hasta
unos
400
milisegundos
,
aunque
se
consigue
una
experiencia
interactiva
m√°s
satisfac-


toria
con
valores
de
q
menores
.
Por
otro
lado
,
si
hacemos
q
mucho
menor
que
400
milise-


gundos
,
entonces
muchos
paquetes
podr√≠an
no
llegar
antes
de
su
instante
de
reproducci√≥n


planificado
debido
a
la
fluctuaci√≥n
de
los
paquetes
por
causa
de
la
red
.
Por
simplificar
,
diga-


mos
que
si
suelen
experimentarse
grandes
variaciones
en
los
retardos
terminal
a
terminal
es


preferible
utilizar
un
valor
de
q
grande
;
por
el
contrario
,
si
el
retardo
es
peque√±o
y
las
varia-


ciones
del
mismo
tambi√©n
es
preferible
emplear
un
valor
de
q
peque√±o
,
tal
vez
inferior
a
150


milisegundos
.


En
la
Figura
7.5
se
ilustra
este
compromiso
entre
el
retardo
de
reproducci√≥n
y
la
tasa
de


p√©rdida
de
paquetes
.
La
figura
muestra
los
instantes
en
que
se
generan
los
paquetes
y
los
ins-


tantes
en
que
esos
paquetes
se
reproducen
para
un
√∫nico
periodo
de
conversaci√≥n
.
En
la


figura
se
consideran
dos
retardos
de
reproducci√≥n
iniciales
diferentes
.
Como
se
muestra
en


la
l√≠nea
escalonada
de
la
izquierda
,
el
emisor
genera
paquetes
a
intervalos
peri√≥dicos
(
por


ejemplo
,
cada
20
milisegundos
)
.
El
primer
paquete
de
ese
periodo
de
conversaci√≥n
se
recibe


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
589


Paquetes


generados


Tiempo


Paquetes


r
p
p
'


Planificaci√≥n
de


reproducci√≥n


p‚Äìr


Planificaci√≥n
de


reproducci√≥n


p'‚Äìr


Paquetes


recibidos


Reproducci√≥n


omitida


Figura
7.5
‚Ä¢
P√©rdidas
de
paquetes
para
distintos
retardos
de
reproducci√≥n
fijos
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
589en
el
instante
r.
Como
se
muestra
en
la
figura
,
los
instantes
de
llegada
de
los
paquetes
suce-


sivos
no
est√°n
espaciados
de
manera
uniforme
debido
a
las
fluctuaciones
de
la
red
.


Para
la
primera
planificaci√≥n
de
reproducci√≥n
se
fija
un
retardo
de
reproducci√≥n
inicial


fijo
de
p
‚Äì
r.
Con
esta
planificaci√≥n
el
cuarto
paquete
no
llega
antes
de
su
instante
de
repro-


ducci√≥n
planificado
,
por
lo
que
el
reproductor
considera
que
se
ha
perdido
.
En
la
segunda


planificaci√≥n
de
reproducci√≥n
el
retardo
de
reproducci√≥n
inicial
fijo
se
hace
igual
a
p 
‚Äì
r.


Para
esta
planificaci√≥n
todos
los
paquetes
llegan
antes
de
su
instante
de
reproducci√≥n
plani-


ficado
,
por
lo
que
no
se
produce
ninguna
p√©rdida
.


Retardo
de
reproducci√≥n
adaptativo


El
ejemplo
anterior
ilustra
un
importante
compromiso
entre
el
retardo
y
la
tasa
de
p√©rdidas


que
surge
siempre
a
la
hora
de
dise√±ar
una
estrategia
de
reproducci√≥n
con
retardos
de
repro-


ducci√≥n
fijos
.
Si
hacemos
que
el
retardo
inicial
de
reproducci√≥n
sea
grande
,
la
mayor√≠a
de


los
paquetes
llegar√°n
a
tiempo
y
por
tanto
habr√°
una
tasa
de
p√©rdidas
despreciable
;
sin


embargo
,
para
servicios
interactivos
como
la
telefon√≠a
por
Internet
,
esos
grandes
retardos


pueden
resultar
molestos
,
si
no
intolerables
.
Idealmente
,
lo
que
queremos
es
minimizar
el


retardo
de
reproducci√≥n
bajo
la
restricci√≥n
de
que
la
tasa
de
p√©rdidas
sea
inferior
a
un
cierto


porcentaje
precisado
y
peque√±o
.


La
forma
natural
de
tratar
con
este
compromiso
es
estimar
el
retardo
de
la
red
y
la


varianza
de
ese
retardo
y
ajustar
el
retardo
de
reproducci√≥n
correspondientemente
al
princi-


pio
de
cada
periodo
de
conversaci√≥n
.
Este
ajuste
adaptativo
de
los
retardos
de
reproducci√≥n


al
principio
de
los
periodos
de
conversaci√≥n
har√°
que
los
periodos
de
silencio
del
emisor
se


compriman
y
estiren
;
sin
embargo
,
la
compresi√≥n
y
el
alargamiento
de
esos
silencios
en
una


proporci√≥n
razonable
no
resulta
perceptible
durante
la
conversaci√≥n
.


De
acuerdo
con
lo
expuesto
en
[
Ramjee
1994
]
,
ahora
vamos
a
describir
un
algoritmo


gen√©rico
que
puede
utilizar
el
receptor
para
ajustar
adaptativamente
sus
retardos
de
repro-


ducci√≥n
.
Con
este
fin
,
sean


ti
=
la
marca
de
tiempo
del
paquete
i-√©simo
,
es
decir
,
el
instante
en
que
el
paquete
fue


generado
por
el
emisor


ri
=
el
instante
en
el
que
el
paquete
i
llega
al
receptor


pi
=
el
instante
en
el
que
el
receptor
reproduce
el
paquete
i


El
retardo
terminal
a
terminal
de
la
red
para
el
paquete
i-√©simo
es
ri
‚Äì
ti
.
Debido
a
la


fluctuaci√≥n
de
la
red
este
retardo
variar√°
de
un
paquete
a
otro
.
Sea
di
una
estimaci√≥n
del


retardo
promedio
de
la
red
al
recibirse
el
paquete
i-√©simo
.
Esta
estimaci√≥n
se
calcula
a
partir


de
la
marca
de
tiempo
de
la
forma
siguiente
:


di
=
(
1
‚Äì
u
)
di‚Äì1
+
u
(
ri
‚Äì
ti
)


donde
u
es
una
constante
fija
(
por
ejemplo
,
u
=
0,01
)
.
Por
tanto
,
di
es
una
media
m√≥vil
de


los
retardos
de
red
observados
r1
‚Äì
t1
,
.
.
.
,
ri
‚Äì
ti
.
La
estimaci√≥n
asigna
un
mayor
peso
a
los


retardos
de
red
m√°s
recientemente
observados
que
a
los
del
pasado
m√°s
distante
.
Esta
forma


de
estimaci√≥n
no
deber√≠a
resultarle
extra√±a
al
lector
;
una
idea
similar
se
emplea
para
estimar


los
tiempos
de
ida
y
vuelta
en
TCP
,
como
hemos
visto
en
el
Cap√≠tulo
3
.
Sea
vi
una
estima-


ci√≥n
de
la
desviaci√≥n
media
del
retardo
con
respecto
al
retardo
promedio
estimado
.
Esta
esti-


maci√≥n
tambi√©n
se
construye
a
partir
de
las
marcas
de
tiempo
:


590
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
590vi
=
(
1
‚Äì
u
)
vi‚Äì1
+
u
|
ri
‚Äì
ti
‚Äì
di
|


Las
estimaciones
di
y
vi
se
calculan
para
cada
paquete
recibido
,
aunque
s√≥lo
se
utilizan
para


determinar
el
punto
de
reproducci√≥n
del
primer
paquete
de
cada
periodo
de
conversaci√≥n
.


Una
vez
que
se
han
calculado
estas
estimaciones
,
el
receptor
emplea
el
siguiente
algo-


ritmo
para
la
reproducci√≥n
de
los
paquetes
.
Si
el
paquete
i
es
el
primero
de
un
periodo
de


conversaci√≥n
,
su
instante
de
reproducci√≥n
pi
se
calcula
como
:


pi
=
ti
+
di
+
Kvi


donde
K
es
una
constante
positiva
(
por
ejemplo
,
K
=
4
)
.
El
prop√≥sito
del
t√©rmino
Kvi
es
esta-


blecer
el
instante
de
reproducci√≥n
lo
suficientemente
lejos
en
el
futuro
como
para
que
s√≥lo


una
peque√±a
fracci√≥n
de
los
paquetes
correspondientes
a
ese
periodo
de
conversaci√≥n
que


vayan
llegando
se
pierdan
debido
a
una
llegada
tard√≠a
.
El
instante
de
reproducci√≥n
para
los


siguientes
paquetes
de
un
periodo
de
conversaci√≥n
se
calcula
mediante
un
desplazamiento


con
respecto
al
instante
en
el
que
el
primer
paquete
de
ese
periodo
de
conversaci√≥n
se
repro-


duce
.
En
particular
,
sea


qi
=
pi
‚Äì
ti


la
diferencia
temporal
entre
el
instante
en
que
se
gener√≥
el
primer
paquete
del
periodo
de


conversaci√≥n
y
el
instante
en
se
reprodujo
.
Si
el
paquete
j
tambi√©n
pertenece
al
mismo


periodo
de
conversaci√≥n
se
reproducir√°
en
el
instante


pj
=
tj
+
qi


El
algoritmo
reci√©n
descrito
tiene
mucho
sentido
,
asumiendo
que
el
receptor
pueda


determinar
si
un
paquete
es
el
primero
de
su
correspondiente
periodo
de
conversaci√≥n
.
Si
no


hay
p√©rdidas
de
paquetes
,
entonces
el
receptor
podr√°
determinar
si
el
paquete
i
es
el
primero


de
su
periodo
de
conversaci√≥n
comparando
la
marca
de
tiempo
del
paquete
i-√©simo
con
la


del
paquete
(
i
‚Äì
1)-√©simo
.
De
hecho
,
si
ti
‚Äì
ti‚Äì1
>
20
milisegundos
,
entonces
el
receptor
sabe


que
el
paquete
i-√©simo
est√°
dando
inicio
a
un
nuevo
paquete
de
conversaci√≥n
.
Pero
ahora


suponga
que
existen
p√©rdidas
ocasionales
de
paquetes
.
En
este
caso
,
dos
paquetes
sucesivos


recibidos
en
el
destino
pueden
tener
marcas
de
tiempo
que
difieren
en
m√°s
de
20
milisegun-


dos
,
a
pesar
de
que
ambos
paquetes
pertenecen
al
mismo
periodo
de
conversaci√≥n
.
Y
es
por


esta
raz√≥n
por
la
que
los
n√∫meros
de
secuencia
resultan
particularmente
√∫tiles
.
El
receptor


puede
emplear
los
n√∫meros
de
secuencia
para
determinar
si
esa
diferencia
de
m√°s
de
20


milisegundos
en
las
marcas
de
tiempo
se
debe
a
un
nuevo
periodo
de
conversaci√≥n
o
a
la


p√©rdida
de
paquetes
.


Flujos
de
audio
y
v√≠deo
almacenado


Concluyamos
esta
secci√≥n
con
algunas
palabras
acerca
de
los
flujos
de
audio
y
v√≠deo
alma-


cenado
.
Normalmente
,
las
aplicaciones
de
audio
/
v√≠deo
almacenado
tambi√©n
utilizan
los


n√∫meros
de
secuencia
,
las
marcas
de
tiempo
y
el
retardo
de
reproducci√≥n
para
aliviar
o


incluso
eliminar
los
efectos
de
fluctuaci√≥n
de
la
red
.
Sin
embargo
,
existe
una
importante


diferencia
entre
el
audio
/
v√≠deo
interactivo
en
tiempo
real
y
los
flujos
de
audio
/
v√≠deo
almace-


nado
.
Espec√≠ficamente
,
los
flujos
de
audio
/
v√≠deo
almacenado
pueden
tolerar
retardos
signi-


ficativamente
mayores
.
De
hecho
,
cuando
un
usuario
solicita
un
clip
de
audio
/
v√≠deo
,
le


resulta
perfectamente
aceptable
esperar
cinco
segundos
o
m√°s
antes
de
que
la
reproducci√≥n


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
591


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
591comience
.
Y
la
mayor√≠a
de
los
usuarios
pueden
tolerar
tambi√©n
retardos
similares
despu√©s


de
llevar
a
cabo
operaciones
interactivas
tales
como
un
salto
temporal
dentro
del
flujo
mul-


timedia
.
Esta
mayor
tolerancia
al
retardo
proporciona
al
desarrollador
de
aplicaciones
una


mayor
flexibilidad
a
la
hora
de
dise√±ar
aplicaciones
para
datos
multimedia
almacenados
.


7.3.3
Recuperaci√≥n
frente
a
p√©rdidas
de
paquetes


Hemos
explicado
con
un
cierto
grado
de
detalle
c√≥mo
una
aplicaci√≥n
de
telefon√≠a
por
Inter-


net
puede
enfrentarse
a
la
fluctuaci√≥n
de
los
paquetes
.
Ahora
vamos
a
describir
brevemente


diversos
esquemas
que
tratan
de
preservar
una
calidad
de
audio
aceptable
en
presencia
del


fen√≥meno
de
p√©rdida
de
paquetes
.
Dichos
esquemas
se
denominan
esquemas
de
recupera-


ci√≥n
frente
a
p√©rdidas
.
Aqu√≠
,
definimos
la
p√©rdida
de
paquetes
en
un
sentido
amplio
:
un


paquete
se
pierde
si
nunca
llega
al
receptor
o
si
llega
despu√©s
de
su
instante
de
reproducci√≥n


planificado
.
Nuestro
ejemplo
de
telefon√≠a
por
Internet
nos
servir√°
de
nuevo
de
contexto
para


describir
los
esquemas
de
recuperaci√≥n
frente
a
p√©rdidas
.
 

Como
hemos
mencionado
al
principio
de
esta
secci√≥n
,
la
retransmisi√≥n
de
los
paquetes


perdidos
generalmente
no
resulta
apropiada
en
una
aplicaci√≥n
interactiva
en
tiempo
real


como
la
de
telefon√≠a
por
Internet
.
De
hecho
,
la
retransmisi√≥n
de
un
paquete
que
no
haya
lle-


gado
antes
de
su
instante
de
reproducci√≥n
planificado
no
tiene
ning√∫n
sentido
.
Retransmitir


un
paquete
que
ha
desbordado
la
cola
de
un
router
no
suele
poder
hacerse
con
la
suficiente


rapidez
.
Debido
a
estas
consideraciones
,
las
aplicaciones
de
telefon√≠a
por
Internet
utilizan
a


menudo
alg√∫n
tipo
de
esquema
de
anticipaci√≥n
de
p√©rdidas
.
Dos
tipos
de
esquemas
de
anti-


cipaci√≥n
de
p√©rdidas
son
la
correcci√≥n
de
errores
hacia
adelante
(
FEC
,
Forward
Error


Correction
)
y
el
intercalado
.


Correcci√≥n
de
errores
hacia
adelante
(
FEC
)


La
idea
b√°sica
de
la
t√©cnica
FEC
consiste
en
a√±adir
informaci√≥n
redundante
al
flujo
original


de
paquetes
.
A
cambio
de
incrementar
ligeramente
la
velocidad
de
transmisi√≥n
del
flujo
de


audio
,
esa
informaci√≥n
redundante
puede
utilizarse
para
reconstruir
aproximaciones
o
ver-


siones
exactas
de
algunos
de
los
paquetes
perdidos
.
Siguiendo
lo
expuesto
en
[
Bolot
1996
]
y


[
Perkins
1998
]
,
vamos
a
esbozar
dos
mecanismos
FEC
sencillos
.
El
primero
de
ellos
env√≠a


un
fragmento
redundante
codificado
despu√©s
de
cada
n
fragmentos
.
El
fragmento
redun-


dante
se
obtiene
aplicando
la
operaci√≥n
OR
exclusiva
a
los
n
fragmentos
originales
[
Sha-


cham
1990
]
.
De
esta
manera
,
si
alg√∫n
paquete
del
grupo
de
los
n
+
1
paquetes
se
pierde
el


receptor
puede
reconstruir
completamente
el
paquete
perdido
.
Pero
si
se
pierden
dos
o
m√°s


paquetes
de
un
grupo
,
el
receptor
no
podr√°
reconstruirlos
.
Manteniendo
peque√±o
el
tama√±o


del
grupo
,
n
+
1
,
un
gran
porcentaje
de
los
paquetes
perdidos
puede
recuperarse
siempre
que


la
tasa
de
p√©rdidas
no
sea
excesiva
.
Sin
embargo
,
cuanto
m√°s
peque√±o
sea
el
tama√±o
del


grupo
,
mayor
ser√°
el
incremento
relativo
de
la
velocidad
de
transmisi√≥n
del
flujo
de
audio
.


En
particular
,
la
velocidad
de
transmisi√≥n
se
incrementa
seg√∫n
un
factor
de
1/
n
;
por
ejem-


plo
,
si
n
=
3
la
velocidad
de
transmisi√≥n
se
incrementa
en
un
33
por
ciento
.
Adem√°s
,
este


esquema
sencillo
incrementa
el
retardo
de
reproducci√≥n
,
ya
que
el
receptor
tiene
que
esperar


a
recibir
el
grupo
de
paquetes
completo
antes
de
poder
iniciar
la
reproducci√≥n
.
Para
ver
deta-


lles
m√°s
pr√°cticos
acerca
de
c√≥mo
funciona
el
mecanismo
FEC
en
el
transporte
de
datos


multimedia
,
consulte
[
RFC
2733
]
.


El
segundo
mecanismo
FEC
consiste
en
enviar
un
flujo
de
audio
de
menor
resoluci√≥n


como
informaci√≥n
redundante
.
Por
ejemplo
,
el
emisor
podr√≠a
crear
un
flujo
de
audio
nomi-


592
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
592nal
y
otro
flujo
correspondiente
de
baja
resoluci√≥n
y
baja
tasa
de
bit
.
(
El
flujo
nominal


podr√≠a
ser
una
codificaci√≥n
PCM
a
64
kbps
y
el
flujo
de
menor
calidad
podr√≠a
ser
una
codi-


ficaci√≥n
GSM
a
13
kbps
.
)
El
flujo
de
baja
velocidad
de
bit
se
denomina
flujo
redundante
.


Como
se
muestra
en
la
Figura
7.6
,
el
emisor
construye
el
n-√©simo
paquete
tomando
el
n-


√©simo
fragmento
del
flujo
nominal
y
a√±adi√©ndole
el
(
n
‚Äì
1)-
√©simo
fragmento
del
flujo


redundante
.
De
este
manera
,
cuando
existan
p√©rdidas
de
paquetes
no
consecutivos
,
el
recep-


tor
podr√°
ocultar
esa
p√©rdida
reproduciendo
el
fragmento
codificado
de
baja
tasa
de
bit
que


llegue
con
el
siguiente
paquete
.
Por
supuesto
,
los
fragmentos
de
baja
tasa
de
bit
proporcio-


nan
una
menor
calidad
que
los
fragmentos
nominales
.
Sin
embargo
,
un
flujo
compuesto
por


una
gran
mayor√≠a
de
fragmentos
de
alta
calidad
,
algunos
fragmentos
ocasionales
de
baja


calidad
y
en
el
que
no
falte
ning√∫n
fragmento
proporciona
una
buena
calidad
global
de


audio
.
Observe
que
,
en
este
esquema
,
el
receptor
s√≥lo
tiene
que
recibir
dos
paquetes
para


comenzar
a
reproducir
,
por
lo
que
el
incremento
en
el
retardo
de
reproducci√≥n
es
peque√±o
.


Adem√°s
,
si
la
codificaci√≥n
a
baja
velocidad
es
muy
inferior
a
la
codificaci√≥n
nominal
,
enton-


ces
el
incremento
en
la
velocidad
de
transmisi√≥n
ser√°
peque√±o
.


Para
poder
resolver
el
problema
de
la
p√©rdida
de
paquetes
consecutivos
podemos
utili-


zar
una
sencilla
variante
.
En
lugar
de
a√±adir
simplemente
el
(
n
‚Äì
1)-√©simo
fragmento
de
tasa


de
bit
baja
al
n-√©simo
fragmento
nominal
,
el
emisor
puede
a√±adir
el
(
n
‚Äì
1
)
-√©simo
y
el
(
n
‚Äì


2)-√©simo
fragmentos
de
baja
tasa
de
bit
,
o
a√±adir
el
(
n
‚Äì
1
)
-√©simo
y
el
(
n
‚Äì
3)-√©simo
frag-


mentos
de
baja
tasa
de
bit
,
etc.
A√±adiendo
m√°s
fragmentos
de
baja
tasa
de
bit
al
fragmento


nominal
,
la
calidad
de
audio
en
el
receptor
ser√°
aceptable
para
una
mayor
variedad
de
entor-


nos
de
entrega
de
paquetes
de
mejor
esfuerzo
en
presencia
de
p√©rdidas
.
Por
otro
lado
,
cada


fragmento
adicional
incrementa
el
ancho
de
banda
de
transmisi√≥n
y
el
retardo
de
reproduc-


ci√≥n
.


RAT
[
RAT
2009
]
es
una
aplicaci√≥n
de
telefon√≠a
por
Internet
bien
documentada
que
uti-


liza
mecanismos
FEC
.
Puede
transmitir
flujos
de
audio
de
menor
calidad
junto
con
el
flujo


de
audio
nominal
,
tal
como
hemos
descrito
anteriormente
.
Consulte
tambi√©n
[
Rosenberg


2000
]
.


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
593


1


11


1


1


2


2


2
2


3


3


p√©rdida


3
4


3
41
2


3
4


4


Redundancia


Flujo


recibido


Flujo


original


Flujo


reconstruido


Figura
7.6
‚Ä¢
Inserci√≥n
de
informaci√≥n
redundante
de
menor
calidad
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
593Intercalado


Como
alternativa
a
la
transmisi√≥n
de
informaci√≥n
redundante
,
una
aplicaci√≥n
de
telefon√≠a


por
Internet
puede
enviar
el
audio
intercalado
.
Como
se
muestra
en
la
Figura
7.7
,
el
emisor


reordena
las
unidades
de
datos
de
audio
antes
de
su
transmisi√≥n
,
de
forma
que
las
unidades


originalmente
adyacentes
est√°n
separadas
por
un
cierta
distancia
dentro
del
flujo
transmi-


tido
.
El
intercalado
puede
mitigar
el
efecto
de
la
p√©rdida
de
paquetes
.
Si
,
por
ejemplo
,
las


unidades
tienen
una
longitud
de
5
milisegundos
y
los
fragmentos
tienen
una
longitud
de
20


milisegundos
(
es
decir
,
hay
cuatro
unidades
por
fragmento
)
,
entonces
el
primer
fragmento


podr√≠a
contener
las
unidades
1
,
5
,
9
y
13
;
el
segundo
fragmento
podr√≠a
contener
las
unidades


2
,
6
,
10
y
14
,
y
as√≠
sucesivamente
.
La
Figura
7.7
muestra
que
la
p√©rdida
de
un
√∫nico
paquete


en
un
flujo
intercalado
da
como
resultado
una
serie
de
m√∫ltiples
huecos
peque√±os
en
el
flujo


reconstruido
,
en
lugar
del
√∫nico
hueco
de
gran
tama√±o
que
aparecer√≠a
si
tuvi√©ramos
un


flujo
no
intercalado
.


El
intercalado
puede
mejorar
significativamente
la
calidad
percibida
en
un
flujo
de


audio
[
Perkins
1998
]
.
Tambi√©n
tiene
una
baja
sobrecarga
de
datos
administrativos
.
La
des-


ventaja
obvia
del
intercalado
es
que
incrementa
la
latencia
.
Esto
limita
su
uso
en
las
aplica-


ciones
interactivas
como
la
telefon√≠a
por
Internet
,
aunque
puede
funcionar
bien
para
el
env√≠o


de
flujos
de
audio
almacenado
.
Una
de
las
principales
ventajas
del
intercalado
es
que
no


incrementa
los
requisitos
de
ancho
de
banda
de
un
flujo
.


Reparaci√≥n
de
los
flujos
de
audio
da√±ados
en
el
receptor


Los
esquemas
de
recuperaci√≥n
basados
en
el
receptor
tratan
de
generar
un
sustituto
para
un


paquete
perdido
que
sea
similar
al
original
.
Como
se
explica
en
[
Perkins
1998
]
es
posible


hacer
esto
,
ya
que
las
se√±ales
de
audio
,
y
en
particular
la
voz
,
exhiben
una
gran
cantidad
de


594
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Flujo


original


Flujo


intercalado


Flujo


recibido


Flujo


reconstruido


5
9
131


2
41


2
3
41


5
9
131


2
10
146


5
86


5
7
86


2
10
14
perdido6


7
11
153


10
129


10
11
129


4
12
168


13
1614


13
15
1614


4
12
168


Figura
7.7
‚Ä¢
Env√≠o
de
audio
intercalado
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
594auto-similitud
a
corto
plazo
.
Por
esto
,
estas
t√©cnicas
funcionan
para
tasas
de
p√©rdida
relati-


vamente
bajas
(
de
menos
del
15
por
ciento
)
y
para
paquetes
de
peque√±o
tama√±o
(
4-40
mili-


segundos
)
.
Cuando
la
longitud
de
la
p√©rdida
se
aproxima
a
la
longitud
de
un
fonema
(
5-100


milisegundos
)
estas
t√©cnicas
dejan
de
funcionar
ya
que
el
oyente
podr√≠a
perderse
fonemas


completos
.


Quiz√°
la
forma
m√°s
simple
de
recuperaci√≥n
por
parte
del
receptor
es
la
repetici√≥n
de


paquetes
.
La
repetici√≥n
de
paquetes
sustituye
los
paquetes
perdidos
con
copias
de
los
paque-


tes
que
hayan
llegado
inmediatamente
antes
de
la
p√©rdida
.
Esta
t√©cnica
tiene
una
baja
com-


plejidad
computacional
y
proporciona
unos
resultados
razonablemente
buenos
.
Otra
forma


de
recuperaci√≥n
basada
en
el
receptor
es
la
interpolaci√≥n
,
que
utiliza
el
audio
anterior
y
pos-


terior
a
la
p√©rdida
para
interpolar
un
paquete
adecuado
que
permita
cubrir
el
hueco
.
La


interpolaci√≥n
funciona
algo
mejor
que
la
repetici√≥n
de
paquetes
,
pero
requiere
un
uso


significativamente
mayor
de
recursos
de
computaci√≥n
[
Perkins
1998
]
.


7.3.4
Distribuci√≥n
multimedia
en
la
red
Internet
actual
:


redes
de
distribuci√≥n
de
contenido


Dado
que
las
velocidades
de
transmisi√≥n
de
flujos
de
v√≠deo
var√≠an
desde
centenares
de
kbps


para
los
v√≠deos
de
baja
resoluci√≥n
hasta
varios
Mbps
para
el
v√≠deo
de
calidad
DVD
,
la
tarea


de
enviar
flujos
de
v√≠deo
almacenado
bajo
demanda
a
un
gran
n√∫mero
de
usuarios
distribui-


dos
geogr√°ficamente
parece
plantear
un
desaf√≠o
de
gran
magnitud
.
El
enfoque
m√°s
simple


ser√≠a
almacenar
el
v√≠deo
en
un
√∫nico
servidor
y
simplemente
transmitir
el
flujo
desde
un
ser-


vidor
de
v√≠deo
(
o
granja
de
servidores
)
a
un
cliente
para
cada
solicitud
de
cliente
,
como
se


explica
en
la
Secci√≥n
7.2
.
Pero
existen
dos
problemas
obvios
con
esta
soluci√≥n
.
En
primer


lugar
,
puesto
que
un
cliente
puede
encontrarse
muy
lejos
del
servidor
,
los
paquetes
de
servi-


dor
a
cliente
pueden
pasar
a
trav√©s
de
muchos
ISP
,
incrementando
la
probabilidad
de
que
los


retardos
y
las
p√©rdidas
sean
significativos
.
En
segundo
lugar
,
si
el
v√≠deo
es
muy
popular
pro-


bablemente
haya
que
enviarlo
m√∫ltiples
veces
a
trav√©s
de
los
mismos
ISP
(
y
a
trav√©s
de
los


mismos
enlaces
de
comunicaciones
)
,
consumiendo
as√≠
un
ancho
de
banda
significativo
.
En


el
Cap√≠tulo
2
hemos
explicado
c√≥mo
el
almacenamiento
en
cach√©
puede
aliviar
estos
proble-


mas
.
Aunque
all√≠
analizamos
el
almacenamiento
en
cach√©
en
t√©rminos
de
contenido
web
tra-


dicional
,
deber√≠a
estar
claro
que
el
almacenamiento
en
cach√©
tambi√©n
es
apropiado
para


contenido
multimedia
,
como
el
audio
y
el
v√≠deo
almacenado
.
En
esta
secci√≥n
vamos
a
hablar


de
las
redes
de
distribuci√≥n
de
contenido
(
CDN
,
Content
Distribution
Networks
)
,
que


proporcionan
una
soluci√≥n
alternativa
para
la
distribuci√≥n
de
contenido
multimedia
almace-


nado
(
as√≠
como
para
la
distribuci√≥n
de
contenido
web
tradicional
)
.


Las
redes
CDN
se
basan
en
la
filosof√≠a
de
que
si
el
cliente
no
puede
acercarse
al
conte-


nido
(
porque
la
ruta
de
entrega
de
mejor
esfuerzo
desde
el
servidor
al
cliente
no
puede


soportar
los
flujos
de
v√≠deo
)
,
entonces
el
contenido
debe
ser
llevado
hasta
el
cliente
.
Las


redes
CDN
utilizan
,
por
tanto
,
un
modelo
diferente
que
las
cach√©s
web
.
Para
una
red
CDN
,


los
clientes
de
pago
ya
no
son
los
ISP
,
sino
los
proveedores
de
contenido
.
Un
proveedor
de


contenido
que
tenga
un
v√≠deo
para
distribuir
(
como
por
ejemplo
CNN
)
paga
a
una
compa√±√≠a


CDN
(
como
Akamai
)
para
que
lleve
su
v√≠deo
a
los
usuarios
que
lo
soliciten
con
el
menor


retardo
posible
.


Una
compa√±√≠a
CDN
suele
proporcionar
su
servicio
de
distribuci√≥n
de
contenido
de
la


forma
siguiente
:


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
595


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
5951
.
La
compa√±√≠a
CDN
instala
centenares
de
servidores
CDN
por
todo
Internet
.
Normal-


mente
,
la
empresa
CDN
coloca
los
servidores
CDN
en
centros
de
datos
,
que
suelen


estar
ubicados
en
los
ISP
de
nivel
inferior
,
cerca
de
las
redes
de
acceso
a
los
ISP
y
de


los
clientes
.


2
.
La
compa√±√≠a
CDN
replica
el
contenido
de
sus
clientes
en
los
servidores
CDN
.
Cada
vez


que
un
cliente
actualiza
su
contenido
,
la
empresa
CDN
redistribuye
el
nuevo
contenido


a
los
servidores
CDN
.


3
.
La
empresa
CDN
proporciona
un
mecanismo
para
que
,
cuando
un
cliente
solicita
el


contenido
,
ese
contenido
sea
proporcionado
por
el
servidor
CDN
que
mejor
pueda


entreg√°rselo
a
ese
cliente
espec√≠fico
.
Este
servidor
puede
ser
el
servidor
m√°s
pr√≥ximo
al


cliente
(
quiz√°
en
el
mismo
ISP
que
el
cliente
)
o
ser
un
servidor
CDN
que
disponga
de


una
ruta
libre
de
congesti√≥n
hacia
el
cliente
.


La
Figura
7.8
muestra
la
interacci√≥n
entre
el
proveedor
de
contenido
y
la
empresa
CDN
.


El
proveedor
de
contenido
determina
primero
cu√°l
de
sus
objetos
(
por
ejemplo
,
v√≠deos
)


quiere
que
la
CDN
distribuya
.
(
El
proveedor
de
contenido
distribuye
los
restantes
objetos


sin
que
la
CDN
intervenga
.
)
El
proveedor
de
contenido
etiqueta
el
contenido
y
lo
env√≠a
a
un


nodo
CDN
,
que
a
su
vez
replica
el
contenido
y
lo
env√≠a
a
una
serie
de
servidores
CDN
selec-


cionados
.
La
empresa
CDN
puede
poseer
una
red
privada
para
enviar
el
contenido
desde
el


nodo
CDN
a
los
servidores
CDN
.
Cada
vez
que
el
proveedor
de
contenido
modifica
un


596
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Servidor
de
origen


en
Am√©rica
del
Norte


Servidor
CDN


en
Am√©rica
del
Sur


Servidor
CDN


en
Europa


Servidor
CDN


en
Asia


Nodo
de


distribuci√≥n
CDN


Figura
7.8
‚Ä¢
La
red
CDN
env√≠a
los
objetos
etiquetados
por
el
proveedor
de


contenido
a
sus
servidores
CDN
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
596objeto
distribuido
CDN
env√≠a
la
versi√≥n
nueva
al
nodo
CDN
,
que
de
nuevo
replica
inmedia-


tamente
el
objeto
y
los
distribuye
a
los
servidores
CDN
.
Es
importante
recordar
que
cada


servidor
CDN
normalmente
contiene
objetos
de
muchos
proveedores
de
contenido
.


Ahora
viene
la
pregunta
interesante
.
Cuando
un
navegador
en
el
host
de
un
usuario


recibe
la
orden
de
extraer
un
objeto
espec√≠fico
(
identificado
mediante
un
URL
)
,
¬ø
c√≥mo


determina
el
navegador
si
debe
extraer
el
objeto
del
servidor
origen
o
de
uno
de
los
servido-


res
CDN
?
Normalmente
,
las
redes
CDN
hacen
uso
de
la
t√©cnica
de
redirecci√≥n
DNS
para


guiar
a
los
navegadores
hacia
el
servidor
correcto
[
Kangasharju
2000
]
.


Por
ejemplo
,
suponga
que
el
nombre
de
host
del
proveedor
de
contenido
es
www
.


foo.com
.
S
u
p
o
n
g
a
 
q
u
e
 
e
l
 
n
o
m
b
r
e
 
d
e
 
l
a
 
e
m
p
r
e
s
a
 
C
D
N
 
e
s
 
cdn.com
.
Suponga
adem√°s
que
el


proveedor
de
contenido
s√≥lo
quiere
que
la
CDN
distribuya
sus
archivos
de
v√≠deo
mpeg
,


mientras
que
todos
los
dem√°s
objetos
,
incluyendo
las
p√°ginas
HTML
de
base
,
ser√°n
distri-


buidas
directamente
por
el
proveedor
de
contenido
.
Para
conseguir
esto
,
el
proveedor
de


contenido
modifica
todos
los
objetos
HTML
del
servidor
de
origen
de
modo
que
todos
los


URL
de
los
archivos
de
v√≠deo
vayan
precedidos
por
http://www.cdn.com
.
Por
tanto
,
si


un
archivo
HTML
en
el
proveedor
de
contenido
ten√≠a
originalmente
una
referencia
a


http://www.foo.com/sports/highlights.mpg
,
el
proveedor
de
contenido
etique-


tar√≠a
este
objeto
sustituyendo
la
referencia
en
el
archivo
HTML
por
http://www.cdn
.


com
/
www.foo.com
/
sports
/
highlights.mpg
.


Cuando
un
navegador
solicita
una
p√°gina
web
que
contiene
el
v√≠deo
highlights
.


mpg
,
tendr√°n
lugar
las
siguientes
acciones
:


1
.
El
navegador
env√≠a
la
solicitud
correspondiente
al
objeto
HTML
de
base
hacia
el
servi-


dor
origen
,
www.foo.com
,
el
cual
env√≠a
el
objeto
HTML
solicitado
al
navegador
.
El


navegador
analiza
el
archivo
HTML
y
encuentra
la
referencia
a
http://www.cdn
.


com
/
www.foo.com
/
sports
/
highlights.mpg
.


2
.
El
navegador
hace
entonces
una
b√∫squeda
DNS
de
www.cdn.com
,
que
es
el
nombre
de


host
correspondiente
al
URL
referenciado
.
El
sistema
DNS
est√°
configurado
de
forma


que
todas
las
consultas
acerca
de
www.cdn.comque
lleguen
a
un
servidor
DNS
ra√≠z
se


env√≠en
a
un
servidor
DNS
autoritativo
para
www.cdn.com
.
Cuando
el
servidor
DNS


autoritativo
recibe
la
consulta
,
extrae
la
direcci√≥n
IP
del
navegador
solicitante
.
Utili-


zando
un
mapa
interno
de
la
red
que
ha
construido
para
toda
Internet
,
el
servidor
DNS


de
la
empresa
CDN
devuelve
la
direcci√≥n
IP
del
servidor
CDN
que
probablement
sea
el


m√°s
adecuado
para
el
navegador
solicitante
(
a
menudo
ser√°
el
servidor
CDN
m√°s
pr√≥-


ximo
al
navegador
)
.


3
.
El
cliente
DNS
en
el
host
que
realiza
la
solicitud
recibe
una
respuesta
DNS
con
la
direc-


ci√≥n
IP
.
El
navegador
env√≠a
entonces
su
solicitud
HTTP
al
servidor
CDN
que
tiene
esa


direcci√≥n
IP
.
El
navegador
obtiene
el
archivo
de
v√≠deo
highlights.mpg
de
ese
servi-


dor
CDN
.
Para
subsiguientes
solicitudes
dirigidas
a
www.cdn.com
,
el
cliente
conti-


nuar√°
utilizando
el
mismo
servidor
CDN
,
ya
que
la
direcci√≥n
IP
de
www.cdn.com
se


encontrar√°
en
la
cach√©
DNS
(
en
el
host
cliente
o
en
el
servidor
de
nombres
DNS
local
)
.


En
resumen
,
como
se
muestra
en
la
Figura
7.9
,
el
host
que
realiza
la
solicitud
acude


primero
al
servidor
web
origen
para
obtener
el
objeto
HTML
de
base
y
luego
al
servidor


DNS
autoritativo
correspondiente
a
la
empresa
CDN
para
obtener
la
direcci√≥n
IP
del
mejor


servidor
CDN
.
Por
√∫ltimo
,
acude
a
ese
servidor
CDN
para
obtener
el
v√≠deo
.
Observe
que
no


hace
falta
realizar
ning√∫n
cambio
en
HTTP
,
DNS
o
en
el
navegador
para
implementar
este


esquema
de
distribuci√≥n
.


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
597


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
597Lo
que
nos
queda
por
explicar
es
c√≥mo
una
empresa
CDN
determina
el
‚Äú
mejor
‚Äù
servi-


dor
CDN
para
el
host
solicitante
.
Aunque
cada
empresa
CDN
tiene
su
propia
manera
propie-


taria
de
hacer
esto
,
no
es
dif√≠cil
hacerse
una
idea
aproximada
de
qu√©
es
lo
que
hacen
.
Para


cada
ISP
de
acceso
a
Internet
(
que
contiene
potenciales
clientes
que
realizan
solicitudes
)
,
la


empresa
CDN
tiene
anotado
cu√°l
es
el
mejor
servidor
CDN
.
La
empresa
CDN
determina


cu√°l
es
el
mejor
servidor
CDN
bas√°ndose
en
su
conocimiento
de
las
tablas
de
enrutamiento


Internet
(
espec√≠ficamente
de
las
tablas
BGP
de
las
que
hemos
hablado
en
el
Cap√≠tulo
4
)
,
en


las
estimaciones
del
tiempo
de
ida
y
vuelta
y
en
otras
medidas
de
las
que
dispone
para
las


comunicaciones
entre
sus
diversos
servidores
en
las
distintas
redes
de
acceso
;
consulte


[
Verma
2001
]
para
ver
un
an√°lisis
m√°s
detallado
.
De
este
forma
,
la
empresa
CDN
estima
qu√©


servidor
CDN
proporcionar√°
el
mejor
servicio
de
entrega
de
mejor
esfuerzo
a
cada
ISP
.


La
empresa
CDN
hace
esto
para
un
gran
n√∫mero
de
ISP
de
acceso
en
Internet
y
emplea


dicha
informaci√≥n
para
configurar
el
servidor
DNS
autoritativo
.
Para
ver
un
an√°lisis
del


env√≠o
de
flujos
multimedia
desde
el
punto
de
vista
de
una
gran
empresa
CDN
operativa


(
Akamai
)
,
consulte
[
Sripanidkulchpai
2004
]
.
Para
ver
los
recientes
desarrollos
en
la
investi-


gaci√≥n
de
las
redes
CDN
,
consulte
[
Krishnamurthy
2001
;
Mao
2002
;
Saroiu
2002
;
Freed-


man
2004
;
Su
2006
;
Huang
2008
]
.


7.3.5
Dimensionamiento
de
las
redes
con
servicio
de
entrega


de
mejor
esfuerzo
para
proporcionar
calidad
de
servicio


En
las
secciones
anteriores
hemos
visto
c√≥mo
diversas
t√©cnicas
del
nivel
de
aplicaci√≥n
,


como
la
reproducci√≥n
de
paquetes
,
los
mecanismos
FEC
,
el
intercalado
de
paquetes
en
los


hosts
y
una
infraestructura
CDN
implantada
por
toda
la
red
pueden
mejorar
la
calidad
de
las


aplicaciones
multimedia
en
la
red
Internet
actual
que
dispone
de
un
servicio
de
entrega
de


mejor
esfuerzo
.
Fundamentalmente
,
las
dificultades
para
dar
soporte
a
las
aplicaciones
mul-


timedia
surgen
de
sus
estrictos
requisitos
de
rendimiento
(
bajo
retardo
de
paquetes
terminal


598
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Servidor
origen


Solcititud
HTTP
para

 

Solicitud
HTTP
para


Consulta
DNS
para


Servidor
CDN


cercano


Servidor
DNS


autoritativo
de
la


empresa
CDN


2


1


3


Figura
7.9
‚Ä¢
Las
redes
CDN
utilizan
el
sistema
DNS
para
dirigir
las
solicitudes
a


un
servidor
CDN
cercano
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
598a
terminal
,
baja
fluctuaci√≥n
del
retardo
y
baja
tasa
de
p√©rdidas
)
y
del
hecho
de
que
el
retardo


de
los
paquetes
,
la
fluctuaci√≥n
de
los
retardos
y
las
p√©rdidas
se
producen
cuando
la
red
est√°


congestionada
.
Una
t√©cnica
definitiva
para
mejorar
la
calidad
de
las
aplicaciones
multime-


dia
(
una
t√©cnica
que
a
menudo
puede
emplearse
para
resolver
pr√°cticamente
cualquier
pro-


blema
en
el
que
los
recursos
est√©n
restringidos
)
es
simplemente
‚Äú
meter
dinero
‚Äù
y
evitar


desde
el
principio
que
exista
una
contienda
por
los
recursos
.
En
el
caso
de
las
aplicaciones


multimedia
en
red
,
esto
quiere
decir
proporcionar
suficiente
capacidad
de
enlace
por
toda
la


red
,
de
modo
que
nunca
se
produzca
(
o
s√≥lo
se
produzca
muy
raramente
)
una
congesti√≥n
en


la
red
,
con
los
consiguientes
retardos
y
p√©rdidas
de
paquetes
.
Con
suficiente
capacidad
de


enlace
,
los
paquetes
podr√≠an
atravesar
la
red
Internet
de
hoy
d√≠a
sin
retardos
de
puesta
en


cola
y
sin
p√©rdidas
.
Desde
muchos
puntos
de
vista
,
√©sta
es
una
situaci√≥n
ideal
:
las
aplicacio-


nes
multimedia
funcionar√≠an
perfectamente
,
los
usuarios
estar√≠an
contentos
y
todo
esto


podr√≠a
conseguirse
sin
efectuar
ning√∫n
cambio
en
la
arquitectura
Internet
basada
en
un
ser-


vicio
de
entrega
de
mejor
esfuerzo
.
Por
supuesto
,
la
cuesti√≥n
es
cu√°nta
capacidad
es
‚Äú
sufi-


ciente
‚Äù
para
conseguir
esta
situaci√≥n
paradisiaca
y
si
los
costes
de
proporcionar
un
ancho
de


banda
‚Äú
suficiente
‚Äù
resultan
pr√°cticos
desde
el
punto
de
vista
comercial
para
los
ISP
.


La
cuesti√≥n
de
cu√°nta
capacidad
proporcionar
en
los
enlaces
de
la
red
para
una
cierta


topolog√≠a
dada
,
con
el
fin
de
conseguir
un
determinado
nivel
de
rendimiento
terminal
a
ter-


minal
,
se
suele
denominar
aprovisionamiento
de
ancho
de
banda
.
El
problema
todav√≠a


m√°s
complicado
de
c√≥mo
dise√±ar
una
topolog√≠a
de
red
(
d√≥nde
colocar
los
routers
,
c√≥mo


interconectar
los
routers
mediante
enlaces
y
qu√©
capacidad
asignar
a
los
enlaces
)
para
con-


seguir
un
nivel
prefijado
de
rendimiento
terminal
a
terminal
es
un
problema
de
dise√±o
de


redes
que
a
menudo
de
denomina
dimensionamiento
de
la
red
.
T
a
n
t
o
 
e
l
 
a
p
r
o
v
i
s
i
o
n
a
m
i
e
n
t
o


de
ancho
de
banda
como
el
dimensionamiento
de
la
red
son
temas
complejos
que
caen
fuera


del
alcance
de
este
libro
.
Sin
embargo
,
conviene
decir
que
es
necesario
resolver
los
siguien-


tes
problemas
para
poder
predecir
el
rendimiento
de
nivel
de
aplicaci√≥n
entre
dos
puntos
ter-


minales
de
la
red
y
as√≠
poder
prever
una
capacidad
suficiente
como
para
satisfacer
los


requisitos
de
rendimiento
de
una
aplicaci√≥n
.


‚Ä¢
Modelos
de
demanda
de
tr√°fico
entre
puntos
terminales
de
la
red
.
Los
modelos
pueden


tener
que
especificarse
tanto
en
el
nivel
de
llamada
(
por
ejemplo
,
usuarios
‚Äú
que
llegan
‚Äù
a


la
red
e
inician
aplicaciones
terminal
a
terminal
)
como
en
el
nivel
de
paquetes
(
por
ejem-


plo
,
n√∫mero
de
paquetes
generados
por
las
aplicaciones
activas
)
.
Observe
que
la
carga
de


trabajo
puede
variar
a
lo
largo
del
tiempo
.


‚Ä¢
Requisitos
de
rendimiento
bien
definidos
.
Por
ejemplo
,
un
requisito
de
rendimiento
para
el


soporte
de
tr√°fico
sensible
al
retardo
,
como
el
de
las
aplicaciones
interactivas
de
audio/


v√≠deo
,
puede
ser
que
la
probabilidad
de
que
el
retardo
terminal
a
terminal
de
la
aplicaci√≥n


supere
un
determinado
umbral
m√°ximo
tolerable
sea
inferior
a
un
cierto
valor
peque√±o


[
Fraleigh
2003
]
.


‚Ä¢
Modelos
para
predecir
el
rendimiento
terminal
a
terminal
para
un
modelo
de
carga


de
trabajo
determinado
,
junto
con
t√©cnicas
para
encontrar
una
asignaci√≥n
de
coste


m√≠nimo
del
ancho
de
banda
que
permita
satisfacer
los
requisitos
de
todos
los
usuarios
.


En
este
aspecto
,
los
investigadores
est√°n
trabajando
arduamente
para
desarrollar
mode-


los
(
v√©ase
la
Secci√≥n
1.4
)
que
permitan
cuantificar
el
rendimiento
para
una
carga
de
tra-


bajo
determinada
,
junto
con
t√©cnicas
de
optimizaci√≥n
para
hallar
las
asignaciones
de


ancho
de
banda
de
coste
m√≠nimo
que
satisfagan
los
requisitos
de
rendimiento
.


7.3
‚Ä¢
UTILIZACI√ìN
√ìPTIMA
DEL
SERVICIO
DE
ENTREGA
DE
MEJOR
ESFUERZO
599


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
599Dado
que
la
red
Internet
actual
basada
en
un
servicio
de
entrega
de
mejor
esfuerzo


podr√≠a
(
desde
el
punto
de
vista
tecnol√≥gico
)
soportar
tr√°fico
multimedia
con
un
rendimiento


apropiado
si
estuviera
dimensionada
para
hacerlo
,
la
pregunta
natural
es
por
qu√©
la
red


Internet
de
hoy
d√≠a
no
lo
hace
.
Las
respuestas
son
principalmente
econ√≥micas
y
organizati-


vas
.
Desde
el
punto
de
vista
econ√≥mico
,
¬ø
estar√≠an
dispuestos
los
usuarios
a
pagar
a
sus
ISP


el
suficiente
dinero
como
para
que
los
ISP
instalaran
un
ancho
de
banda
suficiente
para


soportar
aplicaciones
multimedia
sobre
la
actual
Internet
?
Las
cuestiones
organizativas
son


quiz√°
a√∫n
m√°s
dif√≠ciles
.
Observe
que
una
ruta
terminal
a
terminal
entre
dos
puntos
extremos


de
una
comunicaci√≥n
multimedia
tendr√°
que
pasar
por
las
redes
de
m√∫ltiples
ISP
.
Desde
el


punto
de
vista
organizativo
,
¬ø
estar√≠an
dispuestos
estos
ISP
a
cooperar
(
tal
vez
compartiendo


los
recursos
)
para
asegurar
que
la
ruta
terminal
a
terminal
est√©
adecuadamente
dimensionada


y
d√©
soporte
a
las
aplicaciones
multimedia
?
Para
ver
un
an√°lisis
desde
la
perspectiva
de
estos


problemas
econ√≥micos
y
organizativos
,
consulte
[
Davies
2005
]
.
Para
ver
un
an√°lisis
del


dimensionamiento
de
redes
troncales
de
nivel
1
con
el
fin
de
dar
soporte
a
tr√°fico
sensible
al


retardo
,
consulte
[
Fraleigh
2003
]
.


7.4
Protocolos
para
aplicaciones
interactivas


en
tiempo
real


Las
aplicaciones
interactivas
en
tiempo
real
,
incluidas
la
telefon√≠a
por
Internet
y
la
video-


conferencia
,
prometen
controlar
gran
parte
del
crecimiento
futuro
de
Internet
.
Por
tanto
,
no


debe
sorprendernos
que
organismos
de
estandarizaci√≥n
como
IETF
e
ITU
hayan
estado
ocu-


pados
durante
muchos
a√±os
(
¬°
y
contin√∫an
est√°ndolo
!
)
en
el
establecimiento
de
est√°ndares


para
esta
clase
de
aplicaciones
.
Disponiendo
de
los
est√°ndares
apropiados
para
las
aplicacio-


nes
interactivas
en
tiempo
real
,
empresas
independientes
podr√°n
crear
nuevos
y
convincen-


tes
productos
que
interoperen
entre
s√≠
.
En
esta
secci√≥n
vamos
a
examinar
RTP
,
SIP
y
H.323


para
aplicaciones
interactivas
en
tiempo
real
.
Estos
tres
conjuntos
de
est√°ndares
disfrutan
de


una
amplia
implementaci√≥n
en
los
productos
industriales
.


7.4.1
RTP


En
la
secci√≥n
anterior
hemos
visto
que
el
lado
emisor
de
una
aplicaci√≥n
multimedia
a√±ade


campos
de
cabecera
a
los
fragmentos
de
audio
/
v√≠deo
antes
de
pasarlos
a
la
capa
de
trans-


porte
.
Estos
campos
de
cabecera
incluyen
n√∫meros
de
secuencia
y
marcas
de
tiempo
.
Dado


que
la
mayor√≠a
de
las
aplicaciones
multimedia
de
red
pueden
hacer
uso
de
los
n√∫meros
de


secuencia
y
de
las
marcas
de
tiempo
,
es
conveniente
disponer
de
una
estructura
de
paquete


estandarizada
que
incluya
campos
para
los
datos
de
audio
/
v√≠deo
,
los
n√∫meros
de
secuencia
y


las
marcas
de
tiempo
,
as√≠
como
otros
campos
potencialmente
√∫tiles
.
RTP
,
definido
en
el


documento
RFC
3550
,
es
este
est√°ndar
.
RTP
puede
emplearse
para
transportar
formatos


comunes
como
PCM
,
GSM
y
MP3
para
sonido
y
MPEG
y
H.263
para
v√≠deo
.
Tambi√©n
se


puede
utilizar
para
transportar
formatos
de
sonido
y
v√≠deo
propietarios
.
Actualmente
RTP


disfruta
de
una
amplia
implementaci√≥n
en
centenares
de
productos
y
prototipos
de
investi-


gaci√≥n
.
Adem√°s
es
complementario
de
otros
importantes
protocolos
interactivos
de
tiempo


real
,
como
SIP
y
H.323
.


600
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
600En
esta
secci√≥n
proporcionamos
una
introducci√≥n
a
RTP
y
a
su
protocolo
compa√±ero


RTCP
.
Animamos
a
los
lectores
a
visitar
el
sitio
de
RTP
de
Henning
Schulzrinne
[
Schulz-


rinne-RTP
2009
]
,
que
proporciona
abundante
informaci√≥n
sobre
el
tema
.
Tambi√©n
pueden


visitar
el
sitio
de
RA
T
[
RAT
2009
]
,
que
documenta
una
aplicaci√≥n
de
telefon√≠a
por
Internet


que
emplea
RTP
.


Fundamentos
de
RTP


Normalmente
,
RTP
se
ejecuta
sobre
UDP
.
El
lado
emisor
encapsula
un
fragmento
multime-


dia
dentro
de
un
paquete
RTP
,
luego
encapsula
ese
paquete
en
un
segmento
UDP
y
despu√©s


pasa
el
segmento
a
IP
.
El
lado
receptor
extrae
el
paquete
RTP
del
segmento
UDP
,
a
conti-


nuaci√≥n
extrae
el
fragmento
multimedia
del
paquete
RTP
y
lo
pasa
al
reproductor
multime-


dia
para
su
decodificaci√≥n
y
procesamiento
.


Por
ejemplo
,
considere
el
uso
de
RTP
para
transportar
voz
.
Suponga
que
el
origen
de


voz
est√°
codificado
en
PCM
(
es
decir
,
la
voz
est√°
muestreada
,
cuantizada
y
digitalizada
)
a


64
kbps
.
Suponga
tambi√©n
que
la
aplicaci√≥n
recopila
los
datos
codificados
en
fragmentos
de


20
milisegundos
;
es
decir
,
un
fragmento
tiene
160
bytes
.
El
lado
emisor
precede
a
cada
frag-


mento
de
datos
de
audio
con
una
cabecera
RTP
que
incluye
el
tipo
de
codificaci√≥n
audio
,


un
n√∫mero
de
secuencia
y
una
marca
de
tiempo
.
La
cabecera
RTP
normalmente
tiene
12


bytes
.
El
fragmento
de
audio
junto
con
la
cabecera
RTP
forman
el
paquete
RTP
.
El
paquete


RTP
se
env√≠a
entonces
a
la
interfaz
de
socket
UDP
.
En
el
lado
receptor
,
la
aplicaci√≥n
recibe


el
paquete
RTP
procedente
de
su
interfaz
de
socket
.
La
aplicaci√≥n
extrae
el
fragmento
de


audio
del
paquete
 
RTP
y
utiliza
los
campos
de
cabecera
del
mismo
para
decodificar
y
repro-


ducir
apropiadamente
el
fragmento
.


Si
una
aplicaci√≥n
incorpora
RTP
,
en
lugar
de
un
esquema
propietario
para
especificar
el


tipo
de
carga
√∫til
,
los
n√∫meros
de
secuencia
o
las
marcas
de
tiempo
,
entonces
la
aplicaci√≥n


interoperar√°
m√°s
f√°cilmente
con
las
dem√°s
aplicaciones
multimedia
de
red
.
Por
ejemplo
,
si


dos
empresas
distintas
desarrollan
software
para
telefon√≠a
por
Internet
y
ambas
incorporan


en
su
producto
el
protocolo
RTP
,
existir√°
la
posibilidad
de
que
un
usuario
que
emplee
uno


de
esos
productos
de
telefon√≠a
por
Internet
pueda
comunicarse
con
otro
usuario
que
use
el


producto
de
la
otra
empresa
.
En
la
Secci√≥n
7.4.3
veremos
que
RTP
suele
utilizarse
junto
con


los
est√°ndares
de
telefon√≠a
Internet
.


Debemos
destacar
que
RTP
no
proporciona
ning√∫n
mecanismo
para
garantizar
la


entrega
a
tiempo
de
los
datos
ni
ninguna
otra
garant√≠a
de
calidad
del
servicio
(
QoS
,
Quality-


of-Service
)
;
ni
siquiera
garantiza
la
entrega
de
paquetes
o
evita
la
entrega
de
paquetes
desor-


denados
.
De
hecho
,
la
encapsulaci√≥n
RTP
s√≥lo
se
percibe
en
los
sistemas
terminales
.
Los


routers
no
diferencian
entre
los
datagramas
IP
que
transportan
paquetes
RTP
y
los
que
no
.


RTP
permite
que
a
cada
origen
(
por
ejemplo
,
una
c√°mara
o
un
micr√≥fono
)
se
le
asigne


su
propio
flujo
independiente
de
paquetes
RTP
.
Por
ejemplo
,
para
una
videoconferencia


entre
dos
participantes
podr√≠an
abrirse
cuatro
flujos
RTP
:
dos
flujos
para
transmitir
el
audio


(
uno
en
cada
direcci√≥n
)
y
dos
flujos
para
transmitir
el
v√≠deo
(
tambi√©n
uno
en
cada
direc-


ci√≥n
)
.
Sin
embargo
,
muchas
t√©cnicas
de
codificaci√≥n
populares
(
entre
las
que
se
incluyen


MPEG
1
y
MPEG
2
)
empaquetan
el
audio
y
el
v√≠deo
en
un
mismo
flujo
durante
el
proceso


de
codificaci√≥n
.
Cuando
el
codificador
empaqueta
el
audio
y
el
v√≠deo
,
entonces
s√≥lo
se


genera
un
flujo
RTP
en
cada
direcci√≥n
.


Los
paquetes
RTP
no
est√°n
limitados
a
las
aplicaciones
de
unidifusi√≥n
.
Tambi√©n
pueden


enviarse
a
trav√©s
de
√°rboles
de
multidifusi√≥n
uno-a-muchos
y
muchos-a-muchos
.
En
una


7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
601


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
601sesi√≥n
de
multidifusi√≥n
muchos-a-muchos
,
normalmente
todos
los
emisores
y
or√≠genes


de
la
sesi√≥n
utilizan
el
mismo
grupo
de
multidifusi√≥n
para
enviar
sus
flujos
RTP
.
Estos
flu-


jos
multidifusi√≥n
RTP
conjuntos
pertenecen
a
una
sesi√≥n
RTP
,
del
mismo
modo
que
los


flujos
de
audio
y
de
v√≠deo
procedentes
de
m√∫ltiples
emisores
en
una
aplicaci√≥n
de
video-


conferencia
.


Campos
de
cabecera
de
los
paquetes
RTP


Como
se
muestra
en
la
Figura
7.10
,
los
cuatro
campos
principales
de
la
cabecera
RTP
son
el


tipo
de
carga
√∫til
,
el
n√∫mero
de
secuencia
,
la
marca
de
tiempo
y
el
identificador
de
origen
.


El
campo
Tipo
de
carga
√∫til
del
paquete
RTP
tiene
una
longitud
de
7
bits
.
En
un
flujo
de


audio
,
el
campo
Tipo
de
carga
√∫til
se
emplea
para
indicar
el
tipo
de
codificaci√≥n
de
audio


(
por
ejemplo
,
PCM
,
modulaci√≥n
delta
adaptativa
,
codificaci√≥n
predictiva
lineal
)
que
se
est√°


utilizando
.
Si
un
emisor
decide
cambiar
el
tipo
de
codificaci√≥n
en
mitad
de
una
sesi√≥n
,


puede
informar
al
receptor
de
dicho
cambio
a
trav√©s
de
este
campo
que
define
el
tipo
de


carga
√∫til
.
El
emisor
puede
desear
cambiar
la
codificaci√≥n
con
el
fin
de
aumentar
la
calidad


del
audio
o
para
disminuir
la
tasa
de
bit
del
flujo
RTP
.
En
la
Tabla
7.2
se
enumeran
algunos


de
los
tipos
de
carga
√∫til
de
audio
a
los
que
actualmente
da
soporte
RTP
.


Para
un
flujo
de
v√≠deo
,
el
tipo
de
carga
√∫til
se
utiliza
para
indicar
el
tipo
de
codificaci√≥n


de
v√≠deo
(
por
ejemplo
,
JPEG
con
movimiento
,
MPEG
1
,
MPEG
2
,
H.261
)
.
De
nuevo
,
el


emisor
puede
cambiar
el
tipo
de
codificaci√≥n
de
v√≠deo
sobre
la
marcha
durante
una
sesi√≥n
.


En
la
Tabla
7.3
se
enumeran
algunos
de
los
tipos
de
carga
√∫til
de
v√≠deo
soportados
actual-


mente
por
RTP
.
Los
restantes
campos
importantes
son
los
siguientes
:


‚Ä¢
Campo
de
n√∫mero
de
secuencia
.
El
campo
de
n√∫mero
de
secuencia
tiene
una
longitud
de


16
bits
.
El
n√∫mero
de
secuencia
aumenta
en
una
unidad
para
cada
paquete
RTP
enviado


N√∫mero
de
tipo
Formato
Frecuencia
Velocidad


de
carga
√∫til
de
audio
de
muestreo


0
PCM
/H9262-law
8
kHz
64
kbps


1
1016
8
kHz
4,8
kbps


3
GSM
8
kHz
13
kbps


7
LPC
8
kHz
2,4
kbps


9
G.722
16
kHz
48‚Äì64
kbps


14
MPEG
Audio
90
kHz
‚Äî


15
G.728
8
kHz
16
kbps


Tabla
7.2
‚Ä¢
Tipos
de
carga
√∫til
de
audio
soportados
por
RTP
.


602
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Tipo
de


carga
√∫til


N√∫mero
de


secuencia


Identificador
de
origen


de
sincronizaci√≥n


Diversos


campos


Marca


de
tiempo


Figura
7.10
‚Ä¢
Campos
de
la
cabecera
RTP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
602N√∫mero
de
tipo
de
carga
√∫til
Formato
de
v√≠deo


26
JPEG
con
movimiento


31
H.261


32
MPEG
1
v√≠deo


33
MPEG
2
v√≠deo


Tabla
7.3
‚Ä¢
Algunos
tipos
de
carga
√∫til
de
v√≠deo
soportados
por
RTP
.


y
puede
ser
utilizado
por
el
receptor
para
detectar
p√©rdidas
de
paquetes
y
restaurar
la


secuencia
de
paquetes
.
Por
ejemplo
,
si
el
lado
receptor
de
la
aplicaci√≥n
recibe
un
flujo
de


paquetes
RTP
con
un
hueco
entre
los
n√∫meros
de
secuencia
86
y
89
,
entonces
el
receptor


sabe
que
faltan
los
paquetes
87
y
88
.
El
receptor
puede
entonces
intentar
ocultar
los
datos


perdidos
.


‚Ä¢
Campo
de
marca
de
tiempo
.
El
campo
de
marca
de
tiempo
tiene
una
longitud
de
32
bits


y
designa
el
instante
de
muestreo
del
primer
byte
del
paquete
de
datos
RTP
.
Como
hemos


visto
en
la
secci√≥n
anterior
,
el
receptor
puede
utilizar
marcas
de
tiempo
para
eliminar
la


fluctuaci√≥n
de
los
paquetes
introducida
por
la
red
y
para
proporcionar
una
reproducci√≥n


s√≠ncrona
en
el
receptor
.
La
marca
de
tiempo
se
obtiene
de
una
se√±al
de
reloj
de
muestreo


del
emisor
.
Por
ejemplo
,
para
audio
,
la
se√±al
de
reloj
de
marca
de
tiempo
se
incrementa


en
una
unidad
para
cada
periodo
de
muestreo
(
por
ejemplo
,
cada
125
microsegundos
para


una
se√±al
de
reloj
de
muestro
de
8
kHz
)
;
si
la
aplicaci√≥n
de
audio
genera
fragmentos
que


constan
de
160
muestras
codificadas
,
entonces
la
marca
de
tiempo
se
incrementa
en
160


para
cada
paquete
RTP
cuando
el
origen
est√°
activo
.
La
se√±al
de
reloj
de
marca
de
tiempo


contin√∫a
aumentando
a
una
velocidad
constante
incluso
aunque
el
origen
est√©
inactivo
.


‚Ä¢
Identificador
del
origen
de
sincronizaci√≥n
(
SSRC
,
Synchronization
Source
Identifier
)
.
El


campo
SSRC
tiene
una
longitud
de
32
bits
.
Este
campo
identifica
el
origen
del
flujo
RTP
.


Normalmente
,
cada
flujo
de
una
sesi√≥n
RTP
tiene
un
SSRC
distinto
.
El
SSRC
no
es
la


direcci√≥n
IP
del
emisor
,
sino
un
n√∫mero
que
el
origen
asigna
aleatoriamente
cuando
se


inicia
un
nuevo
flujo
.
La
probabilidad
de
que
dos
flujos
obtengan
el
mismo
SSRC
es
muy


peque√±a
.
En
el
caso
de
que
esto
ocurriera
,
los
dos
or√≠genes
deber√°n
elegir
un
nuevo
valor


de
SSRC
.


Desarrollo
de
aplicaciones
software
con
RTP


Existen
dos
enfoques
para
el
desarrollo
de
una
aplicaci√≥n
de
red
basada
en
RTP
.
El
primer


enfoque
consiste
en
que
el
desarrollador
de
la
aplicaci√≥n
incorpore
manualmente
RTP
;
es


decir
,
que
escriba
realmente
el
c√≥digo
que
lleve
a
cabo
la
encapsulaci√≥n
RTP
en
el
lado
emi-


sor
y
el
procesamiento
RTP
en
el
lado
receptor
.
El
segundo
enfoque
consiste
en
que
el
desa-


rrollador
de
la
aplicaci√≥n
utilice
las
bibliotecas
RTP
existentes
(
para
los
programadores
de


C
)
y
las
clases
Java
(
para
los
programadores
de
Java
)
que
realizan
la
encapsulaci√≥n
y
el
pro-


cesamiento
para
la
aplicaci√≥n
.
Puesto
que
es
posible
que
est√©
interesado
en
escribir
su
pri-


mera
aplicaci√≥n
multimedia
de
red
utilizando
RTP
,
a
continuaci√≥n
vamos
a
elaborar
un
poco


m√°s
cada
uno
de
estos
dos
enfoques
.
(
La
tarea
de
programaci√≥n
disponible
al
final
del
cap√≠-


tulo
le
guiar√°
a
trav√©s
de
la
creaci√≥n
de
una
aplicaci√≥n
RTP
.
)
Haremos
esto
en
el
contexto
de


una
comunicaci√≥n
de
unidifusi√≥n
(
en
lugar
de
en
un
contexto
de
multidifusi√≥n
)
.


7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
603


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
603Recuerde
del
Cap√≠tulo
2
que
la
API
de
UDP
requiere
que
el
proceso
emisor
establezca
,


para
cada
segmento
UDP
que
env√≠a
,
la
direcci√≥n
de
destino
IP
y
el
n√∫mero
de
puerto
de


destino
antes
de
enviar
el
paquete
al
socket
UDP
.
A
continuaci√≥n
el
segmento
UDP
se
trans-


mitir√°
a
trav√©s
de
Internet
y
(
si
el
segmento
no
se
pierde
,
por
ejemplo
,
a
causa
de
un
desbor-


damiento
del
buffer
del
router
)
terminar√°
llegando
a
la
puerta
del
proceso
receptor
de
la


aplicaci√≥n
.
Esta
puerta
queda
completamente
definida
por
la
direcci√≥n
IP
de
destino
y
el


n√∫mero
de
puerto
de
destino
.
De
hecho
,
cualquier
datagrama
IP
que
contenga
esta
direcci√≥n


IP
de
destino
y
ese
n√∫mero
de
puerto
de
destino
ser√°
dirigido
a
la
puerta
UDP
del
proceso


receptor
.
(
La
API
de
UDP
tambi√©n
permite
al
desarrollador
de
la
aplicaci√≥n
establecer
el


n√∫mero
de
puerto
de
origen
de
UDP
;
sin
embargo
,
este
valor
no
tiene
ning√∫n
efecto
sobre
el


proceso
al
que
se
env√≠a
el
segmento
.
)
Es
importante
destacar
que
RTP
no
obliga
a
emplear


un
n√∫mero
de
puerto
espec√≠fico
.
Cuando
un
desarrollador
de
aplicaciones
crea
una
aplica-


ci√≥n
RTP
,
especifica
los
n√∫meros
de
puerto
para
los
dos
lados
de
la
aplicaci√≥n
.


Como
parte
de
la
tarea
de
programaci√≥n
de
este
cap√≠tulo
,
tendr√°
que
escribir
un
servi-


dor
RTP
que
encapsule
tramas
de
v√≠deo
almacenado
dentro
de
los
paquetes
RTP
.
Tendr√°
que


hacerlo
de
forma
manual
;
es
decir
,
su
aplicaci√≥n
tomar√°
una
trama
de
v√≠deo
,
a√±adir√°
las


cabeceras
RTP
a
la
trama
para
crear
un
paquete
RTP
y
luego
pasar√°
esa
trama
RTP
al
socket


UDP
.
Para
hacer
esto
necesitar√°
crear
campos
contenedor
para
las
diversas
cabeceras
RTP
,


incluyendo
un
campo
de
n√∫mero
de
secuencia
y
un
campo
de
marca
de
tiempo
.
Y
para
cada


uno
de
los
paquetes
RTP
creados
,
tendr√°
que
definir
apropiadamente
el
n√∫mero
de
secuencia


y
la
marca
de
tiempo
.
Tendr√°
que
escribir
expl√≠citamente
el
c√≥digo
para
llevar
a
cabo
todas


estas
operaciones
RTP
en
el
lado
emisor
de
su
aplicaci√≥n
.
Como
se
muestra
en
la
Figura


7.11
,
su
API
para
la
red
ser√°
la
API
est√°ndar
del
socket
UDP
.


Un
m√©todo
alternativo
(
que
no
se
realiza
en
la
tarea
de
programaci√≥n
)
consiste
en
utili-


zar
una
clase
RTP
en
Java
(
o
una
biblioteca
RTP
en
C
para
los
programadores
de
C
)
para


implementar
las
operaciones
RTP
.
Como
se
m
uestra
en
la
Figura
7.12
,
con
este
m√©todo
el


desarrollador
de
la
aplicaci√≥n
puede
tener
la
impresi√≥n
de
que
RTP
forma
parte
de
la
capa


de
transporte
,
con
una
API
de
RTP
/
UDP
entre
la
capa
de
aplicaci√≥n
y
la
capa
de
trans-


porte
.
Sin
entrar
en
demasiados
detalles
(
como
los
relativos
a
la
clase
/
biblioteca
)
,
cuando
se


env√≠a
un
fragmento
de
datos
multimedia
a
la
API
,
el
lado
emisor
de
la
aplicaci√≥n
tiene
que


proporcionar
a
la
interfaz
el
propio
fragmento
,
un
n√∫mero
de
tipo
de
carga
√∫til
,
un
identifi-


cador
SSRC
y
una
marca
de
tiempo
,
adem√°s
de
un
n√∫mero
de
puerto
de
destino
y
una


direcci√≥n
IP
de
destino
.
S√≥lo
comentar
que
Java
Media
Framework
(
JMF
)
incluye
una


implementaci√≥n
completa
de
RTP
.


604
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


IP


UDP


Enlace
de
datos


F√≠sica


RTP


Aplicaci√≥n


Socket


Figura
7.11
‚Ä¢
RTP
es
parte
de
la
aplicaci√≥n
y
queda
por
encima
del
socket


UDP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
6047.4.2
Protocolo
de
control
de
RTP
(
RTCP
)


El
documento
RFC
3550
tambi√©n
especifica
el
protocolo
RTCP
,
un
protocolo
que
una
apli-


caci√≥n
multimedia
de
red
puede
emplear
junto
con
RTP
.
Como
se
muestra
en
el
escenario
de


multidifusi√≥n
de
la
Figura
7.13
,
cada
uno
de
los
participantes
en
una
sesi√≥n
RTP
transmite


paquetes
RTCP
a
todos
los
dem√°s
participantes
de
la
sesi√≥n
mediante
multidifusi√≥n
IP
.
Nor-


malmente
,
en
una
sesi√≥n
RTP
existe
una
√∫nica
direcci√≥n
de
multidifusi√≥n
y
todos
los
paque-


tes
RTP
y
RTCP
pertenecientes
a
la
sesi√≥n
utilizan
esa
direcci√≥n
de
multidifusi√≥n
.
Los


paquetes
RTP
y
RTCP
se
distinguen
entre
s√≠
por
medio
del
uso
de
distintos
n√∫meros
de


puerto
.
(
El
n√∫mero
de
puerto
RTCP
se
establece
para
que
sea
igual
al
n√∫mero
de
puerto
RTP


m√°s
uno
.
)


Los
paquetes
RTCP
no
encapsulan
fragmentos
de
audio
ni
de
v√≠deo
.
En
lugar
de
ello
,


estos
paquetes
son
enviados
peri√≥dicamente
y
contienen
informes
del
emisor
y
/
o
receptor


que
anuncian
estad√≠sticas
que
pueden
ser
√∫tiles
para
la
aplicaci√≥n
.
Estas
estad√≠sticas
inclu-


yen
el
n√∫mero
de
paquetes
enviados
,
el
n√∫mero
de
paquetes
perdidos
y
la
fluctuaci√≥n
entre


7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
605


IP


UDP


Enlace
de
datos


F√≠sica


RTP


Transporte


Aplicaci√≥n


Figura
7.12
‚Ä¢
RTP
puede
interpretarse
como
una
subcapa
de
la
capa
de


transporte
.


Receptor
Receptor


RTCP


RTCP


RTCP


Internet


Emisor


RTCP


Figura
7.13
‚Ä¢
Tanto
los
emisores
como
los
receptores
env√≠an
mensajes
RTCP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
605llegadas
.
La
especificaci√≥n
de
RTP
[
RFC
3550
]
no
establece
qu√©
debe
hacer
la
aplicaci√≥n


con
esta
informaci√≥n
de
realimentaci√≥n
,
por
lo
que
esta
cuesti√≥n
depende
del
desarrollador


de
la
aplicaci√≥n
.
Por
ejemplo
,
los
emisores
pueden
utilizar
la
informaci√≥n
de
realimentaci√≥n


para
modificar
sus
velocidades
de
transmisi√≥n
,
o
tambi√©n
se
puede
emplear
con
prop√≥sitos


de
diagn√≥stico
;
por
ejemplo
,
los
receptores
pueden
determinar
si
existen
problemas
de


car√°cter
local
,
regional
o
global
.


Tipos
de
paquetes
RTCP


Para
cada
flujo
RTP
que
recibe
un
receptor
como
parte
de
una
sesi√≥n
,
el
receptor
genera
un


informe
de
recepci√≥n
.
El
receptor
agrega
sus
informes
de
recepci√≥n
en
un
√∫nico
paquete


RTCP
,
el
cual
es
enviado
al
√°rbol
de
multidifusi√≥n
que
conecta
a
todos
los
participantes
de


la
sesi√≥n
.
El
informe
de
recepci√≥n
incluye
varios
campos
,
siendo
los
m√°s
importantes
los


siguientes
:


‚Ä¢E
l
 
i
d
e
n
t
i
f
i
c
a
d
o
r
 
S
S
R
C
 
d
e
l
 
f
l
u
j
o
 
R
T
P
p
a
r
a
 
e
l
 
q
u
e
 
s
e
 
h
a
 
g
e
n
e
r
a
d
o
 
e
l
 
i
n
f
o
r
m
e
 
d
e
 
r
e
c
e
p
c
i
√≥
n
.
 

‚Ä¢L
a
 
f
r
a
c
c
i
√≥
n
 
d
e
 
p
a
q
u
e
t
e
s
 
p
e
r
d
i
d
o
s
 
d
e
n
t
r
o
 
d
e
l
 
f
l
u
j
o
 
R
T
P
.
 
C
a
d
a
 
r
e
c
e
p
t
o
r
 
c
a
l
c
u
l
a
 
e
l
 
n
√∫
m
e
r
o


de
paquetes
RTP
perdidos
dividido
entre
el
n√∫mero
de
paquetes
RTP
enviados
como


parte
del
flujo
.
Si
un
emisor
recibe
informes
de
recepci√≥n
que
indican
que
a
los
recepto-


res
s√≥lo
est√°
llegando
una
peque√±a
fracci√≥n
de
los
paquetes
transmitidos
por
el
emisor


puede
cambiar
a
una
tasa
de
codificaci√≥n
menor
,
con
el
fin
de
disminuir
la
congesti√≥n
de


la
red
y
mejorar
la
tasa
de
recepci√≥n
.


‚Ä¢
El
√∫ltimo
n√∫mero
de
secuencia
recibido
en
el
flujo
de
paquetes
RTP
.


‚Ä¢L
a
 
f
l
u
c
t
u
a
c
i
√≥
n
 
e
n
t
r
e
 
l
l
e
g
a
d
a
s
,
 
q
u
e
 
e
s
 
u
n
a
 
e
s
t
i
m
a
c
i
√≥
n
 
s
u
a
v
i
z
a
d
a
 
d
e
 
l
a
 
v
a
r
i
a
c
i
√≥
n
 
d
e
l


tiempo
que
transcurre
entre
la
llegada
de
paquetes
sucesivos
del
flujo
RTP
.


El
emisor
crea
y
transmite
paquetes
de
informe
de
emisor
TCP
para
cada
flujo
RTP
que


transmite
.
Estos
paquetes
incluyen
informaci√≥n
acerca
del
flujo
RTP
,
entre
la
que
se
incluye
:


‚Ä¢E
l
 
i
d
e
n
t
i
f
i
c
a
d
o
r
 
S
S
R
C
 
d
e
l
 
f
l
u
j
o
 
R
T
P
.


‚Ä¢L
a
 
m
a
r
c
a
 
d
e
 
t
i
e
m
p
o
 
y
 
e
l
 
t
i
e
m
p
o
 
a
b
s
o
l
u
t
o
 
d
e
l
 
p
a
q
u
e
t
e
 
R
T
P
m
√°
s
 
r
e
c
i
e
n
t
e
m
e
n
t
e
 
g
e
n
e
r
a
d
o


en
el
flujo
.


‚Ä¢E
l
 
n
√∫
m
e
r
o
 
d
e
 
p
a
q
u
e
t
e
s
 
e
n
v
i
a
d
o
s
 
e
n
 
e
l
 
f
l
u
j
o
.
 

‚Ä¢
El
n√∫mero
de
bytes
enviados
en
el
flujo
.


Los
informes
del
emisor
se
pueden
utilizar
para
sincronizar
los
distintos
flujos
multi-


media
dentro
de
una
sesi√≥n
RTP
.
Por
ejemplo
,
consideremos
una
aplicaci√≥n
de
videoconfe-


rencia
en
la
que
cada
emisor
genera
dos
flujos
RTP
independientes
,
uno
para
el
v√≠deo
y
otro


para
el
audio
.
Las
marcas
de
tiempo
de
estos
paquetes
RTP
est√°n
ligadas
a
los
relojes
de


muestreo
del
v√≠deo
y
del
audio
y
no
est√°n
relacionadas
con
el
tiempo
absoluto
(
es
decir
,
el


tiempo
real
)
.
Cada
informe
de
emisor
RTCP
contiene
,
para
el
paquete
generado
m√°s
recien-


temente
en
el
flujo
RTP
asociado
,
la
marca
de
tiempo
del
paquete
RTP
y
el
tiempo
absoluto


de
cuando
el
paquete
fue
creado
.
Por
tanto
,
los
paquetes
de
informe
de
emisor
RTCP
aso-


cian
el
reloj
de
muestreo
con
el
reloj
de
tiempo
real
.
Los
receptores
pueden
utilizar
esta


asociaci√≥n
de
los
informes
de
emisor
RTCP
para
sincronizar
la
reproducci√≥n
del
audio
y
del


v√≠deo
.


Para
cada
flujo
RTP
que
transmite
un
emisor
,
√©ste
tambi√©n
crea
y
transmite
paquetes
de


descripci√≥n
del
origen
.
Estos
paquetes
contienen
informaci√≥n
acerca
del
origen
,
como
la


606
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
606direcci√≥n
de
correo
electr√≥nico
del
emisor
,
el
nombre
del
mismo
y
la
aplicaci√≥n
que
genera


el
flujo
RTP
.
Tambi√©n
incluye
el
SSRC
del
flujo
RTP
asociado
.
Estos
paquetes
proporcionan


una
correspondencia
entre
el
identificador
del
origen
(
es
decir
,
el
SSRC
)
y
el
nombre
del


usuario
/
host
.


Los
paquetes
RTCP
son
apilables
;
es
decir
,
los
informes
de
recepci√≥n
del
receptor
,
los


informes
del
emisor
y
los
descriptores
del
origen
se
pueden
concatenar
en
un
mismo


paquete
.
El
paquete
resultante
se
encapsula
entonces
en
un
segmento
UDP
que
se
reenv√≠a


sobre
el
√°rbol
de
multidifusi√≥n
.


Escalado
del
ancho
de
banda
RTCP


Es
posible
que
haya
observado
que
RTCP
tiene
un
potencial
problema
de
escalado
.
Por


ejemplo
,
considere
una
sesi√≥n
RTP
que
consta
de
un
emisor
y
de
un
gran
n√∫mero
de
recep-


tores
.
Si
cada
uno
de
los
receptores
genera
peri√≥dicamente
paquetes
RTCP
,
entonces
la
velo-


cidad
agregada
de
transmisi√≥n
de
los
paquetes
RTCP
puede
exceder
en
gran
medida
la


velocidad
de
los
paquetes
RTP
enviados
por
el
emisor
.
Observe
que
la
cantidad
de
tr√°fico


RTP
enviada
al
√°rbol
de
multidifusi√≥n
no
cambia
cuando
aumenta
el
n√∫mero
de
receptores
,


mientras
que
la
cantidad
de
tr√°fico
RTCP
crece
linealmente
con
el
n√∫mero
de
recepto-


res
.
Para
resolver
este
problema
de
escalado
,
RTCP
modifica
la
velocidad
a
la
que
un
parti-


cipante
env√≠a
paquetes
RTCP
sobre
el
√°rbol
de
multidifusi√≥n
como
una
funci√≥n
del
n√∫mero


de
participantes
en
la
sesi√≥n
.
Adem√°s
,
dado
que
cada
participante
env√≠a
paquetes
de
control


a
todos
los
dem√°s
,
cada
participante
podr√°
estimar
el
n√∫mero
total
de
participantes
en
la


sesi√≥n
[
Friedman
1999
]
.


RTCP
intenta
limitar
su
tr√°fico
a
un
5
por
ciento
del
ancho
de
banda
de
la
sesi√≥n
.
Por


ejemplo
,
suponga
que
hay
un
emisor
que
est√°
enviando
v√≠deo
a
una
velocidad
de
2
Mbps
.
En


este
caso
,
RTCP
intenta
limitar
su
tr√°fico
al
5
por
ciento
de
2
Mbps
,
es
decir
,
a
100
kbps
,
de


la
manera
siguiente
:
el
protocolo
proporciona
el
75
por
ciento
de
esta
velocidad
,
es
decir
,
75


kbps
,
a
los
receptores
;
y
el
restante
25
por
ciento
de
la
velocidad
,
25
kbps
,
al
emisor
.
Los


75
kbps
dedicados
a
los
receptores
son
compartidos
de
forma
equitativa
entre
los
receptores
.


Por
tanto
,
si
hay
R
receptores
,
entonces
cada
uno
de
ellos
puede
enviar
tr√°fico
RTCP
a
una


velocidad
de
75
/
R
kbps
,
y
el
emisor
podr√°
enviar
tr√°fico
RTCP
a
una
velocidad
de
25
kbps
.


Un
participante
(
un
emisor
o
un
receptor
)
determina
el
periodo
de
transmisi√≥n
de
paquetes


RTCP
de
forma
din√°mica
calculando
el
tama√±o
promedio
de
paquete
RTCP
(
a
lo
largo
de
la


sesi√≥n
completa
)
y
dividiendo
dicho
valor
entre
su
velocidad
asignada
.
En
resumen
,
para
un


emisor
,
el
periodo
de
transmisi√≥n
de
los
paquetes
RTCP
es
:


Ye
l
 
p
e
r
i
o
d
o
 
d
e
 
t
r
a
n
s
m
i
s
i
√≥
n
 
d
e
 
l
o
s
 
p
a
q
u
e
t
e
s
 
R
T
C
Pp
a
r
a
 
u
n
 
r
e
c
e
p
t
o
r
 
e
s
:
 

7.4.3
SIP


Imagine
un
mundo
en
el
que
,
cuando
se
encuentra
trabajando
en
su
PC
,
sus
llamadas
de
tel√©-


fono
llegan
a
su
PC
a
trav√©s
de
Internet
.
Cuando
se
levanta
y
camina
,
sus
llamadas
telef√≥ni-


T
=
  


N√∫mero
de
receptores


0,75
 
0,05
 
ancho
de
banda
de
la
sesi√≥n
 
(
tama√±o
medio
de
los
paquetes
RTCP
)


T
N√∫mero
de
emisores


0,25
  
0,05
   
ancho
de
banda
de
la
sesi√≥n
 
(
tama√±o
medio
de
los
paquetes
RTCP
)
.
        
.
 

7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
607


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
607cas
son
enrutadas
autom√°ticamente
a
su
PDA
.
Y
cuando
est√°
conduciendo
,
sus
llamadas
son


autom√°ticamente
enrutadas
a
alg√∫n
dispositivo
Internet
disponible
en
su
coche
.
En
ese


mismo
mundo
,
tambi√©n
es
posible
estar
participando
en
una
conferencia
telef√≥nica
y
acce-


der
a
un
libro
de
direcciones
para
llamar
e
invitar
a
otros
para
que
participen
en
la
conferen-


cia
.
Los
dem√°s
participantes
pueden
encontrarse
sentados
frente
a
sus
equipos
PC
,
paseando


con
sus
PDA
o
conduciendo
sus
autom√≥viles
(
independientemente
de
d√≥nde
est√©n
,
su
invi-


taci√≥n
ser√°
enrutada
de
forma
transparente
)
.
En
ese
mismo
mundo
,
al
navegar
por
la
p√°gina


principal
de
un
individuo
existir√°
un
enlace
‚Äú
Ll√°mame
‚Äù
en
el
que
al
hacer
clic
se
establecer√°


una
sesi√≥n
de
telefon√≠a
por
Internet
entre
su
PC
y
el
propietario
de
la
p√°gina
(
se
encuentre


donde
se
encuentre
esa
persona
)
.


En
ese
mundo
ya
no
existe
una
red
de
telefon√≠a
de
conmutaci√≥n
de
circuitos
;
en
lugar


de
ello
,
todas
las
llamadas
pasan
a
trav√©s
de
Internet
de
extremo
a
extremo
.
En
este
mundo
,


las
empresas
tampoco
utilizan
ya
las
PBX
,
es
decir
,
circuitos
conmutados
locales
que
permi-


ten
gestionar
las
llamadas
telef√≥nicas
entre
empresas
.
En
su
lugar
,
el
tr√°fico
telef√≥nico
entre


compa√±√≠as
fluye
a
trav√©s
de
la
red
LAN
de
alta
velocidad
de
las
mismas
.
 

Todo
esto
puede
sonarle
a
ciencia
ficci√≥n
y
,
por
supuesto
,
las
redes
de
comutaci√≥n
de


circuitos
y
las
PBX
actuales
no
van
a
desaparecer
completamente
en
un
futuro
cercano


[
Jiang
2001
]
.
No
obstante
,
existen
protocolos
y
productos
que
pueden
convertir
esta
visi√≥n


en
realidad
.
Entre
los
protocolos
m√°s
prometedores
que
van
en
esta
direcci√≥n
est√°
el
Proto-


colo
de
iniciaci√≥n
de
sesiones
(
SIP
,
Session
Initiation
Protocol
)
,
definido
en
[
RFC
3261
;


RFC5411
]
.
SIP
es
un
protocolo
ligero
que
hace
lo
siguiente
:


‚Ä¢P
r
o
p
o
r
c
i
o
n
a
 
m
e
c
a
n
i
s
m
o
s
 
p
a
r
a
 
e
s
t
a
b
l
e
c
e
r
 
l
l
a
m
a
d
a
s
 
e
n
t
r
e
 
e
l
 
q
u
e
 
l
l
a
m
a
 
y
 
e
l
 
q
u
e
 
e
s
 
l
l
a
m
a
d
o


a
trav√©s
de
una
red
IP
.
Permite
al
que
llama
notificar
al
llamado
que
desea
iniciar
una


comunicaci√≥n
.
Tambi√©n
permite
a
los
participantes
acordar
los
m√©todos
de
codificaci√≥n


de
los
datos
multimedia
,
as√≠
como
dar
por
terminadas
las
llamadas
.


‚Ä¢P
r
o
p
o
r
c
i
o
n
a
 
m
e
c
a
n
i
s
m
o
s
 
a
l
 
q
u
e
 
l
l
a
m
a
 
p
a
r
a
 
d
e
t
e
r
m
i
n
a
r
 
l
a
 
d
i
r
e
c
c
i
√≥
n
 
I
P
a
c
t
u
a
l
 
d
e
l
 
l
l
a
m
a
d
o
.


Los
usuarios
no
tienen
una
√∫nica
direcci√≥n
fija
porque
pueden
asignarse
din√°micamente


direcciones
(
mediante
DHCP
)
y
porque
pueden
tener
m√∫ltiples
dispositivos
IP
,
teniendo


cada
uno
de
ellos
una
direcci√≥n
IP
diferente
.


‚Ä¢P
r
o
p
o
r
c
i
o
n
a
 
m
e
c
a
n
i
s
m
o
s
 
p
a
r
a
 
l
a
 
g
e
s
t
i
√≥
n
 
d
e
 
l
l
a
m
a
d
a
s
 
t
a
l
e
s
 
c
o
m
o
 
a
√±
a
d
i
r
 
n
u
e
v
o
s
 
f
l
u
j
o
s


multimedia
durante
la
llamada
,
cambiar
el
m√©todo
de
codificaci√≥n
o
invitar
a
nuevos
par-


ticipantes
mientras
tiene
lugar
la
llamada
,
adem√°s
de
mecanismos
para
la
transferencia


de
llamadas
y
el
mantenimiento
de
las
mismas
.


Establecimiento
de
una
llamada
con
una
direcci√≥n
IP
conocida


Para
comprender
la
esencia
de
SIP
,
lo
mejor
es
analizar
un
ejemplo
concreto
.
En
este
ejem-


plo
,
Alicia
se
encuentra
delante
de
su
PC
y
desea
llamar
a
Benito
,
que
tambi√©n
est√°
traba-


jando
con
su
computadora
.
Los
PC
de
Alicia
y
de
Benito
est√°n
equipados
con
software


basado
en
SIP
que
les
permite
hacer
y
recibir
llamadas
telef√≥nicas
.
En
este
ejemplo
inicial
,


supondremos
que
Alicia
conoce
la
direcci√≥n
IP
de
la
computadora
de
Benito
.
En
la
Figura


7.14
se
ilustra
el
proceso
SIP
de
establecimiento
de
llamadas
.


En
la
Figura
7.14
vemos
que
se
inicia
una
sesi√≥n
SIP
cuando
Alicia
env√≠a
a
Benito
un


mensaje
INVITE
,
que
es
parecido
a
un
mensaje
de
solicitud
HTTP
.
Este
mensaje
INVITE
se


env√≠a
sobre
UDP
al
puerto
bien
conocido
5060
para
SIP
.
(
Los
mensajes
SIP
tambi√©n
se
pue-


den
enviar
sobre
TCP
.
)
El
mensaje
INVITE
incluye
un
identificador
para
Benito


608
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
608(benito@193.64.210.89
)
,
una
indicaci√≥n
de
la
direcci√≥n
IP
actual
de
Alicia
,
una
indicaci√≥n


de
que
Alicia
desea
recibir
audio
,
el
cual
debe
codificarse
en
formato
A
VP
0
(
codificaci√≥n


PCM
/H9262-law
)
y
encapsularse
en
RTP
,
y
una
indicaci√≥n
de
que
Alicia
desea
recibir
los
paque-


tes
RTP
en
el
puerto
38060
.
Despu√©s
de
recibir
el
INVITE
de
Alicia
,
Benito
env√≠a
un
men-


saje
de
respuesta
SIP
,
que
es
similar
a
un
mensaje
de
respuesta
HTTP
.
Este
mensaje
de


respuesta
SIP
tambi√©n
se
env√≠a
al
puerto
SIP
5060
.
La
respuesta
de
Benito
incluye
un
men-


saje
200
OK
y
una
indicaci√≥n
de
su
direcci√≥n
IP
,
la
forma
de
codificaci√≥n
y
empaqueta-


miento
que
desea
para
recepci√≥n
y
su
n√∫mero
de
puerto
al
que
deben
enviarse
los
paquetes


de
audio
.
Observe
que
,
en
este
ejemplo
,
Alicia
y
Benito
van
a
emplear
diferentes
mecanis-


mos
de
codificaci√≥n
de
audio
:
a
Alicia
se
le
solicita
que
codifique
su
audio
con
GSM
mien-


tras
que
a
Benito
se
le
pide
que
codifique
su
audio
con
PCM
/H9262-law
.
Una
vez
recibida
la


respuesta
de
Benito
,
Alicia
env√≠a
a
Benito
un
mensaje
de
reconocimiento
SIP
.
Despu√©s
de


esta
transacci√≥n
SIP
,
Benito
y
Alicia
pueden
hablar
.
(
Por
comodidad
visual
,
la
Figura
7.14


muestra
que
Alicia
habla
despu√©s
de
Benito
,
pero
en
la
realidad
normalmente
hablan
al


mismo
tiempo
.
)
Benito
codificar√°
y
empaquetar√°
el
audio
de
la
forma
requerida
y
enviar√°


los
paquetes
de
audio
al
n√∫mero
de
puerto
38060
en
la
direcci√≥n
IP
167.180.112.24
.
Alicia


7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
609


Tiempo
Tiempo


167.180.112.24


INVITE
benito@193.64.210.89


c
=
IN
IP4
167.180.112.24


m
=
audio
38060
RTP
/
AVP
0


200
OK


c
=
In
IP4
193.64.210.89


m
=
audio
48753
RTP
/
AVP
3


El
terminal
de


Benito
suena


193.64.210.89


/H9262
Law
audio


puerto
5060


puerto
5060


puerto
38060


Alicia
Benito


puerto
5060


puerto
48753


ACK


GSM


Figura
7.14
‚Ä¢
Establecimiento
de
una
llamada
SIP
cuando
Alicia
conoce


la
direcci√≥n
IP
de
Benito
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
609tambi√©n
codificar√°
y
empaquetar√°
el
audio
en
el
formato
solicitado
y
enviar√°
los
paquetes


de
audio
al
n√∫mero
de
puerto
48753
en
la
direcci√≥n
IP
193.64.210.89
.


Con
este
sencillo
ejemplo
hemos
aprendido
una
serie
de
caracter√≠sticas
clave
de
SIP
.
En


primer
lugar
,
SIP
es
un
protocolo
fuera
de
banda
:
los
mensajes
SIP
se
env√≠an
y
se
reciben
en


sockets
diferentes
de
los
utilizados
para
enviar
y
recibir
los
datos
multimedia
.
En
segundo


lugar
,
los
propios
mensajes
SIP
son
mensajes
legibles
ASCII
y
son
parecidos
a
los
mensajes


HTTP
.
Por
√∫ltimo
,
SIP
requiere
que
todos
los
mensajes
sean
reconocidos
,
por
lo
que
se


puede
ejecutar
sobre
UDP
o
sobre
TCP
.


Siguiendo
con
este
ejemplo
,
ahora
vamos
a
considerar
lo
que
ocurrir√≠a
si
Benito
no
dis-


pone
de
un
codec
PCM
/H9262-law
para
codificar
el
audio
.
En
este
caso
,
en
lugar
de
responder


con
200
OK
,
Benito
probablemente
responder√≠a
con
el
mensaje
600
Not
Acceptablee


incluir√≠a
en
el
mensaje
todos
los
codecs
que
puede
utilizar
.
Alicia
elegir√≠a
entonces
uno
de


los
codecs
de
la
lista
y
enviar√≠a
otro
mensaje
INVITE
,
anunciando
en
esta
ocasi√≥n
el
codec


elegido
.
Benito
tambi√©n
podr√≠a
simplemente
rechazar
la
llamada
enviando
uno
de
los


muchos
posibles
c√≥digos
de
respuesta
de
rechazo
.
(
Existen
muchos
c√≥digos
de
este
tipo
,


entre
los
que
se
incluyen
‚Äú
ocupado
‚Äù
,
‚Äú
ausente
‚Äù
,
‚Äú
pago
requerido
‚Äù
y
‚Äú
prohibido
‚Äù
.
)


Direcciones
SIP


En
el
ejemplo
anterior
,
la
direcci√≥n
SIP
de
Benito
es
sip:benito@193.64.210.89
.
Sin


embargo
,
es
deseable
que
muchas
(
si
no
la
mayor√≠a
)
direcciones
SIP
se
parezcan
a
direccio-


nes
de
correo
electr√≥nico
.
Por
ejemplo
,
la
direcci√≥n
de
Benito
podr√≠a
ser
sip
:
benito


@dominio.com
.
Cuando
el
dispositivo
SIP
de
Alicia
env√≠a
un
mensaje
INVITE
,
el
mensaje


incluir√≠a
esta
direcci√≥n
similar
a
una
direcci√≥n
de
correo
electr√≥nico
;
la
infraestructura
SIP


enrutar√≠a
entonces
el
mensaje
al
dispositivo
IP
que
Benito
est√©
utilizando
en
ese
momento


(
como
veremos
m√°s
adelante
)
.
Otro
posible
formato
de
la
direcci√≥n
SIP
podr√≠a
ser
el
n√∫mero


de
tel√©fono
de
Benito
o
simplemente
su
nombre
y
apellidos
(
suponiendo
siempre
que
fueran


√∫nicos
)
.


Una
caracter√≠stica
interesante
de
las
direcciones
SIP
es
que
pueden
incluirse
en
p√°ginas


web
,
al
igual
que
se
incluyen
las
direcciones
de
correo
electr√≥nico
en
las
p√°ginas
web
con
el


URL
mailto
.
Por
ejemplo
,
suponga
que
Benito
tiene
una
p√°gina
web
personal
y
que
desea


proporcionar
un
medio
a
sus
visitantes
para
que
le
llamen
.
Benito
puede
simplemente
incluir


el
URL
sip:benito@dominio.com
y
,
de
este
modo
,
cuando
un
visitante
haga
clic
en
el


URL
,
la
aplicaci√≥n
SIP
del
dispositivo
del
visitante
se
ejecuta
y
env√≠a
un
mensaje
INVITE
a


Benito
.


Mensajes
SIP


En
esta
breve
introducci√≥n
al
protocolo
SIP
no
vamos
a
tratar
todas
las
cabeceras
y
tipos
de


mensajes
SIP
.
En
lugar
de
ello
vamos
a
examinar
brevemente
el
mensaje
SIP
INVITE
junto


con
unas
pocas
l√≠neas
de
cabecera
comunes
.
Supongamos
de
nuevo
que
Alicia
desea
iniciar


una
llamada
de
tel√©fono
IP
con
Benito
y
en
esta
ocasi√≥n
Alicia
conoce
la
direcci√≥n
SIP
de


Benito
,
benito@dominio.com
,
pero
no
conoce
la
direcci√≥n
IP
del
dispositivo
que
Benito


est√°
utilizando
actualmente
.
El
mensaje
de
Alicia
ser√≠a
similar
al
siguiente
:


INVITE
sip:benito@dominio.com
SIP/2.0


Via
:
SIP/2.0
/
UDP
167.180.112.24


From
:
sip:alicia@hereway.com


To
:
sip:benito@dominio.com


610
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
610Call-ID
:
a2e3a@pigeon.hereway.com


Content-Type
:
application
/
sdp


Content-Length
:
885


c
=
IN
IP4
167.180.112.24


m
=
audio
38060
RTP
/
AVP
0


La
l√≠nea
INVITE
incluye
la
versi√≥n
de
SIP
,
al
igual
que
en
un
mensaje
de
solicitud


HTTP
.
Cuando
un
mensaje
SIP
atraviesa
un
dispositivo
SIP
(
incluyendo
el
dispositivo
que


origina
el
mensaje
)
asocia
una
l√≠nea
de
cabecera
Via
,
que
indica
la
direcci√≥n
IP
del
disposi-


tivo
.
(
Veremos
enseguida
que
el
mensaje
INVITE
t√≠pico
atraviesa
muchos
dispositivos
SIP


antes
de
llegar
a
la
aplicaci√≥n
SIP
del
llamado
.
)
De
formar
similar
a
un
mensaje
de
correo


electr√≥nico
,
el
mensaje
SIP
incluye
una
l√≠nea
de
cabecera
From
y
una
l√≠nea
de
cabecera
To
.


El
mensaje
incluye
tambi√©n
la
l√≠nea
de
cabecera
Call-ID
,
que
identifica
de
forma
un√≠voca


la
llamada
(
de
forma
similar
al
message-ID
de
un
correo
electr√≥nico
)
.
Tambi√©n
incluye
la


l√≠nea
de
cabecera
Content-Type
,
que
define
el
formato
utilizado
para
describir
el
conte-


nido
del
mensaje
SIP
,
e
incluye
la
l√≠nea
de
cabecera
Content-Length
,
que
proporciona
la


longitud
en
bytes
del
contenido
del
mensaje
.
Por
√∫ltimo
,
despu√©s
de
un
retorno
de
carro
y
un


salto
de
l√≠nea
,
se
incluye
el
contenido
del
mensaje
.
En
este
caso
,
el
contenido
proporciona


informaci√≥n
acerca
de
la
direcci√≥n
IP
de
Alicia
y
de
c√≥mo
desea
√©sta
recibir
el
audio
.


Traducci√≥n
de
nombres
y
localizaci√≥n
de
usuarios


En
el
ejemplo
de
la
Figura
7.14
hemos
supuesto
que
el
dispositivo
SIP
de
Alicia
conoc√≠a
la


direcci√≥n
IP
en
la
que
podr√≠a
contactar
a
Benito
.
Pero
esta
suposici√≥n
es
bastante
poco
rea-


lista
,
no
s√≥lo
porque
las
direcciones
IP
a
menudo
son
asignadas
din√°micamente
mediante


DHCP
,
sino
tambi√©n
porque
Benito
dispone
de
varios
dispositivos
IP
(
por
ejemplo
,
diversos


dispositivos
en
su
domicilio
,
en
el
trabajo
y
en
el
coche
)
.
Por
tanto
,
ahora
vamos
a
suponer


que
Alicia
s√≥lo
conoce
la
direcci√≥n
de
correo
electr√≥nico
de
Benito
,
benito@dominio
.


com
,
y
que
esta
misma
direcci√≥n
se
utiliza
para
las
llamadas
basadas
en
SIP
.
En
este
caso
,


Alicia
tiene
que
obtener
la
direcci√≥n
IP
del
dispositivo
que
est√°
utilizando
actualmente
el


usuario
benito@dominio.com
.
Para
determinar
esto
,
Alicia
crea
un
mensaje
INVITE
que


comienza
con
INVITE
benito@dominio.com
SIP/2.0y
env√≠a
este
mensaje
a
un
proxy


SIP
.
El
proxy
contestar√°
con
una
respuesta
SIP
que
podr√≠a
incluir
la
direcci√≥n
IP
del
dispo-


sitivo
que
actualmente
est√°
utilizando
benito@dominio.com
.
De
forma
alternativa
,
la
res-


puesta
podr√≠a
incluir
la
direcci√≥n
IP
del
buz√≥n
de
voz
de
Benito
,
o
podr√≠a
incluir
un
URL
de


una
p√°gina
web
(
que
diga
‚Äú
¬°
Benito
est√°
durmiendo
.
No
molestar
!
‚Äù
)
.
Adem√°s
,
el
resultado


devuelto
por
el
proxy
podr√≠a
depender
de
qui√©n
hace
la
llamada
:
si
la
llamada
es
de
la
esposa


de
Benito
,
aceptar√°
la
llamada
y
suministrar√°
su
direcci√≥n
IP
;
si
la
llamada
la
hace
la
suegra


de
Benito
,
podr√≠a
responder
con
el
URL
que
apunta
a
la
p√°gina
web
de
¬°
Estoy
durmiendo
!


Es
posible
que
en
este
momento
se
est√©
preguntando
c√≥mo
puede
el
servidor
proxy


determinar
la
direcci√≥n
IP
actual
para
benito@dominio.com
.
Para
responder
a
esta
pre-


gunta
,
primero
tenemos
que
decir
algunas
cosas
acerca
de
otro
dispositivo
SIP
:
el
registra-


dor
SIP
.
Todos
los
usuarios
SIP
tienen
un
asociado
registrador
.
Cuando
un
usuario
ejecuta


una
aplicaci√≥n
SIP
en
un
dispositivo
,
la
aplicaci√≥n
env√≠a
un
mensaje
de
registro
SIP
al
regis-


trador
,
inform√°ndole
de
su
direcci√≥n
IP
actual
.
Por
ejemplo
,
cuando
Benito
ejecuta
su
apli-


caci√≥n
SIP
en
su
PDA
,
la
aplicaci√≥n
enviar√°
un
mensaje
con
las
siguientes
l√≠neas
:


7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
611


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
611REGISTER
sip
:
dominio.com
SIP/2.0


Via
:
SIP/2.0
/
UDP
193.64.210.89


From
:
sip:benito@dominio.com


To
:
sip:benito@dominio.com


Expires
:
3600


El
registrador
de
Benito
mantiene
su
direcci√≥n
IP
actual
.
Cuando
Benito
cambia
a
un


dispositivo
SIP
nuevo
,
√©ste
env√≠a
un
nuevo
mensaje
de
registro
indicando
la
nueva
direcci√≥n


IP
.
Adem√°s
,
si
Benito
permanece
en
el
mismo
dispositivo
durante
un
periodo
de
tiempo


largo
,
el
dispositivo
enviar√°
mensajes
de
registro
de
refresco
,
indicando
que
la
direcci√≥n
IP


enviada
m√°s
recientemente
contin√∫a
siendo
v√°lida
.
(
En
el
ejemplo
anterior
,
los
mensajes
de


refresco
necesariamente
eran
enviados
cada
3.600
segundos
con
el
fin
de
mantener
la
direc-


ci√≥n
en
el
servidor
registrador
.
)
Merece
la
pena
comentar
que
el
registrador
es
an√°logo
a
un


servidor
de
nombres
DNS
autoritativo
:
el
servidor
DNS
traduce
los
nombres
fijos
de
host
a


direcciones
IP
fijas
y
el
registrador
SIP
traduce
los
identificadores
fijos
de
personas
(
por


ejemplo
,
benito@dominio.com
)
a
direcciones
IP
din√°micas
.
A
menudo
los
registradores


SIP
y
los
proxies
SIP
se
ejecutan
en
el
mismo
host
.


Examinemos
ahora
c√≥mo
el
servidor
proxy
de
Alicia
obtiene
la
direcci√≥n
IP
actual
de


Benito
.
En
la
exposici√≥n
anterior
hemos
visto
que
el
servidor
proxy
simplemente
necesita


reenviar
el
mensaje
INVITE
de
Alicia
al
registrador
/
proxy
de
Benito
.
El
registrador
/
proxy


podr√≠a
entonces
reenviar
el
mensaje
al
dispositivo
SIP
actual
de
Benito
.
Por
√∫ltimo
,
una
vez


que
Benito
ha
recibido
el
mensaje
INVITE
de
Alicia
,
podr√≠a
enviar
una
respuesta
SIP
a


Alicia
.


612
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


9


5


6


4


7


2


3


1


8


registrador
SIP


upenn.edu


proxy
SIP


umass.edu


cliente
SIP


217.123.56.89


cliente
SIP


197.87.54.21


registrador
SIP


eurcom.fr


Figura
7.15
‚Ä¢
Iniciaci√≥n
de
sesi√≥n
que
implica
proxies
y
registradores
SIP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
612Por
ejemplo
,
considere
la
Figura
7.15
,
en
la
que
juan@umass.edu
,
que
actualmente


est√°
trabajando
en
217.123.56.89
,
desea
iniciar
una
sesi√≥n
de
V
oz
sobre
IP
(
V
oIP
)
con


katy@upenn.edu
,
que
se
encuentra
en
este
momento
trabajando
en
197.87.54.21
.
Los


pasos
que
se
llevan
a
cabo
son
los
siguientes
:
(
1
)
Juan
env√≠a
un
mensaje
INVITE
al
proxy


SIP
umass
.
(
2
)
El
proxy
realiza
una
b√∫squeda
DNS
en
el
registrador
SIP
upenn.edu
(
no


mostrado
en
el
diagrama
)
y
luego
reenv√≠a
el
mensaje
al
servidor
registrador
.
(
3
)
Puesto
que


katy@upenn.edu
todav√≠a
no
est√°
registrada
en
el
registrador
upenn
,
√©ste
env√≠a
una
res-


puesta
de
redirecci√≥n
que
indica
que
deber√≠a
probar
katy@eurecom.fr
.
(
4
)
El
proxy


umass
env√≠a
un
mensaje
INVITE
al
registrador
SIP
eurecom
.
(
5
)
El
registrador
eurecom


conoce
la
direcci√≥n
IP
de
katy@eurecom.fr
y
reenv√≠a
el
mensaje
INVITE
al
host


197.87.54.21
,
que
est√°
ejecutando
el
cliente
SIP
de
Katy
.
(
6-8
)
Se
devuelve
al
cliente
SIP


217.123.56.89
una
respuesta
SIP
a
trav√©s
de
los
registradores
/
proxies
.
(
9
)
Los
datos
multi-


media
se
env√≠an
directamente
entre
los
dos
clientes
.
(
Tambi√©n
existe
un
mensaje
de
recono-


cimiento
SIP
,
que
no
se
muestra
en
la
figura
.
)


Nuestra
exposici√≥n
acerca
de
SIP
se
ha
centrado
en
el
proceso
de
iniciaci√≥n
de
llamada


para
el
caso
de
llamadas
de
voz
.
SIP
,
aunque
en
general
es
un
protocolo
de
se√±alizaci√≥n
para


el
inicio
y
la
terminaci√≥n
de
llamadas
,
puede
utilizarse
para
videoconferencia
,
as√≠
como
para


sesiones
basadas
en
texto
.
De
hecho
,
SIP
se
ha
convertido
en
un
componente
fundamental


en
muchas
aplicaciones
de
mensajer√≠a
instant√°nea
.
Animamos
a
los
lectores
que
deseen


aprender
m√°s
acerca
de
SIP
a
visitar
el
sitio
web
de
Henning
Schulzrinne
[
Schulzrinne-SIP


2009
]
.
En
particular
,
en
este
sitio
encontrar√°
software
de
c√≥digo
abierto
para
clientes
y
servi-


dores
SIP
[
SIP
Software
2009
]
.


7.4.4
H.323


Como
alternativa
a
SIP
,
H.323
es
un
est√°ndar
popular
para
audio
y
videoconferencia
en


tiempo
real
entre
sistemas
terminales
de
Internet
.
Como
se
muestra
en
la
Figura
7.16
,
el


est√°ndar
tambi√©n
cubre
c√≥mo
los
sistemas
terminales
conectados
a
Internet
se
comunican


con
tel√©fonos
conectados
a
redes
telef√≥nicas
de
conmutaci√≥n
de
circuitos
.
(
SIP
tambi√©n


hace
esto
,
aunque
no
lo
vamos
a
ver
aqu√≠
.
)
El
canalizador
H.323
es
un
dispositivo
similar
a


un
registrador
SIP
.


El
est√°ndar
H.323
es
una
especificaci√≥n
paraguas
que
incluye
las
siguientes
especifica-


ciones
:


‚Ä¢U
n
a
 
e
s
p
e
c
i
f
i
c
a
c
i
√≥
n
 
a
c
e
r
c
a
 
d
e
 
c
√≥
m
o
 
l
o
s
 
p
u
n
t
o
s
 
t
e
r
m
i
n
a
l
e
s
 
n
e
g
o
c
i
a
n
 
l
o
s
 
s
i
s
t
e
m
a
s
 
d
e
 
c
o
d
i
-


ficaci√≥n
comunes
de
audio
/
v√≠deo
.
Puesto
que
H.323
soporta
una
serie
de
est√°ndares
de


codificaci√≥n
de
audio
y
v√≠deo
,
se
necesita
un
protocolo
que
permita
la
comunicaci√≥n


entre
los
puntos
terminales
con
el
fin
de
acordar
un
sistema
de
codificaci√≥n
com√∫n
.


‚Ä¢U
n
a
 
e
s
p
e
c
i
f
i
c
a
c
i
√≥
n
 
a
c
e
r
c
a
 
d
e
 
c
√≥
m
o
 
s
e
 
e
n
c
a
p
s
u
l
a
n
 
y
 
s
e
 
e
n
v
√≠
a
n
 
l
o
s
 
f
r
a
g
m
e
n
t
o
s
 
d
e
 
a
u
d
i
o
 
y


v√≠deo
a
trav√©s
de
la
red
.
En
particular
,
H.323
obliga
el
uso
de
RTP
para
este
prop√≥sito
.


‚Ä¢U
n
a
 
e
s
p
e
c
i
f
i
c
a
c
i
√≥
n
 
a
c
e
r
c
a
 
d
e
 
c√≥mo
los
puntos
terminales
se
comunican
con
sus
respecti-


vos
canalizadores
.


‚Ä¢U
n
a
 
e
s
p
e
c
i
f
i
c
a
c
i
√≥
n
 
a
c
e
r
c
a
 
d
e
 
c
√≥
m
o
 
l
o
s
 
t
e
l
√©
f
o
n
o
s
 
I
n
t
e
r
n
e
t
 
s
e
 
c
o
m
u
n
i
c
a
n
 
a
 
t
r
a
v
√©
s
 
d
e
 
u
n
a


pasarela
con
tel√©fonos
ordinarios
de
la
red
p√∫blica
de
telefon√≠a
conmutada
.


Como
m√≠nimo
,
cada
punto
terminal
H.323
debe
soportar
el
est√°ndar
de
compresi√≥n
de


voz
G.711
.
G.711
utiliza
PCM
para
generar
voz
digitalizada
a
56
o
64
kbps
.
Aunque
H.323


7.4
‚Ä¢
PROTOCOLOS
PARA
APLICACIONES
INTERACTIVAS
EN
TIEMPO
REAL
613


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
613requiere
que
todos
los
puntos
terminales
permitan
voz
(
a
trav√©s
de
G.711
)
,
las
capacidades


de
v√≠deo
son
opcionales
.
Dado
que
el
soporte
de
v√≠deo
es
opcional
,
los
fabricantes
de
termi-


nales
pueden
vender
terminales
de
voz
m√°s
simples
,
as√≠
como
terminales
m√°s
complejos
que


soporten
tanto
audio
como
v√≠deo
.
Las
capacidades
de
v√≠deo
para
un
punto
terminal
 
H.323


son
opcionales
.
Sin
embargo
,
si
un
punto
terminal
soporta
v√≠deo
,
entonces
tiene
que
sopor-


tar
(
como
m√≠nimo
)
el
est√°ndar
de
v√≠deo
QCIF
H.261
(
176
/H11003144
p√≠xeles
)
.


H.323
es
un
est√°ndar
muy
amplio
que
,
adem√°s
de
los
est√°ndares
y
protocolos
descritos


anteriormente
,
impone
el
uso
del
protocolo
de
control
H.245
,
de
un
canal
de
se√±alizaci√≥n


Q.931
y
de
un
protocolo
RAS
para
el
registro
con
el
canalizador
.


Concluimos
esta
secci√≥n
examinando
algunas
de
las
diferencias
m√°s
importantes
entre


H.323
y
SIP
.


‚Ä¢H
.
3
2
3
 
e
s
 
u
n
a
 
s
e
r
i
e
 
c
o
m
p
l
e
t
a
 
y
 
v
e
r
t
i
c
a
l
m
e
n
t
e
 
i
n
t
e
g
r
a
d
a
 
d
e
 
p
r
o
t
o
c
o
l
o
s
 
p
a
r
a
 
c
o
n
f
e
r
e
n
c
i
a
s


multimedia
:
se√±alizaci√≥n
,
registro
,
control
de
admisi√≥n
,
transporte
y
codecs
(
codificado-


res-decodificadores
)
.


‚Ä¢P
o
r
 
e
l
 
c
o
n
t
r
a
r
i
o
,
 
S
I
P
√∫
n
i
c
a
m
e
n
t
e
 
c
o
n
t
r
o
l
a
 
e
l
 
i
n
i
c
i
o
 
y
 
g
e
s
t
i
√≥
n
 
d
e
 
l
a
s
 
s
e
s
i
o
n
e
s
,
 
c
o
n
s
t
a
n
d
o


de
un
√∫nico
componente
.
SIP
funciona
con
RTP
pero
no
es
obligatorio
.
Funciona
con
los


codecs
de
voz
G.711
y
los
codecs
de
v√≠deo
QCIF
H.261
,
pero
tampoco
son
obligatorios
.


Se
puede
combinar
con
otros
protocolos
y
servicios
.


‚Ä¢H
.
3
2
3
 
p
r
o
c
e
d
e
 
d
e
 
l
a
 
I
T
U
 
(
t
e
l
e
f
o
n
√≠
a
)
,
 
m
i
e
n
t
r
a
s
 
q
u
e
 
S
I
P
p
r
o
c
e
d
e
 
d
e
 
I
E
T
F
 
y
 
t
o
m
a
 
m
u
c
h
o
s


conceptos
de
la
Web
,
DNS
y
el
correo
electr√≥nico
de
Internet
.


‚Ä¢
H.323
,
al
ser
un
est√°ndar
paraguas
,
es
grande
y
complejo
.
SIP
utiliza
el
principio
de
sen-


cillez
KISS
(
keep
it
simple
,
stupid
)
.


Si
desea
ver
una
excelente
exposici√≥n
acerca
de
H.323
,
SIP
y
V
oIP
en
general
,
consulte


[
Hersent
2000
]
.


614
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Internet


Puntos
terminales
H.323
Tel√©fonos


Canalizador


Pasarela


Red


telef√≥nica


Figura
7.16
‚Ä¢
Sistemas
terminales
H.323
conectados
a
Internet
pueden


comunicarse
con
tel√©fonos
conectados
a
una
red
telef√≥nica


de
circuitos
conmutados
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
6147.5
M√∫ltiples
clases
de
servicios


En
las
secciones
anteriores
hemos
visto
c√≥mo
las
aplicaciones
multimedia
pueden
utilizar


los
n√∫meros
de
secuencia
,
las
marcas
de
tiempo
,
FEC
,
RTP
y
H.323
en
la
red
Internet
actual
.


Las
redes
CDN
representan
una
soluci√≥n
global
de
sistema
para
distribuir
contenido
mul-


timedia
.
Pero
,
¬ø
son
estas
t√©cnicas
por
s√≠
mismas
suficientes
para
soportar
aplicaciones


fiables
y
robustas
tales
como
un
servicio
de
telefon√≠a
IP
que
sea
equivalente
a
la
red
telef√≥-


nica
actual
?
Antes
de
responder
a
esta
pregunta
,
recordemos
una
vez
m√°s
que
la
red
Internet


actual
proporciona
un
servicio
de
entrega
de
mejor
esfuerzo
a
todas
sus
aplicaciones
;
es


decir
,
no
hace
ninguna
promesa
relativa
a
la
calidad
del
servicio
que
recibir√°
una
aplicaci√≥n
.


La
aplicaci√≥n
recibir√°
aquel
nivel
de
rendimiento
(
por
ejemplo
,
p√©rdida
y
retardos
de
paque-


tes
terminal
a
terminal
)
que
la
red
sea
capaz
de
proporcionar
en
cada
momento
.
Recuerde


tambi√©n
que
la
red
Internet
p√∫blica
actual
no
permite
que
las
aplicaciones
multimedia
sensi-


bles
al
retardo
soliciten
ning√∫n
tratamiento
especial
.
Dado
que
todos
los
paquetes
,
inclu-


yendo
los
paquetes
de
audio
y
de
v√≠deo
sensibles
al
retardo
,
son
tratados
de
la
misma
forma


en
los
routers
,
la
calidad
de
una
llamada
de
tel√©fono
IP
activa
puede
arruinarse
si
existe
el


suficiente
tr√°fico
que
interfiera
(
es
decir
,
congesti√≥n
de
red
)
como
para
aumentar
de
forma


notable
el
retardo
y
las
p√©rdidas
que
afectan
a
la
llamada
.


Pero
si
el
objetivo
es
el
de
proporcionar
un
modelo
de
servicio
que
ofrezca
algo
m√°s


que
el
servicio
de
mejor
esfuerzo
de
la
red
Internet
actual
(
que
vale
para
todo
)
,
¬ø
qu√©
tipo
de


servicio
hay
que
proporcionar
exactamente
?
Un
modelo
de
servicio
simple
mejorado
con-


sistir√≠a
en
clasificar
el
tr√°fico
en
clases
y
proporcionar
diferentes
niveles
de
servicio
a
esas


distintas
clases
de
tr√°fico
.
Por
ejemplo
,
un
ISP
puede
desear
proporcionar
una
clase
de
ser-


vicio
mejor
al
tr√°fico
de
teleconferencia
o
de
voz
sobre
IP
sensibles
al
retardo
(
¬°
y
cobrar
m√°s


por
este
servicio
!
)
que
al
tr√°fico
el√°stico
como
el
de
FTP
o
HTTP
.
Todos
estamos
familiari-


zados
con
las
distintas
clases
de
servicio
en
nuestra
vida
cotidiana
:
los
pasajeros
de
primera


clase
de
una
l√≠nea
a√©rea
obtienen
un
mejor
servicio
que
los
pasajeros
de
la
clase
business
,


quienes
a
su
vez
obtienen
un
mejor
servicio
que
el
que
se
proporciona
a
los
pasajeros
de
la


clase
turista
;
las
personas
VIP
pueden
entrar
de
forma
inmediata
a
los
eventos
mientras
que


los
dem√°s
tienen
que
esperar
en
fila
;
en
algunos
pa√≠ses
las
personas
mayores
son
tremenda-


mente
respetadas
y
se
les
ofrece
los
asientos
de
honor
y
lo
m√°s
exquisito
de
los
alimentos
en


la
mesa
.


Es
importante
observar
que
tal
servicio
diferenciado
se
proporciona
entre
agregados
de


tr√°fico
;
es
decir
,
entre
clases
de
tr√°fico
,
no
entre
conexiones
individuales
.
Por
ejemplo
,
todos


los
pasajeros
de
primera
clase
son
tratados
igual
(
ning√∫n
pasajero
de
primera
clase
recibe
un


tratamiento
mejor
que
cualquier
otro
pasajero
tambi√©n
de
primera
clase
)
,
al
igual
que
todos


los
paquetes
V
oIP
recibir√°n
el
mismo
tratamiento
dentro
de
la
red
,
independientemente
de
la


conexi√≥n
terminal
a
terminal
concreta
a
la
que
pertenezcan
.
Como
veremos
,
al
tratar
con
un


n√∫mero
peque√±o
de
agregados
de
tr√°fico
en
lugar
de
con
una
gran
cantidad
de
conexiones


individuales
,
los
nuevos
mecanismos
de
red
requeridos
para
proporcionar
un
servicio
de


entrega
m√°s
efectivo
que
el
de
mejor
esfuerzo
pueden
ser
relativamente
simples
.


Evidentemente
,
los
primeros
dise√±adores
de
Internet
ten√≠an
esta
idea
de
m√∫ltiples
cla-


ses
de
servicios
en
mente
.
Recuerde
el
campo
Tipo
de
servicio
(
ToS
)
de
la
cabecera
IPv4
en


la
Figura
4.13
.
IEN123
[
ISI
1979
]
describe
el
campo
ToS
tambi√©n
presente
en
un
antecesor


del
datagrama
IPv4
de
la
siguiente
manera
:
‚Äú
El
campo
Tipo
de
servicio
proporciona
una


indicaci√≥n
de
los
par√°metros
abstractos
de
la
calidad
del
servicio
deseado
.
Estos
par√°metros


se
emplean
para
guiar
la
selecci√≥n
de
los
par√°metros
del
servicio
al
transmitir
un
datagrama


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
615


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
615a
trav√©s
de
una
red
concreta
.
Varias
redes
ofrecen
mecanismos
de
precedencia
de
servicio
,


que
tratan
en
cierto
modo
el
tr√°fico
con
precedencia
alta
como
si
fuera
m√°s
importante
que


el
resto
del
tr√°fico
.
‚Äù
Incluso
hace
tres
d√©cadas
,
¬°
la
visi√≥n
de
proporcionar
diferentes
niveles


de
servicio
a
los
diferentes
niveles
de
tr√°fico
estaba
clara
!
Sin
embargo
,
nos
ha
llevado
todo


ese
tiempo
el
conseguir
llevar
a
la
pr√°ctica
dicha
visi√≥n
.


Comenzaremos
nuestro
estudio
en
la
Secci√≥n
7.5.1
considerando
varios
escenarios
que


motivar√°n
la
necesidad
de
mecanismos
espec√≠ficos
que
den
soporte
a
m√∫ltiples
clases
de
ser-


vicio
.
A
continuaci√≥n
nos
ocuparemos
de
dos
temas
importantes
:
la
planificaci√≥n
en
el
nivel


de
enlace
y
la
vigilancia
/
clasificaci√≥n
de
paquetes
en
la
Secci√≥n
7.5.2
.
En
la
Secci√≥n
7.5.3


cubriremos
los
servicios
diferenciados
(
Diffserv
):
el
est√°ndar
actual
de
Internet
para
propor-


cionar
servicios
diferenciados
.


7.5.1
Escenarios


La
Figura
7.17
muestra
un
escenario
de
red
simple
.
Suponga
que
fluyen
dos
paquetes
de


aplicaci√≥n
originados
en
los
hosts
H1
y
H2
de
una
LAN
y
que
est√°n
destinados
a
los
hosts


H3
y
H4
de
otra
LAN
.
Los
routers
de
las
dos
redes
LAN
est√°n
conectados
mediante
un


enlace
a
1,5
Mbps
.
Suponemos
que
las
velocidades
de
las
redes
LAN
son
significativamente


m√°s
altas
que
1,5
Mbps
y
vamos
a
fijarnos
en
la
cola
de
salida
del
router
R1
;
es
aqu√≠
donde


se
producir√°
el
retardo
y
la
p√©rdida
de
paquetes
si
la
velocidad
agregada
de
transmisi√≥n
de


H1
y
H2
excede
los
1,5
Mbps
.
Consideremos
ahora
varios
escenarios
,
que
nos
van
a
presen-


tar
la
necesidad
de
mecanismos
espec√≠ficos
para
dar
soporte
a
m√∫ltiples
clases
de
servicios
.


Escenario
1
:
una
aplicaci√≥n
de
audio
de
1
Mbps
y
una
transferencia
FTP


El
escenario
1
se
ilustra
en
la
Figura
7.18
.
En
este
caso
,
una
aplicaci√≥n
de
audio
de
1
Mbps


(
por
ejemplo
,
una
llamada
de
audio
con
calidad
de
CD
)
comparte
el
enlace
a
1,5
 
Mbps
entre


R1
y
R2
con
una
aplicaci√≥n
FTP
que
est√°
transfiriendo
un
archivo
desde
H2
a
H4
.
Con
el


616
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


R1


Enlace
a


1,5
Mbps


Cola
de
la
interfaz


de
salida
de
R1


R2


H2


H1


H4


H3


Figura
7.17
‚Ä¢
Una
red
simple
con
dos
aplicaciones
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
616servicio
de
entrega
del
mejor
esfuerzo
de
Internet
,
los
paquetes
de
audio
y
FTP
se
mezclan


en
la
cola
de
salida
de
R1
y
(
normalmente
)
se
transmiten
siguiendo
el
orden
primero
en


entrar
primero
en
salir
(
FIFO
,
First-In-First-Out
)
.
En
este
escenario
,
una
r√°faga
de
paquetes


procedentes
del
origen
FTP
podr√≠a
potencialmente
llenar
la
cola
,
haciendo
que
los
paquetes


de
audio
IP
se
retardaran
excesivamente
o
se
perdieran
a
causa
de
un
desbordamiento
del


buffer
de
R1
.
¬ø
C√≥mo
podemos
resolver
este
potencial
problema
?
Dado
que
la
aplicaci√≥n


FTP
no
tiene
restricciones
de
tiempo
,
nuestra
intuici√≥n
puede
llevarnos
a
pensar
que
deber√≠a


proporcionarse
una
prioridad
estricta
a
los
paquetes
de
audio
en
R1
.
Aplicando
esta
disci-


plina
de
planificaci√≥n
con
prioridad
estricta
,
un
paquete
de
audio
que
se
encuentra
en
el
buf-


fer
de
salida
de
R1
siempre
deber√≠a
transmitirse
antes
que
cualquier
paquete
FTP
que
se


encuentre
en
este
mismo
buffer
.
El
enlace
entre
R1
y
R2
ser√≠a
entonces
como
un
enlace
dedi-


cado
a
1,5
Mbps
para
el
tr√°fico
de
audio
y
el
tr√°fico
FTP
emplear√≠a
dicho
enlace
s√≥lo
cuando


no
hubiera
tr√°fico
de
audio
en
la
cola
.


Con
el
fin
de
que
R1
distinga
los
paquetes
de
audio
de
los
paquetes
FTP
que
tiene
en
su


cola
,
cada
uno
de
los
paquetes
debe
marcarse
como
perteneciente
a
una
de
esas
dos
clases


de
tr√°fico
.
√âste
era
el
objetivo
original
del
campo
Tipo
de
servicio
(
ToS
)
de
IPv4
.
Aunque


pueda
parecer
obvio
,
√©ste
es
nuestro
primer
principio
b√°sico
en
el
que
se
fundamentan
los


mecanismos
necesarios
para
proporcionar
m√∫ltiples
clases
de
tr√°fico
:


Principio
1
:
el
marcado
de
los
paquetes
permite
a
un
router
diferenciar
entre
paquetes


pertenecientes
a
distintas
clases
de
tr√°fico
.


Escenario
2
:
una
aplicaci√≥n
de
audio
de
1
Mbps
y
una
transferencia
FTP


con
prioridad
alta


Nuestro
segundo
escenario
es
ligeramente
diferente
del
escenario
1
.
Suponga
ahora
que


el
usuario
FTP
ha
comprado
a
su
ISP
un
servicio
‚Äú
platinum
‚Äù
(
es
decir
,
de
alto
precio
)
,


mientras
que
el
usuario
de
audio
ha
adquirido
un
servicio
Internet
de
bajo
presupuesto
y


barato
,
cuyo
coste
es
una
min√∫scula
fracci√≥n
del
coste
del
servicio
platinum
.
En
este
caso
,


¬ø
deber√≠a
darse
prioridad
a
los
paquetes
de
audio
del
usuario
que
ha
adquirido
un
servicio


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
617


R1


Enlace
a


1,5
Mbps
R2


H2


H1


H4


H3


Figura
7.18
‚Ä¢
Competencia
entre
aplicaciones
de
audio
y
FTP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
617barato
frente
a
los
paquetes
FTP
?
Posiblemente
no
.
En
este
caso
,
parece
m√°s
razonable
dife-


renciar
los
paquetes
bas√°ndose
en
la
direcci√≥n
IP
del
emisor
.
En
general
,
vemos
que
es
nece-


sario
que
los
routers
clasifiquen
los
paquetes
de
acuerdo
con
determinados
criterios
.


Teniendo
esto
en
cuenta
,
tenemos
que
modificar
ligeramente
el
principio
1
:


Principio
1
(
modificado
):
la
clasificaci√≥n
de
paquetes
permite
a
los
routers
diferenciar


entre
paquetes
que
pertenecen
a
distintas
clases
de
tr√°fico
.


El
marcado
expl√≠cito
de
los
paquetes
es
una
forma
que
permite
diferenciarlos
.
Sin


embargo
,
la
marca
que
transporta
el
paquete
,
por
s√≠
misma
,
no
implica
que
el
paquete
reci-


bir√°
una
determinada
calidad
de
servicio
.
El
marcado
es
simplemente
un
mecanismo
para


distinguir
los
paquetes
.
La
manera
en
que
un
router
distingue
entre
paquetes
trat√°ndolos
de


forma
diferente
es
una
decisi√≥n
de
vigilancia
.


Escenario
3
:
una
aplicaci√≥n
de
audio
con
mal
comportamiento


y
una
transferencia
FTP


Suponga
ahora
que
,
de
alguna
manera
(
usando
mecanismos
que
estudiaremos
en
las
siguien-


tes
secciones
)
,
el
router
sabe
que
debe
dar
prioridad
a
los
paquetes
procedentes
de
la
aplica-


ci√≥n
de
audio
a
1
Mbps
.
Puesto
que
la
velocidad
del
enlace
de
salida
es
de
1,5
Mbps
,
incluso


aunque
los
paquetes
FTP
tengan
una
prioridad
menor
todav√≠a
recibir√°n
,
como
promedio
,
 
un


servicio
de
transmisi√≥n
de
0,5
Mbps
.
Pero
,
¬ø
qu√©
ocurre
si
la
aplicaci√≥n
de
audio
comienza
a


enviar
paquetes
a
una
velocidad
de
1,5
Mbps
o
superior
(
bien
maliciosamente
o
debido
a
un


error
de
la
aplicaci√≥n
)
?
En
este
caso
,
los
paquetes
FTP
no
recibir√°n
ning√∫n
servicio
del


enlace
R1
a
R2
.
Podr√≠an
producirse
problemas
similares
si
varias
aplicaciones
(
por
ejemplo
,


varias
llamadas
de
audio
)
,
todas
ellas
con
la
misma
prioridad
,
tuvieran
que
compartir
el


ancho
de
banda
de
un
enlace
;
un
flujo
no
conforme
podr√≠a
degradar
y
arruinar
el
rendi-


miento
de
los
restantes
flujos
.
Idealmente
,
es
deseable
un
grado
de
aislamiento
entre
clases


de
tr√°fico
y
tambi√©n
posiblemente
entre
flujos
de
una
misma
clase
de
tr√°fico
,
con
el
fin
de


proteger
a
cada
uno
de
los
flujos
de
aquellos
flujos
que
presentan
un
comportamiento
err√≥-


neo
.
El
concepto
de
proteger
los
flujos
individuales
de
una
determinada
clase
frente
a
las


otras
contradice
nuestra
observaci√≥n
anterior
acerca
de
que
los
paquetes
de
todos
los
flujos


pertenecientes
a
una
clase
deber√≠an
ser
tratados
del
mismo
modo
.
En
la
pr√°ctica
,
los
paque-


tes
de
una
clase
son
de
hecho
tratados
del
mismo
modo
en
los
routers
del
n√∫cleo
de
la
red
.


Sin
embargo
,
en
la
frontera
de
la
red
los
paquetes
de
un
determinado
flujo
pueden
ser
moni-


torizados
para
garantizar
que
la
velocidad
agregada
de
un
flujo
individual
no
excede
un


cierto
valor
.


Estas
consideraciones
nos
llevan
a
nuestro
segundo
principio
:


Principio
2
:
es
deseable
proporcionar
un
grado
de
aislamiento
entre
las
clases
de
tr√°-


fico
y
entre
los
flujos
,
de
manera
que
una
clase
o
un
flujo
no
se
vea
afectado
de
forma


adversa
por
otro
que
tiene
un
comportamiento
err√≥neo
.


En
la
siguiente
secci√≥n
vamos
a
examinar
varios
mecanismos
espec√≠ficos
para
propor-


cionar
este
aislamiento
entres
clases
de
tr√°fico
o
flujos
.
Debemos
comentar
aqu√≠
que
es
posi-


ble
adoptar
dos
enfoques
.
En
primer
lugar
,
como
se
muestra
en
la
Figura
7.19
,
es
posible


vigilar
el
tr√°fico
.
Si
una
clase
de
tr√°fico
o
flujo
tiene
que
satisfacer
ciertos
criterios
(
por


ejemplo
,
que
el
flujo
de
audio
no
exceda
la
velocidad
de
pico
de
1
Mbps
)
,
entonces
puede


618
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
618utilizarse
un
mecanismo
de
vigilancia
con
el
fin
de
garantizar
que
esos
criterios
son
obser-


vados
.
Si
la
aplicaci√≥n
que
se
est√°
monitorizando
presenta
un
mal
comportamiento
,
enton-


ces
el
mecanismo
de
vigilancia
llevar√°
a
cabo
una
cierta
acci√≥n
(
por
ejemplo
,
descartar
o


retardar
los
paquetes
que
est√°n
violando
los
criterios
)
,
de
modo
que
el
tr√°fico
que
realmente


entre
en
la
red
cumpla
los
criterios
.
El
mecanismo
de
goteo
(
una
cubeta
con
p√©rdidas
)
que


examinaremos
en
la
siguiente
secci√≥n
es
quiz√°
el
mecanismo
de
vigilancia
m√°s
ampliamente


utilizado
.
En
la
Figura
7.19
,
el
mecanismo
de
clasificaci√≥n
y
marcado
de
paquetes
(
Princi-


pio
1
)
y
el
mecanismo
de
vigilancia
(
Principio
2
)
est√°n
localizados
en
la
frontera
de
la
red
,


bien
en
el
sistema
terminal
o
bien
en
un
router
de
frontera
.


Un
enfoque
alternativo
para
proporcionar
aislamiento
entre
clases
de
tr√°fico
o
flujos
es


que
el
mecanismo
de
planificaci√≥n
de
paquetes
a
nivel
de
enlace
asigne
expl√≠citamente
una


cantidad
fija
de
ancho
de
banda
del
enlace
a
cada
clase
o
flujo
.
Por
ejemplo
,
al
flujo
de
audio


podr√≠a
asign√°rsele
1
Mbps
en
R1
y
al
flujo
FTP
se
le
podr√≠a
asignar
0,5
Mbps
.
En
este
caso
,


los
flujos
de
audio
y
FTP
ven
un
enlace
l√≥gico
con
una
capacidad
de
1,0
y
0,5
Mbps
,
respec-


tivamente
,
como
se
muestra
en
la
Figura
7.20
.


Con
un
cumplimiento
estricto
de
la
asignaci√≥n
de
ancho
de
banda
a
nivel
de
enlace
,
una


clase
o
un
flujo
s√≥lo
puede
usar
la
cantidad
de
ancho
de
banda
que
ha
sido
asignada
;
en
con-


creto
,
no
puede
utilizar
ancho
de
banda
que
no
est√©
siendo
actualmente
empleado
por


otros
.
Por
ejemplo
,
si
el
flujo
de
audio
se
silencia
(
por
ejemplo
,
si
el
que
habla
hace
una


pausa
y
no
genera
paquetes
de
audio
)
,
el
flujo
FTP
seguir√°
sin
poder
transmitir
a
m√°s
de


0,5
Mbps
a
trav√©s
del
enlace
de
R1
a
R2
,
incluso
aunque
la
asignaci√≥n
de
ancho
de
banda


de
1
Mbps
del
flujo
de
audio
no
est√©
siendo
utilizada
en
ese
momento
.
Por
tanto
,
es
de-


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
619


R1


Enlace
a
1,5
Mbps


Vigilancia
y
marcado


de
paquetes


Medici√≥n
y
vigilancia
Marcas


R2


H2


H1


Clave
:


H4


H3


Figura
7.19
‚Ä¢
Vigilancia
(
y
marcado
)
de
los
flujos
de
tr√°fico
de
audio
y
FTP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
619seable
utilizar
el
ancho
de
banda
de
la
forma
m√°s
eficiente
posible
,
permitiendo
a
una


clase
de
tr√°fico
o
flujo
utilizar
el
ancho
de
banda
no
utilizado
por
otros
en
cualquier
ins-


tante
dado
.
Estas
consideraciones
nos
llevan
a
nuestro
tercer
principio
:


Principio
3
:
mientras
se
proporciona
aislamiento
entre
clases
o
flujos
,
es
deseable


utilizar
los
recursos
(
por
ejemplo
,
el
ancho
de
banda
del
enlace
y
los
buffers
)
de
la


forma
m√°s
eficiente
posible
.


7.5.2
Mecanismos
de
planificaci√≥n
y
vigilancia


Ahora
que
hemos
identificado
los
principios
en
que
se
fundamentan
los
mecanismos
nece-


sarios
para
proporcionar
las
distintas
clases
de
servicios
,
vamos
a
considerar
en
detalle
dos


de
los
mecanismos
m√°s
importantes
:
la
planificaci√≥n
y
la
vigilancia
.


Mecanismos
de
planificaci√≥n


Recuerde
que
en
las
Secciones
1.3
y
4.3
hemos
visto
que
los
paquetes
que
pertenecen
a


varios
flujos
de
red
se
multiplexan
y
se
ponen
en
cola
para
su
transmisi√≥n
en
los
buffers
de


salida
asociados
con
un
enlace
.
La
forma
en
que
los
paquetes
puestos
en
cola
son
seleccio-


nados
para
su
transmisi√≥n
a
trav√©s
del
enlace
se
conoce
como
disciplina
de
planificaci√≥n


de
enlace
.
Vamos
a
considerar
ahora
m√°s
detalladamente
varias
de
las
disciplinas
de
planifi-


caci√≥n
de
enlace
m√°s
importantes
.


Primero
en
entrar-primero
en
salir
(
FIFO
)


La
Figura
7.21
muestra
las
abstracciones
del
modelo
de
cola
para
la
disciplina
de
planifica-


ci√≥n
de
enlace
FIFO
.
Los
paquetes
que
llegan
a
la
cola
de
salida
del
enlace
esperan
para
ser


transmitidos
si
el
enlace
actualmente
est√°
ocupado
transmitiendo
otro
paquete
.
Si
no
hay


suficiente
espacio
en
el
buffer
como
para
almacenar
el
paquete
que
ha
llegado
,
la
pol√≠tica


de
eliminaci√≥n
de
paquetes
de
la
cola
determina
si
el
paquete
ser√°
eliminado
(
paquete
per-


dido
)
o
si
se
ser√°n
eliminados
otros
paquetes
de
la
cola
para
hacer
espacio
al
paquete
reci√©n


620
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


R1


Enlace
a


1,5
Mbps


Enlace
l√≥gico


a
1,0
Mbps


Enlace


l√≥gico


a
0,5
Mbps


R2


H2


H1


H4


H3


Figura
7.20
‚Ä¢
Aislamiento
l√≥gico
de
los
flujos
de
las
aplicaciones
de
audio
y
FTP
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
620llegado
.
En
la
exposici√≥n
que
sigue
vamos
a
ignorar
la
eliminaci√≥n
de
paquetes
.
Cuando
un


paquete
se
transmite
completamente
a
trav√©s
del
enlace
de
salida
(
es
decir
,
recibe
servicio
)


se
elimina
de
la
cola
.


La
disciplina
de
planificaci√≥n
FIFO
,
tambi√©n
conocida
como
FCFS
(
First-Come-First-


Served
,
primero
en
entrar
,
primero
en
ser
servido
)
,
selecciona
los
paquetes
para
su
transmi-


si√≥n
a
trav√©s
del
enlace
en
el
mismo
orden
en
que
han
llegado
a
la
cola
del
enlace
de
salida
.


Todos
estamos
familiarizados
con
las
colas
FIFO
gracias
a
las
paradas
de
los
autobuses


(
especialmente
en
Inglaterra
,
donde
las
colas
parecen
haber
sido
perfeccionadas
)
o
a
otros


centros
de
servicios
,
donde
los
clientes
que
llegan
se
colocan
al
final
de
la
fila
,
permane-


ciendo
en
orden
y
luego
van
siendo
servidos
a
medida
que
llegan
al
principio
de
la
fila
.


La
Figura
7.22
muestra
el
funcionamiento
de
la
cola
FIFO
.
La
llegada
de
los
paquetes


est√°
indicada
mediante
flechas
numeradas
por
encima
de
la
l√≠nea
de
tiempo
superior
,
indi-


cando
el
n√∫mero
de
orden
en
el
que
ha
llegado
el
paquete
.
La
salida
de
cada
uno
de
los


paquetes
se
muestra
por
debajo
de
la
l√≠nea
de
tiempo
inferior
.
El
instante
en
el
que
un


paquete
recibe
servicio
(
est√°
siendo
transmitido
)
se
indica
mediante
el
rect√°ngulo
som-


breado
situado
entre
las
dos
l√≠neas
de
tiempo
.
En
la
disciplina
FIFO
los
paquetes
salen
en
el


mismo
orden
en
el
que
llegaron
.
Observe
que
despu√©s
de
la
salida
del
paquete
4
el
enlace


permanece
inactivo
(
ya
que
los
paquetes
1
hasta
4
han
sido
transmitidos
y
eliminados
de
la


cola
)
hasta
la
llegada
del
paquete
5
.


Colas
con
prioridad


En
las
colas
con
prioridad
los
paquetes
que
llegan
al
enlace
de
salida
se
clasifican
en
clases


de
prioridad
en
la
cola
de
salida
,
como
se
muestra
en
la
Figura
7.23
.
Como
se
ha
visto
en
la


secci√≥n
anterior
,
la
clase
de
prioridad
de
un
paquete
puede
depender
de
una
marca
expl√≠cita


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
621


Llegadas
Salidas


Cola


(
√°rea
de
espera
)


Enlace


(
servidor
)


Figura
7.21
‚Ä¢
Abstracci√≥n
de
la
cola
FIFO
.


Tiempo


Llegadas


Salidas


Paquete


en
servicio


Tiempo


1


1
2
3
4
5


2
3


1


t
=
0
t
=
2
t
=
4
t
=
6
t
=
8
t
=
10
t
=
12
t
=
14


2
3
4
5


4
5


Figura
7.22
‚Ä¢
La
cola
FIFO
en
funcionamiento
.


t
=
0
t
=
2
t
=
4
t
=
6
t
=
8
t
=
10
t
=
12
t
=
14


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
621que
transporta
en
su
cabecera
(
por
ejemplo
,
el
valor
de
los
bits
ToS
de
un
paquete
IPv4
)
,
de
su


direcci√≥n
IP
de
origen
o
de
destino
,
su
n√∫mero
de
puerto
de
destino
u
otro
criterio
.
Normal-


mente
,
cada
clase
de
prioridad
tiene
su
propia
cola
.
Al
seleccionar
un
paquete
para
su
transmi-


si√≥n
,
la
disciplina
de
colas
con
prioridad
transmitir√°
un
paquete
de
la
clase
con
la
prioridad


m√°s
alta
que
tenga
una
cola
no
vac√≠a
(
es
decir
,
que
tenga
paquetes
para
ser
transmitidos
)
.
La


elecci√≥n
entre
paquetes
con
la
misma
clase
de
prioridad
normalmente
se
realiza
aplicando
la


disciplina
FIFO
.


La
Figura
7.24
ilustra
el
funcionamiento
de
una
cola
con
dos
clases
de
prioridad
.
Los


paquetes
1
,
3
y
4
pertenecen
a
la
clase
con
prioridad
alta
y
los
paquetes
2
y
5
pertenecen
a
la


clase
con
prioridad
baja
.
El
paquete
1
llega
y
se
encuentra
con
que
el
enlace
est√°
inactivo
,


por
lo
que
inicia
la
transmisi√≥n
.
Durante
la
transmisi√≥n
del
paquete
1
llegan
los
paquetes
2
y


3
y
se
colocan
,
respectivamente
,
en
las
colas
de
baja
y
alta
prioridad
.
Despu√©s
de
la
transmi-


si√≥n
del
paquete
1
se
selecciona
el
paquete
3
(
un
paquete
con
prioridad
alta
)
para
su
trans-


misi√≥n
antes
que
el
paquete
2
(
incluso
aunque
haya
llegado
antes
,
ya
que
es
un
paquete
con


baja
prioridad
)
.
Al
terminar
la
transmisi√≥n
del
paquete
3
se
inicia
la
transmisi√≥n
del
paquete


2
.
El
paquete
4
(
un
paquete
con
prioridad
alta
)
llega
durante
la
transmisi√≥n
del
paquete
2
(
un


paquete
con
prioridad
baja
)
.
En
una
disciplina
de
colas
con
prioridad
no
expropiativa
,
la


transmisi√≥n
de
un
paquete
no
se
interrumpe
una
vez
que
√©sta
ha
comenzado
.
En
este
caso
,
el


paquete
4
se
pone
en
cola
para
ser
transmitido
y
comienza
a
ser
enviado
una
vez
que
la


transmisi√≥n
del
paquete
2
ha
sido
completada
.


622
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Llegadas
Salidas


Cola
de
baja
prioridad


(
√°rea
de
espera
)


Clasificaci√≥n


Cola
de
alta
prioridad


(
√°rea
de
espera
)


Enlace


(
servidor
)


Figura
7.23
‚Ä¢
Modelo
de
colas
con
prioridad
.


Llegadas


Salidas


Paquete


en
servicio


1


1
23
45


2
3


1
23
45


45


Tiempo


Tiempo


t
=
0
t
=
2
t
=
4
t
=
6
t
=
8
t
=
10
t
=
12
t
=
14


Figura
7.24
‚Ä¢
Funcionamiento
de
la
cola
con
prioridad
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
622Colas
de
turno
rotatorio
y
colas
equitativas
ponderadas
(
WFQ
)


En
la
disciplina
de
colas
de
turno
rotatorio
(
round
robin
)
los
paquetes
se
clasifican
en
cla-


ses
al
igual
que
en
la
colas
con
prioridad
.
Sin
embargo
,
en
lugar
de
existir
un
servicio
de


prioridad
estricta
entre
clases
,
un
planificador
de
turno
rotatorio
alterna
el
servicio
entre
cla-


ses
.
En
la
forma
m√°s
simple
de
la
planificaci√≥n
por
turno
rotatorio
se
transmite
un
paquete


de
clase
1
seguido
de
un
paquete
de
clase
2
,
seguido
de
un
paquete
de
clase
1
,
seguido
de
un


paquete
de
clase
2
,
y
as√≠
sucesivamente
.
Una
disciplina
de
colas
conservadora
nunca
permi-


tir√°
que
el
enlace
permanezca
inactivo
siempre
que
haya
paquetes
(
de
cualquier
clase
)
espe-


rando
a
ser
transmitidos
.
Una
disciplina
de
colas
de
turno
rotatorio
conservadora
busca


un
paquete
de
una
determinada
clase
,
pero
si
no
lo
encuentra
,
comprueba
inmediatamente
la


siguiente
clase
de
la
secuencia
de
turno
rotatorio
.


La
Figura
7.25
ilustra
el
funcionamiento
de
una
cola
por
turno
rotatorio
de
dos
cla-


ses
.
En
este
ejemplo
,
los
paquetes
1
,
2
y
4
pertenecen
a
la
clase
1
y
los
paquetes
3
y
5


pertenecen
a
la
clase
2
.
El
paquete
1
comienza
a
ser
transmitido
de
forma
inmediata


nada
m√°s
llegar
a
la
cola
de
salida
.
Los
paquetes
2
y
3
llegan
mientras
se
est√°
transmi-


tiendo
el
paquete
1
y
por
tanto
tienen
que
ponerse
en
cola
hasta
poder
ser
transmitidos
.
Una


vez
que
el
paquete
1
se
ha
transmitido
,
el
planificador
del
enlace
busca
un
paquete
de
clase


2
,
por
lo
que
transmite
el
paquete
3
.
Despu√©s
de
transmitir
este
paquete
,
el
planificador


busca
un
paquete
de
clase
1
y
transmite
el
paquete
2
.
Una
vez
transmitido
el
paquete
2
s√≥lo


queda
en
la
cola
el
paquete
4
,
el
cual
es
transmitido
inmediatamente
despu√©s
del
paquete
2
.


Una
abstracci√≥n
generalizada
de
las
colas
de
turno
rotatorio
que
ha
encontrado
un
con-


siderable
uso
en
las
arquitecturas
QoS
es
la
denominada
disciplina
de
cola
equitativa
pon-


derada
(
WFQ
,
Weighted
Fair
Queuing
)
[
Demers
1990
;
Parekh
1993
]
.
En
la
Figura
7.26
se


ilustran
las
colas
WFQ
.
Los
paquetes
que
llegan
se
clasifican
y
se
ponen
en
cola
en
el
√°rea


de
espera
de
la
clase
apropiada
.
Como
en
la
planificaci√≥n
por
turno
rotatorio
,
un
planifica-


dor
WFQ
dar√°
servicio
a
las
clases
siguiendo
un
orden
circular
:
primero
dar√°
servicio
a
la


clase
1
,
luego
a
la
clase
2
,
despu√©s
a
la
clase
3
y
luego
(
suponiendo
que
existen
tres
clases
)


repetir√°
este
patr√≥n
de
servicio
.
WFQ
tambi√©n
es
una
disciplina
de
cola
conservadora
y
,


por
tanto
,
pasar√°
inmediatamente
a
la
siguiente
clase
indicada
en
la
secuencia
de
servicio


cuando
se
encuentre
con
una
clase
de
cola
vac√≠a
.


WFQ
se
diferencia
del
mecanismo
de
turno
rotatorio
en
que
cada
clase
puede
recibir


una
cantidad
de
servicio
diferente
en
cualquier
intervalo
de
tiempo
.
Espec√≠ficamente
,
a
cada


clase
i
se
le
asigna
un
peso
wi
.
En
WFQ
,
durante
cualquier
intervalo
de
tiempo
en
el
que


existan
paquetes
de
la
clase
i
para
enviar
,
se
garantiza
que
la
clase
i
recibir√°
una
fracci√≥n
de


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
623


Llegadas


Paquete


en
servicio


1


1
23
45


2
3


1
23
45


45


Salidas


Tiempo


Tiempo


t
=
0
t
=
2
t
=
4
t
=
6
t
=
8
t
=
10
t
=
12
t
=
14


Figura
7.25
‚Ä¢
Funcionamiento
de
una
cola
por
turno
rotatorio
de
dos
clases
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
623servicio
igual
a
wi/(‚àëwj
)
,
donde
el
sumatorio
del
denominador
se
calcula
para
todas
las
cla-


ses
que
tengan
paquetes
para
ser
transmitidos
.
En
el
caso
peor
,
incluso
aunque
todas
las


clases
tengan
paquetes
en
cola
,
contin√∫a
estando
garantizado
que
la
clase
i
recibir√°
una
frac-


ci√≥n
wi/(‚àëwj
)
del
ancho
de
banda
.
Por
tanto
,
en
el
caso
de
un
enlace
con
una
velocidad
de


transmisi√≥n
R
,
la
clase
i
siempre
alcanzar√°
una
tasa
de
transferencia
de
al
menos


R
¬∑
wi/(‚àëwj
)
.
Esta
descripci√≥n
de
las
colas
WFQ
que
hemos
proporcionado
se
corresponde


con
el
caso
ideal
,
ya
que
no
hemos
considerado
el
hecho
de
que
los
paquetes
son
unidades


discretas
de
datos
y
que
la
transmisi√≥n
de
un
paquete
no
ser√°
interrumpida
por
el
inicio
de
la


transmisi√≥n
de
otro
paquete
.
En
[
Demers
1990
]
y
[
Parekh
1993
]
se
analiza
este
problema
.


Como
veremos
en
las
siguientes
secciones
,
WFQ
desempe√±a
un
papel
fundamental
en
las


arquitecturas
QoS.
Tambi√©n
est√°
disponible
en
los
routers
actuales
[
Cisco
QoS
2009
]
.


Vigilancia
:
la
cubeta
con
p√©rdidas


Uno
de
los
principios
que
establecimos
en
la
Secci√≥n
7.5.1
era
que
la
vigilancia
,
es
decir
,
la


regulaci√≥n
de
la
velocidad
a
la
que
una
clase
o
flujo
puede
inyectar
paquetes
en
la
red
(
en
la


exposici√≥n
que
sigue
supondremos
que
la
unidad
de
vigilancia
es
un
flujo
)
.
Adem√°s
,
la
vigi-


lancia
es
un
mecanismo
QoS
importante
.
Pero
,
¬ø
qu√©
aspectos
de
la
tasa
de
paquetes
de
un


flujo
deber√≠an
ser
vigilados
?
Podemos
identificar
tres
importantes
criterios
de
vigilancia
,


cada
uno
de
ellos
diferente
con
respecto
a
la
escala
de
tiempo
de
vigilancia
del
flujo
de


paquetes
:


‚Ä¢
Tasa
promedio
.
La
red
puede
querer
limitar
la
tasa
promedio
a
largo
plazo
(
paquetes
por


intervalo
de
tiempo
)
a
la
que
los
paquetes
de
un
flujo
pueden
ser
enviados
a
la
red
.
Un


problema
crucial
en
este
caso
es
el
intervalo
de
tiempo
sobre
el
que
se
vigilar√°
la
tasa


promedio
.
Un
flujo
cuya
tasa
promedio
est√©
limitada
a
100
paquetes
por
segundo
est√°


m√°s
restringido
que
un
origen
que
est√°
limitado
a
6.000
paquetes
por
minuto
,
incluso


aunque
ambos
tengan
la
misma
tasa
promedio
a
lo
largo
de
un
intervalo
de
tiempo
lo


suficientemente
largo
.
Por
ejemplo
,
esta
√∫ltima
restricci√≥n
permitir√≠a
a
un
flujo
enviar


1.000
paquetes
en
un
determinado
intervalo
de
tiempo
de
un
segundo
,
mientras
que
la


primera
restricci√≥n
impedir√≠a
este
comportamiento
de
env√≠os
.


‚Ä¢
Tasa
de
pico
.
Mientras
que
la
restricci√≥n
de
la
tasa
promedio
limita
la
cantidad
de
tr√°fico


que
puede
ser
enviado
a
la
red
para
un
periodo
de
tiempo
relativamente
largo
,
la
restric-


624
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


Clasificar


llegadas
Salidas


w1


w2


w3
Enlace


Figura
7.26
‚Ä¢
Colas
equitativas
ponderadas
(
WFQ
)
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
624ci√≥n
de
la
tasa
de
pico
limita
el
n√∫mero
m√°ximo
de
paquetes
que
pueden
ser
enviados
en


un
periodo
de
tiempo
m√°s
corto
.
Siguiendo
con
el
ejemplo
anterior
,
la
red
puede
vigilar


un
flujo
con
una
tasa
promedio
de
6.000
paquetes
por
minuto
,
a
la
vez
que
limita
la
tasa


de
pico
del
flujo
a
1.500
paquetes
por
segundo
.


‚Ä¢
Tama√±o
de
la
r√°faga
.
La
red
tambi√©n
puede
desear
limitar
el
n√∫mero
m√°ximo
de
paque-


tes
(
la
‚Äú
r√°faga
‚Äù
de
paquetes
)
que
pueden
ser
enviados
a
la
red
en
un
intervalo
de
tiempo


extremadamente
corto
.
En
el
l√≠mite
,
cuando
la
longitud
del
intervalo
tiende
a
cero
,
el


tama√±o
de
la
r√°faga
limita
el
n√∫mero
de
paquetes
que
pueden
ser
enviados
a
la
red
de


forma
instant√°nea
.
Incluso
aunque
f√≠sicamente
sea
imposible
enviar
instant√°neamente


varios
paquetes
a
la
red
(
despu√©s
de
todo
,
los
enlaces
tienen
una
velocidad
de
transmi-


si√≥n
f√≠sica
que
no
puede
excederse
)
,
la
abstracci√≥n
de
un
tama√±o
m√°ximo
de
r√°faga
es


muy
√∫til
.


El
mecanismo
de
goteo
de
la
cubeta
con
p√©rdidas
es
una
abstracci√≥n
que
puede
utili-


zarse
para
caracterizar
estos
l√≠mites
de
vigilancia
.
Como
se
muestra
en
la
Figura
7.27
,
una


cubeta
con
p√©rdidas
es
una
cubeta
que
puede
almacenar
hasta
b
fichas
.
Las
fichas
se
van


a√±adiendo
a
esta
cubeta
de
la
forma
siguiente
:
las
nuevas
fichas
que
potencialmente
pueden


a√±adirse
a
la
cubeta
siempre
se
generan
a
una
velocidad
de
r
fichas
por
segundo
.
(
Para
sim-


plificar
,
supondremos
que
la
unidad
de
tiempo
en
este
caso
es
el
segundo
.
)
Si
la
cubeta
con-


tiene
menos
de
b
fichas
cuando
se
genera
una
ficha
,
la
ficha
que
se
acaba
de
generar
se


a√±ade
a
la
cubeta
;
en
caso
contrario
,
dicha
ficha
reci√©n
generada
se
ignora
y
la
cubeta
sigue


conteniendo
b
fichas
.


Veamos
ahora
c√≥mo
se
puede
utilizar
una
cubeta
con
p√©rdidas
para
vigilar
o
monitori-


zar
un
flujo
de
paquetes
.
Supongamos
que
antes
de
transmitir
un
paquete
a
la
red
es
necesa-


rio
eliminar
una
ficha
de
la
cubeta
.
En
este
caso
,
si
la
cubeta
est√°
vac√≠a
el
paquete
tendr√°
que


esperar
a
que
haya
una
ficha
.
(
Una
alternativa
ser√≠a
eliminar
el
paquete
,
aunque
esta
opci√≥n


no
vamos
a
considerarla
aqu√≠
.
)
Consideremos
ahora
c√≥mo
este
comportamiento
controla
un


flujo
de
tr√°fico
.
Puesto
que
como
m√°ximo
puede
haber
b
fichas
en
la
cubeta
,
el
tama√±o


m√°ximo
de
r√°faga
para
un
flujo
controlado
mediante
una
cubeta
con
p√©rdidas
es
de
b
fichas
.


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
625


A
la
red


Paquetes


Eliminar


ficha


√Årea
de


espera
de


ficha


La
cubeta


contiene
hasta


b
fichas


r
fichas
/
segundo


Figura
7.27
‚Ä¢
El
controlador
de
la
cubeta
con
p√©rdidas
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
625Adem√°s
,
dado
que
la
velocidad
de
generaci√≥n
de
fichas
es
r
,
el
n√∫mero
m√°ximo
de
paquetes


que
pueden
entrar
en
la
red
en
cualquier
intervalo
de
tiempo
de
longitud
t
es
rt
+
b.
Por


tanto
,
la
tasa
de
generaci√≥n
de
fichas
r
sirve
para
limitar
la
tasa
promedio
a
largo
plazo
a
la


que
los
paquetes
pueden
acceder
a
la
red
.
Tambi√©n
pueden
utilizarse
varias
cubetas
con
p√©r-


didas
(
en
concreto
,
dos
cubetas
de
este
tipo
en
serie
)
para
controlar
la
tasa
de
pico
de
un
flujo


adem√°s
de
la
tasa
promedio
a
largo
plazo
(
consulte
los
problemas
de
repaso
incluidos
al
final


del
cap√≠tulo
)
.


Cubeta
con
p√©rdidas
+
cola
WFQ
=
retardo
m√°ximo
probable
en
una
cola


Enseguida
vamos
a
examinar
los
m√©todos
Intserv
y
Diffserv
que
permiten
proporcionar
cali-


dad
de
servicio
en
Internet
.
Veremos
que
tanto
la
vigilancia
mediante
cubetas
con
p√©rdidas


como
la
planificaci√≥n
WFQ
pueden
desempe√±ar
un
papel
importante
.
A
continuaci√≥n
con-


cluiremos
esta
secci√≥n
considerando
el
enlace
de
salida
de
un
router
que
multiplexa
n
flujos
,


estando
cada
uno
de
ellos
controlado
mediante
una
cubeta
con
p√©rdidas
cuyos
par√°metros


son
bi
y
ri
,
i
=
1
,
.
.
.
,
n
,
y
utilizando
la
disciplina
de
planificaci√≥n
WFQ
.
Vamos
a
emplear
el


t√©rmino
flujo
para
hacer
referencia
al
conjunto
de
paquetes
que
el
planificador
no
distingue


entre
s√≠
.
En
la
pr√°ctica
,
un
flujo
puede
comprender
tr√°fico
procedente
de
una
√∫nica
conexi√≥n


terminal
a
terminal
o
de
una
colecci√≥n
de
conexiones
de
este
tipo
(
v√©ase
la
Figura
7.28
)
.


Recuerde
que
con
la
disciplina
WFQ
se
garantiza
que
cada
flujo
i
reciba
una
cuota
del


ancho
de
banda
del
enlace
igual
a
,
como
m√≠nimo
,
R
¬∑
wi/(‚àëwj
)
,
donde
R
es
la
velocidad
de


transmisi√≥n
del
enlace
en
paquetes
/
segundo
.
En
este
caso
,
¬ø
cu√°l
es
el
retardo
m√°ximo
que


experimentar√°
un
paquete
mientras
espera
para
recibir
servicio
en
la
cola
WFQ
(
es
decir
,


despu√©s
de
atravesar
la
cubeta
con
p√©rdidas
)
?
Vamos
a
centrarnos
en
el
flujo
1
.
Supongamos


que
la
cubeta
del
flujo
1
inicialmente
est√°
llena
y
llega
una
r√°faga
de
b1
paquetes
al
contro-


lador
de
la
cubeta
del
flujo
1
.
Estos
paquetes
extraer√°n
todas
las
fichas
(
sin
esperar
)
de
la


cubeta
y
pasar√°n
al
√°rea
de
espera
WFQ
correspondiente
al
flujo
1
.
Puesto
que
estos
b1


paquetes
reciben
servicio
a
una
tasa
como
m√≠nimo
de
R
¬∑
wi
/(‚àëwj
)
paquetes
/
segundo
,
el


626
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


b1


r1


w1


wn


bn


rn


Figura
7.28
‚Ä¢
n
flujos
multiplexados
con
cubetas
con
p√©rdidas


y
planificaci√≥n
WFQ
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
626√∫ltimo
de
estos
paquetes
sufrir√°
un
retardo
m√°ximo
dm√°x
hasta
que
se
complete
su
transmi-


si√≥n
,
donde


La
fundamentaci√≥n
en
que
se
basa
esta
f√≥rmula
es
que
si
hay
b1
paquetes
en
la
cola
y


se
les
est√°
dando
servicio
(
se
les
est√°
eliminando
de
la
cola
)
a
una
tasa
de
como
m√≠nimo
R
¬∑


w1/
(
‚àëwj
)
paquetes
por
segundo
,
entonces
la
cantidad
de
tiempo
transcurrido
hasta
que
el


√∫ltimo
bit
del
√∫ltimo
paquete
es
transmitido
no
puede
ser
mayor
que
b1/(R
¬∑
w1/(‚àëwj
)
)
.
Uno


de
los
problemas
de
repaso
le
pide
que
demuestre
que
siempre
y
cuando
r1
<
R
¬∑
w1/(‚àëwj
)
,


entonces
dm√°x
es
el
retardo
m√°ximo
que
cualquier
paquete
del
flujo
1
experimentar√°
en
la


cola
WFQ
.


7.5.3
Diffserv


El
objetivo
de
la
arquitectura
Diffserv
de
Internet
[
RFC
2475
;
Kilkki
1999
]
es
el
de
propor-


cionar
una
diferenciaci√≥n
de
servicio
,
es
decir
,
la
capacidad
de
manejar
diferentes
‚Äú
clases
‚Äù


de
tr√°fico
de
formas
distintas
dentro
de
Internet
,
y
hacer
esto
de
una
manera
escalable
y
fle-


xible
.
La
necesidad
de
la
escalabilidad
surge
del
hecho
de
que
pueden
existir
centenares
de


miles
de
flujos
simult√°neos
de
tr√°fico
origen-destino
en
un
router
troncal
de
Internet
.
Vere-


mos
a
continuaci√≥n
que
esta
necesidad
se
cubre
incluyendo
solamente
una
simple
funciona-


lidad
dentro
del
n√∫cleo
de
la
red
,
con
m√°s
operaciones
de
control
complejas
implementadas


en
la
frontera
de
la
red
.
La
necesidad
de
la
flexibilidad
se
debe
al
hecho
de
que
pueden
sur-


gir
nuevas
clases
de
servicio
y
quedar
obsoletas
otras
clases
de
servicio
m√°s
antiguas
.
La


arquitectura
Diffserv
es
flexible
en
el
sentido
de
que
no
define
servicios
ni
clases
de
servi-


cios
espec√≠ficos
;
en
lugar
de
ello
,
Diffserv
proporciona
componentes
funcionales
,
es
decir
,


las
piezas
de
una
arquitectura
de
red
con
las
que
pueden
construirse
tales
servicios
.
Exami-


nemos
ahora
estos
componentes
en
detalle
.


Servicios
diferenciados
:
un
escenario
simple


Para
establecer
el
marco
de
trabajo
con
el
fin
de
definir
los
componentes
arquitect√≥nicos
del


modelo
de
servicios
diferenciados
(
Diffserv
)
,
comenzaremos
con
la
sencilla
red
mostrada
en


la
Figura
7.29
.
En
esta
secci√≥n
vamos
a
describir
un
posible
uso
de
los
componentes
de


Diffserv
.
Como
se
describe
en
el
documento
RFC
2475
son
posibles
muchas
otras
variantes
.


Nuestro
objetivo
aqu√≠
es
proporcionar
una
introducci√≥n
a
los
aspectos
clave
de
Diffserv
,
en


lugar
de
describir
el
modelo
arquitect√≥nico
de
forma
exhaustiva
.
Aninamos
a
los
lectores


interesados
en
aprender
m√°s
cosas
acerca
de
Diffserv
a
consultar
el
libro
[
Kilkki
1999
]
.


La
arquitectura
de
los
servicios
diferenciados
consta
de
dos
conjuntos
de
elementos
fun-


cionales
:


‚Ä¢
Funciones
de
frontera
:
clasificaci√≥n
de
paquetes
y
acondicionamiento
del
tr√°fico
.
En
la


frontera
de
entrada
de
la
red
(
es
decir
,
en
cualquier
host
que
soporte
el
modelo
Dif
fserv


que
genere
tr√°fico
o
en
el
primer
router
compatible
con
Dif
fserv
a
trav√©s
del
cual
pase


el
tr√°fico
)
,
se
marcan
los
paquetes
que
llegan
.
M√°s
espec√≠ficamente
,
se
asigna
un
cierto


valor
al
campo
servicio
diferenciado
(
DS
,
Differentiated
Service
)
de
la
cabecera
del


paquete
.
Por
ejemplo
,
en
la
Figura
7.29
los
paquetes
que
est√°n
siendo
transmitidos
de
H1


a
H3
pueden
marcarse
en
R1
,
mientras
que
los
paquetes
que
se
env√≠an
de
H2
a
H4
pue-


d
b


R
wwm√°x


j


=
 
‚àë


1


1
 

7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
627


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
627den
marcarse
en
R2
.
La
marca
que
recibe
un
paquete
identifica
la
clase
de
tr√°fico
a
la
que


pertenece
.
Las
distintas
clases
de
tr√°fico
recibir√°n
entonces
un
servicio
diferente
en
 
la


red
principal
.


‚Ä¢
Funci√≥n
del
n√∫cleo
:
reenv√≠o
.
Cuando
un
paquete
marcado
con
DS
llega
a
un
router
DS
,


el
paquete
es
reenviado
al
siguiente
salto
de
acuerdo
con
el
comportamiento
por
salto


asociado
con
dicha
clase
de
paquete
.
El
comportamiento
por
salto
influye
en
c√≥mo
las


clases
de
tr√°fico
en
competencia
comparten
los
bufferes
de
un
router
y
el
ancho
de
banda


del
enlace
.
Un
principio
fundamental
de
la
arquitectura
Diffserv
es
que
el
comporta-


miento
por
salto
de
un
router
se
basar√°
√∫nicamente
en
las
marcas
de
los
paquetes
,
es


decir
,
en
la
clase
de
tr√°fico
a
la
que
pertenece
el
paquete
.
Por
tanto
,
si
los
paquetes
que
se


est√°n
enviando
de
H1
a
H3
en
la
Figura
7.29
reciben
la
misma
marca
que
los
paquetes


que
est√°n
siendo
enviados
de
H2
a
H4
,
entonces
los
routers
de
la
red
tratan
estos
paque-


tes
como
agregados
sin
distinguir
si
los
paquetes
fueron
originados
en
H1
o
en
H2
.
Por


ejemplo
,
R3
no
diferenciar√°
entre
los
paquetes
de
H1
y
H2
al
reenviarlos
hacia
R4
.


Por
tanto
,
la
arquitectura
de
servicios
diferenciados
obvia
la
necesidad
de
controlar
el


estado
del
router
para
cada
pareja
individual
origen-destino
(
una
consideraci√≥n
impor-


tante
para
cumplir
el
requisito
de
escalabilidad
comentado
al
principio
de
esta
secci√≥n
)
.


En
este
momento
puede
resultarnos
√∫til
comentar
una
analog√≠a
.
En
muchos
actos
socia-


les
a
gran
escala
(
por
ejemplo
,
una
importante
recepci√≥n
p√∫blica
,
una
sala
de
baile
o
una
dis-


coteca
,
un
concierto
o
un
partido
de
f√∫tbol
)
,
las
personas
que
asisten
al
acto
reciben
distintos


tipos
de
entradas
o
pases
:
las
personalidades
reciben
entradas
VIP
;
los
mayores
de
18
a√±os


disponen
de
entradas
de
adulto
(
por
ejemplo
,
en
el
caso
de
que
se
vayan
a
servir
bebidas


alcoh√≥licas
)
;
los
pases
para
estar
entre
bastidores
en
los
conciertos
;
los
pases
de
prensa
para


los
periodistas
,
incluso
un
pase
ordinario
para
las
personas
normales
.
Normalmente
,
estos


diversos
tipos
de
entradas
o
pases
se
distribuyen
a
la
entrada
del
acto
,
es
decir
,
en
la
frontera


628
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


R4


Router
hoja


Clave
:


Router
de
n√∫cleo


R2


R1
R6


R7


R3
R5


H1


H2


H4


H3


R2
R2


Figura
7.29
‚Ä¢
Un
ejemplo
de
red
Diffserv
simple
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
628que
da
paso
al
acto
.
Es
precisamente
en
la
frontera
donde
se
llevan
a
cabo
operaciones
inten-


sivas
de
computaci√≥n
,
tales
como
abonar
una
entrada
,
comprobar
que
el
tipo
de
invitaci√≥n


es
el
apropiado
y
comprobar
que
la
invitaci√≥n
se
corresponde
con
alg√∫n
tipo
de
identifica-


ci√≥n
.
Adem√°s
,
puede
existir
un
l√≠mite
relativo
al
n√∫mero
de
personas
de
un
determinado
tipo


que
pueden
asistir
al
acto
.
Si
existe
tal
l√≠mite
,
es
posible
que
la
gente
tenga
que
esperar
antes


de
entrar
en
el
acto
.
Una
vez
que
se
ha
accedido
al
acto
,
el
pase
permite
que
cada
persona


reciba
un
servicio
diferenciado
en
las
distintas
zonas
en
las
que
tiene
lugar
el
acto
;
por
ejem-


plo
,
un
VIP
puede
obtener
las
bebidas
gratis
,
un
mesa
mejor
,
una
comida
gratuita
,
acceso
a


salas
exclusivas
y
un
servicio
de
atenciones
.
Por
el
contrario
,
una
persona
normal
queda


excluida
de
determinadas
√°reas
,
tendr√°
que
abonar
las
bebidas
y
s√≥lo
recibir√°
un
servicio


b√°sico
.
En
ambos
casos
,
el
servicio
recibido
en
el
acto
depende
√∫nicamente
del
tipo
de
pase


del
que
disponga
la
persona
.
Adem√°s
,
todas
las
personas
pertenecientes
a
una
clase
son
tra-


tadas
de
la
misma
forma
.


Clasificaci√≥n
y
acondicionamiento
del
tr√°fico
de
Diffserv


La
Figura
7.30
proporciona
una
visi√≥n
l√≥gica
de
las
funciones
de
clasificaci√≥n
y
marcado
en


el
router
de
frontera
.
En
primer
lugar
,
los
paquetes
que
llegan
al
router
de
frontera
se
clasifi-


can
.
El
clasificador
selecciona
los
paquetes
bas√°ndose
en
los
valores
de
uno
o
m√°s
campos


de
la
cabecera
del
paquete
(
por
ejemplo
,
direcci√≥n
de
origen
,
direcci√≥n
de
destino
,
puerto
de


origen
,
puerto
de
destino
e
ID
de
protocolo
)
y
dirige
al
paquete
a
la
funci√≥n
de
marcado


apropiada
.
La
marca
de
un
paquete
se
transporta
dentro
del
campo
DS
[
RFC
3260
]
en
la


cabecera
del
paquete
IPv4
o
IPv6
.
La
definici√≥n
del
campo
DS
pretende
sustituir
a
las
defi-


niciones
anteriores
del
campo
Tipo
de
servicio
de
IPv4
y
de
los
campos
de
clase
de
tr√°fico


de
IPv6
que
se
explicaron
en
el
Cap√≠tulo
4
.


En
algunos
casos
,
un
usuario
final
puede
estar
de
acuerdo
en
limitar
su
velocidad
de


transmisi√≥n
de
paquetes
con
el
fin
de
cumplir
un
perfil
declarado
de
tr√°fico
.
El
perfil
de


tr√°fico
puede
contener
un
l√≠mite
para
la
tasa
de
pico
,
as√≠
como
para
el
tama√±o
de
r√°faga
del


flujo
de
paquetes
,
como
hemos
visto
anteriormente
con
el
mecanismo
de
la
cubeta
con
p√©r-


didas
.
A
medida
que
el
usuario
env√≠a
paquetes
a
la
red
cumpliendo
el
perfil
de
tr√°fico
nego-


ciado
,
los
paquetes
reciben
su
marca
de
prioridad
y
son
reenviados
a
trav√©s
de
su
ruta
hasta


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
629


Paquetes
Reenviar


Clasificador
Marcador


Eliminar


Conformador/


Eliminador


Medidor


Figura
7.30
‚Ä¢
Visi√≥n
l√≥gica
de
las
funciones
de
clasificaci√≥n
de
paquetes


y
acondicionamiento
de
tr√°fico
en
el
router
terminal
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
629alcanzar
el
destino
.
Por
el
contrario
,
si
se
viola
el
perfil
de
tr√°fico
,
los
paquetes
que
no
cum-


plen
los
l√≠mites
impuestos
por
dicho
perfil
pueden
marcarse
de
forma
diferente
,
confor-


marse
(
por
ejemplo
,
ser
retardados
de
manera
que
se
observe
una
restricci√≥n
de
tasa


m√°xima
)
,
o
pueden
ser
eliminados
en
la
frontera
de
la
red
.
El
papel
de
la
funci√≥n
de


medida
,
mostrada
en
la
Figura
7.30
,
es
el
de
comparar
el
flujo
de
paquetes
entrantes
con
el


perfil
de
tr√°fico
negociado
y
determinar
si
un
paquete
cumple
dicho
perfil
negociado
.
La


decisi√≥n
real
acerca
de
si
volver
a
marcar
de
forma
inmediata
,
reenviar
,
retardar
o
eliminar


un
paquete
es
una
pol√≠tica
que
debe
establecer
el
administrador
de
la
red
y
no
es
espec√≠fica


de
la
arquitectura
Diffserv
.


Comportamientos
por
salto


Hasta
el
momento
nos
hemos
centrado
en
las
funciones
de
frontera
de
la
arquitectura
Diff-


serv
.
El
segundo
componente
clave
de
la
arquitectura
de
servicios
diferenciados
tiene
que


ver
con
el
comportamiento
por
salto
(
PHB
,
Per-Hop
Behavior
)
de
los
routers
Diffserv
.
El


PHB
se
define
de
manera
cr√≠ptica
como
‚Äú
una
descripci√≥n
del
comportamiento
de
reenv√≠o


observable
externamente
de
un
nodo
Diffserv
aplicado
a
un
agregado
de
comportamiento


Diffserv
particular
‚Äù
[
RFC
2475
]
.
Profundizando
un
poco
en
esta
definici√≥n
,
podemos
ver


que
contiene
varias
consideraciones
importantes
:


‚Ä¢U
n
 
P
H
B
 
p
u
e
d
e
 
d
a
r
 
l
u
g
a
r
 
a
 
q
u
e
 
d
i
f
e
r
e
n
t
e
s
 
c
l
a
s
e
s
 
d
e
 
t
r
√°
f
i
c
o
 
r
e
c
i
b
a
n
 
d
i
s
t
i
n
t
o
s
 
r
e
n
d
i
m
i
e
n
t
o
s


(
es
decir
,
diferentes
comportamientos
de
reenv√≠o
observables
externamente
)
.


‚Ä¢A
u
n
q
u
e
 
u
n
 
P
H
B
 
d
e
f
i
n
e
 
d
i
f
e
r
e
n
t
e
s
 
r
e
n
d
i
m
i
e
n
t
o
s
 
(
c
o
m
p
o
r
t
a
m
i
e
n
t
o
s
)
 
e
n
t
r
e
 
c
l
a
s
e
s
,
 
n
o


obliga
al
uso
de
ning√∫n
mecanismo
concreto
para
conseguir
estos
comportamientos
.


Siempre
y
cuando
se
cumplan
los
criterios
de
rendimiento
observables
externamente
,


puede
aplicarse
cualquier
mecanismo
de
implementaci√≥n
y
cualquier
pol√≠tica
de
asigna-


ci√≥n
de
buffer
/
ancho
de
banda
.
Por
ejemplo
,
un
PHB
no
requiere
que
se
emplee
una
disci-


plina
de
colas
de
paquetes
concreta
(
por
ejemplo
,
una
cola
con
prioridad
,
una
cola
WFQ
o


una
cola
FCFS
)
para
conseguir
un
determinado
comportamiento
.
El
PHB
es
el
fin
y
la
asig-


naci√≥n
de
recursos
y
los
mecanismos
de
implementaci√≥n
son
los
medios
.


‚Ä¢L
a
s
 
d
i
f
e
r
e
n
c
i
a
s
 
e
n
 
e
l
 
r
e
n
d
i
m
i
e
n
t
o
 
d
e
b
e
n
 
s
e
r
 
o
b
s
e
r
v
a
b
l
e
s
 
y
 
p
o
r
 
t
a
n
t
o
 
m
e
n
s
u
r
a
b
l
e
s
.
 

Actualmente
est√°n
definidos
dos
PHB
:
un
PHB
de
reenv√≠o
expedito
(
EF
,
Expedited
For-


warding
)
[
RFC
3246
]
y
un
PHB
de
reenv√≠o
garantizado
(
AF
,
Assured
Forwarding
)
[
RFC


2597
]
.


‚Ä¢E
l
 
P
H
B
 
d
e
 
reenv√≠o
expedito(EF
)
especifica
que
la
tasa
de
salida
de
una
clase
de
tr√°fico


de
un
 
router
tiene
que
ser
igual
o
mayor
que
una
tasa
configurada
.
Es
decir
,
durante
cual-


quier
intervalo
de
tiempo
,
a
la
clase
de
tr√°fico
se
le
garantiza
que
recibir√°
el
suficiente


ancho
de
banda
como
para
que
la
tasa
de
salida
del
tr√°fico
sea
igual
o
mayor
que
la
tasa


m√≠nima
configurada
.
Observe
que
el
comportamiento
por
salto
EF
implica
cierta
forma


de
aislamiento
entre
las
clases
de
tr√°fico
,
ya
que
esta
garant√≠a
se
implementa
indepen-


dientemente
de
la
intensidad
de
tr√°fico
de
cualquier
otra
clase
que
est√©
llegando
a
un
rou-


ter
.
Por
tanto
,
incluso
aunque
las
restantes
clases
de
tr√°fico
est√©n
inundando
el
router
y


los
recursos
del
enlace
,
gran
parte
de
estos
recursos
tienen
que
continuar
estando
dispo-


nibles
para
esa
clase
con
el
fin
de
garantizar
que
recibe
su
garant√≠a
de
tasa
m√≠nima
.
Por


tanto
,
EF
proporciona
una
clase
con
la
simple
abstracci√≥n
de
un
enlace
con
un
ancho
de


banda
m√≠nimo
garantizado
.


630
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
630‚Ä¢E
l
 
P
H
B
 
d
e
 
reenv√≠o
garantizado(AF
)
es
m√°s
complejo
.
El
reenv√≠o
garantizado
divide
el


tr√°fico
en
cuatro
clases
,
y
a
cada
una
de
las
clases
se
le
garantiza
que
recibir√°
cierta
can-


tidad
m√≠nima
de
ancho
de
banda
y
de
buffer
.
Dentro
de
cada
clase
,
los
paquetes
vuelven


a
clasificarse
en
una
de
tres
categor√≠as
de
preferencia
de
eliminaci√≥n
.
Cuando
en
una


clase
AF
se
produce
congesti√≥n
,
un
router
puede
descartar
(
eliminar
)
paquetes
bas√°ndose


en
sus
valores
de
preferencia
de
eliminaci√≥n
.
Si
desea
conocer
m√°s
detalles
,
consulte


[
RFC
2597
]
.
Variando
la
cantidad
de
recursos
asignados
a
cada
clase
,
un
ISP
puede
pro-


porcionar
diferentes
niveles
de
rendimiento
a
las
distintas
clases
de
tr√°fico
AF
.


Retrospectiva
de
los
servicios
diferenciados
 

Durante
los
√∫ltimos
20
a√±os
han
sido
numerosos
los
intentos
(
la
mayor√≠a
de
ellos
sin
√©xito
)


de
introducir
la
calidad
de
servicio
(
QoS
)
en
la
redes
de
conmutaci√≥n
de
paquetes
.
Los
dis-


tintos
intentos
han
fallado
m√°s
por
razones
econ√≥micas
y
de
legado
que
por
cuestiones
t√©c-


nicas
.
Entre
estos
intentos
se
incluyen
las
redes
ATM
terminal
a
terminal
y
las
redes
TCP
/
IP
.


Veamos
brevemente
estos
problemas
en
el
contexto
de
los
servicios
diferenciados
(
los
cua-


les
estudiaremos
en
la
siguiente
secci√≥n
)
.


Hasta
el
momento
hemos
supuesto
impl√≠citamente
que
Diffserv
se
implanta
dentro
de


un
mismo
dominio
administrativo
.
El
caso
m√°s
t√≠pico
es
aquel
en
el
que
un
servicio
terminal


a
terminal
tiene
que
ser
establecido
entre
varios
ISP
que
se
encuentran
entre
los
sistemas
ter-


minales
en
comunicaci√≥n
.
Para
proporcionar
un
servicio
diferenciado
terminal
a
terminal
,


todos
los
ISP
existentes
entre
los
sistemas
terminales
no
s√≥lo
tienen
que
proporcionar
dicho


servicio
,
sino
que
tambi√©n
tienen
que
cooperar
y
establecer
acuerdos
para
ofrecer
al
usuario


final
un
verdadero
servicio
terminal
a
terminal
.
Sin
esta
clase
de
cooperaci√≥n
,
los
ISP
que


venden
directamente
el
servicio
diferenciado
a
los
clientes
tendr√≠an
que
decir
continua-


mente
:
‚Äú
S√≠
,
sabemos
que
usted
ha
pagado
un
extra
,
pero
no
tenemos
un
acuerdo
de
servicio


con
uno
de
nuestros
ISP
de
nivel
superior
.
¬°
Sentimos
que
se
hayan
producido
muchos
hue-


cos
en
su
llamada
V
oIP
!
‚Äù
.


Incluso
dentro
de
un
mismo
dominio
administrativo
,
Diffserv
por
s√≠
solo
no
es
sufi-


ciente
para
proporcionar
garant√≠as
de
calidad
de
servicio
a
una
clase
de
servicio
concreta
.


Diffserv
s√≥lo
permite
que
diferentes
clases
de
tr√°fico
reciban
distintos
niveles
de
rendi-


miento
.
Si
una
red
est√°
extremadamente
infradimensionada
,
incluso
el
tr√°fico
con
prioridad


alta
puede
recibir
un
rendimiento
inaceptable
.
Por
tanto
,
para
ser
efectivos
,
los
servicios


diferenciados
deben
combinarse
con
un
dimensionado
apropiado
de
la
red
(
v√©ase
la
Secci√≥n


7.3.5
)
.
No
obstante
,
los
servicios
diferenciados
pueden
sacar
un
mayor
partido
de
la
inver-


si√≥n
del
ISP
en
la
capacidad
de
la
red
.
Haciendo
que
los
recursos
est√©n
disponibles
para
las


clases
de
tr√°fico
con
prioridad
alta
(
y
que
pagan
m√°s
)
cuando
los
necesiten
(
a
expensas
de


las
clases
de
tr√°fico
con
prioridad
inferior
)
,
el
ISP
puede
proporcionar
un
nivel
alto
de
rendi-


miento
a
estas
clases
de
prioridad
alta
.
Cuando
las
clases
con
prioridad
alta
ya
no
necesitan


estos
recursos
,
entonces
podr√°n
utilizarlos
las
clases
de
tr√°fico
con
prioridad
inferior
(
que


presumiblemente
habr√°n
pagado
menos
por
esta
clase
de
servicio
)
.


Otro
problema
con
estos
servicios
avanzados
es
la
necesidad
de
vigilar
y
,
posiblemente
,


conformar
el
tr√°fico
,
lo
que
puede
resultar
complejo
y
costoso
.
Tambi√©n
es
necesario
factu-


rar
los
servicios
de
manera
diferente
(
muy
probablemente
por
volumen
en
lugar
de
como


hacen
actualmente
la
mayor√≠a
de
los
ISP
,
que
cobran
una
tarifa
mensual
fija
)
,
otro
requisito


costoso
para
el
ISP
.
Por
√∫ltimo
,
si
los
servicios
diferenciados
estuvieran
realmente
imple-


mentados
y
la
red
operara
con
una
carga
s√≥lo
moderada
,
la
mayor
parte
del
tiempo
no
se
per-


7.5
‚Ä¢
M√öLTIPLES
CLASES
DE
SERVICIOS
631


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
631cibir√≠a
una
diferencia
entre
un
servicio
de
mejor
esfuerzo
y
un
servicio
diferenciado
.
De


hecho
,
actualmente
,
el
retardo
terminal
a
terminal
normalmente
se
controla
mediante
las


velocidades
de
acceso
y
los
saltos
de
router
,
en
lugar
de
mediante
los
retardos
de
cola
en
los


routers
.
Imagine
al
infeliz
cliente
de
un
servicio
diferenciado
que
ha
pagado
por
un
servicio


premium
,
s√≥lo
para
descubrir
que
el
servicio
de
mejor
esfuerzo
que
se
est√°
proporcionando


a
otros
clientes
tiene
casi
siempre
el
mismo
rendimiento
que
el
servicio
premium
.


7.6
Garant√≠as
de
calidad
de
servicio


En
la
secci√≥n
anterior
hemos
visto
que
el
marcado
y
la
vigilancia
de
paquetes
,
el
aislamiento


del
tr√°fico
y
la
planificaci√≥n
en
el
nivel
de
enlace
pueden
proporcionar
una
clase
de
servicio


con
mejor
rendimiento
que
otra
.
Con
ciertas
disciplinas
de
planificaci√≥n
,
como
la
planifica-


ci√≥n
con
prioridad
,
las
clases
de
tr√°fico
inferiores
son
pr√°cticamente
‚Äú
invisibles
‚Äù
para
la


clase
de
tr√°fico
con
prioridad
m√°s
alta
.
Con
un
dimensionamiento
apropiado
de
la
red
,


la
clase
de
servicio
de
m√°s
alta
prioridad
puede
,
de
hecho
,
conseguir
tasas
de
p√©rdida
de


paquetes
y
retardos
extremadamente
bajos
,
con
un
rendimiento
esencialmente
id√©ntico
a
las


redes
de
conmutaci√≥n
de
circuitos
.
¬ø
Pero
puede
la
red
garantizar
que
un
flujo
activo
perte-


neciente
a
una
clase
de
tr√°fico
de
alta
prioridad
continuar√°
recibiendo
dicho
servicio
mien-


tras
dure
el
flujo
,
utilizando
√∫nicamente
los
mecanismos
que
hemos
descrito
hasta
el


momento
?
En
realidad
no
.
En
esta
secci√≥n
veremos
por
qu√©
hacen
falta
otros
mecanismos


de
red
y
protocolos
adicionales
para
proporcionar
garant√≠as
de
calidad
de
servicio
.


7.6.1
Ejemplo
explicativo


Vo
l
v
a
m
o
s
 
a
 
n
u
e
s
t
r
o
 
e
s
c
e
n
a
r
i
o
 
d
e
 
l
a
 
S
e
c
c
i
√≥
n
 
7
.
5
.
1
 
y
 
c
o
n
s
i
d
e
r
e
m
o
s
 
l
a
s
 
d
o
s
 
a
p
l
i
c
a
c
i
o
n
e
s
 
d
e


audio
a
1
Mbps
que
transmiten
sus
paquetes
a
trav√©s
del
enlace
de
1,5
Mbps
,
como
se
mues-


tra
en
la
Figura
7.31
.
La
velocidad
combinada
de
datos
de
los
dos
flujos
(
2
Mbps
)
excede
la


capacidad
del
enlace
.
Incluso
utilizando
los
mecanismos
de
clasificaci√≥n
y
marcado
,
el
ais-


lamiento
de
flujos
y
la
compartici√≥n
del
ancho
de
banda
no
utilizado
(
que
en
realidad
es


igual
a
cero
)
es
obvio
que
no
podemos
alcanzar
nuestro
objetivo
.
Simplemente
,
no
existe
el


suficiente
ancho
de
banda
como
para
satisfacer
las
necesidades
de
ambas
aplicaciones
al


mismo
tiempo
.
Si
las
dos
aplicaciones
comparten
equitativamente
el
ancho
de
banda
,
cada


una
de
ellas
s√≥lo
podr√°
emplear
0,75
Mbps
.
Examinando
las
cosas
desde
otro
punto
de
vista
,


cada
aplicaci√≥n
perder√≠a
el
25
por
ciento
de
sus
paquetes
transmitidos
.
√âsta
es
una
calidad


de
servicio
tan
inaceptablemente
baja
que
ambas
aplicaciones
de
audio
ser√°n
completamente


inutilizables
;
de
hecho
,
ni
siquiera
merece
la
pena
transmitir
ning√∫n
paquete
de
audio
.


Dado
que
no
se
puede
satisfacer
simult√°neamente
a
las
dos
aplicaciones
de
la
Figura


7.31
,
¬ø
qu√©
deber√≠a
hacer
la
red
?
Permitir
que
ambas
contin√∫en
con
una
QoS
inaceptable


implica
desperdiciar
los
recursos
de
la
red
en
una
serie
de
flujos
de
aplicaci√≥n
que
,
en
√∫ltimo


extremo
,
no
tienen
ninguna
utilidad
para
el
usuario
final
.
La
respuesta
es
bastante
simple
:


habr√°
que
bloquear
uno
de
los
flujos
de
aplicaci√≥n
(
es
decir
,
denegarle
el
acceso
a
la
red
)


mientras
que
se
permite
al
otro
continuar
utilizando
el
1
Mbps
completo
que
la
aplicaci√≥n


necesita
.
La
red
telef√≥nica
ser√≠a
un
ejemplo
de
red
en
la
que
se
efect√∫a
ese
tipo
de
bloqueo


de
llamadas
:
si
no
se
pueden
asignar
a
la
llamada
los
recursos
requeridos
(
un
circuito
termi-


nal
a
terminal
en
el
caso
de
la
red
telef√≥nica
)
,
se
bloquea
la
llamada
(
se
la
impide
cursarse
a


trav√©s
de
la
red
)
y
se
devuelve
una
se√±al
de
ocupado
al
usuario
.
En
nuestro
ejemplo
,
no
se


632
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
632gana
nada
permitiendo
que
un
flujo
entre
en
la
red
si
no
va
a
recibir
una
QoS
suficiente


como
para
poder
considerarlo
utilizable
.
De
hecho
,
existe
un
coste
asociado
a
la
admisi√≥n


de
un
flujo
que
no
vaya
a
recibir
su
QoS
necesaria
,
ya
que
se
estar√°n
empleando
recursos
de


la
red
para
dar
soporte
a
un
flujo
que
no
tiene
ninguna
utilidad
para
el
usuario
final
.


Admitiendo
o
bloqueando
expl√≠citamente
los
flujos
,
bas√°ndose
en
sus
requisitos
de


recursos
y
en
los
requisitos
de
los
flujos
ya
admitidos
,
la
red
puede
garantizar
que
los
flujos


admitidos
podr√°n
recibir
la
QoS
solicitada
.
Junto
a
la
necesidad
de
proporcionar
una
QoS


garantizada
a
un
cierto
flujo
est√°
impl√≠cita
la
necesidad
de
que
ese
flujo
declare
sus
requisi-


tos
de
QoS.
Este
proceso
de
hacer
que
un
flujo
declare
sus
requisitos
de
QoS
y
que
luego
la


red
acepte
el
flujo
(
con
la
QoS
requerida
)
o
le
bloquee
se
denomina
proceso
de
admisi√≥n


de
llamada
.
√âste
es
,
por
tanto
,
el
cuarto
de
los
principios
fundamentales
(
de
los
otros


tres
hemos
hablado
en
la
Secci√≥n
7.5.1
)
de
los
mecanismos
necesarios
para
proporcionar


calidad
de
servicio
(
QoS
)
.


Principio
4
:
si
los
recursos
suficientes
no
siempre
van
a
estar
disponibles
y
es
necesa-


rio
garantizar
la
calidad
de
servicio
,
se
necesita
un
proceso
de
admisi√≥n
de
llamadas
en


el
que
los
flujos
declaren
sus
requisitos
de
QoS
y
o
bien
los
admita
en
la
red
(
con
la
QoS


requerida
)
o
bloquee
(
si
la
red
no
puede
proporcionar
la
QoS
requerida
)
.


7.6.2
Reserva
de
recursos
,
admisi√≥n
de
llamadas
,


establecimiento
de
llamadas


Nuestro
ejemplo
introductorio
resalta
la
necesidad
de
diversos
nuevos
mecanismos
y
proto-


colos
de
red
,
para
el
caso
en
que
haya
que
garantizar
a
una
llamada
(
a
un
flujo
terminal
a


terminal
)
una
determinada
calidad
de
servicio
una
vez
que
la
llamada
se
ha
establecido
:


‚Ä¢
Reserva
de
recursos
.
La
√∫nica
forma
de
garantizar
que
una
llamada
dispondr√°
de
los


recursos
(
ancho
de
banda
de
enlace
,
buffers
)
necesarios
para
obtener
su
calidad
de
servi-


cio
deseada
consiste
en
asignar
expl√≠citamente
dichos
recursos
a
esa
llamada
;
a
este
pro-


ceso
se
le
conoce
en
la
jerga
del
mundo
de
las
redes
con
el
nombre
de
reserva
de


recursos
.
Una
vez
reservados
los
recursos
,
la
llamada
podr√°
,
mientras
dure
,
acceder
bajo


7.6
‚Ä¢
GARANT√çAS
DE
CALIDAD
DE
SERVICIO
633


R1


Enlace
a
1,5
Mbps


Audio


1
Mbps


Audio


1
Mbps


R2


H2


H1


H4


H3


Figura
7.31
‚Ä¢
Dos
aplicaciones
de
audio
competidoras
sobrecargan
el
enlace


de
R1a
R2
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
633demanda
a
dichos
recursos
,
independientemente
de
las
demandas
de
todas
las
restantes


llamadas
.
Si
una
llamada
reserva
y
recibe
una
garant√≠a
de
x
Mbps
de
ancho
de
banda
de


enlace
y
nunca
transmite
a
una
velocidad
superior
a
x
podr√°
disfrutar
de
unas
comunica-


ciones
sin
p√©rdidas
y
sin
retardos
.


‚Ä¢
Admisi√≥n
de
llamadas
.
Si
hay
que
reservar
recursos
,
entonces
la
red
tiene
que
disponer


de
un
mecanismo
para
que
las
llamadas
puedan
solicitar
y
reservar
los
recursos
;
este
pro-


ceso
se
conoce
con
el
nombre
de
proceso
de
admisi√≥n
de
llamadas
.
Dado
que
los
recur-


sos
no
son
infinitos
,
cuando
una
llamada
realiza
una
solicitud
de
admisi√≥n
de
llamada


esa
admisi√≥n
ser√°
denegada
(
es
decir
,
la
llamada
ser√°
bloqueada
)
si
no
est√°n
disponibles


los
recursos
solicitados
.
Este
tipo
de
admisi√≥n
de
llamadas
es
realizado
por
las
redes


telef√≥nicas
,
en
las
que
solicitamos
los
recursos
en
el
momento
de
marcar
un
n√∫mero
.
Si


est√°n
disponibles
los
circuitos
(
particiones
TDMA
)
necesarios
para
completar
la
lla-


mada
,
se
asignar√°n
los
circuitos
y
la
llamada
podr√°
completarse
.
Si
los
circuitos
no
est√°n


disponibles
,
entonces
se
bloquear√°
la
llamada
y
recibiremos
la
se√±al
de
ocupado
.
Una


llamada
bloqueada
puede
volver
a
intentar
que
la
admitan
en
la
red
,
pero
no
se
le
permi-


tir√°
enviar
tr√°fico
hacia
la
red
hasta
que
haya
completado
el
proceso
de
admisi√≥n
de
lla-


mada
.


Por
supuesto
,
al
igual
que
el
gestor
del
restaurante
de
la
Secci√≥n
1.3.1
no
deber√≠a
aceptar


reservas
para
m√°s
mesas
que
las
que
el
restaurante
tiene
,
un
router
que
realiza
asignacio-


nes
del
ancho
de
banda
del
enlace
no
debe
asignar
m√°s
ancho
de
banda
del
que
est√©
dis-


ponible
en
dicho
enlace
.
Normalmente
una
llamada
s√≥lo
podr√°
reservar
una
fracci√≥n
del


ancho
de
banda
del
enlace
,
por
lo
que
el
router
puede
asignar
ancho
de
banda
del
enlace


a
m√°s
de
una
llamada
.
Sin
embargo
,
la
suma
del
ancho
de
banda
asignado
a
todas
las
lla-


madas
debe
ser
inferior
a
la
capacidad
del
enlace
.


‚Ä¢
Se√±alizaci√≥n
del
establecimiento
de
llamada
.
El
proceso
de
admisi√≥n
de
llamadas
des-


crito
m√°s
arriba
requiere
que
las
llamadas
sean
capaces
de
reservar
los
recursos
suficien-


tes
en
cada
uno
de
los
routers
que
formen
parte
de
la
ruta
entre
el
origen
y
el
destino
,
con


el
fin
de
asegurarse
de
satisfacer
sus
requisitos
de
QoS
terminal
a
terminal
.
Cada
router


deber√°
determinar
los
recursos
locales
requeridos
por
la
sesi√≥n
,
tener
en
cuenta
la
canti-


dad
de
recursos
que
ya
han
sido
comprometidos
con
otras
sesiones
activas
y
determinar


si
dispone
de
los
suficientes
recursos
como
para
satisfacer
los
requisitos
de
QoS
por
salto


que
esa
sesi√≥n
tiene
en
dicho
router
,
sin
violar
las
garant√≠as
de
QoS
locales
que
ya
se


hayan
concedido
a
otras
sesiones
ya
admitidas
.
Hace
falta
un
protocolo
de
se√±alizaci√≥n


para
coordinar
estas
diversas
actividades
:
la
asignaci√≥n
de
recursos
locales
en
cada
salto
,


as√≠
como
la
decisi√≥n
global
terminal
a
terminal
de
si
la
llamada
ha
sido
o
no
capaz
de


reservar
los
recursos
suficientes
en
cada
uno
de
los
routers
de
la
ruta
terminal
a
terminal
.


√âste
es
el
trabajo
del
protocolo
de
establecimiento
de
llamada
.


En
la
Figura
7.32
se
describe
el
proceso
de
establecimiento
de
llamada
.
Consideremos
ahora


con
m√°s
detalle
los
pasos
implicados
en
un
proceso
de
admisi√≥n
de
llamada
:


1
.
Caracterizaci√≥n
del
tr√°fico
y
especificaci√≥n
de
la
calidad
de
servicio
deseada
.
Para
que


un
router
pueda
determinar
si
sus
recursos
son
suficientes
o
no
para
satisfacer
los
requi-


sitos
QoS
de
una
llamada
,
dicha
llamada
debe
declarar
en
primer
lugar
sus
requisitos


QoS
,
as√≠
como
caracterizar
el
tr√°fico
que
va
a
enviar
a
la
red
y
para
el
que
est√°
solici-


tando
una
garant√≠a
de
QoS.
En
la
arquitectura
Intserv
de
Internet
,
la
especificaci√≥n


Rspec
(
donde
la
letra
R
hace
referencia
al
t√©rmino
reserva
)
[
RFC
2215
]
define
la
QoS


634
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
634espec√≠fica
que
una
llamada
est√°
solicitando
;
la
especificaci√≥n
denomina
Tspec
(
donde


la
letra
T
hace
referencia
al
t√©rmino
tr√°fico
)
[
RFC
2210
]
caracteriza
el
tr√°fico
que
el


emisor
va
a
enviar
hacia
la
red
o
que
el
receptor
va
a
recibir
de
la
red
,
respectivamente
.


La
forma
espec√≠fica
de
Rspec
y
Tspec
variar√°
dependiendo
del
servicio
solicitado
,
como


se
explica
m√°s
adelante
.
En
las
redes
ATM
,
los
elementos
de
informaci√≥n
referentes
a
la


descripci√≥n
del
tr√°fico
de
usuario
y
al
par√°metro
QoS
transportan
informaci√≥n
con
pro-


p√≥sitos
similares
a
las
especificaciones
Tspec
y
Rspec
,
respectivamente
.


2
.
Se√±alizaci√≥n
para
el
establecimiento
de
llamada
.
Es
necesario
transportar
hasta
los
rou-


ters
en
los
que
se
van
a
reservar
los
recursos
para
la
llamada
un
descriptor
de
tr√°fico
de


la
llamada
y
una
solicitud
de
QoS.
En
Internet
,
dentro
de
la
arquitectura
Intserv
,
se
uti-


liza
para
este
prop√≥sito
el
protocolo
RSVP
[
RFC
2210
]
.
En
las
redes
ATM
,
el
protocolo


Q2931b
transporta
esta
informaci√≥n
entre
los
conmutadores
de
la
red
ATM
y
un
punto


terminal
.


7.6
‚Ä¢
GARANT√çAS
DE
CALIDAD
DE
SERVICIO
635


Establecimiento
de
se√±alizaci√≥n
de
llamada
QoS


Solicitud
/
respuesta


Figura
7.32
‚Ä¢
Proceso
de
establecimiento
de
llamada
.


1


2


Establecimiento
de


se√±alizaci√≥n
de
llamada
QoS


Solicitud
:
especificar


tr√°fico
(
Tspec
)
,


garant√≠a
(
Rspec
)


Respuesta
:
si
la


solicitud
puede
o


no
ser
satisfecha


El
elemento
considera


los
recursos
requeridos


y
los
recursos
no
reservados


3


Figura
7.33
‚Ä¢
Comportamiento
de
cada
elemento
con
respecto
a
la
llamada
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
635636
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


EL
PRINCIPIO
DEL
ESTADO
FR√ÅGIL


RSVP
se
utiliza
para
instalar
el
estado
(
reservas
de
ancho
de
banda
)
en
los
routers
y
se
dice
de
√©l


que
es
un
protocolo
de
estado
fr√°gil
(
soft-state
)
.
En
t√©rminos
generales
,
asociamos
el
t√©rmino
estado


fr√°gil
con
aquellas
t√©cnicas
de
se√±alizaci√≥n
en
las
que
el
estado
instalado
caduca
(
y
es
eliminado
)
,


a
menos
que
sea
refrescado
peri√≥dicamente
mediante
la
recepci√≥n
de
un
mensaje
de
se√±alizaci√≥n


(
normalmente
enviado
por
la
entidad
que
instal√≥
inicialmente
el
estado
)
que
indique
que
el
estado


debe
permanecer
instalado
.
Puesto
que
un
estado
no
refrescado
terminar√°
por
caducar
,
la
se√±ali-


zaci√≥n
de
estado
fr√°gil
no
requiere
ni
una
eliminaci√≥n
expl√≠cita
del
estado
,
ni
un
procedimiento


para
eliminar
los
estados
hu√©rfanos
en
caso
de
que
fallara
el
instalador
de
estados
.
De
forma
simi-


lar
,
puesto
que
la
instalaci√≥n
del
estado
y
los
mensajes
de
refresco
ser√°n
seguidos
por
sucesivos


mensajes
de
refresco
peri√≥dicos
,
no
hace
falta
que
la
se√±alizaci√≥n
sea
fiable
.
El
t√©rmino
estado
fr√°-


gil
fue
acu√±ado
por
Clark
[
Clark
1988
]
,
quien
describi√≥
la
noci√≥n
de
mensajes
peri√≥dicos
de


refresco
del
estado
enviados
por
un
sistema
terminal
y
sugiri√≥
que
,
con
dichos
mensajes
de
refres-


co
,
el
estado
podr√≠a
perderse
en
caso
de
fallo
y
luego
ser
restaurado
autom√°ticamente
mediante


los
mensajes
de
refresco
subsiguientes
,
todo
ello
de
forma
transparente
para
el
sistema
terminal
y


sin
invocar
ning√∫n
procedimiento
expl√≠cito
de
recuperaci√≥n
de
fallos
:


‚Äù
.
.
.
la
informaci√≥n
de
estado
no
ser√≠a
cr√≠tica
a
la
hora
de
mantener
el
tipo
deseado
de


servicio
asociado
con
el
flujo
.
En
lugar
de
ello
,
ese
tipo
de
servicio
ser√≠a
impuesto
por
los


puntos
terminales
,
que
enviar√≠an
mensajes
peri√≥dicamente
para
garantizar
que
se
asocie


con
el
flujo
el
tipo
de
servicio
apropiado
.
De
esta
forma
,
la
informaci√≥n
de
estado
asocia-


da
con
el
flujo
podr√≠a
perderse
como
consecuencia
de
fallo
,
sin
que
ello
provocara
una


interrupci√≥n
permanente
de
las
caracter√≠sticas
de
servicio
que
se
est√©n
utilizando
.
Yo
llamo


a
este
concepto
‚Äú
estado
fr√°gil
‚Äù
y
puede
que
dicho
concepto
nos
permita
conseguir
nuestros


objetivos
principales
de
supervivencia
y
flexibilidad
.
.
.
‚Äù


Simplificando
,
la
esencia
de
una
t√©cnica
basada
en
estado
fr√°gil
consiste
en
que
el
instalador


del
estado
utilice
un
procedimiento
peri√≥dico
de
instalaci√≥n
/
refresco
del
estado
basado
en
el


mejor
esfuerzo
y
otro
procedimiento
de
eliminaci√≥n
del
estado
por
caducidad
en
el
dispositivo


donde
ese
estado
se
almacene
.
Las
t√©cnicas
de
estado
fr√°gil
han
sido
adoptadas
en
numerosos


protocolos
,
incluyendo
RSVP
,
PIM
(
Secci√≥n
4.7
)
,
SIP
(
Secci√≥n
7.4.3
)
e
IGMP
(
Secci√≥n
4.7
)
,
as√≠


como
en
las
tablas
de
reenv√≠o
de
puentes
transparentes
(
Secci√≥n
5.6
)
.


La
se√±alizaci√≥n
de
estado
firme
(
hard-state
)
utiliza
la
t√©cnica
inversa
a
la
del
estado
fr√°gil
:
el


estado
instalado
continuar√°
instalado
hasta
que
sea
expl√≠citamente
eliminado
por
el
receptor
de


un
mensaje
de
eliminaci√≥n
del
estado
enviado
por
el
instalador
del
estado
.
Puesto
que
el
estado


contin√∫a
instalado
hasta
que
sea
expl√≠citamente
eliminado
,
la
se√±alizaci√≥n
de
estado
firme
requie-


re
un
mecanismo
para
eliminar
los
estados
hu√©rfanos
que
hayan
quedado
despu√©s
de
que
falle
el


instalador
de
estado
o
despu√©s
de
que
√©ste
haya
terminado
su
ejecuci√≥n
sin
eliminar
alg√∫n
estado
.


De
forma
similar
,
dado
que
la
instalaci√≥n
y
la
eliminaci√≥n
del
estado
s√≥lo
se
llevan
a
cabo
una
vez


(
sin
refrescos
ni
caducidad
del
estado
)
,
es
importante
para
el
instalador
del
estado
conocer
cu√°ndo


ha
sido
instalado
o
eliminado
dicho
estado
.
Como
consecuencia
,
con
las
t√©cnicas
de
estado
firme


suelen
asociarse
protocolos
de
se√±alizaci√≥n
fiables
(
en
lugar
de
basados
en
el
mejor
esfuerzo
)
.
Por


tanto
,
y
por
simplificar
nuestro
an√°lisis
,
la
esencia
de
una
t√©cnica
de
estado
firme
consiste
en
la
ins-


talaci√≥n
y
eliminaci√≥n
fiables
y
expl√≠citas
de
la
informaci√≥n
de
estado
.
Las
t√©cnicas
de
estado
firme


PR√ÅCTICA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
6363
.
Admisi√≥n
de
llamadas
en
cada
elemento
.
Una
vez
que
un
router
recibe
la
especificaci√≥n


de
tr√°fico
y
el
par√°metro
QoS
,
debe
determinar
si
puede
o
no
admitir
la
llamada
.
Esta


decisi√≥n
sobre
la
admisi√≥n
de
la
llamada
depender√°
de
la
especificaci√≥n
de
tr√°fico
,
del


tipo
de
servicio
solicitado
y
de
los
compromisos
de
recursos
existentes
que
el
router


haya
aceptado
para
las
llamadas
que
ya
est√°n
activas
.
Recuerde
que
hemos
visto
,
por


ejemplo
en
la
Secci√≥n
7.5.3
,
c√≥mo
puede
utilizarse
la
combinaci√≥n
de
un
origen
contro-


lado
mediante
una
cubeta
con
p√©rdidas
y
WFQ
para
determinar
el
retardo
m√°ximo
de


puesta
en
cola
en
dicho
origen
.
En
la
Figura
7.33
se
ilustra
el
proceso
de
admisi√≥n


de
una
llamada
en
un
cierto
elemento
.


Consulte
[
Breslau
2000
;
Roberts
2004
]
para
ver
m√°s
detalles
acerca
del
proceso
de


admisi√≥n
y
establecimiento
de
llamadas
.


7.6.3
QoS
garantizada
en
Internet
:
Intserv
y
RSVP


La
arquitectura
de
servicios
integrados
(
Intserv
)
es
un
marco
de
trabajo
desarrollado
por
el


IETF
para
proporcionar
garant√≠as
QoS
individualizadas
a
cada
sesi√≥n
de
aplicaci√≥n
indivi-


dual
en
Internet
.
La
especificaci√≥n
de
servicio
garantizado
en
Intserv
,
definida
en
[
RFC


2212
]
,
proporciona
cotas
firmes
(
matem√°ticamente
demostrables
)
para
los
retardos
de


puesta
en
cola
que
un
paquete
puede
experimentar
en
un
router
.
Aunque
los
detalles
subya-


centes
al
servicio
garantizado
son
bastante
complicados
,
la
idea
b√°sica
es
,
en
realidad
,
muy


simple
.
En
una
primera
aproximaci√≥n
,
se
proporciona
una
caracterizaci√≥n
del
tr√°fico
de
un


cierto
origen
mediante
un
mecanismo
de
cubeta
con
p√©rdidas
(
v√©ase
la
Secci√≥n
7.5.2
)
con


par√°metros
 
(
r
,
b
)
y
el
servicio
solicitado
se
caracteriza
mediante
la
velocidad
de
transmi-


si√≥n
,
R
,
a
la
que
se
enviar√°n
los
paquetes
.
En
esencia
,
una
llamada
que
est√©
solicitando
un


servicio
garantizado
estar√°
pidiendo
que
se
garantice
a
los
bits
de
sus
paquetes
una
veloci-


dad
de
reenv√≠o
de
 
R
bits
/
segundo
.
Dado
que
el
tr√°fico
se
especifica
mediante
una
caracteri-


zaci√≥n
basada
en
el
mecanismo
de
la
cubeta
con
p√©rdidas
y
dado
que
se
est√°
solicitando
una


velocidad
garantizada
R
,
tambi√©n
es
posible
acotar
el
retardo
m√°ximo
de
puesta
en
cola
en


el
router
.
Recuerde
que
,
con
una
caracterizaci√≥n
del
tr√°fico
mediante
la
cubeta
con
p√©rdidas
,


la
cantidad
de
tr√°fico
(
en
bits
)
generada
en
cualquier
intervalo
de
duraci√≥n
t
est√°
acotada
por


la
expresi√≥n
rt
+
b.
Recuerde
tambi√©n
de
la
Secci√≥n
7.5.2
que
cuando
se
conecta
un
origen


con
cubeta
con
p√©rdidas
a
una
cola
que
garantiza
que
se
dar√°
servicio
al
tr√°fico
a
una
veloci-


dad
no
inferior
a
R
bits
por
segundo
,
el
retardo
m√°ximo
de
puesta
en
cola
experimentado
por


cualquier
paquete
estar√°
acotado
por
la
expresi√≥n
b
/
R
,
siempre
y
cuando
R
sea
mayor
que
r.


Tambi√©n
se
ha
definido
una
segunda
forma
de
garant√≠a
de
servicio
Intserv
,
conocida
como


7.6
‚Ä¢
GARANT√çAS
DE
CALIDAD
DE
SERVICIO
637


se
han
adoptado
en
protocolos
tales
como
ST-II
[
Partridge
1992
,
RFC
1190
]
y
Q.2931
[
ITU-T


Q.2931
1994
]
.


RSVP
ha
proporcionado
desde
su
concepci√≥n
un
mecanismo
para
la
eliminaci√≥n
expl√≠cita


(
aunque
opcional
)
de
las
reservas
.


La
se√±alizaci√≥n
fiable
basada
en
mensajes
de
reconocimiento
ACK
fue
introducida
como


extensi√≥n
de
RSVP
en
[
RFC
2961
]
y
tambi√©n
fue
sugerida
en
[
Pan
1997
]
.
RSVP
ha
adoptado


opcionalmente
,
por
tanto
,
algunos
elementos
de
las
t√©cnicas
de
se√±alizaci√≥n
de
estado
firme
.


Consulte
[
Ji
2003
]
para
ver
un
an√°lisis
y
una
comparativa
de
los
protocolos
de
estado
fr√°gil
y


de
estado
firme
.
 

M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
637servicio
de
carga
controlada
,
que
especifica
que
una
llamada
recibir√°
 
una
‚Äú
calidad
de
servi-


cio
que
se
aproximar√°
grandemente
a
la
QoS
que
ese
mismo
flujo
recibir√≠a
de
un
elemento


de
red
no
cargado
‚Äù
[
RFC
2211
]
.


El
Protocolo
de
reserva
de
recursos
(
RSVP
,
Resource
ReSerVation
Protocol
)
[
RFC


2205
;
Zhang
1993
]
es
un
protocolo
de
se√±alizaci√≥n
de
Internet
que
podr√≠a
utilizarse
para
lle-


var
a
cabo
la
se√±alizaci√≥n
de
establecimiento
de
llamada
que
Intserv
necesita
.
RSVP
tam-


bi√©n
se
ha
utilizado
junto
con
Diffserv
para
coordinar
funciones
de
servicios
diferenciados


entre
m√∫ltiples
redes
,
y
tambi√©n
ha
sido
ampliada
y
utilizada
como
protocolo
de
se√±aliza-


ci√≥n
en
otras
circunstancias
,
entre
las
que
cabe
destacar
la
variante
RSVP-TE
[
RFC
3209
]


para
se√±alizaci√≥n
MPLS
,
como
se
ha
visto
en
la
Secci√≥n
5.8.2
.


En
un
contexto
Intserv
,
el
protocolo
RSVP
permite
a
las
aplicaciones
reservar
ancho
de


banda
para
sus
flujos
de
datos
.
El
protocolo
es
empleado
por
un
host
,
por
cuenta
de
un
flujo


de
datos
de
aplicaci√≥n
,
con
el
fin
de
solicitar
una
cantidad
espec√≠fica
de
ancho
de
banda
de


la
red
.
RSVP
tambi√©n
es
utilizado
por
los
routers
para
reenviar
las
solicitudes
de
reserva


de
ancho
de
banda
.
Para
implementar
RSVP
es
necesario
que
el
software
RSVP
est√©
pre-


sente
en
los
receptores
,
los
emisores
y
en
los
routers
situados
a
lo
largo
de
la
ruta
terminal
a


terminal
mostrada
en
la
Figura
7.32
.
Las
caracter√≠sticas
principales
de
RSVP
son
:


‚Ä¢P
r
o
p
o
r
c
i
o
n
a
 
reservas
de
ancho
de
banda
en
√°rboles
de
multidifusi√≥n
,
gestion√°ndose


la
unidifusi√≥n
como
un
caso
degenerado
de
multidifusi√≥n
.
Esto
es
particularmente
impor-


tante
para
las
aplicaciones
multimedia
,
tales
como
los
flujos
de
televisi√≥n
sobre
IP
,
en
los


que
muchos
receptores
pueden
querer
recibir
el
mismo
tr√°fico
multimedia
que
se
est√°


enviando
desde
un
√∫nico
origen
.


‚Ä¢E
s
 
orientado
al
receptor
;
es
decir
,
el
receptor
de
un
flujo
de
datos
se
encarga
de
iniciar


y
mantener
la
reserva
de
recursos
utilizada
para
dicho
flujo
.
Esta
visi√≥n
innovadora
,
cen-


trada
en
el
receptor
de
RSVP
,
asigna
a
los
receptores
el
control
del
tr√°fico
que
reciben
,


permitiendo
por
ejemplo
que
distintos
receptores
reciban
y
visualicen
una
multidifusi√≥n


multimedia
a
diferentes
resoluciones
.
Esto
contrasta
bastante
con
la
visi√≥n
centrada
en
el


emisor
de
la
se√±alizaci√≥n
adoptada
en
el
protocolo
Q2931b
de
ATM
.


El
est√°ndar
RSVP
[
RFC
2205
]
no
especifica
c√≥mo
la
red
debe
proporcionar
el
ancho
de


banda
reservado
a
los
flujos
de
datos
.
Se
trata
meramente
de
un
protocolo
que
permite
a
las


aplicaciones
reservar
el
ancho
de
banda
de
enlace
necesario
.
Una
vez
hechas
las
reservas
,


es
tarea
de
los
routers
de
Internet
proporcionar
ese
ancho
de
banda
reservado
a
los
distintos


flujos
de
datos
.
Estas
asignaciones
probablemente
se
hagan
utilizando
los
mecanismos
de


vigilancia
y
planificaci√≥n
(
cubeta
con
p√©rdidas
,
planificaci√≥n
con
prioridades
,
colas
equita-


tivas
ponderadas
)
analizados
en
la
Secci√≥n
7.5
.
Para
obtener
m√°s
informaci√≥n
acerca
de


RSVP
,
consulte
[
RFC
2205
;
Zhang
1993
]
y
los
materiales
electr√≥nicos
en
l√≠nea
adicionales


asociados
con
este
libro
.


7.7
Resumen


El
campo
de
las
redes
multimedia
constituye
uno
de
los
desarrollos
m√°s
atractivos
(
y
que


todav√≠a
no
han
terminado
de
materializarse
)
en
la
red
Internet
actual
.
Las
personas
est√°n
en


todo
el
mundo
pasando
cada
vez
menos
tiempo
delante
de
su
radio
o
de
su
televisi√≥n
y
recu-


rriendo
en
su
lugar
a
Internet
para
acceder
a
transmisiones
de
audio
y
de
v√≠deo
,
tanto
en
vivo


638
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
638como
pregrabadas
.
A
medida
que
vaya
habiendo
m√°s
y
m√°s
hogares
con
acceso
de
alta
velo-


cidad
,
esta
tendencia
no
har√°
sino
acelerarse
:
los
telespectadores
t√≠picos
de
todo
el
mundo


acceder√°n
a
sus
programas
de
v√≠deo
favoritos
a
trav√©s
de
Internet
en
lugar
de
a
trav√©s
de
los


canales
tradicionales
de
se√±ales
de
televisi√≥n
.
Adem√°s
de
para
la
distribuci√≥n
de
audio
y
de


v√≠deo
,
Internet
tambi√©n
se
est√°
empleando
para
transportar
llamadas
telef√≥nicas
.
De
hecho
,


a
lo
largo
de
la
pr√≥xima
d√©cada
Internet
puede
llegar
a
hacer
que
el
sistema
telef√≥nico
tradi-


cional
de
conmutaci√≥n
de
circuitos
quede
obsoleto
en
muchos
pa√≠ses
.
Internet
no
s√≥lo
pro-


porcionar√°
servicios
telef√≥nicos
por
menos
dinero
,
sino
que
tambi√©n
facilitar√°
numerosos


servicios
de
valor
a√±adido
,
como
videoconferencia
,
servicios
de
directorio
en
l√≠nea
,
servi-


cios
de
mensajer√≠a
vocal
e
integraci√≥n
web
.


En
la
Secci√≥n
7.1
hemos
clasificado
las
aplicaciones
multimedia
en
tres
categor√≠as
dife-


rentes
:
flujos
de
audio
y
v√≠deo
almacenado
,
transmisi√≥n
uno-a-muchos
de
audio
y
v√≠deo
en


tiempo
real
y
audio
y
v√≠deo
interactivo
en
tiempo
real
.
Hemos
recalcado
que
las
aplicacio-


nes
multimedia
son
sensibles
al
retardo
y
tolerantes
a
las
p√©rdidas
,
caracter√≠sticas
muy
dis-


tintas
a
las
de
las
aplicaciones
con
contenido
est√°tico
,
que
son
tolerantes
al
retardo
e


intolerantes
a
las
p√©rdidas
.
Tambi√©n
hemos
explicado
algunas
de
las
dificultades
que
el
ser-


vicio
actual
de
entrega
de
mejor
esfuerzo
de
Internet
plantea
a
las
aplicaciones
multimedia
.


Hemos
repasado
diversas
propuestas
que
se
han
hecho
para
resolver
esos
problemas
plan-


teados
,
incluyendo
la
propuesta
de
mejorar
simplemente
la
infraestructura
de
red
existente


(
a√±adiendo
m√°s
ancho
de
banda
,
m√°s
cach√©s
de
red
y
m√°s
nodos
CDN
e
implantando
tecno-


log√≠as
de
multidifusi√≥n
)
,
la
propuesta
de
a√±adir
funcionalidad
a
Internet
de
manera
que
las


aplicaciones
puedan
reservar
recursos
terminal
a
terminal
de
modo
que
la
red
pueda
satisfa-


cer
las
reservas
realizadas
y
,
finalmente
,
la
propuesta
de
introducir
clases
de
servicio
para


permitir
diferenciar
los
distintos
servicios
.


En
las
Secciones
7.2
a
7.4
hemos
examinado
las
arquitecturas
y
mecanismos
para
la


transmisi√≥n
de
informaci√≥n
multimedia
en
una
red
con
un
servicio
de
entrega
de
mejor


esfuerzo
.
En
la
Secci√≥n
7.2
hemos
repasado
diversas
arquitecturas
para
la
transmisi√≥n
de


flujos
de
audio
y
v√≠deo
almacenado
.
Hemos
analizado
la
interacci√≥n
con
los
usuarios
(
las


√≥rdenes
de
pausa
/
reanudaci√≥n
,
reposicionamiento
y
avance
r√°pido
visual
)
y
hemos
hecho


una
introducci√≥n
a
RTSP
,
un
protocolo
que
proporciona
interacci√≥n
cliente-servidor
para
las


aplicaciones
de
flujos
multimedia
.
En
la
Secci√≥n
7.3
hemos
examinado
c√≥mo
pueden
dise-


√±arse
aplicaciones
interactivas
en
tiempo
real
para
ejecutarse
sobre
una
red
con
servicio
de


entrega
de
mejor
esfuerzo
.
All√≠
vimos
c√≥mo
pueden
aliviarse
enormemente
los
efectos
de


las
fluctuaciones
inducidas
por
la
red
utilizando
una
combinaci√≥n
de
bufferes
de
cliente
,


n√∫meros
de
secuencia
de
los
paquetes
y
marcas
de
tiempo
.
Tambi√©n
hemos
explicado
c√≥mo


una
CDN
facilita
la
transmisi√≥n
de
flujos
multimedia
almacenados
,
al
transmitir
proactiva-


mente
la
informaci√≥n
multimedia
almacenada
a
servidores
CDN
situados
‚Äú
cerca
‚Äù
de
los


puntos
terminales
de
usuario
.


En
la
Secci√≥n
7.5
hemos
visto
c√≥mo
pueden
utilizarse
diversos
mecanismos
de
red


(
disciplinas
de
planificaci√≥n
de
nivel
de
enlace
y
mecanismos
de
vigilancia
del
tr√°fico
)
para


proporcionar
un
servicio
diferenciado
entre
distintas
clases
de
tr√°fico
.
Finalmente
,
en
la
Sec-


ci√≥n
7.6
hemos
analizado
c√≥mo
puede
una
red
proporcionar
garant√≠asde
calidad
de
servicio


a
las
llamadas
admitidas
por
la
red
.
All√≠
vimos
que
hacen
falta
otros
nuevos
protocolos
y


mecanismos
de
red
adicionales
,
incluyendo
los
de
reserva
de
recursos
,
admisi√≥n
de
llama-


das
y
se√±alizaci√≥n
de
llamadas
.
Juntos
,
estos
nuevos
elementos
de
red
hacen
que
las
redes


del
ma√±ana
,
capaces
de
proporcionar
garant√≠as
QoS
,
vayan
a
ser
muy
diferentes
(
y
bastante


m√°s
complejas
)
de
la
Internet
actual
basada
en
un
servicio
de
entrega
de
mejor
esfuerzo
.


7.7
‚Ä¢
RESUMEN
639


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
639Problemas
y
cuestiones
de
repaso


Cap√≠tulo
7
Cuestiones
de
repaso


SECCIONES
7.1‚Äì7.2


R1
.
¬ø
Qu√©
quiere
decir
interactividad
en
la
transmisi√≥n
de
flujos
de
audio
/
v√≠deo
almace-


nado
?
¬ø
Y
en
la
transmisi√≥n
de
audio
/
v√≠deo
interactivo
en
tiempo
real
?


R2
.
Se
han
expuesto
tres
campos
de
mejora
de
Internet
para
dar
un
mejor
soporte
a
las


aplicaciones
multimedia
.
Resuma
brevemente
los
puntos
de
vista
de
cada
campo
.
¬ø
A


qu√©
campo
pertenece
usted
?


R3
.
¬ø
Cu√°les
son
algunas
de
las
tasas
de
compresi√≥n
t√≠picas
(
relaci√≥n
entre
el
n√∫mero
de


bits
de
un
objeto
no
comprimido
y
el
n√∫mero
de
bits
de
la
versi√≥n
comprimida
de


dicho
objeto
)
en
las
aplicaciones
de
audio
e
im√°genes
?
¬ø
Cu√°les
son
las
t√©cnicas
de


compresi√≥n
examinadas
en
la
Secci√≥n
7.1
?


R4
.
Las
Figuras
7.1
y
7.2
presentan
dos
esquemas
de
transmisi√≥n
de
flujos
multimedia


almacenados
.
¬ø
Cu√°les
son
las
ventajas
y
desventajas
de
cada
uno
de
ellos
?


SECCIONES
7.3‚Äì7.4


R5
.
¬ø
Cu√°l
es
la
diferencia
entre
el
retardo
terminal
a
terminal
y
la
fluctuaci√≥n
de
paque-


tes
?
¬ø
Cu√°les
son
las
causas
de
la
fluctuaci√≥n
de
paquetes
?


R6
.
¬ø
Por
qu√©
un
paquete
que
se
recibe
despu√©s
de
su
instante
de
reproducci√≥n
planificado


se
considera
un
paquete
perdido
?


R7
.
En
la
Secci√≥n
7.3
se
han
descrito
dos
esquemas
FEC
.
Res√∫malos
brevemente
.
Ambos


esquemas
incrementan
la
velocidad
de
transmisi√≥n
del
flujo
mediante
la
adici√≥n
de


m√°s
sobrecarga
.
¬ø
El
intercalado
aumenta
tambi√©n
la
velocidad
de
transmisi√≥n
?


R8
.
¬ø
Cu√°l
es
el
papel
de
DNS
en
una
red
CDN
?
¬ø
Tiene
que
modificarse
el
sistema
DNS


para
dar
soporte
a
una
CDN
?
¬ø
Qu√©
informaci√≥n
tiene
que
proporcionar
una
CDN
al


sistema
DNS
,
si
es
que
tiene
que
proporcionar
alguna
?


R9
.
¬ø
Qu√©
informaci√≥n
se
necesita
para
dimensionar
una
red
de
modo
que
se
consiga
una


determinada
calidad
de
servicio
?


R10
.
¬ø
Cu√°ntos
flujos
RTP
distintos
de
sesiones
diferentes
puede
identificar
un
receptor
?


¬ø
C√≥mo
se
identifican
los
diferentes
flujos
dentro
de
la
misma
sesi√≥n
?
¬ø
C√≥mo
se
dis-


tinguen
los
paquetes
RTP
y
RTPC
(
como
parte
de
la
misma
sesi√≥n
)
?


R11
.
En
la
Secci√≥n
7.4
se
han
descrito
tres
tipos
de
paquetes
RTCP
.
Resuma
brevemente
la


informaci√≥n
contenida
en
cada
uno
de
estos
tipos
de
paquetes
.


R12
.
¬ø
Cu√°l
es
el
papel
de
un
registrador
SIP
?
¬ø
En
qu√©
se
diferencia
el
papel
de
un
registra-


dor
SIP
del
de
un
agente
propio
en
IP
m√≥vil
?


SECCIONES
7.5‚Äì7.6


R13
.
En
la
Secci√≥n
7.5
hemos
visto
las
colas
con
prioridad
no
expropiativa
.
¬ø
En
qu√©
con-


sistir√≠an
las
colas
con
prioridad
expropiativa
?
¬ø
Tienen
sentido
las
colas
con
prioridad


expropiativa
en
las
redes
de
computadoras
?


640
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
640PROBLEMAS
641


R14
.
Proporcione
un
ejemplo
de
disciplina
de
planificaci√≥n
de
trabajo
que
no
sea
conserva-


dora
.


R15
.
Proporcione
un
ejemplo
de
las
colas
que
haya
en
su
vida
cotidiana
y
que
se
correspon-


dan
con
los
esquemas
de
las
colas
FIFO
,
con
prioridad
,
por
turno
rotatorio
y
WFQ
.


R16
.
¬ø
Cu√°les
son
algunas
de
las
dificultades
asociadas
con
el
modelo
Intserv
y
la
reserva


de
recursos
por
parte
de
los
flujos
?


Problemas


P1
.
Navegue
por
la
Web
y
localice
dos
sitios
en
los
que
haya
disponibles
flujos
de
audio


y
/
o
v√≠deo
almacenado
.
Para
cada
sitio
,
utilice
Wireshark
para
determinar
:


a.
Si
se
utilizan
metarchivos
.


b.
Si
el
audio
/
v√≠deo
se
env√≠a
sobre
UDP
o
sobre
TCP
.


c.
Si
se
utiliza
RTP
.


d.
Si
se
utiliza
RTSP
.


P2
.
Considere
el
buffer
de
cliente
mostrado
en
la
Figura
7.3
.
Suponga
que
el
sistema
de


transmisi√≥n
de
flujos
utiliza
la
tercera
opci√≥n
;
es
decir
,
el
servidor
env√≠a
los
datos
mul-


timedia
al
socket
tan
r√°pido
como
es
posible
.
Suponga
que
el
ancho
de
banda
TCP
dis-


ponible
es
>
>
d
la
mayor
parte
del
tiempo
.
Suponga
tambi√©n
que
el
buffer
de
cliente


s√≥lo
almacena
la
tercera
parte
de
los
datos
.
Describa
c√≥mo
x(t
)
y
el
contenido
del
buf-


fer
de
cliente
variar√°n
a
lo
largo
del
tiempo
.


P3
.
¬ø
Es
lo
mismo
el
buffer
de
recepci√≥n
TCP
y
el
buffer
de
cliente
del
reproductor
multi-


media
?
Si
no
son
lo
mismo
,
¬ø
c√≥mo
interact√∫an
?


P4
.
En
el
ejemplo
de
telefon√≠a
por
Internet
de
la
Secci√≥n
7.3
,
sea
h
el
n√∫mero
total
de


bytes
de
cabecera
a√±adido
a
cada
fragmento
,
incluyendo
las
cabeceras
UDP
e
IP
.


a.
Suponiendo
que
se
env√≠a
un
datagrama
IP
cada
20
milisegundos
,
determine
la
velo-


cidad
de
transmisi√≥n
en
bits
por
segundo
para
los
datagramas
generados
por
un
lado


de
esta
aplicaci√≥n
.


b.
¬ø
Cu√°l
es
el
valor
t√≠pico
de
h
cuando
se
utiliza
RTP
?


P5
.
Considere
el
procedimiento
descrito
en
la
Secci√≥n
7.3
para
estimar
el
retardo
prome-


dio
di
.
Suponga
que
u
=
0,1
.
Sea
r1
‚Äì
t1
el
retardo
de
la
muestra
m√°s
reciente
,
sea
r2
‚Äì


t2
el
siguiente
retardo
de
la
muestra
m√°s
reciente
,
etc.


a.
Para
una
aplicaci√≥n
de
audio
dada
suponga
que
han
llegado
cuatro
paquetes
al


receptor
con
los
retardos
de
muestra
r4
‚Äì
t4
,
r3
‚Äì
t3
,
r2
‚Äì
t2
y
r1
‚Äì
t1
.
Exprese
la
esti-


maci√≥n
del
retardo
d
en
funci√≥n
de
las
cuatro
muestras
.
 

b.
Generalice
la
f√≥rmula
para
n
retardos
de
muestra
.


c.
Para
la
f√≥rmula
del
apartado
(
b
)
,
obtenga
la
f√≥rmula
resultante
cuando
n
tiende
a


infinito
.
Comente
por
qu√©
este
procedimiento
para
obtener
la
media
se
denomina


media
m√≥vil
exponencial
.


P6
.
Repita
los
apartados
(
a
)
y
(
b
)
del
problema
anterior
para
obtener
la
estimaci√≥n
de
la


desviaci√≥n
media
del
retardo
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
641642
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


P7
.
En
el
ejemplo
de
telefon√≠a
por
Internet
de
la
Secci√≥n
7.3
,
hemos
presentado
un
proce-


dimiento
en
l√≠nea
(
media
m√≥vil
exponencial
)
para
estimar
el
retardo
.
En
este
problema


vamos
a
examinar
un
procedimiento
alternativo
.
Sea
ti
la
marca
de
tiempo
del
paquete


i-√©simo
recibido
;
sea
ri
el
instante
en
el
que
el
paquete
i-√©simo
es
recibido
.
Sea
dn


nuestra
estimaci√≥n
del
retardo
medio
despu√©s
de
recibir
el
paquete
n-√©simo
.
Despu√©s


de
recibir
el
primer
paquete
,
establecemos
que
la
estimaci√≥n
del
retardo
es
igual
a
d1
=


r1
‚Äì
t1
.


a.
Suponga
que
deseamos
que
dn
=
(
r1
‚Äì
t1
+
r2
‚Äì
t2
+
.
.
.
+
rn
‚Äì
tn)/n
para
todo
n.
Pro-


porcione
una
f√≥rmula
recursiva
para
dn
en
funci√≥n
de
dn‚Äì1
,
rn
y
tn
.


b.
Describa
por
qu√©
en
la
telefon√≠a
por
Internet
la
estimaci√≥n
del
retardo
descrita
en
la


Secci√≥n
7.3
es
m√°s
apropiada
que
la
estimaci√≥n
dada
en
el
apartado
(
a
)
.


P8
.
Compare
el
procedimiento
descrito
en
la
Secci√≥n
7.3
para
estimar
el
retardo
medio


con
el
procedimiento
dado
en
la
Secci√≥n
3.5
para
estimar
el
tiempo
de
ida
y
vuelta
.


¬ø
Qu√©
tienen
en
com√∫n
ambos
procedimientos
?
¬ø
En
qu√©
se
diferencian
?


P9
.
Considere
la
estrategia
de
reproducci√≥n
adaptativa
expuesta
en
la
Secci√≥n
7.3
.


a.
¬ø
C√≥mo
pueden
tener
dos
paquetes
recibidos
en
el
destino
sucesivamente
marcas
de


tiempo
que
difieren
en
m√°s
de
20
milisegundos
si
ambos
paquetes
pertenecen
al


mismo
periodo
de
conversaci√≥n
?


b.
¬ø
C√≥mo
puede
utilizar
el
receptor
los
n√∫meros
de
secuencia
para
determinar
si
se


trata
del
primer
paquete
de
un
periodo
de
conversaci√≥n
?
Sea
espec√≠fico
.


P10
.
Considere
la
siguiente
figura
(
que
es
similar
a
la
Figura
7.5
)
.
Un
emisor
comienza
a


enviar
audio
empaquetado
peri√≥dicamente
en
t
=
1
.
El
primer
paquete
llega
al
receptor


en
t
=
8
.


a.
¬ø
Cu√°les
son
los
retardos
(
del
emisor
al
receptor
,
ignorando
cualquier
retardo
de


reproducci√≥n
)
de
los
paquetes
2
a
8
?
Observe
que
cada
segmento
de
l√≠nea
vertical


y
horizontal
de
la
figura
tiene
una
longitud
de
1
,
2
o
3
unidades
de
tiempo
.


Paquetes


generados


Tiempo


Paquetes


18


Paquetes


recibidos


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
642PROBLEMAS
643


b.
Si
la
reproducci√≥n
del
audio
se
inicia
tan
pronto
como
llega
el
primer
paquete
al


receptor
en
t
=
8
,
¬ø
cu√°les
de
los
ocho
primeros
paquetes
enviados
no
llegar√°n
a


tiempo
para
la
reproducci√≥n
?


c.
Si
la
reproducci√≥n
del
audio
comienza
en
t
=
9
,
¬ø
cu√°les
de
los
ocho
primeros
paque-


tes
enviados
no
llegar√°n
a
tiempo
para
la
reproducci√≥n
?


d.
¬ø
Cu√°l
es
el
retardo
m√≠nimo
de
reproducci√≥n
en
el
receptor
que
hace
que
los
ocho


primeros
paquetes
lleguen
a
tiempo
para
la
reproducci√≥n
?


P11
.
Considere
de
nuevo
la
figura
del
Problema
P10
,
que
muestra
los
tiempos
de
transmi-


si√≥n
y
de
recepci√≥n
de
los
paquetes
.


a.
Calcule
el
retardo
estimado
para
los
paquetes
2
hasta
8
utilizando
la
f√≥rmula
para


di
de
la
Secci√≥n
7.3.2
.
Utilice
un
valor
de
u
=
0,1
.


b.
Calcule
la
desviaci√≥n
estimada
del
retardo
respecto
del
promedio
estimado
para
los


paquetes
2
a
8
utilizando
la
f√≥rmula
para
vi
de
la
Secci√≥n
7.3.2
.
Utilice
un
valor
de


u
=
0,1
.


P12
.
Recuerde
los
dos
esquemas
FEC
para
la
aplicaci√≥n
de
telefon√≠a
por
Internet
descritos


en
la
Secci√≥n
7.3
.
Suponga
que
el
primer
esquema
genera
un
fragmento
redundante


por
cada
cuatro
fragmentos
originales
.
Suponga
que
el
segundo
esquema
utiliza
una


codificaci√≥n
con
una
tasa
de
bit
baja
cuya
velocidad
de
transmisi√≥n
es
el
25
por
ciento


de
la
velocidad
de
transmisi√≥n
del
flujo
nominal
.


a.
¬ø
Cu√°nto
ancho
de
banda
adicional
requiere
cada
esquema
?
¬ø
Cu√°nto
retardo
de


reproducci√≥n
a√±ade
cada
esquema
?


b.
¬ø
C√≥mo
funciona
cada
uno
de
los
dos
esquemas
cuando
se
pierde
el
primer
paquete


de
cada
grupo
de
cinco
paquetes
?
¬ø
Qu√©
esquema
proporcionar√°
una
mejor
calidad


de
audio
?


c.
¬ø
C√≥mo
funciona
cada
uno
de
los
dos
esquemas
cuando
se
pierde
el
primer
paquete


de
cada
grupo
de
dos
paquetes
?
¬ø
Qu√©
esquema
proporcionar√°
una
mejor
calidad
de


audio
?


P13
.
Puesto
que
una
CDN
no
incrementa
la
cantidad
de
capacidad
de
enlace
en
una
red


(
suponiendo
que
la
CDN
utiliza
los
enlaces
existentes
para
distribuir
su
contenido


entre
los
nodos
CDN
)
,
¬ø
c√≥mo
mejora
una
CDN
el
rendimiento
visto
por
los
hosts
?


Proporcione
un
ejemplo
.


P14
.
¬ø
Es
posible
para
una
CDN
proporcionar
un
peor
rendimiento
a
un
host
que
ha
solici-


tado
un
objeto
multimedia
,
que
cuando
el
host
solicita
el
objeto
al
servidor
origen
dis-


tante
?
Explique
su
respuesta
.


P15
.
¬ø
C√≥mo
se
calcula
la
fluctuaci√≥n
temporal
entre
llegadas
en
el
informe
de
recepci√≥n
de


RTCP
?
(
Sugerencia
:
lea
el
documento
RFC
dedicado
a
RTP
.
)


P16
.
a.
Suponga
que
hemos
enviado
a
Internet
dos
datagramas
IP
,
transportando
cada
uno


de
ellos
un
segmento
UDP
diferente
.
El
primer
datagrama
tiene
una
direcci√≥n
IP
de


origen
A1
,
una
direcci√≥n
IP
de
destino
B
,
un
puerto
de
origen
P1
y
un
puerto
de
des-


tino
T.
El
segundo
datagrama
tiene
la
direcci√≥n
IP
de
origen
A2
,
la
direcci√≥n
IP
de


destino
B
,
el
puerto
de
origen
P2
y
el
puerto
de
destino
T.
Suponga
que
A1
es
dife-


rente
de
A2
y
que
P1
es
diferente
de
P2
.
Suponiendo
que
ambos
datagramas
llegan
a


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
643644
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


su
destino
final
,
¬ø
ser√°n
recibidos
los
dos
datagramas
UDP
por
el
mismo
socket
?


¬ø
Por
qu√©
?


b.
Suponga
que
Alicia
,
Benito
y
Clara
desean
mantener
una
conferencia
de
voz
utili-


zando
SIP
y
RTP
.
Para
que
Alicia
pueda
enviar
a
y
recibir
paquetes
RTP
proceden-


tes
de
Benito
y
Clara
,
¬ø
basta
con
un
socket
UDP
(
adem√°s
del
socket
necesario
para


los
mensajes
SIP
)
?
En
caso
afirmativo
,
¬ø
c√≥mo
distingue
el
cliente
SIP
de
Alicia
los


paquetes
RTP
recibidos
de
Benito
de
los
procedentes
de
Clara
?


P17
.
Considere
una
sesi√≥n
RTP
que
consta
de
cuatro
usuarios
,
en
la
que
todos
env√≠an
y
reci-


ben
paquetes
RTP
en
la
misma
direcci√≥n
de
multidifusi√≥n
.
Cada
usuario
env√≠a
v√≠deo
a


100
kbps
.


a.
¬ø
Limitar√°
RTCP
su
tr√°fico
a
esa
velocidad
?


b.
¬ø
Cu√°nto
ancho
de
banda
RTCP
se
le
asignar√°
a
un
receptor
particular
?


c.
¬ø
Cu√°nto
ancho
de
banda
RTCP
se
le
asignar√°
a
un
emisor
particular
?


P18
.
a.
¬ø
En
qu√©
se
parece
RTSP
a
HTTP
?
¬ø
RTSP
tiene
m√©todos
?
¬ø
Puede
utilizarse
HTTP


para
solicitar
un
flujo
?


b.
¬ø
En
qu√©
se
diferencia
RTSP
de
HTTP
?
Por
ejemplo
,
HTTP
es
un
protocolo
en


banda
o
fuera
de
banda
?
¬ø
Mantiene
RTSP
informaci√≥n
de
estado
acerca
del


cliente
(
considere
la
funci√≥n
pausar
/
reanudar
)
?


P19
.
Verdadero
o
falso
:


a.
Si
un
flujo
de
v√≠deo
almacenado
se
descarga
directamente
de
un
servidor
web
a
un


reproductor
multimedia
,
entonces
la
aplicaci√≥n
est√°
usando
TCP
como
protocolo


de
transporte
subyacente
.


b.
Cuando
se
est√°
usando
RTP
,
un
emisor
puede
cambiar
la
codificaci√≥n
en
mitad
de


una
sesi√≥n
.


c.
Todas
las
aplicaciones
que
usan
RTP
deben
emplear
el
puerto
87
.


d.
Si
una
sesi√≥n
RTP
tiene
un
flujo
separado
de
audio
y
de
v√≠deo
para
cada
emisor
,


entonces
los
flujos
de
audio
y
de
v√≠deo
usan
el
mismo
SSRC
.


e.
En
los
servicios
diferenciados
,
aunque
el
comportamiento
por
salto
define
diferen-


cias
en
el
rendimiento
entre
clases
,
no
se
impone
ning√∫n
mecanismo
concreto
para


conseguir
esos
rendimientos
.


f.
Suponga
que
Alicia
desea
establecer
una
sesi√≥n
SIP
con
Benito
.
Alicia
,
en
su
men-


saje
INVITE
incluye
la
l√≠nea
:
m
=
audio
48753
RTP
/
A
VP
3
(
A
VP
3
indica
audio


GSM
)
.
Alicia
ha
indicado
,
por
tanto
,
en
este
mensaje
que
desea
enviar
audio
GSM
.


g.
Respecto
a
la
afirmaci√≥n
anterior
,
Alicia
ha
indicado
en
su
mensaje
INVITE
que


enviar√°
el
audio
al
puerto
48753
.


h.
Normalmente
los
mensajes
SIP
se
env√≠an
entre
entidades
SIP
utilizando
un
n√∫mero


de
puerto
SIP
por
defecto
.


i.
Para
mantener
el
registro
,
los
clientes
SIP
tienen
que
enviar
peri√≥dicamente
men-


sajes
REGISTER
.


j.
SIP
obliga
a
que
todos
los
clientes
SIP
soporten
la
codificaci√≥n
de
audio
G.711
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
644PROBLEMAS
645


P20
.
Suponga
que
se
aplica
la
disciplina
de
planificaci√≥n
WFQ
a
un
buffer
que
soporta
tres


clases
y
suponga
que
los
pesos
para
las
tres
clases
son
0,5
,
0,25
y
0,25
.


a.
Suponga
que
cada
clase
tiene
un
gran
n√∫mero
de
paquetes
en
el
buffer
.
¬ø
En
qu√©


secuencia
se
dar√°
servicio
a
las
tres
clases
para
obtener
los
pesos
WFQ
?
(
En
la
pla-


nificaci√≥n
por
turno
rotario
,
una
secuencia
natural
es
123123123
.
.
.
)


b.
Suponga
que
las
clases
1
y
2
tienen
una
gran
cantidad
de
paquetes
en
el
buffer
y


que
no
hay
paquetes
de
clase
3
en
el
buffer
.
¬ø
En
qu√©
secuencia
se
dar√°
servicio
a


las
tres
clases
para
obtener
los
pesos
WFQ
?


P21
.
Considere
la
figura
de
m√°s
abajo
,
que
es
similar
a
las
Figuras
7.22
‚Äì
7.25
.
Responda
a


las
siguientes
cuestiones
:


a.
Suponiendo
un
servicio
FIFO
,
indique
el
instante
en
el
que
los
paquetes
2
hasta
12


abandonan
la
cola
.
Para
cada
paquete
,
¬ø
cu√°l
es
el
retardo
entre
su
llegada
y
el
ini-


cio
de
la
partici√≥n
en
la
que
se
transmite
?
¬ø
Cu√°l
es
el
promedio
de
este
retardo
para


los
12
paquetes
?


b.
Suponga
ahora
un
servicio
con
prioridad
,
en
el
que
los
paquetes
con
n√∫mero
impar


tienen
prioridad
alta
y
los
paquetes
con
n√∫mero
par
tienen
prioridad
baja
.
Indique


el
instante
en
que
los
paquetes
2
a
12
abandonan
la
cola
.
Para
cada
paquete
,
¬ø
cu√°l


es
el
retardo
entre
su
llegada
y
el
inicio
de
la
partici√≥n
en
la
que
se
transmiten
?


¬ø
Cu√°l
es
el
promedio
de
este
retardo
para
los
12
paquetes
?


c.
Suponga
ahora
un
servicio
por
turno
rotatorio
.
Suponga
que
los
paquetes
1
,
2
,
3
,
6
,


11
y
12
pertenecen
a
la
clase
1
y
que
los
paquetes
4
,
5
,
7
,
8
,
9
y
10
son
de
clase
2
.


Indique
el
instante
en
el
que
cada
uno
de
los
paquetes
2
a
12
abandonan
la
cola
.


Para
cada
paquete
,
¬ø
cu√°l
es
el
retardo
entre
su
llegada
y
su
salida
?
¬ø
Cu√°l
es
el
pro-


medio
de
este
retardo
para
los
12
paquetes
?


d.
Ahora
suponga
un
servicio
WFQ
(
Weighted
Fair
Queueing
)
.
Suponga
que
los


paquetes
con
n√∫mero
impar
son
de
clase
1
y
que
los
paquetes
con
n√∫mero
para
son


de
clase
2
.
La
clase
1
tiene
un
peso
WFQ
de
2
mientras
que
la
clase
2
tiene
un
peso


WFQ
de
1
.
Observe
que
puede
no
ser
posible
conseguir
una
planificaci√≥n
WFQ


idealizada
como
se
ha
descrito
en
el
texto
,
por
lo
que
debe
indicar
por
qu√©
ha
deci-


dido
que
cada
paquete
concreto
entre
en
servicio
en
cada
partici√≥n
de
tiempo
.
Para


cada
paquete
,
¬ø
cu√°l
es
el
retardo
entre
su
llegada
y
su
salida
?
¬ø
Cu√°l
es
el
promedio


de
este
retardo
para
los
12
paquetes
?


Tiempo


Llegadas


Salidas


Paquete


en
servicio


Tiempo


1
6


5
932


8
10


11


74
12


t
=
0


1


t
=
2
t
=
4
t
=
6
t
=
8
t
=
10
t
=
12
t
=
14


1


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
645646
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


e.
¬ø
Qu√©
ha
observado
en
el
retardo
promedio
para
cada
uno
de
los
cuatro
casos


(
FCFS
,
por
turno
rotatorio
,
con
prioridad
y
WFQ
)
?


P22
.
Considere
de
nuevo
la
figura
del
Problema
P21
.


a.
Suponga
un
servicio
con
prioridad
,
teniendo
los
paquetes
1
,
4
,
5
,
6
y
11
prioridad


alta
y
los
restantes
paquetes
prioridad
baja
.
Indique
las
particiones
de
tiempo
en
las


que
los
paquetes
2
a
12
salen
de
la
cola
.


b.
Suponga
ahora
que
se
utiliza
un
servicio
por
turno
rotatorio
,
perteneciendo
los


paquetes
1
,
4
,
5
,
6
y
11
a
una
clase
de
tr√°fico
y
los
restantes
paquetes
a
una
segunda


clase
de
tr√°fico
.
Indique
las
particiones
de
tiempo
en
las
que
cada
uno
de
los
paque-


tes
2
a
12
salen
de
la
cola
.


c.
Suponga
ahora
que
se
emplea
un
servicio
WFQ
,
perteneciendo
los
paquetes
1
,
4
,
5
,


6
y
11
a
una
clase
de
tr√°fico
y
los
restantes
paquetes
a
una
segunda
clase
de
tr√°fico
.


La
clase
1
tiene
un
peso
WFQ
de
1
y
la
clase
2
tiene
un
peso
WFQ
de
2
(
f√≠jese
en


que
estos
pesos
son
diferentes
a
los
de
la
cuesti√≥n
anterior
)
.
Indique
las
particiones


de
tiempo
en
las
que
cada
uno
de
los
paquetes
2
a
12
abandonan
la
cola
.
V√©ase
tam-


bi√©n
la
advertencia
indicada
en
la
cuesti√≥n
anterior
relativa
al
servicio
WFQ
.


P23
.
Considere
la
figura
de
esta
p√°gina
,
la
cual
muestra
una
cubeta
con
p√©rdidas
que
est√°


siendo
alimentada
con
un
flujo
de
paquetes
.
El
buffer
de
fichas
puede
almacenar
como


m√°ximo
dos
fichas
e
,
inicialmente
,
en
t
=
0
est√°
lleno
.
Las
nuevas
fichas
llegan
con


una
tasa
igual
a
una
ficha
por
partici√≥n
de
tiempo
.
La
velocidad
del
enlace
de
salida
es


tal
que
si
dos
paquetes
obtienen
fichas
al
principio
de
una
partici√≥n
de
tiempo
,
ambos


pueden
dirigirse
al
enlace
de
salida
en
la
misma
partici√≥n
de
tiempo
.
Los
detalles
de


temporizaci√≥n
del
sistema
son
los
siguientes
:


1
.
Los
paquetes
(
si
los
hay
)
llegan
al
principio
de
la
partici√≥n
de
tiempo
.
As√≠
,
en
la


figura
,
los
paquetes
1
,
2
y
3
llegan
en
la
partici√≥n
0
.
Si
ya
existen
paquetes
en
la


cola
,
entonces
los
paquetes
que
llegan
se
colocan
al
final
de
la
cola
.
Los
paquetes


avanzan
hacia
el
principio
de
la
cola
siguiendo
una
planificaci√≥n
FIFO
.


2
.
Una
vez
que
se
han
a√±adido
a
la
cola
las
fichas
que
llegan
,
si
existe
alg√∫n
paquete


en
la
cola
,
uno
o
dos
de
estos
paquetes
(
dependiendo
del
n√∫mero
de
fichas
disponi-


bles
)
eliminar√°n
cada
uno
de
ellos
una
ficha
del
buffer
de
fichas
y
pasan
al
enlace


Llegadas


Cola
de
paquetes


(
espera
para
obtener


una
ficha
)


9


10


7
6
4


8
5


1


3


2


t
=
8
t
=
6
t
=
4
t
=
2
t
=
0
t
=
4
t
=
2
t
=
0


r
=
1
ficha
/
partici√≥n


b
=
2
fichas


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
646PREGUNTAS
PARA
LA
DISCUSI√ìN
647


de
salida
durante
dicha
partici√≥n
.
Por
tanto
,
los
paquetes
1
y
2
eliminan
cada
uno


una
ficha
del
buffer
(
puesto
que
inicialmente
existen
dos
fichas
)
y
pasan
al
enlace


de
salida
durante
la
partici√≥n
de
tiempo
0
.


3
.
Si
el
buffer
de
fichas
no
est√°
lleno
se
a√±ade
una
nueva
ficha
,
ya
que
la
velocidad
de


generaci√≥n
de
fichas
es
r
=
1
ficha
/
partici√≥n
.


4
.
El
tiempo
avanza
a
la
siguiente
partici√≥n
de
tiempo
y
estos
pasos
se
repiten
.


Responda
a
las
siguientes
preguntas
:


a.
Para
cada
partici√≥n
de
tiempo
,
identifique
los
paquetes
que
se
encuentran
en
la
cola


y
el
n√∫mero
de
fichas
que
hay
en
la
cubeta
inmediatamente
despu√©s
de
que
las
lle-


gadas
hayan
sido
procesadas
(
paso
1
anterior
)
pero
antes
de
que
cualquiera
de
los


paquetes
haya
atravesado
la
cola
y
eliminado
una
ficha
.
Luego
,
para
la
partici√≥n
t
=


0
del
ejemplo
anterior
,
los
paquetes
1
,
2
y
3
est√°n
en
la
cola
y
en
el
buffer
hay
dos


fichas
.


b.
Para
cada
partici√≥n
de
tiempo
,
indique
qu√©
paquetes
aparecen
en
la
salida
despu√©s


de
que
se
hayan
eliminado
de
la
cola
la
o
las
fichas
.
Por
tanto
,
para
la
partici√≥n
t
=


0
del
ejemplo
anterior
,
los
paquetes
1
y
2
aparecen
en
el
enlace
de
salida
del
buffer


con
p√©rdidas
durante
la
partici√≥n
0
.
 

P24
.
Repita
el
Problema
P23
pero
suponiendo
ahora
que
r
=
2
.
Suponga
de
nuevo
que
ini-


cialmente
la
cubeta
est√°
llena
.


P25
.
Considere
el
Problema
P24
y
suponga
en
este
caso
que
r
=
3
y
que
b
=
2
,
al
igual
que


antes
.
¬ø
Cambiar√≠a
esto
su
respuesta
al
problema
anterior
?


P26
.
Considere
el
mecanismo
de
vigilancia
de
la
cubeta
con
p√©rdidas
(
visto
en
la
Secci√≥n


7.5
)
que
monitoriza
la
velocidad
promedio
y
el
tama√±o
de
r√°faga
de
un
flujo
de
paque-


tes
.
Ahora
tambi√©n
deseamos
monitorizar
la
velocidad
de
pico
,
p.
Explique
c√≥mo
la


salida
de
este
mecanismo
de
vigilancia
de
la
cubeta
con
p√©rdidas
puede
alimentar
a
un


segundo
mecanismo
del
mismo
tipo
,
de
modo
que
las
dos
cubetas
con
p√©rdidas
conec-


tadas
en
serie
monitoricen
la
velocidad
media
,
la
velocidad
de
pico
y
el
tama√±o
de


r√°faga
.
Aseg√∫rese
de
establecer
el
tama√±o
de
la
cubeta
y
la
velocidad
de
generaci√≥n
de


fichas
del
segundo
mecanismo
de
vigilancia
.


P27
.
Se
dice
que
un
flujo
de
paquetes
cumple
una
especificaci√≥n
de
cubeta
con
p√©rdidas


(
r
,
b
)
con
un
tama√±o
de
r√°faga
igual
a
b
y
una
velocidad
media
r
si
el
n√∫mero
de
paque-


tes
que
llega
a
dicha
cubeta
es
menor
que
rt
+
b
paquetes
en
todo
intervalo
de
tiempo


de
longitud
t
para
todo
t.
Un
flujo
de
paquetes
que
cumpla
con
una
especificaci√≥n
de


cubeta
con
p√©rdidas
(
r
,
b
)
,
¬ø
tendr√°
que
esperar
alguna
vez
en
un
controlador
de
cubeta


con
p√©rdidas
con
par√°metros
r
y
b
?
Justifique
su
respuesta
.


P28
.
Demuestre
que
siempre
y
cuando
r1
<
Rw
1/(‚àë
wj
)
,
entonces
dm√°x
es
el
retardo
m√°ximo


que
cualquier
paquete
del
flujo
1
puede
experimentar
en
la
cola
WFQ
.


Preguntas
para
la
discusi√≥n


D1
.
Localice
una
empresa
que
transmita
flujos
de
v√≠deo
en
vivo
utilizando
mecanismos
de


distribuci√≥n
P2P.
Escriba
un
art√≠culo
acerca
de
la
tecnolog√≠a
subyacente
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
647648
CAP√çTULO
7
‚Ä¢
REDES
MULTIMEDIA


D2
.
¬ø
Qu√©
cree
que
es
mejor
,
transmitir
flujos
de
audio
/
v√≠deo
almacenado
sobre
TCP
o


sobre
UDP
?


D3
.
Escriba
un
informe
sobre
los
productos
SIP
de
Cisco
.


D4
.
¬ø
Puede
resolverse
el
problema
de
proporcionar
garant√≠as
de
calidad
de
servicio
(
QoS
)


simplemente
aportando
el
suficiente
ancho
de
banda
,
es
decir
,
actualizando
las
capaci-


dades
de
todos
los
enlaces
de
manera
que
las
limitaciones
de
ancho
de
banda
ya
no


constituyan
un
problema
?


D5
.
Un
mercado
emergente
interesante
es
la
utilizaci√≥n
de
la
telefon√≠a
por
Internet
y
una


red
LAN
de
alta
velocidad
por
parte
de
una
empresa
para
reemplazar
el
PBX
de
esa


misma
empresa
.
Escriba
un
informe
de
una
p√°gina
acerca
de
este
tema
.
Responda
a
la


siguientes
preguntas
en
su
informe
:


a.
¬ø
Qu√©
es
un
PBX
tradicional
?
¬ø
Qui√©n
lo
utilizar√≠a
?


b.
Considere
una
llamada
entre
un
usuario
de
la
empresa
y
otro
usuario
externo
a
la


empresa
que
est√°
conectado
a
la
red
telef√≥nica
tradicional
.
¬ø
Qu√©
clase
de
tecnolo-


g√≠a
se
necesita
en
la
interfaz
entre
la
red
LAN
y
la
red
telef√≥nica
tradicional
?


c.
Adem√°s
del
software
de
telefon√≠a
por
Internet
y
la
interfaz
mencionada
en
el
apar-


tado
(
b
)
,
¬ø
qu√©
m√°s
se
necesita
para
reemplazar
el
PBX
?


D6
.
Piense
en
c√≥mo
se
dimensiona
una
red
de
carreteras
(
por
ejemplo
,
c√≥mo
se
determina


el
n√∫mero
de
carriles
de
las
autov√≠as
que
entran
y
salen
de
una
gran
ciudad
)
.
Enumere


los
cuatro
pasos
que
cree
que
seguir√≠a
un
ingeniero
de
caminos
al
dimensionar
tal
red


de
carreteras
.
¬ø
Cu√°les
son
los
pasos
an√°logos
que
se
seguir√≠an
para
dimensionar
una


red
de
computadoras
?


Tareas
de
programaci√≥n


En
esta
pr√°ctica
de
laboratorio
tendr√°
que
implementar
un
servidor
y
un
cliente
de
flujos
de


v√≠deo
.
El
cliente
utilizar√°
el
protocolo
RTSP
(
Real-Time
Streaming
Protocol
)
para
controlar


las
acciones
del
servidor
.
El
servidor
utilizar√°
el
protocolo
de
tiempo
real
RTP
para
empa-


quetar
el
v√≠deo
y
transportarlo
sobre
UDP
.


Se
le
proporcionar√°
c√≥digo
Java
que
implementa
parcialmente
RTSP
y
RTP
en
el


cliente
y
en
el
servidor
.
Su
trabajo
consistir√°
en
completar
tanto
el
c√≥digo
de
cliente


como
de
servidor
.
Cuando
haya
terminado
,
habr√°
creado
una
aplicaci√≥n
cliente-servidor


que
har√°
lo
siguiente
:


‚Ä¢E
l
 
c
l
i
e
n
t
e
 
e
n
v
√≠
a
 
c
o
m
a
n
d
o
s
 
S
E
T
U
P
,
 
P
L
A
Y
,
 
P
A
U
S
E
 
y
 
T
E
A
R
D
O
W
N
 
R
T
S
P
,
 
y
 
e
l
 
s
e
r
v
i
d
o
r


responde
a
los
comandos
.


‚Ä¢C
u
a
n
d
o
 
e
l
 
s
e
r
v
i
d
o
r
 
s
e
 
e
n
c
u
e
n
t
r
a
 
e
n
 
e
l
 
e
s
t
a
d
o
 
d
e
 
r
e
p
r
o
d
u
c
c
i
√≥
n
,
 
p
e
r
i
√≥
d
i
c
a
m
e
n
t
e
 
c
a
p
t
u
r
a


una
trama
JPEG
almacenada
,
la
empaqueta
con
RTP
y
env√≠a
el
paquete
RTP
a
un
socket


UDP
.


‚Ä¢E
l
 
c
l
i
e
n
t
e
 
r
e
c
i
b
e
 
l
o
s
 
p
a
q
u
e
t
e
s
 
R
T
P
,
 
e
x
t
r
a
e
 
l
a
s
 
t
r
a
m
a
s
 
J
P
E
G
,
 
d
e
s
c
o
m
p
r
i
m
e
 
l
a
s
 
t
r
a
m
a
s
 
y
 
l
a
s


reproduce
en
el
monitor
del
cliente
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
648El
c√≥digo
que
le
proporcionamos
implementa
el
protocolo
RTSP
en
el
servidor
y
el


desempaquetamiento
RTP
en
el
cliente
.
El
c√≥digo
tambi√©n
se
ocupa
de
mostrar
el
v√≠deo


transmitido
.
Tendr√°
que
implementar
RTSP
en
el
cliente
y
RTP
en
el
servidor
.


Esta
tarea
de
programaci√≥n
mejorar√°
significativamente
la
compresi√≥n
del
estudiante


sobre
RTP
,
RTSP
y
la
transmisi√≥n
de
los
flujos
de
v√≠deo
,
por
lo
que
le
recomendamos
que
la


realice
.
La
tarea
tambi√©n
sugiere
una
serie
de
ejercicios
opcionales
,
incluyendo
la
imple-


mentaci√≥n
del
comando
RTSP
DESCRIBE
tanto
en
el
cliente
como
en
el
servidor
.
Puede


encontrar
todos
los
detalles
acerca
de
la
tarea
,
as√≠
como
importantes
fragmentos
de
c√≥digo


Java
,
en
el
sitio
web
http://www
.awl.com
/
kurose-ross
.


TAREAS
DE
PROGRAMACI√ìN
649


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
649650


¬ø
Qu√©
le
hizo
especializarse
en
redes
multimedia
?


Ocuri√≥
casi
por
causalidad
.
Como
estudiante
de
doctorado
estuve
incolucrado
en
DARTnet
,
una
red


experimental
que
se
extend√≠a
por
Estados
Unidos
mediante
l√≠neas
T1
.
DARTnet
se
utiliz√≥
como
campo


de
pruebas
para
la
multidifusi√≥n
y
las
herramientas
en
tiempo
real
de
Internet
.
Esto
me
llev√≥
a
escribir


mi
primera
herramienta
para
audio
,
NeV
oT.
A
trav√©s
de
algunos
de
los
participantes
de
DARTnet
,
me


involucr√©
en
el
IETF
,
dentro
del
entonces
naciente
grupo
de
trabajo
Video
Transport
.
Este
grupo
estan-


dariz√≥
m√°s
tarde
RTP
.


¬ø
Cu√°l
fue
su
primer
trabajo
en
la
industria
de
las
computadoras
?
¬ø
Qu√©
implic√≥
?


Mi
primer
trabajo
en
la
industria
de
las
computadoras
fue
el
de
soldar
un
kit
de
computadora
Altair


cuando
era
estudiante
de
bachillerato
en
Livermore
,
California
.
Cuando
volv√≠
a
Alemania
,
comenc√©


con
una
empresa
peque√±a
de
consultor√≠a
que
dise√±√≥
un
programa
de
gesti√≥n
de
direcciones
para
una


agencia
de
viajes
,
almacenando
los
datos
en
cintas
de
casete
para
nuestro
TRS-80
y
utilizando
como


impresora
una
m√°quina
de
escribir
IBM
Selectric
con
una
interfaz
hardware
casera
.


Mi
primer
trabajo
de
verdad
fue
en
los
laboratorios
AT&T
Bell
Laboratories
,
donde
desarroll√©
un


emulador
de
red
para
construir
redes
experimentales
en
un
entorno
de
laboratorio
.


¬ø
Cu√°les
son
los
objetivos
del
Internet
Real-Time
Lab
?


Nuestro
objetivo
es
proporcionar
componentes
y
piezas
para
la
red
Internet
con
el
fin
de
que
sea
la


√∫nica
infraestructura
de
comunicaciones
en
el
futuro
.
Esto
incluye
el
desarrollo
de
nuevos
protocolos


como
GIST
(
para
la
se√±alizaci√≥n
de
la
capa
de
red
)
y
LoST
(
para
localizar
los
recursos
por
ubica-


ci√≥n
)
,
o
mejorar
los
protocolos
que
han
estado
funcionando
hasta
ahora
,
como
SIP
,
trabajando
en
los


sistemas
Rich
Presence
,
P2P
,
los
mecanismos
de
llamadas
de
emergencia
de
siguiente
generaci√≥n


y
las
herramientas
de
creaci√≥n
de
servicios
.
Recientemente
nos
hemos
centrado
especialmente
tam-


bi√©n
en
los
sistemas
inal√°mbricos
para
V
oIP
,
como
son
las
redes
802.11b
y
802.11n
y
es
posible
tam-


bi√©n
que
las
redes
WiMax
tomen
importancia
en
las
tecnolog√≠as
para
el
campo
de
la
telefon√≠a
.
Tambi√©n


estamos
intentando
mejorar
de
forma
considerable
la
capacidad
de
los
usuarios
para
diagnosticar
los


fallos
en
la
complicada
mara√±a
de
proveedores
y
equipos
,
utilizando
el
sistema
de
diagn√≥stico
de
fallos


entre
iguales
conocido
como
DYSWIS
(
Do
You
See
What
I
See
)
.


Intentamos
llevar
a
cabo
el
trabajo
relevante
de
forma
pr√°ctica
,
construyendo
prototipos
y
siste-


mas
de
c√≥digo
abierto
,
midiendo
el
rendimiento
de
los
sistemas
reales
y
contribuyendo
a
los
est√°nda-


res
del
IETF
.


Henning
Schulzrinne


Henning
Schulzrinne
es
Catedr√°tico
Chair
del
departamento
de


Ciencias
de
la
Computaci√≥n
y
director
del
Internet
Real-Time


Laboratory
en
la
Universidad
de
Columbia
.
Es
coautor
de
RTP
,
RTSP
,


SIP
y
GIST
,
protocolos
claves
para
las
comunicaciones
de
audio
y


v√≠deo
a
trav√©s
de
Internet
.
Henning
obtuvo
su
t√≠tulo
de
grado
en


Ingenier√≠a
El√©ctrica
e
Industrial
en
la
Universidad
T√©cnica
de


Darmstadt
,
Alemania
,
su
m√°ster
en
Ingenier√≠a
El√©ctrica
y
de
compu-


tadoras
en
la
Universidad
de
Cincinnati
y
es
doctor
en
Ingenier√≠a


El√©ctrica
por
la
Universidad
de
Massachusetts
,
Amherst
.


UNA
ENTREVISTA
CON
...


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
650651


¬ø
Cu√°l
es
su
visi√≥n
del
futuro
de
las
redes
multimedia
?


Ahora
nos
encontramos
en
una
fase
de
transici√≥n
;
estamos
s√≥lo
a
unos
pocos
a√±os
de
que
IP
sea
la
pla-


taforma
universal
para
los
servicios
multimedia
,
desde
IPTV
a
V
oIP
.
Todos
confiamos
en
que
la
radio
,


el
tel√©fono
y
la
televisi√≥n
est√©n
disponibles
incluso
durante
las
tormentas
de
nieve
y
los
terremotos
;
por


tanto
,
cuando
Internet
tome
el
papel
de
estas
redes
dedicadas
,
los
usuarios
esperar√°n
el
mismo
nivel
de


fiabilidad
.


Tendremos
que
aprender
a
dise√±ar
tecnolog√≠as
de
red
para
un
ecosistema
de
operadoras
y
pro-


veedores
de
contenido
y
de
servicios
competidores
,
que
dar√°n
servicio
a
muchos
usuarios
sin
for-


maci√≥n
t√©rcnica
y
que
tendr√°n
que
defenderse
de
un
conjunto
peque√±o
,
pero
destructivo
,
de
usuarios


maliciosos
y
criminales
.
Modificar
los
protocolos
est√°
comenzando
a
ser
cada
m√°s
complicado
.


Adem√°s
,
cada
vez
son
m√°s
complejos
,
ya
que
tienen
que
tener
en
cuenta
los
intereses
de
negocios
com-


petidores
,
los
temas
de
seguridad
y
confidencialidad
y
la
falta
de
transparencia
de
las
redes
debida
al


uso
de
cortafuegos
y
traductores
de
direcciones
de
red
.


Dado
que
las
redes
multimedia
se
est√°n
convirtiendo
en
la
base
de
casi
todas
las
aplicaciones
de


entretenimiento
de
gran
consumo
,
tendr√°
que
hacerse
hincapi√©
en
la
gesti√≥n
de
redes
de
muy
gran


tama√±o
,
con
un
coste
bajo
.
Los
usuarios
esperar√°n
disponer
de
una
gran
facilidad
de
uso
,
para
poder


localizar
,
por
ejemplo
,
el
mismo
contenido
en
todos
sus
dispositivos
.


¬ø
Por
qu√©
tiene
SIP
un
futuro
prometedor
?


Am
e
d
i
d
a
 
q
u
e
 
s
e
 
a
c
t
u
a
l
i
c
e
n
 
l
a
s
 
r
e
d
e
s
 
i
n
a
l
√°
m
b
r
i
c
a
s
 
a
c
t
u
a
l
e
s
 
c
o
n
v
i
r
t
i
√©
n
d
o
s
e
 
e
n
 
r
e
d
e
s
 
3
G
,
 
e
s
 
d
e
 
e
s
p
e
r
a
r


que
un
√∫nico
mecanismo
de
se√±alizaci√≥n
multimedia
se
extienda
a
todos
los
tipos
de
redes
,
desde
los


modems
por
cable
a
las
redes
telef√≥nicas
corporativas
y
las
redes
inal√°mbricas
p√∫blicas
.
Junto
con
las


radios
software
,
esto
har√°
posible
que
en
el
futuro
pueda
utilizarse
un
√∫nico
dispositivo
en
una
red


dom√©stica
,
como
por
ejemplo
un
tel√©fono
inal√°mbrico
BlueTooth
,
en
una
red
corporativa
a
trav√©s
de


802.11
y
en
un
√°rea
global
mediante
redes
3G.
Incluso
antes
de
que
dispongamos
de
tal
dispositivo


inal√°mbrico
universal
y
√∫nico
,
los
mecanismos
de
movilidad
personal
har√°n
posible
ocultar
las
dife-


rencias
entre
redes
.
Un
identificador
se
convertir√°
en
el
medio
universal
de
localizaci√≥n
de
una
perso-


na
,
en
lugar
de
tener
que
recordar
o
transmitir
media
docena
de
n√∫meros
de
telef√≥no
espec√≠ficos
de


cada
tecnolog√≠a
o
de
cada
ubicaci√≥n
.


SIP
tambi√©n
rompe
la
provisi√≥n
de
transporte
de
voz
(
bits
)
desde
los
servicios
de
voz
.
Ahora
es


t√©cnicamente
posible
romper
con
el
monopolio
de
la
telefon√≠a
local
,
en
el
que
una
empresa
proporcio-


na
transporte
de
bits
neutral
,
mientras
que
otros
proporcionan
‚Äú
tono
de
marcado
‚Äù
IP
y
los
servicios
tele-


f√≥nicos
cl√°sicos
,
como
las
pasarelas
,
el
reenv√≠o
de
llamadas
y
el
identificador
del
llamante
.


M√°s
all√°
de
la
se√±alizaci√≥n
multimedia
,
SIP
ofrece
un
nuevo
servicio
que
no
exist√≠a
en
In
ternet
:


la
notificaci√≥n
de
sucesos
.
Se
han
hecho
aproximaciones
a
tales
servicios
con
la
t√©cnicas
HTTP
y


el
correo
electr√≥nico
,
pero
nunca
han
sido
muy
satisfactorias
.
Dado
que
los
sucesos
son
una
abs-


tracci√≥n
com√∫n
en
los
sistemas
distribuidos
,
esto
puede
simplificar
la
construcci√≥n
de
nuevos
ser-


vicios
.


¬ø
Tiene
alg√∫n
consejo
para
los
estudiantes
que
ahora
se
inician
en
el
campo
de
las
redes
?


El
campo
de
las
redes
abarca
m√∫ltiples
disciplinas
.
Deriva
de
la
ingenier√≠a
el√©ctrica
,
las
ciencias
de
la


computaci√≥n
,
la
investigaci√≥n
operativa
,
la
estad√≠stica
,
la
econom√≠a
y
otras
disciplinas
.
Por
tanto
,
los


investigadores
de
redes
tienen
que
estar
familizarizados
con
temas
que
van
bastante
m√°s
all√°
de
los
pro-


tocolos
y
los
algoritmos
de
enrutamiento
.


Dado
que
las
redes
se
est√°n
convirtiendo
en
una
parte
importante
de
la
vida
cotidiana
,
los
estu-


diantes
que
deseen
sobresalir
en
este
campo
deben
pensar
en
las
nuevas
restricciones
de
recursos
que


afectan
a
las
redes
,
el
tiempo
y
el
esfuerzo
de
las
personas
,
en
lugar
de
pensar
s√≥lo
en
el
ancho
de
banda


o
en
la
capacidad
de
almacenamiento
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
651652


Trabajar
en
el
campo
de
investigaci√≥n
de
las
redes
puede
resultar
tremendamente
satisfactorio
,
ya


que
es
algo
que
permite
a
las
personas
comunicarse
e
intercambiar
ideas
,
una
de
las
esencias
de
los


seres
humanos
.
Internet
se
ha
convertido
en
la
tercera
infraestructura
global
m√°s
importante
,
junto
con


los
sistemas
de
transporte
y
la
distribuci√≥n
de
energ√≠a
.
Pr√°cticamente
ninguna
parte
de
la
econom√≠a


puede
funcionar
sin
redes
de
altas
prestaciones
,
por
lo
que
el
futuro
pr√≥ximo
est√°
repleto
de
oportuni-


dades
.


M07_KURO9675_05_SE_CH07.qxd
 
22/3/10
 
10:11
 
P√°gina
652CAP√çTULO
8


Seguridad
en


las
redes
de


computadoras


653


En
la
Secci√≥n
1.6
hemos
descrito
algunos
de
los
ataques
m√°s
da√±inos
y
predominantes
en


Internet
,
incluyendo
los
ataques
de
software
malicioso
,
de
denegaci√≥n
de
servicio
,
de
hus-


meadores
,
de
enmascaramiento
de
or√≠genes
y
borrado
y
modificaci√≥n
de
mensajes
.
Aunque


ya
hemos
estudiado
un
mont√≥n
de
cosas
acerca
de
las
redes
de
computadoras
,
no
hemos
exa-


minado
todav√≠a
c√≥mo
dotar
de
seguridad
a
las
redes
para
defenderse
de
los
ataques
esboza-


dos
en
la
Secci√≥n
1.6
.
Equipados
con
nuestros
conocimientos
reci√©n
adquiridos
sobre
las


redes
de
computadoras
y
los
protocolos
de
Internet
,
ahora
vamos
a
estudiar
en
profundidad


las
comunicaciones
seguras
y
,
en
concreto
,
c√≥mo
las
redes
de
computadoras
pueden
defen-


derse
de
los
malos
.


Presentemos
a
Alicia
y
Benito
,
dos
personas
que
desean
comunicarse
y
desean
hacerlo


‚Äú
de
forma
segura
‚Äù
.
Puesto
que
√©ste
es
un
texto
sobre
redes
,
debemos
resaltar
que
Alicia
y


Benito
podr√≠an
ser
dos
routers
que
desean
intercambiar
sus
tablas
de
enrutamiento
de
forma


segura
,
o
un
cliente
y
un
servidor
que
desean
establecer
una
conexi√≥n
de
transporte
segura


o
dos
aplicaciones
de
correo
electr√≥nico
que
quieren
intercambiar
mensajes
de
correo
segu-


ros
(
casos
que
consideraremos
en
este
cap√≠tulo
)
.
Alicia
y
Benito
son
entidades
bien
conoci-


das
en
la
comunidad
de
la
seguridad
,
quiz√°
porque
sus
nombres
son
m√°s
divertidos
que
una


entidad
gen√©rica
‚Äú
A
‚Äù
que
desea
comunicarse
de
forma
segura
con
una
entidad
gen√©rica


‚Äú
B
‚Äù
.
Los
asuntos
amorosos
il√≠citos
,
las
comunicaciones
en
tiempo
de
guerra
y
las
transac-


ciones
de
negocios
son
las
necesidades
humanas
de
comunicaci√≥n
segura
habituales
;
prefi-


riendo
 
la
primera
de
estas
necesidades
a
las
dos
√∫ltimas
,
nos
hace
felices
utilizar
a
Alicia
y


Benito
como
nuestro
emisor
y
nuestro
receptor
e
imaginarlos
en
este
primer
escenario
.


Hemos
dicho
que
Alicia
y
Benito
desean
comunicarse
‚Äú
de
forma
segura
‚Äù
,
pero
,
¬ø
qu√©


quiere
decir
esto
exactamente
?
Como
veremos
,
la
seguridad
(
como
el
amor
)
es
algo
que


tiene
muchos
matices
;
es
decir
,
la
seguridad
tiene
muchas
caras
.
Realmente
,
Alicia
y
Benito


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
653desean
que
el
contenido
de
sus
comunicaciones
sea
secreto
y
que
nadie
pueda
conocerlo


(
sobre
todo
un
esposo
celoso
)
.
Probablemente
,
tambi√©n
desear√°n
estar
seguros
de
que


cuando
ellos
est√°n
manteniendo
una
comunicaci√≥n
,
realmente
est√©n
comunic√°ndose
el
uno


con
el
otro
y
que
si
la
comunicaci√≥n
es
alterada
por
un
tercero
,
esa
alteraci√≥n
pueda
ser


detectada
.
En
la
primera
parte
de
este
cap√≠tulo
vamos
a
abordar
las
t√©cnicas
fundamentales


de
criptograf√≠a
que
permiten
cifrar
las
comunicaciones
,
autenticar
al
interlocutor
con
el
que


se
establece
la
comunicaci√≥n
y
garantizar
la
integridad
del
mensaje
.


En
la
segunda
parte
del
cap√≠tulo
examinaremos
c√≥mo
pueden
utilizarse
los
principios


fundamentales
de
la
criptograf√≠a
para
crear
protocolos
de
red
seguros
.
De
nuevo
,


siguiendo
el
m√©todo
de
arriba-abajo
,
examinaremos
los
protocolos
seguros
en
cada
una
de


las
cuatro
capas
superiores
,
comenzando
por
la
capa
de
aplicaci√≥n
.
Veremos
c√≥mo
dotar


de
seguridad
al
correo
electr√≥nico
,
c√≥mo
dotar
de
seguridad
a
una
conexi√≥n
TCP
,
c√≥mo


proporcionar
seguridad
a
la
capa
de
red
y
c√≥mo
dotar
de
seguridad
a
una
red
LAN
inal√°m-


brica
.
En
la
tercera
parte
del
cap√≠tulo
consideraremos
la
seguridad
operacional
,
la
cual
se


ocupa
de
la
protecci√≥n
de
las
redes
institucionales
frente
a
los
ataques
.
En
particular
,
estu-


diaremos
c√≥mo
los
cortafuegos
y
los
sistemas
de
detecci√≥n
de
intrusiones
pueden
mejorar


la
seguridad
de
la
red
de
una
organizaci√≥n
.


8.1
¬ø
Qu√©
es
la
seguridad
de
red
?


Comencemos
nuestro
estudio
sobre
la
seguridad
de
las
redes
volviendo
a
nuestros
amantes


Alicia
y
Benito
que
desean
comunicarse
‚Äú
de
forma
segura
‚Äù
.
¬ø
Qu√©
significa
esto
exacta-


mente
?
En
realidad
,
Alicia
quiere
que
s√≥lo
Benito
sea
capaz
de
comprender
los
mensajes


que
ella
le
env√≠a
,
incluso
aunque
est√©n
comunic√°ndose
a
trav√©s
de
un
medio
no
seguro
en
el


que
un
intruso
(
Tom√°s
,
por
ejemplo
)
pueda
interceptar
lo
que
Alicia
transmite
a
Benito
.


Benito
tambi√©n
quiere
estar
seguro
de
que
el
mensaje
que
√©l
recibe
de
Alicia
fue
realmente


enviado
por
Alicia
,
y
Alicia
quiere
estar
segura
de
que
la
persona
que
se
est√°
comunicando


con
ella
es
realmente
Benito
.
Alicia
y
Benito
tambi√©n
quieren
estar
seguros
de
que
el
conte-


nido
de
sus
mensajes
no
ha
sido
alterado
en
el
camino
.
Adem√°s
,
quieren
estar
seguros
de
que


siempre
podr√°n
comunicarse
(
es
decir
,
que
nadie
les
puede
denegar
el
acceso
a
los
recursos


necesarios
para
comunicarse
)
.
Teniendo
en
cuenta
estas
consideraciones
,
podemos
identifi-


car
las
siguientes
propiedades
deseables
en
una
comunicaci√≥n
segura
.


‚Ä¢
Confidencialidad
.
S√≥lo
el
emisor
y
el
receptor
deseado
deber√°n
comprender
el
contenido


de
los
mensajes
transmitidos
.
Puesto
que
los
curiosos
pueden
interceptar
los
mensajes
,
es


absolutamente
necesario
que
los
mensajes
sean
cifrados
de
alguna
manera
,
de
modo
que


un
mensaje
interceptado
no
pueda
ser
comprendido
por
el
que
lo
ha
interceptado
.
Este


aspecto
de
la
confidencialidad
es
probablemente
el
concepto
m√°s
com√∫nmente
percibido


del
t√©rmino
comunicaci√≥n
segura
.
En
la
Secci√≥n
8.2
estudiaremos
las
t√©cnicas
criptogr√°-


ficas
para
el
cifrado
y
descifrado
de
datos
.


‚Ä¢
Autenticaci√≥n
del
punto
terminal
.
Tanto
el
emisor
como
el
receptor
deber√°n
poder


confirmar
la
identidad
del
otro
en
el
proceso
de
comunicaci√≥n
(
confirmar
que
el
otro


es
de
hecho
quien
dice
ser
)
.
La
comunicaci√≥n
humana
frente
a
frente
resuelve
este


problema
f√°cilmente
gracias
al
reconocimiento
visual
.
Cuando
las
entidades
se
comu-


nican
a
trav√©s
de
un
medio
en
el
que
no
es
posible
ver
al
otro
,
la
autenticaci√≥n
no
es


tan
sencilla
.
Por
ejemplo
,
¬ø
por
qu√©
deber√≠a
creerse
que
un
mensaje
de
correo
electr√≥-


654
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
654nico
recibido
que
contiene
una
cadena
de
texto
que
dice
que
dicho
mensaje
procede


de
un
amigo
suyo
realmente
procede
de
ese
amigo
?


‚Ä¢
Integridad
del
mensaje
.
Incluso
si
el
emisor
y
el
receptor
son
capaces
de
autenticarse


entre
s√≠
,
continuar√°n
queriendo
estar
seguros
de
que
el
contenido
de
sus
comunicaciones


no
ha
sido
alterado
durante
la
transmisi√≥n
ni
maliciosamente
ni
por
accidente
.
Se
pueden


emplear
extensiones
a
las
t√©cnicas
de
suma
de
comprobaci√≥n
que
hemos
visto
en
los
pro-


tocolos
de
enlace
de
datos
y
de
transporte
fiable
para
proporcionar
integridad
a
los
men-


sajes
.
Estudiaremos
la
autenticaci√≥n
del
punto
terminal
y
la
integridad
de
los
mensajes


en
la
Secci√≥n
8.3
.


‚Ä¢
Seguridad
operacional
.
Casi
todas
las
organizaciones
(
empresas
,
universidades
,
etc.
)


actuales
disponen
de
redes
que
est√°n
conectadas
a
la
red
p√∫blica
Internet
.
Estas
redes


pueden
,
potencialmente
,
verse
comprometidas
por
los
atacantes
que
pueden
acceder
a


ellas
a
trav√©s
de
Internet
.
Los
atacantes
pueden
intentar
depositar
gusanos
en
los
hosts
de


la
red
,
conseguir
secretos
corporativos
,
realizar
un
mapa
de
las
configuraciones
internas


de
la
red
y
ejecutar
ataques
DoS.
En
la
Secci√≥n
8.8
veremos
que
se
emplean
dispositivos


operacionales
,
como
los
cortafuegos
y
los
sistemas
de
detecci√≥n
de
intrusiones
,
para
res-


ponder
a
los
ataques
efectuados
contra
la
red
de
una
organizaci√≥n
.
Un
cortafuegos
se


coloca
entre
la
red
de
la
organizaci√≥n
y
la
red
p√∫blica
,
controlando
el
acceso
de
paquetes


procedentes
de
la
red
.
Un
sistema
de
detecci√≥n
de
intrusiones
realiza
una
‚Äú
inspecci√≥n


profunda
de
los
paquetes
‚Äù
,
alertando
a
los
administradores
de
la
red
cuando
detecta
cual-


quier
actividad
sospechosa
.


Una
vez
establecido
lo
que
queremos
decir
al
hablar
de
la
seguridad
de
la
red
,
vamos
a


ver
exactamente
a
qu√©
informaci√≥n
puede
tener
acceso
un
intruso
y
qu√©
acciones
pueden
lle-


var
a
cabo
dicho
intruso
.
La
Figura
8.1
ilustra
este
escenario
.
Alicia
es
el
emisor
y
desea


enviar
datos
a
Benito
,
que
es
el
receptor
.
Para
intercambiar
datos
de
forma
segura
y
poder


cumplir
los
requisitos
de
confidencialidad
,
autenticaci√≥n
del
punto
terminal
e
integridad
de


los
mensajes
,
Alicia
y
Benito
intercambiar√°n
mensajes
de
control
y
mensajes
de
datos
(
de


forma
similar
a
como
los
emisores
y
receptores
TCP
intercambian
segmentos
de
control
y


segmentos
de
datos
)
.
Normalmente
,
todos
o
algunos
de
estos
mensajes
ser√°n
cifrados
.
Como


hemos
visto
en
la
Secci√≥n
1.6
,
potencialmente
un
intruso
puede
:


‚Ä¢
curiosear
(
husmear
y
registrar
los
mensajes
de
control
y
de
datos
que
se
transmiten


por
el
canal
)
.


‚Ä¢
modificar
,
insertar
o
borrar
mensajes
o
el
contenido
de
los
mismos
.


Como
veremos
,
a
menos
que
se
tomen
las
contramedidas
adecuadas
,
estas
capacidades


permitir√°n
a
un
intruso
montar
una
amplia
variedad
de
ataques
contra
la
seguridad
de
la
red
:


escuchando
las
comunicaciones
(
posiblemente
robando
las
contrase√±as
y
los
datos
)
,
suplan-


tando
a
otra
entidad
,
pirateando
una
sesi√≥n
activa
,
denegando
el
servicio
a
los
usuarios
leg√≠-


timos
de
la
red
por
sobrecarga
de
los
recursos
del
sistema
,
etc.
Puede
ver
un
resumen
de
los


ataques
conocidos
en
el
Centro
de
coordinaci√≥n
CERT
[
CERT
2009
]
.
Consulte
tambi√©n


[
Cisco
Security
2009
;
V
oydock
1983
;
Bhimani
1996
;
Skoudis
2006
]
.


Una
vez
que
ha
quedado
claro
el
hecho
de
que
existen
amenazas
reales
en
Internet
,


¬ø
cu√°les
son
los
equivalentes
en
Internet
de
Alicia
y
Benito
,
nuestros
amigos
que
necesitan


comunicarse
de
forma
segura
?
Realmente
,
Benito
y
Alicia
pueden
ser
personas
situadas
en


dos
sistemas
terminales
,
por
ejemplo
,
una
Alicia
real
y
un
Benito
real
que
desean
intercam-


biar
mensajes
de
correo
electr√≥nico
de
forma
segura
.
Asimismo
,
tambi√©n
pueden
desear
par-


8.1
‚Ä¢
¬ø
QU√â
ES
LA
SEGURIDAD
DE
RED
?
655


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
655ticipar
en
una
transacci√≥n
de
comercio
electr√≥nico
;
por
ejemplo
,
Benito
puede
tener
que


transferir
el
n√∫mero
de
su
tarjeta
de
cr√©dito
de
forma
segura
a
un
servidor
web
para
comprar


cierto
producto
en
l√≠nea
.
De
forma
similar
,
una
Alicia
real
puede
querer
interactuar
con
su


banco
en
l√≠nea
.
Los
participantes
que
necesitan
comunicaciones
seguras
pueden
ser
ellos


mismos
parte
de
la
infraestructura
de
red
.
Recuerde
que
el
sistema
de
nombres
de
dominio


(
DNS
,
v√©ase
la
Secci√≥n
2.5
)
o
los
demonios
de
enrutamiento
que
intercambian
informaci√≥n
de


enrutamiento
(
v√©ase
la
Secci√≥n
4.6
)
requieren
una
comunicaci√≥n
segura
entre
ambas
partes
.


Esto
tambi√©n
es
as√≠
en
el
caso
de
las
aplicaciones
de
gesti√≥n
de
red
,
un
tema
que
examinare-


mos
en
el
Cap√≠tulo
9
.
Un
intruso
que
pudiera
interferir
de
forma
activa
en
las
b√∫squedas
DNS


(
como
hemos
visto
en
la
Secci√≥n
2.5
)
,
los
c√°lculos
de
enrutamiento
[
Murphy
2003
]
o
las


funciones
de
gesti√≥n
de
red
[
RFC
2574
]
podr√≠a
causar
estragos
en
Internet
.


Una
vez
que
hemos
establecido
el
marco
de
trabajo
,
algunas
de
las
definiciones


m√°s
importantes
y
la
necesidad
de
dotar
de
seguridad
a
la
red
,
vamos
a
profundizar
a


continuaci√≥n
en
la
criptograf√≠a
.
Aunque
el
uso
de
la
criptograf√≠a
para
proporcionar
con-


fidencialidad
es
evidente
,
veremos
tambi√©n
que
la
criptograf√≠a
resulta
fundamental


para
la
autenticaci√≥n
del
punto
terminal
y
la
verificaci√≥n
de
la
integridad
de
los
mensa-


jes
,
haciendo
de
ella
una
piedra
angular
de
los
mecanismos
de
seguridad
de
la
red
.


8.2
Principios
de
la
criptograf√≠a


Aunque
la
criptograf√≠a
tiene
una
larga
historia
que
se
remonta
hasta
la
√©poca
de
Julio
C√©sar
,


las
t√©cnicas
criptogr√°ficas
modernas
,
incluyendo
muchas
de
las
utilizadas
en
Internet
,
est√°n


basadas
en
los
avances
realizados
en
los
√∫ltimos
30
a√±os
.
El
libro
de
Kahn
,
The
Codebre-


akers
[
Kahn
1967
]
,
y
el
libro
de
Singh
,
The
Code
Book
:
The
Science
of
Secrecy
from


Ancient
Egypt
to
Quantum
Cryptography
[
Singh
1999
]
,
proporcionan
una
fascinante


visi√≥n
de
la
larga
historia
de
la
criptograf√≠a
.
Una
exposici√≥n
completa
sobre
critpograf√≠a


requiere
un
libro
completo
[
Kaufman
1995
;
Schneier
1995
]
y
,
por
tanto
,
aqu√≠
s√≥lo
vamos


a
abordar
los
aspectos
esenciales
,
en
particular
aquellos
que
est√°n
en
pr√°ctica
en
Internet
.


Debemos
comentar
tambi√©n
que
aunque
en
esta
secci√≥n
vamos
a
centrarnos
en
el
uso
de


la
criptograf√≠a
para
conseguir
confidencialidad
,
veremos
despu√©s
que
las
t√©cnicas
cripto-


gr√°ficas
est√°n
inextricablemente
unidas
a
la
autenticaci√≥n
,
la
integridad
de
los
mensajes
,


el
no
repudio
y
otras
muchas
cuestiones
.


656
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Emisor


seguro


Alicia


Tom√°s


Canal


Mensaje
de
datos
y
de
control


Receptor


seguro


Benito


Datos
Datos


Figura
8.1
‚Ä¢
Emisor
,
receptor
e
intruso
(
Alicia
,
Benito
y
Tom√°s
)
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
656Las
t√©cnicas
criptogr√°ficas
permiten
a
un
emisor
ocultar
los
datos
de
modo
que
los


intrusos
no
puedan
obtener
ninguna
informaci√≥n
a
partir
de
los
datos
interceptados
.
El


receptor
,
por
supuesto
,
deber√°
ser
capaz
de
recuperar
los
datos
originales
a
partir
de
los
datos


ocultados
.
La
Figura
8.2
ilustra
parte
de
la
terminolog√≠a
m√°s
importante
.


Suponga
ahora
que
Alicia
quiere
enviar
un
mensaje
a
Benito
.
El
mensaje
de
Alicia


en
su
forma
original
(
por
ejemplo
,
‚Äú
Benito
,
te
quiero
.
Alicia
‚Äù
)
se
conoce
con
el


nombre
de
texto
en
claro
o
texto
plano
(
cleartext
o
plaintext
)
Alicia
cifra
su
mensaje
de


texto
en
claro
utilizando
un
algoritmo
de
cifrado
de
modo
que
el
mensaje
cifrado
,
que
se


conoce
con
el
nombre
de
texto
cifrado
(
ciphertext
)
,
es
ininteligible
para
cualquier
intruso
.


Es
interesante
observar
que
,
en
muchos
sistemas
criptogr√°ficos
modernos
,
incluyendo
los


utilizados
en
Internet
,
la
propia
t√©cnica
de
cifrado
es
conocida
,
en
el
sentido
de
que
es


p√∫blica
,
est√°
estandarizada
y
est√°
disponible
para
todo
el
mundo
(
por
ejemplo
,
[
RFC
1321
;


RFC
2437
;
RFC
2420
;
NIST
2001
]
)
,
incluso
para
los
potenciales
intrusos
)
.
Evidentemente
,


si
todo
el
mundo
conoce
el
m√©todo
utilizado
para
codificar
los
datos
,
entonces
deber√°
existir


alg√∫n
tipo
de
informaci√≥n
secreta
que
impida
a
un
intruso
descifrar
los
datos
transmitidos
:


aqu√≠
es
donde
entran
en
acci√≥n
las
claves
.


En
la
Figura
8.2
Alicia
proporciona
una
clave
,
KA
,
una
cadena
de
n√∫meros
o
caracte-


res
como
entrada
para
el
algoritmo
de
cifrado
.
El
algoritmo
de
cifrado
toma
la
clave
y
el


mensaje
de
texto
en
claro
,
m
,
como
entrada
y
genera
el
texto
cifrado
como
salida
.
La
nota-


ci√≥n
KA(m
)
hace
referencia
al
formato
en
texto
cifrado
(
cifrado
utilizando
la
clave
KA
)


correspondiente
al
mensaje
de
texto
en
claro
,
m.
El
algoritmo
de
cifrado
real
con
el
que
se


vaya
a
utilizar
la
clave
KA
resultar√°
evidente
dentro
del
contexto
.
De
forma
similar
,


Benito
proporcionar√°
una
clave
,
KB
,
al
algoritmo
de
descifrado
,
que
toma
el
texto
cifrado


y
la
clave
de
Benito
como
entrada
y
genera
como
salida
el
texto
en
claro
original
.
En
otras


palabras
,
si
Benito
recibe
un
mensaje
cifrado
KA(m
)
,
lo
descifra
realizando
el
c√°lculo


KB(KA(m
)
)
=
m.
En
los
sistemas
de
clave
sim√©trica
,
las
claves
de
Alicia
y
de
Benito
son


id√©nticas
y
deben
mantenerse
en
secreto
.
En
los
sistemas
de
clave
p√∫blica
,
se
emplea
una


pareja
de
claves
.
Una
de
las
claves
es
conocida
tanto
por
Benito
como
por
Alicia
(
de


hecho
es
conocida
por
todo
el
mundo
)
.
La
otra
clave
s√≥lo
es
conocida
por
Benito
o
por


Alicia
,
pero
no
por
ambos
.
En
las
siguiente
subsecciones
vamos
a
estudiar
los
sistemas
de


clave
sim√©trica
y
de
clave
p√∫blica
m√°s
detalladamente
.


8.2
‚Ä¢
PRINCIPIOS
DE
LA
CRIPTOGRAF√çA
657


Algoritmo


de
cifrado


Texto
cifrado


Canal


Tom√°s


Alicia
Benito


Algoritmo


de
descifrado


Texto
en
claro


Clave
:


clave


Texto
en
claro


KA
KB


Figura
8.2
‚Ä¢
Componentes
criptogr√°ficos
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6578.2.1
Criptograf√≠a
de
clave
sim√©trica


Todos
los
algoritmos
criptogr√°ficos
implican
sustituir
una
cosa
por
otra
;
por
ejemplo
,
se


toma
un
fragmento
de
texto
en
claro
y
luego
se
calcula
y
sustituye
por
el
texto
cifrado
apro-


piado
para
crear
el
mensaje
cifrado
.
Antes
de
estudiar
un
sistema
criptogr√°fico
moderno


basado
en
claves
,
entremos
primero
en
materia
estudiando
un
algoritmo
de
clave
sim√©trica


muy
simple
y
muy
antiguo
atribuido
a
Julio
C√©sar
,
y
que
se
conoce
con
el
nombre
de


cifrado
de
C√©sar
(
la
palabra
cifrado
se
emplea
a
menudo
para
designar
a
un
m√©todo
que


permite
encriptar
los
datos
)
.


Para
un
texto
en
espa√±ol
,
el
cifrado
de
C√©sar
funcionar√≠a
tomando
cada
letra
del
men-


saje
en
claro
y
sustituy√©ndola
por
la
letra
que
est√°
k
posiciones
por
detr√°s
en
el
alfabeto
(
vol-


viendo
al
principio
una
vez
que
se
llega
al
final
;
es
decir
,
haciendo
que
a
la
letra
z
la
siga
la


letra
a
)
.
Por
ejemplo
,
si
k
=
3
,
entonces
la
letra
a
del
texto
en
claro
se
convertir√°
en
la
letra
d


en
el
texto
cifrado
;
la
letra
b
de
un
texto
en
claro
se
convertir√°
en
la
letra
e
en
el
texto


cifrado
,
y
as√≠
sucesivamente
.
Aqu√≠
,
el
propio
valor
de
k
sirve
como
clave
.
Por
ejemplo
,
el


mensaje
de
texto
en
claro
‚Äú
benito
,
te
quiero.alicia
‚Äù
se
transformar√≠a
en
‚Äú
ehqlwr
,


whtxlhur.dolfld
‚Äù
en
el
texto
cifrado
.
Aunque
el
texto
cifrado
parece
una
sucesi√≥n
de


letras
sin
sentido
,
en
realidad
no
se
tardar√≠a
mucho
en
romper
el
c√≥digo
si
se
sabe
que
se
est√°


utilizando
el
cifrado
de
C√©sar
,
ya
que
s√≥lo
hay
25
posibles
valores
de
clave
.


Una
mejora
del
cifrado
de
C√©sar
ser√≠a
el
cifrado
monoalfab√©tico
,
que
tambi√©n
susti-


tuye
una
letra
del
alfabeto
por
otra
.
Sin
embargo
,
en
lugar
de
efectuar
esas
sustituciones


seg√∫n
una
patr√≥n
regular
(
por
ejemplo
,
utilizando
un
desplazamiento
k
igual
para
todas
las


letras
)
,
cualquier
letra
puede
sustituirse
por
cualquier
otra
,
siempre
que
cada
una
tenga
una


√∫nica
letra
y
viceversa
.
La
regla
de
sustituci√≥n
de
la
Figura
8.3
muestra
una
posible
codifi-


caci√≥n
para
el
texto
en
claro
.


El
mensaje
de
texto
en
claro
‚Äú
benito
,
te
quiero.alicia
‚Äù
se
convierte
en
‚Äú
ncj-


suk
,
uc
pyscok.mgsbsm
‚Äù
.
De
nuevo
,
como
en
el
caso
del
cifrado
de
C√©sar
,
esto
parece


una
serie
de
letras
sin
sentido
.
El
cifrado
monoalfab√©tico
es
desde
luego
mejor
que
el
cifrado


de
C√©sar
,
en
el
sentido
de
que
existen
26
!
(
del
orden
de
10
26
)
posibles
parejas
de
letras
en


lugar
de
las
25
posibles
parejas
que
el
cifrado
de
C√©sar
proporciona
.
Un
ataque
por
fuerza


bruta
que
consistiera
en
probar
todas
las
10
26
posibles
parejas
requerir√≠a
demasiado
trabajo


como
para
considerarlo
una
forma
factible
de
romper
el
algoritmo
de
cifrado
y
decodificar
el


mensaje
.
Sin
embargo
,
el
an√°lisis
estad√≠stico
del
idioma
utilizado
en
el
texto
en
claro
,
por


ejemplo
,
saber
que
las
letras
e
y
a
son
las
letras
que
m√°s
frecuentemente
aparecen
en
un
texto


t√≠pico
en
espa√±ol
(
representando
aproximadamente
el
14
y
el
12
por
ciento
,
respectiva-


mente
)
,
y
saber
que
existen
determinadas
combinaciones
de
dos
y
tres
letras
que
aparecen


muy
frecuentemente
juntas
(
por
ejemplo
,
‚Äú
se
‚Äù
,
‚Äú
es
‚Äù
‚Äú
re
‚Äù
,
‚Äú
la
‚Äù
‚Äú
al
‚Äù
,
etc.
)
puede
romper
de


forma
relativamente
f√°cil
este
c√≥digo
.
Si
el
intruso
tiene
un
conocimiento
acerca
del
posible


contenido
del
mensaje
,
entonces
es
todav√≠a
m√°s
f√°cil
romper
el
c√≥digo
.
Por
ejemplo
,
si
el


intruso
Tom√°s
es
el
esposo
de
Alicia
y
sospecha
que
√©sta
 
tiene
una
relaci√≥n
sentimental
con


Benito
,
entonces
podr√≠a
deducir
que
los
nombres
‚Äú
benito
‚Äù
y
‚Äú
alicia
‚Äù
aparecer√°n
en
el
texto
.


658
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Letras
texto
en
claro
:


Letras
texto
cifrado
:


Figura
8.3
‚Ä¢
Cifrado
monoalfab√©tico
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
658Si
Tom√°s
estuviera
seguro
de
que
esos
dos
nombres
aparecen
en
el
texto
cifrado
y
dispusiera


de
una
copia
del
mensaje
de
texto
cifrado
de
ejemplo
que
hemos
proporcionado
anterior-


mente
,
entonces
podr√≠a
determinar
inmediatamente
doce
de
las
26
parejas
de
letras
,
lo
que


implica
reducir
seg√∫n
un
factor
de
10
15
menos
posibilidades
que
habr√≠a
que
comprobar


mediante
un
m√©todo
de
fuerza
bruta
.
De
hecho
,
si
Tom√°s
sospechara
que
Alicia
le
est√°
enga-


√±ando
,
tambi√©n
esperar√≠a
encontrar
algunas
otras
palabras
seleccionadas
dentro
del
mensaje
.


Al
a
 
h
o
r
a
 
d
e
 
c
o
n
s
i
d
e
r
a
r
 
l
o
 
f
√°
c
i
l
 
q
u
e
 
p
u
e
d
e
 
s
e
r
 
q
u
e
 
T
o
m
√°
s
 
r
o
m
p
a
 
e
l
 
e
s
q
u
e
m
a
 
d
e
 
c
i
f
r
a
d
o


utilizado
por
Benito
y
Alicia
,
podemos
distinguir
tres
escenarios
distintos
dependiendo
de
la


informaci√≥n
de
la
que
disponga
el
intruso
.


‚Ä¢
Ataque
de
s√≥lo
texto
cifrado
.
En
algunos
casos
,
el
intruso
puede
tener
acceso
√∫nicamente


al
texto
cifrado
interceptado
,
sin
disponer
de
informaci√≥n
segura
acerca
del
contenido
del


mensaje
en
claro
.
Ya
hemos
visto
c√≥mo
el
an√°lisis
estad√≠stico
puede
ayudarnos
a
realizar


un
ataque
de
s√≥lo
texto
cifrado
al
esquema
de
cifrado
.


‚Ä¢
Ataque
de
texto
en
claro
conocido
.
Anteriormente
hemos
visto
que
si
Tom√°s
estuviera


seguro
,
de
alguna
manera
,
de
que
las
palabras
‚Äú
benito
‚Äù
y
‚Äú
alicia
‚Äù
aparecen
en
el
mensaje


de
texto
cifrado
,
entonces
podr√≠a
haber
determinado
las
parejas
(
texto
en
claro
,
texto


cifrado
)
para
las
letras
a
,
l
,
i
,
c
,
b
,
e
,
n
,
t
y
o.
Tom√°s
tambi√©n
podr√≠a
haber
sido
lo
sufi-


cientemente
afortunado
como
para
haber
grabado
todas
las
transmisiones
de
texto
cifrado


y
luego
encontrar
en
una
hoja
de
papel
la
propia
versi√≥n
descifrada
por
Alicia
de
una
de


las
transmisiones
cifradas
.
Cuando
un
intruso
conoce
alguna
de
las
parejas
(
texto
en


claro
,
texto
cifrado
)
,
decimos
que
se
trata
de
un
ataque
de
texto
en
claro
conocido
al


esquema
de
cifrado
.


‚Ä¢
Ataque
de
texto
en
claro
seleccionado
.
En
un
ataque
de
texto
en
claro
seleccionado
,
el


intruso
tiene
la
posibilidad
de
elegir
el
mensaje
de
texto
en
claro
y
obtener
su
correspon-


diente
texto
cifrado
.
Para
los
algoritmos
de
cifrado
simples
que
hemos
visto
ahora
,
si


Tom√°s
pudiera
hacer
que
Alicia
enviara
el
mensaje
‚Äú
Es
extra√±o
mojar
queso
en


la
cerveza
o
probar
whisky
de
garrafa
‚Äù
podr√≠a
romper
completamente
el


esquema
de
cifrado
.
Pronto
veremos
que
,
para
t√©cnicas
de
cifrado
m√°s
sofisticadas
,
un


ataque
de
texto
en
claro
seleccionado
no
implica
necesariamente
que
la
t√©cnica
de
cifrado


pueda
ser
rota
.


Hace
quinientos
a√±os
se
invento
una
t√©cnica
denominada
cifrado
polialfab√©tico
,
que


permit√≠a
mejorar
el
cifrado
monoalfab√©tico
.
La
idea
subyacente
al
cifrado
polialfab√©tico
es


utilizar
varios
cifrados
monoalfab√©ticos
,
utilizando
un
cifrado
monoalfab√©tico
espec√≠fico


para
codificar
cada
letra
situada
en
una
posici√≥n
espec√≠fica
dentro
del
mensaje
de
texto
en


claro
.
De
ese
modo
,
una
misma
letra
que
aparezca
en
diferentes
posiciones
dentro
del
men-


saje
en
claro
se
podr√≠a
codificar
de
forma
distinta
cada
vez
.
En
la
Figura
8.4
se
muestra
un


ejemplo
de
un
esquema
de
cifrado
polialfab√©tico
.
Est√°
compuesto
por
dos
cifrados
de
C√©sar


(
con
k
=
5
y
k
=
19
)
,
mostrados
en
sendas
filas
.
Podr√≠amos
decidir
utilizar
estos
dos
cifrados


de
C√©sar
,
C1
y
C2
,
seg√∫n
el
patr√≥n
repetitivo
C
1
,
C1
,
C2
,
C1
,
C2
.
De
este
modo
,
la
primera
y


la
segunda
letras
del
texto
en
claro
se
codificar√≠an
utilizando
C
1
,
la
tercera
aplicando
C
2
,
la


cuarta
utilizando
C1
y
la
quinta
utilizando
C2
.
A
continuaci√≥n
el
patr√≥n
se
repite
,
lo
que
har√≠a


que
la
sexta
letra
se
codificara
utilizando
C1
,
la
s√©ptima
con
C1
,
y
as√≠
sucesivamente
.
As√≠
,
el


mensaje
de
texto
en
claro
‚Äú
benito
,
te
quiero
.
‚Äù
tendr√≠a
el
equivalente
de
texto
cifrado


‚Äú
gjgnmt
,
yx
vnnjkt
.
‚Äù
Observe
que
la
primera
e
del
mensaje
de
texto
en
claro
se
cifra


utilizando
C1
,
mientras
que
la
segunda
e
se
cifra
utilizando
C
2
.
En
este
ejemplo
,
la
‚Äú
clave
‚Äù


8.2
‚Ä¢
PRINCIPIOS
DE
LA
CRIPTOGRAF√çA
659


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
659de
cifrado
y
de
descifrado
es
el
propio
conocimiento
de
los
dos
cifrados
de
C√©sar


(
k
=
5
,
k
=
19
)
y
del
patr√≥n
C1
,
C1
,
C2
,
C1
,
C2
.


Cifrado
de
bloque


Avancemos
ahora
hacia
tiempos
m√°s
modernos
y
veamos
c√≥mo
se
lleva
a
cabo
hoy
d√≠a
el


cifrado
de
clave
sim√©trica
.
Existen
dos
clases
generales
de
t√©cnicas
de
cifrado
sim√©trico
:


cifrados
de
flujo
y
cifrados
de
bloque
.
Examinaremos
brevemente
los
cifrados
de
flujo
en


la
Secci√≥n
8.7
cuando
investiguemos
la
seguridad
en
las
redes
LAN
inal√°mbricas
.
En


esta
secci√≥n
,
nos
centraremos
en
los
cifrados
de
bloque
que
se
emplean
en
muchos
protoco-


los
seguros
de
Internet
,
incluyendo
PGP
(
para
correo
electr√≥nico
seguro
)
,
SSL
(
para
dotar


de
seguridad
a
las
conexiones
TCP
)
e
IPsec
(
para
dotar
de
seguridad
al
transporte
de
la


capa
de
red
)
.


En
un
cifrado
de
bloque
,
el
mensaje
que
hay
que
cifrar
se
procesa
en
bloques
de
k
bits
.


Por
ejemplo
,
si
k
=
64
,
entonces
el
mensaje
se
descompone
en
bloques
de
64
bits
y
cada
blo-


que
se
cifra
de
forma
independiente
.
Para
codificar
un
bloque
,
el
sistema
de
cifrado
asigna


una
correspondencia
uno-a-uno
,
con
el
fin
de
asignar
el
bloque
de
k
bits
de
texto
en
claro
a


un
bloque
de
k
bits
de
texto
cifrado
.
Veamos
un
ejemplo
.
Suponga
que
k
=
3
,
de
modo
que
el


cifrado
de
bloque
asigna
a
cada
entrada
de
3
bits
(
texto
en
claro
)
una
salida
de
3
bits
(
texto


cifrado
)
.
En
la
Tabla
8.1
se
proporciona
una
posible
de
estas
correspondencias
.
Observe
que


se
trata
de
una
aplicaci√≥n
uno-a-uno
,
es
decir
,
existe
una
salida
diferente
para
cada
entrada
.


Este
cifrado
de
bloque
descompone
el
mensaje
en
bloques
de
3
bits
y
cifra
cada
bloque
de


acuerdo
con
la
correspondencia
anterior
.
Puede
verificar
que
si
se
cifra
el
mensaje


010110001111
se
obtiene
como
resultado
101000111001
.


Continuando
con
este
ejemplo
de
bloque
de
3
bits
,
observe
que
la
correspondencia
de
la


Tabla
8.1
es
simplemente
una
asignaci√≥n
de
entre
las
muchas
posibles
.
¬ø
Cu√°ntas
posibles


correspondencias
existen
?
Para
responder
a
esta
cuesti√≥n
simplemente
observe
que
una


correspondencia
no
es
otra
cosa
que
una
permutaci√≥n
de
todas
las
posibles
entradas
.
Existen


23
(=
8)
posibles
entradas
(
enumeradas
bajo
las
columnas
etiquetadas
como
Entrada
)
.
Estas


ocho
entradas
pueden
permutarse
en
8
!
=
40.320
formas
distintas
.
Dado
que
cada
una
de


estas
permutaciones
especifica
una
correspondencia
,
habr√°
40.320
posibles
corresponden-


cias
.
Podemos
interpretar
cada
una
de
estas
correspondencias
como
una
clave
:
si
Alicia
y


Benito
conocen
simult√°neamente
la
correspondencia
(
la
clave
)
,
podr√°n
cifrar
y
descifrar


los
mensajes
que
se
intercambien
.


El
ataque
por
fuerza
bruta
a
este
sistema
de
cifrado
consistir√≠a
en
tratar
de
descifrar
un


texto
utilizando
todas
las
correspondencias
posibles
.
Puesto
que
s√≥lo
existen
40.320
corres-


pondencias
(
cuando
k
=
3
)
,
esto
puede
llevarse
a
cabo
r√°pidamente
con
cualquier
PC
de


escritorio
.
Para
evitar
los
ataques
por
fuerza
bruta
,
los
sistemas
de
cifrado
de
bloque
nor-


malmente
utilizan
bloques
de
mucho
mayor
tama√±o
,
compuestos
de
k
=
64
bits
o
incluso


mayores
.
Observe
que
el
n√∫mero
de
correspondencias
posibles
para
un
cifrado
cualquiera


660
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Letras
texto
en
claro
:
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z


C1(k
=
5
):


C2(k
=
19
):


f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
a
b
c
d
e


t
u
v
w
x
y
z
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s


Figura
8.4
‚Ä¢
Cifrado
polialfab√©tico
utilizando
dos
cifrados
de
C√©sar
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6608.2
‚Ä¢
PRINCIPIOS
DE
LA
CRIPTOGRAF√çA
661


Entrada
Salida
Entrada
Salida


000
110
100
011


001
111
101
010


010
101
110
000


011
100
111
001


Tabla
8.1
‚Ä¢
Un
cifrado
de
bloque
espec√≠fico
de
3
bits
.


de
bloques
de
k
bits
es
de
2k
!
,
que
es
un
valor
astron√≥mico
incluso
para
valores
moderados


de
k
(
como
por
ejemplo
k
=
64
)
.


Aunque
los
cifrados
de
bloque
de
tabla
completa
,
como
el
que
acabamos
de
descri-


bir
,
pueden
producir
esquemas
de
cifrado
de
clave
sim√©trica
robustos
,
incluso
con
valo-


res
moderados
de
k
,
lamentablemente
resultan
dif√≠ciles
de
implementar
.
Para
k
=
64
y


una
correspondencia
determinada
,
Alicia
y
Benito
necesitar√≠an
mantener
una
tabla
con


264
valores
de
entrada
,
lo
que
es
una
tarea
imposible
.
Adem√°s
,
si
Alicia
y
Benito
quisieran


cambiar
de
clave
,
ambos
tendr√≠an
que
volver
a
generar
la
tabla
.
Por
tanto
,
la
utilizaci√≥n
de


un
cifrado
de
bloque
de
tabla
completa
que
proporcione
correspondencias
predeterminadas


entre
todas
las
entradas
y
las
salidas
(
como
en
el
ejemplo
anterior
)
resulta
simplemente


impracticable
.


En
lugar
de
ello
,
los
sistemas
de
cifrado
de
bloque
suelen
utilizar
funciones
que
simu-


lan
la
generaci√≥n
de
tablas
aleatoriamente
permutadas
.
En
la
Figura
8.5
se
muestra
un
ejem-


plo
(
adaptado
de
[
Kaufman
1995
]
)
de
una
funci√≥n
de
este
tipo
para
k
=
64
.
La
funci√≥n


descompone
en
primer
lugar
el
bloque
de
64
bits
en
ocho
fragmentos
,
estando
cada
frag-


mento
compuesto
por
8
bits
.
Cada
fragmento
de
8
bits
se
procesa
mediante
una
tabla
de
8


por
8
bits
,
que
tiene
un
tama√±o
manejable
.
Por
ejemplo
,
el
primer
fragmento
se
procesa


Salida
de
64
bits


Bucle


de
n


ciclos


8
bits


8
bits


T1


8
bits


8
bits


T2


8
bits


8
bits


T3


8
bits


Entrada
de
64
bits


8
bits


T4


8
bits


8
bits


T5


8
bits


8
bits


T6


8
bits


8
bits


T7


8
bits


8
bits


T8


Aleatorizador
de
64
bits


Figura
8.5
‚Ä¢
Ejemplo
de
un
cifrado
de
bloque
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
661mediante
la
tabla
designada
como
T
1
.
A
continuaci√≥n
,
los
8
fragmentos
de
salida
se
recom-


ponen
en
un
bloque
de
64
bits
.
Las
posiciones
de
los
64
bits
del
bloque
a
continuaci√≥n
se


aleatorizan
(
permutan
)
para
generar
una
salida
de
64
bits
.
Esta
salida
se
realimenta
hacia
la


entrada
de
64
bits
,
donde
comienza
un
nuevo
ciclo
.
Despu√©s
de
n
ciclos
como
√©ste
,
la
fun-


ci√≥n
proporciona
un
bloque
de
64
bits
de
texto
cifrado
.
El
prop√≥sito
de
los
distintos
ciclos
es


hacer
que
cada
bit
de
entrada
afecte
a
la
mayor√≠a
(
si
no
a
todos
)
de
los
bits
de
salida
finales


(
si
s√≥lo
se
utilizara
un
ciclo
,
cada
bit
de
entrada
dado
s√≥lo
afectar√≠a
a
8
de
los
64
bits
de


salida
)
.
La
clave
para
este
algoritmo
de
cifrado
de
bloque
estar√≠a
compuesta
por
las
ocho


tablas
de
permutaci√≥n
(
asumiendo
que
la
funci√≥n
de
aleatorizaci√≥n
sea
de
dominio
p√∫blico
)
.


Hoy
d√≠a
existen
varios
sistemas
de
cifrado
de
bloque
populares
,
incluyendo
DES
(
Data


Encryption
Standard
,
Est√°ndar
de
cifrado
de
datos
)
,
3DES
y
AES
(
Advanced
Encryption


Standard
,
Est√°ndar
avanzado
de
cifrado
)
.
Cada
uno
de
estos
est√°ndares
utiliza
funciones
en


lugar
de
tablas
predeterminadas
,
seg√∫n
las
ideas
expuestas
en
la
Figura
8.5
(
aunque
son
m√°s


complicadas
y
espec√≠ficas
de
cada
sistema
de
cifrado
)
.
Cada
uno
de
estos
algoritmos
utiliza


tambi√©n
una
cadena
de
bits
como
clave
.
Por
ejemplo
,
DES
emplea
bloques
de
64
bits
con


una
clave
de
56
bits
.
AES
utiliza
bloques
de
128
bits
y
puede
operar
con
claves
de
128
,
192


y
256
bits
de
longitud
.
La
clave
de
un
algoritmo
determina
las
‚Äú
mini-tablas
‚Äù
espec√≠ficas
de


asignaci√≥n
y
permutaci√≥n
dentro
del
algoritmo
.
El
ataque
por
fuerza
bruta
a
cada
uno


de
estos
sistemas
de
cifrado
consistir√≠a
en
ir
aplicando
sucesivamente
todas
las
claves
,


usando
el
algoritmo
de
descifrado
de
cada
una
.
Observe
que
con
una
longitud
de
clave
igual


a
n
,
existen
2
n
claves
posibles
.
NIST
[
NIST
2001
]
estima
que
una
m√°quina
que
pudiera


romper
el
algoritmo
DES
de
56
bits
en
un
segundo
(
es
decir
,
que
pudiera
probar
en
un


segundo
las
256
claves
)
necesitar√≠a
aproximadamente
149
trillones
de
a√±os
para
romper
una


clave
AES
de
128
bits
.


Encadenamiento
de
bloques
cifrados


En
las
aplicaciones
de
redes
de
computadoras
,
normalmente
es
necesario
cifrar
mensajes
de


gran
tama√±o
(
o
largos
flujos
de
datos
)
.
Si
aplicamos
un
cifrado
de
bloques
como
el
descrito
,


descomponiendo
simplemente
el
mensaje
en
bloques
de
k
bits
y
cifrando
independiente-


mente
cada
bloque
,
aparece
un
problema
bastante
sutil
pero
de
gran
importancia
.
Para
ver
en


qu√©
consiste
,
observe
que
dos
o
m√°s
de
los
bloques
del
texto
en
claro
podr√≠an
ser
id√©nticos
.
Por


ejemplo
,
el
texto
en
claro
en
dos
o
m√°s
bloques
podr√≠a
ser
‚Äú
HTTP/1.1
‚Äù
.
Para
estos
bloques


id√©nticos
,
el
cifrado
de
bloque
producir√≠a
,
por
supuesto
,
el
mismo
texto
cifrado
.
De
ese


modo
,
un
atacante
podr√≠a
posiblemente
adivinar
el
texto
en
claro
cuando
viera
bloques
de


texto
cifrado
id√©nticos
y
podr√≠a
incluso
ser
capaz
de
descifrar
el
mensaje
completo
identifi-


cando
bloques
de
texto
cifrado
id√©nticos
y
utilizando
el
conocimiento
acerca
de
la
estructura


de
protocolos
subyacente
[
Kaufman
1995
]
.


Para
resolver
este
problema
,
podemos
introducir
cierta
aleatoriedad
en
el
texto


cifrado
,
de
modo
que
id√©nticos
bloques
de
texto
en
claro
produzcan
bloques
de
texto


cifrado
diferentes
.
Para
explicar
esta
idea
,
sea
m(i
)
el
i-√©simo
bloque
de
texto
en
claro
,
sea


c(i
)
el
i-√©simo
bloque
de
texto
cifrado
y
sea
a
/H17053b
la
operaci√≥n
OR-exclusiva
(
XOR
)
de


dos
cadenas
de
bits
,
a
y
b.
(
Recuerde
que
0
/H170530
=
1
/H170531
=
0
y
que
0
/H170531
=
1
/H170530
=
1
,
y
que


la
operaci√≥n
XOR
de
dos
cadenas
de
bits
se
realiza
bit
por
bit
.
As√≠
,
por
ejemplo
,
10101010


/H1705311110000
=
01011010
.
)
Asimismo
,
designaremos
mediante
KS
al
algoritmo
de
encripta-


ci√≥n
de
bloque
cifrado
con
clave
S.
La
idea
b√°sica
es
la
siguiente
:
el
emisor
genera
un


n√∫mero
aleatorio
de
k
bits
r(i
)
para
el
i-√©simo
bloque
y
calcula
c(i
)
=
KS(m(i)/H17053r(i
)
)
.


662
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6628.2
‚Ä¢
PRINCIPIOS
DE
LA
CRIPTOGRAF√çA
663


Observe
que
se
selecciona
un
nuevo
n√∫mero
aleatorio
de
k
bits
para
cada
bloque
.
El
emi-


sor
env√≠a
entonces
c(1
)
,
r(1
)
,
c(2
)
,
r(2
)
,
c(3
)
,
r(3
)
,
etc.
Puesto
que
el
receptor
recibe
c(i
)
y


r(i
)
puede
recuperar
cada
bloque
del
texto
en
claro
calculando
m(i
)
=
KS(c(i
)
)
/H17053r(i
)
.
Es


importante
observar
que
,
aunque
r(i
)
se
env√≠e
sin
cifrar
y
por
tanto
podr√≠a
ser
husmeado


por
Tom√°s
,
√©ste
no
podr√°
obtener
el
texto
en
claro
m(i
)
,
ya
que
no
conoce
la
clave
KS
.


Observe
tambi√©n
que
si
dos
bloques
de
texto
en
claro
m(i
)
y
m
(
j
)
son
iguales
,
los
corres-


pondientes
bloques
en
texto
cifrado
c(i
)
y
c
(
j
)
ser√°n
diferentes
(
siempre
y
cuando
los


n√∫meros
aleatorios
r(i
)
y
r
(
j
)
sean
distintos
,
lo
que
ocurre
con
una
muy
alta
probabilidad
)
.


Por
ejemplo
,
considere
el
sistema
de
cifrado
de
bloques
de
3
bits
de
la
Tabla
8.1
.


Suponga
que
el
texto
en
claro
es
010010010
.
Si
Alicia
cifra
esta
secuencia
directamente
sin


incluir
ninguna
aleatoriedad
,
el
texto
cifrado
resultante
ser√°
101101101
.
Si
Tom√°s
captura
el


texto
cifrado
,
dado
que
cada
uno
de
los
tres
bloques
de
cifrado
es
igual
,
podr√°
suponer


correctamente
que
cada
uno
de
los
tres
bloques
de
texto
en
claro
son
tambi√©n
coincidentes
.


Ahora
suponga
que
en
lugar
de
ello
Alicia
genera
los
bloques
aleatorios
r(1
)
=
001
,
r(2
)


=
111
y
r(3
)
=
100
y
aplica
la
t√©cnica
anteriormente
explicada
para
generar
el
texto
cifrado


c(1
)
=
100
,
c(2
)
=
010
y
c(3
)
=
000
.
Observe
que
ahora
los
tres
bloques
de
texto
cifrado
son


distintos
incluso
aunque
los
bloques
de
texto
en
claro
son
iguales
.
Alicia
env√≠a
entonces


c(1
)
,
r(1
)
,
c(2
)
y
r(2
)
.
El
lector
puede
verificar
que
Benito
podr√°
obtener
el
texto
en
claro


original
utilizando
la
clave
compartida
KS
.


Alg√∫n
lector
m√°s
astuto
habr√°
deducido
que
el
introducir
la
aleatoriedad
resuelve
un


problema
,
pero
crea
otro
:
en
concreto
,
Alicia
tiene
que
transmitir
el
doble
de
bits
que
antes
.


De
hecho
,
por
cada
bit
de
cifrado
,
Alicia
debe
ahora
enviar
tambi√©n
un
bit
aleatorio
,
dupli-


cando
as√≠
el
ancho
de
banda
requerido
.
Si
lo
que
queremos
es
estar
en
misa
y
repicando
a
la


vez
,
los
sistemas
de
cifrado
de
bloque
suelen
utilizar
una
t√©cnica
denominada
Encadena-


miento
de
bloques
cifrados
(
CBC
,
Cipher
Block
Chaining
)
.
La
idea
b√°sica
consiste
en


enviar
s√≥lo
un
valor
aleatorio
junto
con
el
primer
mensaje
,
y
hacer
que
el
emisor
y
el
recep-


tor
utilicen
los
bloques
codificados
calculados
,
en
lugar
de
los
subsiguientes
n√∫meros
alea-


torios
.
Espec√≠ficamente
,
CBC
opera
como
sigue
:


1
.
Antes
de
cifrar
el
mensaje
(
o
el
flujo
de
datos
)
,
el
emisor
genera
una
cadena
aleatoria
de


k
bits
,
denominada
Vector
de
inicializaci√≥n
(
IV
,
Initialization
Vector
)
.
Denotaremos
a


este
vector
de
inicializaci√≥n
mediante
c(0
)
.
El
emisor
env√≠a
el
vector
IV
al
receptor
sin


cifrar
.


2
.
Para
el
primer
bloque
,
el
emisor
calcula
m(1
)
/H17053c(0
)
,
es
decir
,
calcula
la
operaci√≥n
OR


exclusiva
del
primer
bloque
de
texto
en
claro
con
IV
.
A
continuaci√≥n
,
introduce
el
resul-


tado
en
el
algoritmo
de
cifrado
de
bloque
,
para
obtener
el
correspondiente
bloque
de


texto
cifrado
;
es
decir
,
c(1
)
=
KS(m(1
)
/H17053c(0
)
)
.
El
emisor
env√≠a
despu√©s
el
bloque


cifrado
c(1
)
al
receptor
.


3
.
Para
el
i-√©simo
bloque
,
el
emisor
genera
el
i-√©simo
bloque
de
texto
cifrado
utilizando
la


f√≥rmula
c(i
)
=
KS(m(i
)
/H17053c(i
/H110021
)
)
.


Examinemos
ahora
algunas
de
las
consecuencias
de
este
m√©todo
.
En
primer
lugar
,
el


receptor
continuar√°
pudiendo
recuperar
el
mensaje
original
.
De
hecho
,
cuando
el
receptor


reciba
c(i
)
,
descifrar√°
el
mensaje
con
KS
para
obtener
s(i
)
=
m(i
)
/H17053c(i
‚Äì
1
)
;
puesto
que


el
receptor
tambi√©n
conoce
c(i
‚Äì
1
)
,
puede
entonces
obtener
el
bloque
de
texto
en
claro
a
par-


tir
de
la
f√≥rmula
m(i
)
=
s(i
)
/H17053c(i
‚Äì
1
)
.
En
segundo
lugar
,
incluso
si
dos
bloques
de
texto
en


claro
son
id√©nticos
,
los
textos
cifrados
correspondientes
ser√°n
(
casi
siempre
)
diferentes
.
En


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
663tercer
lugar
,
aunque
el
emisor
env√≠e
el
vector
IV
sin
cifrar
,
ning√∫n
intruso
podr√°
descifrar


los
bloques
de
texto
cifrado
dado
que
no
conocen
la
clave
secreta
,
S.
Por
√∫ltimo
,
el
emisor


s√≥lo
env√≠a
un
bloque
de
sobrecarga
(
el
vector
IV
)
,
con
lo
que
el
uso
de
ancho
de
banda
s√≥lo


se
incrementa
de
una
forma
pr√°cticamente
despreciable
,
asumiendo
que
estemos
utilizando


mensajes
de
gran
longitud
(
compuestos
de
centenares
de
bloques
)
.


Como
ejemplo
,
determinemos
ahora
el
texto
cifrado
para
el
sistema
de
cifrado
de
blo-


que
de
3
bits
de
la
Tabla
8.1
,
utilizando
como
texto
en
claro
010010001
y
como
vector
IV
=


c(0
)
=
001
.
En
primer
lugar
,
el
emisor
utiliza
el
vector
IV
para
calcular
c(1
)
=
KS(m(1
)
/H17053


c(0
)
)
=
100
y
a
continuaci√≥n
calcula
c(2
)
=
KS(m(2
)
/H17053c(1
)
)
=
KS(010
/H17053
100
)
=
000
y
c(3
)
=


KS(m(3
)
/H17053c(2
)
)
=
KS(010
/H17053000
)
=
101
.
El
lector
puede
verificar
que
el
receptor
,
cono-


ciendo
el
vector
IV
y
la
clave
KS
,
puede
recuperar
el
texto
en
claro
original
.


La
t√©cnica
CBC
tiene
una
importante
consecuencia
a
la
hora
de
dise√±ar
protocolos
de


red
seguros
:
necesitaremos
proporcionar
un
mecanismo
dentro
del
protocolo
para
transferir


el
vector
IV
desde
el
emisor
al
receptor
.
Posteriormente
en
el
cap√≠tulo
veremos
c√≥mo
se


hace
esto
en
diversos
protocolos
.


8.2.2
Cifrado
de
clave
p√∫blica


Durante
m√°s
de
2.000
a√±os
(
desde
la
√©poca
del
cifrado
de
C√©sar
hasta
la
d√©cada
de
1970
)
,
la


comunicaci√≥n
cifrada
requer√≠a
que
los
dos
interlocutores
que
se
estaban
comunicando
com-


partieran
una
clave
secreta
:
la
clave
sim√©trica
utilizada
para
el
cifrado
y
el
descifrado
.
Una


dificultad
con
esta
t√©cnica
es
que
ambas
partes
deben
acordar
de
alguna
manera
cu√°l
es
esa


clave
secreta
,
¬°
pero
el
hacer
eso
requiere
que
se
comuniquen
(
presumiblemente
de
forma


segura
)
!
Quiz√°
ambas
partes
podr√≠an
primero
reunirse
y
acordar
en
persona
cu√°l
es
esa
clave


(
por
ejemplo
,
dos
de
los
centuriones
de
C√©sar
podr√≠an
reunirse
en
una
termas
romanas
)
y
en


lo
sucesivo
comunicarse
mediante
un
m√©todo
de
cifrado
.
Sin
embargo
,
en
un
mundo
conec-


tado
en
red
,
los
interlocutores
que
se
est√°n
comunicando
pueden
no
llegar
a
encontrarse


nunca
de
forma
f√≠sica
,
y
puede
que
incluso
no
lleguen
a
conversar
excepto
a
trav√©s
de
la
red
.


¬ø
Es
posible
que
dos
partes
se
comuniquen
de
forma
cifrada
sin
conocer
de
antemano
una


clave
secreta
compartida
?
En
1976
Diffie
y
Hellman
[
Diffie
1976
]
inventaron
un
algoritmo


(
que
ahora
se
conoce
como
algoritmo
de
intercambio
de
claves
de
Diffie-Hellman
)
para


hacer
precisamente
eso
;
se
trata
de
un
enfoque
radicalmente
distinto
y
maravillosamente


elegante
para
las
comunicaciones
seguras
y
que
ha
conducido
al
desarrollo
de
los
sistemas


actuales
de
clave
p√∫blica
.
Como
veremos
en
breve
,
los
sistemas
criptogr√°ficos
de
clave


p√∫blica
disfrutan
tambi√©n
de
diversas
propiedades
muy
atractivas
que
los
hacen
√∫tiles
no


s√≥lo
para
el
cifrado
,
sino
tambi√©n
para
la
autenticaci√≥n
y
las
firmas
digitales
.
Es
intere-


sante
observar
que
recientemente
ha
salido
a
la
luz
que
unas
ideas
similares
a
las
de
[
Dif-


fie
1976
]
y
[
RSA
1978
]
hab√≠an
sido
desarrolladas
independientemente
a
principios
de
la


d√©cada
de
1970
en
una
serie
de
informes
secretos
elaborados
por
investigadores
del
Grupo


de
seguridad
de
electr√≥nica
y
comunicaciones
en
el
Reino
Unido
[
Ellis
1987
]
.
Como
a


menudo
suele
suceder
,
las
grandes
ideas
pueden
surgir
de
forma
independiente
en
muchos


lugares
distintos
;
afortunadamente
,
los
avances
relativos
a
los
sistemas
de
clave
p√∫blica


no
s√≥lo
tuvieron
lugar
en
privado
,
sino
tambi√©n
a
la
vista
del
p√∫blico
.


Conceptualmente
,
la
utilizaci√≥n
de
un
sistema
de
criptograf√≠a
de
clave
p√∫blica
es
muy


simple
.
Suponga
que
Alicia
quiere
comunicarse
con
Benito
.
Como
se
muestra
en
la
Figura


8.6
,
en
lugar
de
que
Benito
y
Alicia
compartan
una
√∫nica
clave
secreta
(
como
es
el
caso
en


los
sistemas
de
clave
sim√©trica
)
,
Benito
(
el
receptor
de
los
mensajes
de
Alicia
)
dispone
en
su


664
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
664lugar
de
dos
claves
:
una
clave
p√∫blica
que
est√°
disponible
para
todo
el
mundo
(
incluyendo
a


Tom√°s
el
intruso
)
y
una
clave
privada
que
s√≥lo
Benito
conoce
.
Utilizaremos
la
notaci√≥n
KB


+
y


KB


‚Äì
para
hacer
referencia
a
las
claves
p√∫blica
y
privada
de
Benito
,
respectivamente
.
Para
poder


comunicarse
con
Benito
,
Alicia
consulta
primero
la
clave
p√∫blica
de
Benito
y
luego
cifra
su


mensaje
,
m
,
destinado
a
Benito
utilizando
esa
clave
p√∫blica
de
Benito
y
un
algoritmo
de


cifrado
conocido
(
por
ejemplo
,
un
algoritmo
estandarizado
)
;
es
decir
,
Alicia
calcula
KB


+
(
m
)
.


Benito
recibe
el
mensaje
cifrado
de
Alicia
y
utiliza
su
clave
privada
y
un
algoritmo
de
desci-


frado
conocido
(
por
ejemplo
,
un
algoritmo
estandarizado
)
para
descifrar
el
mensaje
cifrado


de
Alicia
.
Es
decir
,
Benito
calcula
KB


‚Äì
(
KB


+
(
m
)
)
.
Como
veremos
m√°s
adelante
,
existen
t√©cnicas


y
algoritmos
de
cifrado
/
descifrado
para
seleccionar
claves
p√∫blicas
y
privadas
tales
que


KB


‚Äì
(
KB


+
(
m
)
)
=
m
;
es
decir
,
tales
que
al
aplicar
la
clave
p√∫blica
de
Benito
,
KB


+
,
a
un
mensaje
,
m


(
para
obtener
KB


+
(
m
)
)
,
y
aplicar
luego
la
clave
privada
de
Benito
,
KB


‚Äì
,
a
la
versi√≥n
cifrada
de


m
(
es
decir
,
calcular
KB


‚Äì
(
KB


+
(
m
)
)
)
se
vuelve
a
obtener
m.
Es
un
resultado
realmente
maravi-


lloso
.
De
esta
manera
,
Alicia
puede
utilizar
la
clave
de
Benito
que
est√°
p√∫blicamente
disponi-


ble
con
el
fin
de
enviar
un
mensaje
secreto
a
Benito
,
sin
que
ninguno
de
los
dos
tenga
que


distribuir
ninguna
clave
secreta
.
Como
veremos
enseguida
,
podemos
intercambiar
el
papel
de


la
clave
p√∫blica
y
la
clave
privada
y
obtener
el
mismo
resultado
;
es
decir
,
KB


‚Äì
(
KB


+
(
m
)
)
=
KB


+


(
KB


‚Äì
(
m
)
)
=
m.


La
utilizaci√≥n
de
la
criptograf√≠a
de
clave
p√∫blica
es
por
tanto
conceptualmente
muy
sim-


ple
.
Pero
puede
que
al
lector
le
surjan
inmediatamente
dos
preguntas
.
Un
primer
posible
pro-


blema
es
que
,
aunque
un
intruso
que
intercepte
el
mensaje
de
cifrado
de
Alicia
s√≥lo
obtendr√°


datos
sin
sentido
,
ese
intruso
conoce
tanto
la
clave
(
la
clave
p√∫blica
de
Benito
,
que
est√°
dis-


ponible
para
que
todo
el
mundo
la
vea
)
,
como
el
algoritmo
que
Alicia
ha
utilizado
para
el


cifrado
.
Tom√°s
podr√≠a
entonces
montar
un
ataque
de
texto
claro
conocido
,
utilizando
ese


algoritmo
de
cifrado
estandarizado
y
la
clave
de
cifrado
de
Benito
,
p√∫blicamente
disponible
,


para
codificar
cualquier
mensaje
que
desee
.
Tom√°s
tambi√©n
podr√≠a
intentar
,
por
ejemplo
,


codificar
mensajes
,
o
partes
de
mensajes
,
que
piense
que
Alicia
podr√≠a
enviar
,
con
el
fin
de


suplantarla
.
Obviamente
,
para
que
la
criptograf√≠a
de
clave
p√∫blica
pueda
funcionar
,
la
selec-


ci√≥n
de
claves
y
el
cifrado
/
descifrado
deben
hacerse
de
forma
tal
que
sea
imposible
(
o
al


menos
lo
suficientemente
dif√≠cil
como
para
ser
pr√°cticamente
imposible
)
para
un
intruso


determinar
la
clave
privada
de
Benito
o
descifrar
o
adivinar
de
alguna
otra
manera
el
men-


8.2
‚Ä¢
PRINCIPIOS
DE
LA
CRIPTOGRAF√çA
665


Algoritmo


de
cifrado


Texto


cifrado


Algoritmo


de
descifrado


Mensaje
en


texto
en
claro
,
m


Mensaje
en


texto
en
claro
,
m


Clave
de
descifrado
privada


m
=
KB


‚Äì
(
KB


+
(
m
)
)


KB


‚Äì


KB


+
(
m
)


Clave
de
cifrado
p√∫blicaKB


+


Figura
8.6
‚Ä¢
Criptograf√≠a
de
clave
p√∫blica
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
665saje
que
Alicia
le
ha
enviado
a
Benito
.
El
segundo
problema
potencial
es
que
dado
que
la


clave
de
cifrado
de
Benito
es
p√∫blica
,
cualquiera
puede
enviar
un
mensaje
cifrado
a
Benito
,


incluyendo
Alicia
o
alguien
que
se
haga
pasar
por
Alicia
.
Sin
embargo
,
en
el
caso
de
una


√∫nica
clave
secreta
compartida
,
√©ste
ya
no
ser√°
el
caso
puesto
que
nadie
puede
enviar
un


mensaje
cifrado
a
Benito
utilizando
la
clave
p√∫blicamente
disponible
de
√©ste
.
Es
necesaria


una
firma
digital
,
tema
que
estudiaremos
en
la
Secci√≥n
8.3
,
para
vincular
a
un
emisor
con
un


mensaje
.


RSA


Aunque
pueden
existir
muchos
algoritmos
que
se
correspondan
con
la
descripci√≥n
realizada
,


el
algoritmo
RSA
(
llamado
as√≠
por
sus
inventores
,
Ron
Rivest
,
Adi
Shamir
y
Leonard
Adle-


man
)
se
ha
convertido
casi
en
sin√≥nimo
de
la
criptograf√≠a
de
clave
p√∫blica
.
En
primer
lugar


vamos
a
ver
c√≥mo
funciona
RSA
y
luego
examinaremos
por
qu√©
funciona
.


RSA
hace
un
extenso
uso
de
las
operaciones
aritm√©ticas
m√≥dulo
n.
Por
ello
,
vamos
a


repasar
brevemente
la
aritm√©tica
modular
.
Recuerde
que
x
mod
n
simplemente
indica
el


resto
de
dividir
x
entre
n
;
as√≠
,
por
ejemplo
,
19
mod
5
=
4
.
En
la
aritm√©tica
modular
,
se
reali-


zan
las
operaciones
usuales
de
suma
,
multiplicaci√≥n
y
exponenciaci√≥n
.
Sin
embargo
,
el


resultado
de
cada
operaci√≥n
se
sustituye
por
el
resto
entero
que
se
obtiene
al
dividir
el
resul-


tado
entre
n.
La
realizaci√≥n
de
las
operaciones
de
suma
y
multiplicaci√≥n
en
aritm√©tica
modu-


lar
se
facilita
teniendo
en
cuenta
las
siguientes
f√≥rmulas
de
utilidad
:


[
(
a
mod
n
)
+
(
b
mod
n
)
]
mod
n
=
(
a
+
b
)
mod
n


[
(
a
mod
n
)
‚Äì
(
b
mod
n
)
]
mod
n
=
(
a
‚Äì
b
)
mod
n


[
(
a
mod
n
)
‚Ä¢
(
b
mod
n
)
]
mod
n
=
(
a
‚Ä¢
b
)
mod
n


Se
deduce
de
la
tercera
f√≥rmula
que
(
a
mod
n)d
mod
n
=
a
d
mod
n
,
que
es
una
identidad
que
,


como
pronto
veremos
,
resulta
muy
√∫til
.


Supongamos
ahora
que
Alicia
desea
enviar
a
Benito
un
mensaje
cifrado
con
RSA
,
como


se
muestra
en
la
Figura
8.6
.
En
esta
exposici√≥n
sobre
RSA
,
hay
que
tener
siempre
en
mente


que
un
mensaje
no
es
nada
m√°s
que
un
patr√≥n
de
bits
y
que
cada
patr√≥n
de
bits
puede
repre-


sentarse
de
manera
un√≠voca
mediante
un
n√∫mero
entero
(
junto
con
la
longitud
del
patr√≥n
de


bits
)
.
Por
ejemplo
,
suponga
un
mensaje
igual
al
patr√≥n
de
bits
1001
;
este
mensaje
puede


representarse
mediante
el
entero
decimal
9
.
Por
tanto
,
cifrar
un
mensaje
con
RSA
es
equiva-


lente
a
cifrar
el
n√∫mero
entero
√∫nico
que
representa
a
dicho
mensaje
.


En
RSA
existen
dos
componentes
interrelacionados
:


‚Ä¢L
a
 
e
l
e
c
c
i
√≥
n
 
d
e
 
l
a
s
 
c
l
a
v
e
s
 
p
√∫
b
l
i
c
a
 
y
 
p
r
i
v
a
d
a
.
 

‚Ä¢E
l
 
a
l
g
o
r
i
t
m
o
 
d
e
 
c
i
f
r
a
d
o
 
y
 
d
e
s
c
i
f
r
a
d
o
.
 

Para
generar
las
claves
RSA
p√∫blica
y
privada
,
Benito
lleva
a
cabo
los
pasos
siguientes
:


1
.
Elige
dos
n√∫meros
primos
grandes
,
p
y
q.
¬ø
C√≥mo
de
grandes
tienen
que
ser
p
y
q
?


Cuanto
m√°s
grandes
sean
estos
valores
,
m√°s
dif√≠cil
ser√°
romper
el
algoritmo
RSA
,
pero


tambi√©n
 
se
tardar√°
m√°s
en
realizar
la
codificaci√≥n
y
la
decodificaci√≥n
.
RSA
Laborato-


ries
recomienda
que
el
producto
de
p
por
q
sea
del
orden
de
1.024
bits
.
Si
desea
obtener


informaci√≥n
acerca
de
c√≥mo
determinar
n√∫meros
primos
grandes
,
consulte
[
Caldwell


2007
]
.


666
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6662
.
Calcula
n
=
pq
y
z
=
(
p
‚Äì
1)(q
‚Äì
1
)
.


3
.
Elige
un
n√∫mero
,
e
,
menor
que
n
,
que
no
tiene
ning√∫n
factor
com√∫n
(
distinto
de
1
)
con


z.
(
En
este
caso
,
se
dice
que
e
y
z
son
n√∫meros
primos
relativos
.
)
Se
emplea
la
letra
e


porque
este
valor
se
utilizar√°
en
el
cifrado
o
encriptaci√≥n
.
 

4
.
Determina
un
n√∫mero
,
d
,
tal
que
ed
‚Äì
1
es
divisible
de
forma
exacta
por
z
(
es
decir
,
su


resto
es
igual
a
cero
)
.
La
letra
d
se
emplea
porque
este
valor
se
utilizar√°
en
el
descifrado
.


Dicho
de
otra
forma
,
dado
e
,
seleccionamos
d
tal
que


ed
mod
z
=
1


5
.
La
clave
p√∫blica
que
Benito
pone
a
disposici√≥n
de
todo
el
mundo
,
KB


+
,
es
la
pareja
de


n√∫meros
(
n
,
e
)
;
su
clave
privada
,
KB


‚Äì
,
es
la
pareja
de
n√∫meros
(
n
,
d
)
.


El
cifrado
por
parte
de
Alicia
y
el
descifrado
que
lleva
a
cabo
Benito
se
realizan
como
sigue
:


‚Ä¢S
u
p
o
n
g
a
 
q
u
e
 
A
l
i
c
i
a
 
d
e
s
e
a
 
e
n
v
i
a
r
 
a
 
B
e
n
i
t
o
 
u
n
 
p
a
t
r
√≥
n
 
d
e
 
b
i
t
s
 
r
e
p
r
e
s
e
n
t
a
d
o
 
p
o
r
 
e
l
 
n
√∫
m
e
r
o


entero
m
(
con
m
<
n
)
.
Para
realizar
la
codificaci√≥n
,
Alicia
lleva
a
cabo
la
operaci√≥n
de
expo-


nenciaci√≥n
me
,
y
luego
calcula
el
resto
entero
que
se
obtiene
al
dividir
me
entre
n.
En
otras


palabras
,
el
valor
cifrado
,
c
,
del
mensaje
de
texto
en
claro
de
Alicia
,
m
,
es


c
=
me
mod
n


El
patr√≥n
de
bits
correspondiente
a
este
texto
cifrado
c
se
env√≠a
a
Benito
.


‚Ä¢P
a
r
a
 
d
e
s
c
i
f
r
a
r
 
e
l
 
m
e
n
s
a
j
e
 
d
e
 
t
e
x
t
o
 
c
i
f
r
a
d
o
 
r
e
c
i
b
i
d
o
,
 
c
,
Benito
hace
el
c√°lculo
siguiente
:


m
=
cd
mod
n


que
requiere
el
uso
de
su
clave
privada
(
n
,
d
)
.


Veamos
un
ejemplo
simple
de
RSA
.
Suponga
que
Benito
elige
p
=
5
y
q
=
7
.
(
Evidente-


mente
,
estos
valores
son
demasiado
peque√±os
como
para
ser
seguros
.
)
Entonces
,
n
=
35
y


z
=
24
.
Benito
selecciona
e
=
5
,
ya
que
5
y
24
no
tienen
factores
comunes
.
Por
√∫ltimo
,
Benito


elige
d
=
29
,
dado
que
5
/H1108029
‚Äì
1
(
es
decir
,
ed
‚Äì
1
)
es
divisible
de
forma
exacta
por
24
.
Beni-


to
hace
p√∫blicos
los
dos
valores
,
n
=
35
y
e
=
5
,
y
mantiene
en
secreto
el
valor
d
=
29
.
Obser-


vando
estos
dos
valores
p√∫blicos
,
supongamos
ahora
que
Alicia
quiere
enviar
a
Benito
las


letras
l
,
o
,
v
y
e.
Interpretando
cada
letra
como
un
n√∫mero
comprendido
entre
1
y
26
(
corres-


pondi√©ndose
la
a
con
el
1
y
la
z
con
el
26
)
,
Alicia
y
Benito
llevan
a
cabo
las
operaciones
de


cifrado
y
descifrado
mostradas
en
las
Tablas
8.2
y
8.3
,
respectivamente
.
Observe
que
,
en


este
ejemplo
,
consideramos
cada
una
de
las
cuatro
letras
como
un
mensaje
distinto
.
Un


ejemplo
m√°s
realista
ser√≠a
convertir
las
cuatro
letras
en
sus
representaciones
ASCII
de
8
bits


y
luego
cifrar
el
entero
correspondiente
al
patr√≥n
de
32
bits
resultante
.
(
Tal
ejemplo
m√°s
rea-


lista
genera
n√∫meros
que
son
demasiado
grandes
como
para
imprimirlos
aqu√≠
.
)


Dado
que
el
ejemplo
simple
de
las
Tablas
8.2
y
8.3
ha
dado
lugar
a
n√∫meros
extremada-


mente
grandes
y
,
puesto
que
como
hemos
visto
anteriormente
,
p
y
q
tendr√°n
ambos
longitu-


des
de
centenares
de
bits
,
esto
nos
lleva
a
plantearnos
varias
cuestiones
pr√°cticas
relativas
a


RSA
:
¬ø
c√≥mo
se
seleccionan
los
n√∫meros
primos
grandes
?
¬ø
C√≥mo
se
eligen
despu√©s
e
y
d
?


¬ø
C√≥mo
se
lleva
a
cabo
la
exponenciaci√≥n
con
n√∫meros
grandes
?
Un
an√°lisis
de
estas


importantes
cuestiones
queda
fuera
del
alcance
de
este
texto
,
pero
el
lector
puede
consultar


[
Kaufman
1995
]
y
las
referencias
que
incluye
para
conocer
m√°s
detalles
.


8.2
‚Ä¢
PRINCIPIOS
DE
LA
CRIPTOGRAF√çA
667


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
667Letra
de
texto
en
claro
m
:
representaci√≥n
num√©rica
m
e
Texto
cifrado
c
=
m
e
mod
n


l
12
248832
17


o
15
759375
15


v
22
5153632
22


e
5
3125
10


Tabla
8.2
‚Ä¢
Cifrado
RSA
realizado
por
Alicia
,
e
=
5
,
n
=
35
.


Texto
cifrado
cc
d
m
=
cd
mod
n
Letra
de
texto
en
claro


17
4819685721067509150915091411825223071697
12
l


15
127834039403948858939111232757568359375
15
o


22
851643319086537701956194499721106030592
22
v


10
1000000000000000000000000000000
5
e


Tabla
8.3
‚Ä¢
Descifrado
RSA
realizado
por
Benito
,
d
=
29
,
n
=
35
.


Claves
de
sesi√≥n


Tenemos
que
resaltar
aqu√≠
que
la
exponenciaci√≥n
requerida
por
RSA
es
un
proceso
que
con-


sume
bastante
tiempo
.
Por
el
contrario
,
DES
es
al
menos
100
veces
m√°s
r√°pido
en
software


y
entre
1.000
y
10.000
veces
m√°s
r√°pido
en
hardware
[
RSA
Fast
2007
]
.
Como
resultado
,
a


menudo
RSA
se
utiliza
en
la
pr√°ctica
en
combinaci√≥n
con
alg√∫n
otro
mecanismo
criptogr√°-


fico
de
clave
sim√©trica
.
Por
ejemplo
,
si
Alicia
desea
enviar
a
Benito
una
gran
cantidad
de


datos
cifrados
podr√≠a
hacer
lo
siguiente
:
primero
elegir√≠a
una
clave
para
codificar
los
pro-


pios
datos
;
esta
clave
se
conoce
como
clave
de
sesi√≥n
y
se
designa
mediante
KS
.
Alicia
tiene


que
comunicar
a
Benito
la
clave
de
sesi√≥n
,
ya
que
se
trata
de
la
clave
sim√©trica
compartida


que
ambos
utilizar√°n
con
un
sistema
de
cifrado
de
clave
sim√©trica
(
por
ejemplo
,
con
DES
o


AES
)
.
Alicia
cifra
la
clave
de
sesi√≥n
utilizando
la
clave
p√∫blica
de
Benito
,
es
decir
,
calcula


c
=
(
KS)e
mod
n.
Benito
recibe
la
clave
de
sesi√≥n
cifrada
mediante
RSA
,
c
,
y
la
descifra
para


obtener
la
clave
de
sesi√≥n
,
KS
.
De
este
modo
,
ahora
Benito
conoce
la
clave
de
sesi√≥n
que


Alicia
emplear√°
para
transferir
los
datos
cifrados
.


¬ø
Por
qu√©
funciona
RSA
?


El
cifrado
/
descifrado
de
RSA
parece
algo
un
poco
m√°gico
.
¬ø
Por
qu√©
despu√©s
de
aplicar
el


algoritmo
de
cifrado
y
luego
el
algoritmo
de
descifrado
se
recupera
el
mensaje
original
?


Para
comprender
por
qu√©
funciona
RSA
,
volvamos
a
fijarnos
en
la
ecuaci√≥n
n
=
pq
,
donde
p


y
q
son
los
n√∫meros
primos
grandes
utilizados
por
el
algoritmo
RSA
.


Recuerde
que
,
con
el
cifrado
RSA
,
cada
mensaje
(
representado
√∫nicamente
mediante


un
entero
)
,
m
,
se
eleva
a
la
potencia
e
utilizando
aritm√©tica
de
m√≥dulo
n
,
es
decir
,


c
=
me
mod
n


668
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
668El
descifrado
se
hace
elevando
este
valor
a
la
potencia
d
,
utilizando
de
nuevo
aritm√©tica
de


m√≥dulo
n.
El
resultado
de
un
paso
de
cifrado
seguido
de
un
paso
de
descifrado
ser√°
por


tanto
(
me
mod
n)d
mod
n
.
Veamos
ahora
qu√©
podemos
decir
acerca
de
este
valor
.
Como


hemos
dicho
anteriormente
,
una
propiedad
importante
de
la
aritm√©tica
modular
es
que


(
a
mod
n)d
mod
n
=
ad
mod
n
para
cualesquiera
valores
a
,
n
y
d.
Luego
utilizando
a
=
me
en


esta
propiedad
,
tenemos


(
me
mod
n)d
mod
n
=
med
mod
n


Por
tanto
,
queda
demostrar
que
med
mod
n
=
m.
Aunque
estamos
intentando
eliminar
parte


de
la
magia
acerca
de
por
qu√©
funciona
RSA
,
para
demostrar
esta
igualdad
necesitamos
utili-


zar
aqu√≠
un
resultado
que
tambi√©n
parece
un
poco
m√°gico
extra√≠do
de
la
teor√≠a
de
n√∫meros
.


Espec√≠ficamente
,
necesitamos
un
resultado
que
establece
que
si
p
y
q
son
primos
,
y
si
n
=
pq
y


si
z
=
(
p
‚Äì
1)(q
‚Äì
1
)
,
entonces
xy
mod
n
es
igual
a
x(y
mod
z
)
mod
n
[
Kaufman
1995
]
.
Aplicando


este
resultado
con
x
=
m
e
y
=
ed
tenemos


med
mod
n
=
m(ed
mod
z
)
mod
n


Pero
recuerde
que
hemos
seleccionado
e
y
d
tal
que
ed
mod
z
=
1
.
Esto
nos
da


med
mod
n
=
m1
mod
n
=
m


que
es
exactamente
el
resultado
que
est√°bamos
buscando
.
Elevando
en
primer
lugar
a
la


potencia
e
(
es
decir
,
cifrando
)
y
luego
elevando
a
la
potencia
d
(
es
decir
,
descifrando
)
obte-


nemos
el
valor
original
,
m.
Aunque
m√°s
maravilloso
es
el
hecho
de
que
si
primero
elevamos


a
la
potencia
d
y
luego
a
la
potencia
e
(
es
decir
,
si
invertimos
el
orden
del
cifrado
y
el
desci-


frado
,
realizando
en
primer
lugar
la
operaci√≥n
de
descifrado
y
aplicando
luego
la
operaci√≥n


de
cifrado
)
tambi√©n
obtenemos
el
valor
original
,
m.
Este
estupendo
resultado
se
concluye


inmediatamente
a
partir
de
las
reglas
de
la
propia
aritm√©tica
modular
:


(
md
mod
n)e
mod
n
=
mde
mod
n
=
med
mod
n
=
(
me
mod
n)d
mod
n


La
seguridad
del
algoritmo
RSA
se
basa
en
el
hecho
de
que
no
existen
algoritmos
cono-


cidos
para
factorizar
r√°pidamente
un
n√∫mero
,
en
este
caso
el
valor
p√∫blico
n
,
c
o
n
 
e
l
 
f
i
n
 
d
e


obtener
 
los
n√∫meros
primos
p
y
q.
Si
alguien
conociera
p
y
q
,
entonces
podr√≠a
calcular
f√°cil-


mente
a
partir
del
valor
p√∫blico
e
la
clave
secreta
d.
Por
otro
lado
,
no
se
conoce
con
seguri-


dad
si
existen
o
no
algoritmos
r√°pidos
para
factorizar
un
n√∫mero
,
por
lo
que
,
en
este
sentido
,


la
seguridad
de
RSA
no
est√°
garantizada
.


Otro
algoritmo
popular
de
cifrado
de
clave
p√∫blica
es
el
algoritmo
de
Diffie-Hellman
,


que
analizaremos
brevemente
en
los
problemas
de
repaso
.
El
algoritmo
de
Diffie-Hellman


no
es
tan
vers√°til
como
RSA
,
en
el
sentido
de
que
no
puede
utilizarse
para
cifrar
mensajes


de
longitud
arbitraria
;
sin
embargo
,
s√≠
que
puede
emplearse
para
establecer
una
clave
de


sesi√≥n
sim√©trica
,
que
a
su
vez
se
utilizar√°
para
cifrar
los
mensajes
.


8.3
Integridad
de
los
mensajes
y
autenticaci√≥n


de
los
 
puntos
terminales


En
la
secci√≥n
anterior
hemos
visto
c√≥mo
puede
utilizarse
el
cifrado
para
proporcionar
confi-


dencialidad
a
dos
entidades
que
desean
comunicarse
.
En
esta
secci√≥n
vamos
a
volver
nues-


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
669


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
669tra
atenci√≥n
al
tema
criptogr√°fico
,
igualmente
importante
,
de
proporcionar
integridad
a
los


mensajes
(
t√©cnica
tambi√©n
conocida
como
autenticaci√≥n
de
mensajes
)
.
Junto
con
la
integri-


dad
de
los
mensajes
,
analizaremos
dos
temas
relacionados
en
esta
secci√≥n
:
las
firmas
digita-


les
y
la
autenticaci√≥n
de
los
puntos
terminales
.


Vamos
a
definir
el
problema
de
la
integridad
de
los
mensajes
utilizando
una
vez
m√°s
a


Alicia
y
a
Benito
.
Suponga
que
Benito
recibe
un
mensaje
(
que
puede
estar
cifrado
o
puede


ser
texto
en
claro
)
y
que
√©l
cree
que
este
mensaje
fue
enviado
por
Alicia
.
Para
autenticar
el


mensaje
,
Benito
tiene
que
verificar
que
:


1
.
El
origen
del
mensaje
es
efectivamente
Alicia
.


2
.
El
mensaje
no
ha
sido
alterado
mientras
viajaba
hasta
Benito
.


Veremos
en
las
Secciones
8.4
a
8.7
que
este
problema
de
la
integridad
de
los
mensajes
es


una
preocupaci√≥n
cr√≠tica
en
pr√°cticamente
todos
los
protocolos
de
red
seguros
.


Como
ejemplo
espec√≠fico
,
considere
una
red
de
computadoras
en
la
que
se
est√°


empleando
un
algoritmo
de
enrutamiento
de
estado
del
enlace
(
como
por
ejemplo
OSPF
)


para
determinar
las
rutas
entre
cada
pareja
de
routers
de
la
red
(
v√©ase
el
Cap√≠tulo
4
)
.
En


un
algoritmo
de
estado
del
enlace
,
cada
router
necesita
multidifundir
un
mensaje
de
estado


del
enlace
a
todos
los
restantes
routers
de
la
red
.
El
mensaje
de
estado
del
enlace
de
un


router
incluye
una
lista
de
su
vecinos
directamente
conectados
,
junto
con
los
costes
direc-


tos
a
esos
vecinos
.
Una
vez
que
un
router
recibe
mensajes
de
estado
de
enlace
de
todos
los


dem√°s
routers
puede
crear
un
mapa
completo
de
la
red
,
ejecutar
su
algoritmo
de
enruta-


miento
de
coste
m√≠nimo
y
configurar
su
tabla
de
reenv√≠o
.
Un
ataque
relativamente
senci-


llo
contra
el
algoritmo
de
enrutamiento
consiste
en
que
Tom√°s
distribuya
mensajes
falsos


de
estado
del
enlace
con
informaci√≥n
incorrecta
acerca
del
estado
de
los
enlaces
.
Debido
a


la
necesidad
de
integridad
de
los
mensajes
,
cuando
el
router
B
recibe
un
mensaje
de
estado


del
enlace
procedente
del
router
A
debe
verificar
que
efectivamente
el
router
A
ha
creado


dicho
mensaje
y
,
adem√°s
,
que
nadie
lo
ha
alterado
mientras
que
el
mensaje
se
encontraba


en
tr√°nsito
.


En
esta
secci√≥n
vamos
a
describir
una
popular
t√©cnica
de
integridad
de
mensajes
que
se


utiliza
en
muchos
protocolos
de
red
seguros
.
Pero
,
antes
de
eso
,
tenemos
que
tratar
otro
tema


importante
dentro
del
campo
de
la
criptograf√≠a
:
las
funciones
hash
criptogr√°ficas
.


8.3.1
Funciones
hash
criptogr√°ficas


Como
se
muestra
en
la
Figura
8.7
,
una
funci√≥n
hash
toma
una
entrada
,
m
,
y
calcula
una


cadena
de
tama√±o
fijo
H(m
)
conocida
con
el
nombre
de
hash
.
La
suma
de
comprobaci√≥n
de


Internet
(
Cap√≠tulo
3
)
y
los
c√≥digos
CRC
(
Cap√≠tulo
4
)
cumplen
con
esta
definici√≥n
.
Adem√°s
,


una
funci√≥n
hash
criptogr√°fica
necesita
exhibir
la
siguiente
propiedad
adicional
:


‚Ä¢E
s
c
o
m
p
u
t
a
c
i
o
n
a
l
m
e
n
t
e
 
i
m
p
r
a
c
t
i
c
a
b
l
e
 
e
n
c
o
n
t
r
a
r
 
d
o
s
 
m
e
n
s
a
j
e
s
 
d
i
s
t
i
n
t
o
s
 
x
e
y
tales
que


H(x
)
=
H(y
)
.


De
una
manera
informal
,
podr√≠amos
decir
que
esta
propiedad
significa
que
es
computa-


cionalmente
impracticable
que
un
intruso
sustituya
un
mensaje
protegido
mediante
la
fun-


ci√≥n
hash
por
otro
mensaje
diferente
.
Es
decir
,
si
(
m
,
H(m
)
)
son
el
mensaje
y
el
valor
hash


de
dicho
mensaje
creado
por
el
emisor
,
entonces
un
intruso
no
puede
generar
el
contenido


de
otro
mensaje
,
y
,
que
tenga
el
mismo
valor
de
hash
que
el
mensaje
original
.


670
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
670Vamos
a
verificar
que
una
suma
de
comprobaci√≥n
simple
,
como
la
suma
de
comproba-


ci√≥n
de
Internet
,
nos
proporcionar√≠a
una
funci√≥n
hash
criptogr√°fica
bastante
poco
segura
.
En


lugar
de
realizar
la
aritm√©tica
en
complemento
a
1
(
como
en
la
suma
de
comprobaci√≥n
de


Internet
)
,
calculemos
una
suma
de
comprobaci√≥n
tratando
cada
car√°cter
como
un
byte
y


sumando
los
bytes
en
fragmentos
de
4
bytes
cada
vez
.
Suponga
que
Benito
debe
a
Alicia


100,99
euros
y
que
le
env√≠a
un
mensaje
de
confirmaci√≥n
que
es
la
cadena
de
texto
‚Äú
DEBO100


.99BENITO
.
‚Äù
La
representaci√≥n
ASCII
(
en
notaci√≥n
hexadecimal
)
de
estas
letras
ser√≠a
44
,


45
,
42
,
4F,31
,
30
,
30
,
2E
,
39
,
39
,
42
,
45
,
4E
,
49
,
54
,
4F.


La
Figura
8.8
(
parte
superior
)
muestra
que
la
suma
de
comprobaci√≥n
de
4
bytes
para


este
mensaje
es
FC
F8
09
11
.
Un
mensaje
ligeramente
distinto
(
y
mucho
m√°s
costoso


para
Benito
)
es
el
que
se
muestra
en
la
parte
inferior
de
esta
misma
figura
.
Los
mensajes


‚Äú
DEBO100.99BENITO
‚Äù
y
‚Äú
DEBO900.19BENITO
‚Äù
tienen
la
misma
suma
de
comprobaci√≥n
.


Por
tanto
,
este
sencillo
algoritmo
de
suma
de
comprobaci√≥n
violar√≠a
el
requisito
que
antes


hemos
mencionado
.
Dados
los
datos
originales
,
es
muy
sencillo
encontrar
otro
conjunto
de


datos
con
la
misma
suma
de
comprobaci√≥n
.
Obviamente
,
para
prop√≥sitos
de
seguridad
nece-


sitaremos
una
funci√≥n
hash
bastante
m√°s
potente
que
una
mera
suma
de
comprobaci√≥n
.


El
algoritmo
hash
MD5
de
Ron
Rivest
[
RFC
1321
]
se
utiliza
ampliamente
hoy
d√≠a
.
Este


algoritmo
calcula
un
valor
hash
de
128
bits
mediante
un
proceso
en
cuatro
pasos
,
que
con-


siste
en
un
paso
de
relleno
(
a√±adir
un
uno
seguido
del
n√∫mero
de
ceros
suficiente
como
para


que
la
longitud
del
mensaje
satisfaga
ciertas
condiciones
)
,
un
paso
de
agregaci√≥n
(
a√±adir


una
representaci√≥n
mediante
64
bits
de
la
longitud
del
mensaje
antes
de
la
operaci√≥n
de


relleno
)
,
una
inicializaci√≥n
de
un
acumulador
y
un
bucle
final
en
el
que
se
procesan
los
blo-


ques
de
16
palabras
del
mensaje
,
en
cuatro
pasadas
sucesivas
.
Consulte
[
RFC
1321
]
para
ver


una
descripci√≥n
de
MD5
(
incluyendo
una
implementaci√≥n
con
c√≥digo
fuente
en
C
)
.


El
segundo
algoritmo
principal
de
hash
que
se
utiliza
hoy
d√≠a
es
el
denominado
algo-


ritmo
de
hash
seguro
(
SHA-1
,
Secure
Hash
Algorithm
)
[
FIPS
1995
]
.
Este
algoritmo
est√°


basado
en
una
serie
de
principios
similares
a
los
utilizados
en
el
dise√±o
de
MD4
[
RFC


1320
]
,
el
predecesor
de
MD5
.
SHA-1
,
un
est√°ndar
federal
del
gobierno
de
Estados
Uni-


dos
,
es
obligatorio
siempre
que
se
requiera
un
algoritmo
hash
criptogr√°fico
para
aplica-


ciones
gubernamentales
.
Este
algoritmo
produce
un
resumen
del
mensaje
(
message
digest
)


de
160
bits
.
Esa
mayor
longitud
de
salida
hace
que
SHA-1
sea
m√°s
seguro
.


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
671


Funci√≥n
hash


muchos
a
uno


Mensaje
largo
:
m


Querida
Alicia
:


√âsta
es
una
carta
MUY


larga
,
porque
tengo
muchas


cosas
que
decirte
....


..........


..........


Benito


Hash
de


longitud
fija
:
H(m
)


Opgmdvboijrtnsd


gghPPdogm;lcvkb


Figura
8.7
‚Ä¢
Funciones
hash
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6718.3.2
C√≥digo
de
autenticaci√≥n
del
mensaje


Vo
l
v
a
m
o
s
 
a
h
o
r
a
 
a
l
 
p
r
o
b
l
e
m
a
 
d
e
 
l
a
 
i
n
t
e
g
r
i
d
a
d
 
d
e
 
l
o
s
 
m
e
n
s
a
j
e
s
.
 
A
h
o
r
a
 
q
u
e
 
s
a
b
e
m
o
s
 
q
u
√©
 
s
o
n


las
funciones
hash
,
veamos
una
primera
aproximaci√≥n
de
c√≥mo
podr√≠amos
garantizar
la
inte-


gridad
de
los
mensajes
:


1
.
Alicia
crea
el
mensaje
m
y
calcula
el
valor
hash
H(m
)
(
por
ejemplo
,
con
SHA-1
)
.


2
.
Alicia
a√±ade
a
continuaci√≥n
H(m
)
al
mensaje
m
,
creando
un
mensaje
ampliado
(
m
,


H(m
)
)
,
el
cual
env√≠a
a
Benito
.


3
.
Benito
recibe
el
mensaje
ampliado
(
m
,
h
)
y
calcula
H(m
)
.
Si
H(m
)
=
h
,
Benito
concluye


que
todo
est√°
correcto
.


Este
enfoque
tiene
un
fallo
fundamental
.
El
intruso
Tom√°s
puede
crear
un
mensaje
ficticio


m¬¥e
n
 
e
l
 
q
u
e
 
d
i
j
e
r
a
 
q
u
e
 
e
s
 
A
l
i
c
i
a
,
 
c
a
l
c
u
l
a
rH(m
¬¥
)
y
enviar
a
Benito
(
m
¬¥
,
H(m
¬¥
)
)
.
Cuando


Benito
recibiera
el
mensaje
,
todas
las
comprobaciones
del
paso
3
ser√≠an
correctas
,
por
lo
que


Benito
no
ser√≠a
consciente
de
que
se
ha
producido
un
enga√±o
.


Para
garantizar
la
integridad
de
los
mensajes
,
adem√°s
de
utilizar
funciones
hash
cripto-


gr√°ficas
Alicia
y
Benito
necesitan
un
secreto
compartido
s.
Este
secreto
compartido
,
que
no


es
m√°s
que
una
cadena
de
bits
,
se
denomina
clave
de
autenticaci√≥n
.
Utilizando
este
secreto


compartido
puede
garantizarse
de
la
forma
siguiente
la
integridad
de
los
mensajes
:


1
.
Alicia
crea
el
mensaje
m
,
concatena
s
con
m
para
crear
m
+
s
,
y
calcula
el
valor
hash


H(m
+
s
)
(
por
ejemplo
,
con
SHA-1
)
.
H(m
+
s
)
se
denomina
c√≥digo
de
autenticaci√≥n


de
mensajes
(
MAC
,
Message
Authentication
Code
)
.


2
.
Alicia
a√±ade
entonces
el
c√≥digo
MAC
al
mensaje
m
,
creando
un
mensaje
ampliado
(
m
,


H(m
+
s
)
)
,
y
lo
env√≠a
a
Benito
.


3
.
Benito
recibe
un
mensaje
ampliado
(
m
,
h
)
y
,
conociendo
s
,
calcula
el
valor
MAC
H(m


+
s
)
.
Si
H(m
+
s
)
=
h
,
Benito
concluye
que
todo
est√°
correcto
.


672
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Figura
8.8
‚Ä¢
El
mensaje
inicial
y
el
mensaje
fraudulento
tienen
la
misma
suma


de
comprobaci√≥n
.


Mensaje


DEBO


1
0
0
.


9
9
B
E


N
I
T
O


Representaci√≥n


ASCII


44
45
42
4F


31
 
30
30
2E


39
39
42
45


4E
49
54
4F


FC
F8
09
11
Suma
de
comprobaci√≥n


Mensaje


DEBO


9
0
0
.


1
9
B
E


N
I
T
O


Representaci√≥n


ASCII


44
45
42
4F


39
30
30
2E


31
39
42
45


4E
49
54
4F


FC
F8
09
11
Suma
de
comprobaci√≥n


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
672En
la
Figura
8.9
se
muestra
un
resumen
de
este
procedimiento
.
El
lector
debe
fijarse
en
que


las
siglas
MAC
aqu√≠
(
que
corresponden
a
‚Äú
Message
Authentication
Code
‚Äù
)
no
tienen
nada


que
ver
con
las
siglas
MAC
utilizadas
en
los
protocolos
de
la
capa
de
enlace
(
que
correspon-


den
a
‚Äú
Medium
Access
Control
‚Äù
)
.


Una
caracter√≠stica
muy
conveniente
de
los
valores
MAC
es
que
no
se
necesita
ning√∫n


algoritmo
de
cifrado
.
De
hecho
,
en
muchas
aplicaciones
,
incluyendo
el
algoritmo
de
enruta-


miento
de
estado
del
enlace
descrito
anteriormente
,
las
entidades
que
se
est√°n
comunicando


s√≥lo
se
preocupan
de
la
integridad
de
los
mensajes
,
mientras
que
la
confidencialidad
de
los


mismos
no
les
importa
.
Utilizando
un
c√≥digo
MAC
,
las
entidades
pueden
autenticar
los


mensajes
que
se
intercambian
sin
tener
que
incluir
complejos
algoritmos
de
cifrado
en
el


proceso
de
garant√≠a
de
la
integridad
.


Como
cabr√≠a
esperar
,
a
lo
largo
de
los
a√±os
se
han
propuesto
diversos
est√°ndares
para


los
valores
MAC
.
El
est√°ndar
m√°s
popular
hoy
d√≠a
es
HMAC
,
que
puede
utilizarse
con


MD5
o
SHA-1
.
En
la
pr√°ctica
,
HMAC
hace
pasar
los
datos
y
la
clave
de
autenticaci√≥n
a
tra-


v√©s
de
la
funci√≥n
hash
dos
veces
[
Kaufman
1995
;
RFC
2104
]
.


Sigue
quedando
pendiente
una
cuesti√≥n
importante
.
¬ø
C√≥mo
distribuimos
la
clave


secreta
de
autenticaci√≥n
a
las
distintas
entidades
que
tienen
que
comunicarse
?
Por
ejemplo
,


en
el
algoritmo
de
enrutamiento
de
estado
del
enlace
necesitaremos
distribuir
de
alguna


manera
la
clave
de
autenticaci√≥n
a
cada
uno
de
los
routers
del
sistema
aut√≥nomo
.
(
Observe


que
todos
los
routers
pueden
utilizar
la
misma
clave
de
autenticaci√≥n
.
)
Un
administrador


de
red
podr√≠a
llevar
a
cabo
esa
distribuci√≥n
visitando
f√≠sicamente
cada
uno
de
los
rou-


ters
.
O
bien
,
si
el
administrador
de
la
red
es
demasiado
perezoso
y
si
cada
router
tiene
su


propia
clave
p√∫blica
,
el
administrador
puede
distribuir
la
clave
de
autenticaci√≥n
a
cual-


quiera
de
los
routers
cifr√°ndola
con
la
clave
p√∫blica
del
router
y
luego
enviando
la
clave


cifrada
hasta
el
router
a
trav√©s
de
la
red
.


8.3.3
Firmas
digitales


Piense
en
el
n√∫mero
de
veces
que
ha
firmado
con
su
nombre
en
un
papel
durante
la
√∫ltima


semana
.
Todos
estamos
acostumbrados
a
firmar
cheques
,
recibos
de
tarjetas
de
cr√©dito
,


documentos
legales
y
cartas
.
Nuestra
firma
atestigua
el
hecho
de
que
nosotros
(
y
no
cual-


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
673


H
(
.
)


H
(
.
)


m


m


m


m


s


s


s


+
Internet


Comparar


Clave
:


=
Mensaje


=
Secreto
compartido


H(m+s
)


H(m+s
)


Figura
8.9
‚Ä¢
C√≥digo
de
autenticaci√≥n
de
mensaje
(
MAC
)
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
673quier
otra
persona
)
hemos
aceptado
y
/
o
acordado
el
contenido
de
un
documento
.
En
un


mundo
digital
a
menudo
surge
la
necesidad
de
indicar
el
propietario
o
creador
de
un
docu-


mento
o
de
explicitar
nuestro
acuerdo
con
el
contenido
de
un
documento
.
Una
firma
digital


es
una
t√©cnica
criptogr√°fica
que
permite
conseguir
estos
objetivos
en
el
mundo
digital
.


Al
igual
que
ocurre
con
las
firmas
manuscritas
,
las
firmas
digitales
deben
realizarse
de


forma
que
sean
verificables
y
no
falsificables
.
Es
decir
,
debe
ser
posible
demostrar
que
un


documento
firmado
por
una
persona
ha
sido
,
de
hecho
,
firmado
por
esa
persona
(
la
firma


tiene
que
ser
verificable
)
y
que
s√≥lo
esa
persona
podr√≠a
haber
firmado
el
documento
(
la


firma
no
puede
ser
falsificada
)
.


Consideremos
ahora
c√≥mo
podr√≠amos
dise√±ar
un
esquema
de
firma
digital
.
Observe


que
,
cuando
Benito
firma
un
mensaje
,
debe
poner
algo
en
el
mensaje
que
sea
distintivo
de


√©l
.
Benito
podr√≠a
pensar
en
asociar
un
valor
MAC
para
la
firma
,
en
cuyo
caso
crear√≠a
el
valor


MAC
a√±adiendo
su
clave
(
que
permite
distinguirle
del
resto
de
las
personas
)
al
mensaje
y


luego
aplicando
la
funci√≥n
hash
.
Pero
,
para
que
Alicia
pudiera
verificar
esa
firma
,
tambi√©n


deber√≠a
disponer
de
una
copia
de
la
clave
,
en
cuyo
caso
la
clave
dejar√≠a
de
ser
distintiva
de


Benito
.
Por
tanto
,
los
c√≥digos
MAC
no
nos
permiten
conseguir
nuestro
objetivo
en
este
caso
.


Recuerde
que
,
con
la
criptograf√≠a
de
clave
p√∫blica
,
Benito
dispone
de
sendas
claves


p√∫blica
y
privada
,
siendo
la
pareja
formada
por
esas
claves
distintiva
de
Benito
.
Por
tanto
,
la


criptograf√≠a
de
clave
p√∫blica
es
un
candidato
excelente
para
poder
proporcionar
un
meca-


nismo
de
firma
digital
.
Veamos
ahora
c√≥mo
se
estructura
dicho
mecanismo
.


Suponga
que
Benito
desea
firmar
digitalmente
un
documento
,
m.
Podemos
pensar
en
el


documento
como
si
fuera
un
archivo
o
un
mensaje
que
Benito
va
a
firmar
y
enviar
.
Como
se


muestra
en
la
Figura
8.10
,
para
firmar
este
documento
Benito
utiliza
simplemente
su


clave
privada
,
KB


‚Äì
,
para
calcular
KB


‚Äì
(
m
)
.
De
entrada
,
puede
parecer
extra√±o
que
Benito
uti-


lice
su
clave
privada
(
que
,
como
vimos
en
la
Secci√≥n
8.2
,
se
utiliza
para
descifrar
un
men-


saje
que
haya
sido
cifrado
con
su
clave
p√∫blica
)
para
firmar
un
documento
.
Pero
recuerde


que
el
cifrado
y
el
descifrado
no
son
otra
cosa
que
operaciones
matem√°ticas
(
consistentes


en
elevar
a
la
potencia
e
o
d
en
RSA
;
v√©ase
la
Secci√≥n
8.2
)
y
recuerde
tambi√©n
que
el
obje-


tivo
de
Benito
no
es
cifrar
u
ocultar
el
contenido
del
documento
,
sino
s√≥lo
firmarlo
de
una


manera
que
sea
verificable
y
no
falsificable
.
La
firma
digital
del
documento
realizada
por


Benito
es
KB


‚Äì
(
m
)
.


674
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Algoritmo


de
cifrado


Mensaje
:
m


Clave
privada
de


Benito
,
KB


‚Äì


Querida
Alicia
:


Siento
no
haber
podido


escribirte
durante
tanto


tiempo
,
pero
....


..........


..........


Benito


Mensaje
firmado
:


KB


‚Äì
(
m
)


fadfg54986fgnzmcnv


T98734ngldskg02j


ser09tugkjdflg


..........


Figura
8.10
‚Ä¢
Creaci√≥n
de
una
firma
digital
para
un
documento
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
674¬øCumple
la
firma
digital
KB


‚Äì
(
m
)
nuestros
requisitos
de
que
sea
verificable
y
no
falsifica-


ble
?
Suponga
que
Alicia
dispone
de
m
y
KB


‚Äì
(
m
)
.
Ella
quiere
demostrar
ante
un
tribunal
(
a


consecuencia
de
alg√∫n
tipo
de
litigio
)
que
Benito
es
quien
ha
firmado
el
documento
y
que
es


la
√∫nica
persona
que
podr√≠a
haberlo
firmado
.
Alicia
toma
la
clave
p√∫blica
de
Benito
,
KB


+
,
y


se
la
aplica
a
la
firma
digital
,
KB


‚Äì
(
m
)
,
asociada
con
el
documento
,
m.
Es
decir
,
calcula


KB


+
(
KB


‚Äì
(
m
)
)
,
y
voil√†
:
con
un
gesto
dram√°tico
obtiene
m
,
que
se
corresponde
exactamente
con


el
documento
original
.
Alicia
argumenta
a
continuaci√≥n
que
s√≥lo
Benito
podr√≠a
haber
fir-


mado
el
documento
por
las
siguientes
razones
:


‚Ä¢Q
u
i
e
n
q
u
i
e
r
a
 
q
u
e
 
h
a
y
a
 
f
i
r
m
a
d
o
 
e
l
 
d
o
c
u
m
e
n
t
o
 
t
i
e
n
e
 
q
u
e
 
h
a
b
e
r
 
u
t
i
l
i
z
a
d
o
 
l
a
 
c
l
a
v
e
 
p
r
i
v
a
d
a


de
Benito
,
KB


‚Äì
,
a
la
hora
de
calcular
la
firma
KB


‚Äì
(
m
)
para
que
KB


+
(
KB


‚Äì
(
m
)
)
=
m.


‚Ä¢L
a
 
√∫
n
i
c
a
 
p
e
r
s
o
n
a
 
q
u
e
 
p
u
e
d
e
 
c
o
n
o
c
e
r
 
l
a
 
c
l
a
v
e
 
p
r
i
v
a
d
a
,
 
KB


‚Äì
,
es
el
propio
Benito
.
Recuerde
,


de
nuestra
exposici√≥n
sobre
RSA
de
la
Secci√≥n
8.2
,
que
el
conocimiento
de
la
clave


p√∫blica
,
KB


+
,
no
sirve
de
nada
a
la
hora
de
determinar
la
clave
privada
,
KB


‚Äì
.
Por
tanto
,
la


√∫nica
persona
que
podr√≠a
conocer
KB


‚Äì
es
aquella
que
haya
generado
la
pareja
de
claves
,


(
KB


+
,
KB


‚Äì
)
,
es
decir
,
Benito
.
(
Observe
que
aqu√≠
se
est√°
suponiendo
,
sin
embargo
,
que
Benito


no
ha
proporcionado
su
clave
privada
KB


‚Äì
a
nadie
y
que
nadie
le
ha
robado
KB


‚Äì
.
)


Tambi√©n
es
importante
observar
que
si
el
documento
original
,
m
,
se
modificara
de
alg√∫n


modo
para
obtener
una
forma
alternativa
,
m
¬¥
,
la
firma
que
Benito
generara
para
m
no
ser√≠a


v√°lida
para
m
¬¥
,
ya
que
KB


+
(
KB


‚Äì
(
m
)
)
no
es
igual
a
m
¬¥
.
Por
tanto
,
podemos
concluir
que
las
fir-


mas
digitales
tambi√©n
proporcionan
un
mecanismo
de
integridad
de
los
mensajes
,
permi-


tiendo
al
receptor
verificar
que
el
mensaje
no
ha
sido
alterado
,
adem√°s
de
verificar
el
origen


del
mismo
.


Uno
de
los
problemas
con
la
firma
de
datos
mediante
mecanismos
de
cifrado
es
que
el


cifrado
y
el
descifrado
son
computacionalmente
muy
caros
.
Dada
la
cantidad
adicional
de


procesamiento
que
el
cifrado
y
el
descifrado
exigen
,
el
firmar
los
datos
v√≠a
cifr√°ndolos
/
des-


cifr√°ndolos
completamente
puede
ser
como
matar
moscas
a
ca√±onazos
.
Una
t√©cnica
m√°s
efi-


ciente
consiste
en
introducir
funciones
hash
en
el
mecanismo
de
firma
digital
.
Recuerde
de


la
Secci√≥n
8.3.2
que
un
algoritmo
hash
toma
un
mensaje
,
m
,
de
longitud
arbitraria
y
calcula


una
especie
de
‚Äú
huella
digital
‚Äù
de
longitud
fija
para
el
mensaje
,
que
designamos
mediante


H(m
)
.
Utilizando
una
funci√≥n
hash
,
Benito
firma
el
valor
hash
de
un
mensaje
en
lugar
de
fir-


mar
el
propio
mensaje
,
es
decir
,
Benito
calcula
KB


‚Äì
(
H(m
)
)
.
Puesto
que
H(m
)
es
,
general-


mente
,
mucho
m√°s
peque√±o
que
el
mensaje
original
m
,
la
capacidad
de
proceso
necesario


para
generar
la
firma
digital
se
reduce
sustancialmente
.


En
el
contexto
del
env√≠o
de
un
mensaje
a
Alicia
por
parte
de
Benito
,
la
Figura
8.11
pro-


porciona
un
resumen
del
procedimiento
operativo
requerido
para
crear
una
firma
digital
.


Benito
hace
pasar
su
mensaje
original
,
de
gran
longitud
,
a
trav√©s
de
una
funci√≥n
hash
.
A
con-


tinuaci√≥n
,
firma
digitalmente
el
valor
hash
resultante
utilizando
para
ello
su
clave
privada
.


Despu√©s
,
le
env√≠a
a
Alicia
el
mensaje
original
(
como
texto
en
claro
)
junto
con
el
resumen


del
mensaje
digitalmente
firmado
(
al
que
a
partir
de
ahora
denominaremos
firma
digital
)
.
La


Figura
8.12
proporciona
un
resumen
del
procedimiento
operativo
de
firma
.
Alicia
aplica
la


clave
p√∫blica
del
emisor
al
mensaje
para
obtener
un
valor
hash
.
Asimismo
,
aplica
la
funci√≥n


hash
al
mensaje
recibido
como
texto
en
claro
,
para
obtener
un
segundo
valor
hash
.
Si
los
dos


valores
coinciden
,
entonces
Alicia
puede
estar
segura
acerca
de
la
integridad
y
del
autor
del


mensaje
.


Antes
de
seguir
adelante
,
vamos
a
comparar
brevemente
las
firmas
digitales
con
los


c√≥digos
MAC
,
dado
que
existen
paralelismos
entre
ambos
sistemas
,
pero
tambi√©n
existen


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
675


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
675varias
diferencias
sutiles
e
importantes
.
Tanto
las
firmas
digitales
como
los
c√≥digos
MAC


comienzan
con
un
mensaje
(
o
un
documento
)
.
Para
obtener
un
valor
MAC
de
ese
mensaje
,


a√±adimos
al
mensaje
una
clave
de
autenticaci√≥n
y
luego
calculamos
el
valor
hash
del
resul-


tado
.
Observe
que
,
a
la
hora
de
crear
el
valor
MAC
,
no
hay
involucrado
ning√∫n
mecanismo


de
cifrado
de
clave
p√∫blica
ni
de
clave
sim√©trica
.
Para
crear
una
firma
digital
,
primero
cal-


culamos
el
valor
hash
del
mensaje
y
luego
ciframos
el
mensaje
con
nuestra
clave
privada


(
utilizando
criptograf√≠a
de
clave
p√∫blica
)
.
Por
tanto
,
la
firma
digital
es
una
t√©cnica
‚Äú
m√°s


pesada
‚Äù
,
dado
que
requiere
una
Infraestructura
de
clave
p√∫blica
(
PKI
,
Public
Key
Infrastruc-


ture
)
subyacente
,
en
la
que
existan
autoridades
de
certificaci√≥n
,
como
las
que
m√°s
adelante


se
describen
.
Veremos
en
la
Secci√≥n
8.4
que
PGP
(
un
sistema
muy
popular
de
correo
elec-


tr√≥nico
seguro
)
utiliza
las
firmas
digitales
para
garantizar
la
integridad
de
los
mensajes
.


Tambi√©n
hemos
visto
ya
que
OSPF
utiliza
valores
MAC
para
garantizar
la
integridad
de
los


mensajes
.
En
las
Secciones
8.5
y
8.6
veremos
que
los
valores
MAC
tambi√©n
se
emplean
en


varios
protocolos
de
seguridad
populares
de
las
capas
de
transporte
y
de
red
.


Certificaci√≥n
de
clave
p√∫blica


Una
importante
aplicaci√≥n
de
las
firmas
digitales
es
la
certificaci√≥n
de
clave
p√∫blica
,
es


decir
,
certificar
que
una
clave
p√∫blica
pertenece
a
una
entidad
espec√≠fica
.
Las
t√©cnicas
de


certificaci√≥n
de
clave
p√∫blica
se
utilizan
en
muchos
protocolos
populares
de
seguridad
para


las
comunicaciones
de
red
,
incluyendo
IPsec
y
SSL
.


Para
tratar
de
comprender
el
problema
,
consideremos
una
versi√≥n
de
comercio
electr√≥-


nico
por
Internet
del
cl√°sico
servicio
de
pizza
a
domicilio
.
Alicia
trabaja
en
el
sector
de
la


venta
de
pizza
a
domicilio
y
acepta
pedidos
a
trav√©s
de
Internet
.
Benito
,
un
amante
de
la


676
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Figura
8.11
‚Ä¢
Transmisi√≥n
de
un
mensaje
firmado
digitalmente
.


Clave
privada
de


Benito
,
KB


‚Äì


Funci√≥n
hash


muchos
a
uno


Mensaje
largo


Querida
Alicia
:


√âsta
va
a
ser
una
carta
MUY


larga
,
porque
es
mucho
lo


que
tengo
que
decirte
....


..........


..........


Benito


Hash
de


longitud
fija


Opgmdvboijrtnsd


gghPPdogm;lcvkb


Hash


firmadoPaquete
de
datos


enviado
a
Alicia


Fgkopdgoo69cmxw


54psdterma[asofmz


Algoritmo


de
cifrado


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
676pizza
,
env√≠a
a
Alicia
un
mensaje
de
texto
en
claro
que
incluye
su
direcci√≥n
particular
y
el


tipo
de
pizza
que
desea
.
En
ese
mensaje
,
Benito
tambi√©n
incluye
una
firma
digital
(
es
decir
,


un
valor
hash
firmado
del
mensaje
en
claro
original
)
para
demostrar
a
Alicia
que
√©l
es
el
ver-


dadero
origen
del
mensaje
.
Para
verificar
la
firma
,
Alicia
obtiene
la
clave
de
p√∫blica
de


Benito
(
quiz√°
acudiendo
a
un
servidor
de
clave
p√∫blica
o
a
partir
del
propio
mensaje
de


correo
electr√≥nico
)
y
comprueba
la
firma
digital
.
De
esta
forma
se
asegura
de
que
Benito
,
y


no
alg√∫n
adolescente
gracioso
,
ha
realizado
el
pedido
.


Este
procedimiento
parece
correcto
,
hasta
que
nuestro
intruso
Tom√°s
entra
en
escena
.


Como
se
muestra
en
la
Figura
8.13
,
Tom√°s
est√°
tratando
de
gastar
una
broma
y
env√≠a
un


mensaje
a
Alicia
en
el
que
dice
que
es
Benito
,
proporciona
la
direcci√≥n
particular
de
Benito


y
pide
una
pizza
.
En
este
mensaje
tambi√©n
incluye
su
clave
p√∫blica
(
la
de
Tom√°s
)
,
aunque


Alicia
asume
,
naturalmente
,
que
se
trata
de
la
clave
p√∫blica
de
Benito
.
Tom√°s
tambi√©n


adjunta
una
firma
digital
,
que
habr√°
creado
con
su
propia
clave
privada
.
Despu√©s
de
recibir


el
mensaje
,
Alicia
aplica
la
clave
p√∫blica
de
Tom√°s
(
pensando
que
es
la
de
Benito
)
a
la
firma


digital
y
concluye
que
el
mensaje
de
texto
en
claro
ha
sido
creado
por
Benito
.
Benito
se
que-


dar√°
muy
sorprendido
cuando
el
repartidor
le
lleve
a
su
casa
una
pizza
con
pepperoni
y


anchoas
.


Podemos
ver
a
partir
de
este
ejemplo
que
para
que
la
criptograf√≠a
de
clave
p√∫blica


resulte
√∫til
necesitamos
poder
verificar
que
disponemos
de
la
verdadera
clave
p√∫blica
de
la


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
677


Clave
publica


de
Benito
,
KB


+


Mensaje
largo


Querida
Alicia
:


√âsta
va
a
ser
una
carta
MUY


larga
,
porque
tengo
muchas


cosas
que
contarte
....


..........


..........


Benito


Hash
de


longitud
fija


Opgmdvboijrtnsd


gghPPdogm;lcvkb


Hash


firmado


Fgkopdgoo69cmxw


54psdterma[asofmz


Funci√≥n
hash


muchos
a
uno
Comparar


Hash
de


longitud
fija


Opgmdvboijrtnsd


gghPPdogm;lcvkb


Algoritmo


de
cifrado


Figura
8.12
‚Ä¢
Verificaci√≥n
de
un
mensaje
firmado
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
677entidad
(
persona
,
router
,
navegador
,
etc.
)
con
la
que
queremos
comunicarnos
.
Por
ejemplo
,


cuando
Alicia
quiere
comunicarse
con
Benito
empleando
criptograf√≠a
de
clave
p√∫blica
nece-


sita
verificar
que
la
clave
p√∫blica
que
se
supone
que
pertenece
a
Benito
es
verdaderamente
de


Benito
.


La
asociaci√≥n
entre
una
clave
p√∫blica
y
una
entidad
concreta
normalmente
la
realiza


una
Autoridad
de
certificaci√≥n
(
CA
,
Certification
Authority
)
,
cuyo
trabajo
consiste
en


validar
las
identidades
y
emitir
los
certificados
.
Una
autoridad
de
certificaci√≥n
desempe√±a


los
siguientes
papeles
:


1
.
Una
CA
verifica
que
una
entidad
(
una
persona
,
un
router
,
etc.
)
es
quien
dice
ser
.
No
hay


ning√∫n
procedimiento
establecido
para
la
forma
en
que
se
lleva
a
cabo
esa
certificaci√≥n
.


Al
a
 
h
o
r
a
 
d
e
 
t
r
a
t
a
r
 
c
o
n
 
u
n
a
 
C
A
,
 
u
n
o
 
d
e
b
e
 
c
o
n
f
i
a
r
 
e
n
 
q
u
e
 
e
s
a
 
a
u
t
o
r
i
d
a
d
 
d
e
 
c
e
r
t
i
f
i
c
a
c
i
√≥
n


habr√°
realizado
una
verificaci√≥n
de
identidad
adecuadamente
rigurosa
.
Por
ejemplo
,
si


Tomas
fuera
capaz
de
entrar
en
una
autoridad
de
certificaci√≥n
y
anunciar
simplemente


‚Äú
Yo
soy
Alicia
‚Äù
y
recibir
certificados
asociados
con
la
identidad
de
Alicia
,
entonces
nin-


guno
podr√≠amos
tener
mucha
fe
en
las
claves
p√∫blicas
certificadas
por
esa
autoridad
de


certificaci√≥n
concreta
.
Por
otro
lado
,
uno
tender√≠a
(
¬°
o
quiz√°
no
!
)
a
confiar
m√°s
en
una


autoridad
de
certificaci√≥n
que
dependa
del
gobierno
.
S√≥lo
podemos
confiar
en
la
identi-


dad
asociada
con
una
clave
p√∫blica
en
la
medida
en
que
podamos
confiar
en
una
autori-


678
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Clave
privada
de


Tom√°s
,
KT


‚Äì


Clave
p√∫blica


de
Tom√°s
,
KT


+


Resumen
del
mensaje
firmado
,


utilizando
la
clave
privada


de
Tom√°s


Fgkopdgoo69cmxw


54psdterma[asofmz


Mensaje


Alicia
,


Env√≠ame
una
pizza
.

                               
Benito


Funci√≥n
hash


muchos
a
uno


Alicia
utiliza
la
clave


p√∫blica
de
Tom√°s
,


creyendo
que
es
la
de


Benito
,
y
concluye
que


el
mensaje
procede


de
Benito
.


PIZZA


Algoritmo


de
cifrado


Figure
8.13
‚Ä¢
Tom√°s
se
hacer
pasar
por
Benito
utilizando
criptograf√≠a
de
clave


p√∫blica
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
678dad
de
certificaci√≥n
y
en
sus
t√©cnicas
de
verificaci√≥n
de
identidad
.
Como
ve
,
lo
que
es


necesario
establecer
es
una
aut√©ntica
red
de
confianza
entre
distintas
entidades
.


2
.
Una
vez
que
la
autoridad
de
certificaci√≥n
verifica
la
identidad
de
la
entidad
,
genera
un


certificado
que
asocia
con
esa
entidad
su
correspondiente
clave
p√∫blica
.
El
certificado


contiene
la
clave
p√∫blica
y
la
informaci√≥n
de
identificaci√≥n
globalmente
distintiva


acerca
del
propietario
de
la
clave
p√∫blica
(
por
ejemplo
,
el
nombre
de
una
persona
o
una


direcci√≥n
IP
)
.
El
certificado
es
firmado
digitalmente
por
la
autoridad
de
certificaci√≥n
.


Estos
pasos
se
muestran
en
la
Figura
8.14
.


Veamos
ahora
c√≥mo
pueden
utilizarse
los
certificados
para
combatir
a
los
bromistas
de


la
pizza
como
Tom√°s
y
a
otros
sujetos
indeseables
.
Cuando
Benito
hace
su
pedido
,
tambi√©n


env√≠a
su
certificado
firmado
por
la
autoridad
de
certificaci√≥n
.
Alicia
utiliza
la
clave
p√∫blica


de
la
autoridad
de
certificaci√≥n
para
comprobar
la
validez
del
certificado
de
Benito
y
extraer


la
clave
p√∫blica
de
Benito
.


Tanto
la
Uni√≥n
Internacional
de
Telecomunicaciones
(
ITU
,
International
Telecommuni-


cation
Union
)
como
el
IETF
han
desarrollado
est√°ndares
para
las
autoridades
de
certifica-


ci√≥n
.
ITU
X.509
[
ITU
1993
]
especifica
un
servicio
de
autenticaci√≥n
,
as√≠
como
una
sintaxis


espec√≠fica
para
los
certificados
.
[
RFC
1422
]
describe
un
mecanismo
de
administraci√≥n
de


claves
basado
en
autoridades
de
certificaci√≥n
para
su
utilizaci√≥n
con
el
correo
electr√≥nico


seguro
a
trav√©s
de
Internet
.
Es
compatible
con
X.509
,
pero
va
m√°s
all√°
de
dicho
est√°ndar
,
al


establecer
procedimientos
y
convenios
para
una
arquitectura
de
gesti√≥n
de
claves
.
La
Tabla


8.4
describe
algunos
de
los
campos
m√°s
importantes
de
un
certificado
.


8.3.4
Autenticaci√≥n
del
punto
terminal


La
autenticaci√≥n
del
punto
terminal
es
el
proceso
de
demostrar
a
alguien
la
propia
iden-


tidad
.
En
la
vida
cotidiana
,
las
personas
nos
autenticamos
mutuamente
de
muchas
formas


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
679


Certificado
de
Benito
firmado


por
la
CA
,
que
contiene


su
clave
p√∫blica
,
KB


+


Autoridad
de


certificaci√≥n
(
CA)(KB


+
,
B
)


Clave
privada


de
la
CA
,
KCA


‚Äì


Algoritmo


de
cifrado


Figura
8.14
‚Ä¢
Benito
hace
que
una
autoridad
de
certificaci√≥n
(
CA
)
certifique


su
clave
p√∫blica
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
679Nombre
del
campo
Descripci√≥n


Versi√≥n
N√∫mero
de
versi√≥n
de
la
especificaci√≥n
X.509


N√∫mero
de
serie
Identificador
√∫nico
para
un
certificado
emitido
por
una
CA
.
 

Firma
Especifica
el
algoritmo
utilizado
por
la
CA
para
firmar
este
certificado
.


Nombre
del
emisor
Identidad
de
la
CA
que
emite
este
certificado
,
en
formato
de
nombre
distintivo
(
DN
,
Distinguished


Name)[RFC
2253
]
.


Periodo
de
validez
Inicio
y
final
del
periodo
de
validez
del
certificado
.


Nombre
del
sujeto
Identidad
de
la
entidad
cuya
clave
p√∫blica
est√°
asociada
con
este
certificado
,
en
formato
DN
.


Clave
p√∫blica
del
sujeto
La
clave
p√∫blica
del
sujeto
,
as√≠
como
una
indicaci√≥n
del
algoritmo
de
clave
p√∫blica
(
y
de
los
par√°me-


tros
del
algoritmo
)
con
el
que
hay
que
usar
esta
clave
.


Tabla
8.4
‚Ä¢
Campos
seleccionados
en
una
clave
p√∫blica
X.509
y
RFC
1422
.


distintas
.
Reconocemos
la
cara
de
nuestro
interlocutor
cuando
nos
lo
encontramos
;
reco-


nocemos
nuestras
voces
a
trav√©s
del
tel√©fono
;
somos
autenticados
por
los
empleados
de


aduanas
que
comparan
nuestra
cara
con
la
fotograf√≠a
del
pasaporte
.
Pero
cuando
realizamos


una
autenticaci√≥n
a
trav√©s
de
la
red
,
las
dos
partes
que
se
comunican
no
pueden
utilizar
infor-


maci√≥n
biom√©trica
,
como
la
apariencia
visual
o
el
timbre
de
la
voz
.
De
hecho
,
a
menudo


elementos
de
red
como
los
routers
y
los
procesos
cliente-servidor
deben
autenticarse
mutua-


mente
,
bas√°ndose
exclusivamente
en
los
mensajes
y
datos
intercambiados
.


La
primera
cuesti√≥n
que
debemos
plantearnos
es
si
los
valores
MAC
(
estudiados
en
la


Secci√≥n
8.3.2
)
pueden
utilizarse
en
la
autenticaci√≥n
de
los
puntos
terminales
.
Supongamos


que
Alicia
y
Benito
comparten
un
secreto
com√∫n
,
s
,
y
que
Alicia
desea
enviar
a
Benito
un


mensaje
(
por
ejemplo
,
un
segmento
TCP
)
,
mientras
que
Benito
quiere
asegurarse
de
que
el


mensaje
recibido
procede
de
Alicia
.
La
t√©cnica
natural
basada
en
valores
MAC
ser√≠a
la


siguiente
:
Alicia
crea
un
valor
MAC
utilizando
el
mensaje
y
el
secreto
compartido
,
a√±ade
el


valor
MAC
al
mensaje
y
env√≠a
el
‚Äú
mensaje
ampliado
‚Äù
resultante
a
Benito
.
Cuando
√©ste


recibe
el
mensaje
ampliado
,
utiliza
el
valor
MAC
en
√©l
contenido
para
verificar
tanto
el
ori-


gen
como
la
integridad
del
mensaje
.
De
hecho
,
puesto
que
s√≥lo
Alicia
y
Benito
poseen
ese


secreto
compartido
,
si
los
c√°lculos
del
valor
MAC
realizados
por
Benito
proporcionan
un


resultado
que
coincide
con
el
valor
MAC
incluido
en
el
mensaje
ampliado
,
entonces
Benito


podr√°
estar
seguro
de
que
es
Alicia
quien
ha
enviado
el
mensaje
(
y
de
que
el
mensaje
no
ha


sido
alterado
durante
el
trayecto
)
.


Ataques
por
reproducci√≥n
y
n√∫meros
distintivos


¬ø
Estamos
realmente
seguros
de
que
Benito
puede
confiar
en
que
es
Alicia
quien
ha
enviado


el
mensaje
?
De
hecho
,
Benito
no
puede
estar
100
por
cien
seguro
del
origen
del
mensaje
,


porque
contin√∫a
existiendo
la
posibilidad
de
que
alguien
le
est√©
intentando
enga√±ar


mediante
lo
que
se
denomina
un
ataque
por
reproducci√≥n
.
Como
se
muestra
en
la
Figura


8.15
,
Tom√°s
s√≥lo
necesita
husmear
y
guardar
el
mensaje
ampliado
de
Alicia
y
volver
a


enviarlo
en
alg√∫n
momento
posterior
.
El
mensaje
repetido
podr√≠a
decir
algo
as√≠
como
‚Äú
Te


autorizo
a
que
transfieras
un
mill√≥n
de
euros
de
la
cuenta
de
Beato
a
la
de
Tom√°s
‚Äù
,
lo
que


har√≠a
que
se
transfiriera
un
total
de
dos
millones
de
euros
,
o
el
mensaje
podr√≠a
decir
‚Äú
El


680
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
680enlace
desde
el
router
Alicia
al
router
Carlos
se
ha
ca√≠do
‚Äù
,
lo
cual
,
si
se
env√≠a
justo
despu√©s


de
que
el
enlace
haya
sido
reparado
,
podr√≠a
provocar
la
aparici√≥n
de
configuraciones
err√≥-


neas
en
las
tablas
de
reenv√≠o
.


El
escenario
de
fallo
de
la
Figura
8.15
se
produce
como
resultado
del
hecho
de
que


Benito
no
puede
distinguir
entre
el
mensaje
original
enviado
por
Alicia
y
la
posterior
repro-


ducci√≥n
de
ese
mensaje
original
.
En
otras
palabras
,
Benito
no
puede
estar
seguro
de
si
Alicia


estaba
activa
(
es
decir
,
se
encontraba
realmente
al
otro
extremo
de
la
conexi√≥n
en
ese


momento
)
o
si
el
mensaje
recibido
es
una
grabaci√≥n
que
alguien
est√°
reproduciendo
.
El
lec-


tor
muy
(
muy
)
atento
recordar√°
que
el
protocolo
de
acuerdo
en
tres
fases
de
TCP
necesitaba


resolver
exactamente
el
mismo
problema
:
el
lado
de
servidor
de
una
conexi√≥n
TCP
no
debe


aceptar
una
conexi√≥n
si
el
segmento
SYN
recibido
es
una
copia
antigua
(
retransmisi√≥n
)
de


un
segmento
SYN
correspondiente
a
una
conexi√≥n
anterior
.
¬ø
C√≥mo
hac√≠a
el
servidor
TCP


para
resolver
el
problema
de
determinar
si
el
cliente
estaba
realmente
activo
?
Lo
que
hac√≠a


era
seleccionar
un
n√∫mero
de
secuencia
inicial
que
no
hubiera
sido
utilizado
durante
un


periodo
de
tiempo
muy
largo
,
enviar
dicho
n√∫mero
al
cliente
y
luego
esperar
a
que
el
cliente


respondiera
con
un
segmento
ACK
que
contuviera
dicho
n√∫mero
.
Podemos
adoptar
aqu√≠
la


misma
idea
con
prop√≥sitos
de
autenticaci√≥n
.


Un
n√∫mero
distintivo
(
nonce
,
number
used
once)e
s
 
u
n
 
n
√∫
m
e
r
o
 
q
u
e
 
u
n
 
p
r
o
t
o
c
o
l
o
 
s
√≥
l
o


emplear√°
una
vez
en
toda
su
vida
.
Es
decir
,
una
vez
que
un
protocolo
utiliza
un
n√∫mero
dis-


tintivo
,
jam√°s
volver√°
a
usar
dicho
n√∫mero
.
Como
se
muestra
en
la
Figura
8.16
,
nuestro


nuevo
protocolo
emplea
el
n√∫mero
distintivo
de
la
forma
siguiente
:


1
.
Benito
selecciona
un
n√∫mero
distintivo
,
R
,
y
se
lo
env√≠a
a
Alicia
.
Observe
que
el


n√∫mero
distintivo
se
env√≠a
en
forma
de
texto
legible
.
Alicia
crea
entonces
el
valor
MAC


utilizando
su
mensaje
original
,
el
secreto
compartido
s
y
el
n√∫mero
distintivo
R.
(
Por


ejemplo
,
para
crear
el
valor
MAC
Alicia
puede
concatenar
tanto
el
secreto
compartido


como
el
n√∫mero
distintivo
con
el
mensaje
y
pasar
el
resultado
a
trav√©s
de
una
funci√≥n


hash
.
)
Alicia
a√±ade
el
valor
MAC
al
mensaje
,
crea
un
mensaje
ampliado
y
env√≠a
dicho


mensaje
a
Benito
.


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
681


Tom√°s


Alicia
Benito


Grabadora
de
cinta


Clave
:


Tom√°s


Benito


Transferir
1
M
de
euros


de
Beato
a
Tom√°s
MAC


Transferir
1
M
de
euros


de
Beato
a
Tom√°s
MAC


MAC
=


f(mensaje
,
s
)


Figura
8.15
‚Ä¢
Ataque
por
reproducci√≥n
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6812
.
Benito
calcula
un
valor
MAC
a
partir
del
mensaje
(
contenido
en
el
mensaje
ampliado
)
,


del
n√∫mero
distintivo
R
y
del
secreto
compartido
s.
Si
el
valor
MAC
resultante
es
igual


al
valor
MAC
contenido
en
el
mensaje
ampliado
,
Benito
no
s√≥lo
sabr√°
que
Alicia
ha


generado
el
mensaje
,
sino
tambi√©n
que
lo
ha
generado
despu√©s
de
que
Benito
enviara
el


n√∫mero
distintivo
,
dado
que
el
valor
de
ese
n√∫mero
distintivo
es
necesario
para
calcular


el
valor
MAC
correcto
.


Como
veremos
en
las
Secciones
8.5
y
8.6
al
hablar
de
SSL
e
IPsec
,
la
combinaci√≥n
de


n√∫meros
distintivos
y
valores
MAC
se
utiliza
a
menudo
en
protocolos
de
red
seguros
para


proporcionar
tanto
integridad
de
los
mensajes
como
autenticaci√≥n
del
punto
terminal
.


Pero
,
¬ø
qu√©
pasa
si
Alicia
desea
enviar
una
serie
de
mensajes
,
por
ejemplo
,
una
serie
de


segmentos
TCP
?
¬ø
Tendr√°
Benito
que
enviar
a
Alicia
un
nuevo
n√∫mero
distintivo
por
cada


uno
de
los
mensajes
?
En
la
pr√°ctica
,
s√≥lo
hace
falta
un
√∫nico
n√∫mero
distintivo
.
Como
vere-


mos
en
la
Secci√≥n
8.5
cuando
hablemos
de
SSL
,
un
√∫nico
n√∫mero
distintivo
combinado
con


n√∫meros
de
secuencia
permitir√°
a
Benito
verificar
que
todos
los
mensajes
procedentes
de


Alicia
son
recientes
.


Autenticaci√≥n
mediante
criptograf√≠a
de
clave
p√∫blica


El
uso
de
un
n√∫mero
distintivo
y
un
secreto
compartido
permite
definir
un
protocolo
de


autenticaci√≥n
perfectamente
adecuado
.
Una
pregunta
natural
es
si
podemos
emplear
un


n√∫mero
distintivo
y
la
criptograf√≠a
de
clave
p√∫blica
para
resolver
tambi√©n
el
problema
de
la


autenticaci√≥n
.
La
utilizaci√≥n
de
una
t√©cnica
basada
en
clave
p√∫blica
permitir√≠a
resolver
una


dificultad
de
cualquier
sistema
basado
en
un
secreto
compartido
:
nos
referimos
a
la
dificul-


tad
de
tener
que
preocuparse
por
el
modo
en
que
ambos
interlocutores
pueden
llegar
a
cono-


cer
el
valor
del
secreto
compartido
.
Un
protocolo
natural
basado
en
la
criptograf√≠a
de
clave


p√∫blica
ser√≠a
el
siguiente
:


1
.
Alicia
env√≠a
a
Benito
el
mensaje
‚Äú
Soy
Alicia
‚Äù
.


2
.
Benito
selecciona
un
n√∫mero
distintivo
,
R
,
y
se
lo
env√≠a
a
Alicia
.
Una
vez
m√°s
,
el


n√∫mero
distintivo
se
emplea
para
garantizar
que
Alicia
est√°
activa
.


3
.
Alicia
utiliza
su
clave
privada
,
KA


‚Äì
,
para
cifrar
el
n√∫mero
distintivo
y
env√≠a
el
valor


resultante
,
KA


‚Äì
(
R
)
,
a
Benito
.
Puesto
que
s√≥lo
Alicia
conoce
su
clave
privada
,
nadie


excepto
Alicia
podr√°
generar
KA


‚Äì
(
R
)
.


682
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


MAC
=


f(mensaje
,
s
,
R
)


Alicia


Soy
Alicia


BenitoR


Transferir
1
M
de
euros


de
Beato
a
Tom√°s
MAC


Figura
8.16
‚Ä¢
Defensa
frente
a
los
ataques
por
reproducci√≥n
utilizando
n√∫meros


distintivos
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6824
.
Benito
aplica
la
clave
p√∫blica
de
Alicia
,
KA


+
,
al
mensaje
recibido
;
es
decir
,
Benito
cal-


cula
KA


+
(
KA


‚Äì
(
R
)
)
.
Recuerde
de
nuestra
exposici√≥n
sobre
la
criptograf√≠a
de
clave
p√∫blica


con
RSA
de
la
Secci√≥n
8.2
que
KA


+
(
KA


‚Äì
(
R
)
)
=
R.
De
este
modo
,
Benito
calcula
R
y
auten-


tica
a
Alicia
.


La
operaci√≥n
de
este
protocolo
se
ilustra
en
la
Figura
8.17
.
¬ø
Es
seguro
este
protocolo
?


Puesto
que
utiliza
t√©cnicas
de
clave
p√∫blica
,
requiere
que
Benito
consulte
la
clave
p√∫blica
de


Alicia
.
Esto
conduce
a
un
escenario
bastante
interesante
,
mostrado
en
la
Figura
8.18
,
en
el


que
Tom√°s
puede
ser
capaz
de
hacerse
pasar
por
Alicia
ante
Benito
.


1
.
Tom√°s
env√≠a
a
Benito
el
mensaje
‚Äú
Soy
Alicia
‚Äù
.


2
.
Benito
selecciona
un
n√∫mero
distintivo
,
R
,
y
se
lo
env√≠a
a
Alicia
,
pero
el
mensaje
es


interceptado
por
Tom√°s
.


3
.
Tom√°s
emplea
su
clave
privada
,
KT


‚Äì
,
para
cifrar
el
n√∫mero
distintivo
y
env√≠a
el
valor


resultante
,
KT


‚Äì
(
R
)
,
a
Benito
.
Para
Benito
,
KT


‚Äì
(
R
)
es
simplemente
una
serie
de
bits
y
no


sabe
si
esos
bits
representan
KT


‚Äì
(
R
)
o
KA


‚Äì
(
R
)
.


4
.
Benito
debe
ahora
obtener
la
clave
p√∫blica
de
Alicia
para
poder
aplicar
KA


+
al
valor
que


acaba
de
recibir
.
Env√≠a
un
mensaje
a
Alicia
pregunt√°ndola
cu√°l
es
su
clave
p√∫blica
KA


+


(
Benito
tambi√©n
podr√≠a
obtener
la
clave
p√∫blica
de
Alicia
de
su
sitio
web
)
.
Tom√°s
inter-


cepta
tambi√©n
este
mensaje
y
responde
a
Benito
con
KT


+
,
es
decir
,
con
la
clave
p√∫blica


de
Tom√°s
.
Benito
calcula
KT


+
(
KT


‚Äì
(
R
)
)
=
R
y
,
de
ese
modo
,
autentica
a
Tom√°s
como
si


fuera
Alicia
.


Teniendo
en
cuenta
este
escenario
,
es
evidente
que
la
seguridad
de
este
protocolo
de
autenti-


caci√≥n
de
clave
p√∫blica
depende
completamente
de
la
seguridad
del
sistema
de
distribuci√≥n


de
claves
p√∫blicas
.
Afortunadamente
,
podemos
utilizar
certificados
para
distribuir
claves


p√∫blicas
de
forma
segura
,
como
vimos
en
la
Secci√≥n
8.3
.


8.3
‚Ä¢
INTEGRIDAD
DE
LOS
MENSAJES
Y
AUTENTICACI√ìN
DE
LOS
PUNTOS
TERMINALES
683


R


Benito
calcula


KA


+
(
KA


‚Äì
(
R
)
)
=
R
,


autenticando
a
Alicia


KA


‚Äì
(
R
)


Soy
Alicia


KA


+
Env√≠ame
tu
clave
p√∫blica


KA


+


Figura
8.17
‚Ä¢
Protocolo
de
autenticaci√≥n
de
clave
p√∫blica
que
funciona


correctamente
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
683En
el
escenario
de
la
Figura
8.18
Benito
y
Alicia
pueden
llegar
a
descubrir
que
hay
algo


que
va
mal
en
cuanto
Benito
afirme
haber
interactuado
con
Alicia
,
mientras
que
Alicia
sabe


que
nunca
ha
interactuado
con
Benito
.
Pero
existe
un
ataque
todav√≠a
m√°s
insidioso
que
evita-


r√≠a
incluso
esta
detecci√≥n
.
En
el
escenario
de
la
Figura
8.19
Alicia
y
Benito
est√°n
hablando


entre
ellos
,
pero
explotando
el
mismo
agujero
de
seguridad
en
el
protocolo
de
autenticaci√≥n
,


Tom√°s
es
capaz
de
interponerse
de
forma
transparente
entre
Alicia
y
Benito
.
En
particular
,


si
Benito
comienza
a
enviar
datos
cifrados
a
Alicia
utilizando
la
clave
de
cifrado
que
ha
reci-


bido
de
Tom√°s
,
Tom√°s
puede
extraer
el
texto
en
claro
correspondiente
a
la
comunicaci√≥n


entre
Benito
y
Alicia
.
Al
mismo
tiempo
,
Tom√°s
puede
reenviar
los
datos
de
Benito
a
Alicia


(
despu√©s
de
volver
a
cifrarlos
utilizando
la
clave
p√∫blica
real
de
Alicia
)
.


Benito
est√°
convencido
de
estar
enviando
datos
cifrados
y
Alicia
est√°
convencida
de


estar
recibiendo
datos
cifrados
utilizando
su
propia
clave
p√∫blica
;
ambos
son
inconscientes


de
la
presencia
de
Tom√°s
.
Si
Benito
y
Alicia
se
reunieran
posteriormente
y
hablaran
de
la


interacci√≥n
que
han
tenido
,
Alicia
habr√≠a
recibido
exactamente
lo
que
Benito
envi√≥
,
por
lo


que
ninguno
de
ellos
detectar√≠a
que
algo
va
mal
.
Esto
es
un
ejemplo
del
denominado
ataque


por
interposici√≥n
(
man-in-the-middle
attack
)
.


8.4
Correo
electr√≥nico
seguro


En
las
secciones
anteriores
hemos
examinado
una
serie
de
problemas
fundamentales
en
el


campo
de
la
seguridad
de
red
,
incluyendo
las
t√©cnicas
de
criptograf√≠a
de
clave
sim√©trica
y
de


clave
p√∫blica
,
las
de
autenticaci√≥n
de
punto
terminal
,
los
mecanismos
de
distribuci√≥n
de
cla-


ves
,
el
problema
de
la
integridad
de
los
mensajes
y
las
t√©cnicas
de
firma
digital
.
Ahora


vamos
a
examinar
c√≥mo
se
utilizan
hoy
en
d√≠a
dichas
herramientas
para
proporcionar
segu-


ridad
en
Internet
.


684
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


R


Benito
calcula


KT


+
(
KT


‚Äì
(
R
)
)
=
R
,


autenticando
a
Tom√°s


como
si
fuera
Alicia


KT


‚Äì
(
R
)


Soy
Alicia


KT


+
Env√≠ame
tu
clave
p√∫blica


KA


+


Figura
8.18
‚Ä¢
Un
agujero
de
seguridad
en
el
protocolo
de
autenticaci√≥n
de


clave
p√∫blica
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6848.4
‚Ä¢
CORREO
ELECTR√ìNICO
SEGURO
685


Es
interesante
observar
que
es
posible
proporcionar
servicios
de
seguridad
en
cual-


quiera
de
las
cuatro
capas
superiores
de
la
pila
de
protocolos
de
Internet
.
Cuando
se
propor-


ciona
seguridad
para
un
protocolo
espec√≠fico
de
la
capa
de
aplicaci√≥n
,
la
aplicaci√≥n
que


utiliza
ese
protocolo
disfrutar√°
de
uno
o
m√°s
servicios
de
seguridad
,
como
los
de
confiden-


cialidad
,
autenticaci√≥n
o
integridad
.
Cuando
los
mecanismos
de
seguridad
se
proporcionan


para
un
protocolo
de
la
capa
de
transporte
,
todas
las
aplicaciones
que
usan
dicho
protocolo


disfrutar√°n
de
los
servicios
de
seguridad
del
protocolo
de
transporte
.
Cuando
la
seguridad
se


proporciona
en
la
capa
de
red
en
un
esquema
host
a
host
,
todos
los
segmentos
de
la
capa
de


transporte
(
y
por
tanto
todos
los
datos
de
la
capa
de
aplicaci√≥n
)
disfrutar√°n
de
los
servicios


de
seguridad
de
la
capa
de
red
.
Cuando
se
proporciona
seguridad
a
nivel
de
enlace
,
entonces


los
datos
de
todas
las
tramas
que
viajan
a
trav√©s
del
enlace
utilizar√°n
los
servicios
de
seguri-


dad
del
enlace
.


En
las
Secciones
8.4
a
8.7
vamos
a
examinar
el
modo
en
que
se
utilizan
las
t√©cnicas
de


seguridad
en
las
capas
de
aplicaci√≥n
,
transporte
,
red
y
de
enlace
de
datos
.
Para
ser
coheren-


tes
con
la
estructura
general
del
libro
,
comenzaremos
por
la
parte
superior
de
la
pila
de
pro-


tocolos
,
abordando
la
seguridad
en
la
capa
de
aplicaci√≥n
.
Nuestro
enfoque
consiste
en


utilizar
una
aplicaci√≥n
espec√≠fica
,
como
el
correo
electr√≥nico
,
como
caso
de
estudio
de
las


R


R


KT


‚Äì
(
R
)


KA


‚Äì
(
R
)


Soy
Alicia
Soy
Alicia


KT


+


KA


+


Env√≠ame
tu
clave
p√∫blica


KA


+


Env√≠ame
tu
clave
p√∫blica
KA


+


Benito
env√≠a
una


serie
de
datos
,
m
,


cifrados


utilizando
KT


+


Alicia
descifra


KA


+
(
m
)
y
extrae
m


Tom√°s
descifra
KT


+
(
m
)
,


extrae
m
calculando
m
=
KT


‚Äì
(
KT


+
(
m
)
)
,


cifra
m
utilizando
KA


+
y
reenv√≠a


KA


+
(
m
)
a
Alicia


Figura
8.19
‚Ä¢
Ataque
por
interposici√≥n
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
685t√©cnicas
de
seguridad
de
la
capa
de
aplicaci√≥n
.
Despu√©s
descenderemos
por
la
pila
de
proto-


colos
y
examinaremos
el
protocolo
SSL
(
que
proporciona
seguridad
a
la
capa
de
transporte
)
,


IPsec
(
que
proporciona
seguridad
en
la
capa
de
red
)
y
los
mecanismos
de
seguridad
del
pro-


tocolo
IEEE
802.11
para
redes
LAN
inal√°mbricas
.


El
lector
puede
estarse
preguntando
por
qu√©
se
proporciona
la
funcionalidad
de
seguri-


dad
en
m√°s
de
una
capa
dentro
de
Internet
.
¬ø
No
bastar√≠a
simplemente
con
proporcionar
la


funcionalidad
de
seguridad
en
la
capa
de
red
?
Existen
dos
respuestas
a
esta
pregunta
.
En


primer
lugar
,
aunque
la
seguridad
en
la
capa
de
red
puede
proporcionar
la
funcionalidad


b√°sica
de
cifrado
de
todos
los
datos
contenidos
en
los
datagramas
(
es
decir
,
de
todos
los
seg-


mentos
de
la
capa
de
transporte
)
y
de
autenticar
todas
las
direcciones
IP
de
origen
,
lo
que
no


puede
es
ofrecer
seguridad
de
nivel
de
usuario
.
Por
ejemplo
,
un
sitio
web
de
comercio
elec-


tr√≥nico
no
puede
confiar
en
la
seguridad
de
la
capa
IP
para
autenticar
a
un
cliente
que
est√©


comprando
bienes
o
servicios
en
ese
sitio
.
Por
tanto
,
existe
una
necesidad
de
incorporar
fun-


cionalidad
de
seguridad
en
las
capas
superiores
,
adem√°s
de
la
funcionalidad
b√°sica
en
las


capas
inferiores
.
En
segundo
lugar
,
es
m√°s
f√°cil
generalmente
implantar
servicios
Internet


nuevos
,
incluyendo
los
servicios
de
seguridad
,
en
las
capas
superiores
de
la
pila
de
protoco-


los
.
Mientras
se
espera
a
que
un
nuevo
mecanismo
de
seguridad
se
implante
de
forma
gene-


ralizada
en
la
capa
de
red
,
lo
que
puede
llegar
a
tardar
a√±os
,
muchos
desarrolladores
de


aplicaciones
simplemente
se
ponen
manos
a
la
obra
e
introducen
la
funcionalidad
de
seguri-


dad
en
sus
aplicaciones
favoritas
.
Un
ejemplo
cl√°sico
es
PGP
(
Pretty
Good
Privacy
)
,
que


proporciona
correo
electr√≥nico
seguro
(
y
de
la
que
hablaremos
posteriormente
en
esta
sec-


ci√≥n
)
.
Requiriendo
√∫nicamente
c√≥digo
de
aplicaci√≥n
de
cliente
y
de
servidor
,
PGP
fue
una


de
las
primeras
tecnolog√≠as
de
seguridad
que
se
utiliz√≥
ampliamente
en
Internet
.


8.4.1
Correo
electr√≥nico
seguro


Ahora
vamos
a
utilizar
los
principios
criptogr√°ficos
de
las
Secciones
8.2
a
8.3
para
crear
un


sistema
de
correo
electr√≥nico
seguro
.
Crearemos
este
dise√±o
de
alto
nivel
de
una
forma


incremental
,
introduciendo
en
cada
paso
nuevos
servicios
de
seguridad
.
A
la
hora
de
dise√±ar


un
sistema
de
correo
electr√≥nico
seguro
debemos
tener
presente
el
ejemplo
visto
en
la
Sec-


ci√≥n
8.1
:
la
relaci√≥n
amorosa
entre
Alicia
y
Benito
.
Imagine
que
Alicia
quiere
enviar
un


mensaje
de
correo
electr√≥nico
a
Benito
y
que
Tom√°s
pretende
inmiscuirse
en
la
conversa-


ci√≥n
.


Antes
de
seguir
adelante
y
dise√±ar
un
sistema
de
correo
electr√≥nico
seguro
para
Alicia
y


Benito
,
tenemos
que
considerar
qu√©
caracter√≠sticas
de
seguridad
ser√≠an
m√°s
deseables
para


ellos
.
La
primera
y
principal
es
la
confidencialidad
.
Como
hemos
explicado
en
la
Secci√≥n


8.1
,
ni
Alicia
ni
Benito
quieren
que
Tom√°s
lea
el
correo
electr√≥nico
de
Alicia
.
La
segunda


caracter√≠stica
que
Alicia
y
Benito
probablemente
deseen
para
su
sistema
de
correo
electr√≥-


nico
seguro
es
la
de
autenticaci√≥n
del
emisor
.
En
particular
,
cuando
Benito
recibe
el
men-


saje
‚Äú
Ya
no
te
quiero
.
No
quiero
verte
nunca
m√°s
.
Olv√≠dame
,
Alicia
.
‚Äù


naturalmente
le
gustar√≠a
estar
seguro
de
que
el
mensaje
procede
de
Alicia
y
no
de
un
intruso
.


Otra
caracter√≠stica
que
los
dos
amantes
apreciar√≠an
ser√≠a
la
de
integridad
de
los
mensajes
,
es


decir
,
una
garant√≠a
de
que
los
mensajes
que
Alicia
env√≠e
no
sean
modificados
a
lo
largo
del


camino
hasta
llegar
a
Benito
.
Por
√∫ltimo
,
el
sistema
de
correo
electr√≥nico
debe
proporcionar


una
autenticaci√≥n
del
receptor
;
es
decir
,
Alicia
querr√°
asegurarse
de
que
est√°
enviando
su


mensaje
a
Benito
y
no
a
alguna
otra
persona
(
por
ejemplo
,
Tom√°s
)
que
est√©
haci√©ndose
pasar


por
Benito
.


686
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
686As√≠
que
comencemos
analizando
el
primero
de
los
objetivos
,
la
confidencialidad
.
La


forma
m√°s
directa
de
proporcionar
confidencialidad
es
que
Alicia
cifre
el
mensaje
con
una


tecnolog√≠a
de
clave
sim√©trica
(
como
DES
o
AES
)
y
que
Benito
descifre
el
mensaje
al
reci-


birlo
.
Como
se
explica
en
la
Secci√≥n
8.2
,
si
la
clave
sim√©trica
es
lo
suficiente
larga
y
si
√∫ni-


camente
Alicia
y
Benito
tienen
la
clave
,
entonces
es
extremadamente
dif√≠cil
que
ninguna


otra
persona
(
incluyendo
a
Tom√°s
)
lea
el
mensaje
.
Aunque
esta
t√©cnica
es
muy
sencilla
,
pre-


senta
la
dificultad
fundamental
de
la
que
ya
hemos
hablado
en
la
Secci√≥n
8.2
:
distribuir
una


clave
sim√©trica
de
modo
que
s√≥lo
Alicia
y
Benito
tengan
copia
de
la
misma
.
Por
tanto
,


vamos
a
considerar
una
soluci√≥n
alternativa
:
la
criptograf√≠a
de
clave
p√∫blica
(
utilizando
por


ejemplo
RSA
)
.
En
la
t√©cnica
de
clave
p√∫blica
,
Benito
pone
a
disposici√≥n
de
todo
el
mundo


su
clave
p√∫blica
(
por
ejemplo
,
en
un
servidor
de
claves
p√∫blicas
o
en
su
p√°gina
web
perso-


nal
)
.
Alicia
cifra
su
mensaje
con
la
clave
p√∫blica
de
Benito
y
env√≠a
el
mensaje
cifrado
a
la


direcci√≥n
de
correo
electr√≥nico
de
Benito
.
Cuando
√©ste
recibe
el
mensaje
,
simplemente
lo


descifra
con
su
clave
privada
.
Suponiendo
que
Alicia
est√©
segura
de
que
la
clave
p√∫blica
uti-


lizada
es
la
de
Benito
,
esta
t√©cnica
constituye
un
m√©todo
excelente
para
proporcionar
la
con-


fidencialidad
deseada
.
Sin
embargo
,
un
problema
es
que
el
cifrado
de
clave
p√∫blica
es


relativamente
poco
eficiente
,
particularmente
para
mensajes
de
gran
longitud
.


Para
solventar
este
problema
de
eficiencia
,
vamos
a
hacer
uso
de
una
clave
de
sesi√≥n


(
de
lo
que
hemos
hablado
en
la
Secci√≥n
8.2.2
)
.
En
particular
,
Alicia
(
1
)
selecciona
una
clave


de
sesi√≥n
sim√©trica
aleatoria
,
KS
,
(
2
)
cifra
su
mensaje
,
m
,
con
la
clave
sim√©trica
,
(
3
)
cifra
la


clave
sim√©trica
con
la
clave
p√∫blica
de
Benito
,
KB


+
,
(
4
)
concatena
el
mensaje
cifrado
y


la
clave
sim√©trica
cifrada
para
formar
un
‚Äú
paquete
‚Äù
y
(
5
)
env√≠a
este
paquete
a
la
direcci√≥n
de


correo
electr√≥nico
de
Benito
.
Los
pasos
se
ilustran
en
la
Figura
8.20
.
(
En
√©sta
y
las
subsi-


guientes
figuras
,
el
s√≠mbolo
‚Äú
+
‚Äù
encerrado
en
un
c√≠rculo
representa
la
operaci√≥n
de
concate-


naci√≥n
y
el
signo
‚Äú
‚Äì
‚Äù
encerrado
en
un
c√≠rculo
representa
la
operaci√≥n
de
desconcatenaci√≥n
.
)


Cuando
Benito
recibe
el
paquete
,
(
1
)
utiliza
su
clave
privada
,
KB


‚Äì
,
para
obtener
la
clave
sim√©-


trica
,
KS
,
y
(
2
)
utiliza
la
clave
sim√©trica
KS
para
descifrar
el
mensaje
m.


Habiendo
dise√±ado
un
sistema
de
correo
electr√≥nico
seguro
que
proporciona
un
servi-


cio
de
confidencialidad
,
vamos
a
dise√±ar
ahora
otro
sistema
que
proporcione
tanto
autenti-


caci√≥n
del
emisor
como
integridad
de
los
mensajes
.
Vamos
a
suponer
por
el
momento
que


a
Alicia
y
Benito
ya
no
les
preocupa
la
confidencialidad
(
¬°
quieren
compartir
sus
sentimien-


tos
con
todo
el
mundo
!
)
y
que
s√≥lo
les
preocupa
la
autenticaci√≥n
del
emisor
y
la
integridad


8.4
‚Ä¢
CORREO
ELECTR√ìNICO
SEGURO
687


KS
(
.
)
KS
(
.
)


KS
(
m
)
KS
(
m
)


KS


KS


KB


+
(
.
)


KB


+
(
KS
)
KB


+
(
KS
)


m
m


+
‚Äì
Internet


KB


‚Äì
(
.
)


Alicia
env√≠a
un
mensaje
de
correo
electr√≥nico
m
Benito
recibe
un
mensaje
de
correo
electr√≥nico
m


Figura
8.20
‚Ä¢
Alicia
utiliza
una
clave
de
sesi√≥n
sim√©trica
,
KS
,
para
enviar
un


mensaje
secreto
de
correo
electr√≥nico
a
Benito
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
687de
los
mensajes
.
Para
llevar
a
cabo
esta
tarea
,
utilizaremos
firmas
digitales
y
res√∫menes
de


mensajes
,
como
se
describe
en
la
Secci√≥n
8.3
.
Espec√≠ficamente
,
Alicia
(
1
)
aplica
una
fun-


ci√≥n
hash
H
(
por
ejemplo
,
MD5
)
a
su
mensaje
,
m
,
para
obtener
un
resumen
del
mensaje
,


(
2
)
firma
el
resultado
de
la
funci√≥n
hash
con
su
clave
privada
,
KA


‚Äì
,
para
crear
una
firma
digi-


tal
,
(
3
)
concatena
el
mensaje
original
(
no
cifrado
)
con
la
firma
para
crear
un
paquete
y
(
4
)


env√≠a
el
paquete
a
la
direcci√≥n
de
correo
electr√≥nico
de
Benito
.
Cuando
√©ste
recibe
el


paquete
,
(
1
)
aplica
la
clave
p√∫blica
de
Alicia
,
KA


+
,
al
resumen
del
mensaje
firmado
y
(
2
)


compara
el
resultado
de
esta
operaci√≥n
con
su
propio
valor
hash
,
H
,
del
mensaje
.
Estos


pasos
se
ilustran
en
la
Figura
8.21
.
Como
se
ha
estudiado
en
la
Secci√≥n
8.3
,
si
los
dos
resul-


tados
coinciden
,
Benito
puede
estar
seguro
de
que
el
mensaje
procede
de
Alicia
y
no
ha


sido
alterado
.
 

Vamos
a
considerar
ahora
el
dise√±o
de
un
sistema
de
correo
electr√≥nico
que
proporcione


confidencialidad
,
autenticaci√≥n
del
emisor
e
integridad
de
los
mensajes
.
Esto
puede
hacerse


combinando
los
procedimientos
de
las
Figuras
8.20
y
8.21
.
Alicia
crea
primero
un
paquete


preliminar
,
exactamente
como
en
la
Figura
8.21
,
que
est√°
compuesto
por
su
mensaje
origi-


nal
y
un
valor
hash
digitalmente
firmado
del
mensaje
.
A
continuaci√≥n
,
trata
este
paquete
pre-


liminar
como
un
mensaje
en
s√≠
mismo
y
env√≠a
este
nuevo
mensaje
a
trav√©s
de
los
pasos
del


emisor
de
la
Figura
8.20
,
creando
un
nuevo
paquete
que
es
enviado
a
Benito
.
Los
pasos
apli-


cados
por
Alicia
se
muestran
en
la
Figura
8.22
.
Cuando
Benito
recibe
el
paquete
,
primero


aplica
su
lado
correspondiente
de
la
Figura
8.20
y
luego
su
lado
correspondiente
de
la
Figura


8.21
.
Deber√≠a
quedar
claro
para
el
lector
que
este
dise√±o
permite
conseguir
el
objetivo
de


proporcionar
confidencialidad
,
autenticaci√≥n
del
emisor
e
integridad
de
los
mensajes
.


Observe
que
,
con
este
esquema
,
Alicia
utiliza
la
criptograf√≠a
de
clave
p√∫blica
dos
veces
:
una


vez
con
su
propia
clave
privada
y
otra
con
la
clave
p√∫blica
de
Benito
.
De
forma
similar
,


Benito
tambi√©n
emplea
la
criptograf√≠a
de
clave
p√∫blica
dos
veces
:
una
con
su
clave
privada


y
otra
con
la
clave
p√∫blica
de
Alicia
.


El
dise√±o
de
correo
electr√≥nico
seguro
esbozado
en
la
Figura
8.22
probablemente
pro-


porciona
una
seguridad
satisfactoria
para
la
mayor√≠a
de
los
usuarios
de
correo
electr√≥nico
,


en
la
mayor√≠a
de
las
ocasiones
.
Pero
continuamos
teniendo
un
problema
importante
que


hay
que
resolver
.
El
dise√±o
de
la
Figura
8.22
requiere
que
Alicia
obtenga
la
clave
p√∫blica


de
Benito
y
que
Benito
obtenga
la
clave
p√∫blica
de
Alicia
.
La
distribuci√≥n
de
estas
claves


688
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


H
(
.
)
KA


‚Äì
(
.
)
KA


+
(
.
)


KA


‚Äì
(
H(m
)
)
KA


‚Äì
(
H(m
)
)


m


m


m


+
‚Äì
Internet


Alicia
env√≠a
un
mensaje
de
correo
electr√≥nico
m
Benito
recibe
un
mensaje
de
correo
electr√≥nico
m


H
(
.
)


Comparar


Figura
8.21
‚Ä¢
Utilizaci√≥n
de
funciones
hash
y
firmas
digitales
para
proporcio-


nar
autenticaci√≥n
del
emisor
e
integridad
de
los
mensajes
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
688p√∫blicas
no
es
un
problema
trivial
.
Por
ejemplo
,
Tom√°s
podr√≠a
hacerse
pasar
por
Benito
y


darle
a
Alicia
su
propia
clave
p√∫blica
,
mientras
que
le
hace
creer
que
se
trata
de
la
clave


p√∫blica
de
Benito
,
lo
que
permitir√≠a
a
Tom√°s
recibir
el
mensaje
destinado
a
Benito
.
Como


hemos
visto
en
la
Secci√≥n
8.3
,
una
t√©cnica
popular
para
distribuir
de
forma
segura
las
cla-


ves
p√∫blicas
consiste
en
certificar
esas
claves
p√∫blicas
utilizando
una
autoridad
de
certifi-


caci√≥n
(
CA
)
.


8.4.2
PGP


Escrito
por
Phil
Zimmermann
en
1991
,
Pretty
Good
Privacy
(
PGP
)
es
un
esquema
de


cifrado
de
correo
electr√≥nico
que
se
ha
convertido
en
un
est√°ndar
de
facto
.
Su
sitio
web
sirve


m√°s
de
un
mill√≥n
de
p√°ginas
al
mes
a
usuarios
de
166
pa√≠ses
distintos
[
PGPI
2007
]
.
Hay
ver-


siones
de
PGP
disponibles
en
el
dominio
p√∫blico
;
por
ejemplo
,
podemos
encontrar
el
soft-


ware
PGP
para
nuestra
plataforma
favorita
,
as√≠
como
una
gran
cantidad
de
art√≠culos


interesantes
en
la
p√°gina
web
internacional
de
PGP
[
PGPI
2007
]
.
(
Un
ensayo
particular-


mente
interesante
escrito
por
el
autor
de
PGP
es
[
Zimmermann
2007
]
.
)
B√°sicamente
,
el


dise√±o
de
PGP
es
igual
al
mostrado
en
la
Figura
8.22
.
Dependiendo
de
la
versi√≥n
,
el
soft-


ware
PGP
utiliza
MD5
o
SHA
para
calcular
el
resumen
del
mensaje
;
CAST
,
triple-DES
o


IDEA
para
el
cifrado
de
clave
sim√©trica
y
RSA
para
el
cifrado
de
clave
p√∫blica
.


Cuando
se
instala
PGP
,
el
software
crea
una
pareja
de
clave
p√∫blica
y
clave
privada
para


el
usuario
.
La
clave
p√∫blica
puede
darse
a
conocer
a
todo
el
mundo
a
trav√©s
del
sitio
web
del


usuario
o
puede
almacenarse
en
un
servidor
de
clave
p√∫blica
.
La
clave
privada
est√°
protegida


mediante
el
uso
de
una
contrase√±a
.
La
contrase√±a
debe
introducirse
cada
vez
que
el
usuario


accede
a
la
clave
privada
.
PGP
le
da
al
usuario
la
opci√≥n
de
firmar
digitalmente
el
mensaje
,


de
cifrar
el
mensaje
o
de
realizar
tanto
la
operaci√≥n
de
firma
como
la
de
cifrado
.
La
Figura


8.23
muestra
un
mensaje
firmado
PGP
.
Este
mensaje
aparece
despu√©s
de
la
cabecera
MIME
.


Los
datos
codificados
en
el
mensaje
son
iguales
a
KA


‚Äì
(
H(m
)
)
,
es
decir
,
son
un
resumen
fir-


mado
digitalmente
del
mensaje
.
Como
hemos
comentado
anteriormente
,
para
que
Benito


verifique
la
integridad
del
mensaje
necesitar√°
tener
acceso
a
la
clave
p√∫blica
de
Alicia
.


8.4
‚Ä¢
CORREO
ELECTR√ìNICO
SEGURO
689


H
(
.
)
KA


‚Äì
(
.
)


KS
(
.
)


KS


KA


‚Äì
(
H(m
)
)


m


m


+


+
A
Internet


KB


+
(
.
)


Figura
8.22
‚Ä¢
Alicia
utiliza
la
criptograf√≠a
de
clave
sim√©trica
,
la
criptograf√≠a
de


clave
p√∫blica
,
una
funci√≥n
hash
y
una
firma
digital
para
obtener


los
servicios
de
confidencialidad
,
autenticaci√≥n
del
emisor
e


integridad
de
los
mensajes
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
689La
Figura
8.24
muestra
un
mensaje
PGP
secreto
.
Este
mensaje
tambi√©n
aparece
despu√©s


de
la
cabecera
MIME
.
Por
supuesto
,
el
mensaje
de
texto
en
claro
no
est√°
incluido
en
el


mensaje
secreto
de
correo
electr√≥nico
.
Cuando
un
emisor
(
como
Alicia
)
quiere
tanto
confi-


dencialidad
como
integridad
,
PGP
contiene
un
mensaje
como
el
de
la
Figura
8.24
dentro
del


mensaje
de
la
Figura
8.23
.


-----BEGIN
PGP
SIGNED
MESSAGE-----


Hash
:
 
SHA1


Benito
:


¬ø
Puedo
verte
esta
noche
?


Apasionadamente
tuya
,
Alicia


-----BEGIN
PGP
SIGNATURE-----


Version
:
PGP
for
Personal
Privacy
5.0


Charset
:
noconv


yhHJRHhGJGhgg/12EpJ+lo8gE4vB3mqJhFEvZP9t6n7G6m5Gw2


-----END
PGP
SIGNATURE-----


Figura
8.23
‚Ä¢
Un
mensaje
firmado
mediante
PGP
.


690
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


PHIL
ZIMMERMANN
Y
PGP


Philip
R.
Zimmermann
es
el
creador
de
Pretty
Good
Privacy
(
PGP
)
.
Debido
a
ello
fue
objeto


de
una
investigaci√≥n
criminal
que
dur√≥
tres
a√±os
,
porque
el
gobierno
americano
sosten√≠a


que
las
restricciones
de
exportaci√≥n
de
los
Estados
Unidos
para
el
software
criptogr√°fico


fueron
violadas
cuando
PGP
se
difundi√≥
por
todo
el
mundo
despu√©s
de
su
publicaci√≥n
en


1991
como
software
gratuito
.
Despu√©s
de
distribuir
PGP
como
shareware
,
alguna
otra


persona
lo
puso
en
Internet
y
los
ciudadanos
extranjeros
pudieron
descarg√°rselo
.
Los


programas
criptogr√°ficos
en
Estados
Unidos
est√°n
clasificados
como
las
municiones
seg√∫n


las
leyes
federales
y
no
se
pueden
exportar
.


A
pesar
de
la
falta
de
financiaci√≥n
,
la
falta
de
personal
contratado
y
la
falta
de
una


empresa
que
le
apoyara
y
a
pesar
de
las
intervenciones
gubernamentales
,
PGP
lleg√≥
de
todos


modos
a
convertirse
en
el
software
de
cifrado
de
correo
electr√≥nico
m√°s
ampliamente
utili-


zado
en
todo
el
mundo
.
Resulta
ir√≥nico
que
el
propio
gobierno
de
Estados
Unidos
pueda


haber
contribuido
inadvertidamente
a
la
difusi√≥n
de
PGP
a
causa
del
caso
Zimmermann
.


El
gobierno
de
Estados
Unidos
abandon√≥
el
caso
a
principios
de
1996
.
El
anuncio
fue


enormemente
celebrado
por
los
activistas
de
Internet
.
El
caso
Zimmermann
se
hab√≠a


convertido
en
la
historia
de
una
persona
inocente
luchando
por
sus
derechos
contra
los


abusos
de
un
gobierno
fuerte
.
La
rendici√≥n
del
gobierno
fue
muy
bien
recibida
,
en
parte


debido
a
la
campa√±a
en
favor
de
la
censura
en
Internet
que
estaba
teniendo
lugar
en
el


Congreso
americano
y
a
las
presiones
del
FBI
para
que
se
aumentaran
las
facultades
de


intercepci√≥n
de
las
comunicaciones
concedidas
al
gobierno
.


Despu√©s
de
que
el
gobierno
abandonara
el
caso
,
Zimmermann
fund√≥
PGP
Inc
.
,
que
fue


adquirida
por
Network
Associates
en
diciembre
de
1997
.
Zimmermann
es
ahora
un
consultor


independiente
en
el
campo
de
la
criptograf√≠a
.


HISTORIA


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6908.5
‚Ä¢
CONEXIONES
TCP
SEGURAS
:
SSL
691


-----BEGIN
PGP
MESSAGE-----


Version
:
PGP
for
Personal
Privacy
5.0


u2R4d+/jKmn8Bc5+hgDsqAewsDfrGdszX68liKm5F6Gc4sDfcXyt


RfdS10juHgbcfDssWe7
/
K
=
lKhnMikLo0
+
1
/
BvcX4t==Ujk9PbcD4


Thdf2awQfgHbnmKlok8iy6gThlp


-----END
PGP
MESSAGE


Figura
8.24
‚Ä¢
Un
mensaje
PGP
secreto
.


PGP
tambi√©n
proporciona
un
mecanismo
para
la
certificaci√≥n
de
clave
p√∫blica
,
pero
el


mecanismo
es
bastante
distinto
del
sistema
m√°s
convencional
basado
en
autoridades
de
cer-


tificaci√≥n
.
Las
claves
p√∫blicas
PGP
est√°n
certificadas
por
una
red
de
confianza
.
La
propia


Alicia
puede
certificar
cualquier
pareja
de
clave
/
nombre
de
usuario
cuando
crea
que
esa


pareja
es
realmente
correcta
.
Adem√°s
,
PGP
permite
que
Alicia
diga
que
conf√≠a
en
alg√∫n
otro


usuario
a
la
hora
de
certificar
la
autenticidad
de
otras
claves
.
Algunos
otros
usuarios
PGP


firman
mutuamente
sus
claves
manteniendo
reuniones
espec√≠ficas
de
firma
de
claves
.
Los


usuarios
se
re√∫nen
f√≠sicamente
,
intercambian
sus
claves
p√∫blicas
y
certifican
las
claves
unos


con
otros
firm√°ndolas
con
sus
claves
privadas
.


8.5
Conexiones
TCP
seguras
:
SSL


En
la
secci√≥n
anterior
hemos
visto
c√≥mo
las
t√©cnicas
criptogr√°ficas
pueden
proporcionar


confidencialidad
,
integridad
de
los
datos
y
autenticaci√≥n
del
punto
terminal
a
una
aplicaci√≥n


espec√≠fica
,
que
en
nuestro
caso
concreto
era
el
correo
electr√≥nico
.
En
esta
secci√≥n
vamos
a


descender
un
nivel
dentro
de
la
pila
de
protocolos
para
examinar
c√≥mo
puede
utilizarse
la


criptograf√≠a
para
mejorar
los
servicios
de
seguridad
de
TCP
,
incluyendo
la
confidencialidad
,


la
integridad
de
los
datos
y
la
autenticaci√≥n
del
punto
terminal
.
Esta
versi√≥n
mejorada
de


TCP
se
conoce
com√∫nmente
como
Capa
de
sockets
seguros
(
SSL
,
Secure
Sockets
Layer
)
.


Una
versi√≥n
ligeramente
modificada
de
SSL
versi√≥n
3
,
denominada
Seguridad
de
la
capa


de
transporte
(
TLS
,
Transport
Layer
Security
)
,
ha
sido
estandarizada
por
el
IETF
[
RFC


2246
]
.


SSL
fue
dise√±ado
originalmente
por
Netscape
,
pero
las
ideas
b√°sicas
subyacentes
a


dotar
de
seguridad
a
TCP
han
terminado
evolucionando
a
partir
de
los
trabajos
de
Netscape


(
consulte
,
por
ejemplo
,
Woo
[
Woo
1994
]
)
.
Desde
su
invenci√≥n
,
SSL
ha
disfrutado
de
una


amplia
implantaci√≥n
.
SSL
est√°
soportado
por
todos
los
navegadores
y
servidores
web
m√°s


populares
y
es
empleado
por
la
pr√°ctica
totalidad
de
los
sitios
de
comercio
electr√≥nico
de


Internet
(
incluyendo
Amazon
,
eBay
,
Yahoo
!
,
MSN
,
etc.
)
.
Anualmente
se
gastan
decenas


de
miles
de
millones
de
euros
a
trav√©s
de
SSL
.
De
hecho
,
si
el
lector
ha
realizado
en


alguna
ocasi√≥n
una
compra
por
Internet
con
su
tarjeta
de
cr√©dito
,
la
comunicaci√≥n
entre
su


navegador
y
el
servidor
para
dicha
compra
tuvo
lugar
,
casi
con
total
seguridad
,
sobre
SSL
.


(
Puede
verificar
que
su
navegador
est√°
usando
SSL
viendo
si
el
URL
comienza
por
https
:


en
lugar
de
por
http
:
.
)


Para
entender
la
necesidad
de
SSL
,
analicemos
un
escenario
de
comercio
electr√≥nico


t√≠pico
por
Internet
.
Imagine
que
Benito
est√°
navegando
por
la
Web
y
que
accede
al
sitio
web


de
la
empresa
Alicia
Incorporated
,
que
se
dedica
a
la
venta
de
perfumes
.
El
sitio
Alicia


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
691Incorporated
muestra
un
formulario
en
el
que
se
supone
que
Benito
debe
indicar
el
tipo
de


perfume
y
la
cantidad
deseada
,
junto
con
su
direcci√≥n
y
el
n√∫mero
de
su
tarjeta
de
cr√©dito
.


Benito
introduce
esta
informaci√≥n
,
hace
clic
en
el
bot√≥n
Enviar
y
espera
recibir
(
por
correo


postal
ordinario
)
los
perfumes
adquiridos
;
tambi√©n
espera
recibir
un
cargo
correspondiente
a


ese
pedido
en
su
siguiente
extracto
de
la
tarjeta
de
cr√©dito
.
Todo
esto
suena
muy
bien
,
pero


si
no
se
adopta
ninguna
medida
de
seguridad
Benito
podr√≠a
encontrarse
con
algunas
sor-pre-


sas
.


‚Ä¢
Si
no
se
utiliza
ning√∫n
tipo
de
confidencialidad
(
cifrado
)
,
un
intruso
podr√≠a
interceptar
el


pedido
de
Benito
y
obtener
la
informaci√≥n
de
su
tarjeta
de
cr√©dito
.
El
intruso
podr√≠a


entonces
realizar
compras
a
expensas
de
Benito
.


‚Ä¢S
i
 
n
o
 
s
e
 
u
t
i
l
i
z
a
 
n
i
n
g
√∫
n
 
m
e
c
a
n
i
s
m
o
 
q
u
e
 
g
a
r
a
n
t
i
c
e
 
l
a
 
i
n
t
e
g
r
i
d
a
d
 
d
e
 
l
o
s
 
d
a
t
o
s
,
 
u
n
 
i
n
t
r
u
s
o


podr√≠a
modificar
el
pedido
de
Benito
,
haci√©ndole
comprar
diez
veces
m√°s
frascos
de
per-


fume
de
los
deseados
.


‚Ä¢P
o
r
 
√∫
l
t
i
m
o
,
 
s
i
 
n
o
 
s
e
 
u
t
i
l
i
z
a
 
n
i
n
g
√∫
n
 
t
i
p
o
 
d
e
 
a
u
t
e
n
t
i
c
a
c
i
√≥
n
 
d
e
l
 
s
e
r
v
i
d
o
r
,
 
c
u
a
l
q
u
i
e
r
 
s
e
r
v
i
d
o
r


podr√≠a
mostrar
el
famoso
logotipo
de
Alicia
Incorporated
cuando
en
realidad
nos
encon-


tr√°ramos
en
un
sitio
mantenido
por
Tom√°s
,
que
est√°
haci√©ndose
pasar
por
Alicia
Incorpo-


rated
.
Despu√©s
de
recibir
el
pedido
de
Benito
,
Tom√°s
podr√≠a
tomar
el
dinero
de
Benito
y


salir
corriendo
.
O
Tom√°s
podr√≠a
efectuar
un
robo
de
identidad
,
recopilando
los
datos
rela-


tivos
al
nombre
,
la
direcci√≥n
y
el
n√∫mero
de
tarjeta
de
cr√©dito
de
Benito
.


SSL
solventa
estos
problemas
mejorando
TCP
con
servicios
de
confidencialidad
,
integridad


de
los
datos
,
autenticaci√≥n
del
servidor
y
autenticaci√≥n
del
cliente
.


SSL
se
emplea
a
menudo
para
proporcionar
seguridad
a
las
transacciones
que
tienen


lugar
a
trav√©s
de
HTTP
.
Sin
embargo
,
puesto
que
SSL
dota
de
seguridad
a
TCP
,
puede
ser


empleado
por
cualquier
aplicaci√≥n
que
se
ejecute
sobre
TCP
.
SSL
proporciona
una
Interfaz


de
programaci√≥n
de
aplicaciones
(
API
,
Application
Programmer
Interface
)
simple
con
soc-


kets
,
que
es
similar
y
an√°loga
a
la
API
de
TCP
.
Cuando
una
aplicaci√≥n
desea
utilizar
SSL
,
la


aplicaci√≥n
incluye
clases
/
bibliotecas
SSL
.
Como
se
muestra
en
la
Figura
8.25
,
aunque
SSL


reside
t√©cnicamente
en
la
capa
de
aplicaci√≥n
,
desde
la
perspectiva
del
desarrollador
se
trata


de
un
protocolo
de
transporte
que
proporciona
servicios
TCP
mejorados
con
servicios
de


seguridad
.


692
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


TCP


subcapa
SSL


IP


Aplicaci√≥n


Capa
de


aplicaci√≥n


TCP
mejorado
con
SSL


socket
SSL


socket
TCP


TCP


IP


Aplicaci√≥n


API
de
TCP


socket
TCP


Figura
8.25
‚Ä¢
Aunque
t√©cnicamente
SSL
reside
en
la
capa
de
aplicaci√≥n
,
desde


la
perspectiva
del
desarrollador
se
trata
de
un
protocolo
de
la


capa
de
transporte
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6928.5.1
Panor√°mica
general


Comenzaremos
describiendo
una
versi√≥n
simplificada
de
SSL
,
una
que
nos
va
a
permitir


obtener
una
panor√°mica
general
del
por
qu√©
y
el
c√≥mo
de
SSL
.
Haremos
referencia
a
esta


versi√≥n
simplificada
de
SSL
como
‚Äú
casi-SSL
‚Äù
.
Despu√©s
de
describir
esta
versi√≥n
,
en
la


siguiente
subsecci√≥n
pasaremos
a
describir
en
detalle
el
protocolo
SSL
real
.
Tanto
la
versi√≥n


casi-SSL
como
SSL
se
componen
de
tres
fases
:
acuerdo
,
deducci√≥n
de
la
clave
y
trans-


ferencia
de
datos
.
A
continuaci√≥n
vamos
a
describir
las
tres
fases
de
una
sesi√≥n
de
comuni-


caci√≥n
entre
un
cliente
(
Benito
)
y
un
servidor
(
Alicia
)
,
teniendo
Alicia
una
pareja
de
claves


privada
/
p√∫blica
y
un
certificado
que
asocia
su
identidad
con
su
clave
p√∫blica
.


Fase
de
acuerdo


Durante
la
fase
de
acuerdo
,
Benito
tiene
que
(
a
)
establecer
una
conexi√≥n
TCP
con
Alicia
,


(
b
)
verificar
que
Alicia
es
realmente
Alicia
y
(
c
)
enviar
a
Alicia
una
clave
secreta
maestra
,


que
ambos
emplear√°n
para
generar
todas
las
claves
sim√©tricas
que
necesiten
para
la
sesi√≥n


SSL
.
Estos
tres
pasos
se
muestran
en
la
Figura
8.26
.
Observe
que
,
una
vez
que
se
ha
estable-


cido
la
conexi√≥n
TCP
,
Benito
env√≠a
a
Alicia
un
mensaje
de
saludo
.
A
continuaci√≥n
,
Alicia


responde
con
su
certificado
,
que
contiene
su
clave
p√∫blica
.
Como
se
ha
explicado
en
la
Sec-


ci√≥n
8.3
,
dado
que
el
certificado
ha
sido
emitido
por
una
autoridad
de
certificaci√≥n
,
Benito


puede
estar
seguro
de
que
la
clave
p√∫blica
del
certificado
pertenece
a
Alicia
.
Benito
genera


entonces
una
clave
maestra
(
MS
,
Master
Secret
)
,
la
cual
s√≥lo
utilizar√°
para
esta
sesi√≥n
SSL
;


cifra
la
MS
con
la
clave
p√∫blica
de
Alicia
para
crear
la
clave
maestra
cifrada
(
EMS
,
Encyrp-


ted
Master
Secret
)
y
se
la
env√≠a
a
Alicia
.
√âsta
descifra
la
clave
maestra
cifrada
con
su
clave


privada
para
obtener
la
clave
maestra
(
MS
)
.
Despu√©s
de
esta
fase
,
tanto
Benito
como
Alicia


(
y
nadie
m√°s
)
conocen
la
clave
maestra
para
esta
sesi√≥n
SSL
.


8.5
‚Ä¢
CONEXIONES
TCP
SEGURAS
:
SSL
693


TCP
SYN


TCP
/
SYNACK


Descifra
la
EMS
con


KA


‚Äì
 
para
obtener
la
MS


EMS
=
KA


+
(
MS
)


TCP
ACK


SSL
hello


certificate(b
)


(
a
)


(
c
)


Crea
la
clave


maestra
(
MS
)


Figura
8.26
‚Ä¢
La
fase
de
acuerdo
de
casi-SSL
comienza
con


una
conexi√≥n
TCP
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
693Deducci√≥n
de
las
claves


En
principio
,
la
MS
,
ahora
compartida
por
Benito
y
Alicia
,
podr√≠a
emplearse
como
la
clave


de
sesi√≥n
sim√©trica
para
todos
los
cifrados
y
comprobaciones
de
integridad
de
los
datos
sub-


siguientes
.
Sin
embargo
,
generalmente
,
se
considera
m√°s
seguro
que
Alicia
y
Benito
utilicen


claves
criptogr√°ficas
distintas
y
tambi√©n
que
empleen
claves
distintas
para
el
cifrado
y
las


comprobaciones
de
integridad
.
Por
tanto
,
tanto
Alicia
como
Benito
utilizan
la
clave
maestra


para
generar
cuatro
claves
:


‚Ä¢E
B
=
clave
de
cifrado
de
sesi√≥n
para
los
datos
que
Benito
env√≠a
a
Alicia
.


‚Ä¢M
B
=
clave
MAC
de
sesi√≥n
para
los
datos
que
Benito
env√≠a
a
Alicia
.


‚Ä¢E
A
=
clave
de
cifrado
de
sesi√≥n
para
los
datos
que
Alicia
env√≠a
a
Benito
.


‚Ä¢M
A
=
clave
MAC
de
sesi√≥n
para
los
datos
que
Alicia
env√≠a
a
Benito
.


Tanto
Alicia
como
Benito
generan
las
cuatro
claves
a
partir
de
la
clave
maestra
(
MS
)
.
Esto


podr√≠a
hacerse
simplemente
dividiendo
la
clave
maestra
en
cuatro
claves
(
pero
,
como
vere-


mos
,
esto
es
un
poco
m√°s
complicado
en
el
protocolo
SSL
real
)
.
Al
terminar
la
fase
de


deducci√≥n
de
claves
,
tanto
Alicia
como
Benito
disponen
de
las
cuatro
claves
.
Las
dos
claves


de
cifrado
se
utilizar√°n
para
cifrar
los
datos
y
las
dos
claves
MAC
se
emplear√°n
para
verifi-


car
la
integridad
de
los
datos
.


Transferencia
de
datos


Ahora
que
Alicia
y
Benito
comparten
las
cuatro
mismas
claves
de
sesi√≥n
(
EB
,
MB
,
EA
y
MA
)


pueden
comenzar
a
enviarse
datos
de
forma
segura
a
trav√©s
de
la
conexi√≥n
TCP
.
Puesto
que


TCP
es
un
protocolo
de
flujos
de
bytes
,
una
t√©cnica
natural
ser√≠a
que
SSL
cifrara
los
datos
de


aplicaci√≥n
sobre
la
marcha
y
luego
pasara
esos
datos
cifrados
tambi√©n
sobre
la
marcha
a


TCP
.
Pero
,
si
hacemos
esto
as√≠
,
¬ø
d√≥nde
incluir√≠amos
el
valor
MAC
necesario
para
compro-


bar
la
integridad
?
Realmente
,
no
es
deseable
tener
que
esperar
a
que
termine
la
sesi√≥n
TCP


para
verificar
la
integridad
de
todos
los
datos
que
Benito
ha
estado
enviando
a
lo
largo
de
la


sesi√≥n
completa
.
Para
resolver
este
problema
,
SSL
divide
el
flujo
de
datos
en
registros
,
a√±ade


un
c√≥digo
MAC
a
cada
registro
para
comprobar
la
integridad
y
luego
cifra
el
registro
junto


con
el
c√≥digo
MAC
.
Para
crear
el
valor
MAC
,
Benito
introduce
los
datos
del
registro
y
la


clave
MB
en
una
funci√≥n
hash
,
como
hemos
visto
en
la
Secci√≥n
8.3
.
Para
cifrar
el
paquete


formado
por
el
registro
y
el
valor
MAC
,
Benito
utiliza
su
clave
de
cifrado
de
sesi√≥n
EB
.
Este


paquete
cifrado
se
pasa
entonces
a
TCP
para
transportarlo
a
trav√©s
de
Internet
.


Aunque
este
m√©todo
permite
resolver
bastantes
de
los
problemas
,
sigue
sin
ser
perfecto


en
lo
que
se
refiere
a
proporcionar
integridad
de
los
datos
para
todo
el
flujo
de
mensajes
.
En


particular
,
suponga
que
Tom√°s
es
un
intruso
que
lleva
a
cabo
un
ataque
por
interposici√≥n
y


que
tiene
la
capacidad
de
insertar
,
borrar
y
sustituir
segmentos
en
el
flujo
de
segmentos
TCP


enviados
entre
Alicia
y
Benito
.
Tom√°s
,
por
ejemplo
,
podr√≠a
capturar
dos
segmentos
enviados


por
Benito
,
invertir
el
orden
de
los
mismos
,
ajustar
los
n√∫meros
de
secuencia
TCP
(
que
no


est√°n
cifrados
)
y
luego
enviar
los
dos
segmentos
en
orden
inverso
a
Alicia
.
Suponiendo
que


cada
segmento
TCP
encapsula
exactamente
un
registro
,
vamos
a
ver
ahora
c√≥mo
procesar√≠a


Alicia
dichos
segmentos
.


1
.
El
TCP
que
se
ejecuta
en
Alicia
pensar√°
que
todo
es
correcto
y
pasar√°
los
dos
registros
a


la
subcapa
SSL
.


694
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
6942
.
SSL
en
Alicia
descifrar√°
los
dos
registros
.


3
.
SSL
en
Alicia
utilizar√≠a
la
clave
MAC
en
cada
registro
para
verificar
la
integridad
de


los
datos
de
los
dos
registros
.


4
.
SSL
pasar√≠a
a
continuaci√≥n
los
flujos
de
bytes
descifrados
de
los
dos
registros
a
la
capa


de
aplicaci√≥n
;
pero
el
flujo
de
bytes
completo
recibido
por
Alicia
no
estar√≠a
en
el
orden


correcto
debido
a
la
inversi√≥n
del
orden
de
los
registros
.


Animamos
al
lector
a
examinar
escenarios
similares
para
los
casos
en
que
Tom√°s
elimine
o


reproduzca
segmentos
.


La
soluci√≥n
a
este
problema
,
como
probablemente
ya
habr√°
imaginado
,
consiste
en
uti-


lizar
n√∫meros
de
secuencia
.
SSL
hace
esto
de
la
forma
siguiente
:
Benito
mantiene
un
conta-


dor
de
n√∫mero
de
secuencia
,
que
inicializa
en
cero
y
que
incrementa
cada
vez
que
env√≠a
un


registro
SSL
.
Benito
no
incluye
realmente
un
n√∫mero
de
secuencia
en
el
propio
registro
,


sino
que
cuando
calcula
el
c√≥digo
MAC
incluye
el
n√∫mero
secuencia
en
el
c√°lculo
del


c√≥digo
MAC
.
As√≠
,
ahora
el
valor
MAC
es
un
hash
de
los
datos
m√°s
la
clave
MAC
M
B
m√°s


el
n√∫mero
de
secuencia
actual
.
Alicia
controla
los
n√∫meros
de
secuencia
de
Benito
,


pudiendo
verificar
la
integridad
de
los
datos
de
un
registro
incluyendo
el
n√∫mero
de
secuen-


cia
apropiado
en
el
c√°lculo
de
MAC
.
Este
uso
de
los
n√∫meros
de
secuencia
SSL
impide
que


Tom√°s
lleve
a
cabo
un
ataque
por
interposici√≥n
,
tal
como
la
reordenaci√≥n
o
reproducci√≥n
de


segmentos
(
¬ø
por
qu√©
?
)
.


Registro
SSL


En
la
Figura
8.27
se
muestra
el
registro
SSL
(
as√≠
como
el
registro
casi-SSL
)
.
El
registro


consta
de
un
campo
de
tipo
,
un
campo
de
versi√≥n
,
un
campo
de
longitud
,
un
campo
de
datos


y
un
campo
MAC
.
Observe
que
los
tres
primeros
campos
no
est√°n
cifrados
.
El
campo
de


tipo
indica
si
el
registro
es
un
mensaje
de
la
fase
de
acuerdo
o
un
mensaje
que
contiene
datos


de
aplicaci√≥n
.
Tambi√©n
se
utiliza
para
cerrar
la
conexi√≥n
SSL
,
como
explicamos
m√°s
ade-


lante
.
SSL
en
el
terminal
receptor
utiliza
el
campo
de
longitud
para
extraer
los
registros
SSL


del
flujo
de
bytes
TCP
entrante
.
El
campo
de
versi√≥n
se
explica
por
s√≠
mismo
.


8.5.2
Una
panor√°mica
m√°s
completa


En
la
subsecci√≥n
anterior
nos
hemos
ocupado
del
protocolo
casi-SSL
;
esto
ha
servido
para


proporcionarnos
un
conocimiento
b√°sico
acerca
del
por
qu√©
y
del
c√≥mo
de
SSL
.
Ahora
que


ya
tenemos
una
idea
b√°sica
de
SSL
,
podemos
profundizar
un
poco
y
examinar
los
fundamen-


tos
del
protocolo
SSL
real
.
En
paralelo
con
la
lectura
de
esta
descripci√≥n
del
protocolo
SSL
,


le
animamos
a
que
complete
la
pr√°ctica
de
laboratorio
acerca
de
SSL
con
Wireshark
,
disponi-


ble
en
el
sitio
web
del
libro
.


8.5
‚Ä¢
CONEXIONES
TCP
SEGURAS
:
SSL
695


Versi√≥n
LongitudTipo
Datos
MAC


Cifrado
con
EB


Figura
8.27
‚Ä¢
Formato
de
registro
para
SSL
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
695Fase
de
acuerdo
de
SSL


SSL
no
obliga
a
que
Alicia
y
Benito
utilicen
un
algoritmo
de
clave
sim√©trica
espec√≠fico
,
un


algoritmo
de
clave
p√∫blica
espec√≠fico
ni
un
c√≥digo
MAC
espec√≠fico
.
En
su
lugar
,
SSL
per-


mite
que
Alicia
y
Benito
acuerden
al
principio
de
la
sesi√≥n
SSL
,
durante
la
fase
de
acuerdo
,


los
algoritmos
criptogr√°ficos
que
van
a
emplear
.
Adem√°s
,
durante
la
fase
de
acuerdo
,
Alicia


y
Benito
se
intercambian
n√∫meros
distintivos
,
que
se
utilizan
en
la
creaci√≥n
de
las
claves
de


sesi√≥n
(
EB
,
MB
,
EA
y
MA
)
.
Los
pasos
de
la
fase
de
acuerdo
del
protocolo
SSL
real
son
los


siguientes
:


1
.
El
cliente
env√≠a
la
lista
de
algoritmos
criptogr√°ficos
que
soporta
,
junto
con
un
n√∫mero


distintivo
de
cliente
.


2
.
A
partir
de
la
lista
,
el
servidor
elige
un
algoritmo
sim√©trico
(
por
ejemplo
,
AES
)
,
un
algo-


ritmo
de
clave
p√∫blica
(
por
ejemplo
,
RSA
con
una
longitud
espec√≠fica
de
clave
)
y
un


algoritmo
MAC
.
Devuelve
al
cliente
las
elecciones
que
ha
hecho
,
as√≠
como
un
certifi-


cado
y
un
n√∫mero
distintivo
de
servidor
.


3
.
El
cliente
verifica
el
certificado
,
extrae
la
clave
p√∫blica
del
servidor
,
genera
una
clave


pre-maestra
(
PMS
,
Pre-Master
Secret
)
,
cifra
la
PMS
con
la
clave
p√∫blica
del
servidor
y


env√≠a
la
PMS
cifrada
al
servidor
.


4
.
Utilizando
la
misma
funci√≥n
de
deducci√≥n
de
clave
(
como
la
especificada
por
el


est√°ndar
SSL
)
,
el
cliente
y
el
servidor
calculan
independientemente
la
clave
maestra


(
MS
)
a
partir
de
la
PMS
y
de
los
n√∫meros
distintivos
.
La
PMS
se
divide
entonces
para


generar
las
dos
claves
de
cifrado
y
las
dos
claves
MAC
.
Adem√°s
,
cuando
el
cifrado


sim√©trico
elegido
emplea
CBC
(
tal
como
3DES
o
AES
)
tambi√©n
se
obtienen
a
partir


de
la
PMS
dos
vectores
de
inicializaci√≥n
(
IV
)
,
uno
para
cada
lado
de
la
conexi√≥n
.
A


partir
de
este
momento
todos
los
mensajes
intercambiados
entre
el
cliente
y
el
servi-


dor
son
cifrados
y
autenticados
(
con
un
c√≥digo
MAC
)
.


5
.
El
cliente
env√≠a
un
c√≥digo
MAC
de
todos
los
mensajes
de
acuerdo
.


6
.
El
servidor
env√≠a
un
c√≥digo
MAC
de
todos
los
mensajes
de
acuerdo
.


Los
dos
√∫ltimos
pasos
protegen
el
procedimiento
de
acuerdo
frente
a
posibles
modifica-


ciones
de
los
datos
.
Para
comprobarlo
,
observe
que
en
el
paso
1
el
cliente
normalmente


ofrece
una
lista
de
algoritmos
(
algunos
de
ellos
fuertes
y
otros
m√°s
d√©biles
)
.
Esta
lista
de


algoritmos
se
env√≠a
como
texto
en
claro
,
dado
que
todav√≠a
no
se
han
acordado
los
algorit-


mos
de
cifrado
y
las
claves
.
Tom√°s
,
como
atacante
interpuesto
(
man-in-the-middle
)
,
podr√≠a


borrar
los
algoritmos
m√°s
fuertes
de
la
lista
obligando
al
cliente
a
seleccionar
un
algoritmo


d√©bil
.
Para
evitar
un
ataque
por
modificaci√≥n
,
en
el
paso
5
el
cliente
env√≠a
un
valor
MAC
de


la
concatenaci√≥n
de
todos
los
mensajes
de
acuerdo
que
ha
enviado
y
ha
recibido
.
El
servidor


puede
comparar
dicho
valor
MAC
con
el
valor
MAC
de
los
mensajes
de
acuerdo
que
haya


recibido
y
enviado
.
Si
existe
alguna
incoherencia
,
el
servidor
puede
terminar
la
conexi√≥n
.


De
forma
similar
,
el
servidor
env√≠a
un
mensaje
MAC
de
los
mensajes
de
acuerdo
que
ha


visto
,
permitiendo
al
cliente
detectar
cualquier
incoherencia
.


El
lector
puede
estar
pregunt√°ndose
por
qu√©
se
introducen
valores
distintivos
en
los


pasos
1
y
2
.
¬ø
No
bastar√≠a
con
utilizar
n√∫meros
de
secuencia
para
impedir
los
ataques
por


reproducci√≥n
de
segmentos
?
La
respuesta
es
que
s√≠
,
pero
esos
n√∫meros
de
secuencia
no


impiden
,
por
s√≠
mismos
,
los
‚Äú
ataques
por
reproducci√≥n
de
la
conexi√≥n
‚Äù
.
Considere
,
por


ejemplo
,
el
siguiente
ataque
por
reproducci√≥n
de
la
conexi√≥n
:
suponga
que
Tom√°s
captura


696
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
696todos
los
mensajes
intercambiados
entre
Alicia
y
Benito
.
Al
d√≠a
siguiente
,
Tom√°s
se
hace


pasar
por
Benito
y
env√≠a
a
Alicia
exactamente
la
misma
secuencia
de
mensajes
que
Benito


le
envi√≥
el
d√≠a
anterior
.
Si
Alicia
no
utiliza
n√∫meros
distintivos
responder√°
con
exactamente


la
misma
secuencia
de
mensajes
que
envi√≥
el
d√≠a
anterior
.
Alicia
no
sospechar√°
nada
raro
,
ya


que
cada
mensaje
que
reciba
pasar√°
las
comprobaciones
de
integridad
.
Si
Alicia
es
un
servi-


dor
de
comercio
electr√≥nico
,
pensar√°
que
Benito
est√°
realizando
un
segundo
pedido
(
solici-


tando
exactamente
los
mismos
art√≠culos
)
.
Por
otro
lado
,
incluyendo
un
n√∫mero
distintivo
en


el
protocolo
Alicia
enviar√°
n√∫meros
distintivos
diferentes
en
cada
sesi√≥n
TCP
,
haciendo
que


las
claves
de
cifrado
sean
distintas
en
cada
uno
de
los
dos
d√≠as
.
Por
tanto
,
cuando
Alicia


reciba
una
serie
de
registros
SSL
reproducidos
procedentes
de
Tom√°s
,
esos
registros
no


pasar√°n
las
comprobaciones
de
integridad
y
la
transacci√≥n
de
comercio
electr√≥nico
falsa
no


llegar√°
a
completarse
.
En
resumen
,
en
SSL
los
n√∫meros
distintivos
se
emplean
para
defen-


derse
de
los
‚Äú
ataques
por
reproducci√≥n
de
la
conexi√≥n
‚Äù
,
mientras
que
los
n√∫meros
de


secuencia
se
emplean
para
defenderse
frente
a
la
reproducci√≥n
de
paquetes
individuales


durante
un
sesi√≥n
activa
.


Cierre
de
la
conexi√≥n


En
alg√∫n
momento
,
Benito
o
Alicia
querr√°n
terminar
la
sesi√≥n
SSL
.
Una
posible
t√©cnica


consistir√≠a
en
dejar
que
Benito
terminara
la
sesi√≥n
SSL
simplemente
terminando
la
conexi√≥n


TCP
subyacente
;
es
decir
,
hacer
que
Benito
env√≠e
un
segmento
TCP
FIN
a
Alicia
.
Pero
ese


dise√±o
tan
simplista
abre
la
puerta
a
los
ataques
de
truncamiento
en
los
que
Tom√°s
se
intro-


duce
de
nuevo
en
mitad
de
una
sesi√≥n
SSL
activa
y
termina
la
sesi√≥n
prematuramente
con


un
segmento
TCP
FIN
.
Si
Tom√°s
hiciera
esto
,
Alicia
pensar√≠a
que
ha
recibido
todos
los
datos


de
Benito
,
cuando
en
realidad
s√≥lo
ha
recibido
una
parte
de
los
mismos
.
La
soluci√≥n
a
este


problema
consiste
en
indicar
en
el
campo
de
tipo
si
el
registro
sirve
para
terminar
la
sesi√≥n


SSL
.
(
Aunque
el
tipo
SSL
se
env√≠a
como
texto
en
claro
,
siempre
es
autenticado
en
el
recep-


tor
utilizando
el
valor
MAC
del
registro
.
)
Incluyendo
dicho
campo
,
si
Alicia
recibiera
un


segmento
TCP
FIN
antes
de
recibir
un
registro
SSL
de
cierre
deducir√≠a
inmediatamente
que


algo
raro
est√°
sucediendo
.


Esto
completa
nuestra
introducci√≥n
a
SSL
.
Hemos
visto
que
esta
tecnolog√≠a
utiliza


muchos
de
los
principios
criptogr√°ficos
explicados
en
la
Secciones
8.2
y
8.3
.
Los
lectores


que
deseen
explorar
SSL
a
un
nivel
m√°s
profundo
pueden
consultar
el
libro
de
Rescorla


sobre
SSL
,
que
es
bastante
c√≥modo
de
leer
[
Rescorla
2001
]
.


8.6
Seguridad
de
la
capa
de
red
:
IPsec


y
redes
privadas
virtuales


El
protocolo
de
seguridad
IP
,
m√°s
conocido
como
IPsec
,
proporciona
seguridad
en
la
capa


de
red
.
IPsec
proporciona
seguridad
a
los
datagramas
IP
intercambiados
por
cualesquiera


dos
entidades
de
la
capa
de
red
,
incluyendo
hosts
y
routers
.
Como
enseguida
veremos
,


muchas
instituciones
(
corporaciones
,
agencias
gubernamentales
,
organizaciones
sin
√°nimo


de
lucro
,
etc.
)
utilizan
IPsec
para
crear
redes
privadas
virtuales
(
VPN
)
,
que
funcionan


sobre
la
red
Internet
p√∫blica
.


Antes
de
entrar
en
los
detalles
espec√≠ficos
de
IPsec
,
demos
un
paso
atr√°s
y
consideremos


qu√©
es
lo
que
implica
proporcionar
confidencialidad
en
la
capa
de
red
.
Con
la
confidenciali-


8.6
‚Ä¢
SEGURIDAD
DE
LA
CAPA
DE
RED
:
IPSEC
Y
REDES
PRIVADAS
VIRTUALES
697


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
697dad
en
la
capa
de
red
entre
una
pareja
de
entidades
de
red
(
por
ejemplo
,
entre
dos
routers
,


entre
dos
hosts
o
entre
un
router
y
un
host
)
la
entidad
emisora
cifra
las
cargas
√∫tiles
de
todos


los
datagramas
que
env√≠e
hacia
la
entidad
receptora
.
La
carga
√∫til
cifrada
podr√≠a
ser
un
seg-


mento
TCP
,
un
segmento
UDP
,
un
mensaje
ICMP
,
etc.
Si
dispusi√©ramos
de
tal
servicio
de
la


capa
de
red
,
todos
los
datos
enviados
de
una
entidad
a
la
otra
(
incluyendo
los
mensajes
de


correo
electr√≥nico
,
las
p√°ginas
web
,
los
mensajes
de
acuerdo
TCP
y
los
mensajes
de
adminis-


traci√≥n
,
como
ICMP
y
SNMP
)
estar√≠an
ocultos
a
ojos
de
posibles
terceros
que
pudieran
estar


husmeando
los
mensajes
que
circulan
por
la
red
.
Por
esta
raz√≥n
,
decimos
que
la
seguridad
de


la
capa
de
red
proporciona
un
servicio
b√°sico
de
‚Äú
ocultaci√≥n
‚Äù
.


Adem√°s
de
la
confidencialidad
,
un
protocolo
de
seguridad
de
la
capa
de
red
podr√≠a
poten-


cialmente
proporcionar
otros
servicios
de
seguridad
.
Por
ejemplo
,
podr√≠a
ofrecer
mecanismos


de
autenticaci√≥n
del
origen
de
modo
que
la
entidad
receptora
pueda
verificar
cu√°l
es
el
origen


del
datagrama
seguro
.
Un
protocolo
de
seguridad
de
la
capa
de
red
podr√≠a
proporcionar
un
ser-


vicio
de
integridad
de
los
datos
de
modo
que
la
entidad
receptora
pueda
comprobar
si
se
ha
pro-


ducido
alguna
alteraci√≥n
del
datagrama
mientras
√©ste
se
encontraba
en
tr√°nsito
.
Un
servicio
de


seguridad
de
la
capa
de
red
tambi√©n
podr√≠a
proporcionar
mecanismos
para
prevenir
ataques
por


reproducci√≥n
,
lo
que
significa
que
Benito
podr√≠a
detectar
cualquier
datagrama
duplicado
que
un


atacante
pudiera
insertar
.
Como
pronto
veremos
,
IPsec
de
hecho
proporciona
mecanismos
para


todos
estos
servicios
de
seguridad
,
es
decir
,
para
la
confidencialidad
,
la
autenticaci√≥n
de
origen
,


la
integridad
de
los
datos
y
la
prevenci√≥n
de
los
ataques
por
reproducci√≥n
.


8.6.1
IPsec
y
redes
privadas
virtuales
(
VPN
)


Normalmente
,
una
instituci√≥n
que
abarque
m√∫ltiples
regiones
geogr√°ficas
desear√°
disponer


de
su
propia
red
IP
,
de
modo
que
sus
hosts
y
servidores
puedan
intercambiarse
datos
de


forma
segura
y
confidencial
.
Para
conseguir
este
objetivo
,
esta
instituci√≥n
podr√≠a
implantar


realmente
una
red
f√≠sica
independiente
(
incluyendo
routers
,
enlaces
y
una
infraestructura


DNS
)
que
est√©
completamente
separada
de
la
red
Internet
p√∫blica
.
Dicha
red
separada
,
dedi-


cada
a
una
instituci√≥n
concreta
,
se
denomina
red
privada
.
No
es
sorprendente
que
tales


redes
privadas
puedan
llegar
a
ser
muy
costosas
,
ya
que
la
instituci√≥n
necesitar√°
comprar
,


instalar
y
mantener
su
propia
infraestructura
f√≠sica
de
red
.


En
lugar
de
implantar
y
mantener
una
red
privada
,
muchas
instituciones
crean
actual-


mente
redes
VPN
sobre
la
red
Internet
p√∫blica
existente
.
Con
una
VPN
el
tr√°fico
entre
sucur-


sales
se
env√≠a
a
trav√©s
de
la
red
Internet
p√∫blica
,
en
lugar
de
enviarse
a
trav√©s
de
una
red


f√≠sicamente
independiente
.
Pero
para
proporcionar
confidencialidad
,
el
tr√°fico
entre
sucur-


sales
se
cifra
antes
de
entrar
en
la
Internet
p√∫blica
.
En
la
Figura
8.28
se
muestra
un
ejemplo


simple
de
red
VPN
.
Aqu√≠
,
la
instituci√≥n
est√°
compuesta
por
una
oficina
principal
,
una
sucur-


sal
y
una
serie
de
vendedores
itinerantes
que
suelen
acceder
a
Internet
desde
la
habitaci√≥n


de
su
hotel
.
(
En
la
figura
s√≥lo
se
muestra
uno
de
esos
vendedores
.
)
En
esta
VPN
,
cuando
dos


hosts
situados
en
la
oficina
principal
se
intercambian
datagramas
IP
o
cuando
dos
hosts
de
la


sucursal
quieren
comunicarse
utilizan
el
protocolo
simple
y
tradicional
IPv4
(
es
decir
,
sin


servicios
IPsec
)
.
Sin
embargo
,
cuando
dos
hosts
de
la
instituci√≥n
se
comunican
a
trav√©s
de


una
ruta
que
atraviesa
la
red
Internet
p√∫blica
,
el
tr√°fico
se
cifra
antes
de
entrar
en
Internet
.


Para
entender
c√≥mo
funciona
una
red
VPN
,
veamos
un
ejemplo
simple
en
el
contexto
de


la
Figura
8.28
.
Cuando
un
host
de
la
oficina
principal
env√≠a
un
datagrama
IP
a
un
vendedor


que
se
encuentra
en
un
hotel
,
el
router
de
pasarela
de
la
oficina
principal
convierte
el
data-


grama
IPv4
simple
en
un
datagrama
IPsec
y
luego
reenv√≠a
dicho
datagrama
IPsec
hacia
Inter-


698
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
698net
.
Este
datagrama
IPsec
tiene
de
hecho
una
cabecera
IPv4
tradicional
,
de
modo
que
los
rou-


ters
de
la
red
Internet
p√∫blica
procesan
el
datagrama
como
si
se
tratara
de
un
datagrama
IPv4


normal
;
para
ellos
el
datagrama
es
,
de
hecho
,
como
cualquier
otro
.
Pero
como
se
muestra
en


la
Figura
8.28
,
la
carga
√∫til
del
datagrama
IPsec
incluye
una
cabecera
IPsec
,
que
es
utilizada


para
el
procesamiento
IPsec
;
adem√°s
,
la
carga
√∫til
del
datagrama
IPsec
est√°
cifrada
.
Cuando
el


datagrama
IPsec
llega
al
port√°til
del
vendedor
,
el
sistema
operativo
del
equipo
descifra
la


carga
√∫til
y
proporciona
algunos
otros
servicios
de
seguridad
,
como
la
verificaci√≥n
de
la
inte-


gridad
de
los
datos
,
y
pasa
la
carga
√∫til
descifrada
hacia
el
protocolo
de
la
capa
superior
(
por


ejemplo
,
hacia
TCP
o
UDP
)
.


Esto
es
s√≥lo
una
peque√±a
panor√°mica
de
c√≥mo
una
instituci√≥n
podr√≠a
utilizar
IPsec
para


crear
una
red
VPN
.
Para
que
los
√°rboles
no
nos
oculten
el
bosque
,
hemos
dejado
consciente-


mente
de
lado
muchos
detalles
importantes
.
Realicemos
ahora
un
examen
m√°s
detallado
.


8.6.2
Los
protocolos
AH
y
ESP


IPsec
es
un
protocolo
bastante
complejo
que
est√°
definido
en
m√°s
de
una
docena
de
docu-


mentos
RFC
.
Dos
documentos
importantes
son
RFC
4301
,
que
describe
la
arquitectura
glo-


bal
de
seguridad
IP
,
y
RFC
2411
,
que
proporciona
una
panor√°mica
de
la
serie
de
protocolos


IPsec
.
Como
siempre
,
nuestro
objetivo
en
este
libro
de
texto
no
es
simplemente
repetir
los


arcanos
y
√°ridos
documentos
RFC
,
sino
m√°s
bien
adoptar
un
enfoque
m√°s
operativo
y
peda-


g√≥gico
a
la
hora
de
describir
los
protocolos
.


En
la
serie
de
protocolos
IPsec
hay
dos
protocolos
principales
:
el
protocolo
de
Cabe-


cera
de
autenticaci√≥n
(
AH
,
Authentication
Header
)
y
el
protocolo
de
Carga
√∫til
de
segu-


ridad
para
encapsulaci√≥n
(
ESP
,
Encapsulation
Security
Payload
)
.
Cuando
una
entidad


8.6
‚Ä¢
SEGURIDAD
DE
LA
CAPA
DE
RED
:
IPSEC
Y
REDES
PRIVADAS
VIRTUALES
699


Cabecera


IP


Cabecera


IPsec


Carga
√∫til


segura


Cabecera


IP


Cabecera


IPsec


Carga
√∫til


segura


Cabecera


IP


Cabecera


IPsec


Carga
√∫til


segura


Cabecera


IP
Carga
√∫til


Cabecera


IP
Carga
√∫til


Port√°til
con
IPsec


Router


con
IPv4
e


IPsec


Router


con
IPv4
e


IPsec


Sucursal


Oficina
principal


Vendedor


en
hotel


Internet


Figura
8.28
‚Ä¢
Red
privada
virtual
(
VPN
)
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
699IPsec
de
origen
(
normalmente
un
host
o
un
router
)
env√≠a
datagramas
seguros
a
una
entidad


de
destino
(
tambi√©n
un
host
o
un
router
)
lo
hace
con
el
protocolo
AH
o
el
protocolo
ESP
.
El


protocolo
AH
proporciona
autenticaci√≥n
del
origen
e
integridad
de
los
datos
,
pero
no
pro-


porciona
confidencialidad
.
El
protocolo
ESP
proporciona
autenticaci√≥n
del
origen
,
integri-


dad
de
los
datos
y
confidencialidad
.
Puesto
que
la
confidencialidad
a
menudo
es
cr√≠tica
para


las
redes
VPN
y
otras
aplicaciones
IPsec
,
el
protocolo
ESP
se
utiliza
mucho
m√°s
amplia-


mente
que
el
protocolo
AH
.
Con
el
fin
de
desmitificar
IPsec
y
evitar
buena
parte
de
las
com-


plicaciones
asociadas
nos
vamos
por
tanto
a
centrar
exclusivamente
en
el
protocolo
ESP
.


Aquellos
lectores
que
deseen
tambi√©n
aprender
los
fundamentos
del
protocolo
AH
pueden


explorar
los
documentos
RFC
y
otros
recursos
en
l√≠nea
.


8.6.3
Asociaciones
de
seguridad


Los
datagramas
IPsec
se
intercambian
entre
parejas
de
entidades
de
red
,
como
por
ejemplo


entre
dos
hosts
,
entre
dos
routers
o
entre
un
host
y
un
router
.
Antes
de
enviar
datagramas


IPsec
desde
la
entidad
de
origen
a
la
de
destino
,
ambas
entidades
crean
una
conexi√≥n
l√≥gica


en
la
capa
de
red
.
Esta
conexi√≥n
l√≥gica
se
denomina
asociaci√≥n
de
seguridad
(
SA
,
Security


Association
)
.
Una
asociaci√≥n
de
seguridad
es
una
conexi√≥n
l√≥gica
de
tipo
simplex
;
es
decir
,


una
conexi√≥n
unidireccional
desde
el
origen
al
destino
.
Si
ambas
entidades
desean
enviarse


datagramas
seguros
entre
s√≠
,
entonces
ser√°
necesario
establecer
dos
SA
(
es
decir
,
dos
cone-


xiones
l√≥gicas
)
,
una
en
cada
direcci√≥n
.


Por
ejemplo
,
considere
de
nuevo
la
VPN
institucional
de
la
Figura
8.28
.
Esta
instituci√≥n


consta
de
una
oficina
principal
,
una
sucursal
y
un
cierto
n√∫mero
,
por
ejemplo
,
n
,
de
vendedores


itinerantes
.
Supongamos
,
como
ejemplo
,
que
existe
tr√°fico
IPsec
bidireccional
entre
la
oficina


principal
y
la
sucursal
y
entre
la
oficina
principal
y
los
vendedores
.
En
esta
VPN
,
¬ø
cu√°ntas
aso-


ciaciones
de
seguridad
existir√≠an
?
Para
responder
a
esta
cuesti√≥n
,
observe
que
hay
dos
SA
entre


el
router
de
pasarela
de
la
oficina
principal
y
el
router
de
pasarela
de
la
sucursal
(
una
en
cada


direcci√≥n
)
;
para
la
computadora
port√°til
de
cada
vendedor
tambi√©n
habr√°
dos
SA
entre
el
router


de
pasarela
de
la
oficina
principal
y
el
port√°til
(
de
nuevo
,
una
en
cada
direcci√≥n
)
.
Por
tanto
,
en


total
,
habr√°
(
2
+
2n
)
asociaciones
de
seguridad
.
Sin
embargo
,
recuerde
que
no
todo
el
tr√°fico


enviado
hacia
Internet
por
los
routers
de
pasarela
o
por
las
computadoras
port√°tiles
estar√°


protegido
mediante
IPsec
.
Por
ejemplo
,
un
host
situado
en
la
oficina
principal
podr√≠a
querer


acceder
a
un
servidor
web
(
como
Amazon
o
Google
)
disponible
en
la
red
Internet
p√∫blica
.
Por


tanto
,
el
router
de
pasarela
(
y
los
port√°tiles
)
enviar√°
hacia
Internet
tanto
datagramas
IPv4
nor-


males
como
datagramas
dotados
de
seguridad
IPsec
.


Tratemos
ahora
de
examinar
las
interioridades
de
una
asociaci√≥n
de
seguridad
.
Para
que


las
explicaciones
sean
tangibles
y
concretas
vamos
hacerlo
en
el
contexto
de
una
asociaci√≥n


de
seguridad
existente
entre
el
router
R1
y
el
router
R2
de
la
Figura
8.29
.
(
Podemos
consi-


derar
que
el
router
R1
es
el
router
de
pasarela
de
la
oficina
principal
y
que
el
router
R2
es
el


router
de
pasarela
de
la
sucursal
en
el
contexto
de
la
Figura
8.28
.
)
El
router
R1
mantendr√°


una
cierta
informaci√≥n
de
estado
acerca
de
esta
SA
,
la
cual
incluir√°
:


‚Ä¢U
n
 
i
d
e
n
t
i
f
i
c
a
d
o
r
 
d
e
 
3
2
 
b
i
t
s
 
p
a
r
a
 
l
a
 
S
A
,
 
d
e
n
o
m
i
n
a
d
o
 
√çndice
de
par√°metro
de
seguridad


(
SPI
,
Security
Parameter
Index
)
.


‚Ä¢L
a
 
i
n
t
e
r
f
a
z
 
d
e
 
o
r
i
g
e
n
 
d
e
 
l
a
 
S
A
(
e
n
 
e
s
t
e
 
c
a
s
o
,
 
2
0
0
.
1
6
8
.
1
.
1
0
0
)
 
y
 
l
a
 
i
n
t
e
r
f
a
z
 
d
e
 
d
e
s
t
i
n
o
 
d
e
 
l
a


SA
(
en
este
caso
193.68.2.23
)
.


‚Ä¢E
l
 
t
i
p
o
 
d
e
 
c
i
f
r
a
d
o
 
q
u
e
 
s
e
 
v
a
 
a
 
u
t
i
l
i
z
a
r
 
(
p
o
r
 
e
j
e
m
p
l
o
,
 
3
D
E
S
 
c
o
n
 
C
B
C
)
.


700
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
700‚Ä¢
La
clave
de
cifrado
.


‚Ä¢
El
tipo
de
comprobaci√≥n
de
integridad
(
por
ejemplo
,
HMAC
con
MD5
)
.


‚Ä¢
La
clave
de
autenticaci√≥n
.


Cada
vez
que
el
router
R1
necesite
construir
un
datagrama
IPsec
para
reenviarlo
a
tra-


v√©s
de
esta
SA
,
acceder√°
a
esta
informaci√≥n
de
estado
para
determinar
c√≥mo
debe
autenticar


y
cifrar
el
datagrama
.
De
forma
similar
,
el
router
R2
mantendr√°
la
misma
informaci√≥n
de


estado
para
esta
SA
y
utilizar√°
esta
informaci√≥n
para
autenticar
y
descifrar
todos
los
data-


gramas
IPsec
que
lleguen
desde
dicha
asociaci√≥n
de
seguridad
.


Cada
entidad
IPsec
(
router
o
host
)
suele
mantener
informaci√≥n
de
estado
para
muchas


asociaciones
de
seguridad
.
Por
ejemplo
,
en
el
ejemplo
de
la
red
VPN
de
la
Figura
8.28
con
n


vendedores
,
el
router
de
pasarela
de
la
oficina
principal
mantiene
informaci√≥n
de
estado
para


(
2
+
2n
)
asociaciones
de
seguridad
.
Cada
entidad
IPsec
almacena
la
informaci√≥n
de
estado


para
todas
sus
asociaciones
de
seguridad
en
su
Base
de
datos
de
asociaciones
de
seguri-


dad
(
SAD
,
Security
Association
Database
)
,
que
es
una
estructura
de
datos
contenida
en
el


kernel
del
sistema
operativo
de
esa
entidad
.


8.6.4
El
datagrama
IPsec


Habiendo
descrito
las
asociaciones
de
seguridad
,
podemos
ahora
describir
la
estructura
real


del
datagrama
IPsec
.
IPsec
tiene
dos
formas
distintas
de
paquete
,
una
para
el
denominado


modo
t√∫nel
y
otra
para
el
denominado
modo
transporte
.
El
modo
t√∫nel
,
al
ser
m√°s
apro-


piado
para
las
redes
VPN
,
est√°
m√°s
ampliamente
implantado
que
el
modo
transporte
.
Con
el


fin
de
desmitificar
todav√≠a
m√°s
IPsec
y
evitar
buena
parte
de
los
aspectos
m√°s
complejos
,


nos
vamos
a
centrar
por
tanto
exclusivamente
en
el
modo
t√∫nel
.
Una
vez
que
tenga
una


s√≥lida
comprensi√≥n
de
dicho
modo
,
el
lector
deber√≠a
poder
aprender
por
su
cuenta
los
deta-


lles
acerca
del
modo
transporte
.


El
formato
de
paquete
del
datagrama
IPsec
se
muestra
en
la
Figura
8.30
.
Puede
que
el


lector
crea
que
los
formatos
de
paquete
son
aburridos
e
ins√≠pidos
,
pero
pronto
comprobar√°


que
el
datagrama
IPsec
tiene
en
realidad
la
apariencia
y
el
sabor
de
un
manjar
tex-mex
.


Examinemos
los
campos
IPsec
en
el
contexto
de
la
Figura
8.29
.
Suponga
que
el
router
R1


recibe
un
datagrama
IPv4
normal
procedente
del
host
172.16.1.17
(
situado
en
la
red
de
la


oficina
principal
)
que
est√°
destinado
al
host
172.16.2.48
(
situado
en
la
red
de
la
sucursal
)
.


El
router
R1
utiliza
la
siguiente
receta
para
convertir
este
‚Äú
datagrama
IPv4
original
‚Äù
en
un


datagrama
IPsec
:


8.6
‚Ä¢
SEGURIDAD
DE
LA
CAPA
DE
RED
:
IPSEC
Y
REDES
PRIVADAS
VIRTUALES
701


Figura
8.29
‚Ä¢
Asociaci√≥n
de
seguridad
(
SA
)
de
R1
a
R2
.


Internet


SAR1


172.16.1/24


Oficina
principal
Sucursal


200.168.1.100
193.68.2.23


172.16.2/24


R2


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
701‚Ä¢A
√±
a
d
e
 
a
l
 
f
i
n
a
l
 
d
e
l
 
d
a
t
a
g
r
a
m
a
 
I
P
v
4
 
o
r
i
g
i
n
a
l
 
(
¬°
q
u
e
 
i
n
c
l
u
y
e
 
l
o
s
 
c
a
m
p
o
s
 
o
r
i
g
i
n
a
l
e
s
 
d
e
 
c
a
b
e
-


cera
!
)
un
campo
de
‚Äú
cola
ESP
‚Äù
.


‚Ä¢C
i
f
r
a
 
e
l
 
r
e
s
u
l
t
a
d
o
 
u
t
i
l
i
z
a
n
d
o
 
e
l
 
a
l
g
o
r
i
t
m
o
 
y
 
l
a
 
c
l
a
v
e
 
e
s
p
e
c
i
f
i
c
a
d
o
s
 
p
o
r
 
l
a
 
a
s
o
c
i
a
c
i
√≥
n
 
d
e


seguridad
.


‚Ä¢A
√±
a
d
e
 
a
l
 
p
r
i
n
c
i
p
i
o
 
d
e
 
e
s
t
e
 
p
a
q
u
e
t
e
 
c
i
f
r
a
d
o
 
u
n
 
c
a
m
p
o
 
d
e
n
o
m
i
n
a
d
o
 
‚Äú
c
a
b
e
c
e
r
a
 
E
S
P
‚Äù
;
 
e
l


paquete
resultante
se
conoce
como
‚Äú
enchilada
‚Äù
.


‚Ä¢C
r
e
a
 
u
n
 
v
a
l
o
r
 
M
A
C
 
d
e
 
a
u
t
e
n
t
i
c
a
c
i
√≥
n
 
p
a
r
a
 
toda
la
enchilada
utilizando
el
algoritmo
y
la


clave
especificados
en
la
SA
.


‚Ä¢
A√±ade
el
valor
MAC
al
final
de
la
enchilada
formando
as√≠
la
carga
√∫til
.


‚Ä¢P
o
r
 
√∫
l
t
i
m
o
,
 
c
r
e
a
 
u
n
a
 
n
u
e
v
a
 
c
a
b
e
c
e
r
a
 
I
P
c
o
n
 
t
o
d
o
s
 
l
o
s
 
c
a
m
p
o
s
 
c
l
√°
s
i
c
o
s
 
d
e
 
l
a
 
c
a
b
e
c
e
r
a


IPv4
(
que
suman
normalmente
20
bytes
de
longitud
)
y
a√±ade
dicha
cabecera
al
principio


de
la
carga
√∫til
.


Observe
que
el
datagrama
IPsec
resultante
es
un
datagrama
IPv4
perfectamente
normal
,


con
los
campos
tradicionales
de
cabecera
IPv4
seguidos
de
una
carga
√∫til
.
Pero
en
este
caso


la
carga
√∫til
contiene
una
cabecera
ESP
,
el
datagrama
IP
original
,
una
cola
ESP
y
un
campo


de
autenticaci√≥n
ESP
(
estando
cifrados
el
datagrama
original
y
la
cola
ESP
)
.
El
datagrama


IP
original
tiene
el
valor
172.16.1.17
como
direcci√≥n
IP
de
origen
y
el
172.16.2.48
como


direcci√≥n
IP
de
destino
.
Puesto
que
el
datagrama
IPsec
incluye
el
datagrama
IP
original
,


estas
direcciones
se
incluyen
(
y
se
cifran
)
como
parte
de
la
carga
√∫til
del
paquete
IPsec
.


¬ø
Pero
qu√©
sucede
con
las
direcciones
IP
de
origen
y
de
destino
contenidas
en
la
nueva
cabe-


cera
IP
,
es
decir
,
en
la
cabecera
situada
m√°s
a
la
izquierda
en
el
datagrama
IPsec
?
Como


cabr√≠a
esperar
,
esos
valores
se
configuran
con
las
direcciones
de
las
interfaces
de
router
de


origen
y
de
destino
situadas
en
los
dos
extremos
de
los
t√∫neles
,
es
decir
,
con
los
valores


200.168.1.100
y
193.68.2.23
.
Asimismo
,
el
n√∫mero
de
protocolo
en
este
nuevo
campo
de


cabecera
IPv4
no
se
configura
con
el
valor
correspondiente
a
TCP
,
UDP
o
SMTP
,
sino
con


el
valor
50
,
que
indica
que
se
trata
de
un
datagrama
IPsec
que
est√°
empleando
el
protocolo


ESP
.


Despu√©s
de
que
R1
env√≠e
el
datagrama
IPsec
hacia
la
red
Internet
p√∫blica
,
pasar√°
a
tra-


v√©s
de
muchos
routers
antes
de
alcanzar
R2
.
Cada
uno
de
estos
routers
procesar√°
el
data-


grama
como
si
fuera
un
datagrama
normal
;
de
hecho
,
todos
esos
routers
no
son
conscientes


de
que
el
datagrama
est√©
transportando
datos
cifrados
mediante
IPsec
.
Para
estos
routers
de


702
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Nueva


cabecera
IP


Cabecera


ESP


Cola


ESP


MAC


ESP


Cabecera


IP
original


Carga
√∫til
del


datagrama
IP
original


Cifrado


‚Äú
Enchilada
‚Äù
autenticada


Long
.


rellenoRelleno
Siguiente


cabeceraSPI


N√∫mero


de


secuencia


Figura
8.30
‚Ä¢
Formato
del
datagrama
IPsec
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
702la
red
Internet
p√∫blica
,
puesto
que
la
direcci√≥n
IP
de
destino
contenida
en
la
cabecera
externa


es
R2
,
el
destino
√∫ltimo
del
datagrama
es
R2
.


Habiendo
examinado
este
ejemplo
de
c√≥mo
se
construye
un
datagrama
IPsec
,
veamos


ahora
con
m√°s
detalle
los
ingredientes
de
la
enchilada
.
Como
podemos
ver
en
la
Figura
8.30
,


la
cola
ESP
est√°
compuesta
por
tres
campos
:
relleno
,
longitud
de
relleno
y
siguiente
cabe-


cera
.
Recuerde
que
los
sistemas
de
cifrado
de
bloque
requieren
que
el
mensaje
que
hay
que


cifrar
sea
un
m√∫ltiplo
entero
de
la
longitud
de
bloque
.
Por
ello
se
emplea
un
relleno
(
com-


puesto
por
bytes
que
no
tienen
ning√∫n
significado
)
para
que
,
al
a√±adirlo
al
datagrama
origi-


nal
(
junto
con
los
campos
de
longitud
de
relleno
y
de
siguiente
cabecera
)
,
el
‚Äú
mensaje
‚Äù


resultante
tenga
un
n√∫mero
entero
de
bloques
.
El
campo
de
longitud
de
relleno
indica
a
la


entidad
receptora
cu√°nto
relleno
se
ha
insertado
(
y
,
por
tanto
,
cu√°nto
relleno
habr√°
que
eli-


minar
)
.
El
campo
de
siguiente
cabecera
indica
el
tipo
(
por
ejemplo
,
UDP
)
de
los
datos
con-


tenidos
en
el
campo
de
datos
de
carga
√∫til
.
Los
datos
de
carga
√∫til
(
normalmente
,
el


datagrama
IP
original
)
y
la
cola
ESP
se
concatenan
y
se
cifran
.


Delante
de
esta
unidad
cifrada
se
encuentra
la
cabecera
ESP
,
que
se
env√≠a
como
texto


en
claro
y
que
consta
de
dos
campos
:
el
SPI
y
el
campo
de
n√∫mero
de
secuencia
.
El
SPI


indica
a
la
entidad
receptora
cu√°l
es
la
SA
a
la
que
pertenece
el
datagrama
;
la
entidad
recep-


tora
puede
entonces
indexar
su
base
de
datos
SAD
con
el
√≠ndice
SPI
para
determinar
los


algoritmos
y
claves
apropiados
de
autenticaci√≥n
/
descifrado
.
El
campo
de
n√∫mero
de
secuen-


cia
se
utiliza
para
defenderse
frente
a
los
ataques
por
reproducci√≥n
.


La
entidad
emisora
tambi√©n
a√±ade
un
c√≥digo
MAC
de
autenticaci√≥n
.
Como
hemos


dicho
anteriormente
,
la
entidad
emisora
calcula
un
c√≥digo
MAC
para
toda
la
enchilada


(
compuesta
por
la
cabecera
ESP
,
el
datagrama
IP
original
y
la
cola
ESP
,
estando
el
data-


grama
y
la
cola
cifrados
)
.
Recuerde
que
para
calcular
un
valor
MAC
,
el
emisor
a√±ade
una


clave
secreta
MAC
a
la
enchilada
y
luego
calcula
un
valor
hash
de
longitud
fija
para
el
resul-


tado
.


Cuando
R2
recibe
el
datagrama
IPsec
,
observa
que
la
direcci√≥n
IP
de
destino
del
data-


grama
es
el
propio
R2
,
por
lo
que
dicho
router
se
encarga
de
procesar
el
datagrama
.
Puesto


que
el
campo
de
protocolo
(
en
la
cabecera
IP
situada
m√°s
a
la
izquierda
)
tiene
el
valor
50
,


R2
ve
que
debe
aplicar
el
procesamiento
ESP
de
IPsec
al
datagrama
.
En
primer
lugar
,
anali-


zando
la
enchilada
,
R2
utiliza
el
SPI
para
determinar
a
qu√©
asociaci√≥n
de
seguridad
(
SA
)


pertenece
el
datagrama
.
En
segundo
lugar
,
calcula
el
valor
MAC
de
la
enchilada
y
verifica


que
es
coherente
con
el
valor
contenido
en
el
campo
ESP
MAC
.
Si
lo
es
,
el
router
sabr√°
que


la
enchilada
procede
del
router
R1
y
que
no
ha
sido
manipulada
.
En
tercer
lugar
,
comprueba


el
campo
de
n√∫mero
de
secuencia
para
verificar
que
el
datagrama
sea
reciente
y
no
un
data-


grama
reproducido
.
En
cuarto
lugar
,
descifra
la
unidad
cifrada
utilizando
la
clave
y
el
algo-


ritmo
de
descifrado
asociados
con
la
SA
.
En
quinto
lugar
,
elimina
el
relleno
y
extrae
el


datagrama
IP
normal
original
.
Y
,
finalmente
,
en
sexto
lugar
,
reenv√≠a
el
datagrama
original
a


la
red
de
la
sucursal
para
que
el
datagrama
llegue
a
su
verdadero
destino
.
Es
una
receta
un


tanto
complicada
,
¬ø
verdad
?
¬°
Bueno
,
nunca
dijimos
que
preparar
una
enchilada
fuera
f√°cil
!


Existe
todav√≠a
otra
sutileza
importante
que
necesitamos
explicar
y
que
est√°
centrada
en


la
siguiente
cuesti√≥n
:
cuando
el
router
R1
recibe
un
datagrama
(
no
dotado
de
seguridad
)
pro-


cedente
de
un
host
de
la
red
de
la
oficina
principal
y
dicho
datagrama
est√°
destinado
a
alguna


direcci√≥n
IP
de
destino
situada
fuera
de
la
oficina
principal
,
¬ø
c√≥mo
sabe
R1
si
ese
datagrama


debe
ser
convertido
en
un
datagrama
IPsec
?
Y
si
tiene
que
ser
procesado
por
IPsec
,
¬ø
c√≥mo


sabe
R1
qu√©
SA
(
de
las
muchas
asociaciones
de
seguridad
existentes
en
su
base
de
datos


SAD
)
hay
que
utilizar
para
construir
el
datagrama
IPsec
?
El
problema
se
resuelve
de
la


8.6
‚Ä¢
SEGURIDAD
DE
LA
CAPA
DE
RED
:
IPSEC
Y
REDES
PRIVADAS
VIRTUALES
703


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
703forma
siguiente
.
Junto
con
una
base
de
datos
SAD
,
la
entidad
IPsec
tambi√©n
mantiene
otra


estructura
de
datos
denominada
Base
de
datos
de
pol√≠ticas
de
seguridad
(
SPD
,
Security


Policy
Database
)
.
La
SPD
indica
qu√©
tipos
de
datagramas
(
en
funci√≥n
de
la
direcci√≥n
IP
de


origen
,
la
direcci√≥n
IP
de
destino
y
el
tipo
de
protocolo
)
hay
que
procesar
mediante
IPsec
;
y


para
aquellos
que
haya
que
procesar
mediante
IPsec
,
qu√©
SA
debe
emplearse
.
En
un
cierto


sentido
,
la
informaci√≥n
de
una
SPD
indica
‚Äú
qu√©
‚Äù
hacer
con
los
datagramas
que
lleguen
,


mientras
que
la
informaci√≥n
de
la
SAD
indica
‚Äú
c√≥mo
‚Äù
hay
que
hacerlo
.


Resumen
de
los
servicios
IPsec


¬ø
Qu√©
servicios
proporciona
IPsec
exactamente
?
Examinemos
estos
servicios
desde
la
pers-


pectiva
de
un
atacante
,
como
por
ejemplo
Tom√°s
,
que
se
ha
interpuesto
(
man-in-the-middle
)


en
la
comunicaci√≥n
,
situ√°ndose
en
alg√∫n
lugar
de
la
ruta
entre
los
routers
R1
y
R2
de
la


Figura
8.29
.
Vamos
a
suponer
a
lo
largo
de
estas
explicaciones
que
Tom√°s
no
conoce
las
cla-


ves
de
cifrado
y
de
autenticaci√≥n
empleadas
por
la
SA
.
¬ø
Qu√©
cosas
puede
hacer
Tom√°s
y


cu√°les
no
?
En
primer
lugar
,
Tom√°s
no
puede
ver
el
datagrama
original
.
De
hecho
,
no
s√≥lo


est√°n
los
datos
del
datagrama
original
ocultos
a
ojos
de
Tom√°s
,
sino
que
tambi√©n
lo
est√°n
el


n√∫mero
de
protocolo
,
la
direcci√≥n
IP
de
origen
y
la
direcci√≥n
IP
de
destino
.
Para
los
datagra-


mas
enviados
a
trav√©s
de
la
SA
,
Tom√°s
s√≥lo
sabe
que
el
datagrama
tiene
su
origen
en
alg√∫n


host
de
la
red
172.16.1.0/24
y
que
est√°
destinado
a
alg√∫n
host
de
la
red
172.16.2.0/24
.
No


sabe
si
est√°
transportando
datos
TCP
,
UDP
o
ICMP
;
no
sabe
si
est√°
transportando
HTTP
,


SMTP
,
o
alg√∫n
otro
tipo
de
datos
de
aplicaci√≥n
.
Esta
confidencialidad
,
por
tanto
,
va
bastante


m√°s
all√°
que
en
SSL
.
En
segundo
lugar
,
suponga
que
Tom√°s
trata
de
alterar
un
datagrama
en


la
SA
modificando
algunos
de
sus
bits
.
Cuando
este
datagrama
alterado
llegue
a
R2
no


pasar√°
las
comprobaciones
de
integridad
(
utilizando
el
valor
MAC
)
,
desbaratando
una
vez


m√°s
las
intenciones
de
Tom√°s
.
En
tercer
lugar
,
suponga
que
Tom√°s
intenta
hacerse
pasar
por


R1
,
creando
un
datagrama
IPsec
cuyo
origen
sea
200.168.1.100
y
cuyo
destino
sea


193.68.2.23
.
El
ataque
de
Tom√°s
no
tendr√°
ning√∫n
efecto
,
ya
que
este
datagrama
de
nuevo


no
pasar√°
la
comprobaci√≥n
de
integridad
realizada
en
R2
.
Finalmente
,
puesto
que
IPsec


incluye
n√∫meros
de
secuencia
,
Tom√°s
no
podr√°
desarrollar
con
√©xito
ning√∫n
ataque
por


reproducci√≥n
.
En
resumen
,
y
tal
como
dijimos
al
principio
de
esta
secci√≥n
,
IPsec
propor-


ciona
(
entre
cualquier
pareja
de
dispositivos
que
procesen
paquetes
en
la
capa
de
red
)
meca-


nismos
de
confidencialidad
,
de
autenticaci√≥n
del
origen
,
de
integridad
de
los
datos
y
de


prevenci√≥n
de
los
ataques
por
reproducci√≥n
.


8.6.5
IKE
:
gesti√≥n
de
claves
en
IPsec


Cuando
una
red
VPN
tiene
un
peque√±o
n√∫mero
de
puntos
terminales
(
por
ejemplo
,
s√≥lo
dos


routers
,
como
en
la
Figura
8.29
)
,
el
administrador
de
la
red
puede
introducir
manualmente
la


informaci√≥n
de
la
SA
(
claves
y
algoritmos
de
cifrado
/
autenticaci√≥n
y
los
√≠ndices
SPI
)
en
las


bases
de
datos
SAD
en
los
puntos
terminales
.
Este
tipo
de
‚Äú
introducci√≥n
manual
‚Äù
de
las
cla-


ves
resulta
obviamente
poco
pr√°ctico
para
una
VPN
de
gran
tama√±o
,
que
puede
constar
de


centenares
o
incluso
miles
de
hosts
y
routers
IPsec
.
Las
tareas
de
implantaci√≥n
de
gran


envergadura
y
geogr√°ficamente
distribuidas
requieren
un
mecanismo
automatizado
para
la


creaci√≥n
de
las
SA
.
IPsec
lleva
a
cabo
este
tipo
de
tarea
mediante
el
protocolo
de
Intercam-


bio
de
claves
de
Internet
(
IKE
,
Internet
Key
Exchange
)
,
especificado
en
RFC
4306
.


IKE
presenta
algunas
similitudes
con
el
procedimiento
de
acuerdo
en
SSL
(
v√©ase
la
Sec-


ci√≥n
8.5
)
.
Cada
entidad
IPsec
tiene
un
certificado
,
que
incluye
la
clave
p√∫blica
de
la
entidad
.


704
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
704Al
igual
que
en
SSL
,
el
protocolo
IKE
exige
que
las
dos
entidades
intercambien
certificados
,


negocien
los
algoritmos
de
autenticaci√≥n
y
cifrado
e
intercambien
de
modo
seguro
el
material


necesario
para
crear
las
claves
de
sesi√≥n
para
las
SA
de
IPsec
.
A
diferencia
de
SSL
,
IKE


emplea
dos
fases
para
llevar
a
cabo
estas
tareas
.


Vamos
a
analizar
estas
dos
fases
en
el
contexto
de
los
routers
R1
y
R2
de
la
Figura
8.29
.


La
primera
fase
est√°
compuesta
por
dos
intercambios
de
parejas
de
mensajes
entre
R1
y
R2
:


‚Ä¢D
u
r
a
n
t
e
 
e
l
 
p
r
i
m
e
r
 
i
n
t
e
r
c
a
m
b
i
o
 
d
e
 
m
e
n
s
a
j
e
s
 
l
o
s
 
d
o
s
 
l
a
d
o
s
 
u
t
i
l
i
z
a
n
 
D
i
f
f
i
e
-
H
e
l
l
m
a
n
 
(
v
√©
a
n
s
e


los
problemas
incluidos
al
final
del
cap√≠tulo
)
para
crear
una
IKE
SA
bidireccional
entre


los
routers
.
Para
confundir
a
los
estudiosos
,
esta
SA
IKE
bidireccional
es
enteramente


distinta
de
las
SA
IPsec
presentadas
en
las
Secciones
8.6.3
y
8.6.4
.
La
IKE
SA
propor-


ciona
un
canal
autenticado
y
cifrado
entre
los
dos
routers
.
Durante
este
primer
intercam-


bio
de
parejas
de
mensajes
se
establecen
las
claves
de
cifrado
y
autenticaci√≥n
para
la
IKE


SA
.
Tambi√©n
se
establece
un
valor
secreto
maestro
que
se
utilizar√°
para
calcular
las
cla-


ves
IPSec
SA
posteriormente
en
la
fase
2
.
Observe
que
durante
este
primer
paso
no
se


utilizan
claves
p√∫blica
y
privada
RSA
.
En
particular
,
ni
R1
ni
R2
revelan
su
identidad
fir-


mando
un
mensaje
con
su
clave
privada
.


‚Ä¢D
u
r
a
n
t
e
 
e
l
 
s
e
g
u
n
d
o
 
i
n
t
e
r
c
a
m
b
i
o
 
d
e
 
m
e
n
s
a
j
e
s
 
a
m
b
o
s
 
l
a
d
o
s
 
s
e
 
r
e
v
e
l
a
n
 
m
u
t
u
a
m
e
n
t
e
 
s
u


identidad
,
firmando
sus
mensajes
.
Sin
embargo
,
las
identidades
no
son
reveladas
a
nadie


que
est√©
husmeando
pasivamente
el
canal
de
comunicaci√≥n
,
ya
que
los
mensajes
se


env√≠an
a
trav√©s
del
canal
IKE
SA
seguro
.
Tambi√©n
durante
esta
fase
los
dos
lados
nego-


cian
los
algoritmos
de
cifrado
y
autenticaci√≥n
IPsec
que
ser√°n
empleados
por
las
asocia-


ciones
de
seguridad
IPsec
.


En
la
fase
2
de
IKE
los
dos
lados
crean
una
SA
en
cada
direcci√≥n
.
Al
final
de
la
fase
2


las
claves
de
sesi√≥n
para
cifrado
y
autenticaci√≥n
habr√°n
sido
establecidas
en
ambos
termina-


les
para
las
dos
SA
.
Los
dos
lados
pueden
emplear
entonces
las
SA
para
enviar
datagramas


seguros
,
como
se
describe
en
las
Secciones
8.6.3
y
8.6.4
.
La
principal
motivaci√≥n
para
que


existan
dos
fases
en
IKE
es
el
coste
computacional
:
puesto
que
la
segunda
fase
no
implica


ning√∫n
tipo
de
criptograf√≠a
de
clave
p√∫blica
,
IKE
puede
generar
un
gran
n√∫mero
de
asocia-


ciones
de
seguridad
entre
las
dos
entidades
IPsec
con
un
coste
de
computaci√≥n
relativamente


bajo
.


8.7
Seguridad
de
las
redes
LAN
inal√°mbricas


La
seguridad
es
una
preocupaci√≥n
de
particular
importancia
en
las
redes
inal√°mbricas
,
en
las


que
las
ondas
de
radio
que
transportan
la
tramas
pueden
propagarse
bastante
m√°s
all√°
de
los


l√≠mites
del
edificio
que
alberga
a
los
hosts
y
a
la
estaci√≥n
base
inal√°mbrica
.
En
esta
secci√≥n


vamos
a
presentar
una
breve
introducci√≥n
al
tema
de
la
seguridad
inal√°mbrica
.
El
lector
inte-


resado
en
ver
un
tratamiento
m√°s
detallado
puede
leer
el
libro
de
Edney
y
Arbaugh
[
Edney


2003
]
que
es
bastante
legible
.


El
problema
de
la
seguridad
en
802.11
ha
atra√≠do
una
considerable
atenci√≥n
tanto
en
los


c√≠rculos
t√©cnicos
como
en
los
medios
de
comunicaci√≥n
.
Aunque
ha
habido
mucha
discusi√≥n


en
realidad
se
ha
producido
bastante
poco
debate
,
ya
que
parece
existir
un
consenso
univer-


sal
en
que
la
especificaci√≥n
802.11
original
contiene
diversos
fallos
importantes
de
seguri-


dad
.
De
hecho
,
cualquiera
puede
descargarse
actualmente
software
de
dominio
p√∫blico
que


8.7
‚Ä¢
SEGURIDAD
DE
LAS
REDES
LAN
INAL√ÅMBRICAS
705


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
705aprovecha
los
agujeros
de
seguridad
,
haciendo
que
los
usuarios
que
emplean
los
mecanis-


mos
de
seguridad
simples
de
802.11
sean
tan
vulnerables
como
aquellos
usuarios
que
no


emplean
ninguna
caracter√≠stica
de
seguridad
en
absoluto
.


En
la
siguiente
secci√≥n
vamos
a
analizar
los
mecanismos
de
seguridad
inicialmente


estandarizados
en
la
especificaci√≥n
802.11
,
que
se
conocen
colectivamente
con
el
nombre


de
Privacidad
equivalente
a
la
del
cable
(
WEP
,
Wired
Equivalent
Privacy
)
.
Como
el


nombre
sugiere
,
WEP
pretend√≠a
proporcionar
un
nivel
de
seguridad
similar
al
que
podemos


encontrar
en
las
redes
cableadas
.
Posteriormente
analizaremos
algunos
de
los
agujeros
de


seguridad
de
WEP
y
veremos
el
est√°ndar
802.11i
,
que
es
una
versi√≥n
bastante
m√°s
segura


que
802.11
y
que
se
adopt√≥
en
el
a√±o
2004
.


8.7.1
WEP
(
Wired
Equivalent
Privacy
)


El
protocolo
WEP
del
est√°ndar
IEEE
802.11
[
IEEE
802.11
2009
]
proporciona
autenticaci√≥n


y
cifrado
de
datos
entre
un
host
y
un
punto
de
acceso
inal√°mbrico
(
es
decir
,
una
estaci√≥n


base
)
utilizando
una
t√©cnica
basada
en
una
clave
sim√©trica
compartida
.
WEP
no
especifica


ning√∫n
algoritmo
de
gesti√≥n
de
claves
,
por
lo
que
se
presupone
que
el
host
y
el
punto
de


acceso
inal√°mbrico
han
acordado
de
alguna
manera
qu√©
clave
utilizar
,
empleando
para
ello


alg√∫n
m√©todo
fuera
de
banda
.
La
autenticaci√≥n
se
lleva
a
cabo
de
la
forma
siguiente
:


1
.
Un
host
inal√°mbrico
solicita
la
autenticaci√≥n
por
parte
de
un
punto
de
acceso
.


2
.
El
punto
de
acceso
responde
a
la
solicitud
de
autenticaci√≥n
con
un
n√∫mero
distintivo
de


128
bytes
.


3
.
El
host
inal√°mbrico
cifra
el
n√∫mero
distintivo
utilizando
la
clave
sim√©trica
que
com-


parte
con
el
punto
de
acceso
.


4
.
El
punto
de
acceso
descifra
el
n√∫mero
distintivo
cifrado
por
el
host
.


Si
el
n√∫mero
distintivo
descifrado
se
corresponde
con
el
valor
del
n√∫mero
distintivo
origi-


nalmente
enviado
al
host
,
entonces
el
host
quedar√°
autenticado
por
el
punto
de
acceso
.


El
algoritmo
de
cifrado
de
datos
de
WEP
se
ilustra
en
la
Figura
8.31
.
Se
supone
que


tanto
el
host
como
el
punto
de
acceso
conocen
una
clave
sim√©trica
secreta
de
40
bits
,
KS
.


Adem√°s
,
se
a√±ade
un
vector
de
inicializaci√≥n
(
IV
)
de
24
bits
a
la
clave
de
40
bits
para
crear


una
clave
de
64
bits
que
se
usar√°
para
cifrar
una
√∫nica
trama
.
El
vector
IV
cambiar√°
de
una


trama
a
la
siguiente
,
por
lo
que
cada
trama
ser√°
cifrada
con
una
clave
de
64
bits
distinta
.
El


706
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Generador
de
secuencia
de
claves


(
para
Ks
,
IV
dados
)


k1


IV


d1


c1


k2


IV
k3


IV
kN


IV
IV
kN+1


IVkN+4


Ks
:
clave
secreta


sim√©trica
de
40
bits


Datos
de
trama
de
texto


en
claro
m√°s
CRC


IV
(
por
trama
)


Cabec
.


802.11
IV
Datos
cifrados
con


WEP
m√°s
CRC


d2


c2


d3


c3


dN


cN


CRC1


cN+1
cN+4


CRC4


Figura
8.31
‚Ä¢
Protocolo
WEP
802.11
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
706cifrado
se
realiza
de
la
manera
siguiente
.
En
primer
lugar
se
calcula
un
valor
CRC
de
4
bytes


(
v√©ase
la
Secci√≥n
5.2
)
para
la
carga
√∫til
de
datos
.
La
carga
√∫til
y
los
4
bytes
de
CRC
se
cifran


entonces
utilizando
el
mecanismo
de
cifrado
de
flujo
RC4
.
No
vamos
a
analizar
aqu√≠
los


detalles
de
RC4
(
puede
encontrarlos
en
[
Schneier
1995
]
y
[
Edney
2003
]
)
.
Para
nuestros
pro-


p√≥sitos
,
basta
con
saber
que
el
algoritmo
RC4
,
cuando
se
le
suministra
un
valor
de
clave
(
en


este
caso
,
la
clave
(
KS
,
IV
)
de
64
bits
)
,
produce
un
flujo
de
valores
de
claves
,
k1


IV
,
k2


IV
,
k3


IV
,
.
.


.q
u
e
 
s
e
 
u
t
i
l
i
z
a
n
 
p
a
r
a
 
c
i
f
r
a
r
 
l
o
s
 
d
a
t
o
s
 
y
 
e
l
 
v
a
l
o
r
 
d
e
 
C
R
C
 
d
e
 
u
n
a
 
t
r
a
m
a
.
 
Ae
f
e
c
t
o
s
 
p
r
√°
c
t
i
c
o
s
,


podemos
considerar
que
estas
operaciones
se
realizan
de
byte
en
byte
.
El
cifrado
se
lleva
a


cabo
combinando
mediante
XOR
el
i-√©simo
byte
de
datos
,
di
,
con
el
i-√©simo
valor
de
clave
,


ki


IV
,
perteneciente
al
flujo
de
valores
de
clave
generado
por
la
pareja
(
KS
,
IV
)
;
con
ello
se


genera
el
i-√©simo
byte
de
texto
cifrado
,
ci
:


ci
=
di
/H17053ki


IV


El
valor
del
vector
IV
cambia
de
una
trama
a
la
siguiente
y
se
incluye
como
texto
en


claro
en
la
cabecera
de
cada
trama
802.11
cifrada
con
WEP
,
como
se
muestra
en
la
Figura


8.31
.
El
receptor
toma
la
clave
sim√©trica
secreta
de
40
bits
que
comparte
con
el
emisor
,
le


a√±ade
el
vector
IV
y
emplea
la
clave
de
64
bits
resultante
(
que
es
id√©ntica
a
la
clave
usada


por
el
emisor
para
realizar
el
cifrado
)
con
el
fin
de
descifrar
la
trama
:


di
=
ci
/H17053ki


IV


El
uso
apropiado
del
algoritmo
RC4
requiere
que
nunca
se
utilice
m√°s
de
una
vez
un


mismo
valor
de
clave
de
64
bits
.
Recuerde
que
la
clave
WEP
cambia
de
una
trama
a
otra
.


Para
un
valor
KS
dado
(
que
rara
vez
cambia
,
si
es
que
cambia
alguna
vez
)
,
esto
quiere


decir
que
s√≥lo
hay
224
claves
√∫nicas
.
Si
estas
claves
se
seleccionan
aleatoriamente
,
se
puede


demostrar
[
Walker
2000
;
Edney
2003
]
que
la
probabilidad
de
haber
elegido
el
mismo
valor


del
vector
IV
(
y
por
tanto
de
haber
empleado
la
misma
clave
de
64
bits
)
dos
veces
es
supe-


rior
al
99
por
ciento
despu√©s
de
s√≥lo
12.000
tramas
.
Con
un
tama√±o
de
trama
de
1
kbyte
y


una
velocidad
de
transmisi√≥n
de
11
Mbps
,
bastan
unos
pocos
segundos
para
transmitir


12.000
tramas
.
Adem√°s
,
puesto
que
el
valor
de
IV
se
transmite
como
texto
en
claro
dentro


de
la
trama
,
un
curioso
que
est√©
capturando
la
comunicaci√≥n
podr√°
saber
si
se
ha
utilizado


un
valor
de
IV
duplicado
.


Para
comprender
uno
de
los
problemas
que
se
presentan
cuando
se
utiliza
una
clave


duplicada
,
considere
el
siguiente
ataque
de
texto
en
claro
seleccionado
realizado
por
Tom√°s


contra
Alicia
.
Suponga
que
Tom√°s
(
posiblemente
utilizando
alguna
t√©cnica
de
suplantaci√≥n


de
direcci√≥n
IP
)
env√≠a
una
solicitud
(
por
ejemplo
,
una
solicitud
HTTP
o
FTP
)
a
Alicia
para


transmitir
un
archivo
con
un
contenido
conocido
,
d1
,
d2
,
d3
,
d4
,
.
.
.
.
Tom√°s
tambi√©n
observa


los
datos
cifrados
c1
,
c2
,
c3
,
c4
.
.
.
.
Puesto
que
di
=
ci
/H17053ki


IV
,
si
combinamos
mediante
XOR


ci
con
cada
lado
de
esta
igualdad
obtenemos


di
/H17053ci
=
ki


IV


Con
esta
relaci√≥n
,
Tom√°s
puede
utilizar
los
valores
conocidos
de
di
y
ci
para
calcular
ki


IV
.
La


siguiente
vez
que
Tom√°s
vea
que
se
est√°
utilizando
el
mismo
valor
de
IV
,
conocer√°
la


secuencia
de
clave
k1


IV
,
k2


IV
,
k3


IV
,
.
.
.
y
podr√°
,
por
tanto
,
descifrar
el
mensaje
cifrado
.


Existen
tambi√©n
varios
otros
problemas
adicionales
de
seguridad
que
afectan
a
WEP
.


[
Fluhrer
2001
]
describi√≥
un
ataque
que
aprovecha
una
debilidad
conocida
de
RC4
cuando
se


seleccionan
ciertas
claves
d√©biles
.
[
Stubblefield
2002
]
analiza
varias
formas
eficientes
de


8.7
‚Ä¢
SEGURIDAD
DE
LAS
REDES
LAN
INAL√ÅMBRICAS
707


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
707implementar
y
aprovechar
este
ataque
.
Otro
problema
relativo
a
WEP
est√°
relacionado
con


los
bits
CRC
mostrados
en
la
Figura
8.31
y
transmitidos
en
la
trama
802.11
para
detectar


posibles
alteraciones
de
los
bits
de
la
carga
√∫til
.
Sin
embargo
,
un
atacante
que
cambie
el
con-


tenido
cifrado
(
es
decir
,
que
sustituya
los
datos
cifrados
originales
por
bits
sin
sentido
)
,
que


calcule
el
CRC
para
los
bits
sin
sentido
insertados
y
que
coloque
el
CRC
en
una
trama
WEP


puede
generar
una
trama
802.11
que
ser√°
aceptada
por
el
receptor
.
Lo
que
hacen
falta
aqu√≠


son
t√©cnicas
de
integridad
de
mensajes
como
las
que
hemos
estudiado
en
la
Secci√≥n
8.3
para


detectar
la
alteraci√≥n
o
sustituci√≥n
del
contenido
.
Para
conocer
m√°s
detalles
acerca
de
la


seguridad
en
WEP
,
consulte
[
Edney
2003
;
Walker
2000
;
Weatherspoon
2000
;
802.11
Secu-


rity
2009
]
y
las
referencias
en
ellos
contenidas
.


8.7.2
IEEE
802.11i


Poco
despu√©s
de
la
publicaci√≥n
en
1999
de
la
norma
IEEE
802.11
comenz√≥
el
trabajo
para


desarrollar
una
versi√≥n
nueva
y
mejorada
de
802.11
con
mecanismos
de
seguridad
m√°s


robustos
.
El
nuevo
est√°ndar
,
conocido
con
el
nombre
de
802.11i
,
obtuvo
la
ratificaci√≥n
final


en
2004
.
Como
veremos
,
mientras
que
WEP
proporcionaba
un
cifrado
relativamente
d√©bil
,


junto
con
una
√∫nica
forma
de
llevar
a
cabo
la
autenticaci√≥n
y
ning√∫n
mecanismo
de
distribu-


ci√≥n
de
claves
,
IEEE
802.11i
proporciona
formas
mucho
m√°s
fuertes
de
cifrado
,
un
conjunto


ampliable
de
mecanismos
de
autenticaci√≥n
y
un
mecanismo
de
distribuci√≥n
de
claves
.
De


aqu√≠
en
adelante
vamos
a
presentar
una
panor√°mica
de
802.11i
;
puede
encontrar
una
exce-


lente
presentaci√≥n
t√©cnica
(
un
flujo
de
audio
)
de
802.11i
en
[
TechOnline
2004
]
.


La
Figura
8.32
presenta
el
marco
conceptual
de
802.11i
.
Adem√°s
del
punto
de
acceso
y


del
cliente
inal√°mbrico
,
802.11i
define
un
servidor
de
autenticaci√≥n
con
el
que
el
AP
puede


708
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Descubrimiento
de
las


capacidades
de
seguridad


STA
y
AS
se
autentican
mutuamente
y
generan
conjuntamente


la
clave
maestra
(
MK
)
.
El
AP
sirve
como
‚Äú
punto
de
paso
‚Äù
.


STA
calcula
la
clave
maestra


de
par
(
PMK
)


AS
calcula
la
misma


PMK
y
se
la
env√≠a
al
AP


La
STA
y
el
AP
utilizan
la
clave
PMK


para
calcular
la
clave
temporal
(
TK
)


utilizada
para
el
cifrado
y
las
comprobaciones


de
integridad
de
los
mensajes


Figura
8.32
‚Ä¢
802.11i
:
cuatro
fases
de
operaci√≥n
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
708comunicarse
.
Separar
el
servidor
de
autenticaci√≥n
del
AP
permite
que
un
mismo
servidor
de


autenticaci√≥n
preste
servicio
a
muchos
puntos
de
acceso
,
centralizando
las
(
a
menudo
sensi-


bles
)
decisiones
concernientes
a
la
autenticaci√≥n
y
al
acceso
dentro
de
ese
√∫nico
servidor
y


manteniendo
a
un
nivel
bajo
el
coste
y
la
complejidad
de
los
puntos
de
acceso
.
802.11i
opera


en
cuatro
fases
:


1
.
Descubrimiento
.
En
la
fase
de
descubrimiento
el
AP
anuncia
su
presencia
y
las
formas


de
autenticaci√≥n
y
cifrado
que
puede
proporcionar
al
nodo
de
cliente
inal√°mbrico
.
El


cliente
solicita
entonces
las
formas
espec√≠ficas
de
autenticaci√≥n
y
cifrado
que
desea
.


Aunque
el
cliente
y
el
AP
ya
est√°n
intercambiando
mensajes
,
el
cliente
no
habr√°
sido


todav√≠a
autenticado
ni
dispondr√°
a√∫n
de
una
clave
de
cifrado
,
por
lo
que
son
necesarios


varios
pasos
m√°s
antes
de
que
el
cliente
pueda
comunicarse
con
un
host
remoto
arbitra-


rio
a
trav√©s
del
canal
inal√°mbrico
.


2
.
Autenticaci√≥n
mutua
y
generaci√≥n
de
la
clave
maestra
(
MK
,
Master
Key
)
.
La
autentica-


ci√≥n
tiene
lugar
entre
el
cliente
inal√°mbrico
y
el
servidor
de
autenticaci√≥n
.
En
esta
fase
,


el
punto
de
acceso
act√∫a
b√°sicamente
como
repetidor
,
reenviando
los
mensajes
entre
el


cliente
y
el
servidor
de
autenticaci√≥n
.
El
Protocolo
ampliable
de
autenticaci√≥n
(
EAP
,


Extensible
Authentication
Protocol
)
[
RFC
2284
]
define
los
formatos
de
los
mensajes


terminal
a
terminal
utilizados
en
un
modo
de
interacci√≥n
simple
de
tipo
solicitud
/
res-


puesta
entre
el
cliente
y
el
servidor
de
autenticaci√≥n
.
Como
se
muestra
en
la
Figura


8.33
,
los
mensajes
EAP
se
encapsulan
utilizando
EAPoL
(
EAP
sobre
LAN
,
[
IEEE


802.1X
]
)
y
se
env√≠an
a
trav√©s
del
enlace
inal√°mbrico
802.11
.
Estos
mensajes
EAP
son


entonces
desencapsulados
en
el
punto
de
acceso
y
luego
re-encapsulados
utilizando
el


protocolo
RADIUS
para
su
transmisi√≥n
sobre
UDP
/
IP
hacia
el
servidor
de
autentica-


ci√≥n
.
Aunque
el
protocolo
[
RFC
2865
]
y
el
servidor
RADIUS
no
son
requeridos
obliga-


toriamente
por
el
protocolo
802.11i
,
son
componentes
est√°ndar
de
facto
para
802.11i
.


8.7
‚Ä¢
SEGURIDAD
DE
LAS
REDES
LAN
INAL√ÅMBRICAS
709


STA
:


estaci√≥n
cliente


AP
:


punto
de
acceso


Red


cableada


AS
:


servidor
de


autenticaci√≥n


EAP
TLS


EAP


EAP
sobre
LAN
(
EAPoL
)
RADIUS


IEEE
802.11
UDP
/
IP


Figura
8.33
‚Ä¢
EAP
es
un
protocolo
terminal
a
terminal
.
Los
mensajes
EAP
se


encapsulan
utilizando
EAPoL
sobre
el
enlace
inal√°mbrico


existente
entre
el
cliente
y
el
punto
de
acceso
,
y
empleando


RADIUS
sobre
UDP
/
IP
entre
el
punto
de
acceso
y
el
servidor


de
autenticaci√≥n
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
709Es
posible
que
el
protocolo
DIAMETER
[
RFC
3588
]
recientemente
estandarizado
sus-


tituya
a
RADIUS
en
un
futuro
pr√≥ximo
.


Con
EAP
el
servidor
de
autenticaci√≥n
puede
seleccionar
una
de
varias
formas
para
llevar


a
cabo
la
autenticaci√≥n
.
Aunque
802.11i
no
impone
un
m√©todo
de
autenticaci√≥n
con-


creto
,
a
menudo
se
emplea
el
esquema
de
autenticaci√≥n
EAP-TLS
[
RFC
2716
]
.
EAP-


TLS
utiliza
t√©cnicas
de
clave
p√∫blica
(
incluyendo
cifrado
con
n√∫meros
distintivos
y


res√∫menes
de
mensajes
)
similares
a
las
que
hemos
estudiado
en
la
Secci√≥n
8.3
para
per-


mitir
que
el
cliente
y
el
servidor
de
autenticaci√≥n
se
autentiquen
mutuamente
entre
s√≠
y


para
calcular
una
clave
maestra
(
MK
)
que
ser√°
conocida
por
ambas
partes
.


3
.
Generaci√≥n
de
la
clave
maestra
de
par
(
PMK
,
Pairwise
Master
Key
)
.
La
MK
es
un


secreto
compartido
que
s√≥lo
conocen
el
cliente
y
el
servidor
de
autenticaci√≥n
y
que


ambos
emplean
para
generar
una
segunda
clave
,
la
clave
maestra
de
par
(
PMK
)
.
El
ser-


vidor
de
autenticaci√≥n
env√≠a
entonces
la
PMK
al
AP
.
¬°
Aqu√≠
es
donde
quer√≠amos
llegar
!


El
cliente
y
el
AP
ahora
disponen
de
una
clave
compartida
(
recuerde
que
,
en
WEP
,
el
pro-


blema
de
la
distribuci√≥n
de
claves
ni
siquiera
se
contemplaba
)
y
se
habr√°n
autenticado


mutuamente
entre
s√≠
.
Ya
est√°n
casi
listos
para
poder
comenzar
con
la
operaci√≥n
real
.


4
.
Generaci√≥n
de
la
clave
temporal
(
TK
,
Temporal
Key
)
.
Con
la
PMK
,
el
cliente
inal√°m-


brico
y
el
AP
pueden
ahora
generar
claves
adicionales
que
se
utilizar√°n
para
la
comuni-


caci√≥n
.
De
particular
inter√©s
es
la
clave
tem
poral
(
TK
)
que
se
utilizar√°
para
realizar
el


cifrado
de
nivel
de
enlace
de
los
datos
enviados
a
trav√©s
del
enlace
inal√°mbrico
hacia
un


host
remoto
arbitrario
.


802.11i
proporciona
varias
formas
de
cifrado
,
incluyendo
el
esquema
de
cifrado
basado
en


AES
y
una
versi√≥n
m√°s
fuerte
del
cifrado
WEP
.


8.8
Seguridad
operacional
:
cortafuegos
y
sistemas


de
detecci√≥n
de
intrusiones


Hemos
visto
a
lo
largo
de
este
cap√≠tulo
que
Internet
no
es
un
lugar
muy
seguro
(
los
malos


est√°n
ah√≠
fuera
,
infligiendo
toda
clase
de
estragos
)
.
Conocida
la
naturaleza
hostil
de
Internet
,


vamos
a
considerar
ahora
la
red
de
una
organizaci√≥n
y
al
administrador
de
red
que
la
gestiona
.


Desde
el
punto
de
vista
de
un
administrador
de
red
,
el
mundo
se
divide
de
forma
bastante


n√≠tida
en
dos
bandos
:
los
buenos
(
aquellos
que
pertenecen
a
la
red
de
la
organizaci√≥n
y
que


deben
poder
acceder
a
los
recursos
internos
de
la
misma
de
una
forma
relativamente
poco


restringida
)
y
los
malos
(
todos
los
dem√°s
,
aquellos
que
deben
ser
cuidadosamente
escrutados


a
la
hora
de
acceder
a
los
recursos
de
la
red
)
.
En
muchas
organizaciones
,
desde
los
castillos


medievales
a
los
modernos
edificios
de
oficinas
,
existe
un
√∫nico
punto
de
entrada
/
salida


donde
se
hace
una
comprobaci√≥n
de
seguridad
tanto
de
los
buenos
como
de
los
malos
que


entran
y
salen
de
la
organizaci√≥n
.
En
un
castillo
esto
se
hac√≠a
en
la
puerta
situada
en
el


extremo
de
un
puente
levadizo
;
en
un
edificio
de
oficinas
,
esto
se
hace
en
el
control
de
segu-


ridad
de
entrada
.
En
una
red
de
computadoras
,
cuando
se
comprueba
si
el
tr√°fico
que


entra
/
sale
de
la
red
es
seguro
,
cuando
se
registra
ese
tr√°fico
y
cuando
se
elimina
o
reenv√≠a
,


quienes
se
encargan
de
esas
tareas
son
una
serie
de
dispositivos
operacionales
conocidos


como
cortafuegos
,
sistemas
de
detecci√≥n
de
intrusiones
(
IDS
,
Intrusion
Detection
System
)
y


sistemas
de
prevenci√≥n
de
intrusiones
(
IPS
,
Intrusion
Prevention
System
)
.


710
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
7108.8.1
Cortafuegos


Un
cortafuegos
es
una
combinaci√≥n
de
hardware
y
software
que
a√≠sla
la
red
interna
de
la


organizaci√≥n
de
Internet
,
permitiendo
pasar
a
algunos
paquetes
y
bloqueando
a
otros
.
Un


cortafuegos
permite
a
un
administrador
de
red
controlar
el
acceso
entre
el
mundo
exterior
y


los
recursos
dentro
de
la
red
administrada
,
gestionando
el
flujo
de
tr√°fico
hacia
y
desde
esos


recursos
.
Un
cortafuegos
tiene
tres
objetivos
:


‚Ä¢
Todo
el
tr√°fico
que
va
del
exterior
hacia
el
interior
de
la
red
,
y
viceversa
,
pasa
a
trav√©s


del
cortafuegos
.
La
Figura
8.34
muestra
un
cortafuegos
,
que
se
encuentra
en
el
l√≠mite


entre
la
red
administrada
y
el
resto
de
Internet
.
Aunque
las
organizaciones
de
gran
tama√±o


pueden
 
utilizar
varios
niveles
de
cortafuegos
o
cortafuegos
distribuidos
[
Skoudis
2006
]
,


colocar
un
cortafuegos
en
un
√∫nico
punto
de
acceso
a
la
red
,
como
se
muestra
en
la


Figura
8.34
,
facilita
la
gesti√≥n
y
el
imponer
una
pol√≠tica
de
control
de
acceso
.


‚Ä¢
S√≥lo
se
permite
el
paso
del
tr√°fico
autorizado
de
acuerdo
con
la
pol√≠tica
de
seguridad


local
.
Con
todo
el
tr√°fico
de
entrada
y
de
salida
de
la
red
institucional
pasando
a
trav√©s


del
cortafuegos
,
√©ste
puede
restringir
el
acceso
al
tr√°fico
autorizado
.


‚Ä¢
El
propio
cortafuegos
es
inmune
a
la
penetraci√≥n
.
El
propio
cortafuegos
es
un
disposi-


tivo
conectado
a
la
red
.
Si
no
est√°
dise√±ado
o
instalado
apropiadamente
puede
verse
com-


prometido
,
en
cuyo
caso
s√≥lo
proporciona
una
falsa
sensaci√≥n
de
seguridad
(
lo
que
es


peor
que
no
disponer
de
cortafuegos
)
.


Cisco
y
Check
Point
son
dos
de
las
empresas
l√≠deres
actuales
de
distribuci√≥n
de
cortafuegos
.


Tambi√©n
puede
crearse
f√°cilmente
un
cortafuegos
(
filtro
de
paquetes
)
a
partir
de
una


m√°quina
Linux
utilizando
iptables
(
software
de
dominio
p√∫blico
,
que
se
suministra
habitual-


mente
con
Linux
)
.


8.8
‚Ä¢
SEGURIDAD
OPERACIONAL
711


Red


administrada


Cortafuegos


Internet


p√∫blica


Figura
8.34
‚Ä¢
Colocaci√≥n
de
un
cortafuegos
entre
la
red
administrada
y
el


mundo
exterior
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
711Los
cortafuegos
se
pueden
clasificar
en
tres
categor√≠as
:
filtros
de
paquetes
tradiciona-


les
,
filtros
con
memoria
del
estado
y
pasarelas
de
aplicaci√≥n
.
En
las
siguientes
subseccio-


nes
abordaremos
cada
uno
de
estos
tipos
de
cortafuegos
.


Filtros
de
paquetes
tradicionales


Como
se
muestra
en
la
Figura
8.34
,
una
organizaci√≥n
dispone
normalmente
de
un
router
de


pasarela
que
conecta
su
red
interna
con
su
ISP
(
y
por
tanto
con
la
gran
red
Internet
p√∫blica
)
.


Todo
el
tr√°fico
que
sale
y
entra
en
la
red
interna
pasa
a
trav√©s
de
este
router
y
es
en
este
router


donde
tiene
lugar
el
filtrado
de
paquetes
.
Un
filtro
de
paquetes
examina
cada
datagrama
ais-


ladamente
,
determinando
si
debe
pasar
o
debe
ser
eliminado
bas√°ndose
en
las
reglas
especifi-


cadas
por
el
administrador
.
Las
decisiones
de
filtrado
normalmente
se
basan
en
:


‚Ä¢L
a
s
 
d
i
r
e
c
c
i
o
n
e
s
 
I
P
d
e
 
o
r
i
g
e
n
 
o
 
d
e
 
d
e
s
t
i
n
o
.
 

‚Ä¢E
l
 
t
i
p
o
 
d
e
 
p
r
o
t
o
c
o
l
o
 
e
s
p
e
c
i
f
i
c
a
d
o
 
e
n
 
e
l
 
c
a
m
p
o
 
d
e
 
d
a
t
a
g
r
a
m
a
 
I
P
:
 
T
C
P
,
 
U
D
P
,
 
I
C
M
P
,
 
O
S
P
F
,


etc.


‚Ä¢E
l
 
p
u
e
r
t
o
 
d
e
 
d
e
s
t
i
n
o
 
y
 
d
e
 
o
r
i
g
e
n
 
T
C
P
o
 
U
D
P
.
 

‚Ä¢L
o
s
 
b
i
t
s
 
i
n
d
i
c
a
d
o
r
e
s
 
T
C
P
:
 
S
Y
N
,
 
A
C
K
,
 
e
t
c
.
 

‚Ä¢
El
tipo
de
mensaje
ICMP
.


‚Ä¢D
i
f
e
r
e
n
t
e
s
 
r
e
g
l
a
s
 
p
a
r
a
 
l
o
s
 
d
a
t
a
g
r
a
m
a
s
 
q
u
e
 
s
a
l
e
n
 
y
 
e
n
t
r
a
n
 
e
n
 
l
a
 
r
e
d
.
 

‚Ä¢D
i
f
e
r
e
n
t
e
s
 
r
e
g
l
a
s
 
p
a
r
a
 
l
a
s
 
d
i
s
t
i
n
t
a
s
 
i
n
t
e
r
f
a
c
e
s
 
d
e
l
 
r
o
u
t
e
r
.


Un
administrador
de
red
configura
el
cortafuegos
bas√°ndose
en
la
pol√≠tica
de
la
organi-


zaci√≥n
.
La
pol√≠tica
puede
tener
en
cuenta
la
productividad
del
usuario
y
el
uso
del
ancho
de


banda
,
as√≠
como
los
problemas
de
seguridad
de
una
organizaci√≥n
.
La
Tabla
8.5
enumera
algu-


nas
de
las
posibles
pol√≠ticas
que
una
organizaci√≥n
puede
tener
y
c√≥mo
podr√≠an
controlarse


mediante
un
sistema
de
filtrado
de
paquetes
.
Por
ejemplo
,
si
la
organizaci√≥n
no
desea
permi-


tir
ninguna
conexi√≥n
TCP
entrante
excepto
aquellas
destinadas
a
su
servidor
web
p√∫blico
,


puede
bloquear
todos
los
segmentos
TCP
SYN
entrantes
,
salvo
aquellos
cuyo
puerto
de
des-


tino
sea
el
puerto
80
y
cuya
direcci√≥n
IP
de
destino
sea
la
correspondientes
al
servidor
web
.


Si
la
organizaci√≥n
no
desea
que
sus
usuarios
monopolicen
el
ancho
de
banda
de
acceso
con


aplicaciones
de
radio
por
Internet
,
puede
bloquear
todo
el
tr√°fico
UDP
no
cr√≠tico
(
ya
que
la


radio
por
Internet
a
menudo
se
transmite
sobre
UDP
)
.
Si
la
organizaci√≥n
no
desea
que
su
red


interna
sea
analizada
(
con
Traceroute
)
por
alguien
externo
,
puede
bloquear
todos
los
mensa-


jes
ICMP
TTL
caducados
que
salen
de
la
red
de
la
organizaci√≥n
.


Una
pol√≠tica
de
filtrado
puede
estar
basada
en
una
combinaci√≥n
de
direcciones
y
n√∫me-


ros
de
puerto
.
Por
ejemplo
,
un
router
de
filtrado
podr√≠a
reenviar
todos
los
datagramas
Telnet


(
aquellos
con
un
n√∫mero
de
puerto
igual
a
23
)
excepto
aquellos
que
se
dirigen
y
proceden
de


una
direcci√≥n
incluida
en
una
lista
de
direcciones
IP
especificadas
.
Esta
pol√≠tica
permite
las


conexiones
Telnet
dirigidas
y
procedentes
de
los
hosts
especificados
en
la
lista
de
direcciones


permitidas
.
Lamentablemente
,
basar
la
pol√≠tica
en
direcciones
externas
no
proporciona
nin-


guna
protecci√≥n
frente
a
datagramas
en
los
que
su
direcci√≥n
de
origen
haya
sido
falsificada
.


El
filtrado
tambi√©n
puede
basarse
en
si
se
ha
configurado
o
no
el
bit
TCP
ACK
.
Este


truco
resulta
bastante
√∫til
si
una
organizaci√≥n
desea
permitir
que
sus
clientes
internos
se


conecten
a
servidores
externos
,
pero
quiere
impedir
que
clientes
externos
se
conecten
a
los


servidores
internos
.
Recuerde
de
la
Secci√≥n
3.5
que
el
primer
segmento
de
toda
conexi√≥n


TCP
tiene
puesto
a
0
el
bit
ACK
,
mientras
que
los
restantes
segmentos
de
la
conexi√≥n
tienen


712
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
712Pol√≠tica
Configuraci√≥n
del
cortafuegos


Sin
acceso
web
externo
.
Eliminar
todos
los
paquetes
salientes
hacia
cualquier
direcci√≥n
IP
,


puerto
80
.


Sin
conexiones
TCP
entrantes
,
excepto
Eliminar
todos
los
paquetes
TCP
SYN
entrantes
hacia
cualquier
IP
excepto


las
destinadas
al
servidor
web
p√∫blico
130.207.244.203
,
puerto
80
.


de
la
organizaci√≥n
.


Impedir
que
las
aplicaciones
de
radio
web
Eliminar
todos
los
paquetes
UDP
entrantes
,
excepto
los
paquetes
DNS
.


consuman
el
ancho
de
banda
disponible
.


Impedir
que
la
red
sea
utilizada
para
llevar
Eliminar
todos
los
paquetes
ping
ICMP
hacia
una
direcci√≥n
de
‚Äú
difusi√≥n
‚Äù


a
cabo
un
ataque
DoS.
(
por
ejemplo
,
130.207.255.255
)
.


Impedir
que
la
red
sea
examinada
con
Eliminar
todo
el
tr√°fico
ICMP
TTL
saliente
caducado
.


Traceroute


Tabla
8.5
‚Ä¢
Pol√≠ticas
y
reglas
de
filtrado
correspondientes
de
la
red
130.27/16


de
una
organizaci√≥n
con
un
servidor
web
en
130.207.244.203
.


puesto
a
1
dicho
bit
.
Por
tanto
,
si
una
organizaci√≥n
desea
impedir
que
los
clientes
externos


inicien
conexiones
con
los
servidores
internos
,
basta
con
filtrar
todos
los
segmentos
entran-


tes
que
tengan
el
bit
ACK
puesto
a
0
.
Esta
pol√≠tica
prohibe
todas
las
conexiones
TCP
que


tienen
su
origen
en
el
exterior
,
pero
permite
las
conexiones
originadas
internamente
.


Las
reglas
de
cortafuegos
se
implementan
en
los
routers
mediante
listas
de
control
de


acceso
,
teniendo
cada
interfaz
del
router
su
propia
lista
.
En
la
Tabla
8.6
se
muestra
un
ejem-


plo
de
una
lista
de
control
de
acceso
para
una
organizaci√≥n
222.22/16
.
Esta
lista
de
control


de
acceso
es
para
una
interfaz
que
conecta
el
router
con
los
ISP
externos
a
la
organizaci√≥n
.


Las
reglas
se
aplican
a
cada
datagrama
que
atraviesa
la
interfaz
de
arriba
a
abajo
.
Las
dos


primeras
reglas
juntas
permiten
a
los
usuarios
internos
navegar
por
la
Web
:
la
primera
regla


permite
salir
de
la
red
de
la
organizaci√≥n
a
cualquier
paquete
TCP
con
el
puerto
de
destino


80
;
la
segunda
regla
permite
entrar
en
la
red
de
la
organizaci√≥n
a
cualquier
paquete
TCP
que


tenga
el
puerto
de
origen
80
y
el
bit
ACK
activado
.
Observe
que
si
un
origen
externo
intenta


establecer
una
conexi√≥n
TCP
con
un
host
interno
la
conexi√≥n
ser√°
bloqueada
,
incluso
aun-


que
el
puerto
de
origen
o
el
de
destino
sea
el
puerto
80
.
Las
dos
reglas
siguientes
juntas
per-


miten
a
los
paquetes
DNS
entrar
y
salir
de
la
red
de
la
organizaci√≥n
.
En
resumen
,
esta
lista


de
control
de
acceso
bastante
restrictiva
bloquea
todo
el
tr√°fico
excepto
el
tr√°fico
web
ini-


ciado
dentro
de
la
organizaci√≥n
y
el
tr√°fico
DNS
.
[
CERT
Filtering
2009
]
proporciona
una


lista
de
filtros
de
paquetes
basados
en
puertos
/
protocolos
recomendados
para
evitar
una
serie


de
agujeros
de
seguridad
bien
conocidos
en
las
aplicaciones
de
red
existentes
.


Filtros
de
paquetes
con
memoria
del
estado


En
un
filtro
de
paquetes
tradicional
,
las
decisiones
de
filtrado
se
toman
para
cada
paquete
de


forma
aislada
.
Los
filtros
con
memoria
del
estado
realmente
controlan
las
conexiones
TCP
y


utilizan
dicha
informaci√≥n
para
tomar
las
decisiones
de
filtrado
.


Para
entender
los
filtros
con
memoria
del
estado
,
examinemos
de
nuevo
la
lista
de
con-


trol
de
acceso
de
la
Tabla
8.6
.
Aunque
bastante
restrictiva
,
la
lista
de
control
de
acceso
de


esta
tabla
permite
que
cualquier
paquete
procedente
del
exterior
con
ACK
=
1
y
puerto
de


8.8
‚Ä¢
SEGURIDAD
OPERACIONAL
713


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
713Acci√≥n
Direcci√≥n
Direcci√≥n
Protocolo
Puerto
de
Puerto
de
Bit


de
origen
de
destino
origen
destino
indicador


Permitir
222.22/16
fuera
de
222.22/16
TCP
>
1023
80
cualquiera


Permitir
fuera
de
222.22/16
222.22/16
TCP
80
>
1023
ACK


Permitir
222.22/16
fuera
de
222.22/16
UDP
>
1023
53
‚Äî


Permitir
fuera
de
222.22/16
222.22/16
UDP
53
>
1023
‚Äî


Denegar
todos
todos
todos
todos
todos
todos


Tabla
8.6
‚Ä¢
Lista
de
control
de
acceso
para
una
interfaz
de
router
.


origen
80
atraviese
el
filtro
.
Tales
paquetes
podr√≠an
ser
utilizados
por
posibles
atacantes
para


intentar
hacer
fallar
a
los
sistemas
internos
con
paquetes
mal
formados
,
llevar
a
cabo
ata-


ques
de
denegaci√≥n
de
servicio
o
realizar
un
mapa
de
la
red
interna
.
La
soluci√≥n
m√°s
senci-


lla
consiste
en
bloquear
tambi√©n
los
paquetes
TCP
ACK
,
pero
este
m√©todo
impedir√≠a
a
los


usuarios
internos
de
la
organizaci√≥n
navegar
por
la
Web
.


Los
filtros
con
memoria
del
estado
resuelven
este
problema
almacenando
la
informa-


ci√≥n
de
todas
las
conexiones
TCP
activas
en
una
tabla
de
conexiones
.
Esto
es
posible
porque


el
cortafuegos
puede
observar
el
inicio
de
una
nueva
conexi√≥n
observando
un
acuerdo
en


tres
fases
(
SYN
,
SYNACK
y
ACK
)
y
puede
observar
el
fin
de
una
conexi√≥n
cuando
ve
un


paquete
FIN
para
la
conexi√≥n
.
El
cortafuegos
tambi√©n
puede
suponer
(
de
forma
conserva-


dora
)
que
la
conexi√≥n
ha
terminado
cuando
no
ha
observado
ninguna
actividad
en
la
misma


durante
,
por
ejemplo
,
60
segundos
.
En
la
Tabla
8.7
se
muestra
un
ejemplo
de
una
tabla
de


conexiones
para
un
cortafuegos
.
Esta
tabla
de
conexiones
indica
que
actualmente
hay
tres


conexiones
TCP
activas
,
habi√©ndose
iniciado
todas
ellas
dentro
de
la
organizaci√≥n
.
Adicio-


nalmente
,
el
filtro
con
memoria
del
estado
incluye
una
nueva
columna
,
‚Äú
Comprobar
cone-


xi√≥n
‚Äù
,
en
su
lista
de
control
de
acceso
,
como
se
muestra
en
la
Tabla
8.8
.
Observe
que
esta


tabla
es
id√©ntica
a
la
lista
de
control
de
acceso
de
la
Tabla
8.6
,
excepto
en
que
ahora
indica


que
la
conexi√≥n
deber√≠a
ser
comprobada
para
dos
de
las
reglas
.


Veamos
algunos
ejemplos
para
examinar
c√≥mo
trabajan
conjuntamente
la
tabla
de
cone-


xiones
y
la
lista
de
control
de
acceso
ampliada
.
Suponga
que
un
atacante
intenta
introducir


un
paquete
mal
formado
en
la
red
de
la
organizaci√≥n
enviando
un
datagrama
con
el
puerto


de
origen
TCP
n√∫mero
80
y
con
el
bit
indicador
ACK
activado
.
Suponga
adem√°s
que
este


paquete
tiene
el
n√∫mero
de
puerto
de
origen
12543
y
la
direcci√≥n
IP
de
origen
150.23
.


23.155
.
Cuando
este
paquete
llega
al
cortafuegos
,
√©ste
comprueba
la
lista
de
control
de


acceso
de
la
Tabla
8.8
,
la
cual
indica
que
la
tabla
de
conexiones
tambi√©n
tiene
que
ser
com-


probada
antes
de
permitir
la
entrada
a
este
paquete
en
la
red
de
la
organizaci√≥n
.
El
cortafue-


gos
comprueba
debidamente
la
tabla
de
conexiones
,
ve
que
ese
paquete
no
es
parte
de
una


conexi√≥n
TCP
activa
y
lo
rechaza
.
Como
segundo
ejemplo
,
suponga
que
un
usuario
interno


desea
navegar
por
un
sitio
web
externo
.
Puesto
que
este
usuario
en
primer
lugar
env√≠a
un


segmento
TCP
SYN
,
la
conexi√≥n
TCP
del
usuario
se
registra
en
la
tabla
de
conexiones
.


Cuando
el
servidor
web
devuelve
los
paquetes
(
con
el
bit
ACK
necesariamente
activado
)
,
el


cortafuegos
comprueba
la
tabla
y
ve
que
la
correspondiente
conexi√≥n
est√°
en
curso
.
Por


tanto
,
el
cortafuegos
deja
pasar
a
estos
paquetes
,
no
interviniendo
entonces
en
la
actividad


de
navegaci√≥n
por
la
Web
del
usuario
interno
.


714
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
714Direcci√≥n
de
origen
Direcci√≥n
de
destino
Puerto
de
origen
Puerto
de
destino


222.22.1.7
37.96.87.123
12699
80


222.22.93.2
199.1.205.23
37654
80


222.22.65.143
203.77.240.43
48712
80


Tabla
8.7
‚Ä¢
Tabla
de
conexiones
de
un
filtro
con
memoria
del
estado
.


Acci√≥n
Direcci√≥n
Direcci√≥n
Protocolo
Puerto
de
Puerto
de
Bit
Comprobar


de
origen
de
destino
origen
destino
indicador
conexi√≥n


Permitir
222.22/16
fuera
de
TCP
>
1023
80
cualquiera


222.22/16


Permitir
fuera
de
222.22/16
TCP
80
>
1023
ACK
X


222.22/16


Permitir
222.22/16
fuera
de
UDP
>
1023
53
‚Äî


222.22/16


Permitir
fuera
de
222.22/16
UDP
53
>
1023
‚Äî
X


222.22/16


Denegar
todos
todos
todos
todos
todos
todos


Tabla
8.8
‚Ä¢
Lista
de
control
de
acceso
para
un
filtro
con
memoria


del
estado
.


Pasarela
de
aplicaci√≥n


En
los
ejemplos
anteriores
hemos
visto
que
el
filtrado
en
el
nivel
de
paquetes
permite
a
una


organizaci√≥n
realizar
un
filtrado
basto
,
bas√°ndose
en
los
contenidos
de
las
cabeceras
IP
y


TCP
/
UDP
,
incluyendo
las
direcciones
IP
,
los
n√∫meros
de
puerto
y
los
bits
de
reconocimiento


(
ACK
)
.
Pero
,
¬ø
qu√©
ocurre
si
una
organizaci√≥n
desea
proporcionar
un
servicio
Telnet
a
un


conjunto
restringido
de
usuarios
internos
(
en
oposici√≥n
a
direcciones
IP
)
?
¬ø
Y
qu√©
ocurre
si


la
organizaci√≥n
desea
que
tales
usuarios
privilegiados
se
autentiquen
a
s√≠
mismos
antes
de


permitirles
establecer
conexiones
Telnet
con
el
mundo
exterior
?
Tales
tareas
quedan
fuera


de
las
capacidades
de
los
filtros
tradicionales
y
con
memoria
del
estado
.
De
hecho
,
la
infor-


maci√≥n
acerca
de
la
identidad
de
los
usuarios
internos
est√°
en
los
datos
de
la
capa
de
aplica-


ci√≥n
y
no
est√°
incluida
en
las
cabeceras
IP
/
TCP
/
UDP
.


Para
conseguir
seguridad
con
un
nivel
de
granularidad
m√°s
fino
,
los
cortafuegos
deben


combinar
los
filtros
de
paquetes
con
pasarelas
de
aplicaci√≥n
.
Las
pasarelas
de
aplicaci√≥n


miran
m√°s
all√°
de
la
cabeceras
IP
/
TCP
/
UDP
y
toman
sus
decisiones
bas√°ndose
en
los
datos


de
aplicaci√≥n
.
Una
pasarela
de
aplicaci√≥n
es
un
servidor
espec√≠fico
de
aplicaci√≥n
a
trav√©s


del
cual
deben
pasar
todos
los
datos
de
aplicaci√≥n
(
entrantes
y
salientes
)
.
Pueden
ejecutarse


varias
aplicaciones
de
pasarela
sobre
el
mismo
host
,
pero
cada
pasarela
es
un
servidor
sepa-


rado
con
sus
propios
procesos
.


8.8
‚Ä¢
SEGURIDAD
OPERACIONAL
715


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
715Con
el
fin
de
proporcionar
algunas
nociones
sobre
las
pasarelas
de
aplicaci√≥n
,
vamos
a


dise√±ar
un
cortafuegos
que
permita
s√≥lo
a
un
grupo
restringido
de
usuarios
internos
estable-


cer
una
conexi√≥n
Telnet
con
el
exterior
y
que
impida
a
todos
los
clientes
externos
establecer


una
conexi√≥n
Telnet
con
la
red
interna
.
Tal
pol√≠tica
puede
conseguirse
implementando
una


combinaci√≥n
de
un
filtro
de
paquetes
(
en
un
router
)
y
una
pasarela
de
aplicaci√≥n
Telnet
,


como
se
muestra
en
la
Figura
8.35
.
El
filtro
del
router
est√°
configurado
para
bloquear
todas


las
conexiones
Telnet
excepto
aquellas
que
tienen
su
origen
en
la
direcci√≥n
IP
de
la
pasarela


de
aplicaci√≥n
.
Una
configuraci√≥n
de
filtro
como
√©sta
fuerza
a
todas
las
conexiones
Telnet


salientes
a
pasar
a
trav√©s
de
la
pasarela
de
aplicaci√≥n
.
Considere
ahora
un
usuario
interno


que
quiera
conectarse
mediante
Telnet
con
el
mundo
exterior
.
El
usuario
tiene
que
establecer


en
primer
lugar
una
sesi√≥n
Telnet
con
la
pasarela
de
aplicaci√≥n
.
Una
aplicaci√≥n
que
se


ejecute
en
la
pasarela
y
que
est√°
a
la
escucha
de
sesiones
Telnet
entrantes
pedir√°
al
usuario


que
introduzca
un
ID
de
usuario
y
una
contrase√±a
.
Cuando
el
usuario
proporcione
esta
infor-


maci√≥n
,
la
pasarela
de
aplicaci√≥n
la
comprobar√°
para
ver
si
el
usuario
tiene
permiso
para


establecer
una
conexi√≥n
T
elnet
con
el
mundo
exterior
.
Si
no
es
as√≠
,
la
pasarela
termina
la


conexi√≥n
Telnet
que
tiene
con
el
usuario
interno
.
Si
el
usuario
tiene
permiso
,
entonces


la
pasarela
(
1
)
pide
al
usuario
el
nombre
del
host
externo
con
el
que
desea
conectarse
,
(
2
)


establece
una
sesi√≥n
Telnet
entre
la
pasarela
y
el
host
externo
y
(
3
)
reenv√≠a
al
host
externo


todos
los
datos
que
lleguen
del
usuario
,
de
la
misma
manera
que
reenv√≠a
el
usuario
todos
los


datos
que
lleguen
desde
el
host
externo
.
De
este
modo
,
la
pasarela
de
aplicaci√≥n
 
Telnet
no


s√≥lo
se
encarga
de
realizar
la
autorizaci√≥n
del
usuario
,
sino
que
act√∫a
como
servidor
y


cliente
Telnet
,
retransmitiendo
la
informaci√≥n
entre
el
usuario
y
el
servidor
Telnet
remoto
.


Observe
que
el
filtro
permitir√°
que
se
lleve
a
cabo
el
paso
2
,
dado
que
es
la
pasarela
quien


inicia
la
conexi√≥n
Telnet
con
el
mundo
exterior
.


716
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Pasarela
de


aplicaci√≥n


Sesi√≥n
Telnet


host-pasarela


Sesi√≥n
Telnet


pasarela-
host
remoto


Router


y
filtro


Figura
8.35
‚Ä¢
Cortafuegos
que
consta
de
una
pasarela
de
aplicaci√≥n
y
un
filtro
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
716Las
redes
internas
a
menudo
disponen
de
m√∫ltiples
pasarelas
de
aplicaci√≥n
,
por
ejem-


plo
,
pasarelas
para
Telnet
,
HTTP
,
FTP
y
correo
electr√≥nico
.
De
hecho
,
el
servidor
de
correo


de
una
organizaci√≥n
(
v√©ase
la
Secci√≥n
2.4
)
y
la
cach√©
web
son
pasarelas
de
aplicaci√≥n
.


Pero
las
pasarelas
de
aplicaci√≥n
tambi√©n
tienen
sus
desventajas
.
En
primer
lugar
,
hace


falta
una
pasarela
de
aplicaci√≥n
diferente
para
cada
aplicaci√≥n
.
En
segundo
lugar
,
el
rendi-


miento
se
ver√°
afectado
,
dado
que
todos
los
datos
tendr√°n
que
ser
reenviados
a
trav√©s
de
la


pasarela
.
Esto
se
convierte
en
un
problema
particularmente
en
aquellos
casos
en
los
que
hay


8.8
‚Ä¢
SEGURIDAD
OPERACIONAL
717


ANONIMATO
Y
PRIVACIDAD


Suponga
que
deseamos
visitar
un
sitio
web
controvertido
(
por
ejemplo
,
un
sitio
de
activismo


pol√≠tico
)
y
que
(
1
)
no
queremos
revelar
nuestra
direcci√≥n
IP
al
sitio
web
,
(
2
)
no
queremos
que


el
ISP
local
(
que
podr√≠a
ser
el
ISP
de
nuestro
domicilio
o
empresa
)
sepa
que
estamos
visitan-


do
dicho
sitio
y
(
3
)
no
deseamos
que
el
ISP
local
vea
los
datos
que
estamos
intercambiando


con
el
sitio
.
Si
se
emplea
el
m√©todo
tradicional
de
conexi√≥n
directa
con
el
sitio
web
sin


ning√∫n
tipo
de
cifrado
no
ser√°
posible
conseguir
ninguno
de
los
tres
objetivos
anteriores
.


Incluso
utilizando
SSL
los
dos
primeros
objetivos
ser√°n
inalcanzables
:
la
direcci√≥n
IP
de


origen
ser√°
presentada
al
sitio
web
en
cada
datagrama
que
env√≠emos
y
la
direcci√≥n


de
destino
de
cada
paquete
que
env√≠emos
podr√°
ser
f√°cilmente
husmeada
por
el
ISP
local
.


Para
conseguir
la
confidencialidad
y
el
anonimato
,
podemos
en
su
lugar
utilizar
una
com-


binaci√≥n
de
servidor
proxy
de
confianza
y
SSL
,
como
se
muestra
en
la
Figura
8.36
.
Con
esta


t√©cnica
,
primero
establecemos
una
conexi√≥n
SSL
con
el
proxy
de
confianza
.
Despu√©s
envia-


mos
a
trav√©s
de
esta
conexi√≥n
SSL
una
solicitud
HTTP
de
una
p√°gina
situada
en
el
sitio
web


deseado
.
Cuando
el
proxy
reciba
la
solicitud
HTTP
cifrada
mediante
SSL
la
descifrar√°
y


reenviar√°
la
solicitud
HTTP
de
texto
en
claro
al
sitio
web
.
El
sitio
web
responder√°
entonces
al


proxy
que
a
su
vez
nos
reenviar√°
la
respuesta
a
trav√©s
de
SSL
.
Puesto
que
el
sitio
web
s√≥lo
ve


la
direcci√≥n
IP
del
proxy
,
y
no
la
direcci√≥n
de
nuestro
cliente
,
estaremos
obteniendo
un
acceso


verdaderamente
an√≥nimo
al
sitio
web
.
Y
como
todo
el
tr√°fico
entre
nosotros
y
el
proxy
est√°


cifrado
,
nuestro
ISP
local
no
puede
invadir
nuestra
intimidad
almacenando
en
un
registro
el


nombre
del
sitio
que
hemos
visitado
o
los
datos
que
estamos
intercambiando
.
Muchas


empresas
ofrecen
en
la
actualidad
tales
servicios
proxy
(
como
por
ejemplo
proxify.com
)
.


Por
supuesto
,
con
esta
soluci√≥n
,
nuestro
proxy
conoce
todos
los
datos
:
conoce
nuestra


direcci√≥n
IP
y
la
direcci√≥n
IP
del
sitio
que
estamos
navegando
;
y
puede
ver
como
texto
en


claro
todo
el
tr√°fico
intercambiado
entre
nosotros
y
el
sitio
web
.
Dicha
soluci√≥n
,
por
tanto
,


s√≥lo
ser√°
buena
si
nuestra
confianza
en
el
proxy
es
alta
.
Un
enfoque
m√°s
robusto
adoptado


por
el
servicio
de
anonimato
y
privacidad
TOR
consiste
en
enrutar
el
tr√°fico
a
trav√©s
de
una


serie
de
servidores
proxy
no
confabulados
[
TOR
2009
]
.
En
particular
,
TOR
permite
a
los


usuarios
sugerir
nuevos
proxies
para
su
lista
.
Cuando
un
usuario
se
conecta
a
un
servidor


utilizando
TOR
,
este
servicio
selecciona
aleatoriamente
(
de
entre
su
lista
de
proxies
)
una


cadena
de
tres
proxies
y
enruta
todo
el
tr√°fico
entre
el
cliente
y
el
servidor
a
trav√©s
de


esa
cadena
.
De
esta
forma
,
suponiendo
que
los
proxies
no
est√©n
confabulados
,
nadie
sabe


que
ha
tenido
lugar
una
comunicaci√≥n
entre
nuestra
direcci√≥n
IP
y
el
sitio
web
objetivo
.


Adem√°s
,
aunque
la
comunicaci√≥n
se
realice
como
texto
en
claro
entre
el
√∫ltimo
proxy
y
el
ser-


vidor
,
el
√∫ltimo
proxy
no
sabe
qu√©
direcci√≥n
IP
est√°
enviando
y
recibiendo
ese
texto
en
claro
.


HISTORIA


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
717varios
usuarios
o
aplicaciones
utilizando
la
misma
m√°quina
pasarela
.
Finalmente
,
el
soft-


ware
de
cliente
debe
saber
c√≥mo
contactar
con
la
pasarela
cuando
el
usuario
realiza
una
soli-


citud
,
y
debe
saber
tambi√©n
c√≥mo
decir
a
la
pasarela
de
aplicaci√≥n
con
qu√©
servidor
externo


hay
que
conectarse
.


8.8.2
Sistemas
de
detecci√≥n
de
intrusiones


Ya
hemos
visto
que
un
filtro
de
paquetes
(
tradicional
y
con
memoria
del
estado
)
inspecciona


los
campos
de
cabecera
TCP
,
UDP
e
ICMP
a
la
hora
de
decidir
qu√©
paquetes
deben
pasar
a


trav√©s
del
cortafuegos
.
Sin
embargo
,
para
detectar
muchos
tipos
de
ataques
necesitamos
lle-


var
a
cabo
una
inspecci√≥n
profunda
de
paquetes
,
es
decir
,
mirar
m√°s
all√°
de
los
campos
de


cabecera
examinando
los
propios
datos
de
aplicaci√≥n
transportados
por
los
paquetes
.
Como


hemos
visto
en
la
Secci√≥n
8.8.1
,
las
pasarelas
de
aplicaci√≥n
realizan
a
menudo
una
inspec-


ci√≥n
profunda
de
los
paquetes
.
Pero
cada
pasarela
de
aplicaci√≥n
s√≥lo
lleva
a
cabo
esa
tarea


para
una
aplicaci√≥n
espec√≠fica
.


Por
ello
,
existir√°
un
nicho
para
otro
tipo
m√°s
de
dispositivo
:
un
dispositivo
que
no
s√≥lo


examine
las
cabeceras
de
todos
los
paquetes
que
le
atraviesen
(
como
los
filtros
de
paquetes
)
,


sino
que
tambi√©n
lleve
a
cabo
una
inspecci√≥n
profunda
de
los
paquetes
(
a
diferencia
de
lo


que
sucede
con
los
filtros
de
paquetes
)
.
Cuando
uno
de
tales
dispositivos
detecte
un
paquete


sospechoso
o
una
serie
sospechosa
de
paquetes
puede
impedir
que
esos
paquetes
entren
en


la
red
de
la
organizaci√≥n
.
O
,
si
la
actividad
s√≥lo
se
considera
sospechosa
,
el
dispositivo


podr√≠a
dejar
pasar
los
paquetes
pero
enviando
alertas
a
un
administrador
de
red
,
que
puede


de
ese
modo
echar
un
vistazo
m√°s
detallado
a
dicho
tr√°fico
y
tomar
las
medidas
oportunas
.


Un
dispositivo
que
genere
alertas
cuando
observe
la
presencia
de
tr√°fico
potencialmente


malicioso
se
denomina
Sistema
de
detecci√≥n
de
intrusiones
(
IDS
,
Intrusion
Detection


System
)
.
Un
dispositivo
que
filtre
el
tr√°fico
sospechoso
se
denomina
Sistema
de
preven-


ci√≥n
de
intrusiones
(
IPS
,
Intrusion
Prevention
System
)
.
En
esta
secci√≥n
vamos
a
estudiar


ambos
tipos
de
sistemas
(
IDS
e
IPS
)
conjuntamente
,
dado
que
el
aspecto
t√©cnico
m√°s
intere-


sante
de
dichos
sistemas
es
c√≥mo
detectan
el
tr√°fico
sospechoso
(
y
no
si
env√≠an
alertas
o
eli-


minan
los
paquetes
)
.
Por
tanto
,
vamos
a
utilizar
el
t√©rmino
sistemas
IDS
para
referirnos


tanto
a
los
sistemas
IPS
como
a
los
IDS
.


Un
sistema
IDS
puede
emplearse
para
detectar
una
amplia
gama
de
ataques
,
incluyendo


los
de
mapeado
de
red
(
generados
,
por
ejemplo
,
por
nmap
)
,
escaneo
de
puertos
,
escaneos
de


718
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


Alicia


Anonymizing


Proxy


SSL


Texto
en
claro


Figura
8.36
‚Ä¢
C√≥mo
proporcionar
anonimato
y
privacidad
con
un
proxy
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
718la
pila
TCP
,
ataques
DoS
de
inundaci√≥n
del
ancho
de
banda
,
gusanos
y
virus
,
ataques
de


vulnerabilidades
del
sistema
operativo
y
ataques
de
vulnerabilidades
de
aplicaci√≥n
.
(
En
la


Secci√≥n
1.6
puede
ver
una
panor√°mica
de
los
ataques
de
red
.
)
Actualmente
miles
de
organi-


zaciones
utilizan
sistemas
IDS
.
Muchos
de
estos
sistemas
implementados
son
propietarios
,


comercializados
por
Cisco
,
Check
Point
y
otros
fabricantes
de
equipos
de
seguridad
.
Pero


otros
muchos
de
los
sistemas
IDS
implantados
son
sistemas
de
dominio
p√∫blico
,
como
el


tremendamente
popular
sistema
IDS
Snort
del
que
hablaremos
en
breve
.


Un
organizaci√≥n
puede
implantar
uno
o
m√°s
sensores
IDS
en
su
red
.
La
Figura
8.37


muestra
una
organizaci√≥n
con
tres
sensores
IDS
.
Cuando
se
implantan
m√∫ltiples
sensores
,


normalmente
funcionan
de
manera
concertada
,
enviando
informaci√≥n
acerca
de
las
activida-


des
de
tr√°fico
sospechoso
a
un
procesador
IDS
central
que
recopila
e
integra
la
informaci√≥n


y
env√≠a
alarmas
a
los
administradores
de
la
red
cuando
lo
considera
apropiado
.
En
la
Figura


8.37
,
la
organizaci√≥n
ha
dividido
su
red
en
dos
regiones
:
una
regi√≥n
de
alta
seguridad
,
prote-


gida
por
un
filtro
de
paquetes
y
una
pasarela
de
aplicaci√≥n
y
monitorizada
por
sensores
IDS
;


y
una
regi√≥n
de
menor
seguridad
,
denominada
Zona
desmilitarizada
(
DMZ
,
Demilitarized


Zone
)
que
est√°
protegida
s√≥lo
por
el
filtro
de
paquetes
,
aunque
tambi√©n
est√°
monitorizada


mediante
sensores
IDS
.
Observe
que
la
DMZ
incluye
los
servidores
de
la
organizaci√≥n
que


necesitan
comunicarse
con
el
mundo
exterior
,
como
su
servidor
web
p√∫blico
y
su
servidor


DNS
autoritativo
.


8.8
‚Ä¢
SEGURIDAD
OPERACIONAL
719


Internet


Servidor


web


Servidor


FTP


Servidor


DNS


Red
interna


Pasarela
de


aplicaci√≥n


Zona
desmilitarizada


Filtro


Clave
:


=
Sensores
IDS


Figura
8.37
‚Ä¢
Una
organizaci√≥n
en
la
que
se
ha
implantado
un
filtro
,


una
pasarela
de
aplicaci√≥n
y
sensores
IDS
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
719El
lector
puede
estar
pregunt√°ndose
al
llegar
a
este
punto
por
qu√©
se
emplean
m√∫ltiples


sensores
IDS
.
¬ø
Por
qu√©
no
colocar
simplemente
un
sensor
IDS
justo
detr√°s
del
filtro
de


paquetes
(
o
incluso
integrado
con
el
filtro
de
paquetes
)
en
la
Figura
8.37
?
Como
vamos
a


ver
en
breve
,
un
IDS
no
s√≥lo
tiene
que
llevar
a
cabo
una
inspecci√≥n
profunda
de
los
paque-


tes
,
sino
que
tambi√©n
debe
comparar
cada
paquete
que
pasa
con
decenas
de
miles
de
‚Äú
fir-


mas
‚Äù
;
esto
puede
requerir
una
cantidad
significativa
de
procesamiento
,
en
particular
si
la


organizaci√≥n
recibe
del
orden
de
gigabits
/
segundo
de
tr√°fico
procedente
de
Internet
.
Colo-


cando
los
sensores
IDS
un
poco
m√°s
aguas
abajo
,
cada
sensor
s√≥lo
ve
una
fracci√≥n
del
tr√°-


fico
de
la
organizaci√≥n
y
puede
cumplir
m√°s
f√°cilmente
con
su
tarea
.
De
todos
modos
,
hoy


d√≠a
hay
disponibles
sistemas
IDS
e
IPS
de
altas
prestaciones
y
muchas
organizaciones
sue-


len
conformarse
con
un
√∫nico
sensor
localizado
cerca
de
su
router
de
acceso
.


Los
sistemas
IDS
se
pueden
clasificar
en
t√©rminos
generales
en
sistemas
basados
en


firma
o
sistemas
basados
en
anomal√≠as
.
Un
IDS
basado
en
firmas
mantiene
una
amplia


base
de
datos
de
firmas
de
ataque
.
Cada
firma
es
un
conjunto
de
reglas
concernientes
a
una


actividad
de
intrusi√≥n
.
Una
firma
puede
ser
simplemente
una
lista
de
caracter√≠sticas
acerca


de
un
determinado
paquete
(
por
ejemplo
,
n√∫meros
de
puerto
de
origen
y
de
destino
,
tipo
de


protocolo
y
una
cadena
espec√≠fica
de
bits
en
la
carga
√∫til
del
paquete
)
o
puede
estar
relacio-


nada
con
una
serie
de
paquetes
.
Las
firmas
normalmente
son
creadas
por
ingenieros
de
segu-


ridad
de
red
experimentados
que
se
dedican
a
investigar
los
ataques
conocidos
.
El


administrador
de
red
de
una
organizaci√≥n
puede
personalizar
las
firmas
o
a√±adir
otras
de
su


creaci√≥n
a
la
base
de
datos
.


Operacionalmente
,
un
sistema
IDS
basado
en
firmas
analiza
cada
paquete
que
pasa
a
su


trav√©s
,
comparando
cada
paquete
husmeado
con
las
firmas
de
su
base
de
datos
.
Si
un


paquete
(
o
una
serie
de
paquetes
)
concuerda
con
una
firma
de
la
base
de
datos
,
el
IDS
genera


una
alerta
.
La
alerta
podr√≠a
enviarse
al
administrador
de
red
en
un
mensaje
de
correo
elec-


tr√≥nico
,
podr√≠a
mandarse
al
sistema
de
gesti√≥n
de
la
red
o
podr√≠a
simplemente
almacenarse


en
un
registro
para
su
futura
inspecci√≥n
.


Los
sistemas
IDS
basados
en
firma
,
aunque
est√°n
ampliamente
implantados
,
presentan


una
serie
de
limitaciones
.
La
m√°s
importante
es
que
se
requiere
un
conocimiento
previo
del


ataque
para
generar
una
firma
precisa
.
En
otras
palabras
,
un
IDS
basado
en
firmas
es
comple-


tamente
in√∫til
frente
a
nuevos
ataques
que
todav√≠a
no
hayan
sido
investigados
.
Otra
desven-


taja
es
que
incluso
si
se
produce
una
concordancia
con
una
firma
,
puede
que
dicha


concordancia
no
sea
el
resultado
de
un
ataque
,
con
lo
que
se
generar√≠a
una
falsa
alarma
.
Final-


mente
,
puesto
que
es
necesario
comparar
cada
paquete
con
una
amplia
colecci√≥n
de
firmas
,


el
IDS
puede
verse
desbordado
por
las
necesidades
de
procesamiento
y
debido
a
ello
fraca-


sar
a
la
hora
de
detectar
muchos
paquetes
maliciosos
.


Un
IDS
basado
en
anomal√≠as
crea
un
perfil
de
tr√°fico
observando
el
tr√°fico
durante
la


operaci√≥n
normal
.
Despu√©s
busca
flujos
de
paquetes
que
sean
estad√≠sticamente
inusuales
,


como
por
ejemplo
un
porcentaje
inusual
de
paquetes
ICMP
o
un
crecimiento
exponencial


s√∫bito
en
el
escaneo
de
puertos
y
barridos
mediante
ping
.
Lo
mejor
de
los
sistemas
IDS


basados
en
anomal√≠as
es
que
no
dependen
del
conocimiento
previo
acerca
de
los
ataques


existentes
;
es
decir
,
pueden
detectar
potencialmente
nuevos
ataques
no
documentados
.
Por


otro
lado
,
el
problema
de
distinguir
entre
el
tr√°fico
normal
y
el
tr√°fico
estad√≠sticamente
inu-


sual
es
extremadamente
complejo
.
A
fecha
de
hoy
,
la
mayor√≠a
de
los
sistemas
IDS
implanta-


dos
son
basados
en
signaturas
,
aunque
algunos
de
ellos
incluyen
algunas
caracter√≠sticas
de


los
sistemas
basados
en
anomal√≠as
.


720
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
720Snort


Snort
es
un
IDS
de
dominio
p√∫blico
y
c√≥digo
abierto
,
con
centenares
de
miles
de
implanta-


ciones
conocidas
[
Snort
2007
;
Koziol
2003
]
.
Puede
ejecutarse
sobre
plataformas
Linux
,


UNIX
y
Windows
.
Utiliza
la
interfaz
gen√©rica
de
an√°lisis
libpcap
,
que
tambi√©n
es
utilizada


por
Wireshark
y
otros
muchos
husmeadores
de
paquetes
.
Puede
gestionar
f√°cilmente
100


Mbps
de
tr√°fico
;
para
instalaciones
con
velocidades
de
tr√°fico
del
orden
de
gibabit/


segundo
puede
ser
necesario
emplear
m√∫ltiples
sensores
Snort
.


Para
entender
un
poco
c√≥mo
funciona
Snort
,
examinemos
un
ejemplo
de
signatura
utilizada


por
Snort
:


alert
icmp
$
EXTERNAL_NET
any
-
>
$
HOME_NET
any


(
msg:‚ÄùICMP
PING
NMAP
‚Äù
;
dsize
:
0
;
itype
:
8
;)


Esta
signatura
concordar√°
con
cualquier
paquete
ICMP
que
entre
en
la
red
de
la
organiza-


ci√≥n
(
$
HOME_NET
)
desde
el
exterior
(
$
EXTERNAL_NET
)
,
que
sea
de
tipo
8
(
ping
ICMP
)
y


que
carezca
de
carga
√∫til
(
dsize
=
0
)
.
Puesto
que
nmap
(
v√©ase
la
Secci√≥n
1.6
)
genera
paque-


tes
ping
con
estas
caracter√≠sticas
espec√≠ficas
,
esta
signatura
est√°
dise√±ada
para
detectar
los


barridos
ping
realizados
con
nmap
.
Cuando
un
paquete
concuerda
con
esta
signatura
,
Snort


genera
una
alerta
que
incluye
el
mensaje
‚Äú
ICMP
PING
NMAP
‚Äù
.


Lo
m√°s
impresionante
acerca
de
Snort
quiz√°
sea
la
enorme
comunidad
de
usuarios
y


expertos
de
seguridad
que
mantienen
su
base
de
datos
de
signaturas
.
Normalmente
,
al
cabo


de
pocas
horas
de
detectarse
un
ataque
la
comunidad
Snort
escribe
y
publica
una
signatura


del
ataque
que
despu√©s
es
descargada
por
los
centenares
de
miles
de
implantaciones
Snort


distribuidas
por
todo
el
mundo
.
Adem√°s
,
utilizando
la
sintaxis
de
signaturas
de
Snort
,
los


administradores
de
red
pueden
adaptar
las
signaturas
a
las
necesidades
de
su
propia
organi-


zaci√≥n
modificando
las
signaturas
existentes
o
creando
otras
completamente
nuevas
.


8.9
Resumen


En
este
cap√≠tulo
hemos
examinado
los
diversos
mecanismos
que
nuestros
amantes
secretos
,


Benito
y
Alicia
,
pueden
utilizar
para
comunicarse
de
forma
segura
.
Hemos
visto
que
Benito


y
Alicia
est√°n
interesados
en
la
confidencialidad
(
en
el
sentido
de
que
s√≥lo
ellos
sean
capa-


ces
de
entender
el
contenido
de
los
mensajes
transmitidos
)
,
en
la
autenticaci√≥n
del
punto
ter-


minal
(
con
el
fin
de
estar
seguros
de
que
est√°n
hablando
entre
ellos
)
y
en
la
integridad
de
los


mensajes
(
quieren
estar
seguros
de
que
sus
mensajes
no
son
alterados
en
el
camino
)
.
Por


supuesto
,
la
necesidad
de
comunicaciones
seguras
no
est√°
confinada
a
los
amantes
secretos
.


De
hecho
,
hemos
visto
en
las
Secciones
8.4
a
8.7
que
la
seguridad
puede
utilizarse
en
varias


capas
de
una
arquitectura
de
red
para
protegerse
frente
a
los
malos
que
tienen
en
sus
manos


un
enorme
arsenal
de
posibles
ataques
.


En
la
primera
parte
del
cap√≠tulo
hemos
presentado
varios
de
los
principios
que
subya-


cen
a
las
comunicaciones
seguras
.
En
la
Secci√≥n
8.2
hemos
cubierto
t√©cnicas
criptogr√°fi-


cas
para
el
cifrado
y
descifrado
de
datos
,
incluyendo
la
criptograf√≠a
de
clave
sim√©trica
y
la


criptograf√≠a
de
clave
p√∫blica
.
DES
y
RSA
se
han
examinado
como
casos
de
estudio
espe-


c√≠ficos
de
estas
dos
clases
principales
de
t√©cnicas
criptogr√°ficas
que
se
emplean
en
las


redes
actuales
.


8.9
‚Ä¢
RESUMEN
721


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
721En
la
Secci√≥n
8.3
hemos
examinado
dos
m√©todos
que
permiten
proporcionar
mecanis-


mos
para
asegurar
la
integridad
de
los
mensajes
:
los
c√≥digos
de
autenticaci√≥n
de
mensajes


(
MAC
,
Message
Authentication
Code
)
y
las
firmas
digitales
.
Los
dos
m√©todos
presentan
una


serie
de
paralelismos
.
Ambos
utilizan
funciones
hash
criptogr√°ficas
y
ambas
t√©cnicas
nos


permiten
verificar
el
origen
del
mensaje
,
as√≠
como
la
integridad
del
propio
mensaje
.
Una


diferencia
importante
es
que
los
c√≥digos
MAC
no
se
basan
en
el
cifrado
,
mientras
que
las


firmas
digitales
requieren
una
infraestructura
de
clave
p√∫blica
.
Ambas
t√©cnicas
se
usan


ampliamente
en
la
pr√°ctica
,
como
hemos
visto
en
las
Secciones
8.4
a
8.7
.
Adem√°s
,
las
fir-


mas
digitales
se
utilizan
para
crear
certificados
digitales
,
los
cuales
son
importantes
para


verificar
la
validez
de
las
claves
p√∫blicas
.
Tambi√©n
hemos
investigado
la
autenticaci√≥n
del


punto
terminal
y
hemos
visto
c√≥mo
pueden
emplearse
los
n√∫meros
distintivos
para
frustrar


los
ataques
por
reproducci√≥n
.


En
las
Secciones
8.4
a
8.7
hemos
examinado
varios
protocolos
de
red
seguros
que
dis-


frutan
de
un
amplio
uso
en
la
pr√°ctica
.
Hemos
visto
que
la
criptograf√≠a
de
clave
sim√©trica
se


encuentra
en
el
n√∫cleo
de
PGP
,
SSL
,
IPsec
y
la
seguridad
inal√°mbrica
.
Hemos
visto
que
la


criptograf√≠a
de
clave
p√∫blica
es
crucial
tanto
para
PGP
como
para
SSL
.
Tambi√©n
hemos
visto


que
PGP
utiliza
firmas
digitales
para
proporcionar
la
integridad
de
los
mensajes
,
mientras
que


SSL
e
IPsec
utilizan
c√≥digos
MAC
.
Conociendo
ahora
los
principios
b√°sicos
de
la
criptogra-


f√≠a
y
habiendo
estudiado
c√≥mo
se
utilizan
realmente
estos
principios
,
el
lector
est√°
ahora
en


posici√≥n
de
dise√±ar
sus
propios
protocolos
de
red
seguros
.


Con
las
t√©cnicas
cubiertas
en
las
Secciones
8.2
a
8.7
Benito
y
Alicia
pueden
comuni-


carse
de
forma
segura
.
(
Suponiendo
que
sean
estudiantes
de
redes
que
han
aprovechado
el


material
de
este
libro
y
que
de
esa
forma
pueden
evitar
que
Tom√°s
descubra
su
relaci√≥n
amo-


rosa
.
)
Pero
la
confidencialidad
es
s√≥lo
una
peque√±a
parte
de
la
panor√°mica
general
de
la


seguridad
de
las
redes
.
Como
hemos
se√±alado
en
la
Secci√≥n
8.8
,
el
√©nfasis
en
la
seguridad


de
red
se
ha
puesto
cada
vez
m√°s
en
proteger
la
infraestructura
de
la
red
frente
a
potenciales


ataques
realizados
por
los
malos
.
En
la
√∫ltima
parte
del
cap√≠tulo
hemos
abordado
los
corta-


fuegos
y
los
sistemas
IDS
que
inspeccionan
los
paquetes
que
entran
y
salen
de
la
red
de
una


organizaci√≥n
.


Este
cap√≠tulo
ha
cubierto
una
gran
cantidad
de
temas
,
centr√°ndose
en
los
aspectos
m√°s


importantes
de
la
seguridad
en
las
redes
modernas
.
Animamos
a
los
lectores
que
deseen


profundizar
a
investigar
las
referencias
citadas
a
lo
largo
del
cap√≠tulo
.
En
particular
,
reco-


mendamos
[
Skoudis
2006
]
para
los
temas
relacionados
con
los
ataques
a
la
seguridad
opera-


cional
,
[
Kaufman
1995
]
para
el
estudio
de
la
criptograf√≠a
y
c√≥mo
se
aplica
a
la
seguridad
de


redes
,
[
Rescorla
2001
]
que
proporciona
un
tratamiento
profundo
pero
asequible
sobre
SSL
y


[
Edney
2003
]
que
ofrece
una
exposici√≥n
sobre
la
seguridad
802.11
,
incluyendo
una
investi-


gaci√≥n
intuitiva
sobre
WEP
y
sus
desventajas
.
Los
lectores
que
lo
deseen
tambi√©n
pueden


consultar
[
Ross
2009
]
para
ver
un
amplio
conjunto
de
diapositivas
PowerPoint
(
m√°s
de
400
)


sobre
la
seguridad
en
las
redes
,
as√≠
como
varias
pr√°cticas
de
laboratorio
basadas
en
Linux
.


722
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
722Problemas
y
cuestiones
de
repaso


Cap√≠tulo
8
Problemas
de
repaso


SECCI√ìN
8.1


R1
.
¬ø
Cu√°les
son
las
diferencias
entre
la
confidencialidad
de
los
mensajes
y
la
integridad


de
los
mismos
?
¬ø
Puede
existir
confidencialidad
sin
integridad
?
¬ø
Puede
existir
integri-


dad
sin
confidencialidad
?
Justifique
su
respuesta
.


R2
.
Las
entidades
Internet
(
routers
,
dispositivos
de
conmutaci√≥n
,
servidores
DNS
,
servi-


dores
web
,
sistemas
terminales
de
usuario
,
etc.
)
a
menudo
necesitan
comunicarse
de


forma
segura
.
Proporcione
tres
parejas
espec√≠ficas
de
ejemplo
de
entidades
de
Internet


que
puedan
desear
comunicarse
de
forma
segura
.


SECCI√ìN
8.2


R3
.
Desde
la
perspectiva
de
un
servicio
,
¬ø
cu√°l
es
una
diferencia
importante
entre
un
sis-


tema
de
clave
sim√©trica
y
un
sistema
de
clave
p√∫blica
?


R4
.
Suponga
que
un
intruso
dispone
de
un
mensaje
cifrado
as√≠
como
de
la
versi√≥n
desci-


frada
de
dicho
mensaje
.
¬ø
Puede
el
intruso
montar
un
ataque
de
s√≥lo
texto
cifrado
,
un


ataque
de
texto
en
claro
conocido
o
un
ataque
de
texto
claro
seleccionado
?


R5
.
Considere
un
cifrado
de
8
bloques
.
¬ø
Cu√°ntos
posibles
bloques
de
entrada
tiene
este


sistema
de
cifrado
?
¬ø
Cu√°ntas
posibles
correspondencias
existen
?
Si
interpretamos


cada
correspondencia
como
una
clave
,
entonces
¬ø
cu√°ntas
posibles
claves
tiene
este


sistema
de
cifrado
?


R6
.
Suponga
que
N
personas
desean
comunicarse
con
cada
una
de
las
otras
N
‚Äì
1
personas


utilizando
un
sistema
de
cifrado
de
clave
sim√©trica
.
Todas
las
comunicaciones
entre


cualesquiera
dos
personas
,
i
y
j
,
son
visibles
para
todas
las
dem√°s
personas
de
ese


grupo
de
N
y
nadie
que
no
pertenezca
a
ese
grupo
debe
poder
decodificar
sus
comuni-


caciones
.
¬ø
Cu√°ntas
claves
son
necesarias
en
el
sistema
,
considerado
como
un
todo
?


Suponga
ahora
que
se
utiliza
un
sistema
de
cifrado
de
clave
p√∫blica
.
¬ø
Cu√°ntas
claves


se
requerir√°n
en
este
caso
?


R7
.
Suponga
que
n
=
10.000
,
a
=
10.023
y
b
=
10.004
.
Utilice
una
identidad
de
aritm√©tica


modular
para
calcular
mentalmente
(
a
‚Ä¢
b
)
mod
n.


R8
.
Suponga
que
desea
cifrar
el
mensaje
10101111
cifrando
el
n√∫mero
decimal
correspon-


diente
al
mensaje
.
¬ø
Cu√°l
es
el
n√∫mero
decimal
?


SECCI√ìN
8.3


R9
.
¬ø
De
qu√©
forma
una
funci√≥n
hash
proporciona
una
mejor
comprobaci√≥n
de
la
integri-


dad
de
los
mensajes
que
una
suma
de
comprobaci√≥n
,
tal
como
la
suma
de
comproba-


ci√≥n
de
Internet
?


R10
.
¬ø
Se
puede
‚Äú
descifrar
‚Äù
un
valor
hash
de
un
mensaje
para
obtener
el
mensaje
original
?


Explique
su
respuesta
.


PROBLEMAS
Y
CUESTIONES
DE
REPASO
723


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
723R11
.
Considere
una
variante
del
algoritmo
MAC
(
Figura
8.9
)
en
la
que
el
emisor
env√≠a
(
m
,


H(m
)
+
s
)
,
siendo
H(m
)
+
s
la
concatenaci√≥n
de
H(m
)
y
s.
¬ø
Tiene
alg√∫n
defecto
esta


variante
?
¬ø
Por
qu√©
?


R12
.
¬ø
Qu√©
quiere
decir
que
un
documento
firmado
sea
verificable
y
no
falsificable
?


R13
.
¬ø
En
qu√©
sentido
es
mejor
utilizar
como
firma
digital
la
versi√≥n
cifrada
mediante
clave


p√∫blica
del
valor
hash
de
un
mensaje
,
en
lugar
de
usar
la
versi√≥n
cifrada
mediante


clave
p√∫blica
del
mensaje
completo
?


R14
.
Suponga
que
certificador.com
crea
un
certificado
para
foo.com
.
Normalmente
,
el
cer-


tificado
completo
ser√°
cifrado
con
la
clave
p√∫blica
de
certificador.com
.
¬ø
Verdadero
o


falso
?


R15
.
Suponga
que
Alicia
tiene
un
mensaje
que
est√°
dispuesta
a
enviar
a
cualquiera
que
se
lo


solicite
.
Miles
de
personas
desean
obtener
el
mensaje
de
Alicia
,
pero
cada
una
de
ellas


desea
estar
segura
de
la
integridad
del
mensaje
.
En
este
contexto
,
¬ø
qu√©
piensa
que
es


m√°s
adecuado
un
esquema
de
integridad
basado
en
MAC
o
uno
basado
en
firma
digi-


tal
?
¬ø
Por
qu√©
?


R16
.
¬ø
Cu√°l
es
el
prop√≥sito
de
un
n√∫mero
distintivo
en
un
protocolo
de
autenticaci√≥n
de


punto
terminal
?


R17
.
¬ø
Qu√©
quiere
decir
que
un
n√∫mero
distintivo
es
un
valor
que
s√≥lo
se
usa
una
vez
en
la


vida
?
¬ø
En
la
vida
de
qui√©n
?


R18
.
¬ø
Qu√©
es
un
ataque
por
interposici√≥n
?
¬ø
Puede
producirse
este
ataque
cuando
se
utilizan


claves
sim√©tricas
?


SECCIONES
8.4‚Äì8.7


R19
.
Suponga
que
Benito
recibe
un
mensaje
PGP
de
Alicia
.
¬ø
C√≥mo
puede
Benito
estar


seguro
de
que
Alicia
ha
creado
el
mensaje
(
en
lugar
de
,
por
ejemplo
,
Tom√°s
)
?
¬ø
Utiliza


PGP
un
valor
MAC
para
garantizar
la
integridad
del
mensaje
?


R20
.
En
el
registro
SSL
existe
un
campo
para
los
n√∫meros
de
secuencia
SSL
.
¬ø
Verdadero
o


falso
?


R21
.
¬ø
Cu√°l
es
el
prop√≥sito
de
los
n√∫meros
distintivos
aleatorios
en
el
proceso
de
acuerdo
de


SSL
?


R22
.
Suponga
que
una
sesi√≥n
SSL
emplea
un
cifrado
de
bloque
con
CBC
.
Verdadero
o


falso
:
el
servidor
env√≠a
al
cliente
el
vector
de
inicializaci√≥n
(
IV
)
en
claro
.


R23
.
Suponga
que
Benito
inicia
una
conexi√≥n
TCP
con
Tom√°s
,
que
pretende
hacerse
pasar


por
Alicia
.
Durante
la
fase
de
acuerdo
,
Tom√°s
env√≠a
a
Benito
el
certificado
de
Alicia
.


¬ø
En
qu√©
paso
del
algoritmo
de
acuerdo
SSL
descubrir√°
Benito
que
no
est√°
comunic√°n-


dose
con
Alicia
?


R24
.
Considere
la
transmisi√≥n
de
un
flujo
de
paquetes
desde
el
host
A
al
host
B
utilizando


IPsec
.
Normalmente
se
establecer√°
una
nueva
asociaci√≥n
de
seguridad
(
SA
)
para
cada


paquete
enviado
del
flujo
.
¬ø
Verdadero
o
falso
?


R25
.
Suponga
que
TCP
est√°
ejecut√°ndose
sobre
IPsec
entre
las
sucursales
y
la
oficina
prin-


cipal
de
la
Figura
8.29
.
Si
TCP
retransmite
el
mismo
paquete
,
entonces
los
dos
paque-


724
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
724tes
correspondientes
enviados
por
R1
tendr√°n
el
mismo
n√∫mero
de
secuencia
en
la


cabecera
ESP
.
¬ø
Verdadero
o
falso
?


R26
.
¬ø
Es
lo
mismo
una
asociaci√≥n
de
seguridad
IKE
que
una
asociaci√≥n
de
seguridad


IPsec
?
¬ø
Verdadero
o
falso
?


R27
.
Considere
el
protocolo
WEP
para
802.11
.
Suponga
que
los
datos
son
10101100
y
que


el
flujo
de
claves
es
1111000
.
¬ø
Cu√°l
ser√°
el
texto
cifrado
resultante
?


R28
.
En
WEP
,
en
cada
trama
se
env√≠a
un
vector
de
inicializaci√≥n
(
IV
)
en
claro
.
¬ø
Verdadero


o
falso
?


SECCI√ìN
8.8


R29
.
Los
filtros
de
paquetes
con
memoria
del
estado
mantienen
dos
estructuras
de
datos
.


N√≥mbrelas
y
describa
brevemente
qu√©
hacen
.


R30
.
Considere
un
filtro
de
paquetes
tradicional
(
sin
conocimiento
del
estado
)
.
Este
filtro


puede
filtrar
paquetes
bas√°ndose
en
los
bits
indicadores
TCP
,
as√≠
como
en
otros
cam-


pos
de
cabecera
.
¬ø
Verdadero
o
falso
?


R31
.
En
un
filtro
de
paquetes
tradicional
,
cada
interfaz
puede
tener
su
propia
lista
de
con-


trol
de
acceso
.
¬ø
Verdadero
o
falso
?


R32
.
¬ø
Por
qu√©
una
pasarela
de
aplicaci√≥n
debe
trabajar
conjuntamente
con
un
filtro
de
rou-


ter
para
ser
efectiva
?


R33
.
Los
sistemas
IDS
e
IPS
basados
en
firma
inspeccionan
las
cargas
√∫tiles
de
los
segmen-


tos
TCP
y
UDP
.
¬ø
Verdadero
o
falso
?


Problemas


P1
.
Utilizando
el
cifrado
monoalfab√©tico
de
la
Figura
8.3
,
codifique
el
mensaje
‚Äú
Este
pro-


blema
es
f√°cil
.
‚Äù
Decodifique
el
mensaje
‚Äú
rmij‚Äôu
uamu
xyj
‚Äù
.


P2
.
Demuestre
que
el
ataque
de
texto
en
claro
conocido
de
Tom√°s
,
en
el
que
Tom√°s
conoce


las
parejas
de
traducci√≥n
(
texto
cifrado
,
texto
en
claro
)
de
doce
letras
,
reduce
el


n√∫mero
de
posibles
sustituciones
que
tienen
que
comprobarse
en
el
ejemplo
de
la
Sec-


ci√≥n
8.2.1
en
un
factor
de
aproximadamente
1015
.


P3
.
Considere
el
sistema
polialfab√©tico
mostrado
en
la
Figura
8.4
.
Un
ataque
de
texto
en


claro
seleccionado
que
es
capaz
de
obtener
la
codificaci√≥n
del
texto
en
claro
del
men-


saje
‚Äú
Esextra√±omojarquesoenlacervezao
probar
whisky
de
garrafa
‚Äù
,


¬ø
ser√°
suficiente
para
decodificar
todos
los
mensajes
?
¬ø
Por
qu√©
?


P4
.
Considere
el
cifrado
de
bloque
de
la
Figura
8.5
.
Suponga
que
cada
cifrado
de
bloque


Ti
simplemente
invierte
el
orden
de
los
ocho
bits
de
entrada
(
de
manera
que
,
por
ejem-


plo,11110000
se
convierte
en
00001111
)
.
Suponga
adem√°s
que
el
aleatorizador
de
64


bits
no
modifica
ninguno
de
los
bits
(
de
manera
que
el
valor
de
salida
del
bit
m-√©simo


es
igual
al
valor
de
entrada
del
mismo
bit
)
.
(
a
)
Con
n
=
3
y
siendo
la
entrada
de
64
bits


original
igual
a
10100000
repetido
ocho
veces
,
¬ø
cu√°l
es
el
valor
de
salida
?
(
b
)
Repita


el
apartado
(
a
)
pero
ahora
cambie
el
√∫ltimo
bit
de
la
entrada
de
64
bits
original
de
0
a


PROBLEMAS
725


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
7251
.
(
c
)
Repita
los
apartados
(
a
)
y
(
b
)
pero
ahora
suponga
que
el
aleatorizador
de
64
bits


invierte
el
orden
de
los
64
bits
.


P5
.
Considere
el
cifrado
de
bloque
de
la
Figura
8.5
.
Para
una
determinada
‚Äú
clave
‚Äù
,
Alicia


y
Benito
tendr√°n
que
mantener
ocho
tablas
,
cada
una
de
ellas
de
8
bits
por
8
bits
.
Para


que
Alicia
(
o
Benito
)
pueda
almacenar
las
ocho
tablas
,
¬ø
cu√°ntos
bits
de
almacena-


miento
son
necesarios
?
¬ø
C√≥mo
se
compara
este
n√∫mero
con
el
n√∫mero
de
bits
requeri-


dos
para
un
sistema
de
cifrado
de
bloque
de
64
bits
de
tabla
completa
?


P6
.
Considere
el
cifrado
de
bloque
de
3
bits
de
la
Tabla
8.1
y
que
dispone
del
texto
en


claro
100100100
.
(
a
)
Suponga
que
inicialmente
no
se
utiliza
CBC
.
¬ø
Cu√°l
es
el
texto


cifrado
resultante
?
(
b
)
Suponga
que
Tom√°s
husmea
el
texto
cifrado
.
Suponiendo
que


Tom√°s
sabe
que
se
est√°
utilizando
un
cifrado
de
bloque
de
3
bits
sin
CBC
(
aunque
no


sabe
cu√°l
es
el
cifrado
espec√≠fico
)
¬ø
qu√©
cosas
podr√°
deducir
Tom√°s
?
(
c
)
Ahora
suponga


que
se
utiliza
CBC
con
IV
=
111
.
¬ø
Cu√°l
es
el
texto
cifrado
resultante
?


P7
.
(
a
)
Utilizando
el
algoritmo
RSA
,
elija
p
=
3
y
q
=
11
,
y
codifique
la
palabra
‚Äú
perro
‚Äù


cifrando
cada
letra
por
separado
.
Aplicando
el
algoritmo
de
descifrado
a
la
versi√≥n


cifrada
recupere
el
mensaje
de
texto
en
claro
original
.
(
b
)
Repita
el
apartado
(
a
)


pero
cifrando
ahora
la
palabra
‚Äú
perro
‚Äù
como
un
mensaje
m.


P8
.
Considere
RSA
con
p
=
5
y
q
=
11
.


a.
Calcule
el
valor
de
n
y
z.


b.
Sea
e
igual
a
3
.
¬ø
Por
qu√©
√©ste
es
un
valor
aceptable
para
e
?


c.
Determine
d
tal
que
de
=
1
(
mod
z
)
y
d
<
160
.


d.
Cifre
el
mensaje
m
=
8
utilizando
la
clave
(
n
,
e
)
.
Sea
c
el
texto
cifrado
correspon-


diente
.
Indique
los
detalles
de
todos
los
c√°lculos
realizados
.
Sugerencia
:
para
sim-


plificar
los
c√°lculos
,
utilice
la
f√≥rmula
siguiente
:


[
(
a
mod
n
)
‚Ä¢
(
b
mod
n
)
]
mod
n
=
(
a
‚Ä¢
b
)
mod
n


P9
.
En
este
problema
vamos
a
explorar
el
algoritmo
de
cifrado
de
clave
p√∫blica
de
Diffie-


Hellman
(
DH
)
,
que
permite
a
dos
entidades
acordar
una
clave
compartida
.
El
algoritmo


de
Diffie-Hellman
utiliza
un
n√∫mero
primo
grande
p
y
otro
n√∫mero
tambi√©n
grande
g


pero
menor
que
p.
Tanto
p
como
g
se
hacen
p√∫blicos
(
por
lo
que
cualquier
atacante


podr√≠a
conocerlos
)
.
Con
el
algoritmo
DH
,
Alicia
y
Benito
seleccionan
de
forma
inde-


pendiente
sendas
claves
secretas
,
SA
y
SB
,
respectivamente
.
Alicia
calcula
entonces
su


clave
p√∫blica
,
TA
,
elevando
g
a
SA
y
reduciendo
el
resultado
mod
p.
Benito
calcula
de


forma
similar
su
propia
clave
p√∫blica
,
TB
,
elevando
g
a
SB
y
tomando
luego
mod
p.
Ali-


cia
y
Benito
intercambian
entonces
sus
claves
p√∫blicas
a
trav√©s
de
Internet
.
A
continua-


ci√≥n
Alicia
calcula
la
clave
secreta
compartida
S
elevando
TB
a
SA
y
luego
reduciendo
a


mod
p.
De
forma
similar
,
Benito
calcula
la
clave
compartida
S
¬¥
elevando
TA
a
SB
y


tomando
despu√©s
mod
p.


a.
Demuestre
que
,
en
general
,
Alicia
y
Benito
obtienen
la
misma
clave
sim√©trica
,
es


decir
,
demuestre
que
S
=
S
¬¥
.


b.
Sean
p
=
11
y
g
=
2
y
suponga
que
Alicia
y
Benito
seleccionan
sendas
claves
priva-


das
 
SA
=
5
y
SB
=
12
,
respectivamente
.
Calcule
las
claves
p√∫blicas
de
Alicia
y


Benito
,
TA
y
TB
.
Indique
todos
los
c√°lculos
realizados
.


726
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
726c
.
Continuando
con
el
apartado
(
b
)
,
calcule
ahora
la
clave
sim√©trica
compartida
S.


Indique
todos
los
c√°lculos
realizados
.


d.
Dibuje
un
diagrama
de
temporizaci√≥n
que
muestre
c√≥mo
puede
atacarse
el
algo-


ritmo
de
Diffie-Hellman
utilizando
un
ataque
por
interposici√≥n
.
El
diagrama
de


temporizaci√≥n
debe
tener
tres
l√≠neas
verticales
:
una
para
Alicia
,
otra
para
Benito
y


una
tercera
para
el
atacante
Tom√°s
.


P10
.
Suponga
que
Alicia
quiere
comunicarse
con
Benito
utilizando
criptograf√≠a
de
clave


sim√©trica
con
una
clave
de
sesi√≥n
KS
.
En
la
Secci√≥n
8.2
hemos
visto
c√≥mo
puede
utili-


zarse
la
criptograf√≠a
de
clave
p√∫blica
para
distribuir
la
clave
de
sesi√≥n
de
Alicia
a


Benito
.
En
este
problema
vamos
a
analizar
c√≥mo
puede
distribuirse
la
clave
de
sesi√≥n


(
sin
criptograf√≠a
de
clave
p√∫blica
)
utilizando
un
centro
de
distribuci√≥n
de
claves


(
KDC
,
Key
Distribution
Center
)
.
El
KDC
es
un
servidor
que
comparte
una
clave
sim√©-


trica
secreta
√∫nica
con
cada
usuario
registrado
.
Para
Alicia
y
Benito
vamos
a
designar


estas
claves
mediante
KA-KDC
y
KB-KDC
.
Dise√±e
un
esquema
que
utilice
el
KDC
para


distribuir
KS
a
Alicia
y
a
Benito
.
El
esquema
debe
utilizar
tres
mensajes
para
distribuir


la
clave
de
sesi√≥n
:
un
mensaje
de
Alicia
hacia
el
KDC
,
un
mensaje
del
KDC
a
Alicia


y
,
finalmente
,
un
mensaje
de
Alicia
a
Benito
.
El
primer
mensajes
ser√°
KA-KDC
(
A
,
B
)
.


Utilizando
la
notaci√≥n
KA-KDC
,
K
B-KDC
,
S
,
A
y
B
responda
a
las
siguientes
cuestiones
:


a.
¬ø
Cu√°l
es
el
segundo
mensaje
?


b.
¬ø
C√∫al
es
el
tercer
mensaje
?


P11
.
Calcule
un
tercer
mensaje
diferente
de
los
dos
mensajes
de
la
Figura
8.8
,
que
tenga
la


misma
suma
de
comprobaci√≥n
que
los
mensajes
de
la
Figura
 
8.8
.


P12
.
Suponga
que
Alicia
y
Benito
comparten
dos
claves
secretas
:
una
clave
de
autentica-


ci√≥n
S1
y
una
clave
sim√©trica
de
cifrado
S2
.
Ampl√≠e
la
Figura
8.9
de
forma
que
se
pro-


porcionen
tanto
integridad
como
confidencialidad
.


P13
.
En
el
protocolo
de
distribuci√≥n
de
archivos
P2P
BitTorrent
(
v√©ase
el
Cap√≠tulo
2
)
la


semilla
descompone
el
archivo
en
bloques
y
los
pares
se
redistribuyen
los
bloques


unos
a
otros
.
Si
no
se
utilizara
ninguna
protecci√≥n
,
un
atacante
podr√≠a
f√°cilmente
hacer


que
un
torrente
dejara
de
funcionar
haci√©ndose
pasar
por
un
par
benevolente
y


enviando
bloques
falsos
a
un
peque√±o
subconjunto
de
pares
del
torrente
.
Estos
pares


no
sospechosos
redistribuir√≠an
entonces
los
bloques
falsos
a
otros
pares
,
que
a
su
vez


los
distribuir√≠an
a
otros
.
Por
tanto
,
es
cr√≠tico
para
el
funcionamiento
de
BitTorrent
que


el
sistema
tenga
un
mecanismo
que
permita
a
un
par
verificar
la
integridad
de
un
blo-


que
,
de
modo
que
no
se
redistribuyan
bloques
falsos
.
Suponga
que
cuando
un
par
se


une
a
un
torrente
obtiene
inicialmente
un
archivo
.torrent
de
un
origen
completa-


mente
de
confianza
.
Describa
un
esquema
simple
que
permita
a
los
pares
verificar
la


integridad
de
los
bloques
.


P14
.
El
protocolo
de
enrutamiento
OSPF
utiliza
un
valor
MAC
en
lugar
de
firmas
digitales


para
garantizar
la
integridad
de
los
mensajes
.
¬ø
Por
qu√©
cree
que
se
eligi√≥
un
valor


MAC
en
lugar
de
firmas
digitales
?


P15
.
Considere
nuestro
protocolo
de
autenticaci√≥n
de
la
Figura
8.16
,
en
el
que
Alicia
se


autentica
ante
Benito
y
que
hemos
visto
que
funciona
bien
(
es
decir
,
no
hemos
encon-


trado
en
√©l
ning√∫n
fallo
)
.
Suponga
ahora
que
mientras
que
Alicia
se
est√°
autenticando


ante
Benito
,
√©ste
debe
autenticarse
ante
Alicia
.
Indique
el
escenario
mediante
el
cual


PROBLEMAS
727


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
727Tom√°s
,
haci√©ndose
pasar
por
Alicia
,
podr√≠a
ahora
autenticarse
ante
Benito
como
si


fuera
Alicia
.
(
Sugerencia
:
considere
que
la
secuencia
de
operaciones
del
protocolo
,


una
en
la
que
Tom√°s
es
el
iniciador
y
otra
en
la
que
el
iniciador
es
Benito
,
puede
entre-


mezclarse
arbitrariamente
.
Preste
atenci√≥n
especial
al
hecho
de
que
tanto
Benito
como


Alicia
utilizan
un
n√∫mero
distintivo
y
que
,
si
no
se
tiene
cuidado
,
alguien
podr√≠a
utili-


zar
maliciosamente
el
mismo
n√∫mero
distintivo
.
)


P16
.
En
el
ataque
por
interposici√≥n
(
man-in-the-middle
)
de
la
Figura
8.19
Alicia
no
ha


autenticado
a
Benito
.
Si
Alicia
requiriera
a
Benito
que
se
autenticara
utilizando
el
pro-


tocolo
de
autenticaci√≥n
de
clave
p√∫blica
,
¬ø
podr√≠a
evitarse
el
ataque
por
interposici√≥n
?


Explique
su
razonamiento
.


P17
.
La
Figura
8.20
muestra
las
operaciones
que
Alicia
debe
realizar
con
PGP
para
pro-


porcionar
confidencialidad
,
autenticaci√≥n
e
integridad
de
los
mensajes
.
Haga
un
dia-


grama
de
las
correspondientes
operaciones
que
Benito
debe
realizar
con
el
paquete


recibido
de
Alicia
.


P18
.
Suponga
que
Alicia
quiere
enviar
un
correo
electr√≥nico
a
Benito
.
Benito
tiene
una


pareja
de
claves
p√∫blica-privada
(
KB


+
,
KB


‚Äì
)
,
y
Alicia
dispone
del
certificado
de
Benito
.


Pero
Alicia
no
tiene
una
pareja
de
claves
p√∫blica
y
privada
.
Alicia
y
Benito
(
y
todo
el


mundo
)
comparten
la
misma
funci√≥n
hash
H(/H11080
)
.


a.
En
esta
situaci√≥n
,
¬ø
es
posible
dise√±ar
un
esquema
mediante
el
que
Benito
pueda


verificar
que
es
Alicia
quien
ha
creado
el
mensaje
?
En
caso
afirmativo
,
indique


c√≥mo
mediante
un
diagrama
de
bloques
para
Alicia
y
Benito
.


b.
¬ø
Es
posible
dise√±ar
un
esquema
que
proporcione
confidencialidad
para
enviar
el


mensaje
de
Alicia
a
Benito
?
En
caso
afirmativo
,
indique
c√≥mo
mediante
un
dia-


grama
de
bloques
para
Alicia
y
Benito
.


P19
.
Considere
la
salida
de
Wireshark
mostrada
en
la
p√°gina
siguiente
para
una
parte
de


una
sesi√≥n
SSL
.


a.
¬ø
El
paquete
Wireshark
112
ha
sido
enviado
por
el
cliente
o
por
el
servidor
?


b.
¬ø
Cu√°les
son
el
n√∫mero
de
puerto
y
la
direcci√≥n
IP
del
servidor
?


c.
Suponiendo
que
no
hay
p√©rdidas
ni
retransmisiones
,
¬ø
cu√°l
ser√°
el
n√∫mero
de


secuencia
del
siguiente
segmento
TCP
enviado
por
el
cliente
?


d.
¬ø
Cu√°ntos
registros
SSL
contiene
el
paquete
Wireshark
112
?


e.
El
paquete
112
¬ø
contiene
una
clave
maestra
(
MS
)
o
una
clave
maestra
cifrada


(
EMS
)
o
ninguna
de
las
dos
?


f.
Suponiendo
que
el
campo
de
tipo
de
acuerdo
es
de
1
byte
y
que
cada
campo
de


longitud
es
de
3
bytes
,
¬ø
cu√°les
son
los
valores
del
primer
y
√∫ltimo
byte
de
la
clave


maestra
(
o
de
la
clave
maestra
cifrada
)
?


g.
¬ø
Cu√°ntos
registros
SSL
tiene
en
cuenta
el
mensaje
cifrado
de
acuerdo
del
cliente
?


h.
¬ø
Cu√°ntos
registros
SSL
tiene
en
cuenta
el
mensaje
cifrado
de
acuerdo
del
servidor
?


P20
.
En
la
Secci√≥n
8.5.1
se
muestra
que
,
sin
n√∫meros
de
secuencia
,
Tom√°s
(
man-in-the


middle
)
puede
causar
una
cat√°strofe
en
una
sesi√≥n
SSL
intercambiando
segmentos


TCP
.
¬ø
Podr√≠a
Tom√°s
hacer
algo
similar
borrando
un
segmento
TCP
?
¬ø
Qu√©
necesitar√≠a


hacer
para
tener
√©xito
con
dicho
ataque
de
borrado
?
¬ø
Qu√©
efecto
tendr√≠a
?


728
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
728P21
.
Suponga
que
Alicia
y
Benito
se
est√°n
comunicando
mediante
una
sesi√≥n
SSL
.


Suponga
que
un
atacante
,
que
no
dispone
de
ninguna
de
las
claves
compartidas
,


inserta
un
segmento
TCP
falso
en
un
flujo
de
paquetes
con
la
suma
de
comprobaci√≥n


TCP
y
los
n√∫meros
de
secuencia
correctos
(
y
con
direcciones
IP
y
n√∫meros
de
puerto


tambi√©n
correctos
)
.
¬ø
Aceptar√°
el
SSL
en
el
lado
receptor
el
paquete
falso
y
pasar√°
la


correspondiente
carga
√∫til
a
la
aplicaci√≥n
receptora
?
¬ø
Por
qu√©
?


P22
.
Responda
a
las
siguientes
preguntas
de
tipo
verdadero
/
falso
que
hacen
referencia
a
la


Figura
8.29
.


a.
Cuando
un
host
de
172.16.1/24
env√≠a
un
datagrama
a
un
servidor
Amazon.com
,
el


router
R1
cifrar√°
el
datagrama
utilizando
IPsec
.


b.
Cuando
un
host
de
172.16.1/24
env√≠a
un
datagrama
a
un
host
de
172.16.2/24
,
el


router
R1
cambiar√°
la
direcci√≥n
de
origen
y
de
destino
del
datagrama
IP
.


c.
Suponga
que
un
host
de
172.16.1/24
inicia
una
conexi√≥n
TCP
con
un
servidor
web


situado
en
172.16.2/24
.
Como
parte
de
esta
conexi√≥n
,
todos
los
datagramas
envia-


dos
por
R1
tendr√°n
el
n√∫mero
de
protocolo
50
en
el
campo
de
cabecera
IPv4


situado
m√°s
a
la
izquierda
.


d.
Considere
el
env√≠o
de
un
segmento
TCP
desde
un
host
situado
en
172.16.1/24
a
un


host
que
se
encuentra
en
172.16.2/24
.
Suponga
que
el
reconocimiento
de
este
seg-


mento
se
pierde
,
de
modo
que
TCP
reenv√≠a
el
segmento
.
Puesto
que
IPsec
utiliza


n√∫meros
de
secuencia
,
R1
no
reenviar√°
el
segmento
TCP
.


PROBLEMAS
729


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
729P23
.
Considere
el
ejemplo
de
la
Figura
8.29
.
Suponga
que
Tom√°s
est√°
realizando
un
ataque


por
interposici√≥n
(
man-in-the-middle
)
y
puede
insertar
datagramas
en
el
flujo
de
data-


gramas
que
va
de
R1
a
R2
.
Como
parte
de
un
ataque
por
reproducci√≥n
,
Tom√°s
env√≠a


una
copia
duplicada
de
uno
de
los
datagramas
enviados
de
R1
a
R2
.
¬ø
Descifrar√°
R2
el


datagrama
duplicado
y
lo
reenviar√°
hacia
la
red
de
la
sucursal
?
En
caso
negativo
,
des-


criba
en
detalle
c√≥mo
detecta
R2
el
datagrama
duplicado
.


P24
.
Considere
el
siguiente
protocolo
pseudo-WEP
.
La
clave
es
de
4
bits
y
el
vector
IV


tiene
2
bits
.
El
vector
IV
se
a√±ade
al
final
de
la
clave
al
generar
el
flujo
de
claves
.


Suponga
que
la
clave
secreta
compartida
es
1010
.
Los
flujos
de
claves
para
las
cuatro


entradas
posibles
son
los
siguientes
:


101000
:
0010101101010101001011010100100
.
.
.


101001
:
1010011011001010110100100101101
.
.
.


101010
:
0001101000111100010100101001111
.
.
.


101011
:
1111101010000000101010100010111
.
.
.


Suponga
que
todos
los
mensajes
tienen
una
longitud
de
8
bits
.
Suponga
que
el
ICV


(
comprobaci√≥n
de
integridad
)
tiene
una
longitud
de
4
bits
y
que
se
calcula
combi-


nando
mediante
XOR
los
primeros
4
bits
de
datos
con
los
√∫ltimos
4
bits
de
datos
.


Suponga
que
el
paquete
pseudo-WEP
consta
de
tres
campos
:
el
primero
es
el
campo


IV
,
luego
el
campo
de
mensaje
y
el
√∫ltimo
es
el
campo
ICV
,
estando
algunos
de
estos


campos
cifrados
.


a.
Deseamos
enviar
el
mensaje
m
=
10100000
utilizando
el
vector
IV
=
11
y
WEP
.


¬ø
Cu√°les
ser√°n
los
valores
de
los
tres
campos
WEP
?


b.
Demuestre
que
cuando
el
receptor
descifra
el
paquete
WEP
,
recupera
el
mensaje
y


el
 
ICV
.


c.
Suponga
que
Tom√°s
intercepta
un
paquete
WEP
(
no
necesariamente
con
el
vector


IV
=
11
)
y
quiere
modificarlo
antes
de
reenviarlo
hacia
el
receptor
.
Suponga
que


Tom√°s
invierte
el
primer
bit
de
ICV
.
Suponiendo
que
Tom√°s
no
conoce
los
flujos


de
claves
para
ninguno
de
los
vectores
IV
,
¬ø
qu√©
otro
bit
o
qu√©
otros
bits
tiene
que


invertir
tambi√©n
Tom√°s
para
que
el
paquete
recibido
pase
la
comprobaci√≥n
de
ICV
?


d.
Justifique
su
respuesta
modificando
los
bits
del
paquete
WEP
del
apartado
(
a
)
,
des-


cifrando
el
paquete
resultante
y
verificando
que
el
paquete
pasa
la
comprobaci√≥n


de
integridad
.


P25
.
Proporcione
una
tabla
de
filtrado
y
una
tabla
de
conexi√≥n
para
un
cortafuegos
con


memoria
del
estado
que
sea
lo
m√°s
restrictivo
posible
,
pero
que
lleve
a
cabo
lo


siguiente
:


a.
Permitir
a
todos
los
usuarios
internos
establecer
sesiones
Telnet
con
hosts
externos
.


b.
Permitir
a
los
usuarios
externos
navegar
por
el
sitio
web
de
la
empresa
en
la
direc-


ci√≥n
 
222.22.0.12
.


c.
En
caso
contrario
,
bloquear
todos
los
restantes
tipos
de
tr√°fico
entrante
y
saliente
.


La
red
interna
es
222.22/16
.
En
su
soluci√≥n
,
suponga
que
la
tabla
de
conexiones
alma-


cena
actualmente
tres
conexiones
en
cach√©
,
todas
desde
el
interior
hacia
el
exterior
.


730
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
730En
su
soluci√≥n
tendr√°
que
inventar
los
n√∫meros
de
puerto
y
las
direcciones
IP
apro-


piados
.


P26
.
Suponga
que
Alicia
desea
visitar
el
sitio
web
activistas.com
utilizando
un
servicio
de


tipo
TOR
.
Este
servicio
utiliza
dos
servidores
proxy
no
confabulados
Proxy1
y
Proxy2
.


Alicia
obtiene
en
primer
lugar
los
certificados
(
cada
uno
de
ellos
contiene
una
clave


p√∫blica
)
para
Proxy1
y
Proxy2
de
alg√∫n
servidor
central
.
Designaremos
mediante


K1


+
(
)
,
K2


+
(
)
,
K1


‚Äì
(
)
y
K2


‚Äì
(
)
las
operaciones
de
cifrado
/
descifrado
con
las
claves
p√∫blica


y
privada
RSA
.


a.
Utilizando
un
diagrama
de
temporizaci√≥n
,
proporcione
un
protocolo
(
lo
m√°s
sim-


ple
posible
)
que
permita
a
Alicia
establecer
una
clave
de
sesi√≥n
compartida
S1
con


Proxy1
.
Designe
mediante
S1(m
)
el
cifrado
/
descifrado
de
los
datos
m
con
la
clave


compartida
S1
.


b.
Utilizando
un
diagrama
de
temporizaci√≥n
,
proporcione
un
protocolo
(
lo
m√°s
sim-


ple
posible
)
que
permita
a
Alicia
establecer
una
clave
de
sesi√≥n
compartida
S2
con


Proxy2
sin
revelar
su
direcci√≥n
IP
a
Proxy2
.


c.
Suponga
ahora
que
las
claves
compartidas
S1
y
S2
ya
est√°n
establecidas
.
Utili-


zando
un
diagrama
de
temporizaci√≥n
proporcione
un
protocolo
(
lo
m√°s
simple


posible
y
que
no
utilice
criptograf√≠a
de
clave
p√∫blica
)
que
permita
a
Alicia
solici-


tar
una
p√°gina
html
de
activistas.com
sin
revelar
su
direcci√≥n
IP
a
Proxy2
y
sin


revelar
a
Proxy1
qu√©
sitio
est√°
visitando
.
El
diagrama
debe
terminar
con
la
llegada


de
la
solicitud
HTTP
al
sitio
activistas.com
.


Preguntas
para
la
discusi√≥n


D1
.
Suponga
que
un
intruso
puede
insertar
y
eliminar
mensajes
DNS
en
un
servidor
DNS
.


Describa
tres
escenarios
que
muestren
los
problemas
que
dicho
intruso
podr√≠a
causar
.


D2
.
¬ø
Qu√©
es
Kerberos
?
¬ø
C√≥mo
funciona
?
¬ø
C√≥mo
se
relaciona
con
el
Problema
P10
de
este


cap√≠tulo
?


D3
.
Si
IPsec
proporciona
seguridad
en
la
capa
de
red
,
¬ø
por
qu√©
siguen
haciendo
falta


mecanismos
de
seguridad
en
las
capas
situadas
por
encima
de
IP
?


D4
.
Investigue
unos
cuantos
datos
acerca
de
las
botnets
.
¬ø
Qu√©
protocolos
y
sistemas
utili-


zan
los
atacantes
para
controlar
y
actualizar
hoy
en
d√≠a
las
botnets
?


Pr√°ctica
de
laboratorio
con
Wireshark


En
esta
pr√°ctica
de
laboratorio
(
disponible
en
el
sitio
web
del
libro
)
vamos
a
investigar
el


protocolo
Capa
de
sockets
seguros
(
SSL
,
Secure
Sockets
Layer
)
.
Recuerde
de
la
Secci√≥n
8.5


que
SSL
se
utiliza
para
dotar
de
seguridad
a
una
conexi√≥n
TCP
y
que
se
usa
ampliamente
en


la
pr√°ctica
para
proporcionar
seguridad
a
las
transacciones
por
Internet
.
En
esta
pr√°ctica


vamos
a
centrarnos
en
los
registros
SSL
enviados
a
trav√©s
de
la
conexi√≥n
TCP
.
Trataremos


de
perfilar
y
clasificar
cada
uno
de
los
registros
,
con
el
objetivo
de
entender
el
por
qu√©
y
el


PR√ÅCTICA
DE
LABORATORIO
CON
WIRESHARK
731


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
731c√≥mo
de
cada
uno
de
ellos
.
Investigaremos
los
diversos
tipos
de
registros
SSL
,
as√≠
como
los


campos
de
los
mensajes
SSL
.
Lo
haremos
analizando
una
traza
de
los
registros
SSL
inter-


cambiados
entre
nuestro
host
y
un
servidor
de
comercio
electr√≥nico
.


Pr√°ctica
de
laboratorio
con
IPsec


En
esta
pr√°ctica
de
laboratorio
(
disponible
en
el
sitio
web
del
libro
)
,
vamos
a
explorar
c√≥mo


crear
asociaciones
de
seguridad
IPsec
entre
m√°quinas
linux
.
Puede
realizar
la
primera
parte


de
la
pr√°ctica
con
dos
m√°quinas
linux
normales
,
cada
una
de
las
cuales
deber√°
disponer
de


un
adaptador
Ethernet
.
Pero
para
la
segunda
parte
de
la
pr√°ctica
necesitar√°
cuatro
m√°quinas


linux
,
teniendo
dos
de
ellas
dos
adaptadores
Ethernet
.
En
la
segunda
mitad
de
la
pr√°ctica
de


laboratorio
tendr√°
que
crear
asociaciones
de
seguridad
IPsec
utilizando
el
protocolo
ESP
en


modo
t√∫nel
.
Tendr√°
que
hacer
esto
definiendo
primero
manualmente
las
asociaciones
de


seguridad
y
luego
haciendo
que
IKE
las
cree
.


732
CAP√çTULO
8
‚Ä¢
SEGURIDAD
EN
LAS
REDES
DE
COMPUTADORAS


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
732733


¬ø
Qu√©
le
condujo
a
especializarse
en
el
√°rea
de
la
seguridad
de
redes
?


Puede
que
le
parezca
extra√±o
,
pero
la
respuesta
es
muy
simple
:
era
divertido
.
Mi
formaci√≥n
era
en
pro-


gramaci√≥n
y
administraci√≥n
de
sistemas
,
lo
que
conduce
de
una
forma
bastante
natural
al
campo
de
la


seguridad
.
Y
siempre
me
han
interesado
las
comunicaciones
,
desde
los
tiempos
en
que
realizaba
tra-


bajos
de
programaci√≥n
sobre
sistemas
en
tiempo
compartido
cuando
estudiaba
en
la
universidad
.


Mi
trabajo
en
el
campo
de
la
seguridad
sigue
estando
motivado
por
dos
cosas
:
el
deseo
de
conti-


nuar
haciendo
que
las
computadoras
sean
√∫tiles
,
lo
que
significa
que
su
funci√≥n
no
pueda
verse
corrom-


pida
por
ning√∫n
atacante
y
el
deseo
de
proteger
la
privacidad
.


¬ø
Cu√°l
era
su
visi√≥n
de
Usenet
mientras
la
desarrollaba
?
¬ø
Y
ahora
?


Originalmente
la
ve√≠amos
como
una
forma
de
hablar
acerca
de
la
inform√°tica
y
de
la
programaci√≥n
de


computadoras
con
otras
personas
dispersas
por
todo
el
pa√≠s
,
con
el
a√±adido
de
grupos
de
usuarios
loca-


les
para
cuestiones
administrativas
,
anuncios
de
compra-venta
,
etc.
De
hecho
,
mi
predicci√≥n
original


es
que
se
iban
a
generar
uno
o
dos
mensajes
por
d√≠a
procedentes
de
entre
50
y
100
sitios
como
m√°xi-


mo
.
Pero
el
crecimiento
real
experimentado
por
esa
red
fue
en
temas
relacionados
con
la
sociedad
,


incluyendo
(
pero
sin
limitarse
a
ello
)
la
interacci√≥n
de
los
seres
humanos
con
las
computadoras
.
Mis


grupos
de
noticias
favoritos
a
lo
largo
de
los
a√±os
han
sido
cosas
como
rec.woodworking
(
dedicado
a


la
carpinter√≠a
)
,
as√≠
como
sci.crypt
(
dedicado
a
la
criptograf√≠a
)
.


Hasta
cierto
punto
,
netnews
se
ha
visto
desplazado
por
la
Web
.
Si
tuviera
que
comenzar
a
redise-


√±arla
hoy
en
d√≠a
tendr√≠a
un
aspecto
muy
distinto
.
Pero
contin√∫a
siendo
una
herramienta
excelente
para


apelar
a
una
audiencia
muy
amplia
interesada
en
un
determinado
tema
,
sin
tener
que
depender
de
nin-


g√∫n
sitio
web
concreto
.


¬ø
Hay
alguien
que
le
haya
inspirado
profesionalmente
?
¬ø
En
qu√©
forma
?


El
profesor
Fred
Brooks
(
el
fundador
y
director
original
del
departamento
de
Ciencias
de
la


Computaci√≥n
de
la
Universidad
de
Carolina
del
Norte
en
Chapel
Hill
,
que
era
tambi√©n
el
jefe
del
equi-


po
que
desarroll√≥
el
IBM
S/360
y
el
OS/360
,
y
autor
de
The
Mythical
Man-Month
)
tuvo
una
enorme


Steven
M.
Bellovin


Steven
M.
Bellovin
se
uni√≥
al
claustro
de
profesores
de
la
Universidad


de
Columbia
despu√©s
de
estar
muchos
a√±os
en
el
Laboratorio
de


investigaci√≥n
de
servicios
de
red
de
AT&T
Labs
Research
en
Florham


Park
,
New
Jersey
,
Estados
Unidos
.
Su
inter√©s
principal
se
centra
en


las
redes
,
en
la
seguridad
y
en
por
qu√©
ambos
conceptos
son


incompatibles
.
En
1995
le
concedieron
el
galard√≥n
Usenix
Lifetime


Achievement
Award
por
su
trabajo
en
al
creaci√≥n
de
Usenet
,
la


primera
red
de
intercambio
de
grupos
de
noticias
que
permiti√≥


enlazar
varias
computadoras
y
que
los
usuarios
compartieran


informaci√≥n
y
participaran
en
discusiones
.
Steve
tambi√©n
es
miembro


electo
de
la
National
Academy
of
Engineering
.
Se
gradu√≥
en
la


Universidad
de
Columbia
y
es
doctor
por
la
Universidad
de
Carolina


del
Norte
en
Chapel
Hill
.


UNA
ENTREVISTA
CON
.
.
.


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
733influencia
en
mi
carrera
profesional
.
Por
encima
de
todo
,
me
ense√±√≥
a
mirar
las
cosas
con
una
pers-


pectiva
amplia
y
a
entender
los
compromisos
necesarios
:
c√≥mo
examinar
los
problemas
en
el
contex-


to
del
mundo
real
(
y
cu√°nto
m√°s
lioso
era
el
mundo
real
de
lo
que
a
un
te√≥rico
le
gustar√≠a
)
y
c√≥mo


equilibrar
una
serie
de
intereses
en
conflicto
a
la
hora
de
dise√±ar
una
soluci√≥n
.
La
mayor
parte
del
tra-


bajo
con
computadoras
es
de
ingenier√≠a
:
el
arte
de
llegar
a
los
compromisos
adecuados
con
el
fin
de


satisfacer
muchos
objetivos
contradictorios
.


¬ø
Cu√°l
es
su
visi√≥n
sobre
el
futuro
de
las
redes
y
la
seguridad
?


Hasta
ahora
,
buena
parte
de
la
seguridad
de
la
que
disfrutamos
procede
del
aislamiento
.
Por
ejemplo
,


un
cortafuegos
funciona
cortando
el
acceso
a
ciertas
m√°quinas
y
servicios
.
Pero
nos
encontramos
en


una
era
de
conectividad
creciente
,
con
lo
que
cada
vez
es
m√°s
complicado
poder
aislar
las
cosas
.
Y
lo


que
es
a√∫n
peor
es
que
nuestros
sistemas
de
producci√≥n
requieren
cada
vez
m√°s
elementos
separados


interconectados
mediante
redes
.
Dotar
de
seguridad
a
todo
esto
es
uno
de
nuestros
mayores
desaf√≠os
.


¬ø
Cu√°les
cree
que
han
sido
los
mayores
avances
en
el
campo
de
la
seguridad
?
¬ø
Cu√°nto
m√°s
all√°


debemos
ir
todav√≠a
?


Al
menos
cient√≠ficamente
sabemos
c√≥mo
hacer
criptograf√≠a
,
lo
que
ha
sido
de
una
gran
ayuda
.
Pero
la


mayor
parte
de
los
problemas
de
seguridad
se
deben
a
los
errores
en
el
c√≥digo
y
√©se
es
otro
problema


bastante
m√°s
complicado
.
De
hecho
,
es
el
problema
m√°s
antiguo
a√∫n
no
resuelto
en
las
ciencias
de
la


computaci√≥n
y
,
en
mi
opini√≥n
,
continuar√°
siendo
as√≠
.
El
desaf√≠o
estriba
en
concebir
c√≥mo
dotar
de


seguridad
a
los
sistemas
cuando
no
tenemos
otro
remedio
que
construirlos
a
partir
de
elementos
inse-


guros
.
Hoy
d√≠a
ya
podemos
hacer
eso
para
conseguir
fiabilidad
en
presencia
de
fallos
hardware
;
¬ø
podr√≠-


amos
hacer
lo
mismo
para
la
seguridad
?


¬ø
Qu√©
consejo
le
dar√≠a
a
los
estudiantes
relativo
a
la
seguridad
de
Internet
y
de
las
redes


en
general
?


El
aprender
los
mecanismos
es
la
parte
m√°s
f√°cil
.
Lo
que
es
m√°s
duro
es
aprender
a
pensar
‚Äú
en
forma


paranoica
‚Äù
.
Es
preciso
recordar
que
las
distribuciones
de
probabilidad
no
son
aplicables
en
este
campo
:


los
atacantes
pueden
encontrar
condiciones
improbables
y
de
hecho
lo
har√°n
.
Y
los
detalles
importan
;


de
hecho
importan
much√≠simo
.


734


M08_KURO9675_05_SE_CH08.qxd
 
21/3/10
 
21:40
 
P√°gina
734CAP√çTULO
9


Gesti√≥n
de


redes


735


Habiendo
completado
los
ocho
primeros
cap√≠tulos
de
este
texto
,
ya
somos
perfectamente


conscientes
de
que
una
red
est√°
compuesta
por
muchos
elementos
complejos
de
hardware
y


software
interactuando
entre
s√≠
,
desde
los
enlaces
,
dispositivos
de
conmutaci√≥n
,
routers
,


hosts
y
otros
dispositivos
que
constituyen
los
componentes
f√≠sicos
de
la
red
,
hasta
los


muchos
protocolos
(
tanto
en
hardware
como
en
software
)
que
controlan
y
coordinan
estos


dispositivos
.
Cuando
una
organizaci√≥n
interconecta
centenares
o
miles
de
tales
componen-


tes
para
formar
una
red
,
no
resulta
sorprendente
que
algunos
componentes
funcionen
en
oca-


siones
de
manera
inadecuada
,
que
se
produzcan
fallos
de
configuraci√≥n
de
elementos
de
la


red
,
que
los
recursos
de
la
red
est√©n
sobrexplotados
o
que
los
componentes
de
la
red
simple-


mente
se
rompan
(
por
ejemplo
,
alguien
puede
cortar
un
cable
o
derramar
una
lata
de
refresco


sobre
un
router
)
.
El
administrador
de
la
red
,
cuyo
trabajo
consiste
en
mantener
la
red
en
fun-


cionamiento
,
tiene
que
ser
capaz
de
responder
a
esos
sucesos
(
o
,
todav√≠a
mejor
,
de
evitar-


los
)
.
Habiendo
potencialmente
miles
de
componentes
distribuidos
por
una
extensa
√°rea
,
el


administrador
de
red
,
que
trabaja
desde
un
Centro
de
operaciones
de
red
(
NOC
,
Network


Operations
Center
)
necesita
obviamente
una
serie
de
herramientas
que
le
ayuden
a
monito-


rizar
,
gestionar
y
controlar
la
red
.
En
este
cap√≠tulo
vamos
a
examinar
la
arquitectura
,
los
pro-


tocolos
y
la
base
de
informaci√≥n
usados
por
los
administradores
de
red
para
llevar
a
cabo


esta
tarea
.


9.1
¬ø
Qu√©
es
la
gesti√≥n
de
redes
?


Antes
de
profundizar
en
el
tema
de
la
propia
gesti√≥n
de
redes
,
vamos
a
considerar
en
primer


lugar
unos
cuantos
escenarios
ilustrativos
del
‚Äú
mundo
real
‚Äù
,
que
no
tienen
que
ver
con
las


redes
,
pero
en
los
que
es
necesario
que
un
administrador
monitorice
,
gestione
y
controle
un


sistema
complejo
con
muchos
componentes
interactuando
entre
s√≠
.
Las
plantas
de
genera-


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
735ci√≥n
de
energ√≠a
el√©ctrica
disponen
de
una
sala
de
control
en
la
que
una
serie
de
diales
,
medi-


dores
e
indicadores
luminososos
monitorizan
el
estado
(
temperatura
,
presi√≥n
,
flujo
)
de


diversas
v√°lvulas
,
conductos
y
recipientes
remotos
,
as√≠
como
de
otros
componentes
de
la


planta
.
Estos
dispositivos
permiten
al
operador
monitorizar
la
multitud
de
componentes
que


forman
la
planta
y
pueden
alertarle
(
con
la
famosa
luz
roja
parpadeante
de
advertencia
)


cuando
est√©
a
punto
de
surgir
un
problema
.
El
operador
de
la
planta
llevar√°
a
cabo
una
serie


de
acciones
para
controlar
a
estos
componentes
.
De
forma
similar
,
la
cabina
de
una
aeronave


est√°
llena
de
instrumentos
que
permiten
a
un
piloto
monitorizar
y
controlar
los
m√∫ltiples


componentes
que
forman
un
avi√≥n
.
En
estos
dos
ejemplos
,
el
‚Äú
administrador
‚Äù
monitoriza


una
serie
de
dispositivos
remotos
y
analiza
sus
datos
con
el
fin
de
cerciorarse
de
que
esos


dispositivos
est√©n
operativos
y
de
que
su
operaci√≥n
se
mantenga
dentro
de
una
serie
de
l√≠mi-


tes
prescritos
(
por
ejemplo
,
asegur√°ndose
de
que
el
n√∫cleo
de
una
planta
de
energ√≠a
nuclear


no
se
va
a
fundir
de
manera
inminente
,
o
de
que
el
avi√≥n
no
est√°
a
punto
de
quedarse
sin


combustible
)
.
Asimismo
,
controla
reactivamente
el
sistema
haciendo
ajustes
en
respuesta
a


los
cambios
que
el
sistema
o
su
entorno
sufren
y
tambi√©n
administra
proactivamente
el
sis-


tema
(
por
ejemplo
,
detectando
tendencias
o
comportamientos
an√≥malos
,
lo
que
permite


tomar
una
serie
de
medidas
antes
de
que
surjan
problemas
serios
)
.
En
un
sentido
similar
,
el


administrador
de
una
red
monitorizar√°
,
gestionar√°
y
controlar√°
activamente
el
sistema
que


est√©
a
su
cargo
.


En
los
primeros
d√≠as
de
las
redes
,
cuando
las
redes
de
computadoras
eran
creaciones


producto
de
la
investigaci√≥n
en
lugar
de
una
infraestructura
cr√≠tica
utilizada
por
centenares


de
millones
de
personas
cada
d√≠a
,
el
propio
concepto
de
‚Äú
gesti√≥n
de
red
‚Äù
no
exist√≠a
.
Si
uno


se
encontraba
con
un
problema
de
red
,
pod√≠a
ejecutar
unos
cuantos
comandos
ping
para


localizar
el
origen
del
problema
y
luego
modificar
las
configuraciones
del
sistema
,
reiniciar


el
hardware
o
el
software
o
llamar
a
un
colega
remoto
para
que
llevara
a
cabo
esas
tareas
(
en


[
RFC
789
]
hay
disponible
una
explicaci√≥n
muy
amena
acerca
de
la
primera
ca√≠da
a
gran


escala
de
ARPAnet
el
27
de
octubre
de
1980
,
mucho
antes
de
que
hubiera
disponibles
herra-


mientas
de
gesti√≥n
de
red
y
as√≠
como
de
los
esfuerzos
que
se
hicieron
para
recuperarse
de
la


ca√≠da
y
entender
sus
motivos
)
.
A
medida
que
la
red
Internet
p√∫blica
y
las
intranets
privadas


han
ido
creciendo
,
convirti√©ndose
de
peque√±as
redes
en
una
gran
infraestructura
global
,
ha


ido
creciendo
tambi√©n
la
importancia
y
la
necesidad
de
gestionar
el
enorme
n√∫mero
de
com-


ponentes
hardware
y
software
que
forman
estas
redes
.


Como
motivaci√≥n
para
nuestro
estudio
de
la
gesti√≥n
de
redes
,
vamos
a
comenzar
con


un
ejemplo
simple
.
En
la
Figura
9.1
se
ilustra
una
peque√±a
red
compuesta
por
tres
routers
y


una
serie
de
hosts
y
servidores
.
Incluso
en
una
red
tan
simple
como
√©sta
existen
muchos


escenarios
en
los
que
un
administrador
de
red
podr√≠a
aprovechar
enormemente
la
disponibi-


lidad
de
herramientas
de
gesti√≥n
de
red
:


‚Ä¢
Detecci√≥n
de
fallos
de
una
tarjeta
de
interfaz
en
un
host
o
un
router
.
Con
las
herramien-


tas
de
gesti√≥n
de
red
apropiadas
,
una
entidad
de
red
(
por
ejemplo
,
el
router
A
)
podr√≠a


informar
al
administrador
de
red
que
una
de
sus
interfaces
ha
fallado
.
(
¬°
Esto
es
obvia-


mente
preferible
a
recibir
en
el
NOC
una
llamada
de
un
usuario
airado
diciendo
que
la


conexi√≥n
de
red
no
funciona
!
)
Un
administrador
de
red
que
se
dedique
activamente
a


monitorizar
y
analizar
el
tr√°fico
de
red
puede
ser
capaz
de
impresionar
realmente
al
usua-


rio
potencialmente
airado
,
detectando
problemas
en
la
interfaz
antes
de
que
se
produzcan


y
sustituyendo
la
tarjeta
de
interfaz
sin
esperar
a
que
falle
.
Esto
puede
hacerse
,
por
ejem-


plo
,
si
el
administrador
de
red
observa
un
incremento
en
los
errores
de
suma
de
compro-


baci√≥n
de
las
tramas
enviadas
por
esa
interfaz
que
est√°
a
punto
de
morir
.


736
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
736‚Ä¢
Monitorizaci√≥n
de
los
hosts
.
El
administrador
de
red
puede
realizar
comprobaciones


peri√≥dicas
para
ver
si
todos
los
hosts
de
la
red
est√°n
encendidos
y
operativos
.
De
nuevo
,


el
administrador
de
la
red
puede
ser
capaz
de
impresionar
a
los
usuarios
respondiendo


proactivamente
a
un
problema
(
la
ca√≠da
de
un
host
)
antes
de
que
el
propio
usuario


informe
del
mismo
.


‚Ä¢
Monitorizaci√≥n
del
tr√°fico
como
ayuda
a
la
implantaci√≥n
de
recursos
.
Un
administrador


de
red
puede
monitorizar
los
patrones
de
tr√°fico
entre
cada
origen
y
cada
destino
y
obser-


var
,
por
ejemplo
,
que
si
intercambian
los
servidores
entre
segmentos
de
una
red
LAN
la


cantidad
de
tr√°fico
que
atraviesa
m√∫ltiples
redes
LAN
podr√≠a
reducirse
significativa-


mente
.
Imagine
lo
feliz
que
se
sentir√≠a
todo
el
mundo
cuando
se
consiguiera
as√≠
un
mejor


rendimiento
de
la
red
sin
necesidad
de
invertir
en
nuevos
equipos
.
De
forma
similar
,
al


monitorizar
la
utilizaci√≥n
de
los
enlaces
el
administrador
de
la
red
puede
determinar
que


un
segmento
LAN
o
que
el
enlace
externo
con
el
resto
de
mundo
est√°
sobrecargado
y
que


ser√≠a
necesario
,
en
consecuencia
,
proporcionar
un
enlace
de
mayor
ancho
de
banda
(
por


supuesto
,
con
un
mayor
coste
)
.
El
administrador
de
la
red
tambi√©n
podr√≠a
querer
recibir


notificaciones
autom√°ticamente
cuando
los
niveles
de
congesti√≥n
 
en
un
enlace
excedan


en
un
valor
umbral
dado
,
con
el
fin
de
poder
instalar
un
enlace
de
mayor
ancho
de
banda


antes
de
que
la
congesti√≥n
sea
demasiado
grave
.


‚Ä¢
Detecci√≥n
de
cambios
r√°pidos
en
las
tablas
de
enrutamiento
.
Las
alteraciones
r√°pidas
de


ruta
(
cambios
frecuentes
en
las
tablas
de
enrutamiento
)
pueden
indicar
inestabilidades
en


el
enrutamiento
o
la
existencia
de
un
router
mal
configurado
.
Ciertamente
,
el
administra-


9.1
‚Ä¢
¬ø
QU√â
ES
LA
GESTI√ìN
DE
REDES
?
737


Host


H1


A


B


C


Host
Enlace


a
la
red


externa


Servidor


Figura
9.1
‚Ä¢
Un
escenario
simple
que
ilustra
los
usos
de
la
gesti√≥n
de
red
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
737dor
de
red
que
haya
configurado
inadecuadamente
un
router
preferir√°
descubrir
el
error


por
s√≠
mismo
antes
de
que
la
red
se
caiga
.


‚Ä¢
Monitorizaci√≥n
de
los
SLA
.
Los
Acuerdos
de
nivel
del
servicio
(
SLA
,
Service
Level


Agreements
)
son
contratos
que
definen
m√©tricas
espec√≠ficas
de
rendimiento
y
niveles


aceptables
de
rendimiento
del
proveedor
de
la
red
con
respecto
a
estas
m√©tricas
[
Huston


1999a
]
.
Verizon
y
Sprint
son
s√≥lo
dos
de
los
muchos
proveedores
de
red
que
proporcio-


nan
acuerdos
SLA
garantizados
a
sus
clientes
[
Verizon
2009
;
Sprint
2009
]
.
Estos
SLA


incluyen
la
disponibilidad
del
servicio
(
interrupciones
)
,
la
latencia
,
la
tasa
de
transferen-


cia
y
los
requisitos
de
notificaci√≥n
de
las
interrupciones
.
Evidentemente
,
si
los
criterios


de
rendimiento
han
de
formar
parte
de
un
acuerdo
de
servicio
entre
un
proveedor
de
red


y
sus
usuarios
,
entonces
tendr√°
una
gran
importancia
para
el
administrador
de
red
ser


capaz
de
medir
y
gestionar
las
prestaciones
.


‚Ä¢
Detecci√≥n
de
intrusiones
.
Un
administrador
de
red
puede
desear
que
se
le
notifique
que


ha
llegado
un
cierto
tr√°fico
de
red
procedente
de
un
origen
sospechoso
(
por
ejemplo
,
de


un
cierto
host
o
un
cierto
n√∫mero
de
puerto
)
o
con
destino
a
√©l
.
De
forma
similar
,
el
admi-


nistrador
de
la
red
tambi√©n
podr√≠a
querer
detectar
(
y
en
muchos
casos
filtrar
)
la
existen-


cia
de
ciertos
tipos
de
tr√°fico
(
por
ejemplo
,
paquetes
con
enrutamiento
de
origen
o
un


gran
n√∫mero
de
paquetes
SYN
dirigidos
a
un
cierto
host
)
que
se
sabe
que
son
caracter√≠s-


ticos
de
los
tipos
de
ataques
que
hemos
considerado
en
el
Cap√≠tulo
8
.
 

La
Organizaci√≥n
Internacional
de
Estandarizaci√≥n
(
ISO
)
ha
creado
un
modelo
de
ges-


ti√≥n
de
red
que
resulta
√∫til
para
situar
los
escenarios
de
ejemplo
anteriores
dentro
de
un


marco
de
trabajo
m√°s
estructurado
.
Se
definen
cinco
√°reas
de
gesti√≥n
de
la
red
:


‚Ä¢
Gesti√≥n
de
rendimiento
.
El
objetivo
de
la
gesti√≥n
del
rendimiento
es
cuantificar
,
medir
,


registrar
,
analizar
y
controlar
el
rendimiento
(
por
ejemplo
,
la
utilizaci√≥n
y
la
tasa
de


transferencia
)
de
distintos
componentes
de
la
red
.
Entre
estos
componentes
se
incluyen


dispositivos
individuales
(
como
por
ejemplo
,
enlaces
,
routers
y
hosts
)
,
as√≠
como
abstrac-


ciones
terminal
a
terminal
,
tales
como
una
ruta
a
trav√©s
de
la
red
.
Como
veremos
ense-


guida
,
hay
ciertos
protocolos
est√°ndar
,
como
el
Protocolo
simple
de
gesti√≥n
de
red


(
SNMP
,
Simple
Network
Management
Protocol
)
[
RFC
3410
]
,
que
desempe√±an
un
papel


fundamental
en
la
gesti√≥n
del
rendimiento
de
Internet
.


‚Ä¢
Gesti√≥n
de
fallos
.
El
objetivo
de
la
gesti√≥n
de
fallos
es
registrar
,
detectar
y
contrarrestar


las
condiciones
de
fallo
de
la
red
.
La
l√≠nea
entre
la
gesti√≥n
de
fallos
y
la
gesti√≥n
del
ren-


dimiento
es
bastante
difusa
.
Podemos
pensar
en
la
gesti√≥n
de
fallos
como
en
la
gesti√≥n


inmediata
de
fallos
transitorios
de
la
red
(
por
ejemplo
,
fallos
hardware
o
software
de
un


router
,
un
host
o
de
un
enlace
)
,
mientras
que
la
gesti√≥n
del
rendimiento
tiene
el
objetivo


a
m√°s
largo
plazo
de
proporcionar
niveles
aceptables
de
rendimiento
en
presencia
de


demandas
variables
de
tr√°fico
y
fallos
ocasionales
de
los
dispositivos
de
la
red
.
Al


igual
que
con
la
gesti√≥n
del
rendimiento
,
el
protocolo
SNMP
desempe√±a
un
papel
fun-


damental
en
la
gesti√≥n
de
fallos
.


‚Ä¢
Gesti√≥n
de
configuraci√≥n
.
La
gesti√≥n
de
la
configuraci√≥n
permite
a
un
administrador
de


la
red
controlar
qu√©
dispositivos
se
encuentran
dentro
de
la
red
administrada
y
las
confi-


guraciones
hardware
y
software
de
dichos
dispositivos
.
En
[
RFC
3139
]
se
ofrece
una


panor√°mica
de
la
gesti√≥n
de
la
configuraci√≥n
y
de
los
requisitos
para
las
redes
basadas


en
IP
.


738
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
738‚Ä¢
Gesti√≥n
de
cuentas
.
La
gesti√≥n
de
cuentas
permite
a
los
gestores
de
la
red
especificar
,


registrar
y
controlar
el
acceso
de
los
usuarios
y
de
los
dispositivos
a
los
recursos
de
la


red
.
Las
cuotas
de
uso
,
la
facturaci√≥n
basada
en
el
uso
y
la
asignaci√≥n
de
privilegios
de


acceso
a
los
recursos
caen
dentro
del
campo
de
la
gesti√≥n
de
cuentas
.
 

‚Ä¢
Gesti√≥n
de
la
seguridad
.
El
objetivo
de
la
gesti√≥n
de
la
seguridad
es
controlar
el
acceso
a


los
recursos
de
red
de
acuerdo
con
alguna
pol√≠tica
bien
definida
.
Los
centros
de
distribu-


ci√≥n
de
claves
que
hemos
estudiado
en
la
Secci√≥n
8.3
son
componentes
de
la
gesti√≥n
de


la
seguridad
.
Otro
componente
crucial
es
el
uso
de
cortafuegos
para
monitorizar
y
con-


trolar
los
puntos
de
acceso
externos
a
la
red
de
la
organizaci√≥n
,
tema
que
hemos
estu-


diado
en
la
Secci√≥n
8.9
.


En
este
cap√≠tulo
s√≥lo
vamos
a
cubrir
los
rudimentos
de
la
gesti√≥n
de
red
.
Nuestro
enfo-


que
ser√°
conscientemente
limitado
;
examinaremos
√∫nicamente
la
infraestructura
necesaria


para
la
gesti√≥n
de
red
:
la
arquitectura
global
,
los
protocolos
de
gesti√≥n
de
red
y
la
base
de


informaci√≥n
que
permite
a
un
administrador
mantener
la
red
en
funcionamiento
.
No
vamos


a
cubrir
los
procesos
de
toma
de
decisiones
del
administrador
de
red
,
quien
debe
planificar
,


analizar
y
responder
a
la
informaci√≥n
de
gesti√≥n
enviada
hacia
el
NOC
.
En
este
√°rea
habr√≠a


que
tener
en
cuenta
temas
tales
como
la
identificaci√≥n
y
gesti√≥n
de
fallos
[
Katzela
1995
;


Medhi
1997
;
Steinder
2002
]
,
la
detecci√≥n
proactiva
de
anomal√≠as
[
Thottan
1998
]
,
la
correla-


ci√≥n
de
alarmas
[
Jakobson
1993
]
y
otros
.
Tampoco
vamos
a
cubrir
el
tema
m√°s
amplio
de
la


gesti√≥n
de
servicios
[
Saydam
1996
;
RFC
3052
;
AT&T
SLM
2006
]
:
la
provisi√≥n
de
recursos


tales
como
el
ancho
de
banda
,
la
capacidad
de
los
servidores
y
los
dem√°s
recursos
de
com-


putaci√≥n
/
comunicaci√≥n
necesarios
para
satisfacer
los
requisitos
de
servicio
espec√≠ficos
de
la


misi√≥n
de
una
empresa
.
En
esta
√∫ltima
√°rea
existen
est√°ndares
tales
como
TMN
[
Glitho


1995
;
Sidor
1998
]
y
TINA
[
Hamada
1997
]
que
son
m√°s
completos
(
y
posiblemente
m√°s


complejos
)
de
cara
a
tratar
estos
problemas
m√°s
generales
.


Una
cuesti√≥n
que
a
menudo
se
plantea
es
‚Äú
¬ø
Qu√©
es
la
gesti√≥n
de
red
?
‚Äù
.
Las
explicacio-


nes
que
hasta
ahora
hemos
proporcionado
demostraban
la
necesidad
de
la
gesti√≥n
de
red
e


ilustraban
unos
cuantos
usos
de
la
misma
.
Vamos
a
concluir
esta
secci√≥n
con
una
definici√≥n


de
una
√∫nica
frase
(
aunque
un
poco
larga
)
del
concepto
de
gesti√≥n
de
red
,
definici√≥n
que


hemos
extra√≠do
de
[
Saydam
1996
]
:


‚Äú
La
gesti√≥n
de
red
incluye
la
implantaci√≥n
,
integraci√≥n
y
coordinaci√≥n
del
hardware
,


el
software
y
los
elementos
humanos
para
monitorizar
,
probar
,
sondear
,
configurar
,


analizar
,
evaluar
y
controlar
los
recursos
de
red
y
los
elementos
necesarios
para


satisfacer
los
requisitos
de
respuesta
en
tiempo
real
,
de
rendimiento
operacional
y


de
calidad
de
servicio
a
un
coste
razonable
.
‚Äù


Parece
casi
un
trabalenguas
pero
es
una
definici√≥n
pr√°ctica
bastante
buena
.
En
las
siguientes


secciones
a√±adiremos
un
poco
de
sustancia
a
esta
definici√≥n
m√°s
bien
esquem√°tica
de
la
ges-


ti√≥n
de
red
.


9.2
Infraestructura
para
la
gesti√≥n
de
red


Hemos
visto
en
la
secci√≥n
anterior
que
la
gesti√≥n
de
red
requiere
la
capacidad
de
‚Äú
monitori-


zar
,
probar
,
sondear
,
configurar
,
...
y
controlar
‚Äù
los
componentes
hardware
y
software
de
una


9.2
‚Ä¢
INFRAESTRUCTURA
PARA
LA
GESTI√ìN
DE
RED
739


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
739red
.
Puesto
que
los
dispositivos
de
red
est√°n
distribuidos
,
esto
requerir√°
como
m√≠nimo
que


el
administrador
de
red
sea
capaz
de
recopilar
datos
(
por
ejemplo
,
para
prop√≥sitos
de
moni-


torizaci√≥n
)
desde
una
entidad
remota
y
realizar
cambios
en
dicha
entidad
remota
(
por
ejem-


plo
,
para
controlarla
)
.
Una
analog√≠a
humana
nos
resultar√°
bastante
√∫til
aqu√≠
para
entender
la


infraestructura
necesaria
para
la
gesti√≥n
de
red
.


Imagine
que
es
usted
el
director
de
una
gran
organizaci√≥n
que
dispone
de
sucursales


distribuidas
por
todo
el
mundo
.
Su
trabajo
consiste
en
asegurarse
de
que
los
distintos
com-


ponentes
de
su
organizaci√≥n
operen
sin
ning√∫n
tipo
de
problema
.
¬ø
C√≥mo
lo
har√≠a
?
Como


m√≠nimo
,
recopilar√°
peri√≥dicamente
datos
de
sus
sucursales
mediante
informes
y
diversas


medidas
cuantitativas
de
actividad
,
productividad
y
presupuesto
.
Ocasionalmente
,
pero
no


siempre
,
recibir√°
notificaciones
expl√≠citas
cuando
se
produzca
un
problema
en
una
de
las


sucursales
;
el
director
de
sucursal
que
desee
ascender
en
la
escala
corporativa
(
quiz√°
para


quitarle
a
usted
el
trabajo
)
puede
enviarle
informes
no
solicitados
que
indiquen
lo
bien
que


est√°n
marchando
las
cosas
en
su
sucursal
.
Usted
analizar√°
los
informes
que
reciba
confiando


en
ver
que
las
operaciones
se
desarrollan
sin
ning√∫n
problema
en
todas
partes
,
pero
encon-


tr√°ndose
 
de
vez
en
cuando
,
sin
ninguna
duda
,
con
diversos
problemas
que
requieran
su
aten-


ci√≥n
.
Puede
entonces
iniciar
un
di√°logo
personal
con
una
de
sus
sucursales
problem√°ticas
,


recopilando
m√°s
datos
con
el
fin
de
comprender
el
problema
y
luego
emitiendo
una
orden


ejecutiva
(
‚Äú
¬°
Haz
este
cambio
!
‚Äù
)
al
director
de
la
sucursal
.


Dentro
de
este
escenario
humano
bastante
com√∫n
hay
impl√≠cita
una
infraestructura
de


control
de
la
organizaci√≥n
:
el
director
(
usted
)
,
los
lugares
remotos
que
se
est√°n
controlando


(
las
sucursales
)
,
los
agentes
remotos
(
los
directores
de
sucursal
)
,
los
protocolos
de
comuni-


caci√≥n
(
para
transmitir
los
informes
y
datos
est√°ndar
y
para
los
di√°logos
personales
)
y
los


datos
(
el
contenido
de
los
informes
y
las
medidas
cuantitativas
de
la
actividad
,
la
productivi-


dad
y
los
presupuestos
)
.
Cada
uno
de
los
componentes
de
este
escenario
organizativo


humano
tiene
su
correspondiente
componente
en
el
campo
de
la
gesti√≥n
de
red
.


La
arquitectura
de
un
sistema
de
gesti√≥n
de
red
es
conceptualmente
id√©ntica
al
de
esta


sencilla
analog√≠a
organizativa
humana
.
El
campo
de
la
gesti√≥n
de
red
tiene
su
propia
termi-


nolog√≠a
espec√≠fica
para
los
diversos
componentes
de
una
arquitectura
de
gesti√≥n
de
red
,
por


lo
que
aqu√≠
vamos
a
adoptar
dicha
terminolog√≠a
.
Como
se
muestra
en
la
Figura
9.2
,
hay
tres


componentes
principales
en
una
arquitectura
de
gesti√≥n
de
red
:
una
entidad
gestora
(
el
direc-


tor
en
nuestra
analog√≠a
anterior
,
es
decir
,
usted
)
,
los
dispositivos
gestionados
(
las
sucursales
)


y
un
protocolo
de
gesti√≥n
de
red
.


La
entidad
gestora
es
una
aplicaci√≥n
,
normalmente
con
intervenci√≥n
humana
,
que
se


ejecuta
en
una
estaci√≥n
central
de
gesti√≥n
de
red
situada
en
el
Centro
de
operaciones
de
red


(
NOC
)
.
La
entidad
gestora
es
el
punto
focal
de
la
actividad
de
administraci√≥n
de
la
red
;
con-


trola
la
recopilaci√≥n
,
procesamiento
,
an√°lisis
y
/
o
visualizaci√≥n
de
la
informaci√≥n
de
gesti√≥n


de
la
red
.
Es
aqu√≠
donde
se
inician
las
acciones
para
el
control
del
comportamiento
de
la
red


y
donde
el
administrador
interact√∫a
con
los
dispositivos
que
forman
la
red
.


Un
dispositivo
gestionado
es
un
equipo
de
red
(
incluyendo
su
software
)
que
forma


parte
de
una
red
gestionada
.
Ser√≠a
la
sucursal
dentro
de
nuestra
analog√≠a
humana
.
Un
dis-


positivo
gestionado
puede
ser
un
host
,
un
router
,
un
puente
,
un
concentrador
,
una
impre-


sora
o
un
m√≥dem
.
Dentro
de
un
dispositivo
gestionado
pueden
existir
diversos
objetos


gestionados
.
Estos
objetos
gestionados
son
los
propios
elementos
hardware
contenidos
en


el
dispositivo
gestionado
(
por
ejemplo
,
una
tarjeta
de
interfaz
de
red
)
y
los
conjuntos
de


par√°metros
de
configuraci√≥n
para
los
distintos
elementos
hardware
y
software
(
por
ejem-


plo
,
un
protocolo
de
enrutamiento
intradominio
como
RIP
)
.
En
la
analog√≠a
humana
,
los


740
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
740objetos
gestionados
podr√≠an
ser
los
departamentos
de
cada
sucursal
.
Estos
objetos
gestio-


nados
tienen
asociados
distintos
elementos
de
informaci√≥n
que
se
recopilan
en
una
Base
de


informaci√≥n
de
gesti√≥n
(
MIB
,
Management
Information
Base
)
;
como
veremos
,
los
valo-


res
de
estos
elementos
de
informaci√≥n
est√°n
a
disposici√≥n
de
la
entidad
gestora
(
que
en


muchos
casos
tambi√©n
puede
modificarlos
)
.
En
nuestra
analog√≠a
humana
,
la
MIB
se
corres-


ponde
con
los
datos
cuantitativos
(
medidas
de
actividad
,
productividad
y
presupuestos
,


siendo
estas
√∫ltimas
configurables
por
la
entidad
gestora
)
intercambiados
entre
la
sucursal


y
la
oficina
principal
.
Estudiaremos
en
detalle
las
bases
MIB
en
la
Secci√≥n
9.3
.
Finalmente
,


en
cada
dispositivo
gestionado
reside
tambi√©n
un
 
agente
de
gesti√≥n
de
red
,
un
proceso


que
se
ejecuta
en
el
dispositivo
gestionado
y
que
se
comunica
con
la
entidad
gestora
,
lle-


vando
a
cabo
acciones
locales
en
el
dispositivo
gestionado
bajo
control
de
la
entidad
ges-


tora
.
En
nuestra
analog√≠a
humana
,
un
agente
de
gesti√≥n
de
red
ser√≠a
un
director
de
sucursal
.


El
tercer
elemento
de
una
arquitectura
de
gesti√≥n
de
red
es
el
protocolo
de
gesti√≥n
de


red
.
El
protocolo
se
ejecuta
entre
la
entidad
gestora
y
los
dispositivos
gestionados
,
permi-


tiendo
a
aquella
consultar
el
estado
de
los
dispositivos
gestionados
y
llevar
a
cabo
acciones


de
manera
indirecta
en
estos
dispositivos
a
trav√©s
de
sus
agentes
.
Los
agentes
pueden
utili-


zar
el
protocolo
de
gesti√≥n
de
red
para
informar
a
la
entidad
gestora
de
la
ocurrencia
de
suce-


sos
excepcionales
(
por
ejemplo
,
fallos
de
componentes
o
violaci√≥n
de
los
umbrales
de


rendimiento
)
.
Es
importante
recalcar
que
el
protocolo
de
gesti√≥n
de
red
no
se
encarga
√©l


mismo
de
administrar
la
red
;
simplemente
proporciona
una
serie
de
capacidades
que
un


9.2
‚Ä¢
INFRAESTRUCTURA
PARA
LA
GESTI√ìN
DE
RED
741


Figura
9.2
‚Ä¢
Principales
componentes
de
una
arquitectura
de
gesti√≥n
de
red
.
 

Entidad


gestora


Protocolo
de


gesti√≥n
de
red


Datos


Agente


Dispositivo


gestionado


Dispositivo


gestionado


Dispositivo


gestionado


Dispositivo


gestionado


Datos


Agente
Datos


Agente
Datos


Agente
Datos


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
741administrador
puede
utilizar
para
gestionar
(
‚Äú
monitorizar
,
probar
,
sondear
,
configurar
,
anali-


zar
,
evaluar
y
controlar
‚Äù
)
la
red
.
Se
trata
de
una
distinci√≥n
sutil
,
pero
de
gran
importancia
.


Aunque
la
infraestructura
para
la
gesti√≥n
de
red
es
conceptualmente
simple
,
el
vocabu-


lario
t√≠pico
de
la
gesti√≥n
de
redes
(
‚Äú
entidad
gestora
‚Äù
,
‚Äú
dispositivo
gestionado
‚Äù
,
‚Äú
agente
de


gesti√≥n
‚Äù
y
‚Äú
Base
de
informaci√≥n
de
administraci√≥n
‚Äù
)
puede
a
veces
resultar
confuso
.
Por


ejemplo
,
en
terminolog√≠a
de
gesti√≥n
de
red
y
en
nuestro
sencillo
escenario
de
monitoriza-


ci√≥n
de
hosts
,
los
‚Äú
agentes
de
gesti√≥n
‚Äù
ubicados
en
los
‚Äú
dispositivos
gestionados
‚Äù
son
con-


sultados
peri√≥dicamente
por
la
‚Äú
entidad
gestora
‚Äù
(
una
idea
simple
,
pero
ling√º√≠sticamente


liosa
)
.
Pero
tener
presente
la
analog√≠a
organizativa
humana
y
sus
obvios
paralelismos
con
la


gesti√≥n
de
red
resultar√°
de
gran
ayuda
para
seguir
este
cap√≠tulo
.


Nuestra
exposici√≥n
acerca
de
la
arquitectura
de
gesti√≥n
de
red
anterior
ha
sido
de
car√°c-


ter
gen√©rico
y
de
amplia
aplicaci√≥n
a
una
serie
de
est√°ndares
de
gesti√≥n
de
red
que
han
ido


siendo
propuestos
a
lo
largo
de
los
a√±os
.
Los
est√°ndares
de
gesti√≥n
de
red
comenzaron
a


madurar
a
finales
de
la
d√©cada
de
1980
,
con
el
Elemento
com√∫n
de
servicios
de
informa-


ci√≥n
de
gesti√≥n
/
Protocolo
com√∫n
de
informaci√≥n
de
gesti√≥n
(
CMISE
/
CMIP
,
Common


Management
Information
Services
Element
/
Common
Management
Information
Proto-


col
)
de
OSI
[
Piscatello
1993
;
Stallings
1993
;
Glitho
1998
]
y
el
Protocolo
simple
de
gesti√≥n


de
red
(
SNMP
,
Simple
Network
Management
Protocol
)
de
Internet
[
RFC
3410
;
Stallings


1999
;
Rose
1996
]
emergiendo
como
los
dos
est√°ndares
m√°s
importantes
[
Miller
1997
;


Subramanian
2000
]
.
Ambos
se
dise√±aron
para
ser
independientes
de
redes
y
productos
espe-


c√≠ficos
de
otros
fabricantes
.
Puesto
que
SNMP
fue
r√°pidamente
dise√±ado
e
implantado


cuando
se
hizo
evidente
la
necesidad
de
emplear
mecanismos
de
gesti√≥n
de
red
,
SNMP


encontr√≥
un
amplio
uso
y
aceptaci√≥n
.
Actualmente
,
SNMP
es
el
entorno
de
gesti√≥n
de
red


m√°s
ampliamente
utilizado
e
implantado
.
En
la
siguiente
secci√≥n
estudiaremos
en
detalle
el


protocolo
SNMP
.


9.3
El
entorno
de
gesti√≥n
est√°ndar
de
Internet


Al
contrario
de
lo
que
podr√≠a
sugerir
el
nombre
SNMP
(
Simple
Network
Management
Pro-


tocol
)
,
la
gesti√≥n
de
red
en
Internet
es
mucho
m√°s
que
un
protocolo
que
permite
mover
datos


de
gesti√≥n
entre
una
entidad
gestora
y
sus
agentes
y
se
ha
desarrollado
para
ser
mucho
m√°s


complejo
de
lo
que
el
t√©rmino
‚Äú
simple
‚Äù
puede
sugerir
.
El
entorno
actual
de
gesti√≥n
de
Inter-


net
est√°ndar
tiene
sus
ra√≠ces
en
el
Protocolo
simple
de
monitorizaci√≥n
de
pasarela
(
SGMP
,


Simple
Gateway
Monitoring
Protocol
)
[
RFC
1028
]
.
SGMP
fue
dise√±ado
por
un
grupo
de


investigadores
universitarios
de
redes
,
usuarios
y
gestores
,
cuya
experiencia
con
SGMP
les


permiti√≥
dise√±ar
,
implementar
e
implantar
SNMP
en
s√≥lo
unos
pocos
meses
[
Lynch
1993
]
,


algo
muy
distinto
al
proceso
de
estandarizaci√≥n
de
hoy
d√≠a
.
Desde
entonces
,
SNMP
ha
evo-


lucionado
desde
SNMPv1
pasando
por
SNMPv2
hasta
la
versi√≥n
m√°s
reciente
,
SNMPv3


[
RFC
3410
]
,
lanzada
en
abril
de
1999
y
actualizada
en
diciembre
de
2002
.


Inevitablemente
,
cuando
se
describe
un
entorno
para
la
gesti√≥n
de
redes
deben
abor-


darse
determinadas
cuestiones
:


‚Ä¢
¬ø
Q
u
√©
 
s
e
 
q
u
i
e
r
e
 
d
e
c
i
r
 
c
o
n
 
m
o
n
i
t
o
r
i
z
a
r
 
(
d
e
s
d
e
 
e
l
 
p
u
n
t
o
 
d
e
 
v
i
s
t
a
 
s
e
m
√°
n
t
i
c
o
)
?
 
¬ø
Q
u
√©
 
f
o
r
m
a


de
control
puede
ejercer
el
administrador
de
red
?


‚Ä¢
¬ø
C
u
√°
l
 
e
s
 
e
l
 
f
o
r
m
a
t
o
 
e
s
p
e
c
√≠
f
i
c
o
 
d
e
 
l
a
 
i
n
f
o
r
m
a
c
i
√≥
n
 
c
o
m
u
n
i
c
a
d
a
 
y
/
o
 
i
n
t
e
r
c
a
m
b
i
a
d
a
?
 

‚Ä¢
¬ø
Q
u
√©
 
p
r
o
t
o
c
o
l
o
 
d
e
 
c
o
m
u
n
i
c
a
c
i
√≥
n
 
s
e
 
e
m
p
l
e
a
 
p
a
r
a
 
i
n
t
e
r
c
a
m
b
i
a
r
 
e
s
t
a
 
i
n
f
o
r
m
a
c
i
√≥
n
?


742
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7429.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
743


PRINCIPLES
IN
PRACTICE


CENTRO
DE
OPERACIONES
DE
RED
DE
SPRINTLINK


Las
redes
pueden
tener
todo
tipo
de
formas
y
tama√±os
.
Tanto
en
las
redes
dom√©sticas
m√°s


peque√±as
como
en
el
ISP
de
nivel
1
m√°s
grande
,
es
cometido
del
operador
de
red
garantizar
que


la
red
est√°
funcionando
sin
problemas
.
Pero
,
¬ø
qu√©
ocurre
en
un
centro
de
operaciones
de
red


(
NOC
)
y
cu√°l
es
realmente
el
cometido
de
un
operador
de
red
?


Con
una
red
que
se
extiende
por
todo
el
planeta
,
Sprint
opera
una
de
las
redes
IP
de
nivel
1


m√°s
grandes
del
mundo
.
Conocida
como
SprintLink
(
puede
obtener
m√°s
informaci√≥n
en
www
.


sprint.com
)
,
la
red
tiene
unos
70
puntos
de
presencia
(
los
POP
son
posiciones
en
las
que
hay


routers
IP
de
SprintLink
y
son
los
lugares
donde
los
clientes
se
interconectan
con
la
red
)
y
unos


800
routers
.
¬°
Esto
es
un
mont√≥n
de
ancho
de
banda
!
El
NOC
principal
de
SprintLink
se
encuentra


en
Reston
,
VA
,
y
los
NOC
de
reserva
est√°n
en
Florida
,
Georgia
y
Kansas
City
.
Sprint
tambi√©n


mantiene
centros
NOC
para
sus
redes
ATM
,
frame-relay
y
de
transporte
por
fibra
√≥ptica
subya-


centes
.
En
cualquier
instante
,
un
equipo
de
cuatro
centros
de
operaciones
de
red
monitoriza
y


gestiona
los
equipos
que
se
encuentran
en
el
n√∫cleo
de
la
red
IP
de
SprintLink
.
Tambi√©n
hay
otro


equipo
disponible
para
tratar
cualquier
informe
de
problemas
por
parte
del
cliente
y
para
respon-


der
a
sus
solicitudes
.
La
automatizaci√≥n
en
la
monitorizaci√≥n
(
correlaci√≥n
de
alarmas
,
identifica-


ci√≥n
de
fallos
y
restauraci√≥n
del
servicio
)
,
la
gesti√≥n
de
las
configuraciones
y
la
generaci√≥n
de


informes
de
problemas
de
los
clientes
,
hacen
posible
que
este
peque√±o
grupo
de
operadores
ges-


tionen
una
red
tan
grande
y
compleja
.


T√©cnicos
de
Sprint
monitorizando
el
estado
de
la
red
en
centros
de
operaciones


como
el
de
la
imagen
superior
.
(
Contin√∫a
)


PR√ÅCTICA


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
743Cuando
surgen
problemas
,
el
principal
objetivo
del
operador
de
SprintLink
es
restaurar


r√°pidamente
el
servicio
a
los
clientes
.
Los
operadores
del
NOC
deciden
el
orden
de
las
preferen-


cias
ante
el
problema
y
llevan
a
cabo
los
pasos
de
diagn√≥stico
y
de
restauraci√≥n
siguiendo
un


conjunto
de
procedimientos
en
respuesta
a
un
conjunto
conocido
de
problemas
.
Los
problemas


que
no
pueden
ser
diagnosticados
de
forma
inmediata
o
que
no
pueden
ser
resueltos
por
los


operadores
dentro
de
un
periodo
de
tiempo
con
un
nivel
de
severidad
especificado
(
por
ejemplo
,


15
minutos
)
,
son
transferidos
al
siguiente
nivel
de
soporte
.
El
centro
de
asistencia
t√©cnica
nacional


(
NTAC
,
National
Technical
Assistance
Center
)
de
Sprint
proporciona
dicho
soporte
.
Los
miembros


del
NTAC
son
responsables
de
profundizar
en
las
causas
ra√≠z
de
los
problemas
;
escriben
procedi-


mientos
operativos
para
el
NOC
y
trabajan
con
los
proveedores
de
equipos
(
por
ejemplo
,
con
los


fabricantes
de
routers
)
para
diagnosticar
y
solucionar
problemas
relacionados
con
los
equipos
,


cuando
es
necesario
.
Aproximadamente
el
90
por
ciento
de
los
problemas
son
tratados
directa-


mente
por
los
t√©cnicos
e
ingenieros
del
NOC
.
El
personal
del
NOC
y
el
NTAC
interact√∫a
con
los


dem√°s
equipos
,
incluyendo
a
los
NOC
asociados
(
internos
y
externos
)
y
a
los
equipos
de
opera-


ciones
de
campo
de
Sprint
que
son
‚Äú
los
ojos
,
los
o√≠dos
y
las
manos
‚Äù
en
los
puntos
de
presencia


(
POP
)
de
Sprint
.


Como
hemos
mencionado
anteriormente
en
este
cap√≠tulo
,
la
‚Äú
gesti√≥n
de
red
‚Äù
dentro
de


SprintLink
(
as√≠
como
en
otros
ISP
)
ha
evolucionado
desde
la
gesti√≥n
de
fallos
,
pasando
por
la
ges-


ti√≥n
del
rendimiento
hasta
la
gesti√≥n
de
servicios
,
poniendo
cada
vez
un
mayor
√©nfasis
en
las


necesidades
del
cliente
.
Aunque
se
centran
en
las
necesidades
del
cliente
,
los
operadores
de


Sprint
tambi√©n
se
enorgullecen
de
la
excelencia
operacional
y
de
su
papel
a
la
hora
de
mantener


y
salvaguardar
la
infraestructura
de
red
global
de
uno
de
los
ISP
m√°s
grandes
del
mundo
.


Recordemos
nuestra
analog√≠a
de
la
organizaci√≥n
humana
de
la
secci√≥n
anterior
.
El


director
y
los
directores
de
las
sucursales
deben
ponerse
de
acuerdo
acerca
de
las
medidas


relativas
a
la
actividad
,
la
productividad
y
el
presupuesto
empleadas
para
informar
sobre
el


estado
de
una
sucursal
.
De
forma
similar
,
necesitar√°n
acordar
las
acciones
que
puede
tomar


el
director
(
por
ejemplo
,
recortar
el
presupuesto
,
pedir
al
director
de
una
sucursal
que
cam-


bie
determinados
aspectos
del
funcionamiento
de
la
sucursal
o
despedir
al
personal
y
cerrar


una
sucursal
)
.
En
un
nivel
de
detalle
mayor
,
tendr√°n
que
acordar
tambi√©n
la
forma
en
que
se


comunicar√°n
los
datos
.
Por
ejemplo
,
¬ø
en
qu√©
moneda
(
d√≥lar
o
euro
)
se
realizan
los
presu-


puestos
?
¬ø
En
qu√©
unidades
se
mide
la
productividad
?
Aunque
estos
detalles
pueden
parecer


triviales
,
deben
ser
acordados
.
Por
√∫ltimo
,
ser√°
necesario
especificar
la
forma
en
que
la


informaci√≥n
se
traslada
entre
la
oficina
principal
y
las
sucursales
(
es
decir
,
el
protocolo
de


comunicaciones
)
.


El
entorno
de
gesti√≥n
est√°ndar
de
Internet
se
ocupa
de
estas
cuestiones
.
Este
entorno


consta
de
cuatro
partes
:


‚Ä¢D
e
f
i
n
i
c
i
o
n
e
s
 
d
e
 
l
o
s
 
objetos
de
gesti√≥n
de
red
,
conocidos
como
objetos
MIB
.
En
el


entorno
de
gesti√≥n
est√°ndar
de
Internet
,
la
informaci√≥n
de
gesti√≥n
se
representa
como
una


colecci√≥n
de
objetos
gestionados
que
juntos
forman
un
almac√©n
virtual
de
informaci√≥n
,


conocido
como
Base
de
informaci√≥n
de
gesti√≥n
(
MIB
,
Management
Information
Base
)
.


Un
objeto
MIB
puede
ser
un
contador
,
tal
como
el
n√∫mero
de
datagramas
IP
descartados


en
un
router
debido
a
los
errores
existentes
en
la
cabecera
de
un
datagrama
IP
o
el


n√∫mero
de
errores
de
detecci√≥n
de
portadora
en
una
tarjeta
de
interfaz
Ethernet
;
informa-


744
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
744ci√≥n
descriptiva
,
como
la
versi√≥n
del
software
que
est√°
ejecut√°ndose
en
un
servidor
DNS
;


informaci√≥n
de
estado
,
como
por
ejemplo
si
un
determinado
dispositivo
est√°
funcionando


correctamente
;
o
informaci√≥n
espec√≠fica
del
protocolo
,
como
por
ejemplo
un
camino
de


enrutamiento
hasta
un
destino
.
Los
objetos
MIB
definen
por
tanto
la
informaci√≥n
de
ges-


ti√≥n
mantenida
por
un
dispositivo
gestionado
.
Los
objetos
MIB
relacionados
se
recopilan


en
m√≥dulos
MIB
.
En
nuestra
analog√≠a
de
la
organizaci√≥n
humana
,
la
base
MIB
define
la


informaci√≥n
transmitida
entre
la
oficina
principal
y
las
sucursales
.


‚Ä¢U
n
 
lenguaje
de
definici√≥n
de
datos
,
conocido
como
Estructura
de
la
informaci√≥n
de
ges-


ti√≥n
(
SMI
,
Structure
of
Management
Information
)
.
SMI
define
los
tipos
de
datos
,
un


modelo
de
objeto
y
reglas
para
escribir
y
revisar
la
informaci√≥n
de
gesti√≥n
.
Los
objetos


MIB
se
especifican
en
este
lenguaje
de
definici√≥n
de
datos
.
En
nuestra
analog√≠a
de
la


organizaci√≥n
humana
,
la
SMI
se
emplea
para
definir
los
detalles
del
formato
de
la
infor-


maci√≥n
que
va
a
ser
intercambiada
.


‚Ä¢
Un
protocolo
,
SNMP
.SNMP
se
utiliza
para
transmitir
informaci√≥n
y
comandos
entre
una


entidad
gestora
y
un
agente
que
se
ejecuta
en
un
dispositivo
de
red
gestionado
,
en
repre-


sentaci√≥n
de
esa
entidad
.


‚Ä¢
Capacidades
de
administraci√≥n
y
seguridad
.
La
adici√≥n
de
estas
capacidades
representa


la
principal
mejora
de
SNMPv3
respecto
a
SNMPv2
.


La
arquitectura
de
gesti√≥n
de
red
de
Internet
,
por
dise√±o
,
es
por
tanto
modular
,
con
un


lenguaje
de
definici√≥n
de
datos
y
una
MIB
independientes
del
protocolo
,
y
un
protocolo


independiente
de
la
MIB
.
Es
interesante
rese√±ar
que
esta
arquitectura
modular
fue
inicial-


mente
utilizada
para
facilitar
la
transici√≥n
de
una
gesti√≥n
de
red
basada
en
SNMP
a
un


entorno
de
gesti√≥n
de
red
que
estaba
siendo
desarrollado
por
ISO
,
la
arquitectura
de
gesti√≥n


de
red
competidora
cuando
se
concibi√≥
SNMP
,
aunque
fue
una
transici√≥n
que
nunca
lleg√≥
a


ocurrir
.
Sin
embargo
,
con
el
paso
del
tiempo
,
la
modularidad
del
dise√±o
de
SNMP
le
ha
per-


mitido
evolucionar
a
trav√©s
de
tres
revisiones
fundamentales
,
desarroll√°ndose
de
forma
inde-


pendiente
cada
una
de
las
cuatro
partes
principales
de
SNMP
mencionadas
m√°s
arriba
.


Evidentemente
,
se
tom√≥
una
decisi√≥n
correcta
respecto
a
la
modularidad
,
¬°
aunque
por
una


raz√≥n
equivocada
!


En
las
siguientes
subsecciones
vamos
a
examinar
en
detalle
los
cuatro
componentes


principales
del
entorno
de
gesti√≥n
est√°ndar
de
Internet
.


9.3.1
Estructura
de
la
informaci√≥n
de
gesti√≥n
(
SMI
)


La
Estructura
de
la
informaci√≥n
de
gesti√≥n
(
SMI
,
Structure
of
Management
Informa-


tion
)
(
un
componente
con
un
nombre
bastante
extra√±o
del
entorno
de
gesti√≥n
de
red
que
no


sugiere
nada
acerca
de
su
funcionalidad
)
es
el
lenguaje
utilizado
para
definir
la
informaci√≥n


de
gesti√≥n
que
reside
en
una
entidad
de
red
gestionada
.
Tal
lenguaje
de
definici√≥n
es
necesa-


rio
para
garantizar
que
la
sintaxis
y
la
sem√°ntica
de
los
datos
de
gesti√≥n
de
red
est√°n
bien


definidos
y
no
resultan
ambiguos
.
Observe
que
la
SMI
no
define
una
instancia
espec√≠fica
de


los
datos
contenidos
en
una
entidad
de
red
gestionada
,
sino
el
lenguaje
en
el
que
tal
infor-


maci√≥n
se
especifica
.
Los
documentos
que
describen
la
SMI
para
SNMPv3
(
que
de
forma


bastante
confusa
se
denomina
SMIv2
)
son
[
RFC
2578
;
RFC
2579
;
RFC
2580
]
.
Examine-


mos
la
SMI
de
abajo
hacia
arriba
,
comenzando
por
los
tipos
de
datos
b√°sicos
.
A
continua-


ci√≥n
,
veremos
c√≥mo
se
describen
en
SMI
los
objetos
gestionados
y
luego
c√≥mo
los
objetos


gestionados
relacionados
se
agrupan
en
m√≥dulos
.


9.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
745


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
745746
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


Tipos
de
datos
b√°sicos
de
SMI


El
documento
RFC
2578
especifica
los
tipos
de
datos
b√°sicos
en
el
lenguaje
de
definici√≥n


de
m√≥dulos
MIB
de
SMI
.
Aunque
la
SMI
est√°
basada
en
el
lenguaje
de
definici√≥n
de
objetos


ASN.1
(
Abstract
Syntax
Notation
One
,
Notaci√≥n
de
sintaxis
abstracta
uno
)
[
ISO
1987
;
ISO


X.680
2002
]
(
v√©ase
la
Secci√≥n
9.4
)
,
se
han
a√±adido
bastantes
tipos
de
datos
espec√≠ficos
de


SMI
como
para
considerar
que
SMI
es
por
s√≠
misma
un
lenguaje
de
definici√≥n
de
datos
.
En


la
Tabla
9.1
se
enumeran
los
11
tipos
de
datos
b√°sicos
definidos
en
el
documento
RFC
2578
.


Adem√°s
de
estos
objetos
escalares
,
tambi√©n
es
posible
imponer
una
estructura
tabular
a
una


colecci√≥n
ordenada
de
objetos
MIB
utilizando
la
construcci√≥n
SEQUENCE
OF
;
si
desea


conocer
m√°s
detalles
consulte
el
documento
RFC
2578
.
La
mayor
parte
de
los
tipos
de
datos


de
la
Tabla
9.1
ser√°n
familiares
(
adem√°s
de
que
se
explican
por
s√≠
mismos
)
para
la
mayor√≠a


de
los
lectores
.
El
√∫nico
tipo
de
datos
que
vamos
a
ver
m√°s
detalladamente
enseguida
es
el


tipo
OBJECT
IDENTIFIER
,
que
se
utiliza
para
dar
nombre
a
un
objeto
.


Construcciones
de
nivel
superior
de
SMI


Adem√°s
de
los
tipos
de
datos
b√°sicos
,
el
lenguaje
de
definici√≥n
de
datos
SMI
tambi√©n
pro-


porciona
construcciones
del
lenguaje
de
nivel
superior
.


La
construcci√≥n
OBJECT-TYPEse
utiliza
para
especificar
el
tipo
de
datos
,
el
estado
y
la


sem√°ntica
de
un
objeto
gestionado
.
Colectivamente
,
estos
objetos
gestionados
contienen
los


datos
de
gesti√≥n
que
constituyen
la
base
de
la
gesti√≥n
de
la
red
.
Existen
m√°s
de
10.000
obje-


tos
definidos
en
varios
documentos
RFC
de
Internet
[
RFC
3410
]
.
La
construcci√≥n


Tipo
de
datos
Descripci√≥n


INTEGER
Entero
de
32
bits
,
como
se
define
en
ASN.1
,
con
un
valor
comprendido
entre
/H11002231
y
231
/H110021
,


ambos
inclusive
,
o
un
valor
de
una
lista
de
posibles
valores
constantes
con
nombre
.


Integer32
Entero
de
32
bits
con
un
valor
comprendido
entre
/H11002231
y
231
/H110021
,
ambos
inclusive
.


Unsigned32
Entero
de
32
bits
sin
signo
en
el
rango
de
0
a
2
32
/H110021
,
ambos
inclusive
.


OCTET
STRING
Cadena
de
bytes
en
formato
ASN.1
que
representa
datos
binarios
arbitrarios
o
textuales
,
de
hasta


65.535
bytes
de
longitud
.


OBJECT
IDENTIFIER
Nombre
estructurado
en
formato
ASN.1
asignado
administrativamente
;
v√©ase
la
Secci√≥n
9.3.2
.


IPaddress
Direcci√≥n
de
Internet
de
32
bits
,
en
orden
de
byte
de
red
.


Counter32
Contador
de
32
bits
que
se
incrementa
de
0
a
2
32
/H110021
y
luego
vuelve
a
0
.


Counter64
Contador
de
64
bits
.


Gauge32
Entero
de
32
bits
que
no
aumenta
por
encima
de
2
32
/H110021
ni
disminuye
por
debajo
de
0
cuando


se
incrementa
o
decrementa
.


TimeTicks
Tiempo
,
medido
en
1/100
de
segundo
desde
alg√∫n
suceso
.


Opaque
Cadena
ASN.1
no
interpretada
,
necesaria
por
cuestiones
de
compatibilidad
hacia
abajo
.


Tabla
9.1
‚Ä¢
Tipos
de
datos
b√°sicos
de
la
SMI
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7469.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
747


OBJECT-TYPEtiene
cuatro
cl√°usulas
.
La
cl√°usula
SYNTAXde
una
definici√≥n
OBJECT-TYPE


especifica
el
tipo
de
datos
b√°sico
asociado
con
el
objeto
.
La
cl√°usula
MAX-ACCESS
especi-


fica
si
el
objeto
gestionado
puede
ser
le√≠do
,
escrito
,
creado
o
tiene
su
valor
incluido
en
una


notificaci√≥n
.
La
cl√°usula
STATUS
indica
si
la
definici√≥n
del
objeto
est√°
actualizada
y
es


v√°lida
,
si
es
obsoleta
(
en
cuyo
caso
no
debe
implementarse
,
ya
que
su
definici√≥n
s√≥lo
est√°


incluida
con
prop√≥sitos
hist√≥ricos
)
,
o
est√°
en
desuso
(
obsoleta
pero
implementable
por
cues-


tiones
de
interoperabilidad
con
implementaciones
m√°s
antiguas
)
.
La
cl√°usula
DESCRIPTION


contiene
una
definici√≥n
textual
legible
del
objeto
,
que
‚Äú
documenta
‚Äù
el
prop√≥sito
del
objeto


gestionado
y
deber√≠a
proporcionar
toda
la
informaci√≥n
sem√°ntica
necesaria
para
implemen-


tar
el
objeto
gestionado
.


Como
ejemplo
de
construcci√≥n
OBJECT-TYPE
,
considere
la
definici√≥n
del
tipo
de


objeto
ipSystemStatsInDeliversdel
[
RFC
4293
]
.
Este
objeto
define
un
contador
de
32


bits
que
controla
el
n√∫mero
de
datagramas
IP
que
se
han
recibido
en
el
dispositivo
gestio-


nado
y
que
se
han
entregado
con
√©xito
a
un
protocolo
de
la
capa
superior
.
La
√∫ltima
l√≠nea
de


esta
definici√≥n
hace
referencia
al
nombre
de
este
objeto
,
un
tema
que
abordaremos
en
la


siguiente
subsecci√≥n
.


ipSystemStatsInDelivers
OBJECT-TYPE


SYNTAX
    
Counter32


MAX-ACCESS
read-only


STATUS
    
current


DESCRIPTION


"
The
total
number
of
datagrams
successfully


delivered
to
IPuser-protocols
(
including
ICMP
)
.


When
tracking
interface
statistics
,
the
counter


of
the
interface
to
which
these
datagrams
were


addressed
is
incremented
.
This
interface
might


not
be
the
same
as
theinput
interface
for


some
of
the
datagrams
.


Discontinuities
in
the
value
of
this
counter
can
occur
at
re-initial-


ization
of
the
management
system
,
and
at
other
times
as
indicated
by


the
value
of
ipSystemStatsDiscontinuityTime
.
"


:
:
=
{
ipSystemStatsEntry
18
}


La
construcci√≥n
MODULE-IDENTITYpermite
agrupar
objetos
relacionados
dentro
de
un


‚Äú
m√≥dulo
‚Äù
.
Por
ejemplo
,
[
RFC
4293
]
especifica
el
m√≥dulo
MIB
que
define
los
objetos
ges-


tionados
(
incluyendo
ipSystemStatsInDelivers
)
que
permiten
gestionar
implementa-


ciones
del
Protocolo
de
Internet
(
IP
)
y
su
Protocolo
de
mensajes
de
control
de
Internet


(
ICMP
)
asociado
.
[
RFC
4022
]
especifica
el
m√≥dulo
MIB
para
TCP
y
el
documento
[
RFC


4133
]
especifica
el
m√≥dulo
MIB
para
UDP
.
[
RFC
4502
]
define
el
m√≥dulo
MIB
para
la
moni-


torizaci√≥n
remota
RMON
.
Adem√°s
de
contener
las
definiciones
OBJECT-TYPE
de
los
obje-


tos
gestionados
dentro
del
m√≥dulo
,
la
construcci√≥n
MODULE-IDENTITY
contiene
cl√°usulas


para
documentar
la
informaci√≥n
de
contacto
del
autor
del
m√≥dulo
,
la
fecha
de
la
√∫ltima


actualizaci√≥n
,
un
historial
de
revisiones
y
una
descripci√≥n
textual
del
m√≥dulo
.
Considere


como
ejemplo
la
siguiente
definici√≥n
de
m√≥dulo
para
la
gesti√≥n
del
protocolo
IP
:


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
747748
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


ipMIB
MODULE-IDENTITY


LAST-UPDATED
"
200602020000Z
"


ORGANIZATION
"
IETF
IPv6
MIB
Revision
Team
"


CONTACT-INFO


"
Editor
:


Shawn
A.
Routhier


Interworking
Labs


108
Whispering
Pines
Dr.
Suite
235


Scotts
Valley
,
CA
95066


USA


EMail
:
<
sar@iwl.com
>
"


DESCRIPTION


"
The
MIB
module
for
managing
IP
and
ICMP
implementations
,
but


excluding
their
management
of
IP
routes
.


Copyright
(
C
)
The
Internet
Society
(
2006
)
.


This
version
of
this
MIB
module
is
part
of


RFC
4293
;
see
the
RFC
itself
for
full
legal
notices
.
"


REVISION
     
"
200602020000Z
"


DESCRIPTION


"
The
IP
version
neutral
revision
with
added
IPv6
objects
for
ND
,


default
routers
,
and
router
advertisements
.
As
well
as
being
the


successor
to
RFC
2011
,
this
MIB
is
also
the
successor
to
RFCs


2465
and
2466
.
Published
as
RFC
4293
.
"


REVISION
     
"
199411010000Z
"


DESCRIPTION


"
A
separate
MIB
module
(
IP-MIB
)
for
IP
and
ICMP
management


objects
.
Published
as
RFC
2011
.
"


REVISION
     
"
199103310000Z
"


DESCRIPTION


"
The
initial
revision
of
this
MIB
module
was
part
of
MIB-II
,


which
was
published
as
RFC
1213
.
"


:
:
=
{
mib-2
48
}


La
construcci√≥n
NOTIFICATION-TYPE
se
utiliza
para
especificar
la
informaci√≥n
rela-


cionada
con
los
mensajes
InformationRequesty
SNMPv2-Trapgenerados
por
un
agente


o
por
una
entidad
gestora
(
v√©ase
la
Secci√≥n
9.3.3
)
.
Esta
informaci√≥n
incluye
una
descripci√≥n


(
DESCRIPTION
)
textual
acerca
de
cu√°ndo
deben
ser
enviados
los
mensajes
,
as√≠
como
una


lista
de
los
valores
que
deben
ser
incluidos
en
el
mensaje
generado
;
si
desea
conocer
m√°s


detalles
,
consulte
el
documento
[
RFC
2578
]
.
La
construcci√≥n
MODULE-COMPLIANCEdefine


el
conjunto
de
objetos
gestionados
en
un
m√≥dulo
que
un
agente
debe
implementar
.
La
cons-


trucci√≥n
AGENT-CAPABILITIES
especifica
las
capacidades
de
los
agentes
con
respecto
a


las
definiciones
de
notificaci√≥n
de
objetos
y
sucesos
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7489.3.2
Base
de
informaci√≥n
de
gesti√≥n
(
MIB
)


Como
hemos
mencionado
anteriormente
,
puede
pensarse
en
la
Base
de
informaci√≥n
de
ges-


ti√≥n
,
MIB
,
c
o
m
o
 
e
n
 
u
n
 
a
l
m
a
c
√©
n
 
v
i
r
t
u
a
l
 
d
e
 
i
n
f
o
r
m
a
c
i
√≥
n
,
 
q
u
e
 
a
l
o
j
a
 
o
b
j
e
t
o
s
 
g
e
s
t
i
o
n
a
d
o
s
 
c
u
y
o
s


valores
reflejan
colectivamente
el
‚Äú
estado
‚Äù
actual
de
la
red
.
Estos
valores
pueden
ser
con-


sultados
y
/
o
definidos
por
una
entidad
gestora
enviando
mensajes
SNMP
al
agente
que
se


est√°
ejecutando
en
un
dispositivo
gestionado
en
representaci√≥n
de
la
entidad
gestora
.
Los


objetos
gestionados
se
especifican
utilizando
la
construcci√≥n
SMI
OBJECT-TYPEque
hemos


explicado
anteriormente
y
se
recopilan
en
m√≥dulos
MIB
utilizando
la
construcci√≥n
 
MODULE


-IDENTITY
.


El
IETF
ha
estado
ocupado
estandarizando
los
m√≥dulos
MIB
asociados
con
routers
,


hosts
y
otros
equipos
de
red
.
Esta
tarea
incluye
datos
b√°sicos
de
identificaci√≥n
de
un
ele-


mento
determinado
de
hardware
e
informaci√≥n
de
gesti√≥n
acerca
de
los
protocolos
y
las


interfaces
de
red
del
dispositivo
.
En
2006
hab√≠a
m√°s
de
200
m√≥dulos
MIB
basados
en
est√°n-


dares
e
incluso
un
n√∫mero
mayor
de
m√≥dulos
MIB
espec√≠ficos
de
fabricantes
(
privados
)
.


Con
todos
estos
est√°ndares
,
el
IETF
necesitaba
definir
una
forma
de
identificar
y
nombrar


tanto
los
m√≥dulos
estandarizados
como
los
objetos
gestionados
espec√≠ficos
contenidos
en


los
m√≥dulos
.
En
lugar
de
partir
de
cero
,
el
IETF
adopt√≥
un
marco
de
identificaci√≥n
(
denomi-


naci√≥n
)
de
objetos
estandarizados
que
ya
hab√≠a
utilizado
la
Organizaci√≥n
Internacional
de


Estandarizaci√≥n
(
ISO
)
.
Como
ocurre
con
muchos
organismos
de
estandarizaci√≥n
,
ISO
ten√≠a


‚Äú
grandes
planes
‚Äù
para
su
entorno
de
identificaci√≥n
de
objetos
estandarizados
:
identificar


todos
los
posibles
objetos
estandarizados
(
por
ejemplo
,
formatos
de
datos
,
protocolos
o
ele-


mentos
de
informaci√≥n
)
en
cualquier
red
,
independientemente
de
la
organizaci√≥n
de
estan-


darizaci√≥n
(
como
por
ejemplo
,
Internet
IETF
,
ISO
,
IEEE
o
ANSI
)
,
del
fabricante
del
equipo


o
del
propietario
de
la
red
.
¬°
Un
magn√≠fico
objetivo
!
El
entorno
de
identificaci√≥n
de
objetos


adoptado
por
ISO
es
parte
del
lenguaje
de
definici√≥n
de
objetos
ASN.1
(
Abstract
Syntax


Notation
One
)
[
ISO
X.680
2002
]
que
veremos
en
la
Secci√≥n
9.4
.
Los
m√≥dulos
MIB
estan-


darizados
tienen
acomodo
en
este
entorno
de
denominaci√≥n
,
como
vamos
a
ver
a
continua-


ci√≥n
.


Como
se
muestra
en
la
Figura
9.3
,
en
el
entorno
de
denominaci√≥n
ISO
los
objetos
se


nombran
de
forma
jer√°rquica
.
Observe
que
cada
punto
de
ramificaci√≥n
del
√°rbol
tiene
un


nombre
y
n√∫mero
(
mostrado
entre
par√©ntesis
)
;
por
tanto
,
cualquier
punto
del
√°rbol
puede
ser


identificado
mediante
la
secuencia
de
nombres
o
n√∫meros
que
especifica
el
camino
desde
la


ra√≠z
hasta
dicho
punto
del
√°rbol
de
identificaci√≥n
.
Puede
encontrar
una
utilidad
basada
en


Web
divertida
,
pero
incompleta
y
no
oficial
,
que
permite
recorrer
parte
del
√°rbol
de
identifi-


caci√≥n
de
objetos
(
utilizando
informaci√≥n
de
las
ramificaciones
aportada
por
voluntarios
)
en


[
Alvestrand
1997
]
y
[
France
Telecom
2006
]
.


En
la
parte
superior
de
la
jerarqu√≠a
se
encuentran
ISO
y
el
Sector
de
Estandarizaci√≥n
de


Telecomunicaciones
de
la
Uni√≥n
Internacional
de
Telecomunicaciones
(
ITU-T
)
,
las
dos
orga-


nizaciones
de
est√°ndares
principales
que
se
ocupan
de
ASN.1
,
as√≠
como
una
rama
que
une
los


esfuerzos
de
estas
dos
organizaciones
.
Bajo
la
rama
ISO
del
√°rbol
podemos
ver
las
entradas


correspondientes
a
todos
los
est√°ndares
ISO
(
1.0
)
y
a
los
est√°ndares
emitidos
por
organismos


de
estandarizaci√≥n
de
distintos
pa√≠ses
miembros
de
ISO
(
1.2
)
.
Aunque
en
la
Figura
9.3
no
se


muestra
,
bajo
Organismos
miembros
de
ISO
(
1.2
)
se
encuentra
USA
(
1.2.840
)
,
y
debajo
de


√©ste
se
encuentran
una
serie
de
est√°ndares
de
IEEE
,
ANSI
y
otras
empresas
espec√≠ficas
,
entre


las
que
se
incluyen
RSA
(
1.2.840.11359
)
y
Microsoft
(
1.2.840.113556
)
,
y
bajo
√©ste
est√°n
los


formatos
de
archivo
de
Microsoft
(
1.2.840.113556.4
)
para
diversos
productos
de
Microsoft
,


como
por
ejemplo
Word
(
1.2.840.113556.4.2
)
.
Pero
ahora
nosotros
estamos
interesados
en
las


9.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
749


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
749750
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


ITU-T
(
0
)
Uni√≥n
ISO
/
ITU-T
(
2)ISO
(
1
)


Est√°ndar
(
0
)
Organismos


miembros


de
ISO
(
2
)


Organizaciones


identificadas
por
ISO
(
3
)


Organismos


identificados


por
la
OTAN

 
(
57
)


Open
Software


Foundation
(
22
)


US


DoD
(
6
)


Internet
(
1
)


directory


(
1
)


experimental


(
3
)


security


(
5
)


mail


(
7
)


private


(
4
)


snmpv2


(
6
)


management


(
2
)


MIB-2
(
1
)


system


(
1
)


address


translation


(
3
)


icmp


(
5
)


udp


(
7
)


cmot


(
9
)


interface


(
2
)


ip


(
4
)


tcp


(
6
)


egp


(
8)


transmission


(
10
)


rmon


(
16
)


snmp


(
11
)


Figura
9.3
‚Ä¢
√Årbol
de
identificaci√≥n
de
objetos
ASN.1
.


redes
(
no
en
los
archivos
de
Microsoft
)
,
por
lo
que
vamos
a
centrar
nuestra
atenci√≥n
en
la
rama


etiquetada
como
1.3
,
que
corresponde
a
los
est√°ndares
emitidos
por
los
organismos
reconoci-


dos
por
ISO
,
entre
los
que
se
incluyen
el
Departamento
de
Defensa
de
Estados
Unidos
,
US


DoD
,
(
6
)
(
rama
bajo
la
que
encontraremos
los
est√°ndares
de
Internet
)
,
la
Open
Software
Foun-


dation
(
22
)
,
la
asociaci√≥n
de
l√≠neas
a√©reas
SITA
(
69
)
,
los
organismos
identificados
por
la


OTAN
(
57
)
,
as√≠
como
muchas
otras
organizaciones
.


Bajo
la
rama
Internetdel
√°rbol
(
1.3.6.1
)
,
hay
siete
categor√≠as
.
Bajo
la
rama
private


(
1.3.6.1.4
)
encontramos
una
lista
[
IANA
2009b
]
de
los
nombres
y
los
c√≥digos
empresariales


privados
de
muchos
miles
de
empresas
privadas
que
est√°n
registradas
en
la
IANA
(
Internet


Assigned
Numbers
Authority
)
[
IANA
2009a
]
.
Bajo
las
ramas
management
(
1.3.6.1.2
)
y


MIB-2
(
1.3.6.1.2.1
)
del
√°rbol
de
identificaci√≥n
de
objetos
encontramos
las
definiciones
de


los
m√≥dulos
MIB
estandarizados
.
¬°
Un
largo
viaje
hasta
llegar
al
espacio
de
nombres
ISO
!


M√≥dulos
MIB
estandarizados


El
nivel
inferior
del
√°rbol
de
la
Figura
9.3
muestra
algunos
de
los
m√≥dulos
MIB
orientados
a


hardware
m√°s
importantes
(
system
e
interface
)
,
as√≠
como
los
m√≥dulos
asociados
con


algunos
de
los
m√°s
importantes
protocolos
de
Internet
.
[
RFC
5000
]
enumera
todos
los


m√≥dulos
MIB
estandarizados
.
Aunque
los
documentos
RFC
relativos
a
MIB
son
bastante


tediosos
y
√°ridos
de
leer
,
resultan
instructivos
(
es
decir
,
es
como
tener
que
comer
verdura
,


‚Äú
es
bueno
para
la
salud
‚Äù
)
para
ver
unas
pocas
definiciones
de
m√≥dulos
MIB
,
con
el
fin
de


conocer
el
tipo
de
informaci√≥n
contenida
en
un
m√≥dulo
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
750Identificador
Nombre
Tipo
Descripci√≥n
(
del
RFC
1213
)


del
objeto


1.3.6.1.2.1.1.1
sysDescr
OCTET
STRING
‚Äú
Nombre
completo
e
identificaci√≥n
de
versi√≥n
del
tipo
de


hardware
del
sistema
,
del
sistema
operativo
y
del
software


de
red
.
‚Äù


1.3.6.1.2.1.1.2
sysObjectID
OBJECT
IDENTIFIER
ID
de
objeto
asignado
por
el
fabricante
que
‚Äú
proporciona


un
medio
f√°cil
y
no
ambiguo
de
determinar
la
clase
de


m√°quina
que
est√°
siendo
gestionada
.
‚Äù


1.3.6.1.2.1.1.3
sysUpTime
TimeTicks
‚Äú
El
tiempo
(
en
cent√©simas
de
segundo
)
desde
que
la


parte
de
gesti√≥n
de
red
del
sistema
fue
reinicializada
por


√∫ltima
vez
.
‚Äù


1.3.6.1.2.1.1.4
sysContact
OCTET
STRING
‚Äú
La
persona
de
contacto
para
este
nodo
gestionado
junto


con
la
informaci√≥n
sobre
c√≥mo
ponerse
en
contacto
con


dicha
persona
.
‚Äù


1.3.6.1.2.1.1.5
sysName
OCTET
STRING
‚Äú
Un
nombre
asignado
administrativamente
para
este
nodo


gestionado
.
Por
convenio
,
√©ste
es
el
nombre
de
dominio


completamente
cualificado
del
nodo
.
‚Äù


1.3.6.1.2.1.1.6
sysLocation
OCTET
STRING
‚Äú
Localizaci√≥n
f√≠sica
de
este
nodo
.
‚Äù


1.3.6.1.2.1.1.7
sysServices
Integer32
Un
valor
codificado
que
indica
el
conjunto
de
servicios


disponible
en
este
nodo
:
f√≠sicos
(
por
ejemplo
,
un
repeti-


dor
)
,
enlace
de
datos
/
subred
(
por
ejemplo
,
un
puente
)
,


Internet
(
por
ejemplo
,
una
pasarela
IP
)
,
terminal
a
termi-


nal
(
por
ejemplo
,
un
host
)
,
aplicaciones
.


Tabla
9.2
‚Ä¢
Objetos
gestionados
en
el
grupo
System
de
MIB-2
.


Los
objetos
gestionados
que
caen
en
la
rama
system
contienen
informaci√≥n
general


acerca
del
dispositivo
que
est√°
siendo
gestionado
;
todos
los
dispositivos
gestionados
deben


soportar
los
objetos
MIB
de
system
.
La
Tabla
9.2
define
los
objetos
del
grupo
system
,
tal


y
como
se
definen
en
el
documento
[
RFC
1213
]
.
La
Tabla
9.3
define
los
objetos
gestionados


en
el
m√≥dulo
MIB
para
el
protocolo
UDP
en
una
entidad
gestora
.


9.3.3
Operaciones
del
protocolo
SNMP
y
correspondencias


de
transporte


La
versi√≥n
2
del
Protocolo
simple
de
gesti√≥n
de
red
(
SNMPv2
)
[
RFC
3416
]
se
utiliza
para


transportar
informaci√≥n
MIB
entre
entidades
gestoras
y
agentes
que
se
ejecutan
en
represen-


taci√≥n
de
las
entidades
gestoras
.
El
uso
m√°s
com√∫n
de
SNMP
es
el
modo
de
solicitud-res-


puesta
en
el
que
una
entidad
gestora
SNMPv2
env√≠a
una
solicitud
a
un
agente
SNMPv2
,
el


cual
la
recibe
,
lleva
a
cabo
ciertas
acciones
y
env√≠a
una
respuesta
a
dicha
solicitud
.
Normal-


mente
,
una
solicitud
se
utilizar√°
para
consultar
(
recuperar
)
o
modificar
(
establecer
)
los
valo-


res
de
objetos
MIB
asociados
con
un
dispositivo
gestionado
.
Un
segundo
uso
com√∫n
de


SNMP
es
cuando
un
agente
env√≠a
un
mensaje
no
solicitado
,
conocido
como
mensaje
TRAP
,


a
una
entidad
gestora
.
Los
mensajes
TRAP
se
utilizan
para
notificar
a
una
entidad
gestora
una
 

9.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
751


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
751752
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


Tipo


PDU


(
0‚Äì3
)


ID
de


solicitud


Estado


de
error


(
0‚Äì5
)


√çndice


de
error
Nombre


ValorNombre


Nombre
Valor


Tipo


PDU


(
4
)


Empresa
Direcc
.


agente


Tipo


Trap


(
0‚Äì7
)


C√≥digo


espec√≠fico


Marca
de


tiempo


Valor


Obtener
/
establecer
cabecera


Cabecera
de
Trap
Informaci√≥n
de
Trap


PDU
SNMP


Variables
que
hay
que
obtener
/
establecer


Figura
9.4
‚Ä¢
Formato
de
la
PDU
de
SNMP
.


Identificador
Nombre
Tipo
Descripci√≥n
(
del
RFC
4113
)


del
objeto


1.3.6.1.2.1.7.1
udpInDatagrams
Counter32
‚Äú
N√∫mero
total
de
datagramas
UDP
entregados
a
los


usuarios
UDP
‚Äù


1.3.6.1.2.1.7.2
udpNoPorts
Counter32
‚Äú
N√∫mero
total
de
datagramas
UDP
recibidos
para
los
que


no
hab√≠a
ninguna
aplicaci√≥n
en
el
puerto
de
destino
‚Äù


1.3.6.1.2.1.7.3
udpInErrors
Counter32
‚Äú
N√∫mero
total
de
datagramas
UDP
recibidos
que
no


pudieron
ser
suministrados
por
razones
distintas
a
que


faltara
una
aplicaci√≥n
en
el
puerto
de
destino
‚Äù


1.3.6.1.2.1.7.4
udpOutDatagrams
Counter32
‚Äú
Numero
total
de
datagramas
UDP
enviados
desde


esta
entidad
‚Äù


Tabla
9.3
‚Ä¢
Objetos
gestionados
seleccionados
en
el
m√≥dulo
UDP
de
MIB-2
.


situaci√≥n
excepcional
que
ha
dado
lugar
a
cambios
en
los
valores
de
los
objetos
MIB
.
Ante-


riormente
en
la
Secci√≥n
9.1
hemos
visto
que
el
administrador
de
red
puede
desear
recibir
un


mensaje
TRAP
,
por
ejemplo
,
cuando
una
interfaz
deja
de
funcionar
,
la
congesti√≥n
alcanza


un
nivel
predefinido
en
un
enlace
o
tiene
lugar
alg√∫n
otro
suceso
destacable
.
Observe
que


existe
una
serie
de
compromisos
importantes
entre
el
sondeo
(
interacci√≥n
solicitud-res-


puesta
)
y
la
captura
(
trapping
)
;
v√©anse
los
problemas
al
final
del
cap√≠tulo
.


SNMPv2
define
siete
tipos
de
mensajes
,
conocidos
gen√©ricamente
como
Unidades
de


datos
de
protocolo
(
PDU
,
Protocol
Data
Units
)
,
que
se
enumeran
en
la
Tabla
9.4
y
se
des-


criben
a
continuaci√≥n
.
El
formato
de
las
unidades
PDU
se
muestra
en
la
Figura
9.4
.


‚Ä¢
Las
PDU
GetRequest
,
GetNextRequesty
GetBulkRequestson
enviadas
desde
una


entidad
gestora
a
un
agente
para
solicitar
el
valor
de
uno
o
m√°s
objetos
MIB
del
disposi-


tivo
gestionado
por
el
agente
.
Los
identificadores
de
objeto
de
los
objetos
MIB
cuyos


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
752valores
est√°n
siendo
solicitados
se
especifican
en
la
parte
de
las
variables
de
la
 
PDU
.


GetRequest
,
GetNextRequesty
GetBulkRequestdifieren
en
la
granularidad
de
sus


solicitudes
de
datos
.
GetRequestpuede
solicitar
un
conjunto
arbitrario
de
valores
MIB
;


pueden
utilizarse
m√∫ltiples
GetNextRequests
para
recorrer
secuencialmente
una
lista
o


tabla
de
objetos
MIB
;
GetBulkRequest
permite
devolver
grandes
bloques
de
datos
,


evitando
la
sobrecarga
en
que
se
incurre
si
se
enviaron
varios
mensajes
GetRequest
o


GetNextRequest
.
En
estos
tres
casos
,
el
agente
responde
con
una
PDU
Responseque


contiene
los
identificadores
de
objeto
y
sus
valores
asociados
.


‚Ä¢U
n
a
 
e
n
t
i
d
a
d
 
g
e
s
t
o
r
a
 
u
t
i
l
i
z
a
 
l
a
 
P
D
U
 
SetRequest
para
establecer
el
valor
de
uno
o
m√°s


objetos
MIB
en
un
dispositivo
gestionado
.
Un
agente
responde
con
una
PDU
Response


con
el
estado
de
error
‚Äú
noError
‚Äù
con
el
fin
de
confirmar
que
el
valor
ha
sido
definido
.


‚Ä¢U
n
a
 
e
n
t
i
d
a
d
 
g
e
s
t
o
r
a
 
u
t
i
l
i
z
a
 
u
n
a
 
P
D
U
 
InformRequest
para
notificar
a
otra
entidad
ges-


tora
cierta
informaci√≥n
MIB
que
es
remota
a
la
entidad
receptora
.
La
entidad
receptora


responde
con
una
PDU
Response
con
el
estado
de
error
‚Äú
noError
‚Äù
con
el
fin
de
con-


firmar
la
recepci√≥n
de
la
PDU
InformRequest
.


‚Ä¢E
l
 
√∫
l
t
i
m
o
 
t
i
p
o
 
d
e
 
P
D
U
 
d
e
 
S
N
M
P
v
2
 
e
s
 
e
l
 
m
e
n
s
a
j
e
 
T
R
A
P
.
 
L
o
s
 
m
e
n
s
a
j
e
s
 
T
R
A
P
s
o
n
 
g
e
n
e
-


rados
as√≠ncronamente
;
es
decir
,
no
son
generados
en
respuesta
a
una
solicitud
recibida
,


sino
en
respuesta
a
un
suceso
para
el
que
la
entidad
gestora
requiere
una
notificaci√≥n
.
El


documento
RFC
3418
define
tipos
de
mensajes
TRAP
bien
conocidos
,
como
el
arranque


en
fr√≠o
o
caliente
de
un
dispositivo
,
el
establecimiento
o
la
p√©rdida
de
un
enlace
,
la
p√©r-


dida
de
un
vecino
o
un
suceso
de
fallo
de
autenticaci√≥n
.
Una
solicitud
TRAP
recibida
no


requiere
ninguna
respuesta
por
parte
de
la
entidad
gestora
.


Tipo
de
PDU
de
SNMPv2
Emisor-receptor
Descripci√≥n


GetRequest
entidad
gestora
a
agente
Obtener
el
valor
de
una
o
m√°s
instancias
de
objeto
MIB


GetNextRequest
entidad
gestora
a
agente
Obtener
el
valor
de
la
siguiente
instancia
de
objeto
MIB


en
una
lista
o
tabla


GetBulkRequest
entidad
gestora
a
agente
Obtener
valores
en
un
bloque
grande
de
datos
,
por
ejemplo
,


en
una
tabla
de
gran
tama√±o


InformRequest
entidad
gestora
a
entidad
Informar
a
la
entidad
gestora
remota
de
los
valores
MIB


gestora
remotos
a
su
acceso
.
 

SetRequest
entidad
gestora
a
agente
Establecer
el
valor
de
una
o
m√°s
instancias
de
objeto
MIB


Response
agente
a
entidad
gestora
o
Generado
en
respuesta
a
:


entidad
gestora
a
entidad
gestora
GetRequest
,


GetNextRequest
,


GetBulkRequest
,


SetRequest
PDU
,
o


InformRequest


SNMPv2-Trap
agente
a
entidad
gestora
Informar
al
gestor
de
un
suceso
excepcional


Tabla
9.4
‚Ä¢
Tipos
de
PDU
de
SNMPv2
.


9.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
753


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
753754
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


Dada
la
naturaleza
solicitud-respuesta
de
SNMPv2
,
es
conveniente
se√±alar
aqu√≠
que


aunque
las
PDU
SNMP
pueden
ser
transportadas
por
medio
de
muchos
protocolos
de
trans-


porte
distintos
,
normalmente
son
transportadas
en
la
carga
√∫til
de
un
datagrama
UDP
.
De


hecho
,
el
documento
RFC
3417
establece
que
UDP
es
‚Äú
la
correspondencia
de
transporte
pre-


ferida
‚Äù
.
Dado
que
UDP
es
un
protocolo
de
transporte
no
fiable
,
no
existe
ninguna
garant√≠a


de
que
una
solicitud
,
o
su
respuesta
,
sea
recibida
en
su
destino
.
La
entidad
gestora
utiliza
el


campo
ID
de
solicitud
de
la
PDU
para
numerar
las
solicitudes
que
env√≠a
a
un
agente
y
la
res-


puesta
del
agente
toma
su
ID
de
solicitud
de
la
solicitud
recibida
.
Por
tanto
,
el
campo
ID
de


solicitud
puede
ser
utilizado
por
la
entidad
gestora
para
detectar
las
solicitudes
y
respuestas


perdidas
.
Depender√°
de
la
entidad
gestora
decidir
si
retransmite
una
solicitud
si
no
ha
reci-


bido
la
respuesta
correspondiente
transcurrido
un
cierto
periodo
de
tiempo
.
En
particular
,
el


est√°ndar
SNMP
no
obliga
a
aplicar
ning√∫n
procedimiento
en
concreto
para
las
retransmisio-


nes
y
ni
siquiera
indica
si
la
retransmisi√≥n
debe
llevarse
a
cabo
.
S√≥lo
obliga
a
que
la
entidad


gestora
‚Äú
act√∫e
de
forma
responsable
respecto
a
la
frecuencia
y
duraci√≥n
de
las
retransmisio-


nes
‚Äù
.
Por
supuesto
,
esto
lleva
a
preguntarse
c√≥mo
debe
actuar
un
protocolo
‚Äú
responsable
‚Äù
.


9.3.4
Seguridad
y
administraci√≥n


Los
dise√±adores
de
SNMPv3
han
dicho
que
‚Äú
SNMPv3
puede
interpretarse
como
SNMPv2


con
una
serie
de
capacidades
adicionales
de
seguridad
y
administraci√≥n
‚Äù
[
RFC
3410
]
.
Real-


mente
,
existen
cambios
en
SNMPv3
respecto
de
SNMPv2
,
pero
en
ninguna
parte
estos
cam-


bios
son
m√°s
evidentes
que
en
el
√°rea
de
la
administraci√≥n
y
la
seguridad
.
El
papel
central


de
la
seguridad
en
SNMPv3
fue
particularmente
importante
,
ya
que
la
falta
de
una
adecuada


seguridad
hizo
que
SNMP
se
usara
principalmente
para
monitorizar
m√°s
que
para
cuestio-


nes
de
control
(
por
ejemplo
,
rara
vez
se
emplea
SetRequesten
SNMPv1
)
.


Puesto
que
SNMP
ha
madurado
a
lo
largo
de
tres
versiones
,
su
funcionalidad
ha
crecido


pero
tambi√©n
el
n√∫mero
de
documentos
est√°ndar
relacionados
con
SNMP
.
Esto
lo
demuestra


el
hecho
de
que
existe
incluso
un
documento
RFC
[
RFC
3411
]
que
‚Äú
describe
una
arquitec-


tura
para
describir
los
entornos
de
gesti√≥n
de
SNMP
‚Äù
.
Aunque
la
idea
de
una
‚Äú
arquitectura
‚Äù


para
‚Äú
describir
un
entorno
‚Äù
pueda
parecer
algo
compleja
,
el
objetivo
del
RFC
3411
es
admi-


rable
:
introducir
un
lenguaje
com√∫n
para
describir
la
funcionalidad
y
las
acciones
tomadas


por
un
agente
o
una
entidad
gestora
SNMPv3
.
La
arquitectura
de
una
entidad
SNMPv3
es


clara
y
un
recorrido
por
dicha
arquitectura
servir√°
para
afianzar
nuestra
comprensi√≥n
de


SNMP
.


Las
denominadas
aplicaciones
SNMP
est√°n
compuestas
por
un
generador
de
coman-


dos
,
un
receptor
de
notificaciones
y
un
dispositivo
de
reenv√≠o
proxy
(
normalmente
,
todos


ellos
se
encuentran
en
una
entidad
gestora
)
;
un
contestador
de
comandos
y
un
emisor
de


notificaciones
(
que
habitualmente
est√°n
disponibles
en
un
agente
)
y
la
posibilidad
de
otras


aplicaciones
.
El
generador
de
comandos
genera
las
PDU
GetRequest
,
GetNextRequest
,


GetBulkRequesty
SetRequestque
hemos
examinado
en
la
Secci√≥n
9.3.3
y
controla
las


respuestas
recibidas
a
estas
PDU
.
El
contestador
de
comandos
se
ejecuta
en
un
agente
y


recibe
,
procesa
y
responde
(
utilizando
el
mensaje
Response
)
a
las
PDU
recibidas
 
GetRe-


quest
,
GetNextRequest
,
GetBulkRequest
y
SetRequest
.
La
aplicaci√≥n
que
origina


las
notificaciones
en
un
agente
genera
las
PDU
Trap
;
estas
PDU
son
recibidas
y
procesadas


en
la
aplicaci√≥n
receptora
de
notificaciones
de
una
entidad
gestora
.
La
aplicaci√≥n
de
reenv√≠o


proxy
reenv√≠a
las
PDU
de
solicitud
,
notificaci√≥n
y
respuesta
.


Una
PDU
enviada
por
una
aplicaci√≥n
SNMP
pasa
a
continuaci√≥n
a
trav√©s
del
‚Äú
motor
‚Äù


SNMP
antes
de
ser
enviada
mediante
el
apropiado
protocolo
de
transporte
.
La
Figura
9.5


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7549.3
‚Ä¢
EL
ENTORNO
DE
GESTI√ìN
EST√ÅNDAR
DE
INTERNET
755


muestra
c√≥mo
una
PDU
generada
por
la
aplicaci√≥n
generador
de
comandos
pasa
en
primer


lugar
por
el
m√≥dulo
de
distribuci√≥n
,
donde
se
determina
la
versi√≥n
de
SNMP
.
A
continua-


ci√≥n
,
la
PDU
es
procesada
en
el
sistema
de
procesamiento
de
mensajes
,
donde
se
encapsula


en
una
cabecera
de
mensaje
que
contiene
el
n√∫mero
de
versi√≥n
de
SNMP
,
un
ID
de
mensaje


y
la
informaci√≥n
de
tama√±o
del
mensaje
.
Si
se
necesita
cifrado
o
autenticaci√≥n
,
tambi√©n
se


incluyen
los
apropiados
campos
de
cabecera
que
suministran
esta
informaci√≥n
;
consulte


[
RFC
3411
]
para
conocer
m√°s
detalles
.
Por
√∫ltimo
,
el
mensaje
SNMP
(
la
PDU
generada


por
la
aplicaci√≥n
m√°s
la
informaci√≥n
de
cabecera
del
mensaje
)
se
pasa
al
protocolo
de


transporte
apropiado
.
El
protocolo
de
transporte
preferido
para
los
mensajes
SNMP
es
UDP


(
es
decir
,
los
mensajes
SNMP
son
transportados
como
la
carga
√∫til
en
un
datagrama
UDP
)
y


el
n√∫mero
de
puerto
preferido
para
SNMP
es
el
puerto
161
.
El
puerto
162
se
utiliza
para
los


mensajes
TRAP
.


Hemos
visto
anteriormente
que
los
mensajes
SNMP
se
emplean
no
s√≥lo
para
monitori-


zar
,
sino
tambi√©n
para
controlar
(
por
ejemplo
,
a
trav√©s
del
comando
SetRequest
)
los
ele-


mentos
de
la
red
.
Evidentemente
,
un
intruso
que
pudiera
interceptar
los
mensajes
SNMP
y
/
o


generar
sus
propios
paquetes
SNMP
en
la
infraestructura
de
gesti√≥n
podr√≠a
afectar
a
la
red
.


Por
tanto
,
es
fundamental
que
los
mensajes
SNMP
sean
transmitidos
de
forma
segura
.
Sor-


prendentemente
,
es
s√≥lo
en
la
versi√≥n
m√°s
reciente
de
SNMP
en
la
que
la
seguridad
ha
reci-


bido
la
atenci√≥n
que
merece
.
La
seguridad
de
SNMPv3
se
conoce
como
seguridad
basada


en
usuario
[
RFC
3414
]
,
porque
existe
el
concepto
tradicional
de
usuario
,
identificado
por


su
nombre
de
usuario
,
y
una
informaci√≥n
de
seguridad
asociada
,
como
por
ejemplo
una
con-


Generador


de
comandos


Aplicaciones


SNMP


Motor


SNMP


Receptor
de


notificaciones


Reenviador


proxy


Distribuidor


Sistema
de


procesamiento


de
mensajes


Puntualidad
,


autenticaci√≥n
,


privacidad


Seguridad


Capa
de
transporte


Control


de
acceso


Generador


de
comandos


Originador
de


notificaciones
Otros


PDU


Cabec
.
seguridad
/
mensaje
PDU


Figura
9.5
‚Ä¢
Motor
y
aplicaciones
SNMPv3
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
755756
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


Actualmente
hay
disponibles
centenares
(
si
no
miles
)
de
productos
de
gesti√≥n
de
red
,
todos
ellos


integrando
en
cierto
grado
el
entorno
de
gesti√≥n
de
red
y
los
fundamentos
de
SNMP
que
hemos


estudiado
en
esta
secci√≥n
.
Un
repaso
de
estos
productos
queda
fuera
del
√°mbito
de
este
texto
y


(
sin
duda
)
lejos
de
la
atenci√≥n
del
lector
.
Por
tanto
,
proporcionamos
aqu√≠
algunas
referencias
a


algunos
de
los
productos
m√°s
destacados
.
Un
buen
punto
de
partida
para
ver
una
introducci√≥n
a


las
herramientas
de
gesti√≥n
de
red
es
el
Cap√≠tulo
12
del
libro
[
Subramanian
2000
]
.


Las
herramientas
de
gesti√≥n
de
red
pueden
dividirse
de
forma
general
entre
aquellas
que
los


fabricantes
de
equipos
de
red
construyen
especialmente
para
la
gesti√≥n
de
sus
propios
equipos
y


aquellas
destinadas
a
la
gesti√≥n
de
red
con
equipos
heterog√©neos
.
Entre
las
ofertas
espec√≠ficas
de


los
fabricantes
se
encuentra
la
serie
de
herramientas
de
gesti√≥n
de
red
Network
Application


Performance
Analysis
(
NAPA
)
de
Cisco
desarrollada
para
dispositivos
Cisco
[
Cisco
NAPA
2009
]
.


Juniper
ofrece
sistemas
de
soporte
de
operaci√≥n
(
OSS
,
Operation
Support
Systems
)
para
el
apro-


visionamiento
de
red
y
soporte
SLA
/
QoS
[
Juniper
2009
]
.


trase√±a
,
un
valor
clave
o
ciertos
privilegios
de
acceso
.
SNMPv3
proporciona
mecanismos
de


cifrado
,
de
autenticaci√≥n
,
protecci√≥n
contra
ataques
por
reproducci√≥n
(
v√©ase
la
Secci√≥n
8.3
)


y
control
de
acceso
.


‚Ä¢
Cifrado
.
Las
PDU
SNMP
pueden
cifrarse
utilizando
el
est√°ndar
DES
(
Data
Encryption


Standard
)
en
modo
CBC
(
Cipher
Block
Chaining
)
.
Observe
que
dado
que
el
est√°ndar


DES
es
un
sistema
de
clave
compartida
,
la
clave
secreta
del
usuario
que
cifra
los
datos


tiene
que
ser
conocida
por
la
entidad
receptora
que
tiene
que
descifrar
los
datos
.


‚Ä¢
Autenticaci√≥n
.
SNMP
utiliza
la
t√©cnica
MAC
(
Message
Authentication
Code
)
que
hemos


estudiado
en
la
Secci√≥n
8.3.1
para
proporcionar
tanto
autenticaci√≥n
como
protecci√≥n


frente
a
falsificaciones
[
RFC
2401
]
.
Recuerde
que
la
t√©cnica
MAC
requiere
que
tanto
el


emisor
como
el
receptor
tengan
una
clave
secreta
com√∫n
.


‚Ä¢
Protecci√≥n
frente
a
ataques
por
reproducci√≥n
.
Recuerde
del
Cap√≠tulo
8
que
pueden


emplearse
n√∫meros
distintivos
para
protegerse
frente
a
ataques
por
reproducci√≥n
.


SNMPv3
adopta
una
t√©cnica
relacionada
.
Con
el
fin
de
asegurarse
de
que
un
mensaje


recibido
no
es
una
reproducci√≥n
de
alg√∫n
mensaje
anterior
,
el
receptor
requiere
que
el


emisor
incluya
un
valor
en
cada
mensaje
que
est√°
basado
en
un
contador
del
receptor
.


Este
contador
,
que
funciona
como
un
n√∫mero
distintivo
,
refleja
el
tiempo
transcurrido


desde
que
tuvo
lugar
el
√∫ltimo
reinicio
del
software
de
gesti√≥n
de
red
del
receptor
y
el


n√∫mero
total
de
reinicios
desde
que
dicho
software
del
receptor
fue
configurado
por


√∫ltima
vez
.
Siempre
y
cuando
el
contador
de
un
mensaje
recibido
se
encuentre
dentro
de


cierto
margen
de
error
del
valor
real
del
receptor
,
el
mensaje
es
aceptado
como
un
men-


saje
que
no
es
una
reproducci√≥n
,
momento
en
el
que
el
mensaje
puede
ser
autenticado


y
/
o
descifrado
.
Para
conocer
m√°s
detalles
,
consulte
[
RFC
3414
]
.


‚Ä¢
Control
de
acceso
.
SNMPv3
proporciona
un
mecanismo
de
control
de
acceso
basado
en


vistas
[
RFC
3415
]
que
controla
qu√©
informaci√≥n
de
gesti√≥n
de
red
puede
ser
consultada


y
/
o
definida
por
qu√©
usuario
.
Una
entidad
SNMP
mantiene
informaci√≥n
acerca
de
las


pol√≠ticas
y
los
derechos
de
acceso
en
un
Almac√©n
de
datos
de
configuraci√≥n
local
(
LCD
,


PR√ÅCTICA


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7569.4
‚Ä¢
ASN.1
757


Local
Configuration
Datastore
)
.
Partes
del
LCD
son
accesibles
como
objetos
gestiona-


dos
que
se
definen
en
la
MIB
de
configuraci√≥n
del
modelo
de
control
de
acceso
basado


en
vistas
[
RFC
3415
]
,
y
por
tanto
pueden
ser
gestionadas
y
manipuladas
remotamente


v√≠a
SNMP
.


9.4
ASN.1


En
este
libro
hemos
abordado
una
serie
de
interesantes
temas
acerca
de
las
redes
de
compu-


tadoras
.
Sin
embargo
,
esta
secci√≥n
dedicada
a
ASN.1
es
posible
que
no
se
encuentre
dentro


de
la
lista
de
los
diez
temas
m√°s
interesantes
.
Como
las
verduras
,
el
conocimiento
de
ASN.1


y
del
amplio
tema
de
los
servicios
de
presentaci√≥n
es
algo
que
es
‚Äú
bueno
para
ti
‚Äù
.
ASN.1
es


un
est√°ndar
ISO
que
se
utiliza
en
una
serie
de
protocolos
relacionados
con
Internet
,
particu-


larmente
en
el
√°rea
de
la
gesti√≥n
de
red
.
Por
ejemplo
,
hemos
visto
en
la
Secci√≥n
9.3
que
las


variables
MIB
en
SNMP
estaban
inextricablemente
ligadas
a
ASN.1
.
Por
tanto
,
aunque
el


material
proporcionado
sobre
ASN.1
en
esta
secci√≥n
puede
ser
bastante
√°rido
,
esperamos


que
el
lector
considere
su
importancia
.


Con
el
fin
de
motivarse
,
considere
el
siguiente
experimento
mental
.
Suponga
que
es


posible
copiar
datos
de
forma
fiable
directamente
desde
la
memoria
de
una
computadora
a


la
memoria
de
una
computadora
remota
.
Si
esto
pudiera
hacerse
,
¬ø
estar√≠a
‚Äú
resuelto
‚Äù
el
pro-


blema
de
la
comunicaci√≥n
?
La
respuesta
a
esta
pregunta
depende
de
la
definici√≥n
de
‚Äú
pro-


blema
de
comunicaci√≥n
‚Äù
.
Ciertamente
,
una
copia
perfecta
de
memoria
a
memoria
pasar√≠a


exactamente
los
bits
y
los
bytes
de
un
equipo
a
otro
pero
,
¬ø
quiere
esto
decir
que
cuando
el


software
que
se
ejecuta
en
la
computadora
receptora
acceda
a
estos
datos
,
ver√°
los
mismos


valores
que
estaban
almacenados
en
la
memoria
de
la
computadora
emisora
?
La
respuesta
a


esta
pregunta
es
‚Äú
¬°
no
necesariamente
!
‚Äù
El
quid
del
problema
es
que
diferentes
arquitecturas


de
computadora
,
diferentes
sistemas
operativos
y
diferentes
compiladores
emplean
conve-


nios
distintos
para
almacenar
y
representar
los
datos
.
Si
los
datos
tienen
que
transmitirse
y


almacenarse
en
distintas
computadoras
(
como
ocurre
en
todas
las
redes
de
comunicaciones
)
,


entonces
est√°
claro
que
este
problema
de
representaci√≥n
de
los
datos
tiene
que
solucionarse
.


Veamos
un
ejemplo
de
este
problema
.
Considere
el
siguiente
fragmento
de
c√≥digo
C.


¬ø
C√≥mo
se
podr√≠a
disponer
esta
estructura
en
memoria
?


struct
{


char
codigo
;


int
x
;


}
prueba
;


prueba.x
=
259
;


prueba.codigo
=
‚Äò
a
‚Äô
;


En
la
parte
izquierda
de
la
Figura
9.6
se
muestra
una
posible
disposici√≥n
de
estos
datos


en
una
arquitectura
hipot√©tica
:
est√°
formada
por
un
√∫nico
byte
de
memoria
que
contiene
el


car√°cter
a
,
seguido
de
una
palabra
de
16
bits
que
contiene
el
valor
entero
259
,
almacenado


con
el
byte
m√°s
significativo
en
primer
lugar
.
En
la
parte
derecha
de
la
Figura
9.6
se
mues-


tra
la
disposici√≥n
en
memoria
de
otra
computadora
.
El
car√°cter
a
va
seguido
por
el
valor


entero
almacenado
con
el
byte
menos
significativo
en
primer
lugar
y
con
el
entero
de
16
bits


alineado
al
principio
de
una
palabra
de
16
bits
.
Ciertamente
,
si
se
realizara
una
copia
literal


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
757758
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


entre
las
memorias
de
estas
computadoras
y
se
empleara
la
misma
definici√≥n
de
estructura


para
acceder
a
los
valores
almacenados
,
¬°
se
ver√≠an
resultados
muy
diferentes
en
ambas
com-


putadoras
!


El
hecho
de
que
distintas
arquitecturas
empleen
formatos
de
datos
internos
diferentes
es


un
problema
real
e
importante
.
El
problema
concreto
del
almacenamiento
de
enteros
en
for-


matos
diferentes
es
tan
com√∫n
que
tiene
nombre
propio
.
El
sistema
big-endian
para
almace-


nar
n√∫meros
enteros
coloca
en
primer
lugar
los
bytes
m√°s
significativos
(
en
la
direcci√≥n
de


almacenamiento
menor
)
.
El
sistema
little-endian
almacena
en
primer
lugar
los
bytes
menos


significativos
.
Los
procesadores
de
Sun
SPARC
y
Motorola
emplean
el
sistema
big-endian
,


mientras
que
los
procesa-dores
de
Intel
y
DEC
/
Compaq
Alpha
emplean
el
sistema
little-


endian
.
Los
t√©rminos
 
big-endian
y
little-endian
est√°n
tomados
del
libro
Los
viajes
de
Gulli-


ver
,
de
Jonathan
Swift
,
en
el
que
dos
grupos
de
personas
insisten
de
forma
dogm√°tica
en


hacer
una
misma
cosa
de
dos
formas
diferentes
(
as√≠
,
la
analog√≠a
con
las
arquitecturas
de


computadora
es
clara
)
.
Un
grupo
de
personas
de
la
tierra
de
Lilliput
insist√≠a
en
romper
los


huevos
por
el
extremo
m√°s
grande
(
‚Äú
los
big-endians
‚Äù
)
,
mientras
que
el
otro
grupo
quer√≠a


romperlos
por
el
extremo
m√°s
peque√±o
.
Esta
diferencia
fue
la
causa
de
una
gran
rebeli√≥n
y


contienda
civil
.


Puesto
que
computadoras
distintas
almacenan
y
representan
los
datos
de
formas
dife-


rentes
,
¬ø
c√≥mo
deben
afrontar
esto
los
protocolos
de
red
?
Por
ejemplo
,
si
un
agente
SNMP


desea
enviar
un
mensaje
Response
que
contiene
el
valor
entero
del
n√∫mero
de
datagramas


UDP
recibidos
,
¬ø
c√≥mo
deber√≠a
representar
el
valor
entero
que
va
enviar
a
la
entidad
gestora
,


utilizando
la
ordenaci√≥n
big-endian
o
la
little-endian
?
Una
opci√≥n
ser√≠a
que
el
agente


enviara
los
bytes
del
entero
en
el
mismo
orden
en
que
fueron
almacenados
en
la
entidad
ges-


tora
.
Otra
opci√≥n
ser√≠a
que
el
agente
enviara
el
entero
utilizando
su
propio
orden
de
almace-


namiento
y
que
la
entidad
receptora
reordenara
los
bytes
,
en
caso
necesario
.
Cualquiera
de


estas
opciones
precisa
que
el
emisor
y
el
receptor
conozcan
el
formato
de
representaci√≥n


de
enteros
del
otro
.


Una
tercera
opci√≥n
ser√≠a
disponer
de
un
m√©todo
independiente
de
la
m√°quina
,
indepen-


diente
del
sistema
operativo
e
independiente
del
lenguaje
para
describir
los
n√∫meros
enteros


y
otros
tipos
de
datos
(
es
decir
,
disponer
de
un
lenguaje
de
definici√≥n
de
datos
)
y
de
reglas


para
establecer
la
forma
en
que
cada
uno
de
los
tipos
de
datos
debe
ser
transmitido
a
trav√©s


de
la
red
.
Cuando
se
reciben
datos
de
un
determinado
tipo
,
se
reciben
en
un
formato
cono-


cido
y
pueden
entonces
ser
almacenados
en
cualquier
formato
espec√≠fico
de
la
m√°quina


requerido
.
Tanto
la
SMI
que
hemos
estudiado
en
la
Secci√≥n
9.3
como
ASN.1
adoptan
esta


tercera
opci√≥n
.
En
la
jerga
de
ISO
,
estos
dos
est√°ndares
describen
un
servicio
de
presenta-


ci√≥n
:
el
servicio
de
transmisi√≥n
y
traducci√≥n
de
informaci√≥n
de
un
formato
espec√≠fico
de
la


a


00000001


00000011


prueba.codigo


prueba.x


prueba.codigo


prueba.x


a


00000011


00000001


Figura
9.6
‚Ä¢
Dos
disposiciones
de
datos
distintas
en
dos
arquitecturas


diferentes
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7589.4
‚Ä¢
ASN.1
759


Hippie
de


los
a√±os
60


Chupi


Abuela
Adolescente


Chupi


Figura
9.7
‚Ä¢
El
problema
de
presentaci√≥n
.


Hippie
de


los
a√±os
60


Servicio
de


presentaci√≥n


Abuela
Adolescente


Servicio
de


presentaci√≥n


Me
gusta


Estupendo
Mola


Chupi


Me
gusta
Servicio
de


presentaci√≥n


Figura
9.8
‚Ä¢
El
problema
de
la
presentaci√≥n
resuelto
.


m√°quina
a
otro
.
La
Figura
9.7
ilustra
un
problema
de
presentaci√≥n
del
mundo
real
;
ninguno


de
los
receptores
comprende
la
idea
esencial
que
se
est√°
comunicando
(
que
el
que
habla


quiere
algo
)
.
Como
se
muestra
en
la
Figura
9.8
,
un
servicio
de
presentaci√≥n
puede
resolver


este
problema
traduciendo
la
idea
a
un
lenguaje
independiente
de
la
persona
y
de
entendi-


miento
com√∫n
(
mediante
el
servicio
de
presentaci√≥n
)
,
enviando
dicha
informaci√≥n
al
recep-


tor
y
luego
traduci√©ndola
a
un
lenguaje
que
el
receptor
comprenda
.


La
Tabla
9.5
muestra
unos
pocos
tipos
de
datos
definidos
en
ASN.1
.
Recuerde
que
en


nuestro
estudio
anterior
de
la
SMI
hemos
hablado
de
los
tipos
de
datos
INTEGER
,
OCTET


STRING
y
OBJECT
IDENTIFIER
.
Dado
que
nuestro
objetivo
aqu√≠
(
afortunadamente
)
no
es


proporcionar
una
introducci√≥n
completa
a
ASN.1
,
remitimos
al
lector
a
los
est√°ndares
o
al


libro
impreso
o
en
l√≠nea
[
Larmouth
1996
]
para
ver
una
descripci√≥n
de
los
tipos
y
construc-


tores
de
ASN.1
,
tales
como
SEQUENCE
y
SET
,
que
permiten
definir
tipos
de
datos
estructu-


rados
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
759760
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


Etiqueta
Tipo
Descripci√≥n


1
BOOLEAN
El
valor
es
verdadero
(
‚Äú
true
‚Äù
)
o
falso
(
‚Äú
false
‚Äù
)


2
INTEGER
Puede
ser
arbitrariamente
grande


3
BITSTRING
Lista
de
uno
o
m√°s
bits


4
OCTET
STRING
Lista
de
uno
o
m√°s
bytes


5
NULL
Ning√∫n
valor


6
OBJECT
IDENTIFIER
Nombre
en
el
√°rbol
de
denominaci√≥n
est√°ndar
de


ASN.1
;
v√©ase
la
Secci√≥n
9.2.2


9
REAL
Punto
flotante


Tabla
9.5
‚Ä¢
Tipos
de
datos
ASN.1
seleccionados
.


Adem√°s
de
proporcionar
un
lenguaje
de
definici√≥n
de
datos
,
ASN.1
tambi√©n
propor-


ciona
Reglas
b√°sicas
de
codificaci√≥n
(
BER
,
Basic
Encoding
Rules
)
que
especifican
c√≥mo


instancias
de
objetos
que
han
sido
definidas
utilizando
el
lenguaje
de
definici√≥n
de
datos
de


ASN.1
deben
enviarse
a
trav√©s
de
la
red
.
Las
reglas
BER
adoptan
un
m√©todo
denominado


TLV
(
Type
,
Length
,
Value
;
Tipo
,
Longitud
,
Valor
)
para
codificar
datos
para
su
transmi-


si√≥n
.
Para
cada
elemento
de
datos
que
se
va
a
enviar
,
se
transmite
el
tipo
de
datos
,
la
longi-


tud
del
elemento
de
datos
y
el
valor
real
de
dicho
elemento
,
en
este
orden
.
Con
este
sencillo


convenio
,
los
datos
recibidos
pr√°cticamente
se
identifican
por
s√≠
mismos
.


En
la
Figura
9.9
se
muestra
c√≥mo
se
enviar√≠an
los
dos
elementos
de
datos
de
un
ejem-


plo
simple
.
En
este
ejemplo
,
el
emisor
desea
enviar
la
cadena
de
caracteres
‚Äú
smith
‚Äù
seguida


del
valor
decimal
259
(
que
en
binario
es
00000001
00000011
,
es
decir
,
un
byte
de
valor
1


seguido
de
un
byte
de
valor
3
)
utilizando
la
ordenaci√≥n
big-endian
.
El
primer
byte
del
flujo


transmitido
tiene
el
valor
4
,
lo
que
indica
que
el
tipo
del
siguiente
elemento
de
datos
es


OCTET
STRING
;
√©sta
es
la
‚Äú
T
‚Äù
de
la
codificaci√≥n
TLV
.
El
segundo
byte
del
flujo
contiene
la


longitud
de
la
cadena
OCTET
STRING
,
en
este
caso
,
5
.
El
tercer
byte
del
flujo
da
inicio
a
la


cadena
OCTET
STRING
de
longitud
5
y
contiene
la
representaci√≥n
ASCII
de
la
letra
s.
Los


valores
T
,
L
y
V
del
siguiente
elemento
de
datos
son
2
(
el
valor
de
etiqueta
de
tipo
INTE-


GER
)
,
2
(
es
decir
,
un
entero
con
una
de
longitud
2
bytes
)
y
la
representaci√≥n
de
2
bytes
con


ordenaci√≥n
big-endian
del
valor
decimal
259
.


En
nuestra
exposici√≥n
anterior
s√≥lo
hemos
tocado
un
subconjunto
peque√±o
y
simple
de


ASN.1
.
Entre
los
recursos
disponibles
para
aprender
m√°s
sobre
ASN.1
se
incluyen
el
docu-


mento
de
los
est√°ndares
ASN.1
[
ISO
X.680
2002
]
,
el
libro
en
l√≠nea
relativo
a
OSI
[
Lar-


mouth
1996
]
y
los
sitios
web
relacionados
con
ASN.1
,
[
OSS
2007
]
y
[
France
Telecom


2006
]
.


9.5
Conclusi√≥n


Terminamos
aqu√≠
nuestro
estudio
sobre
la
gesti√≥n
de
red
y
todo
lo
que
se
refiere
a
las
redes
.


En
este
√∫ltimo
cap√≠tulo
dedicado
a
la
gesti√≥n
de
red
,
hemos
comenzado
planteando
la


necesidad
de
proporcionar
las
herramientas
apropiadas
al
administrador
de
red
(
la
persona


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
7609.5
‚Ä¢
CONCLUSI√ìN
761


cuyo
trabajo
consiste
en
mantener
la
red
‚Äú
activa
y
funcionando
‚Äù
)
para
monitorizar
,
probar
,


sondear
,
configurar
,
analizar
,
evaluar
y
controlar
el
funcionamiento
de
la
red
.
Las
analog√≠as


presentadas
con
la
gesti√≥n
de
sistemas
complejos
como
las
plantas
de
energ√≠a
,
los
aviones
y


las
organizaciones
humanas
nos
han
ayudado
a
entender
esta
necesidad
.
Hemos
visto
que
la


arquitectura
de
los
sistemas
de
gesti√≥n
de
red
giran
en
torno
a
cinco
componentes
clave
:
(
1
)


una
entidad
gestora
de
red
,
(
2
)
un
conjunto
de
dispositivos
remotos
gestionados
(
desde
la


entidad
gestora
)
,
(
3
)
las
Bases
de
la
informaci√≥n
de
gesti√≥n
(
MIB
)
disponibles
en
estos
dis-


positivos
,
que
contienen
datos
acerca
de
la
operaci√≥n
y
el
estado
de
los
dispositivos
,
(
4
)


agentes
remotos
que
comunican
la
informaci√≥n
de
la
MIB
y
que
llevan
a
cabo
acciones
bajo


el
control
de
la
entidad
gestora
de
red
y
(
5
)
un
protocolo
para
la
comunicaci√≥n
entre
la
enti-


dad
gestora
y
los
dispositivos
remotos
.


Ac
o
n
t
i
n
u
a
c
i
√≥
n
 
h
e
m
o
s
 
p
r
o
f
u
n
d
i
z
a
d
o
 
e
n
 
l
o
s
 
d
e
t
a
l
l
e
s
 
d
e
l
 
e
n
t
o
r
n
o
 
d
e
 
g
e
s
t
i
√≥
n
 
e
s
t
√°
n
d
a
r
 
d
e


Internet
y
en
el
protocolo
SNMP
en
particular
.
Hemos
visto
c√≥mo
SNMP
instancia
los
cinco


componentes
clave
de
una
arquitectura
de
gesti√≥n
de
red
y
hemos
dedicado
un
tiempo


considerable
a
examinar
los
objetos
MIB
,
la
SMI
(
el
lenguaje
de
definici√≥n
de
datos
para


especificar
las
bases
MIB
)
y
el
propio
protocolo
SNMP
.
Dado
que
SMI
y
ASN.1
est√°n
estre-


apellido::=
OCTET
STRING


codigo::=
INTEGER


{
codigo
,
259
}


{
apellido
,
"
smith
"
}


M√≥dulo
de
declaraciones


de
tipos
de
datos
escrito


en
ASN.1


Instancias
de
tipos
de
datos


especificados
en
el
m√≥dulo


Reglas
b√°sicas
de
codificaci√≥n


(
BER
)


Flujo
de
bytes


transmitido


3


1


2


2


h


t


i


m


s


5


4


Figura
9.9
‚Ä¢
Ejemplo
de
codificaci√≥n
BER
.


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
761762
CAP√çTULO
9
‚Ä¢
GESTI√ìN
DE
REDES


chamente
ligados
y
que
ASN.1
desempe√±a
un
papel
clave
en
la
capa
de
presentaci√≥n
del


modelo
de
referencia
de
siete
capas
ISO
/
OSI
,
hemos
examinado
brevemente
ASN.1
.
Quiz√°


m√°s
importante
que
los
detalles
del
propio
ASN.1
fue
la
necesidad
de
proporcionar
la
tra-


ducci√≥n
entre
los
formatos
de
datos
espec√≠ficos
de
las
m√°quinas
de
una
red
.
Aunque
algunas


arquitecturas
de
red
reconocen
expl√≠citamente
la
importancia
de
este
servicio
disponiendo


de
una
capa
de
presentaci√≥n
,
esta
capa
est√°
ausente
en
la
pila
de
protocolos
de
Internet
.


Tambi√©n
merece
la
pena
destacar
que
hay
muchos
temas
sobre
la
gesti√≥n
de
red
que


hemos
decidido
no
abordar
,
temas
tales
como
la
identificaci√≥n
y
gesti√≥n
de
fallos
,
la
detec-


ci√≥n
proactiva
de
anomal√≠as
,
la
correlaci√≥n
de
alarmas
y
las
muchas
cuestiones
sobre
la
ges-


ti√≥n
de
servicios
(
por
ejemplo
,
en
oposici√≥n
a
la
gesti√≥n
de
red
)
.
Aunque
importantes
,
estos


temas
merecen
su
propio
libro
,
por
lo
que
el
lector
puede
recurrir
a
las
referencias
dadas
en


la
Secci√≥n
9.1
.


Problemas
y
cuestiones
de
repaso


Cap√≠tulo
9
Problemas
de
repaso


SECCI√ìN
9.1


R1
.
¬ø
Por
qu√©
se
beneficia
un
administrador
de
red
de
disponer
de
herramientas
de
gesti√≥n


de
red
?
Describa
cinco
escenarios
.


R2
.
¬ø
Cu√°les
son
las
cinco
√°reas
de
gesti√≥n
de
red
definidas
por
la
organizaci√≥n
ISO
?


R3
.
¬ø
Cu√°l
es
la
diferencia
entre
gesti√≥n
de
red
y
gesti√≥n
de
servicios
?


SECCI√ìN
9.2


R4
.
Defina
los
siguientes
t√©rminos
:
entidad
gestora
,
dispositivo
gestionado
,
agente
de
ges-


ti√≥n
,
MIB
,
protocolo
de
gesti√≥n
de
red
.


SECCI√ìN
9.3


R5
.
¬ø
Cu√°l
es
el
papel
de
la
SMI
en
la
gesti√≥n
de
red
?


R6
.
¬ø
Cu√°l
es
una
diferencia
importante
entre
un
mensaje
solicitud-respuesta
y
un
mensaje


TRAP
en
SNMP
?


R7
.
¬ø
Cu√°les
son
los
siete
tipos
de
mensajes
utilizados
en
SNMP
?


R8
.
¬ø
Qu√©
es
un
‚Äú
motor
SNMP
‚Äù
?


SECCI√ìN
9.4


R9
.
¬ø
Cu√°l
es
el
prop√≥sito
del
√°rbol
de
identificaci√≥n
de
objetos
de
ASN.1
?


R10
.
¬ø
Cu√°l
es
el
papel
de
ASN.1
en
la
capa
de
presentaci√≥n
del
modelo
de
referencia
ISO/


OSI
?


R11
.
¬ø
Tiene
Internet
una
capa
de
presentaci√≥n
?
Si
no
la
tiene
,
¬ø
c√≥mo
se
tratan
las
diferen-


cias
entre
las
arquitecturas
de
m√°quinas
,
por
ejemplo
,
la
distinta
representaci√≥n
de
los


enteros
en
las
distintas
m√°quinas
?


R12
.
¬ø
Cu√°l
es
el
significado
de
la
codificaci√≥n
TLV
?


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
762PREGUNTAS
PARA
LA
DISCUSI√ìN
763


Problemas


P1
.
Considere
las
dos
formas
en
que
tiene
lugar
la
comunicaci√≥n
entre
una
entidad
gestora


y
un
dispositivo
gestionado
:
el
modo
solicitud-respuesta
y
TRAP
.
¬ø
Cu√°les
son
las
ven-


tajas
y
los
inconvenientes
de
estos
dos
m√©todos
,
en
t√©rminos
de
(
1
)
costes
,
(
2
)
tiempo


de
notificaci√≥n
cuando
se
producen
sucesos
excepcionales
y
(
3
)
robustez
con
respecto


a
los
mensajes
perdidos
entre
la
entidad
gestora
y
el
dispositivo
?


P2
.
En
la
Secci√≥n
9.3
hemos
visto
que
era
preferible
transportar
mensajes
SNMP
en
data-


gramas
UDP
no
fiables
.
¬ø
Por
qu√©
cree
que
los
dise√±adores
de
SNMP
eligieron
UDP


en
lugar
de
TCP
como
protocolo
de
transporte
para
SNMP
?


P3
.
¬ø
Qu√©
es
el
identificador
de
objeto
ASN.1
para
el
protocolo
RMON
(
v√©ase
la
Figura


9.3
)
?


P4
.
Suponga
que
trabaja
en
una
empresa
de
Estados
Unidos
que
desea
desarrollar
su
pro-


pia
MIB
para
gestionar
una
l√≠nea
de
productos
.
¬ø
D√≥nde
se
registrar√≠a
dentro
del
√°rbol


de
identificaci√≥n
de
objetos
(
Figura
9.3
)
?
(
Sugerencia
:
tendr√°
que
investigar
en
los


RFC
u
otros
documentos
para
poder
responder
a
esta
pregunta
.
)


P5
.
Recuerde
de
la
Secci√≥n
9.3.2
que
una
empresa
privada
puede
crear
sus
propias
varia-


bles
MIB
bajo
la
rama
private
1.3.6.4
.
Suponga
que
IBM
deseara
crear
una
MIB


para
el
software
de
su
servidor
web
.
¬ø
Cu√°l
ser√≠a
el
siguiente
cualificador
OID
despu√©s


de
1.3.6.1.4
?
(
Para
responder
a
esta
pregunta
,
tendr√°
que
consultar
[
IANA
2009b
]
)
.


Realice
una
b√∫squeda
en
la
Web
y
vea
si
puede
encontrar
si
existe
tal
MIB
en
un
ser-


vidor
de
IBM
.


P6
.
¬ø
Por
qu√©
cree
que
la
longitud
precede
al
valor
en
una
codificaci√≥n
TLV
(
en
lugar
de


que
ir
a
continuaci√≥n
del
valor
)
?


P7
.
Considere
la
Figura
9.9
.
¬ø
Cu√°l
ser√≠a
la
codificaci√≥n
BER
de
{
codigo,276
}
{
ape-


llido,‚ÄúMarco
‚Äù
}
?


P8
.
Considere
la
Figura
9.9
.
¬ø
Cu√°l
ser√≠a
la
codificaci√≥n
BER
de
{
codigo,160
}
{
ape-


llido,‚ÄúDario
‚Äù
}
?


Preguntas
para
la
discusi√≥n


D1
.
Adem√°s
de
la
planta
de
energ√≠a
el√©ctrica
o
la
cabina
de
un
avi√≥n
,
indique
una
analog√≠a


de
un
sistema
distribuido
complejo
que
necesite
ser
controlado
.


D2
.
Considere
el
escenario
de
la
Secci√≥n
9.1
.
¬ø
Qu√©
otras
actividades
cree
que
un
adminis-


trador
de
red
puede
desear
monitorizar
?
¬ø
Por
qu√©
?


D3
.
Lea
el
documento
RFC
789
.
¬ø
C√≥mo
podr√≠a
haberse
evitado
la
ca√≠da
de
ARPAnet
de


1980
(
o
c√≥mo
podr√≠a
haberse
simplificado
su
recuperaci√≥n
)
si
los
administradores
de


ARPAnet
hubieran
dispuesto
de
las
herramientas
de
gesti√≥n
de
red
actuales
?


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
763764


¬ø
Por
qu√©
decidi√≥
especializarse
en
el
campo
de
las
redes
?


Siempre
me
ha
fascinado
el
construir
todo
tipo
de
cosas
,
desde
que
me
dediqu√©
a
introducir
horquillas


del
pelo
en
los
enchufes
cuando
era
un
ni√±o
.
Poco
a
poco
fui
desarrollando
un
inter√©s
en
los
equipos


de
sonido
durante
mi
adolescencia
,
fabricando
sistemas
de
sonido
para
grupos
de
rock
que
parec√≠an
lo


suficientemente
potentes
como
para
pulverizar
el
hormig√≥n
.
Mientras
estaba
en
la
universidad
,
traba-


jaba
reparando
televisiones
y
equipos
de
radio
(
principalmente
equipos
de
sonido
)
y
me
sent√≠
intere-


sado
por
las
computadoras
y
por
todo
aquello
que
fuera
digital
,
incluyendo
tanto
el
hardware
como
el


software
.
Comenc√©
a
tratar
de
interconectar
todo
tipo
de
equipos
extra√±os
.
Primero
,
me
dediqu√©
a


conectar
perif√©ricos
con
procesadores
.
Despu√©s
unos
sistemas
con
otros
.
El
campo
de
la
redes
es
la
m√°s


evolucionada
de
las
interfaces
y
,
actualmente
,
Internet
es
la
m√°s
evolucionada
de
las
redes
.


¬ø
En
qu√©
consisti√≥
su
primer
trabajo
en
la
industria
de
las
computadoras
?
¬ø
A
qu√©
se
dedicaba
?


La
mayor
parte
de
mis
primeros
a√±os
de
profesi√≥n
la
pas√©
en
la
universidad
de
Purdue
.
A
lo
largo
del


tiempo
me
toc√≥
impartir
formaci√≥n
en
todos
los
cursos
que
definen
el
curr√≠culum
de
los
estudiantes
de


primer
ciclo
en
Ingenier√≠a
Inform√°tica
y
El√©ctrica
.
Mi
trabajo
inclu√≠a
dise√±ar
nuevos
cursos
dedicados


a
los
temas
entonces
nacientes
del
hardware
y
el
software
de
microprocesadores
.
Por
ejemplo
,
duran-


te
un
semestre
,
nuestra
clase
ten√≠a
que
dise√±ar
una
computadora
a
partir
de
los
chips
componentes


construy√©ndola
durante
las
pr√°cticas
de
laboratorio
del
curso
;
uno
de
los
equipos
se
encargaba
de
la


unidad
central
de
proceso
,
otro
del
subsistema
de
memoria
y
otro
del
subsistema
de
E
/
S
,
etc.
Al
semes-


tre
siguiente
,
escrib√≠amos
el
software
del
sistema
para
el
hardware
que
hab√≠amos
construido
.


Fue
m√°s
o
menos
al
tiempo
que
comenc√©
a
trabajar
en
tareas
de
direcci√≥n
en
los
sistemas
infor-


m√°ticos
del
campus
,
encarg√°ndome
de
informar
al
rector
como
director
de
servicios
de
usuario
de
los


sistemas
de
computadoras
acad√©micos
.


¬ø
Qu√©
parte
de
su
trabajo
es
la
que
representa
un
mayor
desaf√≠o
?


Seguir
estando
al
d√≠a
de
todos
los
cambios
,
tanto
en
el
campo
t√©cnico
como
en
el
de
los
negocios
.
Soy


un
director
con
un
perfil
bastante
t√©cnico
y
cada
vez
me
es
m√°s
dif√≠cil
estar
actualizado
en
lo
que
res-


pecta
a
los
avances
t√©cnicos
experimentados
en
nuestro
sector
.
Mi
papel
tambi√©n
me
exige
seguir
los


cambios
que
se
producen
en
el
entorno
empresarial
,
como
por
ejemplo
en
las
fusiones
y
adquisiciones
.


Jeff
Case


Jeff
Case
es
el
fundador
y
director
t√©cnico
de
SNMP
Research
,
Inc
.


SNMP
(
Simple
Network
Management
Protocol
)
es
un
productor


l√≠der
de
elaboraci√≥n
de
est√°ndares
de
Internet
y
productos


basados
en
est√°ndares
para
la
gesti√≥n
de
redes
.
Jeff
se
gradu√≥


en
Educaci√≥n
Industrial
y
Tecnolog√≠a
de
Ingenier√≠a
El√©ctrica
y


obtuvo
los
masters
en
Educaci√≥n
Industrial
y
en
Ingenier√≠a


El√©ctrica
en
la
Universidad
de
Purdue
.
Se
doctor√≥
en
Educaci√≥n


T√©cnica
en
la
Universidad
de
Illinois
,
Urbana-Champaign
.


UNA
ENTREVISTA
CON
...


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
764¬øCu√°l
cree
qu√©
es
el
futuro
de
las
redes
y
de
Internet
?


Un
futuro
de
crecimiento
sostenido
.
Una
velocidad
cada
vez
mayor
.
Una
ubicuidad
creciente
.
Un
con-


tenido
en
expansi√≥n
.
Una
mayor
tensi√≥n
entre
anarqu√≠a
y
direcci√≥n
centralizada
.
M√°s
correo
basura
.


M√°s
herramientas
para
combatir
el
correo
basura
.
M√°s
problemas
de
seguridad
.
M√°s
soluciones
de


seguridad
.
Finalmente
,
debemos
estar
preparados
para
lo
completamente
inesperado
.


¬ø
Qu√©
personas
le
han
inspirado
profesionalmente
?


Mi
difunto
padre
,
que
fue
un
hombre
de
negocios
de
√©xito
;
Dilbert
;
los
doctores
Vint
Cerf
,
Jon
Postel
,


Marshall
Rose
y
Chuck
Davin
,
que
son
personas
bien
conocidas
en
el
sector
de
Internet
;
Bill
Seifert
,


ahora
socio
de
capital
riesgo
;
el
doctor
Rupert
Evans
,
mi
profesor
de
t√©sis
;
mi
esposa
,
que
trabaja
con-


migo
en
la
empresa
y
,
en
√∫ltimo
lugar
,
pero
no
por
ello
menos
importante
,
Jes√∫s
.


He
o√≠do
que
tiene
usted
una
notable
colecci√≥n
de
‚Äú
citas
‚Äù
.
Cuando
trabajaba
como
profesor
,
¬ø
sol√≠a


ilustrar
sus
ense√±anzas
con
esas
citas
?


‚Äú
Un
ejemplo
es
m√°s
valioso
que
dos
libros
‚Äù
(
creo
que
es
de
Gauss
)
.


‚Äú
En
ocasiones
,
existe
una
distancia
entre
la
teor√≠a
y
la
pr√°ctica
.
La
distancia
entre
la
teor√≠a
y
la


pr√°ctica
en
teor√≠a
no
es
tan
grande
como
la
distancia
entre
la
teor√≠a
y
la
pr√°ctica
en
la
pr√°ctica
.
‚Äù
(
No


tengo
ni
idea
de
qui√©n
es
esta
cita
.
)


¬ø
Cu√°les
han
sido
los
mayores
obst√°culos
a
la
hora
de
desarrollar
los
est√°ndares
Internet
?


El
dinero
.
Los
factores
pol√≠ticos
.
El
ego
.
Los
errores
de
liderazgo
.


¬ø
Cu√°l
ha
sido
la
utilizaci√≥n
m√°s
sorprendente
de
la
tecnolog√≠a
SNMP
?


Todas
ellas
.
Yo
llegu√©
a
involucrarme
en
las
cuestiones
de
gesti√≥n
de
Internet
con
el
√∫nico
objeto
de


satisfacer
mis
propias
necesidades
de
supervivencia
.
Necesitaba
disponer
de
algunas
buenas
herra-


mientas
para
gestionar
la
infraestructura
de
red
de
mi
organizaci√≥n
.
El
gran
√©xito
debido
a
la
existen-


cia
de
muchas
otras
personas
que
necesitaban
resolver
problemas
similares
es
atribu√≠ble
a
la
intuici√≥n
,


a
la
buena
suerte
y
al
trabajo
duro
.
Lo
importante
es
que
conseguimos
dar
muy
pronto
con
la
arqui-


tectura
correcta
.


765


M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
765M09_KURO9675_05_SE_CH09.qxd
 
21/3/10
 
19:37
 
P√°gina
766Referencias


767


Aclaraci√≥n
sobre
los
URL
:
en
las
referencias
que
se
proporcionan
a
continuaci√≥n
hemos
incluido
los


URL
a
p√°ginas
web
,
documentos
exclusivamente
web
y
otros
materiales
que
no
hayan
sido


publicados
en
una
conferencia
o
revista
(
siempre
que
hemos
podido
localizar
un
URL
para
dicho


material
)
.
A
diferencia
de
las
ediciones
anteriores
de
este
libro
,
no
hemos
incluido
los
URL


correspondientes
a
conferencias
y
publicaciones
en
revistas
,
ya
que
dichos
documentos
normalmente


pueden
encontrarse
utilizando
el
motor
de
b√∫squeda
disponible
en
el
sitio
web
de
una
conferencia


(
por
ejemplo
,
los
documentos
de
todas
las
conferencias
y
workshops
de
ACM
Sigcomm
est√°n


disponibles
en
http://www.acm.org/sigcomm
)
,
o
a
trav√©s
de
una
suscripci√≥n
digital
.
Todos
los
URL


que
se
proporcionan
a
continuaci√≥n
se
validaron
(
y
probaron
)
en
enero
de
2009
,
por
lo
que
es
posible


que
actualmente
alguno
est√©
desactualizado
.
Por
favor
consulte
la
versi√≥n
en
l√≠nea
de
este
libro
(
http:/


/www.awl.com
/
kurose-ross
)
para
obtener
la
bibliograf√≠a
actualizada
.


Aclaraci√≥n
sobre
los
documentos
RFC
(
Request
for
Comments
)
de
Internet
:
hay
disponibles


copias
de
los
documentos
RFC
de
Internet
en
muchos
sitios
.
El
editor
de
documentos
RFC
de
la


Internet
Society
(
el
organismo
que
supervisa
los
RFC
)
mantiene
el
sitio
http://www.rfc-editor.org
.
En


este
sitio
es
posible
buscar
un
RFC
espec√≠fico
por
t√≠tulo
,
n√∫mero
o
autores
,
y
muestra
las


actualizaciones
de
los
RFC
localizados
.
Los
RFC
de
Internet
pueden
estar
actualizados
o
haber


quedado
obsoletos
debido
a
la
existencia
de
documentos
posteriores
.
Nuestro
sitio
favorito
para


consultar
los
RFC
es
el
original
:
http://www.rfc-editor.org
.


[
3Com
Addressing
2009
]
3Com
Corp
.
,
‚Äú
White
paper
:
Understanding
IP
addressing
:
Everything
you


ever
wanted
to
know
‚Äù
,
http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf


[
3GPP
2009
]
P√°gina
principal
de
Third
Generation
Partnership
Project
:
http://www.3gpp.org/


[
802.11
Security
2009
]
The
Unofficial
802.11
Security
Web
Page
,
http://www.drizzle.com/~aboba/


IEEE/


[
Abitz
1993
]
P.
Albitz
y
C.
Liu
,
DNS
and
BIND
,
O‚ÄôReilly
&
Associates
,
Petaluma
,
CA
,
1993
.


[
Abramson
1970
]
N.
Abramson
,
‚Äú
The
Aloha
System‚ÄîAnother
Alternative
for
Computer


Communications
‚Äù
,
Proc
.
1970
Fall
Joint
Computer
Conference
,
AFIPS
Conference
,
p√°g.
37
,
1970
.


[
Abramson
1985
]
N.
Abramson
,
‚Äú
Development
of
the
Alohanet
‚Äù
,
IEEE
Transactions
on
Information


Theory
,
V
ol
.
IT-31
,
N¬∫
3
(
marzo
1985
)
,
p√°gs
.
119‚Äì123
.


[
Ahn
1995]J.
S.
Ahn
,
P.
B.
Danzig
,
Z.
Liu
y
Y
.
Yan
,
‚Äú
Experience
with
TCP
Vegas
:
Emulation
and


Experiment
‚Äù
,
Proc
.
1995
ACM
SIGCOMM(Boston
,
MA
,
agosto
1995
)
,
p√°gs
.
185‚Äì195
.


[
Akamai
2009
]
P√°gina
principal
de
Akamai
:
http://www.akamai.com
.


[
Akella
2003
]
A.
Akella
,
S.
Seshan
,
A.
Shaikh
;
‚Äú
An
empirical
Evaluation
of
Wide-area
Internet


Bottlenecks
‚Äù
,
Proc
.
2003
ACM
Internet
Measurement
Conf
.
(
Miami
FL
,
noviembre
2003
)
.


[
Alvestrand
1997
]
H.
Alvestrand
,
‚Äú
Object
Identifier
Registry
‚Äù
,
http://www.alvestrand.no/objectid/


[
Anderson
1995
]
J.
B.
Andersen
,
T.
S.
Rappaport
,
S.
Yoshida
,
‚Äú
Propagation
Measurements
and


Models
for
Wireless
Communications
Channels
‚Äù
,
IEEE
Communications
Magazine
(
enero
1995
)
,


p√°gs
.
42‚Äì49
.


[
Aperjis
2008
]
C.
Aperjis
,
M.J.
Freedman
,
R.
Johari
,
‚Äú
Peer-assisted
Content
Sistribution
with
Prices
‚Äù
,


Proc
.
ACM
CoNEXT‚Äô08,(Madrid
,
diciembre
2008
)
.


[
Appenzeller
2004
]
G.
Appenzeller
,
I.
Keslassy
,
N.
McKeown
,
‚Äú
Sizing
Router
Buffers
‚Äù
,
Proc
.
2004


ACM
SIGCOMM
(
Portland
,
OR
,
agosto
2004
)
.


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
767[ARIN
1996
]
ARIN
,
‚Äú
IP
allocation
report
‚Äù
,
ftp://rs.arin.net/netinfo/ip_network_allocations


[
Ash
1998
]
G.
R.
Ash
,
Dynamic
Routing
in
Telecommunications
Networks
,
McGraw
Hill
,
NY
,
NY
,


1998
.


[
ASO-ICANN
2009
]
The
Address
Supporting
Organization
home
page
,
http://www.aso
.icann.org


[
AT&T
SLM
2008]AT&T
Business
,
‚Äú
AT&T
Enterprise
Hosting
Services
Service
Guide
‚Äù
,
http:/


/www.att.com
/
abs
/
serviceguide
/
docs
/
eh_sg.pdf


[
Atheros
2009
]
Atheros
Communications
Inc
.
‚Äú
Atheros
AR5006
WLAN
Chipset
Product
Bulletins
‚Äù
,


http://www.atheros.com/pt/AR5006Bulletins.htm


[
Ayanoglu
1995
]
E.
Ayanoglu
,
S.
Paul
,
T.
F.
La
Porta
,
K.
K.
Sabnani
,
R.
D.
Gitlin
,
‚Äú
AIRMAIL
:
A


Link-Layer
Protocol
for
Wireless
Networks
‚Äù
,
ACM
ACM
/
Baltzer
Wireless
Networks
Journal
,
1
:


47‚Äì60
,
febrero
1995
.


[
Bakre
1995
]
A.
Bakre
,
B.
R.
Badrinath
,
‚Äú
I-TCP
:
Indirect
TCP
for
Mobile
Hosts
‚Äù
,
Proc
.
1995
Int
.


Conf
.
on
Distributed
Computing
Systems
(
ICDCS
)
,
mayo
1995
,
p√°gs
.
136‚Äì143
.


[
Balakrishnan
1997
]
H.
Balakrishnan
,
V
.
Padmanabhan
,
S.
Seshan
,
R.
Katz
,
‚Äú
A
Comparison
of


Mechanisms
for
Improving
TCP
Performance
Over
Wireless
Links
‚Äù
,
IEEE
/
ACM
Transactions
on


Networking
Vo
l
.
 
5
,
 
N
¬∫
 
6
 
(
d
i
c
i
e
m
b
r
e
 
1
9
9
7
)
,


[
Baran
1964
]
P.
Baran
,
‚Äú
On
Distributed
Communication
Networks
‚Äù
,
IEEE
Transactions
on


Communication
Systems
,
marzo
1964
.
Rand
Corporation
Technical
report
with
the
same
title


(
Memorandum
RM-3420-PR
,
1964
)
.
http://www.rand.org/publications/RM/RM3420/


[
Bardwell
2004
]
J.
Bardwell
,
‚Äú
You
Believe
You
Understand
What
You
Think
I
Said
.
.
.
The
Truth


About
802.11
Signal
And
Noise
Metrics
:
A
Discussion
Clarifying
Often-Misused
802.11
WLAN


Terminologies
‚Äù
,
http://www.connect802.com/download/techpubs/2004/you_believe_D100201.pdf


[
Baset
2006
]
S.
A.
Basset
and
H.
Schulzrinne
,
‚Äú
An
analysis
of
the
Skype
peer-to-peer
Internet


Telephony
Protocol
‚Äù
,
Proc
.
2006
IEEE
Infocom
(
Barcelona
,
Espa√±a
,
abril
2006
)
.


[
BBC
2001
]
BBC
news
online
‚Äú
A
Small
Slice
of
Design
‚Äù
,
abril
2001
,
http://news.bbc.co.uk/2/hi/


science
/
nature/1264205.stm


[
BBC
Multicast
2009
]
BB
,
‚Äú
BBC
Multicast
Trial
‚Äù
http://support.bbc.co.uk/multicast/


[
Beheshti
2008
]
N.
Beheshti
,
Y
.
Ganjali
,
M.
Ghobadi
,
N.
McKeown
,
G.
Salmon
,
‚Äú
Experimental


Study
of
Router
Buffer
Sizing
‚Äù
,
Proc
.
ACM
Internet
Measurement
Conference
,
October
2008
,


Vo
u
l
i
a
g
m
e
n
i
,
 
G
r
e
e
c
e
.


[
Bender
2000
]
P.
Bender
,
P.
Black
,
M.
Grob
,
R.
Padovani
,
N.
Sindhushayana
,
A.
Viterbi
,


‚Äú
CDMA
/
HDR
:
A
bandwidth-efficient
high-speed
wireless
data
service
for
nomadic
users
‚Äù
,
IEEE


Commun
.
Mag
.
,
V
ol
.
38
,
N¬∫
7
(
julio
2000
)
p√°gs
.
70‚Äì77
.


[
Berners-Lee
1989
]
T.
Berners-Lee
,
CERN
,
‚Äú
Information
Management
:
A
Proposal
‚Äù
,
marzo
1989
,


mayo
1990
.
http://www.w3.org/History/1989/proposal.html


[
Berners-Lee
1994
]
T.
Berners-Lee
,
R.
Cailliau
,
A.
Luotonen
,
H.
Frystyk
Nielsen
,
A.
Secret
,
‚Äú
The


World-Wide
Web
‚Äù
,
Communications
of
the
ACM
,
Vo
l
.
 
3
7
,
 
N
¬∫
 
8
 
(
a
g
o
s
t
o
 
1
9
9
4
)
,
 
p
√°
g
s
.
 
7
6
‚Äì
8
2
.


[
Bernstein
2009
]
D.
Bernstein
,
‚Äú
SYN
Cookies
‚Äù
,
http://cr.yp.to/syncookies.html


[
Bertsekas
1991
]
D.
Bertsekas
,
R.
Gallagher
,
Data
Networks
,
2¬™
ed
.
,
Prentice
Hall
,
Englewood
Cliffs
,


NJ
,
1991
.


[
Bhimani
1996
]
A.
Bhimani
:
‚Äú
Securing
the
Commercial
Internet
‚Äù
,
Communications
of
the
ACM
,
Vo
l
.


39
N¬∫
6
(
marzo
1996
)
,
p√°gs
.
29‚Äì35
.


[
Biddle
2003
]
P.
Biddle
,
P.
England
,
M.
Peinado
,
B.
Willman
,
‚Äú
The
Darknet
and
the
Future
of


Content
Distribution
‚Äù
,
2002
ACM
Workshop
on
Digital
Rights
Management
(
noviembre
2002
,


Washington
,
D.C.
)
http://crypto.stanford.edu/DRM2002/darknet5.doc


[
Biersack
1992
]
E.
W.
Biersack
,
‚Äú
Performance
evaluation
of
forward
error
correction
in
ATM


networks
‚Äù
,
Proc
.
1999
ACM
SIGCOMM
(
Baltimore
,
MD
,
agosto
1992
)
,
p√°gs
.
248‚Äì257
.


768
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
768[BIND
2009
]
Internet
Software
Consortium
page
on
BIND
,
http://www.isc.org/bind.html


[
Bisdikian
2001
]
C.
Bisdikian
,
‚Äú
An
Overview
of
the
Bluetooth
Wireless
Technology
‚Äù
,
IEEE


Communications
Magazine
,
N¬∫
12
(
diciembre
2001
)
,
p√°gs
.
86‚Äì94
.


[
Bishop
2003
]
M.
Bishop
,
Computer
Security
:
Art
and
Science
,
Boston
:
Addison
Wesley
,
Boston


MA
,
2003
.


[
BitTorrent
2009
]
P√°gina
principal
de
BitTorrent.org
:
http://www.bittorrent.org


[
Black
1995
]
U.
Black
,
ATM
Volume
I
:
Foundation
for
Broadband
Networks
,
Prentice
Hall
,
1995
.


[
Blumenthal
2001
]
M.
Blumenthal
,
D.
Clark
,
‚Äú
Rethinking
the
Design
of
the
Internet
:
the
End-to-end


Arguments
vs
.
the
Brave
New
World
‚Äù
,
ACM
Transactions
on
Internet
Technology
,
V
ol
.
1
,
N¬∫
1


(
agosto
2001
)
p√°gs
.
70‚Äì109
.


[
Bochman
1984
]
G.
V
.
Bochmann
,
C.
A.
Sunshine
,
‚Äú
Formal
methods
in
communication
protocol


design
,
‚Äù
IEEE
Transactions
on
Communications
,
V
ol
.
28
,
N¬∫
4
(
abril
1980
)
,
p√°gs
.
624‚Äì631
.


[
Bolot
1994
]
J-C.
Bolot
,
T.
Turletti
,
‚Äú
A
rate
control
scheme
for
packet
video
in
the
Internet
,
‚Äù
Proc
.


1994
IEEE
Infocom
,
p√°gs
.
1216‚Äì1223
.


[
Bolot
1996
]
J-C.
Bolot
,
A.
Vega-Garcia
,
‚Äú
Control
Mechanisms
for
Packet
Audio
in
the
Internet
‚Äù
,


Proc
.
1996
IEEE
Infocom
,
p√°gs
.
232‚Äì239
.


[
Bradner
1996
]
S.
Bradner
,
A.
Mankin
,
IPng
:
Internet
Protocol
Next
Generation
,
Addison-Wesley
,


Reading
,
MA
,
1996
.


[
Brakmo
1995
]
L.
Brakmo
,
L.
Peterson
,
‚Äú
TCP
Vegas
:
End
to
End
Congestion
Avoidance
on
a
Global


Internet
‚Äù
,
IEEE
Journal
of
Selected
Areas
in
Communications
,
V
ol
.
13
,
N¬∫
8
,
p√°gs
.
1465‚Äì1480
,


octubre
1995
.


[
Breslau
2000
]
L.
Breslau
,
E.
Knightly
,
S.
Shenker
,
I.
Stoica
,
H.
Zhang
,
‚Äú
Endpoint
Admission


Control
:
Architectural
Issues
and
Performance
‚Äù
,
Proc
.
2000
ACM
SIGCOMM
(
Estocolmo
,
Suecia
,


agosto
2000
)
.


[
Brodnik
1997
]
A.
Brodnik
,
S.
Carlsson
,
M.
Degemark
,
S.
Pink
,
‚Äú
Small
Forwarding
Tables
for
Fast


Routing
Lookups
‚Äù
,
Proc
.
1997
ACM
SIGCOMM(Cannes
,
Francia
,
octubre
1997
)
,
p√°gs
.
3‚Äì15
.


[
Bush
1945
]
V
.
Bush
,
‚Äú
As
We
May
Think
‚Äù
,
The
Atlantic
Monthly
,
julio
1945
.
http://www.theatlantic
.


com
/
unbound
/
flashbks
/
computer
/
bushf.htm
.


[
Byers
1998
]
J.
Byers
,
M.
Luby
,
M.
Mitzenmacher
,
A
Rege
,
‚Äú
A
digital
fountain
approach
to
reliable


distribution
of
bulk
data
‚Äù
,
Proc
.
1998
ACM
SIGCOMM(Vancouver
,
Canad√°
,
agosto
1998
)
,
p√°gs
.
56‚Äì67
.


[
Cablelabs
2009
]
P√°gina
principal
de
CableLabs
:
http://www.cablelabs.com


[
CacheLogic
2009
]
P√°gina
principal
de
CacheLogic
:
http://www.cachelogic.com


[
Caesar
2005
]
M.
Caesar
,
J
Rexford
,
‚Äú
BGP
Routing
Policies
in
ISP
Networks
‚Äù
,
IEEE
Network


Magazine
,
vol.
19
,
N¬∫
6
(
noviembre
2005
)
.


[
Caldwell
2009
]
C.
Caldwell
,
‚Äú
The
Prime
Pages
‚Äù
,
http://www.utm.edu/research/primes/prove


[
Cardwell
2000
]
N.
Cardwell
,
S.
Savage
,
T.
Anderson
,
‚Äú
Modeling
TCP
Latency
‚Äù
,
Proc
.
2000
IEEE


Infocom
,
(
Tel-Aviv
,
Israel
,
marzo
2000
)
.


[
CASA
2009
]
Center
for
Collaborative
Adaptive
Sensing
of
the
Atmosphere
,
http://www
.casa.umass
.


edu


[
Casado
2007
]
M.
Casado
,
M.
Freedman
,
J.
Pettit
,
J.
Luo
,
N.
McKeown
,
S.
Shenker
,
‚Äú
Ethane
:
Taking


Control
of
the
Enterprise
‚Äù
,
Proc
.
ACM
SIGCOMM
‚Äô
07,(agosto
2007
,
Kyoto
,
Jap√≥n
)
.


[
Casner
1992
]
S.
Casner
,
S.
Deering
,
‚Äú
First
IETF
Internet
Audiocast
‚Äù
,
ACM
SIGCOMM
Computer


Communications
Review
,
Vol
.
22
,
N¬∫
3
(
julio
1992
)
,
p√°gs
.
92‚Äì97
.


[
Ceiva
2009
]
P√°gina
principal
de
Ceiva
:
http://www.ceiva.com/


[
CENS
2009
]
Center
for
Embedded
Network
Sensing
,
http://www.cens.ucla.edu/


[
Cerf
1974
]
V
.
Cerf
y
R.
Kahn
,
‚Äú
A
Protocol
for
Packet
Network
Interconnection
‚Äù
,
IEEE
Transactions


on
Communications
Technology
,
V
ol
.
COM-22
,
N¬∫
5
,
p√°gs
.
627‚Äì641
.


REFERENCIAS
769


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
769[CERT
2001‚Äì09
]
CERT
,
‚Äú
Advisory
2001‚Äì09
:
Statistical
Weaknesses
in
TCP
/
IP
Initial
Sequence


Numbers
‚Äù
,
http://www.cert.org/advisories/CA-2001-09.html


[
CERT
2003‚Äì04
]
CERT
,
‚Äú
CERT
Advisory
CA-2003-04
MS-SQL
Server
Worm
‚Äù
,
http://
www.cert
.


org
/
advisories
/
CA-2003-04.html


[
CERT
2009
]
Centro
de
coordinaci√≥n
del
CERT
:
http://www.cert.org/advisories


[
CERT
Filtering
2009
]
CERT
,
‚Äú
Packet
Filtering
for
Firewall
Systems
‚Äù
,
http://www.cert.org/


tech_tips
/
packet_filtering.html


[
Cert
SYN
1996
]
CERT
,
‚Äú
Advisory
CA-96.21
:
TCP
SYN
Flooding
and
IP
Spoofing
Attacks
‚Äù
,
http:/


/www.cert.org
/
advisories
/
CA-1998-01.html


[
Chao
2001
]
H.
J.
Chao
,
C.
Lam
,
E.
Oki
,
Broadband
Packet
Switching
Technologies‚ÄîA
Practical


Guide
to
ATM
Switches
and
IP
Routers
,
John
Wiley
&
Sons
,
2001
.


[
Chen
2000
]
G.
Chen
,
D.
Kotz
,
‚Äú
A
Survey
of
Context-Aware
Mobile
Computing
Research
‚Äù
,


Technical
Report
TR2000-381
,
Dept
.
of
Computer
Science
,
Dartmouth
College
,
noviembre
2000
.


http://www.cs.dartmouth.edu/reports/TR2000-381.pdf


[
Chen
2006
]
K.-T.
Chen
,
C.-Y
.
Huang
,
P.
Huang
,
C.-L.
Lei
,
‚Äú
Quantifying
Skype
User
Satisfaction
‚Äù
,


Proc
.
2006
ACM
SIGCOMM
(
Pisa
,
Italia
,
septiembre
2006
)
.


[
Cheswick
2000
]
B.
Cheswick
,
H.
Burch
,
S.
Branigan
,
‚Äú
Mapping
and
Visualizing
the
Internet
‚Äù
,
Proc
.


2000
Usenix
Conference
(
junio
2000
,
San
Diego
)
.


[
Chiu
1989]D.
Chiu
,
R.
Jain
,
‚Äú
Analysis
of
the
Increase
and
Decrease
Algorithms
for
Congestion


Avoidance
in
Computer
Networks
‚Äù
,
Computer
Networks
and
ISDN
Systems
,
V
ol
.
17
,
N¬∫
1
,
p√°gs
.


1‚Äì14
.
http://www.cs.wustl.edu/~jain/papers/cong_av.htm


[
Christiansen
2001
]
M.
Christiansen
,
K.
Jeffay
,
D.
Ott
,
F.
D.
Smith
,
‚Äú
Tuning
Red
for
Web
Traffic
‚Äù
,


IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
9
,
N¬∫
3
(
junio
2001
)
,
p√°gs
.
249‚Äì264
.


[
Chuang
2005
]
S.
Chuang
,
S.
Iyer
,
N.
McKeown
,
‚Äú
Practical
Algorithms
for
Performance
Guarantees


in
Buffered
Crossbars
‚Äù
,
Proc
.
2005
IEEE
Infocom
.


[
Cicconetti
2006
]
C.
Cicconetti
,
L.
Lenzini
,
A.
Mingozi
,
K.
Eklund
,
‚Äú
Quality
of
Service
Support
in


802.16
Networks
‚Äù
,
IEEE
Network
Magazine
,
marzo
/
abril
2006
,
p√°gs
.
50‚Äì55
.


[
Cisco
12000
2009
]
Cisco
Systems
Inc
.
,
‚Äú
Cisco
XR
12000
Series
and
Cisco
12000
Series
Routers
‚Äù
,


http://www.cisco.com/en/US/products/ps6342/index.html


[
Cisco
8500
2009
]
Cisco
Systems
Inc
.
,
‚Äú
Catalyst
8500
Campus
Switch
Router
Architecture
‚Äù
,
http:/


/www.cisco.com
/
univercd
/
cc
/
td
/
doc
/
product
/
l3sw/8540
/
rel_12_0
/
w5_6f
/
softcnfg/1cfg8500.pdf


[
Cisco
NAT
2009
]
Cisco
Systems
Inc
.
,
‚Äú
How
NAT
Works
‚Äù
,
http://www.cisco.com/en/US/tech/tk648/


tk361
/
technologies_tech_note09186a0080094831.shtml


[
Cisco
NAPA
2009]Cisco
Systems
Inc
.
,
‚Äú
Cisco
Network
Application
Performance
Analysis
(
NAPA
)


Solution
‚Äù
,
http://www.cisco.com/en/US/products/sw/netmgtsw/index.html


[
Cisco
QoS
2009
]
Cisco
Systems
Inc
.
,
‚Äú
Advanced
QoS
Services
for
the
Intelligent
Internet
‚Äù
,
http:/


/www.cisco.com
/
warp
/
public
/
cc
/
pd
/
iosw
/
ioft
/
ioqo
/
tech
/
qos_wp.htm


[
Cisco
Queue
2009
]
Cisco
Systems
Inc
.
,
‚Äú
Congestion
Management
Overview
‚Äù
http://www
.cisco
.


com
/
en
/
US
/
docs
/
ios/12_2
/
qos
/
configuration
/
guide
/
qcfconmg.html


[
Cisco
Security
2009
]
Cisco
Systems
Inc
.
,
‚Äú
Why
You
Need
a
Firewall
‚Äù
,
http://www.cisco
.com
/
en/


US
/
products
/
sw
/
secursw
/
ps743
/
products_user_guide_chapter09186a008007f303.html


[
Cisco
Switches
2009
]
Cisco
Systems
Inc
,
‚Äú
Multiservice
Switches
‚Äù
,
http://www.cisco.com/warp/


public
/
cc
/
pd
/
si
/
index.shtml


[
Cisco
SYN
2009
]
Cisco
Systems
Inc
.
,
‚Äú
Defining
Strategies
to
Protect
Against
TCP
SYN
Denial
of


Service
Attacks
‚Äù
,
http://www.cisco.com/en/US/tech/tk828/technologies_tech
_


note09186a00800f67d5.shtml


[
Clark
1988
]
D.
Clark
,
‚Äú
The
Design
Philosophy
of
the
DARPA
Internet
Protocols
‚Äù
,
Proc
.
1988
ACM


SIGCOMM
(
Stanford
,
CA
,
agosto
1988
)
.


770
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
770[Clarke
2002
]
I.
Clarke
,
T.
W.
Hong
,
S.
G.
Miller
,
O.
Sandberg
,
B.
Wiley
,
‚Äú
Protecting
Free


Expression
Online
with
Freenet
‚Äù
,
IEEE
Internet
Computing
,
enero‚Äìfebrero
.
2002
,
p√°gs
.
40‚Äì49
.


[
Cohen
1977
]
D.
Cohen
,
‚Äú
Issues
in
Transnet
Packetized
V
oice
Communication
‚Äù
,
Proc
.
Fifth
Data


Communications
Symposium
,
(
Snowbird
,
Utah
,
septiembre
1977
)
p√°gs
.
6‚Äì13
.


[
Cohen
2003
]
B.
Cohen
,
‚Äú
Incentives
to
Build
Robustness
in
BitTorrent
‚Äù
,
First
Workshop
on
the


Economics
of
Peer-to-Peer
Systems
,
Berkeley
,
CA
,
junio
2003
.


[
Cookie
Central
2009
]
P√°gina
principal
de
Cookie
Central
:
http://www.cookiecentral.com/


n_cookie_faq.htm


[
CoolStreaming
2005]X.
Zhang
,
J.
Liu
,
J.
,
B.
Li
y
T.-S.
P.
Yum
,
‚Äú
CoolStreamingDONet/:AD
a
t
a
-


driven
Overlay
Network
for
Peer-to-Peer
Live
Media
Streaming
‚Äù
,
Proc
.
IEEE
INFOCOM
(
marzo


2005
,
Miami
FL
)
.


[
Cormen
2001
]
T.
H.
Cormen
,
Introduction
to
Algorithms
,
2nd
Ed
.
,
MIT
Press
,
Cambridge
,
MA
,


2001
.


[
Crow
1997
]
B.
Crow
,
I.
Widjaja
,
J.
Kim
,
P.
Sakai
,
‚Äú
IEEE
802.11
Wireless
Local
Area
Networks
‚Äù
,


IEEE
Communications
Magazine
,
septiembre
1997
,
p√°gs
.
116‚Äì126
.


[
Crowcroft
1995
]
J.
Crowcroft
,
Z.
Wang
,
A.
Smith
,
J.
Adams
,
‚Äú
A
Comparison
of
the
IETF
and
ATM


Service
Models
‚Äù
,
IEEE
Communications
Magazine
,
nov./
dic
.
1995
,
p√°gs
.
12‚Äì16
.


[
Crowcroft
1999
]
J.
Crowcroft
,
M.
Handley
,
I.
Wakeman
,
Internetworking
Multimedia
,
Morgan-


Kaufman
,
San
Francisco
,
1999
.


[
Cusumano
1998
]
M.
A.
Cusumano
,
D.
B.
Yoffie
,
Competing
on
Internet
Time
:
Lessons
from


Netscape
and
its
Battle
with
Microsoft
,
Free
Press
,
NY
,
NY
,
1998
.


[
Daigle
1991
]
J.
N.
Daigle
,
Queuing
Theory
for
Telecommunications
,
Addison-Wesley
,
Reading
,
MA
,


1991
.


[
Dalal
1978
]
Y.
 
D
a
l
a
l
,
 
R
.
 
M
e
t
c
a
l
f
e
,
 
‚Äú
R
e
v
e
r
s
e
 
P
a
t
h
 
F
o
r
w
a
r
d
i
n
g
 
o
f
 
B
r
o
a
d
c
a
s
t
 
P
a
c
k
e
t
s
‚Äù
,


Communications
of
the
ACM
,
V
ol
.
21
,
N¬∫
12
(
diciembre
1978
)
,
p√°gs
.
1040‚Äì1048
.


[
Davie
2000
]
B.
Davie
y
Y
.
Rekhter
,
MPLS
:
Technology
and
Applications
,
Morgan
Kaufmann
Series


in
Networking
,
2000
.


[
Davies
2004
]
G.
Davies
,
F.
Kelly
,
‚Äú
Network
Dimensioning
,
Service
Costing
,
and
Pricing
in
a
Packet-


switched
Environment
‚Äù
,
Telecommunications
Policy
,
V
ol
.
28
(
N¬∫
4
)
,
p√°gs
.
391‚Äì412
.


[
DEC
1990
]
Digital
Equipment
Corporation
,
‚Äú
In
Memoriam
:
J.
C.
R.
Licklider
1915‚Äì1990
‚Äù
,
SRC


Research
Report
61
,
agosto
1990
.
http://www.memex.org/licklider.pdf


[
DeClercq
2002
]
J.
DeClercq
,
O.
Paridaens
,
‚Äú
Scalability
Implications
of
Virtual
Private
Networks
‚Äù
,


IEEE
Communications
Magazine
,
V
ol
.
40
N¬∫
5
(
mayo
2002
)
,
p√°gs
.
151‚Äì157
.


[
Demers
1990]A.
Demers
,
S.
Keshav
,
S.
Shenker
,
‚Äú
Analysis
and
Simulation
of
a
Fair
Queuing


Algorithm
‚Äù
,
Internetworking
:
Research
and
Experience
,
Vo
l
.
 
1
,
 
N
¬∫
 
1
,
 
1
9
9
0
,
 
p
√°
g
s
.
 
3
‚Äì
2
6
.


[
Denning
1997
]
D.
Denning
(
Editor
)
,
P.
Denning
(
Preface
)
,
Internet
Besieged
:
Countering


Cyberspace
Scofflaws
,
Addison-Wesley
,
Reading
,
MA
,
1997
.


[
dhc
2009
]
P√°gina
principal
del
grupo
de
trabajo
Configuraci√≥n
din√°mica
de
hosts
de
IETF
:
http:/


/www.ietf.org
/
html.charters
/
dhc-charter.html


[
Diggavi
2004
]
S.
N.
Diggavi
,
N.
Al-Dhahir
,
A.
Stamoulis
,
R.
Calderbank
,
‚Äú
Great
Expectations
:
The


Value
of
Spatial
Diversity
in
Wireless
Networks
‚Äù
,
Proceedings
of
the
IEEE
,
vol.
92
,
N¬∫
2
,
febrero


2004
.


[
Diot
2000
]
C.
Diot
,
B.
N.
Levine
,
B.
Lyles
,
H.
Kassem
,
D.
Balensiefen
,
‚Äú
Deployment
Issues
for
the


IP
Multicast
Service
and
Architecture
‚Äù
,
IEEE
Network
,
Vo
l
.
 
1
4
,
 
N
¬∫
 
1
 
(
e
n
e
r
o
/
f
e
b
r
e
r
o
 
2
0
0
0
)
,
 
p
√°
g
s
.


78‚Äì88
.


[
Dmitiropoulos
2007
]
X.
Dmitiropoulos
,
D.
Krioukov
,
M.
Fomenkov
,
B.
Huffaker
,
Y
.
Hyun
,
KC


Claffy
,
G.
Riley
,
‚Äú
AS
Relationships
:
Inference
and
Validation
‚Äù
,
ACM
Computer
Communication


Review
,
enero
2007
.


REFERENCIAS
771


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
771[Dodge
2009
]
M.
Dodge
,
‚Äú
An
Atlas
of
Cyberspaces
‚Äù
,
http://www.cybergeography.org/atlas/isp_maps
.


html


[
Donahoo
2001
]
M.
Donahoo
,
K.
Calvert
,
TCP
/
IP
Sockets
in
C
:
Practical
Guide
for
Programmers
,


Morgan
Kaufman
,
2001
.


[
Doucer
2002
]
J.
R.
Douceur
,
‚Äú
The
Sybil
Attack
‚Äù
,
First
International
Workshop
on
Peer-to-Peer


Systems
(
IPTPS
‚Äô
02)(Cambridge
,
MA
,
marzo
2002
)
.


[
DSL
2009
]
P√°gina
principal
de
DSL
Forum
,
http://www.dslforum.org/


[
Dhunghel
2008
]
P.
Dhungel
,
D.
Wu
,
B.
Schonhorst
,
K.W.
Ross
,
‚Äú
A
Measurement
Study
of
Attacks


on
BitTorrent
Leechers
‚Äù
,
7th
International
Workshop
on
Peer-to-Peer
Systems
(
IPTPS
2008
)
(
Tampa


Bay
,
febrero
2008
)
.


[
Droms
2002
]
R.
Droms
,
T.
Lemon
,
The
DHCP
Handbook
(
2nd
Edition
)
,
SAMS
Publishing
,
2002
.


[
Edney
2003
]
J.
Edney
y
W.
A.
Arbaugh
,
Real
802.11
Security
:
Wi-Fi
Protected
Access
and
802.11i
,


Addison-Wesley
Professional
,
2003
.


[
Eklund
2002
]
K.
Eklund
,
R.
Marks
,
K.
Stanswood
,
S.
Wang
,
‚Äú
IEEE
Standard
802.16
:
A
Technical


Overview
of
the
Wireless
MAN
Air
Interface
for
Broadband
Wireless
Access
‚Äù
,
IEEE
Communica-


tions
Magazine
,
junio
2002
,
p√°gs
.
98‚Äì107
.


[
Ellis
1987
]
H.
Ellis
,
‚Äú
The
Story
of
Non-Secret
Encryption
‚Äù
,
http://jya.com/ellisdoc.htm


[
Ericsson
2009
]
Ericsson
,
‚Äú
The
Evolution
of
Edge
‚Äù
,
http://www.ericsson.com/technology/


whitepapers
/
broadband
/
evolution_of_EDGE.shtml


[
ESM
2009
]
P√°gina
principal
de
End
System
Multicast
,
http://esm.cs.cmu.edu/


[
Estrin
1997
]
D.
Estrin
,
M.
Handley
,
A.
Helmy
,
P.
Huang
,
D.
Thaler
,
‚Äú
A
Dynamic
Bootstrap


Mechanism
for
Rendezvous-based
Multicast
Routing
‚Äù
,
Proceedings
of
IEEE
Infocom
‚Äô
98(Nueva


York
,
NY
,
abril
1998
)
.


[
Falkner
2007
]
J.
Falkner
,
M.
Piatek
,
J.P.
John
,
A.
Krishnamurthy
,
T.
Anderson
,
‚Äú
Profiling
a
Million


Sser
DHT
‚Äù
,
Proc
.
ACM
Internet
Measurement
Conference
,
noviembre
2007
.


[
Faloutsos
1999
]
C.
Faloutsos
,
M.
Faloutsos
,
P.
Faloutsos
,
‚Äú
What
Does
the
Internet
Look
Like
?


Empirical
Laws
of
the
Internet
Topology
‚Äù
,
Proc
.
1999
ACM
SIGCOMM
(
Boston
,
MA
,
agosto
1999
)
.


[
Feamster
2004
]
N.
Feamster
,
J.
Winick
,
J.
Rexford
,
‚Äú
A
Model
for
BGP
Routing
for
Network


Engineering
‚Äù
,
Proc
.
2004
ACM
SIGMETRICS
(
NY
,
NY
,
junio
2004
)
.


[
Feldman
2005
]
M.
Feldman
J.
Chuang
,
‚Äú
Overcoming
Free-riding
Behavior
in
Peer-to-peer


Systems
‚Äù
,
ACM
SIGecom
Exchanges
,
julio
2005
.


[
Feldmeier
1988
]
D.
Feldmeier
,
‚Äú
Improving
Gateway
Performance
with
a
Routing
Table
Cache
‚Äù
,


Proc
.
1988
IEEE
Infocom
(
Nueva
Orleans
LA
,
marzo
1988
)
.


[
Feldmeier
1995
]
D.
Feldmeier
,
‚Äú
Fast
Software
Implementation
of
Error
Detection
Codes
‚Äù
,


IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
3
,
N¬∫
6
(
diciembre
1995
)
,
p√°gs
.
640‚Äì652
.


[
FIPS
1995
]
Federal
Information
Processing
Standard
,
‚Äú
Secure
Hash
Standard
‚Äù
,
FIPS
Publication


180-1
.
http://www.itl.nist.gov/fipspubs/fip180-1.htm


[
Floyd
1999
]
S.
Floyd
,
K.
Fall
,
‚Äú
Promoting
the
Use
of
End-to-End
Congestion
Control
in
the


Internet
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
6
,
N¬∫
5
(
octubre
1998
)
,
p√°gs
.
458‚Äì472
.


[
Floyd
2000
]
S.
Floyd
,
M.
Handley
,
J.
Padhye
,
J.
Widmer
,
‚Äú
Equation-Based
Congestion
Control
for


Unicast
Applications
‚Äù
,
Proc
.
2000
ACM
SIGCOMM
(
Estocolmo
,
Suecia
,
agosto
2000
)
.


[
Floyd
2001
]
S.
Floyd
,
‚Äú
A
Report
on
Some
Recent
Developments
in
TCP
Congestion
Control
‚Äù
,
IEEE


Communications
Magazine
(
abril
2001
)
,


[
Floyd
2009
]
S.
Floyd
,
‚Äú
References
on
RED
(
Random
Early
Detection
)
Queue
Management
‚Äù
,
http:/


/www.icir.org
/
floyd
/
red.html


[
Floyd
Synchronization
1994
]
S.
Floyd
,
V
.
Jacobson
,
‚Äú
Synchronization
of
Periodic
Routing


Messages
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
2
,
N¬∫
2
(
abril
1997
)
,
p√°gs
.
122‚Äì136
.


772
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
772[Floyd
TCP
1994
]
S.
Floyd
,
‚Äú
TCP
and
Explicit
Congestion
Notification
‚Äù
,
ACM
SIGCOMM


Computer
Communications
Review
,
V
ol
.
24
,
N¬∫
5
,
p√°gs
.
10‚Äì23
,
Oct
.
1994
.


[
Fluhrer
2001
]
S.
Fluhrer
,
I.
Mantin
,
A.
Shamir
,
‚Äú
Weaknesses
in
the
Key
Scheduling
Algorithm
of


RC4
‚Äù
,
Eighth
Annual
Workshop
on
Selected
Areas
in
Cryptography(Toronto
,
Canad√°
,
agosto
2002
)
.


[
Fortz
2000
]
B.
Fortz
,
M.
Thorup
,
‚Äú
Internet
Traffic
Engineering
by
Optimizing
OSPF
Weights
‚Äù
,


Proc
.
2000
IEEE
Infocom
(
Tel
Aviv
,
Israel
,
abril
2000
)
.


[
Fortz
2002
]
B.
Fortz
,
J.
Rexford
,
M.
Thorup
,
‚Äú
Traffic
Engineering
with
Traditional
IP
Routing


Protocols
‚Äù
,
IEEE
Communication
Magazine
,
Oct
.
2002
.


[
Foster
2002
]
I.
Foster
,
‚Äú
The
Grid
:
A
New
Infrastructure
for
21st
Century
Science
‚Äù
,
Physics
Today
,


55(2):42‚Äì47
,
2002
.


[
Fraleigh
2003
]
C.
Fraleigh
,
T.
Tobagi
,
C.
Diot
,
‚Äú
Provisioning
IP
backbone
Networks
to
Support


Latency
Sensitive
Traffic
‚Äù
,
Proc
.
IEEE
Infocom
Conference
(
San
Francisco
,
marzo
2003
)
.


[
France
Telecom
2009
]
Object
Identifier
(
OID
)
repository
,
http://asn1.elibel.tm.fr/oid/


[
Fraleigh
2003
]
C.
Fraleigh
,
F.
Tobagi
,
C.
Diot
,
‚Äú
Provisioning
IP
Backbone
Networks
to
Support


Latency
Sensitive
Traffic
‚Äù
,
Proc
.
2003
IEEE
Infocom
(
San
Francisco
,
CA
,
marzo
2003
)
.


[
Freedman
2004
]
M.
J.
Freedman
,
E.
Freudenthal
,
D.
Mazires
,
‚Äú
Democratizing
Content
Publication


with
Coral
‚Äù
,
USENIX
NSDI
,
2004
.


[
Friedman
1999
]
T.
Friedman
,
D.
Towsley
‚Äú
Multicast
Session
Membership
Size
Estimation
‚Äù
,
Proc
.


1999
IEEE
Infocom
(
Nueva
York
,
USA
,
marzo
1999
)
.


[
Frost
1994
]
J.
Frost
,
‚Äú
BSD
Sockets
:
A
Quick
and
Dirty
Primer
‚Äù
,
http://world.std.com/~jimf/papers/


sockets
/
sockets.html


[
Gallagher
1983
]
R.
G.
Gallagher
,
P.
A.
Humblet
,
P.
M.
Spira
,
‚Äú
A
Distributed
Algorithm
for


Minimum
Weight-Spanning
Trees
‚Äù
,
ACM
Trans
.
on
Programming
Languages
and
Systems
,
1(5
)
,


(
enero
1983
)
,
p√°gs
.
66‚Äì77
.


[
Gao
2001
]
L.
Gao
,
J.
Rexford
,
‚Äú
Stable
Internet
Routing
Without
Global
Coordination
‚Äù
,
IEEE
/
ACM


Trans
.
Networking
,
V
ol
.
9
,
N¬∫
6
(
diciembre
2001
)
,
p√°gs
.
681‚Äì692
.


[
Garces-Erce
2003
]
L.
Garces-Erce
,
K.
W.
Ross
,
E.
Biersack
,
P.
Felber
,
G.
Urvoy-Keller
,
‚Äú
TOPLUS
:


Topology
Centric
Lookup
Service
‚Äù
,
Fifth
Int
.
Workshop
on
Networked
Group
Communications
(
NGC


2003
)
,
(
Munich
,
septiembre
2003
)
http://cis.poly.edu/~ross/papers/TOPLUS.pdf


[
Gartner
2003
]
F.
C.
Gartner
,
‚Äú
A
Survey
of
Self-Stabilizing
Spanning-Tree
Construction


Algorithms
‚Äù
,
Technical
Report
IC/2003/38
,
Swiss
Federal
Institute
of
Technology
(
EPFL
)
,
School
of


Computer
and
Communication
Sciences
,
10
de
junio
de
2003
.
http://ic2.epfl.ch/publications/


documents
/
IC_TECH_REPORT_200338.pdf
.


[
Gauthier
1999
]
L.
Gauthier
,
C.
Diot
y
J.
Kurose
,
‚Äú
End-to-end
Transmission
Control
Mechanisms
for


Multiparty
Interactive
Applications
on
the
Internet
‚Äù
,
Proc
.
1999
IEEE
Infocom
(
Nueva
York
,
NY
,


abril
1999
)
.


[
Giacopelli
1990
]
J.
Giacopelli
,
M.
Littlewood
,
W.
D.
Sincoskie
‚Äú
Sunshine
:
A
high
performance
self-


routing
broadband
packet
switch
architecture
‚Äù
,
1990
International
Switching
Symposium
.
An


extended
version
of
this
paper
appeared
in
IEEE
J.
Selected
.
Areas
in
Communications
,
V
ol
.
9
,
N¬∫
8


(
octubre
1991
)
,
p√°gs
.
1289‚Äì1298
.


[
Girard
1990
]
A.
Girard
,
Routing
and
Dimensioning
in
Circuit-Switched
Networks
,
Addison-Wesley
,


Reading
,
MA
,
1990
.


[
Glitho
1995
]
R.
Glitho
,
S.
Hayes
(
eds
.
)
,
special
issue
on
Telecommunications
Management


Network
,
IEEE
Communications
Magazine
,
Vo
l
.
 
3
3
,
 
N
¬∫
 
3
 
(
m
a
r
z
o
 
1
9
9
5
)
.


[
Glitho
1998
]
R.
Glitho
,
‚Äú
Contrasting
OSI
Systems
Management
to
SNMP
and
TMN
‚Äù
,
Journal
of


Network
and
Systems
Management
,
V
ol
.
6
,
N¬∫
2
(
junio
1998
)
,
p√°gs
.
113‚Äì131
.


[
Gnutella
2009
]
‚Äú
The
Gnutella
Protocol
Specification
,
v0.4
‚Äù
http://www9.limewire.com/developer/


gnutella_protocol_0.4.pdf


REFERENCIAS
773


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
773[Goodman
1997
]
David
J.
Goodman
,
Wireless
Personal
Communications
Systems
,
Prentice-
Hall
,


1997
.


[
Goralski
1999
]
W.
Goralski
,
Frame
Relay
for
High-Speed
Networks
,
John
Wiley
,
Nueva
York
,
1999
.


[
Goralski
2001
]
W.
Goralski
,
Optical
Networking
and
WDM
,
Osborne
/
McGraw-Hill
,
Berkeley
,
CA
,


2001
.


[
Griffin
2009
]
T.
Griffin
,
‚Äú
Interdomain
Routing
Links
‚Äù
,
http://www.cl.cam.ac.uk/~tgg22/


interdomain/


[
Guha
2006
]
S.
Guha
,
N.
Daswani
,
R.
Jain
,
‚Äú
An
Experimental
Study
of
the
Skype
Peer-to-Peer
V
oIP


System
‚Äù
,
Proc
.
Fifth
Int
.
Workshop
on
P2P
Systems(Santa
Barbara
,
CA
,
2006
)
.


[
Guo
2005
]
L.
Guo
,
S.
Chen
,
Z.
Xiao
,
E.
Tan
,
X.
Ding
,
X.
Zhang
,
‚Äú
Measurement
,
Analysis
,
and


Modeling
of
BitTorrent-like
Systems
‚Äù
,
ACM
Internet
Measurement
Conference
(
IMC
)
,
2005
.


[
Gupta
1998
]
P.
Gupta
,
S.
Lin
,
N.
McKeown
.
‚Äú
Routing
lookups
in
hardware
at
memory
access


speeds
‚Äù
,
Proc
.
1998
IEEE
Infocom
(
San
Francisco
,
CA
,
abril
1998
)
,
p√°gs
.
1241‚Äì1248
.


[
Gupta
2001
]
P.
Gupta
,
N.
McKeown
,
‚Äú
Algorithms
for
Packet
Classification
‚Äù
,
IEEE
Network


Magazine
,
V
ol
.
15
,
N¬∫
2
(
Mar./abril
2001
)
,
p√°gs
.
24‚Äì32
.


[
Ha
2008
]
Ha
,
S.
,
Rhee
,
I.
,
L.
Xu
,
‚Äú
CUBIC
:
A
New
TCP-Friendly
High-Speed
TCP
Variant
‚Äù
,
ACM


SIGOPS
Operating
System
Review
,
2008
.


[
Hain
2005
]
T.
Hain
,
‚Äú
A
Pragmatic
Report
on
IPv4
Address
Space
Consumption
‚Äù
,
Internet
Protocol


Journal
,
V
ol
.
8
,
N¬∫
3
.


[
Halabi
2000
]
S.
Halabi
,
Internet
Routing
Architectures
,
2¬™
Ed
.
,
Cisco
Press
,
2000
.


[
Halperin
2008
]
D.
Halperin
,
T.
Heydt-Benjamin
,
B.
Ransford
,
S.
Clark
,
B.
Defend
,
W.
Morgan
,
K.


Fu
,
T.
Kohno
,
W.
Maisel
,
‚Äú
Pacemakers
and
implantable
cardiac
defibrillators
:
Software
radio
attacks


and
zero-power
defenses
‚Äù
,
Proc
.
29th
Annual
IEEE
Symposium
on
Security
and
Privacy
,
mayo
2008
.


[
Hamada
1997
]
T.
Hamada
,
H.
Kamata
,
S.
Hogg
,
‚Äú
An
Overview
of
the
TINA
Management
Architec-


ture
‚Äù
,
Journal
of
Network
and
Systems
Management
,
V
ol
.
5
.
N¬∫
4
(
diciembre
1997
)
;
p√°gs
.
411‚Äì435
.


[
Hei
2007
]
X.
Hei
,
C.
Liang
,
J.
Liang
,
Y
.
Liu
,
K.
W.
Ross
,
‚Äú
A
Measurement
Study
of
a
Large-scale


P2P
IPTV
System
‚Äù
,
IEEE
Trans
.
on
Multimedia
,
diciembre
2007
.


[
Heidemann
1997
]
J.
Heidemann
,
K.
Obraczka
,
J.
Touch
,
‚Äú
Modeling
the
Performance
of
HTTP
over


Several
Transport
Protocols
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
Vo
l
.
 
5
,
 
N
¬∫
 
5
 
(
o
c
t
u
b
r
e
 
1
9
9
7
)
,


p√°gs
.
616‚Äì630
.


[
Held
2001
]
G.
Held
,
Data
Over
Wireless
Networks
:
Bluetooth
,
WAP
,
and
Wireless
LANs
,
McGraw-


Hill
,
2001
.


[
Hersent
2000
]
O.
Hersent
,
D.
Gurle
,
J-P.
Petit
,
IP
Telephony
:
Packet-Based
Multimedia
Communi-


cation
Systems
,
Pearson
Education
Limited
,
Edinburgh
,
2000
.


[
Holland
2001
]
G.
Holland
,
N.
Vaidya
,
V
.
Bahl
,
‚Äú
A
Rate-Adaptive
MAC
Protocol
for
Multi-Hop


Wireless
Networks
‚Äù
,
Proc
.
2001
ACM
Int
.
Conference
of
Mobile
Computing
and
Networking


(
Mobicom01
)
(
Roma
,
Italia
,
julio
2001
)
.


[
Hollot
2002
]
C.V
.
Hollot
,
V
.
Misra
,
D.
Towsley
,
W.
Gong
,
‚Äú
Analysis
and
design
of
controllers
for


AQM
routers
supporting
TCP
flows
‚Äù
,
IEEE
Transactions
on
Automatic
Control
,
V
ol
.
47
,
N¬∫
6
(
junio


2002
)
,
p√°gs
.
945‚Äì959
.


[
Huang
2002
]
C.
Haung
,
V
.
Sharma
,
K.
Owens
,
V
.
Makam
,
‚Äú
Building
Reliable
MPLS
Networks


Using
a
Path
Protection
Mechanism
‚Äù
,
IEEE
Communications
Magazine
,
Vo
l
.
 
4
0
,
 
N
¬∫
 
3
 
(
m
a
r
z
o
 
2
0
0
2
)
,


p√°gs
.
156‚Äì162
.


[
Huang
2005
]
Y.
 
H
u
a
n
g
,
 
R
.
 
G
u
e
r
i
n
,
 
‚Äú
D
o
e
s
 
O
v
e
r-
P
r
o
v
i
s
i
o
n
i
n
g
 
B
e
c
o
m
e
 
M
o
r
e
 
o
r
 
L
e
s
s
 
E
ff
i
c
i
e
n
t
 
a
s


Networks
Grow
Larger
?
‚Äù
,
Proc
.
IEEE
Int
.
Conf
.
Network
Protocols
(
ICNP
)
(
Boston
MA
,
noviembre


2005
)
.


[
Huang
2007
]
C.
Huang
,
Jin
Li
,
K.W.
Ross
,
‚Äú
Can
Internet
V
oD
be
profitable
?
‚Äù
,
Proc
ACM


SIGCOMM
(
Kyoto
,
agosto
2007
)
.


774
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
774[Huang
2008
]
C.
Huang
,
J.
Li
,
Angela
Wang
and
K.W.
Ross
,
‚Äú
Understanding
Hybrid
CDN-P2P
:
Why


Limelight
Needs
its
Own
Red
Swoosh
‚Äù
,
NOSSDA
V
2008
,
Braunschweig
,
Alemania
,
mayo
2008
.


[
Huitema
1998
]
C.
Huitema
,
IPv6
:
The
New
Internet
Protocol
,
2nd
Ed
.
,
Prentice
Hall
,
Englewood


Cliffs
,
NJ
,
1998
.


[
Huston
1999a
]
G.
Huston
,
‚Äú
Interconnection
,
Peering
,
and
Settlements‚ÄîPart
I
‚Äù
,
The
Internet


Protocol
Journal
,
Vo
l
.
 
2
,
 
N
¬∫
 
1
 
(
m
a
r
z
o
 
1
9
9
9
)
.


[
Huston
2001
]
G.
Huston
,
‚Äú
Analyzing
the
Internet
BGP
Routing
Table
‚Äù
,
The
Internet
Protocol


Journal
,
V
ol
.
4
,
N¬∫
1
(
marzo
2001
)
.


[
Huston
2004
]
G.
Huston
,
‚Äú
NAT
Anatomy
:
A
Look
Inside
Network
Address
Translators
‚Äù
,
The


Internet
Protocol
Journal
,
Vo
l
.
 
7
,
 
N
¬∫
 
3
 
(
s
e
p
t
i
e
m
b
r
e
 
2
0
0
4
)
.


[
Huston
2008a
]
G.
Huston
,
‚Äú
Confronting
Ipv4
Address
Exhaustion
‚Äù
,
http://www.potaroo
.net
/
ispcol/


2008-10
/
v4depletion.html


[
Huston
2008b
]
G.
Huston
,
G.
Michaelson
,
‚Äú
IPv6
Deployment
:
Just
where
are
we
?
‚Äù
http://
www
.


potaroo.net/ispcol/2008-04/ipv6.html


[
IAB
2009
]
P√°gina
principal
de
Internet
Architecture
Board
,
http://www.iab.org/


[
IANA
2009a
]
P√°gina
principal
de
Internet
Assigned
Number
Authority
,
http://www.iana.org/


[
IANA
2009b
]
Internet
Assigned
Number
Authority
,
‚Äú
Private
Enterprise
Numbers
‚Äù
http://
www.iana
.


org
/
assignments
/
enterprise-numbers


[
IANA
Protocol
Numbers
2009
]
Internet
Assigned
Numbers
Authority
,
Protocol
Numbers
,
http:/


/www.iana.org
/
assignments
/
protocol-numbers
/
protocol-numbers.xhtml


[
ICANN
2009
]
P√°gina
principal
de
The
Internet
Corporation
for
Assigned
Names
and
Numbers
,


http://www.icann.org


[
IEC
Optical
2009
]
IEC
Online
Education
,
‚Äú
Optical
Access
‚Äù
,
http://www.iec.org/online/tutorials/


opt_acc/


[
IEEE
802
2009
]
P√°gina
principal
del
comit√©
de
est√°ndares
IEEE
802
LAN
/
MAN
:
http:/


/www.ieee802.org/


[
IEEE
802.11
1999
]
IEEE
802.11
,
1999
Edition
(
ISO
/
IEC
8802-11
:
1999
)
IEEE
Standards
for


Informa-tion
Technology‚ÄîTelecommunications
and
Information
Exchange
Between
Systems‚ÄîLocal


and
Metro-politan
Area
Network‚ÄîSpecific
Requirements‚ÄîPart
11
:
Wireless
LAN
Medium
Access


Control
(
MAC
)
and
Physical
Layer
(
PHY
)
Specification
,
http://standards.ieee.org/getieee802/


download/802.11-1999.pdf


[
IEEE
802.11n
]
IEEE
,
‚Äú
IEEE
P802.11‚ÄîTask
Group
N‚ÄîMeeting
Update
:
Status
of
802.11n
‚Äù
http:/


/grouper.ieee.org
/
groups/802/11
/
Reports
/
tgn_update.htm


[
IEEE
802.15
2009
]
P√°gina
principal
del
grupo
de
trabajo
IEEE
802.15
para
WPAN
:
http://grouper
.


ieee.org/groups/802/15/.


[
IEEE
802.16d
2004
]
IEEE
,
‚Äú
IEEE
Standard
for
Local
and
metropolitan
area
networks
,
Part
16
:
Air


Interface
for
Fixed
Broadband
Wireless
Access
Systems
‚Äù
,
http://standards.ieee.org/getieee802/


download/802.16-2004.pdf


[
IEEE
802.16e
2005
]
IEEE
,
‚Äú
IEEE
Standard
for
Local
and
metropolitan
area
networks
,
Part
16
:
Air


Interface
for
Fixed
and
Mobile
Broadband
Wireless
Access
Systems
,
Amendment
2
:
Physical
and


Medium
Access
Control
Layers
for
Combined
Fixed
and
Mobile
Operation
in
Licensed
Bands
and


Corrigendum
1
‚Äù
,
http://standards.ieee.org/getieee802/download/802
.16e-2005.pdf


[
IEEE
802.1q
2005
]
IEEE
,
‚Äú
IEEE
Standard
for
Local
and
Metropolitan
Area
Networks
:
Virtual


Bridged
Local
Area
Networks
‚Äù
,
http://standards.ieee.org/getieee802/download/802
.1Q-2005.pdf


[
IEEE
802.1X
]
IEEE
Std
802.1X-2001
Port-Based
Network
Access
Control
,
http://
standards.ieee
.


org
/
reading
/
ieee
/
std_public
/
description
/
lanman/802.1x-2001_desc.html


[
IEEE
802.3
2009
]
IEEE
,
‚Äú
IEEE
802.3
CSMA
/
CD
(
Ethernet
)
,
‚Äù
http://grouper.ieee.org/groups/802/3/


[
IEEE
802.5
2009
]
P√°gina
principal
de
IEEE
,
IEEE
802.5
,
http://www.ieee802.org/5/www8025org/


REFERENCIAS
775


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
775[IETF
2009
]
P√°gina
principal
de
Internet
Engineering
Task
Force
,
http://www.ietf.org


[
IMAP
2009
]
The
IMAP
Connection
,
http://www.imap.org/


[
Intel
2009
]
Intel
Corp
,
‚Äú
Intel
¬Æ
82544
Gigabit
Ethernet
Controller
‚Äù
http://www.intel.com/design/


network
/
products
/
lan
/
docs/82544_docs.htm


[
Intel
WiMax
2009
]
Intel
Corp
.
,
‚Äú
WiMax
Technology
‚Äù
,
http://www.intel.com/technology/wimax/


index.htm


[
Internet2
Multicast
2009
]
P√°gina
principal
de
Internet2
Multicast
Working
Group
,
http://multicast


.internet2.edu/


[
IPv6
2009
]
P√°gina
principal
de
IPv6.com
,
http://www.ipv6.com/


[
ISC
2009
]
P√°gina
principal
de
Internet
Systems
Consortium
,
http://www.isc.org


[
ISI
1979
]
Information
Sciences
Institute
,
‚Äú
DoD
Standard
Internet
Protocol
‚Äù
,
Internet
Engineering


Note
123
,
diciembre
1979
.
http://www.isi.edu/in-notes/ien/ien123.txt


[
ISO
2009
]
P√°gina
principal
de
la
Organizaci√≥n
Internacional
de
Estandarizaci√≥n
(
ISO
,
International


Organization
for
Standardization
):
http://www.iso.org/


[
ISO
X.680
2002
]
International
Organization
for
Standardization
,
‚Äú
X.680
:
ITU-T
Recommendation


X.680
(
2002
)
Information
Technology‚ÄîAbstract
Syntax
Notation
One
(
ASN.1
):
Specification
of


Basic
Notation
.
‚Äù
http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf


[
ITU
2005
]
International
Telecommunication
Union
,
The
Internet
of
Things
,
2005
,
http://
www.itu
.


int
/
osg
/
spu
/
publications
/
internetofthings
/
InternetofThings_summary.pdf


[
ITU
2009
]
P√°gina
principal
de
ITU
,
http://www.itu.int/


[
ITU
Statistics
2009
]
International
Telecommunications
Union
,
‚Äú
ICT
Statistics
‚Äù
,
http://
www.itu.int/


ITU-D
/
icteye
/
Reports.aspx


[
Iyer
2002
]
S.
Iyer
,
R.
Zhang
,
N.
McKeown
,
‚Äú
Routers
with
a
Single
Stage
of
Buffering
‚Äù
,
Proc
.
2002


ACM
SIGCOMM
(
Pittsburgh
,
PA
,
agosto
2002
)
.


[
Jacobson
1988
]
V
.
Jacobson
,
‚Äú
Congestion
Avoidance
and
Control
‚Äù
,
Proc
.
1988
ACM
SIGCOMM


(
Stanford
,
CA
,
agosto
1988
)
,
p√°gs
.
314‚Äì329
.


[
Jain
1986
]
R.
Jain
,
‚Äú
A
timeout-based
congestion
control
scheme
for
window
flow-controlled


networks
‚Äù
,
IEEE
Journal
on
Selected
Areas
in
Communications
SAC-4
,
7
(
octubre
1986
)
.


[
Jain
1989
]
R.
Jain
,
‚Äú
A
Delay-Based
Approach
for
Congestion
Avoidance
in
Interconnected


Heterogeneous
Computer
Networks
‚Äù
,
ACM
SIGCOMM
Computer
Communications
Review
,
V
ol
.
19
,


N¬∫
5
(
1989
)
,
p√°gs
.
56‚Äì71
.


[
Jain
1994
]
R.
Jain
,
FDDI
Handbook
:
High-Speed
Networking
Using
Fiber
and
Other
Media
,


Addison-Wesley
,
Reading
,
MA
,
1994
.


[
Jain
1996
]
R.
Jain
.
S.
Kalyanaraman
,
S.
Fahmy
,
R.
Goyal
,
S.
Kim
,
‚Äú
Tutorial
Paper
on
ABR
Source


Behavior
‚Äù
,
ATM
Forum/96-1270
,
Oct
.
1996
.
http://www.cse.wustl.edu/~jain/atmf/ftp/atm96-1270.pdf


[
Jaiswal
2003
]
S.
Jaiswal
,
G.
Iannaccone
,
C.
Diot
,
J.
Kurose
,
D.
Towsley
,
‚Äú
Measurement
and


Classification
of
Out-of-Sequence
Packets
in
a
Tier-1
IP
backbone
‚Äù
,
Proc
.
2003
IEEE
Infocom
.


[
Jakobson
1993
]
G.
Jacobson
,
M.
Weissman
,
‚Äú
Alarm
Correlation
‚Äù
,
IEEE
Network
Magazine
,
1993
,


p√°gs
.
52‚Äì59
.


[
Ji
2003
]
P.
Ji
,
Z.
Ge
,
J.
Kurose
,
D.
Towsley
,
‚Äú
A
Comparison
of
Hard-state
and
Soft-state
Signaling


Protocols
‚Äù
,
Proc
.
2003
ACM
SIGCOMM
(
Karlsruhe
,
Alemania
,
agosto
2003
)
.


[
Jiang
2001
]
W.
Jiang
,
J.
Lennox
,
H.
Schulzrinne
,
K.
Singh
,
‚Äú
Towards
Junking
the
PBX
:
Deploying


IP
Telephony
‚Äù
,
NOSSDAV‚Äô01(Port
Jefferson
,
NY
,
junio
2001
)
.


[
Jin
2004
]
C.
Jin
,
D.
X.
We
,
S.
Low
,
‚Äú
FAST
TCP
:
Motivation
,
architecture
,
algorithms
,


performance
‚Äù
,
Proc
.
2004
IEEE
Infocom
(
Hong
Kong
,
marzo
2004
)
.


[
Juniper
2009
]
Juniper
Networks
,
‚Äú
Provider
Network
Management
‚Äù
,
http://www.juniper
.net/


solutions
/
service_provider
/
provider_network_management/


776
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
776[Kaaranen
2001
]
H.
Kaaranen
,
S.
Naghian
,
L.
Laitinen
,
A.
Ahtiainen
,
V
.
Niemi
,
Networks
:


Architecture
,
Mobility
and
Services
,
Nueva
York
:
John
Wiley
&
Sons
,
2001
.


[
Kahn
1978
]
R.
E.
Kahn
,
S.
Gronemeyer
,
J.
Burchfiel
,
R.
Kunzelman
,
‚Äú
Advances
in
Packet
Radio


Technology
‚Äù
,
Proc
.
of
the
IEEE
,
66
,
11
(
noviembre
1978
)
.


[
Kamerman
1997]A.
Kamerman
,
L.
Monteban
,
‚Äú
WaveLAN-II
:
A
High‚ÄìPerformance
Wireless
LAN
for


the
Unlicensed
Band
‚Äù
,
Bell
Labs
Technical
Journal
,
Summer
1997
,
p√°gs
.
118‚Äì133
.


[
Kangasharju
2000
]
J.
Kangasharju
,
K.
W.
Ross
,
J.
W.
Roberts
,
‚Äú
Performance
Evaluation
of


Redirection
Schemes
in
Content
Distribution
Networks
,
‚Äù
Proc
.
5th
Web
Caching
and
Content


Distribution
Workshop
(
Lisboa
,
Portugal
,
mayo
2000
)
.


[
Kar
2000
]
K.
Kar
,
M.
Kodialam
,
T.
V
.
Lakshman
,
‚Äú
Minimum
Interference
Routing
of
Bandwidth


Guaranteed
Tunnels
with
MPLS
Traffic
Engineering
Applications
‚Äù
,
IEEE
J.
Selected
Areas
in


Communications
,
diciembre
2000
.


[
Karol
1987
]
M.
Karol
,
M.
Hluchyj
,
A.
Morgan
,
‚Äú
Input
Versus
Output
Queuing
on
a
Space-
Division


Packet
Switch
‚Äù
,
IEEE
Transactions
on
Communications
,
Vo
l
.
 
3
5
,
 
N
¬∫
 
1
2
,
 
(
d
i
c
i
e
m
b
r
e
 
1
9
8
7
)
,
p√°gs
.


1347‚Äì1356
.


[
Katabi
2002
]
D.
Katabi
,
M.
Handley
,
C.
Rohrs
,
‚Äú
Internet
Congestion
Control
for
Future
High
Band-


width-Delay
Product
Environments
‚Äù
,
Proc
.
2002
ACM
SIGCOMM
(
Pittsburgh
,
PA
,
agosto
2002
)
.


[
Katzela
1995
]
I.
Katzela
,
M.
Schwartz
.
‚Äú
Schemes
for
Fault
Identification
in
Communication


Networks
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
3
,
N¬∫
6
(
diciembre
1995
)
,
p√°gs
.
753‚Äì764
.


[
Kaufman
1995
]
C.
Kaufman
,
R.
Perlman
,
M.
Speciner
,
Network
Security
,
Private
Communication
in


a
Public
World
,
Prentice
Hall
,
Englewood
Cliffs
,
NJ
,
1995
.


[
Kelly
1998
]
F.
P.
Kelly
,
A.
Maulloo
,
D.
Tan
,
‚Äú
Rate
control
for
communication
networks
:
Shadow


prices
,
proportional
fairness
and
stability
‚Äù
,
J.
Operations
Res
.
Soc
.
,
V
ol
.
49
,
N¬∫
3
,
p√°gs
.
237‚Äì252
,


marzo
1998
.


[
Kelly
2003
]
T.
Kelly
,
‚Äú
Scalable
TCP
:
improving
performance
in
high
speed
wide
area
networks
‚Äù
,


ACM
SIGCOMM
Computer
Communications
Review
,
Vo
l
.
 
3
3
,
 
N
¬∫
 
2
 
(
a
b
r
i
l
 
2
0
0
3
)
,
 
p√°gs
.
83‚Äì91
.


[
Keshav
1998
]
S.
Keshav
,
R.
Sharma
,
‚Äú
Issues
and
Trends
in
Router
Design
‚Äù
,
IEEE
Communications


Magazine
,
V
ol
.
36
,
N¬∫
5
(
mayo
1998
)
,
p√°gs
.
144‚Äì151
.


[
Keslassy
2003
]
I.
Keslassy
,
S.
Chuang
,
K.
Yu
,
D.
Miller
,
M.
Horowitz
,
O.
Solgaard
,
McKeown
,


‚Äú
Scaling
Internet
Routers
Using
Optics
‚Äù
,
Proc
.
2003
ACM
SIGCOMM
(
Karlsruhe
,
Alemania
,
agosto


2003
)
.


[
Kilkki
1999
]
K.
Kilkki
,
Differentiated
Services
for
the
Internet
,
Macmillan
Technical
Publishing
,


Indianapolis
,
IN
,
1999
.


[
Kim
2005
]
H.
Kim
,
S.
Rixner
,
V
.
Pai
,
‚Äú
Network
Interface
Data
Caching
‚Äù
,
IEEE
Transactions
on


Computers
,
V
ol
.
54
,
N¬∫
11
(
noviembre
2005
)
,
p√°gs
.
1394‚Äì1408
.


[
Kim
2008
]
C.
Kim
,
M.
Caesar
,
J.
Rexford
,
‚Äú
Floodless
in
SEATTLE
:
A
Scalable
Ethernet


Architecture
for
Large
Enterprises
‚Äù
,
Proc
.
ACM
SIGCOMM
‚Äô
08(agosto
2008
,
Seattle
,
WA
)
.


[
Kleinrock
1961
]
L.
Kleinrock
,
‚Äú
Information
Flow
in
Large
Communication
Networks
‚Äù
,
RLE


Quarterly
Progress
Report
,
julio
1961
.


[
Kleinrock
1964
]
L.
Kleinrock
,
1964
Communication
Nets
:
Stochastic
Message
Flow
and
Delay
,


McGraw-Hill
,
NY
,
NY
,
1964
.


[
Kleinrock
1975
]
L.
Kleinrock
,
Queuing
Systems
,
Vol
.
1
,
John
Wiley
,
Nueva
York
,
1975
.


[
Kleinrock
1975b
]
L.
Kleinrock
,
F.
A.
Tobagi
,
‚Äú
Packet
Switching
in
Radio
Channels
:
Part
I‚ÄîCarrier


Sense
Multiple-Access
Modes
and
Their
Throughput-Delay
Characteristics
‚Äù
,
IEEE
Transactions
on


Communications
,
V
ol
.
23
,
N¬∫
12
(
diciembre
1975
)
,
p√°gs
.
1400‚Äì1416
.


[
Kleinrock
1976
]
L.
Kleinrock
,
Queuing
Systems
,
Vol
.
2
,
John
Wiley
,
Nueva
York
,
1976
.


[
Kleinrock
2004
]
L.
Kleinrock
,
‚Äú
The
Birth
of
the
Internet
‚Äù
,
http://www.lk.cs.ucla.edu/LK/Inet/birth
.


html


REFERENCIAS
777


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
777[Kohler
2006
]
E.
Kohler
,
M.
Handley
,
S.
Floyd
,
‚Äú
DDCP
:
Designing
DCCP
:
Congestion
Control


Without
Reliability
‚Äù
,
Proc
.
2006
ACM
SIGCOMM
(
Pisa
,
Italia
,
septiembre
2006
)
.


[
Korhonen
2003
]
J.
Korhonen
,
Introduction
to
3
G
Mobile
Communications
,
2¬™
ed
.
,
Artech
House
,


2003
.


[
Koziol
2003
]
J.
Koziol
,
Intrusion
Detection
with
Snort
,
Sams
Publishing
,
2003
.


[
Krishnamurthy
2001]B.
Krishnamurthy
y
J.
Rexford
,
Web
Protocols
and
Practice
:
HTTP/
1.1
,


Networking
Protocols
,
and
Traffic
Measurement
,
Addison-Wesley
,
Boston
,
MA
,
2001
.


[
Krishnamurthy
2001b]B.
Krishnamurthy
,
C.
Wills
,
Y
.
Zhang
,
‚Äú
On
the
Use
and
Performance
of


Content
Distribution
Networks
‚Äù
,
ACM
Internet
Measurement
Conference,2001
.


[
Kulkarni
2005
]
S.
Kulkarni
,
C.
Rosenberg
,
‚Äú
Opportunistic
Scheduling
:
Generalizations
to
Include


Mul-tiple
Constraints
,
Multiple
Interfaces
,
and
Short
Term
Fairness
‚Äù
,
Wireless
Networks
,
11
,


557‚Äì569
,
2005
.


[
Kumar
2006
]
R.
Kumar
,
K.W.
Ross
,
‚Äú
Optimal
Peer-Assisted
File
Distribution
:
Single
and
Multi-


Class
Problems
‚Äù
,
IEEE
Workshop
on
Hot
Topics
in
Web
Systems
and
Technologies
,
Boston
,
2006
.


[
Kurose
1996
]
Unix
Network
Progranmming
,
http://gaia.cs.umass.edu/ntu_socket/


[
Labovitz
1997
]
C.
Labovitz
,
G.
R.
Malan
,
F.
Jahanian
,
‚Äú
Internet
Routing
Instability
‚Äù
,
Proc
.
1997


ACM
SIGCOMM
(
Cannes
,
Francia
,
septiembre
1997
)
,
p√°gs
.
115‚Äì126
.


[
Labrador
1999
]
M.
Labrador
,
S.
Banerjee
,
‚Äú
Packet
Dropping
Policies
for
ATM
and
IP
Networks
‚Äù
,


IEEE
Communications
Surveys
,
V
ol
.
2
,
N¬∫
3
(
tercer
trimestre
de
1999
)
,
p√°gs
.
2‚Äì14
.


[
Lacage
2004
]
M.
Lacage
,
M.H.
Manshaei
,
T.
Turletti
,
‚Äú
IEEE
802.11
Rate
Adaptation
:
A
Practical


Approach
‚Äù
,
ACM
Int
.
Symposium
on
Modeling
,
Analysis
,
and
Simulation
of
Wireless
and
Mobile


Systems
(
MSWiM
)
(
octubre
2004
,
Venecia
,
Italia
)
.


[
Lakshman
1997
]
T.
V
.
Lakshman
,
U.
Madhow
,
‚Äú
The
Performance
of
TCP
/
IP
for
Networks
with


High
Bandwidth-Delay
Products
and
Random
Loss
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
5


N¬∫
3
(
1997
)
.
p√°gs
.
336‚Äì350
.


[
Lam
1980
]
S.
Lam
,
‚Äú
A
Carrier
Sense
Multiple
Access
Protocol
for
Local
Networks
‚Äù
,
Computer


Networks
,
V
ol
.
4
(
1980
)
,
p√°gs
.
21‚Äì32
,
1980
.


[
Lamport
1981
]
L.
Lamport
,
‚Äú
Password
Authentication
with
Insecure
Communication
‚Äù
,


Communications
of
the
ACM
,
V
ol
.
24
,
N¬∫
11
(
noviembre
1981
)
,
p√°gs
.
770‚Äì772
.


[
Larmouth
1996
]
J.
Larmouth
,
Understanding
OSI
,
International
Thomson
Computer
Press
1996
.


Chapter
8
of
this
book
deals
with
ASN.1
and
is
available
on-line
at
http://www.salford
.ac.uk
/
iti/


books
/
osi
/
all.html#head8


[
Lawton
2001
]
G.
Lawton
,
‚Äú
Is
IPv6
Finally
Gaining
Ground
?
‚Äù
IEEE
Computer
Magazine
(
agosto


2001
)
,
p√°gs
.
11‚Äì15
.


[
Leiner
1998
]
B.
Leiner
,
V
.
Cerf
,
D.
Clark
,
R.
Kahn
,
L.
Kleinrock
,
D.
Lynch
,
J.
Postel
,
L.
Roberts
,
S.


Woolf
,
‚Äú
A
Brief
History
of
the
Internet
‚Äù
,
http://www.isoc.org/internet/history/brief.html


[
Li
2004
]
L.
Li
,
D.
Alderson
,
W.
Willinger
,
J.
Doyle
,
‚Äú
A
First-Principles
Approach
to
Understanding


the
Internet‚Äôs
Router-Level
Topology
‚Äù
,
Proc
.
2004
ACM
SIGCOMM
(
Portland
,
Oreg√≥n
,
agosto
2004
)
.


[
Li
2007
]
J.
Li
,
M.
Guidero
,
Z.
Wu
,
E.
Purpus
,
T.
Ehrenkranz
,
‚Äú
BGP
Routing
Dynamics
Revisited
.
‚Äù


ACM
Computer
Communication
Review
,
abril
2007
.


[
Liang
2006
]
J.
Liang
,
N.
Naoumov
,
K.W.
Ross
,
‚Äú
The
Index
Poisoning
Attack
in
P2P
File-Sharing


Systems
‚Äù
,
Proc
.
2006
IEEE
Infocom
2006
(
Barcelona
,
Espa√±a
,
abril
2006
)
.


[
Lin
2001
]
Y.
 
L
i
n
,
 
I
.
 
C
h
l
a
m
t
a
c
,
 
Wireless
and
Mobile
Network
Architectures
,
John
Wiley
and
Sons
,


Nueva
York
,
NY
,
2001
.


[
Liogkas
2006
]
N.
Liogkas
,
R.
Nelson
,
E.
Kohler
,
L.
Zhang
,
‚Äú
Exploiting
BitTorrent
For
Fun
(
But
Not


Profit
)
,
‚Äù
6th
International
Workshop
on
Peer-to-Peer
Systems
(
IPTPS
2006
)
.


[
Liu
2002
]
B.
Liu
,
D.
Goeckel
,
D.
Towsley
,
‚Äú
TCP-Cognizant
Adaptive
Forward
Error
Correction
in


Wireless
Networks
‚Äù
,
Proc
.
2002
Global
Internet
.


778
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
778[Locher
2006
]
T.
Locher
,
P.
Moor
,
S.
Schmid
,
R.
Wattenhofer
,
‚Äú
Free
Riding
in
BitTorrent
is
Cheap
‚Äù
,


Proc
.
ACM
HotNets
2006
(
Irvine
CA
,
noviembre
2006
)
.


[
Lui
2004
]
J.
Lui
,
V
.
Misra
,
D.
Rubenstein
,
‚Äú
On
the
Robustness
of
Soft
State
Protocols
‚Äù
,
Proc
.
IEEE


Int
.
Conference
on
Network
Protocols
(
ICNP
‚Äô
04
)
,
p√°gs
.
50‚Äì60
.


[
Luotonen
1998
]
A.
Luotonen
,
Web
Proxy
Servers
,
Prentice
Hall
,
Englewood
Cliffs
,
Nueva
Jersey
,


1998
.


[
Lynch
1993
]
D.
Lynch
,
M.
Rose
,
Internet
System
Handbook
,
Addison-Wesley
,
Reading
,
MA
,
1993
.


[
Macedonia
1994
]
M.
Macedonia
,
D.
Brutzman
,
‚Äú
MBone
Provides
Audio
and
Video
Across
the


Internet
‚Äù
,
IEEE
Computer
Magazine
,
V
ol
.
27
,
N¬∫
4
(
abril
1994
)
,
p√°gs
.
30‚Äì36
.


[
Mahdavi
1997
]
J.
Mahdavi
,
S.
Floyd
,
‚Äú
TCP-Friendly
Unicast
Rate-Based
Flow
Control
‚Äù
,


unpublished
note
,
enero
1997
.


[
Malware
2006
]
Computer
Economics
,
‚Äú
2005
Malware
Report
:
The
Impact
of
Malicious
Code


Attacks
‚Äù
,
http://www.computereconomics.com


[
manet
2009
]
IETF
Mobile
Ad-hoc
Networks
(
manet
)
Working
Group
,
http://www.ietf.org/html
.


charters
/
manet-charter.html


[
Mao
2002
]
Z.
M.
Mao
,
C.
Cranor
,
F.
Douglis
,
M.
Rabinovich
,
O.
Spatscheck
,
J.
Wang
,
‚Äú
A
Precise


and
Efficient
Evaluation
of
the
Proximity
between
Web
Clients
and
Their
Local
DNS
Servers
‚Äù
,


USENIX
2002
.


[
Maymounkov
2002
]
P.
Maymounkov
,
D.
Mazi√®res
.
‚Äú
Kademlia
:
A
Peer-to-Peer
Information
System


Based
on
the
XOR
Metric
.
‚Äù
Proceedings
of
the
1st
International
Workshop
on
Peerto-Peer
Systems


(
IPTPS
‚Äô
02
)
,
p√°gs
.
53‚Äì65
,
marzo
2002
.


[
McKeown
1997a
]
N.
McKeown
,
M.
Izzard
,
A.
Mekkittikul
,
W.
Ellersick
,
M.
Horowitz
,
‚Äú
The
Tiny


Tera
:
A
Packet
Switch
Core
‚Äù
,
IEEE
Micro
Magazine
,
enero
/
febrero
1997
.


[
McKeown
1997b
]
N.
McKeown
,
‚Äú
A
Fast
Switched
Backplane
for
a
Gigabit
Switched
Router
‚Äù
,


Business
Communications
Review
,
V
ol
.
27
,
N¬∫
12
.
http://tiny-tera.stanford.edu/~nickm/papers/


cisco_fasts_wp.pdf


[
McQuillan
1980
]
J.
McQuillan
,
I.
Richer
,
E.
Rosen
,
‚Äú
The
New
Routing
Algorithm
for
the
Arpanet
‚Äù
,


IEEE
Transactions
on
Communications
,
V
ol
.
28
,
N¬∫
5
(
mayo
1980
)
,
p√°gs
.
711‚Äì719
.


[
Medhi
1997
]
D.
Medhi
,
D.
Tipper
(
eds
.
)
,
Special
Issue
:
Fault
Management
in
Communication


Networks
,
Journal
of
Network
and
Systems
Management
,
V
ol
.
5
.
N¬∫
2
(
junio
1997
)
.


[
Meng
2005
]
X.
Meng
,
‚Äú
IPv4
Address
Allocation
and
the
BGP
Routing
Table
Evolution
‚Äù
,
Computer


Communication
Reviews
,
V
ol
.
35
,
N¬∫
1
(
2005
)
,
p√°gs
.
71‚Äì80
.


[
Metcalfe
1976
]
R.
M.
Metcalfe
,
D.
R.
Boggs
.
‚Äú
Ethernet
:
Distributed
Packet
Switching
for
Local


Computer
Networks
‚Äù
,
Communications
of
the
Association
for
Computing
Machinery
,
V
ol
.
19
,
N¬∫
7
,


(
julio
1976
)
,
p√°gs
.
395‚Äì404
.


[
MFA
Forum
2009]P√°gina
principal
de
Ip
/
MPLS
Forum
:
http://www.ipmplsforum.org/


[
Microsoft
Player
Media
2009
]
P√°gina
principal
de
Microsoft
Windows
Media
,
http://www


.microsoft.com
/
windows
/
windowsmedia/


[
Miller
1997
]
M.A.
Miller
,
Managing
Internetworks
with
SNMP
,
2¬™
ed
.
,
M
&
T
Books
,
Nueva
York
,


1997
.


[
Mirkovic
2005
]
J.
Mirkovic
,
S.
Dietrich
,
D.
Dittrich
.
P.
Reiher
,
Internet
Denial
of
Service
:
Attack


and
Defense
Mechanisms
,
Prentice
Hall
,
2005
.


[
Mockapetris
1988
]
P.
V
.
Mockapetris
,
K.
J.
Dunlap
,
‚Äú
Development
of
the
Domain
Name
System
‚Äù
,


Proc
.
1988
ACM
SIGCOMM
(
Stanford
,
CA
,
agosto
1988
)
.


[
Mockapetris
2005
]
P.
Mockapetris
,
Sigcomm
Award
Lecture
,
v√≠deo
disponible
en
http://
www
.


postel.org/sigcomm


[
Mogul
2003
]
J.
Mogul
,
‚Äú
TCP
offload
is
a
dumb
idea
whose
time
has
come
‚Äù
.
Proc
.
HotOS
IX
:
The


9th
Workshop
on
Hot
Topics
in
Operating
Systems
,
(
2003
)
USENIX
Association
.


REFERENCIAS
779


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
779[Molinero-Fern√°ndez
2002
]
P.
Molinero-Fern√°ndez
,
N.
McKeown
,
H.
Zhang
,
‚Äú
Is
IP
Going
to
Take


Over
the
World
(
of
Communications
)
?
‚Äù
,
Proc
.
2002
ACM
Hotnets
.


[
Molle
1987
]
M.
L.
Molle
,
K.
Sohraby
,
A.
N.
Venetsanopoulos
,
‚Äú
Space-Time
Models
of


Asynchronous
CSMA
Protocols
for
Local
Area
Networks
‚Äù
,
IEEE
Journal
on
Selected
Areas
in


Communications
,
V
ol
.
5
,
N¬∫
6
,
(
1987
)
p√°gs
.
956‚Äì968
.


[
Moore
2001
]
D.
Moore
,
G.
V
oelker
,
S.
Savage
,
‚Äú
Inferring
Internet
Denial
of
Service
Activity
‚Äù
,
Proc
.


2001
USENIX
Security
Symposium
(
Washington
DC
,
agosto
2001
)
.


[
Moore
2003
]
D.
Moore
,
V
.
Paxson
,
S.
Savage
,
C.
Shannon
,
S.
Staniford
,
N.
Weaver
,
‚Äú
Inside
the


Slammer
Worm
‚Äù
,
2003
IEEE
Security
and
Privacy
Conference
.


[
Moshchuck
2006
]
A.
Moshchuk
,
T.
Bragin
,
S.
Gribble
,
H.
Levy
,
‚Äú
A
Crawler-based
Study
of


Spyware
on
the
Web
‚Äù
,
Proc
.
13th
Annual
Network
and
Distributed
Systems
Security
Symposium


(
NDSS
2006
)
(
San
Diego
,
CA
,
febrero
2006
)
.


[
Mouly
1992
]
M.
Mouly
,
M.
Pautet
,
The
GSM
System
for
Mobile
Communications
,
Cell
and
Sys
,


Palaiseau
,
Francia
,
1992
.


[
Moy
1998
]
J.
Moy
,
OSPF
:
Anatomy
of
An
Internet
Routing
Protocol
,
Addison-Wesley
,
Reading
,


MA
,
1998
.


[
Mukherjee
1997
]
B.
Mukherjee
,
Optical
Communication
Networks
,
McGraw-Hill
,
1997
.


[
Murphy
2003
]
V√©ase
[
RFC
4272
]


[
Nahum
2002
]
E.
Nahum
,
T.
Barzilai
,
D.
Kandlur
,
‚Äú
Performance
Issues
in
WWW
Servers
‚Äù
,


IEEE
/
ACM
Transactions
on
Networking
,
V
ol
10
,
N¬∫
1
(
Feb
.
2002
)
.


[
Naoumov
2006
]
N.
Naoumov
,
K.W.
Ross
,
‚Äú
Exploiting
P2P
Systems
for
DDoS
Attacks
‚Äù
,
Intl


Workshop
on
Peer-to-Peer
Information
Management
,
(
Hong
Kong
,
mayo
2006
)
,


[
Neglia
2007
]
G.
Neglia
,
G.
Reina
,
H.
Zhang
,
D.
Towsley
,
A.
Venkataramani
,
J.
Danaher
,


‚Äú
Availability
in
BitTorrent
Systems
‚Äù
,
Proc
.
IEEE
INFOCOM
2007
,
mayo
2007
.


[
Neumann
1997
]
R.
Neumann
,
‚Äú
Internet
Routing
Black
Hole
‚Äù
,
The
Risks
Digest
:
Forum
on
Risks
to


the
Public
in
Computers
and
Related
Systems
,
V
ol
.
19
,
N¬∫
12
(
mayo
1997
)
.
http://
catless.ncl.ac.uk/


Risks/19.12.html#subj1.1


[
Newman
2008
]
D.
Newman
,
‚Äú
802.11n
Gear
10
Times
Faster
Than
Current
Wi-Fi
Offerings
‚Äù
,


Network
World
,
Oct
.
27
,
2008
.
http://www.networkworld.com/reviews/2008/102708-wlan-


test.html?page=1


[
Nicholson
2006
]
A
Nicholson
,
Y
.
Chawathe
,
M.
Chen
,
B.
Noble
,
D.
Wetherall
,
‚Äú
ImprovedAccess


Point
Selection
‚Äù
,
Proc
.
2006
ACM
Mobisys
Conference
(
Uppsala
Sweden
,
2006
)
.


[
Nielsen
1997
]
H.
F.
Nielsen
,
J.
Gettys
,
A.
Baird-Smith
,
E.
Prud‚Äôhommeaux
,
H.
W.
Lie
,
C.
Lilley
,


‚Äú
Network
Performance
Effects
of
HTTP/1.1
,
CSS1
,
and
PNG
‚Äù
,
W3C
Document
,
1997
(
also


appears
in
Proc
.
1997
ACM
SIGCOM
,
(
Cannes
,
Francia
,
septiembre
1997
)
,
p√°gs
.
155‚Äì166
.


[
NIST
2001
]
National
Institute
of
Standards
and
Technology
,
‚Äú
Advanced
Encryption
Standard


(
AES
)
,
‚Äù
Federal
Information
Processing
Standards
197
,
noviembre
2001
,
http://csrc.nist
.gov/


publications
/
fips
/
fips197
/
fips-197.pdf


[
Nmap
2009
]
P√°gina
principal
de
Nmap
:
http://www.insecure.com/nmap


[
Nonnenmacher
1998
]
J.
Nonnenmacher
,
E.
Biersak
,
D.
Towsley
,
‚Äú
Parity-Based
Loss
Recovery
for


Reliable
Multicast
Transmission
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
6
,
N¬∫
4
(
agosto


1998
)
,
p√°gs
.
349‚Äì361
.


[
NTIA
1998
]
National
Telecommunications
and
Information
Administration
(
NTIA
)
,
US
Department


of
Commerce
,
‚Äú
Management
of
Internet
names
and
addresses
‚Äù
,
Docket
Number
:
980212036-8146-


02
.
http://www.ntia.doc.gov/ntiahome/domainname/6_5_98dns.htm


[
Odlyzko
2003
]
A.
Odlyzko
,
‚Äú
Internet
Traffic
Growth
:
Sources
and
Implications
‚Äù
,
A.
M.
Optical


Transmission
Systems
and
Equipment
for
WDM
Networking
II
,
Proc
.
SPIE
,
5247
,
2003
,
p√°gs
.
1‚Äì15
.


http://www.dtc.umn.edu/~odlyzko/doc/itcom.internet.growth.pdf
.


780
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
780[OSI
2009
]
P√°gina
principal
de
International
Organization
for
Standardization
,
http://www.iso.org/


iso
/
en
/
ISOOnline.frontpage


[
OSS
2009
]
OSS
Nokalva
,
‚Äú
ASN.1
Resources
‚Äù
,
http://www.oss.com/asn1/


[
Padhye
2000
]
J.
Padhye
,
V
.
Firoiu
,
D.
Towsley
,
J.
Kurose
,
‚Äú
Modeling
TCP
Reno
Performance
:
A


Simple
Model
and
its
Empirical
Validation
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
8
N¬∫
2


(
abril
2000
)
,
p√°gs
.
133‚Äì145
.


[
Padhye
2001
]
J.
Padhye
,
S.
Floyd
,
‚Äú
On
Inferring
TCP
Behavior
‚Äù
,
Proc
.
2001
ACM
SIGCOMM
,
(
San


Diego
,
CA
,
agosto
2001
)
.


[
Pan
1997
]
P.
Pan
,
H.
Schulzrinne
,
‚Äú
Staged
Refresh
Timers
for
RSVP
‚Äù
,
Proc
.
2nd
Global
Internet


Conference
(
Phoenix
,
AZ
,
diciembre
1997
)
.


[
Parekh
1993
]
A.
Parekh
,
R.
Gallagher
,
‚Äú
A
generalized
processor
sharing
approach
to
flow
control
in


integrated
services
networks
:
the
single-node
case
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
1
,


N¬∫
3
(
junio
1993
)
,
p√°gs
.
344‚Äì357
.


[
Partridge
1992
]
C.
Partridge
,
S.
Pink
,
‚Äú
An
Implementation
of
the
Revised
Internet
Stream
Protocol


(
ST-2
)
,
‚Äù
Journal
of
Internetworking
:
Research
and
Experience
,
V
ol
.
3
,
N¬∫.
1
(
marzo
1992
)
.


[
Partridge
1998
]
C.
Partridge
,
et
al
.
‚Äú
A
Fifty
Gigabit
per
second
IP
Router
‚Äù
,
IEEE
/
ACM
Transactions


on
Networking
,
V
ol
.
6
,
N¬∫
3
(
junio
1998
)
,
p√°gs
.
237‚Äì248
.


[
Paxson
1997
]
V.
 
P
a
x
s
o
n
,
 
‚Äú
E
n
d
-
t
o
-
e
n
d
 
I
n
t
e
r
n
e
t
 
p
a
c
k
e
t
 
d
y
n
a
m
i
c
s
‚Äù
,
 
Proc
.
1997
ACM
SIGCOMM


(
Cannes
,
Francia
,
septiembre
1997
)
.


[
Perkins
1994
]
A.
Perkins
,
‚Äú
Networking
with
Bob
Metcalfe
‚Äù
,
The
Red
Herring
Magazine
,
noviembre


1994
.


[
Perkins
1998
]
C.
Perkins
,
O.
Hodson
,
V
.
Hardman
,
‚Äú
A
Survey
of
Packet
Loss
Recovery
Techniques


for
Streaming
Audio
‚Äù
,
IEEE
Network
Magazine
,
sept./oct
.
1998
,
p√°gs
.
40‚Äì47
.


[
Perkins
1998b
]
C.
Perkins
,
Mobile
IP
:
Design
Principles
and
Practice
,
Addison-Wesley
,
Reading
,


MA
,
1998
.


[
Perkins
2000
]
C.
Perkins
,
Ad
Hoc
Networking
,
Addison-Wesley
,
Reading
,
MA
,
2000
.


[
Perlman
1999
]
R.
Perlman
,
Interconnections
:
Bridges
,
Routers
,
Switches
,
and
Internetworking


Protocols
,
2¬™
ed
.
,
Addison-Wesley
Professional
Computing
Series
,
Reading
,
MA
,
1999
.


[
PGPI
2009
]
The
International
PGP
Home
Page
,
http://www.pgpi.org


[
Phifer
2000]L.
Phifer
,
‚Äú
The
Trouble
with
NAT
‚Äù
,
The
Internet
Protocol
Journal
,
Vo
l
.
 
3
,
 
N
¬∫
 
4


(
diciembre
2000
)
,
http://www.cisco.com/warp/public/759/ipj_3-4/ipj_3-4_nat.html


[
Piatek
2007
]
M.
Piatek
,
T.
Isdal
,
T.
Anderson
,
A.
Krishnamurthy
,
A.
Venkataramani
,
‚Äú
Do
Incentives


Build
Robustness
in
Bittorrent
?
‚Äù
,
Proc
.
NSDI
,
2007
.


[
Piatek
2008
]
M.
Piatek
,
T.
Isdal
,
A.
Krishnamurthy
,
T.
Anderson
,
‚Äú
One
hop
Reputations
for
Peer-to-


peer
File
Sharing
Workloads
‚Äù
,
Proc
.
NSDI
,
2008
.


[
Pickholtz
1982
]
R.
Pickholtz
,
D.
Schilling
,
L.
Milstein
,
‚Äú
Theory
of
Spread
Spectrum


Communication‚Äîa
Tutorial
‚Äù
,
IEEE
Transactions
on
Communications
,
V
ol
.
30
,
N¬∫
5
(
mayo
1982
)
,


p√°gs
.
855‚Äì884
.


[
pingplotter
2009
]
P√°gina
principal
de
pingplotter
,
http://www.pingplotter.com


[
Piscatello
1993
]
D.
Piscatello
,
A.
Lyman
Chapin
,
Open
Systems
Networking
,
Addison-Wesley
,


Reading
,
MA
,
1993
.


[
Point
Topic
2006
]
Point
Topic
Ltd
.
,
World
Broadband
Statistics
Q1
2006,http://www
.pointtopic
.


com


[
Potaroo
2009
]
‚Äú
Growth
of
the
BGP
Table‚Äì1994
to
Present
‚Äù
,
http://bgp.potaroo.net/


[
PPLive
2009
]
P√°gina
principal
de
PPLive
:
http://www.pplive.com


[
PriMetrica
2009
]
Global
Internet
Geography
,
http://www.telegeography.com/products/gig/index.php


[
QuickTime
2009
]
P√°gina
principal
de
QuickTime
:
http://www.apple.com/quicktime


REFERENCIAS
781


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
781[Quittner
1998
]
J.
Quittner
,
M.
Slatalla
,
Speeding
the
Net
:
The
Inside
Story
of
Netscape
and
How
it


Challenged
Microsoft
,
Atlantic
Monthly
Press
,
1998
.


[
Ramakrishnan
1990
]
K.
K.
Ramakrishnan
,
R.
Jain
,
‚Äú
A
Binary
Feedback
Scheme
for
Congestion


Avoidance
in
Computer
Networks
‚Äù
,
ACM
Transactions
on
Computer
Systems
,
Vo
l
.
 
8
,
 
N
¬∫
 
2
 
(
m
a
y
o


1990
)
,
p√°gs
.
158‚Äì181
.


[
Raman
1999
]
S.
Raman
,
S.
McCanne
,
‚Äú
A
Model
,
Analysis
,
and
Protocol
Framework
for
Soft
State-


based
Communication
‚Äù
,
Proc
.
1999
ACM
SIGCOMM
(
Boston
,
MA
,
agosto
1999
)
.


[
Raman
2007
]
B.
Raman
,
K.
Chebrolu
,
‚Äú
Experiences
in
using
WiFi
for
Rural
Internet
in
India
‚Äù
,
IEEE


Communications
Magazine
,
Special
Issue
on
New
Directions
in
Networking
Technologies
in


Emerging
Economies
,
Jan
2007
.


[
Ramaswami
1998
]
R.
Ramaswami
,
K.
Sivarajan
,
Optical
Networks
:
A
Practical
Perspective
,


Morgan
Kaufman
Publishers
,
1998
.


[
Ramjee
1994
]
R.
Ramjee
,
J.
Kurose
,
D.
Towsley
,
H.
Schulzrinne
,
‚Äú
Adaptive
Playout
Mechanisms


for
Packetized
Audio
Applications
in
Wide-Area
Networks
‚Äù
,
Proc
.
1994
IEEE
Infocom
.


[
Rao
1996
]
K.
R.
Rao
and
J.
J.
Hwang
,
Techniques
and
Standards
for
Image
,
Video
and
Audio


Coding
,
Prentice
Hall
,
Englewood
Cliffs
,
NJ
,
1996
.


[
RAT
2009
]
Robust
Audio
Tool
,
http://www-mice.cs.ucl.ac.uk/multimedia/software/rat/


[
Ratnasamy
2001
]
S.
Ratnasamy
,
P.
Francis
,
M.
Handley
,
R.
Karp
,
S.
Shenker
,
‚Äú
A
Scalable
Content-


Addressable
Network
‚Äù
,
Proc
.
2001
ACM
SIGCOMM
(
San
Diego
,
CA
,
agosto
2001
)
.


[
RealNetworks
2009
]
P√°gina
principal
de
RealNetworks
:
http://www.realnetworks.com


[
Ren
2006
]
S.
Ren
,
L.
Guo
y
X.
Zhang
,
‚Äú
ASAP
:
an
AS-aware
peer-relay
protocol
for
high
quality


Vo
I
P
‚Äù
,
 
Proc
.
2006
IEEE
ICDCS
(
Lisboa
,
Portugal
,
julio
2006
)
.


[
Rescorla
2001
]
E.
Rescorla
,
SSL
and
TLS
:
Designing
and
Building
Secure
Systems
,
Addison-Wesley
,


Boston
,
2001
.


[
RFC
001
]
S.
Crocker
,
‚Äú
Host
Software
‚Äù
,
RFC
001
(
the
very
first
RFC
!
)
.


[
RFC
768
]
J.
Postel
,
‚Äú
User
Datagram
Protocol
‚Äù
,
RFC
768
,
agosto
1980
.


[
RFC
789
]
E.
Rosen
,
‚Äú
Vulnerabilities
of
Network
Control
Protocols
‚Äù
,
RFC
789
.


[
RFC
791
]
J.
Postel
,
‚Äú
Internet
Protocol
:
DARPA
Internet
Program
Protocol
Specification
‚Äù
,
RFC
791
,


septiembre
1981
.


[
RFC
792
]
J.
Postel
,
‚Äú
Internet
Control
Message
Protocol
‚Äù
,
RFC
792
,
septiembre
1981
.


[
RFC
793
]
J.
Postel
,
‚Äú
Transmission
Control
Protocol
‚Äù
,
RFC
793
,
septiembre
1981
.


[
RFC
801
]
J.
Postel
,
‚Äú
NCP
/
TCP
Transition
Plan
‚Äù
,
RFC
801
,
noviembre
1981
.


[
RFC
826
]
D.
C.
Plummer
,
‚Äú
An
Ethernet
Address
Resolution
Protocol‚Äîor‚ÄîConverting
Network


Protocol
Addresses
to
48
bit
Ethernet
Address
for
Transmission
on
Ethernet
Hardware
‚Äù
,
RFC
826
,


noviembre
1982
.


[
RFC
829
]
V.
 
C
e
r
f
,
 
‚Äú
P
a
c
k
e
t
 
S
a
t
e
l
l
i
t
e
 
Te
c
h
n
o
l
o
g
y
 
R
e
f
e
r
e
n
c
e
 
S
o
u
r
c
e
s
‚Äù
,
 
R
F
C
 
8
2
9
,
 
n
o
v
i
e
m
b
r
e
 
1
9
8
2
.


[
RFC
854
]
J.
Postel
,
J.
Reynolds
,
‚Äú
TELNET
Protocol
Specification
‚Äù
,
RFC
854
,
mayo
1993
.


[
RFC
950
]
J.
Mogul
,
J.
Postel
,
‚Äú
Internet
Standard
Subnetting
Procedure
‚Äù
,
RFC
950
,
agosto
1985
.


[
RFC
959
]
J.
Postel
y
J.
Reynolds
,
‚Äú
File
Transfer
Protocol
(
FTP
)
,
‚Äù
RFC
959
,
octubre
1985
.


[
RFC
977
]
B.
Kantor
,
P.
Lapsley
,
‚Äú
Network
News
Transfer
Protocol
‚Äù
,
RFC
977
,
febrero
1986
.


[
RFC
1028
]
J.
Davin
,
J.D.
Case
,
M.
Fedor
,
M.
Schoffstall
,
‚Äú
A
Simple
Gateway
Monitoring
Protocol
‚Äù
,


RFC
1028
,
noviembre
1987
.


[
RFC
1034
]
P.
V.
Mockapetris
,
‚Äú
Domain
Names‚ÄîConcepts
and
Facilities
‚Äù
,
RFC
1034
,
noviembre


1987
.


[
RFC
1035
]
P.
Mockapetris
,
‚Äú
Domain
Names‚ÄîImplementation
and
Specification
‚Äù
,
RFC
1035
,


noviembre
1987
.


782
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
782[RFC
1058
]
C.
L.
Hendrick
,
‚Äú
Routing
Information
Protocol
‚Äù
,
RFC
1058
,
junio
1988
.


[
RFC
1071
]
R.
Braden
,
D.
Borman
y
C.
Partridge
,
‚Äú
Computing
The
Internet
Checksum
‚Äù
,
RFC
1071
,


septiembre
1988
.


[
RFC
1075
]
D.
Waitzman
,
C.
Partridge
,
S.
Deering
,
‚Äú
Distance
Vector
Multicast
Routing
Protocol
‚Äù
,


RFC
1075
,
noviembre
1988
.


[
RFC
1112
]
S.
Deering
,
‚Äú
Host
Extension
for
IP
Multicasting
‚Äù
,
RFC
1112
,
agosto
1989
.


[
RFC
1122
]
R.
Braden
,
‚Äú
Requirements
for
Internet
Hosts‚ÄîCommunication
Layers
‚Äù
,
RFC
1122
,


octubre
1989
.


[
RFC
1123
]
R.
Braden
,
ed
.
,
‚Äú
Requirements
for
Internet
Hosts‚ÄîApplication
and
Support
‚Äù
,
RFC-1123
,


octubre
1989
.


[
RFC
1142
]
D.
Oran
,
‚Äú
OSI
IS-IS
Intra-domain
Routing
Protocol
‚Äù
,
RFC
1142
,
febrero
1990
.


[
RFC
1190
]
C.
Topolcic
,
‚Äú
Experimental
Internet
Stream
Protocol
:
Version
2
(
ST-II
)
,
‚Äù
RFC
1190
,


octubre
1990
.


[
RFC
1191
]
J.
Mogul
,
S.
Deering
,
‚Äú
Path
MTU
Discovery
‚Äù
,
RFC
1191
,
noviembre
1990
.


[
RFC
1213
]
K.
McCloghrie
,
M.
T.
Rose
,
‚Äú
Management
Information
Base
for
Network
Management


of
TCP
/
IP-based
internets
:
MIB-II
‚Äù
,
RFC
1213
,
marzo
1991
.


[
RFC
1256
]
S.
Deering
,
‚Äú
ICMP
Router
Discovery
Messages
‚Äù
,
RFC
1256
,
septiembre
1991
.


[
RFC
1320
]
R.
Rivest
,
‚Äú
The
MD4
Message-Digest
Algorithm
‚Äù
,
RFC
1320
,
abril
1992
.


[
RFC
1321
]
R.
Rivest
,
‚Äú
The
MD5
Message-Digest
Algorithm
‚Äù
,
RFC
1321
,
abril
1992
.


[
RFC
1323
]
V
.
Jacobson
,
S.
Braden
,
D.
Borman
,
‚Äú
TCP
Extensions
for
High
Performance
‚Äù
,
RFC


1323
,
mayo
1992
.


[
RFC
1422
]
S.
Kent
,
‚Äú
Privacy
Enhancement
for
Internet
Electronic
Mail
:
Part
II
:
Certificate-
Based


Key
Management
‚Äù
,
RFC
1422
.


[
RFC
1547
]
D.
Perkins
,
‚Äú
Requirements
for
an
Internet
Standard
Point-to-Point
Protocol
‚Äù
,
RFC
1547
,


diciembre
1993
.


[
RFC
1584
]
J.
Moy
,
‚Äú
Multicast
Extensions
to
OSPF
‚Äù
,
RFC
1584
,
marzo
1994
.


[
RFC
1633
]
R.
Braden
,
D.
Clark
,
S.
Shenker
,
‚Äú
Integrated
Services
in
the
Internet
Architecture
:
an


Overview
‚Äù
,
RFC
1633
,
junio
1994
.


[
RFC
1636
]
R.
Braden
,
D.
Clark
,
S.
Crocker
,
C.
Huitema
,
‚Äú
Report
of
IAB
Workshop
on
Security
in


the
Internet
Architecture
‚Äù
,
RFC
1636
,
noviembre
1994
.


[
RFC
1661
]
W.
Simpson
(
ed
.
)
,
‚Äú
The
Point-to-Point
Protocol
(
PPP
)
,
‚Äù
RFC
1661
,
julio
1994
.


[
RFC
1662
]
W.
Simpson
(
ed
.
)
,
‚Äú
PPP
in
HDLC-like
framing
‚Äù
,
RFC
1662
,
julio
1994
.


[
RFC
1700
]
J.
Reynolds
y
J.
Postel
,
‚Äú
Assigned
Numbers
‚Äù
,
RFC
1700
,
octubre
1994
.


[
RFC
1752
]
S.
Bradner
,
A.
Mankin
,
‚Äú
The
Recommendations
for
the
IP
Next
Generation
Protocol
‚Äù
,


RFC
1752
,
enero
1995
.


[
RFC
1760
]
N.
Haller
,
‚Äú
The
S
/
KEY
One-Time
Password
System
‚Äù
,
RFC
1760
,
febrero
1995
.


[
RFC
1918
]
Y.
 
R
e
k
h
t
e
r
,
 
B
.
 
M
o
s
k
o
w
i
t
z
,
 
D
.
 
K
a
r
r
e
n
b
e
rg
,
 
G
.
 
J
.
 
d
e
 
G
r
o
o
t
,
 
E
.
 
L
e
a
r
,
 
‚Äú
A
d
d
r
e
s
s
 
A
l
l
o
c
a
t
i
o
n


for
Private
Internets
‚Äù
,
RFC
1918
,
febrero
1996
.


[
RFC
1930
]
J.
Hawkinson
,
T.
Bates
,
‚Äú
Guidelines
for
Creation
,
Selection
,
and
Registration
of
an


Autonomous
System
(
AS
)
,
‚Äù
RFC
1930
,
marzo
1996
.


[
RFC
1938
]
N.
Haller
,
C.
Metz
,
‚Äú
A
One-Time
Password
System
‚Äù
,
RFC
1938
,
mayo
1996
.


[
RFC
1939
]
J.
Myers
y
M.
Rose
,
‚Äú
Post
Office
Protocol‚ÄîVersion
3
‚Äù
,
RFC
1939
,
mayo
1996
.


[
RFC
1945
]
T.
Berners-Lee
,
R.
Fielding
,
H.
Frystyk
,
‚Äú
Hypertext
Transfer
Protocol‚ÄîHTTP/1.0
‚Äù
,


RFC
1945
,
mayo
1996
.


[
RFC
2003
]
C.
Perkins
,
‚Äú
IP
Encapsulation
within
IP
‚Äù
,
RFC
2003
,
octubre
1996
.


[
RFC
2004
]
C.
Perkins
,
‚Äú
Minimal
Encapsulation
within
IP
‚Äù
,
RFC
2004
,
octubre
1996
.


REFERENCIAS
783


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
783[RFC
2018
]
M.
Mathis
,
J.
Mahdavi
,
S.
Floyd
,
A.
Romanow
,
‚Äú
TCP
Selective
Acknowledgment


Options
‚Äù
,
RFC
2018
,
octubre
1996
.


[
RFC
2050
]
K.
Hubbard
,
M.
Kosters
,
D.
Conrad
,
D.
Karrenberg
,
J.
Postel
,
‚Äú
Internet
Registry
IP


Allocation
Guidelines
‚Äù
,
RFC
2050
,
noviembre
1996
.


[
RFC
2104
]
H.
Krawczyk
,
M.
Bellare
,
R.
Canetti
,
‚Äú
HMAC
:
Keyed-Hashing
for
Message


Authentication
‚Äù
,
RFC
2104
,
febrero
1997
.


[
RFC
2131
]
R.
Droms
,
‚Äú
Dynamic
Host
Configuration
Protocol
‚Äù
,
RFC
2131
,
marzo
1997
.


[
RFC
2136
]
P.
Vixie
,
S.
Thomson
,
Y.
Rekhter
,
J.
Bound
,
‚Äú
Dynamic
Updates
in
the
Domain
Name


System
‚Äù
,
RFC
2136
,
abril
1997
.


[
RFC
2153
]
W.
Simpson
,
‚Äú
PPP
Vendor
Extensions
‚Äù
,
RFC
2153
,
mayo
1997
.


[
RFC
2205
]
R.
Braden
,
Ed
.
,
L.
Zhang
,
S.
Berson
,
S.
Herzog
,
S.
Jamin
,
‚Äú
Resource
ReSerVation


Protocol
(
RSVP)‚ÄîVersion
1
Functional
Specification
‚Äù
,
RFC
2205
,
septiembre
1997
.


[
RFC
2210
]
J.
Wroclawski
,
‚Äú
The
Use
of
RSVP
with
IETF
Integrated
Services
‚Äù
,
RFC
2210
,


septiembre
1997
.


[
RFC
2211
]
J.
Wroclawski
,
‚Äú
Specification
of
the
Controlled-Load
Network
Element
Service
‚Äù
,
RFC


2211
,
septiembre
1997
.


[
RFC
2215
]
S.
Shenker
,
J.
Wroclawski
,
‚Äú
General
Characterization
Parameters
for
Integrated
Service


Network
Elements
‚Äù
,
RFC
2215
,
septiembre
1997
.


[
RFC
2246
]
T.
Dierks
y
C.
Allen
,
‚Äú
The
TLS
Protocol
‚Äù
,
RFC
2246
,
enero
1998
.


[
RFC
2253
]
M.
Wahl
,
S.
Kille
,
T.
Howes
,
‚Äú
Lightweight
Directory
Access
Protocol
(
v3
)
,
‚Äù
RFC
2253
,


diciembre
1997
.


[
RFC
2284
]
L.
Blunk
,
J.
V
ollbrecht
,
‚Äú
PPP
Extensible
Authentication
Protocol
(
EAP
)
,
‚Äù
RFC
2284
,


marzo
1998
.


[
RFC
2326
]
H.
Schulzrinne
,
A.
Rao
,
R.
Lanphier
,
‚Äú
Real
Time
Streaming
Protocol
(
RTSP
)
,
‚Äù
RFC


2326
,
abril
1998
.


[
RFC
2328
]
J.
Moy
,
‚Äú
OSPF
Version
2
‚Äù
,
RFC
2328
,
abril
1998
.


[
RFC
2420
]
H.
Kummert
,
‚Äú
The
PPP
Triple-DES
Encryption
Protocol
(
3DESE
)
,
‚Äù
RFC
2420
,


septiembre
1998
.


[
RFC
2437
]
B.
Kaliski
,
J.
Staddon
,
‚Äú
PKCS
#
1
:
RSA
Cryptography
Specifications
,
Version
2
‚Äù
,
RFC


2437
,
octubre
1998
.


[
RFC
2453
]
G.
Malkin
,
‚Äú
RIP
Version
2
‚Äù
,
RFC
2453
,
noviembre
1998
.


[
RFC
2460
]
S.
Deering
,
R.
Hinden
,
‚Äú
Internet
Protocol
,
Version
6
(
IPv6
)
Specification
‚Äù
,
RFC
2460
,


diciembre
1998
.


[
RFC
2475
]
S.
Blake
,
D.
Black
,
M.
Carlson
,
E.
Davies
,
Z.
Wang
,
W.
Weiss
,
‚Äú
An
Architecture
for


Differentiated
Services
‚Äù
,
RFC
2475
,
diciembre
1998
.


[
RFC
2578
]
K.
McCloghrie
,
D.
Perkins
,
J.
Schoenwaelder
,
‚Äú
Structure
of
Management
Information


Version
2
(
SMIv2
)
,
‚Äù
RFC
2578
,
abril
1999
.


[
RFC
2579
]
K.
McCloghrie
,
D.
Perkins
,
J.
Schoenwaelder
,
‚Äú
Textual
Conventions
for
SMIv2
‚Äù
,
RFC


2579
,
abril
1999
.


[
RFC
2580
]
K.
McCloghrie
,
D.
Perkins
,
J.
Schoenwaelder
,
‚Äú
Conformance
Statements
for
SMIv2
‚Äù
,


RFC
2580
,
abril
1999
.


[
RFC
2581
]
M.
Allman
,
V
.
Paxson
,
W.
Stevens
,
‚Äú
TCP
Congestion
Control
‚Äù
,
RFC
2581
,


abril
1999
.


[
RFC
2597
]
J.
Heinanen
,
F.
Baker
,
W.
Weiss
,
J.
Wroclawski
,
‚Äú
Assured
Forwarding
PHB
Group
‚Äù
,


RFC
2597
,
junio
1999
.


[
RFC
2616
]
R.
Fielding
,
J.
Gettys
,
J.
Mogul
,
H.
Frystyk
,
L.
Masinter
,
P.
Leach
,
T.
Berners-Lee
,
R.


Fielding
,
‚Äú
Hypertext
Transfer
Protocol‚ÄîHTTP/1.1
‚Äù
,
RFC
2616
,
junio
1999
.


784
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
784[RFC
2663
]
P.
Srisuresh
,
M.
Holdrege
,
‚Äú
IP
Network
Address
Translator
(
NAT
)
Terminology
and


Considerations
‚Äù
,
RFC
2663
.


[
RFC
2702
]
D.
Awduche
,
J.
Malcolm
,
J.
Agogbua
,
M.
O‚ÄôDell
,
J.
McManus
,
‚Äú
Requirements
for


Traffic
Engineering
Over
MPLS
‚Äù
,
septiembre
1999
.


[
RFC
2716
]
B.
Aboba
,
D.
Simon
,
‚Äú
PPP
EAP
TLS
Authentication
Protocol
‚Äù
,
RFC
2716
,
octubre
1999
.


[
RFC
2733
]
J.
Rosenberg
,
H.
Schulzrinne
,
‚Äú
An
RTP
Payload
Format
for
Generic
Forward
Error


Correction
‚Äù
,
RFC
2733
,
diciembre
1999
.


[
RFC
2827
]
P.
Ferguson
,
D.
Senie
,
‚Äú
Network
Ingress
Filtering
:
Defeating
Denial
of
Service
Attacks


which
Employ
IP
Source
Address
Spoofing
‚Äù
,
RFC
2827
,
mayo
2000
.


[
RFC
2865
]
C.
Rigney
,
S.
Willens
,
A.
Rubens
,
W.
Simpson
,
‚Äú
Remote
Authentication
Dial
In
User


Service
(
RADIUS
)
,
‚Äù
RFC
2865
,
junio
2000
.


RFC
2960]R.
Stewart
,
Q.
Xie
,
K.
Morneault
,
C.
Sharp
,
H.
Schwarzbauer
,
T.
Taylor
,
I.
Rytina
,
M.
Kalla
,


L.
Zhang
,
V
.
Paxson
,
‚Äú
Stream
Control
Transmission
Protocol
‚Äù
,
RFC
2960
,
octubre
2000
.


[
RFC
2961
]
L.
Berger
,
D.
Gan
,
G.
Swallow
,
P.
Pan
,
F.
Tommasi
,
S.
Molendini
,
‚Äú
RSVP
Refresh


Overhead
Reduction
Extensions
‚Äù
,
RFC
2961
,
abril
2001
.


[
RFC
2988
]
V
.
Paxson
,
M.
Allman
,
‚Äú
Computing
TCP‚Äôs
Retransmission
Timer
‚Äù
,
RFC
2988
,


noviembre
2000
.


[
RFC
3007
]
B.
Wellington
,
‚Äú
Secure
Domain
Name
System
(
DNS
)
Dynamic
Update
‚Äù
,
RFC
3007
,


noviembre
2000
.


[
RFC
3022
]
P.
Srisuresh
,
K.
Egevang
,
‚Äú
Traditional
IP
Network
Address
Translator
(
Traditional


NAT
)
,
‚Äù
RFC
3022
,
enero
2001
.


[
RFC
3022
]
P.
Srisuresh
,
K.
Egevang
,
‚Äú
Traditional
IP
Network
Address
Translator
(
Traditional


NAT
)
,
‚Äù
RFC
3022
,
enero
2001
.


[
RFC
3031
]
E.
Rosen
,
A.
Viswanathan
,
R.
Callon
,
‚Äú
Multiprotocol
Label
Switching
Architecture
‚Äù
,


RFC
3031
,
enero
2001
.


[
RFC
3032
]
E.
Rosen
,
D.
Tappan
,
G.
Fedorkow
,
Y
.
Rekhter
,
D.
Farinacci
,
T.
Li
,
A.
Conta
,
‚Äú
MPLS


Label
Stack
Encoding
‚Äù
,
RFC
3032
,
enero
2001
.


[
RFC
3052
]
M.
Eder
,
S.
Nag
,
‚Äú
Service
Management
Architectures
Issues
and
Review
‚Äù
,
RFC
3052
,


enero
2001
.


[
RFC
3139
]
L.
Sanchez
,
K.
McCloghrie
,
J.
Saperia
,
‚Äú
Requirements
for
Configuration
Management
of


IP-Based
Networks
‚Äù
,
RFC
3139
,
junio
2001
.


[
RFC
3168
]
K.
Ramakrishnan
,
S.
Floyd
,
D.
Black
,
‚Äú
The
Addition
of
Explicit
Congestion
Notification


(
ECN
)
to
IP
‚Äù
,
RFC
3168
,
septiembre
2001
.


[
RFC
3209
]
D.
Awduche
,
L.
Berger
,
D.
Gan
,
T.
Li
,
V
.
Srinivasan
,
G.
Swallow
,
‚Äú
RSVP-TE
:


Extensions
to
RSVP
for
LSP
Tunnels
‚Äù
,
RFC
3209
,
diciembre
2001
.


[
RFC
3221
]
G.
Huston
,
‚Äú
Commentary
on
Inter-Domain
Routing
in
the
Internet
‚Äù
,
RFC
3221
,


diciembre
2001
.


[
RFC
3232
]
J.
Reynolds
,
‚Äú
Assigned
Numbers
:
RFC
1700
is
Replaced
by
an
On-line
Database
‚Äù
,
RFC


3232
,
enero
2002
.


[
RFC
3246
]
B.
Davie
,
A.
Charny
,
J.C.R.
Bennet
,
K.
Benson
,
J.Y
.
Le
Boudec
,
W.
Courtney
,
S.
Davari
,


V
.
Firoiu
,
D.
Stiliadis
,
‚Äú
An
Expedited
Forwarding
PHB
(
Per-Hop
Behavior
)
,
‚Äù
RFC
3246
,
marzo
2002
.


[
RFC
3260
]
D.
Grossman
,
‚Äú
New
Terminology
and
Clarifications
for
Diffserv
‚Äù
,
RFC
3260
,
abril


2002
.


[
RFC
3261
]
J.
Rosenberg
,
H.
Schulzrinne
,
G.
Carmarillo
,
A.
Johnston
,
J.
Peterson
,
R.
Sparks
,
M.


Handley
,
E.
Schooler
,
‚Äú
SIP
:
Session
Initiation
Protocol
‚Äù
,
RFC
3261
,
julio
2002
.


[
RFC
3272
]
J.
Boyle
,
V
.
Gill
,
A.
Hannan
,
D.
Cooper
,
D.
Awduche
,
B.
Christian
,
W.S.
Lai
,
‚Äú
Overview


and
Principles
of
Internet
Traffic
Engineering
‚Äù
,
RFC
3272
,
mayo
2002
.


REFERENCIAS
785


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
785[RFC
3286
]
L.
Ong
,
J.
Yoakum
,
‚Äú
An
Introduction
to
the
Stream
Control
Transmission
Protocol


(
SCTP
)
,
‚Äù
RFC
3286
,
mayo
2002
.


[
RFC
3344
]
C.
Perkins
,
ed
.
,
‚Äú
IP
Mobility
Support
for
IPv4
‚Äù
,
RFC
3344
,
octubre
2002
.


[
RFC
3346
]
J.
Boyle
,
V
.
Gill
,
A.
Hannan
,
D.
Cooper
,
D.
Awduche
,
B.
Christian
,
W.
S.
Lai
,


‚Äú
Applicability
Statement
for
Traffic
Engineering
with
MPLS
‚Äù
,
RFC
3346
,
agosto
2002
.


[
RFC
3376
]
B.
Cain
,
S.
Deering
,
I.
Kouvelas
,
B.
Fenner
,
A.
Thyagarajan
,
‚Äú
Internet
Group


Management
Protocol
,
Version
3
‚Äù
,
RFC
3376
,
octubre
2002
.


[
RFC
3390
]
M.
Allman
,
S.
Floyd
,
C.
Partridge
,
‚Äú
Increasing
TCP‚Äôs
Initial
Window
‚Äù
,
RFC
3390
,


octubre
2002
.


[
RFC
3410
]
J.
Case
,
R.
Mundy
,
D.
Partain
,
‚Äú
Introduction
and
Applicability
Statements
for
Internet


Standard
Management
Framework
‚Äù
,
RFC
3410
,
diciembre
2002
.


[
RFC
3411
]
D.
Harrington
,
R.
Presuhn
,
B.
Wijnen
,
‚Äú
An
Architecture
for
Describing
Simple
Network


Management
Protocol
(
SNMP
)
Management
Frameworks
‚Äù
,
RFC
3411
,
diciembre
2002
.


[
RFC
3414
]
U.
Blumenthal
,
‚Äú
User-based
Security
Model
(
USM
)
for
version
3
of
the
Simple
Network


Management
Protocol
(
SNMPv3
)
,
‚Äù
RFC
3414
,
diciembre
2002
.


[
RFC
3415
]
B.
Wijnen
,
R.
Presuhn
,
K.
McCloghrie
,
‚Äú
View-based
Access
Control
Model
(
V
ACM
)
for


the
Simple
Network
Management
Protocol
(
SNMP
)
,
‚Äù
RFC
3415
,
diciembre
2002
.


[
RFC
3416
]
R.
Presuhn
,
J.
Case
,
K.
McCloghrie
,
M.
Rose
,
S.
Waldbusser
,
‚Äú
Version
2
of
the
Protocol


Operations
for
the
Simple
Network
Management
Protocol
(
SNMP
)
,
‚Äù
diciembre
2002
.


[
RFC
3417
]
R.
Presuhn
,
‚Äú
Transport
Mappings
for
the
Simple
Network
Management
Protocol
‚Äù
,


(
SNMP
)
,
RFC
3417
,
diciembre
2002
.


[
RFC
3439
]
R.
Bush
and
D.
Meyer
,
‚Äú
Some
internet
architectural
guidelines
and
philosophy
‚Äù
,
RFC


3439
,
diciembre
2003
.


[
RFC
3468
]
L.
Andersson
,
G.
Swallow
,
‚Äú
The
Multiprotocol
Label
Switching
(
MPLS
)
Working
Group


Decision
on
MPLS
Signaling
Protocols
‚Äù
,
RFC
3468
,
febrero
2003
.


[
RFC
3469
]
V.
 
S
h
a
r
m
a
,
 
E
d
.
,
 
F.
 
H
e
l
l
s
t
r
a
n
d
,
 
E
d
,
 
‚Äú
F
r
a
m
e
w
o
r
k
 
f
o
r
 
M
u
l
t
i
-
P
r
o
t
o
c
o
l
 
L
a
b
e
l
 
S
w
i
t
c
h
i
n
g


(
MPLS)-based
Recovery
‚Äù
,
RFC
3469
,
febrero
2003
.
ftp://ftp.rfc-editor.org/in-notes/rfc3469.txt


[
RFC
3501
]
M.
Crispin
,
‚Äú
Internet
Message
Access
Protocol‚ÄîVersion
4rev1
‚Äù
,
RFC
3501
,
marzo


2003
.


[
RFC
3550
]
H.
Schulzrinne
,
S.
Casner
,
R.
Frederick
,
V
.
Jacobson
,
‚Äú
RTP
:
A
Transport
Protocol
for


Real-Time
Applications
‚Äù
,
RFC
3550
,
julio
2003
.


[
RFC
3569
]
S.
Bhattacharyya
(
ed
.
)
,
‚Äú
An
Overview
of
Source-Specific
Multicast
(
SSM
)
,
‚Äù
RFC
3569
,


julio
2003
.


[
RFC
3588
]
P.
Calhoun
,
J.
Loughney
,
E.
Guttman
,
G.
Zorn
,
J.
Arkko
,
‚Äú
Diameter
Base
Protocol
‚Äù
,
RFC


3588
,
septiembre
2003
.


[
RFC
3618
]
B.
Fenner
,
D.
Meyer
,
Ed
.
,
‚Äú
Multicast
Source
Discovery
Protocol
(
MSDP
)
,
‚Äù
RFC
3618
,


octubre
2003
.


[
RFC
3649]S.
Floyd
,
‚Äú
High
Speed
TCP
for
Large
Congestion
Windows
‚Äù
,
RFC
3649
,
diciembre
2003
.


[
RFC
3782
]
S.
Floyd
,
T.
Henderson
,
A.
Gurtov
,
‚Äú
The
NewReno
Modification
to
TCP‚Äôs
Fast
Recovery


Algorithm
‚Äù
,
RFC
3782
,
abril
2004
.


[
RFC
3973
]
A.
Adams
,
J.
Nicholas
,
W.
Siadak
,
‚Äú
Protocol
Independent
Multicast‚ÄîDense
Mode


(
PIM-DM
):
Protocol
Specification
(
Revised
)
,
‚Äù
RFC
3973
,
enero
2005
.


[
RFC
4022
]
R.
Raghunarayan
,
Ed
.
,
‚Äú
Management
Information
Base
for
the
Transmission
Control


Protocol
(
TCP
)
,
‚Äù
RFC
4022
,
marzo
2005
.


[
RFC
4113
]
B.
Fenner
,
J.
Flick
,
‚Äú
Management
Information
Base
for
the
User
Datagram
Protocol


(
UDP
)
,
‚Äù
RFC
4113
,
junio
2005
.


[
RFC
4213
]
E.
Nordmark
,
R.
Gilligan
,
‚Äú
Basic
Transition
Mechanisms
for
IPv6
Hosts
and
Routers
‚Äù
,


RFC
4213
,
octubre
2005
.


786
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
786[RFC
4271
]
Y.
 
R
e
k
h
t
e
r
,
 
T.
 
L
i
,
 
S
.
 
H
a
r
e
s
,
 
E
d
.
,
 
‚Äú
A
B
o
r
d
e
r
 
G
a
t
e
w
a
y
 
P
r
o
t
o
c
o
l
 
4
 
(
B
G
P
-
4
)
,
‚Äù
 
R
F
C
 
4
2
7
1
,


enero
2006
.


[
RFC
4272
]
S.
Murphy
,
‚Äú
BGP
Security
Vulnerabilities
Analysis
‚Äù
,
RFC
4274
,
enero
2006
.


[
RFC4274
]
Meyer
,
D.
y
K.
Patel
,
‚Äú
BGP-4
Protocol
Analysis
‚Äù
,
RFC
4274
,
enero
2006
.


[
RFC4276
]
Hares
,
S.
y
A.
Retana
,
‚Äú
BGP
4
Implementation
Report
‚Äù
,
RFC
4276
,
enero
2006
.


[
RFC
4291
]
R.
Hinden
,
S.
Deering
,
‚Äú
IP
Version
6
Addressing
Architecture
‚Äù
,
RFC
4291
,
febrero
2006
.


[
RFC
4293
]
S.
Routhier
,
Ed
.
‚Äú
Management
Information
Base
for
the
Internet
Protocol
(
IP
)
,
‚Äù
RFC


4293
,
abril
2006
.


[
RFC
4301
]
S.
Kent
,
K.
Seo
,
‚Äú
Security
Architecture
for
the
Internet
Protocol
‚Äù
,
RFC
4301
,
diciembre


2005
.


[
RFC
4302
]
S.
Kent
,
‚Äú
IP
Authentication
Header
‚Äù
,
RFC
4302
,
diciembre
2005
.


[
RFC
4303
]
S.
Kent
,
‚Äú
IP
Encapsulating
Security
Payload
(
ESP
)
,
‚Äù
RFC
4303
,
diciembre
2005
.


[
RFC
4305
]
D.
Eastlake
,
‚Äú
Cryptographic
Algorithm
Implementation
Requirements
for
Encapsulating


Security
Payload
(
ESP
)
and
Authentication
Header
(
AH
)
,
‚Äù
RFC
4305
,
diciembre
2005
.


[
RFC
4340
]
E.
Kohler
,
M.
Handley
,
S.
Floyd
,
‚Äú
Datagram
Congestion
Control
Protocol
(
DCCP
)
,
‚Äù


RFC
4340
,
marzo
2006
.


[
RFC
4443
]
A.
Conta
,
S.
Deering
,
M.
Gupta
,
Ed
.
,
‚Äú
Internet
Control
Message
Protocol
(
ICMPv6
)
for


the
Internet
Protocol
Version
6
(
IPv6
)
Specification
‚Äù
,
RFC
4443
,
marzo
2006
.


[
RFC
4346
]
T.
Dierks
,
E.
Rescorla
,
‚Äú
The
Transport
Layer
Security
(
TLS
)
Protocol
Version
1.1
‚Äù
,
RFC


4346
,
abril
2006
.


[
RFC
4502
]
S.
Waldbusser
,
‚Äú
Remote
Network
Monitoring
Management
Information
Base
Version
2
‚Äù
,


RFC
4502
,
mayo
2006
.


[
RFC
4601
]
B.
Fenner
,
M.
Handley
,
H.
Holbrook
,
I.
Kouvelas
,
‚Äú
Protocol
Independent
Multicast
‚Äî


Sparse
Mode
(
PIM-SM
):
Protocol
Specification
(
Revised
)
,
‚Äù
RFC
4601
,
agosto
2006
.


[
RFC
4607
]
H.
Holbrook
,
B.
Cain
,
‚Äú
Source-Specific
Multicast
for
IP
‚Äù
,
RFC
4607
,
agosto
2006
.


[
RFC
4611
]
M.
McBride
,
J.
Meylor
,
D.
Meyer
,
‚Äú
Multicast
Source
Discovery
Protocol
(
MSDP
)


Deployment
Scenarios
‚Äù
,
RFC
4611
,
agosto
2006
.


[
RFC
4632
]
V.
 
F
u
l
l
e
r
,
 
T.
 
L
i
,
 
‚Äú
C
l
a
s
s
l
e
s
s
 
I
n
t
e
r-
d
o
m
a
i
n
 
R
o
u
t
i
n
g
 
(
C
I
D
R
)
:
 
T
h
e
 
I
n
t
e
r
n
e
t
 
A
d
d
r
e
s
s


Assignment
and
Aggregation
Plan
‚Äù
,
RFC
4632
,
agosto
2006
.


[
RFC
5000
]
RFC
editor
,
‚Äú
Internet
Official
Protocol
Standards
‚Äù
,
RFC
5000
,
mayo
2008
.


[
RFC
5110
]
P.
Savola
,
‚Äú
Overview
of
the
Internet
Multicast
Routing
Architecture
‚Äù
,
RFC
5110
,
enero


2008
.


[
RFC
5218
]
D.
Thaler
,
B.
Aboba
,
‚Äú
What
Makes
For
a
Successful
Protocol
?
,
‚Äù
RFC
5218
,
julio
2008
.


[
RFC
5321
]
J.
Klensin
,
‚Äú
Simple
Mail
Transfer
Protocol
‚Äù
,
RFC
5321
,
octubre
2008
.


[
RFC
5322
]
P.
Resnick
,
Ed
.
,
‚Äú
Internet
Message
Format
‚Äù
,
RFC
5322
octubre
2008
.


[
RFC
5348
]
S.
Floyd
,
M.
Handley
,
J.
Padhye
,
J.Widmer
,
‚Äú
TCP
Friendly
Rate
Control
(
TFRC
):


Protocol
Specification
‚Äù
,
RFC
5348
,
septiembre
.
2008
.


[
RFC
5411
]
J
Rosenberg
,
‚Äú
A
Hitchhiker‚Äôs
Guide
to
the
Session
Initiation
Protocol
(
SIP
)
,
‚Äù
RFC
5411
,


febrero
2009
.


[
Rhee
1998
]
I.
Rhee
,
‚Äú
Error
Control
Techniques
for
Interactive
Low-bit
Rate
Video
Transmission


over
the
Internet
‚Äù
,
Proc
.
1998
ACM
SIGCOMM
(
Vancouver
BC
,
agosto
1998
)
.


[
Roberts
1967
]
L.
Roberts
,
T.
Merril
,
‚Äú
Toward
a
Cooperative
Network
of
Time-Shared
Computers
‚Äù
,


AFIPS
Fall
Conference
,
octubre
1966
.


[
Roberts
2004
]
J.
Roberts
,
‚Äú
Internet
Traffic
,
QoS
and
Pricing
‚Äù
,
Proceedings
of
the
IEEE
,
V
ol
.
92
,


N¬∫
9
(
septiembre
2004
)
,
p√°gs
.
1389‚Äì1399
.


[
Rom
1990
]
R.
Rom
,
M.
Sidi
,
Multiple
Access
Protocols
:
Performance
and
Analysis
,
Springer-


Verlag
,
Nueva
York
,
1990
.


REFERENCIAS
787


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
787[Root-servers
2009
]
http://www.root-servers.org/


[
Rose
1996
]
M.
Rose
,
The
Simple
Book
:
An
Introduction
to
Internet
Management
,
Revised
Second


Edition
,
Prentice
Hall
,
Englewood
Cliffs
,
NJ
,
1996
.


[
Rosenberg
2000
]
J.
Rosenberg
,
L.
Qiu
,
H.
Schulzrinne
,
‚Äú
Integrating
Packet
FEC
into
Adaptive


Playout
Buffer
Algorithms
on
the
Internet
‚Äù
,
Proc
.
2000
IEEE
Infocom
(
Tel
Aviv
,
Israel
,
abril
2000
)
.


[
Ross
1995
]
K.
W.
Ross
,
Multiservice
Loss
Models
for
Broadband
Telecommunication
Networks
,


Springer
,
Berl√≠n
,
1995
.


[
Ross
2009
]
K.
W.
Ross
,
PowerPoint
slides
on
network
Security
,
http://cis.poly.edu/~ross


[
Rowston
2001
]
A.
Rowston
,
P.
Druschel
,
‚Äú
Pastry
:
Scalable
,
Distributed
Object
Location
and
Routing


for
Large-Scale
Peer-to-Peer
Systems
‚Äù
,
in
Proc
.
2001
IFIP
/
ACM
Middleware
,
Heidelberg
,
Alemania
,


2001
.


[
RSA
1978
]
R.
Rivest
,
A.
Shamir
,
L.
Adelman
,
‚Äú
A
Method
for
Obtaining
Digital
Signatures
and


Public-key
Cryptosystems
‚Äù
,
Communications
of
the
ACM
,
V
ol
.
21
,
N¬∫
2
,
p√°gs
.
120‚Äì126
,
febrero
1978
.


[
RSA
Fast
2009
]
RSA
Laboratories
,
‚Äú
How
fast
is
RSA
?
‚Äù
http://www.rsa.com/rsalabs/node


.asp?id=2215


[
RSA
Key
2009
]
RSA
Laboratories
,
‚Äú
How
large
a
key
should
be
used
in
the
RSA
Crypto
system
?
‚Äù


http://www.rsa.com/rsalabs/node.asp?id=2218


[
Rubenstein
1998
]
D.
Rubenstein
,
J.
Kurose
,
D.
Towsley
,
‚Äú
Real-Time
Reliable
Multicast
Using


Proactive
Forward
Error
Correction
‚Äù
,
Proceedings
of
NOSSDAV
‚Äô
98(Cambridge
,
UK
,
julio
1998
)
.


[
Rubin
2001
]
A.
Rubin
,
White-Hat
Security
Arsenal
:
Tackling
the
Threats
,
Addison-Wesley
,
2001
.


[
Ruiz-Sanchez
2001
]
M.
Ruiz-S√°nchez
,
E.
Biersack
,
W.
Dabbous
,
‚Äú
Survey
and
Taxonomy
of
IP


Address
Lookup
Algorithms
‚Äù
,
IEEE
Network
Magazine
,
V
ol
.
15
,
N¬∫
2
,
p√°gs
.
8‚Äì23
,
marzo
/
abril
2001
.


[
Saltzer
1984
]
J.
Saltzer
,
D.
Reed
,
D.
Clark
,
‚Äú
End-to-End
Arguments
in
System
Design
‚Äù
,
ACM


Transactions
on
Computer
Systems
(
TOCS
)
,
Vo
l
.
 
2
,
 
N
¬∫
 
4
 
(
n
o
v
i
e
m
b
r
e
 
1
9
8
4
)
.


[
Saroiu
2002
]
S.
Saroiu
,
P.K.
Gummadi
,
S.D.
Gribble
,
‚Äú
A
Measurement
Study
of
Peer-to-Peer
File


Sharing
Systems
‚Äù
,
Proc
.
of
Multimedia
Computing
and
Networking
(
MMCN),2002
.


[
Saroiu
2002b
]
S.
Saroiu
,
K.
P.
Gummadi
,
R.
J.
Dunn
,
S.
D.
Gribble
y
H.
M.
Levy
,
‚Äú
An
Analysis
of


Internet
Content
Delivery
Systems
‚Äù
,
USENIX
OSDI
,
2002
.


[
Saydam
1996
]
T.
Saydam
,
T.
Magedanz
,
‚Äú
From
Networks
and
Network
Management
into
Service


and
Service
Management
‚Äù
,
Journal
of
Networks
and
System
Management
,
Vo
l
.
 
4
,
 
N
¬∫
 
4
 
(
d
i
c
i
e
m
b
r
e


1996
)
,
p√°gs
.
345‚Äì348
.


[
Schiller
2003
]
J.
Schiller
,
Mobile
Communications
2¬™
edici√≥n
,
Addison
Wesley
,
2003
.


[
Schneier
1995
]
B.
Schneier
,
Applied
Cryptography
:
Protocols
,
Algorithms
,
and
Source
Code
in
C
,


John
Wiley
and
Sons
,
1995
.


[
Schulzrinne
1997
]
H.
Schulzrinne
,
‚Äú
A
Comprehensive
Multimedia
Control
Architecture
for
the


Internet
‚Äù
,
NOSSDAV‚Äô97
(
Network
and
Operating
System
Support
for
Digital
Audio
and
Video)(St
.


Louis
,
MO
,
mayo
1997
)
.


[
Schulzrinne-RTP
2009
]
Sitio
RTP
de
Henning
Schulzrinne
:
http://www.cs.columbia.edu/~hgs/rtp


[
Schulzrinne-RTSP
2009
]
Sitio
de
RTSP
de
Henning
Schulzrinne
:
http://www.cs.columbia.edu/~hgs/


rtsp


[
Schulzrinne-SIP
2009]Sitio
SIP
de
Henning
Schulzrinne
:
http://www.cs.columbia.edu/~hgs/sip


[
Schwartz
1977
]
M.
Schwartz
,
Computer-Communication
Network
Design
and
Analysis
,
Prentice-


Hall
,
Englewood
Cliffs
,
N.J.
,
1997
.


[
Schwartz
1980
]
M.
Schwartz
,
Information
,
Transmission
,
Modulation
,
and
Noise
,
McGraw
Hill
,


NY
,
NY
1980
.


[
Schwartz
1982
]
M.
Schwartz
,
‚Äú
Performance
Analysis
of
the
SNA
Virtual
Route
Pacing
Control
‚Äù
,


IEEE
Transactions
on
Communications
,
V
ol
.
30
,
N¬∫
1
(
enero
1982
)
,
p√°gs
.
172‚Äì184
.


788
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
788[Scourias
2009
]
J.
Scourias
,
‚Äú
Overview
of
the
Global
System
for
Mobile
Communications
:
GSM
.
‚Äù


http://www.privateline.com/PCS/GSM0.html


[
Segaller
1998
]
S.
Segaller
,
Nerds
2.0.1
,
A
Brief
History
of
the
Internet
,
TV
Books
,
Nueva
York
,


1998
.


[
Shacham
1990
]
N.
Shacham
,
P.
McKenney
,
‚Äú
Packet
Recovery
in
High-Speed
Networks
Using


Coding
and
Buffer
Management
‚Äù
,
Proc
.
1990
IEEE
Infocom
(
San
Francisco
,
CA
,
abril
1990
)
,
p√°gs
.


124‚Äì131
.


[
Sharma
2003
]
P.
Sharma
,
E
,
Perry
,
R.
Malpani
,
‚Äú
IP
Multicast
Operational
Network
management
:


Design
,
Challenges
,
and
Experiences
‚Äù
,
IEEE
Network
Magazine
,
marzo
2003
,
p√°gs
.
49‚Äì55
.


[
Sidor
1998
]
D.
Sidor
,
‚Äú
TMN
Standards
:
Satisfying
Today‚Äôs
Needs
While
Preparing
for
Tomorrow
‚Äù
,


IEEE
Communications
Magazine
,
V
ol
.
36
,
N¬∫
3
(
marzo
1998
)
,
p√°gs
.
54‚Äì64
.


[
SIP
Software
2009
]
H.
Schulzrinne
Software
Package
site
,
http://www.cs.columbia.edu/IRT/


software


[
Skoudis
2004
]
E.
Skoudis
,
L.
Zeltser
,
Malware
:
Fighting
Malicious
Code
,
Prentice
Hall
,
2004
.


[
Skoudis
2006
]
E.
Skoudis
,
T.
Liston
,
Counter
Hack
Reloaded
:
A
Step-by-Step
Guide
to
Computer


Attacks
and
Effective
Defenses
(
2¬™
ed
.
)
,
Prentice
Hall
,
2006
.


[
Skype
2009
]
P√°gina
principal
de
Skype
:
www.skype.com


[
SMIL
2009
]
P√°gina
principal
de
W3C
Synchronized
Multimedia
:
http://www.w3.org/AudioVideo


[
Snort
2009
]
P√°gina
principal
de
Sourcefire
Inc
.
,
Snort
:
http://http://www.snort.org/


[
Solari
1997]S.
J.
Solari
,
Digital
Video
and
Audio
Compression
,
McGraw
Hill
,
NY
,
NY
,
1997
.


[
Solensky
1996
]
F.
Solensky
,
‚Äú
IPv4
Address
Lifetime
Expectations
‚Äù
,
in
IPng
:
Internet
Protocol
Next


Generation
(
S.
Bradner
,
A.
Mankin
,
ed
.
)
,
Addison-Wesley
,
Reading
,
MA
,
1996
.


[
Spragins
1991
]
J.
D.
Spragins
,
Telecommunications
Protocols
and
Design
,
Addison-Wesley
,


Reading
,
MA
,
1991
.


[
Sprint
2009
]
Sprint
Corp
.
,
‚Äú
Dedicated
Internet
Access
Service
Level
Agreements
‚Äù
,
http://
www
.


sprint.com/business/resources/dedicated_internet_access.pdf


[
Srikant
2004
]
R.
Srikant
,
The
Mathematics
of
Internet
Congestion
Control
,
Birkhauser
,
2004


[
Srinivasan
1999
]
V.
 
S
r
i
n
i
v
a
s
a
n
 
y
 
G
.
 
Va
rg
h
e
s
e
,
 
‚Äú
F
a
s
t
 
A
d
d
r
e
s
s
 
L
o
o
k
u
p
 
U
s
i
n
g
 
C
o
n
t
r
o
l
l
e
d
 
P
r
e
f
i
x


Expansion
‚Äù
,
ACM
Transactions
Computer
Sys
.
,
V
ol
.
17
,
N¬∫
1
(
febrero
1999
)
,
p√°gs
.
1‚Äì40
.


[
Sripanidkulchai
2004
]
K.
Sripanidkulchai
,
B.
Maggs
y
H.
Zhang
,
‚Äú
An
analysis
of
live
streaming


workloads
on
the
Internet
‚Äù
,
Proc
.
4th
ACM
SIGCOMM
Internet
Measurement
Conference(Taormina
,


Sicilia
,
Italia
)
,
p√°gs
.
41‚Äì54
,
2004
.


[
Stallings
1993
]
W.
Stallings
,
SNMP
,
SNMP
v2
,
and
CMIP
The
Practical
Guide
to
Network


Management
Standards
,
Addison-Wesley
,
Reading
,
MA
,
1993
.


[
Stallings
1999
]
W.
Stallings
,
SNMP
,
SNMPv2
,
SNMPv3
,
and
RMON
1
and
2,Addison-Wesley
,


Reading
,
MA
,
1999
.


[
Steinder
2002
]
M.
Steinder
,
A.
Sethi
,
‚Äú
Increasing
robustness
of
fault
localization
through
analysis
of


lost
,
spurious
,
and
positive
symptoms
‚Äù
,
Proc
.
2002
IEEE
Infocom
.


[
Stevens
1990
]
W.
R.
Stevens
,
Unix
Network
Programming
,
Prentice-Hall
,
Englewood
Cliffs
,
NJ
.


[
Stevens
1994
]
W.
R.
Stevens
,
TCP
/
IP
Illustrated
,
Vol
.
1
:
The
Protocols
,
Addison-Wesley
,
Reading
,


MA
,
1994
.


[
Stevens
1997
]
W.R.
Stevens
,
Unix
Network
Programming
,
Volume
1
:
Networking
APIs-Sockets
and


XTI
,
2nd
edition
,
Prentice-Hall
,
Englewood
Cliffs
,
NJ
,
1997
.


[
Stewart
1999]J.
Stewart
,
BGP4
:
Interdomain
Routing
in
the
Internet
,
Addison-Wesley
,
1999
.


[
Stoica
2001
]
I.
Stoica
,
R.
Morris
,
D.
Karger
,
M.F.
Kaashoek
,
H.
Balakrishnan
,
‚Äú
Chord
:
A
Scalable


Peer-to-Peer
Lookup
Service
for
Internet
Applications
‚Äù
,
Proc
.
2001
ACM
SIGCOMM
(
San
Diego
,


CA
,
agosto
2001
)
.


REFERENCIAS
789


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
789[Stone
1998
]
J.
Stone
,
M.
Greenwald
,
C.
Partridge
,
J.
Hughes
,
‚Äú
Performance
of
Checksums
and


CRC‚Äôs
Over
Real
Data
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
Vo
l
.
 
6
,
 
N
¬∫
 
5
 
(
o
c
t
u
b
r
e
 
1
9
9
8
)
,
p√°gs
.


529‚Äì543
.


[
Stone
2000
]
J.
Stone
,
C.
Partridge
,
‚Äú
When
Reality
and
the
Checksum
Disagree
‚Äù
,
Proc
.
2000
ACM


SIGCOMM
(
Estocolmo
,
Suecia
,
agosto
2000
)
.


[
Strayer
1992
]
W.
T.
Strayer
,
B.
Dempsey
,
A.
Weaver
,
XTP
:
The
Xpress
Transfer
Protocol
,
Addison-


Wesley
,
Reading
,
MA
,
1992
.


[
Stubblefield
2002
]
A.
Stubblefield
,
J.
Ioannidis
,
A.
Rubin
,
‚Äú
Using
the
Fluhrer
,
Mantin
,
and
Shamir


Attack
to
Break
WEP
‚Äù
,
Proceedings
of
2002
Network
and
Distributed
Systems
Security
Symposium


(
2002
)
,
17‚Äì22
.


[
Subramanian
2000
]
M.
Subramanian
,
Network
Management
:
Principles
and
Practice
,
Addison-


Wesley
,
Reading
,
MA
,
2000
.


[
Subramanian
2002
]
L.
Subramanian
,
S.
Agarwal
,
J.
Rexford
,
R.
Katz
,
‚Äú
Characterizing
the
Internet


Hierarchy
from
Multiple
Vantage
Points
‚Äù
,
Proc
.
2002
IEEE
Infocom
.


[
Sundaresan
2006
]
K.Sundaresan
,
K.
Papagiannaki
,
‚Äú
The
Need
for
Cross-layer
Information
in


Access
Point
Selection
‚Äù
,
Proc
.
2006
ACM
Internet
Measurement
Conference(R√≠o
de
Janeiro
,
octubre


2006
)
.


[
Su
2006
]
A.-J.
Su
,
D.
Choffnes
,
A.
Kuzmanovic
y
F.
Bustamante
,
‚Äú
Drafting
Behind
Akamai
‚Äù
ACM


SIGCOMM
,
septiembre
2006
.


[
Suh
2006
]
K.
Suh
,
D.
R.
Figueiredo
,
J.
Kurose
y
D.
Towsley
,
‚Äú
Characterizing
and
detecting
relayed


traffic
:
A
case
study
using
Skype
‚Äù
,
Proc
.
2006
IEEE
Infocom
(
Barcelona
,
Espa√±a
,
abril
2006
)
.


[
Sunshine
1978
]
C.
Sunshine
,
Y
.
Dalal
,
‚Äú
Connection
Management
in
Transport
Protocols
‚Äù
,
Computer


Networks
,
North-Holland
,
Amsterdam
,
1978
.


[
TechnOnLine
2009
]
TechOnLine
,
‚Äú
Protected
Wireless
Networks
‚Äù
,
online
webcast
tutorial
,
http:/


/www.techonline.com
/
community
/
tech_topic
/
internet/21752


[
Thaler
1997
]
D.
Thaler
and
C.
Ravishankar
,
‚Äú
Distributed
Center-Location
Algorithms
‚Äù
,
IEEE


Journal
on
Selected
Areas
in
Communications
,
V
ol
.
15
,
N¬∫
3
,
(
abril
1997
)
,
p√°gs
.
291‚Äì303
.


[
Think
2009
]
Technical
History
of
Network
Protocols
,
‚Äú
Cyclades
‚Äù
,
http://www.cs.utexas
.edu
/
users/


chris
/
think
/
Cyclades
/
index.shtml


[
Thottan
1998
]
M.
Thottan
,
C.
Ji
,
‚Äú
Proactive
Anomaly
Detection
Using
Distributed
Intelligent


Agents
‚Äù
,
IEEE
Network
Magazine
,
V
ol
.
12
,
N¬∫
5
(
sept./oct
.
1998
)
,
p√°gs
.
21‚Äì28
.


[
Tobagi
1990
]
F.
Tobagi
,
‚Äú
Fast
Packet
Switch
Architectures
for
Broadband
Integrated
Networks
‚Äù
,


Proc
.
of
the
IEEE
,
V
ol
.
78
,
N¬∫
1
(
enero
1990
)
,
p√°gs
.
133‚Äì167
.


[
TOR
2009
]
Tor
:
Anonymity
Online
,
http://www.torproject.org


[
Turner
1988
]
J.
S.
Turner
‚Äú
Design
of
a
Broadcast
packet
switching
network
‚Äù
,
IEEE
Transactions
on


Communications
,
V
ol
.
36
,
N¬∫
6
(
junio
1988
)
,
p√°gs
.
734‚Äì743
.


[
Turner
2009
]
B.
Turner
,
‚Äú
2
G
,
3
G
,
4
G
Wireless
Tutorial
‚Äù
,
http://blogs.nmscommunications
.com/


communications/2008/10/2g-3g-4g-wireless-tutorial.html


[
UPnP
Forum
2009
]
P√°gina
principal
de
UPnP
Forum
:
http://www.upnp.org/


[
van
der
Berg
2008
]
R.
van
der
Berg
,
‚Äú
How
the
‚Äò
Net
works
:
an
introduction
to
peering
and
transit
‚Äù
,


http://arstechnica.com/guides/other/peering-and-transit.ars


[
Varghese
1997
]
G.
Varghese
,
A.
Lauck
,
‚Äú
Hashed
and
Hierarchical
Timing
Wheels
:
Efficient
Data


Structures
for
Implementing
a
Timer
Facility
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
V
ol
.
5
,
N¬∫
6


(
diciembre
1997
)
,
p√°gs
.
824‚Äì834
.


[
Vasudevan
2006
]
S.
Vasudevan
,
C.
Diot
,
J.
Kurose
,
D.
Towsley
,
‚Äú
Facilitating
Access
Point
Selection


in
IEEE
802.11
Wireless
Networks
‚Äù
,
Proc
.
2005
ACM
Internet
Measurement
Conference(San


Francisco
CA
,
octubre
2005
)
.


790
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
790[Verizon
2009
]
Verizon
,
‚Äú
US
Products
and
Services
‚Äù
,
http://www.verizonbusiness.com/terms/us/


products/


[
Verizon
FIOS
2009
]
FIOS
FAQ
,
http://www22.verizon.com/Residential/FiOSInternet/FAQ/FAQ
.


htm


[
Verma
2001]D.
C.
Verma
,
Content
Distribution
Networks
:
An
Engineering
Approach
,
John
Wiley
,


2001
.


[
Villamizar
1994
]
C.
Villamizar
,
C.
Song
.
‚Äú
High
performance
tcp
in
ansnet
‚Äù
,
ACM
SIGCOMM


Computer
Communications
Review
,
V
ol
.
24
,
N¬∫
5
(
1994
)
,
p√°gs
.
45‚Äì60
.


[
Viterbi
1995
]
A.
Viterbi
,
CDMA
:
Principles
of
Spread
Spectrum
Communication
,
Addison-Wesley
,


Reading
,
MA
,
1995
.


[
Voydock
1983
]
V
.
L.
V
oydock
,
S.T.
Kent
,
‚Äú
Security
Mechanisms
in
High-Level
Network
Protocols
‚Äù
,


ACM
Computing
Surveys
,
V
ol
.
15
,
N¬∫
2
(
junio
1983
)
,
p√°gs
.
135‚Äì171
.


[
W3C
1995
]
The
World
Wide
Web
Consortium
,
‚Äú
A
Little
History
of
the
World
Wide
Web
‚Äù
,
1995
.


http://www.w3.org/History.html


[
Wakeman
1992
]
I.
Wakeman
,
J.
Crowcroft
,
Z.
Wang
,
D.
Sirovica
,
‚Äú
Layering
Considered
Harmful
‚Äù
,


IEEE
Network
,
enero
1992
,
p√°gs
.
20‚Äì24
.


[
Waldvogel
1997
]
M.
Waldvogel
et
al
.
,
‚Äú
Scalable
High
Speed
IP
Routing
Lookup
‚Äù
,
Proc
.
1997
ACM


SIGCOMM
(
Cannes
,
Francia
,
septiembre
1997
)
.


[
Walker
2000]J.
Walker
,
‚Äú
IEEE
P802.11
Wireless
LANs
,
Unsafe
at
Any
Key
Size
;
An
Analysis
of
the


WEP
Encapsulation
‚Äù
,
Oct
.
2000
,
http://www.drizzle.com/~aboba/IEEE/0-362.zip


[
Wall
1980
]
D.
Wall
,
Mechanisms
for
Broadcast
and
Selective
Broadcast
,
Ph
.
D.
thesis
,
Stanford


University
,
junio
1980
.


[
Wang
2004
]
B.
Wang
,
J.
Kurose
,
P.
Shenoy
,
D.
Towsley
,
‚Äú
Multimedia
Streaming
via
TCP
:
An


Analytic
Performance
Study
‚Äù
,
Proc
.
ACM
Multimedia
Conf
.
(
NY
,
NY
,
octubre
2004
)
.


[
Weatherspoon
2000
]
S.
Weatherspoon
,
‚Äú
Overview
of
IEEE
802.11b
Security
‚Äù
,
Intel
Technology


Journal
,
(
2nd
Quarter
2000
)
,
http://download.intel.com/technology/itj/q22000/pdf/art_5.pdf


[
Wei
2005
]
W.
Wei
,
B.
Wang
,
C.
Zhang
,
J.
Kurose
,
D.
Towsley
,
‚Äú
Classification
of
Access
Network


Types
:
Ethernet
,
Wireless
LAN
,
ADSL
,
Cable
Modem
or
Dialup
?
,
‚Äù
Proc
.
2005
IEEE
Infocom
(
abril


2005
)
.


[
Wei
2006
]
W.
Wei
,
C.
Zhang
,
H.
Zang
,
J.
Kurose
,
D.
Towsley
,
‚Äú
Inference
and
Evaluation
of
Split-


Connection
Approaches
in
Cellular
Data
Networks
‚Äù
,
Proc
.
Active
and
Passive
Measurement


Workshop
(
Adelaide
,
Australia
,
marzo
2006
)
.


[
Wei
2007
]
D.
X.
Wei
,
C.
Jin
,
S.
H.
Low
,
S.
Hegde
,
‚Äú
FAST
TCP
:
Motivation
,
Architecture
,


Algorithms
,
Performance
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
2007
.


[
Weiser
1991
]
M.
Weiser
,
‚Äú
The
Computer
for
the
Twenty-First
Century
‚Äù
,
Scientific
American


(
septiembre
1991
):
94‚Äì10
.
http://www.ubiq.com/hypertext/weiser/SciAmDraft3.html


[
Wigle.net
2009
]
Wireless
Geographic
Logging
Engine
,
http://www.wigle.net


[
Williams
1993
]
R.
Williams
,
‚Äú
A
Painless
Guide
to
CRC
Error
Detection
Algorithms
‚Äù
,
http://www
.


ross.net/crc/crcpaper.html


[
WiMax
Forum
2009
]
WiMax
Forum
,
http://www.wimaxforum.org


[
Wireshark
2009
]
P√°gina
principal
de
Wireshark
:
http://www.wireshark.org


[
Wischik
2005
]
D.
Wischik
,
N.
McKeown
,
‚Äú
Part
I
:
Buffer
Sizes
for
Core
Routers
‚Äù
,
ACM
SIGCOMM


Computer
Communications
Review
,
V
ol
.
35
,
N¬∫
3
,
julio
2005
.


[
Woo
1994
]
T.
Woo
,
R.
Bindignavle
,
S.
Su
,
S.
Lam
,
‚Äú
SNP
:
an
interface
for
secure
network


programming
‚Äù
,
Proc
.
1994
Summer
USENIX
,
Boston
,
MA
,
junio
1994
,
p√°gs
.
45‚Äì58
.


[
Wood
2009
]
L.
Wood
,
‚Äú
Lloyds
Satellites
Constellations
‚Äù
,
http://www.ee.surrey.ac.uk/Personal/L.


Wood
/
constellations
/
iridium.html


REFERENCIAS
791


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
791[Xanadu
2009
]
P√°gina
principal
del
proyecto
Xanadu
:
http://www.xanadu.com/


[
Xiao
2000
]
X.
Xiao
,
A.
Hannan
,
B.
Bailey
,
L.
Ni
,
‚Äú
Traffic
Engineering
with
MPLS
in
the
Internet
‚Äù
,


IEEE
Network
,
marzo
/
abril
2000
.


[
Xie
2008
]
H.
Xie
,
Y
.R.
Yang
,
A.
Krishnamurthy
,
Y
.
Liu
,
A.
Silberschatz
,
‚Äú
P4P
:
Provider
Portal
for


Applications
‚Äù
,
Proc
.
ACM
SIGCOMM
(
Seattle
,
agosto
2008
)
.


[
Yannuzzi
2005
]
M.
Yannuzzi
,
X.
Masip-Bruin
,
O.
Bonaventure
,
‚Äú
Open
Issues
in
Interdomain


Routing
:
A
Survey
‚Äù
,
IEEE
Network
Magazine
,
nov./dic
.
2005
.


[
Yavatkar
1994]R.
Yavatkar
,
N.
Bhagwat
,
‚Äú
Improving
End-to-End
Performance
of
TCP
over
Mobile


Internetworks
‚Äù
,
Proc
.
Mobile
94
Workshop
on
Mobile
Computing
Systems
and
Applications
,


diciembre
1994
.


[
Youtube
2009
]
P√°gina
principal
de
Youtube
:
www.youtube.com


[
Yu
2006
]
H.
Yu
,
M.
Kaminsky
,
P.
B.
Gibbons
y
A.
Flaxman
,
SybilGuard
:
Defending
Against
Sybil


Attacks
via
Social
Networks
,
Proc
.
2006
ACM
(
Pisa
,
Italia
,
septiembre
2006
)
.


[
Zegura
1997
]
E.
Zegura
,
K.
Calvert
,
M.
Donahoo
,
‚Äú
A
Quantitative
Comparison
of
Graph-based


Models
for
Internet
Topology
‚Äù
,
IEEE
/
ACM
Transactions
on
Networking
,
Vo
l
.
 
5
,
 
N
¬∫
 
6
,
 
(
d
i
c
i
e
m
b
r
e


1997
)
.
V√©ase
tambi√©n
http://www.cc.gatech.edu/projects/gtim
para
obtener
un
paquete
software
que


permite
generar
redes
con
una
estructura
de
red
terminal
de
tr√°nsito
.


[
Zhang
1993
]
L.
Zhang
,
S.
Deering
,
D.
Estrin
,
S.
Shenker
,
D.
Zappala
,
‚Äú
RSVP
:
A
New
Resource


Reservation
Protocol
‚Äù
,
IEEE
Network
Magazine
,
V
ol
.
7
,
N¬∫
9
(
septiembre
1993
)
,
p√°gs
.
8‚Äì18
.


[
Zhao
2004
]
B.
Y
.
Zhao
,
L.
Huang
,
J.
Stribling
,
S.
C.
Rhea
,
A.
D.
Joseph
,
J.
Kubiatowicz
,
‚Äú
Tapestry
:


AR
e
s
i
l
i
e
n
t
 
G
l
o
b
a
l
-
s
c
a
l
e
 
O
v
e
r
l
a
y
 
f
o
r
 
S
e
r
v
i
c
e
 
D
e
p
l
o
y
m
e
n
t
‚Äù
,
 
IEEE
Journal
on
Selected
Areas
in


Communications
,
V
ol
.
22
,
N¬∫
1
(
enero
2004
)
.


[
Zimmerman
1980
]
H.
Zimmerman
,
‚Äú
OS1
Reference
Model-The
ISO
Model
of
Architecture
for


Open
Systems
Interconnection
‚Äù
,
IEEE
Transactions
on
Communications
,
Vo
l
.
 
2
8
,
 
N
¬∫
 
4
 
(
a
b
r
i
l
 
1
9
8
0
)
,


p√°gs
.
425‚Äì432
.


[
Zimmermann
2009
]
P.
Zimmermann
,
‚Äú
Why
do
you
need
PGP
?
‚Äù
http://www.pgpi.org/doc/whypgp/


en/


792
REFERENCIAS


Z01_KURO9675_05_SE_REF.qxd
 
21/3/10
 
15:02
 
P√°gina
792√çndice


A


Abandono
de
los
pares
,
149‚Äì150


ABR
(
Available
Bit
Rate
)
,
servicio
,
256
,


262‚Äì265
,
306


Acceso
m√∫ltiple
,
420
,
430‚Äì443
,
454‚Äì458
,


506‚Äì508


acceso
celular
a
Internet
,
529‚Äì535


acceso
m√∫ltiple
con
sondeo
de
portadora


(
CSMA
)
,
439‚Äì441
,
454‚Äì458
,


514‚Äì520


acceso
m√∫ltiple
por
divisi√≥n
de
c√≥digo


(
CDMA
)
,
506‚Äì508


ALOHA
protocolos
,
434‚Äì438


canales
de
difusi√≥n
,
417
,
430


capa
de
enlace
,
420
,
430‚Äì443
,
454‚Äì458


colisiones
,
431‚Äì433
,
439‚Äì441
,
514‚Äì520


Ethernet
,
454‚Äì458


FDDI
,
443


multiplexaci√≥n
por
divisi√≥n
de


frecuencia
(
FDM
)
,
433‚Äì434


multiplexaci√≥n
por
divisi√≥n
en
el
tiempo


(
TDM
)
,
433‚Äì434


protocolos
de
acceso
aleatorio
,
434‚Äì442


protocolos
de
particionamiento
del


canal
,
433‚Äì434


protocolos
de
toma
de
turnos
,
441‚Äì442


redes
de
√°rea
local
(
LAN
)
y
,
442‚Äì443
,


508‚Äì529


redes
inal√°mbricas
,
506‚Äì535


retardo
de
propagaci√≥n
del
canal
,


439‚Äì440


tramas
y
,
431‚Äì433


WiFi
,
508‚Äì529


Acceso
telef√≥nico
,
redes
,
13‚Äì14


Acuerdo
de
nivel
de
servicio
(
SLA
)
,
738


Acuerdo
en
tres
fases
,
154
,
230
,
250‚Äì251


Acumulativo
,
reconocimiento
,
219
,
234


Ad
hoc
,
redes
inal√°mbricas
,
501‚Äì502


Adaptaci√≥n
de
la
velocidad
,
WiFi
,
524‚Äì525


Adaptador
de
red
,
422‚Äì424


Agente
ajeno
,
537
,
544


Agentes
de
usuario
,
115


Agregaci√≥n
de
direcciones
,
333


Algoritmo
de
descifrado
,
657


Algoritmo
de
enrutamiento
global
,
355


Algoritmo
de
vector
de
distancias
(
DV
)
,


355
,
360‚Äì367


algoritmo
de
enrutamiento
descentral-


izado
,
355
,
360‚Äì361


Bellman-Ford
,
ecuaci√≥n
,
360‚Äì361


bucle
de
enrutamiento
,
365


coste
del
enlace
,
362‚Äì363


inversa
envenenada
,
365‚Äì366


relaci√≥n
rutas
coste
m√≠nimo
,
360


tablas
de
enrutamiento
,
362‚Äì363


y
algoritmos
de
estado
de
enlaces
,


366‚Äì367


Algoritmos
basados
en
la
conmutaci√≥n
de


circuitos
,
367


Algoritmos
de
enrutamiento
din√°mico
,
355


Algoritmos
descentralizados
,
355
,
360‚Äì361


Algoritmos
est√°ticos
,
355


Alias
del
servidor
de
correo
,
127


ALOHA
con
particiones
,
protocolo
,


435‚Äì438


ALOHA
,
protocolos
,
434‚Äì438


√Åmbito
de
direcciones
privadas
,
NAT
,
340


Ancho
de
banda
,
26
,
89
,
267
,
607


aplicaciones
sensibles
al
,
89


escalado
del
ancho
de
banda
RTCP
,
607


frecuencia
,
26‚Äì27


tanteo
del
,
267


Anycast
,
direcci√≥n
,
347


AON
(
Active
Optical
Network
)
,
17


AP
.
V√©ase
Punto
de
acceso


API
(
Application
Programming
Interface
)
,


6


Aplicaciones
de
red
,
49
,
82‚Äì86
,
95‚Äì151


correo
electr√≥nico
,
115‚Äì125


FTP
,
protocolo
,
49
,
112‚Äì114


P2P
(
Peer-to-Peer
)
,
82‚Äì85
,
139‚Äì151


protocolos
de
la
capa
de
aplicaci√≥n
,
94


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
793Aplicaciones
de
red
(
continuaci√≥n
)


sistema
de
nombres
de
dominio
(
DNS
)
,


49
,
125‚Äì139


World
Wide
Web
,
95‚Äì112


Aplicaciones
distribuidas
,
5‚Äì6
,
10


AQM
(
Active
Queue
Management
)
,
321


√Årbol
basado
en
el
origen
,
395‚Äì396


√Årbol
compartido
por
el
grupo
,
394‚Äì395


√Årbol
de
recubrimiento
,
388‚Äì390


√Årea
troncal
OSPF
,
377


ARP
(
Address
Resolution
Protocol
)
,


445‚Äì450


direccionamiento
de
la
capa
de
enlace
,


445‚Äì450


env√≠o
de
datagramas
a
nodos
,
448‚Äì450


paquete
,
447


subredes
,
448‚Äì450


tabla
,
447‚Äì448


ARPA
(
Advanced
Research
Projects


Agency
)
,
59‚Äì62


ARQ
(
Automatic
Repeat
Request
)
,


protocolos
,
207‚Äì215


bit
alternante
,
214‚Äì215


parada
y
espera
,
208‚Äì209


reconocimientos
(
ACK
)
,
206‚Äì211


reconocimientos
negativos
(
NAK
)
,


206‚Äì211


Arranque
lento
,
TCP
,
268‚Äì269


ASN.1
(
Abstract
Syntax
Notation
One
)
,


746
,
749‚Äì750
,
757‚Äì760


Asociaci√≥n
de
seguridad
(
SA
)
,
700‚Äì701


Ataque
por
interposici√≥n
,
57
,
684


Ataque
por
inundaci√≥n
SYN
,
254‚Äì255


Ataque
por
reproducci√≥n
,
680‚Äì682


ATM
(
Asynchronous
Transfer
Mode
)
,
pro-


tocolo
,
256
,
262‚Äì265


Autenticaci√≥n
del
punto
terminal
,
654
,


669‚Äì684


ataque
por
reproducci√≥n
,
680‚Äì682


ataque
por
interposici√≥n
,
684


autenticaci√≥n
de
clave
p√∫blica
,
682‚Äì684


n√∫meros
distintivos
,
680‚Äì682


Autenticaci√≥n
,
clave
de
,
672


Aut√≥nomos
,
sistemas
(
AS
)
,
368‚Äì384


enrutamiento
de
la
patata
caliente
,
370


enrutamiento
interno
del
sistema


aut√≥nomo
,
368‚Äì369
,
371‚Äì377
,
383


Primero
la
ruta
abierta
m√°s
corta


(
OSPG
)
,
372
,
375‚Äì377


protocolo
de
enrutamiento
entre
sis-


temas
aut√≥nomos
,
369‚Äì370


Protocolo
de
informaci√≥n
de


enrutamiento
(
RIP
)
,
371‚Äì375


Protocolo
de
pasarela
de
frontera


(
BGP
)
,
377‚Äì384


protocolos
del
algoritmo
de


enrutamiento
,
367‚Äì371


routers
de
pasarela
,
368‚Äì369


Autoridad
de
certificaci√≥n
(
CA
)
,
678‚Äì680


B


Base
de
datos
de
asociaciones
de
seguridad


(
SAD
)
,
701


Base
de
datos
de
pol√≠ticas
de
seguridad


(
SPD
)
,
704


Base
de
informaci√≥n
de
gesti√≥n
.
V√©ase


MIB


Bellman-Ford
,
ecuaci√≥n
,
360‚Äì361


BER
(
Basic
Encoding
Rules
)
,
760


BER
(
Bit
Error
Rate
)
,
504‚Äì505


BGP
(
Border
Gateway
Protocol
)
,
377‚Äì384


atributos
,
379‚Äì381


enrutamiento
entre
sistemas
aut√≥nomos
,


377‚Äì384


pares
,
378‚Äì381


pol√≠tica
de
enrutamiento
,
382‚Äì384


prefijos
,
379


selecci√≥n
de
la
ruta
,
381‚Äì382


sesi√≥n
externa
(
eBGP
)
,
378‚Äì379


sesi√≥n
interna
(
iBGP
)
,
378‚Äì379


Bidireccional
,
transferencia
de
datos
,
205


Bit
alternante
,
protocolo
,
214‚Äì215


Bit
de
no
incremento
(
NI
)
,
265


Bit
,
errores
de
,
206‚Äì215


BitTorrent
,
142‚Äì145
,
183‚Äì184


Bloques
de
direcciones
IP
,
335


Bluetooth
(
IEEE
802.15.1
)
,
526‚Äì527


Botnet
,
54


Buffer
cliente
,
580‚Äì581


Buffer
de
emisi√≥n
,
230


Buffer
de
salida
(
cola
)
,
28


C


Caballo
de
Troya
,
55


794
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
794Cabecera
,
campos
de
,
56
,
232
,
602‚Äì603


Cable
de
cobre
de
par
trenzado
,
21‚Äì22


Cable
,
redes
de
,
15‚Äì17


Cach√©
web
(
servidor
proxy
)
,
107‚Äì111


Cach√©
,
107‚Äì111
,
132‚Äì134


Calidad
de
servicio
(
QoS
)
,
632‚Äì638


admisi√≥n
de
llamadas
,
633‚Äì637


establecimiento
de
llamadas
,
633‚Äì637


garant√≠as
multimedia
,
633‚Äì638


Internet
,
servicios
,
637‚Äì638


reserva
de
recursos
,
633


RSVP
,
protocolo
de
reserva
de
recursos
,


636‚Äì637


se√±alizaci√≥n
de
estado
firme
,
636


se√±alizaci√≥n
de
estado
fr√°gil
,
636


servicios
integrados
(
Intserv
)
,
637‚Äì638


CAM
(
Content
Addressable
Memory
)
,
316


Canales
de
radio
terrestres
,
22


Canales
de
radio
v√≠a
sat√©lite
,
23


Capa
de
aplicaci√≥n
,
49
,
52
,
81‚Äì184


aplicaciones
de
red
,
49
,
82‚Äì85
,
94‚Äì151


arquitecturas
de
las
aplicaciones
de
red
,


82‚Äì85


correo
electr√≥nico
(
e-mail
)
,
115‚Äì125


direccionamiento
de
procesos
,
93


HTTP
,
protocolo
,
49
,
95‚Äì111
,
120


Interfaz
de
programaci√≥n
de


aplicaciones
(
API
)
,
87


mensajes
,
49
,
52
,
86


P2P
,
82‚Äì85
,
125‚Äì151


procesos
de
comunicaci√≥n
,
86‚Äì87


Protocolo
de
transferencia
de
archivos


(
FTP
)
,
49
,
112‚Äì114


protocolos
,
49
,
94


seguridad
,
90


servicios
de
transporte
,
88‚Äì94


sistema
de
nombres
de
dominio
(
DNS
)
,


49
,
125‚Äì139


SMTP
,
protocolo
,
49
,
115‚Äì122


socket
,
programaci√≥n
,
87
,
151‚Äì167


SSL
(
Secure
Socket
Layer
)
,
92


tasa
de
transferencia
,
89


TCP
,
protocolo
,
50
,
90‚Äì91
,
92
,
96‚Äì100
,


151‚Äì161


temporizaci√≥n
,
89


transferencia
de
datos
fiable
,
88


UDP
,
protocolo
,
50
,
91‚Äì93
,
151‚Äì167


World
Wide
Web
,
95‚Äì112


Capa
de
enlace
,
4
,
53
,
55
,
417‚Äì496
,


515‚Äì517


acceso
m√∫ltiple
,
420
,
430‚Äì443
,
454‚Äì458


adaptador
de
red
,
422‚Äì424


ARP
,
protocolo
,
445‚Äì450


canales
de
difusi√≥n
,
417
,
430


conexiones
punto
a
punto
,
417‚Äì419
,


430
,
470


Conmutaci√≥n
de
etiquetas
multiproto-


colo
(
MPLS
)
,
474‚Äì477


conmutador
(
switch
)
,
4
,
451
,
460‚Äì470


control
de
acceso
al
medio
(
MAC
)
,
420
,


444‚Äì445


direccionamiento
,
444‚Äì450


Ethernet
,
53
,
450‚Äì460


implementaci√≥n
,
422‚Äì424


nodos
,
419
,
421
,
444‚Äì450


PPP
,
protocolo
,
53
,
419
,
470‚Äì474


protocolo
,
50


reconocimientos
,
WiFi
,
515‚Äì517


redes
de
√°rea
local
(
LAN
)
,
442‚Äì443
,


450‚Äì452
,
460‚Äì470


servicios
proporcionados
por
,
419‚Äì421


solicitudes
de
p√°ginas
web
,
477‚Äì483


tramas
,
53
,
55
,
419‚Äì420
,
431‚Äì433
,


452‚Äì454


Capa
de
red
,
50
,
52
,
186‚Äì190
,
299‚Äì416
,


697‚Äì705


ABR
,
servicio
de
redes
ATM
,
306


algoritmos
de
enrutamiento
,
300‚Äì304
,


321‚Äì322
,
353‚Äì371


arquitectura
de
un
router
,
312‚Äì323


capa
de
transporte
y
,
186‚Äì190


CBR
,
servicio
de
las
redes
ATM
,
306


configuraci√≥n
de
la
conexi√≥n
,
303
,


306‚Äì312


datagramas
,
50
,
52
,
323‚Äì329
,
344‚Äì351


direccionamiento
,
329‚Äì342
,
345


enrutamiento
de
difusi√≥n
,
382‚Äì393


enrutamiento
por
multidifusi√≥n
,


393‚Äì397


enrutamiento
,
299‚Äì304
,
353‚Äì356
,


367‚Äì397


ICMP
,
protocolo
,
343‚Äì345


IPsec
,
protocolo
,
352‚Äì353
,
697‚Äì704


modelos
de
servicio
,
304‚Äì306


√çNDICE
795


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
795Capa
de
red
(
continuaci√≥n
)


protocolo
,
50


Protocolo
de
Internet
(
IP
)
,
323‚Äì353


redes
de
circuitos
virtuales
(
VC
)
,


306‚Äì307
,
312


redes
de
datagramas
,
306‚Äì307
,
310‚Äì312


redes
privadas
virtuales
(
VPN
)
,


697‚Äì704


reenv√≠o
,
299‚Äì304
,
323‚Äì353


Capa
de
sockets
seguros
.
V√©ase
SSL


Capa
f√≠sica
,
51


Capas
de
protocolos
,
46‚Äì53


arquitectura
en
capas
,
46‚Äì51


capa
de
aplicaci√≥n
,
49


capa
de
enlace
,
50


capa
de
transporte
,
49


capa
f√≠sica
,
51


datagramas
,
50
,
52‚Äì53


mensajes
,
49
,
52‚Äì53


modelo
de
referencia
OSI
,
51


modelo
de
servicio
,
48‚Äì49


pila
de
protocolos
,
48


redes
de
computadoras
,
49‚Äì51


segmentos
,
50
,
52‚Äì53


tramas
,
50
,
52‚Äì53


Carga
√∫til
,
campo
,
53
,
520


CBR
,
servicio
de
redes
ATM
,
306


CDMA
(
Code
Division
Multiple
Access
)
,


506‚Äì508


CDN
(
Content
Distribution
Network
)
,
569
,


573
,
595‚Äì598


Celdas
,
531


de
gesti√≥n
de
recursos
(
RM
)
,
264


Centro
de
conmutaci√≥n
de
servicios


m√≥viles
propios
(
MSC
)
,
549
,


551‚Äì554


Centro
de
conmutaci√≥n
m√≥vil
(
MSC
)
,
533


Centro
de
conmutaci√≥n
pasarela
para
servi-


cios
m√≥viles
(
GMSC
)
,
549


Centro
de
operaciones
de
red
.
V√©ase
NOC


C√©sar
,
cifrado
de
,
658
,
664


CIDR
(
Classless
Interdomain
Routing
)
,


332‚Äì335


Cifrado
,
352
,
654‚Äì655
,
656‚Äì657
.
V√©ase


tambi√©n
Criptograf√≠a


de
bloque
,
660‚Äì662


monoalfab√©tico
,
658‚Äì660


Cifrado
de
clave
p√∫blica
,
657
,
664‚Äì669
,


676‚Äì679
,
682‚Äì684


autenticaci√≥n
del
punto
terminal
usando
,


682‚Äì684


Autoridad
de
certificaci√≥n
(
CA
)
,


678‚Äì679


claves
(
p√∫blica
y
privada
)
,
665


Diffie-Helman
,
algoritmo
de
intercam-


bio
de
claves
de
,
664‚Äì665


integridad
de
los
mensajes
y
,
678‚Äì679


RSA
,
algoritmo
,
666‚Äì669


Claves
,
665
,
668
,
672


clave
de
sesi√≥n
,
668


clave
privada
,
665


clave
p√∫blica
,
665


Clientes
,
9
,
86


Cliente-servidor
,
arquitectura
,
83‚Äì85
,


154‚Äì167


capa
de
aplicaci√≥n
,
82‚Äì85


Java
,
aplicaciones
,
154‚Äì167


programaci√≥n
de
sockets
,
154‚Äì167


TCP
,
protocolo
,
151‚Äì161


UDP
,
protocolo
,
151‚Äì167


COA
(
Care-of
Address
)
,
539
,
545


Coaxial
,
cable
,
22


Cola
(
buffer
de
salida
)
,
28


Colas
,
29
,
34‚Äì45
,
319‚Äì323
,
620‚Äì624


bloqueo
HOL
,
322


con
prioridad
,
621‚Äì622


de
turno
rotatorio
,
623‚Äì624


equitativas
ponderadas
(
WFQ
)
,
623‚Äì624


gesti√≥n
activa
de
colas
(
AQM
)
,
321


intensidad
de
tr√°fico
,
39


mecanismos
de
planificaci√≥n
,
620‚Äì624


p√©rdida
de
paquetes
y
,
29
,
38‚Äì40


planificador
de
paquetes
,
321


Primero
en
entrar-primero
en
salir


(
FIFO
)
,
620‚Äì621


RED
,
algoritmo
,
321


retardos
de
,
29
,
34‚Äì39


routers
de
la
capa
de
red
y
las
,
319‚Äì323


velocidad
del
entramado
de
con-


mutaci√≥n
y
,
319‚Äì320


Colisiones
.
V√©ase
CSMA
(
Carrier
Sense


Multiple
Access
)
;
Acceso
m√∫ltiple


Compartici√≥n
de
archivos
P2P
,
86


Comportamiento
por
salto
(
PHB
)
,
Diffserv
,


630‚Äì631


796
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
796Compresi√≥n
de
audio
/
v√≠deo
,
574‚Äì576


Comprobaci√≥n
de
redundancia
c√≠clica


(
CRC
)
,
428‚Äì430
,
520‚Äì521


Comprobaciones
de
paridad
,
425‚Äì427


Comunicaci√≥n
l√≥gica
,
186


Conexiones
punto
a
punto
(
enlaces
)
,
230
,


417‚Äì419
,
430
,
470


Conexiones
terminal
a
terminal
,
25
,
40‚Äì42
,


203
,
262
,
439‚Äì440
,
571‚Äì573
,
587


control
de
congesti√≥n
,
262


dise√±o
de
sistema
UDP
,
202


garant√≠a
estricta
,
572


garant√≠a
parcial
,
572


retardos
,
40‚Äì42
,
439‚Äì440
,
587


servicio
de
mejor
esfuerzo
y
,
571‚Äì573
,


587


servicios
multimedia
y
,
572‚Äì573
,
587


Conmutaci√≥n
de
circuitos
,
23
,
29‚Äì31


conexiones
terminal
a
terminal
,
25


conmutaci√≥n
de
paquetes
,
comparaci√≥n


con
,
23


movimiento
de
datos
y
,
25
,
28‚Äì29


multiplexaci√≥n
,
26‚Äì28


multiplexaci√≥n
estad√≠stica
,
29‚Äì31


periodos
de
inactividad
,
27


Conmutaci√≥n
de
etiquetas
multiprotocolo


(
MPLS
)
,
474‚Äì477


Conmutaci√≥n
de
paquetes
,
2
,
23‚Äì25
,


27‚Äì32
,
34‚Äì45
,
58‚Äì59


almacenamiento
y
reenv√≠o
,
transmisi√≥n
,


28


buffer
de
salida
(
cola
)
,
28


conmutaci√≥n
de
circuitos
,
comparaci√≥n


con
,
29‚Äì31


desarrollo
de
la
,
58


movimiento
de
datos
y
,
25
,
28‚Äì29


multiplexaci√≥n
estad√≠stica
,
29‚Äì31


p√©rdida
de
paquetes
,
29
,
34
,
38‚Äì40


procesadores
de
mensajes
de
interfaz


(
IMP
)
,
59


retardos
,
35‚Äì44


retardos
de
cola
,
29
,
34‚Äì40


routers
,
4
,
31‚Äì32
,
303


ruta
,
4


sistemas
terminales
y
,
2


switches
de
la
capa
de
enlace
,
4
,
303


tabla
de
reenv√≠o
,
31‚Äì32


tasa
de
transferencia
,
42‚Äì45


Consultas
DNS
,
132


Control
,
conexi√≥n
de
,
112


Control
de
congesti√≥n
,
189
,
256‚Äì277


algoritmo
de
,
268‚Äì272


arranque
lento
y
,
268‚Äì269


asistido
por
la
red
,
262


bit
indicativo
de
la
congesti√≥n
(
CI
)
,
264


capa
de
transporte
,
189
,
256‚Äì277


causas
y
costes
,
256‚Äì261


celdas
de
gesti√≥n
de
recursos
(
RM
)
,
264


conexiones
TCP
en
paralelo
,
277


crecimiento
aditivo
y
decrecimiento


multiplicativo
(
AIMD
)
,
272‚Äì273


enlaces
de
cuello
de
botella
,
274‚Äì277


equidad
,
274‚Äì277


evitaci√≥n
de
la
congesti√≥n
,
 
269‚Äì270


intervalo
de
temporizaci√≥n
,
267


modo
de
transferencia
as√≠ncrono
(
ATM
)
,


256
,
262‚Äì265


recuperaci√≥n
r√°pida
,
271‚Äì272


tanteo
del
ancho
de
banda
,
267


tasa
de
transferencia
y
,
273


TCP
,
protocolo
,
265‚Äì277


terminal
a
terminal
,
262


UDP
,
protocolo
,
276


velocidad
de
bit
disponible
(
ABR
)
,
256
,


262‚Äì265


ventana
de
congesti√≥n
,
265‚Äì272


Control
de
flujo
,
246‚Äì249
,
421


Control
de
trama
,
campo
,
522‚Äì523


Cookies
,
105‚Äì107


Correcci√≥n
de
errores
hacia
adelante


(
FEC
)
,
426‚Äì427
,
592‚Äì593


Correo
electr√≥nico
(
e-mail
)
,
115‚Äì125
,


684‚Äì691


agentes
de
usuario
,
115


basado
en
Web
,
125


desarrollo
del
,
117


formatos
de
mensaje
,
120


IMAP
,
protocolo
,
124


PGP
(
Pretty
Good
Privacy
)
,
686
,


689‚Äì691


POP3
,
protocolo
,
122‚Äì124


protocolos
de
acceso
,
120‚Äì125


seguridad
,
684‚Äì691


servidores
de
correo
,
115


√çNDICE
797


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
797Correo
electr√≥nico
(
continuaci√≥n
)


SMTP
,
protocolo
,
49
,
115‚Äì122


Corresponsal
,
537
,
543


Cortafuegos
,
344
,
710‚Äì718


filtrado
de
paquetes
,
712‚Äì715


filtros
con
memoria
del
estado
,
713‚Äì715


pasarela
de
aplicaci√≥n
,
715‚Äì718


TOR
,
servidor
proxy
,
717


Crecimiento
aditivo
y
decrecimiento


multiplicativo
(
AIMD
)
,
control
de


congesti√≥n
,
272‚Äì273


Criptograf√≠a
,
656‚Äì672


algoritmo
de
cifrado
,
657


algoritmo
de
descifrado
,
657


cifrado
de
bloque
,
660‚Äì662


cifrado
de
C√©sar
,
658
,
664


cifrado
de
clave
p√∫blica
,
657
,
664‚Äì669


cifrado
monoalfab√©tico
,
658‚Äì660


cifrado
polialfab√©tico
,
659


clave
de
sesi√≥n
,
668


clave
privada
,
665


clave
p√∫blica
,
665


encadenamiento
de
bloques
cifrados


(
CBC
)
,
662‚Äì664


funciones
hash
,
670‚Äì672


RSA
,
algoritmo
,
666‚Äì669


sistemas
de
clave
sim√©trica
,
658‚Äì664


texto
cifrado
,
656‚Äì657


CSMA
(
Carrier
Sense
Multiple
Access
)
,


439‚Äì441
,
454‚Äì458
,
514‚Äì520


aplicaciones
Ethernet
,
454‚Äì458


con
evitaci√≥n
de
colisiones


(
CSMA
/
CA
)
,
514‚Äì520


detecci√≥n
de
colisiones
(
CSMA
/
CD
)
,


439
,
454‚Äì458


LAN
inal√°mbrica
(
WiFi
)
,
aplicaciones
,


514‚Äì520


protocolo
de
la
capa
de
enlace
,
439‚Äì441


Cubeta
con
p√©rdidas
,
vigilancia
,
624‚Äì627


D


DARPA
(
Defense
Advanced
Research


Projects
Agency
)
,
60‚Äì62


Datagramas
,
52
,
55
,
323‚Äì329
,
344‚Äì351
,


701‚Äì704


Base
de
datos
de
pol√≠ticas
de
seguridad


(
SPD
)
,
704


campos
,
323‚Äì326
,
346‚Äì349


fragmentaci√≥n
,
326‚Äì329
,
348


inspecci√≥n
de
seguridad
,
344


IPsec
,
701‚Äì704


IPv4
,
formato
,
323‚Äì329


IPv6
,
formato
,
346‚Äì349


l√≠mite
de
saltos
,
348


longitud
,
325
,
347


pila
dual
,
349‚Äì351


Protocolo
de
Internet
(
IP
)
y
,
323‚Äì329
,


345‚Äì349


protocolo
de
la
capa
de
red
y
,
50
,
53


suma
de
comprobaci√≥n
de
cabecera
,


325
,
348


tiempo
de
vida
,
campo
,
325


Tipo
de
servicio
(
TOS
)
,
bits
,
325


transici√≥n
de
IPv4
a
IPv6
,
349‚Äì351


tunelizaci√≥n
,
350‚Äì351
,
701‚Äì704


Datos
,
conexi√≥n
,
112


DDoS
,
ataque
,
56
,
138‚Äì139


Demultiplexaci√≥n
,
189‚Äì197


entrega
de
datos
utilizando
,
190‚Äì197


n√∫meros
de
puerto
,
192‚Äì197


orientado
a
conexi√≥n
,
194‚Äì195


sin
conexi√≥n
,
193‚Äì194


TCP
,
aplicaciones
,
194‚Äì197


UDP
,
aplicaciones
,
193‚Äì194


Denegaci√≥n
de
servicio
(
DoS
)
,
ataques
,


55‚Äì56


Denegaci√≥n
de
servicio
distribuido


(
DDoS
)
,
ataque
,
56
,
138‚Äì139


Descompresi√≥n
,
578


Descubrimiento
de
agentes
,
545‚Äì548


Descubrimiento
,
mensaje
de
,
337‚Äì338


Detecci√≥n
aleatoria
temprana
(
RED
)
,


algoritmo
,
321


DHCP
(
Dynamic
Host
Configuration


Protocol
)
,
336‚Äì339


ACK
,
mensaje
,
339


direcciones
IP
de
la
capa
de
red
,


336‚Äì339


mensaje
de
descubrimiento
,
337‚Äì338


mensaje
de
solicitud
,
339


oferta
,
mensaje
de
,
338


protocolo
plug-and-play
,
336


DHT
(
Distributed
Hash
Table
)
,
145‚Äì150


Diffie-Helman
,
algoritmo
de
intercambio
de


claves
de
,
664‚Äì665


Diffserv
,
627‚Äì632


798
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
798aplicaciones
multimedia
,
627‚Äì632


comportamiento
por
salto
(
PHB
)
,


630‚Äì631


perfiles
de
tr√°fico
,
627‚Äì628


DIFS
(
Distributed
Inter-frame


Spacing
)
,
516


Difusi√≥n
,
canales
,
417
,
430


Dijkstra
,
algoritmo
,
356‚Äì360


Dimensionamiento
de
las
redes
,


598‚Äì600


Direcci√≥n
,
campos
de
,
520‚Äì522


Direcci√≥n
cedida
.
V√©ase
COA


Direcci√≥n
de
difusi√≥n
,
445


Direccionamiento
,
93
,
329‚Äì342
,
345
,


444‚Äì445
,
538‚Äì539
,
608‚Äì610


agregaci√≥n
de
direcciones
,
333


√°mbito
,
340


anycast
,
347


ARP
,
protocolo
,
445‚Äì450


bloque
de
direcciones
,
335


capa
de
aplicaci√≥n
,
94


capa
de
red
,
329‚Äì342
,
345


con
clases
,
335


de
la
capa
de
enlace
,
444‚Äì450


DHCP
,
protocolo
,
336‚Äì339


direcci√≥n
ajena
,
539


direcci√≥n
cedida
(
COA
)
,
539


direcci√≥n
de
difusi√≥n
,
445


direcci√≥n
permanente
,
539


Enrutamiento
entre
dominios
sin


clase
(
CIDR
)
,
332‚Äì335


establecimiento
de
llamada
,
SIP
,


608‚Äì610


gesti√≥n
de
la
movilidad
y
,
538‚Äì539


host
,
98
,
336‚Äì339


independencia
de
las
capas
,
446


interfaz
,
329‚Äì331


IPv4
,
329‚Äì342


IPv6
,
345


MAC
,
direcciones
,
444‚Äì445


nodos
,
444‚Äì450
,
538‚Äì539


notaci√≥n
decimal
con
punto
,


330‚Äì332


prefijo
,
333


privado
,
340


Protocolo
de
Internet
(
IP
)
,
93
,


329‚Äì342
,
345


SIP
,
protocolo
,
608‚Äì610


subredes
,
331‚Äì332
,
448‚Äì450


temporal
,
336‚Äì337


traducci√≥n
de
direcciones
de
red


(
NAT
)
,
339‚Äì342


UPnP
(
Universal
Plug
and
Play
)
,


342


Dispositivos
de
conmutaci√≥n
,
451
,


460‚Äì470


auto-aprendizaje
,
462‚Äì463


comparaci√≥n
con
 
routers
,
464‚Äì466


de
la
capa
de
enlace
,
451
,
460‚Äì470


desventajas
,
466‚Äì467


dispositivos
plug-and-play
,
463


envenenamiento
,
465


Ethernet
,
451
,
460‚Äì462


filtrado
,
460‚Äì462


propiedades
,
463‚Äì464


redes
de
√°rea
local
(
LAN
)
y
,


460‚Äì470


redes
virtuales
de
√°rea
local


(
VLAN
)
,
466‚Äì470


reenv√≠o
,
460‚Äì462


transparencia
,
460


Distribuci√≥n
de
archivos
P2P
,
139


DMZ
(
Demilitarized
Zone
)
,
719


DNS
(
Domain
Name
System
)
,
49
,


125‚Äì139


alias
de
host
,
127


alias
de
servidor
de
correo
,
127


almacenamiento
en
cach√©
,
132‚Äì134


aplicaciones
de
red
,
50
,
125‚Äì137


base
de
datos
jer√°rquica
(
servidores


ra√≠z
)
,
129‚Äì132


consultas
,
132


DDoS
,
ataque
,
138‚Äì139


distribuci√≥n
de
carga
,
126‚Äì128


IP
,
direcciones
,
126‚Äì134


mensajes
,
134‚Äì136


nombre
de
host
,
125
,
134‚Äì135


problemas
de
dise√±o
generalizados
,


128‚Äì129


registros
,
136‚Äì137


registros
de
recursos
(
RR
)
,
134‚Äì135


traducci√≥n
nombre
de
host-direcci√≥n


IP
,
125‚Äì126
,
128‚Äì134


DNS
,
servidores
locales
,
131‚Äì132


√çNDICE
799


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
799DNS
(
continuaci√≥n
)


DNS
,
servidores
ra√≠z
,
129‚Äì132


Dominio
de
nivel
superior
,
servidores


de
,
129‚Äì132


Drop-tail
,
pol√≠tica
,
321


DSL
(
Digital
Subscriber
Line
)
,
14‚Äì15


Duraci√≥n
,
campo
,
522‚Äì523


DVMRP
(
Distance-Vector
Multicast


Routing
Protocol
)
,
396‚Äì397


E


EAP
(
Extensible
Authentication
Protocol
)
,


709‚Äì710


EDGE
(
Enhanced
Data
Rates
for
Global


Evolution
)
,
534


EFCI
,
bit
,
264


Eficiencia
de
Ethernet
,
457


El√°sticas
,
aplicaciones
,
89


Emisor
,
utilizaci√≥n
de
,
217‚Äì228


En
banda
,
informaci√≥n
,
113


Encadenamiento
de
bloques
cifrados


(
CBC
)
,
662‚Äì664


Encapsulaci√≥n
,
52
,
541‚Äì542


Enlace
cuello
de
botella
,
44
,
274‚Äì277


Enlaces
inal√°mbricos
,
499‚Äì500
,
503‚Äì506
,


517‚Äì519


conexiones
de
host
,
499‚Äì500


desvanecimiento
,
506


interferencias
,
503


obstrucci√≥n
,
504‚Äì505


p√©rdida
de
propagaci√≥n
,
503


Preparado
para
enviar
(
CTS
)
,
518‚Äì519


problemas
de
los
terminales
ocultos
,


505‚Äì506
,
517‚Äì519


propagaci√≥n
multicamino
,
503


punto
a
punto
,
520


relaci√≥n
se√±al
/
ruido
(
SNR
)
,
503‚Äì504


Solicitud
de
transmisi√≥n
(
RTS
)
,


518‚Äì519


tasa
de
errores
de
bit
(
BER
)
,
504‚Äì505


Enrutamiento
,
33‚Äì34
,
299‚Äì304
,
353‚Äì356
,


367‚Äì397
,
539‚Äì544
,
545
,
550


de
la
patata
caliente
,
370


de
multidifusi√≥n
,
384‚Äì390


directo
,
542‚Äì544


encapsulaci√≥n
,
541‚Äì542


entre
sistemas
aut√≥nomos
,
369
,
377‚Äì384


funci√≥n
de
la
capa
de
red
,
299‚Äì304


grafos
,
353‚Äì356


indirecto
,
540‚Äì542
,
545


interno
del
sistema
aut√≥nomo
,
368‚Äì369
,


371‚Äì377
,
383


jer√°rquico
,
367‚Äì384


llamadas
hacia
sistemas
m√≥viles
,
550


mensaje
de
respuesta
(
anuncios
)
,
372


nodos
m√≥viles
,
539‚Äì544


n√∫mero
de
itinerancia
de
la
estaci√≥n


m√≥vil
(
MSRN
)
,
550


Primero
la
ruta
abierta
m√°s
corta


(
OSPF
)
,
372
,
375‚Äì377


por
multidifusi√≥n
,
384
,
390‚Äì397


problema
del
enrutamiento
triangular
,


542


protocolo
de
localizaci√≥n
de
usuarios


m√≥viles
,
543‚Äì544


Protocolo
de
pasarela
de
frontera


(
BGP
)
,
377‚Äì384


reenv√≠o
y
,
300‚Äì304


reenv√≠o
por
el
camino
inverso
(
RPF
)
,


377‚Äì378
,
396‚Äì397


RIP
,
protocolo
,
371‚Äì375


sistemas
aut√≥nomos
(
AS
)
,
368‚Äì384


sistemas
inal√°mbricos
,
539‚Äì544
,
545
,


550


tablas
de
,
362‚Äì364
,
373‚Äì374


Enrutamiento
,
algoritmos
de
,
301‚Äì304
,


321‚Äì322
,
353‚Äì371
,
390
,
393‚Äì395


basado
en
la
conmutaci√≥n
de
circuitos
,


367


bucle
de
enrutamiento
,
365


colas
,
321‚Äì322


de
difusi√≥n
,
356
,
390


de
estado
de
enlaces
(
LS
)
,
355‚Äì360
,


366‚Äì367


descentralizado
,
355
,
360‚Äì361


Dijkstra
,
356‚Äì360


din√°mico
,
355


enrutamiento
jer√°rquico
y
,
367‚Äì371


est√°tico
,
355


funci√≥n
de
enrutamiento
,
353‚Äì356


global
,
355


por
multidifusi√≥n
,
393‚Äì395


por
vector
de
distancias
,
355
,
360‚Äì367


protocolo
de
enrutamiento
entre


sistemas
aut√≥nomos
,
369‚Äì370


800
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
800protocolo
de
enrutamiento
interno
del


sistema
aut√≥nomo
,
368


RED
,
algoritmo
,
321‚Äì322


sensible
/
no
sensible
a
la
carga
,
355


sistemas
aut√≥nomos
(
AS
)
,
368‚Äì371


valores
de
la
tabla
de
reenv√≠o
,
300‚Äì304


Enrutamiento
de
difusi√≥n
,
356
,
384‚Äì390


algoritmo
,
356
,
390


√°rbol
de
recubrimiento
,
388‚Äì390


inundaci√≥n
,
386‚Äì388


reenv√≠o
por
el
camino
inverso
(
RPF
)
,


387‚Äì388


unidifusi√≥n
por
N
v√≠as
,
385‚Äì386


Enrutamiento
entre
dominios
sin
clase
.


V√©ase
CIDR


Enrutamiento
interno
del
sistema
aut√≥nomo
,


368‚Äì369
,
371‚Äì377
,
383


Primero
la
ruta
abierta
m√°s
corta


(
OSPF
)
,
372
,
375‚Äì377


protocolo
del
algoritmo
,
368‚Äì369


RIP
,
protocolo
,
371‚Äì375


y
enrutamiento
entre
sistemas


aut√≥nomos
,
383


Enrutamiento
por
multidifusi√≥n
,
384
,


390‚Äì397


algoritmo
de
,
393‚Äì396


aplicaciones
Internet
,
396‚Äì397


DVMRP
,
protocolo
,
396‚Äì397


grupo
de
multidifusi√≥n
,
391


indirecci√≥n
de
direcciones
,
391


Multidifusi√≥n
independiente
del
proto-


colo
(
PIM
)
,
protocolo
de


enrutamiento
,
396‚Äì397


Protocolo
de
gesti√≥n
de
grupos
de


Internet
(
IGMP
)
,
391‚Äì393


reenv√≠o
por
el
camino
inverso
(
RPF
)
,


395‚Äì397


SSM
,
protocolo
,
396


Entramado
de
conmutaci√≥n
,
313
,
317‚Äì320


colas
,
319‚Äì320


funci√≥n
de
reenv√≠o
de
un
router
,
313
,


317‚Äì319


velocidad
del
,
319‚Äì320


v√≠a
bus
,
318


v√≠a
memoria
,
317‚Äì318


v√≠a
una
red
de
interconexi√≥n
,
318


entregar_datos
(
)
,
llamada
,
203‚Äì205


Entrevistas


Bellovin
,
Samuel
M.
,
733‚Äì734


Case
,
Jeff
,
764‚Äì765


Cerf
,
Vinton
G.
,
415‚Äì416


Cohen
,
Bram
,
183‚Äì184


Floyd
,
Sally
,
297‚Äì298


Kleinrock
,
Leonard
,
79‚Äì80


Lam
,
Simon
S.
,
495‚Äì496


Perkins
,
Charlie
,
564‚Äì566


Schulzrinne
,
Henning
,
650‚Äì652


ER
,
campo
,
265


Errores
,
206‚Äì215
,
421
,
424‚Äì430


bits
de
detecci√≥n
y
correcci√≥n
de
,


424‚Äì425


bits
no
detectados
,
423


Comprobaci√≥n
de
redundancia
c√≠clica


(
CRC
)
,
428‚Äì430


comprobaciones
de
paridad
,
425‚Äì428


correcci√≥n
de
errores
hacia
adelante


(
FEC
)
,
426‚Äì427


de
nivel
de
bit
,
206‚Äì215
,
424‚Äì425


servicios
de
la
capa
de
enlace
,
421
,


424‚Äì430


servicios
de
la
capa
transporte
,
206‚Äì215


suma
de
comprobaci√≥n
,
207
,
427


transferencia
de
datos
fiable
(
rdt
)
y
,


206‚Äì215


Escalabilidad
,
P2P
,
140‚Äì142


Espacio
distribuido
entre
tramas
(
DIFS
)
,


516


Espectro
disperso
por
salto
de
frecuencia


(
FHSS
)
,
526


Establecimiento
de
llamada
,
SIP
,
608‚Äì610


Establecimiento
de
llamadas
,
garant√≠as


QoS
,
633‚Äì637


Estaci√≥n
base
,
19
,
531‚Äì533


controlador
de
la
(
BSC
)
,
532


infraestructura
inal√°mbrica
,
19
,
531‚Äì533


sistema
de
la
(
BSS
)
,
532


transductora
(
BTS
)
,
532


Estado
de
enlaces
(
LS
)
,
algoritmo
de
,


355‚Äì360
,
366‚Äì367


de
difusi√≥n
,
356


de
Dijkstra
,
356‚Äì360


enrutamiento
global
,
355


y
algoritmo
de
vector
de
distancias


(
DV
)
,
366‚Äì367


√çNDICE
801


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
801Estado
de
la
informaci√≥n
de
usuario
,
114


Estructura
de
la
informaci√≥n
de
gesti√≥n


(
SMI
)
,
742‚Äì745


Ethernet
,
18
,
51
,
64‚Äì65
,
450‚Äì460


acceso
m√∫ltiple
con
sondeo
de
portadora


y
detecci√≥n
de
colisiones


(
CSMA
/
CD
)
,
454‚Äì458


aplicaciones
de
la
capa
de
enlace
,
50
,


450‚Äì460


conexiones
no
fiables
,
453‚Äì454


conmutador
,
451
,
460‚Äì462


desarrollo
de
,
61


eficiencia
,
457


estructura
de
la
trama
,
452‚Äì454


hubs
,
450‚Äì452


repetidor
,
458


tecnolog√≠a
LAN
y
,
450‚Äì452


tecnolog√≠as
,
458‚Äì460


Etiquetas
VLAN
,
469‚Äì470


EWMA
(
Exponential
Weighted
Moving


Average
)
,
236‚Äì237


F


FDDI
(
Fiber-Distributed
Data
Interface
)
,


443


FDM
(
Frequency-Division
Multiplexing
)
,


26‚Äì28
,
433‚Äì434


FHSS
(
Frequency-Hopping
Spread


Spectrum
)
,
526


Fibra
directa
,
17


Fibra
hasta
el
hogar
(
FTTH
)
,
redes
,
17‚Äì18


Fibra
√≥ptica
,
22


FIFO
(
First-In-First-Out
)
,
cola
,
620‚Äì621


Filtros
,
460‚Äì462
,
712‚Äì715


de
paquetes
con
memoria
del
estado
,


713‚Äì715


de
paquetes
,
712‚Äì715


Fin
de
temporizaci√≥n
,
236
,
242‚Äì244
,
267


control
de
congesti√≥n
y
,
267


intervalos
,
238
,
242‚Äì244


retransmisi√≥n
y
,
238
,
243‚Äì244


TCP
,
protocolo
,
238
,
243
,
267


transferencia
de
datos
fiable
(
rdt
)
,


239‚Äì241


transferencia
de
datos
fiable
con
proce-


samiento
en
cadena
,
215‚Äì228


velocidad
del
emisor
(
host
)
y
,
243
,
267


Firmas
digitales
,
673‚Äì679


Fluctuaci√≥n
,
571
,
578
,
587‚Äì592


de
paquetes
,
571
,
578
,
587‚Äì592


eliminaci√≥n
de
la
,
578
,
588‚Äì592


estrategias
para
el
retardo
de
la
repro-


ducci√≥n
,
588‚Äì592


flujos
de
audio
/
v√≠deo
almacenado
,
576
,


591


marcas
de
tiempo
,
588


n√∫meros
de
secuencia
,
588


redes
multimedia
y
,
571
,
578
,
588‚Äì592


Flujos
,
569‚Äì570
,
577‚Äì585
,
591
,
594‚Äì595


acceso
a
trav√©s
de
un
servidor
web
,


578‚Äì579


buffer
cliente
,
580‚Äì581


de
audio
y
v√≠deo
almacenado
,
568‚Äì569
,


577‚Äì581


de
audio
y
v√≠deo
en
vivo
,
570


de
entrada
,
154


de
salida
,
154


eliminaci√≥n
de
la
fluctuaci√≥n
,
578
,
588


recuperaci√≥n
de
paquetes
perdidos
,


592‚Äì595


reparaci√≥n
de
flujos
de
audio
da√±ados


en
el
receptor
,
594‚Äì595


reproductor
multimedia
,
578


RTSP
,
protocolo
,
576
,
582‚Äì585


servicios
en
Internet
,
577


servidor
de
,
580‚Äì581


y
programaci√≥n
de
sockets
,
153‚Äì154


FSM
(
M√°quina
de
estados
finitos
)
,


205‚Äì206


FTP
(
File
Transfer
Protocol
)
,
49
,
112‚Äì114
,


615‚Äì620


aplicaciones
de
audio
,
616‚Äì620


comandos
,
114


conexi√≥n
de
control
,
112


conexi√≥n
de
datos
,
112


escenarios
de
aplicaciones
multimedia
,


616‚Äì620


estado
de
la
informaci√≥n
del
usuario
,


114


protocolo
de
la
capa
de
aplicaci√≥n
,
49
,


112‚Äì114


respuestas
,
114


Fuera
de
banda
,
informaci√≥n
,
113


Funci√≥n
de
medida
,
Diffserv
,
630


802
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
802
G


Gateway
,
routers
,
368


Generador
de
bits
,
428


Gesti√≥n
activa
de
colas
(
AQM
)
,
321


Gesti√≥n
de
la
potencia
,
WiFi
,
525‚Äì526


Gesti√≥n
de
redes
,
735‚Äì765


ASN.1
,
746
,
749‚Äì750
,
757‚Äì760


Base
de
informaci√≥n
de
gesti√≥n
(
MIB
)
,


741
,
744‚Äì745
,
749‚Äì751


centro
de
operaciones
de
red
(
NOC
)
,


735
,
743‚Äì744


entorno
de
gesti√≥n
est√°ndar
de
Internet
,


742‚Äì745


escenarios
,
735‚Äì739


estructura
de
la
informaci√≥n
de
gesti√≥n


(
SMI
)
,
745‚Äì748


infraestructura
,
739‚Äì742


SGMP
,
protocolo
,
742


SNMP
,
protocolo
,
742
,
751‚Äì757


GET
condicional
,
mecanismo
,
111‚Äì112


GMSC
(
Gateway
Mobile
services


Switching
Center
)
,
549


GPRS
(
General
Packet
Radio
Service
)
,
534


Grafos
,
enrutamiento
,
353‚Äì356


GSM
(
Global
System
for
Mobile


Communications
)
,
530
,
532
,
551‚Äì554


comparaci√≥n
con
IP
m√≥vil
,
554


est√°ndares
,
530
,
532


transferencia
de
llamadas
en
,
551‚Äì554


Gusanos
,
55


H


H.323
,
est√°ndares
,
613‚Äì614


Hash
,
funciones
critpogr√°ficas
,
670‚Äì672


Hash
,
tablas
,
145‚Äì150


abandono
de
los
pares
,
149‚Äì150


circular
,
147‚Äì149


distribuidas
(
DHT
)
,
145‚Äì150


HFC
(
Hybrid
Fiber-Coaxial
)
,
redes
,
16
,


569


H√≠brido
de
fibra
y
coaxial
.
V√©ase
HFC


HLR
(
Home
Location
Register
)
,
549


HOL
,
bloqueo
,
322‚Äì323


Hosts
,
2‚Äì4
,
9
,
93
,
127
,
336‚Äì339
,
498‚Äì502
.


V√©ase
tambi√©n
Nodos
;
Routers


alias
,
127


direccionamiento
,
93
,
336‚Äì339


inal√°mbricos
,
498‚Äì502


sistemas
terminales
como
,
2‚Äì4
,
9


HTTP
(
HyperText
Transfer
Protocol
)
,
49
,


95‚Äì111
,
120


conexiones
no
persistentes
,
98‚Äì99


conexiones
persistentes
,
99


cookies
,
105‚Äì107


formato
del
mensaje
,
101‚Äì105


mensaje
de
respuesta
,
102‚Äì105


mensaje
de
solicitud
,
101‚Äì102


protocolo
de
la
capa
de
aplicaci√≥n
,
49
,


95‚Äì105


protocolo
TCP
y
,
96‚Äì100


SMTP
comparado
con
,
120


tiempo
de
ida
y
vuelta
(
RTT
)
,
99‚Äì100


Web
,
p√°gina
,
95‚Äì96


World
Wide
Web
y
,
95‚Äì105


Hubs
Ethernet
,
450‚Äì452


Husmeador
de
paquetes
,
56‚Äì57


I


ICMP
(
Internet
Control
Message
Protocol
)
,


343‚Äì345


Identificador
de
conjunto
de
servicio


(
SSID
)
,
512


Identificador
del
origen
de
sincronizaci√≥n


(
SSRC
)
,
603


IDS
(
Intrusion
Detection
System
)
,
344
,


718‚Äì721


IEEE
802.11
LAN
inal√°mbrica
.
V√©ase
WiFi


IETF
(
Internet
Engineering
Task
Force
)
,


est√°ndares
,
5


IGMP
(
Internet
Group
Management


Protocol
)
,
391‚Äì393


IKE
(
Internet
Key
Exchange
)
,
704


IMAP
(
Internet
Mail
Access
Protocol
)
,
124


IMP
(
Interface
Message
Processors
)
,
59


Inanici√≥n
,
581


Indicaci√≥n
de
congesti√≥n
expl√≠cita
directa


(
EFCI
)
,
bit
,
264


Indicador
,
campo
segmento
TCP
,
232


√çndice
de
par√°metro
de
seguridad
(
SPI
)
,
700


Indirecci√≥n
de
direcciones
,
391


Ingenier√≠a
de
tr√°fico
,
477


Integridad
de
los
datos
,
IPsec
,
352


Integridad
de
los
mensajes
,
655
,
669‚Äì679


Autoridad
de
certificaci√≥n
(
CA
)
,


677‚Äì680


certificaci√≥n
de
clave
p√∫blica
,
676‚Äì679


√çNDICE
803


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
803Integridad
de
los
mensajes
(
continuaci√≥n
)


clave
de
autenticaci√≥n
,
672


c√≥digo
de
autenticaci√≥n
de
mensaje


(
MAC
)
,
672


firmas
digitales
,
673‚Äì679


funciones
hash
criptogr√°ficas
,
670‚Äì672


seguridad
de
las
redes
de
computadoras


e
,
655
,
669‚Äì670


Intercalado
,
594


Intercambio
de
claves
de
Internet
(
IKE
)
,


704


Interfaz
de
datos
distribuidos
para
fibra
,


443


Interfaz
de
enlace
,
310‚Äì311


Interfaz
de
programaci√≥n
de
aplicaciones


(
API
)
,
6


Interfaz
,
329‚Äì331


Internet
,
1‚Äì66
,
90‚Äì93
,
115‚Äì125
,
189‚Äì190
,


570‚Äì574
,
577
,
742‚Äì745


aplicaciones
distribuidas
,
5‚Äì6
,
10


ataques
,
53‚Äì58


capa
de
transporte
e
,
90‚Äì92
,
189‚Äì190


capas
de
protocolo
,
46‚Äì53


conmutaci√≥n
de
paquetes
,
2
,
25‚Äì27
,


30‚Äì34
,
34‚Äì45
,
58‚Äì59


correo
electr√≥nico
,
115‚Äì125


desarrollo
de
,
63‚Äì64


entorno
de
gesti√≥n
de
red
,
742‚Äì745


IETF
(
Internet
Engineering
Task
Force
)
,


est√°ndares
,
5


medios
f√≠sicos
,
20‚Äì23


no
fiabilidad
,
189


p√©rdida
de
paquetes
,
38‚Äì40


protocolo
de
red
,
7‚Äì9


redes
de
acceso
,
12‚Äì20


redes
de
computadoras
e
,
1‚Äì66


redes
troncales
,
33


retardos
,
34‚Äì42


RFC
(
Requests
for
comments
)
,
5


servicios
de
flujos
de
audio
/
video
,
577


servicios
de
transporte
de
la
capa
de


aplicaci√≥n
proporcionados
por
,


90‚Äì93
,
115‚Äì125


sistemas
terminales
(
hosts
)
,
2‚Äì4
,
9
,


20‚Äì23


soporte
multimedia
,
571‚Äì574


SSL
,
92


tasa
de
transferencia
,
42‚Äì45


TCP
,
servicios
,
5
,
90‚Äì92
,
189‚Äì190


telefon√≠a
por
,
150‚Äì151
,
570


UDP
,
servicios
,
91‚Äì92
,
189‚Äì190


Intserv
,
servicios
integrados
,
637‚Äì638


Inundaci√≥n
,
386‚Äì388


Inversa
envenenada
,
t√©cnica
,
365‚Äì366


Inversi√≥n
de
la
conexi√≥n
,
342


IP
(
Internet
Protocol
)
,
5
,
189‚Äì190
,


323‚Äì353
,
474‚Äì477
,
571
,
585‚Äì600
.


V√©ase
tambi√©n
IP
m√≥vil
,
protocolo


aplicaciones
multimedia
,
571
,
585‚Äì600


componentes
,
323


Conmutaci√≥n
de
etiquetas
multiproto-


colo
(
MPLS
)
,
474‚Äì477


DHCP
,
protocolo
,
336‚Äì339


direccionamiento
,
329‚Äì342
,
345


Enrutamiento
entre
dominios
sin
clase


(
CIDR
)
,
332‚Äì335


formato
de
los
datagramas
,
323‚Äì329
,


346‚Äì351


fragmentaci√≥n
,
326‚Äì329


ICMP
(
Internet
Control
Message


Protocol
)
,
343‚Äì345


IPv4
,
323‚Äì342
,
349‚Äì351


IPv6
,
345‚Äì351


modelo
de
servicio
,
189


pila
dual
,
m√©todo
para
la
transici√≥n
de


versiones
,
349‚Äì351


reenv√≠o
,
323‚Äì353


servicio
de
mejor
esfuerzo
,
189
,
571
,


585‚Äì600


servicios
de
capa
de
red
,
189
,
323‚Äì353


servicios
de
la
capa
de
transporte
,


189‚Äì190


traducci√≥n
de
direcciones
de
red
(
NAT
)
,


339‚Äì342


tunelizaci√≥n
para
transici√≥n
entre
ver-


siones
,
350‚Äì351


UPnP
(
Universal
Plug
and
Play
)
,
342


IP
m√≥vil
,
protocolo
,
545‚Äì548
,
554


anuncio
de
agente
,
546


comparaci√≥n
con
est√°ndares
GSM
,
554


direcci√≥n
cedida
(
COA
)
,
546


enrutamiento
indirecto
,
545


registro
ante
el
agente
propio
,
546‚Äì548


IP
,
direcciones
,
93
,
125


IPS
(
Intrusion
Prevention
System
)
,
344
,


718


804
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
804IPsec
(
seguridad
IP
)
,
352‚Äì353
,
697‚Äì705


Asociaci√≥n
de
seguridad
(
SA
)
,
700‚Äì701


cifrado
,
352


datagramas
,
701‚Äì704


IKE
(
Internet
Key
Exchange
)
,
704


integridad
de
los
datos
,
352


negociaci√≥n
critpogr√°fica
,
352


redes
privadas
virtuales
(
VPN
)
,


697‚Äì704


servicios
de
la
capa
de
red
,
352‚Äì353
,


704


IPTV
,
569


IPv4
,
323‚Äì342
,
349‚Äì351


direccionamiento
,
329‚Äì342


formato
de
datagrama
,
323‚Äì329


fragmentaci√≥n
,
326‚Äì329


transici√≥n
al
formato
IPv6
,
349‚Äì351


IPv6
,
345‚Äì351


direcci√≥n
anycast
,
347


formato
de
datagrama
,
346‚Äì349


pila
dual
,
 
349‚Äì351


prioridad
y
etiquetado
del
flujo
,
347


transici√≥n
desde
IPv4
a
,
349‚Äì351


tunelizaci√≥n
,
350‚Äì351


ISP
(
Internet
Service
Providers
)
,
4
,
32‚Äì34


igualitarios
,
34


puntos
de
presencia
(
POP
)
,
34


redes
troncales
,
33


sistemas
terminales
e
,
4‚Äì5


Iterativa
,
consulta
,
132


J


Java
,
aplicaciones
,
154‚Äì167


programaci√≥n
de
sockets
,
154‚Äì167


TCP
,
protocolo
,
151‚Äì161


UDP
,
protocolo
,
161‚Äì167


L


LAN
(
Local
Area
Network
)
,
20
,
442‚Äì443
,


450‚Äì452
,
460‚Äì470
,
508‚Äì529
,
531
,


705‚Äì710


Bluetooth
(
IEEE
802.15.1
)
,
526‚Äì527


conmutadores
de
la
capa
de
enlace
,


460‚Äì470


evoluci√≥n
de
Ethernet
,
450‚Äì452


FDDI
,
443


frente
a
tecnolog√≠a
celular
3
G
,
531


inal√°mbrica
,
20
,
508‚Äì529
,
705‚Äì710


protocolos
de
acceso
m√∫ltiple
,
442‚Äì444
,


508‚Äì529


seguridad
,
705‚Äì710


token
ring
,
443


virtual
(
VLAN
)
,
466‚Äì470


WEP
(
Wired
Equivalent
Privacy
)
,


706‚Äì708


WiFi
(
IEEE
802.11
)
,
20
,
508‚Äì526
,


705‚Äì710


WiMax
(
IEEE
802.16
)
,
527‚Äì529


L√≠mite
de
saltos
,
348


L√≠nea
de
abonado
digital
.
V√©ase
DSL


M


Malware
,
54‚Äì55


MAN
(
Metropolitan
Area
Network
)
,
443


M√°quina
de
estados
finitos
(
FSM
)
,


205‚Äì206


Marcas
de
tiempo
,
588
,
603


Marcos
temporales
,
433‚Äì434


Media
m√≥vil
exponencialmente
ponderada


(
EWMA
)
,
236‚Äì237


Medios
f√≠sicos
,
20‚Äì23
,
42


cable
coaxial
,
22


cable
de
cobre
de
par
trenzado
,
21‚Äì22


canales
de
radio
terrestre
,
22


canales
de
radio
v√≠a
sat√©lite
,
23


fibra
√≥ptica
,
22


guiados
,
21


no
guiados
,
21


retardo
de
empaquetamiento
,
42


Memoria
direccionable
por
contenido
.


V√©ase
CAM


Mensajes
,
28
,
49
,
52‚Äì53
,
86
,
101‚Äì105
,


120
,
135‚Äì136
,
186
,
309
,
336‚Äì339
,


343‚Äì345
,
371‚Äì372
,
610‚Äì611


aplicaciones
de
la
capa
de
red
,
309
,


336‚Äì339
,
343‚Äì345
,
371‚Äì372


capa
de
aplicaci√≥n
,
49
,
52‚Äì53


de
correo
electr√≥nico
,
formatos
,
120


de
respuesta
HTTP
,
102‚Äì105


de
respuesta
RIP
(
anuncios
)
,
372


de
se√±alizaci√≥n
,
309


de
solicitud
HTTP
,
101‚Äì102


DHCP
,
protocolo
,
336‚Äì339


HTTP
,
formato
,
101‚Äì105


ICMP
,
protocolo
,
343‚Äì345


paquetes
,
28


√çNDICE
805


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
805Mensajes
(
continuaci√≥n
)


segmentos
de
la
capa
de
transporte
,
186


SIP
,
protocolo
,
610‚Äì611


sistema
de
nombres
de
dominio
(
DNS
)
,


135‚Äì137


Metarchivo
,
578‚Äì579


M√©todo
basado
en
un
nodo
central
,
389


MIB
(
Management
Information
Base
)
,
741
,


744‚Äì745
,
749‚Äì751


Minitel
,
proyecto
,
62‚Äì63


Modems
,
13‚Äì14
,
16


Modo
de
transferencia
as√≠ncrono
.
V√©ase


ATM


Modo
t√∫nel
,
datagramas
,
350‚Äì351
,


701‚Äì704


Movilidad
,
gesti√≥n
de
la
,
535‚Äì544
,


549‚Äì554


agente
ajeno
,
537
,
544


corresponsal
,
537
,
543


dimensiones
,
535‚Äì537


direcci√≥n
cedida
(
COA
)
,
539


direccionamiento
,
538‚Äì539


encapsulaci√≥n
,
541‚Äì542


enrutamiento
,
539‚Äì544
,
550


enrutamiento
directo
,
542‚Äì544


enrutamiento
indirecto
,
540‚Äì542


nodos
m√≥viles
,
538‚Äì544


red
ajena
(
visitada
)
,
537
,
549


red
propia
,
537
,
549


redes
celulares
,
549‚Äì554


transferencia
de
llamadas
,
551‚Äì554


MSC
(
Mobile
Switching
Center
)
,
533


MSRN
(
Mobile
Station
Roaming
Number
)
,


550


MSS
(
Maximum
Segment
Size
)
,
230‚Äì232


MTU
(
Maximum
Transmission
Unit
)
,
230


Multidifusi√≥n
espec√≠fica
del
origen
,
proto-


colo
.
V√©ase
SSM


Multimedia
en
tiempo
real
,
570
,
600‚Äì614


aplicaciones
de
audio
y
v√≠deo
,
570


H.323
,
est√°ndares
,
613‚Äì614


Protocolo
de
control
de
RTP
(
RTCP
)
,


605‚Äì607


RTP
,
protocolo
,
600‚Äì604


SIP
,
protocolo
,
607‚Äì613


telefon√≠a
por
Internet
,
570


Multiplexaci√≥n
,
26‚Äì28
,
29‚Äì31
,
190‚Äì197


capa
de
transporte
,
190‚Äì197


conmutaci√≥n
de
paquetes
,
28‚Äì31


estad√≠stica
,
29‚Äì31


n√∫meros
de
puerto
,
192‚Äì197


orientada
a
conexi√≥n
,
194‚Äì195


por
divisi√≥n
de
frecuencia
(
FDM
)
,
26‚Äì28


por
divisi√≥n
en
el
tiempo
(
TDM
)
,
26‚Äì28


recopilaci√≥n
y
paso
de
datos
utilizando
,


189‚Äì197


redes
de
conmutaci√≥n
de
circuitos
,
26


sin
conexi√≥n
,
193‚Äì194


sockets
,
191‚Äì193


TCP
,
aplicaciones
,
194‚Äì197


UDP
,
aplicaciones
,
193‚Äì194


N


NAT
(
Network
Address
Translation
)
,


339‚Äì342


Negativo
,
reconocimiento
(
NAK
)
,
206‚Äì211


Negociaci√≥n
criptogr√°fica
,
IPsec
,
352


NI
,
bit
,
265


nmap
,
exploraci√≥n
de
puertos
,
196


No
filtrado
,
par
,
145


No
guiado
,
medio
,
21


No
persistente
,
conexi√≥n
,
98‚Äì99


NOC
(
Network
Operations
Center
)
,
735
,


743‚Äì744


Nodo
de
soporte
GPRS
.
V√©ase
SGSN


Nodos
,
34‚Äì42
,
353‚Äì355
,
419
,
421
,


444‚Äì450
,
538‚Äì544


agente
ajeno
,
537
,
544


agente
propio
,
537


capa
de
enlace
,
419
,
421
,
444‚Äì450


control
de
flujo
,
421


corresponsal
,
537
,
543


detecci√≥n
de
errores
y
,
421


direccionamiento
,
444‚Äì450
,
538‚Äì539


enrutamiento
hacia
dispositivos
m√≥viles
,


539‚Äì544


env√≠o
de
datagramas
a
,
448‚Äì450


grafos
,
354‚Äì355


m√≥viles
,
538‚Äì544


retardo
,
34‚Äì42


transmisi√≥n
semiduplex
y
full-duplex
,


421


Nombre
de
host
,
125
,
128‚Äì135


alias
,
127


almacenamiento
en
cach√©
DNS
,


132‚Äì134


806
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
806base
de
datos
de
servidores
DNS
,


129‚Äì132


can√≥nico
,
127


registros
de
recursos
(
RR
)
,
134‚Äì135


traducci√≥n
a
direcci√≥n
IP
,
125
,
128‚Äì134


Notaci√≥n
de
sintaxis
abstracta
uno
.
V√©ase


ASN.1


Notaci√≥n
decimal
con
punto
,
330‚Äì332


nslookup
,
programa
,
136


N√∫mero
de
itinerancia
de
la
estaci√≥n
m√≥vil


(
MSRN
)
,
550


N√∫mero
de
reconocimiento
,
campo
de
seg-


mento
TCP
,
232


N√∫meros
de
puerto
,
94
,
192‚Äì197


de
destino
,
94
,
192


de
origen
,
192


exploraci√≥n
,
196


inversi√≥n
de
,
193‚Äì194


servidores
web
y
,
196‚Äì197


N√∫meros
de
secuencia
,
209
,
218‚Äì223
,
232
‚Äì


236
,
386‚Äì388
,
522‚Äì523
,
588
,
602


ARQ
,
protocolos
,
209


campo
,
232
,
522‚Äì523
,
602


eliminaci√≥n
de
la
fluctuaci√≥n
mediante
,


588


GBN
,
protocolo
,
218‚Äì222


inundaci√≥n
controlada
,
386


repetici√≥n
selectiva
(
SR
)
,
222


TCP
,
segmentos
,
232‚Äì236


N√∫meros
distintivos
,
680‚Äì682


O


Objeto
,
archivos
,
96


Opciones
,
campo
segmento
,
TCP
,
232


OSPF
(
Open
Shortest
Path
First
)
,
372
,


375‚Äì377


√°rea
troncal
,
377


enrutamiento
interno
del
sistema


aut√≥nomo
,
371
,
375‚Äì377


funcionalidades
avanzadas
de


enrutamiento
,
375‚Äì376


pesos
de
los
enlaces
en
,
377


routers
de
frontera
de
√°rea
,
377


P


P2P
(
Peer-to-Peer
)
,
82‚Äì85
,
139‚Äì151


arquitectura
,
83‚Äì85


BitTorrent
,
protocolo
,
142‚Äì145


capa
de
aplicaci√≥n
,
139‚Äì151


compartici√≥n
de
archivos
,
 
86


distribuci√≥n
de
archivos
,
139‚Äì145


escalabilidad
,
140‚Äì142


Internet
,
telefon√≠a
,
150‚Äì151


proceso
cliente
,
86


proceso
servidor
,
86


Skype
,
aplicaci√≥n
,
150‚Äì151


tabla
hash
distribuida
(
DHT
)
para
,


145‚Äì150


tiempo
de
distribuci√≥n
,
140‚Äì142


Paquete
de
asfixia
o
bloqueo
,
262


Paquetes
,
4
,
28
,
38‚Äì40
,
203‚Äì228
,
262
,
571
,


578
,
586‚Äì595
,
601‚Äì602
,
606‚Äì607


de
asfixia
o
bloqueo
,
262


duplicados
,
209
,
213


fluctuaci√≥n
de
,
571
,
578
,
588‚Äì592


n√∫mero
de
secuencia
,
209


p√©rdida
de
,
29
,
38‚Äì40
,
211‚Äì215
,


586‚Äì587
,
592‚Äì595


redes
multimedia
,
571
,
578
,
586‚Äì595
,


601‚Äì602
,
606‚Äì607


retransmisi√≥n
,
207
,
213‚Äì215


RTP
,
protocolo
,
601‚Äì602
,
606‚Äì607


servicios
de
mejor
esfuerzo
,
571
,


586‚Äì595


transferencia
de
datos
fiable
(
rdt
)
,


203‚Äì228


Parada
y
espera
,
protocolos
de
,
207‚Äì208
,


216‚Äì217


Pares
,
143‚Äì145
,
378‚Äì379


ISP
igualitarios
,
34


no
filtrados
,
145


Protocolo
de
pasarela
de
frontera


(
BGP
)
,
378‚Äì381


Particiones
de
tiempo
,
433‚Äì437


Pasarela
de
aplicaci√≥n
,
715‚Äì718


Pasarela
,
routers
de
,
368


P√©rdida
de
propagaci√≥n
,
503


Perfiles
de
tr√°fico
de
Diffserv
,
629‚Äì630


Pesos
de
los
enlaces
en
OSPF
,
377


PGP
(
Pretty
Good
Privacy
)
,
686
,
689‚Äì691


Picored
,
Bluetooth
,
526‚Äì527


Pila
dual
,
m√©todo
IP
,
349‚Äì351


PIM
(
Protocol
Independent
Multicast
)
,
pro-


tocolo
de
enrutamiento
,
396‚Äì397


√çNDICE
807


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
807Planificaci√≥n
,
mecanismos
de
.
V√©ase
Colas


Planificador
de
paquetes
,
321


PLMN
(
Public
Land
Mobile
Network
)
,


549‚Äì550


Plug-and-play
,
protocolo
,
336
,
463


Poda
,
396


Pol√≠tica
de
importaci√≥n
,
381


PON
(
Passive
Optical
Network
)
,
17


POP
(
punto
de
presencia
)
,
34


POP3
,
protocolo
,
122‚Äì124


PPP
(
Point-to-Point
Protocol
)
,
50
,
419
,


470‚Äì474


Prefijos
,
310‚Äì311
,
333
,
379


Preparado
para
enviar
(
CTS
)
,
518‚Äì519


Primero
la
ruta
abierta
m√°s
corta
.
V√©ase


OSPF


Problemas
del
terminal
oculto
,
505‚Äì506
,


517‚Äì519


Procesadores
de
mensajes
de
interfaz


(
IMP
)
,
59


Programa
cliente
,
9


Programa
servidor
,
9


Programaci√≥n
basada
en
sucesos
,
221


Propagaci√≥n
multicamino
,
503


Protocolo
ampliable
de
autenticaci√≥n
.


V√©ase
EAP


Protocolo
de
acceso
a
correo
de
Internet
.


V√©ase
IMAP


Protocolo
de
configuraci√≥n
din√°mica
de


host
.
V√©ase
DHCP


Protocolo
de
control
de
transmisi√≥n
.
V√©ase


TCP


Protocolo
de
datagramas
de
usuario
.
V√©ase


UDP


Protocolo
de
enrutamiento
por
multidi-


fusi√≥n
por
vector
de
distancias
.


V√©ase
DVMRP


Protocolo
de
gesti√≥n
de
grupos
de
Internet
.


V√©ase
IGMP


Protocolo
de
informaci√≥n
de
enrutamiento
.


V√©ase
RIP


Protocolo
de
inicio
de
sesi√≥n
.
V√©ase
SIP


Protocolo
de
Internet
.
V√©ase
IP


Protocolo
de
mensajes
de
control
de


Internet
.
V√©ase
ICMP


Protocolo
de
pasarela
de
frontera
.
V√©ase


BGP


Protocolo
de
pasarela
interior
.
V√©ase


Protocolo
de
enrutamiento
interno


del
sistema
aut√≥nomo


Protocolo
de
paso
de
testigo
,
442


Protocolo
de
resoluci√≥n
de
direcciones
.


V√©ase
ARP


Protocolo
de
sondeo
,
441‚Äì442


Protocolo
de
transferencia
de
archivos
.


V√©ase
FTP


Protocolo
de
transferencia
de
hipertexto
.


V√©ase
HTTP


Protocolo
de
transmisi√≥n
de
flujos
en


tiempo
real
.
V√©ase
RTSP


Protocolo
de
transporte
en
tiempo
real
.


V√©ase
RTP


Protocolo
punto
a
punto
.
V√©ase
PPP


Protocolo
simple
de
gesti√≥n
de
red
.
V√©ase


SNMP


Protocolo
simple
de
transferencia
de


correo
.
V√©ase
SMTP


Protocolos


analog√≠a
humana
,
7‚Äì8


de
acceso
aleatorio
,
434‚Äì442
,
454‚Äì458
,


514‚Äì520


de
enrutamiento
(
terminal
a
terminal
)
,


31‚Äì32


de
particionamiento
del
canal
,
433‚Äì434


de
red
,
8‚Äì9


de
toma
por
turnos
,
441‚Äì442


de
ventana
deslizante
,
218


fuera
de
banda
,
582


IETF
,
est√°ndares
,
5


Proxy
,
servidor
,
SIP
,
611‚Äì613


Puertos
de
entrada
,
routers
,
313‚Äì316


Puertos
de
salida
,
routers
,
314
,
319


Puntero
de
datos
urgentes
,
segmento
TCP
,


232


Punto
de
acceso
(
AP
)
,
18
,
501
,
511


Punto
de
cita
,
389


Punto
de
presencia
(
POP
)
,
34


Q


QoS.
V√©ase
Calidad
de
servicio


R


rdt_enviar
(
)
,
llamada
,
203‚Äì205
,
221


rdt_recibir
(
)
,
llamada
,
203‚Äì205


808
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
808Reconocimientos
,
206‚Äì211
,
219
,
232
‚Äì


236
,
240‚Äì246


acumulativo
,
219
,
234
,
242


duplicados
,
210‚Äì211
,
243‚Äì244


negativos
(
NAK
)
,
206‚Äì210


n√∫mero
de
,
 
232


p√©rdida
,
241‚Äì242


positivos
(
ACK
)
,
206‚Äì211
,
240‚Äì242


retransmisi√≥n
r√°pida
,
244‚Äì246


superpuestos
,
236


TCP
,
protocolo
,
232‚Äì236
,
240‚Äì246


Recuperaci√≥n
de
p√©rdida
de
paquetes
,


592‚Äì595


correcci√≥n
de
errores
hacia
adelante


(
FEC
)
,
592‚Äì593


intercalado
,
594


reparaci√≥n
de
flujos
de
audio


da√±ados
en
el
receptor
,
594‚Äì595


Recuperaci√≥n
r√°pida
,
TCP
,
271‚Äì272


Recursiva
,
consulta
,
132


RED
(
Random
Early
Detection
)
,
algo-


ritmo
,
321


Red
ajena
(
visitada
)
,
537
,
549


Red
de
√°rea
local
.
V√©ase
LAN


Red
de
√°rea
local
virtual
.
V√©ase
VLAN


Red
de
√°rea
metropolitana
(
MAN
)
,
443


Red
de
distribuci√≥n
de
contenido
.


V√©ase
CDN


Red
m√≥vil
terrestre
p√∫blica
propia
.


V√©ase
PLMN


Red
privada
virtual
.
V√©ase
VPN


Red
propia
,
537
,
549


Red
terminal
,
382‚Äì384


Red
terminal
multiconectada
,
382


Red
vehicular
ad
hoc
(
V
ANET
)
,
502


Redes
de
acceso
,
12‚Äì21
.


V√©ase
tambi√©nAcceso
m√∫ltiple


acceso
inal√°mbrico
de
√°rea
extensa
,


19


acceso
telef√≥nico
,
13‚Äì14


cable
,
15‚Äì17


DSL
,
14‚Äì15


Ethernet
,
18


FTTH
,
17


telco
,
12‚Äì13


WiFi
,
18


WiMAX
,
20


Redes
de
circuitos
virtuales
(
VC
)
,


306‚Äì309
,
312


estado
de
la
conexi√≥n
,
308


fase
de
configuraci√≥n
,
308‚Äì309


fase
de
terminaci√≥n
,
309


fase
de
transferencia
de
datos
,
309


mensajes
de
se√±alizaci√≥n
,
309


or√≠genes
de
,
312


routers
,
307‚Äì309


servicio
orientado
a
la
conexi√≥n
,


306‚Äì307


Redes
de
computadoras
,
1‚Äì80
,
82‚Äì85
,


653‚Äì697
.
V√©ase
tambi√©n
Internet


acceso
inal√°mbrico
de
√°rea
extensa
,


18‚Äì20


acceso
telef√≥nico
,
13‚Äì14


arquitectura
,
82‚Äì85


arquitectura
en
capas
,
46‚Äì52


ataques
,
53‚Äì58


cable
,
15‚Äì17


capa
de
aplicaci√≥n
,
49
,
52‚Äì53
,


82‚Äì85


capas
de
protocolos
,
46‚Äì53


conmutaci√≥n
de
circuitos
,
23‚Äì31


conmutaci√≥n
de
paquetes
,
2
,
23‚Äì25
,


28‚Äì32
,
34‚Äì45
,
58‚Äì59


DSL
,
14‚Äì15


Ethernet
,
18


FTTH
,
17


historia
,
58‚Äì65


ISP
(
Internet
Service
Provider
)
,
4
,


32‚Äì34


medios
f√≠sicos
,
20‚Äì23


multiplexaci√≥n
,
26‚Äì28
,
39‚Äì31


n√∫cleo
,
23‚Äì34


p√©rdida
de
paquetes
,
38‚Äì40


programa
cliente
,
9


programa
servidor
,
9


protocolo
,
5
,
7‚Äì9


redes
de
acceso
,
12‚Äì21


retardos
,
34‚Äì42


seguridad
,
53‚Äì58
,
653‚Äì697


sistemas
terminales
(
hosts
)
,
2‚Äì4
,
9
,


20‚Äì23


tasa
de
transferencia
,
42‚Äì45


WiFi
,
18


WiMAX
,
20


√çNDICE
809


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
809Redes
de
datagramas
,
306‚Äì307
,
310‚Äì312


coincidencia
de
prefijo
,
310‚Äì311


interfaz
de
enlace
,
310‚Äì311


or√≠genes
de
,
312


routers
,
310‚Äì311


servicio
sin
conexi√≥n
,
306‚Äì307


Redes
de
malla
inal√°mbricas
,
502


Redes
inal√°mbricas
,
18
,
497‚Äì566


acceso
inal√°mbrico
de
√°rea
extensa
,
20


acceso
m√∫ltiple
por
divisi√≥n
de
c√≥digo


(
CDMA
)
,
506‚Äì50


ad
hoc
,
501‚Äì502


Bluetooth
(
IEEE
802.15.1
)
,
526‚Äì527


enlaces
,
499‚Äì500
,
503‚Äì506


estaci√≥n
base
,
500‚Äì501
,
512


gesti√≥n
de
la
movilidad
,
535‚Äì544
,


549‚Äì554


hosts
498‚Äì499


impacto
sobre
TCP
,
555‚Äì556


impacto
sobre
UDP
,
555‚Äì556


infraestructura
,
502


IP
m√≥vil
,
545‚Äì548


LAN
y
,
18
,
508‚Äì529


sistemas
celulares
,
529‚Äì535
,
549‚Äì554


transferencia
,
501
,
551‚Äì554


WiFi
(
IEEE
802.11
)
,
20
,
508‚Äì526


WiMax
(
IEEE
802.16
)
,
20
,
527‚Äì529


Redes
m√≥viles
ad
hoc
(
MANET
)
,
502
,
537


Redes
multimedia
,
567‚Äì652


aplicaciones
interactivas
en
tiempo
real
,


570
,
600‚Äì614


audio
,
568‚Äì571
,
574‚Äì585
,
588‚Äì592
,


594‚Äì595
,
616‚Äì620


calidad
de
servicio
(
QoS
)
,
633‚Äì638


compresi√≥n
,
574‚Äì576


fluctuaci√≥n
,
571
,
578
,
588‚Äì592


flujos
,
569‚Äì570
,
577‚Äì585
,
591
,
594‚Äì595


FTP
,
aplicaciones
,
616‚Äì620


mecanismos
de
planificaci√≥n
(
colas
)
,


620‚Äì624


mecanismos
de
vigilancia
,
624‚Äì627


m√∫ltiples
clases
de
servicios
,
615‚Äì633


p√©rdida
de
paquetes
,
586‚Äì587
,
592‚Äì595


redes
de
distribuci√≥n
de
contenido


(
CDN
)
,
569
,
573
,
595‚Äì598


redes
solapadas
de
multidifusi√≥n
,
573


RSVP
(
Resource
ReSerVation
Protocol
)
,


636‚Äì637


servicio
de
mejor
esfuerzo
,
571
,


585‚Äì600


servicio
diferenciado
(
Diffserv
)
,


627‚Äì633


servicios
integrados
(
Intserv
)
,
637‚Äì638


soporte
Internet
para
,
572‚Äì574


v√≠deo
,
568‚Äì570
,
574‚Äì585


Redes
√≥pticas
activas
(
AON
)
,
17


Redes
√≥pticas
pasivas
(
PON
)
,
17


Redes
solapadas
de
multidifusi√≥n
,
573


Reenv√≠o
,
31‚Äì32
,
299‚Äì304
,
323‚Äì353
,


387‚Äì388
,
395‚Äì397
,
460‚Äì462


conmutadoras
de
la
capa
de
enlace
,


460‚Äì462


datagramas
,
325‚Äì329
,
344‚Äì351


direccionamiento
y
,
329‚Äì342
,
345


enrutamiento
y
,
299‚Äì304
,
387‚Äì388
,


395‚Äì397


fragmentaci√≥n
,
326‚Äì329
,
348


funciones
de
la
capa
de
red
,
299‚Äì304
,


323‚Äì353


ICMP
(
Internet
Control
Message


Protocol
)
,
343‚Äì345


IP
(
protocolo
de
Internet
)
,
323‚Äì353


IPv4
,
323‚Äì342
,
349‚Äì351


IPv6
,
345‚Äì351


por
el
camino
inverso
(
RPF
)
,
387‚Äì388
,


395‚Äì397


seguridad
(
IPsec
)
,
352‚Äì353


tablas
de
,
33‚Äì34
,
299‚Äì304


traducci√≥n
de
direcciones
de
red
(
NAT
)
,


339‚Äì342


UPnP
(
Universal
Plug
and
Play
)
y
,
342


Registrador
SIP
,
611‚Äì613


Registro
ante
el
agente
propio
,
546‚Äì548


Registro
de
ubicaciones
de
visitantes


(
VLR
)
,
549


Registro
de
ubicaciones
propias
(
HLR
)
,


549


Registro
SSL
,
formato
,
697


Registros
DNS
,
136‚Äì137


Reglas
b√°sicas
de
codificaci√≥n
(
BER
)
,
760


Rellenado
de
bytes
,
473‚Äì474


Reparaci√≥n
de
flujos
de
audio
da√±ados
en


el
receptor
,
594‚Äì595


810
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
810Repetidor
Ethernet
,
458


Reproducci√≥n
,
retardar
,
588‚Äì592


Retardos
,
29
,
34‚Äì42
,
439‚Äì440
,
585‚Äì600


comparaci√≥n
de
los
retardos
de
trans-


misi√≥n
y
de
propagaci√≥n
,
37


de
cola
,
29
,
36
,
38‚Äì40


de
empaquetamiento
,
42


de
procesamiento
,
35‚Äì36


de
propagaci√≥n
,
36‚Äì38


de
propagaci√≥n
del
canal
,
439‚Äì440


de
sistemas
terminales
,
42


de
transmisi√≥n
,
36


dimensionamiento
de
las
redes
,
598‚Äì600


estrategias
de
reproducci√≥n
,
588‚Äì592


fluctuaci√≥n
,
587‚Äì592


nodal
,
34‚Äì40


p√©rdida
de
paquetes
,
29
,
38‚Äì40
,


586‚Äì587
,
592‚Äì595


redes
de
conmutaci√≥n
de
paquetes
y
,


34‚Äì42


redes
de
distribuci√≥n
de
contenido


(
CDN
)
,
573
,
595‚Äì598


redes
multimedia
,
585‚Äì600


servicio
de
mejor
esfuerzo
y
,
585‚Äì600


terminal
a
terminal
,
40‚Äì42
,
439‚Äì440
,


587


traceroute
,
programa
,
41‚Äì42


Retransmisi√≥n
r√°pida
,
244‚Äì246


RFC
(
Requests
for
comments
)
,
5


RIP
(
Routing
Information
Protocol
)
,


371‚Äì375


RM
,
celdas
,
264


Routers
,
4
,
31‚Äì32
,
300‚Äì304
,
307‚Äì323
,
353
,


368‚Äì371
,
464‚Äì466


arquitectura
,
312‚Äì314


arquitectura
de
la
capa
de
red
,
312‚Äì323


colas
,
319‚Äì323


comparaci√≥n
con
conmutadores
de
la


capa
de
enlace
,
464‚Äì466


de
destino
,
353


de
frontera
de
√°rea
,
377


de
origen
,
353


de
pasarela
,
368‚Äì369


del
primer
salto
,
353


entramado
de
conmutaci√≥n
,
313
,


317‚Äì320


funci√≥n
de
enrutamiento
,
353
,
368


predeterminado
,
353


procesador
de
enrutamiento
,
314


puertos
de
entrada
,
313‚Äì316


puertos
de
salida
,
314
,
319


red
de
circuitos
virtuales
,
307‚Äì309


redes
de
conmutaci√≥n
de
paquetes
y
,


31‚Äì32


redes
de
datagramas
,
310‚Äì311


sistemas
aut√≥nomos
(
AS
)
,
368‚Äì371


switches
de
la
capa
de
enlace
como
,
4
,


31‚Äì32
,
303


tablas
de
reenv√≠o
,
31‚Äì32
,
300‚Äì304


velocidad
de
l√≠nea
,
315‚Äì316


RPF
(
Reverse
Path
Forwarding
)
,
387‚Äì388
,


396‚Äì397


RR
(
registros
de
recursos
)
,
134‚Äì135


RSA
,
algoritmo
,
666‚Äì669


RSVP
(
Resource
ReSerVation
Protocol
)
,


636‚Äì637


RTP
(
Real-time
Transport
Protocol
)
,


600‚Äì604


aplicaciones
software
para
,
603‚Äì604


cabecera
,
601‚Äì603


escalado
del
ancho
de
banda
RTCP
,
607


paquetes
,
601‚Äì602
,
606‚Äì607


Protocolo
de
control
de
RTP
(
RTCP
)
,


605‚Äì607


sesi√≥n
,
600


RTSP
(
Real-Time
Streaming
Protocol
)
,


576
,
582‚Äì585


Ruta
,
4
,
354‚Äì355


de
coste
m√≠nimo
,
354‚Äì355
,
360


S


Sat√©lites
de
la
√≥rbita
baja
terrestre
(
LEO
)
,


23


Sat√©lites
geoestacionarios
,
23


Segmentos
,
50
,
52‚Äì53
,
186
,
190‚Äì193
,


201‚Äì203
,
231‚Äì236
,
249‚Äì255


campos
de
cabecera
,
232‚Äì233


capa
de
transporte
,
49
,
52‚Äì53
,
186
,


190‚Äì193
,
231‚Äì236


conversi√≥n
de
mensajes
con
,
186


estructura
del
segmento
TCP
,
231‚Äì233
,


249‚Äì255


n√∫mero
de
puerto
,
campos
,
190‚Äì193
,


232


√çNDICE
811


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
811Segmentos
(
continuaci√≥n
)


n√∫mero
de
secuencia
,
232‚Äì235


suma
de
comprobaci√≥n
,
201‚Äì203
,
231


SYN
,
249‚Äì255


tama√±o
m√°ximo
(
MSS
)
,
230‚Äì232


transporte
sin
conexi√≥n
y
,
201‚Äì203


UDP
,
estructura
,
201‚Äì203


unidad
m√°xima
de
transmisi√≥n
(
MTU
)
,


230


Seguridad
,
53‚Äì58
,
90
,
344
,
352‚Äì353
,


653‚Äì697


ataque
por
reproducci√≥n
,
680‚Äì682


ataque
de
interposici√≥n
,
57
,
684


ataques
,
53‚Äì58


autenticaci√≥n
del
punto
terminal
,
654
,


669‚Äì684


capa
de
aplicaci√≥n
,
90


capa
de
red
,
344
,
352‚Äì353


cifrado
de
clave
p√∫blica
,
657
,
664‚Äì669
,


678‚Äì679
,
682‚Äì684


cifrado
,
654‚Äì655
,
656‚Äì657


correo
electr√≥nico
(
e-mail
)
,
684‚Äì691


cortafuegos
,
344
,
710‚Äì718


criptograf√≠a
,
656‚Äì672


DoS
,
ataques
,
55‚Äì56


funciones
hash
criptogr√°ficas
,
670‚Äì672


inspecci√≥n
de
datagramas
,
344


integridad
del
mensaje
,
655
,
669‚Äì679


IPsec
,
protocolo
,
352‚Äì353
,
697‚Äì704


LAN
inal√°mbrica
,
705‚Äì710


malware
,
54‚Äì55


operacional
,
655
,
710‚Äì722


packet
sniffers
,
57


PGP
(
Pretty
Good
Privacy
)
,
686
,


689‚Äì691


propiedades
de
las
comunicaciones


seguras
,
654‚Äì656


redes
de
computadoras
,
53‚Äì58
,
653‚Äì697


redes
privadas
virtuales
(
VPN
)
,


697‚Äì704


Seguridad
de
la
capa
de
transporte


(
TLS
)
,
691


sistemas
de
detecci√≥n
de
intrusiones


(
IDS
)
,
344
,
718‚Äì721


SSL
,
691‚Äì697


suplantaci√≥n
IP
,
57


TCP
,
protocolo
,
691‚Äì697


WEP
(
Wired
Equivalent
Privacy
)
,


706‚Äì708


Se√±alizaci√≥n
de
estado
firme
,
636


Se√±alizaci√≥n
de
estado
fr√°gil
,
636


Se√±alizaci√≥n
,
mensajes
de
,
309


Se√±al-ruido
,
relaci√≥n
(
SNR
)
,
503‚Äì504


Servicio
de
entrega
de
mejor
esfuerzo
,
189
,


571‚Äì574
,
585‚Äì600


conexiones
terminal
a
terminal


(
retardo
)
,
571‚Äì573
,
587


dimensionamiento
de
las
redes
con
,


598‚Äì600


fluctuaci√≥n
de
paquetes
,
571
,
587‚Äì588


IP
,
aplicaciones
,
189
,
571‚Äì574
,
585‚Äì600


limitaciones
,
586‚Äì588


p√©rdida
de
paquetes
,
586‚Äì587
,
592‚Äì595


redes
de
distribuci√≥n
de
contenido


(
CDN
)
,
573
,
595‚Äì598


Servicio
de
flujo
de
bytes
,
154


Servicio
general
de
paquetes
de
radio


(
GPRS
)
,
534


Servicio
universal
de
comunicaciones


m√≥viles
(
UMTS
)
,
534


Servicios
orientados
a
la
conexi√≥n
,


194‚Äì195
,
249‚Äì256
,
306‚Äì307
,
312


capa
de
red
,
306‚Äì307
,
312


capa
de
transporte
,
249‚Äì255


demultiplexaci√≥n
,
194‚Äì195


gesti√≥n
de
la
conexi√≥n
TCP
,
249‚Äì255


multiplexaci√≥n
,
194‚Äì195


redes
de
circuitos
virtuales
(
VC
)
,


306‚Äì307
,
312


Servicios
sin
conexi√≥n
,
193‚Äì194
,
198‚Äì203
,


306‚Äì307
,
310‚Äì312


aplicaciones
Internet
,
199‚Äì200


capa
de
red
,
306‚Äì307
,
310‚Äì312


capa
de
transporte
,
193‚Äì194
,
198‚Äì203


multiplexaci√≥n
y
demultiplexaci√≥n
,


193‚Äì194


redes
de
datagramas
,
306‚Äì307
,
310‚Äì312


segmento
,
estructura
,
201


suma
de
comprobaci√≥n
,
201‚Äì203


UDP
,
aplicaciones
,
198‚Äì203


Servidores
,
9
,
86


de
correo
,
115
,
127


DNS
autoritativos
,
129‚Äì132


SGMP
(
Simple
Gateway
Monitoring


Protocol
)
,
742


812
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
812SGSN
(
Serving
GPRS
Support
Node
)
,


533‚Äì535


SIP
(
Session
Initiation
Protocol
)
,
607‚Äì613


direcciones
,
610


establecimiento
de
llamada
,
608‚Äì610


mensajes
,
610‚Äì611


registradores
,
611‚Äì613


servidor
proxy
,
611‚Äì613


Sistema
basado
en
anomal√≠as
,
720


Sistema
basado
en
firmas
,
720


Sistema
de
detecci√≥n
de
intrusiones
.
Ve√°se


IDS


Sistema
de
nombres
de
dominio
.
Ve√°se


DNS


Sistema
de
prevenci√≥n
de
intrusiones
.


Ve√°se
IPS


Sistema
global
de
comunicaciones
m√≥viles
.


Ve√°se
GSM


Sistemas
celulares
,
529‚Äì535
,
549‚Äì554


acceso
a
Internet
,
528‚Äì535


acceso
m√∫ltiple
inal√°mbrico
,
529‚Äì535


ampliaci√≥n
de
Internet
extended
(
2.5
y


3
G
)
,
533‚Äì535


arquitectura
de
red
,
529‚Äì535


clasificaci√≥n
de
generaciones
,
530‚Äì531


conexiones
de
voz
(
2
G
)
,
531‚Äì533


enrutamiento
de
llamadas
,
550


estaciones
transductoras
,
532‚Äì533


gesti√≥n
de
la
movilidad
,
549‚Äì554


GSM
,
est√°ndares
,
530
,
532
,
551‚Äì554


localizaci√≥n
de
abonados
,
533


MSC
,
550‚Äì554


Nodo
de
soporte
GPRS
(
SGSN
)
,


533‚Äì535


red
m√≥vil
terrestre
p√∫blica
propia


(
PLMN
)
,
549‚Äì550


registro
de
ubicaci√≥n
de
visitantes


(
VLR
)
,
549


registro
de
ubicaciones
propias
(
HLR
)
,


549


tecnolog√≠a
LAN
inal√°mbrica
y
celular


(
3
G
)
,
531


transferencia
de
llamadas
,
551‚Äì554


Sistemas
de
audio
,
568‚Äì570
,
574‚Äì585
,


587‚Äì592
,
594‚Äì595
,
616‚Äì620


acceso
a
trav√©s
de
un
servidor
web
,


578‚Äì579


almacenado
,
568‚Äì570
,
576‚Äì581


buffer
cliente
,
580‚Äì581


compresi√≥n
,
574‚Äì576


en
vivo
,
570


fluctuaci√≥n
,
578
,
587‚Äì592


flujos
569‚Äì570
,
576‚Äì581


FTP
,
aplicaciones
,
616‚Äì620


recuperaci√≥n
de
p√©rdidas
de
paquetes
,


592‚Äì593


reparaci√≥n
de
flujos
en
el
receptor
,


594‚Äì595


reproductor
multimedia
,
578


RTSP
,
protocolo
,
576
,
582‚Äì585


servicios
de
flujos
de
audio
en
Internet
,


577


servidor
de
flujos
,
580‚Äì581


Sistemas
de
clave
sim√©trica
,
658‚Äì664


cifrado
de
bloque
,
660‚Äì662


cifrado
de
C√©sar
,
658
,
664


cifrado
monoalfab√©tico
,
658‚Äì660


cifrado
polialfab√©tico
,
659


encadenamiento
de
bloques
cifrados


(
CBC
)
,
662‚Äì664


Sistemas
de
v√≠deo
,
568‚Äì570
,
574‚Äì585


acceso
a
trav√©s
de
un
servidor
web
,


578‚Äì579


almacenado
,
568‚Äì569
,
576‚Äì581


buffer
cliente
,
580‚Äì581


compresi√≥n
,
574‚Äì576


flujos
de
v√≠deo
,
569‚Äì570
,
576‚Äì581


reproductor
multimedia
,
578


RTSP
,
protocolo
,
576
,
582‚Äì585


servicios
de
flujos
de
v√≠deo
en
Internet
,


577


servidor
de
flujos
,
580‚Äì581


v√≠deo
en
vivo
,
570


Sistemas
terminales
,
2‚Äì4
,
9
,
20‚Äì23
,
42


API
,
6


aplicaciones
distribuidas
,
5‚Äì6
,
10


clientes
,
10‚Äì11


dispositivos
,
10


enlaces
de
comunicaciones
(
medios
)
,
2
,


20‚Äì23


hosts
como
,
2‚Äì4
,
9


paquetes
,
4


Proveedor
de
servicios
de
Internet
(
ISP
)


y
,
4‚Äì5


√çNDICE
813


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
813Sistemas
terminales
(
continuaci√≥n
)


retardos
,
42


routers
,
4


ruta
,
4


servidores
,
10‚Äì11


switches
,
4


velocidad
de
transmisi√≥n
,
4


Skype
,
aplicaci√≥n
P2P
,
150‚Äì151


SLA
(
Service
Level
Agreement
)
,
738


SMTP
(
Simple
Mail
Transfer
Protocol
)
,
49
,


115‚Äì122


acceso
a
correo
,
121‚Äì122


correo
electr√≥nico
,
115‚Äì122


HTTP
comparado
con
,
120


protocolo
de
la
capa
de
aplicaci√≥n
,
29
,


115‚Äì122


SNMP
(
Simple
Network
Management


Protocol
)
,
742
,
751‚Äì757


SNYACK
,
segmento
,
249


Sockets
,
87
,
190‚Äì193


Sockets
,
programaci√≥n
,
87
,
151‚Äì167


aplicaciones
cliente-servidor
,
154‚Äì167


flujos
,
154


Interfaz
de
programaci√≥n
de
aplica-


ciones
(
API
)
,
87


interfaz
entre
proceso
y
red
,
87


Java
,
aplicaciones
,
154‚Äì167


TCP
,
protocolo
,
151‚Äì161


UDP
,
protocolo
,
151‚Äì167


Solicitud
autom√°tica
de
repetici√≥n
.
V√©ase


ARQ
,
protocolos


Solicitud
de
comentarios
.
V√©ase
RFC


Solicitud
de
transmisi√≥n
(
RTS
)
,
518‚Äì519


SPD
(
Security
Policy
Database
)
,
704


SSID
(
Service
Set
Identifier
)
,
512


SSL
(
Secure
Sockets
Layer
)
,
92
,
691‚Äì697


cierre
de
la
conexi√≥n
,
697


deducci√≥n
de
claves
,
694


fase
de
acuerdo
,
693‚Äì694
,
696‚Äì697


formato
de
registro
,
695


seguridad
TCP
,
92
,
691‚Äì697


transferencia
de
datos
,
694‚Äì695


SSRC
(
Synchronization
Source
Identifier
)
,


603


Subredes
,
331‚Äì333
,
448‚Äì450
,
523‚Äì524


Suma
de
comprobaci√≥n
,
201‚Äì203
,
207
,


228
,
231
,
325
,
348
,
427


capa
de
enlace
,
427


capa
de
transporte
,
201‚Äì203
,
207
,
228
,


232


de
cabecera
de
datagrama
,
325
,
348


de
Internet
,
427


segmentos
UPD
,
201‚Äì203


TCP
,
segmento
,
231


transferencia
de
datos
fiable
,
207
,
228


Suplantaci√≥n
IP
,
57


SYN
,
segmentos
TCP
,
249‚Äì255


T


Tabla
de
traducciones
NAT
,
340


Tablas
hash
distribuidas
(
DHT
)
,
145‚Äì150


Tama√±o
m√°ximo
de
segmento
.
V√©ase
MSS


Tarjeta
de
interfaz
de
red
(
NIC
)
,
422


Tarjeta
de
l√≠nea
,
313


Tasa
de
errores
de
bit
(
VER
)
,
504‚Äì505


Tasa
de
transferencia
,
42‚Äì45
,
89
,
273


aplicaciones
el√°sticas
,
89


aplicaciones
sensibles
al
ancho
de


banda
,
89


capa
de
aplicaci√≥n
,
89


control
de
congesti√≥n
y
,
273


instant√°nea
,
43


media
,
43


seguridad
de
red
y
,
42‚Äì45


TCP
,
protocolo
,
273


tiempo
de
ida
y
vuelta
(
RTT
)
,
273


TCP
(
Transmission
Control
Protocol
)
,
5
,


50
,
90‚Äì94
,
96‚Äì100
,
151‚Äì161
,


189‚Äì190
,
194‚Äì197
,
228‚Äì255
,


265‚Äì277
,
555‚Äì556
,
691‚Äì697


acuerdo
en
tres
fases
,
154
,
230
,


250‚Äì251


aplicaciones
de
la
capa
de
transporte
,


49
,
90‚Äì92
,
189‚Äì190
,
194‚Äì197
,


228‚Äì256
,
265‚Äì277


ataque
por
inundaci√≥n
SYN
,
254‚Äì255


cliente-servidor
,
aplicaci√≥n
,
154‚Äì161


conexi√≥n
no
persistente
,
98‚Äì99


conexi√≥n
persistente
,
99


conexiones
punto
a
punto
,
230


control
de
congesti√≥n
,
265‚Äì277


control
de
flujo
,
246‚Äì249


demultiplexaci√≥n
,
194‚Äì197


estados
,
251‚Äì253


814
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
814estimaci√≥n
del
tiempo
de
ida
y
vuelta
,


236‚Äì239


estructura
del
segmento
,
231‚Äì233


GBN
y
SR
,
comparaci√≥n
de
los


protocolos
,
246


gesti√≥n
de
la
conexi√≥n
,
249‚Äì255


HTTP
y
,
95‚Äì100


Internet
,
 
90‚Äì91


intervalos
de
fin
de
temporizaci√≥n
,
238
,


241‚Äì244
,
267


Java
,
aplicaci√≥n
,
154‚Äì161


multiplexaci√≥n
,
194‚Äì197


n√∫meros
de
secuencia
y
de


reconocimiento
,
233‚Äì236


reconocimientos
(
ACK
)
,
232‚Äì236
,


240‚Äì246


retransmisi√≥n
r√°pida
,
244‚Äì246


servicio
de
flujo
de
bytes
,
154


servicio
de
transferencia
de
datos
fiable
,


239‚Äì246


servicios
de
la
capa
de
aplicaci√≥n
,
50
,


90‚Äì91
,
92
,
96‚Äì100
,
151‚Äì161


socket
,
programaci√≥n
,
151‚Äì161


SSL
,
92
,
691‚Äì697


tecnolog√≠a
inal√°mbrica
y
movilidad
,


impacto
sobre
,
555‚Äì556


transporte
orientado
a
la
conexi√≥n
,


194‚Äì197
,
228‚Äì255


TCP
Reno
,
271‚Äì272


TCP
Tahoe
,
271‚Äì272


TCP
/
IP
,
229


TDL
(
Top-Level
Domain
)
,
servidores
,


129‚Äì132


TDM
(
Time-Division
Multiplexing
)
,
26‚Äì28
,


433‚Äì434


Telco
,
12‚Äì13


Temporizaci√≥n
,
capa
de
aplicaci√≥n
,
89


Texto
cifrado
,
656‚Äì657


Texto
en
claro
,
657


Tiempo
de
distribuci√≥n
,
140‚Äì142


Tiempo
de
envejecimiento
,
463


Tiempo
de
ida
y
vuelta
(
RTT
)
,
99‚Äì100
,


236‚Äì239
,
272


Tiempo
de
vida
,
campo
,
325


Tipo
de
servicio
(
TOS
)
,
bit
,
325


TLS
(
Transport
Layer
Security
)
,
691


TLV
,
m√©todo
,
760


Token
ring
,
443


TOR
,
servidor
proxy
,
717


Torres
de
telefon√≠a
,
501


Traceroute
,
programas
,
41


Traducci√≥n
de
direcciones
de
red
.
V√©ase


NAT


Tramas
,
53
,
55‚Äì56
,
419‚Äì420
,
431‚Äì438
,


452‚Äì454
,
470
,
472‚Äì474
,
513‚Äì514
,


520‚Äì523


802.11
,
campos
,
520‚Äì523


acceso
m√∫ltiple
y
,
430‚Äì438


baliza
,
513


capa
de
enlace
,
50
,
55‚Äì56
,
419‚Äì420
,


431‚Äì438
,
470
,
473‚Äì474


capa
f√≠sica
,
51


colisiones
,
431‚Äì433


conexiones
no
fiables
,
453‚Äì454


estructura
de
la
trama
Ethernet
,
452‚Äì454


exploraci√≥n
activa
y
pasiva
,
513


LAN
inal√°mbrica
(
WiFi
)
,
513‚Äì514
,


520‚Äì523


paquete
(
de
datos
)
,
470
,
472‚Äì474


particiones
de
tiempo
,
433‚Äì438


PPP
,
protocolo
,
470
,
473‚Äì474


rellenado
de
bytes
,
473‚Äì474


Transferencia
de
datos
fiable
(
rdt
)
,
88
,
190
,


203‚Äì228
,
239‚Äì246


aplicaciones
de
la
capa
de
transporte
,


88
,
190
,
203‚Äì228
,
239‚Äì246


ARQ
,
protocolos
,
207‚Äì215


bidireccional
,
205


canal
con
errores
de
bit
(
protocolo


rdt2.0
)
,
206‚Äì211


canal
con
p√©rdidas
y
errores
de
bit
(
pro-


tocolo
rdt3.0
)
,
211‚Äì215


canal
fiable
(
protocolo
rdt1.0
)
,
205‚Äì206


entregar_datos
(
)
,
llamada
,
203‚Äì205


errores
de
bit
y
,
206‚Äì215


m√°quina
de
estados
finitos
(
FSM
)
,


205‚Äì206


modelo
de
servicio
,
203‚Äì205


n√∫meros
de
secuencia
,
209
,
218
,
228


paquetes
de
datos
y
,
211‚Äì215


protocolos
de
parada
y
espera
,
207‚Äì208
,


216‚Äì217


rdt_enviar
(
)
,
llamada
,
203‚Äì205
,
221


rdt_recibir
(
)
,
llamada
,
203‚Äì205


√çNDICE
815


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
815Transferencia
de
datos
fiable
(
rdt
)


(
continuaci√≥n
)


reconocimientos
(
ACK
)
,
206‚Äì211
,
228
,


240‚Äì241


reconocimientos
negativos
(
NAK
)
,


206‚Äì211
,
228


repetici√≥n
selectiva
(
SR
)
,
222‚Äì228
,
246


Retroceder
N
(
GBN
)
,
protocolo
,


218‚Äì222
,
246


servicios
para
la
capa
de
aplicaci√≥n
,


88‚Äì89


suma
de
comprobaci√≥n
(
detecci√≥n
de


errores
)
,
207
,
228


TCP
,
servicios
,
239‚Äì246


unidireccional
,
205


Transferencia
de
datos
fiable
con


procesamiento
en
cadena
,
215‚Äì228


protocolo
de
parada
y
espera
comparado


con
,
216‚Äì217


protocolo
de
ventana
deslizante
,
218


reconocimiento
acumulativo
,
219


repetici√≥n
selectiva
(
SR
)
,
222‚Äì228


Retroceder
N
(
GBN
)
,
protocolo
,


218‚Äì222


sucesos
fin
de
temporizaci√≥n
,
219


utilizaci√≥n
del
emisor
,
217‚Äì228


Transferencia
de
datos
no
fiable
(
udt
)
,


204‚Äì205


Transmisi√≥n
de
almacenamiento
y
reenv√≠o
,


28


Transmisi√≥n
,
retardo
,
36


Transmisi√≥n
,
velocidad
de
,
4


Transporte
,
capa
de
,
49
,
53
,
88‚Äì94
,


185‚Äì280


capa
de
red
y
,
186‚Äì189


control
de
congesti√≥n
,
189
,
256‚Äì277


demultiplexaci√≥n
,
190‚Äì197


Internet
y
,
90‚Äì94
,
189‚Äì190


multiplexaci√≥n
,
190‚Äì197


n√∫meros
de
puerto
,
192‚Äì197


orientado
a
conexi√≥n
,
194‚Äì195
,


228‚Äì256


protocolo
,
49


segmentos
,
50
,
52
,
186
,
190‚Äì193


seguridad
,
90


servicios
,
186‚Äì190


servicios
de
temporizaci√≥n
,
89


servicios
de
transporte
disponibles
para


aplicaciones
,
88‚Äì94
,
189


servidores
web
y
,
196‚Äì197


sin
conexi√≥n
,
193‚Äì194
,
198‚Äì203


tasa
de
transferencia
,
89


TCP
,
servicios
,
49
,
90‚Äì91
,
92
,
189‚Äì190
,


194‚Äì197
,
228‚Äì256
,
265‚Äì277


transferencia
de
datos
fiable
,
88
,
190
,


203‚Äì228
,
239‚Äì246


UDP
,
servicios
,
50
,
91‚Äì92
,
189‚Äì190
,


193‚Äì194
,
198‚Äì203
,
276


Troncalizaci√≥n
VLAN
,
468‚Äì470


U


UDP
(
User
Datagram
Protocol
)
,
50
,


91‚Äì93
,
161‚Äì168
,
189‚Äì190
,
193‚Äì194
,


198‚Äì203
,
276
,
555‚Äì556


aplicaciones
de
la
capa
de
transporte
,


49
,
91‚Äì93
,
189‚Äì190
,
193‚Äì194
,


198‚Äì203
,
277


cliente-servidor
,
aplicaci√≥n
,
161‚Äì168


equidad
en
el
control
de
congesti√≥n
,
276


estructura
del
segmento
,
201


Internet
,
aplicaciones
,
91‚Äì93
,
199‚Äì200


Java
,
aplicaci√≥n
,
163‚Äì167


multiplexaci√≥n
y
demultiplexaci√≥n
,


193‚Äì194


programaci√≥n
de
sockets
,
161‚Äì168


servicios
de
la
capa
de
aplicaci√≥n
,
49
,


91‚Äì93
,
161‚Äì168


suma
de
comprobaci√≥n
,
201‚Äì203
,
231


tecnolog√≠a
inal√°mbrica
y
movilidad
,


impacto
sobre
,
555‚Äì556


transporte
sin
conexi√≥n
,
198‚Äì203


UMTS
(
Universal
Telecommunication


Service
)
,
534


Unidad
m√°xima
de
transmisi√≥n
(
MTU
)
,


230


Unidifusi√≥n
por
N
v√≠as
,
385‚Äì386


Unidireccional
,
transferencia
de
datos
,
205


UPnP
(
Universal
Plug
and
Play
)
,
342


V


Velocidad
de
bit
disponible
.
V√©ase
ABR


Velocidad
de
chip
,
CDMA
,
506‚Äì508


Velocidad
de
l√≠nea
,
routers
,
315‚Äì316


Velocidad
expl√≠cita
(
ER
)
,
campo
,
265


816
√çNDICE


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
816Velocidades
de
datos
mejoradas
para


evoluci√≥n
global
(
EDGE
)
,
534


Ventana
de
recepci√≥n
,
232
,
247


Vigilancia
,
mecanismos
de
,
624‚Äì627


Virus
,
55


VLAN
(
Virtual
Local
Area
Network
)
,


466‚Äì470


VPN
(
Virtual
Private
Network
)
,
697‚Äì705


W


Web
,
correo
electr√≥nico
basado
en
,
125


Web
,
navegadores
,
96


Web
,
p√°ginas
,
95‚Äì96
,
477‚Äì483


acceso
a
flujos
de
audio
/
v√≠deo
a
trav√©s


de
,
578‚Äì579


aplicaciones
de
protocolo
de
red
,


477‚Äì483


direcciones
IP
,
477‚Äì480


enrutamiento
dentro
del
dominio
,
481


HTTP
,
protocolo
,
96


interacci√≥n
cliente-servidor
,
482‚Äì483


metarchivo
,
578‚Äì579


servidores
web
,
96
,
578‚Äì579


solicitudes
,
477‚Äì483


WEP
(
Wired
Equivalent
Privacy
)
,
706‚Äì708


802.11
,
protocolo
MAC
,
514‚Äì520


802.11
,
trama
,
520‚Äì523


802.11i
,
mecanismos
de
seguridad
,


708‚Äì721


WFQ
,
colas
equitativas
ponderadas
,


623‚Äì624
,
626


WiFi
,
18
,
508‚Äì526
,
705‚Äì710


adaptaci√≥n
de
la
velocidad
,
524‚Äì525


arquitectura
802.11
,
510‚Äì514


canales
,
512‚Äì514


conjunto
de
servicio
b√°sico
(
BSS
)
,
510


CSMA
con
evitaci√≥n
de
colisiones


(
CSMA
/
CA
)
,
514‚Äì520


enlace
punto
a
punto
,
520


est√°ndares
802.11
,
508‚Äì510


exploraci√≥n
activa
y
pasiva
,
513‚Äì514


gesti√≥n
de
la
potencia
,
525‚Äì526


jungla
,
512


movilidad
,
523‚Äì524


Preparado
para
enviar
(
CTS
)
,
518‚Äì519


problemas
de
los
terminales
ocultos
,


517‚Äì519


punto
de
acceso
(
AP
)
,
511


reconocimiento
de
la
capa
de
enlace
,


515‚Äì517


seguridad
,
705‚Äì710


solicitud
de
transmisi√≥n
(
RTS
)
,
518‚Äì519


subredes
,
523‚Äì524


tramas
,
512‚Äì514
,
520‚Äì523


WEP
,
706‚Äì708


WiMax
(
IEEE
802.16
)
,
20
,
527‚Äì529


World
Wide
Web
,
63‚Äì64
,
95‚Äì112


cach√©
web
(
servidor
proxy
)
,
107‚Äì111


cookies
,
105‚Äì107


desarrollo
de
la
,
63‚Äì64


GET
condicional
,
mecanismo
,
111‚Äì112


HTTP
,
protocolo
,
95‚Äì107


Z


Zona
desmilitarizada
(
DMZ
)
,
719


√çNDICE
817


Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
817Z02_KURO9675_05_SE_IDX.qxd
 
22/3/10
 
10:39
 
P√°gina
818jjj!cXTefbaXWhVTV\ba!Vb
`


(
¬£
XW
!


ATSTbSTR^\_dcPS^aPb


Kurose


Ross


Redes
de
computadoras
 
es
el
principal
libro
de
texto
en
el


aprendizaje
de
los
aspectos
b√°sicos
de
redes
.
Los
profesores


Jim
Kurose
y
Keith
Ross
hacen
una
presentaci√≥n
muy
atrac-


tiva
de
todos
los
temas
,
utilizando
un
enfoque
desde
arriba


hacia
abajo
en
el
tratamiento
de
redes
e
Internet
.

 
Esta
edici√≥n
conserva
el
√©nfasis
original
sobre
los
para
-


digmas
de
capa
de
aplicaci√≥n
,
la
programaci√≥n
de
aplicacio
-


nes
y
los
protocolos
de
capa
superior
,
fomentando
la
trans
-


misi√≥n
de
la
experiencia
con
conceptos
sobre
protocolos
y


redes
.

 
Este
libro
incluye
una
suscripci√≥n
de
seis
meses
al
si
-


tio
web
que
complementa
al
libro
.
Esta
suscripci√≥n
gratuita
 

proporciona
complementos
de
apoyo
al
estudiante
,
inclu
-


yendo
:


U√ä
"
¬òVi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬è>L¬ú√Ä
>
√å¬ú√Ä¬à¬ú√äV¬ú¬ò√ä7¬à√Äi√É
¬Ö
>
√Ä¬é
¬∞


U√ä
 
√ïi√õi√ä¬´√Ä?V√å¬àV
>
√É√ä`i√ä¬´√Ä¬ú}√Ä>¬ì>V¬à¬ù¬ò
¬∞


U√ä
¬´¬´¬èi√å√É√äi¬ò√ä>√õ
>
√ä¬µ√ïi√ä¬à¬è√ï√É√å√Ä>¬ò√ä`¬à√õi√Ä√É¬ú√É√äV¬ú¬òVi¬´√å¬ú√É√äV¬è>√õi√ä√ä

 
de
las
redes
.


U√ä


√ïi√É√å¬à¬ú¬ò>√Ä¬à¬ú√É√ä¬à¬ò√åi√Ä
>
V√å¬à√õ¬ú√É√ä¬µ√ïi√ä¬èi√ä
>
√û√ï`>√Ä?¬ò√ä
>
√äi√õ>¬è√ï
>
√Ä√ä√ä

 
su
grado
de
comprensi√≥n
de
los
temas
estudiados
.


U√ä
¬ò√åi√Äi√É>¬ò√åi√É√äi¬ò¬è>Vi√É√ä
>
√ä¬ú√å√Ä¬ú√É√ä√ÄiV√ï√Ä√É¬ú√É
¬∞


James
F
.
Kurose


i¬à√å
¬Ö
√ä7
¬∞
√ä,¬ú√É√É


ATSTbSTR^\_dcPS^aPb


D]T]U^`dTSTbRT]ST]cT


(
¬£
XW\V\¬âa


>
ca^b[XQa^bSTX]cTa{b
)


Fred
Halsall


Redes
de
computadores
e
Internet


*

,-
"
√ä

-
"
√ä7

-

9


-
	 
√ä¬ô√án¬án{¬á√án√ì¬ô¬á√§n√é¬á√é

 
¬àV¬ú¬è?√É√ä
	
>
√ÄV¬à>√ä6?√¢¬µ√ïi√¢


Redes
de
computadores
y
arquitecturas


de
comunicaciones
.
Supuestos
pr√°cticos


*

,-
"
√ä
*
,
 
/


√ä


-
	 
√ä¬ô√án¬án{¬á√ì√§x¬á{√à√§√á¬á√§


redes.indd
  
1
26/3/10
  
08:21:18
