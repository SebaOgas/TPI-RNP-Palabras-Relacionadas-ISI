href="https://colab.research.google.com
github
institutohumai
cursos-python
blob
master
CV/6_Segmentacion
Segmentacion.ipynb
img
src='https://colab.research.google.com
assets
colab-badge.svg
/a
Segmentación
Semántica
hablamos
detección
objetos
clase
vimos
usaban
bounding
boxes
rectangulares
etiquetar
predecir
objetos
imágenes
hablaremos
segmentación
semántica
enfoca
dividir
imagen
regiones
pertenecen
clases
semánticas
diferencia
detección
objetos
segmentación
semántica
reconoce
comprende
imágenes
nivel
píxel
etiquetado
predicción
regiones
semánticas
nivel
píxel
figura
muestra
etiquetas
perro
gato
fondo
imagen
segmentación
semántica
comparación
detección
objetos
bordes
nivel
píxel
etiquetados
segmentación
semántica
obviamente
detallados
Segmentación
imágenes
segmentación
instancias
tareas
importantes
campo
visión
artificial
similares
segmentación
semántica
segmentación
imágenes
segmentación
instancias
distinguiremos
brevemente
segmentación
semántica
segmentación
imágenes
divide
imagen
regiones
constituyentes
métodos
tipo
problemas
suelen
correlación
píxeles
imagen
necesita
información
etiqueta
píxeles
imagen
entrenamiento
garantizar
regiones
segmentadas
tengan
semántica
esperamos
obtener
predicción
segmentación
instancias
denomina
detección
segmentación
simultáneas
Estudia
reconocer
regiones
nivel
píxeles
instancia
objeto
imagen
diferencia
segmentación
semántica
segmentación
instancias
necesita
distinguir
semántica
instancias
objetos
ejemplo
perros
imagen
segmentación
instancias
distinguir
perros
pertenece
píxel
Dataset
segmentación
semántica
Pascal
VOC2012
conjuntos
datos
segmentación
semántica
importantes
Pascal
VOC2012
continuación
echar
vistazo
conjunto
datos
The
tar
file
of
the
dataset
is
about
GB
so
it
may
take
while
to
download
the
file
The
extracted
dataset
is
located
at
/data
VOCdevkit
VOC2012
ingresar
carpeta
data
VOCdevkit
VOC2012
componentes
conjunto
datos
carpeta
ImageSets
Segmentation
contiene
archivos
texto
especifican
ejemplos
entrenamiento
prueba
carpetas
JPEGImages
SegmentationClass
almacenan
imagen
entrada
etiqueta
ejemplo
respectivamente
etiqueta
formato
imagen
tamaño
imagen
entrada
etiquetada
píxeles
color
imagen
etiqueta
pertenecen
clase
semántica
define
función
readvocimages
leer
imágenes
etiquetas
entrada
memoria
Dibujamos
primeras
imágenes
entrada
etiquetas
imágenes
etiquetas
blanco
negro
representan
bordes
fondo
respectivamente
colores
corresponden
clases
Next
we
enumerate
the
RGB
color
values
and
class
names
for
all
the
labels
in
this
dataset
constantes
definidas
anteriormente
encontrar
convenientemente
índice
clase
píxel
etiqueta
Definimos
función
voccolormap2label
crear
asignación
valores
color
RGB
anteriores
índices
clase
función
voclabel_indices
asignar
valor
RGB
índices
clase
conjunto
datos
Pascal
VOC2012
ejemplo
imagen
ejemplo
índice
clase
delantera
avión
índice
fondo
Preprocesamiento
datos
experimentos
anteriores
reescalar
imágenes
ajustarnos
forma
entrada
requerida
modelo
segmentación
semántica
requiere
volver
escalar
clases
píxeles
previstas
forma
original
imagen
entrada
cambio
escala
inexacto
especialmente
regiones
segmentadas
clases
evitar
problema
recortamos
imagen
forma
fija
lugar
cambiar
escala
Específicamente
usando
RandomCrop
vimos
hicimos
image
augmentation
recortamos
área
imagen
entrada
etiqueta
Dataset
Personalizado
Segmentación
Semántica
Definimos
clase
conjunto
datos
segmentación
semántica
personalizada
VOCSegDataset
heredando
clase
Dataset
proporcionada
API
alto
nivel
implementar
función
getitem
acceder
arbitrariamente
imagen
entrada
indexada
idx
conjunto
datos
índice
clase
píxel
imagen
imágenes
conjunto
datos
tamaño
pequeño
tamaño
salida
recorte
aleatorio
ejemplos
filtran
función
filtro
personalizada
definimos
función
normalize_image
estandarizar
valores
canales
RGB
imágenes
entrada
Lectura
Dataset
clase
VOCSegDataset
personalizada
crear
instancias
conjunto
entrenamiento
conjunto
prueba
respectivamente
Supongamos
especificamos
forma
salida
imágenes
recortadas
aleatoriamente
continuación
cantidad
ejemplos
retienen
conjunto
entrenamiento
conjunto
prueba
establecer
tamaño
lote
64
definimos
iterador
datos
conjunto
entrenamiento
Imprimamos
forma
minilote
diferencia
clasificación
imágenes
detección
objetos
etiquetas
tensores
tridimensionales
Convolución
transpuesta
capas
CNN
visto
capas
convolucionales
capas
pooling
normalmente
reducen
reducen
dimensiones
espaciales
alto
ancho
entrada
mantienen
cambios
segmentación
semántica
clasifica
nivel
píxel
conveniente
dimensiones
espaciales
entrada
salida
ejemplo
dimensión
canal
píxel
salida
contener
resultados
clasificación
píxel
entrada
posición
espacial
lograr
especialmente
capas
CNN
reducen
dimensiones
espaciales
debemos
tipo
capas
CNN
capaces
aumentar
dimensiones
espaciales
mapas
características
intermedias
upsampling
sección
presentaremos
convolución
transpuesta
invertir
operaciones
downsampling
convolución
Operación
básica
Ignorando
canales
comencemos
operación
básica
convolución
transpuesta
stride
padding
Supongamos
tensor
entrada
kernel
Deslizar
ventana
kernel
stride
fila
columna
produce
resultados
intermedios
resultado
intermedio
tensor
inicializan
ceros
calcular
tensor
intermedio
elemento
tensor
entrada
multiplica
kernel
tensor
resultante
reemplace
porción
tensor
intermedio
posición
porción
reemplazada
tensor
intermedio
corresponde
posición
elemento
tensor
entrada
utilizado
cálculo
resultados
intermedios
suman
producir
salida
implementar
operación
básica
convolución
transpuesta
trans_conv
matriz
entrada
matriz
kernel
K.
diferencia
convolución
normal
reduce
elementos
entrada
kernel
convolución
transpuesta
propaga
elementos
entrada
kernel
produciendo
salida
entrada
construir
tensor
entrada
tensor
kernel
figura
validar
salida
implementación
operación
convolución
transpuesta
bidimensional
básica
Alternatively
when
the
input
and
kernel
are
both
four-dimensional
tensors
we
can
use
high-level
APIs
to
obtain
the
same
results
Padding
Strides
Multiples
Canales
diferencia
convolución
regular
aplica
padding
entrada
convolución
transpuesta
aplica
salida
ejemplo
especificar
padding
lados
altura
ancho
fila
columna
eliminarán
salida
convolución
transpuesta
parecer
contraintuitivo
padding
relleno
inglés
eliminaría
dimensiones
agregarlas
respuesta
viene
convoluciones
transpuestas
PyTorch
resto
frameworks
Deep
Learning
única
razón
usarías
convoluciones
transpuestas
anular
reducción
dimensionalidad
introducida
convoluciones
regulares
previas
red
padding
convoluciones
transpuestas
diseñado
contrario
padding
convoluciones
regulares
contrarrestar
efectos
convolución
regular
padding
simplemente
debemos
agregar
convolución
transpuesta
padding
Siguiendo
lógica
stride
convolución
transpuesta
especifica
saltearno
píxeles
resultados
intermedios
entrada
Usando
tensores
entrada
kernel
figura
cambiar
stride
aumenta
altura
ancho
tensores
intermedios
tensor
salida
figura
fragmento
código
validar
salida
convolución
transpuesta
stride
múltiples
canales
entrada
salida
convolución
transpuesta
funciona
convolución
normal
Suponga
entrada
canales
convolución
transpuesta
asigna
kernel
canal
entrada
especifican
múltiples
canales
salida
tendremos
kernel
canal
salida
alimentamos
capa
convolucional
generar
creamos
capa
convolucional
transpuesta
hiperparámetros
número
canales
salida
número
canales
forma
ilustrar
ejemplo
Conexión
Matrices
Transpuestas
convolución
transpuesta
nombre
matriz
transpuesta
explicar
veamos
implementar
convoluciones
usando
multiplicaciones
matrices
ejemplo
definimos
entrada
kernel
convolución
función
corr2d
calcular
salida
convolución
Y.
continuación
reescribimos
kernel
convolución
matriz
pesos
rala
contiene
ceros
forma
matriz
peso
elementos
distintos
cero
provienen
kernel
convolución
K.
concatenamos
entrada
fila
fila
obtener
vector
longitud
16
multiplicación
matriz
vectorizada
vector
longitud
remodelarlo
obtener
resultado
operación
convolución
original
acabamos
implementar
convoluciones
usando
multiplicaciones
matrices
implementar
convoluciones
transpuestas
usando
multiplicaciones
matrices
ejemplo
tomamos
salida
convolución
regular
entrada
convolución
transpuesta
implementar
operación
multiplicando
matrices
necesitamos
transponer
matriz
pesos
forma
Convolución
Transpuesta
vs
Deconvolución
capa
convolucional
transpuesta
conoce
erróneamente
capa
deconvolucional
capa
deconvolucional
invierte
funcionamiento
capa
convolucional
estándar
salida
generada
capa
convolucional
estándar
deconvoluciona
recupera
entrada
original
capa
convolucional
transpuesta
similar
capa
deconvolucional
sentido
dimensión
espacial
generada
ambas
convolución
transpuesta
invierte
convolución
estándar
valores
dimensiones
Fully
Convolutional
Networks
discutió
anteriormente
segmentación
semántica
clasifica
imágenes
nivel
píxeles
red
totalmente
convolucional
Fully
Convolutional
Network
FCN
utiliza
red
neuronal
convolucional
transformar
píxeles
imagen
clases
píxeles
diferencia
CNN
anteriormente
clasificación
imágenes
detección
objetos
red
totalmente
convolucional
transforma
altura
ancho
mapas
activación
intermedios
vuelta
imagen
entrada
logra
capa
convolucional
transpuesta
presentada
sección
resultado
salida
clasificación
imagen
entrada
correspondencia
nivel
píxel
dimensión
canal
píxel
salida
contiene
resultados
clasificación
píxel
entrada
posición
espacial
Modelo
describimos
diseño
básico
modelo
red
totalmente
convolucional
muestra
figura
modelo
CNN
extraer
características
imagen
transforma
número
canales
número
clases
capa
convolucional
finalmente
transforma
altura
ancho
mapas
características
imagen
entrada
convolución
transpuesta
resultado
salida
modelo
altura
anchura
imagen
entrada
canal
salida
contiene
clases
predichas
píxel
entrada
posición
espacial
continuación
modelo
ResNet-18
preentrenado
conjunto
datos
ImageNet
extraer
características
imagen
denotar
instancia
modelo
pretrained_net
capas
modelo
incluyen
capa
average
pooling
global
capa
densas
necesarias
red
totalmente
convolucional
continuación
creamos
instancia
red
totalmente
convolucional
net
Copia
capas
previamente
entrenadas
ResNet-18
capa
averge
pooling
global
capa
densa
cerca
salida
Dada
entrada
altura
ancho
320
480
respectivamente
propagación
directa
net
reduce
altura
ancho
entrada
1/32
original
10
15
continuación
capa
convolucional
transformar
cantidad
canales
salida
cantidad
clases
21
conjunto
datos
Pascal
VOC2012
Finalmente
necesitamos
aumentar
altura
ancho
mapas
características
32
volver
cambiarlos
altura
ancho
imagen
entrada
Recuerde
calcular
forma
salida
capa
convolucional
cambiáramos
capas
convolucionales
podríamos
capa
tendría
kernel
stride
padding
general
stride
padding
asumiendo
número
entero
altura
ancho
kernel
convolución
transpuesta
aumentará
altura
ancho
entrada
Inicializar
capas
convolucionales
transpuestas
capas
convolucionales
transpuestas
aumentar
altura
ancho
mapas
características
procesamiento
imágenes
necesitemos
escalar
imagen
upsampling
interpolación
bilineal
técnicas
upsampling
utilizadas
inicializar
capas
convolucionales
transpuestas
explicar
interpolación
bilineal
digamos
dada
imagen
entrada
calcular
píxel
imagen
salida
muestreada
calcular
píxel
imagen
salida
coordenada
asigne
coordenada
imagen
entrada
ejemplo
relación
tamaño
entrada
tamaño
salida
mapeados
números
reales
busque
píxeles
cercanos
coordenada
imagen
entrada
Finalmente
píxel
imagen
salida
coordenada
calcula
base
píxeles
cercanos
imagen
entrada
distancia
relativa
upsampling
interpolación
bilineal
implementar
capa
convolucional
transpuesta
kernel
construido
función
bilinearkernel
limitaciones
espacio
proporcionamos
implementación
función
bilinearkernel
continuación
discusiones
diseño
algoritmo
Experimentemos
upsampling
interpolación
bilineal
implementa
capa
convolucional
transpuesta
Construimos
capa
convolucional
transpuesta
duplica
altura
ancho
inicializamos
kernel
función
bilinear_kernel
Leemos
imagen
asignamos
salida
upsampling
Y.
imprimir
imagen
necesitamos
ajustar
posición
dimensión
canal
capa
convolucional
transpuesta
aumenta
alto
ancho
imagen
factor
escalas
coordenadas
imagen
ampliada
interpolación
bilineal
imagen
original
aspecto
red
totalmente
convolucional
inicializamos
capa
convolucional
transpuesta
upsampling
interpolación
bilineal
capa
convolucional
inicialización
Xavier
Entrenamiento
entrenar
red
totalmente
convolucional
función
pérdida
cálculo
accuracy
esencialmente
clasificación
imágenes
capítulos
anteriores
canales
salida
capa
convolucional
transpuesta
predecir
clase
píxel
dimensión
canal
especifica
cálculo
función
pérdida
precisión
calcula
función
corrección
clase
predicha
píxeles
Predicción
predecir
necesitamos
estandarizar
imagen
entrada
canal
transformar
imagen
formato
entrada
dimensiones
requerido
CNN
visualizar
clase
prevista
píxel
mapeamos
clase
prevista
color
etiqueta
conjunto
datos
imágenes
conjunto
datos
prueba
varían
tamaño
forma
modelo
utiliza
capa
convolucional
transpuesta
paso
32
altura
ancho
imagen
entrada
indivisible
32
altura
ancho
salida
capa
convolucional
transpuesta
desviará
forma
imagen
entrada
solucionar
problema
recortar
áreas
rectangulares
altura
ancho
múltiplos
enteros
32
imagen
propagación
píxeles
áreas
separado
unión
áreas
rectangulares
cubrir
completamente
imagen
entrada
píxel
cubierto
múltiples
áreas
rectangulares
promedio
salidas
convolución
transpuestas
áreas
separadas
píxel
ingresar
operación
softmax
predecir
clase
simplificar
leemos
imágenes
prueba
recortamos
área
predicción
esquina
superior
izquierda
imagen
imágenes
prueba
imprimimos
áreas
recortadas
resultados
predicción
terreno
fila
fila
